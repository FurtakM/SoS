// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7446 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4567 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4866 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 2992 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2619 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 2992 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2619 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 2992 0 4
// MC_Registry ( ) ;
 213: CALL 41864 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42315 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 32
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21177 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21113 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18106 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21013 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22027 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21254 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21047 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21080 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17885 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21935 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20192 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20767 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20767 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20564 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20228 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20404 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19688 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20302 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20803 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21543 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21113 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18106 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21013 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21254 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21047 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21080 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17885 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21935 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20192 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20767 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20767 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20564 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20228 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20404 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19688 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20302 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20803 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21543 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 10
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 11
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 12
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 13
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 14
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// end ;
1621: LD_VAR 0 1
1625: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1626: LD_INT 8
1628: PPUSH
1629: CALL_OW 353
1633: PUSH
1634: LD_INT 0
1636: EQUAL
1637: IFFALSE 1672
1639: GO 1641
1641: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1642: LD_INT 1
1644: PPUSH
1645: LD_INT 32
1647: PPUSH
1648: LD_INT 50
1650: PUSH
1651: LD_INT 10
1653: PUSH
1654: LD_INT 4
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: LIST
1661: PPUSH
1662: LD_INT 7
1664: PUSH
1665: EMPTY
1666: LIST
1667: PPUSH
1668: CALL 19688 0 4
// end ;
1672: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1673: LD_INT 1
1675: PPUSH
1676: LD_INT 30
1678: PUSH
1679: LD_INT 3
1681: PUSH
1682: EMPTY
1683: LIST
1684: LIST
1685: PPUSH
1686: CALL 11393 0 2
1690: IFFALSE 1784
1692: GO 1694
1694: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1695: LD_INT 1
1697: PPUSH
1698: LD_INT 3
1700: PUSH
1701: LD_INT 1
1703: PUSH
1704: LD_INT 2
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 3
1712: PUSH
1713: LD_INT 1
1715: PUSH
1716: LD_INT 2
1718: PUSH
1719: LD_INT 5
1721: PUSH
1722: LD_INT 3
1724: PUSH
1725: LD_INT 1
1727: PUSH
1728: LD_INT 2
1730: PUSH
1731: LD_INT 5
1733: PUSH
1734: LD_INT 3
1736: PUSH
1737: LD_INT 1
1739: PUSH
1740: LD_INT 2
1742: PUSH
1743: LD_INT 7
1745: PUSH
1746: LD_INT 3
1748: PUSH
1749: LD_INT 1
1751: PUSH
1752: LD_INT 2
1754: PUSH
1755: LD_INT 7
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: LIST
1767: LIST
1768: LIST
1769: LIST
1770: LIST
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: PPUSH
1780: CALL 21761 0 2
// end ;
1784: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1785: LD_INT 4
1787: PPUSH
1788: LD_INT 30
1790: PUSH
1791: LD_INT 3
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PPUSH
1798: CALL 11393 0 2
1802: IFFALSE 1896
1804: GO 1806
1806: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1807: LD_INT 4
1809: PPUSH
1810: LD_INT 3
1812: PUSH
1813: LD_INT 1
1815: PUSH
1816: LD_INT 2
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 3
1824: PUSH
1825: LD_INT 1
1827: PUSH
1828: LD_INT 2
1830: PUSH
1831: LD_INT 5
1833: PUSH
1834: LD_INT 3
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 2
1842: PUSH
1843: LD_INT 5
1845: PUSH
1846: LD_INT 4
1848: PUSH
1849: LD_INT 1
1851: PUSH
1852: LD_INT 2
1854: PUSH
1855: LD_INT 6
1857: PUSH
1858: LD_INT 4
1860: PUSH
1861: LD_INT 1
1863: PUSH
1864: LD_INT 2
1866: PUSH
1867: LD_INT 6
1869: PUSH
1870: EMPTY
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PPUSH
1892: CALL 21761 0 2
// end ;
1896: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1897: LD_INT 1
1899: PPUSH
1900: LD_INT 30
1902: PUSH
1903: LD_INT 3
1905: PUSH
1906: EMPTY
1907: LIST
1908: LIST
1909: PPUSH
1910: CALL 11393 0 2
1914: PUSH
1915: LD_EXP 69
1919: PUSH
1920: LD_INT 1
1922: ARRAY
1923: PUSH
1924: LD_INT 1
1926: ARRAY
1927: PUSH
1928: LD_INT 0
1930: EQUAL
1931: AND
1932: IFFALSE 2043
1934: GO 1936
1936: DISABLE
// begin enable ;
1937: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1938: LD_INT 1
1940: PPUSH
1941: LD_INT 3
1943: PUSH
1944: LD_INT 1
1946: PUSH
1947: LD_INT 2
1949: PUSH
1950: LD_INT 4
1952: PUSH
1953: LD_INT 3
1955: PUSH
1956: LD_INT 1
1958: PUSH
1959: LD_INT 2
1961: PUSH
1962: LD_INT 5
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 2
1973: PUSH
1974: LD_INT 5
1976: PUSH
1977: LD_INT 3
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 7
1988: PUSH
1989: LD_INT 3
1991: PUSH
1992: LD_INT 1
1994: PUSH
1995: LD_INT 2
1997: PUSH
1998: LD_INT 7
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 2
2009: PUSH
2010: LD_INT 7
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: LIST
2021: LIST
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: LIST
2028: LIST
2029: LIST
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PPUSH
2039: CALL 21761 0 2
// end ;
2043: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2044: LD_INT 4
2046: PPUSH
2047: LD_INT 30
2049: PUSH
2050: LD_INT 3
2052: PUSH
2053: EMPTY
2054: LIST
2055: LIST
2056: PPUSH
2057: CALL 11393 0 2
2061: PUSH
2062: LD_EXP 69
2066: PUSH
2067: LD_INT 4
2069: ARRAY
2070: PUSH
2071: LD_INT 1
2073: ARRAY
2074: PUSH
2075: LD_INT 0
2077: EQUAL
2078: AND
2079: IFFALSE 2190
2081: GO 2083
2083: DISABLE
// begin enable ;
2084: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2085: LD_INT 4
2087: PPUSH
2088: LD_INT 3
2090: PUSH
2091: LD_INT 1
2093: PUSH
2094: LD_INT 2
2096: PUSH
2097: LD_INT 4
2099: PUSH
2100: LD_INT 3
2102: PUSH
2103: LD_INT 1
2105: PUSH
2106: LD_INT 2
2108: PUSH
2109: LD_INT 5
2111: PUSH
2112: LD_INT 3
2114: PUSH
2115: LD_INT 1
2117: PUSH
2118: LD_INT 2
2120: PUSH
2121: LD_INT 5
2123: PUSH
2124: LD_INT 4
2126: PUSH
2127: LD_INT 1
2129: PUSH
2130: LD_INT 2
2132: PUSH
2133: LD_INT 6
2135: PUSH
2136: LD_INT 4
2138: PUSH
2139: LD_INT 1
2141: PUSH
2142: LD_INT 2
2144: PUSH
2145: LD_INT 6
2147: PUSH
2148: LD_INT 3
2150: PUSH
2151: LD_INT 1
2153: PUSH
2154: LD_INT 2
2156: PUSH
2157: LD_INT 5
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: PPUSH
2186: CALL 21761 0 2
// end ;
2190: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2191: LD_EXP 11
2195: PUSH
2196: LD_INT 22
2198: PUSH
2199: LD_INT 6
2201: PUSH
2202: EMPTY
2203: LIST
2204: LIST
2205: PUSH
2206: LD_INT 21
2208: PUSH
2209: LD_INT 2
2211: PUSH
2212: EMPTY
2213: LIST
2214: LIST
2215: PUSH
2216: LD_INT 3
2218: PUSH
2219: LD_INT 34
2221: PUSH
2222: LD_INT 51
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: LIST
2237: PPUSH
2238: CALL_OW 69
2242: AND
2243: IFFALSE 2372
2245: GO 2247
2247: DISABLE
2248: LD_INT 0
2250: PPUSH
// begin enable ;
2251: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2252: LD_ADDR_VAR 0 1
2256: PUSH
2257: LD_INT 22
2259: PUSH
2260: LD_INT 6
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 21
2269: PUSH
2270: LD_INT 2
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 3
2279: PUSH
2280: LD_INT 34
2282: PUSH
2283: LD_INT 51
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: LIST
2298: PPUSH
2299: CALL_OW 69
2303: PUSH
2304: FOR_IN
2305: IFFALSE 2370
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2307: LD_VAR 0 1
2311: PPUSH
2312: CALL_OW 314
2316: NOT
2317: PUSH
2318: LD_VAR 0 1
2322: PPUSH
2323: CALL_OW 256
2327: PUSH
2328: LD_INT 250
2330: GREATER
2331: AND
2332: IFFALSE 2368
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2334: LD_VAR 0 1
2338: PPUSH
2339: LD_INT 81
2341: PUSH
2342: LD_INT 6
2344: PUSH
2345: EMPTY
2346: LIST
2347: LIST
2348: PPUSH
2349: CALL_OW 69
2353: PPUSH
2354: LD_VAR 0 1
2358: PPUSH
2359: CALL_OW 74
2363: PPUSH
2364: CALL_OW 115
2368: GO 2304
2370: POP
2371: POP
// end ;
2372: PPOPN 1
2374: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2375: LD_EXP 11
2379: PUSH
2380: LD_INT 22
2382: PUSH
2383: LD_INT 6
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 21
2392: PUSH
2393: LD_INT 2
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 34
2405: PUSH
2406: LD_INT 51
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: PUSH
2413: EMPTY
2414: LIST
2415: LIST
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: LIST
2421: PPUSH
2422: CALL_OW 69
2426: PUSH
2427: LD_INT 0
2429: EQUAL
2430: AND
2431: IFFALSE 2445
2433: GO 2435
2435: DISABLE
// begin enable ;
2436: ENABLE
// pink_attack := false ;
2437: LD_ADDR_EXP 11
2441: PUSH
2442: LD_INT 0
2444: ST_TO_ADDR
// end ;
2445: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2446: LD_EXP 12
2450: PUSH
2451: LD_INT 22
2453: PUSH
2454: LD_INT 8
2456: PUSH
2457: EMPTY
2458: LIST
2459: LIST
2460: PPUSH
2461: CALL_OW 69
2465: AND
2466: IFFALSE 2577
2468: GO 2470
2470: DISABLE
2471: LD_INT 0
2473: PPUSH
// begin enable ;
2474: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2475: LD_ADDR_VAR 0 1
2479: PUSH
2480: LD_INT 22
2482: PUSH
2483: LD_INT 8
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 21
2492: PUSH
2493: LD_INT 2
2495: PUSH
2496: EMPTY
2497: LIST
2498: LIST
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 69
2508: PUSH
2509: FOR_IN
2510: IFFALSE 2575
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2512: LD_VAR 0 1
2516: PPUSH
2517: CALL_OW 314
2521: NOT
2522: PUSH
2523: LD_VAR 0 1
2527: PPUSH
2528: CALL_OW 256
2532: PUSH
2533: LD_INT 250
2535: GREATER
2536: AND
2537: IFFALSE 2573
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2539: LD_VAR 0 1
2543: PPUSH
2544: LD_INT 81
2546: PUSH
2547: LD_INT 8
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PPUSH
2554: CALL_OW 69
2558: PPUSH
2559: LD_VAR 0 1
2563: PPUSH
2564: CALL_OW 74
2568: PPUSH
2569: CALL_OW 115
2573: GO 2509
2575: POP
2576: POP
// end ;
2577: PPOPN 1
2579: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2580: LD_EXP 12
2584: PUSH
2585: LD_INT 22
2587: PUSH
2588: LD_INT 8
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PPUSH
2595: CALL_OW 69
2599: PUSH
2600: LD_INT 0
2602: EQUAL
2603: AND
2604: IFFALSE 2618
2606: GO 2608
2608: DISABLE
// begin enable ;
2609: ENABLE
// alfa_support := false ;
2610: LD_ADDR_EXP 12
2614: PUSH
2615: LD_INT 0
2617: ST_TO_ADDR
// end ; end_of_file
2618: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2619: LD_INT 0
2621: PPUSH
2622: PPUSH
2623: PPUSH
2624: PPUSH
// uc_side := side ;
2625: LD_ADDR_OWVAR 20
2629: PUSH
2630: LD_VAR 0 1
2634: ST_TO_ADDR
// uc_nation := nat ;
2635: LD_ADDR_OWVAR 21
2639: PUSH
2640: LD_VAR 0 2
2644: ST_TO_ADDR
// team := [ ] ;
2645: LD_ADDR_VAR 0 10
2649: PUSH
2650: EMPTY
2651: ST_TO_ADDR
// hc_importance := 100 ;
2652: LD_ADDR_OWVAR 32
2656: PUSH
2657: LD_INT 100
2659: ST_TO_ADDR
// case commander of jakes :
2660: LD_VAR 0 4
2664: PUSH
2665: LD_STRING jakes
2667: DOUBLE
2668: EQUAL
2669: IFTRUE 2673
2671: GO 2750
2673: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2674: LD_INT 1
2676: PPUSH
2677: LD_INT 1
2679: PPUSH
2680: LD_VAR 0 5
2684: PPUSH
2685: CALL_OW 380
// hc_gallery := pkremaster ;
2689: LD_ADDR_OWVAR 33
2693: PUSH
2694: LD_STRING pkremaster
2696: ST_TO_ADDR
// hc_face_number := 12 ;
2697: LD_ADDR_OWVAR 34
2701: PUSH
2702: LD_INT 12
2704: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2705: LD_ADDR_OWVAR 26
2709: PUSH
2710: LD_STRING Jan van Jakes
2712: ST_TO_ADDR
// houten := CreateHuman ;
2713: LD_ADDR_EXP 3
2717: PUSH
2718: CALL_OW 44
2722: ST_TO_ADDR
// LogHuman ( houten ) ;
2723: LD_EXP 3
2727: PPUSH
2728: CALL 7665 0 1
// team := team ^ houten ;
2732: LD_ADDR_VAR 0 10
2736: PUSH
2737: LD_VAR 0 10
2741: PUSH
2742: LD_EXP 3
2746: ADD
2747: ST_TO_ADDR
// end ; sylvia :
2748: GO 2836
2750: LD_STRING sylvia
2752: DOUBLE
2753: EQUAL
2754: IFTRUE 2758
2756: GO 2835
2758: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2759: LD_INT 2
2761: PPUSH
2762: LD_INT 1
2764: PPUSH
2765: LD_VAR 0 5
2769: PPUSH
2770: CALL_OW 380
// hc_gallery := pkremaster ;
2774: LD_ADDR_OWVAR 33
2778: PUSH
2779: LD_STRING pkremaster
2781: ST_TO_ADDR
// hc_face_number := 13 ;
2782: LD_ADDR_OWVAR 34
2786: PUSH
2787: LD_INT 13
2789: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2790: LD_ADDR_OWVAR 26
2794: PUSH
2795: LD_STRING Sylvia Johnson
2797: ST_TO_ADDR
// brown := CreateHuman ;
2798: LD_ADDR_EXP 4
2802: PUSH
2803: CALL_OW 44
2807: ST_TO_ADDR
// LogHuman ( brown ) ;
2808: LD_EXP 4
2812: PPUSH
2813: CALL 7665 0 1
// team := team ^ brown ;
2817: LD_ADDR_VAR 0 10
2821: PUSH
2822: LD_VAR 0 10
2826: PUSH
2827: LD_EXP 4
2831: ADD
2832: ST_TO_ADDR
// end ; end ;
2833: GO 2836
2835: POP
// hc_gallery :=  ;
2836: LD_ADDR_OWVAR 33
2840: PUSH
2841: LD_STRING 
2843: ST_TO_ADDR
// hc_name :=  ;
2844: LD_ADDR_OWVAR 26
2848: PUSH
2849: LD_STRING 
2851: ST_TO_ADDR
// hc_importance := 0 ;
2852: LD_ADDR_OWVAR 32
2856: PUSH
2857: LD_INT 0
2859: ST_TO_ADDR
// for i = 1 to num do
2860: LD_ADDR_VAR 0 8
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_VAR 0 6
2874: PUSH
2875: FOR_TO
2876: IFFALSE 2940
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2878: LD_INT 0
2880: PPUSH
2881: LD_VAR 0 8
2885: PUSH
2886: LD_INT 4
2888: MOD
2889: PUSH
2890: LD_INT 1
2892: PLUS
2893: PPUSH
2894: LD_VAR 0 5
2898: PPUSH
2899: CALL_OW 380
// un := CreateHuman ;
2903: LD_ADDR_VAR 0 9
2907: PUSH
2908: CALL_OW 44
2912: ST_TO_ADDR
// LogHuman ( un ) ;
2913: LD_VAR 0 9
2917: PPUSH
2918: CALL 7665 0 1
// team := team ^ un ;
2922: LD_ADDR_VAR 0 10
2926: PUSH
2927: LD_VAR 0 10
2931: PUSH
2932: LD_VAR 0 9
2936: ADD
2937: ST_TO_ADDR
// end ;
2938: GO 2875
2940: POP
2941: POP
// for i = 1 to team do
2942: LD_ADDR_VAR 0 8
2946: PUSH
2947: DOUBLE
2948: LD_INT 1
2950: DEC
2951: ST_TO_ADDR
2952: LD_VAR 0 10
2956: PUSH
2957: FOR_TO
2958: IFFALSE 2985
// PlaceUnitArea ( team [ i ] , area , false ) ;
2960: LD_VAR 0 10
2964: PUSH
2965: LD_VAR 0 8
2969: ARRAY
2970: PPUSH
2971: LD_VAR 0 3
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: CALL_OW 49
2983: GO 2957
2985: POP
2986: POP
// end ;
2987: LD_VAR 0 7
2991: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2992: LD_INT 0
2994: PPUSH
2995: PPUSH
// for i = 1 to n1 do
2996: LD_ADDR_VAR 0 6
3000: PUSH
3001: DOUBLE
3002: LD_INT 1
3004: DEC
3005: ST_TO_ADDR
3006: LD_VAR 0 1
3010: PUSH
3011: FOR_TO
3012: IFFALSE 3034
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3014: LD_INT 1
3016: PPUSH
3017: LD_INT 1
3019: PPUSH
3020: LD_VAR 0 4
3024: PPUSH
3025: LD_INT 0
3027: PPUSH
3028: CALL_OW 59
3032: GO 3011
3034: POP
3035: POP
// for i = 1 to n2 do
3036: LD_ADDR_VAR 0 6
3040: PUSH
3041: DOUBLE
3042: LD_INT 1
3044: DEC
3045: ST_TO_ADDR
3046: LD_VAR 0 2
3050: PUSH
3051: FOR_TO
3052: IFFALSE 3074
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3054: LD_INT 2
3056: PPUSH
3057: LD_INT 1
3059: PPUSH
3060: LD_VAR 0 4
3064: PPUSH
3065: LD_INT 0
3067: PPUSH
3068: CALL_OW 59
3072: GO 3051
3074: POP
3075: POP
// for i = 1 to n3 do
3076: LD_ADDR_VAR 0 6
3080: PUSH
3081: DOUBLE
3082: LD_INT 1
3084: DEC
3085: ST_TO_ADDR
3086: LD_VAR 0 3
3090: PUSH
3091: FOR_TO
3092: IFFALSE 3114
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3094: LD_INT 3
3096: PPUSH
3097: LD_INT 1
3099: PPUSH
3100: LD_VAR 0 4
3104: PPUSH
3105: LD_INT 0
3107: PPUSH
3108: CALL_OW 59
3112: GO 3091
3114: POP
3115: POP
// end ; end_of_file
3116: LD_VAR 0 5
3120: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3121: LD_INT 0
3123: PPUSH
3124: PPUSH
3125: PPUSH
3126: PPUSH
3127: PPUSH
3128: PPUSH
// uc_side := your_side ;
3129: LD_ADDR_OWVAR 20
3133: PUSH
3134: LD_OWVAR 2
3138: ST_TO_ADDR
// uc_nation := nation_russian ;
3139: LD_ADDR_OWVAR 21
3143: PUSH
3144: LD_INT 3
3146: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3147: LD_ADDR_EXP 17
3151: PUSH
3152: LD_STRING Gladkov
3154: PPUSH
3155: CALL_OW 25
3159: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3160: LD_ADDR_EXP 18
3164: PUSH
3165: LD_STRING Davidov
3167: PPUSH
3168: CALL_OW 25
3172: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3173: LD_ADDR_EXP 19
3177: PUSH
3178: LD_STRING Burlak
3180: PPUSH
3181: CALL_OW 25
3185: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3186: LD_ADDR_EXP 20
3190: PUSH
3191: LD_STRING Stolypin
3193: PPUSH
3194: CALL_OW 25
3198: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3199: LD_ADDR_EXP 15
3203: PUSH
3204: LD_EXP 17
3208: PUSH
3209: LD_EXP 18
3213: PUSH
3214: LD_EXP 19
3218: PUSH
3219: LD_EXP 20
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: LIST
3228: LIST
3229: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3230: LD_ADDR_EXP 23
3234: PUSH
3235: LD_EXP 15
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: ST_TO_ADDR
// team := [ ] ;
3246: LD_ADDR_VAR 0 6
3250: PUSH
3251: EMPTY
3252: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3253: LD_ADDR_VAR 0 4
3257: PUSH
3258: LD_INT 4
3260: PUSH
3261: LD_INT 3
3263: PUSH
3264: LD_INT 3
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: PUSH
3272: LD_OWVAR 67
3276: ARRAY
3277: ST_TO_ADDR
// hc_gallery :=  ;
3278: LD_ADDR_OWVAR 33
3282: PUSH
3283: LD_STRING 
3285: ST_TO_ADDR
// hc_name :=  ;
3286: LD_ADDR_OWVAR 26
3290: PUSH
3291: LD_STRING 
3293: ST_TO_ADDR
// hc_importance := 0 ;
3294: LD_ADDR_OWVAR 32
3298: PUSH
3299: LD_INT 0
3301: ST_TO_ADDR
// case player_com of gladkov :
3302: LD_EXP 23
3306: PUSH
3307: LD_EXP 17
3311: DOUBLE
3312: EQUAL
3313: IFTRUE 3317
3315: GO 3462
3317: POP
// begin for i = 1 to 10 do
3318: LD_ADDR_VAR 0 3
3322: PUSH
3323: DOUBLE
3324: LD_INT 1
3326: DEC
3327: ST_TO_ADDR
3328: LD_INT 10
3330: PUSH
3331: FOR_TO
3332: IFFALSE 3371
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3334: LD_INT 0
3336: PPUSH
3337: LD_INT 1
3339: PPUSH
3340: LD_VAR 0 4
3344: PUSH
3345: LD_INT 1
3347: PLUS
3348: PPUSH
3349: CALL_OW 380
// team := team ^ CreateHuman ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: CALL_OW 44
3367: ADD
3368: ST_TO_ADDR
// end ;
3369: GO 3331
3371: POP
3372: POP
// for i = 1 to 15 do
3373: LD_ADDR_VAR 0 3
3377: PUSH
3378: DOUBLE
3379: LD_INT 1
3381: DEC
3382: ST_TO_ADDR
3383: LD_INT 15
3385: PUSH
3386: FOR_TO
3387: IFFALSE 3432
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3389: LD_INT 0
3391: PPUSH
3392: LD_VAR 0 3
3396: PUSH
3397: LD_INT 3
3399: MOD
3400: PUSH
3401: LD_INT 2
3403: PLUS
3404: PPUSH
3405: LD_VAR 0 4
3409: PPUSH
3410: CALL_OW 380
// team := team ^ CreateHuman ;
3414: LD_ADDR_VAR 0 6
3418: PUSH
3419: LD_VAR 0 6
3423: PUSH
3424: CALL_OW 44
3428: ADD
3429: ST_TO_ADDR
// end ;
3430: GO 3386
3432: POP
3433: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3434: LD_INT 44
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 1
3442: PPUSH
3443: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3447: LD_INT 34
3449: PPUSH
3450: LD_INT 3
3452: PPUSH
3453: LD_INT 1
3455: PPUSH
3456: CALL_OW 322
// end ; davidov :
3460: GO 4345
3462: LD_EXP 18
3466: DOUBLE
3467: EQUAL
3468: IFTRUE 3472
3470: GO 3747
3472: POP
// begin for i = 1 to 10 do
3473: LD_ADDR_VAR 0 3
3477: PUSH
3478: DOUBLE
3479: LD_INT 1
3481: DEC
3482: ST_TO_ADDR
3483: LD_INT 10
3485: PUSH
3486: FOR_TO
3487: IFFALSE 3526
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3489: LD_INT 0
3491: PPUSH
3492: LD_INT 4
3494: PPUSH
3495: LD_VAR 0 4
3499: PUSH
3500: LD_INT 1
3502: PLUS
3503: PPUSH
3504: CALL_OW 380
// team := team ^ CreateHuman ;
3508: LD_ADDR_VAR 0 6
3512: PUSH
3513: LD_VAR 0 6
3517: PUSH
3518: CALL_OW 44
3522: ADD
3523: ST_TO_ADDR
// end ;
3524: GO 3486
3526: POP
3527: POP
// for i = 1 to 15 do
3528: LD_ADDR_VAR 0 3
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_INT 15
3540: PUSH
3541: FOR_TO
3542: IFFALSE 3587
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3544: LD_INT 0
3546: PPUSH
3547: LD_VAR 0 3
3551: PUSH
3552: LD_INT 3
3554: MOD
3555: PUSH
3556: LD_INT 1
3558: PLUS
3559: PPUSH
3560: LD_VAR 0 4
3564: PPUSH
3565: CALL_OW 380
// team := team ^ CreateHuman ;
3569: LD_ADDR_VAR 0 6
3573: PUSH
3574: LD_VAR 0 6
3578: PUSH
3579: CALL_OW 44
3583: ADD
3584: ST_TO_ADDR
// end ;
3585: GO 3541
3587: POP
3588: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3589: LD_INT 34
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3602: LD_INT 32
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3615: LD_INT 27
3617: PPUSH
3618: LD_INT 3
3620: PPUSH
3621: LD_INT 1
3623: PPUSH
3624: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3628: LD_INT 30
3630: PPUSH
3631: LD_INT 3
3633: PPUSH
3634: LD_INT 1
3636: PPUSH
3637: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3641: LD_INT 63
3643: PPUSH
3644: LD_INT 3
3646: PPUSH
3647: LD_INT 1
3649: PPUSH
3650: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3654: LD_INT 57
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: LD_INT 1
3662: PPUSH
3663: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3667: LD_INT 58
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3680: LD_INT 8
3682: PPUSH
3683: LD_INT 3
3685: PPUSH
3686: LD_INT 1
3688: PPUSH
3689: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3693: LD_INT 12
3695: PPUSH
3696: LD_INT 3
3698: PPUSH
3699: LD_INT 1
3701: PPUSH
3702: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3706: LD_INT 14
3708: PPUSH
3709: LD_INT 3
3711: PPUSH
3712: LD_INT 1
3714: PPUSH
3715: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3719: LD_INT 24
3721: PPUSH
3722: LD_INT 3
3724: PPUSH
3725: LD_INT 1
3727: PPUSH
3728: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3732: LD_INT 33
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 1
3740: PPUSH
3741: CALL_OW 324
// end ; gorki :
3745: GO 4345
3747: LD_EXP 19
3751: DOUBLE
3752: EQUAL
3753: IFTRUE 3757
3755: GO 4038
3757: POP
// begin for i = 1 to 10 do
3758: LD_ADDR_VAR 0 3
3762: PUSH
3763: DOUBLE
3764: LD_INT 1
3766: DEC
3767: ST_TO_ADDR
3768: LD_INT 10
3770: PUSH
3771: FOR_TO
3772: IFFALSE 3826
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3774: LD_INT 0
3776: PPUSH
3777: LD_INT 3
3779: PPUSH
3780: LD_VAR 0 4
3784: PUSH
3785: LD_INT 1
3787: PLUS
3788: PPUSH
3789: CALL_OW 380
// team := team ^ CreateHuman ;
3793: LD_ADDR_VAR 0 6
3797: PUSH
3798: LD_VAR 0 6
3802: PUSH
3803: CALL_OW 44
3807: ADD
3808: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3809: LD_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: ARRAY
3819: PPUSH
3820: CALL 7665 0 1
// end ;
3824: GO 3771
3826: POP
3827: POP
// for i = 1 to 15 do
3828: LD_ADDR_VAR 0 3
3832: PUSH
3833: DOUBLE
3834: LD_INT 1
3836: DEC
3837: ST_TO_ADDR
3838: LD_INT 15
3840: PUSH
3841: FOR_TO
3842: IFFALSE 3915
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3844: LD_INT 0
3846: PPUSH
3847: LD_INT 1
3849: PUSH
3850: LD_INT 2
3852: PUSH
3853: LD_INT 4
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: PUSH
3861: LD_INT 1
3863: PPUSH
3864: LD_INT 3
3866: PPUSH
3867: CALL_OW 12
3871: ARRAY
3872: PPUSH
3873: LD_VAR 0 4
3877: PPUSH
3878: CALL_OW 380
// team := team ^ CreateHuman ;
3882: LD_ADDR_VAR 0 6
3886: PUSH
3887: LD_VAR 0 6
3891: PUSH
3892: CALL_OW 44
3896: ADD
3897: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3898: LD_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: ARRAY
3908: PPUSH
3909: CALL 7665 0 1
// end ;
3913: GO 3841
3915: POP
3916: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3917: LD_INT 40
3919: PPUSH
3920: LD_INT 3
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3930: LD_INT 34
3932: PPUSH
3933: LD_INT 3
3935: PPUSH
3936: LD_INT 1
3938: PPUSH
3939: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3943: LD_INT 18
3945: PPUSH
3946: LD_INT 3
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3956: LD_ADDR_OWVAR 37
3960: PUSH
3961: LD_INT 22
3963: ST_TO_ADDR
// vc_engine := engine_combustion ;
3964: LD_ADDR_OWVAR 39
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// vc_control := control_manual ;
3972: LD_ADDR_OWVAR 38
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3980: LD_ADDR_OWVAR 40
3984: PUSH
3985: LD_INT 45
3987: ST_TO_ADDR
// vc_fuel_battery := 3 ;
3988: LD_ADDR_OWVAR 41
3992: PUSH
3993: LD_INT 3
3995: ST_TO_ADDR
// veh := CreateVehicle ;
3996: LD_ADDR_VAR 0 7
4000: PUSH
4001: CALL_OW 45
4005: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4006: LD_VAR 0 7
4010: PPUSH
4011: LD_INT 1
4013: PPUSH
4014: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4018: LD_VAR 0 7
4022: PPUSH
4023: LD_INT 107
4025: PPUSH
4026: LD_INT 83
4028: PPUSH
4029: LD_INT 0
4031: PPUSH
4032: CALL_OW 48
// end ; stolypin :
4036: GO 4345
4038: LD_EXP 20
4042: DOUBLE
4043: EQUAL
4044: IFTRUE 4048
4046: GO 4344
4048: POP
// begin for i = 1 to 10 do
4049: LD_ADDR_VAR 0 3
4053: PUSH
4054: DOUBLE
4055: LD_INT 1
4057: DEC
4058: ST_TO_ADDR
4059: LD_INT 10
4061: PUSH
4062: FOR_TO
4063: IFFALSE 4102
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4065: LD_INT 0
4067: PPUSH
4068: LD_INT 2
4070: PPUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_INT 1
4078: PLUS
4079: PPUSH
4080: CALL_OW 380
// team := team ^ CreateHuman ;
4084: LD_ADDR_VAR 0 6
4088: PUSH
4089: LD_VAR 0 6
4093: PUSH
4094: CALL_OW 44
4098: ADD
4099: ST_TO_ADDR
// end ;
4100: GO 4062
4102: POP
4103: POP
// for i = 1 to 15 do
4104: LD_ADDR_VAR 0 3
4108: PUSH
4109: DOUBLE
4110: LD_INT 1
4112: DEC
4113: ST_TO_ADDR
4114: LD_INT 15
4116: PUSH
4117: FOR_TO
4118: IFFALSE 4176
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4120: LD_INT 0
4122: PPUSH
4123: LD_INT 1
4125: PUSH
4126: LD_INT 3
4128: PUSH
4129: LD_INT 4
4131: PUSH
4132: EMPTY
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 1
4139: PPUSH
4140: LD_INT 3
4142: PPUSH
4143: CALL_OW 12
4147: ARRAY
4148: PPUSH
4149: LD_VAR 0 4
4153: PPUSH
4154: CALL_OW 380
// team := team ^ CreateHuman ;
4158: LD_ADDR_VAR 0 6
4162: PUSH
4163: LD_VAR 0 6
4167: PUSH
4168: CALL_OW 44
4172: ADD
4173: ST_TO_ADDR
// end ;
4174: GO 4117
4176: POP
4177: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4178: LD_INT 34
4180: PPUSH
4181: LD_INT 3
4183: PPUSH
4184: LD_INT 1
4186: PPUSH
4187: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4191: LD_ADDR_OWVAR 37
4195: PUSH
4196: LD_INT 22
4198: ST_TO_ADDR
// vc_engine := engine_combustion ;
4199: LD_ADDR_OWVAR 39
4203: PUSH
4204: LD_INT 1
4206: ST_TO_ADDR
// vc_control := control_manual ;
4207: LD_ADDR_OWVAR 38
4211: PUSH
4212: LD_INT 1
4214: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4215: LD_ADDR_OWVAR 40
4219: PUSH
4220: LD_INT 51
4222: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4223: LD_ADDR_OWVAR 41
4227: PUSH
4228: LD_INT 30
4230: ST_TO_ADDR
// veh := CreateVehicle ;
4231: LD_ADDR_VAR 0 7
4235: PUSH
4236: CALL_OW 45
4240: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4241: LD_VAR 0 7
4245: PPUSH
4246: LD_INT 1
4248: PPUSH
4249: LD_INT 100
4251: PPUSH
4252: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 107
4263: PPUSH
4264: LD_INT 83
4266: PPUSH
4267: LD_INT 0
4269: PPUSH
4270: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4274: LD_ADDR_OWVAR 37
4278: PUSH
4279: LD_INT 22
4281: ST_TO_ADDR
// vc_engine := engine_combustion ;
4282: LD_ADDR_OWVAR 39
4286: PUSH
4287: LD_INT 1
4289: ST_TO_ADDR
// vc_control := control_manual ;
4290: LD_ADDR_OWVAR 38
4294: PUSH
4295: LD_INT 1
4297: ST_TO_ADDR
// vc_weapon := ru_crane ;
4298: LD_ADDR_OWVAR 40
4302: PUSH
4303: LD_INT 52
4305: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4306: LD_ADDR_OWVAR 41
4310: PUSH
4311: LD_INT 30
4313: ST_TO_ADDR
// veh := CreateVehicle ;
4314: LD_ADDR_VAR 0 7
4318: PUSH
4319: CALL_OW 45
4323: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4324: LD_VAR 0 7
4328: PPUSH
4329: LD_INT 115
4331: PPUSH
4332: LD_INT 96
4334: PPUSH
4335: LD_INT 0
4337: PPUSH
4338: CALL_OW 48
// end ; end ;
4342: GO 4345
4344: POP
// if isTest then
4345: LD_EXP 1
4349: IFFALSE 4363
// tmp := team else
4351: LD_ADDR_VAR 0 5
4355: PUSH
4356: LD_VAR 0 6
4360: ST_TO_ADDR
4361: GO 4427
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4363: LD_ADDR_VAR 0 5
4367: PUSH
4368: LD_STRING text
4370: PPUSH
4371: LD_INT 12
4373: PPUSH
4374: LD_INT 12
4376: PPUSH
4377: LD_INT -2
4379: PUSH
4380: LD_INT -5
4382: PUSH
4383: LD_INT -3
4385: PUSH
4386: EMPTY
4387: LIST
4388: LIST
4389: LIST
4390: PUSH
4391: LD_VAR 0 6
4395: ADD
4396: PPUSH
4397: LD_INT 1
4399: PUSH
4400: LD_INT 2
4402: PUSH
4403: LD_INT 1
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 3
4412: PUSH
4413: LD_INT 4
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: PPUSH
4422: CALL_OW 42
4426: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4427: LD_EXP 23
4431: PPUSH
4432: LD_INT 9
4434: PPUSH
4435: LD_INT 0
4437: PPUSH
4438: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4442: LD_VAR 0 5
4446: PUSH
4447: LD_INT 1
4449: ARRAY
4450: PPUSH
4451: LD_INT 2
4453: PPUSH
4454: CALL_OW 336
// for i = 1 to tmp do
4458: LD_ADDR_VAR 0 3
4462: PUSH
4463: DOUBLE
4464: LD_INT 1
4466: DEC
4467: ST_TO_ADDR
4468: LD_VAR 0 5
4472: PUSH
4473: FOR_TO
4474: IFFALSE 4529
// if i < 4 then
4476: LD_VAR 0 3
4480: PUSH
4481: LD_INT 4
4483: LESS
4484: IFFALSE 4509
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4486: LD_VAR 0 5
4490: PUSH
4491: LD_VAR 0 3
4495: ARRAY
4496: PPUSH
4497: LD_INT 9
4499: PPUSH
4500: LD_INT 0
4502: PPUSH
4503: CALL_OW 49
4507: GO 4527
// SetSide ( tmp [ i ] , 6 ) ;
4509: LD_VAR 0 5
4513: PUSH
4514: LD_VAR 0 3
4518: ARRAY
4519: PPUSH
4520: LD_INT 6
4522: PPUSH
4523: CALL_OW 235
4527: GO 4473
4529: POP
4530: POP
// player_squad := tmp ;
4531: LD_ADDR_EXP 21
4535: PUSH
4536: LD_VAR 0 5
4540: ST_TO_ADDR
// pl_counter := 4 ;
4541: LD_ADDR_EXP 22
4545: PUSH
4546: LD_INT 4
4548: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4549: LD_INT 17
4551: PPUSH
4552: LD_INT 5
4554: PPUSH
4555: LD_INT 1
4557: PPUSH
4558: CALL 18106 0 3
// end ;
4562: LD_VAR 0 2
4566: RET
// export Popov ; export function InitAction ; var commander ; begin
4567: LD_INT 0
4569: PPUSH
4570: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4571: LD_INT 6
4573: PPUSH
4574: LD_INT 3
4576: PPUSH
4577: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4581: LD_INT 1
4583: PPUSH
4584: LD_INT 1
4586: PPUSH
4587: CALL_OW 86
// uc_side := 6 ;
4591: LD_ADDR_OWVAR 20
4595: PUSH
4596: LD_INT 6
4598: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4599: LD_ADDR_EXP 24
4603: PUSH
4604: LD_STRING Popov
4606: PPUSH
4607: CALL_OW 25
4611: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4612: LD_ADDR_OWVAR 67
4616: PUSH
4617: LD_INT 0
4619: PPUSH
4620: CALL_OW 426
4624: ST_TO_ADDR
// if not Difficulty then
4625: LD_OWVAR 67
4629: NOT
4630: IFFALSE 4640
// Difficulty := 2 ;
4632: LD_ADDR_OWVAR 67
4636: PUSH
4637: LD_INT 2
4639: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4640: LD_ADDR_VAR 0 2
4644: PUSH
4645: LD_INT 1
4647: PPUSH
4648: CALL_OW 426
4652: ST_TO_ADDR
// if not commander then
4653: LD_VAR 0 2
4657: NOT
4658: IFFALSE 4668
// commander := 1 ;
4660: LD_ADDR_VAR 0 2
4664: PUSH
4665: LD_INT 1
4667: ST_TO_ADDR
// InitCommanders ( commander ) ;
4668: LD_VAR 0 2
4672: PPUSH
4673: CALL 3121 0 1
// end ;
4677: LD_VAR 0 1
4681: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4682: LD_EXP 22
4686: PUSH
4687: LD_INT 12
4689: LESS
4690: IFFALSE 4863
4692: GO 4694
4694: DISABLE
4695: LD_INT 0
4697: PPUSH
// begin enable ;
4698: ENABLE
// for i = pl_counter to pl_counter + 2 do
4699: LD_ADDR_VAR 0 1
4703: PUSH
4704: DOUBLE
4705: LD_EXP 22
4709: DEC
4710: ST_TO_ADDR
4711: LD_EXP 22
4715: PUSH
4716: LD_INT 2
4718: PLUS
4719: PUSH
4720: FOR_TO
4721: IFFALSE 4767
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4723: LD_EXP 21
4727: PUSH
4728: LD_VAR 0 1
4732: ARRAY
4733: PPUSH
4734: LD_INT 18
4736: PPUSH
4737: LD_INT 0
4739: PPUSH
4740: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4744: LD_EXP 21
4748: PUSH
4749: LD_VAR 0 1
4753: ARRAY
4754: PPUSH
4755: LD_INT 107
4757: PPUSH
4758: LD_INT 88
4760: PPUSH
4761: CALL_OW 111
// end ;
4765: GO 4720
4767: POP
4768: POP
// for i = pl_counter to pl_counter + 2 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_EXP 22
4779: DEC
4780: ST_TO_ADDR
4781: LD_EXP 22
4785: PUSH
4786: LD_INT 2
4788: PLUS
4789: PUSH
4790: FOR_TO
4791: IFFALSE 4847
// begin repeat wait ( 0 0$01 ) ;
4793: LD_INT 35
4795: PPUSH
4796: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4800: LD_EXP 21
4804: PUSH
4805: LD_VAR 0 1
4809: ARRAY
4810: PPUSH
4811: LD_INT 107
4813: PPUSH
4814: LD_INT 88
4816: PPUSH
4817: CALL_OW 297
4821: PUSH
4822: LD_INT 6
4824: LESS
4825: IFFALSE 4793
// SetSide ( player_squad [ i ] , 3 ) ;
4827: LD_EXP 21
4831: PUSH
4832: LD_VAR 0 1
4836: ARRAY
4837: PPUSH
4838: LD_INT 3
4840: PPUSH
4841: CALL_OW 235
// end ;
4845: GO 4790
4847: POP
4848: POP
// pl_counter := pl_counter + 3 ;
4849: LD_ADDR_EXP 22
4853: PUSH
4854: LD_EXP 22
4858: PUSH
4859: LD_INT 3
4861: PLUS
4862: ST_TO_ADDR
// end ;
4863: PPOPN 1
4865: END
// export function Dialog ; begin
4866: LD_INT 0
4868: PPUSH
// if not isTest then
4869: LD_EXP 1
4873: NOT
4874: IFFALSE 4896
// case query ( task ) of 1 :
4876: LD_STRING task
4878: PPUSH
4879: CALL_OW 97
4883: PUSH
4884: LD_INT 1
4886: DOUBLE
4887: EQUAL
4888: IFTRUE 4892
4890: GO 4895
4892: POP
// ; end ;
4893: GO 4896
4895: POP
// InGameOn ;
4896: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4900: LD_INT 107
4902: PPUSH
4903: LD_INT 84
4905: PPUSH
4906: CALL_OW 86
// if isTest then
4910: LD_EXP 1
4914: IFFALSE 4924
// dialogue_skipped := true ;
4916: LD_ADDR_OWVAR 59
4920: PUSH
4921: LD_INT 1
4923: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4924: LD_ADDR_EXP 9
4928: PUSH
4929: LD_EXP 21
4933: PUSH
4934: LD_INT 1
4936: ARRAY
4937: PPUSH
4938: LD_INT 0
4940: PPUSH
4941: LD_INT 96
4943: PPUSH
4944: LD_INT 79
4946: PPUSH
4947: LD_INT 2
4949: PPUSH
4950: CALL_OW 145
4954: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4955: LD_INT 35
4957: PPUSH
4958: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4962: LD_EXP 24
4966: PPUSH
4967: LD_STRING DR1
4969: PPUSH
4970: CALL_OW 94
// Wait ( 0 0$01 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5012: LD_INT 3
5014: PPUSH
5015: LD_INT 30
5017: PUSH
5018: LD_INT 0
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PPUSH
5025: CALL 11393 0 2
5029: PUSH
5030: LD_EXP 1
5034: OR
5035: IFFALSE 5005
// InGameOff ;
5037: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5041: LD_STRING C1
5043: PPUSH
5044: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5048: LD_INT 35
5050: PPUSH
5051: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5055: LD_EXP 9
5059: PPUSH
5060: CALL_OW 461
5064: PUSH
5065: LD_INT 2
5067: EQUAL
5068: IFFALSE 5048
// if not isTest then
5070: LD_EXP 1
5074: NOT
5075: IFFALSE 5097
// case query ( support ) of 1 :
5077: LD_STRING support
5079: PPUSH
5080: CALL_OW 97
5084: PUSH
5085: LD_INT 1
5087: DOUBLE
5088: EQUAL
5089: IFTRUE 5093
5091: GO 5096
5093: POP
// ; end ;
5094: GO 5097
5096: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5097: LD_INT 3
5099: PPUSH
5100: LD_INT 12
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: LD_INT 22
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 0
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PPUSH
5130: CALL_OW 69
5134: PUSH
5135: LD_INT 1
5137: ARRAY
5138: PPUSH
5139: CALL_OW 468
// if player_com = stolypin then
5143: LD_EXP 23
5147: PUSH
5148: LD_EXP 20
5152: EQUAL
5153: IFFALSE 5182
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5155: LD_INT 18
5157: PPUSH
5158: LD_INT 3
5160: PUSH
5161: LD_INT 3
5163: PUSH
5164: LD_INT 2
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: LIST
5171: PUSH
5172: LD_OWVAR 67
5176: ARRAY
5177: PPUSH
5178: CALL 6482 0 2
// end ;
5182: LD_VAR 0 1
5186: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5187: LD_EXP 10
5191: PUSH
5192: LD_OWVAR 1
5196: PUSH
5197: LD_INT 31500
5199: LESS
5200: AND
5201: IFFALSE 5365
// case query ( call1 ) of 1 :
5203: LD_STRING call1
5205: PPUSH
5206: CALL_OW 97
5210: PUSH
5211: LD_INT 1
5213: DOUBLE
5214: EQUAL
5215: IFTRUE 5219
5217: GO 5353
5219: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5220: LD_INT 3
5222: PPUSH
5223: LD_INT 12
5225: PPUSH
5226: LD_INT 1
5228: PPUSH
5229: LD_EXP 9
5233: PPUSH
5234: CALL_OW 468
// call := false ;
5238: LD_ADDR_EXP 10
5242: PUSH
5243: LD_INT 0
5245: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5246: LD_EXP 24
5250: PPUSH
5251: LD_STRING DR6
5253: PPUSH
5254: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5258: LD_INT 6300
5260: PPUSH
5261: LD_INT 8400
5263: PPUSH
5264: CALL_OW 12
5268: PPUSH
5269: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5273: LD_INT 18
5275: PUSH
5276: LD_INT 19
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 1
5285: PPUSH
5286: LD_INT 2
5288: PPUSH
5289: CALL_OW 12
5293: ARRAY
5294: PPUSH
5295: LD_INT 1
5297: PPUSH
5298: LD_INT 2
5300: PPUSH
5301: CALL_OW 12
5305: PPUSH
5306: CALL 6482 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5310: LD_INT 25200
5312: PPUSH
5313: LD_INT 35700
5315: PPUSH
5316: CALL_OW 12
5320: PPUSH
5321: CALL_OW 67
// call := true ;
5325: LD_ADDR_EXP 10
5329: PUSH
5330: LD_INT 1
5332: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5333: LD_INT 3
5335: PPUSH
5336: LD_INT 12
5338: PPUSH
5339: LD_INT 2
5341: PPUSH
5342: LD_EXP 9
5346: PPUSH
5347: CALL_OW 468
// end ; 2 :
5351: GO 5365
5353: LD_INT 2
5355: DOUBLE
5356: EQUAL
5357: IFTRUE 5361
5359: GO 5364
5361: POP
// ; end ;
5362: GO 5365
5364: POP
// if call and tick >= 15 15$00 then
5365: LD_EXP 10
5369: PUSH
5370: LD_OWVAR 1
5374: PUSH
5375: LD_INT 31500
5377: GREATEREQUAL
5378: AND
5379: IFFALSE 5808
// case query ( call2 ) of 1 :
5381: LD_STRING call2
5383: PPUSH
5384: CALL_OW 97
5388: PUSH
5389: LD_INT 1
5391: DOUBLE
5392: EQUAL
5393: IFTRUE 5397
5395: GO 5633
5397: POP
// begin call := false ;
5398: LD_ADDR_EXP 10
5402: PUSH
5403: LD_INT 0
5405: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5406: LD_INT 1
5408: PPUSH
5409: LD_INT 21
5411: PUSH
5412: LD_INT 3
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: PPUSH
5419: CALL 11393 0 2
5423: PUSH
5424: LD_INT 4
5426: PPUSH
5427: LD_INT 21
5429: PUSH
5430: LD_INT 3
5432: PUSH
5433: EMPTY
5434: LIST
5435: LIST
5436: PPUSH
5437: CALL 11393 0 2
5441: AND
5442: IFFALSE 5490
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5444: LD_INT 18
5446: PUSH
5447: LD_INT 19
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: PUSH
5454: LD_INT 1
5456: PPUSH
5457: LD_INT 2
5459: PPUSH
5460: CALL_OW 12
5464: ARRAY
5465: PPUSH
5466: LD_INT 5
5468: PUSH
5469: LD_INT 4
5471: PUSH
5472: LD_INT 4
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_OWVAR 67
5484: ARRAY
5485: PPUSH
5486: CALL 6243 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5490: LD_INT 1
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11393 0 2
5507: PUSH
5508: LD_INT 0
5510: EQUAL
5511: IFFALSE 5540
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5513: LD_INT 19
5515: PPUSH
5516: LD_INT 5
5518: PUSH
5519: LD_INT 4
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: LD_OWVAR 67
5534: ARRAY
5535: PPUSH
5536: CALL 6243 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5540: LD_INT 4
5542: PPUSH
5543: LD_INT 21
5545: PUSH
5546: LD_INT 3
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL 11393 0 2
5557: PUSH
5558: LD_INT 0
5560: EQUAL
5561: IFFALSE 5590
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5563: LD_INT 18
5565: PPUSH
5566: LD_INT 5
5568: PUSH
5569: LD_INT 4
5571: PUSH
5572: LD_INT 4
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: LIST
5579: PUSH
5580: LD_OWVAR 67
5584: ARRAY
5585: PPUSH
5586: CALL 6243 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5590: LD_INT 10500
5592: PPUSH
5593: LD_INT 23100
5595: PPUSH
5596: CALL_OW 12
5600: PPUSH
5601: CALL_OW 67
// call := true ;
5605: LD_ADDR_EXP 10
5609: PUSH
5610: LD_INT 1
5612: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5613: LD_INT 3
5615: PPUSH
5616: LD_INT 12
5618: PPUSH
5619: LD_INT 2
5621: PPUSH
5622: LD_EXP 9
5626: PPUSH
5627: CALL_OW 468
// end ; 2 :
5631: GO 5808
5633: LD_INT 2
5635: DOUBLE
5636: EQUAL
5637: IFTRUE 5641
5639: GO 5796
5641: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5642: LD_INT 3
5644: PPUSH
5645: LD_INT 12
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: LD_EXP 9
5655: PPUSH
5656: CALL_OW 468
// call := false ;
5660: LD_ADDR_EXP 10
5664: PUSH
5665: LD_INT 0
5667: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5668: LD_EXP 24
5672: PPUSH
5673: LD_STRING DR6
5675: PPUSH
5676: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5680: LD_INT 6300
5682: PPUSH
5683: LD_INT 8400
5685: PPUSH
5686: CALL_OW 12
5690: PPUSH
5691: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5695: LD_INT 18
5697: PUSH
5698: LD_INT 19
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PUSH
5705: LD_INT 1
5707: PPUSH
5708: LD_INT 2
5710: PPUSH
5711: CALL_OW 12
5715: ARRAY
5716: PPUSH
5717: LD_INT 3
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 2
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: PUSH
5731: LD_OWVAR 67
5735: ARRAY
5736: PUSH
5737: LD_INT 0
5739: PPUSH
5740: LD_INT 1
5742: PPUSH
5743: CALL_OW 12
5747: MINUS
5748: PPUSH
5749: CALL 6482 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5753: LD_INT 35700
5755: PPUSH
5756: LD_INT 44100
5758: PPUSH
5759: CALL_OW 12
5763: PPUSH
5764: CALL_OW 67
// call := true ;
5768: LD_ADDR_EXP 10
5772: PUSH
5773: LD_INT 1
5775: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5776: LD_INT 3
5778: PPUSH
5779: LD_INT 12
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: LD_EXP 9
5789: PPUSH
5790: CALL_OW 468
// end ; 3 :
5794: GO 5808
5796: LD_INT 3
5798: DOUBLE
5799: EQUAL
5800: IFTRUE 5804
5802: GO 5807
5804: POP
// ; end ;
5805: GO 5808
5807: POP
// end ;
5808: PPOPN 4
5810: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5811: LD_INT 22
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: EMPTY
5818: LIST
5819: LIST
5820: PUSH
5821: LD_INT 21
5823: PUSH
5824: LD_INT 1
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PPUSH
5835: CALL_OW 69
5839: PUSH
5840: LD_INT 0
5842: EQUAL
5843: PUSH
5844: LD_INT 22
5846: PUSH
5847: LD_INT 4
5849: PUSH
5850: EMPTY
5851: LIST
5852: LIST
5853: PUSH
5854: LD_INT 21
5856: PUSH
5857: LD_INT 1
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PPUSH
5868: CALL_OW 69
5872: PUSH
5873: LD_INT 0
5875: EQUAL
5876: AND
5877: IFFALSE 6081
5879: GO 5881
5881: DISABLE
// begin DialogueOn ;
5882: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5886: LD_EXP 24
5890: PPUSH
5891: LD_STRING DR7
5893: PPUSH
5894: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5898: LD_OWVAR 1
5902: PUSH
5903: LD_INT 116550
5905: PUSH
5906: LD_INT 95550
5908: PUSH
5909: LD_INT 89250
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_OWVAR 67
5921: ARRAY
5922: LESS
5923: IFFALSE 5937
// AddMedal ( med1 , 1 ) else
5925: LD_STRING med1
5927: PPUSH
5928: LD_INT 1
5930: PPUSH
5931: CALL_OW 101
5935: GO 5948
// AddMedal ( med1 , - 1 ) ;
5937: LD_STRING med1
5939: PPUSH
5940: LD_INT 1
5942: NEG
5943: PPUSH
5944: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5948: LD_INT 81
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: PUSH
5958: LD_INT 21
5960: PUSH
5961: LD_INT 3
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PPUSH
5972: CALL_OW 69
5976: PUSH
5977: LD_INT 0
5979: EQUAL
5980: IFFALSE 5994
// AddMedal ( med3 , 1 ) else
5982: LD_STRING med3
5984: PPUSH
5985: LD_INT 1
5987: PPUSH
5988: CALL_OW 101
5992: GO 6005
// AddMedal ( med3 , - 1 ) ;
5994: LD_STRING med3
5996: PPUSH
5997: LD_INT 1
5999: NEG
6000: PPUSH
6001: CALL_OW 101
// if player_squad = 15 then
6005: LD_EXP 21
6009: PUSH
6010: LD_INT 15
6012: EQUAL
6013: IFFALSE 6027
// AddMedal ( med2 , 1 ) else
6015: LD_STRING med2
6017: PPUSH
6018: LD_INT 1
6020: PPUSH
6021: CALL_OW 101
6025: GO 6070
// if player_squad > 12 and player_squad < 15 then
6027: LD_EXP 21
6031: PUSH
6032: LD_INT 12
6034: GREATER
6035: PUSH
6036: LD_EXP 21
6040: PUSH
6041: LD_INT 15
6043: LESS
6044: AND
6045: IFFALSE 6059
// AddMedal ( med2 , 2 ) else
6047: LD_STRING med2
6049: PPUSH
6050: LD_INT 2
6052: PPUSH
6053: CALL_OW 101
6057: GO 6070
// AddMedal ( med2 , - 1 ) ;
6059: LD_STRING med2
6061: PPUSH
6062: LD_INT 1
6064: NEG
6065: PPUSH
6066: CALL_OW 101
// GiveMedals ( MAIN ) ;
6070: LD_STRING MAIN
6072: PPUSH
6073: CALL_OW 102
// YouWin ;
6077: CALL_OW 103
// end ;
6081: END
// every 0 0$01 trigger IsDead ( player_com ) do
6082: LD_EXP 23
6086: PPUSH
6087: CALL_OW 301
6091: IFFALSE 6158
6093: GO 6095
6095: DISABLE
// begin if IsLive ( Houten ) then
6096: LD_EXP 3
6100: PPUSH
6101: CALL_OW 300
6105: IFFALSE 6121
// SayRadio ( Houten , DJ5 ) else
6107: LD_EXP 3
6111: PPUSH
6112: LD_STRING DJ5
6114: PPUSH
6115: CALL_OW 94
6119: GO 6144
// if IsLive ( Brown ) then
6121: LD_EXP 4
6125: PPUSH
6126: CALL_OW 300
6130: IFFALSE 6144
// SayRadio ( Brown , DS5 ) ;
6132: LD_EXP 4
6136: PPUSH
6137: LD_STRING DS5
6139: PPUSH
6140: CALL_OW 94
// Wait ( 0 0$01 ) ;
6144: LD_INT 35
6146: PPUSH
6147: CALL_OW 67
// YouLost ( dead ) ;
6151: LD_STRING dead
6153: PPUSH
6154: CALL_OW 104
// end ;
6158: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6159: LD_EXP 9
6163: PPUSH
6164: CALL_OW 301
6168: PUSH
6169: LD_EXP 1
6173: NOT
6174: AND
6175: IFFALSE 6242
6177: GO 6179
6179: DISABLE
// begin if IsLive ( Brown ) then
6180: LD_EXP 4
6184: PPUSH
6185: CALL_OW 300
6189: IFFALSE 6205
// SayRadio ( Brown , DS5 ) else
6191: LD_EXP 4
6195: PPUSH
6196: LD_STRING DS5
6198: PPUSH
6199: CALL_OW 94
6203: GO 6228
// if IsLive ( Houten ) then
6205: LD_EXP 3
6209: PPUSH
6210: CALL_OW 300
6214: IFFALSE 6228
// SayRadio ( Houten , DJ5 ) ;
6216: LD_EXP 3
6220: PPUSH
6221: LD_STRING DJ5
6223: PPUSH
6224: CALL_OW 94
// Wait ( 0 0$01 ) ;
6228: LD_INT 35
6230: PPUSH
6231: CALL_OW 67
// YouLost ( depot ) ;
6235: LD_STRING depot
6237: PPUSH
6238: CALL_OW 104
// end ;
6242: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6243: LD_INT 0
6245: PPUSH
6246: PPUSH
6247: PPUSH
// for i = 1 to n do
6248: LD_ADDR_VAR 0 4
6252: PUSH
6253: DOUBLE
6254: LD_INT 1
6256: DEC
6257: ST_TO_ADDR
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_TO
6264: IFFALSE 6467
// begin uc_side := 6 ;
6266: LD_ADDR_OWVAR 20
6270: PUSH
6271: LD_INT 6
6273: ST_TO_ADDR
// uc_nation := 3 ;
6274: LD_ADDR_OWVAR 21
6278: PUSH
6279: LD_INT 3
6281: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6282: LD_ADDR_OWVAR 37
6286: PUSH
6287: LD_INT 23
6289: PUSH
6290: LD_INT 22
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 1
6299: PPUSH
6300: LD_INT 2
6302: PPUSH
6303: CALL_OW 12
6307: ARRAY
6308: ST_TO_ADDR
// vc_control := control_computer ;
6309: LD_ADDR_OWVAR 38
6313: PUSH
6314: LD_INT 3
6316: ST_TO_ADDR
// vc_engine := engine_siberite ;
6317: LD_ADDR_OWVAR 39
6321: PUSH
6322: LD_INT 3
6324: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6325: LD_ADDR_OWVAR 40
6329: PUSH
6330: LD_INT 43
6332: PUSH
6333: LD_INT 44
6335: PUSH
6336: LD_INT 44
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 1
6346: PPUSH
6347: LD_INT 3
6349: PPUSH
6350: CALL_OW 12
6354: ARRAY
6355: ST_TO_ADDR
// un := CreateVehicle ;
6356: LD_ADDR_VAR 0 5
6360: PUSH
6361: CALL_OW 45
6365: ST_TO_ADDR
// case area of east_arr :
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 18
6373: DOUBLE
6374: EQUAL
6375: IFTRUE 6379
6377: GO 6414
6379: POP
// begin PlaceUnitArea ( un , area , false ) ;
6380: LD_VAR 0 5
6384: PPUSH
6385: LD_VAR 0 1
6389: PPUSH
6390: LD_INT 0
6392: PPUSH
6393: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6397: LD_VAR 0 5
6401: PPUSH
6402: LD_INT 79
6404: PPUSH
6405: LD_INT 33
6407: PPUSH
6408: CALL_OW 111
// end ; south_arr :
6412: GO 6458
6414: LD_INT 19
6416: DOUBLE
6417: EQUAL
6418: IFTRUE 6422
6420: GO 6457
6422: POP
// begin PlaceUnitArea ( un , area , false ) ;
6423: LD_VAR 0 5
6427: PPUSH
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_INT 0
6435: PPUSH
6436: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6440: LD_VAR 0 5
6444: PPUSH
6445: LD_INT 131
6447: PPUSH
6448: LD_INT 148
6450: PPUSH
6451: CALL_OW 111
// end ; end ;
6455: GO 6458
6457: POP
// Wait ( 0 0$02 ) ;
6458: LD_INT 70
6460: PPUSH
6461: CALL_OW 67
// end ;
6465: GO 6263
6467: POP
6468: POP
// pink_attack := true ;
6469: LD_ADDR_EXP 11
6473: PUSH
6474: LD_INT 1
6476: ST_TO_ADDR
// end ;
6477: LD_VAR 0 3
6481: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6482: LD_INT 0
6484: PPUSH
6485: PPUSH
6486: PPUSH
// for i = 1 to n do
6487: LD_ADDR_VAR 0 4
6491: PUSH
6492: DOUBLE
6493: LD_INT 1
6495: DEC
6496: ST_TO_ADDR
6497: LD_VAR 0 2
6501: PUSH
6502: FOR_TO
6503: IFFALSE 6729
// begin uc_side := 6 ;
6505: LD_ADDR_OWVAR 20
6509: PUSH
6510: LD_INT 6
6512: ST_TO_ADDR
// uc_nation := 3 ;
6513: LD_ADDR_OWVAR 21
6517: PUSH
6518: LD_INT 3
6520: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6521: LD_INT 0
6523: PPUSH
6524: LD_INT 3
6526: PPUSH
6527: LD_INT 4
6529: PPUSH
6530: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6534: LD_ADDR_OWVAR 37
6538: PUSH
6539: LD_INT 22
6541: ST_TO_ADDR
// vc_control := control_manual ;
6542: LD_ADDR_OWVAR 38
6546: PUSH
6547: LD_INT 1
6549: ST_TO_ADDR
// vc_engine := engine_combustion ;
6550: LD_ADDR_OWVAR 39
6554: PUSH
6555: LD_INT 1
6557: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6558: LD_ADDR_OWVAR 40
6562: PUSH
6563: LD_INT 51
6565: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6566: LD_ADDR_OWVAR 41
6570: PUSH
6571: LD_INT 50
6573: ST_TO_ADDR
// un := CreateVehicle ;
6574: LD_ADDR_VAR 0 5
6578: PUSH
6579: CALL_OW 45
6583: ST_TO_ADDR
// case area of east_arr :
6584: LD_VAR 0 1
6588: PUSH
6589: LD_INT 18
6591: DOUBLE
6592: EQUAL
6593: IFTRUE 6597
6595: GO 6612
6597: POP
// SetDir ( un , 4 ) ; south_arr :
6598: LD_VAR 0 5
6602: PPUSH
6603: LD_INT 4
6605: PPUSH
6606: CALL_OW 233
6610: GO 6636
6612: LD_INT 19
6614: DOUBLE
6615: EQUAL
6616: IFTRUE 6620
6618: GO 6635
6620: POP
// SetDir ( un , 5 ) ; end ;
6621: LD_VAR 0 5
6625: PPUSH
6626: LD_INT 5
6628: PPUSH
6629: CALL_OW 233
6633: GO 6636
6635: POP
// PlaceUnitArea ( un , area , false ) ;
6636: LD_VAR 0 5
6640: PPUSH
6641: LD_VAR 0 1
6645: PPUSH
6646: LD_INT 0
6648: PPUSH
6649: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6653: CALL_OW 44
6657: PPUSH
6658: LD_VAR 0 5
6662: PPUSH
6663: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6667: LD_VAR 0 5
6671: PPUSH
6672: LD_INT 1
6674: PPUSH
6675: LD_INT 100
6677: PPUSH
6678: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6682: LD_VAR 0 5
6686: PPUSH
6687: LD_INT 106
6689: PPUSH
6690: LD_INT 88
6692: PPUSH
6693: CALL_OW 111
// AddComUnload ( un ) ;
6697: LD_VAR 0 5
6701: PPUSH
6702: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6706: LD_VAR 0 5
6710: PPUSH
6711: LD_VAR 0 1
6715: PPUSH
6716: CALL_OW 173
// Wait ( 0 0$02 ) ;
6720: LD_INT 70
6722: PPUSH
6723: CALL_OW 67
// end ;
6727: GO 6502
6729: POP
6730: POP
// Wait ( 0 0$05 ) ;
6731: LD_INT 175
6733: PPUSH
6734: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6738: LD_INT 6
6740: PPUSH
6741: LD_INT 34
6743: PUSH
6744: LD_INT 51
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PPUSH
6751: CALL 11393 0 2
6755: IFFALSE 6943
// begin wait ( 0 0$01 ) ;
6757: LD_INT 35
6759: PPUSH
6760: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6764: LD_ADDR_VAR 0 4
6768: PUSH
6769: LD_INT 6
6771: PPUSH
6772: LD_INT 34
6774: PUSH
6775: LD_INT 51
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PPUSH
6782: CALL 11393 0 2
6786: PUSH
6787: FOR_IN
6788: IFFALSE 6939
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6790: LD_VAR 0 4
6794: PPUSH
6795: LD_INT 9
6797: PPUSH
6798: CALL_OW 308
6802: PUSH
6803: LD_VAR 0 4
6807: PPUSH
6808: CALL 31555 0 1
6812: PPUSH
6813: CALL_OW 258
6817: PUSH
6818: LD_INT 1
6820: EQUAL
6821: AND
6822: PUSH
6823: LD_EXP 8
6827: AND
6828: IFFALSE 6855
// begin Say ( GetDriver ( i ) , Dtran ) ;
6830: LD_VAR 0 4
6834: PPUSH
6835: CALL 31555 0 1
6839: PPUSH
6840: LD_STRING Dtran
6842: PPUSH
6843: CALL_OW 88
// dialog_trans := false ;
6847: LD_ADDR_EXP 8
6851: PUSH
6852: LD_INT 0
6854: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6855: LD_VAR 0 4
6859: PPUSH
6860: CALL_OW 316
6864: IFFALSE 6880
// ComMoveToArea ( i , area ) ;
6866: LD_VAR 0 4
6870: PPUSH
6871: LD_VAR 0 1
6875: PPUSH
6876: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6880: LD_VAR 0 4
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 308
6894: PUSH
6895: LD_VAR 0 4
6899: PPUSH
6900: LD_INT 1
6902: PPUSH
6903: CALL_OW 289
6907: PUSH
6908: LD_INT 0
6910: EQUAL
6911: AND
6912: IFFALSE 6937
// begin RemoveUnit ( GetDriver ( i ) ) ;
6914: LD_VAR 0 4
6918: PPUSH
6919: CALL 31555 0 1
6923: PPUSH
6924: CALL_OW 64
// RemoveUnit ( i ) ;
6928: LD_VAR 0 4
6932: PPUSH
6933: CALL_OW 64
// end ; end ;
6937: GO 6787
6939: POP
6940: POP
// end ;
6941: GO 6738
// end ;
6943: LD_VAR 0 3
6947: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6948: LD_INT 0
6950: PPUSH
6951: PPUSH
6952: PPUSH
6953: PPUSH
// if isTest then
6954: LD_EXP 1
6958: IFFALSE 6962
// exit ;
6960: GO 7351
// for i = 1 to n do
6962: LD_ADDR_VAR 0 4
6966: PUSH
6967: DOUBLE
6968: LD_INT 1
6970: DEC
6971: ST_TO_ADDR
6972: LD_VAR 0 2
6976: PUSH
6977: FOR_TO
6978: IFFALSE 7210
// begin uc_side := 8 ;
6980: LD_ADDR_OWVAR 20
6984: PUSH
6985: LD_INT 8
6987: ST_TO_ADDR
// uc_nation := 1 ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 1
6995: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
6996: LD_ADDR_VAR 0 6
7000: PUSH
7001: LD_INT 3
7003: PUSH
7004: LD_INT 4
7006: PUSH
7007: LD_INT 4
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: LIST
7014: PUSH
7015: LD_INT 1
7017: PPUSH
7018: LD_OWVAR 67
7022: PPUSH
7023: CALL_OW 12
7027: ARRAY
7028: ST_TO_ADDR
// vc_chassis := ch ;
7029: LD_ADDR_OWVAR 37
7033: PUSH
7034: LD_VAR 0 6
7038: ST_TO_ADDR
// vc_control := control_computer ;
7039: LD_ADDR_OWVAR 38
7043: PUSH
7044: LD_INT 3
7046: ST_TO_ADDR
// vc_engine := engine_combustion ;
7047: LD_ADDR_OWVAR 39
7051: PUSH
7052: LD_INT 1
7054: ST_TO_ADDR
// if ch = us_medium_tracked then
7055: LD_VAR 0 6
7059: PUSH
7060: LD_INT 3
7062: EQUAL
7063: IFFALSE 7110
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7065: LD_ADDR_OWVAR 40
7069: PUSH
7070: LD_INT 3
7072: PUSH
7073: LD_INT 4
7075: PUSH
7076: LD_INT 5
7078: PUSH
7079: LD_INT 7
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PUSH
7088: LD_OWVAR 67
7092: PPUSH
7093: LD_OWVAR 67
7097: PUSH
7098: LD_INT 1
7100: PLUS
7101: PPUSH
7102: CALL_OW 12
7106: ARRAY
7107: ST_TO_ADDR
7108: GO 7151
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7110: LD_ADDR_OWVAR 40
7114: PUSH
7115: LD_INT 5
7117: PUSH
7118: LD_INT 6
7120: PUSH
7121: LD_INT 7
7123: PUSH
7124: LD_INT 7
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: PUSH
7133: LD_INT 1
7135: PPUSH
7136: LD_OWVAR 67
7140: PUSH
7141: LD_INT 1
7143: PLUS
7144: PPUSH
7145: CALL_OW 12
7149: ARRAY
7150: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7151: LD_ADDR_OWVAR 41
7155: PUSH
7156: LD_INT 70
7158: ST_TO_ADDR
// un := CreateVehicle ;
7159: LD_ADDR_VAR 0 5
7163: PUSH
7164: CALL_OW 45
7168: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7169: LD_VAR 0 5
7173: PPUSH
7174: LD_VAR 0 1
7178: PPUSH
7179: LD_INT 0
7181: PPUSH
7182: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7186: LD_VAR 0 5
7190: PPUSH
7191: LD_INT 65
7193: PPUSH
7194: LD_INT 9
7196: PPUSH
7197: CALL_OW 111
// Wait ( 0 0$02 ) ;
7201: LD_INT 70
7203: PPUSH
7204: CALL_OW 67
// end ;
7208: GO 6977
7210: POP
7211: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7212: LD_INT 90
7214: PUSH
7215: LD_INT 80
7217: PUSH
7218: LD_INT 70
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: LD_OWVAR 67
7230: ARRAY
7231: PPUSH
7232: CALL_OW 13
7236: IFFALSE 7343
// begin uc_side := 8 ;
7238: LD_ADDR_OWVAR 20
7242: PUSH
7243: LD_INT 8
7245: ST_TO_ADDR
// uc_nation := 1 ;
7246: LD_ADDR_OWVAR 21
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7254: LD_ADDR_OWVAR 37
7258: PUSH
7259: LD_INT 4
7261: ST_TO_ADDR
// vc_control := control_computer ;
7262: LD_ADDR_OWVAR 38
7266: PUSH
7267: LD_INT 3
7269: ST_TO_ADDR
// vc_engine := engine_combustion ;
7270: LD_ADDR_OWVAR 39
7274: PUSH
7275: LD_INT 1
7277: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7278: LD_ADDR_OWVAR 40
7282: PUSH
7283: LD_INT 14
7285: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7286: LD_ADDR_OWVAR 41
7290: PUSH
7291: LD_INT 70
7293: ST_TO_ADDR
// un := CreateVehicle ;
7294: LD_ADDR_VAR 0 5
7298: PUSH
7299: CALL_OW 45
7303: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7304: LD_VAR 0 5
7308: PPUSH
7309: LD_VAR 0 1
7313: PPUSH
7314: LD_INT 0
7316: PPUSH
7317: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7321: LD_VAR 0 5
7325: PPUSH
7326: LD_INT 65
7328: PPUSH
7329: LD_INT 9
7331: PPUSH
7332: CALL_OW 111
// Wait ( 0 0$02 ) ;
7336: LD_INT 70
7338: PPUSH
7339: CALL_OW 67
// end ; alfa_support := true ;
7343: LD_ADDR_EXP 12
7347: PUSH
7348: LD_INT 1
7350: ST_TO_ADDR
// end ;
7351: LD_VAR 0 3
7355: RET
// every 0 0$01 trigger tick mod [ 21 21$00 , 16 16$00 , 12 12$00 ] [ Difficulty ] = 0 do
7356: LD_OWVAR 1
7360: PUSH
7361: LD_INT 44100
7363: PUSH
7364: LD_INT 33600
7366: PUSH
7367: LD_INT 25200
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: PUSH
7375: LD_OWVAR 67
7379: ARRAY
7380: MOD
7381: PUSH
7382: LD_INT 0
7384: EQUAL
7385: IFFALSE 7445
7387: GO 7389
7389: DISABLE
// begin enable ;
7390: ENABLE
// SayRadio ( Popov , DR5 ) ;
7391: LD_EXP 24
7395: PPUSH
7396: LD_STRING DR5
7398: PPUSH
7399: CALL_OW 94
// Wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7403: LD_INT 1050
7405: PPUSH
7406: LD_INT 4200
7408: PPUSH
7409: CALL_OW 12
7413: PPUSH
7414: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7418: LD_INT 20
7420: PPUSH
7421: LD_INT 5
7423: PUSH
7424: LD_INT 6
7426: PUSH
7427: LD_INT 7
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PUSH
7435: LD_OWVAR 67
7439: ARRAY
7440: PPUSH
7441: CALL 6948 0 2
// end ; end_of_file
7445: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7446: LD_INT 0
7448: PPUSH
// enable_addtolog := isTest ;
7449: LD_ADDR_OWVAR 81
7453: PUSH
7454: LD_EXP 1
7458: ST_TO_ADDR
// lines_break_limit := 5 ;
7459: LD_ADDR_EXP 26
7463: PUSH
7464: LD_INT 5
7466: ST_TO_ADDR
// lines_break_type := --- ;
7467: LD_ADDR_EXP 27
7471: PUSH
7472: LD_STRING ---
7474: ST_TO_ADDR
// lines_counter := 0 ;
7475: LD_ADDR_EXP 25
7479: PUSH
7480: LD_INT 0
7482: ST_TO_ADDR
// show_line_index := true ;
7483: LD_ADDR_EXP 28
7487: PUSH
7488: LD_INT 1
7490: ST_TO_ADDR
// tick_log := true ;
7491: LD_ADDR_EXP 29
7495: PUSH
7496: LD_INT 1
7498: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7499: LD_STRING ----------SAND OF SIBERIA LOG----------
7501: PPUSH
7502: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7506: LD_STRING Map Name: 
7508: PUSH
7509: LD_OWVAR 68
7513: STR
7514: PPUSH
7515: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7519: LD_STRING Map Number: 
7521: PUSH
7522: LD_OWVAR 70
7526: STR
7527: PPUSH
7528: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7532: LD_STRING Difficulty: 
7534: PUSH
7535: LD_OWVAR 67
7539: STR
7540: PPUSH
7541: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7545: LD_STRING ---------------------------------------
7547: PPUSH
7548: CALL_OW 561
// end ;
7552: LD_VAR 0 1
7556: RET
// function Log ( text ) ; begin
7557: LD_INT 0
7559: PPUSH
// if show_line_index then
7560: LD_EXP 28
7564: IFFALSE 7576
// result := lines_counter ;
7566: LD_ADDR_VAR 0 2
7570: PUSH
7571: LD_EXP 25
7575: ST_TO_ADDR
// if tick_log then
7576: LD_EXP 29
7580: IFFALSE 7606
// result := result &  T:  & tick &   ;
7582: LD_ADDR_VAR 0 2
7586: PUSH
7587: LD_VAR 0 2
7591: PUSH
7592: LD_STRING  T: 
7594: STR
7595: PUSH
7596: LD_OWVAR 1
7600: STR
7601: PUSH
7602: LD_STRING  
7604: STR
7605: ST_TO_ADDR
// AddToLog ( result & text ) ;
7606: LD_VAR 0 2
7610: PUSH
7611: LD_VAR 0 1
7615: STR
7616: PPUSH
7617: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7621: LD_ADDR_EXP 25
7625: PUSH
7626: LD_EXP 25
7630: PUSH
7631: LD_INT 1
7633: PLUS
7634: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7635: LD_EXP 25
7639: PUSH
7640: LD_EXP 26
7644: MOD
7645: PUSH
7646: LD_INT 0
7648: EQUAL
7649: IFFALSE 7660
// AddToLog ( lines_break_type ) ;
7651: LD_EXP 27
7655: PPUSH
7656: CALL_OW 561
// end ;
7660: LD_VAR 0 2
7664: RET
// export function LogHuman ( id ) ; begin
7665: LD_INT 0
7667: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7668: LD_STRING Human Created. id: 
7670: PUSH
7671: LD_VAR 0 1
7675: STR
7676: PUSH
7677: LD_STRING ; side: 
7679: STR
7680: PUSH
7681: LD_VAR 0 1
7685: PPUSH
7686: CALL_OW 255
7690: STR
7691: PUSH
7692: LD_STRING ; class: 
7694: STR
7695: PUSH
7696: LD_VAR 0 1
7700: PPUSH
7701: CALL_OW 257
7705: STR
7706: PUSH
7707: LD_STRING ; 
7709: STR
7710: PPUSH
7711: CALL 7557 0 1
// end ;
7715: LD_VAR 0 2
7719: RET
// export function LogVeh ( id ) ; begin
7720: LD_INT 0
7722: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7723: LD_STRING Vehicle Created. id: 
7725: PUSH
7726: LD_VAR 0 1
7730: STR
7731: PUSH
7732: LD_STRING ; side: 
7734: STR
7735: PUSH
7736: LD_VAR 0 1
7740: PPUSH
7741: CALL_OW 255
7745: STR
7746: PUSH
7747: LD_STRING ; nation: 
7749: STR
7750: PUSH
7751: LD_VAR 0 1
7755: PPUSH
7756: CALL_OW 248
7760: STR
7761: PUSH
7762: LD_STRING ; weapon: 
7764: STR
7765: PUSH
7766: LD_VAR 0 1
7770: PPUSH
7771: CALL_OW 264
7775: STR
7776: PUSH
7777: LD_STRING ; 
7779: STR
7780: PPUSH
7781: CALL 7557 0 1
// end ;
7785: LD_VAR 0 2
7789: RET
// export function LogEvent ( event ) ; begin
7790: LD_INT 0
7792: PPUSH
// Log ( Event Executed. id:  & event ) ;
7793: LD_STRING Event Executed. id: 
7795: PUSH
7796: LD_VAR 0 1
7800: STR
7801: PPUSH
7802: CALL 7557 0 1
// end ; end_of_file
7806: LD_VAR 0 2
7810: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7811: LD_INT 0
7813: PPUSH
7814: PPUSH
7815: PPUSH
7816: PPUSH
7817: PPUSH
7818: PPUSH
7819: PPUSH
7820: PPUSH
// if unit then
7821: LD_VAR 0 1
7825: IFFALSE 8225
// begin if mode = 0 then
7827: LD_VAR 0 3
7831: PUSH
7832: LD_INT 0
7834: EQUAL
7835: IFFALSE 7983
// begin if coords then
7837: LD_VAR 0 2
7841: IFFALSE 7981
// while ( coords > 1 ) do
7843: LD_VAR 0 2
7847: PUSH
7848: LD_INT 1
7850: GREATER
7851: IFFALSE 7981
// if not HasTask ( unit ) then
7853: LD_VAR 0 1
7857: PPUSH
7858: CALL_OW 314
7862: NOT
7863: IFFALSE 7979
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7865: LD_VAR 0 1
7869: PPUSH
7870: LD_VAR 0 2
7874: PUSH
7875: LD_INT 1
7877: ARRAY
7878: PPUSH
7879: LD_VAR 0 2
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7892: LD_INT 35
7894: PPUSH
7895: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7899: LD_VAR 0 1
7903: PPUSH
7904: CALL_OW 250
7908: PUSH
7909: LD_VAR 0 2
7913: PUSH
7914: LD_INT 1
7916: ARRAY
7917: EQUAL
7918: PUSH
7919: LD_VAR 0 1
7923: PPUSH
7924: CALL_OW 251
7928: PUSH
7929: LD_VAR 0 2
7933: PUSH
7934: LD_INT 2
7936: ARRAY
7937: EQUAL
7938: AND
7939: IFFALSE 7892
// for i = 1 to 2 do
7941: LD_ADDR_VAR 0 5
7945: PUSH
7946: DOUBLE
7947: LD_INT 1
7949: DEC
7950: ST_TO_ADDR
7951: LD_INT 2
7953: PUSH
7954: FOR_TO
7955: IFFALSE 7977
// coords := Delete ( coords , 1 ) ;
7957: LD_ADDR_VAR 0 2
7961: PUSH
7962: LD_VAR 0 2
7966: PPUSH
7967: LD_INT 1
7969: PPUSH
7970: CALL_OW 3
7974: ST_TO_ADDR
7975: GO 7954
7977: POP
7978: POP
// end ;
7979: GO 7843
// end else
7981: GO 8225
// begin if coords then
7983: LD_VAR 0 2
7987: IFFALSE 8225
// begin x := GetX ( unit ) ;
7989: LD_ADDR_VAR 0 6
7993: PUSH
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 250
8003: ST_TO_ADDR
// y := GetY ( unit ) ;
8004: LD_ADDR_VAR 0 7
8008: PUSH
8009: LD_VAR 0 1
8013: PPUSH
8014: CALL_OW 251
8018: ST_TO_ADDR
// while ( coords > 1 ) do
8019: LD_VAR 0 2
8023: PUSH
8024: LD_INT 1
8026: GREATER
8027: IFFALSE 8225
// begin Wait ( 0 0$0.3 ) ;
8029: LD_INT 10
8031: PPUSH
8032: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8036: LD_VAR 0 1
8040: PPUSH
8041: CALL_OW 255
8045: PPUSH
8046: LD_VAR 0 1
8050: PPUSH
8051: CALL_OW 250
8055: PPUSH
8056: LD_VAR 0 1
8060: PPUSH
8061: CALL_OW 251
8065: PPUSH
8066: LD_INT 14
8068: PPUSH
8069: CALL 22563 0 4
8073: IFFALSE 8104
// begin ComMoveXY ( unit , x , y ) ;
8075: LD_VAR 0 1
8079: PPUSH
8080: LD_VAR 0 6
8084: PPUSH
8085: LD_VAR 0 7
8089: PPUSH
8090: CALL_OW 111
// result := false ;
8094: LD_ADDR_VAR 0 4
8098: PUSH
8099: LD_INT 0
8101: ST_TO_ADDR
// end else
8102: GO 8143
// if not HasTask ( unit ) then
8104: LD_VAR 0 1
8108: PPUSH
8109: CALL_OW 314
8113: NOT
8114: IFFALSE 8143
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8116: LD_VAR 0 1
8120: PPUSH
8121: LD_VAR 0 2
8125: PUSH
8126: LD_INT 1
8128: ARRAY
8129: PPUSH
8130: LD_VAR 0 2
8134: PUSH
8135: LD_INT 2
8137: ARRAY
8138: PPUSH
8139: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8143: LD_VAR 0 1
8147: PPUSH
8148: CALL_OW 250
8152: PUSH
8153: LD_VAR 0 2
8157: PUSH
8158: LD_INT 1
8160: ARRAY
8161: EQUAL
8162: PUSH
8163: LD_VAR 0 1
8167: PPUSH
8168: CALL_OW 251
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: LD_INT 2
8180: ARRAY
8181: EQUAL
8182: AND
8183: IFFALSE 8223
// for i = 1 to 2 do
8185: LD_ADDR_VAR 0 5
8189: PUSH
8190: DOUBLE
8191: LD_INT 1
8193: DEC
8194: ST_TO_ADDR
8195: LD_INT 2
8197: PUSH
8198: FOR_TO
8199: IFFALSE 8221
// coords := Delete ( coords , 1 ) ;
8201: LD_ADDR_VAR 0 2
8205: PUSH
8206: LD_VAR 0 2
8210: PPUSH
8211: LD_INT 1
8213: PPUSH
8214: CALL_OW 3
8218: ST_TO_ADDR
8219: GO 8198
8221: POP
8222: POP
// end ;
8223: GO 8019
// end ; end ; end ; result := true ;
8225: LD_ADDR_VAR 0 4
8229: PUSH
8230: LD_INT 1
8232: ST_TO_ADDR
// end ;
8233: LD_VAR 0 4
8237: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8243: LD_ADDR_VAR 0 5
8247: PUSH
8248: LD_INT 81
8250: PUSH
8251: LD_VAR 0 1
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: PPUSH
8260: CALL_OW 69
8264: ST_TO_ADDR
// for i in units do
8265: LD_ADDR_VAR 0 4
8269: PUSH
8270: LD_VAR 0 2
8274: PUSH
8275: FOR_IN
8276: IFFALSE 8304
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8278: LD_VAR 0 4
8282: PPUSH
8283: LD_VAR 0 5
8287: PPUSH
8288: LD_VAR 0 4
8292: PPUSH
8293: CALL_OW 74
8297: PPUSH
8298: CALL_OW 115
// end ;
8302: GO 8275
8304: POP
8305: POP
// end ;
8306: LD_VAR 0 3
8310: RET
// export function MC_Show ( string ) ; begin
8311: LD_INT 0
8313: PPUSH
// display_strings := string ;
8314: LD_ADDR_OWVAR 47
8318: PUSH
8319: LD_VAR 0 1
8323: ST_TO_ADDR
// end ; end_of_file
8324: LD_VAR 0 2
8328: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8329: LD_INT 0
8331: PPUSH
8332: PPUSH
8333: PPUSH
8334: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8335: LD_ADDR_VAR 0 8
8339: PUSH
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_INT 2
8347: PPUSH
8348: EMPTY
8349: PPUSH
8350: CALL 11476 0 3
8354: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8355: LD_VAR 0 8
8359: PUSH
8360: LD_VAR 0 2
8364: PPUSH
8365: LD_VAR 0 3
8369: PPUSH
8370: CALL_OW 428
8374: PUSH
8375: LD_INT 0
8377: EQUAL
8378: AND
8379: IFFALSE 8453
// for i = 1 to plist do
8381: LD_ADDR_VAR 0 6
8385: PUSH
8386: DOUBLE
8387: LD_INT 1
8389: DEC
8390: ST_TO_ADDR
8391: LD_VAR 0 8
8395: PUSH
8396: FOR_TO
8397: IFFALSE 8451
// if NotTask ( plist [ i ] ) then
8399: LD_VAR 0 8
8403: PUSH
8404: LD_VAR 0 6
8408: ARRAY
8409: PPUSH
8410: CALL 32200 0 1
8414: IFFALSE 8449
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8416: LD_VAR 0 8
8420: PUSH
8421: LD_VAR 0 6
8425: ARRAY
8426: PPUSH
8427: LD_INT 0
8429: PPUSH
8430: LD_VAR 0 2
8434: PPUSH
8435: LD_VAR 0 3
8439: PPUSH
8440: LD_VAR 0 4
8444: PPUSH
8445: CALL_OW 145
// end ;
8449: GO 8396
8451: POP
8452: POP
// end ;
8453: LD_VAR 0 5
8457: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8458: LD_INT 0
8460: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8461: LD_VAR 0 1
8465: PPUSH
8466: LD_INT 6
8468: PPUSH
8469: LD_VAR 0 2
8473: PPUSH
8474: LD_VAR 0 3
8478: PPUSH
8479: LD_VAR 0 4
8483: PPUSH
8484: CALL 9962 0 5
// end ;
8488: LD_VAR 0 5
8492: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8493: LD_INT 0
8495: PPUSH
8496: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8497: LD_ADDR_VAR 0 4
8501: PUSH
8502: LD_INT 22
8504: PUSH
8505: LD_VAR 0 1
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 2
8516: PUSH
8517: LD_INT 30
8519: PUSH
8520: LD_INT 0
8522: PUSH
8523: EMPTY
8524: LIST
8525: LIST
8526: PUSH
8527: LD_INT 30
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: PUSH
8542: EMPTY
8543: LIST
8544: LIST
8545: PUSH
8546: EMPTY
8547: LIST
8548: PPUSH
8549: CALL_OW 69
8553: PPUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: CALL_OW 250
8563: PPUSH
8564: LD_VAR 0 2
8568: PPUSH
8569: CALL_OW 251
8573: PPUSH
8574: CALL_OW 73
8578: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8579: LD_VAR 0 4
8583: PPUSH
8584: LD_VAR 0 2
8588: PPUSH
8589: CALL 10251 0 2
8593: IFFALSE 8652
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8595: LD_VAR 0 1
8599: PPUSH
8600: LD_INT 30
8602: PUSH
8603: LD_VAR 0 2
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PPUSH
8612: CALL 11393 0 2
8616: PUSH
8617: LD_INT 1
8619: ARRAY
8620: PPUSH
8621: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8625: LD_ADDR_EXP 48
8629: PUSH
8630: LD_EXP 48
8634: PPUSH
8635: LD_VAR 0 1
8639: PPUSH
8640: LD_VAR 0 2
8644: PPUSH
8645: EMPTY
8646: PPUSH
8647: CALL 42234 0 4
8651: ST_TO_ADDR
// end ; end ;
8652: LD_VAR 0 3
8656: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8657: LD_INT 0
8659: PPUSH
8660: PPUSH
8661: PPUSH
8662: PPUSH
8663: PPUSH
8664: PPUSH
// result := false ;
8665: LD_ADDR_VAR 0 4
8669: PUSH
8670: LD_INT 0
8672: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8673: LD_VAR 0 1
8677: PPUSH
8678: LD_EXP 40
8682: PPUSH
8683: CALL 43182 0 2
8687: IFFALSE 8900
// for i = 1 to MREG_LabList do
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: DOUBLE
8695: LD_INT 1
8697: DEC
8698: ST_TO_ADDR
8699: LD_EXP 40
8703: PUSH
8704: FOR_TO
8705: IFFALSE 8898
// begin if MREG_LabList [ i ] [ 1 ] = side then
8707: LD_EXP 40
8711: PUSH
8712: LD_VAR 0 5
8716: ARRAY
8717: PUSH
8718: LD_INT 1
8720: ARRAY
8721: PUSH
8722: LD_VAR 0 1
8726: EQUAL
8727: IFFALSE 8896
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8729: LD_ADDR_VAR 0 7
8733: PUSH
8734: LD_EXP 40
8738: PUSH
8739: LD_VAR 0 5
8743: ARRAY
8744: PUSH
8745: LD_INT 2
8747: ARRAY
8748: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8749: LD_ADDR_VAR 0 9
8753: PUSH
8754: LD_INT 22
8756: PUSH
8757: LD_VAR 0 1
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: PUSH
8766: LD_INT 2
8768: PUSH
8769: LD_INT 30
8771: PUSH
8772: LD_INT 0
8774: PUSH
8775: EMPTY
8776: LIST
8777: LIST
8778: PUSH
8779: LD_INT 30
8781: PUSH
8782: LD_INT 1
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: LIST
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: PUSH
8798: EMPTY
8799: LIST
8800: PPUSH
8801: CALL_OW 69
8805: PPUSH
8806: LD_VAR 0 7
8810: PPUSH
8811: CALL_OW 250
8815: PPUSH
8816: LD_VAR 0 7
8820: PPUSH
8821: CALL_OW 251
8825: PPUSH
8826: CALL_OW 73
8830: ST_TO_ADDR
// if dep then
8831: LD_VAR 0 9
8835: IFFALSE 8894
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8837: LD_VAR 0 9
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_VAR 0 3
8851: PPUSH
8852: CALL 10367 0 3
8856: IFFALSE 8894
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8858: LD_VAR 0 7
8862: PPUSH
8863: LD_VAR 0 2
8867: PPUSH
8868: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8872: LD_VAR 0 7
8876: PPUSH
8877: LD_VAR 0 3
8881: PPUSH
8882: CALL_OW 207
// result := true ;
8886: LD_ADDR_VAR 0 4
8890: PUSH
8891: LD_INT 1
8893: ST_TO_ADDR
// end ; end ; break ;
8894: GO 8898
// end ; end ;
8896: GO 8704
8898: POP
8899: POP
// end ;
8900: LD_VAR 0 4
8904: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8905: LD_INT 0
8907: PPUSH
8908: PPUSH
8909: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8910: LD_ADDR_VAR 0 7
8914: PUSH
8915: LD_VAR 0 2
8919: PPUSH
8920: LD_VAR 0 3
8924: PPUSH
8925: LD_VAR 0 4
8929: PPUSH
8930: CALL 9092 0 3
8934: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8935: LD_ADDR_EXP 46
8939: PUSH
8940: LD_EXP 46
8944: PPUSH
8945: LD_VAR 0 1
8949: PPUSH
8950: LD_INT 2
8952: PPUSH
8953: LD_VAR 0 2
8957: PUSH
8958: LD_VAR 0 3
8962: PUSH
8963: LD_VAR 0 4
8967: PUSH
8968: EMPTY
8969: LIST
8970: LIST
8971: LIST
8972: PPUSH
8973: CALL 42143 0 4
8977: ST_TO_ADDR
// if ext_list then
8978: LD_VAR 0 5
8982: IFFALSE 9087
// for i = 1 to ext_list do
8984: LD_ADDR_VAR 0 8
8988: PUSH
8989: DOUBLE
8990: LD_INT 1
8992: DEC
8993: ST_TO_ADDR
8994: LD_VAR 0 5
8998: PUSH
8999: FOR_TO
9000: IFFALSE 9085
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9002: LD_ADDR_EXP 46
9006: PUSH
9007: LD_EXP 46
9011: PPUSH
9012: LD_VAR 0 1
9016: PPUSH
9017: LD_VAR 0 5
9021: PUSH
9022: LD_VAR 0 8
9026: ARRAY
9027: PPUSH
9028: LD_VAR 0 7
9032: PUSH
9033: LD_VAR 0 8
9037: ARRAY
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PUSH
9043: LD_VAR 0 7
9047: PUSH
9048: LD_VAR 0 8
9052: ARRAY
9053: PUSH
9054: LD_INT 2
9056: ARRAY
9057: PUSH
9058: LD_VAR 0 7
9062: PUSH
9063: LD_VAR 0 8
9067: ARRAY
9068: PUSH
9069: LD_INT 3
9071: ARRAY
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: LIST
9077: PPUSH
9078: CALL 42143 0 4
9082: ST_TO_ADDR
9083: GO 8999
9085: POP
9086: POP
// end ;
9087: LD_VAR 0 6
9091: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9092: LD_INT 0
9094: PPUSH
9095: PPUSH
// list := [ ] ;
9096: LD_ADDR_VAR 0 5
9100: PUSH
9101: EMPTY
9102: ST_TO_ADDR
// case d of 0 :
9103: LD_VAR 0 3
9107: PUSH
9108: LD_INT 0
9110: DOUBLE
9111: EQUAL
9112: IFTRUE 9116
9114: GO 9249
9116: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9117: LD_ADDR_VAR 0 5
9121: PUSH
9122: LD_VAR 0 1
9126: PUSH
9127: LD_INT 4
9129: MINUS
9130: PUSH
9131: LD_VAR 0 2
9135: PUSH
9136: LD_INT 4
9138: MINUS
9139: PUSH
9140: LD_INT 2
9142: PUSH
9143: EMPTY
9144: LIST
9145: LIST
9146: LIST
9147: PUSH
9148: LD_VAR 0 1
9152: PUSH
9153: LD_INT 3
9155: MINUS
9156: PUSH
9157: LD_VAR 0 2
9161: PUSH
9162: LD_INT 1
9164: PUSH
9165: EMPTY
9166: LIST
9167: LIST
9168: LIST
9169: PUSH
9170: LD_VAR 0 1
9174: PUSH
9175: LD_INT 4
9177: PLUS
9178: PUSH
9179: LD_VAR 0 2
9183: PUSH
9184: LD_INT 4
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: LIST
9191: PUSH
9192: LD_VAR 0 1
9196: PUSH
9197: LD_INT 3
9199: PLUS
9200: PUSH
9201: LD_VAR 0 2
9205: PUSH
9206: LD_INT 3
9208: PLUS
9209: PUSH
9210: LD_INT 5
9212: PUSH
9213: EMPTY
9214: LIST
9215: LIST
9216: LIST
9217: PUSH
9218: LD_VAR 0 1
9222: PUSH
9223: LD_VAR 0 2
9227: PUSH
9228: LD_INT 4
9230: PLUS
9231: PUSH
9232: LD_INT 0
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: LIST
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: ST_TO_ADDR
// end ; 1 :
9247: GO 9947
9249: LD_INT 1
9251: DOUBLE
9252: EQUAL
9253: IFTRUE 9257
9255: GO 9390
9257: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9258: LD_ADDR_VAR 0 5
9262: PUSH
9263: LD_VAR 0 1
9267: PUSH
9268: LD_VAR 0 2
9272: PUSH
9273: LD_INT 4
9275: MINUS
9276: PUSH
9277: LD_INT 3
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: LIST
9284: PUSH
9285: LD_VAR 0 1
9289: PUSH
9290: LD_INT 3
9292: MINUS
9293: PUSH
9294: LD_VAR 0 2
9298: PUSH
9299: LD_INT 3
9301: MINUS
9302: PUSH
9303: LD_INT 2
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: LIST
9310: PUSH
9311: LD_VAR 0 1
9315: PUSH
9316: LD_INT 4
9318: MINUS
9319: PUSH
9320: LD_VAR 0 2
9324: PUSH
9325: LD_INT 1
9327: PUSH
9328: EMPTY
9329: LIST
9330: LIST
9331: LIST
9332: PUSH
9333: LD_VAR 0 1
9337: PUSH
9338: LD_VAR 0 2
9342: PUSH
9343: LD_INT 3
9345: PLUS
9346: PUSH
9347: LD_INT 0
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: LIST
9354: PUSH
9355: LD_VAR 0 1
9359: PUSH
9360: LD_INT 4
9362: PLUS
9363: PUSH
9364: LD_VAR 0 2
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_INT 5
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: LIST
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: ST_TO_ADDR
// end ; 2 :
9388: GO 9947
9390: LD_INT 2
9392: DOUBLE
9393: EQUAL
9394: IFTRUE 9398
9396: GO 9527
9398: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9399: LD_ADDR_VAR 0 5
9403: PUSH
9404: LD_VAR 0 1
9408: PUSH
9409: LD_VAR 0 2
9413: PUSH
9414: LD_INT 3
9416: MINUS
9417: PUSH
9418: LD_INT 3
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: LIST
9425: PUSH
9426: LD_VAR 0 1
9430: PUSH
9431: LD_INT 4
9433: PLUS
9434: PUSH
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 4
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: LIST
9447: PUSH
9448: LD_VAR 0 1
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PLUS
9461: PUSH
9462: LD_INT 0
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: LIST
9469: PUSH
9470: LD_VAR 0 1
9474: PUSH
9475: LD_INT 3
9477: MINUS
9478: PUSH
9479: LD_VAR 0 2
9483: PUSH
9484: LD_INT 1
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_INT 4
9499: MINUS
9500: PUSH
9501: LD_VAR 0 2
9505: PUSH
9506: LD_INT 4
9508: MINUS
9509: PUSH
9510: LD_INT 2
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: ST_TO_ADDR
// end ; 3 :
9525: GO 9947
9527: LD_INT 3
9529: DOUBLE
9530: EQUAL
9531: IFTRUE 9535
9533: GO 9668
9535: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9536: LD_ADDR_VAR 0 5
9540: PUSH
9541: LD_VAR 0 1
9545: PUSH
9546: LD_INT 3
9548: PLUS
9549: PUSH
9550: LD_VAR 0 2
9554: PUSH
9555: LD_INT 4
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: PUSH
9563: LD_VAR 0 1
9567: PUSH
9568: LD_INT 4
9570: PLUS
9571: PUSH
9572: LD_VAR 0 2
9576: PUSH
9577: LD_INT 4
9579: PLUS
9580: PUSH
9581: LD_INT 5
9583: PUSH
9584: EMPTY
9585: LIST
9586: LIST
9587: LIST
9588: PUSH
9589: LD_VAR 0 1
9593: PUSH
9594: LD_INT 4
9596: MINUS
9597: PUSH
9598: LD_VAR 0 2
9602: PUSH
9603: LD_INT 1
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_VAR 0 1
9615: PUSH
9616: LD_VAR 0 2
9620: PUSH
9621: LD_INT 4
9623: MINUS
9624: PUSH
9625: LD_INT 3
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: PUSH
9633: LD_VAR 0 1
9637: PUSH
9638: LD_INT 3
9640: MINUS
9641: PUSH
9642: LD_VAR 0 2
9646: PUSH
9647: LD_INT 3
9649: MINUS
9650: PUSH
9651: LD_INT 2
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: LIST
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: LIST
9665: ST_TO_ADDR
// end ; 4 :
9666: GO 9947
9668: LD_INT 4
9670: DOUBLE
9671: EQUAL
9672: IFTRUE 9676
9674: GO 9809
9676: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9677: LD_ADDR_VAR 0 5
9681: PUSH
9682: LD_VAR 0 1
9686: PUSH
9687: LD_VAR 0 2
9691: PUSH
9692: LD_INT 4
9694: PLUS
9695: PUSH
9696: LD_INT 0
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: LIST
9703: PUSH
9704: LD_VAR 0 1
9708: PUSH
9709: LD_INT 3
9711: PLUS
9712: PUSH
9713: LD_VAR 0 2
9717: PUSH
9718: LD_INT 3
9720: PLUS
9721: PUSH
9722: LD_INT 5
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: LIST
9729: PUSH
9730: LD_VAR 0 1
9734: PUSH
9735: LD_INT 3
9737: PLUS
9738: PUSH
9739: LD_VAR 0 2
9743: PUSH
9744: LD_INT 4
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: PUSH
9752: LD_VAR 0 1
9756: PUSH
9757: LD_VAR 0 2
9761: PUSH
9762: LD_INT 3
9764: MINUS
9765: PUSH
9766: LD_INT 3
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: LIST
9773: PUSH
9774: LD_VAR 0 1
9778: PUSH
9779: LD_INT 4
9781: MINUS
9782: PUSH
9783: LD_VAR 0 2
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_INT 2
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: ST_TO_ADDR
// end ; 5 :
9807: GO 9947
9809: LD_INT 5
9811: DOUBLE
9812: EQUAL
9813: IFTRUE 9817
9815: GO 9946
9817: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9818: LD_ADDR_VAR 0 5
9822: PUSH
9823: LD_VAR 0 1
9827: PUSH
9828: LD_INT 4
9830: MINUS
9831: PUSH
9832: LD_VAR 0 2
9836: PUSH
9837: LD_INT 1
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: LD_VAR 0 1
9849: PUSH
9850: LD_VAR 0 2
9854: PUSH
9855: LD_INT 4
9857: MINUS
9858: PUSH
9859: LD_INT 3
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: LIST
9866: PUSH
9867: LD_VAR 0 1
9871: PUSH
9872: LD_INT 4
9874: PLUS
9875: PUSH
9876: LD_VAR 0 2
9880: PUSH
9881: LD_INT 4
9883: PLUS
9884: PUSH
9885: LD_INT 5
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: LIST
9892: PUSH
9893: LD_VAR 0 1
9897: PUSH
9898: LD_INT 3
9900: PLUS
9901: PUSH
9902: LD_VAR 0 2
9906: PUSH
9907: LD_INT 4
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: LIST
9914: PUSH
9915: LD_VAR 0 1
9919: PUSH
9920: LD_VAR 0 2
9924: PUSH
9925: LD_INT 3
9927: PLUS
9928: PUSH
9929: LD_INT 0
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: LIST
9936: PUSH
9937: EMPTY
9938: LIST
9939: LIST
9940: LIST
9941: LIST
9942: LIST
9943: ST_TO_ADDR
// end ; end ;
9944: GO 9947
9946: POP
// result := list ;
9947: LD_ADDR_VAR 0 4
9951: PUSH
9952: LD_VAR 0 5
9956: ST_TO_ADDR
// end ;
9957: LD_VAR 0 4
9961: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9962: LD_INT 0
9964: PPUSH
9965: PPUSH
9966: PPUSH
9967: PPUSH
9968: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9969: LD_ADDR_VAR 0 10
9973: PUSH
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 2
9981: PPUSH
9982: EMPTY
9983: PPUSH
9984: CALL 11476 0 3
9988: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
9989: LD_ADDR_VAR 0 9
9993: PUSH
9994: LD_INT 22
9996: PUSH
9997: LD_VAR 0 1
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 2
10008: PUSH
10009: LD_INT 30
10011: PUSH
10012: LD_INT 0
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: LD_INT 30
10021: PUSH
10022: LD_INT 1
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: LIST
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: PUSH
10038: EMPTY
10039: LIST
10040: PPUSH
10041: CALL_OW 69
10045: PPUSH
10046: LD_VAR 0 3
10050: PPUSH
10051: LD_VAR 0 4
10055: PPUSH
10056: CALL_OW 73
10060: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10061: LD_ADDR_VAR 0 8
10065: PUSH
10066: LD_VAR 0 9
10070: PPUSH
10071: LD_VAR 0 2
10075: PPUSH
10076: CALL 10251 0 2
10080: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10081: LD_VAR 0 10
10085: PUSH
10086: LD_VAR 0 8
10090: AND
10091: PUSH
10092: LD_VAR 0 9
10096: PPUSH
10097: LD_VAR 0 3
10101: PPUSH
10102: LD_VAR 0 4
10106: PPUSH
10107: CALL_OW 297
10111: PUSH
10112: LD_INT 26
10114: LESSEQUAL
10115: AND
10116: PUSH
10117: LD_VAR 0 3
10121: PPUSH
10122: LD_VAR 0 4
10126: PPUSH
10127: CALL_OW 428
10131: PUSH
10132: LD_INT 0
10134: EQUAL
10135: AND
10136: IFFALSE 10246
// for i = 1 to plist do
10138: LD_ADDR_VAR 0 7
10142: PUSH
10143: DOUBLE
10144: LD_INT 1
10146: DEC
10147: ST_TO_ADDR
10148: LD_VAR 0 10
10152: PUSH
10153: FOR_TO
10154: IFFALSE 10244
// if IsInUnit ( plist [ i ] ) then
10156: LD_VAR 0 10
10160: PUSH
10161: LD_VAR 0 7
10165: ARRAY
10166: PPUSH
10167: CALL_OW 310
10171: IFFALSE 10190
// ComExitBuilding ( plist [ i ] ) else
10173: LD_VAR 0 10
10177: PUSH
10178: LD_VAR 0 7
10182: ARRAY
10183: PPUSH
10184: CALL_OW 122
10188: GO 10242
// if NotTask ( plist [ i ] ) then
10190: LD_VAR 0 10
10194: PUSH
10195: LD_VAR 0 7
10199: ARRAY
10200: PPUSH
10201: CALL 32200 0 1
10205: IFFALSE 10242
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10207: LD_VAR 0 10
10211: PUSH
10212: LD_VAR 0 7
10216: ARRAY
10217: PPUSH
10218: LD_VAR 0 2
10222: PPUSH
10223: LD_VAR 0 3
10227: PPUSH
10228: LD_VAR 0 4
10232: PPUSH
10233: LD_VAR 0 5
10237: PPUSH
10238: CALL_OW 145
// end ;
10242: GO 10153
10244: POP
10245: POP
// end ;
10246: LD_VAR 0 6
10250: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10251: LD_INT 0
10253: PPUSH
10254: PPUSH
10255: PPUSH
// pom := GetBase ( bdepot ) ;
10256: LD_ADDR_VAR 0 4
10260: PUSH
10261: LD_VAR 0 1
10265: PPUSH
10266: CALL_OW 274
10270: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10271: LD_ADDR_VAR 0 5
10275: PUSH
10276: LD_VAR 0 2
10280: PPUSH
10281: LD_VAR 0 1
10285: PPUSH
10286: CALL_OW 248
10290: PPUSH
10291: CALL_OW 450
10295: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10296: LD_VAR 0 4
10300: PPUSH
10301: LD_INT 1
10303: PPUSH
10304: CALL_OW 275
10308: PUSH
10309: LD_VAR 0 5
10313: PUSH
10314: LD_INT 1
10316: ARRAY
10317: GREATEREQUAL
10318: PUSH
10319: LD_VAR 0 4
10323: PPUSH
10324: LD_INT 3
10326: PPUSH
10327: CALL_OW 275
10331: PUSH
10332: LD_VAR 0 5
10336: PUSH
10337: LD_INT 3
10339: ARRAY
10340: GREATEREQUAL
10341: AND
10342: IFFALSE 10354
// result := true else
10344: LD_ADDR_VAR 0 3
10348: PUSH
10349: LD_INT 1
10351: ST_TO_ADDR
10352: GO 10362
// result := false ;
10354: LD_ADDR_VAR 0 3
10358: PUSH
10359: LD_INT 0
10361: ST_TO_ADDR
// end ;
10362: LD_VAR 0 3
10366: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10367: LD_INT 0
10369: PPUSH
10370: PPUSH
10371: PPUSH
10372: PPUSH
10373: PPUSH
// pom := GetBase ( bdepot ) ;
10374: LD_ADDR_VAR 0 5
10378: PUSH
10379: LD_VAR 0 1
10383: PPUSH
10384: CALL_OW 274
10388: ST_TO_ADDR
// cost := [ ] ;
10389: LD_ADDR_VAR 0 8
10393: PUSH
10394: EMPTY
10395: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10396: LD_ADDR_VAR 0 6
10400: PUSH
10401: LD_VAR 0 2
10405: PPUSH
10406: LD_VAR 0 1
10410: PPUSH
10411: CALL_OW 248
10415: PPUSH
10416: CALL_OW 450
10420: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10421: LD_ADDR_VAR 0 7
10425: PUSH
10426: LD_VAR 0 3
10430: PPUSH
10431: LD_VAR 0 1
10435: PPUSH
10436: CALL_OW 248
10440: PPUSH
10441: CALL_OW 450
10445: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10446: LD_ADDR_VAR 0 8
10450: PUSH
10451: LD_VAR 0 8
10455: PPUSH
10456: LD_INT 1
10458: PPUSH
10459: LD_VAR 0 6
10463: PUSH
10464: LD_INT 1
10466: ARRAY
10467: PUSH
10468: LD_VAR 0 7
10472: PUSH
10473: LD_INT 1
10475: ARRAY
10476: PLUS
10477: PPUSH
10478: CALL_OW 1
10482: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10483: LD_ADDR_VAR 0 8
10487: PUSH
10488: LD_VAR 0 8
10492: PPUSH
10493: LD_INT 2
10495: PPUSH
10496: LD_VAR 0 6
10500: PUSH
10501: LD_INT 2
10503: ARRAY
10504: PUSH
10505: LD_VAR 0 7
10509: PUSH
10510: LD_INT 2
10512: ARRAY
10513: PLUS
10514: PPUSH
10515: CALL_OW 1
10519: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10520: LD_ADDR_VAR 0 8
10524: PUSH
10525: LD_VAR 0 8
10529: PPUSH
10530: LD_INT 3
10532: PPUSH
10533: LD_VAR 0 6
10537: PUSH
10538: LD_INT 3
10540: ARRAY
10541: PUSH
10542: LD_VAR 0 7
10546: PUSH
10547: LD_INT 3
10549: ARRAY
10550: PLUS
10551: PPUSH
10552: CALL_OW 1
10556: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10557: LD_VAR 0 5
10561: PPUSH
10562: LD_INT 1
10564: PPUSH
10565: CALL_OW 275
10569: PUSH
10570: LD_VAR 0 8
10574: PUSH
10575: LD_INT 1
10577: ARRAY
10578: GREATEREQUAL
10579: PUSH
10580: LD_VAR 0 5
10584: PPUSH
10585: LD_INT 3
10587: PPUSH
10588: CALL_OW 275
10592: PUSH
10593: LD_VAR 0 8
10597: PUSH
10598: LD_INT 3
10600: ARRAY
10601: GREATEREQUAL
10602: AND
10603: IFFALSE 10615
// result := true else
10605: LD_ADDR_VAR 0 4
10609: PUSH
10610: LD_INT 1
10612: ST_TO_ADDR
10613: GO 10623
// result := false ;
10615: LD_ADDR_VAR 0 4
10619: PUSH
10620: LD_INT 0
10622: ST_TO_ADDR
// end ;
10623: LD_VAR 0 4
10627: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10628: LD_INT 0
10630: PPUSH
10631: PPUSH
10632: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10633: LD_ADDR_VAR 0 5
10637: PUSH
10638: LD_VAR 0 1
10642: PPUSH
10643: LD_INT 2
10645: PPUSH
10646: EMPTY
10647: PPUSH
10648: CALL 11476 0 3
10652: ST_TO_ADDR
// if unit and plist then
10653: LD_VAR 0 2
10657: PUSH
10658: LD_VAR 0 5
10662: AND
10663: IFFALSE 10724
// for i = 1 to plist do
10665: LD_ADDR_VAR 0 4
10669: PUSH
10670: DOUBLE
10671: LD_INT 1
10673: DEC
10674: ST_TO_ADDR
10675: LD_VAR 0 5
10679: PUSH
10680: FOR_TO
10681: IFFALSE 10722
// if NotTask ( plist [ i ] ) then
10683: LD_VAR 0 5
10687: PUSH
10688: LD_VAR 0 4
10692: ARRAY
10693: PPUSH
10694: CALL 32200 0 1
10698: IFFALSE 10720
// ComDismantle ( plist [ i ] , unit ) ;
10700: LD_VAR 0 5
10704: PUSH
10705: LD_VAR 0 4
10709: ARRAY
10710: PPUSH
10711: LD_VAR 0 2
10715: PPUSH
10716: CALL_OW 167
10720: GO 10680
10722: POP
10723: POP
// result := true ;
10724: LD_ADDR_VAR 0 3
10728: PUSH
10729: LD_INT 1
10731: ST_TO_ADDR
// end ;
10732: LD_VAR 0 3
10736: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10737: LD_INT 0
10739: PPUSH
10740: PPUSH
10741: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10742: LD_ADDR_VAR 0 5
10746: PUSH
10747: LD_VAR 0 1
10751: PPUSH
10752: LD_INT 2
10754: PPUSH
10755: EMPTY
10756: PPUSH
10757: CALL 11476 0 3
10761: ST_TO_ADDR
// if unit and plist then
10762: LD_VAR 0 2
10766: PUSH
10767: LD_VAR 0 5
10771: AND
10772: IFFALSE 10833
// for i = 1 to plist do
10774: LD_ADDR_VAR 0 4
10778: PUSH
10779: DOUBLE
10780: LD_INT 1
10782: DEC
10783: ST_TO_ADDR
10784: LD_VAR 0 5
10788: PUSH
10789: FOR_TO
10790: IFFALSE 10831
// if NotTask ( plist [ i ] ) then
10792: LD_VAR 0 5
10796: PUSH
10797: LD_VAR 0 4
10801: ARRAY
10802: PPUSH
10803: CALL 32200 0 1
10807: IFFALSE 10829
// ComComplete ( plist [ i ] , unit ) ;
10809: LD_VAR 0 5
10813: PUSH
10814: LD_VAR 0 4
10818: ARRAY
10819: PPUSH
10820: LD_VAR 0 2
10824: PPUSH
10825: CALL 31736 0 2
10829: GO 10789
10831: POP
10832: POP
// result := true ;
10833: LD_ADDR_VAR 0 3
10837: PUSH
10838: LD_INT 1
10840: ST_TO_ADDR
// end ;
10841: LD_VAR 0 3
10845: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10846: LD_INT 0
10848: PPUSH
10849: PPUSH
10850: PPUSH
10851: PPUSH
10852: PPUSH
10853: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10854: LD_ADDR_VAR 0 5
10858: PUSH
10859: LD_INT 22
10861: PUSH
10862: LD_VAR 0 1
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 21
10873: PUSH
10874: LD_INT 3
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PUSH
10881: LD_INT 3
10883: PUSH
10884: LD_INT 57
10886: PUSH
10887: EMPTY
10888: LIST
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PUSH
10894: LD_INT 3
10896: PUSH
10897: LD_INT 24
10899: PUSH
10900: LD_INT 1000
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: LIST
10915: LIST
10916: PPUSH
10917: CALL_OW 69
10921: ST_TO_ADDR
// r := [ ] ;
10922: LD_ADDR_VAR 0 6
10926: PUSH
10927: EMPTY
10928: ST_TO_ADDR
// if not tmp then
10929: LD_VAR 0 5
10933: NOT
10934: IFFALSE 10940
// exit else
10936: GO 11128
10938: GO 11108
// begin r := [ tmp [ 1 ] ] ;
10940: LD_ADDR_VAR 0 6
10944: PUSH
10945: LD_VAR 0 5
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PUSH
10954: EMPTY
10955: LIST
10956: ST_TO_ADDR
// for i = 2 to tmp do
10957: LD_ADDR_VAR 0 3
10961: PUSH
10962: DOUBLE
10963: LD_INT 2
10965: DEC
10966: ST_TO_ADDR
10967: LD_VAR 0 5
10971: PUSH
10972: FOR_TO
10973: IFFALSE 11106
// begin m := false ;
10975: LD_ADDR_VAR 0 7
10979: PUSH
10980: LD_INT 0
10982: ST_TO_ADDR
// for j = 1 to r do
10983: LD_ADDR_VAR 0 4
10987: PUSH
10988: DOUBLE
10989: LD_INT 1
10991: DEC
10992: ST_TO_ADDR
10993: LD_VAR 0 6
10997: PUSH
10998: FOR_TO
10999: IFFALSE 11073
// if GetLives ( tmp [ i ] ) < r [ j ] then
11001: LD_VAR 0 5
11005: PUSH
11006: LD_VAR 0 3
11010: ARRAY
11011: PPUSH
11012: CALL_OW 256
11016: PUSH
11017: LD_VAR 0 6
11021: PUSH
11022: LD_VAR 0 4
11026: ARRAY
11027: LESS
11028: IFFALSE 11071
// begin r := Insert ( r , j , tmp [ i ] ) ;
11030: LD_ADDR_VAR 0 6
11034: PUSH
11035: LD_VAR 0 6
11039: PPUSH
11040: LD_VAR 0 4
11044: PPUSH
11045: LD_VAR 0 5
11049: PUSH
11050: LD_VAR 0 3
11054: ARRAY
11055: PPUSH
11056: CALL_OW 2
11060: ST_TO_ADDR
// m := true ;
11061: LD_ADDR_VAR 0 7
11065: PUSH
11066: LD_INT 1
11068: ST_TO_ADDR
// break ;
11069: GO 11073
// end ;
11071: GO 10998
11073: POP
11074: POP
// if not m then
11075: LD_VAR 0 7
11079: NOT
11080: IFFALSE 11104
// r := r ^ tmp [ i ] ;
11082: LD_ADDR_VAR 0 6
11086: PUSH
11087: LD_VAR 0 6
11091: PUSH
11092: LD_VAR 0 5
11096: PUSH
11097: LD_VAR 0 3
11101: ARRAY
11102: ADD
11103: ST_TO_ADDR
// end ;
11104: GO 10972
11106: POP
11107: POP
// end ; if r then
11108: LD_VAR 0 6
11112: IFFALSE 11126
// result := r else
11114: LD_ADDR_VAR 0 2
11118: PUSH
11119: LD_VAR 0 6
11123: ST_TO_ADDR
11124: GO 11128
// exit ;
11126: GO 11128
// end ;
11128: LD_VAR 0 2
11132: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11133: LD_INT 0
11135: PPUSH
11136: PPUSH
11137: PPUSH
11138: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11139: LD_ADDR_VAR 0 5
11143: PUSH
11144: LD_INT 22
11146: PUSH
11147: LD_VAR 0 1
11151: PUSH
11152: EMPTY
11153: LIST
11154: LIST
11155: PUSH
11156: LD_INT 2
11158: PUSH
11159: LD_INT 25
11161: PUSH
11162: LD_INT 2
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: LD_INT 25
11171: PUSH
11172: LD_INT 16
11174: PUSH
11175: EMPTY
11176: LIST
11177: LIST
11178: PUSH
11179: LD_INT 34
11181: PUSH
11182: LD_INT 13
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PUSH
11189: LD_INT 34
11191: PUSH
11192: LD_INT 52
11194: PUSH
11195: EMPTY
11196: LIST
11197: LIST
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: LIST
11203: LIST
11204: LIST
11205: PUSH
11206: LD_INT 24
11208: PUSH
11209: LD_INT 650
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: LIST
11220: PPUSH
11221: CALL_OW 69
11225: ST_TO_ADDR
// p := 1 ;
11226: LD_ADDR_VAR 0 4
11230: PUSH
11231: LD_INT 1
11233: ST_TO_ADDR
// for i = 1 to repairs do
11234: LD_ADDR_VAR 0 3
11238: PUSH
11239: DOUBLE
11240: LD_INT 1
11242: DEC
11243: ST_TO_ADDR
11244: LD_VAR 0 5
11248: PUSH
11249: FOR_TO
11250: IFFALSE 11386
// begin if IsInUnit ( repairs [ i ] ) then
11252: LD_VAR 0 5
11256: PUSH
11257: LD_VAR 0 3
11261: ARRAY
11262: PPUSH
11263: CALL_OW 310
11267: IFFALSE 11286
// ComExitBuilding ( repairs [ i ] ) else
11269: LD_VAR 0 5
11273: PUSH
11274: LD_VAR 0 3
11278: ARRAY
11279: PPUSH
11280: CALL_OW 122
11284: GO 11384
// if not HasTask ( repairs [ i ] ) then
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: PPUSH
11297: CALL_OW 314
11301: NOT
11302: IFFALSE 11384
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11304: LD_VAR 0 5
11308: PUSH
11309: LD_VAR 0 3
11313: ARRAY
11314: PPUSH
11315: LD_EXP 47
11319: PUSH
11320: LD_VAR 0 1
11324: ARRAY
11325: PUSH
11326: LD_VAR 0 4
11330: ARRAY
11331: PPUSH
11332: CALL_OW 130
// if i mod 3 = 0 then
11336: LD_VAR 0 3
11340: PUSH
11341: LD_INT 3
11343: MOD
11344: PUSH
11345: LD_INT 0
11347: EQUAL
11348: IFFALSE 11364
// p := p + 1 ;
11350: LD_ADDR_VAR 0 4
11354: PUSH
11355: LD_VAR 0 4
11359: PUSH
11360: LD_INT 1
11362: PLUS
11363: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11364: LD_EXP 47
11368: PUSH
11369: LD_VAR 0 1
11373: ARRAY
11374: PUSH
11375: LD_VAR 0 4
11379: LESS
11380: IFFALSE 11384
// break ;
11382: GO 11386
// end ; end ;
11384: GO 11249
11386: POP
11387: POP
// end ; end_of_file
11388: LD_VAR 0 2
11392: RET
// export function MCF_Get ( side , filter ) ; begin
11393: LD_INT 0
11395: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11396: LD_ADDR_VAR 0 3
11400: PUSH
11401: LD_INT 22
11403: PUSH
11404: LD_VAR 0 1
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: PUSH
11413: LD_VAR 0 2
11417: PUSH
11418: EMPTY
11419: LIST
11420: LIST
11421: PPUSH
11422: CALL_OW 69
11426: ST_TO_ADDR
// end ;
11427: LD_VAR 0 3
11431: RET
// export function MCF_Lab ( side ) ; begin
11432: LD_INT 0
11434: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11435: LD_ADDR_VAR 0 2
11439: PUSH
11440: LD_INT 22
11442: PUSH
11443: LD_VAR 0 1
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: PUSH
11452: LD_INT 30
11454: PUSH
11455: LD_INT 8
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: PUSH
11462: EMPTY
11463: LIST
11464: LIST
11465: PPUSH
11466: CALL_OW 69
11470: ST_TO_ADDR
// end ;
11471: LD_VAR 0 2
11475: RET
// export function MCF_Class ( side , class , filter ) ; begin
11476: LD_INT 0
11478: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11479: LD_ADDR_VAR 0 4
11483: PUSH
11484: LD_INT 22
11486: PUSH
11487: LD_VAR 0 1
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 25
11498: PUSH
11499: LD_VAR 0 2
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: LD_VAR 0 3
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: LIST
11517: PPUSH
11518: CALL_OW 69
11522: ST_TO_ADDR
// end ;
11523: LD_VAR 0 4
11527: RET
// export function MCF_All ( side , filter ) ; begin
11528: LD_INT 0
11530: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11531: LD_ADDR_VAR 0 3
11535: PUSH
11536: LD_INT 22
11538: PUSH
11539: LD_VAR 0 1
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 2
11550: PUSH
11551: LD_INT 25
11553: PUSH
11554: LD_INT 1
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: PUSH
11561: LD_INT 25
11563: PUSH
11564: LD_INT 2
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 25
11573: PUSH
11574: LD_INT 3
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PUSH
11581: LD_INT 25
11583: PUSH
11584: LD_INT 4
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: PUSH
11598: LD_VAR 0 2
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: LIST
11607: PPUSH
11608: CALL_OW 69
11612: ST_TO_ADDR
// end ;
11613: LD_VAR 0 3
11617: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11618: LD_INT 0
11620: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11621: LD_ADDR_VAR 0 4
11625: PUSH
11626: LD_INT 22
11628: PUSH
11629: LD_VAR 0 1
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: LD_INT 92
11640: PUSH
11641: LD_VAR 0 2
11645: PUSH
11646: LD_INT 1
11648: ARRAY
11649: PUSH
11650: LD_VAR 0 2
11654: PUSH
11655: LD_INT 2
11657: ARRAY
11658: PUSH
11659: LD_VAR 0 2
11663: PUSH
11664: LD_INT 3
11666: ARRAY
11667: PUSH
11668: EMPTY
11669: LIST
11670: LIST
11671: LIST
11672: LIST
11673: PUSH
11674: LD_VAR 0 3
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: PPUSH
11684: CALL_OW 69
11688: ST_TO_ADDR
// end ;
11689: LD_VAR 0 4
11693: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11694: LD_INT 0
11696: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11697: LD_ADDR_VAR 0 3
11701: PUSH
11702: LD_INT 22
11704: PUSH
11705: LD_VAR 0 1
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: LD_INT 21
11716: PUSH
11717: LD_INT 2
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: LD_VAR 0 2
11728: PUSH
11729: EMPTY
11730: LIST
11731: LIST
11732: LIST
11733: PPUSH
11734: CALL_OW 69
11738: ST_TO_ADDR
// end ;
11739: LD_VAR 0 3
11743: RET
// export function MCF_Cargo ( side ) ; begin
11744: LD_INT 0
11746: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11747: LD_ADDR_VAR 0 2
11751: PUSH
11752: LD_VAR 0 1
11756: PPUSH
11757: LD_INT 2
11759: PUSH
11760: LD_INT 34
11762: PUSH
11763: LD_INT 12
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 34
11772: PUSH
11773: LD_INT 32
11775: PUSH
11776: EMPTY
11777: LIST
11778: LIST
11779: PUSH
11780: LD_INT 34
11782: PUSH
11783: LD_INT 51
11785: PUSH
11786: EMPTY
11787: LIST
11788: LIST
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: PPUSH
11796: CALL 11694 0 2
11800: ST_TO_ADDR
// end ;
11801: LD_VAR 0 2
11805: RET
// export function MCF_Ape ( side ) ; begin
11806: LD_INT 0
11808: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11809: LD_ADDR_VAR 0 2
11813: PUSH
11814: LD_INT 22
11816: PUSH
11817: LD_VAR 0 1
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: PUSH
11826: LD_INT 2
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 12
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 15
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 25
11851: PUSH
11852: LD_INT 16
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: LD_INT 25
11861: PUSH
11862: LD_INT 17
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PPUSH
11880: CALL_OW 69
11884: ST_TO_ADDR
// end ;
11885: LD_VAR 0 2
11889: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11890: LD_INT 0
11892: PPUSH
11893: PPUSH
11894: PPUSH
11895: PPUSH
// result := [ ] ;
11896: LD_ADDR_VAR 0 3
11900: PUSH
11901: EMPTY
11902: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11903: LD_ADDR_VAR 0 4
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL 11806 0 1
11917: ST_TO_ADDR
// case type of 0 , normal :
11918: LD_VAR 0 2
11922: PUSH
11923: LD_INT 0
11925: DOUBLE
11926: EQUAL
11927: IFTRUE 11937
11929: LD_STRING normal
11931: DOUBLE
11932: EQUAL
11933: IFTRUE 11937
11935: GO 11948
11937: POP
// cl := class_apeman ; 1 , soldier :
11938: LD_ADDR_VAR 0 5
11942: PUSH
11943: LD_INT 12
11945: ST_TO_ADDR
11946: GO 12024
11948: LD_INT 1
11950: DOUBLE
11951: EQUAL
11952: IFTRUE 11962
11954: LD_STRING soldier
11956: DOUBLE
11957: EQUAL
11958: IFTRUE 11962
11960: GO 11973
11962: POP
// cl := class_apeman_soldier ; 2 , engineer :
11963: LD_ADDR_VAR 0 5
11967: PUSH
11968: LD_INT 15
11970: ST_TO_ADDR
11971: GO 12024
11973: LD_INT 2
11975: DOUBLE
11976: EQUAL
11977: IFTRUE 11987
11979: LD_STRING engineer
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
11988: LD_ADDR_VAR 0 5
11992: PUSH
11993: LD_INT 16
11995: ST_TO_ADDR
11996: GO 12024
11998: LD_INT 3
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12012
12004: LD_STRING kamikaze
12006: DOUBLE
12007: EQUAL
12008: IFTRUE 12012
12010: GO 12023
12012: POP
// cl := class_apeman_kamikaze ; end ;
12013: LD_ADDR_VAR 0 5
12017: PUSH
12018: LD_INT 17
12020: ST_TO_ADDR
12021: GO 12024
12023: POP
// for i = 1 to tmp do
12024: LD_ADDR_VAR 0 6
12028: PUSH
12029: DOUBLE
12030: LD_INT 1
12032: DEC
12033: ST_TO_ADDR
12034: LD_VAR 0 4
12038: PUSH
12039: FOR_TO
12040: IFFALSE 12089
// if GetClass ( tmp [ i ] ) = cl then
12042: LD_VAR 0 4
12046: PUSH
12047: LD_VAR 0 6
12051: ARRAY
12052: PPUSH
12053: CALL_OW 257
12057: PUSH
12058: LD_VAR 0 5
12062: EQUAL
12063: IFFALSE 12087
// result := result ^ tmp [ i ] ;
12065: LD_ADDR_VAR 0 3
12069: PUSH
12070: LD_VAR 0 3
12074: PUSH
12075: LD_VAR 0 4
12079: PUSH
12080: LD_VAR 0 6
12084: ARRAY
12085: ADD
12086: ST_TO_ADDR
12087: GO 12039
12089: POP
12090: POP
// end ;
12091: LD_VAR 0 3
12095: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12096: LD_INT 0
12098: PPUSH
12099: PPUSH
12100: PPUSH
12101: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12102: LD_ADDR_VAR 0 5
12106: PUSH
12107: LD_INT 22
12109: PUSH
12110: LD_VAR 0 1
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PUSH
12119: LD_VAR 0 3
12123: PUSH
12124: EMPTY
12125: LIST
12126: LIST
12127: PPUSH
12128: CALL_OW 69
12132: ST_TO_ADDR
// r := [ ] ;
12133: LD_ADDR_VAR 0 6
12137: PUSH
12138: EMPTY
12139: ST_TO_ADDR
// if tmp then
12140: LD_VAR 0 5
12144: IFFALSE 12213
// for i = 1 to tmp do
12146: LD_ADDR_VAR 0 7
12150: PUSH
12151: DOUBLE
12152: LD_INT 1
12154: DEC
12155: ST_TO_ADDR
12156: LD_VAR 0 5
12160: PUSH
12161: FOR_TO
12162: IFFALSE 12211
// if GetTag ( tmp [ i ] ) = tag then
12164: LD_VAR 0 5
12168: PUSH
12169: LD_VAR 0 7
12173: ARRAY
12174: PPUSH
12175: CALL_OW 110
12179: PUSH
12180: LD_VAR 0 2
12184: EQUAL
12185: IFFALSE 12209
// r := r ^ tmp [ i ] ;
12187: LD_ADDR_VAR 0 6
12191: PUSH
12192: LD_VAR 0 6
12196: PUSH
12197: LD_VAR 0 5
12201: PUSH
12202: LD_VAR 0 7
12206: ARRAY
12207: ADD
12208: ST_TO_ADDR
12209: GO 12161
12211: POP
12212: POP
// result := r ;
12213: LD_ADDR_VAR 0 4
12217: PUSH
12218: LD_VAR 0 6
12222: ST_TO_ADDR
// end ;
12223: LD_VAR 0 4
12227: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12228: LD_INT 0
12230: PPUSH
12231: PPUSH
12232: PPUSH
// tmp := plist ;
12233: LD_ADDR_VAR 0 5
12237: PUSH
12238: LD_VAR 0 2
12242: ST_TO_ADDR
// if tmp then
12243: LD_VAR 0 5
12247: IFFALSE 12324
// begin for i = 1 to tmp do
12249: LD_ADDR_VAR 0 6
12253: PUSH
12254: DOUBLE
12255: LD_INT 1
12257: DEC
12258: ST_TO_ADDR
12259: LD_VAR 0 5
12263: PUSH
12264: FOR_TO
12265: IFFALSE 12312
// if GetTag ( tmp [ i ] ) <> tag then
12267: LD_VAR 0 5
12271: PUSH
12272: LD_VAR 0 6
12276: ARRAY
12277: PPUSH
12278: CALL_OW 110
12282: PUSH
12283: LD_VAR 0 3
12287: NONEQUAL
12288: IFFALSE 12310
// SetTag ( tmp [ i ] , tag ) ;
12290: LD_VAR 0 5
12294: PUSH
12295: LD_VAR 0 6
12299: ARRAY
12300: PPUSH
12301: LD_VAR 0 3
12305: PPUSH
12306: CALL_OW 109
12310: GO 12264
12312: POP
12313: POP
// result := true ;
12314: LD_ADDR_VAR 0 4
12318: PUSH
12319: LD_INT 1
12321: ST_TO_ADDR
// end else
12322: GO 12332
// result := false ;
12324: LD_ADDR_VAR 0 4
12328: PUSH
12329: LD_INT 0
12331: ST_TO_ADDR
// end ;
12332: LD_VAR 0 4
12336: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12337: LD_INT 0
12339: PPUSH
12340: PPUSH
12341: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12342: LD_ADDR_VAR 0 4
12346: PUSH
12347: LD_VAR 0 1
12351: PPUSH
12352: LD_VAR 0 2
12356: PPUSH
12357: EMPTY
12358: PPUSH
12359: CALL 12096 0 3
12363: ST_TO_ADDR
// if tmp then
12364: LD_VAR 0 4
12368: IFFALSE 12420
// begin for i = 1 to tmp do
12370: LD_ADDR_VAR 0 5
12374: PUSH
12375: DOUBLE
12376: LD_INT 1
12378: DEC
12379: ST_TO_ADDR
12380: LD_VAR 0 4
12384: PUSH
12385: FOR_TO
12386: IFFALSE 12408
// SetTag ( tmp [ i ] , 0 ) ;
12388: LD_VAR 0 4
12392: PUSH
12393: LD_VAR 0 5
12397: ARRAY
12398: PPUSH
12399: LD_INT 0
12401: PPUSH
12402: CALL_OW 109
12406: GO 12385
12408: POP
12409: POP
// result := true ;
12410: LD_ADDR_VAR 0 3
12414: PUSH
12415: LD_INT 1
12417: ST_TO_ADDR
// end else
12418: GO 12428
// result := false ;
12420: LD_ADDR_VAR 0 3
12424: PUSH
12425: LD_INT 0
12427: ST_TO_ADDR
// end ;
12428: LD_VAR 0 3
12432: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12433: LD_INT 0
12435: PPUSH
12436: PPUSH
12437: PPUSH
12438: PPUSH
12439: PPUSH
// sort_list := [ ] ;
12440: LD_ADDR_VAR 0 5
12444: PUSH
12445: EMPTY
12446: ST_TO_ADDR
// for i = 1 to list do
12447: LD_ADDR_VAR 0 3
12451: PUSH
12452: DOUBLE
12453: LD_INT 1
12455: DEC
12456: ST_TO_ADDR
12457: LD_VAR 0 1
12461: PUSH
12462: FOR_TO
12463: IFFALSE 12625
// begin if i = 1 then
12465: LD_VAR 0 3
12469: PUSH
12470: LD_INT 1
12472: EQUAL
12473: IFFALSE 12499
// sort_list := sort_list ^ list [ i ] else
12475: LD_ADDR_VAR 0 5
12479: PUSH
12480: LD_VAR 0 5
12484: PUSH
12485: LD_VAR 0 1
12489: PUSH
12490: LD_VAR 0 3
12494: ARRAY
12495: ADD
12496: ST_TO_ADDR
12497: GO 12623
// begin for j = 1 to sort_list do
12499: LD_ADDR_VAR 0 4
12503: PUSH
12504: DOUBLE
12505: LD_INT 1
12507: DEC
12508: ST_TO_ADDR
12509: LD_VAR 0 5
12513: PUSH
12514: FOR_TO
12515: IFFALSE 12592
// begin add := false ;
12517: LD_ADDR_VAR 0 6
12521: PUSH
12522: LD_INT 0
12524: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12525: LD_VAR 0 1
12529: PUSH
12530: LD_VAR 0 3
12534: ARRAY
12535: PUSH
12536: LD_VAR 0 5
12540: PUSH
12541: LD_VAR 0 4
12545: ARRAY
12546: LESS
12547: IFFALSE 12590
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12549: LD_ADDR_VAR 0 5
12553: PUSH
12554: LD_VAR 0 5
12558: PPUSH
12559: LD_VAR 0 4
12563: PPUSH
12564: LD_VAR 0 1
12568: PUSH
12569: LD_VAR 0 3
12573: ARRAY
12574: PPUSH
12575: CALL_OW 2
12579: ST_TO_ADDR
// add := true ;
12580: LD_ADDR_VAR 0 6
12584: PUSH
12585: LD_INT 1
12587: ST_TO_ADDR
// break ;
12588: GO 12592
// end ; end ;
12590: GO 12514
12592: POP
12593: POP
// if not add then
12594: LD_VAR 0 6
12598: NOT
12599: IFFALSE 12623
// sort_list := sort_list ^ list [ i ] ;
12601: LD_ADDR_VAR 0 5
12605: PUSH
12606: LD_VAR 0 5
12610: PUSH
12611: LD_VAR 0 1
12615: PUSH
12616: LD_VAR 0 3
12620: ARRAY
12621: ADD
12622: ST_TO_ADDR
// end ; end ;
12623: GO 12462
12625: POP
12626: POP
// result := sort_list ;
12627: LD_ADDR_VAR 0 2
12631: PUSH
12632: LD_VAR 0 5
12636: ST_TO_ADDR
// end ;
12637: LD_VAR 0 2
12641: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12642: LD_INT 0
12644: PPUSH
12645: PPUSH
12646: PPUSH
12647: PPUSH
12648: PPUSH
// sort_list := [ ] ;
12649: LD_ADDR_VAR 0 5
12653: PUSH
12654: EMPTY
12655: ST_TO_ADDR
// for i = 1 to list do
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: DOUBLE
12662: LD_INT 1
12664: DEC
12665: ST_TO_ADDR
12666: LD_VAR 0 1
12670: PUSH
12671: FOR_TO
12672: IFFALSE 12834
// begin if i = 1 then
12674: LD_VAR 0 3
12678: PUSH
12679: LD_INT 1
12681: EQUAL
12682: IFFALSE 12708
// sort_list := sort_list ^ list [ i ] else
12684: LD_ADDR_VAR 0 5
12688: PUSH
12689: LD_VAR 0 5
12693: PUSH
12694: LD_VAR 0 1
12698: PUSH
12699: LD_VAR 0 3
12703: ARRAY
12704: ADD
12705: ST_TO_ADDR
12706: GO 12832
// begin for j = 1 to sort_list do
12708: LD_ADDR_VAR 0 4
12712: PUSH
12713: DOUBLE
12714: LD_INT 1
12716: DEC
12717: ST_TO_ADDR
12718: LD_VAR 0 5
12722: PUSH
12723: FOR_TO
12724: IFFALSE 12801
// begin add := false ;
12726: LD_ADDR_VAR 0 6
12730: PUSH
12731: LD_INT 0
12733: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12734: LD_VAR 0 1
12738: PUSH
12739: LD_VAR 0 3
12743: ARRAY
12744: PUSH
12745: LD_VAR 0 5
12749: PUSH
12750: LD_VAR 0 4
12754: ARRAY
12755: GREATER
12756: IFFALSE 12799
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12758: LD_ADDR_VAR 0 5
12762: PUSH
12763: LD_VAR 0 5
12767: PPUSH
12768: LD_VAR 0 4
12772: PPUSH
12773: LD_VAR 0 1
12777: PUSH
12778: LD_VAR 0 3
12782: ARRAY
12783: PPUSH
12784: CALL_OW 2
12788: ST_TO_ADDR
// add := true ;
12789: LD_ADDR_VAR 0 6
12793: PUSH
12794: LD_INT 1
12796: ST_TO_ADDR
// break ;
12797: GO 12801
// end ; end ;
12799: GO 12723
12801: POP
12802: POP
// if not add then
12803: LD_VAR 0 6
12807: NOT
12808: IFFALSE 12832
// sort_list := sort_list ^ list [ i ] ;
12810: LD_ADDR_VAR 0 5
12814: PUSH
12815: LD_VAR 0 5
12819: PUSH
12820: LD_VAR 0 1
12824: PUSH
12825: LD_VAR 0 3
12829: ARRAY
12830: ADD
12831: ST_TO_ADDR
// end ; end ;
12832: GO 12671
12834: POP
12835: POP
// result := sort_list ;
12836: LD_ADDR_VAR 0 2
12840: PUSH
12841: LD_VAR 0 5
12845: ST_TO_ADDR
// end ;
12846: LD_VAR 0 2
12850: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12851: LD_INT 0
12853: PPUSH
12854: PPUSH
12855: PPUSH
12856: PPUSH
12857: PPUSH
12858: PPUSH
// tmp := [ ] ;
12859: LD_ADDR_VAR 0 8
12863: PUSH
12864: EMPTY
12865: ST_TO_ADDR
// r := [ ] ;
12866: LD_ADDR_VAR 0 7
12870: PUSH
12871: EMPTY
12872: ST_TO_ADDR
// add := false ;
12873: LD_ADDR_VAR 0 9
12877: PUSH
12878: LD_INT 0
12880: ST_TO_ADDR
// if plist then
12881: LD_VAR 0 2
12885: IFFALSE 12961
// begin for i = 1 to plist do
12887: LD_ADDR_VAR 0 5
12891: PUSH
12892: DOUBLE
12893: LD_INT 1
12895: DEC
12896: ST_TO_ADDR
12897: LD_VAR 0 2
12901: PUSH
12902: FOR_TO
12903: IFFALSE 12957
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12905: LD_ADDR_VAR 0 8
12909: PUSH
12910: LD_VAR 0 8
12914: PUSH
12915: LD_VAR 0 2
12919: PUSH
12920: LD_VAR 0 5
12924: ARRAY
12925: PUSH
12926: LD_VAR 0 2
12930: PUSH
12931: LD_VAR 0 5
12935: ARRAY
12936: PPUSH
12937: LD_VAR 0 3
12941: PPUSH
12942: CALL_OW 259
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: EMPTY
12952: LIST
12953: ADD
12954: ST_TO_ADDR
// end ;
12955: GO 12902
12957: POP
12958: POP
// end else
12959: GO 12969
// result := false ;
12961: LD_ADDR_VAR 0 4
12965: PUSH
12966: LD_INT 0
12968: ST_TO_ADDR
// if tmp then
12969: LD_VAR 0 8
12973: IFFALSE 13147
// begin r := r ^ [ tmp [ 1 ] ] ;
12975: LD_ADDR_VAR 0 7
12979: PUSH
12980: LD_VAR 0 7
12984: PUSH
12985: LD_VAR 0 8
12989: PUSH
12990: LD_INT 1
12992: ARRAY
12993: PUSH
12994: EMPTY
12995: LIST
12996: ADD
12997: ST_TO_ADDR
// for i = 2 to tmp do
12998: LD_ADDR_VAR 0 5
13002: PUSH
13003: DOUBLE
13004: LD_INT 2
13006: DEC
13007: ST_TO_ADDR
13008: LD_VAR 0 8
13012: PUSH
13013: FOR_TO
13014: IFFALSE 13145
// begin for j = 1 to r do
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: DOUBLE
13022: LD_INT 1
13024: DEC
13025: ST_TO_ADDR
13026: LD_VAR 0 7
13030: PUSH
13031: FOR_TO
13032: IFFALSE 13109
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13034: LD_VAR 0 8
13038: PUSH
13039: LD_VAR 0 5
13043: ARRAY
13044: PUSH
13045: LD_INT 2
13047: ARRAY
13048: PUSH
13049: LD_VAR 0 7
13053: PUSH
13054: LD_VAR 0 6
13058: ARRAY
13059: PUSH
13060: LD_INT 2
13062: ARRAY
13063: LESS
13064: IFFALSE 13107
// begin r := Insert ( r , j , tmp [ i ] ) ;
13066: LD_ADDR_VAR 0 7
13070: PUSH
13071: LD_VAR 0 7
13075: PPUSH
13076: LD_VAR 0 6
13080: PPUSH
13081: LD_VAR 0 8
13085: PUSH
13086: LD_VAR 0 5
13090: ARRAY
13091: PPUSH
13092: CALL_OW 2
13096: ST_TO_ADDR
// add := true ;
13097: LD_ADDR_VAR 0 9
13101: PUSH
13102: LD_INT 1
13104: ST_TO_ADDR
// break ;
13105: GO 13109
// end ; end ;
13107: GO 13031
13109: POP
13110: POP
// if not add then
13111: LD_VAR 0 9
13115: NOT
13116: IFFALSE 13143
// r := r ^ [ tmp [ i ] ] ;
13118: LD_ADDR_VAR 0 7
13122: PUSH
13123: LD_VAR 0 7
13127: PUSH
13128: LD_VAR 0 8
13132: PUSH
13133: LD_VAR 0 5
13137: ARRAY
13138: PUSH
13139: EMPTY
13140: LIST
13141: ADD
13142: ST_TO_ADDR
// end ;
13143: GO 13013
13145: POP
13146: POP
// end ; result := r ;
13147: LD_ADDR_VAR 0 4
13151: PUSH
13152: LD_VAR 0 7
13156: ST_TO_ADDR
// end ;
13157: LD_VAR 0 4
13161: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13162: LD_INT 0
13164: PPUSH
13165: PPUSH
13166: PPUSH
13167: PPUSH
13168: PPUSH
13169: PPUSH
// tmp := [ ] ;
13170: LD_ADDR_VAR 0 8
13174: PUSH
13175: EMPTY
13176: ST_TO_ADDR
// r := [ ] ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: EMPTY
13183: ST_TO_ADDR
// add := false ;
13184: LD_ADDR_VAR 0 9
13188: PUSH
13189: LD_INT 0
13191: ST_TO_ADDR
// if plist then
13192: LD_VAR 0 2
13196: IFFALSE 13272
// begin for i = 1 to plist do
13198: LD_ADDR_VAR 0 5
13202: PUSH
13203: DOUBLE
13204: LD_INT 1
13206: DEC
13207: ST_TO_ADDR
13208: LD_VAR 0 2
13212: PUSH
13213: FOR_TO
13214: IFFALSE 13268
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13216: LD_ADDR_VAR 0 8
13220: PUSH
13221: LD_VAR 0 8
13225: PUSH
13226: LD_VAR 0 2
13230: PUSH
13231: LD_VAR 0 5
13235: ARRAY
13236: PUSH
13237: LD_VAR 0 2
13241: PUSH
13242: LD_VAR 0 5
13246: ARRAY
13247: PPUSH
13248: LD_VAR 0 3
13252: PPUSH
13253: CALL_OW 259
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: EMPTY
13263: LIST
13264: ADD
13265: ST_TO_ADDR
// end ;
13266: GO 13213
13268: POP
13269: POP
// end else
13270: GO 13280
// result := false ;
13272: LD_ADDR_VAR 0 4
13276: PUSH
13277: LD_INT 0
13279: ST_TO_ADDR
// if tmp then
13280: LD_VAR 0 8
13284: IFFALSE 13458
// begin r := r ^ [ tmp [ 1 ] ] ;
13286: LD_ADDR_VAR 0 7
13290: PUSH
13291: LD_VAR 0 7
13295: PUSH
13296: LD_VAR 0 8
13300: PUSH
13301: LD_INT 1
13303: ARRAY
13304: PUSH
13305: EMPTY
13306: LIST
13307: ADD
13308: ST_TO_ADDR
// for i = 2 to tmp do
13309: LD_ADDR_VAR 0 5
13313: PUSH
13314: DOUBLE
13315: LD_INT 2
13317: DEC
13318: ST_TO_ADDR
13319: LD_VAR 0 8
13323: PUSH
13324: FOR_TO
13325: IFFALSE 13456
// begin for j = 1 to r do
13327: LD_ADDR_VAR 0 6
13331: PUSH
13332: DOUBLE
13333: LD_INT 1
13335: DEC
13336: ST_TO_ADDR
13337: LD_VAR 0 7
13341: PUSH
13342: FOR_TO
13343: IFFALSE 13420
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13345: LD_VAR 0 8
13349: PUSH
13350: LD_VAR 0 5
13354: ARRAY
13355: PUSH
13356: LD_INT 2
13358: ARRAY
13359: PUSH
13360: LD_VAR 0 7
13364: PUSH
13365: LD_VAR 0 6
13369: ARRAY
13370: PUSH
13371: LD_INT 2
13373: ARRAY
13374: GREATER
13375: IFFALSE 13418
// begin r := Insert ( r , j , tmp [ i ] ) ;
13377: LD_ADDR_VAR 0 7
13381: PUSH
13382: LD_VAR 0 7
13386: PPUSH
13387: LD_VAR 0 6
13391: PPUSH
13392: LD_VAR 0 8
13396: PUSH
13397: LD_VAR 0 5
13401: ARRAY
13402: PPUSH
13403: CALL_OW 2
13407: ST_TO_ADDR
// add := true ;
13408: LD_ADDR_VAR 0 9
13412: PUSH
13413: LD_INT 1
13415: ST_TO_ADDR
// break ;
13416: GO 13420
// end ; end ;
13418: GO 13342
13420: POP
13421: POP
// if not add then
13422: LD_VAR 0 9
13426: NOT
13427: IFFALSE 13454
// r := r ^ [ tmp [ i ] ] ;
13429: LD_ADDR_VAR 0 7
13433: PUSH
13434: LD_VAR 0 7
13438: PUSH
13439: LD_VAR 0 8
13443: PUSH
13444: LD_VAR 0 5
13448: ARRAY
13449: PUSH
13450: EMPTY
13451: LIST
13452: ADD
13453: ST_TO_ADDR
// end ;
13454: GO 13324
13456: POP
13457: POP
// end ; result := r ;
13458: LD_ADDR_VAR 0 4
13462: PUSH
13463: LD_VAR 0 7
13467: ST_TO_ADDR
// end ;
13468: LD_VAR 0 4
13472: RET
// export function MCF_Clear ( side ) ; var i ; begin
13473: LD_INT 0
13475: PPUSH
13476: PPUSH
// for i = 1 to 100 do
13477: LD_ADDR_VAR 0 3
13481: PUSH
13482: DOUBLE
13483: LD_INT 1
13485: DEC
13486: ST_TO_ADDR
13487: LD_INT 100
13489: PUSH
13490: FOR_TO
13491: IFFALSE 13527
// if MCF_Tag ( side , i , [ ] ) then
13493: LD_VAR 0 1
13497: PPUSH
13498: LD_VAR 0 3
13502: PPUSH
13503: EMPTY
13504: PPUSH
13505: CALL 12096 0 3
13509: IFFALSE 13525
// MCF_ClearTag ( side , i ) ;
13511: LD_VAR 0 1
13515: PPUSH
13516: LD_VAR 0 3
13520: PPUSH
13521: CALL 12337 0 2
13525: GO 13490
13527: POP
13528: POP
// result := true ;
13529: LD_ADDR_VAR 0 2
13533: PUSH
13534: LD_INT 1
13536: ST_TO_ADDR
// end ;
13537: LD_VAR 0 2
13541: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13542: LD_INT 0
13544: PPUSH
13545: PPUSH
13546: PPUSH
// for i = 1 to plist do
13547: LD_ADDR_VAR 0 4
13551: PUSH
13552: DOUBLE
13553: LD_INT 1
13555: DEC
13556: ST_TO_ADDR
13557: LD_VAR 0 1
13561: PUSH
13562: FOR_TO
13563: IFFALSE 13612
// if MCF_HasClass ( plist [ i ] ) = n then
13565: LD_VAR 0 1
13569: PUSH
13570: LD_VAR 0 4
13574: ARRAY
13575: PPUSH
13576: CALL 14099 0 1
13580: PUSH
13581: LD_VAR 0 2
13585: EQUAL
13586: IFFALSE 13610
// tmp := tmp ^ plist [ i ] ;
13588: LD_ADDR_VAR 0 5
13592: PUSH
13593: LD_VAR 0 5
13597: PUSH
13598: LD_VAR 0 1
13602: PUSH
13603: LD_VAR 0 4
13607: ARRAY
13608: ADD
13609: ST_TO_ADDR
13610: GO 13562
13612: POP
13613: POP
// result := tmp ;
13614: LD_ADDR_VAR 0 3
13618: PUSH
13619: LD_VAR 0 5
13623: ST_TO_ADDR
// end ;
13624: LD_VAR 0 3
13628: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13629: LD_INT 0
13631: PPUSH
13632: PPUSH
13633: PPUSH
// if mreg = ToArm then
13634: LD_VAR 0 2
13638: PUSH
13639: LD_STRING ToArm
13641: EQUAL
13642: IFFALSE 13747
// begin tmp := MREG_ToArm [ side ] ;
13644: LD_ADDR_VAR 0 6
13648: PUSH
13649: LD_EXP 56
13653: PUSH
13654: LD_VAR 0 1
13658: ARRAY
13659: ST_TO_ADDR
// if tmp = 0 then
13660: LD_VAR 0 6
13664: PUSH
13665: LD_INT 0
13667: EQUAL
13668: IFFALSE 13674
// exit else
13670: GO 14094
13672: GO 13747
// begin for i = MREG_ToArm [ side ] downto n do
13674: LD_ADDR_VAR 0 5
13678: PUSH
13679: DOUBLE
13680: LD_EXP 56
13684: PUSH
13685: LD_VAR 0 1
13689: ARRAY
13690: INC
13691: ST_TO_ADDR
13692: LD_VAR 0 3
13696: PUSH
13697: FOR_DOWNTO
13698: IFFALSE 13720
// tmp := Delete ( tmp , 1 ) ;
13700: LD_ADDR_VAR 0 6
13704: PUSH
13705: LD_VAR 0 6
13709: PPUSH
13710: LD_INT 1
13712: PPUSH
13713: CALL_OW 3
13717: ST_TO_ADDR
13718: GO 13697
13720: POP
13721: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13722: LD_ADDR_EXP 56
13726: PUSH
13727: LD_EXP 56
13731: PPUSH
13732: LD_VAR 0 1
13736: PPUSH
13737: LD_VAR 0 6
13741: PPUSH
13742: CALL_OW 1
13746: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13747: LD_VAR 0 2
13751: PUSH
13752: LD_STRING ToDep
13754: EQUAL
13755: IFFALSE 13860
// begin tmp := MREG_ToDep [ side ] ;
13757: LD_ADDR_VAR 0 6
13761: PUSH
13762: LD_EXP 57
13766: PUSH
13767: LD_VAR 0 1
13771: ARRAY
13772: ST_TO_ADDR
// if tmp = 0 then
13773: LD_VAR 0 6
13777: PUSH
13778: LD_INT 0
13780: EQUAL
13781: IFFALSE 13787
// exit else
13783: GO 14094
13785: GO 13860
// begin for i = MREG_ToDep [ side ] downto n do
13787: LD_ADDR_VAR 0 5
13791: PUSH
13792: DOUBLE
13793: LD_EXP 57
13797: PUSH
13798: LD_VAR 0 1
13802: ARRAY
13803: INC
13804: ST_TO_ADDR
13805: LD_VAR 0 3
13809: PUSH
13810: FOR_DOWNTO
13811: IFFALSE 13833
// tmp := Delete ( tmp , 1 ) ;
13813: LD_ADDR_VAR 0 6
13817: PUSH
13818: LD_VAR 0 6
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 3
13830: ST_TO_ADDR
13831: GO 13810
13833: POP
13834: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13835: LD_ADDR_EXP 57
13839: PUSH
13840: LD_EXP 57
13844: PPUSH
13845: LD_VAR 0 1
13849: PPUSH
13850: LD_VAR 0 6
13854: PPUSH
13855: CALL_OW 1
13859: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13860: LD_VAR 0 2
13864: PUSH
13865: LD_STRING ToFac
13867: EQUAL
13868: IFFALSE 13973
// begin tmp := MREG_ToFac [ side ] ;
13870: LD_ADDR_VAR 0 6
13874: PUSH
13875: LD_EXP 55
13879: PUSH
13880: LD_VAR 0 1
13884: ARRAY
13885: ST_TO_ADDR
// if tmp = 0 then
13886: LD_VAR 0 6
13890: PUSH
13891: LD_INT 0
13893: EQUAL
13894: IFFALSE 13900
// exit else
13896: GO 14094
13898: GO 13973
// begin for i = MREG_ToFac [ side ] downto n do
13900: LD_ADDR_VAR 0 5
13904: PUSH
13905: DOUBLE
13906: LD_EXP 55
13910: PUSH
13911: LD_VAR 0 1
13915: ARRAY
13916: INC
13917: ST_TO_ADDR
13918: LD_VAR 0 3
13922: PUSH
13923: FOR_DOWNTO
13924: IFFALSE 13946
// tmp := Delete ( tmp , 1 ) ;
13926: LD_ADDR_VAR 0 6
13930: PUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: LD_INT 1
13938: PPUSH
13939: CALL_OW 3
13943: ST_TO_ADDR
13944: GO 13923
13946: POP
13947: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13948: LD_ADDR_EXP 55
13952: PUSH
13953: LD_EXP 55
13957: PPUSH
13958: LD_VAR 0 1
13962: PPUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: CALL_OW 1
13972: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
13973: LD_VAR 0 2
13977: PUSH
13978: LD_STRING ToLab
13980: EQUAL
13981: IFFALSE 14086
// begin tmp := MREG_ToLab [ side ] ;
13983: LD_ADDR_VAR 0 6
13987: PUSH
13988: LD_EXP 54
13992: PUSH
13993: LD_VAR 0 1
13997: ARRAY
13998: ST_TO_ADDR
// if tmp = 0 then
13999: LD_VAR 0 6
14003: PUSH
14004: LD_INT 0
14006: EQUAL
14007: IFFALSE 14013
// exit else
14009: GO 14094
14011: GO 14086
// begin for i = MREG_ToLab [ side ] downto n do
14013: LD_ADDR_VAR 0 5
14017: PUSH
14018: DOUBLE
14019: LD_EXP 54
14023: PUSH
14024: LD_VAR 0 1
14028: ARRAY
14029: INC
14030: ST_TO_ADDR
14031: LD_VAR 0 3
14035: PUSH
14036: FOR_DOWNTO
14037: IFFALSE 14059
// tmp := Delete ( tmp , 1 ) ;
14039: LD_ADDR_VAR 0 6
14043: PUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: LD_INT 1
14051: PPUSH
14052: CALL_OW 3
14056: ST_TO_ADDR
14057: GO 14036
14059: POP
14060: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14061: LD_ADDR_EXP 54
14065: PUSH
14066: LD_EXP 54
14070: PPUSH
14071: LD_VAR 0 1
14075: PPUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: CALL_OW 1
14085: ST_TO_ADDR
// end ; end ; result := true ;
14086: LD_ADDR_VAR 0 4
14090: PUSH
14091: LD_INT 1
14093: ST_TO_ADDR
// end ;
14094: LD_VAR 0 4
14098: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14099: LD_INT 0
14101: PPUSH
14102: PPUSH
14103: PPUSH
// side := GetSide ( unit ) ;
14104: LD_ADDR_VAR 0 4
14108: PUSH
14109: LD_VAR 0 1
14113: PPUSH
14114: CALL_OW 255
14118: ST_TO_ADDR
// tmp := 0 ;
14119: LD_ADDR_VAR 0 3
14123: PUSH
14124: LD_INT 0
14126: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14127: LD_VAR 0 1
14131: PUSH
14132: LD_EXP 56
14136: PUSH
14137: LD_VAR 0 4
14141: ARRAY
14142: IN
14143: IFFALSE 14153
// tmp := 1 ;
14145: LD_ADDR_VAR 0 3
14149: PUSH
14150: LD_INT 1
14152: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14153: LD_VAR 0 1
14157: PUSH
14158: LD_EXP 57
14162: PUSH
14163: LD_VAR 0 4
14167: ARRAY
14168: IN
14169: IFFALSE 14179
// tmp := 2 ;
14171: LD_ADDR_VAR 0 3
14175: PUSH
14176: LD_INT 2
14178: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14179: LD_VAR 0 1
14183: PUSH
14184: LD_EXP 55
14188: PUSH
14189: LD_VAR 0 4
14193: ARRAY
14194: IN
14195: IFFALSE 14205
// tmp := 3 ;
14197: LD_ADDR_VAR 0 3
14201: PUSH
14202: LD_INT 3
14204: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14205: LD_VAR 0 1
14209: PUSH
14210: LD_EXP 54
14214: PUSH
14215: LD_VAR 0 4
14219: ARRAY
14220: IN
14221: IFFALSE 14231
// tmp := 4 ;
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: LD_INT 4
14230: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14231: LD_VAR 0 1
14235: PUSH
14236: LD_EXP 68
14240: PUSH
14241: LD_VAR 0 4
14245: ARRAY
14246: IN
14247: IFFALSE 14257
// tmp := 5 ;
14249: LD_ADDR_VAR 0 3
14253: PUSH
14254: LD_INT 5
14256: ST_TO_ADDR
// result := tmp ;
14257: LD_ADDR_VAR 0 2
14261: PUSH
14262: LD_VAR 0 3
14266: ST_TO_ADDR
// end ;
14267: LD_VAR 0 2
14271: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14272: LD_INT 0
14274: PPUSH
14275: PPUSH
// if mreg = ToArm then
14276: LD_VAR 0 2
14280: PUSH
14281: LD_STRING ToArm
14283: EQUAL
14284: IFFALSE 14373
// for i = MREG_ToArm [ side ] downto 1 do
14286: LD_ADDR_VAR 0 5
14290: PUSH
14291: DOUBLE
14292: LD_EXP 56
14296: PUSH
14297: LD_VAR 0 1
14301: ARRAY
14302: INC
14303: ST_TO_ADDR
14304: LD_INT 1
14306: PUSH
14307: FOR_DOWNTO
14308: IFFALSE 14371
// if MREG_ToArm [ side ] [ i ] = unit then
14310: LD_EXP 56
14314: PUSH
14315: LD_VAR 0 1
14319: ARRAY
14320: PUSH
14321: LD_VAR 0 5
14325: ARRAY
14326: PUSH
14327: LD_VAR 0 3
14331: EQUAL
14332: IFFALSE 14369
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14334: LD_ADDR_EXP 56
14338: PUSH
14339: LD_EXP 56
14343: PPUSH
14344: LD_EXP 56
14348: PUSH
14349: LD_VAR 0 1
14353: ARRAY
14354: PUSH
14355: LD_VAR 0 5
14359: ARRAY
14360: PPUSH
14361: LD_INT 1
14363: PPUSH
14364: CALL 31020 0 3
14368: ST_TO_ADDR
// end ;
14369: GO 14307
14371: POP
14372: POP
// if mreg = ToDep then
14373: LD_VAR 0 2
14377: PUSH
14378: LD_STRING ToDep
14380: EQUAL
14381: IFFALSE 14470
// for i = MREG_ToDep [ side ] downto 1 do
14383: LD_ADDR_VAR 0 5
14387: PUSH
14388: DOUBLE
14389: LD_EXP 57
14393: PUSH
14394: LD_VAR 0 1
14398: ARRAY
14399: INC
14400: ST_TO_ADDR
14401: LD_INT 1
14403: PUSH
14404: FOR_DOWNTO
14405: IFFALSE 14468
// if MREG_ToDep [ side ] [ i ] = unit then
14407: LD_EXP 57
14411: PUSH
14412: LD_VAR 0 1
14416: ARRAY
14417: PUSH
14418: LD_VAR 0 5
14422: ARRAY
14423: PUSH
14424: LD_VAR 0 3
14428: EQUAL
14429: IFFALSE 14466
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14431: LD_ADDR_EXP 57
14435: PUSH
14436: LD_EXP 57
14440: PPUSH
14441: LD_EXP 57
14445: PUSH
14446: LD_VAR 0 1
14450: ARRAY
14451: PUSH
14452: LD_VAR 0 5
14456: ARRAY
14457: PPUSH
14458: LD_INT 1
14460: PPUSH
14461: CALL 31020 0 3
14465: ST_TO_ADDR
// end ;
14466: GO 14404
14468: POP
14469: POP
// if mreg = ToFac then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToFac
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToFac [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 55
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToFac [ side ] [ i ] = unit then
14504: LD_EXP 55
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 55
14532: PUSH
14533: LD_EXP 55
14537: PPUSH
14538: LD_EXP 55
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31020 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToLab then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToLab
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToLab [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 54
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToLab [ side ] [ i ] = unit then
14601: LD_EXP 54
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 54
14629: PUSH
14630: LD_EXP 54
14634: PPUSH
14635: LD_EXP 54
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31020 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// end ;
14664: LD_VAR 0 4
14668: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14669: LD_INT 0
14671: PPUSH
14672: PPUSH
// result := false ;
14673: LD_ADDR_VAR 0 2
14677: PUSH
14678: LD_INT 0
14680: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14681: LD_ADDR_VAR 0 3
14685: PUSH
14686: DOUBLE
14687: LD_INT 1
14689: DEC
14690: ST_TO_ADDR
14691: LD_EXP 46
14695: PUSH
14696: FOR_TO
14697: IFFALSE 14761
// if MREG_ToBuild [ i ] [ 1 ] = side then
14699: LD_EXP 46
14703: PUSH
14704: LD_VAR 0 3
14708: ARRAY
14709: PUSH
14710: LD_INT 1
14712: ARRAY
14713: PUSH
14714: LD_VAR 0 1
14718: EQUAL
14719: IFFALSE 14759
// begin if MREG_ToBuild [ i ] [ 1 ] then
14721: LD_EXP 46
14725: PUSH
14726: LD_VAR 0 3
14730: ARRAY
14731: PUSH
14732: LD_INT 1
14734: ARRAY
14735: IFFALSE 14759
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14737: LD_ADDR_VAR 0 2
14741: PUSH
14742: LD_EXP 46
14746: PUSH
14747: LD_VAR 0 3
14751: ARRAY
14752: PUSH
14753: LD_INT 1
14755: ARRAY
14756: ST_TO_ADDR
// break ;
14757: GO 14761
// end ; end ;
14759: GO 14696
14761: POP
14762: POP
// for i = 1 to MREG_ToRepair do
14763: LD_ADDR_VAR 0 3
14767: PUSH
14768: DOUBLE
14769: LD_INT 1
14771: DEC
14772: ST_TO_ADDR
14773: LD_EXP 47
14777: PUSH
14778: FOR_TO
14779: IFFALSE 14843
// if MREG_ToRepair [ i ] [ 1 ] = side then
14781: LD_EXP 47
14785: PUSH
14786: LD_VAR 0 3
14790: ARRAY
14791: PUSH
14792: LD_INT 1
14794: ARRAY
14795: PUSH
14796: LD_VAR 0 1
14800: EQUAL
14801: IFFALSE 14841
// begin if MREG_ToRepair [ i ] [ 1 ] then
14803: LD_EXP 47
14807: PUSH
14808: LD_VAR 0 3
14812: ARRAY
14813: PUSH
14814: LD_INT 1
14816: ARRAY
14817: IFFALSE 14841
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14819: LD_ADDR_VAR 0 2
14823: PUSH
14824: LD_EXP 47
14828: PUSH
14829: LD_VAR 0 3
14833: ARRAY
14834: PUSH
14835: LD_INT 1
14837: ARRAY
14838: ST_TO_ADDR
// break ;
14839: GO 14843
// end ; end ;
14841: GO 14778
14843: POP
14844: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14845: LD_VAR 0 1
14849: PPUSH
14850: LD_INT 57
14852: PUSH
14853: EMPTY
14854: LIST
14855: PPUSH
14856: CALL 11393 0 2
14860: IFFALSE 14887
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14862: LD_ADDR_VAR 0 2
14866: PUSH
14867: LD_VAR 0 1
14871: PPUSH
14872: LD_INT 57
14874: PUSH
14875: EMPTY
14876: LIST
14877: PPUSH
14878: CALL 11393 0 2
14882: PUSH
14883: LD_INT 1
14885: ARRAY
14886: ST_TO_ADDR
// end ;
14887: LD_VAR 0 2
14891: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14892: LD_INT 0
14894: PPUSH
14895: PPUSH
14896: PPUSH
14897: PPUSH
14898: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14899: LD_ADDR_VAR 0 6
14903: PUSH
14904: LD_VAR 0 1
14908: PPUSH
14909: LD_INT 21
14911: PUSH
14912: LD_INT 3
14914: PUSH
14915: EMPTY
14916: LIST
14917: LIST
14918: PPUSH
14919: CALL 11393 0 2
14923: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14924: LD_ADDR_VAR 0 7
14928: PUSH
14929: LD_VAR 0 1
14933: PPUSH
14934: LD_INT 81
14936: PUSH
14937: LD_VAR 0 1
14941: PUSH
14942: EMPTY
14943: LIST
14944: LIST
14945: PPUSH
14946: CALL 11393 0 2
14950: ST_TO_ADDR
// if not enemy then
14951: LD_VAR 0 7
14955: NOT
14956: IFFALSE 14968
// result := false else
14958: LD_ADDR_VAR 0 3
14962: PUSH
14963: LD_INT 0
14965: ST_TO_ADDR
14966: GO 15022
// begin scan := NearestUnit ( b , enemy ) ;
14968: LD_ADDR_VAR 0 5
14972: PUSH
14973: LD_VAR 0 6
14977: PPUSH
14978: LD_VAR 0 7
14982: PPUSH
14983: CALL 32345 0 2
14987: ST_TO_ADDR
// if scan [ 2 ] < dist then
14988: LD_VAR 0 5
14992: PUSH
14993: LD_INT 2
14995: ARRAY
14996: PUSH
14997: LD_VAR 0 2
15001: LESS
15002: IFFALSE 15014
// result := true else
15004: LD_ADDR_VAR 0 3
15008: PUSH
15009: LD_INT 1
15011: ST_TO_ADDR
15012: GO 15022
// result := false ;
15014: LD_ADDR_VAR 0 3
15018: PUSH
15019: LD_INT 0
15021: ST_TO_ADDR
// end ; end ;
15022: LD_VAR 0 3
15026: RET
// export function MCF_Info ( ) ; begin
15027: LD_INT 0
15029: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15030: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15032: PUSH
15033: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15035: ADD
15036: PUSH
15037: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15039: ADD
15040: PUSH
15041: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15043: ADD
15044: PUSH
15045: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15047: ADD
15048: PUSH
15049: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15051: ADD
15052: PUSH
15053: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15055: ADD
15056: PUSH
15057: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15059: ADD
15060: PUSH
15061: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15063: ADD
15064: PUSH
15065: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15067: ADD
15068: PPUSH
15069: CALL 8311 0 1
// end ; end_of_file
15073: LD_VAR 0 1
15077: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15078: LD_INT 0
15080: PPUSH
15081: PPUSH
15082: PPUSH
15083: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15084: LD_ADDR_VAR 0 5
15088: PUSH
15089: LD_VAR 0 1
15093: PPUSH
15094: LD_INT 2
15096: PUSH
15097: LD_INT 25
15099: PUSH
15100: LD_INT 2
15102: PUSH
15103: EMPTY
15104: LIST
15105: LIST
15106: PUSH
15107: LD_INT 25
15109: PUSH
15110: LD_INT 3
15112: PUSH
15113: EMPTY
15114: LIST
15115: LIST
15116: PUSH
15117: LD_INT 25
15119: PUSH
15120: LD_INT 4
15122: PUSH
15123: EMPTY
15124: LIST
15125: LIST
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: PPUSH
15133: CALL 11393 0 2
15137: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15138: LD_ADDR_VAR 0 5
15142: PUSH
15143: LD_VAR 0 5
15147: PPUSH
15148: LD_INT 0
15150: PPUSH
15151: CALL 13542 0 2
15155: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15156: LD_ADDR_VAR 0 6
15160: PUSH
15161: LD_VAR 0 1
15165: PPUSH
15166: LD_VAR 0 5
15170: PPUSH
15171: LD_INT 1
15173: PPUSH
15174: CALL 13162 0 3
15178: ST_TO_ADDR
// if n > sk then
15179: LD_VAR 0 2
15183: PUSH
15184: LD_VAR 0 6
15188: GREATER
15189: IFFALSE 15201
// n := sk ;
15191: LD_ADDR_VAR 0 2
15195: PUSH
15196: LD_VAR 0 6
15200: ST_TO_ADDR
// for i = 1 to n do
15201: LD_ADDR_VAR 0 4
15205: PUSH
15206: DOUBLE
15207: LD_INT 1
15209: DEC
15210: ST_TO_ADDR
15211: LD_VAR 0 2
15215: PUSH
15216: FOR_TO
15217: IFFALSE 15329
// if ( sk [ i ] [ 1 ] ) <> 0 then
15219: LD_VAR 0 6
15223: PUSH
15224: LD_VAR 0 4
15228: ARRAY
15229: PUSH
15230: LD_INT 1
15232: ARRAY
15233: PUSH
15234: LD_INT 0
15236: NONEQUAL
15237: IFFALSE 15327
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15239: LD_ADDR_EXP 53
15243: PUSH
15244: LD_EXP 53
15248: PPUSH
15249: LD_VAR 0 1
15253: PPUSH
15254: LD_VAR 0 6
15258: PUSH
15259: LD_VAR 0 4
15263: ARRAY
15264: PUSH
15265: LD_INT 1
15267: ARRAY
15268: PPUSH
15269: LD_INT 1
15271: PPUSH
15272: CALL 42143 0 4
15276: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15277: LD_ADDR_EXP 56
15281: PUSH
15282: LD_EXP 56
15286: PPUSH
15287: LD_VAR 0 1
15291: PPUSH
15292: LD_EXP 56
15296: PUSH
15297: LD_VAR 0 1
15301: ARRAY
15302: PUSH
15303: LD_INT 1
15305: PLUS
15306: PPUSH
15307: LD_VAR 0 6
15311: PUSH
15312: LD_VAR 0 4
15316: ARRAY
15317: PUSH
15318: LD_INT 1
15320: ARRAY
15321: PPUSH
15322: CALL 30861 0 4
15326: ST_TO_ADDR
// end ;
15327: GO 15216
15329: POP
15330: POP
// end ;
15331: LD_VAR 0 3
15335: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 1
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11393 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13542 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 2
15431: PPUSH
15432: CALL 13162 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 2
15529: PPUSH
15530: CALL 42143 0 4
15534: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 57
15539: PUSH
15540: LD_EXP 57
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 57
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 30861 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 2
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11393 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13542 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 3
15689: PPUSH
15690: CALL 13162 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 3
15787: PPUSH
15788: CALL 42143 0 4
15792: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 55
15797: PUSH
15798: LD_EXP 55
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 55
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 30861 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: EMPTY
15892: LIST
15893: LIST
15894: LIST
15895: PPUSH
15896: CALL 11393 0 2
15900: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15901: LD_ADDR_VAR 0 5
15905: PUSH
15906: LD_VAR 0 5
15910: PPUSH
15911: LD_INT 0
15913: PPUSH
15914: CALL 13542 0 2
15918: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15919: LD_ADDR_VAR 0 6
15923: PUSH
15924: LD_VAR 0 1
15928: PPUSH
15929: LD_VAR 0 5
15933: PPUSH
15934: LD_INT 4
15936: PPUSH
15937: CALL 13162 0 3
15941: ST_TO_ADDR
// if n > sk then
15942: LD_VAR 0 2
15946: PUSH
15947: LD_VAR 0 6
15951: GREATER
15952: IFFALSE 15964
// n := sk ;
15954: LD_ADDR_VAR 0 2
15958: PUSH
15959: LD_VAR 0 6
15963: ST_TO_ADDR
// for i = 1 to n do
15964: LD_ADDR_VAR 0 4
15968: PUSH
15969: DOUBLE
15970: LD_INT 1
15972: DEC
15973: ST_TO_ADDR
15974: LD_VAR 0 2
15978: PUSH
15979: FOR_TO
15980: IFFALSE 16092
// if ( sk [ i ] [ 1 ] ) <> 0 then
15982: LD_VAR 0 6
15986: PUSH
15987: LD_VAR 0 4
15991: ARRAY
15992: PUSH
15993: LD_INT 1
15995: ARRAY
15996: PUSH
15997: LD_INT 0
15999: NONEQUAL
16000: IFFALSE 16090
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16002: LD_ADDR_EXP 53
16006: PUSH
16007: LD_EXP 53
16011: PPUSH
16012: LD_VAR 0 1
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: LD_INT 4
16034: PPUSH
16035: CALL 42143 0 4
16039: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16040: LD_ADDR_EXP 54
16044: PUSH
16045: LD_EXP 54
16049: PPUSH
16050: LD_VAR 0 1
16054: PPUSH
16055: LD_EXP 54
16059: PUSH
16060: LD_VAR 0 1
16064: ARRAY
16065: PUSH
16066: LD_INT 1
16068: PLUS
16069: PPUSH
16070: LD_VAR 0 6
16074: PUSH
16075: LD_VAR 0 4
16079: ARRAY
16080: PUSH
16081: LD_INT 1
16083: ARRAY
16084: PPUSH
16085: CALL 30861 0 4
16089: ST_TO_ADDR
// end ;
16090: GO 15979
16092: POP
16093: POP
// end ;
16094: LD_VAR 0 3
16098: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16099: LD_INT 0
16101: PPUSH
16102: PPUSH
16103: PPUSH
16104: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16105: LD_ADDR_VAR 0 6
16109: PUSH
16110: LD_VAR 0 1
16114: PPUSH
16115: LD_INT 2
16117: PUSH
16118: LD_INT 25
16120: PUSH
16121: LD_INT 1
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: PUSH
16128: LD_INT 25
16130: PUSH
16131: LD_INT 2
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PUSH
16138: LD_INT 25
16140: PUSH
16141: LD_INT 3
16143: PUSH
16144: EMPTY
16145: LIST
16146: LIST
16147: PUSH
16148: LD_INT 25
16150: PUSH
16151: LD_INT 4
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: LIST
16162: LIST
16163: LIST
16164: PPUSH
16165: CALL 11393 0 2
16169: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16170: LD_ADDR_VAR 0 6
16174: PUSH
16175: LD_VAR 0 6
16179: PPUSH
16180: LD_INT 0
16182: PPUSH
16183: CALL 13542 0 2
16187: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16188: LD_ADDR_VAR 0 7
16192: PUSH
16193: LD_VAR 0 1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: LD_INT 1
16205: PPUSH
16206: CALL 13162 0 3
16210: ST_TO_ADDR
// if n > sk then
16211: LD_VAR 0 2
16215: PUSH
16216: LD_VAR 0 7
16220: GREATER
16221: IFFALSE 16233
// n := sk ;
16223: LD_ADDR_VAR 0 2
16227: PUSH
16228: LD_VAR 0 7
16232: ST_TO_ADDR
// for i = 1 to n do
16233: LD_ADDR_VAR 0 5
16237: PUSH
16238: DOUBLE
16239: LD_INT 1
16241: DEC
16242: ST_TO_ADDR
16243: LD_VAR 0 2
16247: PUSH
16248: FOR_TO
16249: IFFALSE 16293
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16251: LD_ADDR_EXP 53
16255: PUSH
16256: LD_EXP 53
16260: PPUSH
16261: LD_VAR 0 1
16265: PPUSH
16266: LD_VAR 0 7
16270: PUSH
16271: LD_VAR 0 5
16275: ARRAY
16276: PUSH
16277: LD_INT 1
16279: ARRAY
16280: PPUSH
16281: LD_VAR 0 3
16285: PPUSH
16286: CALL 42143 0 4
16290: ST_TO_ADDR
// end ;
16291: GO 16248
16293: POP
16294: POP
// end ;
16295: LD_VAR 0 4
16299: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16300: LD_INT 0
16302: PPUSH
16303: PPUSH
16304: PPUSH
// b := false ;
16305: LD_ADDR_VAR 0 6
16309: PUSH
16310: LD_INT 0
16312: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16313: LD_VAR 0 3
16317: PUSH
16318: LD_INT 1
16320: PUSH
16321: LD_INT 9
16323: PUSH
16324: LD_INT 5
16326: PUSH
16327: LD_INT 8
16329: PUSH
16330: EMPTY
16331: LIST
16332: LIST
16333: LIST
16334: LIST
16335: IN
16336: IFFALSE 16424
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16338: LD_VAR 0 1
16342: PPUSH
16343: LD_INT 2
16345: PUSH
16346: LD_INT 30
16348: PUSH
16349: LD_INT 4
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 30
16358: PUSH
16359: LD_INT 5
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: LIST
16370: PPUSH
16371: CALL 11393 0 2
16375: IFFALSE 16424
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16377: LD_ADDR_VAR 0 6
16381: PUSH
16382: LD_VAR 0 1
16386: PPUSH
16387: LD_INT 2
16389: PUSH
16390: LD_INT 30
16392: PUSH
16393: LD_INT 4
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: PUSH
16400: LD_INT 30
16402: PUSH
16403: LD_INT 5
16405: PUSH
16406: EMPTY
16407: LIST
16408: LIST
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL 11393 0 2
16419: PUSH
16420: LD_INT 1
16422: ARRAY
16423: ST_TO_ADDR
// if class = class_engineer then
16424: LD_VAR 0 3
16428: PUSH
16429: LD_INT 2
16431: EQUAL
16432: IFFALSE 16520
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16434: LD_VAR 0 1
16438: PPUSH
16439: LD_INT 2
16441: PUSH
16442: LD_INT 30
16444: PUSH
16445: LD_INT 0
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: PUSH
16452: LD_INT 30
16454: PUSH
16455: LD_INT 1
16457: PUSH
16458: EMPTY
16459: LIST
16460: LIST
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: LIST
16466: PPUSH
16467: CALL 11393 0 2
16471: IFFALSE 16520
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16473: LD_ADDR_VAR 0 6
16477: PUSH
16478: LD_VAR 0 1
16482: PPUSH
16483: LD_INT 2
16485: PUSH
16486: LD_INT 30
16488: PUSH
16489: LD_INT 0
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 30
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: LIST
16510: PPUSH
16511: CALL 11393 0 2
16515: PUSH
16516: LD_INT 1
16518: ARRAY
16519: ST_TO_ADDR
// if class = class_mechanic then
16520: LD_VAR 0 3
16524: PUSH
16525: LD_INT 3
16527: EQUAL
16528: IFFALSE 16598
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16530: LD_VAR 0 1
16534: PPUSH
16535: LD_INT 30
16537: PUSH
16538: LD_INT 3
16540: PUSH
16541: EMPTY
16542: LIST
16543: LIST
16544: PPUSH
16545: CALL 11393 0 2
16549: IFFALSE 16598
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16551: LD_ADDR_VAR 0 6
16555: PUSH
16556: LD_VAR 0 1
16560: PPUSH
16561: LD_INT 2
16563: PUSH
16564: LD_INT 30
16566: PUSH
16567: LD_INT 2
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: PUSH
16574: LD_INT 30
16576: PUSH
16577: LD_INT 3
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: LIST
16588: PPUSH
16589: CALL 11393 0 2
16593: PUSH
16594: LD_INT 1
16596: ARRAY
16597: ST_TO_ADDR
// if class = class_scientistic then
16598: LD_VAR 0 3
16602: PUSH
16603: LD_INT 4
16605: EQUAL
16606: IFFALSE 16716
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16608: LD_VAR 0 1
16612: PPUSH
16613: LD_INT 2
16615: PUSH
16616: LD_INT 30
16618: PUSH
16619: LD_INT 6
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: PUSH
16626: LD_INT 30
16628: PUSH
16629: LD_INT 7
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 8
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: LIST
16650: LIST
16651: PPUSH
16652: CALL 11393 0 2
16656: IFFALSE 16716
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16658: LD_ADDR_VAR 0 6
16662: PUSH
16663: LD_VAR 0 1
16667: PPUSH
16668: LD_INT 2
16670: PUSH
16671: LD_INT 30
16673: PUSH
16674: LD_INT 6
16676: PUSH
16677: EMPTY
16678: LIST
16679: LIST
16680: PUSH
16681: LD_INT 30
16683: PUSH
16684: LD_INT 7
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: PUSH
16691: LD_INT 30
16693: PUSH
16694: LD_INT 8
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: PPUSH
16707: CALL 11393 0 2
16711: PUSH
16712: LD_INT 1
16714: ARRAY
16715: ST_TO_ADDR
// if GetClass ( unit ) = class then
16716: LD_VAR 0 2
16720: PPUSH
16721: CALL_OW 257
16725: PUSH
16726: LD_VAR 0 3
16730: EQUAL
16731: IFFALSE 16765
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16733: LD_ADDR_EXP 53
16737: PUSH
16738: LD_EXP 53
16742: PPUSH
16743: LD_VAR 0 1
16747: PPUSH
16748: LD_VAR 0 2
16752: PPUSH
16753: LD_VAR 0 3
16757: PPUSH
16758: CALL 42234 0 4
16762: ST_TO_ADDR
// end else
16763: GO 16858
// if b then
16765: LD_VAR 0 6
16769: IFFALSE 16850
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16771: LD_VAR 0 2
16775: PPUSH
16776: CALL_OW 310
16780: PUSH
16781: LD_VAR 0 2
16785: PPUSH
16786: CALL_OW 310
16790: PUSH
16791: LD_VAR 0 6
16795: NONEQUAL
16796: AND
16797: IFFALSE 16808
// ComExitBuilding ( unit ) ;
16799: LD_VAR 0 2
16803: PPUSH
16804: CALL_OW 122
// if not IsInUnit ( unit ) then
16808: LD_VAR 0 2
16812: PPUSH
16813: CALL_OW 310
16817: NOT
16818: IFFALSE 16834
// ComEnterUnit ( unit , b ) ;
16820: LD_VAR 0 2
16824: PPUSH
16825: LD_VAR 0 6
16829: PPUSH
16830: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16834: LD_VAR 0 2
16838: PPUSH
16839: LD_VAR 0 3
16843: PPUSH
16844: CALL_OW 183
// end else
16848: GO 16858
// result := false ;
16850: LD_ADDR_VAR 0 4
16854: PUSH
16855: LD_INT 0
16857: ST_TO_ADDR
// end ; end_of_file
16858: LD_VAR 0 4
16862: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16863: LD_INT 0
16865: PPUSH
16866: PPUSH
16867: PPUSH
16868: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16869: LD_ADDR_VAR 0 5
16873: PUSH
16874: LD_INT 35
16876: PUSH
16877: LD_INT 45
16879: PUSH
16880: LD_INT 46
16882: PUSH
16883: LD_INT 47
16885: PUSH
16886: LD_INT 1
16888: PUSH
16889: LD_INT 2
16891: PUSH
16892: LD_INT 48
16894: PUSH
16895: LD_INT 49
16897: PUSH
16898: LD_INT 50
16900: PUSH
16901: LD_INT 20
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: ST_TO_ADDR
// if MCF_Lab ( side ) then
16916: LD_VAR 0 1
16920: PPUSH
16921: CALL 11432 0 1
16925: IFFALSE 17164
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16927: LD_VAR 0 1
16931: PPUSH
16932: CALL 11432 0 1
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: PPUSH
16941: CALL_OW 461
16945: PUSH
16946: LD_INT 2
16948: EQUAL
16949: IFFALSE 17088
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16951: LD_VAR 0 1
16955: PPUSH
16956: CALL 11432 0 1
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL 17260 0 2
16974: IFFALSE 17001
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
16976: LD_VAR 0 1
16980: PPUSH
16981: CALL 11432 0 1
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: PPUSH
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 124
16999: GO 17088
// if MCF_Lab ( side ) > 1 then
17001: LD_VAR 0 1
17005: PPUSH
17006: CALL 11432 0 1
17010: PUSH
17011: LD_INT 1
17013: GREATER
17014: IFFALSE 17088
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17016: LD_VAR 0 1
17020: PPUSH
17021: CALL 11432 0 1
17025: PUSH
17026: LD_INT 2
17028: ARRAY
17029: PPUSH
17030: CALL_OW 461
17034: PUSH
17035: LD_INT 2
17037: EQUAL
17038: IFFALSE 17088
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17040: LD_VAR 0 1
17044: PPUSH
17045: CALL 11432 0 1
17049: PUSH
17050: LD_INT 2
17052: ARRAY
17053: PPUSH
17054: LD_VAR 0 2
17058: PPUSH
17059: CALL 17260 0 2
17063: IFFALSE 17088
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17065: LD_VAR 0 1
17069: PPUSH
17070: CALL 11432 0 1
17074: PUSH
17075: LD_INT 2
17077: ARRAY
17078: PPUSH
17079: LD_VAR 0 2
17083: PPUSH
17084: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17088: LD_VAR 0 2
17092: PUSH
17093: LD_INT 2
17095: PUSH
17096: LD_INT 11
17098: PUSH
17099: LD_INT 4
17101: PUSH
17102: LD_INT 3
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: IN
17111: IFFALSE 17164
// begin for lab in MCF_Lab ( side ) do
17113: LD_ADDR_VAR 0 6
17117: PUSH
17118: LD_VAR 0 1
17122: PPUSH
17123: CALL 11432 0 1
17127: PUSH
17128: FOR_IN
17129: IFFALSE 17162
// if BuildingStatus ( lab ) = bs_need_ape then
17131: LD_VAR 0 6
17135: PPUSH
17136: CALL_OW 461
17140: PUSH
17141: LD_INT 10
17143: EQUAL
17144: IFFALSE 17160
// MCL_ResTame ( side , lab ) ;
17146: LD_VAR 0 1
17150: PPUSH
17151: LD_VAR 0 6
17155: PPUSH
17156: CALL 17385 0 2
17160: GO 17128
17162: POP
17163: POP
// end ; end ; end ;
17164: LD_VAR 0 3
17168: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17169: LD_INT 0
17171: PPUSH
17172: PPUSH
// tmp := [ ] ;
17173: LD_ADDR_VAR 0 3
17177: PUSH
17178: EMPTY
17179: ST_TO_ADDR
// if not lab then
17180: LD_VAR 0 1
17184: NOT
17185: IFFALSE 17197
// result := false else
17187: LD_ADDR_VAR 0 2
17191: PUSH
17192: LD_INT 0
17194: ST_TO_ADDR
17195: GO 17255
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17197: LD_ADDR_VAR 0 3
17201: PUSH
17202: LD_VAR 0 3
17206: PUSH
17207: LD_VAR 0 1
17211: PPUSH
17212: LD_INT 1
17214: PPUSH
17215: CALL_OW 268
17219: ADD
17220: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17221: LD_ADDR_VAR 0 3
17225: PUSH
17226: LD_VAR 0 3
17230: PUSH
17231: LD_VAR 0 1
17235: PPUSH
17236: LD_INT 2
17238: PPUSH
17239: CALL_OW 268
17243: ADD
17244: ST_TO_ADDR
// result := tmp ;
17245: LD_ADDR_VAR 0 2
17249: PUSH
17250: LD_VAR 0 3
17254: ST_TO_ADDR
// end ; end ;
17255: LD_VAR 0 2
17259: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17260: LD_INT 0
17262: PPUSH
17263: PPUSH
17264: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17265: LD_ADDR_VAR 0 5
17269: PUSH
17270: LD_INT 35
17272: PUSH
17273: LD_INT 45
17275: PUSH
17276: LD_INT 46
17278: PUSH
17279: LD_INT 47
17281: PUSH
17282: LD_INT 1
17284: PUSH
17285: LD_INT 2
17287: PUSH
17288: LD_INT 48
17290: PUSH
17291: LD_INT 49
17293: PUSH
17294: LD_INT 50
17296: PUSH
17297: LD_INT 20
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: LIST
17304: LIST
17305: LIST
17306: LIST
17307: LIST
17308: LIST
17309: LIST
17310: LIST
17311: ST_TO_ADDR
// if lab then
17312: LD_VAR 0 1
17316: IFFALSE 17372
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17318: LD_VAR 0 2
17322: PUSH
17323: LD_VAR 0 5
17327: IN
17328: PUSH
17329: LD_VAR 0 2
17333: PPUSH
17334: CALL_OW 481
17338: PUSH
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 17169 0 1
17348: IN
17349: OR
17350: IFFALSE 17362
// result := true else
17352: LD_ADDR_VAR 0 3
17356: PUSH
17357: LD_INT 1
17359: ST_TO_ADDR
17360: GO 17370
// result := false ;
17362: LD_ADDR_VAR 0 3
17366: PUSH
17367: LD_INT 0
17369: ST_TO_ADDR
// end else
17370: GO 17380
// result := false ;
17372: LD_ADDR_VAR 0 3
17376: PUSH
17377: LD_INT 0
17379: ST_TO_ADDR
// end ;
17380: LD_VAR 0 3
17384: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17385: LD_INT 0
17387: PPUSH
17388: PPUSH
17389: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17390: LD_ADDR_VAR 0 4
17394: PUSH
17395: LD_VAR 0 1
17399: PPUSH
17400: LD_INT 171
17402: PPUSH
17403: EMPTY
17404: PPUSH
17405: CALL 12096 0 3
17409: ST_TO_ADDR
// if not ape then
17410: LD_VAR 0 4
17414: NOT
17415: IFFALSE 17447
// if MCF_Ape ( side ) then
17417: LD_VAR 0 1
17421: PPUSH
17422: CALL 11806 0 1
17426: IFFALSE 17447
// ape := MCF_Ape ( side ) [ 1 ] ;
17428: LD_ADDR_VAR 0 4
17432: PUSH
17433: LD_VAR 0 1
17437: PPUSH
17438: CALL 11806 0 1
17442: PUSH
17443: LD_INT 1
17445: ARRAY
17446: ST_TO_ADDR
// if ape then
17447: LD_VAR 0 4
17451: IFFALSE 17502
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17453: LD_VAR 0 4
17457: PUSH
17458: LD_INT 1
17460: ARRAY
17461: PPUSH
17462: CALL_OW 310
17466: PUSH
17467: LD_VAR 0 4
17471: PUSH
17472: LD_INT 1
17474: ARRAY
17475: PPUSH
17476: CALL_OW 310
17480: PUSH
17481: LD_VAR 0 2
17485: NONEQUAL
17486: AND
17487: IFFALSE 17502
// ComExitBuilding ( ape [ 1 ] ) ;
17489: LD_VAR 0 4
17493: PUSH
17494: LD_INT 1
17496: ARRAY
17497: PPUSH
17498: CALL_OW 122
// if not lab then
17502: LD_VAR 0 2
17506: NOT
17507: IFFALSE 17513
// exit else
17509: GO 17661
17511: GO 17621
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17513: LD_VAR 0 1
17517: PPUSH
17518: LD_INT 16
17520: PPUSH
17521: LD_INT 25
17523: PUSH
17524: LD_INT 4
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: PPUSH
17531: CALL 12096 0 3
17535: PUSH
17536: LD_INT 0
17538: EQUAL
17539: PUSH
17540: LD_VAR 0 2
17544: PPUSH
17545: CALL_OW 313
17549: PUSH
17550: LD_INT 6
17552: EQUAL
17553: AND
17554: IFFALSE 17621
// begin tmp := UnitsInside ( lab ) ;
17556: LD_ADDR_VAR 0 5
17560: PUSH
17561: LD_VAR 0 2
17565: PPUSH
17566: CALL_OW 313
17570: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17571: LD_VAR 0 5
17575: PUSH
17576: LD_VAR 0 5
17580: ARRAY
17581: PPUSH
17582: LD_INT 16
17584: PPUSH
17585: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17589: LD_VAR 0 5
17593: PUSH
17594: LD_VAR 0 5
17598: ARRAY
17599: PPUSH
17600: CALL_OW 310
17604: IFFALSE 17621
// ComExitBuilding ( tmp [ tmp ] ) ;
17606: LD_VAR 0 5
17610: PUSH
17611: LD_VAR 0 5
17615: ARRAY
17616: PPUSH
17617: CALL_OW 122
// end ; if ape then
17621: LD_VAR 0 4
17625: IFFALSE 17661
// if not IsInUnit ( ape [ 1 ] ) then
17627: LD_VAR 0 4
17631: PUSH
17632: LD_INT 1
17634: ARRAY
17635: PPUSH
17636: CALL_OW 310
17640: NOT
17641: IFFALSE 17661
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17643: LD_VAR 0 4
17647: PUSH
17648: LD_INT 1
17650: ARRAY
17651: PPUSH
17652: LD_VAR 0 2
17656: PPUSH
17657: CALL_OW 120
// end ;
17661: LD_VAR 0 3
17665: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17666: LD_INT 0
17668: PPUSH
17669: PPUSH
17670: PPUSH
// result := false ;
17671: LD_ADDR_VAR 0 2
17675: PUSH
17676: LD_INT 0
17678: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17679: LD_ADDR_VAR 0 3
17683: PUSH
17684: LD_VAR 0 1
17688: PPUSH
17689: CALL 17776 0 1
17693: ST_TO_ADDR
// if techs then
17694: LD_VAR 0 3
17698: IFFALSE 17728
// if techs [ 2 ] then
17700: LD_VAR 0 3
17704: PUSH
17705: LD_INT 2
17707: ARRAY
17708: IFFALSE 17720
// result := true else
17710: LD_ADDR_VAR 0 2
17714: PUSH
17715: LD_INT 1
17717: ST_TO_ADDR
17718: GO 17728
// result := false ;
17720: LD_ADDR_VAR 0 2
17724: PUSH
17725: LD_INT 0
17727: ST_TO_ADDR
// end ;
17728: LD_VAR 0 2
17732: RET
// export function MCL_Start ( side ) ; var i ; begin
17733: LD_INT 0
17735: PPUSH
17736: PPUSH
// if MCL_GetTechList ( side ) then
17737: LD_VAR 0 1
17741: PPUSH
17742: CALL 17776 0 1
17746: IFFALSE 17771
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17748: LD_VAR 0 1
17752: PPUSH
17753: LD_VAR 0 1
17757: PPUSH
17758: CALL 17776 0 1
17762: PUSH
17763: LD_INT 1
17765: ARRAY
17766: PPUSH
17767: CALL 16863 0 2
// end ;
17771: LD_VAR 0 2
17775: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17776: LD_INT 0
17778: PPUSH
17779: PPUSH
17780: PPUSH
// if MREG_ToRes then
17781: LD_EXP 50
17785: IFFALSE 17870
// for i = 1 to MREG_ToRes do
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: DOUBLE
17793: LD_INT 1
17795: DEC
17796: ST_TO_ADDR
17797: LD_EXP 50
17801: PUSH
17802: FOR_TO
17803: IFFALSE 17868
// if MREG_ToRes [ i ] [ 1 ] = side then
17805: LD_EXP 50
17809: PUSH
17810: LD_VAR 0 3
17814: ARRAY
17815: PUSH
17816: LD_INT 1
17818: ARRAY
17819: PUSH
17820: LD_VAR 0 1
17824: EQUAL
17825: IFFALSE 17866
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17827: LD_ADDR_VAR 0 4
17831: PUSH
17832: LD_VAR 0 4
17836: PPUSH
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: PLUS
17845: PPUSH
17846: LD_EXP 50
17850: PUSH
17851: LD_VAR 0 3
17855: ARRAY
17856: PUSH
17857: LD_INT 2
17859: ARRAY
17860: PPUSH
17861: CALL_OW 1
17865: ST_TO_ADDR
// end ;
17866: GO 17802
17868: POP
17869: POP
// result := techs ;
17870: LD_ADDR_VAR 0 2
17874: PUSH
17875: LD_VAR 0 4
17879: ST_TO_ADDR
// end ;
17880: LD_VAR 0 2
17884: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17885: LD_INT 0
17887: PPUSH
17888: PPUSH
// for i = 1 to tech_list do
17889: LD_ADDR_VAR 0 4
17893: PUSH
17894: DOUBLE
17895: LD_INT 1
17897: DEC
17898: ST_TO_ADDR
17899: LD_VAR 0 2
17903: PUSH
17904: FOR_TO
17905: IFFALSE 17959
// if not tech_list [ i ] = 20 then
17907: LD_VAR 0 2
17911: PUSH
17912: LD_VAR 0 4
17916: ARRAY
17917: PUSH
17918: LD_INT 20
17920: EQUAL
17921: NOT
17922: IFFALSE 17957
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17924: LD_ADDR_EXP 50
17928: PUSH
17929: LD_EXP 50
17933: PPUSH
17934: LD_VAR 0 1
17938: PPUSH
17939: LD_VAR 0 2
17943: PUSH
17944: LD_VAR 0 4
17948: ARRAY
17949: PPUSH
17950: EMPTY
17951: PPUSH
17952: CALL 42143 0 4
17956: ST_TO_ADDR
17957: GO 17904
17959: POP
17960: POP
// result := true ;
17961: LD_ADDR_VAR 0 3
17965: PUSH
17966: LD_INT 1
17968: ST_TO_ADDR
// end ;
17969: LD_VAR 0 3
17973: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
17974: LD_INT 0
17976: PPUSH
17977: PPUSH
// for i = MREG_ToRes downto 1 do
17978: LD_ADDR_VAR 0 3
17982: PUSH
17983: DOUBLE
17984: LD_EXP 50
17988: INC
17989: ST_TO_ADDR
17990: LD_INT 1
17992: PUSH
17993: FOR_DOWNTO
17994: IFFALSE 18040
// if MREG_ToRes [ i ] [ 1 ] = side then
17996: LD_EXP 50
18000: PUSH
18001: LD_VAR 0 3
18005: ARRAY
18006: PUSH
18007: LD_INT 1
18009: ARRAY
18010: PUSH
18011: LD_VAR 0 1
18015: EQUAL
18016: IFFALSE 18038
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18018: LD_ADDR_EXP 50
18022: PUSH
18023: LD_EXP 50
18027: PPUSH
18028: LD_VAR 0 3
18032: PPUSH
18033: CALL_OW 3
18037: ST_TO_ADDR
18038: GO 17993
18040: POP
18041: POP
// result := true ;
18042: LD_ADDR_VAR 0 2
18046: PUSH
18047: LD_INT 1
18049: ST_TO_ADDR
// end ;
18050: LD_VAR 0 2
18054: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18055: LD_INT 0
18057: PPUSH
// result := GetTechProgress ( side , tech ) ;
18058: LD_ADDR_VAR 0 3
18062: PUSH
18063: LD_VAR 0 1
18067: PPUSH
18068: LD_VAR 0 2
18072: PPUSH
18073: CALL_OW 326
18077: ST_TO_ADDR
// end ;
18078: LD_VAR 0 3
18082: RET
// export function MCL_Require ( tech ) ; begin
18083: LD_INT 0
18085: PPUSH
// result := GetTechTechsReq ( tech ) ;
18086: LD_ADDR_VAR 0 2
18090: PUSH
18091: LD_VAR 0 1
18095: PPUSH
18096: CALL_OW 480
18100: ST_TO_ADDR
// end ; end_of_file
18101: LD_VAR 0 2
18105: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18106: LD_INT 0
18108: PPUSH
18109: PPUSH
18110: PPUSH
// uc_side := 0 ;
18111: LD_ADDR_OWVAR 20
18115: PUSH
18116: LD_INT 0
18118: ST_TO_ADDR
// uc_nation := 0 ;
18119: LD_ADDR_OWVAR 21
18123: PUSH
18124: LD_INT 0
18126: ST_TO_ADDR
// for i = 1 to n do
18127: LD_ADDR_VAR 0 5
18131: PUSH
18132: DOUBLE
18133: LD_INT 1
18135: DEC
18136: ST_TO_ADDR
18137: LD_VAR 0 2
18141: PUSH
18142: FOR_TO
18143: IFFALSE 18288
// begin hc_importance := 0 ;
18145: LD_ADDR_OWVAR 32
18149: PUSH
18150: LD_INT 0
18152: ST_TO_ADDR
// hc_gallery :=  ;
18153: LD_ADDR_OWVAR 33
18157: PUSH
18158: LD_STRING 
18160: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18161: LD_ADDR_OWVAR 35
18165: PUSH
18166: LD_VAR 0 3
18170: PUSH
18171: LD_INT 20
18173: MINUS
18174: PPUSH
18175: LD_VAR 0 3
18179: PUSH
18180: LD_INT 20
18182: PLUS
18183: PPUSH
18184: CALL_OW 12
18188: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18189: LD_ADDR_OWVAR 31
18193: PUSH
18194: LD_INT 0
18196: PPUSH
18197: LD_INT 2
18199: PPUSH
18200: CALL_OW 12
18204: PUSH
18205: LD_INT 0
18207: PUSH
18208: LD_INT 0
18210: PUSH
18211: LD_INT 0
18213: PUSH
18214: EMPTY
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18220: LD_ADDR_OWVAR 30
18224: PUSH
18225: LD_INT 0
18227: PUSH
18228: LD_INT 0
18230: PUSH
18231: LD_INT 0
18233: PUSH
18234: LD_INT 0
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: ST_TO_ADDR
// hc_name :=  ;
18243: LD_ADDR_OWVAR 26
18247: PUSH
18248: LD_STRING 
18250: ST_TO_ADDR
// hc_class := class_apeman ;
18251: LD_ADDR_OWVAR 28
18255: PUSH
18256: LD_INT 12
18258: ST_TO_ADDR
// ape := CreateHuman ;
18259: LD_ADDR_VAR 0 6
18263: PUSH
18264: CALL_OW 44
18268: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18269: LD_VAR 0 6
18273: PPUSH
18274: LD_VAR 0 1
18278: PPUSH
18279: LD_INT 0
18281: PPUSH
18282: CALL_OW 49
// end ;
18286: GO 18142
18288: POP
18289: POP
// end ;
18290: LD_VAR 0 4
18294: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18295: LD_INT 0
18297: PPUSH
18298: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18299: LD_VAR 0 1
18303: PPUSH
18304: CALL 11806 0 1
18308: PUSH
18309: LD_EXP 37
18313: PUSH
18314: LD_VAR 0 1
18318: ARRAY
18319: GREATEREQUAL
18320: IFFALSE 18497
// begin if GetTag ( unit ) = 17 then
18322: LD_VAR 0 2
18326: PPUSH
18327: CALL_OW 110
18331: PUSH
18332: LD_INT 17
18334: EQUAL
18335: IFFALSE 18495
// begin SetTag ( unit , 0 ) ;
18337: LD_VAR 0 2
18341: PPUSH
18342: LD_INT 0
18344: PPUSH
18345: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL 11432 0 1
18358: PUSH
18359: LD_VAR 0 1
18363: PPUSH
18364: CALL 17776 0 1
18368: NOT
18369: AND
18370: IFFALSE 18395
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18372: LD_VAR 0 2
18376: PPUSH
18377: LD_VAR 0 1
18381: PPUSH
18382: CALL 11432 0 1
18386: PUSH
18387: LD_INT 1
18389: ARRAY
18390: PPUSH
18391: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18395: LD_VAR 0 1
18399: PPUSH
18400: CALL 11432 0 1
18404: NOT
18405: PUSH
18406: LD_VAR 0 1
18410: PPUSH
18411: LD_INT 30
18413: PUSH
18414: LD_INT 1
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: PPUSH
18421: CALL 11393 0 2
18425: AND
18426: IFFALSE 18495
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18428: LD_VAR 0 2
18432: PPUSH
18433: LD_VAR 0 1
18437: PPUSH
18438: LD_INT 30
18440: PUSH
18441: LD_INT 1
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: PPUSH
18448: CALL 11393 0 2
18452: PUSH
18453: LD_INT 1
18455: ARRAY
18456: PPUSH
18457: CALL_OW 250
18461: PPUSH
18462: LD_VAR 0 1
18466: PPUSH
18467: LD_INT 30
18469: PUSH
18470: LD_INT 1
18472: PUSH
18473: EMPTY
18474: LIST
18475: LIST
18476: PPUSH
18477: CALL 11393 0 2
18481: PUSH
18482: LD_INT 1
18484: ARRAY
18485: PPUSH
18486: CALL_OW 251
18490: PPUSH
18491: CALL_OW 111
// end ; end else
18495: GO 18681
// if GetClass ( unit ) <> 4 then
18497: LD_VAR 0 2
18501: PPUSH
18502: CALL_OW 257
18506: PUSH
18507: LD_INT 4
18509: NONEQUAL
18510: IFFALSE 18516
// exit else
18512: GO 18681
18514: GO 18681
// if GetTag ( unit ) = 0 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 0
18528: EQUAL
18529: IFFALSE 18545
// SetTag ( unit , 17 ) else
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 17
18538: PPUSH
18539: CALL_OW 109
18543: GO 18681
// begin if IsInUnit ( unit ) then
18545: LD_VAR 0 2
18549: PPUSH
18550: CALL_OW 310
18554: IFFALSE 18565
// ComExitBuilding ( unit ) ;
18556: LD_VAR 0 2
18560: PPUSH
18561: CALL_OW 122
// Wait ( 1 ) ;
18565: LD_INT 1
18567: PPUSH
18568: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18572: LD_ADDR_VAR 0 4
18576: PUSH
18577: LD_INT 22
18579: PUSH
18580: LD_INT 0
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: PUSH
18587: LD_INT 25
18589: PUSH
18590: LD_INT 12
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: EMPTY
18598: LIST
18599: LIST
18600: PPUSH
18601: CALL_OW 69
18605: PPUSH
18606: LD_VAR 0 2
18610: PPUSH
18611: CALL_OW 74
18615: ST_TO_ADDR
// if not ape then
18616: LD_VAR 0 4
18620: NOT
18621: IFFALSE 18627
// exit else
18623: GO 18681
18625: GO 18636
// ComHold ( ape ) ;
18627: LD_VAR 0 4
18631: PPUSH
18632: CALL_OW 140
// if not HasTask ( unit ) then
18636: LD_VAR 0 2
18640: PPUSH
18641: CALL_OW 314
18645: NOT
18646: IFFALSE 18679
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18648: LD_VAR 0 2
18652: PPUSH
18653: LD_VAR 0 4
18657: PPUSH
18658: CALL_OW 250
18662: PPUSH
18663: LD_VAR 0 4
18667: PPUSH
18668: CALL_OW 251
18672: PPUSH
18673: CALL_OW 131
18677: GO 18681
// exit ;
18679: GO 18681
// end ; end ;
18681: LD_VAR 0 3
18685: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18686: LD_INT 0
18688: PPUSH
18689: PPUSH
18690: PPUSH
18691: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18692: LD_ADDR_VAR 0 4
18696: PUSH
18697: LD_EXP 38
18701: PUSH
18702: LD_VAR 0 1
18706: ARRAY
18707: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18708: LD_ADDR_VAR 0 5
18712: PUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: LD_STRING normal
18720: PPUSH
18721: CALL 11890 0 2
18725: ST_TO_ADDR
// if apes then
18726: LD_VAR 0 5
18730: IFFALSE 18958
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18732: LD_INT 2
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: CALL_OW 321
18744: PUSH
18745: LD_INT 2
18747: EQUAL
18748: PUSH
18749: LD_VAR 0 4
18753: PUSH
18754: LD_INT 2
18756: ARRAY
18757: PUSH
18758: LD_INT 1
18760: EQUAL
18761: AND
18762: PUSH
18763: LD_VAR 0 1
18767: PPUSH
18768: LD_STRING engineer
18770: PPUSH
18771: CALL 11890 0 2
18775: PUSH
18776: LD_INT 3
18778: LESS
18779: AND
18780: PUSH
18781: LD_VAR 0 1
18785: PPUSH
18786: LD_INT 30
18788: PUSH
18789: LD_INT 1
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: PPUSH
18796: CALL 11393 0 2
18800: AND
18801: IFFALSE 18855
// begin for i in apes do
18803: LD_ADDR_VAR 0 3
18807: PUSH
18808: LD_VAR 0 5
18812: PUSH
18813: FOR_IN
18814: IFFALSE 18851
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18816: LD_VAR 0 3
18820: PPUSH
18821: LD_VAR 0 1
18825: PPUSH
18826: LD_INT 30
18828: PUSH
18829: LD_INT 1
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: PPUSH
18836: CALL 11393 0 2
18840: PUSH
18841: LD_INT 1
18843: ARRAY
18844: PPUSH
18845: CALL_OW 120
// end ;
18849: GO 18813
18851: POP
18852: POP
// end else
18853: GO 18958
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18855: LD_INT 11
18857: PPUSH
18858: LD_VAR 0 1
18862: PPUSH
18863: CALL_OW 321
18867: PUSH
18868: LD_INT 2
18870: EQUAL
18871: PUSH
18872: LD_VAR 0 4
18876: PUSH
18877: LD_INT 1
18879: ARRAY
18880: PUSH
18881: LD_INT 1
18883: EQUAL
18884: AND
18885: PUSH
18886: LD_VAR 0 1
18890: PPUSH
18891: LD_INT 30
18893: PUSH
18894: LD_INT 5
18896: PUSH
18897: EMPTY
18898: LIST
18899: LIST
18900: PPUSH
18901: CALL 11393 0 2
18905: AND
18906: IFFALSE 18958
// begin for i in apes do
18908: LD_ADDR_VAR 0 3
18912: PUSH
18913: LD_VAR 0 5
18917: PUSH
18918: FOR_IN
18919: IFFALSE 18956
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18921: LD_VAR 0 3
18925: PPUSH
18926: LD_VAR 0 1
18930: PPUSH
18931: LD_INT 30
18933: PUSH
18934: LD_INT 5
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: PPUSH
18941: CALL 11393 0 2
18945: PUSH
18946: LD_INT 1
18948: ARRAY
18949: PPUSH
18950: CALL_OW 120
// end ;
18954: GO 18918
18956: POP
18957: POP
// end ; end ; end ; end_of_file
18958: LD_VAR 0 2
18962: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18963: LD_INT 0
18965: PPUSH
18966: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18967: LD_VAR 0 1
18971: PPUSH
18972: CALL_OW 257
18976: PUSH
18977: LD_INT 4
18979: EQUAL
18980: NOT
18981: PUSH
18982: LD_VAR 0 2
18986: NOT
18987: OR
18988: IFFALSE 18994
// exit else
18990: GO 19028
18992: GO 19028
// if not GetTag ( unit ) = 4 then
18994: LD_VAR 0 1
18998: PPUSH
18999: CALL_OW 110
19003: PUSH
19004: LD_INT 4
19006: EQUAL
19007: NOT
19008: IFFALSE 19014
// exit else
19010: GO 19028
19012: GO 19028
// ComHeal ( unit , target ) ;
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_VAR 0 2
19023: PPUSH
19024: CALL_OW 128
// end ;
19028: LD_VAR 0 3
19032: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19033: LD_INT 0
19035: PPUSH
19036: PPUSH
19037: PPUSH
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19042: LD_ADDR_VAR 0 5
19046: PUSH
19047: LD_INT 22
19049: PUSH
19050: LD_VAR 0 1
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: LD_INT 21
19061: PUSH
19062: LD_INT 1
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PUSH
19069: LD_INT 3
19071: PUSH
19072: LD_INT 55
19074: PUSH
19075: EMPTY
19076: LIST
19077: PUSH
19078: EMPTY
19079: LIST
19080: LIST
19081: PUSH
19082: LD_INT 3
19084: PUSH
19085: LD_INT 54
19087: PUSH
19088: EMPTY
19089: LIST
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PUSH
19095: LD_INT 3
19097: PUSH
19098: LD_INT 24
19100: PUSH
19101: LD_INT 1000
19103: PUSH
19104: EMPTY
19105: LIST
19106: LIST
19107: PUSH
19108: EMPTY
19109: LIST
19110: LIST
19111: PUSH
19112: EMPTY
19113: LIST
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: PPUSH
19119: CALL_OW 69
19123: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19124: LD_ADDR_VAR 0 8
19128: PUSH
19129: LD_VAR 0 1
19133: PPUSH
19134: LD_INT 30
19136: PUSH
19137: LD_INT 1
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: PPUSH
19144: CALL 11393 0 2
19148: ST_TO_ADDR
// r := [ ] ;
19149: LD_ADDR_VAR 0 6
19153: PUSH
19154: EMPTY
19155: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19156: LD_VAR 0 1
19160: PPUSH
19161: LD_INT 5
19163: PPUSH
19164: EMPTY
19165: PPUSH
19166: CALL 12096 0 3
19170: IFFALSE 19226
// for j in MCF_Tag ( side , 5 , [ ] ) do
19172: LD_ADDR_VAR 0 4
19176: PUSH
19177: LD_VAR 0 1
19181: PPUSH
19182: LD_INT 5
19184: PPUSH
19185: EMPTY
19186: PPUSH
19187: CALL 12096 0 3
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19224
// if GetLives ( j ) = 1000 then
19195: LD_VAR 0 4
19199: PPUSH
19200: CALL_OW 256
19204: PUSH
19205: LD_INT 1000
19207: EQUAL
19208: IFFALSE 19222
// SetTag ( j , 0 ) ;
19210: LD_VAR 0 4
19214: PPUSH
19215: LD_INT 0
19217: PPUSH
19218: CALL_OW 109
19222: GO 19192
19224: POP
19225: POP
// if tmp then
19226: LD_VAR 0 5
19230: IFFALSE 19559
// begin r := [ tmp [ 1 ] ] ;
19232: LD_ADDR_VAR 0 6
19236: PUSH
19237: LD_VAR 0 5
19241: PUSH
19242: LD_INT 1
19244: ARRAY
19245: PUSH
19246: EMPTY
19247: LIST
19248: ST_TO_ADDR
// for i = 2 to tmp do
19249: LD_ADDR_VAR 0 3
19253: PUSH
19254: DOUBLE
19255: LD_INT 2
19257: DEC
19258: ST_TO_ADDR
19259: LD_VAR 0 5
19263: PUSH
19264: FOR_TO
19265: IFFALSE 19557
// begin m := false ;
19267: LD_ADDR_VAR 0 7
19271: PUSH
19272: LD_INT 0
19274: ST_TO_ADDR
// if d then
19275: LD_VAR 0 8
19279: IFFALSE 19434
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19281: LD_VAR 0 5
19285: PUSH
19286: LD_VAR 0 3
19290: ARRAY
19291: PPUSH
19292: CALL_OW 256
19296: PUSH
19297: LD_INT 650
19299: LESS
19300: PUSH
19301: LD_VAR 0 5
19305: PUSH
19306: LD_VAR 0 3
19310: ARRAY
19311: PPUSH
19312: LD_VAR 0 8
19316: PUSH
19317: LD_INT 1
19319: ARRAY
19320: PPUSH
19321: CALL_OW 250
19325: PPUSH
19326: LD_VAR 0 8
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: PPUSH
19335: CALL_OW 251
19339: PPUSH
19340: CALL_OW 297
19344: PUSH
19345: LD_INT 10
19347: GREATER
19348: AND
19349: IFFALSE 19434
// begin if not GetTag ( tmp [ i ] ) = 5 then
19351: LD_VAR 0 5
19355: PUSH
19356: LD_VAR 0 3
19360: ARRAY
19361: PPUSH
19362: CALL_OW 110
19366: PUSH
19367: LD_INT 5
19369: EQUAL
19370: NOT
19371: IFFALSE 19391
// SetTag ( tmp [ i ] , 5 ) ;
19373: LD_VAR 0 5
19377: PUSH
19378: LD_VAR 0 3
19382: ARRAY
19383: PPUSH
19384: LD_INT 5
19386: PPUSH
19387: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19391: LD_VAR 0 5
19395: PUSH
19396: LD_VAR 0 3
19400: ARRAY
19401: PPUSH
19402: LD_VAR 0 8
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PPUSH
19411: CALL_OW 250
19415: PPUSH
19416: LD_VAR 0 8
19420: PUSH
19421: LD_INT 1
19423: ARRAY
19424: PPUSH
19425: CALL_OW 251
19429: PPUSH
19430: CALL_OW 111
// end ; for j = 1 to r do
19434: LD_ADDR_VAR 0 4
19438: PUSH
19439: DOUBLE
19440: LD_INT 1
19442: DEC
19443: ST_TO_ADDR
19444: LD_VAR 0 6
19448: PUSH
19449: FOR_TO
19450: IFFALSE 19524
// if GetLives ( tmp [ i ] ) < r [ j ] then
19452: LD_VAR 0 5
19456: PUSH
19457: LD_VAR 0 3
19461: ARRAY
19462: PPUSH
19463: CALL_OW 256
19467: PUSH
19468: LD_VAR 0 6
19472: PUSH
19473: LD_VAR 0 4
19477: ARRAY
19478: LESS
19479: IFFALSE 19522
// begin r := Insert ( r , j , tmp [ i ] ) ;
19481: LD_ADDR_VAR 0 6
19485: PUSH
19486: LD_VAR 0 6
19490: PPUSH
19491: LD_VAR 0 4
19495: PPUSH
19496: LD_VAR 0 5
19500: PUSH
19501: LD_VAR 0 3
19505: ARRAY
19506: PPUSH
19507: CALL_OW 2
19511: ST_TO_ADDR
// m := true ;
19512: LD_ADDR_VAR 0 7
19516: PUSH
19517: LD_INT 1
19519: ST_TO_ADDR
// break ;
19520: GO 19524
// end ;
19522: GO 19449
19524: POP
19525: POP
// if not m then
19526: LD_VAR 0 7
19530: NOT
19531: IFFALSE 19555
// r := r ^ tmp [ i ] ;
19533: LD_ADDR_VAR 0 6
19537: PUSH
19538: LD_VAR 0 6
19542: PUSH
19543: LD_VAR 0 5
19547: PUSH
19548: LD_VAR 0 3
19552: ARRAY
19553: ADD
19554: ST_TO_ADDR
// end ;
19555: GO 19264
19557: POP
19558: POP
// end ; result := r end ; end_of_file
19559: LD_ADDR_VAR 0 2
19563: PUSH
19564: LD_VAR 0 6
19568: ST_TO_ADDR
19569: LD_VAR 0 2
19573: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19574: LD_INT 0
19576: PPUSH
19577: PPUSH
19578: PPUSH
// pom := GetBase ( bdepot ) ;
19579: LD_ADDR_VAR 0 3
19583: PUSH
19584: LD_VAR 0 1
19588: PPUSH
19589: CALL_OW 274
19593: ST_TO_ADDR
// sor := [ ] ;
19594: LD_ADDR_VAR 0 4
19598: PUSH
19599: EMPTY
19600: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19601: LD_ADDR_VAR 0 4
19605: PUSH
19606: LD_VAR 0 4
19610: PUSH
19611: LD_VAR 0 3
19615: PPUSH
19616: LD_INT 1
19618: PPUSH
19619: CALL_OW 275
19623: ADD
19624: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19625: LD_ADDR_VAR 0 4
19629: PUSH
19630: LD_VAR 0 4
19634: PUSH
19635: LD_VAR 0 3
19639: PPUSH
19640: LD_INT 2
19642: PPUSH
19643: CALL_OW 275
19647: ADD
19648: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19649: LD_ADDR_VAR 0 4
19653: PUSH
19654: LD_VAR 0 4
19658: PUSH
19659: LD_VAR 0 3
19663: PPUSH
19664: LD_INT 3
19666: PPUSH
19667: CALL_OW 275
19671: ADD
19672: ST_TO_ADDR
// result := sor ;
19673: LD_ADDR_VAR 0 2
19677: PUSH
19678: LD_VAR 0 4
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 2
19687: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19688: LD_INT 0
19690: PPUSH
19691: PPUSH
// while ( coord_list ) do
19692: LD_VAR 0 3
19696: IFFALSE 19870
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19698: LD_ADDR_EXP 46
19702: PUSH
19703: LD_EXP 46
19707: PPUSH
19708: LD_VAR 0 1
19712: PPUSH
19713: LD_VAR 0 2
19717: PPUSH
19718: LD_VAR 0 3
19722: PUSH
19723: LD_INT 1
19725: ARRAY
19726: PUSH
19727: LD_VAR 0 3
19731: PUSH
19732: LD_INT 2
19734: ARRAY
19735: PUSH
19736: LD_VAR 0 3
19740: PUSH
19741: LD_INT 3
19743: ARRAY
19744: PUSH
19745: EMPTY
19746: LIST
19747: LIST
19748: LIST
19749: PPUSH
19750: CALL 42143 0 4
19754: ST_TO_ADDR
// if weapon_list then
19755: LD_VAR 0 4
19759: IFFALSE 19830
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19761: LD_ADDR_EXP 43
19765: PUSH
19766: LD_EXP 43
19770: PPUSH
19771: LD_VAR 0 1
19775: PPUSH
19776: LD_VAR 0 4
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: LD_VAR 0 3
19789: PUSH
19790: LD_INT 1
19792: ARRAY
19793: PUSH
19794: LD_VAR 0 3
19798: PUSH
19799: LD_INT 2
19801: ARRAY
19802: PUSH
19803: EMPTY
19804: LIST
19805: LIST
19806: PPUSH
19807: CALL 42143 0 4
19811: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19812: LD_ADDR_VAR 0 4
19816: PUSH
19817: LD_VAR 0 4
19821: PPUSH
19822: LD_INT 1
19824: PPUSH
19825: CALL_OW 3
19829: ST_TO_ADDR
// end ; for i = 1 to 3 do
19830: LD_ADDR_VAR 0 6
19834: PUSH
19835: DOUBLE
19836: LD_INT 1
19838: DEC
19839: ST_TO_ADDR
19840: LD_INT 3
19842: PUSH
19843: FOR_TO
19844: IFFALSE 19866
// coord_list := Delete ( coord_list , 1 ) ;
19846: LD_ADDR_VAR 0 3
19850: PUSH
19851: LD_VAR 0 3
19855: PPUSH
19856: LD_INT 1
19858: PPUSH
19859: CALL_OW 3
19863: ST_TO_ADDR
19864: GO 19843
19866: POP
19867: POP
// end ;
19868: GO 19692
// result := true ;
19870: LD_ADDR_VAR 0 5
19874: PUSH
19875: LD_INT 1
19877: ST_TO_ADDR
// end ;
19878: LD_VAR 0 5
19882: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19883: LD_INT 0
19885: PPUSH
19886: PPUSH
// if not weapon_list then
19887: LD_VAR 0 3
19891: NOT
19892: IFFALSE 19896
// exit ;
19894: GO 20011
// while ( coord_list ) do
19896: LD_VAR 0 2
19900: IFFALSE 20011
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19902: LD_ADDR_EXP 43
19906: PUSH
19907: LD_EXP 43
19911: PPUSH
19912: LD_VAR 0 1
19916: PPUSH
19917: LD_VAR 0 3
19921: PUSH
19922: LD_INT 1
19924: ARRAY
19925: PPUSH
19926: LD_VAR 0 2
19930: PUSH
19931: LD_INT 1
19933: ARRAY
19934: PUSH
19935: LD_VAR 0 2
19939: PUSH
19940: LD_INT 2
19942: ARRAY
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: PPUSH
19948: CALL 42143 0 4
19952: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19953: LD_ADDR_VAR 0 3
19957: PUSH
19958: LD_VAR 0 3
19962: PPUSH
19963: LD_INT 1
19965: PPUSH
19966: CALL_OW 3
19970: ST_TO_ADDR
// for i = 1 to 2 do
19971: LD_ADDR_VAR 0 5
19975: PUSH
19976: DOUBLE
19977: LD_INT 1
19979: DEC
19980: ST_TO_ADDR
19981: LD_INT 2
19983: PUSH
19984: FOR_TO
19985: IFFALSE 20007
// coord_list := Delete ( coord_list , 1 ) ;
19987: LD_ADDR_VAR 0 2
19991: PUSH
19992: LD_VAR 0 2
19996: PPUSH
19997: LD_INT 1
19999: PPUSH
20000: CALL_OW 3
20004: ST_TO_ADDR
20005: GO 19984
20007: POP
20008: POP
// end ;
20009: GO 19896
// end ;
20011: LD_VAR 0 4
20015: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20016: LD_INT 0
20018: PPUSH
20019: PPUSH
// while ( coord_list ) do
20020: LD_VAR 0 2
20024: IFFALSE 20179
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20026: LD_VAR 0 2
20030: PUSH
20031: LD_INT 1
20033: ARRAY
20034: PPUSH
20035: LD_VAR 0 2
20039: PUSH
20040: LD_INT 2
20042: ARRAY
20043: PPUSH
20044: CALL_OW 428
20048: IFFALSE 20139
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20050: LD_VAR 0 2
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 2
20063: PUSH
20064: LD_INT 2
20066: ARRAY
20067: PPUSH
20068: CALL_OW 428
20072: PPUSH
20073: CALL_OW 266
20077: PUSH
20078: LD_INT 31
20080: PUSH
20081: LD_INT 32
20083: PUSH
20084: LD_INT 33
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: LIST
20091: IN
20092: IFFALSE 20139
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20094: LD_ADDR_EXP 52
20098: PUSH
20099: LD_EXP 52
20103: PPUSH
20104: LD_VAR 0 1
20108: PPUSH
20109: LD_VAR 0 2
20113: PUSH
20114: LD_INT 1
20116: ARRAY
20117: PPUSH
20118: LD_VAR 0 2
20122: PUSH
20123: LD_INT 2
20125: ARRAY
20126: PPUSH
20127: CALL_OW 428
20131: PPUSH
20132: EMPTY
20133: PPUSH
20134: CALL 42143 0 4
20138: ST_TO_ADDR
// for i = 1 to 3 do
20139: LD_ADDR_VAR 0 4
20143: PUSH
20144: DOUBLE
20145: LD_INT 1
20147: DEC
20148: ST_TO_ADDR
20149: LD_INT 3
20151: PUSH
20152: FOR_TO
20153: IFFALSE 20175
// coord_list := Delete ( coord_list , 1 ) ;
20155: LD_ADDR_VAR 0 2
20159: PUSH
20160: LD_VAR 0 2
20164: PPUSH
20165: LD_INT 1
20167: PPUSH
20168: CALL_OW 3
20172: ST_TO_ADDR
20173: GO 20152
20175: POP
20176: POP
// end ;
20177: GO 20020
// result := true ;
20179: LD_ADDR_VAR 0 3
20183: PUSH
20184: LD_INT 1
20186: ST_TO_ADDR
// end ;
20187: LD_VAR 0 3
20191: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20192: LD_INT 0
20194: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20195: LD_ADDR_EXP 46
20199: PUSH
20200: LD_EXP 46
20204: PPUSH
20205: LD_VAR 0 1
20209: PPUSH
20210: LD_INT 0
20212: PPUSH
20213: LD_VAR 0 2
20217: PPUSH
20218: CALL 42143 0 4
20222: ST_TO_ADDR
// end ;
20223: LD_VAR 0 3
20227: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20228: LD_INT 0
20230: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20231: LD_ADDR_EXP 46
20235: PUSH
20236: LD_EXP 46
20240: PPUSH
20241: LD_VAR 0 1
20245: PPUSH
20246: LD_INT 6
20248: PPUSH
20249: LD_VAR 0 2
20253: PPUSH
20254: CALL 42143 0 4
20258: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20259: LD_ADDR_EXP 49
20263: PUSH
20264: LD_EXP 49
20268: PPUSH
20269: LD_VAR 0 1
20273: PPUSH
20274: LD_VAR 0 3
20278: PUSH
20279: LD_INT 1
20281: ARRAY
20282: PPUSH
20283: LD_VAR 0 3
20287: PUSH
20288: LD_INT 2
20290: ARRAY
20291: PPUSH
20292: CALL 42143 0 4
20296: ST_TO_ADDR
// end ;
20297: LD_VAR 0 4
20301: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20302: LD_INT 0
20304: PPUSH
20305: PPUSH
// if ext_list > 5 then
20306: LD_VAR 0 3
20310: PUSH
20311: LD_INT 5
20313: GREATER
20314: IFFALSE 20358
// for i = 6 to ext_list do
20316: LD_ADDR_VAR 0 5
20320: PUSH
20321: DOUBLE
20322: LD_INT 6
20324: DEC
20325: ST_TO_ADDR
20326: LD_VAR 0 3
20330: PUSH
20331: FOR_TO
20332: IFFALSE 20356
// ext_list := Delete ( ext_list , ext_list ) ;
20334: LD_ADDR_VAR 0 3
20338: PUSH
20339: LD_VAR 0 3
20343: PPUSH
20344: LD_VAR 0 3
20348: PPUSH
20349: CALL_OW 3
20353: ST_TO_ADDR
20354: GO 20331
20356: POP
20357: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20358: LD_VAR 0 1
20362: PPUSH
20363: LD_VAR 0 2
20367: PUSH
20368: LD_INT 1
20370: ARRAY
20371: PPUSH
20372: LD_VAR 0 2
20376: PUSH
20377: LD_INT 2
20379: ARRAY
20380: PPUSH
20381: LD_VAR 0 2
20385: PUSH
20386: LD_INT 3
20388: ARRAY
20389: PPUSH
20390: LD_VAR 0 3
20394: PPUSH
20395: CALL 8905 0 5
// end ;
20399: LD_VAR 0 4
20403: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20404: LD_INT 0
20406: PPUSH
20407: PPUSH
20408: PPUSH
// p := 1 ;
20409: LD_ADDR_VAR 0 6
20413: PUSH
20414: LD_INT 1
20416: ST_TO_ADDR
// if type_list = [ ] then
20417: LD_VAR 0 3
20421: PUSH
20422: EMPTY
20423: EQUAL
20424: IFFALSE 20434
// type_list := b_oil_power ;
20426: LD_ADDR_VAR 0 3
20430: PUSH
20431: LD_INT 26
20433: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20434: LD_ADDR_VAR 0 5
20438: PUSH
20439: DOUBLE
20440: LD_INT 1
20442: DEC
20443: ST_TO_ADDR
20444: LD_VAR 0 2
20448: PUSH
20449: LD_INT 3
20451: DIVREAL
20452: PUSH
20453: FOR_TO
20454: IFFALSE 20557
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20456: LD_ADDR_EXP 46
20460: PUSH
20461: LD_EXP 46
20465: PPUSH
20466: LD_VAR 0 1
20470: PPUSH
20471: LD_VAR 0 3
20475: PUSH
20476: LD_INT 1
20478: PPUSH
20479: LD_VAR 0 3
20483: PPUSH
20484: CALL_OW 12
20488: ARRAY
20489: PPUSH
20490: LD_VAR 0 2
20494: PUSH
20495: LD_VAR 0 6
20499: ARRAY
20500: PUSH
20501: LD_VAR 0 2
20505: PUSH
20506: LD_VAR 0 6
20510: PUSH
20511: LD_INT 1
20513: PLUS
20514: ARRAY
20515: PUSH
20516: LD_VAR 0 2
20520: PUSH
20521: LD_VAR 0 6
20525: PUSH
20526: LD_INT 2
20528: PLUS
20529: ARRAY
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: LIST
20535: PPUSH
20536: CALL 42143 0 4
20540: ST_TO_ADDR
// p := p + 3 ;
20541: LD_ADDR_VAR 0 6
20545: PUSH
20546: LD_VAR 0 6
20550: PUSH
20551: LD_INT 3
20553: PLUS
20554: ST_TO_ADDR
// end ;
20555: GO 20453
20557: POP
20558: POP
// end ;
20559: LD_VAR 0 4
20563: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20564: LD_INT 0
20566: PPUSH
20567: PPUSH
20568: PPUSH
20569: PPUSH
// if not MREG_Deposit [ side ] then
20570: LD_EXP 61
20574: PUSH
20575: LD_VAR 0 1
20579: ARRAY
20580: NOT
20581: IFFALSE 20585
// exit ;
20583: GO 20762
// p := 1 ;
20585: LD_ADDR_VAR 0 4
20589: PUSH
20590: LD_INT 1
20592: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20593: LD_ADDR_VAR 0 3
20597: PUSH
20598: DOUBLE
20599: LD_INT 1
20601: DEC
20602: ST_TO_ADDR
20603: LD_EXP 61
20607: PUSH
20608: LD_VAR 0 1
20612: ARRAY
20613: PUSH
20614: LD_INT 3
20616: DIVREAL
20617: PUSH
20618: FOR_TO
20619: IFFALSE 20760
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20621: LD_EXP 61
20625: PUSH
20626: LD_VAR 0 1
20630: ARRAY
20631: PUSH
20632: LD_VAR 0 4
20636: PUSH
20637: LD_INT 2
20639: PLUS
20640: ARRAY
20641: PUSH
20642: LD_INT 2
20644: EQUAL
20645: IFFALSE 20657
// b := b_oil_mine else
20647: LD_ADDR_VAR 0 5
20651: PUSH
20652: LD_INT 29
20654: ST_TO_ADDR
20655: GO 20665
// b := b_siberite_mine ;
20657: LD_ADDR_VAR 0 5
20661: PUSH
20662: LD_INT 30
20664: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20665: LD_ADDR_EXP 46
20669: PUSH
20670: LD_EXP 46
20674: PPUSH
20675: LD_VAR 0 1
20679: PPUSH
20680: LD_VAR 0 5
20684: PPUSH
20685: LD_EXP 61
20689: PUSH
20690: LD_VAR 0 1
20694: ARRAY
20695: PUSH
20696: LD_VAR 0 4
20700: ARRAY
20701: PUSH
20702: LD_EXP 61
20706: PUSH
20707: LD_VAR 0 1
20711: ARRAY
20712: PUSH
20713: LD_VAR 0 4
20717: PUSH
20718: LD_INT 1
20720: PLUS
20721: ARRAY
20722: PUSH
20723: LD_INT 0
20725: PPUSH
20726: LD_INT 5
20728: PPUSH
20729: CALL_OW 12
20733: PUSH
20734: EMPTY
20735: LIST
20736: LIST
20737: LIST
20738: PPUSH
20739: CALL 42143 0 4
20743: ST_TO_ADDR
// p := p + 3 ;
20744: LD_ADDR_VAR 0 4
20748: PUSH
20749: LD_VAR 0 4
20753: PUSH
20754: LD_INT 3
20756: PLUS
20757: ST_TO_ADDR
// end ;
20758: GO 20618
20760: POP
20761: POP
// end ;
20762: LD_VAR 0 2
20766: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20767: LD_INT 0
20769: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20770: LD_ADDR_EXP 46
20774: PUSH
20775: LD_EXP 46
20779: PPUSH
20780: LD_VAR 0 1
20784: PPUSH
20785: LD_INT 4
20787: PPUSH
20788: LD_VAR 0 2
20792: PPUSH
20793: CALL 42143 0 4
20797: ST_TO_ADDR
// end ;
20798: LD_VAR 0 3
20802: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20803: LD_INT 0
20805: PPUSH
// case nation of 1 , us :
20806: LD_VAR 0 2
20810: PUSH
20811: LD_INT 1
20813: DOUBLE
20814: EQUAL
20815: IFTRUE 20825
20817: LD_STRING us
20819: DOUBLE
20820: EQUAL
20821: IFTRUE 20825
20823: GO 20856
20825: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20826: LD_ADDR_EXP 46
20830: PUSH
20831: LD_EXP 46
20835: PPUSH
20836: LD_VAR 0 1
20840: PPUSH
20841: LD_INT 36
20843: PPUSH
20844: LD_VAR 0 3
20848: PPUSH
20849: CALL 42143 0 4
20853: ST_TO_ADDR
20854: GO 20907
20856: LD_INT 2
20858: DOUBLE
20859: EQUAL
20860: IFTRUE 20870
20862: LD_STRING ar
20864: DOUBLE
20865: EQUAL
20866: IFTRUE 20870
20868: GO 20906
20870: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20871: LD_ADDR_EXP 46
20875: PUSH
20876: LD_VAR 0 1
20880: PPUSH
20881: LD_INT 14
20883: PUSH
20884: LD_INT 2
20886: PUSH
20887: LD_INT 1
20889: PUSH
20890: LD_INT 31
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: PPUSH
20899: CALL 20912 0 2
20903: ST_TO_ADDR
20904: GO 20907
20906: POP
// end ;
20907: LD_VAR 0 4
20911: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20912: LD_INT 0
20914: PPUSH
20915: PPUSH
// for i = 1 to list do
20916: LD_ADDR_VAR 0 4
20920: PUSH
20921: DOUBLE
20922: LD_INT 1
20924: DEC
20925: ST_TO_ADDR
20926: LD_VAR 0 2
20930: PUSH
20931: FOR_TO
20932: IFFALSE 20982
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20934: LD_ADDR_EXP 51
20938: PUSH
20939: LD_EXP 51
20943: PPUSH
20944: LD_VAR 0 1
20948: PPUSH
20949: LD_EXP 51
20953: PUSH
20954: LD_VAR 0 1
20958: ARRAY
20959: PUSH
20960: LD_INT 1
20962: PLUS
20963: PPUSH
20964: LD_VAR 0 2
20968: PUSH
20969: LD_VAR 0 4
20973: ARRAY
20974: PPUSH
20975: CALL 30861 0 4
20979: ST_TO_ADDR
20980: GO 20931
20982: POP
20983: POP
// end ;
20984: LD_VAR 0 3
20988: RET
// export function MCS_GetVehicleList ( side ) ; begin
20989: LD_INT 0
20991: PPUSH
// result := MREG_ToConstruct [ side ] ;
20992: LD_ADDR_VAR 0 2
20996: PUSH
20997: LD_EXP 51
21001: PUSH
21002: LD_VAR 0 1
21006: ARRAY
21007: ST_TO_ADDR
// end ;
21008: LD_VAR 0 2
21012: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21013: LD_INT 0
21015: PPUSH
21016: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21017: LD_ADDR_EXP 58
21021: PUSH
21022: LD_EXP 58
21026: PPUSH
21027: LD_VAR 0 1
21031: PPUSH
21032: LD_VAR 0 2
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// end ;
21042: LD_VAR 0 3
21046: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21047: LD_INT 0
21049: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21050: LD_ADDR_EXP 37
21054: PUSH
21055: LD_EXP 37
21059: PPUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: LD_VAR 0 2
21069: PPUSH
21070: CALL_OW 1
21074: ST_TO_ADDR
// end ;
21075: LD_VAR 0 3
21079: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21080: LD_INT 0
21082: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21083: LD_ADDR_EXP 38
21087: PUSH
21088: LD_EXP 38
21092: PPUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: LD_VAR 0 2
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// end ;
21108: LD_VAR 0 3
21112: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21113: LD_INT 0
21115: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21116: LD_ADDR_EXP 60
21120: PUSH
21121: LD_EXP 60
21125: PPUSH
21126: LD_VAR 0 1
21130: PPUSH
21131: LD_INT 1
21133: PPUSH
21134: LD_VAR 0 2
21138: PPUSH
21139: CALL 30861 0 4
21143: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21144: LD_ADDR_EXP 60
21148: PUSH
21149: LD_EXP 60
21153: PPUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: LD_INT 2
21161: PPUSH
21162: LD_VAR 0 3
21166: PPUSH
21167: CALL 30861 0 4
21171: ST_TO_ADDR
// end ;
21172: LD_VAR 0 4
21176: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21177: LD_INT 0
21179: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21180: LD_ADDR_EXP 72
21184: PUSH
21185: LD_EXP 72
21189: PPUSH
21190: LD_INT 1
21192: PPUSH
21193: LD_VAR 0 1
21197: PPUSH
21198: CALL_OW 1
21202: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21203: LD_ADDR_EXP 72
21207: PUSH
21208: LD_EXP 72
21212: PPUSH
21213: LD_INT 2
21215: PPUSH
21216: LD_VAR 0 2
21220: PPUSH
21221: CALL_OW 1
21225: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21226: LD_ADDR_EXP 72
21230: PUSH
21231: LD_EXP 72
21235: PPUSH
21236: LD_INT 3
21238: PPUSH
21239: LD_VAR 0 3
21243: PPUSH
21244: CALL_OW 1
21248: ST_TO_ADDR
// end ;
21249: LD_VAR 0 4
21253: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21254: LD_INT 0
21256: PPUSH
21257: PPUSH
21258: PPUSH
// if not side or not list then
21259: LD_VAR 0 1
21263: NOT
21264: PUSH
21265: LD_VAR 0 2
21269: NOT
21270: OR
21271: IFFALSE 21275
// exit ;
21273: GO 21443
// SetTech ( 20 , side , state_researched ) ;
21275: LD_INT 20
21277: PPUSH
21278: LD_VAR 0 1
21282: PPUSH
21283: LD_INT 2
21285: PPUSH
21286: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21290: LD_ADDR_EXP 61
21294: PUSH
21295: LD_EXP 61
21299: PPUSH
21300: LD_VAR 0 1
21304: PPUSH
21305: LD_VAR 0 2
21309: PPUSH
21310: CALL_OW 2
21314: ST_TO_ADDR
// p := 1 ;
21315: LD_ADDR_VAR 0 5
21319: PUSH
21320: LD_INT 1
21322: ST_TO_ADDR
// for i = 1 to list / 3 do
21323: LD_ADDR_VAR 0 4
21327: PUSH
21328: DOUBLE
21329: LD_INT 1
21331: DEC
21332: ST_TO_ADDR
21333: LD_VAR 0 2
21337: PUSH
21338: LD_INT 3
21340: DIVREAL
21341: PUSH
21342: FOR_TO
21343: IFFALSE 21441
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21345: LD_VAR 0 2
21349: PUSH
21350: LD_VAR 0 5
21354: ARRAY
21355: PPUSH
21356: LD_VAR 0 2
21360: PUSH
21361: LD_VAR 0 5
21365: PUSH
21366: LD_INT 1
21368: PLUS
21369: ARRAY
21370: PPUSH
21371: LD_VAR 0 2
21375: PUSH
21376: LD_VAR 0 5
21380: PUSH
21381: LD_INT 2
21383: PLUS
21384: ARRAY
21385: PPUSH
21386: CALL 22145 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21390: LD_VAR 0 2
21394: PUSH
21395: LD_VAR 0 5
21399: ARRAY
21400: PPUSH
21401: LD_VAR 0 2
21405: PUSH
21406: LD_VAR 0 5
21410: PUSH
21411: LD_INT 1
21413: PLUS
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 1
21420: PPUSH
21421: CALL_OW 441
// p := p + 3 ;
21425: LD_ADDR_VAR 0 5
21429: PUSH
21430: LD_VAR 0 5
21434: PUSH
21435: LD_INT 3
21437: PLUS
21438: ST_TO_ADDR
// end ;
21439: GO 21342
21441: POP
21442: POP
// end ;
21443: LD_VAR 0 3
21447: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
// if nat = nation_arabian then
21452: LD_VAR 0 2
21456: PUSH
21457: LD_INT 2
21459: EQUAL
21460: IFFALSE 21466
// exit else
21462: GO 21538
21464: GO 21524
// if nat = nation_american then
21466: LD_VAR 0 2
21470: PUSH
21471: LD_INT 1
21473: EQUAL
21474: IFFALSE 21501
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21476: LD_ADDR_VAR 0 4
21480: PUSH
21481: LD_INT 4
21483: PUSH
21484: LD_INT 3
21486: PUSH
21487: LD_INT 1
21489: PUSH
21490: LD_INT 8
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: LIST
21497: LIST
21498: ST_TO_ADDR
21499: GO 21524
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21501: LD_ADDR_VAR 0 4
21505: PUSH
21506: LD_INT 24
21508: PUSH
21509: LD_INT 3
21511: PUSH
21512: LD_INT 1
21514: PUSH
21515: LD_INT 48
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: LIST
21522: LIST
21523: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21524: LD_VAR 0 1
21528: PPUSH
21529: LD_VAR 0 4
21533: PPUSH
21534: CALL 20912 0 2
// end ;
21538: LD_VAR 0 3
21542: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21543: LD_INT 0
21545: PPUSH
21546: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21547: LD_ADDR_EXP 63
21551: PUSH
21552: LD_EXP 63
21556: PPUSH
21557: LD_VAR 0 1
21561: PPUSH
21562: LD_INT 1
21564: PPUSH
21565: LD_VAR 0 4
21569: PPUSH
21570: CALL 30861 0 4
21574: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21575: LD_ADDR_EXP 64
21579: PUSH
21580: LD_EXP 64
21584: PPUSH
21585: LD_VAR 0 1
21589: PPUSH
21590: LD_INT 1
21592: PPUSH
21593: LD_VAR 0 2
21597: PPUSH
21598: CALL 30861 0 4
21602: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21603: LD_ADDR_EXP 65
21607: PUSH
21608: LD_EXP 65
21612: PPUSH
21613: LD_VAR 0 1
21617: PPUSH
21618: LD_INT 1
21620: PPUSH
21621: LD_VAR 0 3
21625: PPUSH
21626: CALL 30861 0 4
21630: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21631: LD_ADDR_EXP 66
21635: PUSH
21636: LD_EXP 66
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 1
21648: PPUSH
21649: LD_VAR 0 5
21653: PPUSH
21654: CALL 30861 0 4
21658: ST_TO_ADDR
// while squad do
21659: LD_VAR 0 5
21663: IFFALSE 21756
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21665: LD_VAR 0 1
21669: PPUSH
21670: LD_VAR 0 5
21674: PUSH
21675: LD_INT 1
21677: ARRAY
21678: PUSH
21679: LD_VAR 0 5
21683: PUSH
21684: LD_INT 2
21686: ARRAY
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: ARRAY
21696: PUSH
21697: LD_VAR 0 5
21701: PUSH
21702: LD_INT 4
21704: ARRAY
21705: PUSH
21706: EMPTY
21707: LIST
21708: LIST
21709: LIST
21710: LIST
21711: PPUSH
21712: CALL 20912 0 2
// for i = 1 to 4 do
21716: LD_ADDR_VAR 0 7
21720: PUSH
21721: DOUBLE
21722: LD_INT 1
21724: DEC
21725: ST_TO_ADDR
21726: LD_INT 4
21728: PUSH
21729: FOR_TO
21730: IFFALSE 21752
// squad := Delete ( squad , 1 ) ;
21732: LD_ADDR_VAR 0 5
21736: PUSH
21737: LD_VAR 0 5
21741: PPUSH
21742: LD_INT 1
21744: PPUSH
21745: CALL_OW 3
21749: ST_TO_ADDR
21750: GO 21729
21752: POP
21753: POP
// end ;
21754: GO 21659
// end ;
21756: LD_VAR 0 6
21760: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21761: LD_INT 0
21763: PPUSH
21764: PPUSH
// for i = 1 to squad do
21765: LD_ADDR_VAR 0 4
21769: PUSH
21770: DOUBLE
21771: LD_INT 1
21773: DEC
21774: ST_TO_ADDR
21775: LD_VAR 0 2
21779: PUSH
21780: FOR_TO
21781: IFFALSE 21831
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21783: LD_ADDR_EXP 69
21787: PUSH
21788: LD_EXP 69
21792: PPUSH
21793: LD_VAR 0 1
21797: PPUSH
21798: LD_EXP 69
21802: PUSH
21803: LD_VAR 0 1
21807: ARRAY
21808: PUSH
21809: LD_INT 1
21811: PLUS
21812: PPUSH
21813: LD_VAR 0 2
21817: PUSH
21818: LD_VAR 0 4
21822: ARRAY
21823: PPUSH
21824: CALL 30861 0 4
21828: ST_TO_ADDR
21829: GO 21780
21831: POP
21832: POP
// while squad do
21833: LD_VAR 0 2
21837: IFFALSE 21930
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21839: LD_VAR 0 1
21843: PPUSH
21844: LD_VAR 0 2
21848: PUSH
21849: LD_INT 1
21851: ARRAY
21852: PUSH
21853: LD_VAR 0 2
21857: PUSH
21858: LD_INT 2
21860: ARRAY
21861: PUSH
21862: LD_VAR 0 2
21866: PUSH
21867: LD_INT 3
21869: ARRAY
21870: PUSH
21871: LD_VAR 0 2
21875: PUSH
21876: LD_INT 4
21878: ARRAY
21879: PUSH
21880: EMPTY
21881: LIST
21882: LIST
21883: LIST
21884: LIST
21885: PPUSH
21886: CALL 20912 0 2
// for i = 1 to 4 do
21890: LD_ADDR_VAR 0 4
21894: PUSH
21895: DOUBLE
21896: LD_INT 1
21898: DEC
21899: ST_TO_ADDR
21900: LD_INT 4
21902: PUSH
21903: FOR_TO
21904: IFFALSE 21926
// squad := Delete ( squad , 1 ) ;
21906: LD_ADDR_VAR 0 2
21910: PUSH
21911: LD_VAR 0 2
21915: PPUSH
21916: LD_INT 1
21918: PPUSH
21919: CALL_OW 3
21923: ST_TO_ADDR
21924: GO 21903
21926: POP
21927: POP
// end ;
21928: GO 21833
// end ;
21930: LD_VAR 0 3
21934: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21935: LD_INT 0
21937: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21938: LD_ADDR_EXP 62
21942: PUSH
21943: LD_EXP 62
21947: PPUSH
21948: LD_VAR 0 1
21952: PPUSH
21953: LD_INT 1
21955: PPUSH
21956: LD_VAR 0 2
21960: PPUSH
21961: CALL 30861 0 4
21965: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21966: LD_ADDR_EXP 62
21970: PUSH
21971: LD_EXP 62
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: LD_INT 2
21983: PPUSH
21984: LD_VAR 0 3
21988: PPUSH
21989: CALL 30861 0 4
21993: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
21994: LD_ADDR_EXP 62
21998: PUSH
21999: LD_EXP 62
22003: PPUSH
22004: LD_VAR 0 1
22008: PPUSH
22009: LD_INT 3
22011: PPUSH
22012: LD_VAR 0 4
22016: PPUSH
22017: CALL 30861 0 4
22021: ST_TO_ADDR
// end ; end_of_file
22022: LD_VAR 0 5
22026: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22027: LD_INT 0
22029: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22030: LD_ADDR_EXP 42
22034: PUSH
22035: LD_EXP 42
22039: PPUSH
22040: LD_VAR 0 1
22044: PPUSH
22045: LD_INT 1
22047: PPUSH
22048: LD_VAR 0 2
22052: PPUSH
22053: CALL 30861 0 4
22057: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22058: LD_VAR 0 1
22062: PPUSH
22063: EMPTY
22064: PPUSH
22065: CALL 11528 0 2
22069: PUSH
22070: LD_INT 1
22072: ARRAY
22073: PPUSH
22074: CALL_OW 248
22078: PUSH
22079: LD_INT 1
22081: EQUAL
22082: IFFALSE 22113
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22084: LD_VAR 0 1
22088: PPUSH
22089: LD_INT 4
22091: PUSH
22092: LD_INT 1
22094: PUSH
22095: LD_INT 1
22097: PUSH
22098: LD_INT 14
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: LIST
22105: LIST
22106: PPUSH
22107: CALL 20912 0 2
22111: GO 22140
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_INT 24
22120: PUSH
22121: LD_INT 1
22123: PUSH
22124: LD_INT 1
22126: PUSH
22127: LD_INT 53
22129: PUSH
22130: EMPTY
22131: LIST
22132: LIST
22133: LIST
22134: LIST
22135: PPUSH
22136: CALL 20912 0 2
// end ;
22140: LD_VAR 0 3
22144: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22145: LD_INT 0
22147: PPUSH
// CreateDepositXY ( x , y , t ) ;
22148: LD_VAR 0 1
22152: PPUSH
22153: LD_VAR 0 2
22157: PPUSH
22158: LD_VAR 0 3
22162: PPUSH
22163: CALL_OW 62
// end ;
22167: LD_VAR 0 4
22171: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
// c := 1 ;
22176: LD_ADDR_VAR 0 5
22180: PUSH
22181: LD_INT 1
22183: ST_TO_ADDR
// case color of red :
22184: LD_VAR 0 3
22188: PUSH
22189: LD_STRING red
22191: DOUBLE
22192: EQUAL
22193: IFTRUE 22197
22195: GO 22208
22197: POP
// c = 1 ; dark-green :
22198: LD_ADDR_VAR 0 5
22202: PUSH
22203: LD_INT 1
22205: ST_TO_ADDR
22206: GO 22494
22208: LD_STRING dark-green
22210: DOUBLE
22211: EQUAL
22212: IFTRUE 22216
22214: GO 22227
22216: POP
// c = 2 ; purple :
22217: LD_ADDR_VAR 0 5
22221: PUSH
22222: LD_INT 2
22224: ST_TO_ADDR
22225: GO 22494
22227: LD_STRING purple
22229: DOUBLE
22230: EQUAL
22231: IFTRUE 22235
22233: GO 22246
22235: POP
// c = 3 ; aqua :
22236: LD_ADDR_VAR 0 5
22240: PUSH
22241: LD_INT 3
22243: ST_TO_ADDR
22244: GO 22494
22246: LD_STRING aqua
22248: DOUBLE
22249: EQUAL
22250: IFTRUE 22254
22252: GO 22265
22254: POP
// c = 4 ; grey :
22255: LD_ADDR_VAR 0 5
22259: PUSH
22260: LD_INT 4
22262: ST_TO_ADDR
22263: GO 22494
22265: LD_STRING grey
22267: DOUBLE
22268: EQUAL
22269: IFTRUE 22273
22271: GO 22284
22273: POP
// c = 5 ; lime :
22274: LD_ADDR_VAR 0 5
22278: PUSH
22279: LD_INT 5
22281: ST_TO_ADDR
22282: GO 22494
22284: LD_STRING lime
22286: DOUBLE
22287: EQUAL
22288: IFTRUE 22292
22290: GO 22303
22292: POP
// c = 6 ; tan :
22293: LD_ADDR_VAR 0 5
22297: PUSH
22298: LD_INT 6
22300: ST_TO_ADDR
22301: GO 22494
22303: LD_STRING tan
22305: DOUBLE
22306: EQUAL
22307: IFTRUE 22311
22309: GO 22322
22311: POP
// c = 7 ; pink :
22312: LD_ADDR_VAR 0 5
22316: PUSH
22317: LD_INT 7
22319: ST_TO_ADDR
22320: GO 22494
22322: LD_STRING pink
22324: DOUBLE
22325: EQUAL
22326: IFTRUE 22330
22328: GO 22341
22330: POP
// c = 8 ; green :
22331: LD_ADDR_VAR 0 5
22335: PUSH
22336: LD_INT 8
22338: ST_TO_ADDR
22339: GO 22494
22341: LD_STRING green
22343: DOUBLE
22344: EQUAL
22345: IFTRUE 22349
22347: GO 22360
22349: POP
// c = 9 ; blue :
22350: LD_ADDR_VAR 0 5
22354: PUSH
22355: LD_INT 9
22357: ST_TO_ADDR
22358: GO 22494
22360: LD_STRING blue
22362: DOUBLE
22363: EQUAL
22364: IFTRUE 22368
22366: GO 22379
22368: POP
// c = 10 ; yellow :
22369: LD_ADDR_VAR 0 5
22373: PUSH
22374: LD_INT 10
22376: ST_TO_ADDR
22377: GO 22494
22379: LD_STRING yellow
22381: DOUBLE
22382: EQUAL
22383: IFTRUE 22387
22385: GO 22398
22387: POP
// c = 11 ; brown :
22388: LD_ADDR_VAR 0 5
22392: PUSH
22393: LD_INT 11
22395: ST_TO_ADDR
22396: GO 22494
22398: LD_STRING brown
22400: DOUBLE
22401: EQUAL
22402: IFTRUE 22406
22404: GO 22417
22406: POP
// c = 12 ; black :
22407: LD_ADDR_VAR 0 5
22411: PUSH
22412: LD_INT 12
22414: ST_TO_ADDR
22415: GO 22494
22417: LD_STRING black
22419: DOUBLE
22420: EQUAL
22421: IFTRUE 22425
22423: GO 22436
22425: POP
// c = 13 ; aqua2 :
22426: LD_ADDR_VAR 0 5
22430: PUSH
22431: LD_INT 13
22433: ST_TO_ADDR
22434: GO 22494
22436: LD_STRING aqua2
22438: DOUBLE
22439: EQUAL
22440: IFTRUE 22444
22442: GO 22455
22444: POP
// c = 14 ; orange :
22445: LD_ADDR_VAR 0 5
22449: PUSH
22450: LD_INT 14
22452: ST_TO_ADDR
22453: GO 22494
22455: LD_STRING orange
22457: DOUBLE
22458: EQUAL
22459: IFTRUE 22463
22461: GO 22474
22463: POP
// c = 15 ; white :
22464: LD_ADDR_VAR 0 5
22468: PUSH
22469: LD_INT 15
22471: ST_TO_ADDR
22472: GO 22494
22474: LD_STRING white
22476: DOUBLE
22477: EQUAL
22478: IFTRUE 22482
22480: GO 22493
22482: POP
// c = 16 ; end ;
22483: LD_ADDR_VAR 0 5
22487: PUSH
22488: LD_INT 16
22490: ST_TO_ADDR
22491: GO 22494
22493: POP
// if HexInfo ( x , y ) = 0 then
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_VAR 0 2
22503: PPUSH
22504: CALL_OW 428
22508: PUSH
22509: LD_INT 0
22511: EQUAL
22512: IFFALSE 22536
// PlaceEnvironment ( x , y , 58 , c ) ;
22514: LD_VAR 0 1
22518: PPUSH
22519: LD_VAR 0 2
22523: PPUSH
22524: LD_INT 58
22526: PPUSH
22527: LD_VAR 0 5
22531: PPUSH
22532: CALL_OW 349
// end ;
22536: LD_VAR 0 4
22540: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22541: LD_INT 0
22543: PPUSH
// RemoveEnvironment ( x , y ) ;
22544: LD_VAR 0 1
22548: PPUSH
22549: LD_VAR 0 2
22553: PPUSH
22554: CALL_OW 347
// end ;
22558: LD_VAR 0 3
22562: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22563: LD_INT 0
22565: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22566: LD_INT 81
22568: PUSH
22569: LD_VAR 0 1
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: PPUSH
22578: CALL_OW 69
22582: PUSH
22583: LD_INT 0
22585: EQUAL
22586: IFFALSE 22598
// result := false else
22588: LD_ADDR_VAR 0 5
22592: PUSH
22593: LD_INT 0
22595: ST_TO_ADDR
22596: GO 22662
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22598: LD_INT 81
22600: PUSH
22601: LD_VAR 0 1
22605: PUSH
22606: EMPTY
22607: LIST
22608: LIST
22609: PUSH
22610: LD_INT 92
22612: PUSH
22613: LD_VAR 0 2
22617: PUSH
22618: LD_VAR 0 3
22622: PUSH
22623: LD_VAR 0 4
22627: PUSH
22628: EMPTY
22629: LIST
22630: LIST
22631: LIST
22632: LIST
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: PPUSH
22638: CALL_OW 69
22642: IFFALSE 22654
// result := true else
22644: LD_ADDR_VAR 0 5
22648: PUSH
22649: LD_INT 1
22651: ST_TO_ADDR
22652: GO 22662
// result := false ;
22654: LD_ADDR_VAR 0 5
22658: PUSH
22659: LD_INT 0
22661: ST_TO_ADDR
// end ;
22662: LD_VAR 0 5
22666: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22667: LD_INT 0
22669: PPUSH
22670: PPUSH
22671: PPUSH
22672: PPUSH
22673: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22674: LD_VAR 0 1
22678: PPUSH
22679: LD_INT 81
22681: PUSH
22682: LD_VAR 0 1
22686: PPUSH
22687: CALL_OW 255
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PPUSH
22696: CALL_OW 69
22700: PPUSH
22701: LD_VAR 0 1
22705: PPUSH
22706: CALL_OW 74
22710: PPUSH
22711: CALL_OW 119
// dir := GetDir ( un ) ;
22715: LD_ADDR_VAR 0 4
22719: PUSH
22720: LD_VAR 0 1
22724: PPUSH
22725: CALL_OW 254
22729: ST_TO_ADDR
// dir := dir - 3 ;
22730: LD_ADDR_VAR 0 4
22734: PUSH
22735: LD_VAR 0 4
22739: PUSH
22740: LD_INT 3
22742: MINUS
22743: ST_TO_ADDR
// if dir < 0 then
22744: LD_VAR 0 4
22748: PUSH
22749: LD_INT 0
22751: LESS
22752: IFFALSE 22768
// dir := dir + 6 ;
22754: LD_ADDR_VAR 0 4
22758: PUSH
22759: LD_VAR 0 4
22763: PUSH
22764: LD_INT 6
22766: PLUS
22767: ST_TO_ADDR
// while true do
22768: LD_INT 1
22770: IFFALSE 23267
// begin coord_dist := 3 ;
22772: LD_ADDR_VAR 0 3
22776: PUSH
22777: LD_INT 3
22779: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22780: LD_ADDR_VAR 0 5
22784: PUSH
22785: LD_VAR 0 1
22789: PPUSH
22790: CALL_OW 250
22794: PPUSH
22795: LD_VAR 0 4
22799: PPUSH
22800: LD_VAR 0 3
22804: PPUSH
22805: CALL_OW 272
22809: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22810: LD_ADDR_VAR 0 6
22814: PUSH
22815: LD_VAR 0 1
22819: PPUSH
22820: CALL_OW 251
22824: PPUSH
22825: LD_VAR 0 4
22829: PPUSH
22830: LD_VAR 0 3
22834: PPUSH
22835: CALL_OW 273
22839: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22840: LD_VAR 0 1
22844: PPUSH
22845: CALL_OW 255
22849: PPUSH
22850: LD_VAR 0 1
22854: PPUSH
22855: CALL_OW 250
22859: PPUSH
22860: LD_VAR 0 1
22864: PPUSH
22865: CALL_OW 251
22869: PPUSH
22870: LD_INT 14
22872: PPUSH
22873: CALL 22563 0 4
22877: PUSH
22878: LD_VAR 0 5
22882: PPUSH
22883: LD_VAR 0 6
22887: PPUSH
22888: CALL_OW 351
22892: OR
22893: PUSH
22894: LD_VAR 0 5
22898: PPUSH
22899: LD_VAR 0 6
22903: PPUSH
22904: CALL_OW 488
22908: PUSH
22909: LD_INT 0
22911: EQUAL
22912: OR
22913: PUSH
22914: LD_VAR 0 5
22918: PPUSH
22919: LD_VAR 0 6
22923: PPUSH
22924: CALL_OW 546
22928: PUSH
22929: LD_INT 1
22931: EQUAL
22932: OR
22933: PUSH
22934: LD_VAR 0 5
22938: PPUSH
22939: LD_VAR 0 6
22943: PPUSH
22944: CALL_OW 428
22948: PUSH
22949: LD_INT 0
22951: NONEQUAL
22952: OR
22953: IFFALSE 23181
// begin repeat begin Wait ( 0 0$0.3 ) ;
22955: LD_INT 10
22957: PPUSH
22958: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22962: LD_ADDR_VAR 0 3
22966: PUSH
22967: LD_VAR 0 3
22971: PUSH
22972: LD_INT 1
22974: PLUS
22975: ST_TO_ADDR
// dir := dir + 1 ;
22976: LD_ADDR_VAR 0 4
22980: PUSH
22981: LD_VAR 0 4
22985: PUSH
22986: LD_INT 1
22988: PLUS
22989: ST_TO_ADDR
// if dir > 5 then
22990: LD_VAR 0 4
22994: PUSH
22995: LD_INT 5
22997: GREATER
22998: IFFALSE 23008
// dir = 0 ;
23000: LD_ADDR_VAR 0 4
23004: PUSH
23005: LD_INT 0
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22563 0 4
23105: NOT
23106: PUSH
23107: LD_VAR 0 5
23111: PPUSH
23112: LD_VAR 0 6
23116: PPUSH
23117: CALL_OW 351
23121: NOT
23122: AND
23123: PUSH
23124: LD_VAR 0 5
23128: PPUSH
23129: LD_VAR 0 6
23133: PPUSH
23134: CALL_OW 488
23138: AND
23139: PUSH
23140: LD_VAR 0 5
23144: PPUSH
23145: LD_VAR 0 6
23149: PPUSH
23150: CALL_OW 546
23154: PUSH
23155: LD_INT 0
23157: EQUAL
23158: AND
23159: PUSH
23160: LD_VAR 0 5
23164: PPUSH
23165: LD_VAR 0 6
23169: PPUSH
23170: CALL_OW 428
23174: PUSH
23175: LD_INT 0
23177: EQUAL
23178: AND
23179: IFFALSE 22955
// end ; ComMoveXY ( un , x , y ) ;
23181: LD_VAR 0 1
23185: PPUSH
23186: LD_VAR 0 5
23190: PPUSH
23191: LD_VAR 0 6
23195: PPUSH
23196: CALL_OW 111
// Wait ( 0 0$1 ) ;
23200: LD_INT 35
23202: PPUSH
23203: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_INT 81
23214: PUSH
23215: LD_VAR 0 1
23219: PPUSH
23220: CALL_OW 255
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PPUSH
23229: CALL_OW 69
23233: PPUSH
23234: LD_VAR 0 1
23238: PPUSH
23239: CALL_OW 74
23243: PPUSH
23244: CALL_OW 296
23248: PUSH
23249: LD_INT 14
23251: GREATEREQUAL
23252: IFFALSE 23265
// begin ComStop ( un ) ;
23254: LD_VAR 0 1
23258: PPUSH
23259: CALL_OW 141
// break ;
23263: GO 23267
// end ; end ;
23265: GO 22768
// end ;
23267: LD_VAR 0 2
23271: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23272: LD_INT 0
23274: PPUSH
23275: PPUSH
23276: PPUSH
23277: PPUSH
23278: PPUSH
23279: PPUSH
23280: PPUSH
23281: PPUSH
// x := GetX ( unit ) ;
23282: LD_ADDR_VAR 0 3
23286: PUSH
23287: LD_VAR 0 1
23291: PPUSH
23292: CALL_OW 250
23296: ST_TO_ADDR
// y := GetY ( unit ) ;
23297: LD_ADDR_VAR 0 4
23301: PUSH
23302: LD_VAR 0 1
23306: PPUSH
23307: CALL_OW 251
23311: ST_TO_ADDR
// i := 0 ;
23312: LD_ADDR_VAR 0 8
23316: PUSH
23317: LD_INT 0
23319: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23320: LD_VAR 0 1
23324: PPUSH
23325: LD_INT 81
23327: PUSH
23328: LD_VAR 0 1
23332: PPUSH
23333: CALL_OW 255
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: PPUSH
23342: CALL_OW 69
23346: PPUSH
23347: LD_VAR 0 1
23351: PPUSH
23352: CALL_OW 74
23356: PPUSH
23357: CALL_OW 119
// dir := GetDir ( unit ) ;
23361: LD_ADDR_VAR 0 7
23365: PUSH
23366: LD_VAR 0 1
23370: PPUSH
23371: CALL_OW 254
23375: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23376: LD_ADDR_VAR 0 9
23380: PUSH
23381: LD_INT 0
23383: PPUSH
23384: LD_INT 1
23386: PPUSH
23387: CALL_OW 12
23391: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23392: LD_INT 10
23394: PPUSH
23395: CALL_OW 67
// if mode then
23399: LD_VAR 0 9
23403: IFFALSE 23421
// dir := dir + 1 else
23405: LD_ADDR_VAR 0 7
23409: PUSH
23410: LD_VAR 0 7
23414: PUSH
23415: LD_INT 1
23417: PLUS
23418: ST_TO_ADDR
23419: GO 23435
// dir := dir - 1 ;
23421: LD_ADDR_VAR 0 7
23425: PUSH
23426: LD_VAR 0 7
23430: PUSH
23431: LD_INT 1
23433: MINUS
23434: ST_TO_ADDR
// if ( dir < 0 ) then
23435: LD_VAR 0 7
23439: PUSH
23440: LD_INT 0
23442: LESS
23443: IFFALSE 23453
// dir := 5 ;
23445: LD_ADDR_VAR 0 7
23449: PUSH
23450: LD_INT 5
23452: ST_TO_ADDR
// if ( dir > 5 ) then
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 5
23460: GREATER
23461: IFFALSE 23471
// dir := 0 ;
23463: LD_ADDR_VAR 0 7
23467: PUSH
23468: LD_INT 0
23470: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23471: LD_ADDR_VAR 0 5
23475: PUSH
23476: LD_VAR 0 3
23480: PPUSH
23481: LD_VAR 0 7
23485: PPUSH
23486: LD_INT 4
23488: PPUSH
23489: CALL_OW 272
23493: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23494: LD_ADDR_VAR 0 6
23498: PUSH
23499: LD_VAR 0 4
23503: PPUSH
23504: LD_VAR 0 7
23508: PPUSH
23509: LD_INT 4
23511: PPUSH
23512: CALL_OW 273
23516: ST_TO_ADDR
// i := i + 1 ;
23517: LD_ADDR_VAR 0 8
23521: PUSH
23522: LD_VAR 0 8
23526: PUSH
23527: LD_INT 1
23529: PLUS
23530: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23531: LD_VAR 0 1
23535: PPUSH
23536: CALL_OW 255
23540: PPUSH
23541: LD_VAR 0 5
23545: PPUSH
23546: LD_VAR 0 6
23550: PPUSH
23551: LD_INT 14
23553: PPUSH
23554: CALL 22563 0 4
23558: PUSH
23559: LD_INT 0
23561: EQUAL
23562: PUSH
23563: LD_VAR 0 5
23567: PPUSH
23568: LD_VAR 0 6
23572: PPUSH
23573: CALL_OW 546
23577: PUSH
23578: LD_INT 0
23580: EQUAL
23581: AND
23582: PUSH
23583: LD_VAR 0 5
23587: PPUSH
23588: LD_VAR 0 6
23592: PPUSH
23593: CALL_OW 428
23597: PUSH
23598: LD_INT 0
23600: EQUAL
23601: AND
23602: IFFALSE 23606
// break ;
23604: GO 23616
// end until i > 4 ;
23606: LD_VAR 0 8
23610: PUSH
23611: LD_INT 4
23613: GREATER
23614: IFFALSE 23392
// if x2 and y2 then
23616: LD_VAR 0 5
23620: PUSH
23621: LD_VAR 0 6
23625: AND
23626: IFFALSE 23649
// result := [ x2 , y2 ] else
23628: LD_ADDR_VAR 0 2
23632: PUSH
23633: LD_VAR 0 5
23637: PUSH
23638: LD_VAR 0 6
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: ST_TO_ADDR
23647: GO 23678
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23649: LD_ADDR_VAR 0 2
23653: PUSH
23654: LD_VAR 0 1
23658: PPUSH
23659: CALL_OW 250
23663: PUSH
23664: LD_VAR 0 1
23668: PPUSH
23669: CALL_OW 251
23673: PUSH
23674: EMPTY
23675: LIST
23676: LIST
23677: ST_TO_ADDR
// end ;
23678: LD_VAR 0 2
23682: RET
// export function MCT_Hex ( x , y ) ; begin
23683: LD_INT 0
23685: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23686: LD_ADDR_VAR 0 3
23690: PUSH
23691: LD_VAR 0 1
23695: PPUSH
23696: LD_VAR 0 2
23700: PPUSH
23701: CALL_OW 546
23705: PUSH
23706: LD_VAR 0 1
23710: PPUSH
23711: LD_VAR 0 2
23715: PPUSH
23716: CALL_OW 428
23720: PUSH
23721: EMPTY
23722: LIST
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: ST_TO_ADDR
// end ;
23728: LD_VAR 0 3
23732: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23733: LD_INT 0
23735: PPUSH
23736: PPUSH
23737: PPUSH
23738: PPUSH
23739: PPUSH
23740: PPUSH
23741: PPUSH
23742: PPUSH
23743: PPUSH
23744: PPUSH
23745: PPUSH
23746: PPUSH
23747: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23748: LD_ADDR_VAR 0 10
23752: PUSH
23753: LD_EXP 60
23757: PUSH
23758: LD_VAR 0 1
23762: ARRAY
23763: PUSH
23764: LD_INT 1
23766: ARRAY
23767: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23768: LD_ADDR_VAR 0 11
23772: PUSH
23773: LD_EXP 60
23777: PUSH
23778: LD_VAR 0 1
23782: ARRAY
23783: PUSH
23784: LD_INT 2
23786: ARRAY
23787: ST_TO_ADDR
// collectors := [ ] ;
23788: LD_ADDR_VAR 0 12
23792: PUSH
23793: EMPTY
23794: ST_TO_ADDR
// is_cargo := false ;
23795: LD_ADDR_VAR 0 13
23799: PUSH
23800: LD_INT 0
23802: ST_TO_ADDR
// if isTest then
23803: LD_EXP 1
23807: IFFALSE 23813
// TimerStart ( ) ;
23809: CALL_OW 548
// if MCF_Cargo ( side ) then
23813: LD_VAR 0 1
23817: PPUSH
23818: CALL 11744 0 1
23822: IFFALSE 23849
// begin collectors := MCF_Cargo ( side ) ;
23824: LD_ADDR_VAR 0 12
23828: PUSH
23829: LD_VAR 0 1
23833: PPUSH
23834: CALL 11744 0 1
23838: ST_TO_ADDR
// is_cargo := true ;
23839: LD_ADDR_VAR 0 13
23843: PUSH
23844: LD_INT 1
23846: ST_TO_ADDR
// end else
23847: GO 23998
// begin if MCF_ApeSpec ( side , engineer ) then
23849: LD_VAR 0 1
23853: PPUSH
23854: LD_STRING engineer
23856: PPUSH
23857: CALL 11890 0 2
23861: IFFALSE 23881
// collectors := MCF_ApeSpec ( side , engineer ) ;
23863: LD_ADDR_VAR 0 12
23867: PUSH
23868: LD_VAR 0 1
23872: PPUSH
23873: LD_STRING engineer
23875: PPUSH
23876: CALL 11890 0 2
23880: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23881: LD_VAR 0 1
23885: PPUSH
23886: LD_INT 2
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL 11476 0 3
23895: IFFALSE 23998
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23897: LD_ADDR_VAR 0 7
23901: PUSH
23902: LD_VAR 0 1
23906: PPUSH
23907: LD_INT 2
23909: PPUSH
23910: EMPTY
23911: PPUSH
23912: CALL 11476 0 3
23916: ST_TO_ADDR
// if z > 5 then
23917: LD_VAR 0 7
23921: PUSH
23922: LD_INT 5
23924: GREATER
23925: IFFALSE 23937
// t1 := 5 else
23927: LD_ADDR_VAR 0 8
23931: PUSH
23932: LD_INT 5
23934: ST_TO_ADDR
23935: GO 23947
// t1 := z ;
23937: LD_ADDR_VAR 0 8
23941: PUSH
23942: LD_VAR 0 7
23946: ST_TO_ADDR
// for t2 = 1 to t1 do
23947: LD_ADDR_VAR 0 9
23951: PUSH
23952: DOUBLE
23953: LD_INT 1
23955: DEC
23956: ST_TO_ADDR
23957: LD_VAR 0 8
23961: PUSH
23962: FOR_TO
23963: IFFALSE 23996
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23965: LD_ADDR_VAR 0 12
23969: PUSH
23970: LD_VAR 0 12
23974: PPUSH
23975: LD_INT 1
23977: PPUSH
23978: LD_VAR 0 7
23982: PUSH
23983: LD_VAR 0 9
23987: ARRAY
23988: PPUSH
23989: CALL_OW 2
23993: ST_TO_ADDR
23994: GO 23962
23996: POP
23997: POP
// end ; end ; if not mode then
23998: LD_VAR 0 10
24002: NOT
24003: IFFALSE 24009
// exit else
24005: GO 24268
24007: GO 24268
// begin if collectors then
24009: LD_VAR 0 12
24013: IFFALSE 24268
// for i in areas do
24015: LD_ADDR_VAR 0 3
24019: PUSH
24020: LD_VAR 0 11
24024: PUSH
24025: FOR_IN
24026: IFFALSE 24266
// if GetListOfCratesInArea ( i ) then
24028: LD_VAR 0 3
24032: PPUSH
24033: CALL_OW 435
24037: IFFALSE 24264
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24039: LD_ADDR_VAR 0 5
24043: PUSH
24044: LD_VAR 0 3
24048: PPUSH
24049: CALL_OW 435
24053: PUSH
24054: LD_INT 1
24056: ARRAY
24057: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24058: LD_ADDR_VAR 0 6
24062: PUSH
24063: LD_VAR 0 3
24067: PPUSH
24068: CALL_OW 435
24072: PUSH
24073: LD_INT 2
24075: ARRAY
24076: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24077: LD_VAR 0 13
24081: PUSH
24082: LD_VAR 0 12
24086: PUSH
24087: LD_INT 1
24089: ARRAY
24090: PPUSH
24091: CALL_OW 110
24095: PUSH
24096: LD_INT 0
24098: EQUAL
24099: AND
24100: IFFALSE 24162
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24102: LD_VAR 0 12
24106: PUSH
24107: LD_INT 1
24109: ARRAY
24110: PPUSH
24111: CALL_OW 314
24115: NOT
24116: PUSH
24117: LD_VAR 0 12
24121: PUSH
24122: LD_INT 1
24124: ARRAY
24125: PPUSH
24126: CALL_OW 110
24130: PUSH
24131: LD_INT 0
24133: EQUAL
24134: AND
24135: IFFALSE 24160
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24137: LD_VAR 0 12
24141: PUSH
24142: LD_INT 1
24144: ARRAY
24145: PPUSH
24146: LD_VAR 0 5
24150: PPUSH
24151: LD_VAR 0 6
24155: PPUSH
24156: CALL_OW 117
// end ; end else
24160: GO 24248
// begin for j = 1 to collectors do
24162: LD_ADDR_VAR 0 4
24166: PUSH
24167: DOUBLE
24168: LD_INT 1
24170: DEC
24171: ST_TO_ADDR
24172: LD_VAR 0 12
24176: PUSH
24177: FOR_TO
24178: IFFALSE 24246
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24180: LD_VAR 0 12
24184: PUSH
24185: LD_VAR 0 4
24189: ARRAY
24190: PPUSH
24191: CALL_OW 314
24195: NOT
24196: PUSH
24197: LD_VAR 0 12
24201: PUSH
24202: LD_VAR 0 4
24206: ARRAY
24207: PPUSH
24208: CALL_OW 110
24212: PUSH
24213: LD_INT 0
24215: EQUAL
24216: AND
24217: IFFALSE 24244
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24219: LD_VAR 0 12
24223: PUSH
24224: LD_VAR 0 4
24228: ARRAY
24229: PPUSH
24230: LD_VAR 0 5
24234: PPUSH
24235: LD_VAR 0 6
24239: PPUSH
24240: CALL 24639 0 3
// end ;
24244: GO 24177
24246: POP
24247: POP
// end ; if isTest then
24248: LD_EXP 1
24252: IFFALSE 24264
// begin debug_time := TimerEnd ( ) ;
24254: LD_ADDR_VAR 0 14
24258: PUSH
24259: CALL_OW 549
24263: ST_TO_ADDR
// end ; end ;
24264: GO 24025
24266: POP
24267: POP
// end ; end ;
24268: LD_VAR 0 2
24272: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24273: LD_INT 0
24275: PPUSH
24276: PPUSH
24277: PPUSH
24278: PPUSH
24279: PPUSH
24280: PPUSH
// if not area then
24281: LD_VAR 0 1
24285: NOT
24286: IFFALSE 24292
// exit else
24288: GO 24554
24290: GO 24554
// if tick mod interval = 0 and Prob ( percent ) then
24292: LD_OWVAR 1
24296: PUSH
24297: LD_VAR 0 4
24301: MOD
24302: PUSH
24303: LD_INT 0
24305: EQUAL
24306: PUSH
24307: LD_VAR 0 3
24311: PPUSH
24312: CALL_OW 13
24316: AND
24317: IFFALSE 24554
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24319: LD_VAR 0 1
24323: PPUSH
24324: CALL_OW 435
24328: PUSH
24329: LD_VAR 0 5
24333: LESS
24334: PUSH
24335: LD_VAR 0 5
24339: PUSH
24340: LD_INT 0
24342: EQUAL
24343: OR
24344: IFFALSE 24554
// begin Randomize ;
24346: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24350: LD_ADDR_VAR 0 7
24354: PUSH
24355: LD_INT 1
24357: PPUSH
24358: LD_VAR 0 2
24362: PPUSH
24363: CALL_OW 12
24367: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24368: LD_ADDR_VAR 0 9
24372: PUSH
24373: LD_VAR 0 1
24377: PPUSH
24378: LD_INT 0
24380: PPUSH
24381: CALL_OW 517
24385: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24386: LD_ADDR_VAR 0 8
24390: PUSH
24391: LD_INT 1
24393: PPUSH
24394: LD_VAR 0 9
24398: PUSH
24399: LD_INT 1
24401: ARRAY
24402: PPUSH
24403: CALL_OW 12
24407: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24408: LD_VAR 0 9
24412: PUSH
24413: LD_INT 1
24415: ARRAY
24416: PUSH
24417: LD_VAR 0 8
24421: ARRAY
24422: PPUSH
24423: LD_VAR 0 9
24427: PUSH
24428: LD_INT 2
24430: ARRAY
24431: PUSH
24432: LD_VAR 0 8
24436: ARRAY
24437: PPUSH
24438: CALL_OW 428
24442: PUSH
24443: LD_INT 0
24445: GREATER
24446: PUSH
24447: LD_VAR 0 9
24451: PUSH
24452: LD_INT 1
24454: ARRAY
24455: PUSH
24456: LD_VAR 0 8
24460: ARRAY
24461: PPUSH
24462: LD_VAR 0 9
24466: PUSH
24467: LD_INT 2
24469: ARRAY
24470: PUSH
24471: LD_VAR 0 8
24475: ARRAY
24476: PPUSH
24477: CALL_OW 284
24481: PUSH
24482: LD_INT 0
24484: GREATER
24485: AND
24486: IFFALSE 24512
// c := Rand ( 1 , tmp [ 1 ] ) ;
24488: LD_ADDR_VAR 0 8
24492: PUSH
24493: LD_INT 1
24495: PPUSH
24496: LD_VAR 0 9
24500: PUSH
24501: LD_INT 1
24503: ARRAY
24504: PPUSH
24505: CALL_OW 12
24509: ST_TO_ADDR
24510: GO 24408
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24512: LD_VAR 0 7
24516: PPUSH
24517: LD_VAR 0 9
24521: PUSH
24522: LD_INT 1
24524: ARRAY
24525: PUSH
24526: LD_VAR 0 8
24530: ARRAY
24531: PPUSH
24532: LD_VAR 0 9
24536: PUSH
24537: LD_INT 2
24539: ARRAY
24540: PUSH
24541: LD_VAR 0 8
24545: ARRAY
24546: PPUSH
24547: LD_INT 1
24549: PPUSH
24550: CALL_OW 54
// end ; end ; end ;
24554: LD_VAR 0 6
24558: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24559: LD_INT 0
24561: PPUSH
24562: PPUSH
// if not MREG_Crates then
24563: LD_EXP 34
24567: NOT
24568: IFFALSE 24572
// exit ;
24570: GO 24634
// for i = MREG_Crates downto 1 do
24572: LD_ADDR_VAR 0 2
24576: PUSH
24577: DOUBLE
24578: LD_EXP 34
24582: INC
24583: ST_TO_ADDR
24584: LD_INT 1
24586: PUSH
24587: FOR_DOWNTO
24588: IFFALSE 24632
// if MREG_Crates [ i ] [ 3 ] = 0 then
24590: LD_EXP 34
24594: PUSH
24595: LD_VAR 0 2
24599: ARRAY
24600: PUSH
24601: LD_INT 3
24603: ARRAY
24604: PUSH
24605: LD_INT 0
24607: EQUAL
24608: IFFALSE 24630
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24610: LD_ADDR_EXP 34
24614: PUSH
24615: LD_EXP 34
24619: PPUSH
24620: LD_VAR 0 2
24624: PPUSH
24625: CALL_OW 3
24629: ST_TO_ADDR
24630: GO 24587
24632: POP
24633: POP
// end ;
24634: LD_VAR 0 1
24638: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24639: LD_INT 0
24641: PPUSH
24642: PPUSH
24643: PPUSH
24644: PPUSH
// if not unit then
24645: LD_VAR 0 1
24649: NOT
24650: IFFALSE 24654
// exit ;
24652: GO 24789
// if HasTask ( unit ) or not CanCarry ( unit ) then
24654: LD_VAR 0 1
24658: PPUSH
24659: CALL_OW 314
24663: PUSH
24664: LD_VAR 0 1
24668: PPUSH
24669: CALL_OW 280
24673: NOT
24674: OR
24675: IFFALSE 24679
// exit ;
24677: GO 24789
// side := GetSide ( unit ) ;
24679: LD_ADDR_VAR 0 6
24683: PUSH
24684: LD_VAR 0 1
24688: PPUSH
24689: CALL_OW 255
24693: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24694: LD_ADDR_VAR 0 7
24698: PUSH
24699: LD_VAR 0 6
24703: PPUSH
24704: LD_INT 30
24706: PUSH
24707: LD_INT 1
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PPUSH
24714: CALL 11393 0 2
24718: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24719: LD_VAR 0 1
24723: PPUSH
24724: CALL_OW 281
24728: PUSH
24729: LD_VAR 0 7
24733: NOT
24734: OR
24735: IFFALSE 24741
// exit else
24737: GO 24789
24739: GO 24789
// if GetResourceAmountXY ( x , y ) then
24741: LD_VAR 0 2
24745: PPUSH
24746: LD_VAR 0 3
24750: PPUSH
24751: CALL_OW 284
24755: IFFALSE 24787
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24757: LD_VAR 0 1
24761: PPUSH
24762: LD_VAR 0 2
24766: PPUSH
24767: LD_VAR 0 3
24771: PPUSH
24772: LD_VAR 0 7
24776: PUSH
24777: LD_INT 1
24779: ARRAY
24780: PPUSH
24781: CALL 32025 0 4
// end else
24785: GO 24789
// exit ;
24787: GO 24789
// end ;
24789: LD_VAR 0 4
24793: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24794: LD_INT 0
24796: PPUSH
24797: PPUSH
24798: PPUSH
24799: PPUSH
24800: PPUSH
// result := 0 ;
24801: LD_ADDR_VAR 0 2
24805: PUSH
24806: LD_INT 0
24808: ST_TO_ADDR
// p := 1 ;
24809: LD_ADDR_VAR 0 4
24813: PUSH
24814: LD_INT 1
24816: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24817: LD_ADDR_VAR 0 3
24821: PUSH
24822: DOUBLE
24823: LD_INT 1
24825: DEC
24826: ST_TO_ADDR
24827: LD_EXP 63
24831: PUSH
24832: LD_VAR 0 1
24836: ARRAY
24837: PUSH
24838: LD_INT 1
24840: ARRAY
24841: PUSH
24842: LD_INT 2
24844: DIVREAL
24845: PUSH
24846: FOR_TO
24847: IFFALSE 24971
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24849: LD_ADDR_VAR 0 5
24853: PUSH
24854: LD_INT 81
24856: PUSH
24857: LD_VAR 0 1
24861: PUSH
24862: EMPTY
24863: LIST
24864: LIST
24865: PUSH
24866: LD_INT 92
24868: PUSH
24869: LD_EXP 63
24873: PUSH
24874: LD_VAR 0 1
24878: ARRAY
24879: PUSH
24880: LD_INT 1
24882: ARRAY
24883: PUSH
24884: LD_VAR 0 4
24888: ARRAY
24889: PUSH
24890: LD_EXP 63
24894: PUSH
24895: LD_VAR 0 1
24899: ARRAY
24900: PUSH
24901: LD_INT 1
24903: ARRAY
24904: PUSH
24905: LD_VAR 0 4
24909: PUSH
24910: LD_INT 1
24912: PLUS
24913: ARRAY
24914: PUSH
24915: LD_INT 12
24917: PUSH
24918: EMPTY
24919: LIST
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: EMPTY
24925: LIST
24926: LIST
24927: PPUSH
24928: CALL_OW 69
24932: ST_TO_ADDR
// if tmp then
24933: LD_VAR 0 5
24937: IFFALSE 24955
// result := result ^ tmp ;
24939: LD_ADDR_VAR 0 2
24943: PUSH
24944: LD_VAR 0 2
24948: PUSH
24949: LD_VAR 0 5
24953: ADD
24954: ST_TO_ADDR
// p := p + 2 ;
24955: LD_ADDR_VAR 0 4
24959: PUSH
24960: LD_VAR 0 4
24964: PUSH
24965: LD_INT 2
24967: PLUS
24968: ST_TO_ADDR
// end ;
24969: GO 24846
24971: POP
24972: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
24973: LD_EXP 64
24977: PUSH
24978: LD_VAR 0 1
24982: ARRAY
24983: PPUSH
24984: LD_INT 81
24986: PUSH
24987: LD_VAR 0 1
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 70
25000: IFFALSE 25041
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25002: LD_ADDR_VAR 0 2
25006: PUSH
25007: LD_VAR 0 2
25011: PUSH
25012: LD_EXP 64
25016: PUSH
25017: LD_VAR 0 1
25021: ARRAY
25022: PPUSH
25023: LD_INT 81
25025: PUSH
25026: LD_VAR 0 1
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PPUSH
25035: CALL_OW 70
25039: ADD
25040: ST_TO_ADDR
// end ; end_of_file
25041: LD_VAR 0 2
25045: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25046: LD_INT 0
25048: PPUSH
25049: PPUSH
25050: PPUSH
// pom := GetBase ( fac ) ;
25051: LD_ADDR_VAR 0 5
25055: PUSH
25056: LD_VAR 0 1
25060: PPUSH
25061: CALL_OW 274
25065: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25066: LD_ADDR_VAR 0 4
25070: PUSH
25071: LD_VAR 0 2
25075: PUSH
25076: LD_INT 1
25078: ARRAY
25079: PPUSH
25080: LD_VAR 0 2
25084: PUSH
25085: LD_INT 2
25087: ARRAY
25088: PPUSH
25089: LD_VAR 0 2
25093: PUSH
25094: LD_INT 3
25096: ARRAY
25097: PPUSH
25098: LD_VAR 0 2
25102: PUSH
25103: LD_INT 4
25105: ARRAY
25106: PPUSH
25107: CALL_OW 449
25111: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25112: LD_VAR 0 5
25116: PPUSH
25117: LD_INT 1
25119: PPUSH
25120: CALL_OW 275
25124: PUSH
25125: LD_VAR 0 4
25129: PUSH
25130: LD_INT 1
25132: ARRAY
25133: GREATEREQUAL
25134: PUSH
25135: LD_VAR 0 5
25139: PPUSH
25140: LD_INT 2
25142: PPUSH
25143: CALL_OW 275
25147: PUSH
25148: LD_VAR 0 4
25152: PUSH
25153: LD_INT 2
25155: ARRAY
25156: GREATEREQUAL
25157: AND
25158: PUSH
25159: LD_VAR 0 5
25163: PPUSH
25164: LD_INT 3
25166: PPUSH
25167: CALL_OW 275
25171: PUSH
25172: LD_VAR 0 4
25176: PUSH
25177: LD_INT 3
25179: ARRAY
25180: GREATEREQUAL
25181: AND
25182: IFFALSE 25194
// result := true else
25184: LD_ADDR_VAR 0 3
25188: PUSH
25189: LD_INT 1
25191: ST_TO_ADDR
25192: GO 25202
// result := false ;
25194: LD_ADDR_VAR 0 3
25198: PUSH
25199: LD_INT 0
25201: ST_TO_ADDR
// end ;
25202: LD_VAR 0 3
25206: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25207: LD_INT 0
25209: PPUSH
25210: PPUSH
25211: PPUSH
// result := false ;
25212: LD_ADDR_VAR 0 3
25216: PUSH
25217: LD_INT 0
25219: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25220: LD_ADDR_VAR 0 4
25224: PUSH
25225: LD_EXP 51
25229: PUSH
25230: LD_VAR 0 1
25234: ARRAY
25235: ST_TO_ADDR
// if tmp then
25236: LD_VAR 0 4
25240: IFFALSE 25292
// for i = 1 to tmp do
25242: LD_ADDR_VAR 0 5
25246: PUSH
25247: DOUBLE
25248: LD_INT 1
25250: DEC
25251: ST_TO_ADDR
25252: LD_VAR 0 4
25256: PUSH
25257: FOR_TO
25258: IFFALSE 25290
// if component = tmp [ i ] then
25260: LD_VAR 0 2
25264: PUSH
25265: LD_VAR 0 4
25269: PUSH
25270: LD_VAR 0 5
25274: ARRAY
25275: EQUAL
25276: IFFALSE 25288
// begin result := true ;
25278: LD_ADDR_VAR 0 3
25282: PUSH
25283: LD_INT 1
25285: ST_TO_ADDR
// break ;
25286: GO 25290
// end ;
25288: GO 25257
25290: POP
25291: POP
// end ;
25292: LD_VAR 0 3
25296: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25297: LD_INT 0
25299: PPUSH
25300: PPUSH
25301: PPUSH
// if fac then
25302: LD_VAR 0 2
25306: IFFALSE 25541
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25308: LD_VAR 0 2
25312: PPUSH
25313: LD_VAR 0 3
25317: PPUSH
25318: CALL 25046 0 2
25322: PUSH
25323: LD_VAR 0 2
25327: PPUSH
25328: CALL_OW 461
25332: PUSH
25333: LD_INT 2
25335: EQUAL
25336: AND
25337: PUSH
25338: LD_VAR 0 2
25342: PPUSH
25343: LD_VAR 0 3
25347: PUSH
25348: LD_INT 1
25350: ARRAY
25351: PPUSH
25352: LD_VAR 0 3
25356: PUSH
25357: LD_INT 2
25359: ARRAY
25360: PPUSH
25361: LD_VAR 0 3
25365: PUSH
25366: LD_INT 3
25368: ARRAY
25369: PPUSH
25370: LD_VAR 0 3
25374: PUSH
25375: LD_INT 4
25377: ARRAY
25378: PPUSH
25379: CALL_OW 448
25383: AND
25384: IFFALSE 25531
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25386: LD_VAR 0 2
25390: PPUSH
25391: LD_VAR 0 3
25395: PUSH
25396: LD_INT 1
25398: ARRAY
25399: PPUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 2
25407: ARRAY
25408: PPUSH
25409: LD_VAR 0 3
25413: PUSH
25414: LD_INT 3
25416: ARRAY
25417: PPUSH
25418: LD_VAR 0 3
25422: PUSH
25423: LD_INT 4
25425: ARRAY
25426: PPUSH
25427: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25431: LD_ADDR_VAR 0 6
25435: PUSH
25436: LD_EXP 51
25440: PUSH
25441: LD_VAR 0 1
25445: ARRAY
25446: ST_TO_ADDR
// for i = 4 downto 1 do
25447: LD_ADDR_VAR 0 5
25451: PUSH
25452: DOUBLE
25453: LD_INT 4
25455: INC
25456: ST_TO_ADDR
25457: LD_INT 1
25459: PUSH
25460: FOR_DOWNTO
25461: IFFALSE 25494
// tab := Remove ( tab , list [ i ] , true ) ;
25463: LD_ADDR_VAR 0 6
25467: PUSH
25468: LD_VAR 0 6
25472: PPUSH
25473: LD_VAR 0 3
25477: PUSH
25478: LD_VAR 0 5
25482: ARRAY
25483: PPUSH
25484: LD_INT 1
25486: PPUSH
25487: CALL 31020 0 3
25491: ST_TO_ADDR
25492: GO 25460
25494: POP
25495: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25496: LD_ADDR_EXP 51
25500: PUSH
25501: LD_EXP 51
25505: PPUSH
25506: LD_VAR 0 1
25510: PPUSH
25511: LD_VAR 0 6
25515: PPUSH
25516: CALL_OW 1
25520: ST_TO_ADDR
// result := true ;
25521: LD_ADDR_VAR 0 4
25525: PUSH
25526: LD_INT 1
25528: ST_TO_ADDR
// end else
25529: GO 25539
// result := false ;
25531: LD_ADDR_VAR 0 4
25535: PUSH
25536: LD_INT 0
25538: ST_TO_ADDR
// end else
25539: GO 25549
// result := false ;
25541: LD_ADDR_VAR 0 4
25545: PUSH
25546: LD_INT 0
25548: ST_TO_ADDR
// end ;
25549: LD_VAR 0 4
25553: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25554: LD_INT 0
25556: PPUSH
25557: PPUSH
// if not veh then
25558: LD_VAR 0 2
25562: NOT
25563: IFFALSE 25567
// exit ;
25565: GO 25741
// if MREG_Parking [ side ] then
25567: LD_EXP 58
25571: PUSH
25572: LD_VAR 0 1
25576: ARRAY
25577: IFFALSE 25741
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25579: LD_VAR 0 2
25583: PPUSH
25584: LD_EXP 58
25588: PUSH
25589: LD_VAR 0 1
25593: ARRAY
25594: PPUSH
25595: CALL_OW 308
25599: NOT
25600: IFFALSE 25741
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25602: LD_VAR 0 2
25606: PPUSH
25607: LD_EXP 58
25611: PUSH
25612: LD_VAR 0 1
25616: ARRAY
25617: PPUSH
25618: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25622: LD_VAR 0 2
25626: PPUSH
25627: CALL_OW 263
25631: PUSH
25632: LD_INT 1
25634: EQUAL
25635: IFFALSE 25741
// begin i := GetDriver ( veh ) ;
25637: LD_ADDR_VAR 0 4
25641: PUSH
25642: LD_VAR 0 2
25646: PPUSH
25647: CALL 31555 0 1
25651: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25652: LD_INT 35
25654: PPUSH
25655: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25659: LD_VAR 0 2
25663: PPUSH
25664: LD_EXP 58
25668: PUSH
25669: LD_VAR 0 1
25673: ARRAY
25674: PPUSH
25675: CALL_OW 308
25679: PUSH
25680: LD_VAR 0 2
25684: PPUSH
25685: CALL_OW 301
25689: OR
25690: IFFALSE 25652
// ComExitVehicle ( i ) ;
25692: LD_VAR 0 4
25696: PPUSH
25697: CALL_OW 121
// Wait ( 1 ) ;
25701: LD_INT 1
25703: PPUSH
25704: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25708: LD_VAR 0 4
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_INT 30
25720: PUSH
25721: LD_INT 3
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PPUSH
25728: CALL 11393 0 2
25732: PUSH
25733: LD_INT 1
25735: ARRAY
25736: PPUSH
25737: CALL_OW 180
// end ; end ; end ;
25741: LD_VAR 0 3
25745: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25746: LD_INT 0
25748: PPUSH
25749: PPUSH
25750: PPUSH
25751: PPUSH
25752: PPUSH
25753: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25754: LD_VAR 0 1
25758: PPUSH
25759: LD_INT 30
25761: PUSH
25762: LD_INT 3
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PPUSH
25769: CALL 11393 0 2
25773: IFFALSE 25957
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25775: LD_VAR 0 1
25779: PPUSH
25780: LD_INT 30
25782: PUSH
25783: LD_INT 3
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: PPUSH
25790: CALL 11393 0 2
25794: PUSH
25795: LD_INT 1
25797: ARRAY
25798: PPUSH
25799: CALL_OW 461
25803: PUSH
25804: LD_INT 2
25806: EQUAL
25807: IFFALSE 25957
// begin for i = 1 to MREG_TurretWeapon do
25809: LD_ADDR_VAR 0 3
25813: PUSH
25814: DOUBLE
25815: LD_INT 1
25817: DEC
25818: ST_TO_ADDR
25819: LD_EXP 43
25823: PUSH
25824: FOR_TO
25825: IFFALSE 25955
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25827: LD_EXP 43
25831: PUSH
25832: LD_VAR 0 3
25836: ARRAY
25837: PUSH
25838: LD_INT 1
25840: ARRAY
25841: PUSH
25842: LD_VAR 0 1
25846: EQUAL
25847: IFFALSE 25953
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25849: LD_ADDR_VAR 0 5
25853: PUSH
25854: LD_EXP 43
25858: PUSH
25859: LD_VAR 0 3
25863: ARRAY
25864: PUSH
25865: LD_INT 2
25867: ARRAY
25868: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25869: LD_ADDR_VAR 0 6
25873: PUSH
25874: LD_EXP 43
25878: PUSH
25879: LD_VAR 0 3
25883: ARRAY
25884: PUSH
25885: LD_INT 3
25887: ARRAY
25888: PUSH
25889: LD_INT 1
25891: ARRAY
25892: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25893: LD_ADDR_VAR 0 7
25897: PUSH
25898: LD_EXP 43
25902: PUSH
25903: LD_VAR 0 3
25907: ARRAY
25908: PUSH
25909: LD_INT 3
25911: ARRAY
25912: PUSH
25913: LD_INT 2
25915: ARRAY
25916: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25917: LD_ADDR_VAR 0 4
25921: PUSH
25922: LD_VAR 0 6
25926: PPUSH
25927: LD_VAR 0 7
25931: PPUSH
25932: CALL_OW 428
25936: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25937: LD_VAR 0 4
25941: PPUSH
25942: LD_VAR 0 5
25946: PPUSH
25947: CALL_OW 148
// break ;
25951: GO 25955
// end ;
25953: GO 25824
25955: POP
25956: POP
// end ; end ;
25957: LD_VAR 0 2
25961: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25962: LD_INT 0
25964: PPUSH
25965: PPUSH
25966: PPUSH
25967: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25968: LD_ADDR_VAR 0 4
25972: PUSH
25973: LD_VAR 0 1
25977: PPUSH
25978: LD_INT 32
25980: PUSH
25981: LD_INT 1
25983: PUSH
25984: EMPTY
25985: LIST
25986: LIST
25987: PPUSH
25988: CALL 11393 0 2
25992: ST_TO_ADDR
// if not tmp then
25993: LD_VAR 0 4
25997: NOT
25998: IFFALSE 26004
// exit else
26000: GO 26086
26002: GO 26086
// begin for i = 1 to tmp do
26004: LD_ADDR_VAR 0 3
26008: PUSH
26009: DOUBLE
26010: LD_INT 1
26012: DEC
26013: ST_TO_ADDR
26014: LD_VAR 0 4
26018: PUSH
26019: FOR_TO
26020: IFFALSE 26084
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26022: LD_VAR 0 4
26026: PUSH
26027: LD_VAR 0 3
26031: ARRAY
26032: PPUSH
26033: CALL_OW 261
26037: PUSH
26038: LD_INT 20
26040: LESS
26041: PUSH
26042: LD_VAR 0 4
26046: PUSH
26047: LD_VAR 0 3
26051: ARRAY
26052: PPUSH
26053: CALL_OW 110
26057: PUSH
26058: LD_INT 0
26060: EQUAL
26061: AND
26062: IFFALSE 26082
// begin SetTag ( tmp [ i ] , 21 ) ;
26064: LD_VAR 0 4
26068: PUSH
26069: LD_VAR 0 3
26073: ARRAY
26074: PPUSH
26075: LD_INT 21
26077: PPUSH
26078: CALL_OW 109
// end ;
26082: GO 26019
26084: POP
26085: POP
// end ; end ;
26086: LD_VAR 0 2
26090: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26091: LD_INT 0
26093: PPUSH
26094: PPUSH
26095: PPUSH
26096: PPUSH
26097: PPUSH
// if not unit then
26098: LD_VAR 0 1
26102: NOT
26103: IFFALSE 26107
// exit ;
26105: GO 26295
// side := GetSide ( unit ) ;
26107: LD_ADDR_VAR 0 3
26111: PUSH
26112: LD_VAR 0 1
26116: PPUSH
26117: CALL_OW 255
26121: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26122: LD_ADDR_VAR 0 5
26126: PUSH
26127: LD_VAR 0 3
26131: PPUSH
26132: LD_INT 2
26134: PUSH
26135: LD_INT 30
26137: PUSH
26138: LD_INT 1
26140: PUSH
26141: EMPTY
26142: LIST
26143: LIST
26144: PUSH
26145: LD_INT 30
26147: PUSH
26148: LD_INT 3
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 30
26157: PUSH
26158: LD_INT 29
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: LIST
26169: LIST
26170: PPUSH
26171: CALL 11393 0 2
26175: ST_TO_ADDR
// if not b then
26176: LD_VAR 0 5
26180: NOT
26181: IFFALSE 26185
// exit ;
26183: GO 26295
// if GetTag ( unit ) = 21 then
26185: LD_VAR 0 1
26189: PPUSH
26190: CALL_OW 110
26194: PUSH
26195: LD_INT 21
26197: EQUAL
26198: IFFALSE 26295
// begin c := NearestUnitToUnit ( b , unit ) ;
26200: LD_ADDR_VAR 0 6
26204: PUSH
26205: LD_VAR 0 5
26209: PPUSH
26210: LD_VAR 0 1
26214: PPUSH
26215: CALL_OW 74
26219: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26220: LD_VAR 0 1
26224: PPUSH
26225: LD_VAR 0 6
26229: PPUSH
26230: CALL_OW 250
26234: PPUSH
26235: LD_VAR 0 6
26239: PPUSH
26240: CALL_OW 251
26244: PPUSH
26245: CALL_OW 297
26249: PUSH
26250: LD_INT 6
26252: GREATER
26253: IFFALSE 26271
// ComMoveUnit ( unit , c ) else
26255: LD_VAR 0 1
26259: PPUSH
26260: LD_VAR 0 6
26264: PPUSH
26265: CALL_OW 112
26269: GO 26295
// begin SetFuel ( unit , 100 ) ;
26271: LD_VAR 0 1
26275: PPUSH
26276: LD_INT 100
26278: PPUSH
26279: CALL_OW 240
// SetTag ( unit , 0 ) ;
26283: LD_VAR 0 1
26287: PPUSH
26288: LD_INT 0
26290: PPUSH
26291: CALL_OW 109
// end ; end ; end ;
26295: LD_VAR 0 2
26299: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26300: LD_INT 0
26302: PPUSH
26303: PPUSH
26304: PPUSH
26305: PPUSH
26306: PPUSH
26307: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26308: LD_ADDR_VAR 0 7
26312: PUSH
26313: LD_VAR 0 1
26317: PPUSH
26318: LD_INT 33
26320: PUSH
26321: LD_INT 2
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 3
26330: PUSH
26331: LD_INT 61
26333: PUSH
26334: EMPTY
26335: LIST
26336: PUSH
26337: EMPTY
26338: LIST
26339: LIST
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PPUSH
26345: CALL 11393 0 2
26349: ST_TO_ADDR
// if not vehs then
26350: LD_VAR 0 7
26354: NOT
26355: IFFALSE 26359
// exit ;
26357: GO 26644
// if nation = 1 then
26359: LD_VAR 0 2
26363: PUSH
26364: LD_INT 1
26366: EQUAL
26367: IFFALSE 26537
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26369: LD_VAR 0 1
26373: PPUSH
26374: LD_INT 30
26376: PUSH
26377: LD_INT 36
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PPUSH
26384: CALL 11393 0 2
26388: NOT
26389: IFFALSE 26395
// exit else
26391: GO 26644
26393: GO 26535
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26395: LD_ADDR_VAR 0 5
26399: PUSH
26400: LD_VAR 0 1
26404: PPUSH
26405: LD_INT 30
26407: PUSH
26408: LD_INT 36
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PPUSH
26415: CALL 11393 0 2
26419: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26420: LD_ADDR_VAR 0 6
26424: PUSH
26425: LD_VAR 0 5
26429: PUSH
26430: LD_INT 1
26432: ARRAY
26433: PPUSH
26434: CALL_OW 313
26438: ST_TO_ADDR
// for i = vehs downto 1 do
26439: LD_ADDR_VAR 0 4
26443: PUSH
26444: DOUBLE
26445: LD_VAR 0 7
26449: INC
26450: ST_TO_ADDR
26451: LD_INT 1
26453: PUSH
26454: FOR_DOWNTO
26455: IFFALSE 26533
// begin if not IsControledBy ( vehs [ i ] ) then
26457: LD_VAR 0 7
26461: PUSH
26462: LD_VAR 0 4
26466: ARRAY
26467: PPUSH
26468: CALL_OW 312
26472: NOT
26473: IFFALSE 26531
// begin tmp := MCV_RemoteDriver ( oper ) ;
26475: LD_ADDR_VAR 0 8
26479: PUSH
26480: LD_VAR 0 6
26484: PPUSH
26485: CALL 26649 0 1
26489: ST_TO_ADDR
// if not tmp then
26490: LD_VAR 0 8
26494: NOT
26495: IFFALSE 26503
// exit else
26497: POP
26498: POP
26499: GO 26644
26501: GO 26531
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26503: LD_VAR 0 7
26507: PUSH
26508: LD_VAR 0 4
26512: ARRAY
26513: PPUSH
26514: LD_VAR 0 8
26518: PUSH
26519: LD_INT 1
26521: ARRAY
26522: PUSH
26523: LD_INT 1
26525: ARRAY
26526: PPUSH
26527: CALL_OW 135
// end ; end ;
26531: GO 26454
26533: POP
26534: POP
// end ; end else
26535: GO 26644
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26537: LD_VAR 0 1
26541: PPUSH
26542: LD_INT 34
26544: PUSH
26545: LD_INT 31
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PPUSH
26552: CALL 11393 0 2
26556: NOT
26557: IFFALSE 26563
// exit else
26559: GO 26644
26561: GO 26644
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26563: LD_ADDR_VAR 0 5
26567: PUSH
26568: LD_VAR 0 1
26572: PPUSH
26573: LD_INT 34
26575: PUSH
26576: LD_INT 31
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PPUSH
26583: CALL 11393 0 2
26587: ST_TO_ADDR
// oper := [ ] ;
26588: LD_ADDR_VAR 0 6
26592: PUSH
26593: EMPTY
26594: ST_TO_ADDR
// for i = 1 to ct do
26595: LD_ADDR_VAR 0 4
26599: PUSH
26600: DOUBLE
26601: LD_INT 1
26603: DEC
26604: ST_TO_ADDR
26605: LD_VAR 0 5
26609: PUSH
26610: FOR_TO
26611: IFFALSE 26642
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26613: LD_ADDR_VAR 0 6
26617: PUSH
26618: LD_VAR 0 6
26622: PUSH
26623: LD_VAR 0 5
26627: PUSH
26628: LD_VAR 0 4
26632: ARRAY
26633: PPUSH
26634: CALL 31555 0 1
26638: ADD
26639: ST_TO_ADDR
26640: GO 26610
26642: POP
26643: POP
// end ; end ; end ;
26644: LD_VAR 0 3
26648: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26649: LD_INT 0
26651: PPUSH
26652: PPUSH
26653: PPUSH
26654: PPUSH
26655: PPUSH
26656: PPUSH
// if not drivers then
26657: LD_VAR 0 1
26661: NOT
26662: IFFALSE 26668
// exit else
26664: GO 26948
26666: GO 26948
// begin linked := [ ] ;
26668: LD_ADDR_VAR 0 5
26672: PUSH
26673: EMPTY
26674: ST_TO_ADDR
// for i = 1 to drivers do
26675: LD_ADDR_VAR 0 3
26679: PUSH
26680: DOUBLE
26681: LD_INT 1
26683: DEC
26684: ST_TO_ADDR
26685: LD_VAR 0 1
26689: PUSH
26690: FOR_TO
26691: IFFALSE 26936
// begin if CanControl ( drivers [ i ] ) then
26693: LD_VAR 0 1
26697: PUSH
26698: LD_VAR 0 3
26702: ARRAY
26703: PPUSH
26704: CALL 32127 0 1
26708: IFFALSE 26934
// if i > 1 then
26710: LD_VAR 0 3
26714: PUSH
26715: LD_INT 1
26717: GREATER
26718: IFFALSE 26895
// begin m := false ;
26720: LD_ADDR_VAR 0 6
26724: PUSH
26725: LD_INT 0
26727: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26728: LD_ADDR_VAR 0 7
26732: PUSH
26733: LD_VAR 0 1
26737: PUSH
26738: LD_VAR 0 3
26742: ARRAY
26743: PPUSH
26744: CALL_OW 432
26748: ST_TO_ADDR
// for j = 1 to linked do
26749: LD_ADDR_VAR 0 4
26753: PUSH
26754: DOUBLE
26755: LD_INT 1
26757: DEC
26758: ST_TO_ADDR
26759: LD_VAR 0 5
26763: PUSH
26764: FOR_TO
26765: IFFALSE 26839
// begin if l < linked [ j ] [ 2 ] then
26767: LD_VAR 0 7
26771: PUSH
26772: LD_VAR 0 5
26776: PUSH
26777: LD_VAR 0 4
26781: ARRAY
26782: PUSH
26783: LD_INT 2
26785: ARRAY
26786: LESS
26787: IFFALSE 26837
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26789: LD_ADDR_VAR 0 5
26793: PUSH
26794: LD_VAR 0 5
26798: PPUSH
26799: LD_INT 1
26801: PPUSH
26802: LD_VAR 0 1
26806: PUSH
26807: LD_VAR 0 3
26811: ARRAY
26812: PUSH
26813: LD_VAR 0 7
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PPUSH
26822: CALL_OW 2
26826: ST_TO_ADDR
// m := true ;
26827: LD_ADDR_VAR 0 6
26831: PUSH
26832: LD_INT 1
26834: ST_TO_ADDR
// break ;
26835: GO 26839
// end ; end ;
26837: GO 26764
26839: POP
26840: POP
// if not m then
26841: LD_VAR 0 6
26845: NOT
26846: IFFALSE 26893
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26848: LD_ADDR_VAR 0 5
26852: PUSH
26853: LD_VAR 0 5
26857: PUSH
26858: LD_VAR 0 1
26862: PUSH
26863: LD_VAR 0 3
26867: ARRAY
26868: PUSH
26869: LD_VAR 0 1
26873: PUSH
26874: LD_VAR 0 3
26878: ARRAY
26879: PPUSH
26880: CALL_OW 432
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: EMPTY
26890: LIST
26891: ADD
26892: ST_TO_ADDR
// end else
26893: GO 26934
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26895: LD_ADDR_VAR 0 5
26899: PUSH
26900: LD_VAR 0 1
26904: PUSH
26905: LD_VAR 0 3
26909: ARRAY
26910: PUSH
26911: LD_VAR 0 1
26915: PUSH
26916: LD_VAR 0 3
26920: ARRAY
26921: PPUSH
26922: CALL_OW 432
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: EMPTY
26932: LIST
26933: ST_TO_ADDR
// end ;
26934: GO 26690
26936: POP
26937: POP
// result := linked ;
26938: LD_ADDR_VAR 0 2
26942: PUSH
26943: LD_VAR 0 5
26947: ST_TO_ADDR
// end ; end ;
26948: LD_VAR 0 2
26952: RET
// export function MCV_ToRepair ( unit ) ; begin
26953: LD_INT 0
26955: PPUSH
// if not unit then
26956: LD_VAR 0 1
26960: NOT
26961: IFFALSE 26967
// exit else
26963: GO 26998
26965: GO 26998
// begin SetTag ( unit , 6 ) ;
26967: LD_VAR 0 1
26971: PPUSH
26972: LD_INT 6
26974: PPUSH
26975: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
26979: LD_VAR 0 1
26983: PPUSH
26984: CALL_OW 255
26988: PPUSH
26989: LD_VAR 0 1
26993: PPUSH
26994: CALL 25554 0 2
// end ; end ;
26998: LD_VAR 0 2
27002: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27003: LD_INT 0
27005: PPUSH
27006: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27007: LD_VAR 0 1
27011: PPUSH
27012: LD_INT 6
27014: PPUSH
27015: EMPTY
27016: PPUSH
27017: CALL 12096 0 3
27021: IFFALSE 27114
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27023: LD_ADDR_VAR 0 3
27027: PUSH
27028: DOUBLE
27029: LD_VAR 0 1
27033: PPUSH
27034: LD_INT 6
27036: PPUSH
27037: EMPTY
27038: PPUSH
27039: CALL 12096 0 3
27043: INC
27044: ST_TO_ADDR
27045: LD_INT 1
27047: PUSH
27048: FOR_DOWNTO
27049: IFFALSE 27112
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27051: LD_VAR 0 1
27055: PPUSH
27056: LD_INT 6
27058: PPUSH
27059: EMPTY
27060: PPUSH
27061: CALL 12096 0 3
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PPUSH
27072: CALL_OW 256
27076: PUSH
27077: LD_INT 1000
27079: EQUAL
27080: IFFALSE 27110
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27082: LD_VAR 0 1
27086: PPUSH
27087: LD_INT 6
27089: PPUSH
27090: EMPTY
27091: PPUSH
27092: CALL 12096 0 3
27096: PUSH
27097: LD_VAR 0 3
27101: ARRAY
27102: PPUSH
27103: LD_INT 0
27105: PPUSH
27106: CALL_OW 109
27110: GO 27048
27112: POP
27113: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27114: LD_VAR 0 1
27118: PPUSH
27119: LD_INT 10
27121: PPUSH
27122: EMPTY
27123: PPUSH
27124: CALL 12096 0 3
27128: IFFALSE 27245
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27130: LD_ADDR_VAR 0 3
27134: PUSH
27135: DOUBLE
27136: LD_VAR 0 1
27140: PPUSH
27141: LD_INT 10
27143: PPUSH
27144: EMPTY
27145: PPUSH
27146: CALL 12096 0 3
27150: INC
27151: ST_TO_ADDR
27152: LD_INT 1
27154: PUSH
27155: FOR_DOWNTO
27156: IFFALSE 27243
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27158: LD_VAR 0 1
27162: PPUSH
27163: LD_INT 10
27165: PPUSH
27166: EMPTY
27167: PPUSH
27168: CALL 12096 0 3
27172: PUSH
27173: LD_VAR 0 3
27177: ARRAY
27178: PPUSH
27179: CALL_OW 302
27183: NOT
27184: PUSH
27185: LD_VAR 0 1
27189: PPUSH
27190: LD_INT 10
27192: PPUSH
27193: EMPTY
27194: PPUSH
27195: CALL 12096 0 3
27199: PUSH
27200: LD_VAR 0 3
27204: ARRAY
27205: PPUSH
27206: CALL_OW 301
27210: OR
27211: IFFALSE 27241
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27213: LD_VAR 0 1
27217: PPUSH
27218: LD_INT 10
27220: PPUSH
27221: EMPTY
27222: PPUSH
27223: CALL 12096 0 3
27227: PUSH
27228: LD_VAR 0 3
27232: ARRAY
27233: PPUSH
27234: LD_INT 0
27236: PPUSH
27237: CALL_OW 109
27241: GO 27155
27243: POP
27244: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27245: LD_ADDR_VAR 0 3
27249: PUSH
27250: LD_VAR 0 1
27254: PPUSH
27255: EMPTY
27256: PPUSH
27257: CALL 11694 0 2
27261: PUSH
27262: LD_VAR 0 1
27266: PPUSH
27267: LD_INT 7
27269: PPUSH
27270: EMPTY
27271: PPUSH
27272: CALL 12096 0 3
27276: DIFF
27277: PUSH
27278: FOR_IN
27279: IFFALSE 27323
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27281: LD_VAR 0 3
27285: PPUSH
27286: CALL_OW 256
27290: PUSH
27291: LD_INT 650
27293: LESS
27294: PUSH
27295: LD_VAR 0 3
27299: PPUSH
27300: CALL_OW 110
27304: PUSH
27305: LD_INT 6
27307: EQUAL
27308: NOT
27309: AND
27310: IFFALSE 27321
// MCV_ToRepair ( i ) ;
27312: LD_VAR 0 3
27316: PPUSH
27317: CALL 26953 0 1
27321: GO 27278
27323: POP
27324: POP
// end ; end_of_file end_of_file
27325: LD_VAR 0 2
27329: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27330: LD_STRING SAILEvent [
27332: PUSH
27333: LD_VAR 0 1
27337: STR
27338: PUSH
27339: LD_STRING ]
27341: STR
27342: PPUSH
27343: CALL 7790 0 1
// if event = 101 and dialog_north then
27347: LD_VAR 0 1
27351: PUSH
27352: LD_INT 101
27354: EQUAL
27355: PUSH
27356: LD_EXP 5
27360: AND
27361: IFFALSE 27425
// begin dialog_north := false ;
27363: LD_ADDR_EXP 5
27367: PUSH
27368: LD_INT 0
27370: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27371: LD_EXP 4
27375: PPUSH
27376: LD_STRING DS1
27378: PUSH
27379: LD_STRING DS2
27381: PUSH
27382: LD_STRING DS3
27384: PUSH
27385: LD_STRING DS6
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: PUSH
27394: LD_INT 1
27396: PPUSH
27397: LD_INT 4
27399: PPUSH
27400: CALL_OW 12
27404: ARRAY
27405: PPUSH
27406: CALL_OW 94
// Wait ( 4 4$00 ) ;
27410: LD_INT 8400
27412: PPUSH
27413: CALL_OW 67
// dialog_north := true ;
27417: LD_ADDR_EXP 5
27421: PUSH
27422: LD_INT 1
27424: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27425: LD_VAR 0 1
27429: PUSH
27430: LD_INT 102
27432: EQUAL
27433: PUSH
27434: LD_EXP 6
27438: AND
27439: IFFALSE 27499
// begin dialog_south := false ;
27441: LD_ADDR_EXP 6
27445: PUSH
27446: LD_INT 0
27448: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27449: LD_EXP 3
27453: PPUSH
27454: LD_STRING DJ1
27456: PUSH
27457: LD_STRING DJ4
27459: PUSH
27460: LD_STRING DJ6
27462: PUSH
27463: EMPTY
27464: LIST
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 1
27470: PPUSH
27471: LD_INT 3
27473: PPUSH
27474: CALL_OW 12
27478: ARRAY
27479: PPUSH
27480: CALL_OW 94
// Wait ( 4 4$00 ) ;
27484: LD_INT 8400
27486: PPUSH
27487: CALL_OW 67
// dialog_south := true ;
27491: LD_ADDR_EXP 6
27495: PUSH
27496: LD_INT 1
27498: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27499: LD_VAR 0 1
27503: PUSH
27504: LD_INT 104
27506: EQUAL
27507: PUSH
27508: LD_EXP 7
27512: AND
27513: IFFALSE 27535
// begin dialog_popov := false ;
27515: LD_ADDR_EXP 7
27519: PUSH
27520: LD_INT 0
27522: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27523: LD_EXP 24
27527: PPUSH
27528: LD_STRING DR4
27530: PPUSH
27531: CALL_OW 94
// end ; end ;
27535: PPOPN 1
27537: END
// on BuildingStarted ( b , unit ) do var side , i ;
27538: LD_INT 0
27540: PPUSH
27541: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27542: LD_EXP 39
27546: PUSH
27547: LD_VAR 0 1
27551: PPUSH
27552: CALL_OW 255
27556: ARRAY
27557: IFFALSE 27735
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27559: LD_STRING BuildingStarted [side: 
27561: PUSH
27562: LD_VAR 0 1
27566: PPUSH
27567: CALL_OW 255
27571: STR
27572: PUSH
27573: LD_STRING ; btype: 
27575: STR
27576: PUSH
27577: LD_VAR 0 1
27581: PPUSH
27582: CALL_OW 266
27586: STR
27587: PUSH
27588: LD_STRING ; unit: 
27590: STR
27591: PUSH
27592: LD_VAR 0 2
27596: STR
27597: PUSH
27598: LD_STRING ]
27600: STR
27601: PPUSH
27602: CALL 7790 0 1
// side := GetSide ( b ) ;
27606: LD_ADDR_VAR 0 3
27610: PUSH
27611: LD_VAR 0 1
27615: PPUSH
27616: CALL_OW 255
27620: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27621: LD_VAR 0 3
27625: PPUSH
27626: LD_INT 21
27628: PUSH
27629: LD_INT 3
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: PPUSH
27636: CALL 11393 0 2
27640: PUSH
27641: LD_INT 1
27643: EQUAL
27644: IFFALSE 27735
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27646: LD_ADDR_VAR 0 4
27650: PUSH
27651: LD_VAR 0 3
27655: PPUSH
27656: LD_INT 21
27658: PUSH
27659: LD_INT 1
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PPUSH
27666: CALL 11393 0 2
27670: PUSH
27671: LD_VAR 0 3
27675: PPUSH
27676: LD_INT 2
27678: PPUSH
27679: EMPTY
27680: PPUSH
27681: CALL 11476 0 3
27685: DIFF
27686: PUSH
27687: FOR_IN
27688: IFFALSE 27733
// if not HasTask ( i ) then
27690: LD_VAR 0 4
27694: PPUSH
27695: CALL_OW 314
27699: NOT
27700: IFFALSE 27731
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27702: LD_VAR 0 4
27706: PPUSH
27707: LD_VAR 0 1
27711: PPUSH
27712: CALL_OW 250
27716: PPUSH
27717: LD_VAR 0 1
27721: PPUSH
27722: CALL_OW 251
27726: PPUSH
27727: CALL_OW 111
27731: GO 27687
27733: POP
27734: POP
// end ;
27735: PPOPN 4
27737: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27738: LD_EXP 39
27742: PUSH
27743: LD_VAR 0 1
27747: PPUSH
27748: CALL_OW 255
27752: ARRAY
27753: IFFALSE 28122
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27755: LD_STRING BuildingComplete [side: 
27757: PUSH
27758: LD_VAR 0 1
27762: PPUSH
27763: CALL_OW 255
27767: STR
27768: PUSH
27769: LD_STRING ; btype: 
27771: STR
27772: PUSH
27773: LD_VAR 0 1
27777: PPUSH
27778: CALL_OW 266
27782: STR
27783: PUSH
27784: LD_STRING ]
27786: STR
27787: PPUSH
27788: CALL 7790 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27792: LD_ADDR_EXP 46
27796: PUSH
27797: LD_EXP 46
27801: PPUSH
27802: LD_VAR 0 1
27806: PPUSH
27807: CALL_OW 255
27811: PPUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 266
27821: PPUSH
27822: LD_VAR 0 1
27826: PPUSH
27827: CALL_OW 250
27831: PUSH
27832: LD_VAR 0 1
27836: PPUSH
27837: CALL_OW 251
27841: PUSH
27842: LD_VAR 0 1
27846: PPUSH
27847: CALL_OW 254
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: LIST
27856: PPUSH
27857: CALL 42234 0 4
27861: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27862: LD_VAR 0 1
27866: PPUSH
27867: CALL_OW 266
27871: PUSH
27872: LD_INT 6
27874: EQUAL
27875: IFFALSE 27909
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27877: LD_ADDR_EXP 40
27881: PUSH
27882: LD_EXP 40
27886: PPUSH
27887: LD_VAR 0 1
27891: PPUSH
27892: CALL_OW 255
27896: PPUSH
27897: LD_VAR 0 1
27901: PPUSH
27902: EMPTY
27903: PPUSH
27904: CALL 42143 0 4
27908: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27909: LD_VAR 0 1
27913: PPUSH
27914: CALL_OW 266
27918: PUSH
27919: LD_INT 0
27921: EQUAL
27922: IFFALSE 28032
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27924: LD_ADDR_EXP 48
27928: PUSH
27929: LD_EXP 48
27933: PPUSH
27934: LD_VAR 0 1
27938: PPUSH
27939: CALL_OW 255
27943: PPUSH
27944: LD_INT 0
27946: PPUSH
27947: EMPTY
27948: PPUSH
27949: CALL 42143 0 4
27953: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27954: LD_VAR 0 1
27958: PPUSH
27959: CALL_OW 274
27963: PPUSH
27964: LD_INT 1
27966: PPUSH
27967: LD_EXP 72
27971: PUSH
27972: LD_INT 1
27974: ARRAY
27975: PPUSH
27976: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
27980: LD_VAR 0 1
27984: PPUSH
27985: CALL_OW 274
27989: PPUSH
27990: LD_INT 2
27992: PPUSH
27993: LD_EXP 72
27997: PUSH
27998: LD_INT 2
28000: ARRAY
28001: PPUSH
28002: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28006: LD_VAR 0 1
28010: PPUSH
28011: CALL_OW 274
28015: PPUSH
28016: LD_INT 3
28018: PPUSH
28019: LD_EXP 72
28023: PUSH
28024: LD_INT 3
28026: ARRAY
28027: PPUSH
28028: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28032: LD_VAR 0 1
28036: PPUSH
28037: CALL_OW 266
28041: PUSH
28042: LD_INT 2
28044: EQUAL
28045: IFFALSE 28077
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28047: LD_ADDR_EXP 48
28051: PUSH
28052: LD_EXP 48
28056: PPUSH
28057: LD_VAR 0 1
28061: PPUSH
28062: CALL_OW 255
28066: PPUSH
28067: LD_INT 2
28069: PPUSH
28070: EMPTY
28071: PPUSH
28072: CALL 42143 0 4
28076: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28077: LD_VAR 0 1
28081: PPUSH
28082: CALL_OW 266
28086: PUSH
28087: LD_INT 4
28089: EQUAL
28090: IFFALSE 28122
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28092: LD_ADDR_EXP 48
28096: PUSH
28097: LD_EXP 48
28101: PPUSH
28102: LD_VAR 0 1
28106: PPUSH
28107: CALL_OW 255
28111: PPUSH
28112: LD_INT 4
28114: PPUSH
28115: EMPTY
28116: PPUSH
28117: CALL 42143 0 4
28121: ST_TO_ADDR
// end ;
28122: PPOPN 1
28124: END
// on ResearchComplete ( tech , lab ) do var i ;
28125: LD_INT 0
28127: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28128: LD_EXP 39
28132: PUSH
28133: LD_VAR 0 2
28137: PPUSH
28138: CALL_OW 255
28142: ARRAY
28143: IFFALSE 28427
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28145: LD_STRING ResearchComplete [side: 
28147: PUSH
28148: LD_VAR 0 2
28152: PPUSH
28153: CALL_OW 255
28157: PPUSH
28158: CALL_OW 255
28162: STR
28163: PUSH
28164: LD_STRING ; tech:
28166: STR
28167: PUSH
28168: LD_VAR 0 1
28172: STR
28173: PUSH
28174: LD_STRING ]
28176: STR
28177: PPUSH
28178: CALL 7790 0 1
// for i = 1 to MREG_ToRes do
28182: LD_ADDR_VAR 0 3
28186: PUSH
28187: DOUBLE
28188: LD_INT 1
28190: DEC
28191: ST_TO_ADDR
28192: LD_EXP 50
28196: PUSH
28197: FOR_TO
28198: IFFALSE 28285
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28200: LD_EXP 50
28204: PUSH
28205: LD_VAR 0 3
28209: ARRAY
28210: PUSH
28211: LD_INT 1
28213: ARRAY
28214: PUSH
28215: LD_VAR 0 2
28219: PPUSH
28220: CALL_OW 255
28224: EQUAL
28225: PUSH
28226: LD_EXP 50
28230: PUSH
28231: LD_VAR 0 3
28235: ARRAY
28236: PUSH
28237: LD_INT 2
28239: ARRAY
28240: PUSH
28241: LD_VAR 0 1
28245: EQUAL
28246: AND
28247: IFFALSE 28283
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28249: LD_ADDR_EXP 50
28253: PUSH
28254: LD_EXP 50
28258: PPUSH
28259: LD_VAR 0 2
28263: PPUSH
28264: CALL_OW 255
28268: PPUSH
28269: LD_VAR 0 1
28273: PPUSH
28274: EMPTY
28275: PPUSH
28276: CALL 42234 0 4
28280: ST_TO_ADDR
// break ;
28281: GO 28285
// end ;
28283: GO 28197
28285: POP
28286: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28287: LD_VAR 0 1
28291: PUSH
28292: LD_INT 2
28294: PUSH
28295: LD_INT 11
28297: PUSH
28298: LD_INT 4
28300: PUSH
28301: LD_INT 3
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: LIST
28308: LIST
28309: IN
28310: IFFALSE 28427
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28312: LD_ADDR_VAR 0 3
28316: PUSH
28317: LD_VAR 0 2
28321: PPUSH
28322: CALL_OW 255
28326: PPUSH
28327: LD_INT 16
28329: PPUSH
28330: LD_INT 25
28332: PUSH
28333: LD_INT 4
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PPUSH
28340: CALL 12096 0 3
28344: ST_TO_ADDR
// if i then
28345: LD_VAR 0 3
28349: IFFALSE 28367
// SetTag ( i [ 1 ] , 0 ) ;
28351: LD_VAR 0 3
28355: PUSH
28356: LD_INT 1
28358: ARRAY
28359: PPUSH
28360: LD_INT 0
28362: PPUSH
28363: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: LD_VAR 0 2
28376: PPUSH
28377: CALL_OW 255
28381: PPUSH
28382: LD_INT 171
28384: PPUSH
28385: EMPTY
28386: PPUSH
28387: CALL 12096 0 3
28391: ST_TO_ADDR
// if i then
28392: LD_VAR 0 3
28396: IFFALSE 28427
// begin SetTag ( i [ 1 ] , 0 ) ;
28398: LD_VAR 0 3
28402: PUSH
28403: LD_INT 1
28405: ARRAY
28406: PPUSH
28407: LD_INT 0
28409: PPUSH
28410: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28414: LD_VAR 0 3
28418: PUSH
28419: LD_INT 1
28421: ARRAY
28422: PPUSH
28423: CALL_OW 122
// end ; end ; end ;
28427: PPOPN 3
28429: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28430: LD_INT 0
28432: PPUSH
28433: PPUSH
28434: PPUSH
28435: PPUSH
28436: PPUSH
28437: PPUSH
28438: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28439: LD_EXP 39
28443: PUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: ARRAY
28454: IFFALSE 29181
// begin side := GetSide ( veh ) ;
28456: LD_ADDR_VAR 0 4
28460: PUSH
28461: LD_VAR 0 1
28465: PPUSH
28466: CALL_OW 255
28470: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28471: LD_ADDR_VAR 0 6
28475: PUSH
28476: LD_VAR 0 1
28480: PPUSH
28481: CALL_OW 265
28485: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28486: LD_ADDR_VAR 0 7
28490: PUSH
28491: LD_VAR 0 1
28495: PPUSH
28496: CALL_OW 262
28500: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28501: LD_ADDR_VAR 0 8
28505: PUSH
28506: LD_VAR 0 1
28510: PPUSH
28511: CALL_OW 263
28515: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28516: LD_ADDR_VAR 0 9
28520: PUSH
28521: LD_VAR 0 1
28525: PPUSH
28526: CALL_OW 264
28530: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28531: LD_STRING VehicleConstructed [side: 
28533: PUSH
28534: LD_VAR 0 4
28538: STR
28539: PUSH
28540: LD_STRING ; id:
28542: STR
28543: PUSH
28544: LD_VAR 0 1
28548: STR
28549: PUSH
28550: LD_STRING ; components: [
28552: STR
28553: PUSH
28554: LD_VAR 0 6
28558: STR
28559: PUSH
28560: LD_STRING , 
28562: STR
28563: PUSH
28564: LD_VAR 0 7
28568: STR
28569: PUSH
28570: LD_STRING , 
28572: STR
28573: PUSH
28574: LD_VAR 0 8
28578: STR
28579: PUSH
28580: LD_STRING , 
28582: STR
28583: PUSH
28584: LD_VAR 0 9
28588: STR
28589: PUSH
28590: LD_STRING ]]
28592: STR
28593: PPUSH
28594: CALL 7790 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28598: LD_VAR 0 1
28602: PPUSH
28603: CALL_OW 264
28607: PUSH
28608: LD_INT 13
28610: PUSH
28611: LD_INT 12
28613: PUSH
28614: LD_INT 14
28616: PUSH
28617: LD_INT 51
28619: PUSH
28620: LD_INT 53
28622: PUSH
28623: LD_INT 52
28625: PUSH
28626: LD_INT 32
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: LIST
28636: LIST
28637: IN
28638: NOT
28639: IFFALSE 28681
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28641: LD_ADDR_EXP 59
28645: PUSH
28646: LD_EXP 59
28650: PPUSH
28651: LD_VAR 0 4
28655: PPUSH
28656: LD_EXP 59
28660: PUSH
28661: LD_VAR 0 4
28665: ARRAY
28666: PUSH
28667: LD_INT 1
28669: PLUS
28670: PPUSH
28671: LD_VAR 0 1
28675: PPUSH
28676: CALL 30861 0 4
28680: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28681: LD_VAR 0 1
28685: PPUSH
28686: CALL_OW 264
28690: PUSH
28691: LD_INT 31
28693: EQUAL
28694: IFFALSE 28713
// SetTag ( GetDriver ( veh ) , 9 ) ;
28696: LD_VAR 0 1
28700: PPUSH
28701: CALL 31555 0 1
28705: PPUSH
28706: LD_INT 9
28708: PPUSH
28709: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28713: LD_VAR 0 1
28717: PPUSH
28718: CALL_OW 264
28722: PUSH
28723: LD_INT 14
28725: PUSH
28726: LD_INT 53
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: IN
28733: IFFALSE 28770
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28735: LD_ADDR_EXP 42
28739: PUSH
28740: LD_EXP 42
28744: PPUSH
28745: LD_VAR 0 1
28749: PPUSH
28750: CALL_OW 255
28754: PPUSH
28755: LD_INT 2
28757: PPUSH
28758: LD_VAR 0 1
28762: PPUSH
28763: CALL 30861 0 4
28767: ST_TO_ADDR
// exit ;
28768: GO 29181
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28770: LD_VAR 0 1
28774: PPUSH
28775: CALL_OW 265
28779: PUSH
28780: LD_EXP 66
28784: PUSH
28785: LD_VAR 0 4
28789: ARRAY
28790: PUSH
28791: LD_INT 1
28793: ARRAY
28794: IN
28795: PUSH
28796: LD_VAR 0 1
28800: PPUSH
28801: CALL_OW 262
28805: PUSH
28806: LD_EXP 66
28810: PUSH
28811: LD_VAR 0 4
28815: ARRAY
28816: PUSH
28817: LD_INT 1
28819: ARRAY
28820: IN
28821: AND
28822: PUSH
28823: LD_VAR 0 1
28827: PPUSH
28828: CALL_OW 263
28832: PUSH
28833: LD_EXP 66
28837: PUSH
28838: LD_VAR 0 4
28842: ARRAY
28843: PUSH
28844: LD_INT 1
28846: ARRAY
28847: IN
28848: AND
28849: PUSH
28850: LD_VAR 0 1
28854: PPUSH
28855: CALL_OW 264
28859: PUSH
28860: LD_EXP 66
28864: PUSH
28865: LD_VAR 0 4
28869: ARRAY
28870: PUSH
28871: LD_INT 1
28873: ARRAY
28874: IN
28875: AND
28876: IFFALSE 28920
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28878: LD_ADDR_EXP 67
28882: PUSH
28883: LD_EXP 67
28887: PPUSH
28888: LD_VAR 0 4
28892: PPUSH
28893: LD_EXP 67
28897: PUSH
28898: LD_VAR 0 4
28902: ARRAY
28903: PUSH
28904: LD_INT 1
28906: PLUS
28907: PPUSH
28908: LD_VAR 0 1
28912: PPUSH
28913: CALL 30861 0 4
28917: ST_TO_ADDR
// exit ;
28918: GO 29181
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28920: LD_VAR 0 6
28924: PUSH
28925: LD_EXP 69
28929: PUSH
28930: LD_VAR 0 4
28934: ARRAY
28935: PUSH
28936: LD_INT 1
28938: ARRAY
28939: EQUAL
28940: PUSH
28941: LD_VAR 0 7
28945: PUSH
28946: LD_EXP 69
28950: PUSH
28951: LD_VAR 0 4
28955: ARRAY
28956: PUSH
28957: LD_INT 2
28959: ARRAY
28960: EQUAL
28961: AND
28962: PUSH
28963: LD_VAR 0 8
28967: PUSH
28968: LD_EXP 69
28972: PUSH
28973: LD_VAR 0 4
28977: ARRAY
28978: PUSH
28979: LD_INT 3
28981: ARRAY
28982: EQUAL
28983: AND
28984: PUSH
28985: LD_VAR 0 9
28989: PUSH
28990: LD_EXP 69
28994: PUSH
28995: LD_VAR 0 4
28999: ARRAY
29000: PUSH
29001: LD_INT 4
29003: ARRAY
29004: EQUAL
29005: AND
29006: IFFALSE 29162
// begin tmp := MREG_ToAttack [ side ] ;
29008: LD_ADDR_VAR 0 5
29012: PUSH
29013: LD_EXP 69
29017: PUSH
29018: LD_VAR 0 4
29022: ARRAY
29023: ST_TO_ADDR
// for i = 1 to 4 do
29024: LD_ADDR_VAR 0 3
29028: PUSH
29029: DOUBLE
29030: LD_INT 1
29032: DEC
29033: ST_TO_ADDR
29034: LD_INT 4
29036: PUSH
29037: FOR_TO
29038: IFFALSE 29060
// tmp := Delete ( tmp , 1 ) ;
29040: LD_ADDR_VAR 0 5
29044: PUSH
29045: LD_VAR 0 5
29049: PPUSH
29050: LD_INT 1
29052: PPUSH
29053: CALL_OW 3
29057: ST_TO_ADDR
29058: GO 29037
29060: POP
29061: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29062: LD_ADDR_EXP 69
29066: PUSH
29067: LD_EXP 69
29071: PPUSH
29072: LD_VAR 0 4
29076: PPUSH
29077: LD_VAR 0 5
29081: PPUSH
29082: CALL_OW 1
29086: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29087: LD_ADDR_EXP 71
29091: PUSH
29092: LD_EXP 71
29096: PPUSH
29097: LD_VAR 0 4
29101: PPUSH
29102: LD_EXP 71
29106: PUSH
29107: LD_VAR 0 4
29111: ARRAY
29112: PUSH
29113: LD_INT 1
29115: PLUS
29116: PPUSH
29117: LD_VAR 0 1
29121: PPUSH
29122: CALL 30861 0 4
29126: ST_TO_ADDR
// if tmp = 0 then
29127: LD_VAR 0 5
29131: PUSH
29132: LD_INT 0
29134: EQUAL
29135: IFFALSE 29160
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29137: LD_ADDR_EXP 69
29141: PUSH
29142: LD_EXP 69
29146: PPUSH
29147: LD_VAR 0 4
29151: PPUSH
29152: LD_INT 0
29154: PPUSH
29155: CALL_OW 1
29159: ST_TO_ADDR
// exit ;
29160: GO 29181
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29162: LD_VAR 0 1
29166: PPUSH
29167: CALL_OW 255
29171: PPUSH
29172: LD_VAR 0 1
29176: PPUSH
29177: CALL 25554 0 2
// end ;
29181: PPOPN 9
29183: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29184: LD_EXP 39
29188: PUSH
29189: LD_VAR 0 2
29193: PPUSH
29194: CALL_OW 255
29198: ARRAY
29199: IFFALSE 29431
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29201: LD_STRING ApemanTamed [side: 
29203: PUSH
29204: LD_VAR 0 2
29208: PPUSH
29209: CALL_OW 255
29213: STR
29214: PUSH
29215: LD_STRING ; sci: 
29217: STR
29218: PUSH
29219: LD_VAR 0 2
29223: STR
29224: PUSH
29225: LD_STRING ; ape: 
29227: STR
29228: PUSH
29229: LD_VAR 0 1
29233: STR
29234: PUSH
29235: LD_STRING ]
29237: STR
29238: PPUSH
29239: CALL 7790 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29243: LD_INT 11
29245: PPUSH
29246: LD_VAR 0 2
29250: PPUSH
29251: CALL_OW 255
29255: PPUSH
29256: CALL_OW 321
29260: PUSH
29261: LD_INT 2
29263: EQUAL
29264: NOT
29265: PUSH
29266: LD_INT 2
29268: PPUSH
29269: LD_VAR 0 2
29273: PPUSH
29274: CALL_OW 255
29278: PPUSH
29279: CALL_OW 321
29283: PUSH
29284: LD_INT 2
29286: EQUAL
29287: NOT
29288: OR
29289: PUSH
29290: LD_VAR 0 2
29294: PPUSH
29295: CALL_OW 255
29299: PPUSH
29300: LD_INT 171
29302: PPUSH
29303: EMPTY
29304: PPUSH
29305: CALL 12096 0 3
29309: PUSH
29310: LD_INT 0
29312: EQUAL
29313: AND
29314: IFFALSE 29328
// begin SetTag ( ape , 171 ) ;
29316: LD_VAR 0 1
29320: PPUSH
29321: LD_INT 171
29323: PPUSH
29324: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29328: LD_VAR 0 2
29332: PPUSH
29333: CALL_OW 255
29337: PPUSH
29338: LD_INT 30
29340: PUSH
29341: LD_INT 1
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PPUSH
29348: CALL 11393 0 2
29352: IFFALSE 29431
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29354: LD_VAR 0 1
29358: PPUSH
29359: LD_VAR 0 2
29363: PPUSH
29364: CALL_OW 255
29368: PPUSH
29369: LD_INT 30
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PPUSH
29379: CALL 11393 0 2
29383: PUSH
29384: LD_INT 1
29386: ARRAY
29387: PPUSH
29388: CALL_OW 250
29392: PPUSH
29393: LD_VAR 0 2
29397: PPUSH
29398: CALL_OW 255
29402: PPUSH
29403: LD_INT 30
29405: PUSH
29406: LD_INT 1
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PPUSH
29413: CALL 11393 0 2
29417: PUSH
29418: LD_INT 1
29420: ARRAY
29421: PPUSH
29422: CALL_OW 251
29426: PPUSH
29427: CALL_OW 111
// end ;
29431: PPOPN 2
29433: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29434: LD_EXP 39
29438: PUSH
29439: LD_VAR 0 1
29443: PPUSH
29444: CALL_OW 255
29448: ARRAY
29449: IFFALSE 29727
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29451: LD_VAR 0 2
29455: PUSH
29456: LD_VAR 0 2
29460: PPUSH
29461: CALL_OW 255
29465: PPUSH
29466: CALL 11806 0 1
29470: IN
29471: IFFALSE 29612
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29473: LD_VAR 0 1
29477: PPUSH
29478: CALL_OW 266
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: LD_INT 1
29488: PUSH
29489: EMPTY
29490: LIST
29491: LIST
29492: IN
29493: IFFALSE 29523
// begin Wait ( 0 0$0.3 ) ;
29495: LD_INT 10
29497: PPUSH
29498: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29502: LD_VAR 0 2
29506: PPUSH
29507: LD_INT 16
29509: PPUSH
29510: CALL_OW 336
// ComExitBuilding ( un ) ;
29514: LD_VAR 0 2
29518: PPUSH
29519: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29523: LD_VAR 0 1
29527: PPUSH
29528: CALL_OW 266
29532: PUSH
29533: LD_INT 4
29535: PUSH
29536: LD_INT 5
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: IN
29543: IFFALSE 29612
// begin Wait ( 0 0$0.3 ) ;
29545: LD_INT 10
29547: PPUSH
29548: CALL_OW 67
// if GetTag ( un ) = 0 then
29552: LD_VAR 0 2
29556: PPUSH
29557: CALL_OW 110
29561: PUSH
29562: LD_INT 0
29564: EQUAL
29565: IFFALSE 29581
// SetClass ( un , class_apeman_soldier ) else
29567: LD_VAR 0 2
29571: PPUSH
29572: LD_INT 15
29574: PPUSH
29575: CALL_OW 336
29579: GO 29612
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29581: LD_INT 3
29583: PPUSH
29584: LD_VAR 0 2
29588: PPUSH
29589: CALL_OW 255
29593: PPUSH
29594: CALL_OW 321
29598: IFFALSE 29612
// SetClass ( un , class_apeman_kamikaze ) ;
29600: LD_VAR 0 2
29604: PPUSH
29605: LD_INT 17
29607: PPUSH
29608: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29612: LD_VAR 0 1
29616: PPUSH
29617: CALL_OW 266
29621: PUSH
29622: LD_INT 32
29624: EQUAL
29625: IFFALSE 29727
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29627: LD_ADDR_EXP 68
29631: PUSH
29632: LD_EXP 68
29636: PPUSH
29637: LD_VAR 0 1
29641: PPUSH
29642: CALL_OW 255
29646: PPUSH
29647: LD_EXP 68
29651: PUSH
29652: LD_VAR 0 1
29656: PPUSH
29657: CALL_OW 255
29661: ARRAY
29662: PUSH
29663: LD_INT 1
29665: PLUS
29666: PPUSH
29667: LD_VAR 0 1
29671: PPUSH
29672: CALL 30861 0 4
29676: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29677: LD_ADDR_EXP 68
29681: PUSH
29682: LD_EXP 68
29686: PPUSH
29687: LD_VAR 0 1
29691: PPUSH
29692: CALL_OW 255
29696: PPUSH
29697: LD_EXP 68
29701: PUSH
29702: LD_VAR 0 1
29706: PPUSH
29707: CALL_OW 255
29711: ARRAY
29712: PUSH
29713: LD_INT 1
29715: PLUS
29716: PPUSH
29717: LD_VAR 0 2
29721: PPUSH
29722: CALL 30861 0 4
29726: ST_TO_ADDR
// end ; end ;
29727: PPOPN 2
29729: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29730: LD_VAR 0 1
29734: PUSH
29735: LD_INT 22
29737: PUSH
29738: LD_INT 1
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PUSH
29745: LD_INT 21
29747: PUSH
29748: LD_INT 3
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PPUSH
29759: CALL_OW 69
29763: IN
29764: PUSH
29765: LD_EXP 13
29769: NOT
29770: AND
29771: IFFALSE 29834
// begin alfa_north_triggered := true ;
29773: LD_ADDR_EXP 13
29777: PUSH
29778: LD_INT 1
29780: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29781: LD_EXP 4
29785: PPUSH
29786: LD_STRING DS4
29788: PPUSH
29789: CALL_OW 94
// Wait ( 1 1$25 ) ;
29793: LD_INT 2975
29795: PPUSH
29796: CALL_OW 67
// if not isTest then
29800: LD_EXP 1
29804: NOT
29805: IFFALSE 29834
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29807: LD_INT 20
29809: PPUSH
29810: LD_INT 5
29812: PUSH
29813: LD_INT 6
29815: PUSH
29816: LD_INT 7
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: LIST
29823: PUSH
29824: LD_OWVAR 67
29828: ARRAY
29829: PPUSH
29830: CALL 6948 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29834: LD_VAR 0 1
29838: PUSH
29839: LD_INT 22
29841: PUSH
29842: LD_INT 4
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 21
29851: PUSH
29852: LD_INT 3
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PPUSH
29863: CALL_OW 69
29867: IN
29868: PUSH
29869: LD_EXP 14
29873: NOT
29874: AND
29875: IFFALSE 29938
// begin alfa_south_triggered := true ;
29877: LD_ADDR_EXP 14
29881: PUSH
29882: LD_INT 1
29884: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29885: LD_EXP 3
29889: PPUSH
29890: LD_STRING DJ3
29892: PPUSH
29893: CALL_OW 94
// Wait ( 0 0$45 ) ;
29897: LD_INT 1575
29899: PPUSH
29900: CALL_OW 67
// if not isTest then
29904: LD_EXP 1
29908: NOT
29909: IFFALSE 29938
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29911: LD_INT 20
29913: PPUSH
29914: LD_INT 5
29916: PUSH
29917: LD_INT 6
29919: PUSH
29920: LD_INT 7
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: LIST
29927: PUSH
29928: LD_OWVAR 67
29932: ARRAY
29933: PPUSH
29934: CALL 6948 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
29938: LD_VAR 0 1
29942: PPUSH
29943: CALL_OW 266
29947: PUSH
29948: LD_INT 1
29950: EQUAL
29951: PUSH
29952: LD_VAR 0 1
29956: PPUSH
29957: CALL_OW 255
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: LD_INT 4
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: IN
29972: AND
29973: IFFALSE 29982
// RaiseSailEvent ( 104 ) ;
29975: LD_INT 104
29977: PPUSH
29978: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
29982: LD_EXP 39
29986: PUSH
29987: LD_VAR 0 1
29991: PPUSH
29992: CALL_OW 255
29996: ARRAY
29997: IFFALSE 30384
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
29999: LD_STRING UnitDestroyed [side 
30001: PUSH
30002: LD_VAR 0 1
30006: PPUSH
30007: CALL_OW 255
30011: STR
30012: PUSH
30013: LD_STRING ; id: 
30015: STR
30016: PUSH
30017: LD_VAR 0 1
30021: STR
30022: PUSH
30023: LD_STRING ; type: 
30025: STR
30026: PUSH
30027: LD_VAR 0 1
30031: PPUSH
30032: CALL_OW 247
30036: STR
30037: PUSH
30038: LD_STRING ]
30040: STR
30041: PPUSH
30042: CALL 7790 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30046: LD_VAR 0 1
30050: PUSH
30051: LD_VAR 0 1
30055: PPUSH
30056: CALL_OW 255
30060: PPUSH
30061: LD_INT 21
30063: PUSH
30064: LD_INT 1
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PPUSH
30071: CALL 11393 0 2
30075: IN
30076: IFFALSE 30232
// begin if MCF_HasClass ( un ) then
30078: LD_VAR 0 1
30082: PPUSH
30083: CALL 14099 0 1
30087: IFFALSE 30232
// case MCF_HasClass ( un ) of 1 :
30089: LD_VAR 0 1
30093: PPUSH
30094: CALL 14099 0 1
30098: PUSH
30099: LD_INT 1
30101: DOUBLE
30102: EQUAL
30103: IFTRUE 30107
30105: GO 30132
30107: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30108: LD_VAR 0 1
30112: PPUSH
30113: CALL_OW 255
30117: PPUSH
30118: LD_STRING ToArm
30120: PPUSH
30121: LD_VAR 0 1
30125: PPUSH
30126: CALL 14272 0 3
30130: GO 30232
30132: LD_INT 2
30134: DOUBLE
30135: EQUAL
30136: IFTRUE 30140
30138: GO 30165
30140: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30141: LD_VAR 0 1
30145: PPUSH
30146: CALL_OW 255
30150: PPUSH
30151: LD_STRING ToDep
30153: PPUSH
30154: LD_VAR 0 1
30158: PPUSH
30159: CALL 14272 0 3
30163: GO 30232
30165: LD_INT 3
30167: DOUBLE
30168: EQUAL
30169: IFTRUE 30173
30171: GO 30198
30173: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30174: LD_VAR 0 1
30178: PPUSH
30179: CALL_OW 255
30183: PPUSH
30184: LD_STRING ToFac
30186: PPUSH
30187: LD_VAR 0 1
30191: PPUSH
30192: CALL 14272 0 3
30196: GO 30232
30198: LD_INT 4
30200: DOUBLE
30201: EQUAL
30202: IFTRUE 30206
30204: GO 30231
30206: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 255
30216: PPUSH
30217: LD_STRING ToLab
30219: PPUSH
30220: LD_VAR 0 1
30224: PPUSH
30225: CALL 14272 0 3
30229: GO 30232
30231: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30232: LD_VAR 0 1
30236: PUSH
30237: LD_EXP 67
30241: PUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: CALL_OW 255
30251: ARRAY
30252: IN
30253: IFFALSE 30338
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30255: LD_ADDR_EXP 67
30259: PUSH
30260: LD_EXP 67
30264: PPUSH
30265: LD_VAR 0 1
30269: PPUSH
30270: LD_INT 0
30272: PPUSH
30273: CALL 31020 0 3
30277: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30278: LD_VAR 0 1
30282: PPUSH
30283: CALL_OW 255
30287: PPUSH
30288: LD_VAR 0 1
30292: PPUSH
30293: CALL_OW 265
30297: PUSH
30298: LD_VAR 0 1
30302: PPUSH
30303: CALL_OW 262
30307: PUSH
30308: LD_VAR 0 1
30312: PPUSH
30313: CALL_OW 263
30317: PUSH
30318: LD_VAR 0 1
30322: PPUSH
30323: CALL_OW 264
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: PPUSH
30334: CALL 20912 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30338: LD_VAR 0 1
30342: PUSH
30343: LD_EXP 71
30347: PUSH
30348: LD_VAR 0 1
30352: PPUSH
30353: CALL_OW 255
30357: ARRAY
30358: IN
30359: IFFALSE 30384
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30361: LD_ADDR_EXP 71
30365: PUSH
30366: LD_EXP 71
30370: PPUSH
30371: LD_VAR 0 1
30375: PPUSH
30376: LD_INT 0
30378: PPUSH
30379: CALL 31020 0 3
30383: ST_TO_ADDR
// end ; end ;
30384: PPOPN 1
30386: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30387: LD_EXP 39
30391: PUSH
30392: LD_VAR 0 2
30396: PPUSH
30397: CALL_OW 255
30401: ARRAY
30402: IFFALSE 30574
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30404: LD_VAR 0 2
30408: PUSH
30409: LD_EXP 68
30413: PUSH
30414: LD_VAR 0 2
30418: PPUSH
30419: CALL_OW 255
30423: ARRAY
30424: IN
30425: PUSH
30426: LD_VAR 0 1
30430: PPUSH
30431: CALL_OW 266
30435: PUSH
30436: LD_INT 32
30438: PUSH
30439: LD_INT 31
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: IN
30446: AND
30447: IFFALSE 30547
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30449: LD_ADDR_EXP 68
30453: PUSH
30454: LD_EXP 68
30458: PPUSH
30459: LD_VAR 0 1
30463: PPUSH
30464: LD_INT 0
30466: PPUSH
30467: CALL 31020 0 3
30471: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30472: LD_ADDR_EXP 68
30476: PUSH
30477: LD_EXP 68
30481: PPUSH
30482: LD_VAR 0 2
30486: PPUSH
30487: LD_INT 0
30489: PPUSH
30490: CALL 31020 0 3
30494: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30495: LD_EXP 68
30499: PUSH
30500: LD_VAR 0 2
30504: PPUSH
30505: CALL_OW 255
30509: ARRAY
30510: PUSH
30511: LD_STRING 
30513: EQUAL
30514: IFFALSE 30547
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30516: LD_ADDR_EXP 68
30520: PUSH
30521: LD_EXP 68
30525: PPUSH
30526: LD_VAR 0 2
30530: PPUSH
30531: CALL_OW 255
30535: PPUSH
30536: LD_INT 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 30861 0 4
30546: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 266
30556: PUSH
30557: LD_INT 36
30559: IN
30560: IFFALSE 30574
// SetTag ( un , 0 ) ;
30562: LD_VAR 0 2
30566: PPUSH
30567: LD_INT 0
30569: PPUSH
30570: CALL_OW 109
// end ;
30574: PPOPN 2
30576: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30577: LD_EXP 39
30581: PUSH
30582: LD_VAR 0 1
30586: PPUSH
30587: CALL_OW 255
30591: ARRAY
30592: IFFALSE 30618
// begin if GetControl ( un ) = control_remote then
30594: LD_VAR 0 1
30598: PPUSH
30599: CALL_OW 263
30603: PUSH
30604: LD_INT 2
30606: EQUAL
30607: IFFALSE 30618
// ComUnlink ( un ) ;
30609: LD_VAR 0 1
30613: PPUSH
30614: CALL_OW 136
// end ;
30618: PPOPN 1
30620: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30621: LD_EXP 39
30625: PUSH
30626: LD_VAR 0 1
30630: PPUSH
30631: CALL_OW 255
30635: ARRAY
30636: IFFALSE 30665
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30638: LD_VAR 0 2
30642: PPUSH
30643: CALL_OW 264
30647: PUSH
30648: LD_INT 31
30650: IN
30651: IFFALSE 30665
// SetTag ( driver , 0 ) ;
30653: LD_VAR 0 1
30657: PPUSH
30658: LD_INT 0
30660: PPUSH
30661: CALL_OW 109
// end ;
30665: PPOPN 4
30667: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30668: LD_INT 0
30670: PPUSH
30671: PPUSH
30672: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30673: LD_ADDR_VAR 0 3
30677: PUSH
30678: LD_VAR 0 1
30682: PPUSH
30683: CALL_OW 269
30687: ST_TO_ADDR
// x := GetX ( building ) ;
30688: LD_ADDR_VAR 0 4
30692: PUSH
30693: LD_VAR 0 1
30697: PPUSH
30698: CALL_OW 250
30702: ST_TO_ADDR
// y := GetY ( building ) ;
30703: LD_ADDR_VAR 0 5
30707: PUSH
30708: LD_VAR 0 1
30712: PPUSH
30713: CALL_OW 251
30717: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30718: LD_ADDR_EXP 43
30722: PUSH
30723: LD_EXP 43
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: CALL_OW 255
30737: PPUSH
30738: LD_VAR 0 3
30742: PPUSH
30743: LD_VAR 0 4
30747: PUSH
30748: LD_VAR 0 5
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PPUSH
30757: CALL 42234 0 4
30761: ST_TO_ADDR
// end ;
30762: PPOPN 5
30764: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30765: LD_VAR 0 1
30769: PUSH
30770: LD_EXP 30
30774: IN
30775: NOT
30776: IFFALSE 30824
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30778: LD_ADDR_EXP 30
30782: PUSH
30783: LD_EXP 30
30787: PPUSH
30788: LD_EXP 30
30792: PUSH
30793: LD_INT 1
30795: PLUS
30796: PPUSH
30797: LD_VAR 0 1
30801: PPUSH
30802: CALL_OW 2
30806: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30807: LD_STRING DestinationUnrechable. [unit: 
30809: PUSH
30810: LD_VAR 0 1
30814: STR
30815: PUSH
30816: LD_STRING ]
30818: STR
30819: PPUSH
30820: CALL 7790 0 1
// end ; end ;
30824: PPOPN 1
30826: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
30827: LD_VAR 0 1
30831: PPUSH
30832: LD_VAR 0 2
30836: PPUSH
30837: LD_VAR 0 3
30841: PPUSH
30842: CALL 43491 0 3
// end ;
30846: PPOPN 3
30848: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
30849: LD_VAR 0 1
30853: PPUSH
30854: CALL 43589 0 1
// end ; end_of_file
30858: PPOPN 1
30860: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30861: LD_INT 0
30863: PPUSH
30864: PPUSH
30865: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30866: LD_ADDR_VAR 0 7
30870: PUSH
30871: LD_VAR 0 1
30875: PUSH
30876: LD_VAR 0 2
30880: ARRAY
30881: PPUSH
30882: LD_VAR 0 3
30886: PPUSH
30887: LD_VAR 0 4
30891: PPUSH
30892: CALL_OW 1
30896: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30897: LD_ADDR_VAR 0 1
30901: PUSH
30902: LD_VAR 0 1
30906: PPUSH
30907: LD_VAR 0 2
30911: PPUSH
30912: LD_VAR 0 7
30916: PPUSH
30917: CALL_OW 1
30921: ST_TO_ADDR
// result := tab ;
30922: LD_ADDR_VAR 0 5
30926: PUSH
30927: LD_VAR 0 1
30931: ST_TO_ADDR
// end ;
30932: LD_VAR 0 5
30936: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
30942: LD_ADDR_VAR 0 5
30946: PUSH
30947: LD_VAR 0 1
30951: PUSH
30952: LD_VAR 0 2
30956: PUSH
30957: LD_INT 1
30959: ARRAY
30960: ARRAY
30961: PPUSH
30962: LD_VAR 0 2
30966: PUSH
30967: LD_INT 2
30969: ARRAY
30970: PPUSH
30971: CALL_OW 3
30975: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
30976: LD_ADDR_VAR 0 1
30980: PUSH
30981: LD_VAR 0 1
30985: PPUSH
30986: LD_VAR 0 2
30990: PUSH
30991: LD_INT 1
30993: ARRAY
30994: PPUSH
30995: LD_VAR 0 5
30999: PPUSH
31000: CALL_OW 1
31004: ST_TO_ADDR
// result := tab ;
31005: LD_ADDR_VAR 0 3
31009: PUSH
31010: LD_VAR 0 1
31014: ST_TO_ADDR
// end ;
31015: LD_VAR 0 3
31019: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31020: LD_INT 0
31022: PPUSH
31023: PPUSH
31024: PPUSH
31025: PPUSH
// i := 1 ;
31026: LD_ADDR_VAR 0 5
31030: PUSH
31031: LD_INT 1
31033: ST_TO_ADDR
// while ( i <= tab ) do
31034: LD_VAR 0 5
31038: PUSH
31039: LD_VAR 0 1
31043: LESSEQUAL
31044: IFFALSE 31419
// begin if not tab [ i ] then
31046: LD_VAR 0 1
31050: PUSH
31051: LD_VAR 0 5
31055: ARRAY
31056: NOT
31057: IFFALSE 31061
// break ;
31059: GO 31419
// if value in tab then
31061: LD_VAR 0 2
31065: PUSH
31066: LD_VAR 0 1
31070: IN
31071: IFFALSE 31184
// begin if not mode then
31073: LD_VAR 0 3
31077: NOT
31078: IFFALSE 31098
// tab := tab diff value else
31080: LD_ADDR_VAR 0 1
31084: PUSH
31085: LD_VAR 0 1
31089: PUSH
31090: LD_VAR 0 2
31094: DIFF
31095: ST_TO_ADDR
31096: GO 31160
// for j = 1 to tab do
31098: LD_ADDR_VAR 0 6
31102: PUSH
31103: DOUBLE
31104: LD_INT 1
31106: DEC
31107: ST_TO_ADDR
31108: LD_VAR 0 1
31112: PUSH
31113: FOR_TO
31114: IFFALSE 31158
// if tab [ j ] = value then
31116: LD_VAR 0 1
31120: PUSH
31121: LD_VAR 0 6
31125: ARRAY
31126: PUSH
31127: LD_VAR 0 2
31131: EQUAL
31132: IFFALSE 31156
// begin tab := Delete ( tab , j ) ;
31134: LD_ADDR_VAR 0 1
31138: PUSH
31139: LD_VAR 0 1
31143: PPUSH
31144: LD_VAR 0 6
31148: PPUSH
31149: CALL_OW 3
31153: ST_TO_ADDR
// break ;
31154: GO 31158
// end ;
31156: GO 31113
31158: POP
31159: POP
// i := i - 1 ;
31160: LD_ADDR_VAR 0 5
31164: PUSH
31165: LD_VAR 0 5
31169: PUSH
31170: LD_INT 1
31172: MINUS
31173: ST_TO_ADDR
// if mode then
31174: LD_VAR 0 3
31178: IFFALSE 31182
// break ;
31180: GO 31419
// end else
31182: GO 31403
// if tab [ i ] and value in tab [ i ] then
31184: LD_VAR 0 1
31188: PUSH
31189: LD_VAR 0 5
31193: ARRAY
31194: PUSH
31195: LD_VAR 0 2
31199: PUSH
31200: LD_VAR 0 1
31204: PUSH
31205: LD_VAR 0 5
31209: ARRAY
31210: IN
31211: AND
31212: IFFALSE 31403
// begin if not mode then
31214: LD_VAR 0 3
31218: NOT
31219: IFFALSE 31245
// tmp := tab [ i ] diff value else
31221: LD_ADDR_VAR 0 7
31225: PUSH
31226: LD_VAR 0 1
31230: PUSH
31231: LD_VAR 0 5
31235: ARRAY
31236: PUSH
31237: LD_VAR 0 2
31241: DIFF
31242: ST_TO_ADDR
31243: GO 31325
// for j = 1 to tab [ i ] do
31245: LD_ADDR_VAR 0 6
31249: PUSH
31250: DOUBLE
31251: LD_INT 1
31253: DEC
31254: ST_TO_ADDR
31255: LD_VAR 0 1
31259: PUSH
31260: LD_VAR 0 5
31264: ARRAY
31265: PUSH
31266: FOR_TO
31267: IFFALSE 31323
// if value = tab [ i ] [ j ] then
31269: LD_VAR 0 2
31273: PUSH
31274: LD_VAR 0 1
31278: PUSH
31279: LD_VAR 0 5
31283: ARRAY
31284: PUSH
31285: LD_VAR 0 6
31289: ARRAY
31290: EQUAL
31291: IFFALSE 31321
// begin tmp := Delete ( tab [ i ] , j ) ;
31293: LD_ADDR_VAR 0 7
31297: PUSH
31298: LD_VAR 0 1
31302: PUSH
31303: LD_VAR 0 5
31307: ARRAY
31308: PPUSH
31309: LD_VAR 0 6
31313: PPUSH
31314: CALL_OW 3
31318: ST_TO_ADDR
// break ;
31319: GO 31323
// end ;
31321: GO 31266
31323: POP
31324: POP
// if tmp = [ ] then
31325: LD_VAR 0 7
31329: PUSH
31330: EMPTY
31331: EQUAL
31332: IFFALSE 31356
// begin tab := Delete ( tab , i ) ;
31334: LD_ADDR_VAR 0 1
31338: PUSH
31339: LD_VAR 0 1
31343: PPUSH
31344: LD_VAR 0 5
31348: PPUSH
31349: CALL_OW 3
31353: ST_TO_ADDR
// end else
31354: GO 31381
// tab := Replace ( tab , i , tmp ) ;
31356: LD_ADDR_VAR 0 1
31360: PUSH
31361: LD_VAR 0 1
31365: PPUSH
31366: LD_VAR 0 5
31370: PPUSH
31371: LD_VAR 0 7
31375: PPUSH
31376: CALL_OW 1
31380: ST_TO_ADDR
// i := i - 1 ;
31381: LD_ADDR_VAR 0 5
31385: PUSH
31386: LD_VAR 0 5
31390: PUSH
31391: LD_INT 1
31393: MINUS
31394: ST_TO_ADDR
// if mode then
31395: LD_VAR 0 3
31399: IFFALSE 31403
// break ;
31401: GO 31419
// end ; i := i + 1 ;
31403: LD_ADDR_VAR 0 5
31407: PUSH
31408: LD_VAR 0 5
31412: PUSH
31413: LD_INT 1
31415: PLUS
31416: ST_TO_ADDR
// end ;
31417: GO 31034
// result := tab ;
31419: LD_ADDR_VAR 0 4
31423: PUSH
31424: LD_VAR 0 1
31428: ST_TO_ADDR
// end ;
31429: LD_VAR 0 4
31433: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31434: LD_INT 0
31436: PPUSH
31437: PPUSH
// for i = 1 to values do
31438: LD_ADDR_VAR 0 4
31442: PUSH
31443: DOUBLE
31444: LD_INT 1
31446: DEC
31447: ST_TO_ADDR
31448: LD_VAR 0 2
31452: PUSH
31453: FOR_TO
31454: IFFALSE 31487
// tab := Remove ( tab , values [ i ] , false ) ;
31456: LD_ADDR_VAR 0 1
31460: PUSH
31461: LD_VAR 0 1
31465: PPUSH
31466: LD_VAR 0 2
31470: PUSH
31471: LD_VAR 0 4
31475: ARRAY
31476: PPUSH
31477: LD_INT 0
31479: PPUSH
31480: CALL 31020 0 3
31484: ST_TO_ADDR
31485: GO 31453
31487: POP
31488: POP
// result := tab ;
31489: LD_ADDR_VAR 0 3
31493: PUSH
31494: LD_VAR 0 1
31498: ST_TO_ADDR
// end ;
31499: LD_VAR 0 3
31503: RET
// export function IsDriver ( unit ) ; begin
31504: LD_INT 0
31506: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31507: LD_VAR 0 1
31511: PUSH
31512: LD_INT 55
31514: PUSH
31515: EMPTY
31516: LIST
31517: PPUSH
31518: CALL_OW 69
31522: IN
31523: IFFALSE 31542
// result := IsInUnit ( unit ) else
31525: LD_ADDR_VAR 0 2
31529: PUSH
31530: LD_VAR 0 1
31534: PPUSH
31535: CALL_OW 310
31539: ST_TO_ADDR
31540: GO 31550
// result := false ;
31542: LD_ADDR_VAR 0 2
31546: PUSH
31547: LD_INT 0
31549: ST_TO_ADDR
// end ;
31550: LD_VAR 0 2
31554: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31555: LD_INT 0
31557: PPUSH
31558: PPUSH
31559: PPUSH
// if not GetControl ( veh ) = control_manual then
31560: LD_VAR 0 1
31564: PPUSH
31565: CALL_OW 263
31569: PUSH
31570: LD_INT 1
31572: EQUAL
31573: NOT
31574: IFFALSE 31586
// result := false else
31576: LD_ADDR_VAR 0 2
31580: PUSH
31581: LD_INT 0
31583: ST_TO_ADDR
31584: GO 31731
// if veh in FilterAllUnits ( [ f_empty ] ) then
31586: LD_VAR 0 1
31590: PUSH
31591: LD_INT 58
31593: PUSH
31594: EMPTY
31595: LIST
31596: PPUSH
31597: CALL_OW 69
31601: IN
31602: IFFALSE 31614
// result := false else
31604: LD_ADDR_VAR 0 2
31608: PUSH
31609: LD_INT 0
31611: ST_TO_ADDR
31612: GO 31731
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31614: LD_ADDR_VAR 0 4
31618: PUSH
31619: LD_INT 22
31621: PUSH
31622: LD_VAR 0 1
31626: PPUSH
31627: CALL_OW 255
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 55
31638: PUSH
31639: EMPTY
31640: LIST
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PPUSH
31646: CALL_OW 69
31650: ST_TO_ADDR
// if not filter then
31651: LD_VAR 0 4
31655: NOT
31656: IFFALSE 31668
// result := false else
31658: LD_ADDR_VAR 0 2
31662: PUSH
31663: LD_INT 0
31665: ST_TO_ADDR
31666: GO 31731
// for i = 1 to filter do
31668: LD_ADDR_VAR 0 3
31672: PUSH
31673: DOUBLE
31674: LD_INT 1
31676: DEC
31677: ST_TO_ADDR
31678: LD_VAR 0 4
31682: PUSH
31683: FOR_TO
31684: IFFALSE 31729
// if IsDriver ( filter [ i ] ) = veh then
31686: LD_VAR 0 4
31690: PUSH
31691: LD_VAR 0 3
31695: ARRAY
31696: PPUSH
31697: CALL 31504 0 1
31701: PUSH
31702: LD_VAR 0 1
31706: EQUAL
31707: IFFALSE 31727
// begin result := filter [ i ] ;
31709: LD_ADDR_VAR 0 2
31713: PUSH
31714: LD_VAR 0 4
31718: PUSH
31719: LD_VAR 0 3
31723: ARRAY
31724: ST_TO_ADDR
// break ;
31725: GO 31729
// end ;
31727: GO 31683
31729: POP
31730: POP
// end ; end ;
31731: LD_VAR 0 2
31735: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31736: LD_INT 0
31738: PPUSH
31739: PPUSH
// if BuildingStatus ( b ) = bs_build then
31740: LD_VAR 0 2
31744: PPUSH
31745: CALL_OW 461
31749: PUSH
31750: LD_INT 1
31752: EQUAL
31753: IFFALSE 31813
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31755: LD_VAR 0 1
31759: PPUSH
31760: LD_STRING h
31762: PUSH
31763: LD_VAR 0 2
31767: PPUSH
31768: CALL_OW 250
31772: PUSH
31773: LD_VAR 0 2
31777: PPUSH
31778: CALL_OW 251
31782: PUSH
31783: LD_VAR 0 2
31787: PUSH
31788: LD_INT 0
31790: PUSH
31791: LD_INT 0
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: PUSH
31806: EMPTY
31807: LIST
31808: PPUSH
31809: CALL_OW 446
// end ;
31813: LD_VAR 0 3
31817: RET
// export function Compare ( val1 , val2 ) ; begin
31818: LD_INT 0
31820: PPUSH
// if val1 = val2 then
31821: LD_VAR 0 1
31825: PUSH
31826: LD_VAR 0 2
31830: EQUAL
31831: IFFALSE 31843
// result := true else
31833: LD_ADDR_VAR 0 3
31837: PUSH
31838: LD_INT 1
31840: ST_TO_ADDR
31841: GO 31851
// result := false ;
31843: LD_ADDR_VAR 0 3
31847: PUSH
31848: LD_INT 0
31850: ST_TO_ADDR
// end ;
31851: LD_VAR 0 3
31855: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31856: LD_INT 0
31858: PPUSH
31859: PPUSH
// result := true ;
31860: LD_ADDR_VAR 0 3
31864: PUSH
31865: LD_INT 1
31867: ST_TO_ADDR
// if array1 = array2 then
31868: LD_VAR 0 1
31872: PUSH
31873: LD_VAR 0 2
31877: EQUAL
31878: IFFALSE 31943
// begin for i = 1 to array1 do
31880: LD_ADDR_VAR 0 4
31884: PUSH
31885: DOUBLE
31886: LD_INT 1
31888: DEC
31889: ST_TO_ADDR
31890: LD_VAR 0 1
31894: PUSH
31895: FOR_TO
31896: IFFALSE 31939
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31898: LD_VAR 0 1
31902: PUSH
31903: LD_VAR 0 4
31907: ARRAY
31908: PPUSH
31909: LD_VAR 0 2
31913: PUSH
31914: LD_VAR 0 4
31918: ARRAY
31919: PPUSH
31920: CALL 31818 0 2
31924: NOT
31925: IFFALSE 31937
// begin result := false ;
31927: LD_ADDR_VAR 0 3
31931: PUSH
31932: LD_INT 0
31934: ST_TO_ADDR
// break ;
31935: GO 31939
// end ;
31937: GO 31895
31939: POP
31940: POP
// end else
31941: GO 31951
// result := false ;
31943: LD_ADDR_VAR 0 3
31947: PUSH
31948: LD_INT 0
31950: ST_TO_ADDR
// end ;
31951: LD_VAR 0 3
31955: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31956: LD_INT 0
31958: PPUSH
31959: PPUSH
// result := false ;
31960: LD_ADDR_VAR 0 3
31964: PUSH
31965: LD_INT 0
31967: ST_TO_ADDR
// for j = 1 to e2 do
31968: LD_ADDR_VAR 0 4
31972: PUSH
31973: DOUBLE
31974: LD_INT 1
31976: DEC
31977: ST_TO_ADDR
31978: LD_VAR 0 2
31982: PUSH
31983: FOR_TO
31984: IFFALSE 32018
// if Compare ( e1 , e2 [ j ] ) then
31986: LD_VAR 0 1
31990: PPUSH
31991: LD_VAR 0 2
31995: PUSH
31996: LD_VAR 0 4
32000: ARRAY
32001: PPUSH
32002: CALL 31818 0 2
32006: IFFALSE 32016
// result := true ;
32008: LD_ADDR_VAR 0 3
32012: PUSH
32013: LD_INT 1
32015: ST_TO_ADDR
32016: GO 31983
32018: POP
32019: POP
// end ;
32020: LD_VAR 0 3
32024: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32025: LD_INT 0
32027: PPUSH
32028: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32029: LD_VAR 0 1
32033: PPUSH
32034: LD_STRING C
32036: PUSH
32037: LD_VAR 0 2
32041: PUSH
32042: LD_VAR 0 3
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: LD_INT 0
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: PUSH
32068: LD_STRING v
32070: PUSH
32071: LD_VAR 0 4
32075: PPUSH
32076: CALL_OW 250
32080: PUSH
32081: LD_VAR 0 4
32085: PPUSH
32086: CALL_OW 251
32090: PUSH
32091: LD_VAR 0 4
32095: PUSH
32096: LD_INT 0
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PPUSH
32118: CALL_OW 446
// end ;
32122: LD_VAR 0 5
32126: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32127: LD_INT 0
32129: PPUSH
32130: PPUSH
32131: PPUSH
// linked := UnitsLinked ( unit ) ;
32132: LD_ADDR_VAR 0 4
32136: PUSH
32137: LD_VAR 0 1
32141: PPUSH
32142: CALL_OW 432
32146: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32147: LD_ADDR_VAR 0 3
32151: PUSH
32152: LD_VAR 0 1
32156: PPUSH
32157: LD_INT 3
32159: PPUSH
32160: CALL_OW 259
32164: ST_TO_ADDR
// if sk > linked then
32165: LD_VAR 0 3
32169: PUSH
32170: LD_VAR 0 4
32174: GREATER
32175: IFFALSE 32187
// result := true else
32177: LD_ADDR_VAR 0 2
32181: PUSH
32182: LD_INT 1
32184: ST_TO_ADDR
32185: GO 32195
// result := false ;
32187: LD_ADDR_VAR 0 2
32191: PUSH
32192: LD_INT 0
32194: ST_TO_ADDR
// end ;
32195: LD_VAR 0 2
32199: RET
// export function NotTask ( unit ) ; begin
32200: LD_INT 0
32202: PPUSH
// result := true ;
32203: LD_ADDR_VAR 0 2
32207: PUSH
32208: LD_INT 1
32210: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32211: LD_VAR 0 1
32215: PPUSH
32216: CALL_OW 437
32220: PUSH
32221: LD_VAR 0 1
32225: PPUSH
32226: CALL_OW 314
32230: OR
32231: IFFALSE 32241
// result := false ;
32233: LD_ADDR_VAR 0 2
32237: PUSH
32238: LD_INT 0
32240: ST_TO_ADDR
// end ;
32241: LD_VAR 0 2
32245: RET
// export function WantHeal ( sci , unit ) ; begin
32246: LD_INT 0
32248: PPUSH
// if GetTaskList ( sci ) > 0 then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 437
32258: PUSH
32259: LD_INT 0
32261: GREATER
32262: IFFALSE 32332
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32264: LD_VAR 0 1
32268: PPUSH
32269: CALL_OW 437
32273: PUSH
32274: LD_INT 1
32276: ARRAY
32277: PUSH
32278: LD_INT 1
32280: ARRAY
32281: PUSH
32282: LD_STRING l
32284: EQUAL
32285: PUSH
32286: LD_VAR 0 1
32290: PPUSH
32291: CALL_OW 437
32295: PUSH
32296: LD_INT 1
32298: ARRAY
32299: PUSH
32300: LD_INT 4
32302: ARRAY
32303: PUSH
32304: LD_VAR 0 2
32308: EQUAL
32309: AND
32310: IFFALSE 32322
// result := true else
32312: LD_ADDR_VAR 0 3
32316: PUSH
32317: LD_INT 1
32319: ST_TO_ADDR
32320: GO 32330
// result := false ;
32322: LD_ADDR_VAR 0 3
32326: PUSH
32327: LD_INT 0
32329: ST_TO_ADDR
// end else
32330: GO 32340
// result := false ;
32332: LD_ADDR_VAR 0 3
32336: PUSH
32337: LD_INT 0
32339: ST_TO_ADDR
// end ;
32340: LD_VAR 0 3
32344: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32345: LD_INT 0
32347: PPUSH
32348: PPUSH
32349: PPUSH
32350: PPUSH
32351: PPUSH
// dist := 99999 ;
32352: LD_ADDR_VAR 0 7
32356: PUSH
32357: LD_INT 99999
32359: ST_TO_ADDR
// un := - 1 ;
32360: LD_ADDR_VAR 0 6
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: ST_TO_ADDR
// if units1 and units2 then
32369: LD_VAR 0 1
32373: PUSH
32374: LD_VAR 0 2
32378: AND
32379: IFFALSE 32467
// for i in units1 do
32381: LD_ADDR_VAR 0 4
32385: PUSH
32386: LD_VAR 0 1
32390: PUSH
32391: FOR_IN
32392: IFFALSE 32465
// for j in units2 do
32394: LD_ADDR_VAR 0 5
32398: PUSH
32399: LD_VAR 0 2
32403: PUSH
32404: FOR_IN
32405: IFFALSE 32461
// if GetDistUnits ( i , j ) < dist then
32407: LD_VAR 0 4
32411: PPUSH
32412: LD_VAR 0 5
32416: PPUSH
32417: CALL_OW 296
32421: PUSH
32422: LD_VAR 0 7
32426: LESS
32427: IFFALSE 32459
// begin un := i ;
32429: LD_ADDR_VAR 0 6
32433: PUSH
32434: LD_VAR 0 4
32438: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32439: LD_ADDR_VAR 0 7
32443: PUSH
32444: LD_VAR 0 4
32448: PPUSH
32449: LD_VAR 0 5
32453: PPUSH
32454: CALL_OW 296
32458: ST_TO_ADDR
// end ;
32459: GO 32404
32461: POP
32462: POP
32463: GO 32391
32465: POP
32466: POP
// result := [ un , dist ] ;
32467: LD_ADDR_VAR 0 3
32471: PUSH
32472: LD_VAR 0 6
32476: PUSH
32477: LD_VAR 0 7
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: ST_TO_ADDR
// end ;
32486: LD_VAR 0 3
32490: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32491: LD_INT 0
32493: PPUSH
32494: PPUSH
32495: PPUSH
32496: PPUSH
32497: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32498: LD_VAR 0 1
32502: NOT
32503: PUSH
32504: LD_VAR 0 1
32508: PPUSH
32509: CALL_OW 256
32513: PUSH
32514: LD_INT 250
32516: LESS
32517: OR
32518: PUSH
32519: LD_VAR 0 1
32523: PPUSH
32524: CALL_OW 314
32528: PUSH
32529: LD_VAR 0 1
32533: PPUSH
32534: CALL_OW 261
32538: PUSH
32539: LD_INT 20
32541: GREATER
32542: AND
32543: OR
32544: IFFALSE 32548
// exit ;
32546: GO 32922
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32548: LD_VAR 0 1
32552: PPUSH
32553: CALL_OW 261
32557: PUSH
32558: LD_INT 20
32560: LESS
32561: PUSH
32562: LD_VAR 0 1
32566: PPUSH
32567: CALL_OW 110
32571: PUSH
32572: LD_INT 21
32574: EQUAL
32575: NOT
32576: AND
32577: IFFALSE 32613
// begin ComStop ( bulldozer ) ;
32579: LD_VAR 0 1
32583: PPUSH
32584: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32588: LD_VAR 0 1
32592: PPUSH
32593: LD_INT 21
32595: PPUSH
32596: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32600: LD_VAR 0 1
32604: PPUSH
32605: CALL 26091 0 1
// exit ;
32609: GO 32922
// end else
32611: GO 32640
// if GetFuel ( bulldozer ) > 20 then
32613: LD_VAR 0 1
32617: PPUSH
32618: CALL_OW 261
32622: PUSH
32623: LD_INT 20
32625: GREATER
32626: IFFALSE 32640
// SetTag ( bulldozer , 0 ) ;
32628: LD_VAR 0 1
32632: PPUSH
32633: LD_INT 0
32635: PPUSH
32636: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32640: LD_ADDR_VAR 0 5
32644: PUSH
32645: LD_VAR 0 2
32649: PPUSH
32650: CALL_OW 353
32654: ST_TO_ADDR
// tmp := [ ] ;
32655: LD_ADDR_VAR 0 6
32659: PUSH
32660: EMPTY
32661: ST_TO_ADDR
// for i = 1 to list do
32662: LD_ADDR_VAR 0 4
32666: PUSH
32667: DOUBLE
32668: LD_INT 1
32670: DEC
32671: ST_TO_ADDR
32672: LD_VAR 0 5
32676: PUSH
32677: FOR_TO
32678: IFFALSE 32776
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32680: LD_VAR 0 5
32684: PUSH
32685: LD_VAR 0 4
32689: ARRAY
32690: PUSH
32691: LD_INT 1
32693: ARRAY
32694: PPUSH
32695: LD_VAR 0 5
32699: PUSH
32700: LD_VAR 0 4
32704: ARRAY
32705: PUSH
32706: LD_INT 2
32708: ARRAY
32709: PPUSH
32710: CALL_OW 554
32714: IFFALSE 32774
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32716: LD_ADDR_VAR 0 6
32720: PUSH
32721: LD_VAR 0 6
32725: PPUSH
32726: LD_VAR 0 6
32730: PUSH
32731: LD_INT 1
32733: PLUS
32734: PPUSH
32735: LD_VAR 0 5
32739: PUSH
32740: LD_VAR 0 4
32744: ARRAY
32745: PUSH
32746: LD_INT 1
32748: ARRAY
32749: PUSH
32750: LD_VAR 0 5
32754: PUSH
32755: LD_VAR 0 4
32759: ARRAY
32760: PUSH
32761: LD_INT 2
32763: ARRAY
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PPUSH
32769: CALL_OW 1
32773: ST_TO_ADDR
// end ;
32774: GO 32677
32776: POP
32777: POP
// ComStop ( bulldozer ) ;
32778: LD_VAR 0 1
32782: PPUSH
32783: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32787: LD_ADDR_VAR 0 7
32791: PUSH
32792: LD_VAR 0 1
32796: PPUSH
32797: CALL_OW 250
32801: PUSH
32802: LD_VAR 0 1
32806: PPUSH
32807: CALL_OW 251
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: ST_TO_ADDR
// for i = tmp downto 1 do
32816: LD_ADDR_VAR 0 4
32820: PUSH
32821: DOUBLE
32822: LD_VAR 0 6
32826: INC
32827: ST_TO_ADDR
32828: LD_INT 1
32830: PUSH
32831: FOR_DOWNTO
32832: IFFALSE 32920
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32834: LD_ADDR_VAR 0 7
32838: PUSH
32839: LD_VAR 0 7
32843: PUSH
32844: LD_INT 1
32846: ARRAY
32847: PPUSH
32848: LD_VAR 0 7
32852: PUSH
32853: LD_INT 2
32855: ARRAY
32856: PPUSH
32857: LD_VAR 0 6
32861: PPUSH
32862: CALL 33023 0 3
32866: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32867: LD_VAR 0 1
32871: PPUSH
32872: LD_VAR 0 7
32876: PUSH
32877: LD_INT 1
32879: ARRAY
32880: PPUSH
32881: LD_VAR 0 7
32885: PUSH
32886: LD_INT 2
32888: ARRAY
32889: PPUSH
32890: CALL 32927 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32894: LD_ADDR_VAR 0 6
32898: PUSH
32899: LD_VAR 0 6
32903: PPUSH
32904: LD_VAR 0 7
32908: PUSH
32909: LD_INT 3
32911: ARRAY
32912: PPUSH
32913: CALL_OW 3
32917: ST_TO_ADDR
// end ;
32918: GO 32831
32920: POP
32921: POP
// end ;
32922: LD_VAR 0 3
32926: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32927: LD_INT 0
32929: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32930: LD_VAR 0 2
32934: PPUSH
32935: LD_VAR 0 3
32939: PPUSH
32940: CALL_OW 351
32944: PUSH
32945: LD_VAR 0 2
32949: PPUSH
32950: LD_VAR 0 3
32954: PPUSH
32955: CALL_OW 554
32959: AND
32960: PUSH
32961: LD_VAR 0 2
32965: PPUSH
32966: LD_VAR 0 3
32970: PPUSH
32971: CALL_OW 488
32975: AND
32976: PUSH
32977: LD_VAR 0 2
32981: PPUSH
32982: LD_VAR 0 3
32986: PPUSH
32987: CALL_OW 428
32991: PUSH
32992: LD_INT 1
32994: NEG
32995: EQUAL
32996: AND
32997: IFFALSE 33018
// AddComMoveXY ( bulldozer , x , y ) ;
32999: LD_VAR 0 1
33003: PPUSH
33004: LD_VAR 0 2
33008: PPUSH
33009: LD_VAR 0 3
33013: PPUSH
33014: CALL_OW 171
// end ;
33018: LD_VAR 0 4
33022: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33023: LD_INT 0
33025: PPUSH
33026: PPUSH
33027: PPUSH
33028: PPUSH
33029: PPUSH
33030: PPUSH
33031: PPUSH
// dist := 99999 ;
33032: LD_ADDR_VAR 0 6
33036: PUSH
33037: LD_INT 99999
33039: ST_TO_ADDR
// for i = 1 to list do
33040: LD_ADDR_VAR 0 5
33044: PUSH
33045: DOUBLE
33046: LD_INT 1
33048: DEC
33049: ST_TO_ADDR
33050: LD_VAR 0 3
33054: PUSH
33055: FOR_TO
33056: IFFALSE 33194
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33058: LD_ADDR_VAR 0 7
33062: PUSH
33063: LD_VAR 0 1
33067: PPUSH
33068: LD_VAR 0 2
33072: PPUSH
33073: LD_VAR 0 3
33077: PUSH
33078: LD_VAR 0 5
33082: ARRAY
33083: PUSH
33084: LD_INT 1
33086: ARRAY
33087: PPUSH
33088: LD_VAR 0 3
33092: PUSH
33093: LD_VAR 0 5
33097: ARRAY
33098: PUSH
33099: LD_INT 2
33101: ARRAY
33102: PPUSH
33103: CALL_OW 298
33107: ST_TO_ADDR
// if d = 0 then
33108: LD_VAR 0 7
33112: PUSH
33113: LD_INT 0
33115: EQUAL
33116: IFFALSE 33120
// continue ;
33118: GO 33055
// if d < dist then
33120: LD_VAR 0 7
33124: PUSH
33125: LD_VAR 0 6
33129: LESS
33130: IFFALSE 33192
// begin _x := list [ i ] [ 1 ] ;
33132: LD_ADDR_VAR 0 8
33136: PUSH
33137: LD_VAR 0 3
33141: PUSH
33142: LD_VAR 0 5
33146: ARRAY
33147: PUSH
33148: LD_INT 1
33150: ARRAY
33151: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33152: LD_ADDR_VAR 0 9
33156: PUSH
33157: LD_VAR 0 3
33161: PUSH
33162: LD_VAR 0 5
33166: ARRAY
33167: PUSH
33168: LD_INT 2
33170: ARRAY
33171: ST_TO_ADDR
// _i := i ;
33172: LD_ADDR_VAR 0 10
33176: PUSH
33177: LD_VAR 0 5
33181: ST_TO_ADDR
// dist := d ;
33182: LD_ADDR_VAR 0 6
33186: PUSH
33187: LD_VAR 0 7
33191: ST_TO_ADDR
// end ; end ;
33192: GO 33055
33194: POP
33195: POP
// result := [ _x , _y , _i , dist ] ;
33196: LD_ADDR_VAR 0 4
33200: PUSH
33201: LD_VAR 0 8
33205: PUSH
33206: LD_VAR 0 9
33210: PUSH
33211: LD_VAR 0 10
33215: PUSH
33216: LD_VAR 0 6
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: ST_TO_ADDR
// end ;
33227: LD_VAR 0 4
33231: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33232: LD_INT 0
33234: PPUSH
33235: PPUSH
33236: PPUSH
33237: PPUSH
33238: PPUSH
// for i = 1 to list do
33239: LD_ADDR_VAR 0 5
33243: PUSH
33244: DOUBLE
33245: LD_INT 1
33247: DEC
33248: ST_TO_ADDR
33249: LD_VAR 0 1
33253: PUSH
33254: FOR_TO
33255: IFFALSE 33569
// begin for j = list downto 2 do
33257: LD_ADDR_VAR 0 6
33261: PUSH
33262: DOUBLE
33263: LD_VAR 0 1
33267: INC
33268: ST_TO_ADDR
33269: LD_INT 2
33271: PUSH
33272: FOR_DOWNTO
33273: IFFALSE 33565
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33275: LD_VAR 0 2
33279: PPUSH
33280: LD_VAR 0 3
33284: PPUSH
33285: LD_VAR 0 1
33289: PUSH
33290: LD_VAR 0 6
33294: ARRAY
33295: PUSH
33296: LD_INT 1
33298: ARRAY
33299: PPUSH
33300: LD_VAR 0 1
33304: PUSH
33305: LD_VAR 0 6
33309: ARRAY
33310: PUSH
33311: LD_INT 2
33313: ARRAY
33314: PPUSH
33315: CALL_OW 298
33319: PUSH
33320: LD_VAR 0 2
33324: PPUSH
33325: LD_VAR 0 3
33329: PPUSH
33330: LD_VAR 0 1
33334: PUSH
33335: LD_VAR 0 6
33339: PUSH
33340: LD_INT 1
33342: MINUS
33343: ARRAY
33344: PUSH
33345: LD_INT 1
33347: ARRAY
33348: PPUSH
33349: LD_VAR 0 1
33353: PUSH
33354: LD_VAR 0 6
33358: PUSH
33359: LD_INT 1
33361: MINUS
33362: ARRAY
33363: PUSH
33364: LD_INT 2
33366: ARRAY
33367: PPUSH
33368: CALL_OW 298
33372: LESS
33373: IFFALSE 33563
// begin _x := list [ j ] [ 1 ] ;
33375: LD_ADDR_VAR 0 7
33379: PUSH
33380: LD_VAR 0 1
33384: PUSH
33385: LD_VAR 0 6
33389: ARRAY
33390: PUSH
33391: LD_INT 1
33393: ARRAY
33394: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33395: LD_ADDR_VAR 0 8
33399: PUSH
33400: LD_VAR 0 1
33404: PUSH
33405: LD_VAR 0 6
33409: ARRAY
33410: PUSH
33411: LD_INT 2
33413: ARRAY
33414: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33415: LD_ADDR_VAR 0 1
33419: PUSH
33420: LD_VAR 0 1
33424: PPUSH
33425: LD_VAR 0 6
33429: PPUSH
33430: LD_INT 1
33432: PPUSH
33433: LD_VAR 0 1
33437: PUSH
33438: LD_VAR 0 6
33442: PUSH
33443: LD_INT 1
33445: MINUS
33446: ARRAY
33447: PUSH
33448: LD_INT 1
33450: ARRAY
33451: PPUSH
33452: CALL 30861 0 4
33456: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33457: LD_ADDR_VAR 0 1
33461: PUSH
33462: LD_VAR 0 1
33466: PPUSH
33467: LD_VAR 0 6
33471: PPUSH
33472: LD_INT 2
33474: PPUSH
33475: LD_VAR 0 1
33479: PUSH
33480: LD_VAR 0 6
33484: PUSH
33485: LD_INT 1
33487: MINUS
33488: ARRAY
33489: PUSH
33490: LD_INT 2
33492: ARRAY
33493: PPUSH
33494: CALL 30861 0 4
33498: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33499: LD_ADDR_VAR 0 1
33503: PUSH
33504: LD_VAR 0 1
33508: PPUSH
33509: LD_VAR 0 6
33513: PUSH
33514: LD_INT 1
33516: MINUS
33517: PPUSH
33518: LD_INT 1
33520: PPUSH
33521: LD_VAR 0 7
33525: PPUSH
33526: CALL 30861 0 4
33530: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33531: LD_ADDR_VAR 0 1
33535: PUSH
33536: LD_VAR 0 1
33540: PPUSH
33541: LD_VAR 0 6
33545: PUSH
33546: LD_INT 1
33548: MINUS
33549: PPUSH
33550: LD_INT 2
33552: PPUSH
33553: LD_VAR 0 8
33557: PPUSH
33558: CALL 30861 0 4
33562: ST_TO_ADDR
// end ; end ;
33563: GO 33272
33565: POP
33566: POP
// end ;
33567: GO 33254
33569: POP
33570: POP
// result := list ;
33571: LD_ADDR_VAR 0 4
33575: PUSH
33576: LD_VAR 0 1
33580: ST_TO_ADDR
// end ;
33581: LD_VAR 0 4
33585: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33586: LD_INT 0
33588: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33589: LD_ADDR_VAR 0 5
33593: PUSH
33594: LD_VAR 0 1
33598: PPUSH
33599: LD_VAR 0 2
33603: PPUSH
33604: CALL_OW 546
33608: PUSH
33609: LD_INT 2
33611: ARRAY
33612: PUSH
33613: LD_VAR 0 3
33617: PPUSH
33618: LD_VAR 0 4
33622: PPUSH
33623: CALL_OW 546
33627: PUSH
33628: LD_INT 2
33630: ARRAY
33631: MINUS
33632: ST_TO_ADDR
// if result < 0 then
33633: LD_VAR 0 5
33637: PUSH
33638: LD_INT 0
33640: LESS
33641: IFFALSE 33658
// result := result * - 1 ;
33643: LD_ADDR_VAR 0 5
33647: PUSH
33648: LD_VAR 0 5
33652: PUSH
33653: LD_INT 1
33655: NEG
33656: MUL
33657: ST_TO_ADDR
// end ;
33658: LD_VAR 0 5
33662: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33663: LD_INT 0
33665: PPUSH
33666: PPUSH
// area = ListEnvironmentArea ( area ) ;
33667: LD_ADDR_VAR 0 2
33671: PUSH
33672: LD_VAR 0 2
33676: PPUSH
33677: CALL_OW 353
33681: ST_TO_ADDR
// if bulldozer > 0 then
33682: LD_VAR 0 1
33686: PUSH
33687: LD_INT 0
33689: GREATER
33690: IFFALSE 33801
// for i = area downto 1 do
33692: LD_ADDR_VAR 0 4
33696: PUSH
33697: DOUBLE
33698: LD_VAR 0 2
33702: INC
33703: ST_TO_ADDR
33704: LD_INT 1
33706: PUSH
33707: FOR_DOWNTO
33708: IFFALSE 33799
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33710: LD_VAR 0 2
33714: PUSH
33715: LD_VAR 0 4
33719: ARRAY
33720: PUSH
33721: LD_INT 1
33723: ARRAY
33724: PPUSH
33725: LD_VAR 0 2
33729: PUSH
33730: LD_VAR 0 4
33734: ARRAY
33735: PUSH
33736: LD_INT 2
33738: ARRAY
33739: PPUSH
33740: CALL_OW 351
33744: IFFALSE 33797
// if not HasTask ( bulldozer ) then
33746: LD_VAR 0 1
33750: PPUSH
33751: CALL_OW 314
33755: NOT
33756: IFFALSE 33797
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33758: LD_VAR 0 1
33762: PPUSH
33763: LD_VAR 0 2
33767: PUSH
33768: LD_VAR 0 4
33772: ARRAY
33773: PUSH
33774: LD_INT 1
33776: ARRAY
33777: PPUSH
33778: LD_VAR 0 2
33782: PUSH
33783: LD_VAR 0 4
33787: ARRAY
33788: PUSH
33789: LD_INT 2
33791: ARRAY
33792: PPUSH
33793: CALL_OW 171
33797: GO 33707
33799: POP
33800: POP
// end ;
33801: LD_VAR 0 3
33805: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33806: LD_INT 0
33808: PPUSH
33809: PPUSH
33810: PPUSH
33811: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33812: LD_ADDR_VAR 0 6
33816: PUSH
33817: LD_INT 22
33819: PUSH
33820: LD_VAR 0 1
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 21
33831: PUSH
33832: LD_VAR 0 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PPUSH
33845: CALL_OW 69
33849: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33850: LD_ADDR_VAR 0 7
33854: PUSH
33855: LD_VAR 0 3
33859: PPUSH
33860: LD_INT 22
33862: PUSH
33863: LD_VAR 0 1
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 21
33874: PUSH
33875: LD_VAR 0 2
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PPUSH
33888: CALL_OW 70
33892: ST_TO_ADDR
// if tmp and pom then
33893: LD_VAR 0 6
33897: PUSH
33898: LD_VAR 0 7
33902: AND
33903: IFFALSE 33923
// result := tmp diff pom else
33905: LD_ADDR_VAR 0 4
33909: PUSH
33910: LD_VAR 0 6
33914: PUSH
33915: LD_VAR 0 7
33919: DIFF
33920: ST_TO_ADDR
33921: GO 33931
// result := false ;
33923: LD_ADDR_VAR 0 4
33927: PUSH
33928: LD_INT 0
33930: ST_TO_ADDR
// end ;
33931: LD_VAR 0 4
33935: RET
// export function SavePosition ( unit ) ; begin
33936: LD_INT 0
33938: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33939: LD_VAR 0 1
33943: PPUSH
33944: LD_VAR 0 1
33948: PPUSH
33949: CALL_OW 250
33953: PPUSH
33954: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33958: LD_VAR 0 1
33962: PPUSH
33963: LD_VAR 0 1
33967: PPUSH
33968: CALL_OW 251
33972: PPUSH
33973: CALL_OW 232
// end ;
33977: LD_VAR 0 2
33981: RET
// export function GetPosition ( unit ) ; begin
33982: LD_INT 0
33984: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33985: LD_ADDR_VAR 0 2
33989: PUSH
33990: LD_VAR 0 1
33994: PPUSH
33995: CALL_OW 252
33999: PUSH
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL_OW 253
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: ST_TO_ADDR
// end ;
34014: LD_VAR 0 2
34018: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34019: LD_INT 0
34021: PPUSH
// if unit in unreachableList then
34022: LD_VAR 0 1
34026: PUSH
34027: LD_EXP 30
34031: IN
34032: IFFALSE 34050
// unreachableList := unreachableList diff unit ;
34034: LD_ADDR_EXP 30
34038: PUSH
34039: LD_EXP 30
34043: PUSH
34044: LD_VAR 0 1
34048: DIFF
34049: ST_TO_ADDR
// if ValidHex ( x , y ) then
34050: LD_VAR 0 2
34054: PPUSH
34055: LD_VAR 0 3
34059: PPUSH
34060: CALL_OW 488
34064: IFFALSE 34090
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34066: LD_VAR 0 1
34070: PPUSH
34071: LD_VAR 0 2
34075: PPUSH
34076: LD_VAR 0 3
34080: PPUSH
34081: CALL_OW 428
34085: PPUSH
34086: CALL_OW 115
// Wait ( 3 ) ;
34090: LD_INT 3
34092: PPUSH
34093: CALL_OW 67
// if unit in unreachableList then
34097: LD_VAR 0 1
34101: PUSH
34102: LD_EXP 30
34106: IN
34107: IFFALSE 34119
// result := false else
34109: LD_ADDR_VAR 0 4
34113: PUSH
34114: LD_INT 0
34116: ST_TO_ADDR
34117: GO 34127
// result := true ;
34119: LD_ADDR_VAR 0 4
34123: PUSH
34124: LD_INT 1
34126: ST_TO_ADDR
// end ; end_of_file
34127: LD_VAR 0 4
34131: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34132: LD_EXP 31
34136: IFFALSE 34198
34138: GO 34140
34140: DISABLE
34141: LD_INT 0
34143: PPUSH
// begin enable ;
34144: ENABLE
// for i = 1 to mc_crates_list do
34145: LD_ADDR_VAR 0 1
34149: PUSH
34150: DOUBLE
34151: LD_INT 1
34153: DEC
34154: ST_TO_ADDR
34155: LD_EXP 32
34159: PUSH
34160: FOR_TO
34161: IFFALSE 34192
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34163: LD_EXP 32
34167: PUSH
34168: LD_VAR 0 1
34172: ARRAY
34173: PPUSH
34174: LD_INT 5
34176: PPUSH
34177: LD_INT 50
34179: PPUSH
34180: LD_INT 700
34182: PPUSH
34183: LD_INT 20
34185: PPUSH
34186: CALL 24273 0 5
34190: GO 34160
34192: POP
34193: POP
// MC_Game ( ) ;
34194: CALL 34201 0 0
// end ;
34198: PPOPN 1
34200: END
// export function MC_Game ( ) ; var i , side , un ; begin
34201: LD_INT 0
34203: PPUSH
34204: PPUSH
34205: PPUSH
34206: PPUSH
// if not isTest then
34207: LD_EXP 1
34211: NOT
34212: IFFALSE 34232
// MC_Show ( [ #tick , tick ] ) else
34214: LD_STRING #tick
34216: PUSH
34217: LD_OWVAR 1
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PPUSH
34226: CALL 8311 0 1
34230: GO 34241
// MC_Show ( debug_string ) ;
34232: LD_EXP 2
34236: PPUSH
34237: CALL 8311 0 1
// for side = 1 to 8 do
34241: LD_ADDR_VAR 0 3
34245: PUSH
34246: DOUBLE
34247: LD_INT 1
34249: DEC
34250: ST_TO_ADDR
34251: LD_INT 8
34253: PUSH
34254: FOR_TO
34255: IFFALSE 36255
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34257: LD_EXP 39
34261: PUSH
34262: LD_VAR 0 3
34266: ARRAY
34267: PUSH
34268: LD_INT 0
34270: EQUAL
34271: PUSH
34272: LD_VAR 0 3
34276: PPUSH
34277: EMPTY
34278: PPUSH
34279: CALL 11528 0 2
34283: PUSH
34284: LD_INT 0
34286: EQUAL
34287: OR
34288: IFFALSE 34292
// continue ;
34290: GO 34254
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34292: LD_VAR 0 3
34296: PPUSH
34297: LD_VAR 0 3
34301: PPUSH
34302: CALL 24794 0 1
34306: PPUSH
34307: CALL 36262 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34311: LD_EXP 71
34315: PUSH
34316: LD_VAR 0 3
34320: ARRAY
34321: PUSH
34322: LD_INT 1
34324: ARRAY
34325: PUSH
34326: LD_INT 0
34328: GREATER
34329: PUSH
34330: LD_EXP 69
34334: PUSH
34335: LD_VAR 0 3
34339: ARRAY
34340: PUSH
34341: LD_INT 1
34343: ARRAY
34344: PUSH
34345: LD_INT 0
34347: EQUAL
34348: AND
34349: PUSH
34350: LD_VAR 0 3
34354: PPUSH
34355: LD_INT 7
34357: PPUSH
34358: EMPTY
34359: PPUSH
34360: CALL 12096 0 3
34364: NOT
34365: AND
34366: IFFALSE 34437
// begin if side = 1 then
34368: LD_VAR 0 3
34372: PUSH
34373: LD_INT 1
34375: EQUAL
34376: IFFALSE 34385
// RaiseSailEvent ( 101 ) ;
34378: LD_INT 101
34380: PPUSH
34381: CALL_OW 427
// if side = 4 then
34385: LD_VAR 0 3
34389: PUSH
34390: LD_INT 4
34392: EQUAL
34393: IFFALSE 34402
// RaiseSailEvent ( 102 ) ;
34395: LD_INT 102
34397: PPUSH
34398: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34402: LD_ADDR_VAR 0 2
34406: PUSH
34407: LD_EXP 71
34411: PUSH
34412: LD_VAR 0 3
34416: ARRAY
34417: PUSH
34418: FOR_IN
34419: IFFALSE 34435
// SetTag ( i , 7 ) ;
34421: LD_VAR 0 2
34425: PPUSH
34426: LD_INT 7
34428: PPUSH
34429: CALL_OW 109
34433: GO 34418
34435: POP
34436: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34437: LD_VAR 0 3
34441: PPUSH
34442: LD_INT 7
34444: PPUSH
34445: EMPTY
34446: PPUSH
34447: CALL 12096 0 3
34451: IFFALSE 34477
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34453: LD_VAR 0 3
34457: PPUSH
34458: LD_VAR 0 3
34462: PPUSH
34463: LD_INT 7
34465: PPUSH
34466: EMPTY
34467: PPUSH
34468: CALL 12096 0 3
34472: PPUSH
34473: CALL 8238 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34477: LD_VAR 0 3
34481: PPUSH
34482: CALL 17776 0 1
34486: PUSH
34487: LD_VAR 0 3
34491: PPUSH
34492: CALL 11432 0 1
34496: AND
34497: IFFALSE 34508
// MCL_Start ( side ) ;
34499: LD_VAR 0 3
34503: PPUSH
34504: CALL 17733 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34508: LD_ADDR_EXP 35
34512: PUSH
34513: LD_EXP 35
34517: PPUSH
34518: LD_VAR 0 3
34522: PPUSH
34523: LD_VAR 0 3
34527: PPUSH
34528: CALL 19033 0 1
34532: PPUSH
34533: CALL_OW 1
34537: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34538: LD_ADDR_EXP 47
34542: PUSH
34543: LD_EXP 47
34547: PPUSH
34548: LD_VAR 0 3
34552: PPUSH
34553: LD_VAR 0 3
34557: PPUSH
34558: CALL 10846 0 1
34562: PPUSH
34563: CALL_OW 1
34567: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34568: LD_VAR 0 3
34572: PPUSH
34573: LD_INT 21
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PPUSH
34583: CALL 11393 0 2
34587: IFFALSE 34598
// MCV_CheckStatus ( side ) ;
34589: LD_VAR 0 3
34593: PPUSH
34594: CALL 27003 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34598: LD_VAR 0 3
34602: PPUSH
34603: LD_EXP 53
34607: PPUSH
34608: CALL 43182 0 2
34612: IFFALSE 34697
// begin for i = MREG_ToChangeClass downto 1 do
34614: LD_ADDR_VAR 0 2
34618: PUSH
34619: DOUBLE
34620: LD_EXP 53
34624: INC
34625: ST_TO_ADDR
34626: LD_INT 1
34628: PUSH
34629: FOR_DOWNTO
34630: IFFALSE 34695
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34632: LD_EXP 53
34636: PUSH
34637: LD_VAR 0 2
34641: ARRAY
34642: PUSH
34643: LD_INT 1
34645: ARRAY
34646: PUSH
34647: LD_VAR 0 3
34651: EQUAL
34652: IFFALSE 34693
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34654: LD_VAR 0 3
34658: PPUSH
34659: LD_EXP 53
34663: PUSH
34664: LD_VAR 0 2
34668: ARRAY
34669: PUSH
34670: LD_INT 2
34672: ARRAY
34673: PPUSH
34674: LD_EXP 53
34678: PUSH
34679: LD_VAR 0 2
34683: ARRAY
34684: PUSH
34685: LD_INT 3
34687: ARRAY
34688: PPUSH
34689: CALL 16300 0 3
// end ; end ;
34693: GO 34629
34695: POP
34696: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34697: LD_INT 1
34699: PUSH
34700: LD_EXP 38
34704: PUSH
34705: LD_VAR 0 3
34709: ARRAY
34710: IN
34711: IFFALSE 34722
// begin MCN_TrainApe ( side ) ;
34713: LD_VAR 0 3
34717: PPUSH
34718: CALL 18686 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34722: LD_VAR 0 3
34726: PPUSH
34727: LD_INT 30
34729: PUSH
34730: LD_INT 3
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PPUSH
34737: CALL 11393 0 2
34741: IFFALSE 34915
// begin if MCF_Tag ( side , 10 , [ ] ) then
34743: LD_VAR 0 3
34747: PPUSH
34748: LD_INT 10
34750: PPUSH
34751: EMPTY
34752: PPUSH
34753: CALL 12096 0 3
34757: IFFALSE 34804
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34759: LD_VAR 0 3
34763: PPUSH
34764: LD_INT 10
34766: PPUSH
34767: EMPTY
34768: PPUSH
34769: CALL 12096 0 3
34773: PPUSH
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11393 0 2
34793: PUSH
34794: LD_INT 1
34796: ARRAY
34797: PPUSH
34798: CALL_OW 168
// end else
34802: GO 34915
// if MREG_ToConstruct [ side ] then
34804: LD_EXP 51
34808: PUSH
34809: LD_VAR 0 3
34813: ARRAY
34814: IFFALSE 34915
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34816: LD_VAR 0 3
34820: PPUSH
34821: LD_VAR 0 3
34825: PPUSH
34826: LD_INT 30
34828: PUSH
34829: LD_INT 3
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PPUSH
34836: CALL 11393 0 2
34840: PUSH
34841: LD_INT 1
34843: ARRAY
34844: PPUSH
34845: LD_EXP 51
34849: PUSH
34850: LD_VAR 0 3
34854: ARRAY
34855: PUSH
34856: LD_INT 1
34858: ARRAY
34859: PUSH
34860: LD_EXP 51
34864: PUSH
34865: LD_VAR 0 3
34869: ARRAY
34870: PUSH
34871: LD_INT 2
34873: ARRAY
34874: PUSH
34875: LD_EXP 51
34879: PUSH
34880: LD_VAR 0 3
34884: ARRAY
34885: PUSH
34886: LD_INT 3
34888: ARRAY
34889: PUSH
34890: LD_EXP 51
34894: PUSH
34895: LD_VAR 0 3
34899: ARRAY
34900: PUSH
34901: LD_INT 4
34903: ARRAY
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: PPUSH
34911: CALL 25297 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34915: LD_VAR 0 3
34919: PPUSH
34920: LD_INT 30
34922: PUSH
34923: LD_INT 3
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PPUSH
34930: CALL 11393 0 2
34934: PUSH
34935: LD_VAR 0 3
34939: PPUSH
34940: LD_EXP 43
34944: PPUSH
34945: CALL 43182 0 2
34949: AND
34950: PUSH
34951: LD_INT 22
34953: PUSH
34954: LD_VAR 0 3
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 2
34965: PUSH
34966: LD_INT 30
34968: PUSH
34969: LD_INT 33
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 30
34978: PUSH
34979: LD_INT 32
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 35
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: LIST
35005: PPUSH
35006: CALL_OW 69
35010: AND
35011: IFFALSE 35022
// MCV_Turret ( side ) ;
35013: LD_VAR 0 3
35017: PPUSH
35018: CALL 25746 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35022: LD_EXP 42
35026: PUSH
35027: LD_VAR 0 3
35031: ARRAY
35032: PUSH
35033: LD_INT 1
35035: GREATER
35036: PUSH
35037: LD_VAR 0 3
35041: PPUSH
35042: CALL 24794 0 1
35046: PUSH
35047: LD_INT 0
35049: EQUAL
35050: AND
35051: IFFALSE 35213
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35053: LD_EXP 42
35057: PUSH
35058: LD_VAR 0 3
35062: ARRAY
35063: PUSH
35064: LD_INT 1
35066: ARRAY
35067: PPUSH
35068: CALL_OW 353
35072: IFFALSE 35110
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35074: LD_EXP 42
35078: PUSH
35079: LD_VAR 0 3
35083: ARRAY
35084: PUSH
35085: LD_INT 2
35087: ARRAY
35088: PPUSH
35089: LD_EXP 42
35093: PUSH
35094: LD_VAR 0 3
35098: ARRAY
35099: PUSH
35100: LD_INT 1
35102: ARRAY
35103: PPUSH
35104: CALL 32491 0 2
35108: GO 35213
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35110: LD_VAR 0 3
35114: PPUSH
35115: LD_INT 30
35117: PUSH
35118: LD_INT 3
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PPUSH
35125: CALL 11393 0 2
35129: IFFALSE 35213
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35131: LD_VAR 0 3
35135: PPUSH
35136: LD_INT 30
35138: PUSH
35139: LD_INT 3
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PPUSH
35146: CALL 11393 0 2
35150: PUSH
35151: LD_INT 1
35153: ARRAY
35154: PPUSH
35155: CALL_OW 461
35159: PUSH
35160: LD_INT 2
35162: EQUAL
35163: IFFALSE 35213
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35165: LD_EXP 42
35169: PUSH
35170: LD_VAR 0 3
35174: ARRAY
35175: PUSH
35176: LD_INT 2
35178: ARRAY
35179: PPUSH
35180: LD_INT 10
35182: PPUSH
35183: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35187: LD_ADDR_EXP 42
35191: PUSH
35192: LD_EXP 42
35196: PPUSH
35197: LD_VAR 0 3
35201: PPUSH
35202: LD_INT 0
35204: PUSH
35205: EMPTY
35206: LIST
35207: PPUSH
35208: CALL_OW 1
35212: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35213: LD_VAR 0 3
35217: PPUSH
35218: LD_INT 33
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PPUSH
35228: CALL 11393 0 2
35232: IFFALSE 35272
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_VAR 0 3
35243: PPUSH
35244: LD_INT 33
35246: PUSH
35247: LD_INT 2
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PPUSH
35254: CALL 11393 0 2
35258: PUSH
35259: LD_INT 1
35261: ARRAY
35262: PPUSH
35263: CALL_OW 248
35267: PPUSH
35268: CALL 26300 0 2
// if MREG_ToRepair [ side ] then
35272: LD_EXP 47
35276: PUSH
35277: LD_VAR 0 3
35281: ARRAY
35282: IFFALSE 35295
// begin MCB_Repair ( side ) ;
35284: LD_VAR 0 3
35288: PPUSH
35289: CALL 11133 0 1
// end else
35293: GO 36208
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35295: LD_VAR 0 3
35299: PPUSH
35300: LD_EXP 49
35304: PPUSH
35305: CALL 43182 0 2
35309: PUSH
35310: LD_VAR 0 3
35314: PPUSH
35315: LD_EXP 40
35319: PPUSH
35320: CALL 43182 0 2
35324: AND
35325: IFFALSE 35533
// begin for i = 1 to MREG_ToUpLab do
35327: LD_ADDR_VAR 0 2
35331: PUSH
35332: DOUBLE
35333: LD_INT 1
35335: DEC
35336: ST_TO_ADDR
35337: LD_EXP 49
35341: PUSH
35342: FOR_TO
35343: IFFALSE 35529
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35345: LD_EXP 49
35349: PUSH
35350: LD_VAR 0 2
35354: ARRAY
35355: PUSH
35356: LD_INT 1
35358: ARRAY
35359: PUSH
35360: LD_VAR 0 3
35364: EQUAL
35365: IFFALSE 35527
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35367: LD_EXP 49
35371: PUSH
35372: LD_VAR 0 2
35376: ARRAY
35377: PUSH
35378: LD_INT 2
35380: ARRAY
35381: PUSH
35382: LD_EXP 49
35386: PUSH
35387: LD_VAR 0 2
35391: ARRAY
35392: PUSH
35393: LD_INT 3
35395: ARRAY
35396: AND
35397: IFFALSE 35525
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35399: LD_VAR 0 3
35403: PPUSH
35404: LD_EXP 49
35408: PUSH
35409: LD_VAR 0 2
35413: ARRAY
35414: PUSH
35415: LD_INT 2
35417: ARRAY
35418: PPUSH
35419: LD_EXP 49
35423: PUSH
35424: LD_VAR 0 2
35428: ARRAY
35429: PUSH
35430: LD_INT 3
35432: ARRAY
35433: PPUSH
35434: CALL 8657 0 3
35438: IFFALSE 35525
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35440: LD_ADDR_EXP 49
35444: PUSH
35445: LD_EXP 49
35449: PPUSH
35450: LD_VAR 0 3
35454: PPUSH
35455: LD_EXP 49
35459: PUSH
35460: LD_VAR 0 2
35464: ARRAY
35465: PUSH
35466: LD_INT 2
35468: ARRAY
35469: PPUSH
35470: LD_EXP 49
35474: PUSH
35475: LD_VAR 0 2
35479: ARRAY
35480: PUSH
35481: LD_INT 3
35483: ARRAY
35484: PPUSH
35485: CALL 42234 0 4
35489: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35490: LD_ADDR_EXP 40
35494: PUSH
35495: LD_EXP 40
35499: PPUSH
35500: LD_VAR 0 3
35504: PPUSH
35505: LD_EXP 40
35509: PUSH
35510: LD_INT 1
35512: ARRAY
35513: PUSH
35514: LD_INT 2
35516: ARRAY
35517: PPUSH
35518: EMPTY
35519: PPUSH
35520: CALL 42234 0 4
35524: ST_TO_ADDR
// end ; break ;
35525: GO 35529
// end ;
35527: GO 35342
35529: POP
35530: POP
// end else
35531: GO 36208
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35533: LD_VAR 0 3
35537: PPUSH
35538: LD_EXP 48
35542: PPUSH
35543: CALL 43182 0 2
35547: IFFALSE 35621
// begin for i = 1 to MREG_ToUpdate do
35549: LD_ADDR_VAR 0 2
35553: PUSH
35554: DOUBLE
35555: LD_INT 1
35557: DEC
35558: ST_TO_ADDR
35559: LD_EXP 48
35563: PUSH
35564: FOR_TO
35565: IFFALSE 35617
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35567: LD_EXP 48
35571: PUSH
35572: LD_VAR 0 2
35576: ARRAY
35577: PUSH
35578: LD_INT 1
35580: ARRAY
35581: PUSH
35582: LD_VAR 0 3
35586: EQUAL
35587: IFFALSE 35615
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35589: LD_VAR 0 3
35593: PPUSH
35594: LD_EXP 48
35598: PUSH
35599: LD_VAR 0 2
35603: ARRAY
35604: PUSH
35605: LD_INT 2
35607: ARRAY
35608: PPUSH
35609: CALL 8493 0 2
// break ;
35613: GO 35617
// end ;
35615: GO 35564
35617: POP
35618: POP
// end else
35619: GO 36208
// if MCF_Get ( side , [ f_constructed ] ) then
35621: LD_VAR 0 3
35625: PPUSH
35626: LD_INT 57
35628: PUSH
35629: EMPTY
35630: LIST
35631: PPUSH
35632: CALL 11393 0 2
35636: IFFALSE 35669
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35638: LD_VAR 0 3
35642: PPUSH
35643: LD_VAR 0 3
35647: PPUSH
35648: LD_INT 57
35650: PUSH
35651: EMPTY
35652: LIST
35653: PPUSH
35654: CALL 11393 0 2
35658: PUSH
35659: LD_INT 1
35661: ARRAY
35662: PPUSH
35663: CALL 10737 0 2
35667: GO 36208
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35669: LD_VAR 0 3
35673: PPUSH
35674: LD_EXP 46
35678: PPUSH
35679: CALL 43182 0 2
35683: PUSH
35684: LD_VAR 0 3
35688: PPUSH
35689: CALL_OW 345
35693: NOT
35694: AND
35695: PUSH
35696: LD_VAR 0 3
35700: PPUSH
35701: CALL 24794 0 1
35705: PUSH
35706: LD_INT 0
35708: EQUAL
35709: AND
35710: IFFALSE 36109
// begin for i = 1 to MREG_ToBuild do
35712: LD_ADDR_VAR 0 2
35716: PUSH
35717: DOUBLE
35718: LD_INT 1
35720: DEC
35721: ST_TO_ADDR
35722: LD_EXP 46
35726: PUSH
35727: FOR_TO
35728: IFFALSE 36105
// if MREG_ToBuild [ i ] [ 1 ] = side then
35730: LD_EXP 46
35734: PUSH
35735: LD_VAR 0 2
35739: ARRAY
35740: PUSH
35741: LD_INT 1
35743: ARRAY
35744: PUSH
35745: LD_VAR 0 3
35749: EQUAL
35750: IFFALSE 36103
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35752: LD_OWVAR 84
35756: PUSH
35757: LD_EXP 46
35761: PUSH
35762: LD_VAR 0 2
35766: ARRAY
35767: PUSH
35768: LD_INT 3
35770: ARRAY
35771: PUSH
35772: LD_INT 1
35774: ARRAY
35775: PPUSH
35776: LD_EXP 46
35780: PUSH
35781: LD_VAR 0 2
35785: ARRAY
35786: PUSH
35787: LD_INT 3
35789: ARRAY
35790: PUSH
35791: LD_INT 2
35793: ARRAY
35794: PPUSH
35795: CALL_OW 351
35799: AND
35800: IFFALSE 35844
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35802: LD_EXP 46
35806: PUSH
35807: LD_VAR 0 2
35811: ARRAY
35812: PUSH
35813: LD_INT 3
35815: ARRAY
35816: PUSH
35817: LD_INT 1
35819: ARRAY
35820: PPUSH
35821: LD_EXP 46
35825: PUSH
35826: LD_VAR 0 2
35830: ARRAY
35831: PUSH
35832: LD_INT 3
35834: ARRAY
35835: PUSH
35836: LD_INT 2
35838: ARRAY
35839: PPUSH
35840: CALL 22541 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 2
35857: ARRAY
35858: PUSH
35859: LD_INT 0
35861: EQUAL
35862: IFFALSE 35932
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35864: LD_VAR 0 3
35868: PPUSH
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 3
35882: ARRAY
35883: PUSH
35884: LD_INT 1
35886: ARRAY
35887: PPUSH
35888: LD_EXP 46
35892: PUSH
35893: LD_VAR 0 2
35897: ARRAY
35898: PUSH
35899: LD_INT 3
35901: ARRAY
35902: PUSH
35903: LD_INT 2
35905: ARRAY
35906: PPUSH
35907: LD_EXP 46
35911: PUSH
35912: LD_VAR 0 2
35916: ARRAY
35917: PUSH
35918: LD_INT 3
35920: ARRAY
35921: PUSH
35922: LD_INT 3
35924: ARRAY
35925: PPUSH
35926: CALL 8329 0 4
35930: GO 36101
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 2
35945: ARRAY
35946: PUSH
35947: LD_INT 6
35949: EQUAL
35950: IFFALSE 36020
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35952: LD_VAR 0 3
35956: PPUSH
35957: LD_EXP 46
35961: PUSH
35962: LD_VAR 0 2
35966: ARRAY
35967: PUSH
35968: LD_INT 3
35970: ARRAY
35971: PUSH
35972: LD_INT 1
35974: ARRAY
35975: PPUSH
35976: LD_EXP 46
35980: PUSH
35981: LD_VAR 0 2
35985: ARRAY
35986: PUSH
35987: LD_INT 3
35989: ARRAY
35990: PUSH
35991: LD_INT 2
35993: ARRAY
35994: PPUSH
35995: LD_EXP 46
35999: PUSH
36000: LD_VAR 0 2
36004: ARRAY
36005: PUSH
36006: LD_INT 3
36008: ARRAY
36009: PUSH
36010: LD_INT 3
36012: ARRAY
36013: PPUSH
36014: CALL 8458 0 4
36018: GO 36101
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36020: LD_VAR 0 3
36024: PPUSH
36025: LD_EXP 46
36029: PUSH
36030: LD_VAR 0 2
36034: ARRAY
36035: PUSH
36036: LD_INT 2
36038: ARRAY
36039: PPUSH
36040: LD_EXP 46
36044: PUSH
36045: LD_VAR 0 2
36049: ARRAY
36050: PUSH
36051: LD_INT 3
36053: ARRAY
36054: PUSH
36055: LD_INT 1
36057: ARRAY
36058: PPUSH
36059: LD_EXP 46
36063: PUSH
36064: LD_VAR 0 2
36068: ARRAY
36069: PUSH
36070: LD_INT 3
36072: ARRAY
36073: PUSH
36074: LD_INT 2
36076: ARRAY
36077: PPUSH
36078: LD_EXP 46
36082: PUSH
36083: LD_VAR 0 2
36087: ARRAY
36088: PUSH
36089: LD_INT 3
36091: ARRAY
36092: PUSH
36093: LD_INT 3
36095: ARRAY
36096: PPUSH
36097: CALL 9962 0 5
// break ;
36101: GO 36105
// end ;
36103: GO 35727
36105: POP
36106: POP
// end else
36107: GO 36208
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36109: LD_VAR 0 3
36113: PPUSH
36114: LD_EXP 52
36118: PPUSH
36119: CALL 43182 0 2
36123: PUSH
36124: LD_VAR 0 3
36128: PPUSH
36129: CALL 24794 0 1
36133: PUSH
36134: LD_INT 0
36136: EQUAL
36137: AND
36138: IFFALSE 36208
// begin for i = 1 to MREG_ToDismantle do
36140: LD_ADDR_VAR 0 2
36144: PUSH
36145: DOUBLE
36146: LD_INT 1
36148: DEC
36149: ST_TO_ADDR
36150: LD_EXP 52
36154: PUSH
36155: FOR_TO
36156: IFFALSE 36206
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36158: LD_EXP 52
36162: PUSH
36163: LD_VAR 0 2
36167: ARRAY
36168: PUSH
36169: LD_INT 1
36171: ARRAY
36172: PUSH
36173: LD_VAR 0 3
36177: EQUAL
36178: IFFALSE 36204
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36180: LD_VAR 0 3
36184: PPUSH
36185: LD_EXP 52
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: PUSH
36196: LD_INT 2
36198: ARRAY
36199: PPUSH
36200: CALL 10628 0 2
// end ;
36204: GO 36155
36206: POP
36207: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36208: LD_VAR 0 3
36212: PPUSH
36213: LD_INT 30
36215: PUSH
36216: LD_INT 1
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PPUSH
36223: CALL 11393 0 2
36227: PUSH
36228: LD_VAR 0 3
36232: PPUSH
36233: CALL 24794 0 1
36237: PUSH
36238: LD_INT 0
36240: EQUAL
36241: AND
36242: IFFALSE 36253
// MCT_CollectCrates ( side ) ;
36244: LD_VAR 0 3
36248: PPUSH
36249: CALL 23733 0 1
// end ;
36253: GO 34254
36255: POP
36256: POP
// end ;
36257: LD_VAR 0 1
36261: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36262: LD_INT 0
36264: PPUSH
36265: PPUSH
36266: PPUSH
36267: PPUSH
36268: PPUSH
36269: PPUSH
36270: PPUSH
36271: PPUSH
36272: PPUSH
36273: PPUSH
36274: PPUSH
36275: PPUSH
36276: PPUSH
36277: PPUSH
36278: PPUSH
// all := MCF_All ( side , [ ] ) ;
36279: LD_ADDR_VAR 0 17
36283: PUSH
36284: LD_VAR 0 1
36288: PPUSH
36289: EMPTY
36290: PPUSH
36291: CALL 11528 0 2
36295: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36296: LD_ADDR_VAR 0 13
36300: PUSH
36301: LD_VAR 0 1
36305: PPUSH
36306: LD_INT 1
36308: PPUSH
36309: EMPTY
36310: PPUSH
36311: CALL 11476 0 3
36315: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36316: LD_ADDR_VAR 0 14
36320: PUSH
36321: LD_VAR 0 1
36325: PPUSH
36326: LD_INT 2
36328: PPUSH
36329: EMPTY
36330: PPUSH
36331: CALL 11476 0 3
36335: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36336: LD_ADDR_VAR 0 15
36340: PUSH
36341: LD_VAR 0 1
36345: PPUSH
36346: LD_INT 3
36348: PPUSH
36349: EMPTY
36350: PPUSH
36351: CALL 11476 0 3
36355: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36356: LD_ADDR_VAR 0 16
36360: PUSH
36361: LD_VAR 0 1
36365: PPUSH
36366: LD_INT 4
36368: PPUSH
36369: EMPTY
36370: PPUSH
36371: CALL 11476 0 3
36375: ST_TO_ADDR
// if mech then
36376: LD_VAR 0 15
36380: IFFALSE 36397
// mech := MCF_SortListDesc ( mech ) ;
36382: LD_ADDR_VAR 0 15
36386: PUSH
36387: LD_VAR 0 15
36391: PPUSH
36392: CALL 12642 0 1
36396: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36397: LD_EXP 56
36401: PUSH
36402: LD_VAR 0 1
36406: ARRAY
36407: PUSH
36408: LD_STRING 
36410: EQUAL
36411: NOT
36412: IFFALSE 36468
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36414: LD_EXP 56
36418: PUSH
36419: LD_VAR 0 1
36423: ARRAY
36424: PUSH
36425: LD_INT 1
36427: ARRAY
36428: PPUSH
36429: CALL_OW 257
36433: PUSH
36434: LD_INT 1
36436: EQUAL
36437: IFFALSE 36466
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36439: LD_VAR 0 1
36443: PPUSH
36444: LD_STRING ToArm
36446: PPUSH
36447: LD_EXP 56
36451: PUSH
36452: LD_VAR 0 1
36456: ARRAY
36457: PUSH
36458: LD_INT 1
36460: ARRAY
36461: PPUSH
36462: CALL 14272 0 3
// end else
36466: GO 36494
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36468: LD_ADDR_EXP 56
36472: PUSH
36473: LD_EXP 56
36477: PPUSH
36478: LD_VAR 0 1
36482: PPUSH
36483: LD_INT 1
36485: PPUSH
36486: LD_INT 0
36488: PPUSH
36489: CALL 30861 0 4
36493: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36494: LD_EXP 57
36498: PUSH
36499: LD_VAR 0 1
36503: ARRAY
36504: PUSH
36505: LD_STRING 
36507: EQUAL
36508: NOT
36509: IFFALSE 36565
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36511: LD_EXP 57
36515: PUSH
36516: LD_VAR 0 1
36520: ARRAY
36521: PUSH
36522: LD_INT 1
36524: ARRAY
36525: PPUSH
36526: CALL_OW 257
36530: PUSH
36531: LD_INT 2
36533: EQUAL
36534: IFFALSE 36563
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36536: LD_VAR 0 1
36540: PPUSH
36541: LD_STRING ToDep
36543: PPUSH
36544: LD_EXP 57
36548: PUSH
36549: LD_VAR 0 1
36553: ARRAY
36554: PUSH
36555: LD_INT 1
36557: ARRAY
36558: PPUSH
36559: CALL 14272 0 3
// end else
36563: GO 36591
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36565: LD_ADDR_EXP 57
36569: PUSH
36570: LD_EXP 57
36574: PPUSH
36575: LD_VAR 0 1
36579: PPUSH
36580: LD_INT 1
36582: PPUSH
36583: LD_INT 0
36585: PPUSH
36586: CALL 30861 0 4
36590: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36591: LD_EXP 55
36595: PUSH
36596: LD_VAR 0 1
36600: ARRAY
36601: PUSH
36602: LD_STRING 
36604: EQUAL
36605: NOT
36606: IFFALSE 36662
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36608: LD_EXP 55
36612: PUSH
36613: LD_VAR 0 1
36617: ARRAY
36618: PUSH
36619: LD_INT 1
36621: ARRAY
36622: PPUSH
36623: CALL_OW 257
36627: PUSH
36628: LD_INT 3
36630: EQUAL
36631: IFFALSE 36660
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36633: LD_VAR 0 1
36637: PPUSH
36638: LD_STRING ToFac
36640: PPUSH
36641: LD_EXP 55
36645: PUSH
36646: LD_VAR 0 1
36650: ARRAY
36651: PUSH
36652: LD_INT 1
36654: ARRAY
36655: PPUSH
36656: CALL 14272 0 3
// end else
36660: GO 36688
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36662: LD_ADDR_EXP 55
36666: PUSH
36667: LD_EXP 55
36671: PPUSH
36672: LD_VAR 0 1
36676: PPUSH
36677: LD_INT 1
36679: PPUSH
36680: LD_INT 0
36682: PPUSH
36683: CALL 30861 0 4
36687: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36688: LD_EXP 54
36692: PUSH
36693: LD_VAR 0 1
36697: ARRAY
36698: PUSH
36699: LD_STRING 
36701: EQUAL
36702: NOT
36703: IFFALSE 36759
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36705: LD_EXP 54
36709: PUSH
36710: LD_VAR 0 1
36714: ARRAY
36715: PUSH
36716: LD_INT 1
36718: ARRAY
36719: PPUSH
36720: CALL_OW 257
36724: PUSH
36725: LD_INT 4
36727: EQUAL
36728: IFFALSE 36757
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36730: LD_VAR 0 1
36734: PPUSH
36735: LD_STRING ToLab
36737: PPUSH
36738: LD_EXP 54
36742: PUSH
36743: LD_VAR 0 1
36747: ARRAY
36748: PUSH
36749: LD_INT 1
36751: ARRAY
36752: PPUSH
36753: CALL 14272 0 3
// end else
36757: GO 36785
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36759: LD_ADDR_EXP 54
36763: PUSH
36764: LD_EXP 54
36768: PPUSH
36769: LD_VAR 0 1
36773: PPUSH
36774: LD_INT 1
36776: PPUSH
36777: LD_INT 0
36779: PPUSH
36780: CALL 30861 0 4
36784: ST_TO_ADDR
// if mode = 0 then
36785: LD_VAR 0 2
36789: PUSH
36790: LD_INT 0
36792: EQUAL
36793: IFFALSE 38631
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36795: LD_VAR 0 1
36799: PPUSH
36800: LD_INT 30
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PPUSH
36810: CALL 11393 0 2
36814: PUSH
36815: LD_VAR 0 1
36819: PPUSH
36820: LD_INT 21
36822: PUSH
36823: LD_INT 3
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PPUSH
36830: CALL 11393 0 2
36834: PUSH
36835: LD_INT 1
36837: EQUAL
36838: AND
36839: IFFALSE 36904
// begin if all then
36841: LD_VAR 0 17
36845: IFFALSE 36902
// for i in ( all diff eng ) do
36847: LD_ADDR_VAR 0 4
36851: PUSH
36852: LD_VAR 0 17
36856: PUSH
36857: LD_VAR 0 14
36861: DIFF
36862: PUSH
36863: FOR_IN
36864: IFFALSE 36900
// if GetTag ( i ) = 0 then
36866: LD_VAR 0 4
36870: PPUSH
36871: CALL_OW 110
36875: PUSH
36876: LD_INT 0
36878: EQUAL
36879: IFFALSE 36898
// MCH_ChangeClass ( side , i , 2 ) ;
36881: LD_VAR 0 1
36885: PPUSH
36886: LD_VAR 0 4
36890: PPUSH
36891: LD_INT 2
36893: PPUSH
36894: CALL 16300 0 3
36898: GO 36863
36900: POP
36901: POP
// end else
36902: GO 37223
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36904: LD_VAR 0 13
36908: PUSH
36909: LD_EXP 56
36913: PUSH
36914: LD_VAR 0 1
36918: ARRAY
36919: PLUS
36920: PUSH
36921: LD_INT 22
36923: PUSH
36924: LD_VAR 0 1
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 30
36935: PUSH
36936: LD_INT 32
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PPUSH
36947: CALL_OW 69
36951: LESS
36952: IFFALSE 36977
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36954: LD_VAR 0 1
36958: PPUSH
36959: LD_VAR 0 14
36963: PUSH
36964: LD_INT 1
36966: ARRAY
36967: PPUSH
36968: LD_INT 1
36970: PPUSH
36971: CALL 16300 0 3
// end else
36975: GO 37223
// if sci < 6 and MCF_Lab ( side ) then
36977: LD_VAR 0 16
36981: PUSH
36982: LD_INT 6
36984: LESS
36985: PUSH
36986: LD_VAR 0 1
36990: PPUSH
36991: CALL 11432 0 1
36995: AND
36996: IFFALSE 37101
// begin if MREG_ToBunker [ side ] then
36998: LD_EXP 68
37002: PUSH
37003: LD_VAR 0 1
37007: ARRAY
37008: IFFALSE 37034
// tmp := sol diff MREG_ToBunker [ side ] else
37010: LD_ADDR_VAR 0 12
37014: PUSH
37015: LD_VAR 0 13
37019: PUSH
37020: LD_EXP 68
37024: PUSH
37025: LD_VAR 0 1
37029: ARRAY
37030: DIFF
37031: ST_TO_ADDR
37032: GO 37044
// tmp := sol ;
37034: LD_ADDR_VAR 0 12
37038: PUSH
37039: LD_VAR 0 13
37043: ST_TO_ADDR
// if tmp then
37044: LD_VAR 0 12
37048: IFFALSE 37099
// for i in tmp do
37050: LD_ADDR_VAR 0 4
37054: PUSH
37055: LD_VAR 0 12
37059: PUSH
37060: FOR_IN
37061: IFFALSE 37097
// if GetTag ( i ) = 0 then
37063: LD_VAR 0 4
37067: PPUSH
37068: CALL_OW 110
37072: PUSH
37073: LD_INT 0
37075: EQUAL
37076: IFFALSE 37095
// MCH_ChangeClass ( side , i , 4 ) ;
37078: LD_VAR 0 1
37082: PPUSH
37083: LD_VAR 0 4
37087: PPUSH
37088: LD_INT 4
37090: PPUSH
37091: CALL 16300 0 3
37095: GO 37060
37097: POP
37098: POP
// end else
37099: GO 37223
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37101: LD_VAR 0 1
37105: PPUSH
37106: LD_INT 30
37108: PUSH
37109: LD_INT 1
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PPUSH
37116: CALL 11393 0 2
37120: IFFALSE 37223
// begin if MREG_ToBunker [ side ] then
37122: LD_EXP 68
37126: PUSH
37127: LD_VAR 0 1
37131: ARRAY
37132: IFFALSE 37158
// tmp := sol diff MREG_ToBunker [ side ] else
37134: LD_ADDR_VAR 0 12
37138: PUSH
37139: LD_VAR 0 13
37143: PUSH
37144: LD_EXP 68
37148: PUSH
37149: LD_VAR 0 1
37153: ARRAY
37154: DIFF
37155: ST_TO_ADDR
37156: GO 37168
// tmp := sol ;
37158: LD_ADDR_VAR 0 12
37162: PUSH
37163: LD_VAR 0 13
37167: ST_TO_ADDR
// if tmp then
37168: LD_VAR 0 12
37172: IFFALSE 37223
// for i in tmp do
37174: LD_ADDR_VAR 0 4
37178: PUSH
37179: LD_VAR 0 12
37183: PUSH
37184: FOR_IN
37185: IFFALSE 37221
// if GetTag ( i ) = 0 then
37187: LD_VAR 0 4
37191: PPUSH
37192: CALL_OW 110
37196: PUSH
37197: LD_INT 0
37199: EQUAL
37200: IFFALSE 37219
// MCH_ChangeClass ( side , i , 2 ) ;
37202: LD_VAR 0 1
37206: PPUSH
37207: LD_VAR 0 4
37211: PPUSH
37212: LD_INT 2
37214: PPUSH
37215: CALL 16300 0 3
37219: GO 37184
37221: POP
37222: POP
// end ; if MCF_Lab ( side ) then
37223: LD_VAR 0 1
37227: PPUSH
37228: CALL 11432 0 1
37232: IFFALSE 37772
// begin if MCL_GetTechList ( side ) then
37234: LD_VAR 0 1
37238: PPUSH
37239: CALL 17776 0 1
37243: IFFALSE 37369
// begin if MREG_ToLab [ side ] then
37245: LD_EXP 54
37249: PUSH
37250: LD_VAR 0 1
37254: ARRAY
37255: IFFALSE 37275
// k := MREG_ToLab [ side ] else
37257: LD_ADDR_VAR 0 8
37261: PUSH
37262: LD_EXP 54
37266: PUSH
37267: LD_VAR 0 1
37271: ARRAY
37272: ST_TO_ADDR
37273: GO 37283
// k := 0 ;
37275: LD_ADDR_VAR 0 8
37279: PUSH
37280: LD_INT 0
37282: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37283: LD_VAR 0 16
37287: PUSH
37288: LD_VAR 0 8
37292: PLUS
37293: PUSH
37294: LD_INT 6
37296: LESSEQUAL
37297: PUSH
37298: LD_VAR 0 17
37302: PUSH
37303: LD_INT 6
37305: GREATER
37306: AND
37307: IFFALSE 37323
// MCH_TrainScientist ( side , 1 ) else
37309: LD_VAR 0 1
37313: PPUSH
37314: LD_INT 1
37316: PPUSH
37317: CALL 15852 0 2
37321: GO 37367
// if all < 6 then
37323: LD_VAR 0 17
37327: PUSH
37328: LD_INT 6
37330: LESS
37331: IFFALSE 37367
// if sci + k < all / 2 then
37333: LD_VAR 0 16
37337: PUSH
37338: LD_VAR 0 8
37342: PLUS
37343: PUSH
37344: LD_VAR 0 17
37348: PUSH
37349: LD_INT 2
37351: DIVREAL
37352: LESS
37353: IFFALSE 37367
// MCH_TrainScientist ( side , 1 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_INT 1
37362: PPUSH
37363: CALL 15852 0 2
// end else
37367: GO 37445
// begin if sci > 2 then
37369: LD_VAR 0 16
37373: PUSH
37374: LD_INT 2
37376: GREATER
37377: IFFALSE 37445
// for i = sci downto 2 do
37379: LD_ADDR_VAR 0 4
37383: PUSH
37384: DOUBLE
37385: LD_VAR 0 16
37389: INC
37390: ST_TO_ADDR
37391: LD_INT 2
37393: PUSH
37394: FOR_DOWNTO
37395: IFFALSE 37443
// if GetTag ( sci [ i ] ) = 0 then
37397: LD_VAR 0 16
37401: PUSH
37402: LD_VAR 0 4
37406: ARRAY
37407: PPUSH
37408: CALL_OW 110
37412: PUSH
37413: LD_INT 0
37415: EQUAL
37416: IFFALSE 37441
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37418: LD_VAR 0 1
37422: PPUSH
37423: LD_VAR 0 16
37427: PUSH
37428: LD_VAR 0 4
37432: ARRAY
37433: PPUSH
37434: LD_INT 2
37436: PPUSH
37437: CALL 16300 0 3
37441: GO 37394
37443: POP
37444: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37445: LD_VAR 0 1
37449: PPUSH
37450: CALL 17776 0 1
37454: PUSH
37455: LD_VAR 0 1
37459: PPUSH
37460: CALL 11432 0 1
37464: AND
37465: PUSH
37466: LD_EXP 35
37470: PUSH
37471: LD_VAR 0 1
37475: ARRAY
37476: NOT
37477: AND
37478: IFFALSE 37772
// begin for j = 1 to MCF_Lab ( side ) do
37480: LD_ADDR_VAR 0 5
37484: PUSH
37485: DOUBLE
37486: LD_INT 1
37488: DEC
37489: ST_TO_ADDR
37490: LD_VAR 0 1
37494: PPUSH
37495: CALL 11432 0 1
37499: PUSH
37500: FOR_TO
37501: IFFALSE 37561
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37503: LD_VAR 0 1
37507: PPUSH
37508: CALL 11432 0 1
37512: PUSH
37513: LD_VAR 0 5
37517: ARRAY
37518: PPUSH
37519: CALL_OW 461
37523: PUSH
37524: LD_INT 3
37526: PUSH
37527: LD_INT 6
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: IN
37534: IFFALSE 37559
// begin b := MCF_Lab ( side ) [ j ] ;
37536: LD_ADDR_VAR 0 11
37540: PUSH
37541: LD_VAR 0 1
37545: PPUSH
37546: CALL 11432 0 1
37550: PUSH
37551: LD_VAR 0 5
37555: ARRAY
37556: ST_TO_ADDR
// break ;
37557: GO 37561
// end ;
37559: GO 37500
37561: POP
37562: POP
// if MCF_Class ( side , 4 , [ ] ) then
37563: LD_VAR 0 1
37567: PPUSH
37568: LD_INT 4
37570: PPUSH
37571: EMPTY
37572: PPUSH
37573: CALL 11476 0 3
37577: IFFALSE 37772
// for j in MCF_Class ( side , 4 , [ ] ) do
37579: LD_ADDR_VAR 0 5
37583: PUSH
37584: LD_VAR 0 1
37588: PPUSH
37589: LD_INT 4
37591: PPUSH
37592: EMPTY
37593: PPUSH
37594: CALL 11476 0 3
37598: PUSH
37599: FOR_IN
37600: IFFALSE 37770
// begin if GetTag ( j ) = 0 then
37602: LD_VAR 0 5
37606: PPUSH
37607: CALL_OW 110
37611: PUSH
37612: LD_INT 0
37614: EQUAL
37615: IFFALSE 37706
// begin if IsInUnit ( j ) and b then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: PUSH
37627: LD_VAR 0 11
37631: AND
37632: IFFALSE 37680
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37634: LD_VAR 0 5
37638: PPUSH
37639: CALL_OW 310
37643: PPUSH
37644: CALL_OW 461
37648: PUSH
37649: LD_INT 2
37651: EQUAL
37652: PUSH
37653: LD_VAR 0 5
37657: PPUSH
37658: CALL_OW 310
37662: PUSH
37663: LD_VAR 0 11
37667: NONEQUAL
37668: AND
37669: IFFALSE 37680
// ComExitBuilding ( j ) ;
37671: LD_VAR 0 5
37675: PPUSH
37676: CALL_OW 122
// if not IsInUnit ( j ) then
37680: LD_VAR 0 5
37684: PPUSH
37685: CALL_OW 310
37689: NOT
37690: IFFALSE 37706
// ComEnterUnit ( j , b ) ;
37692: LD_VAR 0 5
37696: PPUSH
37697: LD_VAR 0 11
37701: PPUSH
37702: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37706: LD_INT 1
37708: PPUSH
37709: LD_VAR 0 5
37713: PPUSH
37714: CALL_OW 255
37718: PPUSH
37719: CALL_OW 321
37723: PUSH
37724: LD_INT 2
37726: EQUAL
37727: PUSH
37728: LD_VAR 0 5
37732: PPUSH
37733: CALL_OW 255
37737: PPUSH
37738: CALL 24794 0 1
37742: PUSH
37743: LD_INT 0
37745: EQUAL
37746: AND
37747: IFFALSE 37768
// MCN_Tame ( GetSide ( j ) , j ) ;
37749: LD_VAR 0 5
37753: PPUSH
37754: CALL_OW 255
37758: PPUSH
37759: LD_VAR 0 5
37763: PPUSH
37764: CALL 18295 0 2
// end ;
37768: GO 37599
37770: POP
37771: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37772: LD_VAR 0 1
37776: PPUSH
37777: LD_INT 30
37779: PUSH
37780: LD_INT 3
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PPUSH
37787: CALL 11393 0 2
37791: IFFALSE 38050
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37793: LD_ADDR_VAR 0 11
37797: PUSH
37798: LD_VAR 0 1
37802: PPUSH
37803: LD_INT 30
37805: PUSH
37806: LD_INT 3
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PPUSH
37813: CALL 11393 0 2
37817: PUSH
37818: LD_INT 1
37820: ARRAY
37821: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37822: LD_ADDR_VAR 0 12
37826: PUSH
37827: LD_VAR 0 1
37831: PPUSH
37832: LD_INT 0
37834: PPUSH
37835: LD_INT 25
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PPUSH
37845: CALL 12096 0 3
37849: ST_TO_ADDR
// for i = 1 to tmp do
37850: LD_ADDR_VAR 0 4
37854: PUSH
37855: DOUBLE
37856: LD_INT 1
37858: DEC
37859: ST_TO_ADDR
37860: LD_VAR 0 12
37864: PUSH
37865: FOR_TO
37866: IFFALSE 37926
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37868: LD_VAR 0 12
37872: PUSH
37873: LD_VAR 0 4
37877: ARRAY
37878: PPUSH
37879: CALL_OW 310
37883: NOT
37884: PUSH
37885: LD_VAR 0 12
37889: PUSH
37890: LD_VAR 0 4
37894: ARRAY
37895: PPUSH
37896: CALL_OW 314
37900: NOT
37901: AND
37902: IFFALSE 37924
// ComEnterUnit ( tmp [ i ] , b ) ;
37904: LD_VAR 0 12
37908: PUSH
37909: LD_VAR 0 4
37913: ARRAY
37914: PPUSH
37915: LD_VAR 0 11
37919: PPUSH
37920: CALL_OW 120
37924: GO 37865
37926: POP
37927: POP
// if MREG_ToFac [ side ] then
37928: LD_EXP 55
37932: PUSH
37933: LD_VAR 0 1
37937: ARRAY
37938: IFFALSE 37958
// k := MREG_ToFac [ side ] else
37940: LD_ADDR_VAR 0 8
37944: PUSH
37945: LD_EXP 55
37949: PUSH
37950: LD_VAR 0 1
37954: ARRAY
37955: ST_TO_ADDR
37956: GO 37966
// k := 0 ;
37958: LD_ADDR_VAR 0 8
37962: PUSH
37963: LD_INT 0
37965: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37966: LD_VAR 0 15
37970: PUSH
37971: LD_VAR 0 8
37975: PLUS
37976: PUSH
37977: LD_INT 6
37979: LESSEQUAL
37980: PUSH
37981: LD_VAR 0 17
37985: PUSH
37986: LD_INT 6
37988: GREATER
37989: AND
37990: IFFALSE 38006
// MCH_TrainMechanic ( side , 1 ) else
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 1
37999: PPUSH
38000: CALL 15594 0 2
38004: GO 38050
// if all < 6 then
38006: LD_VAR 0 17
38010: PUSH
38011: LD_INT 6
38013: LESS
38014: IFFALSE 38050
// if mech + k < all / 2 then
38016: LD_VAR 0 15
38020: PUSH
38021: LD_VAR 0 8
38025: PLUS
38026: PUSH
38027: LD_VAR 0 17
38031: PUSH
38032: LD_INT 2
38034: DIVREAL
38035: LESS
38036: IFFALSE 38050
// MCH_TrainMechanic ( side , 1 ) ;
38038: LD_VAR 0 1
38042: PPUSH
38043: LD_INT 1
38045: PPUSH
38046: CALL 15594 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38050: LD_ADDR_VAR 0 10
38054: PUSH
38055: LD_VAR 0 1
38059: PPUSH
38060: LD_INT 30
38062: PUSH
38063: LD_INT 36
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PPUSH
38070: CALL 11393 0 2
38074: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38075: LD_VAR 0 10
38079: PUSH
38080: LD_VAR 0 15
38084: AND
38085: PUSH
38086: LD_VAR 0 1
38090: PPUSH
38091: LD_INT 3
38093: PPUSH
38094: EMPTY
38095: PPUSH
38096: CALL 11476 0 3
38100: AND
38101: IFFALSE 38259
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38103: LD_VAR 0 1
38107: PPUSH
38108: LD_INT 9
38110: PPUSH
38111: EMPTY
38112: PPUSH
38113: CALL 12096 0 3
38117: PUSH
38118: LD_INT 3
38120: LESS
38121: IFFALSE 38259
// begin if mech < 3 then
38123: LD_VAR 0 15
38127: PUSH
38128: LD_INT 3
38130: LESS
38131: IFFALSE 38145
// k := mech else
38133: LD_ADDR_VAR 0 8
38137: PUSH
38138: LD_VAR 0 15
38142: ST_TO_ADDR
38143: GO 38153
// k := 3 ;
38145: LD_ADDR_VAR 0 8
38149: PUSH
38150: LD_INT 3
38152: ST_TO_ADDR
// for j = 1 to k do
38153: LD_ADDR_VAR 0 5
38157: PUSH
38158: DOUBLE
38159: LD_INT 1
38161: DEC
38162: ST_TO_ADDR
38163: LD_VAR 0 8
38167: PUSH
38168: FOR_TO
38169: IFFALSE 38227
// if GetClass ( mech [ j ] ) = 3 then
38171: LD_VAR 0 15
38175: PUSH
38176: LD_VAR 0 5
38180: ARRAY
38181: PPUSH
38182: CALL_OW 257
38186: PUSH
38187: LD_INT 3
38189: EQUAL
38190: IFFALSE 38225
// begin SetTag ( mech [ j ] , 9 ) ;
38192: LD_VAR 0 15
38196: PUSH
38197: LD_VAR 0 5
38201: ARRAY
38202: PPUSH
38203: LD_INT 9
38205: PPUSH
38206: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38210: LD_VAR 0 15
38214: PUSH
38215: LD_VAR 0 5
38219: ARRAY
38220: PPUSH
38221: CALL_OW 122
// end ;
38225: GO 38168
38227: POP
38228: POP
// if mech < 6 + k then
38229: LD_VAR 0 15
38233: PUSH
38234: LD_INT 6
38236: PUSH
38237: LD_VAR 0 8
38241: PLUS
38242: LESS
38243: IFFALSE 38259
// MCH_TrainMechanic ( side , k ) ;
38245: LD_VAR 0 1
38249: PPUSH
38250: LD_VAR 0 8
38254: PPUSH
38255: CALL 15594 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38259: LD_VAR 0 1
38263: PPUSH
38264: LD_INT 9
38266: PPUSH
38267: EMPTY
38268: PPUSH
38269: CALL 12096 0 3
38273: IFFALSE 38364
// for j in MCF_Tag ( side , 9 , [ ] ) do
38275: LD_ADDR_VAR 0 5
38279: PUSH
38280: LD_VAR 0 1
38284: PPUSH
38285: LD_INT 9
38287: PPUSH
38288: EMPTY
38289: PPUSH
38290: CALL 12096 0 3
38294: PUSH
38295: FOR_IN
38296: IFFALSE 38362
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38298: LD_VAR 0 5
38302: PPUSH
38303: CALL_OW 310
38307: NOT
38308: PUSH
38309: LD_VAR 0 5
38313: PPUSH
38314: CALL 31504 0 1
38318: NOT
38319: AND
38320: IFFALSE 38360
// if ct then
38322: LD_VAR 0 10
38326: IFFALSE 38348
// ComEnterUnit ( j , ct [ 1 ] ) else
38328: LD_VAR 0 5
38332: PPUSH
38333: LD_VAR 0 10
38337: PUSH
38338: LD_INT 1
38340: ARRAY
38341: PPUSH
38342: CALL_OW 120
38346: GO 38360
// SetTag ( j , 0 ) ;
38348: LD_VAR 0 5
38352: PPUSH
38353: LD_INT 0
38355: PPUSH
38356: CALL_OW 109
38360: GO 38295
38362: POP
38363: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38364: LD_INT 1
38366: PPUSH
38367: LD_VAR 0 1
38371: PPUSH
38372: CALL_OW 321
38376: PUSH
38377: LD_INT 2
38379: EQUAL
38380: PUSH
38381: LD_EXP 35
38385: PUSH
38386: LD_VAR 0 1
38390: ARRAY
38391: NOT
38392: AND
38393: PUSH
38394: LD_VAR 0 1
38398: PPUSH
38399: LD_INT 4
38401: PPUSH
38402: EMPTY
38403: PPUSH
38404: CALL 11476 0 3
38408: AND
38409: IFFALSE 38457
// for j in MCF_Class ( side , 4 , [ ] ) do
38411: LD_ADDR_VAR 0 5
38415: PUSH
38416: LD_VAR 0 1
38420: PPUSH
38421: LD_INT 4
38423: PPUSH
38424: EMPTY
38425: PPUSH
38426: CALL 11476 0 3
38430: PUSH
38431: FOR_IN
38432: IFFALSE 38455
// MCN_Tame ( GetSide ( j ) , j ) ;
38434: LD_VAR 0 5
38438: PPUSH
38439: CALL_OW 255
38443: PPUSH
38444: LD_VAR 0 5
38448: PPUSH
38449: CALL 18295 0 2
38453: GO 38431
38455: POP
38456: POP
// if MREG_DefVeh [ side ] then
38457: LD_EXP 67
38461: PUSH
38462: LD_VAR 0 1
38466: ARRAY
38467: IFFALSE 38631
// begin for i in MREG_DefVeh [ side ] do
38469: LD_ADDR_VAR 0 4
38473: PUSH
38474: LD_EXP 67
38478: PUSH
38479: LD_VAR 0 1
38483: ARRAY
38484: PUSH
38485: FOR_IN
38486: IFFALSE 38539
// begin SetTag ( i , 0 ) ;
38488: LD_VAR 0 4
38492: PPUSH
38493: LD_INT 0
38495: PPUSH
38496: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38500: LD_VAR 0 4
38504: PPUSH
38505: LD_EXP 64
38509: PUSH
38510: LD_VAR 0 1
38514: ARRAY
38515: PPUSH
38516: CALL_OW 308
38520: NOT
38521: IFFALSE 38537
// MCV_Parking ( side , i ) ;
38523: LD_VAR 0 1
38527: PPUSH
38528: LD_VAR 0 4
38532: PPUSH
38533: CALL 25554 0 2
// end ;
38537: GO 38485
38539: POP
38540: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38541: LD_VAR 0 1
38545: PPUSH
38546: LD_INT 36
38548: PPUSH
38549: EMPTY
38550: PPUSH
38551: CALL 12096 0 3
38555: IFFALSE 38596
// for i in MCF_Tag ( side , 36 , [ ] ) do
38557: LD_ADDR_VAR 0 4
38561: PUSH
38562: LD_VAR 0 1
38566: PPUSH
38567: LD_INT 36
38569: PPUSH
38570: EMPTY
38571: PPUSH
38572: CALL 12096 0 3
38576: PUSH
38577: FOR_IN
38578: IFFALSE 38594
// SetTag ( i , 0 ) ;
38580: LD_VAR 0 4
38584: PPUSH
38585: LD_INT 0
38587: PPUSH
38588: CALL_OW 109
38592: GO 38577
38594: POP
38595: POP
// if MREG_DefMobActive [ side ] then
38596: LD_EXP 70
38600: PUSH
38601: LD_VAR 0 1
38605: ARRAY
38606: IFFALSE 38631
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38608: LD_ADDR_EXP 70
38612: PUSH
38613: LD_EXP 70
38617: PPUSH
38618: LD_VAR 0 1
38622: PPUSH
38623: LD_INT 0
38625: PPUSH
38626: CALL_OW 1
38630: ST_TO_ADDR
// end ; end ; if mode > 0 then
38631: LD_VAR 0 2
38635: PUSH
38636: LD_INT 0
38638: GREATER
38639: IFFALSE 40654
// begin if tick <= 15 15$00 then
38641: LD_OWVAR 1
38645: PUSH
38646: LD_INT 31500
38648: LESSEQUAL
38649: IFFALSE 39073
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38651: LD_VAR 0 13
38655: PUSH
38656: LD_INT 4
38658: GREATER
38659: PUSH
38660: LD_VAR 0 1
38664: PPUSH
38665: CALL 24794 0 1
38669: PUSH
38670: LD_INT 4
38672: LESS
38673: AND
38674: IFFALSE 38785
// for i in sol do
38676: LD_ADDR_VAR 0 4
38680: PUSH
38681: LD_VAR 0 13
38685: PUSH
38686: FOR_IN
38687: IFFALSE 38783
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38689: LD_ADDR_VAR 0 8
38693: PUSH
38694: LD_VAR 0 1
38698: PPUSH
38699: CALL 24794 0 1
38703: PPUSH
38704: LD_VAR 0 4
38708: PPUSH
38709: CALL_OW 74
38713: ST_TO_ADDR
// if IsInUnit ( i ) then
38714: LD_VAR 0 4
38718: PPUSH
38719: CALL_OW 310
38723: IFFALSE 38734
// ComExitBuilding ( i ) ;
38725: LD_VAR 0 4
38729: PPUSH
38730: CALL_OW 122
// if not HasTask ( i ) and k then
38734: LD_VAR 0 4
38738: PPUSH
38739: CALL_OW 314
38743: NOT
38744: PUSH
38745: LD_VAR 0 8
38749: AND
38750: IFFALSE 38781
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38752: LD_VAR 0 4
38756: PPUSH
38757: LD_VAR 0 8
38761: PPUSH
38762: CALL_OW 250
38766: PPUSH
38767: LD_VAR 0 8
38771: PPUSH
38772: CALL_OW 251
38776: PPUSH
38777: CALL_OW 114
// end ;
38781: GO 38686
38783: POP
38784: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38785: LD_VAR 0 1
38789: PPUSH
38790: LD_INT 30
38792: PUSH
38793: LD_INT 5
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PPUSH
38800: CALL 11393 0 2
38804: IFFALSE 39071
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38806: LD_ADDR_VAR 0 11
38810: PUSH
38811: LD_VAR 0 1
38815: PPUSH
38816: LD_INT 30
38818: PUSH
38819: LD_INT 5
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PPUSH
38826: CALL 11393 0 2
38830: PUSH
38831: LD_INT 1
38833: ARRAY
38834: ST_TO_ADDR
// if mech then
38835: LD_VAR 0 15
38839: IFFALSE 38875
// for i in mech do
38841: LD_ADDR_VAR 0 4
38845: PUSH
38846: LD_VAR 0 15
38850: PUSH
38851: FOR_IN
38852: IFFALSE 38873
// MCH_ChangeClass ( side , i , 1 ) ;
38854: LD_VAR 0 1
38858: PPUSH
38859: LD_VAR 0 4
38863: PPUSH
38864: LD_INT 1
38866: PPUSH
38867: CALL 16300 0 3
38871: GO 38851
38873: POP
38874: POP
// if eng > 1 then
38875: LD_VAR 0 14
38879: PUSH
38880: LD_INT 1
38882: GREATER
38883: IFFALSE 38930
// for i = eng downto 2 do
38885: LD_ADDR_VAR 0 4
38889: PUSH
38890: DOUBLE
38891: LD_VAR 0 14
38895: INC
38896: ST_TO_ADDR
38897: LD_INT 2
38899: PUSH
38900: FOR_DOWNTO
38901: IFFALSE 38928
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38903: LD_VAR 0 1
38907: PPUSH
38908: LD_VAR 0 14
38912: PUSH
38913: LD_VAR 0 4
38917: ARRAY
38918: PPUSH
38919: LD_INT 1
38921: PPUSH
38922: CALL 16300 0 3
38926: GO 38900
38928: POP
38929: POP
// if UnitsInside ( b ) = 6 then
38930: LD_VAR 0 11
38934: PPUSH
38935: CALL_OW 313
38939: PUSH
38940: LD_INT 6
38942: EQUAL
38943: IFFALSE 39071
// begin un := UnitsInside ( b ) [ 1 ] ;
38945: LD_ADDR_VAR 0 9
38949: PUSH
38950: LD_VAR 0 11
38954: PPUSH
38955: CALL_OW 313
38959: PUSH
38960: LD_INT 1
38962: ARRAY
38963: ST_TO_ADDR
// ComExitBuilding ( un ) ;
38964: LD_VAR 0 9
38968: PPUSH
38969: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
38973: LD_VAR 0 1
38977: PPUSH
38978: LD_INT 30
38980: PUSH
38981: LD_INT 5
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PPUSH
38988: CALL 11393 0 2
38992: PUSH
38993: LD_INT 1
38995: GREATER
38996: PUSH
38997: LD_VAR 0 1
39001: PPUSH
39002: CALL 24794 0 1
39006: PUSH
39007: LD_INT 4
39009: GREATEREQUAL
39010: AND
39011: IFFALSE 39071
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_VAR 0 1
39022: PPUSH
39023: LD_INT 30
39025: PUSH
39026: LD_INT 5
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PPUSH
39033: CALL 11393 0 2
39037: PUSH
39038: LD_INT 2
39040: ARRAY
39041: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39042: LD_VAR 0 8
39046: PPUSH
39047: CALL_OW 313
39051: PUSH
39052: LD_INT 6
39054: LESS
39055: IFFALSE 39071
// AddComEnterUnit ( un , k ) ;
39057: LD_VAR 0 9
39061: PPUSH
39062: LD_VAR 0 8
39066: PPUSH
39067: CALL_OW 180
// end ; end ; end ; end else
39071: GO 40654
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39073: LD_VAR 0 1
39077: PPUSH
39078: LD_INT 1
39080: PPUSH
39081: LD_EXP 65
39085: PUSH
39086: LD_VAR 0 1
39090: ARRAY
39091: PUSH
39092: LD_INT 1
39094: ARRAY
39095: PPUSH
39096: CALL 33806 0 3
39100: IFFALSE 39239
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39102: LD_ADDR_VAR 0 12
39106: PUSH
39107: LD_VAR 0 1
39111: PPUSH
39112: LD_INT 21
39114: PUSH
39115: LD_INT 1
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PPUSH
39122: CALL 11393 0 2
39126: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39127: LD_ADDR_VAR 0 11
39131: PUSH
39132: LD_VAR 0 1
39136: PPUSH
39137: LD_INT 30
39139: PUSH
39140: LD_INT 1
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PPUSH
39147: CALL 11393 0 2
39151: ST_TO_ADDR
// if b then
39152: LD_VAR 0 11
39156: IFFALSE 39239
// for i in tmp do
39158: LD_ADDR_VAR 0 4
39162: PUSH
39163: LD_VAR 0 12
39167: PUSH
39168: FOR_IN
39169: IFFALSE 39237
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39171: LD_VAR 0 4
39175: PPUSH
39176: LD_EXP 65
39180: PUSH
39181: LD_VAR 0 1
39185: ARRAY
39186: PUSH
39187: LD_INT 1
39189: ARRAY
39190: PPUSH
39191: CALL_OW 308
39195: NOT
39196: IFFALSE 39235
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39198: LD_VAR 0 4
39202: PPUSH
39203: LD_VAR 0 11
39207: PUSH
39208: LD_INT 1
39210: ARRAY
39211: PPUSH
39212: CALL_OW 250
39216: PPUSH
39217: LD_VAR 0 11
39221: PUSH
39222: LD_INT 1
39224: ARRAY
39225: PPUSH
39226: CALL_OW 251
39230: PPUSH
39231: CALL_OW 111
39235: GO 39168
39237: POP
39238: POP
// end ; if MREG_DefVeh [ side ] then
39239: LD_EXP 67
39243: PUSH
39244: LD_VAR 0 1
39248: ARRAY
39249: IFFALSE 39817
// begin tmp := [ ] ;
39251: LD_ADDR_VAR 0 12
39255: PUSH
39256: EMPTY
39257: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39258: LD_EXP 70
39262: PUSH
39263: LD_VAR 0 1
39267: ARRAY
39268: PUSH
39269: LD_INT 0
39271: EQUAL
39272: IFFALSE 39412
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39274: LD_ADDR_VAR 0 8
39278: PUSH
39279: LD_VAR 0 1
39283: PPUSH
39284: LD_INT 0
39286: PPUSH
39287: LD_INT 25
39289: PUSH
39290: LD_INT 3
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PPUSH
39297: CALL 12096 0 3
39301: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39302: LD_VAR 0 8
39306: PUSH
39307: LD_EXP 67
39311: PUSH
39312: LD_VAR 0 1
39316: ARRAY
39317: GREATER
39318: IFFALSE 39379
// begin for i = 1 to MREG_DefVeh [ side ] do
39320: LD_ADDR_VAR 0 4
39324: PUSH
39325: DOUBLE
39326: LD_INT 1
39328: DEC
39329: ST_TO_ADDR
39330: LD_EXP 67
39334: PUSH
39335: LD_VAR 0 1
39339: ARRAY
39340: PUSH
39341: FOR_TO
39342: IFFALSE 39375
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39344: LD_ADDR_VAR 0 12
39348: PUSH
39349: LD_VAR 0 12
39353: PPUSH
39354: LD_INT 1
39356: PPUSH
39357: LD_VAR 0 8
39361: PUSH
39362: LD_VAR 0 4
39366: ARRAY
39367: PPUSH
39368: CALL_OW 2
39372: ST_TO_ADDR
39373: GO 39341
39375: POP
39376: POP
// end else
39377: GO 39389
// tmp := k ;
39379: LD_ADDR_VAR 0 12
39383: PUSH
39384: LD_VAR 0 8
39388: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39389: LD_ADDR_EXP 70
39393: PUSH
39394: LD_EXP 70
39398: PPUSH
39399: LD_VAR 0 1
39403: PPUSH
39404: LD_INT 1
39406: PPUSH
39407: CALL_OW 1
39411: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39412: LD_ADDR_VAR 0 4
39416: PUSH
39417: LD_EXP 67
39421: PUSH
39422: LD_VAR 0 1
39426: ARRAY
39427: PUSH
39428: FOR_IN
39429: IFFALSE 39815
// begin if not GetDriver ( i ) then
39431: LD_VAR 0 4
39435: PPUSH
39436: CALL 31555 0 1
39440: NOT
39441: IFFALSE 39516
// begin if tmp then
39443: LD_VAR 0 12
39447: IFFALSE 39514
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39449: LD_VAR 0 12
39453: PUSH
39454: LD_INT 1
39456: ARRAY
39457: PPUSH
39458: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39462: LD_VAR 0 12
39466: PUSH
39467: LD_INT 1
39469: ARRAY
39470: PPUSH
39471: LD_VAR 0 4
39475: PPUSH
39476: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39480: LD_VAR 0 12
39484: PUSH
39485: LD_INT 1
39487: ARRAY
39488: PPUSH
39489: LD_INT 36
39491: PPUSH
39492: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39496: LD_ADDR_VAR 0 12
39500: PUSH
39501: LD_VAR 0 12
39505: PPUSH
39506: LD_INT 1
39508: PPUSH
39509: CALL_OW 3
39513: ST_TO_ADDR
// end ; end else
39514: GO 39813
// begin if GetTag ( i ) = 0 then
39516: LD_VAR 0 4
39520: PPUSH
39521: CALL_OW 110
39525: PUSH
39526: LD_INT 0
39528: EQUAL
39529: IFFALSE 39545
// SetTag ( i , 31 ) else
39531: LD_VAR 0 4
39535: PPUSH
39536: LD_INT 31
39538: PPUSH
39539: CALL_OW 109
39543: GO 39813
// if GetTag ( i ) = 31 then
39545: LD_VAR 0 4
39549: PPUSH
39550: CALL_OW 110
39554: PUSH
39555: LD_INT 31
39557: EQUAL
39558: IFFALSE 39813
// begin if GetFuel ( i ) < 20 then
39560: LD_VAR 0 4
39564: PPUSH
39565: CALL_OW 261
39569: PUSH
39570: LD_INT 20
39572: LESS
39573: IFFALSE 39598
// begin SetTag ( i , 21 ) ;
39575: LD_VAR 0 4
39579: PPUSH
39580: LD_INT 21
39582: PPUSH
39583: CALL_OW 109
// MCV_Refuel ( i ) ;
39587: LD_VAR 0 4
39591: PPUSH
39592: CALL 26091 0 1
// continue ;
39596: GO 39428
// end ; if GetLives ( i ) < 700 then
39598: LD_VAR 0 4
39602: PPUSH
39603: CALL_OW 256
39607: PUSH
39608: LD_INT 700
39610: LESS
39611: IFFALSE 39723
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39613: LD_VAR 0 4
39617: PPUSH
39618: LD_EXP 58
39622: PUSH
39623: LD_VAR 0 1
39627: ARRAY
39628: PPUSH
39629: CALL_OW 308
39633: NOT
39634: IFFALSE 39658
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39636: LD_VAR 0 4
39640: PPUSH
39641: LD_EXP 58
39645: PUSH
39646: LD_VAR 0 1
39650: ARRAY
39651: PPUSH
39652: CALL_OW 113
39656: GO 39721
// if GetDriver ( i ) then
39658: LD_VAR 0 4
39662: PPUSH
39663: CALL 31555 0 1
39667: IFFALSE 39721
// begin k := GetDriver ( i ) ;
39669: LD_ADDR_VAR 0 8
39673: PUSH
39674: LD_VAR 0 4
39678: PPUSH
39679: CALL 31555 0 1
39683: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39684: LD_VAR 0 8
39688: PPUSH
39689: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39693: LD_VAR 0 8
39697: PPUSH
39698: LD_VAR 0 4
39702: PPUSH
39703: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39707: LD_VAR 0 8
39711: PPUSH
39712: LD_VAR 0 4
39716: PPUSH
39717: CALL_OW 180
// end ; end else
39721: GO 39813
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39723: LD_ADDR_VAR 0 8
39727: PUSH
39728: LD_VAR 0 1
39732: PPUSH
39733: CALL 24794 0 1
39737: PPUSH
39738: LD_VAR 0 4
39742: PPUSH
39743: CALL_OW 74
39747: ST_TO_ADDR
// if k then
39748: LD_VAR 0 8
39752: IFFALSE 39770
// ComAttackUnit ( i , k ) else
39754: LD_VAR 0 4
39758: PPUSH
39759: LD_VAR 0 8
39763: PPUSH
39764: CALL_OW 115
39768: GO 39813
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39770: LD_VAR 0 4
39774: PPUSH
39775: LD_EXP 58
39779: PUSH
39780: LD_VAR 0 1
39784: ARRAY
39785: PPUSH
39786: CALL_OW 308
39790: NOT
39791: IFFALSE 39813
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39793: LD_VAR 0 4
39797: PPUSH
39798: LD_EXP 58
39802: PUSH
39803: LD_VAR 0 1
39807: ARRAY
39808: PPUSH
39809: CALL_OW 113
// end ; end ; end ; end ;
39813: GO 39428
39815: POP
39816: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39817: LD_VAR 0 1
39821: PPUSH
39822: LD_INT 30
39824: PUSH
39825: LD_INT 5
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PPUSH
39832: CALL 11393 0 2
39836: IFFALSE 40654
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39838: LD_ADDR_VAR 0 11
39842: PUSH
39843: LD_VAR 0 1
39847: PPUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 5
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PPUSH
39858: CALL 11393 0 2
39862: PUSH
39863: LD_INT 1
39865: ARRAY
39866: ST_TO_ADDR
// if eng > 1 then
39867: LD_VAR 0 14
39871: PUSH
39872: LD_INT 1
39874: GREATER
39875: IFFALSE 39922
// for i = eng downto 2 do
39877: LD_ADDR_VAR 0 4
39881: PUSH
39882: DOUBLE
39883: LD_VAR 0 14
39887: INC
39888: ST_TO_ADDR
39889: LD_INT 2
39891: PUSH
39892: FOR_DOWNTO
39893: IFFALSE 39920
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39895: LD_VAR 0 1
39899: PPUSH
39900: LD_VAR 0 14
39904: PUSH
39905: LD_VAR 0 4
39909: ARRAY
39910: PPUSH
39911: LD_INT 1
39913: PPUSH
39914: CALL 16300 0 3
39918: GO 39892
39920: POP
39921: POP
// if sci > 1 then
39922: LD_VAR 0 16
39926: PUSH
39927: LD_INT 1
39929: GREATER
39930: IFFALSE 39977
// for i = sci downto 2 do
39932: LD_ADDR_VAR 0 4
39936: PUSH
39937: DOUBLE
39938: LD_VAR 0 16
39942: INC
39943: ST_TO_ADDR
39944: LD_INT 2
39946: PUSH
39947: FOR_DOWNTO
39948: IFFALSE 39975
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39950: LD_VAR 0 1
39954: PPUSH
39955: LD_VAR 0 16
39959: PUSH
39960: LD_VAR 0 4
39964: ARRAY
39965: PPUSH
39966: LD_INT 1
39968: PPUSH
39969: CALL 16300 0 3
39973: GO 39947
39975: POP
39976: POP
// if sol then
39977: LD_VAR 0 13
39981: IFFALSE 40654
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39983: LD_VAR 0 13
39987: PUSH
39988: LD_EXP 68
39992: PUSH
39993: LD_VAR 0 1
39997: ARRAY
39998: DIFF
39999: PUSH
40000: LD_INT 22
40002: PUSH
40003: LD_VAR 0 1
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 58
40014: PUSH
40015: EMPTY
40016: LIST
40017: PUSH
40018: LD_INT 2
40020: PUSH
40021: LD_INT 30
40023: PUSH
40024: LD_INT 32
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 30
40033: PUSH
40034: LD_INT 31
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: LIST
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: LIST
40050: PPUSH
40051: CALL_OW 69
40055: PUSH
40056: LD_INT 0
40058: EQUAL
40059: AND
40060: IFFALSE 40654
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40062: LD_ADDR_VAR 0 12
40066: PUSH
40067: LD_VAR 0 13
40071: PUSH
40072: LD_EXP 68
40076: PUSH
40077: LD_VAR 0 1
40081: ARRAY
40082: DIFF
40083: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40084: LD_VAR 0 1
40088: PPUSH
40089: LD_INT 30
40091: PUSH
40092: LD_INT 5
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: PPUSH
40099: CALL 11393 0 2
40103: PUSH
40104: LD_INT 1
40106: GREATER
40107: IFFALSE 40138
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40109: LD_ADDR_VAR 0 8
40113: PUSH
40114: LD_VAR 0 1
40118: PPUSH
40119: LD_INT 30
40121: PUSH
40122: LD_INT 5
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PPUSH
40129: CALL 11393 0 2
40133: PUSH
40134: LD_INT 2
40136: ARRAY
40137: ST_TO_ADDR
// for j in tmp do
40138: LD_ADDR_VAR 0 5
40142: PUSH
40143: LD_VAR 0 12
40147: PUSH
40148: FOR_IN
40149: IFFALSE 40652
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40151: LD_VAR 0 5
40155: PUSH
40156: LD_VAR 0 11
40160: PPUSH
40161: CALL_OW 313
40165: IN
40166: PUSH
40167: LD_VAR 0 11
40171: PPUSH
40172: CALL_OW 313
40176: PUSH
40177: LD_INT 6
40179: EQUAL
40180: AND
40181: PUSH
40182: LD_VAR 0 8
40186: AND
40187: PUSH
40188: LD_VAR 0 8
40192: PPUSH
40193: CALL_OW 313
40197: PUSH
40198: LD_INT 6
40200: LESS
40201: AND
40202: IFFALSE 40229
// begin ComExitBuilding ( j ) ;
40204: LD_VAR 0 5
40208: PPUSH
40209: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40213: LD_VAR 0 5
40217: PPUSH
40218: LD_VAR 0 8
40222: PPUSH
40223: CALL_OW 180
// continue ;
40227: GO 40148
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40229: LD_VAR 0 5
40233: PPUSH
40234: CALL_OW 314
40238: NOT
40239: PUSH
40240: LD_VAR 0 5
40244: PPUSH
40245: CALL_OW 110
40249: PUSH
40250: LD_INT 0
40252: EQUAL
40253: AND
40254: PUSH
40255: LD_VAR 0 5
40259: PPUSH
40260: CALL_OW 310
40264: NOT
40265: AND
40266: IFFALSE 40372
// begin if k then
40268: LD_VAR 0 8
40272: IFFALSE 40343
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40274: LD_VAR 0 8
40278: PPUSH
40279: CALL_OW 313
40283: PUSH
40284: LD_VAR 0 11
40288: PPUSH
40289: CALL_OW 313
40293: LESS
40294: IFFALSE 40312
// ComEnterUnit ( j , k ) else
40296: LD_VAR 0 5
40300: PPUSH
40301: LD_VAR 0 8
40305: PPUSH
40306: CALL_OW 120
40310: GO 40341
// if UnitsInside ( b ) < 6 then
40312: LD_VAR 0 11
40316: PPUSH
40317: CALL_OW 313
40321: PUSH
40322: LD_INT 6
40324: LESS
40325: IFFALSE 40341
// ComEnterUnit ( j , b ) ;
40327: LD_VAR 0 5
40331: PPUSH
40332: LD_VAR 0 11
40336: PPUSH
40337: CALL_OW 120
// end else
40341: GO 40372
// if UnitsInside ( b ) < 6 then
40343: LD_VAR 0 11
40347: PPUSH
40348: CALL_OW 313
40352: PUSH
40353: LD_INT 6
40355: LESS
40356: IFFALSE 40372
// ComEnterUnit ( j , b ) ;
40358: LD_VAR 0 5
40362: PPUSH
40363: LD_VAR 0 11
40367: PPUSH
40368: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40372: LD_VAR 0 5
40376: PUSH
40377: LD_VAR 0 1
40381: PPUSH
40382: LD_INT 54
40384: PUSH
40385: EMPTY
40386: LIST
40387: PPUSH
40388: CALL 11393 0 2
40392: IN
40393: PUSH
40394: LD_VAR 0 5
40398: PPUSH
40399: CALL_OW 257
40403: PUSH
40404: LD_INT 1
40406: EQUAL
40407: AND
40408: IFFALSE 40650
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40410: LD_EXP 62
40414: PUSH
40415: LD_VAR 0 1
40419: ARRAY
40420: PUSH
40421: LD_INT 1
40423: ARRAY
40424: PUSH
40425: LD_INT 12
40427: PPUSH
40428: LD_VAR 0 1
40432: PPUSH
40433: CALL_OW 321
40437: PUSH
40438: LD_INT 2
40440: EQUAL
40441: AND
40442: IFFALSE 40490
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40444: LD_VAR 0 1
40448: PPUSH
40449: LD_INT 5
40451: PPUSH
40452: EMPTY
40453: PPUSH
40454: CALL 11476 0 3
40458: PUSH
40459: LD_EXP 62
40463: PUSH
40464: LD_VAR 0 1
40468: ARRAY
40469: PUSH
40470: LD_INT 1
40472: ARRAY
40473: LESS
40474: IFFALSE 40490
// begin SetClass ( j , class_sniper ) ;
40476: LD_VAR 0 5
40480: PPUSH
40481: LD_INT 5
40483: PPUSH
40484: CALL_OW 336
// continue ;
40488: GO 40148
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40490: LD_EXP 62
40494: PUSH
40495: LD_VAR 0 1
40499: ARRAY
40500: PUSH
40501: LD_INT 2
40503: ARRAY
40504: PUSH
40505: LD_INT 41
40507: PPUSH
40508: LD_VAR 0 1
40512: PPUSH
40513: CALL_OW 321
40517: PUSH
40518: LD_INT 2
40520: EQUAL
40521: AND
40522: IFFALSE 40570
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40524: LD_VAR 0 1
40528: PPUSH
40529: LD_INT 8
40531: PPUSH
40532: EMPTY
40533: PPUSH
40534: CALL 11476 0 3
40538: PUSH
40539: LD_EXP 62
40543: PUSH
40544: LD_VAR 0 1
40548: ARRAY
40549: PUSH
40550: LD_INT 2
40552: ARRAY
40553: LESS
40554: IFFALSE 40570
// begin SetClass ( j , class_mortar ) ;
40556: LD_VAR 0 5
40560: PPUSH
40561: LD_INT 8
40563: PPUSH
40564: CALL_OW 336
// continue ;
40568: GO 40148
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40570: LD_EXP 62
40574: PUSH
40575: LD_VAR 0 1
40579: ARRAY
40580: PUSH
40581: LD_INT 3
40583: ARRAY
40584: PUSH
40585: LD_INT 44
40587: PPUSH
40588: LD_VAR 0 1
40592: PPUSH
40593: CALL_OW 321
40597: PUSH
40598: LD_INT 2
40600: EQUAL
40601: AND
40602: IFFALSE 40650
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40604: LD_VAR 0 1
40608: PPUSH
40609: LD_INT 9
40611: PPUSH
40612: EMPTY
40613: PPUSH
40614: CALL 11476 0 3
40618: PUSH
40619: LD_EXP 62
40623: PUSH
40624: LD_VAR 0 1
40628: ARRAY
40629: PUSH
40630: LD_INT 3
40632: ARRAY
40633: LESS
40634: IFFALSE 40650
// begin SetClass ( j , class_bazooker ) ;
40636: LD_VAR 0 5
40640: PPUSH
40641: LD_INT 9
40643: PPUSH
40644: CALL_OW 336
// continue ;
40648: GO 40148
// end ; end ; end ;
40650: GO 40148
40652: POP
40653: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40654: LD_INT 22
40656: PUSH
40657: LD_VAR 0 1
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PUSH
40666: LD_INT 58
40668: PUSH
40669: EMPTY
40670: LIST
40671: PUSH
40672: LD_INT 30
40674: PUSH
40675: LD_INT 32
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: LIST
40686: PPUSH
40687: CALL_OW 69
40691: IFFALSE 40841
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40693: LD_ADDR_VAR 0 12
40697: PUSH
40698: LD_INT 22
40700: PUSH
40701: LD_VAR 0 1
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 58
40712: PUSH
40713: EMPTY
40714: LIST
40715: PUSH
40716: LD_INT 30
40718: PUSH
40719: LD_INT 32
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: LIST
40730: PPUSH
40731: CALL_OW 69
40735: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40736: LD_ADDR_VAR 0 8
40740: PUSH
40741: LD_VAR 0 13
40745: PUSH
40746: LD_EXP 68
40750: PUSH
40751: LD_VAR 0 1
40755: ARRAY
40756: DIFF
40757: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40758: LD_VAR 0 12
40762: PUSH
40763: LD_INT 1
40765: ARRAY
40766: PPUSH
40767: CALL_OW 461
40771: PUSH
40772: LD_INT 2
40774: EQUAL
40775: PUSH
40776: LD_VAR 0 12
40780: PUSH
40781: LD_INT 1
40783: ARRAY
40784: PUSH
40785: LD_EXP 68
40789: PUSH
40790: LD_VAR 0 1
40794: ARRAY
40795: IN
40796: NOT
40797: AND
40798: PUSH
40799: LD_VAR 0 8
40803: AND
40804: IFFALSE 40841
// begin ComExitBuilding ( k [ 1 ] ) ;
40806: LD_VAR 0 8
40810: PUSH
40811: LD_INT 1
40813: ARRAY
40814: PPUSH
40815: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40819: LD_VAR 0 8
40823: PUSH
40824: LD_INT 1
40826: ARRAY
40827: PPUSH
40828: LD_VAR 0 12
40832: PUSH
40833: LD_INT 1
40835: ARRAY
40836: PPUSH
40837: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40841: LD_EXP 35
40845: PUSH
40846: LD_VAR 0 1
40850: ARRAY
40851: IFFALSE 40999
// begin if MCF_Class ( side , 4 , [ ] ) then
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11476 0 3
40867: IFFALSE 40997
// for j in MCF_Class ( side , 4 , [ ] ) do
40869: LD_ADDR_VAR 0 5
40873: PUSH
40874: LD_VAR 0 1
40878: PPUSH
40879: LD_INT 4
40881: PPUSH
40882: EMPTY
40883: PPUSH
40884: CALL 11476 0 3
40888: PUSH
40889: FOR_IN
40890: IFFALSE 40995
// begin if not GetTag ( j ) = 4 then
40892: LD_VAR 0 5
40896: PPUSH
40897: CALL_OW 110
40901: PUSH
40902: LD_INT 4
40904: EQUAL
40905: NOT
40906: IFFALSE 40942
// begin SetTag ( j , 4 ) ;
40908: LD_VAR 0 5
40912: PPUSH
40913: LD_INT 4
40915: PPUSH
40916: CALL_OW 109
// if IsInUnit ( j ) then
40920: LD_VAR 0 5
40924: PPUSH
40925: CALL_OW 310
40929: IFFALSE 40940
// ComExitBuilding ( j ) ;
40931: LD_VAR 0 5
40935: PPUSH
40936: CALL_OW 122
// end else
40940: GO 40993
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40942: LD_VAR 0 5
40946: PPUSH
40947: LD_EXP 35
40951: PUSH
40952: LD_VAR 0 1
40956: ARRAY
40957: PUSH
40958: LD_INT 1
40960: ARRAY
40961: PPUSH
40962: CALL 32246 0 2
40966: NOT
40967: IFFALSE 40993
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40969: LD_VAR 0 5
40973: PPUSH
40974: LD_EXP 35
40978: PUSH
40979: LD_VAR 0 1
40983: ARRAY
40984: PUSH
40985: LD_INT 1
40987: ARRAY
40988: PPUSH
40989: CALL 18963 0 2
// end ;
40993: GO 40889
40995: POP
40996: POP
// end else
40997: GO 41231
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40999: LD_VAR 0 1
41003: PPUSH
41004: LD_INT 4
41006: PPUSH
41007: EMPTY
41008: PPUSH
41009: CALL 11476 0 3
41013: PUSH
41014: LD_VAR 0 1
41018: PPUSH
41019: LD_INT 4
41021: PPUSH
41022: EMPTY
41023: PPUSH
41024: CALL 12096 0 3
41028: AND
41029: IFFALSE 41231
// for j in MCF_Class ( side , 4 , [ ] ) do
41031: LD_ADDR_VAR 0 5
41035: PUSH
41036: LD_VAR 0 1
41040: PPUSH
41041: LD_INT 4
41043: PPUSH
41044: EMPTY
41045: PPUSH
41046: CALL 11476 0 3
41050: PUSH
41051: FOR_IN
41052: IFFALSE 41229
// begin if GetTag ( j ) = 4 then
41054: LD_VAR 0 5
41058: PPUSH
41059: CALL_OW 110
41063: PUSH
41064: LD_INT 4
41066: EQUAL
41067: IFFALSE 41227
// begin SetTag ( j , 0 ) ;
41069: LD_VAR 0 5
41073: PPUSH
41074: LD_INT 0
41076: PPUSH
41077: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41081: LD_VAR 0 1
41085: PPUSH
41086: CALL 11432 0 1
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: CALL 17776 0 1
41100: NOT
41101: AND
41102: IFFALSE 41127
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41104: LD_VAR 0 5
41108: PPUSH
41109: LD_VAR 0 1
41113: PPUSH
41114: CALL 11432 0 1
41118: PUSH
41119: LD_INT 1
41121: ARRAY
41122: PPUSH
41123: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41127: LD_VAR 0 1
41131: PPUSH
41132: CALL 11432 0 1
41136: NOT
41137: PUSH
41138: LD_VAR 0 1
41142: PPUSH
41143: LD_INT 30
41145: PUSH
41146: LD_INT 1
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PPUSH
41153: CALL 11393 0 2
41157: AND
41158: IFFALSE 41227
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41160: LD_VAR 0 5
41164: PPUSH
41165: LD_VAR 0 1
41169: PPUSH
41170: LD_INT 30
41172: PUSH
41173: LD_INT 1
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PPUSH
41180: CALL 11393 0 2
41184: PUSH
41185: LD_INT 1
41187: ARRAY
41188: PPUSH
41189: CALL_OW 250
41193: PPUSH
41194: LD_VAR 0 1
41198: PPUSH
41199: LD_INT 30
41201: PUSH
41202: LD_INT 1
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PPUSH
41209: CALL 11393 0 2
41213: PUSH
41214: LD_INT 1
41216: ARRAY
41217: PPUSH
41218: CALL_OW 251
41222: PPUSH
41223: CALL_OW 111
// end ; end ;
41227: GO 41051
41229: POP
41230: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41231: LD_VAR 0 1
41235: PPUSH
41236: LD_INT 3
41238: PPUSH
41239: EMPTY
41240: PPUSH
41241: CALL 11476 0 3
41245: PUSH
41246: LD_EXP 58
41250: PUSH
41251: LD_VAR 0 1
41255: ARRAY
41256: AND
41257: PUSH
41258: LD_VAR 0 1
41262: PPUSH
41263: LD_INT 6
41265: PPUSH
41266: EMPTY
41267: PPUSH
41268: CALL 12096 0 3
41272: AND
41273: IFFALSE 41804
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41275: LD_ADDR_VAR 0 6
41279: PUSH
41280: LD_EXP 58
41284: PUSH
41285: LD_VAR 0 1
41289: ARRAY
41290: PPUSH
41291: LD_INT 0
41293: PPUSH
41294: CALL_OW 517
41298: PUSH
41299: LD_INT 1
41301: ARRAY
41302: PUSH
41303: LD_INT 1
41305: ARRAY
41306: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41307: LD_ADDR_VAR 0 7
41311: PUSH
41312: LD_EXP 58
41316: PUSH
41317: LD_VAR 0 1
41321: ARRAY
41322: PPUSH
41323: LD_INT 0
41325: PPUSH
41326: CALL_OW 517
41330: PUSH
41331: LD_INT 2
41333: ARRAY
41334: PUSH
41335: LD_INT 1
41337: ARRAY
41338: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41339: LD_VAR 0 1
41343: PPUSH
41344: LD_INT 6
41346: PPUSH
41347: EMPTY
41348: PPUSH
41349: CALL 12096 0 3
41353: IFFALSE 41802
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41355: LD_ADDR_VAR 0 8
41359: PUSH
41360: LD_VAR 0 1
41364: PPUSH
41365: LD_INT 6
41367: PPUSH
41368: EMPTY
41369: PPUSH
41370: CALL 12096 0 3
41374: PUSH
41375: FOR_IN
41376: IFFALSE 41407
// if GetLives ( k ) = 1000 then
41378: LD_VAR 0 8
41382: PPUSH
41383: CALL_OW 256
41387: PUSH
41388: LD_INT 1000
41390: EQUAL
41391: IFFALSE 41405
// SetTag ( k , 0 ) ;
41393: LD_VAR 0 8
41397: PPUSH
41398: LD_INT 0
41400: PPUSH
41401: CALL_OW 109
41405: GO 41375
41407: POP
41408: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41409: LD_VAR 0 1
41413: PPUSH
41414: LD_INT 0
41416: PPUSH
41417: LD_INT 25
41419: PUSH
41420: LD_INT 3
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PPUSH
41427: CALL 12096 0 3
41431: IFFALSE 41495
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41433: LD_ADDR_VAR 0 8
41437: PUSH
41438: LD_VAR 0 4
41442: PPUSH
41443: LD_INT 0
41445: PPUSH
41446: LD_INT 25
41448: PUSH
41449: LD_INT 3
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PPUSH
41456: CALL 12096 0 3
41460: PUSH
41461: FOR_IN
41462: IFFALSE 41493
// if GetTag ( k ) = 0 then
41464: LD_VAR 0 8
41468: PPUSH
41469: CALL_OW 110
41473: PUSH
41474: LD_INT 0
41476: EQUAL
41477: IFFALSE 41491
// begin SetTag ( k , 8 ) ;
41479: LD_VAR 0 8
41483: PPUSH
41484: LD_INT 8
41486: PPUSH
41487: CALL_OW 109
// end ;
41491: GO 41461
41493: POP
41494: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41495: LD_VAR 0 1
41499: PPUSH
41500: LD_INT 6
41502: PPUSH
41503: LD_INT 92
41505: PUSH
41506: LD_VAR 0 6
41510: PUSH
41511: LD_VAR 0 7
41515: PUSH
41516: LD_INT 10
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: PPUSH
41525: CALL 12096 0 3
41529: IFFALSE 41653
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41531: LD_ADDR_VAR 0 5
41535: PUSH
41536: LD_VAR 0 4
41540: PPUSH
41541: LD_INT 6
41543: PPUSH
41544: LD_INT 92
41546: PUSH
41547: LD_VAR 0 6
41551: PUSH
41552: LD_VAR 0 7
41556: PUSH
41557: LD_INT 10
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: PPUSH
41566: CALL 12096 0 3
41570: PUSH
41571: FOR_IN
41572: IFFALSE 41651
// begin if not HasTask ( j ) and GetDriver ( j ) then
41574: LD_VAR 0 5
41578: PPUSH
41579: CALL_OW 314
41583: NOT
41584: PUSH
41585: LD_VAR 0 5
41589: PPUSH
41590: CALL 31555 0 1
41594: AND
41595: IFFALSE 41649
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41597: LD_VAR 0 5
41601: PPUSH
41602: CALL 31555 0 1
41606: PPUSH
41607: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41611: LD_VAR 0 5
41615: PPUSH
41616: CALL 31555 0 1
41620: PPUSH
41621: LD_VAR 0 5
41625: PPUSH
41626: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41630: LD_VAR 0 5
41634: PPUSH
41635: CALL 31555 0 1
41639: PPUSH
41640: LD_VAR 0 5
41644: PPUSH
41645: CALL_OW 180
// end ; end ;
41649: GO 41571
41651: POP
41652: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41653: LD_VAR 0 1
41657: PPUSH
41658: LD_INT 6
41660: PPUSH
41661: LD_INT 92
41663: PUSH
41664: LD_VAR 0 6
41668: PUSH
41669: LD_VAR 0 7
41673: PUSH
41674: LD_INT 10
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: PPUSH
41683: CALL 12096 0 3
41687: PUSH
41688: LD_VAR 0 1
41692: PPUSH
41693: LD_INT 8
41695: PPUSH
41696: EMPTY
41697: PPUSH
41698: CALL 12096 0 3
41702: AND
41703: IFFALSE 41802
// for j in MCF_Tag ( side , 8 , [ ] ) do
41705: LD_ADDR_VAR 0 5
41709: PUSH
41710: LD_VAR 0 1
41714: PPUSH
41715: LD_INT 8
41717: PPUSH
41718: EMPTY
41719: PPUSH
41720: CALL 12096 0 3
41724: PUSH
41725: FOR_IN
41726: IFFALSE 41800
// begin if IsInUnit ( j ) then
41728: LD_VAR 0 5
41732: PPUSH
41733: CALL_OW 310
41737: IFFALSE 41750
// ComExitBuilding ( j ) else
41739: LD_VAR 0 5
41743: PPUSH
41744: CALL_OW 122
41748: GO 41798
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41750: LD_VAR 0 5
41754: PPUSH
41755: LD_VAR 0 1
41759: PPUSH
41760: LD_INT 6
41762: PPUSH
41763: LD_INT 92
41765: PUSH
41766: LD_VAR 0 6
41770: PUSH
41771: LD_VAR 0 7
41775: PUSH
41776: LD_INT 10
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: PPUSH
41785: CALL 12096 0 3
41789: PUSH
41790: LD_INT 1
41792: ARRAY
41793: PPUSH
41794: CALL_OW 129
// end ;
41798: GO 41725
41800: POP
41801: POP
// end ; end else
41802: GO 41859
// if MCF_Tag ( side , 8 , [ ] ) then
41804: LD_VAR 0 1
41808: PPUSH
41809: LD_INT 8
41811: PPUSH
41812: EMPTY
41813: PPUSH
41814: CALL 12096 0 3
41818: IFFALSE 41859
// for k in MCF_Tag ( side , 8 , [ ] ) do
41820: LD_ADDR_VAR 0 8
41824: PUSH
41825: LD_VAR 0 1
41829: PPUSH
41830: LD_INT 8
41832: PPUSH
41833: EMPTY
41834: PPUSH
41835: CALL 12096 0 3
41839: PUSH
41840: FOR_IN
41841: IFFALSE 41857
// SetTag ( k , 0 ) ;
41843: LD_VAR 0 8
41847: PPUSH
41848: LD_INT 0
41850: PPUSH
41851: CALL_OW 109
41855: GO 41840
41857: POP
41858: POP
// end ; end_of_file
41859: LD_VAR 0 3
41863: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41864: LD_INT 0
41866: PPUSH
// MREG_Game := [ ] ;
41867: LD_ADDR_EXP 33
41871: PUSH
41872: EMPTY
41873: ST_TO_ADDR
// MREG_Crates := [ ] ;
41874: LD_ADDR_EXP 34
41878: PUSH
41879: EMPTY
41880: ST_TO_ADDR
// MREG_Heal := [ ] ;
41881: LD_ADDR_EXP 35
41885: PUSH
41886: EMPTY
41887: ST_TO_ADDR
// MREG_Tame := [ ] ;
41888: LD_ADDR_EXP 37
41892: PUSH
41893: EMPTY
41894: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41895: LD_ADDR_EXP 38
41899: PUSH
41900: EMPTY
41901: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41902: LD_ADDR_EXP 39
41906: PUSH
41907: EMPTY
41908: ST_TO_ADDR
// MREG_LabList := [ ] ;
41909: LD_ADDR_EXP 40
41913: PUSH
41914: EMPTY
41915: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41916: LD_ADDR_EXP 41
41920: PUSH
41921: EMPTY
41922: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41923: LD_ADDR_EXP 42
41927: PUSH
41928: EMPTY
41929: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41930: LD_ADDR_EXP 43
41934: PUSH
41935: EMPTY
41936: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41937: LD_ADDR_EXP 44
41941: PUSH
41942: EMPTY
41943: ST_TO_ADDR
// MREG_Status := [ ] ;
41944: LD_ADDR_EXP 45
41948: PUSH
41949: EMPTY
41950: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41951: LD_ADDR_EXP 46
41955: PUSH
41956: EMPTY
41957: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41958: LD_ADDR_EXP 47
41962: PUSH
41963: EMPTY
41964: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41965: LD_ADDR_EXP 48
41969: PUSH
41970: EMPTY
41971: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41972: LD_ADDR_EXP 49
41976: PUSH
41977: EMPTY
41978: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41979: LD_ADDR_EXP 50
41983: PUSH
41984: EMPTY
41985: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41986: LD_ADDR_EXP 51
41990: PUSH
41991: EMPTY
41992: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41993: LD_ADDR_EXP 52
41997: PUSH
41998: EMPTY
41999: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42000: LD_ADDR_EXP 53
42004: PUSH
42005: EMPTY
42006: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42007: LD_ADDR_EXP 54
42011: PUSH
42012: EMPTY
42013: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42014: LD_ADDR_EXP 55
42018: PUSH
42019: EMPTY
42020: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42021: LD_ADDR_EXP 56
42025: PUSH
42026: EMPTY
42027: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42028: LD_ADDR_EXP 57
42032: PUSH
42033: EMPTY
42034: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42035: LD_ADDR_EXP 61
42039: PUSH
42040: EMPTY
42041: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42042: LD_ADDR_EXP 62
42046: PUSH
42047: EMPTY
42048: ST_TO_ADDR
// MREG_Parking := [ ] ;
42049: LD_ADDR_EXP 58
42053: PUSH
42054: EMPTY
42055: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42056: LD_ADDR_EXP 59
42060: PUSH
42061: EMPTY
42062: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42063: LD_ADDR_EXP 63
42067: PUSH
42068: EMPTY
42069: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42070: LD_ADDR_EXP 64
42074: PUSH
42075: EMPTY
42076: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42077: LD_ADDR_EXP 65
42081: PUSH
42082: EMPTY
42083: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42084: LD_ADDR_EXP 67
42088: PUSH
42089: EMPTY
42090: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42091: LD_ADDR_EXP 68
42095: PUSH
42096: EMPTY
42097: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42098: LD_ADDR_EXP 69
42102: PUSH
42103: EMPTY
42104: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42105: LD_ADDR_EXP 71
42109: PUSH
42110: EMPTY
42111: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42112: LD_ADDR_EXP 70
42116: PUSH
42117: EMPTY
42118: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42119: LD_ADDR_EXP 72
42123: PUSH
42124: LD_INT 300
42126: PUSH
42127: LD_INT 100
42129: PUSH
42130: LD_INT 25
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: LIST
42137: ST_TO_ADDR
// end ;
42138: LD_VAR 0 1
42142: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42143: LD_INT 0
42145: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42146: LD_VAR 0 2
42150: PUSH
42151: LD_VAR 0 3
42155: PUSH
42156: LD_VAR 0 4
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: LIST
42165: PUSH
42166: LD_VAR 0 1
42170: IN
42171: IFFALSE 42185
// result := mreg_list else
42173: LD_ADDR_VAR 0 5
42177: PUSH
42178: LD_VAR 0 1
42182: ST_TO_ADDR
42183: GO 42219
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42185: LD_ADDR_VAR 0 1
42189: PUSH
42190: LD_VAR 0 1
42194: PUSH
42195: LD_VAR 0 2
42199: PUSH
42200: LD_VAR 0 3
42204: PUSH
42205: LD_VAR 0 4
42209: PUSH
42210: EMPTY
42211: LIST
42212: LIST
42213: LIST
42214: PUSH
42215: EMPTY
42216: LIST
42217: ADD
42218: ST_TO_ADDR
// result := mreg_list ;
42219: LD_ADDR_VAR 0 5
42223: PUSH
42224: LD_VAR 0 1
42228: ST_TO_ADDR
// end ;
42229: LD_VAR 0 5
42233: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42234: LD_INT 0
42236: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42237: LD_VAR 0 2
42241: PUSH
42242: LD_VAR 0 3
42246: PUSH
42247: LD_VAR 0 4
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: LD_VAR 0 1
42261: IN
42262: IFFALSE 42300
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42264: LD_ADDR_VAR 0 5
42268: PUSH
42269: LD_VAR 0 1
42273: PUSH
42274: LD_VAR 0 2
42278: PUSH
42279: LD_VAR 0 3
42283: PUSH
42284: LD_VAR 0 4
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: LIST
42293: PUSH
42294: EMPTY
42295: LIST
42296: DIFF
42297: ST_TO_ADDR
42298: GO 42310
// result := mreg_list ;
42300: LD_ADDR_VAR 0 5
42304: PUSH
42305: LD_VAR 0 1
42309: ST_TO_ADDR
// end ;
42310: LD_VAR 0 5
42314: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42315: LD_INT 0
42317: PPUSH
42318: PPUSH
42319: PPUSH
// for j = 1 to 8 do
42320: LD_ADDR_VAR 0 3
42324: PUSH
42325: DOUBLE
42326: LD_INT 1
42328: DEC
42329: ST_TO_ADDR
42330: LD_INT 8
42332: PUSH
42333: FOR_TO
42334: IFFALSE 43175
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_INT 51
42343: PUSH
42344: EMPTY
42345: LIST
42346: PPUSH
42347: CALL 11393 0 2
42351: PUSH
42352: LD_OWVAR 2
42356: PUSH
42357: LD_VAR 0 3
42361: EQUAL
42362: NOT
42363: AND
42364: IFFALSE 42382
// MREG_SidesList := MREG_SidesList ^ 1 else
42366: LD_ADDR_EXP 39
42370: PUSH
42371: LD_EXP 39
42375: PUSH
42376: LD_INT 1
42378: ADD
42379: ST_TO_ADDR
42380: GO 42396
// MREG_SidesList := MREG_SidesList ^ 0 ;
42382: LD_ADDR_EXP 39
42386: PUSH
42387: LD_EXP 39
42391: PUSH
42392: LD_INT 0
42394: ADD
42395: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42396: LD_VAR 0 3
42400: PPUSH
42401: LD_INT 2
42403: PUSH
42404: LD_INT 34
42406: PUSH
42407: LD_INT 12
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 34
42416: PUSH
42417: LD_INT 32
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 34
42426: PUSH
42427: LD_INT 51
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: PUSH
42440: EMPTY
42441: LIST
42442: PPUSH
42443: CALL 11694 0 2
42447: IFFALSE 42548
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42449: LD_ADDR_VAR 0 2
42453: PUSH
42454: LD_VAR 0 3
42458: PPUSH
42459: LD_INT 2
42461: PUSH
42462: LD_INT 34
42464: PUSH
42465: LD_INT 12
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 34
42474: PUSH
42475: LD_INT 32
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 34
42484: PUSH
42485: LD_INT 51
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: LIST
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PPUSH
42501: CALL 11694 0 2
42505: PUSH
42506: FOR_IN
42507: IFFALSE 42546
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42509: LD_ADDR_EXP 41
42513: PUSH
42514: LD_EXP 41
42518: PPUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_VAR 0 2
42528: PPUSH
42529: LD_VAR 0 2
42533: PPUSH
42534: CALL_OW 264
42538: PPUSH
42539: CALL 42143 0 4
42543: ST_TO_ADDR
42544: GO 42506
42546: POP
42547: POP
// if MCF_Class ( j , 4 , [ ] ) then
42548: LD_VAR 0 3
42552: PPUSH
42553: LD_INT 4
42555: PPUSH
42556: EMPTY
42557: PPUSH
42558: CALL 11476 0 3
42562: IFFALSE 42595
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42564: LD_ADDR_EXP 54
42568: PUSH
42569: LD_EXP 54
42573: PUSH
42574: LD_VAR 0 3
42578: PPUSH
42579: LD_INT 4
42581: PPUSH
42582: EMPTY
42583: PPUSH
42584: CALL 11476 0 3
42588: PUSH
42589: EMPTY
42590: LIST
42591: ADD
42592: ST_TO_ADDR
42593: GO 42612
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42595: LD_ADDR_EXP 54
42599: PUSH
42600: LD_EXP 54
42604: PUSH
42605: LD_INT 0
42607: PUSH
42608: EMPTY
42609: LIST
42610: ADD
42611: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42612: LD_VAR 0 3
42616: PPUSH
42617: LD_INT 3
42619: PPUSH
42620: EMPTY
42621: PPUSH
42622: CALL 11476 0 3
42626: IFFALSE 42659
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42628: LD_ADDR_EXP 55
42632: PUSH
42633: LD_EXP 55
42637: PUSH
42638: LD_VAR 0 3
42642: PPUSH
42643: LD_INT 3
42645: PPUSH
42646: EMPTY
42647: PPUSH
42648: CALL 11476 0 3
42652: PUSH
42653: EMPTY
42654: LIST
42655: ADD
42656: ST_TO_ADDR
42657: GO 42676
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42659: LD_ADDR_EXP 55
42663: PUSH
42664: LD_EXP 55
42668: PUSH
42669: LD_INT 0
42671: PUSH
42672: EMPTY
42673: LIST
42674: ADD
42675: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42676: LD_VAR 0 3
42680: PPUSH
42681: LD_INT 1
42683: PPUSH
42684: EMPTY
42685: PPUSH
42686: CALL 11476 0 3
42690: IFFALSE 42723
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42692: LD_ADDR_EXP 56
42696: PUSH
42697: LD_EXP 56
42701: PUSH
42702: LD_VAR 0 3
42706: PPUSH
42707: LD_INT 1
42709: PPUSH
42710: EMPTY
42711: PPUSH
42712: CALL 11476 0 3
42716: PUSH
42717: EMPTY
42718: LIST
42719: ADD
42720: ST_TO_ADDR
42721: GO 42740
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42723: LD_ADDR_EXP 56
42727: PUSH
42728: LD_EXP 56
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: EMPTY
42737: LIST
42738: ADD
42739: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42740: LD_VAR 0 3
42744: PPUSH
42745: LD_INT 2
42747: PPUSH
42748: EMPTY
42749: PPUSH
42750: CALL 11476 0 3
42754: IFFALSE 42787
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42756: LD_ADDR_EXP 57
42760: PUSH
42761: LD_EXP 57
42765: PUSH
42766: LD_VAR 0 3
42770: PPUSH
42771: LD_INT 2
42773: PPUSH
42774: EMPTY
42775: PPUSH
42776: CALL 11476 0 3
42780: PUSH
42781: EMPTY
42782: LIST
42783: ADD
42784: ST_TO_ADDR
42785: GO 42804
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42787: LD_ADDR_EXP 57
42791: PUSH
42792: LD_EXP 57
42796: PUSH
42797: LD_INT 0
42799: PUSH
42800: EMPTY
42801: LIST
42802: ADD
42803: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42804: LD_ADDR_EXP 47
42808: PUSH
42809: LD_EXP 47
42813: PUSH
42814: LD_INT 0
42816: PUSH
42817: EMPTY
42818: LIST
42819: ADD
42820: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42821: LD_ADDR_EXP 35
42825: PUSH
42826: LD_EXP 35
42830: PUSH
42831: LD_INT 0
42833: PUSH
42834: EMPTY
42835: LIST
42836: ADD
42837: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42838: LD_ADDR_EXP 37
42842: PUSH
42843: LD_EXP 37
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: ADD
42854: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42855: LD_ADDR_EXP 58
42859: PUSH
42860: LD_EXP 58
42864: PUSH
42865: LD_INT 0
42867: PUSH
42868: EMPTY
42869: LIST
42870: ADD
42871: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42872: LD_ADDR_EXP 59
42876: PUSH
42877: LD_EXP 59
42881: PUSH
42882: LD_INT 0
42884: PUSH
42885: EMPTY
42886: LIST
42887: ADD
42888: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42889: LD_ADDR_EXP 51
42893: PUSH
42894: LD_EXP 51
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: EMPTY
42903: LIST
42904: ADD
42905: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42906: LD_ADDR_EXP 38
42910: PUSH
42911: LD_EXP 38
42915: PUSH
42916: LD_INT 0
42918: PUSH
42919: LD_INT 0
42921: PUSH
42922: LD_INT 0
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: LIST
42933: PUSH
42934: EMPTY
42935: LIST
42936: ADD
42937: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42938: LD_ADDR_EXP 60
42942: PUSH
42943: LD_EXP 60
42947: PUSH
42948: LD_INT 0
42950: PUSH
42951: EMPTY
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: EMPTY
42958: LIST
42959: ADD
42960: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42961: LD_ADDR_EXP 61
42965: PUSH
42966: LD_EXP 61
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: EMPTY
42975: LIST
42976: PUSH
42977: EMPTY
42978: LIST
42979: ADD
42980: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42981: LD_ADDR_EXP 42
42985: PUSH
42986: LD_EXP 42
42990: PUSH
42991: LD_INT 0
42993: PUSH
42994: EMPTY
42995: LIST
42996: ADD
42997: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42998: LD_ADDR_EXP 63
43002: PUSH
43003: LD_EXP 63
43007: PUSH
43008: LD_INT 0
43010: PUSH
43011: EMPTY
43012: LIST
43013: ADD
43014: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43015: LD_ADDR_EXP 64
43019: PUSH
43020: LD_EXP 64
43024: PUSH
43025: LD_INT 0
43027: PUSH
43028: EMPTY
43029: LIST
43030: ADD
43031: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43032: LD_ADDR_EXP 65
43036: PUSH
43037: LD_EXP 65
43041: PUSH
43042: LD_INT 0
43044: PUSH
43045: EMPTY
43046: LIST
43047: ADD
43048: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43049: LD_ADDR_EXP 66
43053: PUSH
43054: LD_EXP 66
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: EMPTY
43063: LIST
43064: ADD
43065: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43066: LD_ADDR_EXP 67
43070: PUSH
43071: LD_EXP 67
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: ADD
43082: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43083: LD_ADDR_EXP 68
43087: PUSH
43088: LD_EXP 68
43092: PUSH
43093: LD_INT 0
43095: PUSH
43096: EMPTY
43097: LIST
43098: ADD
43099: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43100: LD_ADDR_EXP 69
43104: PUSH
43105: LD_EXP 69
43109: PUSH
43110: LD_INT 0
43112: PUSH
43113: EMPTY
43114: LIST
43115: ADD
43116: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43117: LD_ADDR_EXP 71
43121: PUSH
43122: LD_EXP 71
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: EMPTY
43131: LIST
43132: ADD
43133: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43134: LD_ADDR_EXP 70
43138: PUSH
43139: LD_EXP 70
43143: PUSH
43144: LD_INT 0
43146: ADD
43147: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43148: LD_ADDR_EXP 62
43152: PUSH
43153: LD_EXP 62
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: LD_INT 0
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: LIST
43171: ADD
43172: ST_TO_ADDR
// end ;
43173: GO 42333
43175: POP
43176: POP
// end ;
43177: LD_VAR 0 1
43181: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43182: LD_INT 0
43184: PPUSH
43185: PPUSH
43186: PPUSH
// m := false ;
43187: LD_ADDR_VAR 0 5
43191: PUSH
43192: LD_INT 0
43194: ST_TO_ADDR
// for i = 1 to mreg do
43195: LD_ADDR_VAR 0 4
43199: PUSH
43200: DOUBLE
43201: LD_INT 1
43203: DEC
43204: ST_TO_ADDR
43205: LD_VAR 0 2
43209: PUSH
43210: FOR_TO
43211: IFFALSE 43247
// if mreg [ i ] [ 1 ] = side then
43213: LD_VAR 0 2
43217: PUSH
43218: LD_VAR 0 4
43222: ARRAY
43223: PUSH
43224: LD_INT 1
43226: ARRAY
43227: PUSH
43228: LD_VAR 0 1
43232: EQUAL
43233: IFFALSE 43245
// begin m := true ;
43235: LD_ADDR_VAR 0 5
43239: PUSH
43240: LD_INT 1
43242: ST_TO_ADDR
// break ;
43243: GO 43247
// end ;
43245: GO 43210
43247: POP
43248: POP
// result := m ;
43249: LD_ADDR_VAR 0 3
43253: PUSH
43254: LD_VAR 0 5
43258: ST_TO_ADDR
// end ;
43259: LD_VAR 0 3
43263: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43264: LD_INT 0
43266: PPUSH
43267: PPUSH
43268: PPUSH
// m := 0 ;
43269: LD_ADDR_VAR 0 5
43273: PUSH
43274: LD_INT 0
43276: ST_TO_ADDR
// for i = 1 to mreg do
43277: LD_ADDR_VAR 0 4
43281: PUSH
43282: DOUBLE
43283: LD_INT 1
43285: DEC
43286: ST_TO_ADDR
43287: LD_VAR 0 2
43291: PUSH
43292: FOR_TO
43293: IFFALSE 43333
// if mreg [ i ] [ 1 ] = side then
43295: LD_VAR 0 2
43299: PUSH
43300: LD_VAR 0 4
43304: ARRAY
43305: PUSH
43306: LD_INT 1
43308: ARRAY
43309: PUSH
43310: LD_VAR 0 1
43314: EQUAL
43315: IFFALSE 43331
// begin m := m + 1 ;
43317: LD_ADDR_VAR 0 5
43321: PUSH
43322: LD_VAR 0 5
43326: PUSH
43327: LD_INT 1
43329: PLUS
43330: ST_TO_ADDR
// end ;
43331: GO 43292
43333: POP
43334: POP
// result := m ;
43335: LD_ADDR_VAR 0 3
43339: PUSH
43340: LD_VAR 0 5
43344: ST_TO_ADDR
// end ;
43345: LD_VAR 0 3
43349: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43350: LD_INT 0
43352: PPUSH
43353: PPUSH
// result := 0 ;
43354: LD_ADDR_VAR 0 3
43358: PUSH
43359: LD_INT 0
43361: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43362: LD_ADDR_VAR 0 4
43366: PUSH
43367: DOUBLE
43368: LD_INT 1
43370: DEC
43371: ST_TO_ADDR
43372: LD_EXP 53
43376: PUSH
43377: FOR_TO
43378: IFFALSE 43440
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43380: LD_EXP 53
43384: PUSH
43385: LD_VAR 0 4
43389: ARRAY
43390: PUSH
43391: LD_INT 1
43393: ARRAY
43394: PUSH
43395: LD_VAR 0 1
43399: EQUAL
43400: PUSH
43401: LD_EXP 53
43405: PUSH
43406: LD_VAR 0 4
43410: ARRAY
43411: PUSH
43412: LD_INT 2
43414: ARRAY
43415: PUSH
43416: LD_VAR 0 2
43420: EQUAL
43421: AND
43422: IFFALSE 43438
// begin result := result + 1 ;
43424: LD_ADDR_VAR 0 3
43428: PUSH
43429: LD_VAR 0 3
43433: PUSH
43434: LD_INT 1
43436: PLUS
43437: ST_TO_ADDR
// end ;
43438: GO 43377
43440: POP
43441: POP
// end ; end_of_file
43442: LD_VAR 0 3
43446: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
43447: GO 43449
43449: DISABLE
// begin ru_radar := 98 ;
43450: LD_ADDR_EXP 73
43454: PUSH
43455: LD_INT 98
43457: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43458: LD_ADDR_EXP 74
43462: PUSH
43463: LD_INT 89
43465: ST_TO_ADDR
// us_hack := 99 ;
43466: LD_ADDR_EXP 75
43470: PUSH
43471: LD_INT 99
43473: ST_TO_ADDR
// us_artillery := 97 ;
43474: LD_ADDR_EXP 76
43478: PUSH
43479: LD_INT 97
43481: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43482: LD_ADDR_EXP 77
43486: PUSH
43487: LD_INT 91
43489: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
43490: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
43491: LD_INT 0
43493: PPUSH
43494: PPUSH
43495: PPUSH
43496: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
43497: LD_VAR 0 1
43501: PPUSH
43502: CALL_OW 264
43506: PUSH
43507: LD_EXP 77
43511: EQUAL
43512: IFFALSE 43584
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
43514: LD_INT 68
43516: PPUSH
43517: LD_VAR 0 1
43521: PPUSH
43522: CALL_OW 255
43526: PPUSH
43527: CALL_OW 321
43531: PUSH
43532: LD_INT 2
43534: EQUAL
43535: IFFALSE 43547
// eff := 70 else
43537: LD_ADDR_VAR 0 6
43541: PUSH
43542: LD_INT 70
43544: ST_TO_ADDR
43545: GO 43555
// eff := 30 ;
43547: LD_ADDR_VAR 0 6
43551: PUSH
43552: LD_INT 30
43554: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
43555: LD_VAR 0 1
43559: PPUSH
43560: CALL_OW 250
43564: PPUSH
43565: LD_VAR 0 1
43569: PPUSH
43570: CALL_OW 251
43574: PPUSH
43575: LD_VAR 0 6
43579: PPUSH
43580: CALL_OW 495
// end ; end ;
43584: LD_VAR 0 4
43588: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
43589: LD_INT 0
43591: PPUSH
43592: PPUSH
43593: PPUSH
43594: PPUSH
43595: PPUSH
43596: PPUSH
// if cmd = 124 then
43597: LD_VAR 0 1
43601: PUSH
43602: LD_INT 124
43604: EQUAL
43605: IFFALSE 43811
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
43607: LD_ADDR_VAR 0 5
43611: PUSH
43612: LD_INT 2
43614: PUSH
43615: LD_INT 34
43617: PUSH
43618: LD_INT 53
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 34
43627: PUSH
43628: LD_INT 14
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: LIST
43639: PPUSH
43640: CALL_OW 69
43644: ST_TO_ADDR
// if not tmp then
43645: LD_VAR 0 5
43649: NOT
43650: IFFALSE 43654
// exit ;
43652: GO 43811
// for i in tmp do
43654: LD_ADDR_VAR 0 3
43658: PUSH
43659: LD_VAR 0 5
43663: PUSH
43664: FOR_IN
43665: IFFALSE 43809
// begin taskList := GetTaskList ( i ) ;
43667: LD_ADDR_VAR 0 6
43671: PUSH
43672: LD_VAR 0 3
43676: PPUSH
43677: CALL_OW 437
43681: ST_TO_ADDR
// if not taskList then
43682: LD_VAR 0 6
43686: NOT
43687: IFFALSE 43691
// continue ;
43689: GO 43664
// for j = 1 to taskList do
43691: LD_ADDR_VAR 0 4
43695: PUSH
43696: DOUBLE
43697: LD_INT 1
43699: DEC
43700: ST_TO_ADDR
43701: LD_VAR 0 6
43705: PUSH
43706: FOR_TO
43707: IFFALSE 43805
// if taskList [ j ] [ 1 ] = | then
43709: LD_VAR 0 6
43713: PUSH
43714: LD_VAR 0 4
43718: ARRAY
43719: PUSH
43720: LD_INT 1
43722: ARRAY
43723: PUSH
43724: LD_STRING |
43726: EQUAL
43727: IFFALSE 43803
// begin _taskList := Delete ( taskList , 1 ) ;
43729: LD_ADDR_VAR 0 7
43733: PUSH
43734: LD_VAR 0 6
43738: PPUSH
43739: LD_INT 1
43741: PPUSH
43742: CALL_OW 3
43746: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
43747: LD_VAR 0 3
43751: PPUSH
43752: LD_VAR 0 7
43756: PPUSH
43757: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
43761: LD_VAR 0 3
43765: PPUSH
43766: LD_VAR 0 6
43770: PUSH
43771: LD_VAR 0 4
43775: ARRAY
43776: PUSH
43777: LD_INT 2
43779: ARRAY
43780: PPUSH
43781: LD_VAR 0 6
43785: PUSH
43786: LD_VAR 0 4
43790: ARRAY
43791: PUSH
43792: LD_INT 3
43794: ARRAY
43795: PPUSH
43796: LD_INT 8
43798: PPUSH
43799: CALL 43816 0 4
// end ;
43803: GO 43706
43805: POP
43806: POP
// end ;
43807: GO 43664
43809: POP
43810: POP
// end ; end ;
43811: LD_VAR 0 2
43815: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
43816: LD_INT 0
43818: PPUSH
43819: PPUSH
43820: PPUSH
43821: PPUSH
43822: PPUSH
43823: PPUSH
43824: PPUSH
43825: PPUSH
43826: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
43827: LD_VAR 0 1
43831: NOT
43832: PUSH
43833: LD_VAR 0 2
43837: PPUSH
43838: LD_VAR 0 3
43842: PPUSH
43843: CALL_OW 488
43847: NOT
43848: OR
43849: PUSH
43850: LD_VAR 0 4
43854: NOT
43855: OR
43856: IFFALSE 43860
// exit ;
43858: GO 44200
// list := [ ] ;
43860: LD_ADDR_VAR 0 13
43864: PUSH
43865: EMPTY
43866: ST_TO_ADDR
// if x - r < 0 then
43867: LD_VAR 0 2
43871: PUSH
43872: LD_VAR 0 4
43876: MINUS
43877: PUSH
43878: LD_INT 0
43880: LESS
43881: IFFALSE 43893
// min_x := 0 else
43883: LD_ADDR_VAR 0 7
43887: PUSH
43888: LD_INT 0
43890: ST_TO_ADDR
43891: GO 43909
// min_x := x - r ;
43893: LD_ADDR_VAR 0 7
43897: PUSH
43898: LD_VAR 0 2
43902: PUSH
43903: LD_VAR 0 4
43907: MINUS
43908: ST_TO_ADDR
// if y - r < 0 then
43909: LD_VAR 0 3
43913: PUSH
43914: LD_VAR 0 4
43918: MINUS
43919: PUSH
43920: LD_INT 0
43922: LESS
43923: IFFALSE 43935
// min_y := 0 else
43925: LD_ADDR_VAR 0 8
43929: PUSH
43930: LD_INT 0
43932: ST_TO_ADDR
43933: GO 43951
// min_y := y - r ;
43935: LD_ADDR_VAR 0 8
43939: PUSH
43940: LD_VAR 0 3
43944: PUSH
43945: LD_VAR 0 4
43949: MINUS
43950: ST_TO_ADDR
// max_x := x + r ;
43951: LD_ADDR_VAR 0 9
43955: PUSH
43956: LD_VAR 0 2
43960: PUSH
43961: LD_VAR 0 4
43965: PLUS
43966: ST_TO_ADDR
// max_y := y + r ;
43967: LD_ADDR_VAR 0 10
43971: PUSH
43972: LD_VAR 0 3
43976: PUSH
43977: LD_VAR 0 4
43981: PLUS
43982: ST_TO_ADDR
// for _x = min_x to max_x do
43983: LD_ADDR_VAR 0 11
43987: PUSH
43988: DOUBLE
43989: LD_VAR 0 7
43993: DEC
43994: ST_TO_ADDR
43995: LD_VAR 0 9
43999: PUSH
44000: FOR_TO
44001: IFFALSE 44118
// for _y = min_y to max_y do
44003: LD_ADDR_VAR 0 12
44007: PUSH
44008: DOUBLE
44009: LD_VAR 0 8
44013: DEC
44014: ST_TO_ADDR
44015: LD_VAR 0 10
44019: PUSH
44020: FOR_TO
44021: IFFALSE 44114
// begin if not ValidHex ( _x , _y ) then
44023: LD_VAR 0 11
44027: PPUSH
44028: LD_VAR 0 12
44032: PPUSH
44033: CALL_OW 488
44037: NOT
44038: IFFALSE 44042
// continue ;
44040: GO 44020
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
44042: LD_VAR 0 11
44046: PPUSH
44047: LD_VAR 0 12
44051: PPUSH
44052: CALL_OW 351
44056: PUSH
44057: LD_VAR 0 11
44061: PPUSH
44062: LD_VAR 0 12
44066: PPUSH
44067: CALL_OW 554
44071: AND
44072: IFFALSE 44112
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
44074: LD_ADDR_VAR 0 13
44078: PUSH
44079: LD_VAR 0 13
44083: PPUSH
44084: LD_VAR 0 13
44088: PUSH
44089: LD_INT 1
44091: PLUS
44092: PPUSH
44093: LD_VAR 0 11
44097: PUSH
44098: LD_VAR 0 12
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PPUSH
44107: CALL_OW 2
44111: ST_TO_ADDR
// end ;
44112: GO 44020
44114: POP
44115: POP
44116: GO 44000
44118: POP
44119: POP
// if not list then
44120: LD_VAR 0 13
44124: NOT
44125: IFFALSE 44129
// exit ;
44127: GO 44200
// for i in list do
44129: LD_ADDR_VAR 0 6
44133: PUSH
44134: LD_VAR 0 13
44138: PUSH
44139: FOR_IN
44140: IFFALSE 44198
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
44142: LD_VAR 0 1
44146: PPUSH
44147: LD_STRING M
44149: PUSH
44150: LD_VAR 0 6
44154: PUSH
44155: LD_INT 1
44157: ARRAY
44158: PUSH
44159: LD_VAR 0 6
44163: PUSH
44164: LD_INT 2
44166: ARRAY
44167: PUSH
44168: LD_INT 0
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 0
44176: PUSH
44177: LD_INT 0
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: PUSH
44189: EMPTY
44190: LIST
44191: PPUSH
44192: CALL_OW 447
44196: GO 44139
44198: POP
44199: POP
// end ;
44200: LD_VAR 0 5
44204: RET
