// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7640 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4617 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4916 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 42128 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42579 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21371 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21307 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18300 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21207 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22221 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21448 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21241 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21274 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18079 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22129 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20386 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20961 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20961 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20758 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20422 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20598 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19882 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20496 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20997 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21737 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21307 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18300 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21207 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21448 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21241 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21274 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18079 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22129 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20386 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20961 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20961 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20758 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20422 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20598 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19882 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20496 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20997 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21737 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19882 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11587 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21955 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11587 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21955 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11587 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21955 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11587 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21955 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7859 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7859 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7859 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7859 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7859 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4477
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 10
4389: PUSH
4390: LD_INT 9
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: LD_OWVAR 67
4405: ARRAY
4406: PPUSH
4407: LD_INT 10
4409: PUSH
4410: LD_INT 9
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: LD_INT -2
4429: PUSH
4430: LD_INT -5
4432: PUSH
4433: LD_INT -3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: LD_VAR 0 6
4445: ADD
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 2
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 3
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 42
4476: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4477: LD_EXP 25
4481: PPUSH
4482: LD_INT 9
4484: PPUSH
4485: LD_INT 0
4487: PPUSH
4488: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: PPUSH
4501: LD_INT 2
4503: PPUSH
4504: CALL_OW 336
// for i = 1 to tmp do
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: DOUBLE
4514: LD_INT 1
4516: DEC
4517: ST_TO_ADDR
4518: LD_VAR 0 5
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4579
// if i < 4 then
4526: LD_VAR 0 3
4530: PUSH
4531: LD_INT 4
4533: LESS
4534: IFFALSE 4559
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4536: LD_VAR 0 5
4540: PUSH
4541: LD_VAR 0 3
4545: ARRAY
4546: PPUSH
4547: LD_INT 9
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 49
4557: GO 4577
// SetSide ( tmp [ i ] , 6 ) ;
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: ARRAY
4569: PPUSH
4570: LD_INT 6
4572: PPUSH
4573: CALL_OW 235
4577: GO 4523
4579: POP
4580: POP
// player_squad := tmp ;
4581: LD_ADDR_EXP 23
4585: PUSH
4586: LD_VAR 0 5
4590: ST_TO_ADDR
// pl_counter := 4 ;
4591: LD_ADDR_EXP 24
4595: PUSH
4596: LD_INT 4
4598: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4599: LD_INT 17
4601: PPUSH
4602: LD_INT 5
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL 18300 0 3
// end ;
4612: LD_VAR 0 2
4616: RET
// export Popov ; export function InitAction ; var commander ; begin
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4621: LD_INT 6
4623: PPUSH
4624: LD_INT 3
4626: PPUSH
4627: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: CALL_OW 86
// uc_side := 6 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 6
4648: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4649: LD_ADDR_EXP 26
4653: PUSH
4654: LD_STRING Popov
4656: PPUSH
4657: CALL_OW 25
4661: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4662: LD_ADDR_OWVAR 67
4666: PUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 426
4674: ST_TO_ADDR
// if not Difficulty then
4675: LD_OWVAR 67
4679: NOT
4680: IFFALSE 4690
// Difficulty := 2 ;
4682: LD_ADDR_OWVAR 67
4686: PUSH
4687: LD_INT 2
4689: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: LD_INT 1
4697: PPUSH
4698: CALL_OW 426
4702: ST_TO_ADDR
// if not commander then
4703: LD_VAR 0 2
4707: NOT
4708: IFFALSE 4718
// commander := 1 ;
4710: LD_ADDR_VAR 0 2
4714: PUSH
4715: LD_INT 1
4717: ST_TO_ADDR
// InitCommanders ( commander ) ;
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL 3137 0 1
// end ;
4727: LD_VAR 0 1
4731: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4732: LD_EXP 24
4736: PUSH
4737: LD_INT 12
4739: LESS
4740: IFFALSE 4913
4742: GO 4744
4744: DISABLE
4745: LD_INT 0
4747: PPUSH
// begin enable ;
4748: ENABLE
// for i = pl_counter to pl_counter + 2 do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_EXP 24
4759: DEC
4760: ST_TO_ADDR
4761: LD_EXP 24
4765: PUSH
4766: LD_INT 2
4768: PLUS
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4817
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4773: LD_EXP 23
4777: PUSH
4778: LD_VAR 0 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 18
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4794: LD_EXP 23
4798: PUSH
4799: LD_VAR 0 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 107
4807: PPUSH
4808: LD_INT 88
4810: PPUSH
4811: CALL_OW 111
// end ;
4815: GO 4770
4817: POP
4818: POP
// for i = pl_counter to pl_counter + 2 do
4819: LD_ADDR_VAR 0 1
4823: PUSH
4824: DOUBLE
4825: LD_EXP 24
4829: DEC
4830: ST_TO_ADDR
4831: LD_EXP 24
4835: PUSH
4836: LD_INT 2
4838: PLUS
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4897
// begin repeat wait ( 0 0$01 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4850: LD_EXP 23
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 107
4863: PPUSH
4864: LD_INT 88
4866: PPUSH
4867: CALL_OW 297
4871: PUSH
4872: LD_INT 6
4874: LESS
4875: IFFALSE 4843
// SetSide ( player_squad [ i ] , 3 ) ;
4877: LD_EXP 23
4881: PUSH
4882: LD_VAR 0 1
4886: ARRAY
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: CALL_OW 235
// end ;
4895: GO 4840
4897: POP
4898: POP
// pl_counter := pl_counter + 3 ;
4899: LD_ADDR_EXP 24
4903: PUSH
4904: LD_EXP 24
4908: PUSH
4909: LD_INT 3
4911: PLUS
4912: ST_TO_ADDR
// end ;
4913: PPOPN 1
4915: END
// export function Dialog ; begin
4916: LD_INT 0
4918: PPUSH
// if not isTest then
4919: LD_EXP 1
4923: NOT
4924: IFFALSE 4946
// case query ( task ) of 1 :
4926: LD_STRING task
4928: PPUSH
4929: CALL_OW 97
4933: PUSH
4934: LD_INT 1
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// InGameOn ;
4946: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4950: LD_INT 107
4952: PPUSH
4953: LD_INT 84
4955: PPUSH
4956: CALL_OW 86
// if isTest then
4960: LD_EXP 1
4964: IFFALSE 4974
// dialogue_skipped := true ;
4966: LD_ADDR_OWVAR 59
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4974: LD_ADDR_EXP 11
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_INT 1
4986: ARRAY
4987: PPUSH
4988: LD_INT 0
4990: PPUSH
4991: LD_INT 96
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 2
4999: PPUSH
5000: CALL_OW 145
5004: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5012: LD_EXP 26
5016: PPUSH
5017: LD_STRING DR1
5019: PPUSH
5020: CALL_OW 94
// Wait ( 0 0$01 ) ;
5024: LD_INT 35
5026: PPUSH
5027: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5031: LD_EXP 26
5035: PPUSH
5036: LD_STRING DR2
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5043: LD_EXP 26
5047: PPUSH
5048: LD_STRING DR3
5050: PPUSH
5051: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5062: LD_INT 3
5064: PPUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL 11587 0 2
5079: PUSH
5080: LD_EXP 1
5084: OR
5085: IFFALSE 5055
// InGameOff ;
5087: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5091: LD_STRING C1
5093: PPUSH
5094: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5105: LD_EXP 11
5109: PPUSH
5110: CALL_OW 461
5114: PUSH
5115: LD_INT 2
5117: EQUAL
5118: IFFALSE 5098
// if not isTest then
5120: LD_EXP 1
5124: NOT
5125: IFFALSE 5147
// case query ( support ) of 1 :
5127: LD_STRING support
5129: PPUSH
5130: CALL_OW 97
5134: PUSH
5135: LD_INT 1
5137: DOUBLE
5138: EQUAL
5139: IFTRUE 5143
5141: GO 5146
5143: POP
// ; end ;
5144: GO 5147
5146: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5147: LD_INT 3
5149: PPUSH
5150: LD_INT 12
5152: PPUSH
5153: LD_INT 2
5155: PPUSH
5156: LD_INT 22
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 0
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 69
5184: PUSH
5185: LD_INT 1
5187: ARRAY
5188: PPUSH
5189: CALL_OW 468
// if player_com = stolypin then
5193: LD_EXP 25
5197: PUSH
5198: LD_EXP 22
5202: EQUAL
5203: IFFALSE 5232
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5205: LD_INT 18
5207: PPUSH
5208: LD_INT 3
5210: PUSH
5211: LD_INT 3
5213: PUSH
5214: LD_INT 2
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: ARRAY
5227: PPUSH
5228: CALL 6656 0 2
// end ;
5232: LD_VAR 0 1
5236: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5237: LD_EXP 12
5241: PUSH
5242: LD_OWVAR 1
5246: PUSH
5247: LD_INT 31500
5249: LESS
5250: AND
5251: IFFALSE 5423
// case query ( call1 ) of 1 :
5253: LD_STRING call1
5255: PPUSH
5256: CALL_OW 97
5260: PUSH
5261: LD_INT 1
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5411
5269: POP
// begin callUsed := true ;
5270: LD_ADDR_EXP 3
5274: PUSH
5275: LD_INT 1
5277: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5278: LD_INT 3
5280: PPUSH
5281: LD_INT 12
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_EXP 11
5291: PPUSH
5292: CALL_OW 468
// call := false ;
5296: LD_ADDR_EXP 12
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5304: LD_EXP 26
5308: PPUSH
5309: LD_STRING DR6
5311: PPUSH
5312: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5316: LD_INT 6300
5318: PPUSH
5319: LD_INT 8400
5321: PPUSH
5322: CALL_OW 12
5326: PPUSH
5327: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5331: LD_INT 18
5333: PUSH
5334: LD_INT 19
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_INT 2
5346: PPUSH
5347: CALL_OW 12
5351: ARRAY
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 2
5358: PPUSH
5359: CALL_OW 12
5363: PPUSH
5364: CALL 6656 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5368: LD_INT 25200
5370: PPUSH
5371: LD_INT 35700
5373: PPUSH
5374: CALL_OW 12
5378: PPUSH
5379: CALL_OW 67
// call := true ;
5383: LD_ADDR_EXP 12
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 12
5396: PPUSH
5397: LD_INT 2
5399: PPUSH
5400: LD_EXP 11
5404: PPUSH
5405: CALL_OW 468
// end ; 2 :
5409: GO 5423
5411: LD_INT 2
5413: DOUBLE
5414: EQUAL
5415: IFTRUE 5419
5417: GO 5422
5419: POP
// ; end ;
5420: GO 5423
5422: POP
// if call and tick >= 15 15$00 then
5423: LD_EXP 12
5427: PUSH
5428: LD_OWVAR 1
5432: PUSH
5433: LD_INT 31500
5435: GREATEREQUAL
5436: AND
5437: IFFALSE 5882
// case query ( call2 ) of 1 :
5439: LD_STRING call2
5441: PPUSH
5442: CALL_OW 97
5446: PUSH
5447: LD_INT 1
5449: DOUBLE
5450: EQUAL
5451: IFTRUE 5455
5453: GO 5699
5455: POP
// begin callUsed := true ;
5456: LD_ADDR_EXP 3
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// call := false ;
5464: LD_ADDR_EXP 12
5468: PUSH
5469: LD_INT 0
5471: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5472: LD_INT 1
5474: PPUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL 11587 0 2
5489: PUSH
5490: LD_INT 4
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11587 0 2
5507: AND
5508: IFFALSE 5556
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PUSH
5513: LD_INT 19
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 2
5525: PPUSH
5526: CALL_OW 12
5530: ARRAY
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6417 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11587 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5579: LD_INT 19
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 3
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6417 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5606: LD_INT 4
5608: PPUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL 11587 0 2
5623: PUSH
5624: LD_INT 0
5626: EQUAL
5627: IFFALSE 5656
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5629: LD_INT 18
5631: PPUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 4
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: PUSH
5646: LD_OWVAR 67
5650: ARRAY
5651: PPUSH
5652: CALL 6417 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5656: LD_INT 10500
5658: PPUSH
5659: LD_INT 23100
5661: PPUSH
5662: CALL_OW 12
5666: PPUSH
5667: CALL_OW 67
// call := true ;
5671: LD_ADDR_EXP 12
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5679: LD_INT 3
5681: PPUSH
5682: LD_INT 12
5684: PPUSH
5685: LD_INT 2
5687: PPUSH
5688: LD_EXP 11
5692: PPUSH
5693: CALL_OW 468
// end ; 2 :
5697: GO 5882
5699: LD_INT 2
5701: DOUBLE
5702: EQUAL
5703: IFTRUE 5707
5705: GO 5870
5707: POP
// begin callUsed := true ;
5708: LD_ADDR_EXP 3
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5716: LD_INT 3
5718: PPUSH
5719: LD_INT 12
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: LD_EXP 11
5729: PPUSH
5730: CALL_OW 468
// call := false ;
5734: LD_ADDR_EXP 12
5738: PUSH
5739: LD_INT 0
5741: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5742: LD_EXP 26
5746: PPUSH
5747: LD_STRING DR6
5749: PPUSH
5750: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5754: LD_INT 6300
5756: PPUSH
5757: LD_INT 8400
5759: PPUSH
5760: CALL_OW 12
5764: PPUSH
5765: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5769: LD_INT 18
5771: PUSH
5772: LD_INT 19
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PUSH
5779: LD_INT 1
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: CALL_OW 12
5789: ARRAY
5790: PPUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_OWVAR 67
5809: ARRAY
5810: PUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 12
5821: MINUS
5822: PPUSH
5823: CALL 6656 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5827: LD_INT 35700
5829: PPUSH
5830: LD_INT 44100
5832: PPUSH
5833: CALL_OW 12
5837: PPUSH
5838: CALL_OW 67
// call := true ;
5842: LD_ADDR_EXP 12
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5850: LD_INT 3
5852: PPUSH
5853: LD_INT 12
5855: PPUSH
5856: LD_INT 2
5858: PPUSH
5859: LD_EXP 11
5863: PPUSH
5864: CALL_OW 468
// end ; 3 :
5868: GO 5882
5870: LD_INT 3
5872: DOUBLE
5873: EQUAL
5874: IFTRUE 5878
5876: GO 5881
5878: POP
// ; end ;
5879: GO 5882
5881: POP
// end ;
5882: PPOPN 4
5884: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5885: LD_INT 22
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 69
5913: PUSH
5914: LD_INT 0
5916: EQUAL
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 21
5930: PUSH
5931: LD_INT 1
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 69
5946: PUSH
5947: LD_INT 0
5949: EQUAL
5950: AND
5951: IFFALSE 6255
5953: GO 5955
5955: DISABLE
// begin DialogueOn ;
5956: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5960: LD_EXP 26
5964: PPUSH
5965: LD_STRING DR7
5967: PPUSH
5968: CALL_OW 94
// case player_com of Gorki :
5972: LD_EXP 25
5976: PUSH
5977: LD_EXP 21
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 5997
5987: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5988: LD_STRING ACH_GORKI
5990: PPUSH
5991: CALL_OW 543
5995: GO 6058
5997: LD_EXP 22
6001: DOUBLE
6002: EQUAL
6003: IFTRUE 6007
6005: GO 6017
6007: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
6008: LD_STRING ACH_STOLYP
6010: PPUSH
6011: CALL_OW 543
6015: GO 6058
6017: LD_EXP 20
6021: DOUBLE
6022: EQUAL
6023: IFTRUE 6027
6025: GO 6037
6027: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
6028: LD_STRING ACH_DAVIDOV
6030: PPUSH
6031: CALL_OW 543
6035: GO 6058
6037: LD_EXP 19
6041: DOUBLE
6042: EQUAL
6043: IFTRUE 6047
6045: GO 6057
6047: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6048: LD_STRING ACH_GLADKOV
6050: PPUSH
6051: CALL_OW 543
6055: GO 6058
6057: POP
// if not callUsed then
6058: LD_EXP 3
6062: NOT
6063: IFFALSE 6072
// SetAchievement ( ACH_NOSUPP ) ;
6065: LD_STRING ACH_NOSUPP
6067: PPUSH
6068: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6072: LD_OWVAR 1
6076: PUSH
6077: LD_INT 116550
6079: PUSH
6080: LD_INT 95550
6082: PUSH
6083: LD_INT 89250
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: LESS
6097: IFFALSE 6111
// AddMedal ( med1 , 1 ) else
6099: LD_STRING med1
6101: PPUSH
6102: LD_INT 1
6104: PPUSH
6105: CALL_OW 101
6109: GO 6122
// AddMedal ( med1 , - 1 ) ;
6111: LD_STRING med1
6113: PPUSH
6114: LD_INT 1
6116: NEG
6117: PPUSH
6118: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6122: LD_INT 81
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 21
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: LD_INT 0
6153: EQUAL
6154: IFFALSE 6168
// AddMedal ( med3 , 1 ) else
6156: LD_STRING med3
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 101
6166: GO 6179
// AddMedal ( med3 , - 1 ) ;
6168: LD_STRING med3
6170: PPUSH
6171: LD_INT 1
6173: NEG
6174: PPUSH
6175: CALL_OW 101
// if player_loss = 0 then
6179: LD_EXP 10
6183: PUSH
6184: LD_INT 0
6186: EQUAL
6187: IFFALSE 6201
// AddMedal ( med2 , 1 ) else
6189: LD_STRING med2
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 101
6199: GO 6244
// if player_loss > 0 and player_loss < 3 then
6201: LD_EXP 10
6205: PUSH
6206: LD_INT 0
6208: GREATER
6209: PUSH
6210: LD_EXP 10
6214: PUSH
6215: LD_INT 3
6217: LESS
6218: AND
6219: IFFALSE 6233
// AddMedal ( med2 , 2 ) else
6221: LD_STRING med2
6223: PPUSH
6224: LD_INT 2
6226: PPUSH
6227: CALL_OW 101
6231: GO 6244
// AddMedal ( med2 , - 1 ) ;
6233: LD_STRING med2
6235: PPUSH
6236: LD_INT 1
6238: NEG
6239: PPUSH
6240: CALL_OW 101
// GiveMedals ( MAIN ) ;
6244: LD_STRING MAIN
6246: PPUSH
6247: CALL_OW 102
// YouWin ;
6251: CALL_OW 103
// end ;
6255: END
// every 0 0$01 trigger IsDead ( player_com ) do
6256: LD_EXP 25
6260: PPUSH
6261: CALL_OW 301
6265: IFFALSE 6332
6267: GO 6269
6269: DISABLE
// begin if IsLive ( Houten ) then
6270: LD_EXP 4
6274: PPUSH
6275: CALL_OW 300
6279: IFFALSE 6295
// SayRadio ( Houten , DJ5 ) else
6281: LD_EXP 4
6285: PPUSH
6286: LD_STRING DJ5
6288: PPUSH
6289: CALL_OW 94
6293: GO 6318
// if IsLive ( Brown ) then
6295: LD_EXP 5
6299: PPUSH
6300: CALL_OW 300
6304: IFFALSE 6318
// SayRadio ( Brown , DS5 ) ;
6306: LD_EXP 5
6310: PPUSH
6311: LD_STRING DS5
6313: PPUSH
6314: CALL_OW 94
// Wait ( 0 0$01 ) ;
6318: LD_INT 35
6320: PPUSH
6321: CALL_OW 67
// YouLost ( dead ) ;
6325: LD_STRING dead
6327: PPUSH
6328: CALL_OW 104
// end ;
6332: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6333: LD_EXP 11
6337: PPUSH
6338: CALL_OW 301
6342: PUSH
6343: LD_EXP 1
6347: NOT
6348: AND
6349: IFFALSE 6416
6351: GO 6353
6353: DISABLE
// begin if IsLive ( Brown ) then
6354: LD_EXP 5
6358: PPUSH
6359: CALL_OW 300
6363: IFFALSE 6379
// SayRadio ( Brown , DS5 ) else
6365: LD_EXP 5
6369: PPUSH
6370: LD_STRING DS5
6372: PPUSH
6373: CALL_OW 94
6377: GO 6402
// if IsLive ( Houten ) then
6379: LD_EXP 4
6383: PPUSH
6384: CALL_OW 300
6388: IFFALSE 6402
// SayRadio ( Houten , DJ5 ) ;
6390: LD_EXP 4
6394: PPUSH
6395: LD_STRING DJ5
6397: PPUSH
6398: CALL_OW 94
// Wait ( 0 0$01 ) ;
6402: LD_INT 35
6404: PPUSH
6405: CALL_OW 67
// YouLost ( depot ) ;
6409: LD_STRING depot
6411: PPUSH
6412: CALL_OW 104
// end ;
6416: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
6421: PPUSH
// for i = 1 to n do
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6641
// begin uc_side := 6 ;
6440: LD_ADDR_OWVAR 20
6444: PUSH
6445: LD_INT 6
6447: ST_TO_ADDR
// uc_nation := 3 ;
6448: LD_ADDR_OWVAR 21
6452: PUSH
6453: LD_INT 3
6455: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6456: LD_ADDR_OWVAR 37
6460: PUSH
6461: LD_INT 23
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 1
6473: PPUSH
6474: LD_INT 2
6476: PPUSH
6477: CALL_OW 12
6481: ARRAY
6482: ST_TO_ADDR
// vc_control := control_computer ;
6483: LD_ADDR_OWVAR 38
6487: PUSH
6488: LD_INT 3
6490: ST_TO_ADDR
// vc_engine := engine_siberite ;
6491: LD_ADDR_OWVAR 39
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6499: LD_ADDR_OWVAR 40
6503: PUSH
6504: LD_INT 43
6506: PUSH
6507: LD_INT 44
6509: PUSH
6510: LD_INT 44
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 1
6520: PPUSH
6521: LD_INT 3
6523: PPUSH
6524: CALL_OW 12
6528: ARRAY
6529: ST_TO_ADDR
// un := CreateVehicle ;
6530: LD_ADDR_VAR 0 5
6534: PUSH
6535: CALL_OW 45
6539: ST_TO_ADDR
// case area of east_arr :
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 18
6547: DOUBLE
6548: EQUAL
6549: IFTRUE 6553
6551: GO 6588
6553: POP
// begin PlaceUnitArea ( un , area , false ) ;
6554: LD_VAR 0 5
6558: PPUSH
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 0
6566: PPUSH
6567: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_INT 79
6578: PPUSH
6579: LD_INT 33
6581: PPUSH
6582: CALL_OW 111
// end ; south_arr :
6586: GO 6632
6588: LD_INT 19
6590: DOUBLE
6591: EQUAL
6592: IFTRUE 6596
6594: GO 6631
6596: POP
// begin PlaceUnitArea ( un , area , false ) ;
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 1
6606: PPUSH
6607: LD_INT 0
6609: PPUSH
6610: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 131
6621: PPUSH
6622: LD_INT 148
6624: PPUSH
6625: CALL_OW 111
// end ; end ;
6629: GO 6632
6631: POP
// Wait ( 0 0$02 ) ;
6632: LD_INT 70
6634: PPUSH
6635: CALL_OW 67
// end ;
6639: GO 6437
6641: POP
6642: POP
// pink_attack := true ;
6643: LD_ADDR_EXP 13
6647: PUSH
6648: LD_INT 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 3
6655: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// for i = 1 to n do
6661: LD_ADDR_VAR 0 4
6665: PUSH
6666: DOUBLE
6667: LD_INT 1
6669: DEC
6670: ST_TO_ADDR
6671: LD_VAR 0 2
6675: PUSH
6676: FOR_TO
6677: IFFALSE 6903
// begin uc_side := 6 ;
6679: LD_ADDR_OWVAR 20
6683: PUSH
6684: LD_INT 6
6686: ST_TO_ADDR
// uc_nation := 3 ;
6687: LD_ADDR_OWVAR 21
6691: PUSH
6692: LD_INT 3
6694: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6695: LD_INT 0
6697: PPUSH
6698: LD_INT 3
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6708: LD_ADDR_OWVAR 37
6712: PUSH
6713: LD_INT 22
6715: ST_TO_ADDR
// vc_control := control_manual ;
6716: LD_ADDR_OWVAR 38
6720: PUSH
6721: LD_INT 1
6723: ST_TO_ADDR
// vc_engine := engine_combustion ;
6724: LD_ADDR_OWVAR 39
6728: PUSH
6729: LD_INT 1
6731: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6732: LD_ADDR_OWVAR 40
6736: PUSH
6737: LD_INT 51
6739: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6740: LD_ADDR_OWVAR 41
6744: PUSH
6745: LD_INT 50
6747: ST_TO_ADDR
// un := CreateVehicle ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: CALL_OW 45
6757: ST_TO_ADDR
// case area of east_arr :
6758: LD_VAR 0 1
6762: PUSH
6763: LD_INT 18
6765: DOUBLE
6766: EQUAL
6767: IFTRUE 6771
6769: GO 6786
6771: POP
// SetDir ( un , 4 ) ; south_arr :
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 4
6779: PPUSH
6780: CALL_OW 233
6784: GO 6810
6786: LD_INT 19
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6809
6794: POP
// SetDir ( un , 5 ) ; end ;
6795: LD_VAR 0 5
6799: PPUSH
6800: LD_INT 5
6802: PPUSH
6803: CALL_OW 233
6807: GO 6810
6809: POP
// PlaceUnitArea ( un , area , false ) ;
6810: LD_VAR 0 5
6814: PPUSH
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6827: CALL_OW 44
6831: PPUSH
6832: LD_VAR 0 5
6836: PPUSH
6837: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6841: LD_VAR 0 5
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 100
6851: PPUSH
6852: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 106
6863: PPUSH
6864: LD_INT 88
6866: PPUSH
6867: CALL_OW 111
// AddComUnload ( un ) ;
6871: LD_VAR 0 5
6875: PPUSH
6876: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 173
// Wait ( 0 0$02 ) ;
6894: LD_INT 70
6896: PPUSH
6897: CALL_OW 67
// end ;
6901: GO 6676
6903: POP
6904: POP
// Wait ( 0 0$05 ) ;
6905: LD_INT 175
6907: PPUSH
6908: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6912: LD_INT 6
6914: PPUSH
6915: LD_INT 34
6917: PUSH
6918: LD_INT 51
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL 11587 0 2
6929: IFFALSE 7117
// begin wait ( 0 0$01 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6938: LD_ADDR_VAR 0 4
6942: PUSH
6943: LD_INT 6
6945: PPUSH
6946: LD_INT 34
6948: PUSH
6949: LD_INT 51
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL 11587 0 2
6960: PUSH
6961: FOR_IN
6962: IFFALSE 7113
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6964: LD_VAR 0 4
6968: PPUSH
6969: LD_INT 9
6971: PPUSH
6972: CALL_OW 308
6976: PUSH
6977: LD_VAR 0 4
6981: PPUSH
6982: CALL 31819 0 1
6986: PPUSH
6987: CALL_OW 258
6991: PUSH
6992: LD_INT 1
6994: EQUAL
6995: AND
6996: PUSH
6997: LD_EXP 9
7001: AND
7002: IFFALSE 7029
// begin Say ( GetDriver ( i ) , Dtran ) ;
7004: LD_VAR 0 4
7008: PPUSH
7009: CALL 31819 0 1
7013: PPUSH
7014: LD_STRING Dtran
7016: PPUSH
7017: CALL_OW 88
// dialog_trans := false ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// end ; if IsIdle ( i ) then
7029: LD_VAR 0 4
7033: PPUSH
7034: CALL_OW 316
7038: IFFALSE 7054
// ComMoveToArea ( i , area ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: LD_VAR 0 1
7049: PPUSH
7050: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7054: LD_VAR 0 4
7058: PPUSH
7059: LD_VAR 0 1
7063: PPUSH
7064: CALL_OW 308
7068: PUSH
7069: LD_VAR 0 4
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL_OW 289
7081: PUSH
7082: LD_INT 0
7084: EQUAL
7085: AND
7086: IFFALSE 7111
// begin RemoveUnit ( GetDriver ( i ) ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL 31819 0 1
7097: PPUSH
7098: CALL_OW 64
// RemoveUnit ( i ) ;
7102: LD_VAR 0 4
7106: PPUSH
7107: CALL_OW 64
// end ; end ;
7111: GO 6961
7113: POP
7114: POP
// end ;
7115: GO 6912
// end ;
7117: LD_VAR 0 3
7121: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7122: LD_INT 0
7124: PPUSH
7125: PPUSH
7126: PPUSH
7127: PPUSH
// if isTest then
7128: LD_EXP 1
7132: IFFALSE 7136
// exit ;
7134: GO 7525
// for i = 1 to n do
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7384
// begin uc_side := 8 ;
7154: LD_ADDR_OWVAR 20
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// uc_nation := 1 ;
7162: LD_ADDR_OWVAR 21
7166: PUSH
7167: LD_INT 1
7169: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7170: LD_ADDR_VAR 0 6
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 1
7191: PPUSH
7192: LD_OWVAR 67
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// vc_chassis := ch ;
7203: LD_ADDR_OWVAR 37
7207: PUSH
7208: LD_VAR 0 6
7212: ST_TO_ADDR
// vc_control := control_computer ;
7213: LD_ADDR_OWVAR 38
7217: PUSH
7218: LD_INT 3
7220: ST_TO_ADDR
// vc_engine := engine_combustion ;
7221: LD_ADDR_OWVAR 39
7225: PUSH
7226: LD_INT 1
7228: ST_TO_ADDR
// if ch = us_medium_tracked then
7229: LD_VAR 0 6
7233: PUSH
7234: LD_INT 3
7236: EQUAL
7237: IFFALSE 7284
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7239: LD_ADDR_OWVAR 40
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 4
7249: PUSH
7250: LD_INT 5
7252: PUSH
7253: LD_INT 7
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: PPUSH
7267: LD_OWVAR 67
7271: PUSH
7272: LD_INT 1
7274: PLUS
7275: PPUSH
7276: CALL_OW 12
7280: ARRAY
7281: ST_TO_ADDR
7282: GO 7325
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7284: LD_ADDR_OWVAR 40
7288: PUSH
7289: LD_INT 5
7291: PUSH
7292: LD_INT 6
7294: PUSH
7295: LD_INT 7
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_OWVAR 67
7314: PUSH
7315: LD_INT 1
7317: PLUS
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7325: LD_ADDR_OWVAR 41
7329: PUSH
7330: LD_INT 70
7332: ST_TO_ADDR
// un := CreateVehicle ;
7333: LD_ADDR_VAR 0 5
7337: PUSH
7338: CALL_OW 45
7342: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7343: LD_VAR 0 5
7347: PPUSH
7348: LD_VAR 0 1
7352: PPUSH
7353: LD_INT 0
7355: PPUSH
7356: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7360: LD_VAR 0 5
7364: PPUSH
7365: LD_INT 65
7367: PPUSH
7368: LD_INT 9
7370: PPUSH
7371: CALL_OW 111
// Wait ( 0 0$02 ) ;
7375: LD_INT 70
7377: PPUSH
7378: CALL_OW 67
// end ;
7382: GO 7151
7384: POP
7385: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7386: LD_INT 90
7388: PUSH
7389: LD_INT 80
7391: PUSH
7392: LD_INT 70
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_OWVAR 67
7404: ARRAY
7405: PPUSH
7406: CALL_OW 13
7410: IFFALSE 7517
// begin uc_side := 8 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 8
7419: ST_TO_ADDR
// uc_nation := 1 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 1
7427: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7428: LD_ADDR_OWVAR 37
7432: PUSH
7433: LD_INT 4
7435: ST_TO_ADDR
// vc_control := control_computer ;
7436: LD_ADDR_OWVAR 38
7440: PUSH
7441: LD_INT 3
7443: ST_TO_ADDR
// vc_engine := engine_combustion ;
7444: LD_ADDR_OWVAR 39
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7452: LD_ADDR_OWVAR 40
7456: PUSH
7457: LD_INT 14
7459: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7460: LD_ADDR_OWVAR 41
7464: PUSH
7465: LD_INT 70
7467: ST_TO_ADDR
// un := CreateVehicle ;
7468: LD_ADDR_VAR 0 5
7472: PUSH
7473: CALL_OW 45
7477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7478: LD_VAR 0 5
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7495: LD_VAR 0 5
7499: PPUSH
7500: LD_INT 65
7502: PPUSH
7503: LD_INT 9
7505: PPUSH
7506: CALL_OW 111
// Wait ( 0 0$02 ) ;
7510: LD_INT 70
7512: PPUSH
7513: CALL_OW 67
// end ; alfa_support := true ;
7517: LD_ADDR_EXP 14
7521: PUSH
7522: LD_INT 1
7524: ST_TO_ADDR
// end ;
7525: LD_VAR 0 3
7529: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7530: LD_OWVAR 1
7534: PUSH
7535: LD_INT 21000
7537: PUSH
7538: LD_INT 18900
7540: PUSH
7541: LD_INT 16800
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: LD_OWVAR 67
7553: ARRAY
7554: GREATER
7555: IFFALSE 7639
7557: GO 7559
7559: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7560: LD_EXP 26
7564: PPUSH
7565: LD_STRING DR5
7567: PPUSH
7568: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7572: LD_INT 1050
7574: PPUSH
7575: LD_INT 4200
7577: PPUSH
7578: CALL_OW 12
7582: PPUSH
7583: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7587: LD_INT 20
7589: PPUSH
7590: LD_INT 5
7592: PUSH
7593: LD_INT 6
7595: PUSH
7596: LD_INT 8
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_OWVAR 67
7608: ARRAY
7609: PPUSH
7610: CALL 7122 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7614: LD_INT 8400
7616: PPUSH
7617: LD_INT 12600
7619: PPUSH
7620: CALL_OW 12
7624: PPUSH
7625: CALL_OW 67
// until tick >= 120 120$00 ;
7629: LD_OWVAR 1
7633: PUSH
7634: LD_INT 252000
7636: GREATEREQUAL
7637: IFFALSE 7560
// end ; end_of_file
7639: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7640: LD_INT 0
7642: PPUSH
// enable_addtolog := isTest ;
7643: LD_ADDR_OWVAR 81
7647: PUSH
7648: LD_EXP 1
7652: ST_TO_ADDR
// lines_break_limit := 5 ;
7653: LD_ADDR_EXP 28
7657: PUSH
7658: LD_INT 5
7660: ST_TO_ADDR
// lines_break_type := --- ;
7661: LD_ADDR_EXP 29
7665: PUSH
7666: LD_STRING ---
7668: ST_TO_ADDR
// lines_counter := 0 ;
7669: LD_ADDR_EXP 27
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// show_line_index := true ;
7677: LD_ADDR_EXP 30
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// tick_log := true ;
7685: LD_ADDR_EXP 31
7689: PUSH
7690: LD_INT 1
7692: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7693: LD_STRING ----------SAND OF SIBERIA LOG----------
7695: PPUSH
7696: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7700: LD_STRING Map Name: 
7702: PUSH
7703: LD_OWVAR 68
7707: STR
7708: PPUSH
7709: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7713: LD_STRING Map Number: 
7715: PUSH
7716: LD_OWVAR 70
7720: STR
7721: PPUSH
7722: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7726: LD_STRING Difficulty: 
7728: PUSH
7729: LD_OWVAR 67
7733: STR
7734: PPUSH
7735: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7739: LD_STRING ---------------------------------------
7741: PPUSH
7742: CALL_OW 561
// end ;
7746: LD_VAR 0 1
7750: RET
// function Log ( text ) ; begin
7751: LD_INT 0
7753: PPUSH
// if show_line_index then
7754: LD_EXP 30
7758: IFFALSE 7770
// result := lines_counter ;
7760: LD_ADDR_VAR 0 2
7764: PUSH
7765: LD_EXP 27
7769: ST_TO_ADDR
// if tick_log then
7770: LD_EXP 31
7774: IFFALSE 7800
// result := result &  T:  & tick &   ;
7776: LD_ADDR_VAR 0 2
7780: PUSH
7781: LD_VAR 0 2
7785: PUSH
7786: LD_STRING  T: 
7788: STR
7789: PUSH
7790: LD_OWVAR 1
7794: STR
7795: PUSH
7796: LD_STRING  
7798: STR
7799: ST_TO_ADDR
// AddToLog ( result & text ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_VAR 0 1
7809: STR
7810: PPUSH
7811: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7815: LD_ADDR_EXP 27
7819: PUSH
7820: LD_EXP 27
7824: PUSH
7825: LD_INT 1
7827: PLUS
7828: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7829: LD_EXP 27
7833: PUSH
7834: LD_EXP 28
7838: MOD
7839: PUSH
7840: LD_INT 0
7842: EQUAL
7843: IFFALSE 7854
// AddToLog ( lines_break_type ) ;
7845: LD_EXP 29
7849: PPUSH
7850: CALL_OW 561
// end ;
7854: LD_VAR 0 2
7858: RET
// export function LogHuman ( id ) ; begin
7859: LD_INT 0
7861: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7862: LD_STRING Human Created. id: 
7864: PUSH
7865: LD_VAR 0 1
7869: STR
7870: PUSH
7871: LD_STRING ; side: 
7873: STR
7874: PUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 255
7884: STR
7885: PUSH
7886: LD_STRING ; class: 
7888: STR
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 257
7899: STR
7900: PUSH
7901: LD_STRING ; 
7903: STR
7904: PPUSH
7905: CALL 7751 0 1
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogVeh ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7917: LD_STRING Vehicle Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; nation: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 248
7954: STR
7955: PUSH
7956: LD_STRING ; weapon: 
7958: STR
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 264
7969: STR
7970: PUSH
7971: LD_STRING ; 
7973: STR
7974: PPUSH
7975: CALL 7751 0 1
// end ;
7979: LD_VAR 0 2
7983: RET
// export function LogEvent ( event ) ; begin
7984: LD_INT 0
7986: PPUSH
// Log ( Event Executed. id:  & event ) ;
7987: LD_STRING Event Executed. id: 
7989: PUSH
7990: LD_VAR 0 1
7994: STR
7995: PPUSH
7996: CALL 7751 0 1
// end ; end_of_file
8000: LD_VAR 0 2
8004: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8005: LD_INT 0
8007: PPUSH
8008: PPUSH
8009: PPUSH
8010: PPUSH
8011: PPUSH
8012: PPUSH
8013: PPUSH
8014: PPUSH
// if unit then
8015: LD_VAR 0 1
8019: IFFALSE 8419
// begin if mode = 0 then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_INT 0
8028: EQUAL
8029: IFFALSE 8177
// begin if coords then
8031: LD_VAR 0 2
8035: IFFALSE 8175
// while ( coords > 1 ) do
8037: LD_VAR 0 2
8041: PUSH
8042: LD_INT 1
8044: GREATER
8045: IFFALSE 8175
// if not HasTask ( unit ) then
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 314
8056: NOT
8057: IFFALSE 8173
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8059: LD_VAR 0 1
8063: PPUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 1
8071: ARRAY
8072: PPUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: PPUSH
8082: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8086: LD_INT 35
8088: PPUSH
8089: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 250
8102: PUSH
8103: LD_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ARRAY
8111: EQUAL
8112: PUSH
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 251
8122: PUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 2
8130: ARRAY
8131: EQUAL
8132: AND
8133: IFFALSE 8086
// for i = 1 to 2 do
8135: LD_ADDR_VAR 0 5
8139: PUSH
8140: DOUBLE
8141: LD_INT 1
8143: DEC
8144: ST_TO_ADDR
8145: LD_INT 2
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8171
// coords := Delete ( coords , 1 ) ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: LD_INT 1
8163: PPUSH
8164: CALL_OW 3
8168: ST_TO_ADDR
8169: GO 8148
8171: POP
8172: POP
// end ;
8173: GO 8037
// end else
8175: GO 8419
// begin if coords then
8177: LD_VAR 0 2
8181: IFFALSE 8419
// begin x := GetX ( unit ) ;
8183: LD_ADDR_VAR 0 6
8187: PUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 250
8197: ST_TO_ADDR
// y := GetY ( unit ) ;
8198: LD_ADDR_VAR 0 7
8202: PUSH
8203: LD_VAR 0 1
8207: PPUSH
8208: CALL_OW 251
8212: ST_TO_ADDR
// while ( coords > 1 ) do
8213: LD_VAR 0 2
8217: PUSH
8218: LD_INT 1
8220: GREATER
8221: IFFALSE 8419
// begin Wait ( 0 0$0.3 ) ;
8223: LD_INT 10
8225: PPUSH
8226: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 255
8239: PPUSH
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 250
8249: PPUSH
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 251
8259: PPUSH
8260: LD_INT 14
8262: PPUSH
8263: CALL 22757 0 4
8267: IFFALSE 8298
// begin ComMoveXY ( unit , x , y ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 7
8283: PPUSH
8284: CALL_OW 111
// result := false ;
8288: LD_ADDR_VAR 0 4
8292: PUSH
8293: LD_INT 0
8295: ST_TO_ADDR
// end else
8296: GO 8337
// if not HasTask ( unit ) then
8298: LD_VAR 0 1
8302: PPUSH
8303: CALL_OW 314
8307: NOT
8308: IFFALSE 8337
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8310: LD_VAR 0 1
8314: PPUSH
8315: LD_VAR 0 2
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 2
8331: ARRAY
8332: PPUSH
8333: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8337: LD_VAR 0 1
8341: PPUSH
8342: CALL_OW 250
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: EQUAL
8356: PUSH
8357: LD_VAR 0 1
8361: PPUSH
8362: CALL_OW 251
8366: PUSH
8367: LD_VAR 0 2
8371: PUSH
8372: LD_INT 2
8374: ARRAY
8375: EQUAL
8376: AND
8377: IFFALSE 8417
// for i = 1 to 2 do
8379: LD_ADDR_VAR 0 5
8383: PUSH
8384: DOUBLE
8385: LD_INT 1
8387: DEC
8388: ST_TO_ADDR
8389: LD_INT 2
8391: PUSH
8392: FOR_TO
8393: IFFALSE 8415
// coords := Delete ( coords , 1 ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 2
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
8413: GO 8392
8415: POP
8416: POP
// end ;
8417: GO 8213
// end ; end ; end ; result := true ;
8419: LD_ADDR_VAR 0 4
8423: PUSH
8424: LD_INT 1
8426: ST_TO_ADDR
// end ;
8427: LD_VAR 0 4
8431: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8437: LD_ADDR_VAR 0 5
8441: PUSH
8442: LD_INT 81
8444: PUSH
8445: LD_VAR 0 1
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// for i in units do
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_VAR 0 2
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8498
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8472: LD_VAR 0 4
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL_OW 74
8491: PPUSH
8492: CALL_OW 115
// end ;
8496: GO 8469
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 3
8504: RET
// export function MC_Show ( string ) ; begin
8505: LD_INT 0
8507: PPUSH
// display_strings := string ;
8508: LD_ADDR_OWVAR 47
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// end ; end_of_file
8518: LD_VAR 0 2
8522: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
8527: PPUSH
8528: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8529: LD_ADDR_VAR 0 8
8533: PUSH
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 2
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL 11670 0 3
8548: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8549: LD_VAR 0 8
8553: PUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: LD_VAR 0 3
8563: PPUSH
8564: CALL_OW 428
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: AND
8573: IFFALSE 8647
// for i = 1 to plist do
8575: LD_ADDR_VAR 0 6
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 8
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8645
// if NotTask ( plist [ i ] ) then
8593: LD_VAR 0 8
8597: PUSH
8598: LD_VAR 0 6
8602: ARRAY
8603: PPUSH
8604: CALL 32464 0 1
8608: IFFALSE 8643
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8610: LD_VAR 0 8
8614: PUSH
8615: LD_VAR 0 6
8619: ARRAY
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: LD_VAR 0 2
8628: PPUSH
8629: LD_VAR 0 3
8633: PPUSH
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 145
// end ;
8643: GO 8590
8645: POP
8646: POP
// end ;
8647: LD_VAR 0 5
8651: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8652: LD_INT 0
8654: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 6
8662: PPUSH
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_VAR 0 4
8677: PPUSH
8678: CALL 10156 0 5
// end ;
8682: LD_VAR 0 5
8686: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8691: LD_ADDR_VAR 0 4
8695: PUSH
8696: LD_INT 22
8698: PUSH
8699: LD_VAR 0 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 30
8713: PUSH
8714: LD_INT 0
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 30
8723: PUSH
8724: LD_INT 1
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: EMPTY
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 250
8757: PPUSH
8758: LD_VAR 0 2
8762: PPUSH
8763: CALL_OW 251
8767: PPUSH
8768: CALL_OW 73
8772: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8773: LD_VAR 0 4
8777: PPUSH
8778: LD_VAR 0 2
8782: PPUSH
8783: CALL 10445 0 2
8787: IFFALSE 8846
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8789: LD_VAR 0 1
8793: PPUSH
8794: LD_INT 30
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PPUSH
8806: CALL 11587 0 2
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8819: LD_ADDR_EXP 50
8823: PUSH
8824: LD_EXP 50
8828: PPUSH
8829: LD_VAR 0 1
8833: PPUSH
8834: LD_VAR 0 2
8838: PPUSH
8839: EMPTY
8840: PPUSH
8841: CALL 42498 0 4
8845: ST_TO_ADDR
// end ; end ;
8846: LD_VAR 0 3
8850: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8851: LD_INT 0
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// result := false ;
8859: LD_ADDR_VAR 0 4
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8867: LD_VAR 0 1
8871: PPUSH
8872: LD_EXP 42
8876: PPUSH
8877: CALL 43446 0 2
8881: IFFALSE 9094
// for i = 1 to MREG_LabList do
8883: LD_ADDR_VAR 0 5
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_EXP 42
8897: PUSH
8898: FOR_TO
8899: IFFALSE 9092
// begin if MREG_LabList [ i ] [ 1 ] = side then
8901: LD_EXP 42
8905: PUSH
8906: LD_VAR 0 5
8910: ARRAY
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PUSH
8916: LD_VAR 0 1
8920: EQUAL
8921: IFFALSE 9090
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8923: LD_ADDR_VAR 0 7
8927: PUSH
8928: LD_EXP 42
8932: PUSH
8933: LD_VAR 0 5
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8943: LD_ADDR_VAR 0 9
8947: PUSH
8948: LD_INT 22
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 0
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 30
8975: PUSH
8976: LD_INT 1
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: EMPTY
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: CALL_OW 250
9009: PPUSH
9010: LD_VAR 0 7
9014: PPUSH
9015: CALL_OW 251
9019: PPUSH
9020: CALL_OW 73
9024: ST_TO_ADDR
// if dep then
9025: LD_VAR 0 9
9029: IFFALSE 9088
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9031: LD_VAR 0 9
9035: PPUSH
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 3
9045: PPUSH
9046: CALL 10561 0 3
9050: IFFALSE 9088
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9052: LD_VAR 0 7
9056: PPUSH
9057: LD_VAR 0 2
9061: PPUSH
9062: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9066: LD_VAR 0 7
9070: PPUSH
9071: LD_VAR 0 3
9075: PPUSH
9076: CALL_OW 207
// result := true ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 1
9087: ST_TO_ADDR
// end ; end ; break ;
9088: GO 9092
// end ; end ;
9090: GO 8898
9092: POP
9093: POP
// end ;
9094: LD_VAR 0 4
9098: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9104: LD_ADDR_VAR 0 7
9108: PUSH
9109: LD_VAR 0 2
9113: PPUSH
9114: LD_VAR 0 3
9118: PPUSH
9119: LD_VAR 0 4
9123: PPUSH
9124: CALL 9286 0 3
9128: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9129: LD_ADDR_EXP 48
9133: PUSH
9134: LD_EXP 48
9138: PPUSH
9139: LD_VAR 0 1
9143: PPUSH
9144: LD_INT 2
9146: PPUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_VAR 0 3
9156: PUSH
9157: LD_VAR 0 4
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL 42407 0 4
9171: ST_TO_ADDR
// if ext_list then
9172: LD_VAR 0 5
9176: IFFALSE 9281
// for i = 1 to ext_list do
9178: LD_ADDR_VAR 0 8
9182: PUSH
9183: DOUBLE
9184: LD_INT 1
9186: DEC
9187: ST_TO_ADDR
9188: LD_VAR 0 5
9192: PUSH
9193: FOR_TO
9194: IFFALSE 9279
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9196: LD_ADDR_EXP 48
9200: PUSH
9201: LD_EXP 48
9205: PPUSH
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 8
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PUSH
9237: LD_VAR 0 7
9241: PUSH
9242: LD_VAR 0 8
9246: ARRAY
9247: PUSH
9248: LD_INT 2
9250: ARRAY
9251: PUSH
9252: LD_VAR 0 7
9256: PUSH
9257: LD_VAR 0 8
9261: ARRAY
9262: PUSH
9263: LD_INT 3
9265: ARRAY
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: PPUSH
9272: CALL 42407 0 4
9276: ST_TO_ADDR
9277: GO 9193
9279: POP
9280: POP
// end ;
9281: LD_VAR 0 6
9285: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
// list := [ ] ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: EMPTY
9296: ST_TO_ADDR
// case d of 0 :
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 0
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9443
9310: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9311: LD_ADDR_VAR 0 5
9315: PUSH
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 4
9323: MINUS
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 4
9332: MINUS
9333: PUSH
9334: LD_INT 2
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: LD_VAR 0 1
9346: PUSH
9347: LD_INT 3
9349: MINUS
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: LD_INT 1
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 4
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_VAR 0 1
9390: PUSH
9391: LD_INT 3
9393: PLUS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 3
9402: PLUS
9403: PUSH
9404: LD_INT 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_VAR 0 2
9421: PUSH
9422: LD_INT 4
9424: PLUS
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: ST_TO_ADDR
// end ; 1 :
9441: GO 10141
9443: LD_INT 1
9445: DOUBLE
9446: EQUAL
9447: IFTRUE 9451
9449: GO 9584
9451: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9452: LD_ADDR_VAR 0 5
9456: PUSH
9457: LD_VAR 0 1
9461: PUSH
9462: LD_VAR 0 2
9466: PUSH
9467: LD_INT 4
9469: MINUS
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: PUSH
9479: LD_VAR 0 1
9483: PUSH
9484: LD_INT 3
9486: MINUS
9487: PUSH
9488: LD_VAR 0 2
9492: PUSH
9493: LD_INT 3
9495: MINUS
9496: PUSH
9497: LD_INT 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: PUSH
9505: LD_VAR 0 1
9509: PUSH
9510: LD_INT 4
9512: MINUS
9513: PUSH
9514: LD_VAR 0 2
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: LD_INT 3
9539: PLUS
9540: PUSH
9541: LD_INT 0
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: LD_VAR 0 1
9553: PUSH
9554: LD_INT 4
9556: PLUS
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 4
9565: PLUS
9566: PUSH
9567: LD_INT 5
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: ST_TO_ADDR
// end ; 2 :
9582: GO 10141
9584: LD_INT 2
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9721
9592: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9593: LD_ADDR_VAR 0 5
9597: PUSH
9598: LD_VAR 0 1
9602: PUSH
9603: LD_VAR 0 2
9607: PUSH
9608: LD_INT 3
9610: MINUS
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: PLUS
9628: PUSH
9629: LD_VAR 0 2
9633: PUSH
9634: LD_INT 4
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 2
9651: PUSH
9652: LD_INT 4
9654: PLUS
9655: PUSH
9656: LD_INT 0
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 3
9671: MINUS
9672: PUSH
9673: LD_VAR 0 2
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: LD_INT 4
9693: MINUS
9694: PUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 4
9702: MINUS
9703: PUSH
9704: LD_INT 2
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: ST_TO_ADDR
// end ; 3 :
9719: GO 10141
9721: LD_INT 3
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9862
9729: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_VAR 0 1
9739: PUSH
9740: LD_INT 3
9742: PLUS
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 4
9764: PLUS
9765: PUSH
9766: LD_VAR 0 2
9770: PUSH
9771: LD_INT 4
9773: PLUS
9774: PUSH
9775: LD_INT 5
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_VAR 0 1
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_VAR 0 2
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: LD_INT 4
9817: MINUS
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: LIST
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_INT 3
9834: MINUS
9835: PUSH
9836: LD_VAR 0 2
9840: PUSH
9841: LD_INT 3
9843: MINUS
9844: PUSH
9845: LD_INT 2
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: ST_TO_ADDR
// end ; 4 :
9860: GO 10141
9862: LD_INT 4
9864: DOUBLE
9865: EQUAL
9866: IFTRUE 9870
9868: GO 10003
9870: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9871: LD_ADDR_VAR 0 5
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 4
9888: PLUS
9889: PUSH
9890: LD_INT 0
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_VAR 0 1
9902: PUSH
9903: LD_INT 3
9905: PLUS
9906: PUSH
9907: LD_VAR 0 2
9911: PUSH
9912: LD_INT 3
9914: PLUS
9915: PUSH
9916: LD_INT 5
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: PUSH
9924: LD_VAR 0 1
9928: PUSH
9929: LD_INT 3
9931: PLUS
9932: PUSH
9933: LD_VAR 0 2
9937: PUSH
9938: LD_INT 4
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: PUSH
9946: LD_VAR 0 1
9950: PUSH
9951: LD_VAR 0 2
9955: PUSH
9956: LD_INT 3
9958: MINUS
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: PUSH
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 4
9975: MINUS
9976: PUSH
9977: LD_VAR 0 2
9981: PUSH
9982: LD_INT 4
9984: MINUS
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: ST_TO_ADDR
// end ; 5 :
10001: GO 10141
10003: LD_INT 5
10005: DOUBLE
10006: EQUAL
10007: IFTRUE 10011
10009: GO 10140
10011: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10012: LD_ADDR_VAR 0 5
10016: PUSH
10017: LD_VAR 0 1
10021: PUSH
10022: LD_INT 4
10024: MINUS
10025: PUSH
10026: LD_VAR 0 2
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: LD_INT 4
10051: MINUS
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: PUSH
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 4
10068: PLUS
10069: PUSH
10070: LD_VAR 0 2
10074: PUSH
10075: LD_INT 4
10077: PLUS
10078: PUSH
10079: LD_INT 5
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: LD_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PLUS
10095: PUSH
10096: LD_VAR 0 2
10100: PUSH
10101: LD_INT 4
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_VAR 0 2
10118: PUSH
10119: LD_INT 3
10121: PLUS
10122: PUSH
10123: LD_INT 0
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: ST_TO_ADDR
// end ; end ;
10138: GO 10141
10140: POP
// result := list ;
10141: LD_ADDR_VAR 0 4
10145: PUSH
10146: LD_VAR 0 5
10150: ST_TO_ADDR
// end ;
10151: LD_VAR 0 4
10155: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10156: LD_INT 0
10158: PPUSH
10159: PPUSH
10160: PPUSH
10161: PPUSH
10162: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10163: LD_ADDR_VAR 0 10
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: EMPTY
10177: PPUSH
10178: CALL 11670 0 3
10182: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_VAR 0 1
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 30
10205: PUSH
10206: LD_INT 0
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_VAR 0 3
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL_OW 73
10254: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10255: LD_ADDR_VAR 0 8
10259: PUSH
10260: LD_VAR 0 9
10264: PPUSH
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL 10445 0 2
10274: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10275: LD_VAR 0 10
10279: PUSH
10280: LD_VAR 0 8
10284: AND
10285: PUSH
10286: LD_VAR 0 9
10290: PPUSH
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_VAR 0 4
10300: PPUSH
10301: CALL_OW 297
10305: PUSH
10306: LD_INT 26
10308: LESSEQUAL
10309: AND
10310: PUSH
10311: LD_VAR 0 3
10315: PPUSH
10316: LD_VAR 0 4
10320: PPUSH
10321: CALL_OW 428
10325: PUSH
10326: LD_INT 0
10328: EQUAL
10329: AND
10330: IFFALSE 10440
// for i = 1 to plist do
10332: LD_ADDR_VAR 0 7
10336: PUSH
10337: DOUBLE
10338: LD_INT 1
10340: DEC
10341: ST_TO_ADDR
10342: LD_VAR 0 10
10346: PUSH
10347: FOR_TO
10348: IFFALSE 10438
// if IsInUnit ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL_OW 310
10365: IFFALSE 10384
// ComExitBuilding ( plist [ i ] ) else
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: CALL_OW 122
10382: GO 10436
// if NotTask ( plist [ i ] ) then
10384: LD_VAR 0 10
10388: PUSH
10389: LD_VAR 0 7
10393: ARRAY
10394: PPUSH
10395: CALL 32464 0 1
10399: IFFALSE 10436
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10401: LD_VAR 0 10
10405: PUSH
10406: LD_VAR 0 7
10410: ARRAY
10411: PPUSH
10412: LD_VAR 0 2
10416: PPUSH
10417: LD_VAR 0 3
10421: PPUSH
10422: LD_VAR 0 4
10426: PPUSH
10427: LD_VAR 0 5
10431: PPUSH
10432: CALL_OW 145
// end ;
10436: GO 10347
10438: POP
10439: POP
// end ;
10440: LD_VAR 0 6
10444: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10445: LD_INT 0
10447: PPUSH
10448: PPUSH
10449: PPUSH
// pom := GetBase ( bdepot ) ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 274
10464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10465: LD_ADDR_VAR 0 5
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 248
10484: PPUSH
10485: CALL_OW 450
10489: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10490: LD_VAR 0 4
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 275
10502: PUSH
10503: LD_VAR 0 5
10507: PUSH
10508: LD_INT 1
10510: ARRAY
10511: GREATEREQUAL
10512: PUSH
10513: LD_VAR 0 4
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: CALL_OW 275
10525: PUSH
10526: LD_VAR 0 5
10530: PUSH
10531: LD_INT 3
10533: ARRAY
10534: GREATEREQUAL
10535: AND
10536: IFFALSE 10548
// result := true else
10538: LD_ADDR_VAR 0 3
10542: PUSH
10543: LD_INT 1
10545: ST_TO_ADDR
10546: GO 10556
// result := false ;
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: LD_INT 0
10555: ST_TO_ADDR
// end ;
10556: LD_VAR 0 3
10560: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10561: LD_INT 0
10563: PPUSH
10564: PPUSH
10565: PPUSH
10566: PPUSH
10567: PPUSH
// pom := GetBase ( bdepot ) ;
10568: LD_ADDR_VAR 0 5
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 274
10582: ST_TO_ADDR
// cost := [ ] ;
10583: LD_ADDR_VAR 0 8
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_VAR 0 1
10604: PPUSH
10605: CALL_OW 248
10609: PPUSH
10610: CALL_OW 450
10614: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10615: LD_ADDR_VAR 0 7
10619: PUSH
10620: LD_VAR 0 3
10624: PPUSH
10625: LD_VAR 0 1
10629: PPUSH
10630: CALL_OW 248
10634: PPUSH
10635: CALL_OW 450
10639: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10640: LD_ADDR_VAR 0 8
10644: PUSH
10645: LD_VAR 0 8
10649: PPUSH
10650: LD_INT 1
10652: PPUSH
10653: LD_VAR 0 6
10657: PUSH
10658: LD_INT 1
10660: ARRAY
10661: PUSH
10662: LD_VAR 0 7
10666: PUSH
10667: LD_INT 1
10669: ARRAY
10670: PLUS
10671: PPUSH
10672: CALL_OW 1
10676: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10677: LD_ADDR_VAR 0 8
10681: PUSH
10682: LD_VAR 0 8
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_VAR 0 6
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: PUSH
10699: LD_VAR 0 7
10703: PUSH
10704: LD_INT 2
10706: ARRAY
10707: PLUS
10708: PPUSH
10709: CALL_OW 1
10713: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10714: LD_ADDR_VAR 0 8
10718: PUSH
10719: LD_VAR 0 8
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_VAR 0 6
10731: PUSH
10732: LD_INT 3
10734: ARRAY
10735: PUSH
10736: LD_VAR 0 7
10740: PUSH
10741: LD_INT 3
10743: ARRAY
10744: PLUS
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 275
10763: PUSH
10764: LD_VAR 0 8
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: GREATEREQUAL
10773: PUSH
10774: LD_VAR 0 5
10778: PPUSH
10779: LD_INT 3
10781: PPUSH
10782: CALL_OW 275
10786: PUSH
10787: LD_VAR 0 8
10791: PUSH
10792: LD_INT 3
10794: ARRAY
10795: GREATEREQUAL
10796: AND
10797: IFFALSE 10809
// result := true else
10799: LD_ADDR_VAR 0 4
10803: PUSH
10804: LD_INT 1
10806: ST_TO_ADDR
10807: GO 10817
// result := false ;
10809: LD_ADDR_VAR 0 4
10813: PUSH
10814: LD_INT 0
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 4
10821: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
10826: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10827: LD_ADDR_VAR 0 5
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_INT 2
10839: PPUSH
10840: EMPTY
10841: PPUSH
10842: CALL 11670 0 3
10846: ST_TO_ADDR
// if unit and plist then
10847: LD_VAR 0 2
10851: PUSH
10852: LD_VAR 0 5
10856: AND
10857: IFFALSE 10918
// for i = 1 to plist do
10859: LD_ADDR_VAR 0 4
10863: PUSH
10864: DOUBLE
10865: LD_INT 1
10867: DEC
10868: ST_TO_ADDR
10869: LD_VAR 0 5
10873: PUSH
10874: FOR_TO
10875: IFFALSE 10916
// if NotTask ( plist [ i ] ) then
10877: LD_VAR 0 5
10881: PUSH
10882: LD_VAR 0 4
10886: ARRAY
10887: PPUSH
10888: CALL 32464 0 1
10892: IFFALSE 10914
// ComDismantle ( plist [ i ] , unit ) ;
10894: LD_VAR 0 5
10898: PUSH
10899: LD_VAR 0 4
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 2
10909: PPUSH
10910: CALL_OW 167
10914: GO 10874
10916: POP
10917: POP
// result := true ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// end ;
10926: LD_VAR 0 3
10930: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10931: LD_INT 0
10933: PPUSH
10934: PPUSH
10935: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10936: LD_ADDR_VAR 0 5
10940: PUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL 11670 0 3
10955: ST_TO_ADDR
// if unit and plist then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_VAR 0 5
10965: AND
10966: IFFALSE 11027
// for i = 1 to plist do
10968: LD_ADDR_VAR 0 4
10972: PUSH
10973: DOUBLE
10974: LD_INT 1
10976: DEC
10977: ST_TO_ADDR
10978: LD_VAR 0 5
10982: PUSH
10983: FOR_TO
10984: IFFALSE 11025
// if NotTask ( plist [ i ] ) then
10986: LD_VAR 0 5
10990: PUSH
10991: LD_VAR 0 4
10995: ARRAY
10996: PPUSH
10997: CALL 32464 0 1
11001: IFFALSE 11023
// ComComplete ( plist [ i ] , unit ) ;
11003: LD_VAR 0 5
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: CALL 32000 0 2
11023: GO 10983
11025: POP
11026: POP
// result := true ;
11027: LD_ADDR_VAR 0 3
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// end ;
11035: LD_VAR 0 3
11039: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11040: LD_INT 0
11042: PPUSH
11043: PPUSH
11044: PPUSH
11045: PPUSH
11046: PPUSH
11047: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 21
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 3
11077: PUSH
11078: LD_INT 57
11080: PUSH
11081: EMPTY
11082: LIST
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: LD_INT 24
11093: PUSH
11094: LD_INT 1000
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: ST_TO_ADDR
// r := [ ] ;
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: EMPTY
11122: ST_TO_ADDR
// if not tmp then
11123: LD_VAR 0 5
11127: NOT
11128: IFFALSE 11134
// exit else
11130: GO 11322
11132: GO 11302
// begin r := [ tmp [ 1 ] ] ;
11134: LD_ADDR_VAR 0 6
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 1
11146: ARRAY
11147: PUSH
11148: EMPTY
11149: LIST
11150: ST_TO_ADDR
// for i = 2 to tmp do
11151: LD_ADDR_VAR 0 3
11155: PUSH
11156: DOUBLE
11157: LD_INT 2
11159: DEC
11160: ST_TO_ADDR
11161: LD_VAR 0 5
11165: PUSH
11166: FOR_TO
11167: IFFALSE 11300
// begin m := false ;
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// for j = 1 to r do
11177: LD_ADDR_VAR 0 4
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 6
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11267
// if GetLives ( tmp [ i ] ) < r [ j ] then
11195: LD_VAR 0 5
11199: PUSH
11200: LD_VAR 0 3
11204: ARRAY
11205: PPUSH
11206: CALL_OW 256
11210: PUSH
11211: LD_VAR 0 6
11215: PUSH
11216: LD_VAR 0 4
11220: ARRAY
11221: LESS
11222: IFFALSE 11265
// begin r := Insert ( r , j , tmp [ i ] ) ;
11224: LD_ADDR_VAR 0 6
11228: PUSH
11229: LD_VAR 0 6
11233: PPUSH
11234: LD_VAR 0 4
11238: PPUSH
11239: LD_VAR 0 5
11243: PUSH
11244: LD_VAR 0 3
11248: ARRAY
11249: PPUSH
11250: CALL_OW 2
11254: ST_TO_ADDR
// m := true ;
11255: LD_ADDR_VAR 0 7
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// break ;
11263: GO 11267
// end ;
11265: GO 11192
11267: POP
11268: POP
// if not m then
11269: LD_VAR 0 7
11273: NOT
11274: IFFALSE 11298
// r := r ^ tmp [ i ] ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_VAR 0 6
11285: PUSH
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: ADD
11297: ST_TO_ADDR
// end ;
11298: GO 11166
11300: POP
11301: POP
// end ; if r then
11302: LD_VAR 0 6
11306: IFFALSE 11320
// result := r else
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_VAR 0 6
11317: ST_TO_ADDR
11318: GO 11322
// exit ;
11320: GO 11322
// end ;
11322: LD_VAR 0 2
11326: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11327: LD_INT 0
11329: PPUSH
11330: PPUSH
11331: PPUSH
11332: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 16
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 13
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 34
11385: PUSH
11386: LD_INT 52
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 24
11402: PUSH
11403: LD_INT 650
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// p := 1 ;
11420: LD_ADDR_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: ST_TO_ADDR
// for i = 1 to repairs do
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: DOUBLE
11434: LD_INT 1
11436: DEC
11437: ST_TO_ADDR
11438: LD_VAR 0 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11580
// begin if IsInUnit ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 310
11461: IFFALSE 11480
// ComExitBuilding ( repairs [ i ] ) else
11463: LD_VAR 0 5
11467: PUSH
11468: LD_VAR 0 3
11472: ARRAY
11473: PPUSH
11474: CALL_OW 122
11478: GO 11578
// if not HasTask ( repairs [ i ] ) then
11480: LD_VAR 0 5
11484: PUSH
11485: LD_VAR 0 3
11489: ARRAY
11490: PPUSH
11491: CALL_OW 314
11495: NOT
11496: IFFALSE 11578
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11498: LD_VAR 0 5
11502: PUSH
11503: LD_VAR 0 3
11507: ARRAY
11508: PPUSH
11509: LD_EXP 49
11513: PUSH
11514: LD_VAR 0 1
11518: ARRAY
11519: PUSH
11520: LD_VAR 0 4
11524: ARRAY
11525: PPUSH
11526: CALL_OW 130
// if i mod 3 = 0 then
11530: LD_VAR 0 3
11534: PUSH
11535: LD_INT 3
11537: MOD
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11558
// p := p + 1 ;
11544: LD_ADDR_VAR 0 4
11548: PUSH
11549: LD_VAR 0 4
11553: PUSH
11554: LD_INT 1
11556: PLUS
11557: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11558: LD_EXP 49
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: PUSH
11569: LD_VAR 0 4
11573: LESS
11574: IFFALSE 11578
// break ;
11576: GO 11580
// end ; end ;
11578: GO 11443
11580: POP
11581: POP
// end ; end_of_file
11582: LD_VAR 0 2
11586: RET
// export function MCF_Get ( side , filter ) ; begin
11587: LD_INT 0
11589: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// end ;
11621: LD_VAR 0 3
11625: RET
// export function MCF_Lab ( side ) ; begin
11626: LD_INT 0
11628: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11629: LD_ADDR_VAR 0 2
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_VAR 0 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 30
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: ST_TO_ADDR
// end ;
11665: LD_VAR 0 2
11669: RET
// export function MCF_Class ( side , class , filter ) ; begin
11670: LD_INT 0
11672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11673: LD_ADDR_VAR 0 4
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_VAR 0 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_All ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 25
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 25
11767: PUSH
11768: LD_INT 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// end ;
11807: LD_VAR 0 3
11811: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11812: LD_INT 0
11814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11815: LD_ADDR_VAR 0 4
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 92
11834: PUSH
11835: LD_VAR 0 2
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PUSH
11844: LD_VAR 0 2
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PUSH
11853: LD_VAR 0 2
11857: PUSH
11858: LD_INT 3
11860: ARRAY
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// end ;
11883: LD_VAR 0 4
11887: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11888: LD_INT 0
11890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_VAR 0 1
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 21
11910: PUSH
11911: LD_INT 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_VAR 0 2
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PPUSH
11928: CALL_OW 69
11932: ST_TO_ADDR
// end ;
11933: LD_VAR 0 3
11937: RET
// export function MCF_Cargo ( side ) ; begin
11938: LD_INT 0
11940: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11941: LD_ADDR_VAR 0 2
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 12
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 51
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL 11888 0 2
11994: ST_TO_ADDR
// end ;
11995: LD_VAR 0 2
11999: RET
// export function MCF_Ape ( side ) ; begin
12000: LD_INT 0
12002: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12003: LD_ADDR_VAR 0 2
12007: PUSH
12008: LD_INT 22
12010: PUSH
12011: LD_VAR 0 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 2
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 12
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 15
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 16
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 25
12055: PUSH
12056: LD_INT 17
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: ST_TO_ADDR
// end ;
12079: LD_VAR 0 2
12083: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12084: LD_INT 0
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 3
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12097: LD_ADDR_VAR 0 4
12101: PUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL 12000 0 1
12111: ST_TO_ADDR
// case type of 0 , normal :
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12131
12123: LD_STRING normal
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12142
12131: POP
// cl := class_apeman ; 1 , soldier :
12132: LD_ADDR_VAR 0 5
12136: PUSH
12137: LD_INT 12
12139: ST_TO_ADDR
12140: GO 12218
12142: LD_INT 1
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12156
12148: LD_STRING soldier
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12156
12154: GO 12167
12156: POP
// cl := class_apeman_soldier ; 2 , engineer :
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 15
12164: ST_TO_ADDR
12165: GO 12218
12167: LD_INT 2
12169: DOUBLE
12170: EQUAL
12171: IFTRUE 12181
12173: LD_STRING engineer
12175: DOUBLE
12176: EQUAL
12177: IFTRUE 12181
12179: GO 12192
12181: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12182: LD_ADDR_VAR 0 5
12186: PUSH
12187: LD_INT 16
12189: ST_TO_ADDR
12190: GO 12218
12192: LD_INT 3
12194: DOUBLE
12195: EQUAL
12196: IFTRUE 12206
12198: LD_STRING kamikaze
12200: DOUBLE
12201: EQUAL
12202: IFTRUE 12206
12204: GO 12217
12206: POP
// cl := class_apeman_kamikaze ; end ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_INT 17
12214: ST_TO_ADDR
12215: GO 12218
12217: POP
// for i = 1 to tmp do
12218: LD_ADDR_VAR 0 6
12222: PUSH
12223: DOUBLE
12224: LD_INT 1
12226: DEC
12227: ST_TO_ADDR
12228: LD_VAR 0 4
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12283
// if GetClass ( tmp [ i ] ) = cl then
12236: LD_VAR 0 4
12240: PUSH
12241: LD_VAR 0 6
12245: ARRAY
12246: PPUSH
12247: CALL_OW 257
12251: PUSH
12252: LD_VAR 0 5
12256: EQUAL
12257: IFFALSE 12281
// result := result ^ tmp [ i ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_VAR 0 4
12273: PUSH
12274: LD_VAR 0 6
12278: ARRAY
12279: ADD
12280: ST_TO_ADDR
12281: GO 12233
12283: POP
12284: POP
// end ;
12285: LD_VAR 0 3
12289: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_VAR 0 3
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 69
12326: ST_TO_ADDR
// r := [ ] ;
12327: LD_ADDR_VAR 0 6
12331: PUSH
12332: EMPTY
12333: ST_TO_ADDR
// if tmp then
12334: LD_VAR 0 5
12338: IFFALSE 12407
// for i = 1 to tmp do
12340: LD_ADDR_VAR 0 7
12344: PUSH
12345: DOUBLE
12346: LD_INT 1
12348: DEC
12349: ST_TO_ADDR
12350: LD_VAR 0 5
12354: PUSH
12355: FOR_TO
12356: IFFALSE 12405
// if GetTag ( tmp [ i ] ) = tag then
12358: LD_VAR 0 5
12362: PUSH
12363: LD_VAR 0 7
12367: ARRAY
12368: PPUSH
12369: CALL_OW 110
12373: PUSH
12374: LD_VAR 0 2
12378: EQUAL
12379: IFFALSE 12403
// r := r ^ tmp [ i ] ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_VAR 0 6
12390: PUSH
12391: LD_VAR 0 5
12395: PUSH
12396: LD_VAR 0 7
12400: ARRAY
12401: ADD
12402: ST_TO_ADDR
12403: GO 12355
12405: POP
12406: POP
// result := r ;
12407: LD_ADDR_VAR 0 4
12411: PUSH
12412: LD_VAR 0 6
12416: ST_TO_ADDR
// end ;
12417: LD_VAR 0 4
12421: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12422: LD_INT 0
12424: PPUSH
12425: PPUSH
12426: PPUSH
// tmp := plist ;
12427: LD_ADDR_VAR 0 5
12431: PUSH
12432: LD_VAR 0 2
12436: ST_TO_ADDR
// if tmp then
12437: LD_VAR 0 5
12441: IFFALSE 12518
// begin for i = 1 to tmp do
12443: LD_ADDR_VAR 0 6
12447: PUSH
12448: DOUBLE
12449: LD_INT 1
12451: DEC
12452: ST_TO_ADDR
12453: LD_VAR 0 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12506
// if GetTag ( tmp [ i ] ) <> tag then
12461: LD_VAR 0 5
12465: PUSH
12466: LD_VAR 0 6
12470: ARRAY
12471: PPUSH
12472: CALL_OW 110
12476: PUSH
12477: LD_VAR 0 3
12481: NONEQUAL
12482: IFFALSE 12504
// SetTag ( tmp [ i ] , tag ) ;
12484: LD_VAR 0 5
12488: PUSH
12489: LD_VAR 0 6
12493: ARRAY
12494: PPUSH
12495: LD_VAR 0 3
12499: PPUSH
12500: CALL_OW 109
12504: GO 12458
12506: POP
12507: POP
// result := true ;
12508: LD_ADDR_VAR 0 4
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// end else
12516: GO 12526
// result := false ;
12518: LD_ADDR_VAR 0 4
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// end ;
12526: LD_VAR 0 4
12530: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: EMPTY
12552: PPUSH
12553: CALL 12290 0 3
12557: ST_TO_ADDR
// if tmp then
12558: LD_VAR 0 4
12562: IFFALSE 12614
// begin for i = 1 to tmp do
12564: LD_ADDR_VAR 0 5
12568: PUSH
12569: DOUBLE
12570: LD_INT 1
12572: DEC
12573: ST_TO_ADDR
12574: LD_VAR 0 4
12578: PUSH
12579: FOR_TO
12580: IFFALSE 12602
// SetTag ( tmp [ i ] , 0 ) ;
12582: LD_VAR 0 4
12586: PUSH
12587: LD_VAR 0 5
12591: ARRAY
12592: PPUSH
12593: LD_INT 0
12595: PPUSH
12596: CALL_OW 109
12600: GO 12579
12602: POP
12603: POP
// result := true ;
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// end else
12612: GO 12622
// result := false ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 3
12626: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
12631: PPUSH
12632: PPUSH
12633: PPUSH
// sort_list := [ ] ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: EMPTY
12640: ST_TO_ADDR
// for i = 1 to list do
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: DOUBLE
12647: LD_INT 1
12649: DEC
12650: ST_TO_ADDR
12651: LD_VAR 0 1
12655: PUSH
12656: FOR_TO
12657: IFFALSE 12819
// begin if i = 1 then
12659: LD_VAR 0 3
12663: PUSH
12664: LD_INT 1
12666: EQUAL
12667: IFFALSE 12693
// sort_list := sort_list ^ list [ i ] else
12669: LD_ADDR_VAR 0 5
12673: PUSH
12674: LD_VAR 0 5
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: LD_VAR 0 3
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
12691: GO 12817
// begin for j = 1 to sort_list do
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: DOUBLE
12699: LD_INT 1
12701: DEC
12702: ST_TO_ADDR
12703: LD_VAR 0 5
12707: PUSH
12708: FOR_TO
12709: IFFALSE 12786
// begin add := false ;
12711: LD_ADDR_VAR 0 6
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12719: LD_VAR 0 1
12723: PUSH
12724: LD_VAR 0 3
12728: ARRAY
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: LD_VAR 0 4
12739: ARRAY
12740: LESS
12741: IFFALSE 12784
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12743: LD_ADDR_VAR 0 5
12747: PUSH
12748: LD_VAR 0 5
12752: PPUSH
12753: LD_VAR 0 4
12757: PPUSH
12758: LD_VAR 0 1
12762: PUSH
12763: LD_VAR 0 3
12767: ARRAY
12768: PPUSH
12769: CALL_OW 2
12773: ST_TO_ADDR
// add := true ;
12774: LD_ADDR_VAR 0 6
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// break ;
12782: GO 12786
// end ; end ;
12784: GO 12708
12786: POP
12787: POP
// if not add then
12788: LD_VAR 0 6
12792: NOT
12793: IFFALSE 12817
// sort_list := sort_list ^ list [ i ] ;
12795: LD_ADDR_VAR 0 5
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 1
12809: PUSH
12810: LD_VAR 0 3
12814: ARRAY
12815: ADD
12816: ST_TO_ADDR
// end ; end ;
12817: GO 12656
12819: POP
12820: POP
// result := sort_list ;
12821: LD_ADDR_VAR 0 2
12825: PUSH
12826: LD_VAR 0 5
12830: ST_TO_ADDR
// end ;
12831: LD_VAR 0 2
12835: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
// sort_list := [ ] ;
12843: LD_ADDR_VAR 0 5
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i = 1 to list do
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_VAR 0 1
12864: PUSH
12865: FOR_TO
12866: IFFALSE 13028
// begin if i = 1 then
12868: LD_VAR 0 3
12872: PUSH
12873: LD_INT 1
12875: EQUAL
12876: IFFALSE 12902
// sort_list := sort_list ^ list [ i ] else
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_VAR 0 5
12887: PUSH
12888: LD_VAR 0 1
12892: PUSH
12893: LD_VAR 0 3
12897: ARRAY
12898: ADD
12899: ST_TO_ADDR
12900: GO 13026
// begin for j = 1 to sort_list do
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: DOUBLE
12908: LD_INT 1
12910: DEC
12911: ST_TO_ADDR
12912: LD_VAR 0 5
12916: PUSH
12917: FOR_TO
12918: IFFALSE 12995
// begin add := false ;
12920: LD_ADDR_VAR 0 6
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 5
12943: PUSH
12944: LD_VAR 0 4
12948: ARRAY
12949: GREATER
12950: IFFALSE 12993
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12952: LD_ADDR_VAR 0 5
12956: PUSH
12957: LD_VAR 0 5
12961: PPUSH
12962: LD_VAR 0 4
12966: PPUSH
12967: LD_VAR 0 1
12971: PUSH
12972: LD_VAR 0 3
12976: ARRAY
12977: PPUSH
12978: CALL_OW 2
12982: ST_TO_ADDR
// add := true ;
12983: LD_ADDR_VAR 0 6
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// break ;
12991: GO 12995
// end ; end ;
12993: GO 12917
12995: POP
12996: POP
// if not add then
12997: LD_VAR 0 6
13001: NOT
13002: IFFALSE 13026
// sort_list := sort_list ^ list [ i ] ;
13004: LD_ADDR_VAR 0 5
13008: PUSH
13009: LD_VAR 0 5
13013: PUSH
13014: LD_VAR 0 1
13018: PUSH
13019: LD_VAR 0 3
13023: ARRAY
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12865
13028: POP
13029: POP
// result := sort_list ;
13030: LD_ADDR_VAR 0 2
13034: PUSH
13035: LD_VAR 0 5
13039: ST_TO_ADDR
// end ;
13040: LD_VAR 0 2
13044: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13045: LD_INT 0
13047: PPUSH
13048: PPUSH
13049: PPUSH
13050: PPUSH
13051: PPUSH
13052: PPUSH
// tmp := [ ] ;
13053: LD_ADDR_VAR 0 8
13057: PUSH
13058: EMPTY
13059: ST_TO_ADDR
// r := [ ] ;
13060: LD_ADDR_VAR 0 7
13064: PUSH
13065: EMPTY
13066: ST_TO_ADDR
// add := false ;
13067: LD_ADDR_VAR 0 9
13071: PUSH
13072: LD_INT 0
13074: ST_TO_ADDR
// if plist then
13075: LD_VAR 0 2
13079: IFFALSE 13155
// begin for i = 1 to plist do
13081: LD_ADDR_VAR 0 5
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13151
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13099: LD_ADDR_VAR 0 8
13103: PUSH
13104: LD_VAR 0 8
13108: PUSH
13109: LD_VAR 0 2
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PUSH
13120: LD_VAR 0 2
13124: PUSH
13125: LD_VAR 0 5
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 3
13135: PPUSH
13136: CALL_OW 259
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: ADD
13148: ST_TO_ADDR
// end ;
13149: GO 13096
13151: POP
13152: POP
// end else
13153: GO 13163
// result := false ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 0
13162: ST_TO_ADDR
// if tmp then
13163: LD_VAR 0 8
13167: IFFALSE 13341
// begin r := r ^ [ tmp [ 1 ] ] ;
13169: LD_ADDR_VAR 0 7
13173: PUSH
13174: LD_VAR 0 7
13178: PUSH
13179: LD_VAR 0 8
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: EMPTY
13189: LIST
13190: ADD
13191: ST_TO_ADDR
// for i = 2 to tmp do
13192: LD_ADDR_VAR 0 5
13196: PUSH
13197: DOUBLE
13198: LD_INT 2
13200: DEC
13201: ST_TO_ADDR
13202: LD_VAR 0 8
13206: PUSH
13207: FOR_TO
13208: IFFALSE 13339
// begin for j = 1 to r do
13210: LD_ADDR_VAR 0 6
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_VAR 0 7
13224: PUSH
13225: FOR_TO
13226: IFFALSE 13303
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13228: LD_VAR 0 8
13232: PUSH
13233: LD_VAR 0 5
13237: ARRAY
13238: PUSH
13239: LD_INT 2
13241: ARRAY
13242: PUSH
13243: LD_VAR 0 7
13247: PUSH
13248: LD_VAR 0 6
13252: ARRAY
13253: PUSH
13254: LD_INT 2
13256: ARRAY
13257: LESS
13258: IFFALSE 13301
// begin r := Insert ( r , j , tmp [ i ] ) ;
13260: LD_ADDR_VAR 0 7
13264: PUSH
13265: LD_VAR 0 7
13269: PPUSH
13270: LD_VAR 0 6
13274: PPUSH
13275: LD_VAR 0 8
13279: PUSH
13280: LD_VAR 0 5
13284: ARRAY
13285: PPUSH
13286: CALL_OW 2
13290: ST_TO_ADDR
// add := true ;
13291: LD_ADDR_VAR 0 9
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// break ;
13299: GO 13303
// end ; end ;
13301: GO 13225
13303: POP
13304: POP
// if not add then
13305: LD_VAR 0 9
13309: NOT
13310: IFFALSE 13337
// r := r ^ [ tmp [ i ] ] ;
13312: LD_ADDR_VAR 0 7
13316: PUSH
13317: LD_VAR 0 7
13321: PUSH
13322: LD_VAR 0 8
13326: PUSH
13327: LD_VAR 0 5
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// end ;
13337: GO 13207
13339: POP
13340: POP
// end ; result := r ;
13341: LD_ADDR_VAR 0 4
13345: PUSH
13346: LD_VAR 0 7
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 4
13355: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
// tmp := [ ] ;
13364: LD_ADDR_VAR 0 8
13368: PUSH
13369: EMPTY
13370: ST_TO_ADDR
// r := [ ] ;
13371: LD_ADDR_VAR 0 7
13375: PUSH
13376: EMPTY
13377: ST_TO_ADDR
// add := false ;
13378: LD_ADDR_VAR 0 9
13382: PUSH
13383: LD_INT 0
13385: ST_TO_ADDR
// if plist then
13386: LD_VAR 0 2
13390: IFFALSE 13466
// begin for i = 1 to plist do
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: DOUBLE
13398: LD_INT 1
13400: DEC
13401: ST_TO_ADDR
13402: LD_VAR 0 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13462
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13410: LD_ADDR_VAR 0 8
13414: PUSH
13415: LD_VAR 0 8
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: LD_VAR 0 5
13440: ARRAY
13441: PPUSH
13442: LD_VAR 0 3
13446: PPUSH
13447: CALL_OW 259
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: ADD
13459: ST_TO_ADDR
// end ;
13460: GO 13407
13462: POP
13463: POP
// end else
13464: GO 13474
// result := false ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// if tmp then
13474: LD_VAR 0 8
13478: IFFALSE 13652
// begin r := r ^ [ tmp [ 1 ] ] ;
13480: LD_ADDR_VAR 0 7
13484: PUSH
13485: LD_VAR 0 7
13489: PUSH
13490: LD_VAR 0 8
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: PUSH
13499: EMPTY
13500: LIST
13501: ADD
13502: ST_TO_ADDR
// for i = 2 to tmp do
13503: LD_ADDR_VAR 0 5
13507: PUSH
13508: DOUBLE
13509: LD_INT 2
13511: DEC
13512: ST_TO_ADDR
13513: LD_VAR 0 8
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13650
// begin for j = 1 to r do
13521: LD_ADDR_VAR 0 6
13525: PUSH
13526: DOUBLE
13527: LD_INT 1
13529: DEC
13530: ST_TO_ADDR
13531: LD_VAR 0 7
13535: PUSH
13536: FOR_TO
13537: IFFALSE 13614
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13539: LD_VAR 0 8
13543: PUSH
13544: LD_VAR 0 5
13548: ARRAY
13549: PUSH
13550: LD_INT 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 7
13558: PUSH
13559: LD_VAR 0 6
13563: ARRAY
13564: PUSH
13565: LD_INT 2
13567: ARRAY
13568: GREATER
13569: IFFALSE 13612
// begin r := Insert ( r , j , tmp [ i ] ) ;
13571: LD_ADDR_VAR 0 7
13575: PUSH
13576: LD_VAR 0 7
13580: PPUSH
13581: LD_VAR 0 6
13585: PPUSH
13586: LD_VAR 0 8
13590: PUSH
13591: LD_VAR 0 5
13595: ARRAY
13596: PPUSH
13597: CALL_OW 2
13601: ST_TO_ADDR
// add := true ;
13602: LD_ADDR_VAR 0 9
13606: PUSH
13607: LD_INT 1
13609: ST_TO_ADDR
// break ;
13610: GO 13614
// end ; end ;
13612: GO 13536
13614: POP
13615: POP
// if not add then
13616: LD_VAR 0 9
13620: NOT
13621: IFFALSE 13648
// r := r ^ [ tmp [ i ] ] ;
13623: LD_ADDR_VAR 0 7
13627: PUSH
13628: LD_VAR 0 7
13632: PUSH
13633: LD_VAR 0 8
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: EMPTY
13645: LIST
13646: ADD
13647: ST_TO_ADDR
// end ;
13648: GO 13518
13650: POP
13651: POP
// end ; result := r ;
13652: LD_ADDR_VAR 0 4
13656: PUSH
13657: LD_VAR 0 7
13661: ST_TO_ADDR
// end ;
13662: LD_VAR 0 4
13666: RET
// export function MCF_Clear ( side ) ; var i ; begin
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
// for i = 1 to 100 do
13671: LD_ADDR_VAR 0 3
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 100
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13721
// if MCF_Tag ( side , i , [ ] ) then
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 3
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL 12290 0 3
13703: IFFALSE 13719
// MCF_ClearTag ( side , i ) ;
13705: LD_VAR 0 1
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: CALL 12531 0 2
13719: GO 13684
13721: POP
13722: POP
// result := true ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_INT 1
13730: ST_TO_ADDR
// end ;
13731: LD_VAR 0 2
13735: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// for i = 1 to plist do
13741: LD_ADDR_VAR 0 4
13745: PUSH
13746: DOUBLE
13747: LD_INT 1
13749: DEC
13750: ST_TO_ADDR
13751: LD_VAR 0 1
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13806
// if MCF_HasClass ( plist [ i ] ) = n then
13759: LD_VAR 0 1
13763: PUSH
13764: LD_VAR 0 4
13768: ARRAY
13769: PPUSH
13770: CALL 14293 0 1
13774: PUSH
13775: LD_VAR 0 2
13779: EQUAL
13780: IFFALSE 13804
// tmp := tmp ^ plist [ i ] ;
13782: LD_ADDR_VAR 0 5
13786: PUSH
13787: LD_VAR 0 5
13791: PUSH
13792: LD_VAR 0 1
13796: PUSH
13797: LD_VAR 0 4
13801: ARRAY
13802: ADD
13803: ST_TO_ADDR
13804: GO 13756
13806: POP
13807: POP
// result := tmp ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_VAR 0 5
13817: ST_TO_ADDR
// end ;
13818: LD_VAR 0 3
13822: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13823: LD_INT 0
13825: PPUSH
13826: PPUSH
13827: PPUSH
// if mreg = ToArm then
13828: LD_VAR 0 2
13832: PUSH
13833: LD_STRING ToArm
13835: EQUAL
13836: IFFALSE 13941
// begin tmp := MREG_ToArm [ side ] ;
13838: LD_ADDR_VAR 0 6
13842: PUSH
13843: LD_EXP 58
13847: PUSH
13848: LD_VAR 0 1
13852: ARRAY
13853: ST_TO_ADDR
// if tmp = 0 then
13854: LD_VAR 0 6
13858: PUSH
13859: LD_INT 0
13861: EQUAL
13862: IFFALSE 13868
// exit else
13864: GO 14288
13866: GO 13941
// begin for i = MREG_ToArm [ side ] downto n do
13868: LD_ADDR_VAR 0 5
13872: PUSH
13873: DOUBLE
13874: LD_EXP 58
13878: PUSH
13879: LD_VAR 0 1
13883: ARRAY
13884: INC
13885: ST_TO_ADDR
13886: LD_VAR 0 3
13890: PUSH
13891: FOR_DOWNTO
13892: IFFALSE 13914
// tmp := Delete ( tmp , 1 ) ;
13894: LD_ADDR_VAR 0 6
13898: PUSH
13899: LD_VAR 0 6
13903: PPUSH
13904: LD_INT 1
13906: PPUSH
13907: CALL_OW 3
13911: ST_TO_ADDR
13912: GO 13891
13914: POP
13915: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13916: LD_ADDR_EXP 58
13920: PUSH
13921: LD_EXP 58
13925: PPUSH
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: CALL_OW 1
13940: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13941: LD_VAR 0 2
13945: PUSH
13946: LD_STRING ToDep
13948: EQUAL
13949: IFFALSE 14054
// begin tmp := MREG_ToDep [ side ] ;
13951: LD_ADDR_VAR 0 6
13955: PUSH
13956: LD_EXP 59
13960: PUSH
13961: LD_VAR 0 1
13965: ARRAY
13966: ST_TO_ADDR
// if tmp = 0 then
13967: LD_VAR 0 6
13971: PUSH
13972: LD_INT 0
13974: EQUAL
13975: IFFALSE 13981
// exit else
13977: GO 14288
13979: GO 14054
// begin for i = MREG_ToDep [ side ] downto n do
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: DOUBLE
13987: LD_EXP 59
13991: PUSH
13992: LD_VAR 0 1
13996: ARRAY
13997: INC
13998: ST_TO_ADDR
13999: LD_VAR 0 3
14003: PUSH
14004: FOR_DOWNTO
14005: IFFALSE 14027
// tmp := Delete ( tmp , 1 ) ;
14007: LD_ADDR_VAR 0 6
14011: PUSH
14012: LD_VAR 0 6
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL_OW 3
14024: ST_TO_ADDR
14025: GO 14004
14027: POP
14028: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14029: LD_ADDR_EXP 59
14033: PUSH
14034: LD_EXP 59
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: CALL_OW 1
14053: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14054: LD_VAR 0 2
14058: PUSH
14059: LD_STRING ToFac
14061: EQUAL
14062: IFFALSE 14167
// begin tmp := MREG_ToFac [ side ] ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_EXP 57
14073: PUSH
14074: LD_VAR 0 1
14078: ARRAY
14079: ST_TO_ADDR
// if tmp = 0 then
14080: LD_VAR 0 6
14084: PUSH
14085: LD_INT 0
14087: EQUAL
14088: IFFALSE 14094
// exit else
14090: GO 14288
14092: GO 14167
// begin for i = MREG_ToFac [ side ] downto n do
14094: LD_ADDR_VAR 0 5
14098: PUSH
14099: DOUBLE
14100: LD_EXP 57
14104: PUSH
14105: LD_VAR 0 1
14109: ARRAY
14110: INC
14111: ST_TO_ADDR
14112: LD_VAR 0 3
14116: PUSH
14117: FOR_DOWNTO
14118: IFFALSE 14140
// tmp := Delete ( tmp , 1 ) ;
14120: LD_ADDR_VAR 0 6
14124: PUSH
14125: LD_VAR 0 6
14129: PPUSH
14130: LD_INT 1
14132: PPUSH
14133: CALL_OW 3
14137: ST_TO_ADDR
14138: GO 14117
14140: POP
14141: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14142: LD_ADDR_EXP 57
14146: PUSH
14147: LD_EXP 57
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 6
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14167: LD_VAR 0 2
14171: PUSH
14172: LD_STRING ToLab
14174: EQUAL
14175: IFFALSE 14280
// begin tmp := MREG_ToLab [ side ] ;
14177: LD_ADDR_VAR 0 6
14181: PUSH
14182: LD_EXP 56
14186: PUSH
14187: LD_VAR 0 1
14191: ARRAY
14192: ST_TO_ADDR
// if tmp = 0 then
14193: LD_VAR 0 6
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: IFFALSE 14207
// exit else
14203: GO 14288
14205: GO 14280
// begin for i = MREG_ToLab [ side ] downto n do
14207: LD_ADDR_VAR 0 5
14211: PUSH
14212: DOUBLE
14213: LD_EXP 56
14217: PUSH
14218: LD_VAR 0 1
14222: ARRAY
14223: INC
14224: ST_TO_ADDR
14225: LD_VAR 0 3
14229: PUSH
14230: FOR_DOWNTO
14231: IFFALSE 14253
// tmp := Delete ( tmp , 1 ) ;
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 6
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: CALL_OW 3
14250: ST_TO_ADDR
14251: GO 14230
14253: POP
14254: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_EXP 56
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_VAR 0 6
14274: PPUSH
14275: CALL_OW 1
14279: ST_TO_ADDR
// end ; end ; result := true ;
14280: LD_ADDR_VAR 0 4
14284: PUSH
14285: LD_INT 1
14287: ST_TO_ADDR
// end ;
14288: LD_VAR 0 4
14292: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14293: LD_INT 0
14295: PPUSH
14296: PPUSH
14297: PPUSH
// side := GetSide ( unit ) ;
14298: LD_ADDR_VAR 0 4
14302: PUSH
14303: LD_VAR 0 1
14307: PPUSH
14308: CALL_OW 255
14312: ST_TO_ADDR
// tmp := 0 ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 4
14335: ARRAY
14336: IN
14337: IFFALSE 14347
// tmp := 1 ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 1
14346: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14347: LD_VAR 0 1
14351: PUSH
14352: LD_EXP 59
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: IN
14363: IFFALSE 14373
// tmp := 2 ;
14365: LD_ADDR_VAR 0 3
14369: PUSH
14370: LD_INT 2
14372: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14373: LD_VAR 0 1
14377: PUSH
14378: LD_EXP 57
14382: PUSH
14383: LD_VAR 0 4
14387: ARRAY
14388: IN
14389: IFFALSE 14399
// tmp := 3 ;
14391: LD_ADDR_VAR 0 3
14395: PUSH
14396: LD_INT 3
14398: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 56
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: IN
14415: IFFALSE 14425
// tmp := 4 ;
14417: LD_ADDR_VAR 0 3
14421: PUSH
14422: LD_INT 4
14424: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14425: LD_VAR 0 1
14429: PUSH
14430: LD_EXP 70
14434: PUSH
14435: LD_VAR 0 4
14439: ARRAY
14440: IN
14441: IFFALSE 14451
// tmp := 5 ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 5
14450: ST_TO_ADDR
// result := tmp ;
14451: LD_ADDR_VAR 0 2
14455: PUSH
14456: LD_VAR 0 3
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
// if mreg = ToArm then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToArm
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToArm [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 58
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToArm [ side ] [ i ] = unit then
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 58
14532: PUSH
14533: LD_EXP 58
14537: PPUSH
14538: LD_EXP 58
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31284 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToDep then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToDep
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToDep [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 59
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToDep [ side ] [ i ] = unit then
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 59
14629: PUSH
14630: LD_EXP 59
14634: PPUSH
14635: LD_EXP 59
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31284 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// if mreg = ToFac then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_STRING ToFac
14671: EQUAL
14672: IFFALSE 14761
// for i = MREG_ToFac [ side ] downto 1 do
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: DOUBLE
14680: LD_EXP 57
14684: PUSH
14685: LD_VAR 0 1
14689: ARRAY
14690: INC
14691: ST_TO_ADDR
14692: LD_INT 1
14694: PUSH
14695: FOR_DOWNTO
14696: IFFALSE 14759
// if MREG_ToFac [ side ] [ i ] = unit then
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PUSH
14715: LD_VAR 0 3
14719: EQUAL
14720: IFFALSE 14757
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14722: LD_ADDR_EXP 57
14726: PUSH
14727: LD_EXP 57
14731: PPUSH
14732: LD_EXP 57
14736: PUSH
14737: LD_VAR 0 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 5
14747: ARRAY
14748: PPUSH
14749: LD_INT 1
14751: PPUSH
14752: CALL 31284 0 3
14756: ST_TO_ADDR
// end ;
14757: GO 14695
14759: POP
14760: POP
// if mreg = ToLab then
14761: LD_VAR 0 2
14765: PUSH
14766: LD_STRING ToLab
14768: EQUAL
14769: IFFALSE 14858
// for i = MREG_ToLab [ side ] downto 1 do
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: DOUBLE
14777: LD_EXP 56
14781: PUSH
14782: LD_VAR 0 1
14786: ARRAY
14787: INC
14788: ST_TO_ADDR
14789: LD_INT 1
14791: PUSH
14792: FOR_DOWNTO
14793: IFFALSE 14856
// if MREG_ToLab [ side ] [ i ] = unit then
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 3
14816: EQUAL
14817: IFFALSE 14854
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14819: LD_ADDR_EXP 56
14823: PUSH
14824: LD_EXP 56
14828: PPUSH
14829: LD_EXP 56
14833: PUSH
14834: LD_VAR 0 1
14838: ARRAY
14839: PUSH
14840: LD_VAR 0 5
14844: ARRAY
14845: PPUSH
14846: LD_INT 1
14848: PPUSH
14849: CALL 31284 0 3
14853: ST_TO_ADDR
// end ;
14854: GO 14792
14856: POP
14857: POP
// end ;
14858: LD_VAR 0 4
14862: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14863: LD_INT 0
14865: PPUSH
14866: PPUSH
// result := false ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_INT 0
14874: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_EXP 48
14889: PUSH
14890: FOR_TO
14891: IFFALSE 14955
// if MREG_ToBuild [ i ] [ 1 ] = side then
14893: LD_EXP 48
14897: PUSH
14898: LD_VAR 0 3
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 1
14912: EQUAL
14913: IFFALSE 14953
// begin if MREG_ToBuild [ i ] [ 1 ] then
14915: LD_EXP 48
14919: PUSH
14920: LD_VAR 0 3
14924: ARRAY
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: IFFALSE 14953
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_EXP 48
14940: PUSH
14941: LD_VAR 0 3
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: ST_TO_ADDR
// break ;
14951: GO 14955
// end ; end ;
14953: GO 14890
14955: POP
14956: POP
// for i = 1 to MREG_ToRepair do
14957: LD_ADDR_VAR 0 3
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 49
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15037
// if MREG_ToRepair [ i ] [ 1 ] = side then
14975: LD_EXP 49
14979: PUSH
14980: LD_VAR 0 3
14984: ARRAY
14985: PUSH
14986: LD_INT 1
14988: ARRAY
14989: PUSH
14990: LD_VAR 0 1
14994: EQUAL
14995: IFFALSE 15035
// begin if MREG_ToRepair [ i ] [ 1 ] then
14997: LD_EXP 49
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: IFFALSE 15035
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15013: LD_ADDR_VAR 0 2
15017: PUSH
15018: LD_EXP 49
15022: PUSH
15023: LD_VAR 0 3
15027: ARRAY
15028: PUSH
15029: LD_INT 1
15031: ARRAY
15032: ST_TO_ADDR
// break ;
15033: GO 15037
// end ; end ;
15035: GO 14972
15037: POP
15038: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 57
15046: PUSH
15047: EMPTY
15048: LIST
15049: PPUSH
15050: CALL 11587 0 2
15054: IFFALSE 15081
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15056: LD_ADDR_VAR 0 2
15060: PUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 57
15068: PUSH
15069: EMPTY
15070: LIST
15071: PPUSH
15072: CALL 11587 0 2
15076: PUSH
15077: LD_INT 1
15079: ARRAY
15080: ST_TO_ADDR
// end ;
15081: LD_VAR 0 2
15085: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15093: LD_ADDR_VAR 0 6
15097: PUSH
15098: LD_VAR 0 1
15102: PPUSH
15103: LD_INT 21
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PPUSH
15113: CALL 11587 0 2
15117: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15118: LD_ADDR_VAR 0 7
15122: PUSH
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_INT 81
15130: PUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 11587 0 2
15144: ST_TO_ADDR
// if not enemy then
15145: LD_VAR 0 7
15149: NOT
15150: IFFALSE 15162
// result := false else
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 0
15159: ST_TO_ADDR
15160: GO 15216
// begin scan := NearestUnit ( b , enemy ) ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 6
15171: PPUSH
15172: LD_VAR 0 7
15176: PPUSH
15177: CALL 32609 0 2
15181: ST_TO_ADDR
// if scan [ 2 ] < dist then
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 2
15189: ARRAY
15190: PUSH
15191: LD_VAR 0 2
15195: LESS
15196: IFFALSE 15208
// result := true else
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
15206: GO 15216
// result := false ;
15208: LD_ADDR_VAR 0 3
15212: PUSH
15213: LD_INT 0
15215: ST_TO_ADDR
// end ; end ;
15216: LD_VAR 0 3
15220: RET
// export function MCF_Info ( ) ; begin
15221: LD_INT 0
15223: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15224: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15226: PUSH
15227: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15229: ADD
15230: PUSH
15231: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15233: ADD
15234: PUSH
15235: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15237: ADD
15238: PUSH
15239: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15241: ADD
15242: PUSH
15243: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15245: ADD
15246: PUSH
15247: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15249: ADD
15250: PUSH
15251: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15253: ADD
15254: PUSH
15255: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15257: ADD
15258: PUSH
15259: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15261: ADD
15262: PPUSH
15263: CALL 8505 0 1
// end ; end_of_file
15267: LD_VAR 0 1
15271: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15272: LD_INT 0
15274: PPUSH
15275: PPUSH
15276: PPUSH
15277: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15278: LD_ADDR_VAR 0 5
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 25
15293: PUSH
15294: LD_INT 2
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PUSH
15301: LD_INT 25
15303: PUSH
15304: LD_INT 3
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 25
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL 11587 0 2
15331: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_VAR 0 5
15341: PPUSH
15342: LD_INT 0
15344: PPUSH
15345: CALL 13736 0 2
15349: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15350: LD_ADDR_VAR 0 6
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 5
15364: PPUSH
15365: LD_INT 1
15367: PPUSH
15368: CALL 13356 0 3
15372: ST_TO_ADDR
// if n > sk then
15373: LD_VAR 0 2
15377: PUSH
15378: LD_VAR 0 6
15382: GREATER
15383: IFFALSE 15395
// n := sk ;
15385: LD_ADDR_VAR 0 2
15389: PUSH
15390: LD_VAR 0 6
15394: ST_TO_ADDR
// for i = 1 to n do
15395: LD_ADDR_VAR 0 4
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_TO
15411: IFFALSE 15523
// if ( sk [ i ] [ 1 ] ) <> 0 then
15413: LD_VAR 0 6
15417: PUSH
15418: LD_VAR 0 4
15422: ARRAY
15423: PUSH
15424: LD_INT 1
15426: ARRAY
15427: PUSH
15428: LD_INT 0
15430: NONEQUAL
15431: IFFALSE 15521
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15433: LD_ADDR_EXP 55
15437: PUSH
15438: LD_EXP 55
15442: PPUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 6
15452: PUSH
15453: LD_VAR 0 4
15457: ARRAY
15458: PUSH
15459: LD_INT 1
15461: ARRAY
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: CALL 42407 0 4
15470: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_EXP 58
15480: PPUSH
15481: LD_VAR 0 1
15485: PPUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PUSH
15497: LD_INT 1
15499: PLUS
15500: PPUSH
15501: LD_VAR 0 6
15505: PUSH
15506: LD_VAR 0 4
15510: ARRAY
15511: PUSH
15512: LD_INT 1
15514: ARRAY
15515: PPUSH
15516: CALL 31125 0 4
15520: ST_TO_ADDR
// end ;
15521: GO 15410
15523: POP
15524: POP
// end ;
15525: LD_VAR 0 3
15529: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15530: LD_INT 0
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: LD_INT 2
15548: PUSH
15549: LD_INT 25
15551: PUSH
15552: LD_INT 1
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: LD_INT 25
15561: PUSH
15562: LD_INT 3
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 25
15571: PUSH
15572: LD_INT 4
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: PPUSH
15585: CALL 11587 0 2
15589: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15590: LD_ADDR_VAR 0 5
15594: PUSH
15595: LD_VAR 0 5
15599: PPUSH
15600: LD_INT 0
15602: PPUSH
15603: CALL 13736 0 2
15607: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_VAR 0 5
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL 13356 0 3
15630: ST_TO_ADDR
// if n > sk then
15631: LD_VAR 0 2
15635: PUSH
15636: LD_VAR 0 6
15640: GREATER
15641: IFFALSE 15653
// n := sk ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_VAR 0 6
15652: ST_TO_ADDR
// for i = 1 to n do
15653: LD_ADDR_VAR 0 4
15657: PUSH
15658: DOUBLE
15659: LD_INT 1
15661: DEC
15662: ST_TO_ADDR
15663: LD_VAR 0 2
15667: PUSH
15668: FOR_TO
15669: IFFALSE 15781
// if ( sk [ i ] [ 1 ] ) <> 0 then
15671: LD_VAR 0 6
15675: PUSH
15676: LD_VAR 0 4
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_INT 0
15688: NONEQUAL
15689: IFFALSE 15779
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15691: LD_ADDR_EXP 55
15695: PUSH
15696: LD_EXP 55
15700: PPUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PUSH
15711: LD_VAR 0 4
15715: ARRAY
15716: PUSH
15717: LD_INT 1
15719: ARRAY
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL 42407 0 4
15728: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15729: LD_ADDR_EXP 59
15733: PUSH
15734: LD_EXP 59
15738: PPUSH
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_EXP 59
15748: PUSH
15749: LD_VAR 0 1
15753: ARRAY
15754: PUSH
15755: LD_INT 1
15757: PLUS
15758: PPUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 4
15768: ARRAY
15769: PUSH
15770: LD_INT 1
15772: ARRAY
15773: PPUSH
15774: CALL 31125 0 4
15778: ST_TO_ADDR
// end ;
15779: GO 15668
15781: POP
15782: POP
// end ;
15783: LD_VAR 0 3
15787: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15788: LD_INT 0
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15794: LD_ADDR_VAR 0 5
15798: PUSH
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 2
15806: PUSH
15807: LD_INT 25
15809: PUSH
15810: LD_INT 1
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 25
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 25
15829: PUSH
15830: LD_INT 4
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11587 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13736 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 3
15883: PPUSH
15884: CALL 13356 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL 42407 0 4
15986: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 57
15991: PUSH
15992: LD_EXP 57
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 57
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 31125 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL 11587 0 2
16094: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: LD_VAR 0 5
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL 13736 0 2
16112: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16113: LD_ADDR_VAR 0 6
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 5
16127: PPUSH
16128: LD_INT 4
16130: PPUSH
16131: CALL 13356 0 3
16135: ST_TO_ADDR
// if n > sk then
16136: LD_VAR 0 2
16140: PUSH
16141: LD_VAR 0 6
16145: GREATER
16146: IFFALSE 16158
// n := sk ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_VAR 0 6
16157: ST_TO_ADDR
// for i = 1 to n do
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: DOUBLE
16164: LD_INT 1
16166: DEC
16167: ST_TO_ADDR
16168: LD_VAR 0 2
16172: PUSH
16173: FOR_TO
16174: IFFALSE 16286
// if ( sk [ i ] [ 1 ] ) <> 0 then
16176: LD_VAR 0 6
16180: PUSH
16181: LD_VAR 0 4
16185: ARRAY
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PUSH
16191: LD_INT 0
16193: NONEQUAL
16194: IFFALSE 16284
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16196: LD_ADDR_EXP 55
16200: PUSH
16201: LD_EXP 55
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 6
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: LD_INT 4
16228: PPUSH
16229: CALL 42407 0 4
16233: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16234: LD_ADDR_EXP 56
16238: PUSH
16239: LD_EXP 56
16243: PPUSH
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_EXP 56
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PUSH
16260: LD_INT 1
16262: PLUS
16263: PPUSH
16264: LD_VAR 0 6
16268: PUSH
16269: LD_VAR 0 4
16273: ARRAY
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL 31125 0 4
16283: ST_TO_ADDR
// end ;
16284: GO 16173
16286: POP
16287: POP
// end ;
16288: LD_VAR 0 3
16292: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16293: LD_INT 0
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_INT 2
16311: PUSH
16312: LD_INT 25
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 25
16324: PUSH
16325: LD_INT 2
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 25
16334: PUSH
16335: LD_INT 3
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PUSH
16342: LD_INT 25
16344: PUSH
16345: LD_INT 4
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL 11587 0 2
16363: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16364: LD_ADDR_VAR 0 6
16368: PUSH
16369: LD_VAR 0 6
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL 13736 0 2
16381: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16382: LD_ADDR_VAR 0 7
16386: PUSH
16387: LD_VAR 0 1
16391: PPUSH
16392: LD_VAR 0 6
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: CALL 13356 0 3
16404: ST_TO_ADDR
// if n > sk then
16405: LD_VAR 0 2
16409: PUSH
16410: LD_VAR 0 7
16414: GREATER
16415: IFFALSE 16427
// n := sk ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 7
16426: ST_TO_ADDR
// for i = 1 to n do
16427: LD_ADDR_VAR 0 5
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16445: LD_ADDR_EXP 55
16449: PUSH
16450: LD_EXP 55
16454: PPUSH
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PUSH
16465: LD_VAR 0 5
16469: ARRAY
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: CALL 42407 0 4
16484: ST_TO_ADDR
// end ;
16485: GO 16442
16487: POP
16488: POP
// end ;
16489: LD_VAR 0 4
16493: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// b := false ;
16499: LD_ADDR_VAR 0 6
16503: PUSH
16504: LD_INT 0
16506: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 9
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 8
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: IN
16530: IFFALSE 16618
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 30
16542: PUSH
16543: LD_INT 4
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL 11587 0 2
16569: IFFALSE 16618
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16571: LD_ADDR_VAR 0 6
16575: PUSH
16576: LD_VAR 0 1
16580: PPUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 30
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 5
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL 11587 0 2
16613: PUSH
16614: LD_INT 1
16616: ARRAY
16617: ST_TO_ADDR
// if class = class_engineer then
16618: LD_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: EQUAL
16626: IFFALSE 16714
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16628: LD_VAR 0 1
16632: PPUSH
16633: LD_INT 2
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 0
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PPUSH
16661: CALL 11587 0 2
16665: IFFALSE 16714
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16667: LD_ADDR_VAR 0 6
16671: PUSH
16672: LD_VAR 0 1
16676: PPUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 30
16682: PUSH
16683: LD_INT 0
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 30
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11587 0 2
16709: PUSH
16710: LD_INT 1
16712: ARRAY
16713: ST_TO_ADDR
// if class = class_mechanic then
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 3
16721: EQUAL
16722: IFFALSE 16792
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16724: LD_VAR 0 1
16728: PPUSH
16729: LD_INT 30
16731: PUSH
16732: LD_INT 3
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL 11587 0 2
16743: IFFALSE 16792
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16745: LD_ADDR_VAR 0 6
16749: PUSH
16750: LD_VAR 0 1
16754: PPUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 30
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 30
16770: PUSH
16771: LD_INT 3
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL 11587 0 2
16787: PUSH
16788: LD_INT 1
16790: ARRAY
16791: ST_TO_ADDR
// if class = class_scientistic then
16792: LD_VAR 0 3
16796: PUSH
16797: LD_INT 4
16799: EQUAL
16800: IFFALSE 16910
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16802: LD_VAR 0 1
16806: PPUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 30
16812: PUSH
16813: LD_INT 6
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 30
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 30
16832: PUSH
16833: LD_INT 8
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL 11587 0 2
16850: IFFALSE 16910
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16852: LD_ADDR_VAR 0 6
16856: PUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: LD_INT 2
16864: PUSH
16865: LD_INT 30
16867: PUSH
16868: LD_INT 6
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 30
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 30
16887: PUSH
16888: LD_INT 8
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PPUSH
16901: CALL 11587 0 2
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: ST_TO_ADDR
// if GetClass ( unit ) = class then
16910: LD_VAR 0 2
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_VAR 0 3
16924: EQUAL
16925: IFFALSE 16959
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16927: LD_ADDR_EXP 55
16931: PUSH
16932: LD_EXP 55
16936: PPUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: LD_VAR 0 3
16951: PPUSH
16952: CALL 42498 0 4
16956: ST_TO_ADDR
// end else
16957: GO 17052
// if b then
16959: LD_VAR 0 6
16963: IFFALSE 17044
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 310
16974: PUSH
16975: LD_VAR 0 2
16979: PPUSH
16980: CALL_OW 310
16984: PUSH
16985: LD_VAR 0 6
16989: NONEQUAL
16990: AND
16991: IFFALSE 17002
// ComExitBuilding ( unit ) ;
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL_OW 122
// if not IsInUnit ( unit ) then
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 310
17011: NOT
17012: IFFALSE 17028
// ComEnterUnit ( unit , b ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17028: LD_VAR 0 2
17032: PPUSH
17033: LD_VAR 0 3
17037: PPUSH
17038: CALL_OW 183
// end else
17042: GO 17052
// result := false ;
17044: LD_ADDR_VAR 0 4
17048: PUSH
17049: LD_INT 0
17051: ST_TO_ADDR
// end ; end_of_file
17052: LD_VAR 0 4
17056: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
17062: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17063: LD_ADDR_VAR 0 5
17067: PUSH
17068: LD_INT 35
17070: PUSH
17071: LD_INT 45
17073: PUSH
17074: LD_INT 46
17076: PUSH
17077: LD_INT 47
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 48
17088: PUSH
17089: LD_INT 49
17091: PUSH
17092: LD_INT 50
17094: PUSH
17095: LD_INT 20
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
// if MCF_Lab ( side ) then
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 11626 0 1
17119: IFFALSE 17358
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL 11626 0 1
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: CALL_OW 461
17139: PUSH
17140: LD_INT 2
17142: EQUAL
17143: IFFALSE 17282
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL 11626 0 1
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL 17454 0 2
17168: IFFALSE 17195
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL 11626 0 1
17179: PUSH
17180: LD_INT 1
17182: ARRAY
17183: PPUSH
17184: LD_VAR 0 2
17188: PPUSH
17189: CALL_OW 124
17193: GO 17282
// if MCF_Lab ( side ) > 1 then
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL 11626 0 1
17204: PUSH
17205: LD_INT 1
17207: GREATER
17208: IFFALSE 17282
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17210: LD_VAR 0 1
17214: PPUSH
17215: CALL 11626 0 1
17219: PUSH
17220: LD_INT 2
17222: ARRAY
17223: PPUSH
17224: CALL_OW 461
17228: PUSH
17229: LD_INT 2
17231: EQUAL
17232: IFFALSE 17282
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11626 0 1
17243: PUSH
17244: LD_INT 2
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL 17454 0 2
17257: IFFALSE 17282
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11626 0 1
17268: PUSH
17269: LD_INT 2
17271: ARRAY
17272: PPUSH
17273: LD_VAR 0 2
17277: PPUSH
17278: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17282: LD_VAR 0 2
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: LD_INT 11
17292: PUSH
17293: LD_INT 4
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: IN
17305: IFFALSE 17358
// begin for lab in MCF_Lab ( side ) do
17307: LD_ADDR_VAR 0 6
17311: PUSH
17312: LD_VAR 0 1
17316: PPUSH
17317: CALL 11626 0 1
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17356
// if BuildingStatus ( lab ) = bs_need_ape then
17325: LD_VAR 0 6
17329: PPUSH
17330: CALL_OW 461
17334: PUSH
17335: LD_INT 10
17337: EQUAL
17338: IFFALSE 17354
// MCL_ResTame ( side , lab ) ;
17340: LD_VAR 0 1
17344: PPUSH
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL 17579 0 2
17354: GO 17322
17356: POP
17357: POP
// end ; end ; end ;
17358: LD_VAR 0 3
17362: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
// tmp := [ ] ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: EMPTY
17373: ST_TO_ADDR
// if not lab then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17391
// result := false else
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: LD_INT 0
17388: ST_TO_ADDR
17389: GO 17449
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: CALL_OW 268
17413: ADD
17414: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 3
17424: PUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: LD_INT 2
17432: PPUSH
17433: CALL_OW 268
17437: ADD
17438: ST_TO_ADDR
// result := tmp ;
17439: LD_ADDR_VAR 0 2
17443: PUSH
17444: LD_VAR 0 3
17448: ST_TO_ADDR
// end ; end ;
17449: LD_VAR 0 2
17453: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 35
17466: PUSH
17467: LD_INT 45
17469: PUSH
17470: LD_INT 46
17472: PUSH
17473: LD_INT 47
17475: PUSH
17476: LD_INT 1
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: LD_INT 48
17484: PUSH
17485: LD_INT 49
17487: PUSH
17488: LD_INT 50
17490: PUSH
17491: LD_INT 20
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: ST_TO_ADDR
// if lab then
17506: LD_VAR 0 1
17510: IFFALSE 17566
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17512: LD_VAR 0 2
17516: PUSH
17517: LD_VAR 0 5
17521: IN
17522: PUSH
17523: LD_VAR 0 2
17527: PPUSH
17528: CALL_OW 481
17532: PUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: CALL 17363 0 1
17542: IN
17543: OR
17544: IFFALSE 17556
// result := true else
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
17554: GO 17564
// result := false ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_INT 0
17563: ST_TO_ADDR
// end else
17564: GO 17574
// result := false ;
17566: LD_ADDR_VAR 0 3
17570: PUSH
17571: LD_INT 0
17573: ST_TO_ADDR
// end ;
17574: LD_VAR 0 3
17578: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17579: LD_INT 0
17581: PPUSH
17582: PPUSH
17583: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 171
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL 12290 0 3
17603: ST_TO_ADDR
// if not ape then
17604: LD_VAR 0 4
17608: NOT
17609: IFFALSE 17641
// if MCF_Ape ( side ) then
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL 12000 0 1
17620: IFFALSE 17641
// ape := MCF_Ape ( side ) [ 1 ] ;
17622: LD_ADDR_VAR 0 4
17626: PUSH
17627: LD_VAR 0 1
17631: PPUSH
17632: CALL 12000 0 1
17636: PUSH
17637: LD_INT 1
17639: ARRAY
17640: ST_TO_ADDR
// if ape then
17641: LD_VAR 0 4
17645: IFFALSE 17696
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17647: LD_VAR 0 4
17651: PUSH
17652: LD_INT 1
17654: ARRAY
17655: PPUSH
17656: CALL_OW 310
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: LD_INT 1
17668: ARRAY
17669: PPUSH
17670: CALL_OW 310
17674: PUSH
17675: LD_VAR 0 2
17679: NONEQUAL
17680: AND
17681: IFFALSE 17696
// ComExitBuilding ( ape [ 1 ] ) ;
17683: LD_VAR 0 4
17687: PUSH
17688: LD_INT 1
17690: ARRAY
17691: PPUSH
17692: CALL_OW 122
// if not lab then
17696: LD_VAR 0 2
17700: NOT
17701: IFFALSE 17707
// exit else
17703: GO 17855
17705: GO 17815
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 16
17714: PPUSH
17715: LD_INT 25
17717: PUSH
17718: LD_INT 4
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL 12290 0 3
17729: PUSH
17730: LD_INT 0
17732: EQUAL
17733: PUSH
17734: LD_VAR 0 2
17738: PPUSH
17739: CALL_OW 313
17743: PUSH
17744: LD_INT 6
17746: EQUAL
17747: AND
17748: IFFALSE 17815
// begin tmp := UnitsInside ( lab ) ;
17750: LD_ADDR_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: CALL_OW 313
17764: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 5
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 5
17792: ARRAY
17793: PPUSH
17794: CALL_OW 310
17798: IFFALSE 17815
// ComExitBuilding ( tmp [ tmp ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 5
17809: ARRAY
17810: PPUSH
17811: CALL_OW 122
// end ; if ape then
17815: LD_VAR 0 4
17819: IFFALSE 17855
// if not IsInUnit ( ape [ 1 ] ) then
17821: LD_VAR 0 4
17825: PUSH
17826: LD_INT 1
17828: ARRAY
17829: PPUSH
17830: CALL_OW 310
17834: NOT
17835: IFFALSE 17855
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PPUSH
17846: LD_VAR 0 2
17850: PPUSH
17851: CALL_OW 120
// end ;
17855: LD_VAR 0 3
17859: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17860: LD_INT 0
17862: PPUSH
17863: PPUSH
17864: PPUSH
// result := false ;
17865: LD_ADDR_VAR 0 2
17869: PUSH
17870: LD_INT 0
17872: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 1
17882: PPUSH
17883: CALL 17970 0 1
17887: ST_TO_ADDR
// if techs then
17888: LD_VAR 0 3
17892: IFFALSE 17922
// if techs [ 2 ] then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 2
17901: ARRAY
17902: IFFALSE 17914
// result := true else
17904: LD_ADDR_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: ST_TO_ADDR
17912: GO 17922
// result := false ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// end ;
17922: LD_VAR 0 2
17926: RET
// export function MCL_Start ( side ) ; var i ; begin
17927: LD_INT 0
17929: PPUSH
17930: PPUSH
// if MCL_GetTechList ( side ) then
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 17970 0 1
17940: IFFALSE 17965
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 17970 0 1
17956: PUSH
17957: LD_INT 1
17959: ARRAY
17960: PPUSH
17961: CALL 17057 0 2
// end ;
17965: LD_VAR 0 2
17969: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17970: LD_INT 0
17972: PPUSH
17973: PPUSH
17974: PPUSH
// if MREG_ToRes then
17975: LD_EXP 52
17979: IFFALSE 18064
// for i = 1 to MREG_ToRes do
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: DOUBLE
17987: LD_INT 1
17989: DEC
17990: ST_TO_ADDR
17991: LD_EXP 52
17995: PUSH
17996: FOR_TO
17997: IFFALSE 18062
// if MREG_ToRes [ i ] [ 1 ] = side then
17999: LD_EXP 52
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 1
18012: ARRAY
18013: PUSH
18014: LD_VAR 0 1
18018: EQUAL
18019: IFFALSE 18060
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18021: LD_ADDR_VAR 0 4
18025: PUSH
18026: LD_VAR 0 4
18030: PPUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: PLUS
18039: PPUSH
18040: LD_EXP 52
18044: PUSH
18045: LD_VAR 0 3
18049: ARRAY
18050: PUSH
18051: LD_INT 2
18053: ARRAY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// end ;
18060: GO 17996
18062: POP
18063: POP
// result := techs ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_VAR 0 4
18073: ST_TO_ADDR
// end ;
18074: LD_VAR 0 2
18078: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18079: LD_INT 0
18081: PPUSH
18082: PPUSH
// for i = 1 to tech_list do
18083: LD_ADDR_VAR 0 4
18087: PUSH
18088: DOUBLE
18089: LD_INT 1
18091: DEC
18092: ST_TO_ADDR
18093: LD_VAR 0 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18153
// if not tech_list [ i ] = 20 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_VAR 0 4
18110: ARRAY
18111: PUSH
18112: LD_INT 20
18114: EQUAL
18115: NOT
18116: IFFALSE 18151
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18118: LD_ADDR_EXP 52
18122: PUSH
18123: LD_EXP 52
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: ARRAY
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL 42407 0 4
18150: ST_TO_ADDR
18151: GO 18098
18153: POP
18154: POP
// result := true ;
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
// for i = MREG_ToRes downto 1 do
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: DOUBLE
18178: LD_EXP 52
18182: INC
18183: ST_TO_ADDR
18184: LD_INT 1
18186: PUSH
18187: FOR_DOWNTO
18188: IFFALSE 18234
// if MREG_ToRes [ i ] [ 1 ] = side then
18190: LD_EXP 52
18194: PUSH
18195: LD_VAR 0 3
18199: ARRAY
18200: PUSH
18201: LD_INT 1
18203: ARRAY
18204: PUSH
18205: LD_VAR 0 1
18209: EQUAL
18210: IFFALSE 18232
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18212: LD_ADDR_EXP 52
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: LD_VAR 0 3
18226: PPUSH
18227: CALL_OW 3
18231: ST_TO_ADDR
18232: GO 18187
18234: POP
18235: POP
// result := true ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 1
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18249: LD_INT 0
18251: PPUSH
// result := GetTechProgress ( side , tech ) ;
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: CALL_OW 326
18271: ST_TO_ADDR
// end ;
18272: LD_VAR 0 3
18276: RET
// export function MCL_Require ( tech ) ; begin
18277: LD_INT 0
18279: PPUSH
// result := GetTechTechsReq ( tech ) ;
18280: LD_ADDR_VAR 0 2
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 480
18294: ST_TO_ADDR
// end ; end_of_file
18295: LD_VAR 0 2
18299: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18300: LD_INT 0
18302: PPUSH
18303: PPUSH
18304: PPUSH
// uc_side := 0 ;
18305: LD_ADDR_OWVAR 20
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// uc_nation := 0 ;
18313: LD_ADDR_OWVAR 21
18317: PUSH
18318: LD_INT 0
18320: ST_TO_ADDR
// for i = 1 to n do
18321: LD_ADDR_VAR 0 5
18325: PUSH
18326: DOUBLE
18327: LD_INT 1
18329: DEC
18330: ST_TO_ADDR
18331: LD_VAR 0 2
18335: PUSH
18336: FOR_TO
18337: IFFALSE 18482
// begin hc_importance := 0 ;
18339: LD_ADDR_OWVAR 32
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// hc_gallery :=  ;
18347: LD_ADDR_OWVAR 33
18351: PUSH
18352: LD_STRING 
18354: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18355: LD_ADDR_OWVAR 35
18359: PUSH
18360: LD_VAR 0 3
18364: PUSH
18365: LD_INT 20
18367: MINUS
18368: PPUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_INT 20
18376: PLUS
18377: PPUSH
18378: CALL_OW 12
18382: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18383: LD_ADDR_OWVAR 31
18387: PUSH
18388: LD_INT 0
18390: PPUSH
18391: LD_INT 2
18393: PPUSH
18394: CALL_OW 12
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: LD_INT 0
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18414: LD_ADDR_OWVAR 30
18418: PUSH
18419: LD_INT 0
18421: PUSH
18422: LD_INT 0
18424: PUSH
18425: LD_INT 0
18427: PUSH
18428: LD_INT 0
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_class := class_apeman ;
18445: LD_ADDR_OWVAR 28
18449: PUSH
18450: LD_INT 12
18452: ST_TO_ADDR
// ape := CreateHuman ;
18453: LD_ADDR_VAR 0 6
18457: PUSH
18458: CALL_OW 44
18462: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18463: LD_VAR 0 6
18467: PPUSH
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 0
18475: PPUSH
18476: CALL_OW 49
// end ;
18480: GO 18336
18482: POP
18483: POP
// end ;
18484: LD_VAR 0 4
18488: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18489: LD_INT 0
18491: PPUSH
18492: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL 12000 0 1
18502: PUSH
18503: LD_EXP 39
18507: PUSH
18508: LD_VAR 0 1
18512: ARRAY
18513: GREATEREQUAL
18514: IFFALSE 18691
// begin if GetTag ( unit ) = 17 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 17
18528: EQUAL
18529: IFFALSE 18689
// begin SetTag ( unit , 0 ) ;
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 0
18538: PPUSH
18539: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18543: LD_VAR 0 1
18547: PPUSH
18548: CALL 11626 0 1
18552: PUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL 17970 0 1
18562: NOT
18563: AND
18564: IFFALSE 18589
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18566: LD_VAR 0 2
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: CALL 11626 0 1
18580: PUSH
18581: LD_INT 1
18583: ARRAY
18584: PPUSH
18585: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18589: LD_VAR 0 1
18593: PPUSH
18594: CALL 11626 0 1
18598: NOT
18599: PUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL 11587 0 2
18619: AND
18620: IFFALSE 18689
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18622: LD_VAR 0 2
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: LD_INT 30
18634: PUSH
18635: LD_INT 1
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PPUSH
18642: CALL 11587 0 2
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 250
18655: PPUSH
18656: LD_VAR 0 1
18660: PPUSH
18661: LD_INT 30
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL 11587 0 2
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: PPUSH
18680: CALL_OW 251
18684: PPUSH
18685: CALL_OW 111
// end ; end else
18689: GO 18875
// if GetClass ( unit ) <> 4 then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 257
18700: PUSH
18701: LD_INT 4
18703: NONEQUAL
18704: IFFALSE 18710
// exit else
18706: GO 18875
18708: GO 18875
// if GetTag ( unit ) = 0 then
18710: LD_VAR 0 2
18714: PPUSH
18715: CALL_OW 110
18719: PUSH
18720: LD_INT 0
18722: EQUAL
18723: IFFALSE 18739
// SetTag ( unit , 17 ) else
18725: LD_VAR 0 2
18729: PPUSH
18730: LD_INT 17
18732: PPUSH
18733: CALL_OW 109
18737: GO 18875
// begin if IsInUnit ( unit ) then
18739: LD_VAR 0 2
18743: PPUSH
18744: CALL_OW 310
18748: IFFALSE 18759
// ComExitBuilding ( unit ) ;
18750: LD_VAR 0 2
18754: PPUSH
18755: CALL_OW 122
// Wait ( 1 ) ;
18759: LD_INT 1
18761: PPUSH
18762: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: LD_INT 22
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 12
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: PPUSH
18800: LD_VAR 0 2
18804: PPUSH
18805: CALL_OW 74
18809: ST_TO_ADDR
// if not ape then
18810: LD_VAR 0 4
18814: NOT
18815: IFFALSE 18821
// exit else
18817: GO 18875
18819: GO 18830
// ComHold ( ape ) ;
18821: LD_VAR 0 4
18825: PPUSH
18826: CALL_OW 140
// if not HasTask ( unit ) then
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 314
18839: NOT
18840: IFFALSE 18873
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18842: LD_VAR 0 2
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: CALL_OW 250
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: CALL_OW 251
18866: PPUSH
18867: CALL_OW 131
18871: GO 18875
// exit ;
18873: GO 18875
// end ; end ;
18875: LD_VAR 0 3
18879: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18880: LD_INT 0
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_EXP 40
18895: PUSH
18896: LD_VAR 0 1
18900: ARRAY
18901: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18902: LD_ADDR_VAR 0 5
18906: PUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_STRING normal
18914: PPUSH
18915: CALL 12084 0 2
18919: ST_TO_ADDR
// if apes then
18920: LD_VAR 0 5
18924: IFFALSE 19152
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18926: LD_INT 2
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: CALL_OW 321
18938: PUSH
18939: LD_INT 2
18941: EQUAL
18942: PUSH
18943: LD_VAR 0 4
18947: PUSH
18948: LD_INT 2
18950: ARRAY
18951: PUSH
18952: LD_INT 1
18954: EQUAL
18955: AND
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_STRING engineer
18964: PPUSH
18965: CALL 12084 0 2
18969: PUSH
18970: LD_INT 3
18972: LESS
18973: AND
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 30
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PPUSH
18990: CALL 11587 0 2
18994: AND
18995: IFFALSE 19049
// begin for i in apes do
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 5
19006: PUSH
19007: FOR_IN
19008: IFFALSE 19045
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_VAR 0 1
19019: PPUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL 11587 0 2
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: PPUSH
19039: CALL_OW 120
// end ;
19043: GO 19007
19045: POP
19046: POP
// end else
19047: GO 19152
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19049: LD_INT 11
19051: PPUSH
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 321
19061: PUSH
19062: LD_INT 2
19064: EQUAL
19065: PUSH
19066: LD_VAR 0 4
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PUSH
19075: LD_INT 1
19077: EQUAL
19078: AND
19079: PUSH
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 30
19087: PUSH
19088: LD_INT 5
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PPUSH
19095: CALL 11587 0 2
19099: AND
19100: IFFALSE 19152
// begin for i in apes do
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19150
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19115: LD_VAR 0 3
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 30
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL 11587 0 2
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PPUSH
19144: CALL_OW 120
// end ;
19148: GO 19112
19150: POP
19151: POP
// end ; end ; end ; end_of_file
19152: LD_VAR 0 2
19156: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 257
19170: PUSH
19171: LD_INT 4
19173: EQUAL
19174: NOT
19175: PUSH
19176: LD_VAR 0 2
19180: NOT
19181: OR
19182: IFFALSE 19188
// exit else
19184: GO 19222
19186: GO 19222
// if not GetTag ( unit ) = 4 then
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 110
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: NOT
19202: IFFALSE 19208
// exit else
19204: GO 19222
19206: GO 19222
// ComHeal ( unit , target ) ;
19208: LD_VAR 0 1
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: CALL_OW 128
// end ;
19222: LD_VAR 0 3
19226: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19227: LD_INT 0
19229: PPUSH
19230: PPUSH
19231: PPUSH
19232: PPUSH
19233: PPUSH
19234: PPUSH
19235: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19236: LD_ADDR_VAR 0 5
19240: PUSH
19241: LD_INT 22
19243: PUSH
19244: LD_VAR 0 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 55
19268: PUSH
19269: EMPTY
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 3
19278: PUSH
19279: LD_INT 54
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: LD_INT 1000
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19318: LD_ADDR_VAR 0 8
19322: PUSH
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_INT 30
19330: PUSH
19331: LD_INT 1
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL 11587 0 2
19342: ST_TO_ADDR
// r := [ ] ;
19343: LD_ADDR_VAR 0 6
19347: PUSH
19348: EMPTY
19349: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 5
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL 12290 0 3
19364: IFFALSE 19420
// for j in MCF_Tag ( side , 5 , [ ] ) do
19366: LD_ADDR_VAR 0 4
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: EMPTY
19380: PPUSH
19381: CALL 12290 0 3
19385: PUSH
19386: FOR_IN
19387: IFFALSE 19418
// if GetLives ( j ) = 1000 then
19389: LD_VAR 0 4
19393: PPUSH
19394: CALL_OW 256
19398: PUSH
19399: LD_INT 1000
19401: EQUAL
19402: IFFALSE 19416
// SetTag ( j , 0 ) ;
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 109
19416: GO 19386
19418: POP
19419: POP
// if tmp then
19420: LD_VAR 0 5
19424: IFFALSE 19753
// begin r := [ tmp [ 1 ] ] ;
19426: LD_ADDR_VAR 0 6
19430: PUSH
19431: LD_VAR 0 5
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: PUSH
19440: EMPTY
19441: LIST
19442: ST_TO_ADDR
// for i = 2 to tmp do
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: DOUBLE
19449: LD_INT 2
19451: DEC
19452: ST_TO_ADDR
19453: LD_VAR 0 5
19457: PUSH
19458: FOR_TO
19459: IFFALSE 19751
// begin m := false ;
19461: LD_ADDR_VAR 0 7
19465: PUSH
19466: LD_INT 0
19468: ST_TO_ADDR
// if d then
19469: LD_VAR 0 8
19473: IFFALSE 19628
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19475: LD_VAR 0 5
19479: PUSH
19480: LD_VAR 0 3
19484: ARRAY
19485: PPUSH
19486: CALL_OW 256
19490: PUSH
19491: LD_INT 650
19493: LESS
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_VAR 0 3
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 8
19510: PUSH
19511: LD_INT 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 250
19519: PPUSH
19520: LD_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: CALL_OW 251
19533: PPUSH
19534: CALL_OW 297
19538: PUSH
19539: LD_INT 10
19541: GREATER
19542: AND
19543: IFFALSE 19628
// begin if not GetTag ( tmp [ i ] ) = 5 then
19545: LD_VAR 0 5
19549: PUSH
19550: LD_VAR 0 3
19554: ARRAY
19555: PPUSH
19556: CALL_OW 110
19560: PUSH
19561: LD_INT 5
19563: EQUAL
19564: NOT
19565: IFFALSE 19585
// SetTag ( tmp [ i ] , 5 ) ;
19567: LD_VAR 0 5
19571: PUSH
19572: LD_VAR 0 3
19576: ARRAY
19577: PPUSH
19578: LD_INT 5
19580: PPUSH
19581: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19585: LD_VAR 0 5
19589: PUSH
19590: LD_VAR 0 3
19594: ARRAY
19595: PPUSH
19596: LD_VAR 0 8
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PPUSH
19605: CALL_OW 250
19609: PPUSH
19610: LD_VAR 0 8
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: PPUSH
19619: CALL_OW 251
19623: PPUSH
19624: CALL_OW 111
// end ; for j = 1 to r do
19628: LD_ADDR_VAR 0 4
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19718
// if GetLives ( tmp [ i ] ) < r [ j ] then
19646: LD_VAR 0 5
19650: PUSH
19651: LD_VAR 0 3
19655: ARRAY
19656: PPUSH
19657: CALL_OW 256
19661: PUSH
19662: LD_VAR 0 6
19666: PUSH
19667: LD_VAR 0 4
19671: ARRAY
19672: LESS
19673: IFFALSE 19716
// begin r := Insert ( r , j , tmp [ i ] ) ;
19675: LD_ADDR_VAR 0 6
19679: PUSH
19680: LD_VAR 0 6
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PUSH
19695: LD_VAR 0 3
19699: ARRAY
19700: PPUSH
19701: CALL_OW 2
19705: ST_TO_ADDR
// m := true ;
19706: LD_ADDR_VAR 0 7
19710: PUSH
19711: LD_INT 1
19713: ST_TO_ADDR
// break ;
19714: GO 19718
// end ;
19716: GO 19643
19718: POP
19719: POP
// if not m then
19720: LD_VAR 0 7
19724: NOT
19725: IFFALSE 19749
// r := r ^ tmp [ i ] ;
19727: LD_ADDR_VAR 0 6
19731: PUSH
19732: LD_VAR 0 6
19736: PUSH
19737: LD_VAR 0 5
19741: PUSH
19742: LD_VAR 0 3
19746: ARRAY
19747: ADD
19748: ST_TO_ADDR
// end ;
19749: GO 19458
19751: POP
19752: POP
// end ; result := r end ; end_of_file
19753: LD_ADDR_VAR 0 2
19757: PUSH
19758: LD_VAR 0 6
19762: ST_TO_ADDR
19763: LD_VAR 0 2
19767: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19768: LD_INT 0
19770: PPUSH
19771: PPUSH
19772: PPUSH
// pom := GetBase ( bdepot ) ;
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: CALL_OW 274
19787: ST_TO_ADDR
// sor := [ ] ;
19788: LD_ADDR_VAR 0 4
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_VAR 0 4
19804: PUSH
19805: LD_VAR 0 3
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 275
19817: ADD
19818: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19819: LD_ADDR_VAR 0 4
19823: PUSH
19824: LD_VAR 0 4
19828: PUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 275
19841: ADD
19842: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19843: LD_ADDR_VAR 0 4
19847: PUSH
19848: LD_VAR 0 4
19852: PUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: LD_INT 3
19860: PPUSH
19861: CALL_OW 275
19865: ADD
19866: ST_TO_ADDR
// result := sor ;
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 4
19876: ST_TO_ADDR
// end ;
19877: LD_VAR 0 2
19881: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19882: LD_INT 0
19884: PPUSH
19885: PPUSH
// while ( coord_list ) do
19886: LD_VAR 0 3
19890: IFFALSE 20064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19892: LD_ADDR_EXP 48
19896: PUSH
19897: LD_EXP 48
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PUSH
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: PUSH
19930: LD_VAR 0 3
19934: PUSH
19935: LD_INT 3
19937: ARRAY
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: PPUSH
19944: CALL 42407 0 4
19948: ST_TO_ADDR
// if weapon_list then
19949: LD_VAR 0 4
19953: IFFALSE 20024
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19955: LD_ADDR_EXP 45
19959: PUSH
19960: LD_EXP 45
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: LD_VAR 0 4
19974: PUSH
19975: LD_INT 1
19977: ARRAY
19978: PPUSH
19979: LD_VAR 0 3
19983: PUSH
19984: LD_INT 1
19986: ARRAY
19987: PUSH
19988: LD_VAR 0 3
19992: PUSH
19993: LD_INT 2
19995: ARRAY
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PPUSH
20001: CALL 42407 0 4
20005: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 4
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
// end ; for i = 1 to 3 do
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: DOUBLE
20030: LD_INT 1
20032: DEC
20033: ST_TO_ADDR
20034: LD_INT 3
20036: PUSH
20037: FOR_TO
20038: IFFALSE 20060
// coord_list := Delete ( coord_list , 1 ) ;
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_VAR 0 3
20049: PPUSH
20050: LD_INT 1
20052: PPUSH
20053: CALL_OW 3
20057: ST_TO_ADDR
20058: GO 20037
20060: POP
20061: POP
// end ;
20062: GO 19886
// result := true ;
20064: LD_ADDR_VAR 0 5
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// end ;
20072: LD_VAR 0 5
20076: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20077: LD_INT 0
20079: PPUSH
20080: PPUSH
// if not weapon_list then
20081: LD_VAR 0 3
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20205
// while ( coord_list ) do
20090: LD_VAR 0 2
20094: IFFALSE 20205
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20096: LD_ADDR_EXP 45
20100: PUSH
20101: LD_EXP 45
20105: PPUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: LD_VAR 0 2
20124: PUSH
20125: LD_INT 1
20127: ARRAY
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_INT 2
20136: ARRAY
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL 42407 0 4
20146: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_VAR 0 3
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
// for i = 1 to 2 do
20165: LD_ADDR_VAR 0 5
20169: PUSH
20170: DOUBLE
20171: LD_INT 1
20173: DEC
20174: ST_TO_ADDR
20175: LD_INT 2
20177: PUSH
20178: FOR_TO
20179: IFFALSE 20201
// coord_list := Delete ( coord_list , 1 ) ;
20181: LD_ADDR_VAR 0 2
20185: PUSH
20186: LD_VAR 0 2
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 3
20198: ST_TO_ADDR
20199: GO 20178
20201: POP
20202: POP
// end ;
20203: GO 20090
// end ;
20205: LD_VAR 0 4
20209: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20210: LD_INT 0
20212: PPUSH
20213: PPUSH
// while ( coord_list ) do
20214: LD_VAR 0 2
20218: IFFALSE 20373
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20220: LD_VAR 0 2
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_INT 2
20236: ARRAY
20237: PPUSH
20238: CALL_OW 428
20242: IFFALSE 20333
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20244: LD_VAR 0 2
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_VAR 0 2
20257: PUSH
20258: LD_INT 2
20260: ARRAY
20261: PPUSH
20262: CALL_OW 428
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 31
20274: PUSH
20275: LD_INT 32
20277: PUSH
20278: LD_INT 33
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: IN
20286: IFFALSE 20333
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20288: LD_ADDR_EXP 54
20292: PUSH
20293: LD_EXP 54
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: LD_VAR 0 2
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 2
20316: PUSH
20317: LD_INT 2
20319: ARRAY
20320: PPUSH
20321: CALL_OW 428
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL 42407 0 4
20332: ST_TO_ADDR
// for i = 1 to 3 do
20333: LD_ADDR_VAR 0 4
20337: PUSH
20338: DOUBLE
20339: LD_INT 1
20341: DEC
20342: ST_TO_ADDR
20343: LD_INT 3
20345: PUSH
20346: FOR_TO
20347: IFFALSE 20369
// coord_list := Delete ( coord_list , 1 ) ;
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: CALL_OW 3
20366: ST_TO_ADDR
20367: GO 20346
20369: POP
20370: POP
// end ;
20371: GO 20214
// result := true ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// end ;
20381: LD_VAR 0 3
20385: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20386: LD_INT 0
20388: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20389: LD_ADDR_EXP 48
20393: PUSH
20394: LD_EXP 48
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: LD_INT 0
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: CALL 42407 0 4
20416: ST_TO_ADDR
// end ;
20417: LD_VAR 0 3
20421: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20422: LD_INT 0
20424: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20425: LD_ADDR_EXP 48
20429: PUSH
20430: LD_EXP 48
20434: PPUSH
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 6
20442: PPUSH
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL 42407 0 4
20452: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20453: LD_ADDR_EXP 51
20457: PUSH
20458: LD_EXP 51
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 1
20475: ARRAY
20476: PPUSH
20477: LD_VAR 0 3
20481: PUSH
20482: LD_INT 2
20484: ARRAY
20485: PPUSH
20486: CALL 42407 0 4
20490: ST_TO_ADDR
// end ;
20491: LD_VAR 0 4
20495: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20496: LD_INT 0
20498: PPUSH
20499: PPUSH
// if ext_list > 5 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 5
20507: GREATER
20508: IFFALSE 20552
// for i = 6 to ext_list do
20510: LD_ADDR_VAR 0 5
20514: PUSH
20515: DOUBLE
20516: LD_INT 6
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 3
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20550
// ext_list := Delete ( ext_list , ext_list ) ;
20528: LD_ADDR_VAR 0 3
20532: PUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: CALL_OW 3
20547: ST_TO_ADDR
20548: GO 20525
20550: POP
20551: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20552: LD_VAR 0 1
20556: PPUSH
20557: LD_VAR 0 2
20561: PUSH
20562: LD_INT 1
20564: ARRAY
20565: PPUSH
20566: LD_VAR 0 2
20570: PUSH
20571: LD_INT 2
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 3
20588: PPUSH
20589: CALL 9099 0 5
// end ;
20593: LD_VAR 0 4
20597: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
// p := 1 ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_INT 1
20610: ST_TO_ADDR
// if type_list = [ ] then
20611: LD_VAR 0 3
20615: PUSH
20616: EMPTY
20617: EQUAL
20618: IFFALSE 20628
// type_list := b_oil_power ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_INT 26
20627: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20628: LD_ADDR_VAR 0 5
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 2
20642: PUSH
20643: LD_INT 3
20645: DIVREAL
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20751
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20650: LD_ADDR_EXP 48
20654: PUSH
20655: LD_EXP 48
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 3
20669: PUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_VAR 0 3
20677: PPUSH
20678: CALL_OW 12
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 6
20693: ARRAY
20694: PUSH
20695: LD_VAR 0 2
20699: PUSH
20700: LD_VAR 0 6
20704: PUSH
20705: LD_INT 1
20707: PLUS
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 2
20722: PLUS
20723: ARRAY
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL 42407 0 4
20734: ST_TO_ADDR
// p := p + 3 ;
20735: LD_ADDR_VAR 0 6
20739: PUSH
20740: LD_VAR 0 6
20744: PUSH
20745: LD_INT 3
20747: PLUS
20748: ST_TO_ADDR
// end ;
20749: GO 20647
20751: POP
20752: POP
// end ;
20753: LD_VAR 0 4
20757: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not MREG_Deposit [ side ] then
20764: LD_EXP 63
20768: PUSH
20769: LD_VAR 0 1
20773: ARRAY
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20956
// p := 1 ;
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: DOUBLE
20793: LD_INT 1
20795: DEC
20796: ST_TO_ADDR
20797: LD_EXP 63
20801: PUSH
20802: LD_VAR 0 1
20806: ARRAY
20807: PUSH
20808: LD_INT 3
20810: DIVREAL
20811: PUSH
20812: FOR_TO
20813: IFFALSE 20954
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20815: LD_EXP 63
20819: PUSH
20820: LD_VAR 0 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 4
20830: PUSH
20831: LD_INT 2
20833: PLUS
20834: ARRAY
20835: PUSH
20836: LD_INT 2
20838: EQUAL
20839: IFFALSE 20851
// b := b_oil_mine else
20841: LD_ADDR_VAR 0 5
20845: PUSH
20846: LD_INT 29
20848: ST_TO_ADDR
20849: GO 20859
// b := b_siberite_mine ;
20851: LD_ADDR_VAR 0 5
20855: PUSH
20856: LD_INT 30
20858: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20859: LD_ADDR_EXP 48
20863: PUSH
20864: LD_EXP 48
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 5
20878: PPUSH
20879: LD_EXP 63
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: ARRAY
20895: PUSH
20896: LD_EXP 63
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: ARRAY
20916: PUSH
20917: LD_INT 0
20919: PPUSH
20920: LD_INT 5
20922: PPUSH
20923: CALL_OW 12
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: LIST
20932: PPUSH
20933: CALL 42407 0 4
20937: ST_TO_ADDR
// p := p + 3 ;
20938: LD_ADDR_VAR 0 4
20942: PUSH
20943: LD_VAR 0 4
20947: PUSH
20948: LD_INT 3
20950: PLUS
20951: ST_TO_ADDR
// end ;
20952: GO 20812
20954: POP
20955: POP
// end ;
20956: LD_VAR 0 2
20960: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20961: LD_INT 0
20963: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20964: LD_ADDR_EXP 48
20968: PUSH
20969: LD_EXP 48
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: CALL 42407 0 4
20991: ST_TO_ADDR
// end ;
20992: LD_VAR 0 3
20996: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20997: LD_INT 0
20999: PPUSH
// case nation of 1 , us :
21000: LD_VAR 0 2
21004: PUSH
21005: LD_INT 1
21007: DOUBLE
21008: EQUAL
21009: IFTRUE 21019
21011: LD_STRING us
21013: DOUBLE
21014: EQUAL
21015: IFTRUE 21019
21017: GO 21050
21019: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21020: LD_ADDR_EXP 48
21024: PUSH
21025: LD_EXP 48
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_INT 36
21037: PPUSH
21038: LD_VAR 0 3
21042: PPUSH
21043: CALL 42407 0 4
21047: ST_TO_ADDR
21048: GO 21101
21050: LD_INT 2
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21064
21056: LD_STRING ar
21058: DOUBLE
21059: EQUAL
21060: IFTRUE 21064
21062: GO 21100
21064: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21065: LD_ADDR_EXP 48
21069: PUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: LD_INT 14
21077: PUSH
21078: LD_INT 2
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: LD_INT 31
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: PPUSH
21093: CALL 21106 0 2
21097: ST_TO_ADDR
21098: GO 21101
21100: POP
// end ;
21101: LD_VAR 0 4
21105: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21106: LD_INT 0
21108: PPUSH
21109: PPUSH
// for i = 1 to list do
21110: LD_ADDR_VAR 0 4
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 2
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21176
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21128: LD_ADDR_EXP 53
21132: PUSH
21133: LD_EXP 53
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_EXP 53
21147: PUSH
21148: LD_VAR 0 1
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: PLUS
21157: PPUSH
21158: LD_VAR 0 2
21162: PUSH
21163: LD_VAR 0 4
21167: ARRAY
21168: PPUSH
21169: CALL 31125 0 4
21173: ST_TO_ADDR
21174: GO 21125
21176: POP
21177: POP
// end ;
21178: LD_VAR 0 3
21182: RET
// export function MCS_GetVehicleList ( side ) ; begin
21183: LD_INT 0
21185: PPUSH
// result := MREG_ToConstruct [ side ] ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_EXP 53
21195: PUSH
21196: LD_VAR 0 1
21200: ARRAY
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 2
21206: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21207: LD_INT 0
21209: PPUSH
21210: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21211: LD_ADDR_EXP 60
21215: PUSH
21216: LD_EXP 60
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 2
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 3
21240: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21241: LD_INT 0
21243: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21244: LD_ADDR_EXP 39
21248: PUSH
21249: LD_EXP 39
21253: PPUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_VAR 0 2
21263: PPUSH
21264: CALL_OW 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 3
21273: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21274: LD_INT 0
21276: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21277: LD_ADDR_EXP 40
21281: PUSH
21282: LD_EXP 40
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 3
21306: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21307: LD_INT 0
21309: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21310: LD_ADDR_EXP 62
21314: PUSH
21315: LD_EXP 62
21319: PPUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: LD_INT 1
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: CALL 31125 0 4
21337: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21338: LD_ADDR_EXP 62
21342: PUSH
21343: LD_EXP 62
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: LD_VAR 0 3
21360: PPUSH
21361: CALL 31125 0 4
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 4
21370: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21374: LD_ADDR_EXP 74
21378: PUSH
21379: LD_EXP 74
21383: PPUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21397: LD_ADDR_EXP 74
21401: PUSH
21402: LD_EXP 74
21406: PPUSH
21407: LD_INT 2
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21420: LD_ADDR_EXP 74
21424: PUSH
21425: LD_EXP 74
21429: PPUSH
21430: LD_INT 3
21432: PPUSH
21433: LD_VAR 0 3
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 4
21447: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
// if not side or not list then
21453: LD_VAR 0 1
21457: NOT
21458: PUSH
21459: LD_VAR 0 2
21463: NOT
21464: OR
21465: IFFALSE 21469
// exit ;
21467: GO 21637
// SetTech ( 20 , side , state_researched ) ;
21469: LD_INT 20
21471: PPUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21484: LD_ADDR_EXP 63
21488: PUSH
21489: LD_EXP 63
21493: PPUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_VAR 0 2
21503: PPUSH
21504: CALL_OW 2
21508: ST_TO_ADDR
// p := 1 ;
21509: LD_ADDR_VAR 0 5
21513: PUSH
21514: LD_INT 1
21516: ST_TO_ADDR
// for i = 1 to list / 3 do
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: DOUBLE
21523: LD_INT 1
21525: DEC
21526: ST_TO_ADDR
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 3
21534: DIVREAL
21535: PUSH
21536: FOR_TO
21537: IFFALSE 21635
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_VAR 0 5
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: LD_INT 1
21562: PLUS
21563: ARRAY
21564: PPUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_VAR 0 5
21574: PUSH
21575: LD_INT 2
21577: PLUS
21578: ARRAY
21579: PPUSH
21580: CALL 22339 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21584: LD_VAR 0 2
21588: PUSH
21589: LD_VAR 0 5
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_VAR 0 5
21604: PUSH
21605: LD_INT 1
21607: PLUS
21608: ARRAY
21609: PPUSH
21610: LD_VAR 0 1
21614: PPUSH
21615: CALL_OW 441
// p := p + 3 ;
21619: LD_ADDR_VAR 0 5
21623: PUSH
21624: LD_VAR 0 5
21628: PUSH
21629: LD_INT 3
21631: PLUS
21632: ST_TO_ADDR
// end ;
21633: GO 21536
21635: POP
21636: POP
// end ;
21637: LD_VAR 0 3
21641: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
// if nat = nation_arabian then
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 2
21653: EQUAL
21654: IFFALSE 21660
// exit else
21656: GO 21732
21658: GO 21718
// if nat = nation_american then
21660: LD_VAR 0 2
21664: PUSH
21665: LD_INT 1
21667: EQUAL
21668: IFFALSE 21695
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_INT 4
21677: PUSH
21678: LD_INT 3
21680: PUSH
21681: LD_INT 1
21683: PUSH
21684: LD_INT 8
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: ST_TO_ADDR
21693: GO 21718
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: LD_INT 24
21702: PUSH
21703: LD_INT 3
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: LD_INT 48
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21718: LD_VAR 0 1
21722: PPUSH
21723: LD_VAR 0 4
21727: PPUSH
21728: CALL 21106 0 2
// end ;
21732: LD_VAR 0 3
21736: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21741: LD_ADDR_EXP 65
21745: PUSH
21746: LD_EXP 65
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: LD_VAR 0 4
21763: PPUSH
21764: CALL 31125 0 4
21768: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21769: LD_ADDR_EXP 66
21773: PUSH
21774: LD_EXP 66
21778: PPUSH
21779: LD_VAR 0 1
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_VAR 0 2
21791: PPUSH
21792: CALL 31125 0 4
21796: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21797: LD_ADDR_EXP 67
21801: PUSH
21802: LD_EXP 67
21806: PPUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_INT 1
21814: PPUSH
21815: LD_VAR 0 3
21819: PPUSH
21820: CALL 31125 0 4
21824: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21825: LD_ADDR_EXP 68
21829: PUSH
21830: LD_EXP 68
21834: PPUSH
21835: LD_VAR 0 1
21839: PPUSH
21840: LD_INT 1
21842: PPUSH
21843: LD_VAR 0 5
21847: PPUSH
21848: CALL 31125 0 4
21852: ST_TO_ADDR
// while squad do
21853: LD_VAR 0 5
21857: IFFALSE 21950
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_VAR 0 5
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 2
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 3
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: LD_INT 4
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL 21106 0 2
// for i = 1 to 4 do
21910: LD_ADDR_VAR 0 7
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_INT 4
21922: PUSH
21923: FOR_TO
21924: IFFALSE 21946
// squad := Delete ( squad , 1 ) ;
21926: LD_ADDR_VAR 0 5
21930: PUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: LD_INT 1
21938: PPUSH
21939: CALL_OW 3
21943: ST_TO_ADDR
21944: GO 21923
21946: POP
21947: POP
// end ;
21948: GO 21853
// end ;
21950: LD_VAR 0 6
21954: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21955: LD_INT 0
21957: PPUSH
21958: PPUSH
// for i = 1 to squad do
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: DOUBLE
21965: LD_INT 1
21967: DEC
21968: ST_TO_ADDR
21969: LD_VAR 0 2
21973: PUSH
21974: FOR_TO
21975: IFFALSE 22025
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21977: LD_ADDR_EXP 71
21981: PUSH
21982: LD_EXP 71
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_EXP 71
21996: PUSH
21997: LD_VAR 0 1
22001: ARRAY
22002: PUSH
22003: LD_INT 1
22005: PLUS
22006: PPUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 4
22016: ARRAY
22017: PPUSH
22018: CALL 31125 0 4
22022: ST_TO_ADDR
22023: GO 21974
22025: POP
22026: POP
// while squad do
22027: LD_VAR 0 2
22031: IFFALSE 22124
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PUSH
22047: LD_VAR 0 2
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PUSH
22056: LD_VAR 0 2
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 4
22072: ARRAY
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: PPUSH
22080: CALL 21106 0 2
// for i = 1 to 4 do
22084: LD_ADDR_VAR 0 4
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_INT 4
22096: PUSH
22097: FOR_TO
22098: IFFALSE 22120
// squad := Delete ( squad , 1 ) ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 2
22109: PPUSH
22110: LD_INT 1
22112: PPUSH
22113: CALL_OW 3
22117: ST_TO_ADDR
22118: GO 22097
22120: POP
22121: POP
// end ;
22122: GO 22027
// end ;
22124: LD_VAR 0 3
22128: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22129: LD_INT 0
22131: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22132: LD_ADDR_EXP 64
22136: PUSH
22137: LD_EXP 64
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: CALL 31125 0 4
22159: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22160: LD_ADDR_EXP 64
22164: PUSH
22165: LD_EXP 64
22169: PPUSH
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: LD_VAR 0 3
22182: PPUSH
22183: CALL 31125 0 4
22187: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22188: LD_ADDR_EXP 64
22192: PUSH
22193: LD_EXP 64
22197: PPUSH
22198: LD_VAR 0 1
22202: PPUSH
22203: LD_INT 3
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL 31125 0 4
22215: ST_TO_ADDR
// end ; end_of_file
22216: LD_VAR 0 5
22220: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22221: LD_INT 0
22223: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22224: LD_ADDR_EXP 44
22228: PUSH
22229: LD_EXP 44
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 1
22241: PPUSH
22242: LD_VAR 0 2
22246: PPUSH
22247: CALL 31125 0 4
22251: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22252: LD_VAR 0 1
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL 11722 0 2
22263: PUSH
22264: LD_INT 1
22266: ARRAY
22267: PPUSH
22268: CALL_OW 248
22272: PUSH
22273: LD_INT 1
22275: EQUAL
22276: IFFALSE 22307
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: LD_INT 1
22291: PUSH
22292: LD_INT 14
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: PPUSH
22301: CALL 21106 0 2
22305: GO 22334
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22307: LD_VAR 0 1
22311: PPUSH
22312: LD_INT 24
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 1
22320: PUSH
22321: LD_INT 53
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL 21106 0 2
// end ;
22334: LD_VAR 0 3
22338: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22339: LD_INT 0
22341: PPUSH
// CreateDepositXY ( x , y , t ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 2
22351: PPUSH
22352: LD_VAR 0 3
22356: PPUSH
22357: CALL_OW 62
// end ;
22361: LD_VAR 0 4
22365: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22366: LD_INT 0
22368: PPUSH
22369: PPUSH
// c := 1 ;
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 1
22377: ST_TO_ADDR
// case color of red :
22378: LD_VAR 0 3
22382: PUSH
22383: LD_STRING red
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 1 ; dark-green :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
22400: GO 22688
22402: LD_STRING dark-green
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 2 ; purple :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 2
22418: ST_TO_ADDR
22419: GO 22688
22421: LD_STRING purple
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 3 ; aqua :
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 3
22437: ST_TO_ADDR
22438: GO 22688
22440: LD_STRING aqua
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22459
22448: POP
// c = 4 ; grey :
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_INT 4
22456: ST_TO_ADDR
22457: GO 22688
22459: LD_STRING grey
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22478
22467: POP
// c = 5 ; lime :
22468: LD_ADDR_VAR 0 5
22472: PUSH
22473: LD_INT 5
22475: ST_TO_ADDR
22476: GO 22688
22478: LD_STRING lime
22480: DOUBLE
22481: EQUAL
22482: IFTRUE 22486
22484: GO 22497
22486: POP
// c = 6 ; tan :
22487: LD_ADDR_VAR 0 5
22491: PUSH
22492: LD_INT 6
22494: ST_TO_ADDR
22495: GO 22688
22497: LD_STRING tan
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22516
22505: POP
// c = 7 ; pink :
22506: LD_ADDR_VAR 0 5
22510: PUSH
22511: LD_INT 7
22513: ST_TO_ADDR
22514: GO 22688
22516: LD_STRING pink
22518: DOUBLE
22519: EQUAL
22520: IFTRUE 22524
22522: GO 22535
22524: POP
// c = 8 ; green :
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_INT 8
22532: ST_TO_ADDR
22533: GO 22688
22535: LD_STRING green
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22554
22543: POP
// c = 9 ; blue :
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_INT 9
22551: ST_TO_ADDR
22552: GO 22688
22554: LD_STRING blue
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22573
22562: POP
// c = 10 ; yellow :
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_INT 10
22570: ST_TO_ADDR
22571: GO 22688
22573: LD_STRING yellow
22575: DOUBLE
22576: EQUAL
22577: IFTRUE 22581
22579: GO 22592
22581: POP
// c = 11 ; brown :
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_INT 11
22589: ST_TO_ADDR
22590: GO 22688
22592: LD_STRING brown
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22600
22598: GO 22611
22600: POP
// c = 12 ; black :
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 12
22608: ST_TO_ADDR
22609: GO 22688
22611: LD_STRING black
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22630
22619: POP
// c = 13 ; aqua2 :
22620: LD_ADDR_VAR 0 5
22624: PUSH
22625: LD_INT 13
22627: ST_TO_ADDR
22628: GO 22688
22630: LD_STRING aqua2
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22649
22638: POP
// c = 14 ; orange :
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_INT 14
22646: ST_TO_ADDR
22647: GO 22688
22649: LD_STRING orange
22651: DOUBLE
22652: EQUAL
22653: IFTRUE 22657
22655: GO 22668
22657: POP
// c = 15 ; white :
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_INT 15
22665: ST_TO_ADDR
22666: GO 22688
22668: LD_STRING white
22670: DOUBLE
22671: EQUAL
22672: IFTRUE 22676
22674: GO 22687
22676: POP
// c = 16 ; end ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_INT 16
22684: ST_TO_ADDR
22685: GO 22688
22687: POP
// if HexInfo ( x , y ) = 0 then
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_VAR 0 2
22697: PPUSH
22698: CALL_OW 428
22702: PUSH
22703: LD_INT 0
22705: EQUAL
22706: IFFALSE 22730
// PlaceEnvironment ( x , y , 58 , c ) ;
22708: LD_VAR 0 1
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: LD_INT 58
22720: PPUSH
22721: LD_VAR 0 5
22725: PPUSH
22726: CALL_OW 349
// end ;
22730: LD_VAR 0 4
22734: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22735: LD_INT 0
22737: PPUSH
// RemoveEnvironment ( x , y ) ;
22738: LD_VAR 0 1
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: CALL_OW 347
// end ;
22752: LD_VAR 0 3
22756: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22757: LD_INT 0
22759: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22760: LD_INT 81
22762: PUSH
22763: LD_VAR 0 1
22767: PUSH
22768: EMPTY
22769: LIST
22770: LIST
22771: PPUSH
22772: CALL_OW 69
22776: PUSH
22777: LD_INT 0
22779: EQUAL
22780: IFFALSE 22792
// result := false else
22782: LD_ADDR_VAR 0 5
22786: PUSH
22787: LD_INT 0
22789: ST_TO_ADDR
22790: GO 22856
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22792: LD_INT 81
22794: PUSH
22795: LD_VAR 0 1
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: LD_INT 92
22806: PUSH
22807: LD_VAR 0 2
22811: PUSH
22812: LD_VAR 0 3
22816: PUSH
22817: LD_VAR 0 4
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: PPUSH
22832: CALL_OW 69
22836: IFFALSE 22848
// result := true else
22838: LD_ADDR_VAR 0 5
22842: PUSH
22843: LD_INT 1
22845: ST_TO_ADDR
22846: GO 22856
// result := false ;
22848: LD_ADDR_VAR 0 5
22852: PUSH
22853: LD_INT 0
22855: ST_TO_ADDR
// end ;
22856: LD_VAR 0 5
22860: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22861: LD_INT 0
22863: PPUSH
22864: PPUSH
22865: PPUSH
22866: PPUSH
22867: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22868: LD_VAR 0 1
22872: PPUSH
22873: LD_INT 81
22875: PUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 255
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: PPUSH
22890: CALL_OW 69
22894: PPUSH
22895: LD_VAR 0 1
22899: PPUSH
22900: CALL_OW 74
22904: PPUSH
22905: CALL_OW 119
// dir := GetDir ( un ) ;
22909: LD_ADDR_VAR 0 4
22913: PUSH
22914: LD_VAR 0 1
22918: PPUSH
22919: CALL_OW 254
22923: ST_TO_ADDR
// dir := dir - 3 ;
22924: LD_ADDR_VAR 0 4
22928: PUSH
22929: LD_VAR 0 4
22933: PUSH
22934: LD_INT 3
22936: MINUS
22937: ST_TO_ADDR
// if dir < 0 then
22938: LD_VAR 0 4
22942: PUSH
22943: LD_INT 0
22945: LESS
22946: IFFALSE 22962
// dir := dir + 6 ;
22948: LD_ADDR_VAR 0 4
22952: PUSH
22953: LD_VAR 0 4
22957: PUSH
22958: LD_INT 6
22960: PLUS
22961: ST_TO_ADDR
// while true do
22962: LD_INT 1
22964: IFFALSE 23461
// begin coord_dist := 3 ;
22966: LD_ADDR_VAR 0 3
22970: PUSH
22971: LD_INT 3
22973: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22974: LD_ADDR_VAR 0 5
22978: PUSH
22979: LD_VAR 0 1
22983: PPUSH
22984: CALL_OW 250
22988: PPUSH
22989: LD_VAR 0 4
22993: PPUSH
22994: LD_VAR 0 3
22998: PPUSH
22999: CALL_OW 272
23003: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23004: LD_ADDR_VAR 0 6
23008: PUSH
23009: LD_VAR 0 1
23013: PPUSH
23014: CALL_OW 251
23018: PPUSH
23019: LD_VAR 0 4
23023: PPUSH
23024: LD_VAR 0 3
23028: PPUSH
23029: CALL_OW 273
23033: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23034: LD_VAR 0 1
23038: PPUSH
23039: CALL_OW 255
23043: PPUSH
23044: LD_VAR 0 1
23048: PPUSH
23049: CALL_OW 250
23053: PPUSH
23054: LD_VAR 0 1
23058: PPUSH
23059: CALL_OW 251
23063: PPUSH
23064: LD_INT 14
23066: PPUSH
23067: CALL 22757 0 4
23071: PUSH
23072: LD_VAR 0 5
23076: PPUSH
23077: LD_VAR 0 6
23081: PPUSH
23082: CALL_OW 351
23086: OR
23087: PUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: LD_VAR 0 6
23097: PPUSH
23098: CALL_OW 488
23102: PUSH
23103: LD_INT 0
23105: EQUAL
23106: OR
23107: PUSH
23108: LD_VAR 0 5
23112: PPUSH
23113: LD_VAR 0 6
23117: PPUSH
23118: CALL_OW 546
23122: PUSH
23123: LD_INT 1
23125: EQUAL
23126: OR
23127: PUSH
23128: LD_VAR 0 5
23132: PPUSH
23133: LD_VAR 0 6
23137: PPUSH
23138: CALL_OW 428
23142: PUSH
23143: LD_INT 0
23145: NONEQUAL
23146: OR
23147: IFFALSE 23375
// begin repeat begin Wait ( 0 0$0.3 ) ;
23149: LD_INT 10
23151: PPUSH
23152: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23156: LD_ADDR_VAR 0 3
23160: PUSH
23161: LD_VAR 0 3
23165: PUSH
23166: LD_INT 1
23168: PLUS
23169: ST_TO_ADDR
// dir := dir + 1 ;
23170: LD_ADDR_VAR 0 4
23174: PUSH
23175: LD_VAR 0 4
23179: PUSH
23180: LD_INT 1
23182: PLUS
23183: ST_TO_ADDR
// if dir > 5 then
23184: LD_VAR 0 4
23188: PUSH
23189: LD_INT 5
23191: GREATER
23192: IFFALSE 23202
// dir = 0 ;
23194: LD_ADDR_VAR 0 4
23198: PUSH
23199: LD_INT 0
23201: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23202: LD_ADDR_VAR 0 5
23206: PUSH
23207: LD_VAR 0 1
23211: PPUSH
23212: CALL_OW 250
23216: PPUSH
23217: LD_VAR 0 4
23221: PPUSH
23222: LD_VAR 0 3
23226: PPUSH
23227: CALL_OW 272
23231: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23232: LD_ADDR_VAR 0 6
23236: PUSH
23237: LD_VAR 0 1
23241: PPUSH
23242: CALL_OW 251
23246: PPUSH
23247: LD_VAR 0 4
23251: PPUSH
23252: LD_VAR 0 3
23256: PPUSH
23257: CALL_OW 273
23261: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23262: LD_VAR 0 1
23266: PPUSH
23267: CALL_OW 255
23271: PPUSH
23272: LD_VAR 0 1
23276: PPUSH
23277: CALL_OW 250
23281: PPUSH
23282: LD_VAR 0 1
23286: PPUSH
23287: CALL_OW 251
23291: PPUSH
23292: LD_INT 14
23294: PPUSH
23295: CALL 22757 0 4
23299: NOT
23300: PUSH
23301: LD_VAR 0 5
23305: PPUSH
23306: LD_VAR 0 6
23310: PPUSH
23311: CALL_OW 351
23315: NOT
23316: AND
23317: PUSH
23318: LD_VAR 0 5
23322: PPUSH
23323: LD_VAR 0 6
23327: PPUSH
23328: CALL_OW 488
23332: AND
23333: PUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 546
23348: PUSH
23349: LD_INT 0
23351: EQUAL
23352: AND
23353: PUSH
23354: LD_VAR 0 5
23358: PPUSH
23359: LD_VAR 0 6
23363: PPUSH
23364: CALL_OW 428
23368: PUSH
23369: LD_INT 0
23371: EQUAL
23372: AND
23373: IFFALSE 23149
// end ; ComMoveXY ( un , x , y ) ;
23375: LD_VAR 0 1
23379: PPUSH
23380: LD_VAR 0 5
23384: PPUSH
23385: LD_VAR 0 6
23389: PPUSH
23390: CALL_OW 111
// Wait ( 0 0$1 ) ;
23394: LD_INT 35
23396: PPUSH
23397: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23401: LD_VAR 0 1
23405: PPUSH
23406: LD_INT 81
23408: PUSH
23409: LD_VAR 0 1
23413: PPUSH
23414: CALL_OW 255
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 69
23427: PPUSH
23428: LD_VAR 0 1
23432: PPUSH
23433: CALL_OW 74
23437: PPUSH
23438: CALL_OW 296
23442: PUSH
23443: LD_INT 14
23445: GREATEREQUAL
23446: IFFALSE 23459
// begin ComStop ( un ) ;
23448: LD_VAR 0 1
23452: PPUSH
23453: CALL_OW 141
// break ;
23457: GO 23461
// end ; end ;
23459: GO 22962
// end ;
23461: LD_VAR 0 2
23465: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23466: LD_INT 0
23468: PPUSH
23469: PPUSH
23470: PPUSH
23471: PPUSH
23472: PPUSH
23473: PPUSH
23474: PPUSH
23475: PPUSH
// x := GetX ( unit ) ;
23476: LD_ADDR_VAR 0 3
23480: PUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: CALL_OW 250
23490: ST_TO_ADDR
// y := GetY ( unit ) ;
23491: LD_ADDR_VAR 0 4
23495: PUSH
23496: LD_VAR 0 1
23500: PPUSH
23501: CALL_OW 251
23505: ST_TO_ADDR
// i := 0 ;
23506: LD_ADDR_VAR 0 8
23510: PUSH
23511: LD_INT 0
23513: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23514: LD_VAR 0 1
23518: PPUSH
23519: LD_INT 81
23521: PUSH
23522: LD_VAR 0 1
23526: PPUSH
23527: CALL_OW 255
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PPUSH
23536: CALL_OW 69
23540: PPUSH
23541: LD_VAR 0 1
23545: PPUSH
23546: CALL_OW 74
23550: PPUSH
23551: CALL_OW 119
// dir := GetDir ( unit ) ;
23555: LD_ADDR_VAR 0 7
23559: PUSH
23560: LD_VAR 0 1
23564: PPUSH
23565: CALL_OW 254
23569: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23570: LD_ADDR_VAR 0 9
23574: PUSH
23575: LD_INT 0
23577: PPUSH
23578: LD_INT 1
23580: PPUSH
23581: CALL_OW 12
23585: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23586: LD_INT 10
23588: PPUSH
23589: CALL_OW 67
// if mode then
23593: LD_VAR 0 9
23597: IFFALSE 23615
// dir := dir + 1 else
23599: LD_ADDR_VAR 0 7
23603: PUSH
23604: LD_VAR 0 7
23608: PUSH
23609: LD_INT 1
23611: PLUS
23612: ST_TO_ADDR
23613: GO 23629
// dir := dir - 1 ;
23615: LD_ADDR_VAR 0 7
23619: PUSH
23620: LD_VAR 0 7
23624: PUSH
23625: LD_INT 1
23627: MINUS
23628: ST_TO_ADDR
// if ( dir < 0 ) then
23629: LD_VAR 0 7
23633: PUSH
23634: LD_INT 0
23636: LESS
23637: IFFALSE 23647
// dir := 5 ;
23639: LD_ADDR_VAR 0 7
23643: PUSH
23644: LD_INT 5
23646: ST_TO_ADDR
// if ( dir > 5 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 5
23654: GREATER
23655: IFFALSE 23665
// dir := 0 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 0
23664: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23665: LD_ADDR_VAR 0 5
23669: PUSH
23670: LD_VAR 0 3
23674: PPUSH
23675: LD_VAR 0 7
23679: PPUSH
23680: LD_INT 4
23682: PPUSH
23683: CALL_OW 272
23687: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23688: LD_ADDR_VAR 0 6
23692: PUSH
23693: LD_VAR 0 4
23697: PPUSH
23698: LD_VAR 0 7
23702: PPUSH
23703: LD_INT 4
23705: PPUSH
23706: CALL_OW 273
23710: ST_TO_ADDR
// i := i + 1 ;
23711: LD_ADDR_VAR 0 8
23715: PUSH
23716: LD_VAR 0 8
23720: PUSH
23721: LD_INT 1
23723: PLUS
23724: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23725: LD_VAR 0 1
23729: PPUSH
23730: CALL_OW 255
23734: PPUSH
23735: LD_VAR 0 5
23739: PPUSH
23740: LD_VAR 0 6
23744: PPUSH
23745: LD_INT 14
23747: PPUSH
23748: CALL 22757 0 4
23752: PUSH
23753: LD_INT 0
23755: EQUAL
23756: PUSH
23757: LD_VAR 0 5
23761: PPUSH
23762: LD_VAR 0 6
23766: PPUSH
23767: CALL_OW 546
23771: PUSH
23772: LD_INT 0
23774: EQUAL
23775: AND
23776: PUSH
23777: LD_VAR 0 5
23781: PPUSH
23782: LD_VAR 0 6
23786: PPUSH
23787: CALL_OW 428
23791: PUSH
23792: LD_INT 0
23794: EQUAL
23795: AND
23796: IFFALSE 23800
// break ;
23798: GO 23810
// end until i > 4 ;
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 4
23807: GREATER
23808: IFFALSE 23586
// if x2 and y2 then
23810: LD_VAR 0 5
23814: PUSH
23815: LD_VAR 0 6
23819: AND
23820: IFFALSE 23843
// result := [ x2 , y2 ] else
23822: LD_ADDR_VAR 0 2
23826: PUSH
23827: LD_VAR 0 5
23831: PUSH
23832: LD_VAR 0 6
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: ST_TO_ADDR
23841: GO 23872
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23843: LD_ADDR_VAR 0 2
23847: PUSH
23848: LD_VAR 0 1
23852: PPUSH
23853: CALL_OW 250
23857: PUSH
23858: LD_VAR 0 1
23862: PPUSH
23863: CALL_OW 251
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: ST_TO_ADDR
// end ;
23872: LD_VAR 0 2
23876: RET
// export function MCT_Hex ( x , y ) ; begin
23877: LD_INT 0
23879: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23880: LD_ADDR_VAR 0 3
23884: PUSH
23885: LD_VAR 0 1
23889: PPUSH
23890: LD_VAR 0 2
23894: PPUSH
23895: CALL_OW 546
23899: PUSH
23900: LD_VAR 0 1
23904: PPUSH
23905: LD_VAR 0 2
23909: PPUSH
23910: CALL_OW 428
23914: PUSH
23915: EMPTY
23916: LIST
23917: PUSH
23918: EMPTY
23919: LIST
23920: LIST
23921: ST_TO_ADDR
// end ;
23922: LD_VAR 0 3
23926: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23927: LD_INT 0
23929: PPUSH
23930: PPUSH
23931: PPUSH
23932: PPUSH
23933: PPUSH
23934: PPUSH
23935: PPUSH
23936: PPUSH
23937: PPUSH
23938: PPUSH
23939: PPUSH
23940: PPUSH
23941: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23942: LD_ADDR_VAR 0 10
23946: PUSH
23947: LD_EXP 62
23951: PUSH
23952: LD_VAR 0 1
23956: ARRAY
23957: PUSH
23958: LD_INT 1
23960: ARRAY
23961: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23962: LD_ADDR_VAR 0 11
23966: PUSH
23967: LD_EXP 62
23971: PUSH
23972: LD_VAR 0 1
23976: ARRAY
23977: PUSH
23978: LD_INT 2
23980: ARRAY
23981: ST_TO_ADDR
// collectors := [ ] ;
23982: LD_ADDR_VAR 0 12
23986: PUSH
23987: EMPTY
23988: ST_TO_ADDR
// is_cargo := false ;
23989: LD_ADDR_VAR 0 13
23993: PUSH
23994: LD_INT 0
23996: ST_TO_ADDR
// if isTest then
23997: LD_EXP 1
24001: IFFALSE 24007
// TimerStart ( ) ;
24003: CALL_OW 548
// if MCF_Cargo ( side ) then
24007: LD_VAR 0 1
24011: PPUSH
24012: CALL 11938 0 1
24016: IFFALSE 24043
// begin collectors := MCF_Cargo ( side ) ;
24018: LD_ADDR_VAR 0 12
24022: PUSH
24023: LD_VAR 0 1
24027: PPUSH
24028: CALL 11938 0 1
24032: ST_TO_ADDR
// is_cargo := true ;
24033: LD_ADDR_VAR 0 13
24037: PUSH
24038: LD_INT 1
24040: ST_TO_ADDR
// end else
24041: GO 24192
// begin if MCF_ApeSpec ( side , engineer ) then
24043: LD_VAR 0 1
24047: PPUSH
24048: LD_STRING engineer
24050: PPUSH
24051: CALL 12084 0 2
24055: IFFALSE 24075
// collectors := MCF_ApeSpec ( side , engineer ) ;
24057: LD_ADDR_VAR 0 12
24061: PUSH
24062: LD_VAR 0 1
24066: PPUSH
24067: LD_STRING engineer
24069: PPUSH
24070: CALL 12084 0 2
24074: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24075: LD_VAR 0 1
24079: PPUSH
24080: LD_INT 2
24082: PPUSH
24083: EMPTY
24084: PPUSH
24085: CALL 11670 0 3
24089: IFFALSE 24192
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24091: LD_ADDR_VAR 0 7
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_INT 2
24103: PPUSH
24104: EMPTY
24105: PPUSH
24106: CALL 11670 0 3
24110: ST_TO_ADDR
// if z > 5 then
24111: LD_VAR 0 7
24115: PUSH
24116: LD_INT 5
24118: GREATER
24119: IFFALSE 24131
// t1 := 5 else
24121: LD_ADDR_VAR 0 8
24125: PUSH
24126: LD_INT 5
24128: ST_TO_ADDR
24129: GO 24141
// t1 := z ;
24131: LD_ADDR_VAR 0 8
24135: PUSH
24136: LD_VAR 0 7
24140: ST_TO_ADDR
// for t2 = 1 to t1 do
24141: LD_ADDR_VAR 0 9
24145: PUSH
24146: DOUBLE
24147: LD_INT 1
24149: DEC
24150: ST_TO_ADDR
24151: LD_VAR 0 8
24155: PUSH
24156: FOR_TO
24157: IFFALSE 24190
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24159: LD_ADDR_VAR 0 12
24163: PUSH
24164: LD_VAR 0 12
24168: PPUSH
24169: LD_INT 1
24171: PPUSH
24172: LD_VAR 0 7
24176: PUSH
24177: LD_VAR 0 9
24181: ARRAY
24182: PPUSH
24183: CALL_OW 2
24187: ST_TO_ADDR
24188: GO 24156
24190: POP
24191: POP
// end ; end ; if not mode then
24192: LD_VAR 0 10
24196: NOT
24197: IFFALSE 24203
// exit else
24199: GO 24462
24201: GO 24462
// begin if collectors then
24203: LD_VAR 0 12
24207: IFFALSE 24462
// for i in areas do
24209: LD_ADDR_VAR 0 3
24213: PUSH
24214: LD_VAR 0 11
24218: PUSH
24219: FOR_IN
24220: IFFALSE 24460
// if GetListOfCratesInArea ( i ) then
24222: LD_VAR 0 3
24226: PPUSH
24227: CALL_OW 435
24231: IFFALSE 24458
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24233: LD_ADDR_VAR 0 5
24237: PUSH
24238: LD_VAR 0 3
24242: PPUSH
24243: CALL_OW 435
24247: PUSH
24248: LD_INT 1
24250: ARRAY
24251: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24252: LD_ADDR_VAR 0 6
24256: PUSH
24257: LD_VAR 0 3
24261: PPUSH
24262: CALL_OW 435
24266: PUSH
24267: LD_INT 2
24269: ARRAY
24270: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24271: LD_VAR 0 13
24275: PUSH
24276: LD_VAR 0 12
24280: PUSH
24281: LD_INT 1
24283: ARRAY
24284: PPUSH
24285: CALL_OW 110
24289: PUSH
24290: LD_INT 0
24292: EQUAL
24293: AND
24294: IFFALSE 24356
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24296: LD_VAR 0 12
24300: PUSH
24301: LD_INT 1
24303: ARRAY
24304: PPUSH
24305: CALL_OW 314
24309: NOT
24310: PUSH
24311: LD_VAR 0 12
24315: PUSH
24316: LD_INT 1
24318: ARRAY
24319: PPUSH
24320: CALL_OW 110
24324: PUSH
24325: LD_INT 0
24327: EQUAL
24328: AND
24329: IFFALSE 24354
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24331: LD_VAR 0 12
24335: PUSH
24336: LD_INT 1
24338: ARRAY
24339: PPUSH
24340: LD_VAR 0 5
24344: PPUSH
24345: LD_VAR 0 6
24349: PPUSH
24350: CALL_OW 117
// end ; end else
24354: GO 24442
// begin for j = 1 to collectors do
24356: LD_ADDR_VAR 0 4
24360: PUSH
24361: DOUBLE
24362: LD_INT 1
24364: DEC
24365: ST_TO_ADDR
24366: LD_VAR 0 12
24370: PUSH
24371: FOR_TO
24372: IFFALSE 24440
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24374: LD_VAR 0 12
24378: PUSH
24379: LD_VAR 0 4
24383: ARRAY
24384: PPUSH
24385: CALL_OW 314
24389: NOT
24390: PUSH
24391: LD_VAR 0 12
24395: PUSH
24396: LD_VAR 0 4
24400: ARRAY
24401: PPUSH
24402: CALL_OW 110
24406: PUSH
24407: LD_INT 0
24409: EQUAL
24410: AND
24411: IFFALSE 24438
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24413: LD_VAR 0 12
24417: PUSH
24418: LD_VAR 0 4
24422: ARRAY
24423: PPUSH
24424: LD_VAR 0 5
24428: PPUSH
24429: LD_VAR 0 6
24433: PPUSH
24434: CALL 24833 0 3
// end ;
24438: GO 24371
24440: POP
24441: POP
// end ; if isTest then
24442: LD_EXP 1
24446: IFFALSE 24458
// begin debug_time := TimerEnd ( ) ;
24448: LD_ADDR_VAR 0 14
24452: PUSH
24453: CALL_OW 549
24457: ST_TO_ADDR
// end ; end ;
24458: GO 24219
24460: POP
24461: POP
// end ; end ;
24462: LD_VAR 0 2
24466: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24467: LD_INT 0
24469: PPUSH
24470: PPUSH
24471: PPUSH
24472: PPUSH
24473: PPUSH
24474: PPUSH
// if not area then
24475: LD_VAR 0 1
24479: NOT
24480: IFFALSE 24486
// exit else
24482: GO 24748
24484: GO 24748
// if tick mod interval = 0 and Prob ( percent ) then
24486: LD_OWVAR 1
24490: PUSH
24491: LD_VAR 0 4
24495: MOD
24496: PUSH
24497: LD_INT 0
24499: EQUAL
24500: PUSH
24501: LD_VAR 0 3
24505: PPUSH
24506: CALL_OW 13
24510: AND
24511: IFFALSE 24748
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24513: LD_VAR 0 1
24517: PPUSH
24518: CALL_OW 435
24522: PUSH
24523: LD_VAR 0 5
24527: LESS
24528: PUSH
24529: LD_VAR 0 5
24533: PUSH
24534: LD_INT 0
24536: EQUAL
24537: OR
24538: IFFALSE 24748
// begin Randomize ;
24540: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24544: LD_ADDR_VAR 0 7
24548: PUSH
24549: LD_INT 1
24551: PPUSH
24552: LD_VAR 0 2
24556: PPUSH
24557: CALL_OW 12
24561: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24562: LD_ADDR_VAR 0 9
24566: PUSH
24567: LD_VAR 0 1
24571: PPUSH
24572: LD_INT 0
24574: PPUSH
24575: CALL_OW 517
24579: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24580: LD_ADDR_VAR 0 8
24584: PUSH
24585: LD_INT 1
24587: PPUSH
24588: LD_VAR 0 9
24592: PUSH
24593: LD_INT 1
24595: ARRAY
24596: PPUSH
24597: CALL_OW 12
24601: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24602: LD_VAR 0 9
24606: PUSH
24607: LD_INT 1
24609: ARRAY
24610: PUSH
24611: LD_VAR 0 8
24615: ARRAY
24616: PPUSH
24617: LD_VAR 0 9
24621: PUSH
24622: LD_INT 2
24624: ARRAY
24625: PUSH
24626: LD_VAR 0 8
24630: ARRAY
24631: PPUSH
24632: CALL_OW 428
24636: PUSH
24637: LD_INT 0
24639: GREATER
24640: PUSH
24641: LD_VAR 0 9
24645: PUSH
24646: LD_INT 1
24648: ARRAY
24649: PUSH
24650: LD_VAR 0 8
24654: ARRAY
24655: PPUSH
24656: LD_VAR 0 9
24660: PUSH
24661: LD_INT 2
24663: ARRAY
24664: PUSH
24665: LD_VAR 0 8
24669: ARRAY
24670: PPUSH
24671: CALL_OW 284
24675: PUSH
24676: LD_INT 0
24678: GREATER
24679: AND
24680: IFFALSE 24706
// c := Rand ( 1 , tmp [ 1 ] ) ;
24682: LD_ADDR_VAR 0 8
24686: PUSH
24687: LD_INT 1
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 1
24697: ARRAY
24698: PPUSH
24699: CALL_OW 12
24703: ST_TO_ADDR
24704: GO 24602
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24706: LD_VAR 0 7
24710: PPUSH
24711: LD_VAR 0 9
24715: PUSH
24716: LD_INT 1
24718: ARRAY
24719: PUSH
24720: LD_VAR 0 8
24724: ARRAY
24725: PPUSH
24726: LD_VAR 0 9
24730: PUSH
24731: LD_INT 2
24733: ARRAY
24734: PUSH
24735: LD_VAR 0 8
24739: ARRAY
24740: PPUSH
24741: LD_INT 1
24743: PPUSH
24744: CALL_OW 54
// end ; end ; end ;
24748: LD_VAR 0 6
24752: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24753: LD_INT 0
24755: PPUSH
24756: PPUSH
// if not MREG_Crates then
24757: LD_EXP 36
24761: NOT
24762: IFFALSE 24766
// exit ;
24764: GO 24828
// for i = MREG_Crates downto 1 do
24766: LD_ADDR_VAR 0 2
24770: PUSH
24771: DOUBLE
24772: LD_EXP 36
24776: INC
24777: ST_TO_ADDR
24778: LD_INT 1
24780: PUSH
24781: FOR_DOWNTO
24782: IFFALSE 24826
// if MREG_Crates [ i ] [ 3 ] = 0 then
24784: LD_EXP 36
24788: PUSH
24789: LD_VAR 0 2
24793: ARRAY
24794: PUSH
24795: LD_INT 3
24797: ARRAY
24798: PUSH
24799: LD_INT 0
24801: EQUAL
24802: IFFALSE 24824
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24804: LD_ADDR_EXP 36
24808: PUSH
24809: LD_EXP 36
24813: PPUSH
24814: LD_VAR 0 2
24818: PPUSH
24819: CALL_OW 3
24823: ST_TO_ADDR
24824: GO 24781
24826: POP
24827: POP
// end ;
24828: LD_VAR 0 1
24832: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24833: LD_INT 0
24835: PPUSH
24836: PPUSH
24837: PPUSH
24838: PPUSH
// if not unit then
24839: LD_VAR 0 1
24843: NOT
24844: IFFALSE 24848
// exit ;
24846: GO 24983
// if HasTask ( unit ) or not CanCarry ( unit ) then
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 314
24857: PUSH
24858: LD_VAR 0 1
24862: PPUSH
24863: CALL_OW 280
24867: NOT
24868: OR
24869: IFFALSE 24873
// exit ;
24871: GO 24983
// side := GetSide ( unit ) ;
24873: LD_ADDR_VAR 0 6
24877: PUSH
24878: LD_VAR 0 1
24882: PPUSH
24883: CALL_OW 255
24887: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24888: LD_ADDR_VAR 0 7
24892: PUSH
24893: LD_VAR 0 6
24897: PPUSH
24898: LD_INT 30
24900: PUSH
24901: LD_INT 1
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PPUSH
24908: CALL 11587 0 2
24912: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24913: LD_VAR 0 1
24917: PPUSH
24918: CALL_OW 281
24922: PUSH
24923: LD_VAR 0 7
24927: NOT
24928: OR
24929: IFFALSE 24935
// exit else
24931: GO 24983
24933: GO 24983
// if GetResourceAmountXY ( x , y ) then
24935: LD_VAR 0 2
24939: PPUSH
24940: LD_VAR 0 3
24944: PPUSH
24945: CALL_OW 284
24949: IFFALSE 24981
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24951: LD_VAR 0 1
24955: PPUSH
24956: LD_VAR 0 2
24960: PPUSH
24961: LD_VAR 0 3
24965: PPUSH
24966: LD_VAR 0 7
24970: PUSH
24971: LD_INT 1
24973: ARRAY
24974: PPUSH
24975: CALL 32289 0 4
// end else
24979: GO 24983
// exit ;
24981: GO 24983
// end ;
24983: LD_VAR 0 4
24987: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24988: LD_INT 0
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
// result := 0 ;
24995: LD_ADDR_VAR 0 2
24999: PUSH
25000: LD_INT 0
25002: ST_TO_ADDR
// p := 1 ;
25003: LD_ADDR_VAR 0 4
25007: PUSH
25008: LD_INT 1
25010: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25011: LD_ADDR_VAR 0 3
25015: PUSH
25016: DOUBLE
25017: LD_INT 1
25019: DEC
25020: ST_TO_ADDR
25021: LD_EXP 65
25025: PUSH
25026: LD_VAR 0 1
25030: ARRAY
25031: PUSH
25032: LD_INT 1
25034: ARRAY
25035: PUSH
25036: LD_INT 2
25038: DIVREAL
25039: PUSH
25040: FOR_TO
25041: IFFALSE 25165
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25043: LD_ADDR_VAR 0 5
25047: PUSH
25048: LD_INT 81
25050: PUSH
25051: LD_VAR 0 1
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 92
25062: PUSH
25063: LD_EXP 65
25067: PUSH
25068: LD_VAR 0 1
25072: ARRAY
25073: PUSH
25074: LD_INT 1
25076: ARRAY
25077: PUSH
25078: LD_VAR 0 4
25082: ARRAY
25083: PUSH
25084: LD_EXP 65
25088: PUSH
25089: LD_VAR 0 1
25093: ARRAY
25094: PUSH
25095: LD_INT 1
25097: ARRAY
25098: PUSH
25099: LD_VAR 0 4
25103: PUSH
25104: LD_INT 1
25106: PLUS
25107: ARRAY
25108: PUSH
25109: LD_INT 12
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: LIST
25116: LIST
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PPUSH
25122: CALL_OW 69
25126: ST_TO_ADDR
// if tmp then
25127: LD_VAR 0 5
25131: IFFALSE 25149
// result := result ^ tmp ;
25133: LD_ADDR_VAR 0 2
25137: PUSH
25138: LD_VAR 0 2
25142: PUSH
25143: LD_VAR 0 5
25147: ADD
25148: ST_TO_ADDR
// p := p + 2 ;
25149: LD_ADDR_VAR 0 4
25153: PUSH
25154: LD_VAR 0 4
25158: PUSH
25159: LD_INT 2
25161: PLUS
25162: ST_TO_ADDR
// end ;
25163: GO 25040
25165: POP
25166: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25167: LD_EXP 66
25171: PUSH
25172: LD_VAR 0 1
25176: ARRAY
25177: PPUSH
25178: LD_INT 81
25180: PUSH
25181: LD_VAR 0 1
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PPUSH
25190: CALL_OW 70
25194: IFFALSE 25235
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25196: LD_ADDR_VAR 0 2
25200: PUSH
25201: LD_VAR 0 2
25205: PUSH
25206: LD_EXP 66
25210: PUSH
25211: LD_VAR 0 1
25215: ARRAY
25216: PPUSH
25217: LD_INT 81
25219: PUSH
25220: LD_VAR 0 1
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PPUSH
25229: CALL_OW 70
25233: ADD
25234: ST_TO_ADDR
// end ; end_of_file
25235: LD_VAR 0 2
25239: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25240: LD_INT 0
25242: PPUSH
25243: PPUSH
25244: PPUSH
// pom := GetBase ( fac ) ;
25245: LD_ADDR_VAR 0 5
25249: PUSH
25250: LD_VAR 0 1
25254: PPUSH
25255: CALL_OW 274
25259: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25260: LD_ADDR_VAR 0 4
25264: PUSH
25265: LD_VAR 0 2
25269: PUSH
25270: LD_INT 1
25272: ARRAY
25273: PPUSH
25274: LD_VAR 0 2
25278: PUSH
25279: LD_INT 2
25281: ARRAY
25282: PPUSH
25283: LD_VAR 0 2
25287: PUSH
25288: LD_INT 3
25290: ARRAY
25291: PPUSH
25292: LD_VAR 0 2
25296: PUSH
25297: LD_INT 4
25299: ARRAY
25300: PPUSH
25301: CALL_OW 449
25305: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25306: LD_VAR 0 5
25310: PPUSH
25311: LD_INT 1
25313: PPUSH
25314: CALL_OW 275
25318: PUSH
25319: LD_VAR 0 4
25323: PUSH
25324: LD_INT 1
25326: ARRAY
25327: GREATEREQUAL
25328: PUSH
25329: LD_VAR 0 5
25333: PPUSH
25334: LD_INT 2
25336: PPUSH
25337: CALL_OW 275
25341: PUSH
25342: LD_VAR 0 4
25346: PUSH
25347: LD_INT 2
25349: ARRAY
25350: GREATEREQUAL
25351: AND
25352: PUSH
25353: LD_VAR 0 5
25357: PPUSH
25358: LD_INT 3
25360: PPUSH
25361: CALL_OW 275
25365: PUSH
25366: LD_VAR 0 4
25370: PUSH
25371: LD_INT 3
25373: ARRAY
25374: GREATEREQUAL
25375: AND
25376: IFFALSE 25388
// result := true else
25378: LD_ADDR_VAR 0 3
25382: PUSH
25383: LD_INT 1
25385: ST_TO_ADDR
25386: GO 25396
// result := false ;
25388: LD_ADDR_VAR 0 3
25392: PUSH
25393: LD_INT 0
25395: ST_TO_ADDR
// end ;
25396: LD_VAR 0 3
25400: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25401: LD_INT 0
25403: PPUSH
25404: PPUSH
25405: PPUSH
// result := false ;
25406: LD_ADDR_VAR 0 3
25410: PUSH
25411: LD_INT 0
25413: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25414: LD_ADDR_VAR 0 4
25418: PUSH
25419: LD_EXP 53
25423: PUSH
25424: LD_VAR 0 1
25428: ARRAY
25429: ST_TO_ADDR
// if tmp then
25430: LD_VAR 0 4
25434: IFFALSE 25486
// for i = 1 to tmp do
25436: LD_ADDR_VAR 0 5
25440: PUSH
25441: DOUBLE
25442: LD_INT 1
25444: DEC
25445: ST_TO_ADDR
25446: LD_VAR 0 4
25450: PUSH
25451: FOR_TO
25452: IFFALSE 25484
// if component = tmp [ i ] then
25454: LD_VAR 0 2
25458: PUSH
25459: LD_VAR 0 4
25463: PUSH
25464: LD_VAR 0 5
25468: ARRAY
25469: EQUAL
25470: IFFALSE 25482
// begin result := true ;
25472: LD_ADDR_VAR 0 3
25476: PUSH
25477: LD_INT 1
25479: ST_TO_ADDR
// break ;
25480: GO 25484
// end ;
25482: GO 25451
25484: POP
25485: POP
// end ;
25486: LD_VAR 0 3
25490: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25491: LD_INT 0
25493: PPUSH
25494: PPUSH
25495: PPUSH
// if fac then
25496: LD_VAR 0 2
25500: IFFALSE 25735
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 3
25511: PPUSH
25512: CALL 25240 0 2
25516: PUSH
25517: LD_VAR 0 2
25521: PPUSH
25522: CALL_OW 461
25526: PUSH
25527: LD_INT 2
25529: EQUAL
25530: AND
25531: PUSH
25532: LD_VAR 0 2
25536: PPUSH
25537: LD_VAR 0 3
25541: PUSH
25542: LD_INT 1
25544: ARRAY
25545: PPUSH
25546: LD_VAR 0 3
25550: PUSH
25551: LD_INT 2
25553: ARRAY
25554: PPUSH
25555: LD_VAR 0 3
25559: PUSH
25560: LD_INT 3
25562: ARRAY
25563: PPUSH
25564: LD_VAR 0 3
25568: PUSH
25569: LD_INT 4
25571: ARRAY
25572: PPUSH
25573: CALL_OW 448
25577: AND
25578: IFFALSE 25725
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25580: LD_VAR 0 2
25584: PPUSH
25585: LD_VAR 0 3
25589: PUSH
25590: LD_INT 1
25592: ARRAY
25593: PPUSH
25594: LD_VAR 0 3
25598: PUSH
25599: LD_INT 2
25601: ARRAY
25602: PPUSH
25603: LD_VAR 0 3
25607: PUSH
25608: LD_INT 3
25610: ARRAY
25611: PPUSH
25612: LD_VAR 0 3
25616: PUSH
25617: LD_INT 4
25619: ARRAY
25620: PPUSH
25621: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25625: LD_ADDR_VAR 0 6
25629: PUSH
25630: LD_EXP 53
25634: PUSH
25635: LD_VAR 0 1
25639: ARRAY
25640: ST_TO_ADDR
// for i = 4 downto 1 do
25641: LD_ADDR_VAR 0 5
25645: PUSH
25646: DOUBLE
25647: LD_INT 4
25649: INC
25650: ST_TO_ADDR
25651: LD_INT 1
25653: PUSH
25654: FOR_DOWNTO
25655: IFFALSE 25688
// tab := Remove ( tab , list [ i ] , true ) ;
25657: LD_ADDR_VAR 0 6
25661: PUSH
25662: LD_VAR 0 6
25666: PPUSH
25667: LD_VAR 0 3
25671: PUSH
25672: LD_VAR 0 5
25676: ARRAY
25677: PPUSH
25678: LD_INT 1
25680: PPUSH
25681: CALL 31284 0 3
25685: ST_TO_ADDR
25686: GO 25654
25688: POP
25689: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25690: LD_ADDR_EXP 53
25694: PUSH
25695: LD_EXP 53
25699: PPUSH
25700: LD_VAR 0 1
25704: PPUSH
25705: LD_VAR 0 6
25709: PPUSH
25710: CALL_OW 1
25714: ST_TO_ADDR
// result := true ;
25715: LD_ADDR_VAR 0 4
25719: PUSH
25720: LD_INT 1
25722: ST_TO_ADDR
// end else
25723: GO 25733
// result := false ;
25725: LD_ADDR_VAR 0 4
25729: PUSH
25730: LD_INT 0
25732: ST_TO_ADDR
// end else
25733: GO 25743
// result := false ;
25735: LD_ADDR_VAR 0 4
25739: PUSH
25740: LD_INT 0
25742: ST_TO_ADDR
// end ;
25743: LD_VAR 0 4
25747: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25748: LD_INT 0
25750: PPUSH
25751: PPUSH
// if not veh then
25752: LD_VAR 0 2
25756: NOT
25757: IFFALSE 25761
// exit ;
25759: GO 25935
// if MREG_Parking [ side ] then
25761: LD_EXP 60
25765: PUSH
25766: LD_VAR 0 1
25770: ARRAY
25771: IFFALSE 25935
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25773: LD_VAR 0 2
25777: PPUSH
25778: LD_EXP 60
25782: PUSH
25783: LD_VAR 0 1
25787: ARRAY
25788: PPUSH
25789: CALL_OW 308
25793: NOT
25794: IFFALSE 25935
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25796: LD_VAR 0 2
25800: PPUSH
25801: LD_EXP 60
25805: PUSH
25806: LD_VAR 0 1
25810: ARRAY
25811: PPUSH
25812: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25816: LD_VAR 0 2
25820: PPUSH
25821: CALL_OW 263
25825: PUSH
25826: LD_INT 1
25828: EQUAL
25829: IFFALSE 25935
// begin i := GetDriver ( veh ) ;
25831: LD_ADDR_VAR 0 4
25835: PUSH
25836: LD_VAR 0 2
25840: PPUSH
25841: CALL 31819 0 1
25845: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25846: LD_INT 35
25848: PPUSH
25849: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25853: LD_VAR 0 2
25857: PPUSH
25858: LD_EXP 60
25862: PUSH
25863: LD_VAR 0 1
25867: ARRAY
25868: PPUSH
25869: CALL_OW 308
25873: PUSH
25874: LD_VAR 0 2
25878: PPUSH
25879: CALL_OW 301
25883: OR
25884: IFFALSE 25846
// ComExitVehicle ( i ) ;
25886: LD_VAR 0 4
25890: PPUSH
25891: CALL_OW 121
// Wait ( 1 ) ;
25895: LD_INT 1
25897: PPUSH
25898: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25902: LD_VAR 0 4
25906: PPUSH
25907: LD_VAR 0 1
25911: PPUSH
25912: LD_INT 30
25914: PUSH
25915: LD_INT 3
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: PPUSH
25922: CALL 11587 0 2
25926: PUSH
25927: LD_INT 1
25929: ARRAY
25930: PPUSH
25931: CALL_OW 180
// end ; end ; end ;
25935: LD_VAR 0 3
25939: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25940: LD_INT 0
25942: PPUSH
25943: PPUSH
25944: PPUSH
25945: PPUSH
25946: PPUSH
25947: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25948: LD_VAR 0 1
25952: PPUSH
25953: LD_INT 30
25955: PUSH
25956: LD_INT 3
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PPUSH
25963: CALL 11587 0 2
25967: IFFALSE 26151
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25969: LD_VAR 0 1
25973: PPUSH
25974: LD_INT 30
25976: PUSH
25977: LD_INT 3
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PPUSH
25984: CALL 11587 0 2
25988: PUSH
25989: LD_INT 1
25991: ARRAY
25992: PPUSH
25993: CALL_OW 461
25997: PUSH
25998: LD_INT 2
26000: EQUAL
26001: IFFALSE 26151
// begin for i = 1 to MREG_TurretWeapon do
26003: LD_ADDR_VAR 0 3
26007: PUSH
26008: DOUBLE
26009: LD_INT 1
26011: DEC
26012: ST_TO_ADDR
26013: LD_EXP 45
26017: PUSH
26018: FOR_TO
26019: IFFALSE 26149
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26021: LD_EXP 45
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: LD_INT 1
26034: ARRAY
26035: PUSH
26036: LD_VAR 0 1
26040: EQUAL
26041: IFFALSE 26147
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26043: LD_ADDR_VAR 0 5
26047: PUSH
26048: LD_EXP 45
26052: PUSH
26053: LD_VAR 0 3
26057: ARRAY
26058: PUSH
26059: LD_INT 2
26061: ARRAY
26062: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26063: LD_ADDR_VAR 0 6
26067: PUSH
26068: LD_EXP 45
26072: PUSH
26073: LD_VAR 0 3
26077: ARRAY
26078: PUSH
26079: LD_INT 3
26081: ARRAY
26082: PUSH
26083: LD_INT 1
26085: ARRAY
26086: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26087: LD_ADDR_VAR 0 7
26091: PUSH
26092: LD_EXP 45
26096: PUSH
26097: LD_VAR 0 3
26101: ARRAY
26102: PUSH
26103: LD_INT 3
26105: ARRAY
26106: PUSH
26107: LD_INT 2
26109: ARRAY
26110: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26111: LD_ADDR_VAR 0 4
26115: PUSH
26116: LD_VAR 0 6
26120: PPUSH
26121: LD_VAR 0 7
26125: PPUSH
26126: CALL_OW 428
26130: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26131: LD_VAR 0 4
26135: PPUSH
26136: LD_VAR 0 5
26140: PPUSH
26141: CALL_OW 148
// break ;
26145: GO 26149
// end ;
26147: GO 26018
26149: POP
26150: POP
// end ; end ;
26151: LD_VAR 0 2
26155: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26156: LD_INT 0
26158: PPUSH
26159: PPUSH
26160: PPUSH
26161: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26162: LD_ADDR_VAR 0 4
26166: PUSH
26167: LD_VAR 0 1
26171: PPUSH
26172: LD_INT 32
26174: PUSH
26175: LD_INT 1
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PPUSH
26182: CALL 11587 0 2
26186: ST_TO_ADDR
// if not tmp then
26187: LD_VAR 0 4
26191: NOT
26192: IFFALSE 26198
// exit else
26194: GO 26280
26196: GO 26280
// begin for i = 1 to tmp do
26198: LD_ADDR_VAR 0 3
26202: PUSH
26203: DOUBLE
26204: LD_INT 1
26206: DEC
26207: ST_TO_ADDR
26208: LD_VAR 0 4
26212: PUSH
26213: FOR_TO
26214: IFFALSE 26278
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26216: LD_VAR 0 4
26220: PUSH
26221: LD_VAR 0 3
26225: ARRAY
26226: PPUSH
26227: CALL_OW 261
26231: PUSH
26232: LD_INT 20
26234: LESS
26235: PUSH
26236: LD_VAR 0 4
26240: PUSH
26241: LD_VAR 0 3
26245: ARRAY
26246: PPUSH
26247: CALL_OW 110
26251: PUSH
26252: LD_INT 0
26254: EQUAL
26255: AND
26256: IFFALSE 26276
// begin SetTag ( tmp [ i ] , 21 ) ;
26258: LD_VAR 0 4
26262: PUSH
26263: LD_VAR 0 3
26267: ARRAY
26268: PPUSH
26269: LD_INT 21
26271: PPUSH
26272: CALL_OW 109
// end ;
26276: GO 26213
26278: POP
26279: POP
// end ; end ;
26280: LD_VAR 0 2
26284: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26285: LD_INT 0
26287: PPUSH
26288: PPUSH
26289: PPUSH
26290: PPUSH
26291: PPUSH
// if not unit then
26292: LD_VAR 0 1
26296: NOT
26297: IFFALSE 26301
// exit ;
26299: GO 26489
// side := GetSide ( unit ) ;
26301: LD_ADDR_VAR 0 3
26305: PUSH
26306: LD_VAR 0 1
26310: PPUSH
26311: CALL_OW 255
26315: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26316: LD_ADDR_VAR 0 5
26320: PUSH
26321: LD_VAR 0 3
26325: PPUSH
26326: LD_INT 2
26328: PUSH
26329: LD_INT 30
26331: PUSH
26332: LD_INT 1
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 30
26341: PUSH
26342: LD_INT 3
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 30
26351: PUSH
26352: LD_INT 29
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: PPUSH
26365: CALL 11587 0 2
26369: ST_TO_ADDR
// if not b then
26370: LD_VAR 0 5
26374: NOT
26375: IFFALSE 26379
// exit ;
26377: GO 26489
// if GetTag ( unit ) = 21 then
26379: LD_VAR 0 1
26383: PPUSH
26384: CALL_OW 110
26388: PUSH
26389: LD_INT 21
26391: EQUAL
26392: IFFALSE 26489
// begin c := NearestUnitToUnit ( b , unit ) ;
26394: LD_ADDR_VAR 0 6
26398: PUSH
26399: LD_VAR 0 5
26403: PPUSH
26404: LD_VAR 0 1
26408: PPUSH
26409: CALL_OW 74
26413: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26414: LD_VAR 0 1
26418: PPUSH
26419: LD_VAR 0 6
26423: PPUSH
26424: CALL_OW 250
26428: PPUSH
26429: LD_VAR 0 6
26433: PPUSH
26434: CALL_OW 251
26438: PPUSH
26439: CALL_OW 297
26443: PUSH
26444: LD_INT 6
26446: GREATER
26447: IFFALSE 26465
// ComMoveUnit ( unit , c ) else
26449: LD_VAR 0 1
26453: PPUSH
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 112
26463: GO 26489
// begin SetFuel ( unit , 100 ) ;
26465: LD_VAR 0 1
26469: PPUSH
26470: LD_INT 100
26472: PPUSH
26473: CALL_OW 240
// SetTag ( unit , 0 ) ;
26477: LD_VAR 0 1
26481: PPUSH
26482: LD_INT 0
26484: PPUSH
26485: CALL_OW 109
// end ; end ; end ;
26489: LD_VAR 0 2
26493: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26494: LD_INT 0
26496: PPUSH
26497: PPUSH
26498: PPUSH
26499: PPUSH
26500: PPUSH
26501: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26502: LD_ADDR_VAR 0 7
26506: PUSH
26507: LD_VAR 0 1
26511: PPUSH
26512: LD_INT 33
26514: PUSH
26515: LD_INT 2
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: LD_INT 3
26524: PUSH
26525: LD_INT 61
26527: PUSH
26528: EMPTY
26529: LIST
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PPUSH
26539: CALL 11587 0 2
26543: ST_TO_ADDR
// if not vehs then
26544: LD_VAR 0 7
26548: NOT
26549: IFFALSE 26553
// exit ;
26551: GO 26838
// if nation = 1 then
26553: LD_VAR 0 2
26557: PUSH
26558: LD_INT 1
26560: EQUAL
26561: IFFALSE 26731
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26563: LD_VAR 0 1
26567: PPUSH
26568: LD_INT 30
26570: PUSH
26571: LD_INT 36
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PPUSH
26578: CALL 11587 0 2
26582: NOT
26583: IFFALSE 26589
// exit else
26585: GO 26838
26587: GO 26729
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26589: LD_ADDR_VAR 0 5
26593: PUSH
26594: LD_VAR 0 1
26598: PPUSH
26599: LD_INT 30
26601: PUSH
26602: LD_INT 36
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL 11587 0 2
26613: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26614: LD_ADDR_VAR 0 6
26618: PUSH
26619: LD_VAR 0 5
26623: PUSH
26624: LD_INT 1
26626: ARRAY
26627: PPUSH
26628: CALL_OW 313
26632: ST_TO_ADDR
// for i = vehs downto 1 do
26633: LD_ADDR_VAR 0 4
26637: PUSH
26638: DOUBLE
26639: LD_VAR 0 7
26643: INC
26644: ST_TO_ADDR
26645: LD_INT 1
26647: PUSH
26648: FOR_DOWNTO
26649: IFFALSE 26727
// begin if not IsControledBy ( vehs [ i ] ) then
26651: LD_VAR 0 7
26655: PUSH
26656: LD_VAR 0 4
26660: ARRAY
26661: PPUSH
26662: CALL_OW 312
26666: NOT
26667: IFFALSE 26725
// begin tmp := MCV_RemoteDriver ( oper ) ;
26669: LD_ADDR_VAR 0 8
26673: PUSH
26674: LD_VAR 0 6
26678: PPUSH
26679: CALL 26843 0 1
26683: ST_TO_ADDR
// if not tmp then
26684: LD_VAR 0 8
26688: NOT
26689: IFFALSE 26697
// exit else
26691: POP
26692: POP
26693: GO 26838
26695: GO 26725
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26697: LD_VAR 0 7
26701: PUSH
26702: LD_VAR 0 4
26706: ARRAY
26707: PPUSH
26708: LD_VAR 0 8
26712: PUSH
26713: LD_INT 1
26715: ARRAY
26716: PUSH
26717: LD_INT 1
26719: ARRAY
26720: PPUSH
26721: CALL_OW 135
// end ; end ;
26725: GO 26648
26727: POP
26728: POP
// end ; end else
26729: GO 26838
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26731: LD_VAR 0 1
26735: PPUSH
26736: LD_INT 34
26738: PUSH
26739: LD_INT 31
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PPUSH
26746: CALL 11587 0 2
26750: NOT
26751: IFFALSE 26757
// exit else
26753: GO 26838
26755: GO 26838
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26757: LD_ADDR_VAR 0 5
26761: PUSH
26762: LD_VAR 0 1
26766: PPUSH
26767: LD_INT 34
26769: PUSH
26770: LD_INT 31
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PPUSH
26777: CALL 11587 0 2
26781: ST_TO_ADDR
// oper := [ ] ;
26782: LD_ADDR_VAR 0 6
26786: PUSH
26787: EMPTY
26788: ST_TO_ADDR
// for i = 1 to ct do
26789: LD_ADDR_VAR 0 4
26793: PUSH
26794: DOUBLE
26795: LD_INT 1
26797: DEC
26798: ST_TO_ADDR
26799: LD_VAR 0 5
26803: PUSH
26804: FOR_TO
26805: IFFALSE 26836
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26807: LD_ADDR_VAR 0 6
26811: PUSH
26812: LD_VAR 0 6
26816: PUSH
26817: LD_VAR 0 5
26821: PUSH
26822: LD_VAR 0 4
26826: ARRAY
26827: PPUSH
26828: CALL 31819 0 1
26832: ADD
26833: ST_TO_ADDR
26834: GO 26804
26836: POP
26837: POP
// end ; end ; end ;
26838: LD_VAR 0 3
26842: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26843: LD_INT 0
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
// if not drivers then
26851: LD_VAR 0 1
26855: NOT
26856: IFFALSE 26862
// exit else
26858: GO 27142
26860: GO 27142
// begin linked := [ ] ;
26862: LD_ADDR_VAR 0 5
26866: PUSH
26867: EMPTY
26868: ST_TO_ADDR
// for i = 1 to drivers do
26869: LD_ADDR_VAR 0 3
26873: PUSH
26874: DOUBLE
26875: LD_INT 1
26877: DEC
26878: ST_TO_ADDR
26879: LD_VAR 0 1
26883: PUSH
26884: FOR_TO
26885: IFFALSE 27130
// begin if CanControl ( drivers [ i ] ) then
26887: LD_VAR 0 1
26891: PUSH
26892: LD_VAR 0 3
26896: ARRAY
26897: PPUSH
26898: CALL 32391 0 1
26902: IFFALSE 27128
// if i > 1 then
26904: LD_VAR 0 3
26908: PUSH
26909: LD_INT 1
26911: GREATER
26912: IFFALSE 27089
// begin m := false ;
26914: LD_ADDR_VAR 0 6
26918: PUSH
26919: LD_INT 0
26921: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26922: LD_ADDR_VAR 0 7
26926: PUSH
26927: LD_VAR 0 1
26931: PUSH
26932: LD_VAR 0 3
26936: ARRAY
26937: PPUSH
26938: CALL_OW 432
26942: ST_TO_ADDR
// for j = 1 to linked do
26943: LD_ADDR_VAR 0 4
26947: PUSH
26948: DOUBLE
26949: LD_INT 1
26951: DEC
26952: ST_TO_ADDR
26953: LD_VAR 0 5
26957: PUSH
26958: FOR_TO
26959: IFFALSE 27033
// begin if l < linked [ j ] [ 2 ] then
26961: LD_VAR 0 7
26965: PUSH
26966: LD_VAR 0 5
26970: PUSH
26971: LD_VAR 0 4
26975: ARRAY
26976: PUSH
26977: LD_INT 2
26979: ARRAY
26980: LESS
26981: IFFALSE 27031
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26983: LD_ADDR_VAR 0 5
26987: PUSH
26988: LD_VAR 0 5
26992: PPUSH
26993: LD_INT 1
26995: PPUSH
26996: LD_VAR 0 1
27000: PUSH
27001: LD_VAR 0 3
27005: ARRAY
27006: PUSH
27007: LD_VAR 0 7
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PPUSH
27016: CALL_OW 2
27020: ST_TO_ADDR
// m := true ;
27021: LD_ADDR_VAR 0 6
27025: PUSH
27026: LD_INT 1
27028: ST_TO_ADDR
// break ;
27029: GO 27033
// end ; end ;
27031: GO 26958
27033: POP
27034: POP
// if not m then
27035: LD_VAR 0 6
27039: NOT
27040: IFFALSE 27087
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27042: LD_ADDR_VAR 0 5
27046: PUSH
27047: LD_VAR 0 5
27051: PUSH
27052: LD_VAR 0 1
27056: PUSH
27057: LD_VAR 0 3
27061: ARRAY
27062: PUSH
27063: LD_VAR 0 1
27067: PUSH
27068: LD_VAR 0 3
27072: ARRAY
27073: PPUSH
27074: CALL_OW 432
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: EMPTY
27084: LIST
27085: ADD
27086: ST_TO_ADDR
// end else
27087: GO 27128
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27089: LD_ADDR_VAR 0 5
27093: PUSH
27094: LD_VAR 0 1
27098: PUSH
27099: LD_VAR 0 3
27103: ARRAY
27104: PUSH
27105: LD_VAR 0 1
27109: PUSH
27110: LD_VAR 0 3
27114: ARRAY
27115: PPUSH
27116: CALL_OW 432
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: EMPTY
27126: LIST
27127: ST_TO_ADDR
// end ;
27128: GO 26884
27130: POP
27131: POP
// result := linked ;
27132: LD_ADDR_VAR 0 2
27136: PUSH
27137: LD_VAR 0 5
27141: ST_TO_ADDR
// end ; end ;
27142: LD_VAR 0 2
27146: RET
// export function MCV_ToRepair ( unit ) ; begin
27147: LD_INT 0
27149: PPUSH
// if not unit then
27150: LD_VAR 0 1
27154: NOT
27155: IFFALSE 27161
// exit else
27157: GO 27192
27159: GO 27192
// begin SetTag ( unit , 6 ) ;
27161: LD_VAR 0 1
27165: PPUSH
27166: LD_INT 6
27168: PPUSH
27169: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27173: LD_VAR 0 1
27177: PPUSH
27178: CALL_OW 255
27182: PPUSH
27183: LD_VAR 0 1
27187: PPUSH
27188: CALL 25748 0 2
// end ; end ;
27192: LD_VAR 0 2
27196: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27197: LD_INT 0
27199: PPUSH
27200: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27201: LD_VAR 0 1
27205: PPUSH
27206: LD_INT 6
27208: PPUSH
27209: EMPTY
27210: PPUSH
27211: CALL 12290 0 3
27215: IFFALSE 27308
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27217: LD_ADDR_VAR 0 3
27221: PUSH
27222: DOUBLE
27223: LD_VAR 0 1
27227: PPUSH
27228: LD_INT 6
27230: PPUSH
27231: EMPTY
27232: PPUSH
27233: CALL 12290 0 3
27237: INC
27238: ST_TO_ADDR
27239: LD_INT 1
27241: PUSH
27242: FOR_DOWNTO
27243: IFFALSE 27306
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27245: LD_VAR 0 1
27249: PPUSH
27250: LD_INT 6
27252: PPUSH
27253: EMPTY
27254: PPUSH
27255: CALL 12290 0 3
27259: PUSH
27260: LD_VAR 0 3
27264: ARRAY
27265: PPUSH
27266: CALL_OW 256
27270: PUSH
27271: LD_INT 1000
27273: EQUAL
27274: IFFALSE 27304
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27276: LD_VAR 0 1
27280: PPUSH
27281: LD_INT 6
27283: PPUSH
27284: EMPTY
27285: PPUSH
27286: CALL 12290 0 3
27290: PUSH
27291: LD_VAR 0 3
27295: ARRAY
27296: PPUSH
27297: LD_INT 0
27299: PPUSH
27300: CALL_OW 109
27304: GO 27242
27306: POP
27307: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27308: LD_VAR 0 1
27312: PPUSH
27313: LD_INT 10
27315: PPUSH
27316: EMPTY
27317: PPUSH
27318: CALL 12290 0 3
27322: IFFALSE 27439
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27324: LD_ADDR_VAR 0 3
27328: PUSH
27329: DOUBLE
27330: LD_VAR 0 1
27334: PPUSH
27335: LD_INT 10
27337: PPUSH
27338: EMPTY
27339: PPUSH
27340: CALL 12290 0 3
27344: INC
27345: ST_TO_ADDR
27346: LD_INT 1
27348: PUSH
27349: FOR_DOWNTO
27350: IFFALSE 27437
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27352: LD_VAR 0 1
27356: PPUSH
27357: LD_INT 10
27359: PPUSH
27360: EMPTY
27361: PPUSH
27362: CALL 12290 0 3
27366: PUSH
27367: LD_VAR 0 3
27371: ARRAY
27372: PPUSH
27373: CALL_OW 302
27377: NOT
27378: PUSH
27379: LD_VAR 0 1
27383: PPUSH
27384: LD_INT 10
27386: PPUSH
27387: EMPTY
27388: PPUSH
27389: CALL 12290 0 3
27393: PUSH
27394: LD_VAR 0 3
27398: ARRAY
27399: PPUSH
27400: CALL_OW 301
27404: OR
27405: IFFALSE 27435
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27407: LD_VAR 0 1
27411: PPUSH
27412: LD_INT 10
27414: PPUSH
27415: EMPTY
27416: PPUSH
27417: CALL 12290 0 3
27421: PUSH
27422: LD_VAR 0 3
27426: ARRAY
27427: PPUSH
27428: LD_INT 0
27430: PPUSH
27431: CALL_OW 109
27435: GO 27349
27437: POP
27438: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27439: LD_ADDR_VAR 0 3
27443: PUSH
27444: LD_VAR 0 1
27448: PPUSH
27449: EMPTY
27450: PPUSH
27451: CALL 11888 0 2
27455: PUSH
27456: LD_VAR 0 1
27460: PPUSH
27461: LD_INT 7
27463: PPUSH
27464: EMPTY
27465: PPUSH
27466: CALL 12290 0 3
27470: DIFF
27471: PUSH
27472: FOR_IN
27473: IFFALSE 27517
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27475: LD_VAR 0 3
27479: PPUSH
27480: CALL_OW 256
27484: PUSH
27485: LD_INT 650
27487: LESS
27488: PUSH
27489: LD_VAR 0 3
27493: PPUSH
27494: CALL_OW 110
27498: PUSH
27499: LD_INT 6
27501: EQUAL
27502: NOT
27503: AND
27504: IFFALSE 27515
// MCV_ToRepair ( i ) ;
27506: LD_VAR 0 3
27510: PPUSH
27511: CALL 27147 0 1
27515: GO 27472
27517: POP
27518: POP
// end ; end_of_file end_of_file
27519: LD_VAR 0 2
27523: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27524: LD_STRING SAILEvent [
27526: PUSH
27527: LD_VAR 0 1
27531: STR
27532: PUSH
27533: LD_STRING ]
27535: STR
27536: PPUSH
27537: CALL 7984 0 1
// if event = 101 and dialog_north then
27541: LD_VAR 0 1
27545: PUSH
27546: LD_INT 101
27548: EQUAL
27549: PUSH
27550: LD_EXP 6
27554: AND
27555: IFFALSE 27619
// begin dialog_north := false ;
27557: LD_ADDR_EXP 6
27561: PUSH
27562: LD_INT 0
27564: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27565: LD_EXP 5
27569: PPUSH
27570: LD_STRING DS1
27572: PUSH
27573: LD_STRING DS2
27575: PUSH
27576: LD_STRING DS3
27578: PUSH
27579: LD_STRING DS6
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: PUSH
27588: LD_INT 1
27590: PPUSH
27591: LD_INT 4
27593: PPUSH
27594: CALL_OW 12
27598: ARRAY
27599: PPUSH
27600: CALL_OW 94
// Wait ( 4 4$00 ) ;
27604: LD_INT 8400
27606: PPUSH
27607: CALL_OW 67
// dialog_north := true ;
27611: LD_ADDR_EXP 6
27615: PUSH
27616: LD_INT 1
27618: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27619: LD_VAR 0 1
27623: PUSH
27624: LD_INT 102
27626: EQUAL
27627: PUSH
27628: LD_EXP 7
27632: AND
27633: IFFALSE 27693
// begin dialog_south := false ;
27635: LD_ADDR_EXP 7
27639: PUSH
27640: LD_INT 0
27642: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27643: LD_EXP 4
27647: PPUSH
27648: LD_STRING DJ1
27650: PUSH
27651: LD_STRING DJ4
27653: PUSH
27654: LD_STRING DJ6
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 1
27664: PPUSH
27665: LD_INT 3
27667: PPUSH
27668: CALL_OW 12
27672: ARRAY
27673: PPUSH
27674: CALL_OW 94
// Wait ( 4 4$00 ) ;
27678: LD_INT 8400
27680: PPUSH
27681: CALL_OW 67
// dialog_south := true ;
27685: LD_ADDR_EXP 7
27689: PUSH
27690: LD_INT 1
27692: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27693: LD_VAR 0 1
27697: PUSH
27698: LD_INT 104
27700: EQUAL
27701: PUSH
27702: LD_EXP 8
27706: AND
27707: IFFALSE 27729
// begin dialog_popov := false ;
27709: LD_ADDR_EXP 8
27713: PUSH
27714: LD_INT 0
27716: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27717: LD_EXP 26
27721: PPUSH
27722: LD_STRING DR4
27724: PPUSH
27725: CALL_OW 94
// end ; end ;
27729: PPOPN 1
27731: END
// on BuildingStarted ( b , unit ) do var side , i ;
27732: LD_INT 0
27734: PPUSH
27735: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27736: LD_EXP 41
27740: PUSH
27741: LD_VAR 0 1
27745: PPUSH
27746: CALL_OW 255
27750: ARRAY
27751: IFFALSE 27929
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27753: LD_STRING BuildingStarted [side: 
27755: PUSH
27756: LD_VAR 0 1
27760: PPUSH
27761: CALL_OW 255
27765: STR
27766: PUSH
27767: LD_STRING ; btype: 
27769: STR
27770: PUSH
27771: LD_VAR 0 1
27775: PPUSH
27776: CALL_OW 266
27780: STR
27781: PUSH
27782: LD_STRING ; unit: 
27784: STR
27785: PUSH
27786: LD_VAR 0 2
27790: STR
27791: PUSH
27792: LD_STRING ]
27794: STR
27795: PPUSH
27796: CALL 7984 0 1
// side := GetSide ( b ) ;
27800: LD_ADDR_VAR 0 3
27804: PUSH
27805: LD_VAR 0 1
27809: PPUSH
27810: CALL_OW 255
27814: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27815: LD_VAR 0 3
27819: PPUSH
27820: LD_INT 21
27822: PUSH
27823: LD_INT 3
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PPUSH
27830: CALL 11587 0 2
27834: PUSH
27835: LD_INT 1
27837: EQUAL
27838: IFFALSE 27929
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27840: LD_ADDR_VAR 0 4
27844: PUSH
27845: LD_VAR 0 3
27849: PPUSH
27850: LD_INT 21
27852: PUSH
27853: LD_INT 1
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PPUSH
27860: CALL 11587 0 2
27864: PUSH
27865: LD_VAR 0 3
27869: PPUSH
27870: LD_INT 2
27872: PPUSH
27873: EMPTY
27874: PPUSH
27875: CALL 11670 0 3
27879: DIFF
27880: PUSH
27881: FOR_IN
27882: IFFALSE 27927
// if not HasTask ( i ) then
27884: LD_VAR 0 4
27888: PPUSH
27889: CALL_OW 314
27893: NOT
27894: IFFALSE 27925
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27896: LD_VAR 0 4
27900: PPUSH
27901: LD_VAR 0 1
27905: PPUSH
27906: CALL_OW 250
27910: PPUSH
27911: LD_VAR 0 1
27915: PPUSH
27916: CALL_OW 251
27920: PPUSH
27921: CALL_OW 111
27925: GO 27881
27927: POP
27928: POP
// end ;
27929: PPOPN 4
27931: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27932: LD_EXP 41
27936: PUSH
27937: LD_VAR 0 1
27941: PPUSH
27942: CALL_OW 255
27946: ARRAY
27947: IFFALSE 28316
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27949: LD_STRING BuildingComplete [side: 
27951: PUSH
27952: LD_VAR 0 1
27956: PPUSH
27957: CALL_OW 255
27961: STR
27962: PUSH
27963: LD_STRING ; btype: 
27965: STR
27966: PUSH
27967: LD_VAR 0 1
27971: PPUSH
27972: CALL_OW 266
27976: STR
27977: PUSH
27978: LD_STRING ]
27980: STR
27981: PPUSH
27982: CALL 7984 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27986: LD_ADDR_EXP 48
27990: PUSH
27991: LD_EXP 48
27995: PPUSH
27996: LD_VAR 0 1
28000: PPUSH
28001: CALL_OW 255
28005: PPUSH
28006: LD_VAR 0 1
28010: PPUSH
28011: CALL_OW 266
28015: PPUSH
28016: LD_VAR 0 1
28020: PPUSH
28021: CALL_OW 250
28025: PUSH
28026: LD_VAR 0 1
28030: PPUSH
28031: CALL_OW 251
28035: PUSH
28036: LD_VAR 0 1
28040: PPUSH
28041: CALL_OW 254
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: LIST
28050: PPUSH
28051: CALL 42498 0 4
28055: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28056: LD_VAR 0 1
28060: PPUSH
28061: CALL_OW 266
28065: PUSH
28066: LD_INT 6
28068: EQUAL
28069: IFFALSE 28103
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28071: LD_ADDR_EXP 42
28075: PUSH
28076: LD_EXP 42
28080: PPUSH
28081: LD_VAR 0 1
28085: PPUSH
28086: CALL_OW 255
28090: PPUSH
28091: LD_VAR 0 1
28095: PPUSH
28096: EMPTY
28097: PPUSH
28098: CALL 42407 0 4
28102: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28103: LD_VAR 0 1
28107: PPUSH
28108: CALL_OW 266
28112: PUSH
28113: LD_INT 0
28115: EQUAL
28116: IFFALSE 28226
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28118: LD_ADDR_EXP 50
28122: PUSH
28123: LD_EXP 50
28127: PPUSH
28128: LD_VAR 0 1
28132: PPUSH
28133: CALL_OW 255
28137: PPUSH
28138: LD_INT 0
28140: PPUSH
28141: EMPTY
28142: PPUSH
28143: CALL 42407 0 4
28147: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28148: LD_VAR 0 1
28152: PPUSH
28153: CALL_OW 274
28157: PPUSH
28158: LD_INT 1
28160: PPUSH
28161: LD_EXP 74
28165: PUSH
28166: LD_INT 1
28168: ARRAY
28169: PPUSH
28170: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28174: LD_VAR 0 1
28178: PPUSH
28179: CALL_OW 274
28183: PPUSH
28184: LD_INT 2
28186: PPUSH
28187: LD_EXP 74
28191: PUSH
28192: LD_INT 2
28194: ARRAY
28195: PPUSH
28196: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28200: LD_VAR 0 1
28204: PPUSH
28205: CALL_OW 274
28209: PPUSH
28210: LD_INT 3
28212: PPUSH
28213: LD_EXP 74
28217: PUSH
28218: LD_INT 3
28220: ARRAY
28221: PPUSH
28222: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28226: LD_VAR 0 1
28230: PPUSH
28231: CALL_OW 266
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28271
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28241: LD_ADDR_EXP 50
28245: PUSH
28246: LD_EXP 50
28250: PPUSH
28251: LD_VAR 0 1
28255: PPUSH
28256: CALL_OW 255
28260: PPUSH
28261: LD_INT 2
28263: PPUSH
28264: EMPTY
28265: PPUSH
28266: CALL 42407 0 4
28270: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28271: LD_VAR 0 1
28275: PPUSH
28276: CALL_OW 266
28280: PUSH
28281: LD_INT 4
28283: EQUAL
28284: IFFALSE 28316
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28286: LD_ADDR_EXP 50
28290: PUSH
28291: LD_EXP 50
28295: PPUSH
28296: LD_VAR 0 1
28300: PPUSH
28301: CALL_OW 255
28305: PPUSH
28306: LD_INT 4
28308: PPUSH
28309: EMPTY
28310: PPUSH
28311: CALL 42407 0 4
28315: ST_TO_ADDR
// end ;
28316: PPOPN 1
28318: END
// on ResearchComplete ( tech , lab ) do var i ;
28319: LD_INT 0
28321: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28322: LD_EXP 41
28326: PUSH
28327: LD_VAR 0 2
28331: PPUSH
28332: CALL_OW 255
28336: ARRAY
28337: IFFALSE 28621
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28339: LD_STRING ResearchComplete [side: 
28341: PUSH
28342: LD_VAR 0 2
28346: PPUSH
28347: CALL_OW 255
28351: PPUSH
28352: CALL_OW 255
28356: STR
28357: PUSH
28358: LD_STRING ; tech:
28360: STR
28361: PUSH
28362: LD_VAR 0 1
28366: STR
28367: PUSH
28368: LD_STRING ]
28370: STR
28371: PPUSH
28372: CALL 7984 0 1
// for i = 1 to MREG_ToRes do
28376: LD_ADDR_VAR 0 3
28380: PUSH
28381: DOUBLE
28382: LD_INT 1
28384: DEC
28385: ST_TO_ADDR
28386: LD_EXP 52
28390: PUSH
28391: FOR_TO
28392: IFFALSE 28479
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28394: LD_EXP 52
28398: PUSH
28399: LD_VAR 0 3
28403: ARRAY
28404: PUSH
28405: LD_INT 1
28407: ARRAY
28408: PUSH
28409: LD_VAR 0 2
28413: PPUSH
28414: CALL_OW 255
28418: EQUAL
28419: PUSH
28420: LD_EXP 52
28424: PUSH
28425: LD_VAR 0 3
28429: ARRAY
28430: PUSH
28431: LD_INT 2
28433: ARRAY
28434: PUSH
28435: LD_VAR 0 1
28439: EQUAL
28440: AND
28441: IFFALSE 28477
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28443: LD_ADDR_EXP 52
28447: PUSH
28448: LD_EXP 52
28452: PPUSH
28453: LD_VAR 0 2
28457: PPUSH
28458: CALL_OW 255
28462: PPUSH
28463: LD_VAR 0 1
28467: PPUSH
28468: EMPTY
28469: PPUSH
28470: CALL 42498 0 4
28474: ST_TO_ADDR
// break ;
28475: GO 28479
// end ;
28477: GO 28391
28479: POP
28480: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28481: LD_VAR 0 1
28485: PUSH
28486: LD_INT 2
28488: PUSH
28489: LD_INT 11
28491: PUSH
28492: LD_INT 4
28494: PUSH
28495: LD_INT 3
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: LIST
28502: LIST
28503: IN
28504: IFFALSE 28621
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28506: LD_ADDR_VAR 0 3
28510: PUSH
28511: LD_VAR 0 2
28515: PPUSH
28516: CALL_OW 255
28520: PPUSH
28521: LD_INT 16
28523: PPUSH
28524: LD_INT 25
28526: PUSH
28527: LD_INT 4
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PPUSH
28534: CALL 12290 0 3
28538: ST_TO_ADDR
// if i then
28539: LD_VAR 0 3
28543: IFFALSE 28561
// SetTag ( i [ 1 ] , 0 ) ;
28545: LD_VAR 0 3
28549: PUSH
28550: LD_INT 1
28552: ARRAY
28553: PPUSH
28554: LD_INT 0
28556: PPUSH
28557: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28561: LD_ADDR_VAR 0 3
28565: PUSH
28566: LD_VAR 0 2
28570: PPUSH
28571: CALL_OW 255
28575: PPUSH
28576: LD_INT 171
28578: PPUSH
28579: EMPTY
28580: PPUSH
28581: CALL 12290 0 3
28585: ST_TO_ADDR
// if i then
28586: LD_VAR 0 3
28590: IFFALSE 28621
// begin SetTag ( i [ 1 ] , 0 ) ;
28592: LD_VAR 0 3
28596: PUSH
28597: LD_INT 1
28599: ARRAY
28600: PPUSH
28601: LD_INT 0
28603: PPUSH
28604: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28608: LD_VAR 0 3
28612: PUSH
28613: LD_INT 1
28615: ARRAY
28616: PPUSH
28617: CALL_OW 122
// end ; end ; end ;
28621: PPOPN 3
28623: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28624: LD_INT 0
28626: PPUSH
28627: PPUSH
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28633: LD_EXP 41
28637: PUSH
28638: LD_VAR 0 2
28642: PPUSH
28643: CALL_OW 255
28647: ARRAY
28648: IFFALSE 29375
// begin side := GetSide ( veh ) ;
28650: LD_ADDR_VAR 0 4
28654: PUSH
28655: LD_VAR 0 1
28659: PPUSH
28660: CALL_OW 255
28664: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28665: LD_ADDR_VAR 0 6
28669: PUSH
28670: LD_VAR 0 1
28674: PPUSH
28675: CALL_OW 265
28679: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28680: LD_ADDR_VAR 0 7
28684: PUSH
28685: LD_VAR 0 1
28689: PPUSH
28690: CALL_OW 262
28694: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28695: LD_ADDR_VAR 0 8
28699: PUSH
28700: LD_VAR 0 1
28704: PPUSH
28705: CALL_OW 263
28709: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28710: LD_ADDR_VAR 0 9
28714: PUSH
28715: LD_VAR 0 1
28719: PPUSH
28720: CALL_OW 264
28724: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28725: LD_STRING VehicleConstructed [side: 
28727: PUSH
28728: LD_VAR 0 4
28732: STR
28733: PUSH
28734: LD_STRING ; id:
28736: STR
28737: PUSH
28738: LD_VAR 0 1
28742: STR
28743: PUSH
28744: LD_STRING ; components: [
28746: STR
28747: PUSH
28748: LD_VAR 0 6
28752: STR
28753: PUSH
28754: LD_STRING , 
28756: STR
28757: PUSH
28758: LD_VAR 0 7
28762: STR
28763: PUSH
28764: LD_STRING , 
28766: STR
28767: PUSH
28768: LD_VAR 0 8
28772: STR
28773: PUSH
28774: LD_STRING , 
28776: STR
28777: PUSH
28778: LD_VAR 0 9
28782: STR
28783: PUSH
28784: LD_STRING ]]
28786: STR
28787: PPUSH
28788: CALL 7984 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28792: LD_VAR 0 1
28796: PPUSH
28797: CALL_OW 264
28801: PUSH
28802: LD_INT 13
28804: PUSH
28805: LD_INT 12
28807: PUSH
28808: LD_INT 14
28810: PUSH
28811: LD_INT 51
28813: PUSH
28814: LD_INT 53
28816: PUSH
28817: LD_INT 52
28819: PUSH
28820: LD_INT 32
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: LIST
28830: LIST
28831: IN
28832: NOT
28833: IFFALSE 28875
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28835: LD_ADDR_EXP 61
28839: PUSH
28840: LD_EXP 61
28844: PPUSH
28845: LD_VAR 0 4
28849: PPUSH
28850: LD_EXP 61
28854: PUSH
28855: LD_VAR 0 4
28859: ARRAY
28860: PUSH
28861: LD_INT 1
28863: PLUS
28864: PPUSH
28865: LD_VAR 0 1
28869: PPUSH
28870: CALL 31125 0 4
28874: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28875: LD_VAR 0 1
28879: PPUSH
28880: CALL_OW 264
28884: PUSH
28885: LD_INT 31
28887: EQUAL
28888: IFFALSE 28907
// SetTag ( GetDriver ( veh ) , 9 ) ;
28890: LD_VAR 0 1
28894: PPUSH
28895: CALL 31819 0 1
28899: PPUSH
28900: LD_INT 9
28902: PPUSH
28903: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28907: LD_VAR 0 1
28911: PPUSH
28912: CALL_OW 264
28916: PUSH
28917: LD_INT 14
28919: PUSH
28920: LD_INT 53
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: IN
28927: IFFALSE 28964
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28929: LD_ADDR_EXP 44
28933: PUSH
28934: LD_EXP 44
28938: PPUSH
28939: LD_VAR 0 1
28943: PPUSH
28944: CALL_OW 255
28948: PPUSH
28949: LD_INT 2
28951: PPUSH
28952: LD_VAR 0 1
28956: PPUSH
28957: CALL 31125 0 4
28961: ST_TO_ADDR
// exit ;
28962: GO 29375
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28964: LD_VAR 0 1
28968: PPUSH
28969: CALL_OW 265
28973: PUSH
28974: LD_EXP 68
28978: PUSH
28979: LD_VAR 0 4
28983: ARRAY
28984: PUSH
28985: LD_INT 1
28987: ARRAY
28988: IN
28989: PUSH
28990: LD_VAR 0 1
28994: PPUSH
28995: CALL_OW 262
28999: PUSH
29000: LD_EXP 68
29004: PUSH
29005: LD_VAR 0 4
29009: ARRAY
29010: PUSH
29011: LD_INT 1
29013: ARRAY
29014: IN
29015: AND
29016: PUSH
29017: LD_VAR 0 1
29021: PPUSH
29022: CALL_OW 263
29026: PUSH
29027: LD_EXP 68
29031: PUSH
29032: LD_VAR 0 4
29036: ARRAY
29037: PUSH
29038: LD_INT 1
29040: ARRAY
29041: IN
29042: AND
29043: PUSH
29044: LD_VAR 0 1
29048: PPUSH
29049: CALL_OW 264
29053: PUSH
29054: LD_EXP 68
29058: PUSH
29059: LD_VAR 0 4
29063: ARRAY
29064: PUSH
29065: LD_INT 1
29067: ARRAY
29068: IN
29069: AND
29070: IFFALSE 29114
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29072: LD_ADDR_EXP 69
29076: PUSH
29077: LD_EXP 69
29081: PPUSH
29082: LD_VAR 0 4
29086: PPUSH
29087: LD_EXP 69
29091: PUSH
29092: LD_VAR 0 4
29096: ARRAY
29097: PUSH
29098: LD_INT 1
29100: PLUS
29101: PPUSH
29102: LD_VAR 0 1
29106: PPUSH
29107: CALL 31125 0 4
29111: ST_TO_ADDR
// exit ;
29112: GO 29375
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29114: LD_VAR 0 6
29118: PUSH
29119: LD_EXP 71
29123: PUSH
29124: LD_VAR 0 4
29128: ARRAY
29129: PUSH
29130: LD_INT 1
29132: ARRAY
29133: EQUAL
29134: PUSH
29135: LD_VAR 0 7
29139: PUSH
29140: LD_EXP 71
29144: PUSH
29145: LD_VAR 0 4
29149: ARRAY
29150: PUSH
29151: LD_INT 2
29153: ARRAY
29154: EQUAL
29155: AND
29156: PUSH
29157: LD_VAR 0 8
29161: PUSH
29162: LD_EXP 71
29166: PUSH
29167: LD_VAR 0 4
29171: ARRAY
29172: PUSH
29173: LD_INT 3
29175: ARRAY
29176: EQUAL
29177: AND
29178: PUSH
29179: LD_VAR 0 9
29183: PUSH
29184: LD_EXP 71
29188: PUSH
29189: LD_VAR 0 4
29193: ARRAY
29194: PUSH
29195: LD_INT 4
29197: ARRAY
29198: EQUAL
29199: AND
29200: IFFALSE 29356
// begin tmp := MREG_ToAttack [ side ] ;
29202: LD_ADDR_VAR 0 5
29206: PUSH
29207: LD_EXP 71
29211: PUSH
29212: LD_VAR 0 4
29216: ARRAY
29217: ST_TO_ADDR
// for i = 1 to 4 do
29218: LD_ADDR_VAR 0 3
29222: PUSH
29223: DOUBLE
29224: LD_INT 1
29226: DEC
29227: ST_TO_ADDR
29228: LD_INT 4
29230: PUSH
29231: FOR_TO
29232: IFFALSE 29254
// tmp := Delete ( tmp , 1 ) ;
29234: LD_ADDR_VAR 0 5
29238: PUSH
29239: LD_VAR 0 5
29243: PPUSH
29244: LD_INT 1
29246: PPUSH
29247: CALL_OW 3
29251: ST_TO_ADDR
29252: GO 29231
29254: POP
29255: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29256: LD_ADDR_EXP 71
29260: PUSH
29261: LD_EXP 71
29265: PPUSH
29266: LD_VAR 0 4
29270: PPUSH
29271: LD_VAR 0 5
29275: PPUSH
29276: CALL_OW 1
29280: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29281: LD_ADDR_EXP 73
29285: PUSH
29286: LD_EXP 73
29290: PPUSH
29291: LD_VAR 0 4
29295: PPUSH
29296: LD_EXP 73
29300: PUSH
29301: LD_VAR 0 4
29305: ARRAY
29306: PUSH
29307: LD_INT 1
29309: PLUS
29310: PPUSH
29311: LD_VAR 0 1
29315: PPUSH
29316: CALL 31125 0 4
29320: ST_TO_ADDR
// if tmp = 0 then
29321: LD_VAR 0 5
29325: PUSH
29326: LD_INT 0
29328: EQUAL
29329: IFFALSE 29354
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29331: LD_ADDR_EXP 71
29335: PUSH
29336: LD_EXP 71
29340: PPUSH
29341: LD_VAR 0 4
29345: PPUSH
29346: LD_INT 0
29348: PPUSH
29349: CALL_OW 1
29353: ST_TO_ADDR
// exit ;
29354: GO 29375
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29356: LD_VAR 0 1
29360: PPUSH
29361: CALL_OW 255
29365: PPUSH
29366: LD_VAR 0 1
29370: PPUSH
29371: CALL 25748 0 2
// end ;
29375: PPOPN 9
29377: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29378: LD_EXP 41
29382: PUSH
29383: LD_VAR 0 2
29387: PPUSH
29388: CALL_OW 255
29392: ARRAY
29393: IFFALSE 29625
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29395: LD_STRING ApemanTamed [side: 
29397: PUSH
29398: LD_VAR 0 2
29402: PPUSH
29403: CALL_OW 255
29407: STR
29408: PUSH
29409: LD_STRING ; sci: 
29411: STR
29412: PUSH
29413: LD_VAR 0 2
29417: STR
29418: PUSH
29419: LD_STRING ; ape: 
29421: STR
29422: PUSH
29423: LD_VAR 0 1
29427: STR
29428: PUSH
29429: LD_STRING ]
29431: STR
29432: PPUSH
29433: CALL 7984 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29437: LD_INT 11
29439: PPUSH
29440: LD_VAR 0 2
29444: PPUSH
29445: CALL_OW 255
29449: PPUSH
29450: CALL_OW 321
29454: PUSH
29455: LD_INT 2
29457: EQUAL
29458: NOT
29459: PUSH
29460: LD_INT 2
29462: PPUSH
29463: LD_VAR 0 2
29467: PPUSH
29468: CALL_OW 255
29472: PPUSH
29473: CALL_OW 321
29477: PUSH
29478: LD_INT 2
29480: EQUAL
29481: NOT
29482: OR
29483: PUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: LD_INT 171
29496: PPUSH
29497: EMPTY
29498: PPUSH
29499: CALL 12290 0 3
29503: PUSH
29504: LD_INT 0
29506: EQUAL
29507: AND
29508: IFFALSE 29522
// begin SetTag ( ape , 171 ) ;
29510: LD_VAR 0 1
29514: PPUSH
29515: LD_INT 171
29517: PPUSH
29518: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29522: LD_VAR 0 2
29526: PPUSH
29527: CALL_OW 255
29531: PPUSH
29532: LD_INT 30
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PPUSH
29542: CALL 11587 0 2
29546: IFFALSE 29625
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29548: LD_VAR 0 1
29552: PPUSH
29553: LD_VAR 0 2
29557: PPUSH
29558: CALL_OW 255
29562: PPUSH
29563: LD_INT 30
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PPUSH
29573: CALL 11587 0 2
29577: PUSH
29578: LD_INT 1
29580: ARRAY
29581: PPUSH
29582: CALL_OW 250
29586: PPUSH
29587: LD_VAR 0 2
29591: PPUSH
29592: CALL_OW 255
29596: PPUSH
29597: LD_INT 30
29599: PUSH
29600: LD_INT 1
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PPUSH
29607: CALL 11587 0 2
29611: PUSH
29612: LD_INT 1
29614: ARRAY
29615: PPUSH
29616: CALL_OW 251
29620: PPUSH
29621: CALL_OW 111
// end ;
29625: PPOPN 2
29627: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29628: LD_EXP 41
29632: PUSH
29633: LD_VAR 0 1
29637: PPUSH
29638: CALL_OW 255
29642: ARRAY
29643: IFFALSE 29921
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29645: LD_VAR 0 2
29649: PUSH
29650: LD_VAR 0 2
29654: PPUSH
29655: CALL_OW 255
29659: PPUSH
29660: CALL 12000 0 1
29664: IN
29665: IFFALSE 29806
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29667: LD_VAR 0 1
29671: PPUSH
29672: CALL_OW 266
29676: PUSH
29677: LD_INT 0
29679: PUSH
29680: LD_INT 1
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: IN
29687: IFFALSE 29717
// begin Wait ( 0 0$0.3 ) ;
29689: LD_INT 10
29691: PPUSH
29692: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29696: LD_VAR 0 2
29700: PPUSH
29701: LD_INT 16
29703: PPUSH
29704: CALL_OW 336
// ComExitBuilding ( un ) ;
29708: LD_VAR 0 2
29712: PPUSH
29713: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29717: LD_VAR 0 1
29721: PPUSH
29722: CALL_OW 266
29726: PUSH
29727: LD_INT 4
29729: PUSH
29730: LD_INT 5
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: IN
29737: IFFALSE 29806
// begin Wait ( 0 0$0.3 ) ;
29739: LD_INT 10
29741: PPUSH
29742: CALL_OW 67
// if GetTag ( un ) = 0 then
29746: LD_VAR 0 2
29750: PPUSH
29751: CALL_OW 110
29755: PUSH
29756: LD_INT 0
29758: EQUAL
29759: IFFALSE 29775
// SetClass ( un , class_apeman_soldier ) else
29761: LD_VAR 0 2
29765: PPUSH
29766: LD_INT 15
29768: PPUSH
29769: CALL_OW 336
29773: GO 29806
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29775: LD_INT 3
29777: PPUSH
29778: LD_VAR 0 2
29782: PPUSH
29783: CALL_OW 255
29787: PPUSH
29788: CALL_OW 321
29792: IFFALSE 29806
// SetClass ( un , class_apeman_kamikaze ) ;
29794: LD_VAR 0 2
29798: PPUSH
29799: LD_INT 17
29801: PPUSH
29802: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29806: LD_VAR 0 1
29810: PPUSH
29811: CALL_OW 266
29815: PUSH
29816: LD_INT 32
29818: EQUAL
29819: IFFALSE 29921
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29821: LD_ADDR_EXP 70
29825: PUSH
29826: LD_EXP 70
29830: PPUSH
29831: LD_VAR 0 1
29835: PPUSH
29836: CALL_OW 255
29840: PPUSH
29841: LD_EXP 70
29845: PUSH
29846: LD_VAR 0 1
29850: PPUSH
29851: CALL_OW 255
29855: ARRAY
29856: PUSH
29857: LD_INT 1
29859: PLUS
29860: PPUSH
29861: LD_VAR 0 1
29865: PPUSH
29866: CALL 31125 0 4
29870: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29871: LD_ADDR_EXP 70
29875: PUSH
29876: LD_EXP 70
29880: PPUSH
29881: LD_VAR 0 1
29885: PPUSH
29886: CALL_OW 255
29890: PPUSH
29891: LD_EXP 70
29895: PUSH
29896: LD_VAR 0 1
29900: PPUSH
29901: CALL_OW 255
29905: ARRAY
29906: PUSH
29907: LD_INT 1
29909: PLUS
29910: PPUSH
29911: LD_VAR 0 2
29915: PPUSH
29916: CALL 31125 0 4
29920: ST_TO_ADDR
// end ; end ;
29921: PPOPN 2
29923: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29924: LD_VAR 0 1
29928: PPUSH
29929: CALL 54878 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29933: LD_VAR 0 1
29937: PUSH
29938: LD_INT 22
29940: PUSH
29941: LD_INT 3
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 23
29950: PUSH
29951: LD_INT 3
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 21
29960: PUSH
29961: LD_INT 1
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: LIST
29972: PPUSH
29973: CALL_OW 69
29977: IN
29978: IFFALSE 29994
// player_loss := player_loss + 1 ;
29980: LD_ADDR_EXP 10
29984: PUSH
29985: LD_EXP 10
29989: PUSH
29990: LD_INT 1
29992: PLUS
29993: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29994: LD_VAR 0 1
29998: PUSH
29999: LD_INT 22
30001: PUSH
30002: LD_INT 1
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 21
30011: PUSH
30012: LD_INT 3
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PPUSH
30023: CALL_OW 69
30027: IN
30028: PUSH
30029: LD_EXP 15
30033: NOT
30034: AND
30035: IFFALSE 30098
// begin alfa_north_triggered := true ;
30037: LD_ADDR_EXP 15
30041: PUSH
30042: LD_INT 1
30044: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30045: LD_EXP 5
30049: PPUSH
30050: LD_STRING DS4
30052: PPUSH
30053: CALL_OW 94
// Wait ( 1 1$25 ) ;
30057: LD_INT 2975
30059: PPUSH
30060: CALL_OW 67
// if not isTest then
30064: LD_EXP 1
30068: NOT
30069: IFFALSE 30098
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30071: LD_INT 20
30073: PPUSH
30074: LD_INT 5
30076: PUSH
30077: LD_INT 6
30079: PUSH
30080: LD_INT 7
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: LIST
30087: PUSH
30088: LD_OWVAR 67
30092: ARRAY
30093: PPUSH
30094: CALL 7122 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30098: LD_VAR 0 1
30102: PUSH
30103: LD_INT 22
30105: PUSH
30106: LD_INT 4
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 21
30115: PUSH
30116: LD_INT 3
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PPUSH
30127: CALL_OW 69
30131: IN
30132: PUSH
30133: LD_EXP 16
30137: NOT
30138: AND
30139: IFFALSE 30202
// begin alfa_south_triggered := true ;
30141: LD_ADDR_EXP 16
30145: PUSH
30146: LD_INT 1
30148: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30149: LD_EXP 4
30153: PPUSH
30154: LD_STRING DJ3
30156: PPUSH
30157: CALL_OW 94
// Wait ( 0 0$45 ) ;
30161: LD_INT 1575
30163: PPUSH
30164: CALL_OW 67
// if not isTest then
30168: LD_EXP 1
30172: NOT
30173: IFFALSE 30202
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30175: LD_INT 20
30177: PPUSH
30178: LD_INT 5
30180: PUSH
30181: LD_INT 6
30183: PUSH
30184: LD_INT 7
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: PUSH
30192: LD_OWVAR 67
30196: ARRAY
30197: PPUSH
30198: CALL 7122 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30202: LD_VAR 0 1
30206: PPUSH
30207: CALL_OW 266
30211: PUSH
30212: LD_INT 1
30214: EQUAL
30215: PUSH
30216: LD_VAR 0 1
30220: PPUSH
30221: CALL_OW 255
30225: PUSH
30226: LD_INT 1
30228: PUSH
30229: LD_INT 4
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: IN
30236: AND
30237: IFFALSE 30246
// RaiseSailEvent ( 104 ) ;
30239: LD_INT 104
30241: PPUSH
30242: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30246: LD_EXP 41
30250: PUSH
30251: LD_VAR 0 1
30255: PPUSH
30256: CALL_OW 255
30260: ARRAY
30261: IFFALSE 30648
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30263: LD_STRING UnitDestroyed [side 
30265: PUSH
30266: LD_VAR 0 1
30270: PPUSH
30271: CALL_OW 255
30275: STR
30276: PUSH
30277: LD_STRING ; id: 
30279: STR
30280: PUSH
30281: LD_VAR 0 1
30285: STR
30286: PUSH
30287: LD_STRING ; type: 
30289: STR
30290: PUSH
30291: LD_VAR 0 1
30295: PPUSH
30296: CALL_OW 247
30300: STR
30301: PUSH
30302: LD_STRING ]
30304: STR
30305: PPUSH
30306: CALL 7984 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30310: LD_VAR 0 1
30314: PUSH
30315: LD_VAR 0 1
30319: PPUSH
30320: CALL_OW 255
30324: PPUSH
30325: LD_INT 21
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PPUSH
30335: CALL 11587 0 2
30339: IN
30340: IFFALSE 30496
// begin if MCF_HasClass ( un ) then
30342: LD_VAR 0 1
30346: PPUSH
30347: CALL 14293 0 1
30351: IFFALSE 30496
// case MCF_HasClass ( un ) of 1 :
30353: LD_VAR 0 1
30357: PPUSH
30358: CALL 14293 0 1
30362: PUSH
30363: LD_INT 1
30365: DOUBLE
30366: EQUAL
30367: IFTRUE 30371
30369: GO 30396
30371: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30372: LD_VAR 0 1
30376: PPUSH
30377: CALL_OW 255
30381: PPUSH
30382: LD_STRING ToArm
30384: PPUSH
30385: LD_VAR 0 1
30389: PPUSH
30390: CALL 14466 0 3
30394: GO 30496
30396: LD_INT 2
30398: DOUBLE
30399: EQUAL
30400: IFTRUE 30404
30402: GO 30429
30404: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30405: LD_VAR 0 1
30409: PPUSH
30410: CALL_OW 255
30414: PPUSH
30415: LD_STRING ToDep
30417: PPUSH
30418: LD_VAR 0 1
30422: PPUSH
30423: CALL 14466 0 3
30427: GO 30496
30429: LD_INT 3
30431: DOUBLE
30432: EQUAL
30433: IFTRUE 30437
30435: GO 30462
30437: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30438: LD_VAR 0 1
30442: PPUSH
30443: CALL_OW 255
30447: PPUSH
30448: LD_STRING ToFac
30450: PPUSH
30451: LD_VAR 0 1
30455: PPUSH
30456: CALL 14466 0 3
30460: GO 30496
30462: LD_INT 4
30464: DOUBLE
30465: EQUAL
30466: IFTRUE 30470
30468: GO 30495
30470: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30471: LD_VAR 0 1
30475: PPUSH
30476: CALL_OW 255
30480: PPUSH
30481: LD_STRING ToLab
30483: PPUSH
30484: LD_VAR 0 1
30488: PPUSH
30489: CALL 14466 0 3
30493: GO 30496
30495: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30496: LD_VAR 0 1
30500: PUSH
30501: LD_EXP 69
30505: PUSH
30506: LD_VAR 0 1
30510: PPUSH
30511: CALL_OW 255
30515: ARRAY
30516: IN
30517: IFFALSE 30602
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30519: LD_ADDR_EXP 69
30523: PUSH
30524: LD_EXP 69
30528: PPUSH
30529: LD_VAR 0 1
30533: PPUSH
30534: LD_INT 0
30536: PPUSH
30537: CALL 31284 0 3
30541: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30542: LD_VAR 0 1
30546: PPUSH
30547: CALL_OW 255
30551: PPUSH
30552: LD_VAR 0 1
30556: PPUSH
30557: CALL_OW 265
30561: PUSH
30562: LD_VAR 0 1
30566: PPUSH
30567: CALL_OW 262
30571: PUSH
30572: LD_VAR 0 1
30576: PPUSH
30577: CALL_OW 263
30581: PUSH
30582: LD_VAR 0 1
30586: PPUSH
30587: CALL_OW 264
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: PPUSH
30598: CALL 21106 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30602: LD_VAR 0 1
30606: PUSH
30607: LD_EXP 73
30611: PUSH
30612: LD_VAR 0 1
30616: PPUSH
30617: CALL_OW 255
30621: ARRAY
30622: IN
30623: IFFALSE 30648
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30625: LD_ADDR_EXP 73
30629: PUSH
30630: LD_EXP 73
30634: PPUSH
30635: LD_VAR 0 1
30639: PPUSH
30640: LD_INT 0
30642: PPUSH
30643: CALL 31284 0 3
30647: ST_TO_ADDR
// end ; end ;
30648: PPOPN 1
30650: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30651: LD_EXP 41
30655: PUSH
30656: LD_VAR 0 2
30660: PPUSH
30661: CALL_OW 255
30665: ARRAY
30666: IFFALSE 30838
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30668: LD_VAR 0 2
30672: PUSH
30673: LD_EXP 70
30677: PUSH
30678: LD_VAR 0 2
30682: PPUSH
30683: CALL_OW 255
30687: ARRAY
30688: IN
30689: PUSH
30690: LD_VAR 0 1
30694: PPUSH
30695: CALL_OW 266
30699: PUSH
30700: LD_INT 32
30702: PUSH
30703: LD_INT 31
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: IN
30710: AND
30711: IFFALSE 30811
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30713: LD_ADDR_EXP 70
30717: PUSH
30718: LD_EXP 70
30722: PPUSH
30723: LD_VAR 0 1
30727: PPUSH
30728: LD_INT 0
30730: PPUSH
30731: CALL 31284 0 3
30735: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30736: LD_ADDR_EXP 70
30740: PUSH
30741: LD_EXP 70
30745: PPUSH
30746: LD_VAR 0 2
30750: PPUSH
30751: LD_INT 0
30753: PPUSH
30754: CALL 31284 0 3
30758: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30759: LD_EXP 70
30763: PUSH
30764: LD_VAR 0 2
30768: PPUSH
30769: CALL_OW 255
30773: ARRAY
30774: PUSH
30775: LD_STRING 
30777: EQUAL
30778: IFFALSE 30811
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30780: LD_ADDR_EXP 70
30784: PUSH
30785: LD_EXP 70
30789: PPUSH
30790: LD_VAR 0 2
30794: PPUSH
30795: CALL_OW 255
30799: PPUSH
30800: LD_INT 1
30802: PPUSH
30803: LD_INT 0
30805: PPUSH
30806: CALL 31125 0 4
30810: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30811: LD_VAR 0 1
30815: PPUSH
30816: CALL_OW 266
30820: PUSH
30821: LD_INT 36
30823: IN
30824: IFFALSE 30838
// SetTag ( un , 0 ) ;
30826: LD_VAR 0 2
30830: PPUSH
30831: LD_INT 0
30833: PPUSH
30834: CALL_OW 109
// end ;
30838: PPOPN 2
30840: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30841: LD_EXP 41
30845: PUSH
30846: LD_VAR 0 1
30850: PPUSH
30851: CALL_OW 255
30855: ARRAY
30856: IFFALSE 30882
// begin if GetControl ( un ) = control_remote then
30858: LD_VAR 0 1
30862: PPUSH
30863: CALL_OW 263
30867: PUSH
30868: LD_INT 2
30870: EQUAL
30871: IFFALSE 30882
// ComUnlink ( un ) ;
30873: LD_VAR 0 1
30877: PPUSH
30878: CALL_OW 136
// end ;
30882: PPOPN 1
30884: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30885: LD_EXP 41
30889: PUSH
30890: LD_VAR 0 1
30894: PPUSH
30895: CALL_OW 255
30899: ARRAY
30900: IFFALSE 30929
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30902: LD_VAR 0 2
30906: PPUSH
30907: CALL_OW 264
30911: PUSH
30912: LD_INT 31
30914: IN
30915: IFFALSE 30929
// SetTag ( driver , 0 ) ;
30917: LD_VAR 0 1
30921: PPUSH
30922: LD_INT 0
30924: PPUSH
30925: CALL_OW 109
// end ;
30929: PPOPN 4
30931: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30932: LD_INT 0
30934: PPUSH
30935: PPUSH
30936: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30937: LD_ADDR_VAR 0 3
30941: PUSH
30942: LD_VAR 0 1
30946: PPUSH
30947: CALL_OW 269
30951: ST_TO_ADDR
// x := GetX ( building ) ;
30952: LD_ADDR_VAR 0 4
30956: PUSH
30957: LD_VAR 0 1
30961: PPUSH
30962: CALL_OW 250
30966: ST_TO_ADDR
// y := GetY ( building ) ;
30967: LD_ADDR_VAR 0 5
30971: PUSH
30972: LD_VAR 0 1
30976: PPUSH
30977: CALL_OW 251
30981: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30982: LD_ADDR_EXP 45
30986: PUSH
30987: LD_EXP 45
30991: PPUSH
30992: LD_VAR 0 1
30996: PPUSH
30997: CALL_OW 255
31001: PPUSH
31002: LD_VAR 0 3
31006: PPUSH
31007: LD_VAR 0 4
31011: PUSH
31012: LD_VAR 0 5
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PPUSH
31021: CALL 42498 0 4
31025: ST_TO_ADDR
// end ;
31026: PPOPN 5
31028: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31029: LD_VAR 0 1
31033: PUSH
31034: LD_EXP 32
31038: IN
31039: NOT
31040: IFFALSE 31088
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31042: LD_ADDR_EXP 32
31046: PUSH
31047: LD_EXP 32
31051: PPUSH
31052: LD_EXP 32
31056: PUSH
31057: LD_INT 1
31059: PLUS
31060: PPUSH
31061: LD_VAR 0 1
31065: PPUSH
31066: CALL_OW 2
31070: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31071: LD_STRING DestinationUnrechable. [unit: 
31073: PUSH
31074: LD_VAR 0 1
31078: STR
31079: PUSH
31080: LD_STRING ]
31082: STR
31083: PPUSH
31084: CALL 7984 0 1
// end ; end ;
31088: PPOPN 1
31090: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31091: LD_VAR 0 1
31095: PPUSH
31096: LD_VAR 0 2
31100: PPUSH
31101: LD_VAR 0 3
31105: PPUSH
31106: CALL 54976 0 3
// end ;
31110: PPOPN 3
31112: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31113: LD_VAR 0 1
31117: PPUSH
31118: CALL 54984 0 1
// end ; end_of_file
31122: PPOPN 1
31124: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31125: LD_INT 0
31127: PPUSH
31128: PPUSH
31129: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31130: LD_ADDR_VAR 0 7
31134: PUSH
31135: LD_VAR 0 1
31139: PUSH
31140: LD_VAR 0 2
31144: ARRAY
31145: PPUSH
31146: LD_VAR 0 3
31150: PPUSH
31151: LD_VAR 0 4
31155: PPUSH
31156: CALL_OW 1
31160: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31161: LD_ADDR_VAR 0 1
31165: PUSH
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_VAR 0 2
31175: PPUSH
31176: LD_VAR 0 7
31180: PPUSH
31181: CALL_OW 1
31185: ST_TO_ADDR
// result := tab ;
31186: LD_ADDR_VAR 0 5
31190: PUSH
31191: LD_VAR 0 1
31195: ST_TO_ADDR
// end ;
31196: LD_VAR 0 5
31200: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31201: LD_INT 0
31203: PPUSH
31204: PPUSH
31205: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31206: LD_ADDR_VAR 0 5
31210: PUSH
31211: LD_VAR 0 1
31215: PUSH
31216: LD_VAR 0 2
31220: PUSH
31221: LD_INT 1
31223: ARRAY
31224: ARRAY
31225: PPUSH
31226: LD_VAR 0 2
31230: PUSH
31231: LD_INT 2
31233: ARRAY
31234: PPUSH
31235: CALL_OW 3
31239: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31240: LD_ADDR_VAR 0 1
31244: PUSH
31245: LD_VAR 0 1
31249: PPUSH
31250: LD_VAR 0 2
31254: PUSH
31255: LD_INT 1
31257: ARRAY
31258: PPUSH
31259: LD_VAR 0 5
31263: PPUSH
31264: CALL_OW 1
31268: ST_TO_ADDR
// result := tab ;
31269: LD_ADDR_VAR 0 3
31273: PUSH
31274: LD_VAR 0 1
31278: ST_TO_ADDR
// end ;
31279: LD_VAR 0 3
31283: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31284: LD_INT 0
31286: PPUSH
31287: PPUSH
31288: PPUSH
31289: PPUSH
// i := 1 ;
31290: LD_ADDR_VAR 0 5
31294: PUSH
31295: LD_INT 1
31297: ST_TO_ADDR
// while ( i <= tab ) do
31298: LD_VAR 0 5
31302: PUSH
31303: LD_VAR 0 1
31307: LESSEQUAL
31308: IFFALSE 31683
// begin if not tab [ i ] then
31310: LD_VAR 0 1
31314: PUSH
31315: LD_VAR 0 5
31319: ARRAY
31320: NOT
31321: IFFALSE 31325
// break ;
31323: GO 31683
// if value in tab then
31325: LD_VAR 0 2
31329: PUSH
31330: LD_VAR 0 1
31334: IN
31335: IFFALSE 31448
// begin if not mode then
31337: LD_VAR 0 3
31341: NOT
31342: IFFALSE 31362
// tab := tab diff value else
31344: LD_ADDR_VAR 0 1
31348: PUSH
31349: LD_VAR 0 1
31353: PUSH
31354: LD_VAR 0 2
31358: DIFF
31359: ST_TO_ADDR
31360: GO 31424
// for j = 1 to tab do
31362: LD_ADDR_VAR 0 6
31366: PUSH
31367: DOUBLE
31368: LD_INT 1
31370: DEC
31371: ST_TO_ADDR
31372: LD_VAR 0 1
31376: PUSH
31377: FOR_TO
31378: IFFALSE 31422
// if tab [ j ] = value then
31380: LD_VAR 0 1
31384: PUSH
31385: LD_VAR 0 6
31389: ARRAY
31390: PUSH
31391: LD_VAR 0 2
31395: EQUAL
31396: IFFALSE 31420
// begin tab := Delete ( tab , j ) ;
31398: LD_ADDR_VAR 0 1
31402: PUSH
31403: LD_VAR 0 1
31407: PPUSH
31408: LD_VAR 0 6
31412: PPUSH
31413: CALL_OW 3
31417: ST_TO_ADDR
// break ;
31418: GO 31422
// end ;
31420: GO 31377
31422: POP
31423: POP
// i := i - 1 ;
31424: LD_ADDR_VAR 0 5
31428: PUSH
31429: LD_VAR 0 5
31433: PUSH
31434: LD_INT 1
31436: MINUS
31437: ST_TO_ADDR
// if mode then
31438: LD_VAR 0 3
31442: IFFALSE 31446
// break ;
31444: GO 31683
// end else
31446: GO 31667
// if tab [ i ] and value in tab [ i ] then
31448: LD_VAR 0 1
31452: PUSH
31453: LD_VAR 0 5
31457: ARRAY
31458: PUSH
31459: LD_VAR 0 2
31463: PUSH
31464: LD_VAR 0 1
31468: PUSH
31469: LD_VAR 0 5
31473: ARRAY
31474: IN
31475: AND
31476: IFFALSE 31667
// begin if not mode then
31478: LD_VAR 0 3
31482: NOT
31483: IFFALSE 31509
// tmp := tab [ i ] diff value else
31485: LD_ADDR_VAR 0 7
31489: PUSH
31490: LD_VAR 0 1
31494: PUSH
31495: LD_VAR 0 5
31499: ARRAY
31500: PUSH
31501: LD_VAR 0 2
31505: DIFF
31506: ST_TO_ADDR
31507: GO 31589
// for j = 1 to tab [ i ] do
31509: LD_ADDR_VAR 0 6
31513: PUSH
31514: DOUBLE
31515: LD_INT 1
31517: DEC
31518: ST_TO_ADDR
31519: LD_VAR 0 1
31523: PUSH
31524: LD_VAR 0 5
31528: ARRAY
31529: PUSH
31530: FOR_TO
31531: IFFALSE 31587
// if value = tab [ i ] [ j ] then
31533: LD_VAR 0 2
31537: PUSH
31538: LD_VAR 0 1
31542: PUSH
31543: LD_VAR 0 5
31547: ARRAY
31548: PUSH
31549: LD_VAR 0 6
31553: ARRAY
31554: EQUAL
31555: IFFALSE 31585
// begin tmp := Delete ( tab [ i ] , j ) ;
31557: LD_ADDR_VAR 0 7
31561: PUSH
31562: LD_VAR 0 1
31566: PUSH
31567: LD_VAR 0 5
31571: ARRAY
31572: PPUSH
31573: LD_VAR 0 6
31577: PPUSH
31578: CALL_OW 3
31582: ST_TO_ADDR
// break ;
31583: GO 31587
// end ;
31585: GO 31530
31587: POP
31588: POP
// if tmp = [ ] then
31589: LD_VAR 0 7
31593: PUSH
31594: EMPTY
31595: EQUAL
31596: IFFALSE 31620
// begin tab := Delete ( tab , i ) ;
31598: LD_ADDR_VAR 0 1
31602: PUSH
31603: LD_VAR 0 1
31607: PPUSH
31608: LD_VAR 0 5
31612: PPUSH
31613: CALL_OW 3
31617: ST_TO_ADDR
// end else
31618: GO 31645
// tab := Replace ( tab , i , tmp ) ;
31620: LD_ADDR_VAR 0 1
31624: PUSH
31625: LD_VAR 0 1
31629: PPUSH
31630: LD_VAR 0 5
31634: PPUSH
31635: LD_VAR 0 7
31639: PPUSH
31640: CALL_OW 1
31644: ST_TO_ADDR
// i := i - 1 ;
31645: LD_ADDR_VAR 0 5
31649: PUSH
31650: LD_VAR 0 5
31654: PUSH
31655: LD_INT 1
31657: MINUS
31658: ST_TO_ADDR
// if mode then
31659: LD_VAR 0 3
31663: IFFALSE 31667
// break ;
31665: GO 31683
// end ; i := i + 1 ;
31667: LD_ADDR_VAR 0 5
31671: PUSH
31672: LD_VAR 0 5
31676: PUSH
31677: LD_INT 1
31679: PLUS
31680: ST_TO_ADDR
// end ;
31681: GO 31298
// result := tab ;
31683: LD_ADDR_VAR 0 4
31687: PUSH
31688: LD_VAR 0 1
31692: ST_TO_ADDR
// end ;
31693: LD_VAR 0 4
31697: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31698: LD_INT 0
31700: PPUSH
31701: PPUSH
// for i = 1 to values do
31702: LD_ADDR_VAR 0 4
31706: PUSH
31707: DOUBLE
31708: LD_INT 1
31710: DEC
31711: ST_TO_ADDR
31712: LD_VAR 0 2
31716: PUSH
31717: FOR_TO
31718: IFFALSE 31751
// tab := Remove ( tab , values [ i ] , false ) ;
31720: LD_ADDR_VAR 0 1
31724: PUSH
31725: LD_VAR 0 1
31729: PPUSH
31730: LD_VAR 0 2
31734: PUSH
31735: LD_VAR 0 4
31739: ARRAY
31740: PPUSH
31741: LD_INT 0
31743: PPUSH
31744: CALL 31284 0 3
31748: ST_TO_ADDR
31749: GO 31717
31751: POP
31752: POP
// result := tab ;
31753: LD_ADDR_VAR 0 3
31757: PUSH
31758: LD_VAR 0 1
31762: ST_TO_ADDR
// end ;
31763: LD_VAR 0 3
31767: RET
// export function IsDriver ( unit ) ; begin
31768: LD_INT 0
31770: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31771: LD_VAR 0 1
31775: PUSH
31776: LD_INT 55
31778: PUSH
31779: EMPTY
31780: LIST
31781: PPUSH
31782: CALL_OW 69
31786: IN
31787: IFFALSE 31806
// result := IsInUnit ( unit ) else
31789: LD_ADDR_VAR 0 2
31793: PUSH
31794: LD_VAR 0 1
31798: PPUSH
31799: CALL_OW 310
31803: ST_TO_ADDR
31804: GO 31814
// result := false ;
31806: LD_ADDR_VAR 0 2
31810: PUSH
31811: LD_INT 0
31813: ST_TO_ADDR
// end ;
31814: LD_VAR 0 2
31818: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31819: LD_INT 0
31821: PPUSH
31822: PPUSH
31823: PPUSH
// if not GetControl ( veh ) = control_manual then
31824: LD_VAR 0 1
31828: PPUSH
31829: CALL_OW 263
31833: PUSH
31834: LD_INT 1
31836: EQUAL
31837: NOT
31838: IFFALSE 31850
// result := false else
31840: LD_ADDR_VAR 0 2
31844: PUSH
31845: LD_INT 0
31847: ST_TO_ADDR
31848: GO 31995
// if veh in FilterAllUnits ( [ f_empty ] ) then
31850: LD_VAR 0 1
31854: PUSH
31855: LD_INT 58
31857: PUSH
31858: EMPTY
31859: LIST
31860: PPUSH
31861: CALL_OW 69
31865: IN
31866: IFFALSE 31878
// result := false else
31868: LD_ADDR_VAR 0 2
31872: PUSH
31873: LD_INT 0
31875: ST_TO_ADDR
31876: GO 31995
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31878: LD_ADDR_VAR 0 4
31882: PUSH
31883: LD_INT 22
31885: PUSH
31886: LD_VAR 0 1
31890: PPUSH
31891: CALL_OW 255
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 55
31902: PUSH
31903: EMPTY
31904: LIST
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PPUSH
31910: CALL_OW 69
31914: ST_TO_ADDR
// if not filter then
31915: LD_VAR 0 4
31919: NOT
31920: IFFALSE 31932
// result := false else
31922: LD_ADDR_VAR 0 2
31926: PUSH
31927: LD_INT 0
31929: ST_TO_ADDR
31930: GO 31995
// for i = 1 to filter do
31932: LD_ADDR_VAR 0 3
31936: PUSH
31937: DOUBLE
31938: LD_INT 1
31940: DEC
31941: ST_TO_ADDR
31942: LD_VAR 0 4
31946: PUSH
31947: FOR_TO
31948: IFFALSE 31993
// if IsDriver ( filter [ i ] ) = veh then
31950: LD_VAR 0 4
31954: PUSH
31955: LD_VAR 0 3
31959: ARRAY
31960: PPUSH
31961: CALL 31768 0 1
31965: PUSH
31966: LD_VAR 0 1
31970: EQUAL
31971: IFFALSE 31991
// begin result := filter [ i ] ;
31973: LD_ADDR_VAR 0 2
31977: PUSH
31978: LD_VAR 0 4
31982: PUSH
31983: LD_VAR 0 3
31987: ARRAY
31988: ST_TO_ADDR
// break ;
31989: GO 31993
// end ;
31991: GO 31947
31993: POP
31994: POP
// end ; end ;
31995: LD_VAR 0 2
31999: RET
// export function ComComplete ( unit , b ) ; var i ; begin
32000: LD_INT 0
32002: PPUSH
32003: PPUSH
// if BuildingStatus ( b ) = bs_build then
32004: LD_VAR 0 2
32008: PPUSH
32009: CALL_OW 461
32013: PUSH
32014: LD_INT 1
32016: EQUAL
32017: IFFALSE 32077
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
32019: LD_VAR 0 1
32023: PPUSH
32024: LD_STRING h
32026: PUSH
32027: LD_VAR 0 2
32031: PPUSH
32032: CALL_OW 250
32036: PUSH
32037: LD_VAR 0 2
32041: PPUSH
32042: CALL_OW 251
32046: PUSH
32047: LD_VAR 0 2
32051: PUSH
32052: LD_INT 0
32054: PUSH
32055: LD_INT 0
32057: PUSH
32058: LD_INT 0
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: PUSH
32070: EMPTY
32071: LIST
32072: PPUSH
32073: CALL_OW 446
// end ;
32077: LD_VAR 0 3
32081: RET
// export function Compare ( val1 , val2 ) ; begin
32082: LD_INT 0
32084: PPUSH
// if val1 = val2 then
32085: LD_VAR 0 1
32089: PUSH
32090: LD_VAR 0 2
32094: EQUAL
32095: IFFALSE 32107
// result := true else
32097: LD_ADDR_VAR 0 3
32101: PUSH
32102: LD_INT 1
32104: ST_TO_ADDR
32105: GO 32115
// result := false ;
32107: LD_ADDR_VAR 0 3
32111: PUSH
32112: LD_INT 0
32114: ST_TO_ADDR
// end ;
32115: LD_VAR 0 3
32119: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
32120: LD_INT 0
32122: PPUSH
32123: PPUSH
// result := true ;
32124: LD_ADDR_VAR 0 3
32128: PUSH
32129: LD_INT 1
32131: ST_TO_ADDR
// if array1 = array2 then
32132: LD_VAR 0 1
32136: PUSH
32137: LD_VAR 0 2
32141: EQUAL
32142: IFFALSE 32207
// begin for i = 1 to array1 do
32144: LD_ADDR_VAR 0 4
32148: PUSH
32149: DOUBLE
32150: LD_INT 1
32152: DEC
32153: ST_TO_ADDR
32154: LD_VAR 0 1
32158: PUSH
32159: FOR_TO
32160: IFFALSE 32203
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
32162: LD_VAR 0 1
32166: PUSH
32167: LD_VAR 0 4
32171: ARRAY
32172: PPUSH
32173: LD_VAR 0 2
32177: PUSH
32178: LD_VAR 0 4
32182: ARRAY
32183: PPUSH
32184: CALL 32082 0 2
32188: NOT
32189: IFFALSE 32201
// begin result := false ;
32191: LD_ADDR_VAR 0 3
32195: PUSH
32196: LD_INT 0
32198: ST_TO_ADDR
// break ;
32199: GO 32203
// end ;
32201: GO 32159
32203: POP
32204: POP
// end else
32205: GO 32215
// result := false ;
32207: LD_ADDR_VAR 0 3
32211: PUSH
32212: LD_INT 0
32214: ST_TO_ADDR
// end ;
32215: LD_VAR 0 3
32219: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32220: LD_INT 0
32222: PPUSH
32223: PPUSH
// result := false ;
32224: LD_ADDR_VAR 0 3
32228: PUSH
32229: LD_INT 0
32231: ST_TO_ADDR
// for j = 1 to e2 do
32232: LD_ADDR_VAR 0 4
32236: PUSH
32237: DOUBLE
32238: LD_INT 1
32240: DEC
32241: ST_TO_ADDR
32242: LD_VAR 0 2
32246: PUSH
32247: FOR_TO
32248: IFFALSE 32282
// if Compare ( e1 , e2 [ j ] ) then
32250: LD_VAR 0 1
32254: PPUSH
32255: LD_VAR 0 2
32259: PUSH
32260: LD_VAR 0 4
32264: ARRAY
32265: PPUSH
32266: CALL 32082 0 2
32270: IFFALSE 32280
// result := true ;
32272: LD_ADDR_VAR 0 3
32276: PUSH
32277: LD_INT 1
32279: ST_TO_ADDR
32280: GO 32247
32282: POP
32283: POP
// end ;
32284: LD_VAR 0 3
32288: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32289: LD_INT 0
32291: PPUSH
32292: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32293: LD_VAR 0 1
32297: PPUSH
32298: LD_STRING C
32300: PUSH
32301: LD_VAR 0 2
32305: PUSH
32306: LD_VAR 0 3
32310: PUSH
32311: LD_INT 0
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: PUSH
32332: LD_STRING v
32334: PUSH
32335: LD_VAR 0 4
32339: PPUSH
32340: CALL_OW 250
32344: PUSH
32345: LD_VAR 0 4
32349: PPUSH
32350: CALL_OW 251
32354: PUSH
32355: LD_VAR 0 4
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 0
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PPUSH
32382: CALL_OW 446
// end ;
32386: LD_VAR 0 5
32390: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32391: LD_INT 0
32393: PPUSH
32394: PPUSH
32395: PPUSH
// linked := UnitsLinked ( unit ) ;
32396: LD_ADDR_VAR 0 4
32400: PUSH
32401: LD_VAR 0 1
32405: PPUSH
32406: CALL_OW 432
32410: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32411: LD_ADDR_VAR 0 3
32415: PUSH
32416: LD_VAR 0 1
32420: PPUSH
32421: LD_INT 3
32423: PPUSH
32424: CALL_OW 259
32428: ST_TO_ADDR
// if sk > linked then
32429: LD_VAR 0 3
32433: PUSH
32434: LD_VAR 0 4
32438: GREATER
32439: IFFALSE 32451
// result := true else
32441: LD_ADDR_VAR 0 2
32445: PUSH
32446: LD_INT 1
32448: ST_TO_ADDR
32449: GO 32459
// result := false ;
32451: LD_ADDR_VAR 0 2
32455: PUSH
32456: LD_INT 0
32458: ST_TO_ADDR
// end ;
32459: LD_VAR 0 2
32463: RET
// export function NotTask ( unit ) ; begin
32464: LD_INT 0
32466: PPUSH
// result := true ;
32467: LD_ADDR_VAR 0 2
32471: PUSH
32472: LD_INT 1
32474: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32475: LD_VAR 0 1
32479: PPUSH
32480: CALL_OW 437
32484: PUSH
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 314
32494: OR
32495: IFFALSE 32505
// result := false ;
32497: LD_ADDR_VAR 0 2
32501: PUSH
32502: LD_INT 0
32504: ST_TO_ADDR
// end ;
32505: LD_VAR 0 2
32509: RET
// export function WantHeal ( sci , unit ) ; begin
32510: LD_INT 0
32512: PPUSH
// if GetTaskList ( sci ) > 0 then
32513: LD_VAR 0 1
32517: PPUSH
32518: CALL_OW 437
32522: PUSH
32523: LD_INT 0
32525: GREATER
32526: IFFALSE 32596
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32528: LD_VAR 0 1
32532: PPUSH
32533: CALL_OW 437
32537: PUSH
32538: LD_INT 1
32540: ARRAY
32541: PUSH
32542: LD_INT 1
32544: ARRAY
32545: PUSH
32546: LD_STRING l
32548: EQUAL
32549: PUSH
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 437
32559: PUSH
32560: LD_INT 1
32562: ARRAY
32563: PUSH
32564: LD_INT 4
32566: ARRAY
32567: PUSH
32568: LD_VAR 0 2
32572: EQUAL
32573: AND
32574: IFFALSE 32586
// result := true else
32576: LD_ADDR_VAR 0 3
32580: PUSH
32581: LD_INT 1
32583: ST_TO_ADDR
32584: GO 32594
// result := false ;
32586: LD_ADDR_VAR 0 3
32590: PUSH
32591: LD_INT 0
32593: ST_TO_ADDR
// end else
32594: GO 32604
// result := false ;
32596: LD_ADDR_VAR 0 3
32600: PUSH
32601: LD_INT 0
32603: ST_TO_ADDR
// end ;
32604: LD_VAR 0 3
32608: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32609: LD_INT 0
32611: PPUSH
32612: PPUSH
32613: PPUSH
32614: PPUSH
32615: PPUSH
// dist := 99999 ;
32616: LD_ADDR_VAR 0 7
32620: PUSH
32621: LD_INT 99999
32623: ST_TO_ADDR
// un := - 1 ;
32624: LD_ADDR_VAR 0 6
32628: PUSH
32629: LD_INT 1
32631: NEG
32632: ST_TO_ADDR
// if units1 and units2 then
32633: LD_VAR 0 1
32637: PUSH
32638: LD_VAR 0 2
32642: AND
32643: IFFALSE 32731
// for i in units1 do
32645: LD_ADDR_VAR 0 4
32649: PUSH
32650: LD_VAR 0 1
32654: PUSH
32655: FOR_IN
32656: IFFALSE 32729
// for j in units2 do
32658: LD_ADDR_VAR 0 5
32662: PUSH
32663: LD_VAR 0 2
32667: PUSH
32668: FOR_IN
32669: IFFALSE 32725
// if GetDistUnits ( i , j ) < dist then
32671: LD_VAR 0 4
32675: PPUSH
32676: LD_VAR 0 5
32680: PPUSH
32681: CALL_OW 296
32685: PUSH
32686: LD_VAR 0 7
32690: LESS
32691: IFFALSE 32723
// begin un := i ;
32693: LD_ADDR_VAR 0 6
32697: PUSH
32698: LD_VAR 0 4
32702: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32703: LD_ADDR_VAR 0 7
32707: PUSH
32708: LD_VAR 0 4
32712: PPUSH
32713: LD_VAR 0 5
32717: PPUSH
32718: CALL_OW 296
32722: ST_TO_ADDR
// end ;
32723: GO 32668
32725: POP
32726: POP
32727: GO 32655
32729: POP
32730: POP
// result := [ un , dist ] ;
32731: LD_ADDR_VAR 0 3
32735: PUSH
32736: LD_VAR 0 6
32740: PUSH
32741: LD_VAR 0 7
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: ST_TO_ADDR
// end ;
32750: LD_VAR 0 3
32754: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32755: LD_INT 0
32757: PPUSH
32758: PPUSH
32759: PPUSH
32760: PPUSH
32761: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32762: LD_VAR 0 1
32766: NOT
32767: PUSH
32768: LD_VAR 0 1
32772: PPUSH
32773: CALL_OW 256
32777: PUSH
32778: LD_INT 250
32780: LESS
32781: OR
32782: PUSH
32783: LD_VAR 0 1
32787: PPUSH
32788: CALL_OW 314
32792: PUSH
32793: LD_VAR 0 1
32797: PPUSH
32798: CALL_OW 261
32802: PUSH
32803: LD_INT 20
32805: GREATER
32806: AND
32807: OR
32808: IFFALSE 32812
// exit ;
32810: GO 33186
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32812: LD_VAR 0 1
32816: PPUSH
32817: CALL_OW 261
32821: PUSH
32822: LD_INT 20
32824: LESS
32825: PUSH
32826: LD_VAR 0 1
32830: PPUSH
32831: CALL_OW 110
32835: PUSH
32836: LD_INT 21
32838: EQUAL
32839: NOT
32840: AND
32841: IFFALSE 32877
// begin ComStop ( bulldozer ) ;
32843: LD_VAR 0 1
32847: PPUSH
32848: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32852: LD_VAR 0 1
32856: PPUSH
32857: LD_INT 21
32859: PPUSH
32860: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32864: LD_VAR 0 1
32868: PPUSH
32869: CALL 26285 0 1
// exit ;
32873: GO 33186
// end else
32875: GO 32904
// if GetFuel ( bulldozer ) > 20 then
32877: LD_VAR 0 1
32881: PPUSH
32882: CALL_OW 261
32886: PUSH
32887: LD_INT 20
32889: GREATER
32890: IFFALSE 32904
// SetTag ( bulldozer , 0 ) ;
32892: LD_VAR 0 1
32896: PPUSH
32897: LD_INT 0
32899: PPUSH
32900: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32904: LD_ADDR_VAR 0 5
32908: PUSH
32909: LD_VAR 0 2
32913: PPUSH
32914: CALL_OW 353
32918: ST_TO_ADDR
// tmp := [ ] ;
32919: LD_ADDR_VAR 0 6
32923: PUSH
32924: EMPTY
32925: ST_TO_ADDR
// for i = 1 to list do
32926: LD_ADDR_VAR 0 4
32930: PUSH
32931: DOUBLE
32932: LD_INT 1
32934: DEC
32935: ST_TO_ADDR
32936: LD_VAR 0 5
32940: PUSH
32941: FOR_TO
32942: IFFALSE 33040
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32944: LD_VAR 0 5
32948: PUSH
32949: LD_VAR 0 4
32953: ARRAY
32954: PUSH
32955: LD_INT 1
32957: ARRAY
32958: PPUSH
32959: LD_VAR 0 5
32963: PUSH
32964: LD_VAR 0 4
32968: ARRAY
32969: PUSH
32970: LD_INT 2
32972: ARRAY
32973: PPUSH
32974: CALL_OW 554
32978: IFFALSE 33038
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32980: LD_ADDR_VAR 0 6
32984: PUSH
32985: LD_VAR 0 6
32989: PPUSH
32990: LD_VAR 0 6
32994: PUSH
32995: LD_INT 1
32997: PLUS
32998: PPUSH
32999: LD_VAR 0 5
33003: PUSH
33004: LD_VAR 0 4
33008: ARRAY
33009: PUSH
33010: LD_INT 1
33012: ARRAY
33013: PUSH
33014: LD_VAR 0 5
33018: PUSH
33019: LD_VAR 0 4
33023: ARRAY
33024: PUSH
33025: LD_INT 2
33027: ARRAY
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PPUSH
33033: CALL_OW 1
33037: ST_TO_ADDR
// end ;
33038: GO 32941
33040: POP
33041: POP
// ComStop ( bulldozer ) ;
33042: LD_VAR 0 1
33046: PPUSH
33047: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
33051: LD_ADDR_VAR 0 7
33055: PUSH
33056: LD_VAR 0 1
33060: PPUSH
33061: CALL_OW 250
33065: PUSH
33066: LD_VAR 0 1
33070: PPUSH
33071: CALL_OW 251
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: ST_TO_ADDR
// for i = tmp downto 1 do
33080: LD_ADDR_VAR 0 4
33084: PUSH
33085: DOUBLE
33086: LD_VAR 0 6
33090: INC
33091: ST_TO_ADDR
33092: LD_INT 1
33094: PUSH
33095: FOR_DOWNTO
33096: IFFALSE 33184
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
33098: LD_ADDR_VAR 0 7
33102: PUSH
33103: LD_VAR 0 7
33107: PUSH
33108: LD_INT 1
33110: ARRAY
33111: PPUSH
33112: LD_VAR 0 7
33116: PUSH
33117: LD_INT 2
33119: ARRAY
33120: PPUSH
33121: LD_VAR 0 6
33125: PPUSH
33126: CALL 33287 0 3
33130: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
33131: LD_VAR 0 1
33135: PPUSH
33136: LD_VAR 0 7
33140: PUSH
33141: LD_INT 1
33143: ARRAY
33144: PPUSH
33145: LD_VAR 0 7
33149: PUSH
33150: LD_INT 2
33152: ARRAY
33153: PPUSH
33154: CALL 33191 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
33158: LD_ADDR_VAR 0 6
33162: PUSH
33163: LD_VAR 0 6
33167: PPUSH
33168: LD_VAR 0 7
33172: PUSH
33173: LD_INT 3
33175: ARRAY
33176: PPUSH
33177: CALL_OW 3
33181: ST_TO_ADDR
// end ;
33182: GO 33095
33184: POP
33185: POP
// end ;
33186: LD_VAR 0 3
33190: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
33191: LD_INT 0
33193: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
33194: LD_VAR 0 2
33198: PPUSH
33199: LD_VAR 0 3
33203: PPUSH
33204: CALL_OW 351
33208: PUSH
33209: LD_VAR 0 2
33213: PPUSH
33214: LD_VAR 0 3
33218: PPUSH
33219: CALL_OW 554
33223: AND
33224: PUSH
33225: LD_VAR 0 2
33229: PPUSH
33230: LD_VAR 0 3
33234: PPUSH
33235: CALL_OW 488
33239: AND
33240: PUSH
33241: LD_VAR 0 2
33245: PPUSH
33246: LD_VAR 0 3
33250: PPUSH
33251: CALL_OW 428
33255: PUSH
33256: LD_INT 1
33258: NEG
33259: EQUAL
33260: AND
33261: IFFALSE 33282
// AddComMoveXY ( bulldozer , x , y ) ;
33263: LD_VAR 0 1
33267: PPUSH
33268: LD_VAR 0 2
33272: PPUSH
33273: LD_VAR 0 3
33277: PPUSH
33278: CALL_OW 171
// end ;
33282: LD_VAR 0 4
33286: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33287: LD_INT 0
33289: PPUSH
33290: PPUSH
33291: PPUSH
33292: PPUSH
33293: PPUSH
33294: PPUSH
33295: PPUSH
// dist := 99999 ;
33296: LD_ADDR_VAR 0 6
33300: PUSH
33301: LD_INT 99999
33303: ST_TO_ADDR
// for i = 1 to list do
33304: LD_ADDR_VAR 0 5
33308: PUSH
33309: DOUBLE
33310: LD_INT 1
33312: DEC
33313: ST_TO_ADDR
33314: LD_VAR 0 3
33318: PUSH
33319: FOR_TO
33320: IFFALSE 33458
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33322: LD_ADDR_VAR 0 7
33326: PUSH
33327: LD_VAR 0 1
33331: PPUSH
33332: LD_VAR 0 2
33336: PPUSH
33337: LD_VAR 0 3
33341: PUSH
33342: LD_VAR 0 5
33346: ARRAY
33347: PUSH
33348: LD_INT 1
33350: ARRAY
33351: PPUSH
33352: LD_VAR 0 3
33356: PUSH
33357: LD_VAR 0 5
33361: ARRAY
33362: PUSH
33363: LD_INT 2
33365: ARRAY
33366: PPUSH
33367: CALL_OW 298
33371: ST_TO_ADDR
// if d = 0 then
33372: LD_VAR 0 7
33376: PUSH
33377: LD_INT 0
33379: EQUAL
33380: IFFALSE 33384
// continue ;
33382: GO 33319
// if d < dist then
33384: LD_VAR 0 7
33388: PUSH
33389: LD_VAR 0 6
33393: LESS
33394: IFFALSE 33456
// begin _x := list [ i ] [ 1 ] ;
33396: LD_ADDR_VAR 0 8
33400: PUSH
33401: LD_VAR 0 3
33405: PUSH
33406: LD_VAR 0 5
33410: ARRAY
33411: PUSH
33412: LD_INT 1
33414: ARRAY
33415: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33416: LD_ADDR_VAR 0 9
33420: PUSH
33421: LD_VAR 0 3
33425: PUSH
33426: LD_VAR 0 5
33430: ARRAY
33431: PUSH
33432: LD_INT 2
33434: ARRAY
33435: ST_TO_ADDR
// _i := i ;
33436: LD_ADDR_VAR 0 10
33440: PUSH
33441: LD_VAR 0 5
33445: ST_TO_ADDR
// dist := d ;
33446: LD_ADDR_VAR 0 6
33450: PUSH
33451: LD_VAR 0 7
33455: ST_TO_ADDR
// end ; end ;
33456: GO 33319
33458: POP
33459: POP
// result := [ _x , _y , _i , dist ] ;
33460: LD_ADDR_VAR 0 4
33464: PUSH
33465: LD_VAR 0 8
33469: PUSH
33470: LD_VAR 0 9
33474: PUSH
33475: LD_VAR 0 10
33479: PUSH
33480: LD_VAR 0 6
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: ST_TO_ADDR
// end ;
33491: LD_VAR 0 4
33495: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33496: LD_INT 0
33498: PPUSH
33499: PPUSH
33500: PPUSH
33501: PPUSH
33502: PPUSH
// for i = 1 to list do
33503: LD_ADDR_VAR 0 5
33507: PUSH
33508: DOUBLE
33509: LD_INT 1
33511: DEC
33512: ST_TO_ADDR
33513: LD_VAR 0 1
33517: PUSH
33518: FOR_TO
33519: IFFALSE 33833
// begin for j = list downto 2 do
33521: LD_ADDR_VAR 0 6
33525: PUSH
33526: DOUBLE
33527: LD_VAR 0 1
33531: INC
33532: ST_TO_ADDR
33533: LD_INT 2
33535: PUSH
33536: FOR_DOWNTO
33537: IFFALSE 33829
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33539: LD_VAR 0 2
33543: PPUSH
33544: LD_VAR 0 3
33548: PPUSH
33549: LD_VAR 0 1
33553: PUSH
33554: LD_VAR 0 6
33558: ARRAY
33559: PUSH
33560: LD_INT 1
33562: ARRAY
33563: PPUSH
33564: LD_VAR 0 1
33568: PUSH
33569: LD_VAR 0 6
33573: ARRAY
33574: PUSH
33575: LD_INT 2
33577: ARRAY
33578: PPUSH
33579: CALL_OW 298
33583: PUSH
33584: LD_VAR 0 2
33588: PPUSH
33589: LD_VAR 0 3
33593: PPUSH
33594: LD_VAR 0 1
33598: PUSH
33599: LD_VAR 0 6
33603: PUSH
33604: LD_INT 1
33606: MINUS
33607: ARRAY
33608: PUSH
33609: LD_INT 1
33611: ARRAY
33612: PPUSH
33613: LD_VAR 0 1
33617: PUSH
33618: LD_VAR 0 6
33622: PUSH
33623: LD_INT 1
33625: MINUS
33626: ARRAY
33627: PUSH
33628: LD_INT 2
33630: ARRAY
33631: PPUSH
33632: CALL_OW 298
33636: LESS
33637: IFFALSE 33827
// begin _x := list [ j ] [ 1 ] ;
33639: LD_ADDR_VAR 0 7
33643: PUSH
33644: LD_VAR 0 1
33648: PUSH
33649: LD_VAR 0 6
33653: ARRAY
33654: PUSH
33655: LD_INT 1
33657: ARRAY
33658: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33659: LD_ADDR_VAR 0 8
33663: PUSH
33664: LD_VAR 0 1
33668: PUSH
33669: LD_VAR 0 6
33673: ARRAY
33674: PUSH
33675: LD_INT 2
33677: ARRAY
33678: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33679: LD_ADDR_VAR 0 1
33683: PUSH
33684: LD_VAR 0 1
33688: PPUSH
33689: LD_VAR 0 6
33693: PPUSH
33694: LD_INT 1
33696: PPUSH
33697: LD_VAR 0 1
33701: PUSH
33702: LD_VAR 0 6
33706: PUSH
33707: LD_INT 1
33709: MINUS
33710: ARRAY
33711: PUSH
33712: LD_INT 1
33714: ARRAY
33715: PPUSH
33716: CALL 31125 0 4
33720: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33721: LD_ADDR_VAR 0 1
33725: PUSH
33726: LD_VAR 0 1
33730: PPUSH
33731: LD_VAR 0 6
33735: PPUSH
33736: LD_INT 2
33738: PPUSH
33739: LD_VAR 0 1
33743: PUSH
33744: LD_VAR 0 6
33748: PUSH
33749: LD_INT 1
33751: MINUS
33752: ARRAY
33753: PUSH
33754: LD_INT 2
33756: ARRAY
33757: PPUSH
33758: CALL 31125 0 4
33762: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33763: LD_ADDR_VAR 0 1
33767: PUSH
33768: LD_VAR 0 1
33772: PPUSH
33773: LD_VAR 0 6
33777: PUSH
33778: LD_INT 1
33780: MINUS
33781: PPUSH
33782: LD_INT 1
33784: PPUSH
33785: LD_VAR 0 7
33789: PPUSH
33790: CALL 31125 0 4
33794: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33795: LD_ADDR_VAR 0 1
33799: PUSH
33800: LD_VAR 0 1
33804: PPUSH
33805: LD_VAR 0 6
33809: PUSH
33810: LD_INT 1
33812: MINUS
33813: PPUSH
33814: LD_INT 2
33816: PPUSH
33817: LD_VAR 0 8
33821: PPUSH
33822: CALL 31125 0 4
33826: ST_TO_ADDR
// end ; end ;
33827: GO 33536
33829: POP
33830: POP
// end ;
33831: GO 33518
33833: POP
33834: POP
// result := list ;
33835: LD_ADDR_VAR 0 4
33839: PUSH
33840: LD_VAR 0 1
33844: ST_TO_ADDR
// end ;
33845: LD_VAR 0 4
33849: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33850: LD_INT 0
33852: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33853: LD_ADDR_VAR 0 5
33857: PUSH
33858: LD_VAR 0 1
33862: PPUSH
33863: LD_VAR 0 2
33867: PPUSH
33868: CALL_OW 546
33872: PUSH
33873: LD_INT 2
33875: ARRAY
33876: PUSH
33877: LD_VAR 0 3
33881: PPUSH
33882: LD_VAR 0 4
33886: PPUSH
33887: CALL_OW 546
33891: PUSH
33892: LD_INT 2
33894: ARRAY
33895: MINUS
33896: ST_TO_ADDR
// if result < 0 then
33897: LD_VAR 0 5
33901: PUSH
33902: LD_INT 0
33904: LESS
33905: IFFALSE 33922
// result := result * - 1 ;
33907: LD_ADDR_VAR 0 5
33911: PUSH
33912: LD_VAR 0 5
33916: PUSH
33917: LD_INT 1
33919: NEG
33920: MUL
33921: ST_TO_ADDR
// end ;
33922: LD_VAR 0 5
33926: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33927: LD_INT 0
33929: PPUSH
33930: PPUSH
// area = ListEnvironmentArea ( area ) ;
33931: LD_ADDR_VAR 0 2
33935: PUSH
33936: LD_VAR 0 2
33940: PPUSH
33941: CALL_OW 353
33945: ST_TO_ADDR
// if bulldozer > 0 then
33946: LD_VAR 0 1
33950: PUSH
33951: LD_INT 0
33953: GREATER
33954: IFFALSE 34065
// for i = area downto 1 do
33956: LD_ADDR_VAR 0 4
33960: PUSH
33961: DOUBLE
33962: LD_VAR 0 2
33966: INC
33967: ST_TO_ADDR
33968: LD_INT 1
33970: PUSH
33971: FOR_DOWNTO
33972: IFFALSE 34063
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33974: LD_VAR 0 2
33978: PUSH
33979: LD_VAR 0 4
33983: ARRAY
33984: PUSH
33985: LD_INT 1
33987: ARRAY
33988: PPUSH
33989: LD_VAR 0 2
33993: PUSH
33994: LD_VAR 0 4
33998: ARRAY
33999: PUSH
34000: LD_INT 2
34002: ARRAY
34003: PPUSH
34004: CALL_OW 351
34008: IFFALSE 34061
// if not HasTask ( bulldozer ) then
34010: LD_VAR 0 1
34014: PPUSH
34015: CALL_OW 314
34019: NOT
34020: IFFALSE 34061
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
34022: LD_VAR 0 1
34026: PPUSH
34027: LD_VAR 0 2
34031: PUSH
34032: LD_VAR 0 4
34036: ARRAY
34037: PUSH
34038: LD_INT 1
34040: ARRAY
34041: PPUSH
34042: LD_VAR 0 2
34046: PUSH
34047: LD_VAR 0 4
34051: ARRAY
34052: PUSH
34053: LD_INT 2
34055: ARRAY
34056: PPUSH
34057: CALL_OW 171
34061: GO 33971
34063: POP
34064: POP
// end ;
34065: LD_VAR 0 3
34069: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
34070: LD_INT 0
34072: PPUSH
34073: PPUSH
34074: PPUSH
34075: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
34076: LD_ADDR_VAR 0 6
34080: PUSH
34081: LD_INT 22
34083: PUSH
34084: LD_VAR 0 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 21
34095: PUSH
34096: LD_VAR 0 2
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PPUSH
34109: CALL_OW 69
34113: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
34114: LD_ADDR_VAR 0 7
34118: PUSH
34119: LD_VAR 0 3
34123: PPUSH
34124: LD_INT 22
34126: PUSH
34127: LD_VAR 0 1
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 21
34138: PUSH
34139: LD_VAR 0 2
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PPUSH
34152: CALL_OW 70
34156: ST_TO_ADDR
// if tmp and pom then
34157: LD_VAR 0 6
34161: PUSH
34162: LD_VAR 0 7
34166: AND
34167: IFFALSE 34187
// result := tmp diff pom else
34169: LD_ADDR_VAR 0 4
34173: PUSH
34174: LD_VAR 0 6
34178: PUSH
34179: LD_VAR 0 7
34183: DIFF
34184: ST_TO_ADDR
34185: GO 34195
// result := false ;
34187: LD_ADDR_VAR 0 4
34191: PUSH
34192: LD_INT 0
34194: ST_TO_ADDR
// end ;
34195: LD_VAR 0 4
34199: RET
// export function SavePosition ( unit ) ; begin
34200: LD_INT 0
34202: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
34203: LD_VAR 0 1
34207: PPUSH
34208: LD_VAR 0 1
34212: PPUSH
34213: CALL_OW 250
34217: PPUSH
34218: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
34222: LD_VAR 0 1
34226: PPUSH
34227: LD_VAR 0 1
34231: PPUSH
34232: CALL_OW 251
34236: PPUSH
34237: CALL_OW 232
// end ;
34241: LD_VAR 0 2
34245: RET
// export function GetPosition ( unit ) ; begin
34246: LD_INT 0
34248: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
34249: LD_ADDR_VAR 0 2
34253: PUSH
34254: LD_VAR 0 1
34258: PPUSH
34259: CALL_OW 252
34263: PUSH
34264: LD_VAR 0 1
34268: PPUSH
34269: CALL_OW 253
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: ST_TO_ADDR
// end ;
34278: LD_VAR 0 2
34282: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34283: LD_INT 0
34285: PPUSH
// if unit in unreachableList then
34286: LD_VAR 0 1
34290: PUSH
34291: LD_EXP 32
34295: IN
34296: IFFALSE 34314
// unreachableList := unreachableList diff unit ;
34298: LD_ADDR_EXP 32
34302: PUSH
34303: LD_EXP 32
34307: PUSH
34308: LD_VAR 0 1
34312: DIFF
34313: ST_TO_ADDR
// if ValidHex ( x , y ) then
34314: LD_VAR 0 2
34318: PPUSH
34319: LD_VAR 0 3
34323: PPUSH
34324: CALL_OW 488
34328: IFFALSE 34354
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34330: LD_VAR 0 1
34334: PPUSH
34335: LD_VAR 0 2
34339: PPUSH
34340: LD_VAR 0 3
34344: PPUSH
34345: CALL_OW 428
34349: PPUSH
34350: CALL_OW 115
// Wait ( 3 ) ;
34354: LD_INT 3
34356: PPUSH
34357: CALL_OW 67
// if unit in unreachableList then
34361: LD_VAR 0 1
34365: PUSH
34366: LD_EXP 32
34370: IN
34371: IFFALSE 34383
// result := false else
34373: LD_ADDR_VAR 0 4
34377: PUSH
34378: LD_INT 0
34380: ST_TO_ADDR
34381: GO 34391
// result := true ;
34383: LD_ADDR_VAR 0 4
34387: PUSH
34388: LD_INT 1
34390: ST_TO_ADDR
// end ; end_of_file
34391: LD_VAR 0 4
34395: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34396: LD_EXP 33
34400: IFFALSE 34462
34402: GO 34404
34404: DISABLE
34405: LD_INT 0
34407: PPUSH
// begin enable ;
34408: ENABLE
// for i = 1 to mc_crates_list do
34409: LD_ADDR_VAR 0 1
34413: PUSH
34414: DOUBLE
34415: LD_INT 1
34417: DEC
34418: ST_TO_ADDR
34419: LD_EXP 34
34423: PUSH
34424: FOR_TO
34425: IFFALSE 34456
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34427: LD_EXP 34
34431: PUSH
34432: LD_VAR 0 1
34436: ARRAY
34437: PPUSH
34438: LD_INT 5
34440: PPUSH
34441: LD_INT 50
34443: PPUSH
34444: LD_INT 700
34446: PPUSH
34447: LD_INT 20
34449: PPUSH
34450: CALL 24467 0 5
34454: GO 34424
34456: POP
34457: POP
// MC_Game ( ) ;
34458: CALL 34465 0 0
// end ;
34462: PPOPN 1
34464: END
// export function MC_Game ( ) ; var i , side , un ; begin
34465: LD_INT 0
34467: PPUSH
34468: PPUSH
34469: PPUSH
34470: PPUSH
// if not isTest then
34471: LD_EXP 1
34475: NOT
34476: IFFALSE 34496
// MC_Show ( [ #tick , tick ] ) else
34478: LD_STRING #tick
34480: PUSH
34481: LD_OWVAR 1
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PPUSH
34490: CALL 8505 0 1
34494: GO 34505
// MC_Show ( debug_string ) ;
34496: LD_EXP 2
34500: PPUSH
34501: CALL 8505 0 1
// for side = 1 to 8 do
34505: LD_ADDR_VAR 0 3
34509: PUSH
34510: DOUBLE
34511: LD_INT 1
34513: DEC
34514: ST_TO_ADDR
34515: LD_INT 8
34517: PUSH
34518: FOR_TO
34519: IFFALSE 36519
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34521: LD_EXP 41
34525: PUSH
34526: LD_VAR 0 3
34530: ARRAY
34531: PUSH
34532: LD_INT 0
34534: EQUAL
34535: PUSH
34536: LD_VAR 0 3
34540: PPUSH
34541: EMPTY
34542: PPUSH
34543: CALL 11722 0 2
34547: PUSH
34548: LD_INT 0
34550: EQUAL
34551: OR
34552: IFFALSE 34556
// continue ;
34554: GO 34518
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34556: LD_VAR 0 3
34560: PPUSH
34561: LD_VAR 0 3
34565: PPUSH
34566: CALL 24988 0 1
34570: PPUSH
34571: CALL 36526 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34575: LD_EXP 73
34579: PUSH
34580: LD_VAR 0 3
34584: ARRAY
34585: PUSH
34586: LD_INT 1
34588: ARRAY
34589: PUSH
34590: LD_INT 0
34592: GREATER
34593: PUSH
34594: LD_EXP 71
34598: PUSH
34599: LD_VAR 0 3
34603: ARRAY
34604: PUSH
34605: LD_INT 1
34607: ARRAY
34608: PUSH
34609: LD_INT 0
34611: EQUAL
34612: AND
34613: PUSH
34614: LD_VAR 0 3
34618: PPUSH
34619: LD_INT 7
34621: PPUSH
34622: EMPTY
34623: PPUSH
34624: CALL 12290 0 3
34628: NOT
34629: AND
34630: IFFALSE 34701
// begin if side = 1 then
34632: LD_VAR 0 3
34636: PUSH
34637: LD_INT 1
34639: EQUAL
34640: IFFALSE 34649
// RaiseSailEvent ( 101 ) ;
34642: LD_INT 101
34644: PPUSH
34645: CALL_OW 427
// if side = 4 then
34649: LD_VAR 0 3
34653: PUSH
34654: LD_INT 4
34656: EQUAL
34657: IFFALSE 34666
// RaiseSailEvent ( 102 ) ;
34659: LD_INT 102
34661: PPUSH
34662: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34666: LD_ADDR_VAR 0 2
34670: PUSH
34671: LD_EXP 73
34675: PUSH
34676: LD_VAR 0 3
34680: ARRAY
34681: PUSH
34682: FOR_IN
34683: IFFALSE 34699
// SetTag ( i , 7 ) ;
34685: LD_VAR 0 2
34689: PPUSH
34690: LD_INT 7
34692: PPUSH
34693: CALL_OW 109
34697: GO 34682
34699: POP
34700: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34701: LD_VAR 0 3
34705: PPUSH
34706: LD_INT 7
34708: PPUSH
34709: EMPTY
34710: PPUSH
34711: CALL 12290 0 3
34715: IFFALSE 34741
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34717: LD_VAR 0 3
34721: PPUSH
34722: LD_VAR 0 3
34726: PPUSH
34727: LD_INT 7
34729: PPUSH
34730: EMPTY
34731: PPUSH
34732: CALL 12290 0 3
34736: PPUSH
34737: CALL 8432 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34741: LD_VAR 0 3
34745: PPUSH
34746: CALL 17970 0 1
34750: PUSH
34751: LD_VAR 0 3
34755: PPUSH
34756: CALL 11626 0 1
34760: AND
34761: IFFALSE 34772
// MCL_Start ( side ) ;
34763: LD_VAR 0 3
34767: PPUSH
34768: CALL 17927 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34772: LD_ADDR_EXP 37
34776: PUSH
34777: LD_EXP 37
34781: PPUSH
34782: LD_VAR 0 3
34786: PPUSH
34787: LD_VAR 0 3
34791: PPUSH
34792: CALL 19227 0 1
34796: PPUSH
34797: CALL_OW 1
34801: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34802: LD_ADDR_EXP 49
34806: PUSH
34807: LD_EXP 49
34811: PPUSH
34812: LD_VAR 0 3
34816: PPUSH
34817: LD_VAR 0 3
34821: PPUSH
34822: CALL 11040 0 1
34826: PPUSH
34827: CALL_OW 1
34831: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34832: LD_VAR 0 3
34836: PPUSH
34837: LD_INT 21
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PPUSH
34847: CALL 11587 0 2
34851: IFFALSE 34862
// MCV_CheckStatus ( side ) ;
34853: LD_VAR 0 3
34857: PPUSH
34858: CALL 27197 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34862: LD_VAR 0 3
34866: PPUSH
34867: LD_EXP 55
34871: PPUSH
34872: CALL 43446 0 2
34876: IFFALSE 34961
// begin for i = MREG_ToChangeClass downto 1 do
34878: LD_ADDR_VAR 0 2
34882: PUSH
34883: DOUBLE
34884: LD_EXP 55
34888: INC
34889: ST_TO_ADDR
34890: LD_INT 1
34892: PUSH
34893: FOR_DOWNTO
34894: IFFALSE 34959
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34896: LD_EXP 55
34900: PUSH
34901: LD_VAR 0 2
34905: ARRAY
34906: PUSH
34907: LD_INT 1
34909: ARRAY
34910: PUSH
34911: LD_VAR 0 3
34915: EQUAL
34916: IFFALSE 34957
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34918: LD_VAR 0 3
34922: PPUSH
34923: LD_EXP 55
34927: PUSH
34928: LD_VAR 0 2
34932: ARRAY
34933: PUSH
34934: LD_INT 2
34936: ARRAY
34937: PPUSH
34938: LD_EXP 55
34942: PUSH
34943: LD_VAR 0 2
34947: ARRAY
34948: PUSH
34949: LD_INT 3
34951: ARRAY
34952: PPUSH
34953: CALL 16494 0 3
// end ; end ;
34957: GO 34893
34959: POP
34960: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34961: LD_INT 1
34963: PUSH
34964: LD_EXP 40
34968: PUSH
34969: LD_VAR 0 3
34973: ARRAY
34974: IN
34975: IFFALSE 34986
// begin MCN_TrainApe ( side ) ;
34977: LD_VAR 0 3
34981: PPUSH
34982: CALL 18880 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34986: LD_VAR 0 3
34990: PPUSH
34991: LD_INT 30
34993: PUSH
34994: LD_INT 3
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PPUSH
35001: CALL 11587 0 2
35005: IFFALSE 35179
// begin if MCF_Tag ( side , 10 , [ ] ) then
35007: LD_VAR 0 3
35011: PPUSH
35012: LD_INT 10
35014: PPUSH
35015: EMPTY
35016: PPUSH
35017: CALL 12290 0 3
35021: IFFALSE 35068
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
35023: LD_VAR 0 3
35027: PPUSH
35028: LD_INT 10
35030: PPUSH
35031: EMPTY
35032: PPUSH
35033: CALL 12290 0 3
35037: PPUSH
35038: LD_VAR 0 3
35042: PPUSH
35043: LD_INT 30
35045: PUSH
35046: LD_INT 3
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PPUSH
35053: CALL 11587 0 2
35057: PUSH
35058: LD_INT 1
35060: ARRAY
35061: PPUSH
35062: CALL_OW 168
// end else
35066: GO 35179
// if MREG_ToConstruct [ side ] then
35068: LD_EXP 53
35072: PUSH
35073: LD_VAR 0 3
35077: ARRAY
35078: IFFALSE 35179
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
35080: LD_VAR 0 3
35084: PPUSH
35085: LD_VAR 0 3
35089: PPUSH
35090: LD_INT 30
35092: PUSH
35093: LD_INT 3
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PPUSH
35100: CALL 11587 0 2
35104: PUSH
35105: LD_INT 1
35107: ARRAY
35108: PPUSH
35109: LD_EXP 53
35113: PUSH
35114: LD_VAR 0 3
35118: ARRAY
35119: PUSH
35120: LD_INT 1
35122: ARRAY
35123: PUSH
35124: LD_EXP 53
35128: PUSH
35129: LD_VAR 0 3
35133: ARRAY
35134: PUSH
35135: LD_INT 2
35137: ARRAY
35138: PUSH
35139: LD_EXP 53
35143: PUSH
35144: LD_VAR 0 3
35148: ARRAY
35149: PUSH
35150: LD_INT 3
35152: ARRAY
35153: PUSH
35154: LD_EXP 53
35158: PUSH
35159: LD_VAR 0 3
35163: ARRAY
35164: PUSH
35165: LD_INT 4
35167: ARRAY
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: PPUSH
35175: CALL 25491 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
35179: LD_VAR 0 3
35183: PPUSH
35184: LD_INT 30
35186: PUSH
35187: LD_INT 3
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PPUSH
35194: CALL 11587 0 2
35198: PUSH
35199: LD_VAR 0 3
35203: PPUSH
35204: LD_EXP 45
35208: PPUSH
35209: CALL 43446 0 2
35213: AND
35214: PUSH
35215: LD_INT 22
35217: PUSH
35218: LD_VAR 0 3
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: PUSH
35227: LD_INT 2
35229: PUSH
35230: LD_INT 30
35232: PUSH
35233: LD_INT 33
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 30
35242: PUSH
35243: LD_INT 32
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 35
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: LIST
35269: PPUSH
35270: CALL_OW 69
35274: AND
35275: IFFALSE 35286
// MCV_Turret ( side ) ;
35277: LD_VAR 0 3
35281: PPUSH
35282: CALL 25940 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35286: LD_EXP 44
35290: PUSH
35291: LD_VAR 0 3
35295: ARRAY
35296: PUSH
35297: LD_INT 1
35299: GREATER
35300: PUSH
35301: LD_VAR 0 3
35305: PPUSH
35306: CALL 24988 0 1
35310: PUSH
35311: LD_INT 0
35313: EQUAL
35314: AND
35315: IFFALSE 35477
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35317: LD_EXP 44
35321: PUSH
35322: LD_VAR 0 3
35326: ARRAY
35327: PUSH
35328: LD_INT 1
35330: ARRAY
35331: PPUSH
35332: CALL_OW 353
35336: IFFALSE 35374
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35338: LD_EXP 44
35342: PUSH
35343: LD_VAR 0 3
35347: ARRAY
35348: PUSH
35349: LD_INT 2
35351: ARRAY
35352: PPUSH
35353: LD_EXP 44
35357: PUSH
35358: LD_VAR 0 3
35362: ARRAY
35363: PUSH
35364: LD_INT 1
35366: ARRAY
35367: PPUSH
35368: CALL 32755 0 2
35372: GO 35477
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35374: LD_VAR 0 3
35378: PPUSH
35379: LD_INT 30
35381: PUSH
35382: LD_INT 3
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PPUSH
35389: CALL 11587 0 2
35393: IFFALSE 35477
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35395: LD_VAR 0 3
35399: PPUSH
35400: LD_INT 30
35402: PUSH
35403: LD_INT 3
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PPUSH
35410: CALL 11587 0 2
35414: PUSH
35415: LD_INT 1
35417: ARRAY
35418: PPUSH
35419: CALL_OW 461
35423: PUSH
35424: LD_INT 2
35426: EQUAL
35427: IFFALSE 35477
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35429: LD_EXP 44
35433: PUSH
35434: LD_VAR 0 3
35438: ARRAY
35439: PUSH
35440: LD_INT 2
35442: ARRAY
35443: PPUSH
35444: LD_INT 10
35446: PPUSH
35447: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35451: LD_ADDR_EXP 44
35455: PUSH
35456: LD_EXP 44
35460: PPUSH
35461: LD_VAR 0 3
35465: PPUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: PPUSH
35472: CALL_OW 1
35476: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35477: LD_VAR 0 3
35481: PPUSH
35482: LD_INT 33
35484: PUSH
35485: LD_INT 2
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PPUSH
35492: CALL 11587 0 2
35496: IFFALSE 35536
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35498: LD_VAR 0 3
35502: PPUSH
35503: LD_VAR 0 3
35507: PPUSH
35508: LD_INT 33
35510: PUSH
35511: LD_INT 2
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PPUSH
35518: CALL 11587 0 2
35522: PUSH
35523: LD_INT 1
35525: ARRAY
35526: PPUSH
35527: CALL_OW 248
35531: PPUSH
35532: CALL 26494 0 2
// if MREG_ToRepair [ side ] then
35536: LD_EXP 49
35540: PUSH
35541: LD_VAR 0 3
35545: ARRAY
35546: IFFALSE 35559
// begin MCB_Repair ( side ) ;
35548: LD_VAR 0 3
35552: PPUSH
35553: CALL 11327 0 1
// end else
35557: GO 36472
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35559: LD_VAR 0 3
35563: PPUSH
35564: LD_EXP 51
35568: PPUSH
35569: CALL 43446 0 2
35573: PUSH
35574: LD_VAR 0 3
35578: PPUSH
35579: LD_EXP 42
35583: PPUSH
35584: CALL 43446 0 2
35588: AND
35589: IFFALSE 35797
// begin for i = 1 to MREG_ToUpLab do
35591: LD_ADDR_VAR 0 2
35595: PUSH
35596: DOUBLE
35597: LD_INT 1
35599: DEC
35600: ST_TO_ADDR
35601: LD_EXP 51
35605: PUSH
35606: FOR_TO
35607: IFFALSE 35793
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35609: LD_EXP 51
35613: PUSH
35614: LD_VAR 0 2
35618: ARRAY
35619: PUSH
35620: LD_INT 1
35622: ARRAY
35623: PUSH
35624: LD_VAR 0 3
35628: EQUAL
35629: IFFALSE 35791
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35631: LD_EXP 51
35635: PUSH
35636: LD_VAR 0 2
35640: ARRAY
35641: PUSH
35642: LD_INT 2
35644: ARRAY
35645: PUSH
35646: LD_EXP 51
35650: PUSH
35651: LD_VAR 0 2
35655: ARRAY
35656: PUSH
35657: LD_INT 3
35659: ARRAY
35660: AND
35661: IFFALSE 35789
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35663: LD_VAR 0 3
35667: PPUSH
35668: LD_EXP 51
35672: PUSH
35673: LD_VAR 0 2
35677: ARRAY
35678: PUSH
35679: LD_INT 2
35681: ARRAY
35682: PPUSH
35683: LD_EXP 51
35687: PUSH
35688: LD_VAR 0 2
35692: ARRAY
35693: PUSH
35694: LD_INT 3
35696: ARRAY
35697: PPUSH
35698: CALL 8851 0 3
35702: IFFALSE 35789
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35704: LD_ADDR_EXP 51
35708: PUSH
35709: LD_EXP 51
35713: PPUSH
35714: LD_VAR 0 3
35718: PPUSH
35719: LD_EXP 51
35723: PUSH
35724: LD_VAR 0 2
35728: ARRAY
35729: PUSH
35730: LD_INT 2
35732: ARRAY
35733: PPUSH
35734: LD_EXP 51
35738: PUSH
35739: LD_VAR 0 2
35743: ARRAY
35744: PUSH
35745: LD_INT 3
35747: ARRAY
35748: PPUSH
35749: CALL 42498 0 4
35753: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35754: LD_ADDR_EXP 42
35758: PUSH
35759: LD_EXP 42
35763: PPUSH
35764: LD_VAR 0 3
35768: PPUSH
35769: LD_EXP 42
35773: PUSH
35774: LD_INT 1
35776: ARRAY
35777: PUSH
35778: LD_INT 2
35780: ARRAY
35781: PPUSH
35782: EMPTY
35783: PPUSH
35784: CALL 42498 0 4
35788: ST_TO_ADDR
// end ; break ;
35789: GO 35793
// end ;
35791: GO 35606
35793: POP
35794: POP
// end else
35795: GO 36472
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35797: LD_VAR 0 3
35801: PPUSH
35802: LD_EXP 50
35806: PPUSH
35807: CALL 43446 0 2
35811: IFFALSE 35885
// begin for i = 1 to MREG_ToUpdate do
35813: LD_ADDR_VAR 0 2
35817: PUSH
35818: DOUBLE
35819: LD_INT 1
35821: DEC
35822: ST_TO_ADDR
35823: LD_EXP 50
35827: PUSH
35828: FOR_TO
35829: IFFALSE 35881
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35831: LD_EXP 50
35835: PUSH
35836: LD_VAR 0 2
35840: ARRAY
35841: PUSH
35842: LD_INT 1
35844: ARRAY
35845: PUSH
35846: LD_VAR 0 3
35850: EQUAL
35851: IFFALSE 35879
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35853: LD_VAR 0 3
35857: PPUSH
35858: LD_EXP 50
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_INT 2
35871: ARRAY
35872: PPUSH
35873: CALL 8687 0 2
// break ;
35877: GO 35881
// end ;
35879: GO 35828
35881: POP
35882: POP
// end else
35883: GO 36472
// if MCF_Get ( side , [ f_constructed ] ) then
35885: LD_VAR 0 3
35889: PPUSH
35890: LD_INT 57
35892: PUSH
35893: EMPTY
35894: LIST
35895: PPUSH
35896: CALL 11587 0 2
35900: IFFALSE 35933
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35902: LD_VAR 0 3
35906: PPUSH
35907: LD_VAR 0 3
35911: PPUSH
35912: LD_INT 57
35914: PUSH
35915: EMPTY
35916: LIST
35917: PPUSH
35918: CALL 11587 0 2
35922: PUSH
35923: LD_INT 1
35925: ARRAY
35926: PPUSH
35927: CALL 10931 0 2
35931: GO 36472
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35933: LD_VAR 0 3
35937: PPUSH
35938: LD_EXP 48
35942: PPUSH
35943: CALL 43446 0 2
35947: PUSH
35948: LD_VAR 0 3
35952: PPUSH
35953: CALL_OW 345
35957: NOT
35958: AND
35959: PUSH
35960: LD_VAR 0 3
35964: PPUSH
35965: CALL 24988 0 1
35969: PUSH
35970: LD_INT 0
35972: EQUAL
35973: AND
35974: IFFALSE 36373
// begin for i = 1 to MREG_ToBuild do
35976: LD_ADDR_VAR 0 2
35980: PUSH
35981: DOUBLE
35982: LD_INT 1
35984: DEC
35985: ST_TO_ADDR
35986: LD_EXP 48
35990: PUSH
35991: FOR_TO
35992: IFFALSE 36369
// if MREG_ToBuild [ i ] [ 1 ] = side then
35994: LD_EXP 48
35998: PUSH
35999: LD_VAR 0 2
36003: ARRAY
36004: PUSH
36005: LD_INT 1
36007: ARRAY
36008: PUSH
36009: LD_VAR 0 3
36013: EQUAL
36014: IFFALSE 36367
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
36016: LD_OWVAR 84
36020: PUSH
36021: LD_EXP 48
36025: PUSH
36026: LD_VAR 0 2
36030: ARRAY
36031: PUSH
36032: LD_INT 3
36034: ARRAY
36035: PUSH
36036: LD_INT 1
36038: ARRAY
36039: PPUSH
36040: LD_EXP 48
36044: PUSH
36045: LD_VAR 0 2
36049: ARRAY
36050: PUSH
36051: LD_INT 3
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: CALL_OW 351
36063: AND
36064: IFFALSE 36108
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
36066: LD_EXP 48
36070: PUSH
36071: LD_VAR 0 2
36075: ARRAY
36076: PUSH
36077: LD_INT 3
36079: ARRAY
36080: PUSH
36081: LD_INT 1
36083: ARRAY
36084: PPUSH
36085: LD_EXP 48
36089: PUSH
36090: LD_VAR 0 2
36094: ARRAY
36095: PUSH
36096: LD_INT 3
36098: ARRAY
36099: PUSH
36100: LD_INT 2
36102: ARRAY
36103: PPUSH
36104: CALL 22735 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
36108: LD_EXP 48
36112: PUSH
36113: LD_VAR 0 2
36117: ARRAY
36118: PUSH
36119: LD_INT 2
36121: ARRAY
36122: PUSH
36123: LD_INT 0
36125: EQUAL
36126: IFFALSE 36196
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36128: LD_VAR 0 3
36132: PPUSH
36133: LD_EXP 48
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: PUSH
36144: LD_INT 3
36146: ARRAY
36147: PUSH
36148: LD_INT 1
36150: ARRAY
36151: PPUSH
36152: LD_EXP 48
36156: PUSH
36157: LD_VAR 0 2
36161: ARRAY
36162: PUSH
36163: LD_INT 3
36165: ARRAY
36166: PUSH
36167: LD_INT 2
36169: ARRAY
36170: PPUSH
36171: LD_EXP 48
36175: PUSH
36176: LD_VAR 0 2
36180: ARRAY
36181: PUSH
36182: LD_INT 3
36184: ARRAY
36185: PUSH
36186: LD_INT 3
36188: ARRAY
36189: PPUSH
36190: CALL 8523 0 4
36194: GO 36365
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
36196: LD_EXP 48
36200: PUSH
36201: LD_VAR 0 2
36205: ARRAY
36206: PUSH
36207: LD_INT 2
36209: ARRAY
36210: PUSH
36211: LD_INT 6
36213: EQUAL
36214: IFFALSE 36284
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36216: LD_VAR 0 3
36220: PPUSH
36221: LD_EXP 48
36225: PUSH
36226: LD_VAR 0 2
36230: ARRAY
36231: PUSH
36232: LD_INT 3
36234: ARRAY
36235: PUSH
36236: LD_INT 1
36238: ARRAY
36239: PPUSH
36240: LD_EXP 48
36244: PUSH
36245: LD_VAR 0 2
36249: ARRAY
36250: PUSH
36251: LD_INT 3
36253: ARRAY
36254: PUSH
36255: LD_INT 2
36257: ARRAY
36258: PPUSH
36259: LD_EXP 48
36263: PUSH
36264: LD_VAR 0 2
36268: ARRAY
36269: PUSH
36270: LD_INT 3
36272: ARRAY
36273: PUSH
36274: LD_INT 3
36276: ARRAY
36277: PPUSH
36278: CALL 8652 0 4
36282: GO 36365
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36284: LD_VAR 0 3
36288: PPUSH
36289: LD_EXP 48
36293: PUSH
36294: LD_VAR 0 2
36298: ARRAY
36299: PUSH
36300: LD_INT 2
36302: ARRAY
36303: PPUSH
36304: LD_EXP 48
36308: PUSH
36309: LD_VAR 0 2
36313: ARRAY
36314: PUSH
36315: LD_INT 3
36317: ARRAY
36318: PUSH
36319: LD_INT 1
36321: ARRAY
36322: PPUSH
36323: LD_EXP 48
36327: PUSH
36328: LD_VAR 0 2
36332: ARRAY
36333: PUSH
36334: LD_INT 3
36336: ARRAY
36337: PUSH
36338: LD_INT 2
36340: ARRAY
36341: PPUSH
36342: LD_EXP 48
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PUSH
36353: LD_INT 3
36355: ARRAY
36356: PUSH
36357: LD_INT 3
36359: ARRAY
36360: PPUSH
36361: CALL 10156 0 5
// break ;
36365: GO 36369
// end ;
36367: GO 35991
36369: POP
36370: POP
// end else
36371: GO 36472
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36373: LD_VAR 0 3
36377: PPUSH
36378: LD_EXP 54
36382: PPUSH
36383: CALL 43446 0 2
36387: PUSH
36388: LD_VAR 0 3
36392: PPUSH
36393: CALL 24988 0 1
36397: PUSH
36398: LD_INT 0
36400: EQUAL
36401: AND
36402: IFFALSE 36472
// begin for i = 1 to MREG_ToDismantle do
36404: LD_ADDR_VAR 0 2
36408: PUSH
36409: DOUBLE
36410: LD_INT 1
36412: DEC
36413: ST_TO_ADDR
36414: LD_EXP 54
36418: PUSH
36419: FOR_TO
36420: IFFALSE 36470
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36422: LD_EXP 54
36426: PUSH
36427: LD_VAR 0 2
36431: ARRAY
36432: PUSH
36433: LD_INT 1
36435: ARRAY
36436: PUSH
36437: LD_VAR 0 3
36441: EQUAL
36442: IFFALSE 36468
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36444: LD_VAR 0 3
36448: PPUSH
36449: LD_EXP 54
36453: PUSH
36454: LD_VAR 0 2
36458: ARRAY
36459: PUSH
36460: LD_INT 2
36462: ARRAY
36463: PPUSH
36464: CALL 10822 0 2
// end ;
36468: GO 36419
36470: POP
36471: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36472: LD_VAR 0 3
36476: PPUSH
36477: LD_INT 30
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PPUSH
36487: CALL 11587 0 2
36491: PUSH
36492: LD_VAR 0 3
36496: PPUSH
36497: CALL 24988 0 1
36501: PUSH
36502: LD_INT 0
36504: EQUAL
36505: AND
36506: IFFALSE 36517
// MCT_CollectCrates ( side ) ;
36508: LD_VAR 0 3
36512: PPUSH
36513: CALL 23927 0 1
// end ;
36517: GO 34518
36519: POP
36520: POP
// end ;
36521: LD_VAR 0 1
36525: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36526: LD_INT 0
36528: PPUSH
36529: PPUSH
36530: PPUSH
36531: PPUSH
36532: PPUSH
36533: PPUSH
36534: PPUSH
36535: PPUSH
36536: PPUSH
36537: PPUSH
36538: PPUSH
36539: PPUSH
36540: PPUSH
36541: PPUSH
36542: PPUSH
// all := MCF_All ( side , [ ] ) ;
36543: LD_ADDR_VAR 0 17
36547: PUSH
36548: LD_VAR 0 1
36552: PPUSH
36553: EMPTY
36554: PPUSH
36555: CALL 11722 0 2
36559: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36560: LD_ADDR_VAR 0 13
36564: PUSH
36565: LD_VAR 0 1
36569: PPUSH
36570: LD_INT 1
36572: PPUSH
36573: EMPTY
36574: PPUSH
36575: CALL 11670 0 3
36579: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36580: LD_ADDR_VAR 0 14
36584: PUSH
36585: LD_VAR 0 1
36589: PPUSH
36590: LD_INT 2
36592: PPUSH
36593: EMPTY
36594: PPUSH
36595: CALL 11670 0 3
36599: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36600: LD_ADDR_VAR 0 15
36604: PUSH
36605: LD_VAR 0 1
36609: PPUSH
36610: LD_INT 3
36612: PPUSH
36613: EMPTY
36614: PPUSH
36615: CALL 11670 0 3
36619: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36620: LD_ADDR_VAR 0 16
36624: PUSH
36625: LD_VAR 0 1
36629: PPUSH
36630: LD_INT 4
36632: PPUSH
36633: EMPTY
36634: PPUSH
36635: CALL 11670 0 3
36639: ST_TO_ADDR
// if mech then
36640: LD_VAR 0 15
36644: IFFALSE 36661
// mech := MCF_SortListDesc ( mech ) ;
36646: LD_ADDR_VAR 0 15
36650: PUSH
36651: LD_VAR 0 15
36655: PPUSH
36656: CALL 12836 0 1
36660: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36661: LD_EXP 58
36665: PUSH
36666: LD_VAR 0 1
36670: ARRAY
36671: PUSH
36672: LD_STRING 
36674: EQUAL
36675: NOT
36676: IFFALSE 36732
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36678: LD_EXP 58
36682: PUSH
36683: LD_VAR 0 1
36687: ARRAY
36688: PUSH
36689: LD_INT 1
36691: ARRAY
36692: PPUSH
36693: CALL_OW 257
36697: PUSH
36698: LD_INT 1
36700: EQUAL
36701: IFFALSE 36730
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36703: LD_VAR 0 1
36707: PPUSH
36708: LD_STRING ToArm
36710: PPUSH
36711: LD_EXP 58
36715: PUSH
36716: LD_VAR 0 1
36720: ARRAY
36721: PUSH
36722: LD_INT 1
36724: ARRAY
36725: PPUSH
36726: CALL 14466 0 3
// end else
36730: GO 36758
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36732: LD_ADDR_EXP 58
36736: PUSH
36737: LD_EXP 58
36741: PPUSH
36742: LD_VAR 0 1
36746: PPUSH
36747: LD_INT 1
36749: PPUSH
36750: LD_INT 0
36752: PPUSH
36753: CALL 31125 0 4
36757: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36758: LD_EXP 59
36762: PUSH
36763: LD_VAR 0 1
36767: ARRAY
36768: PUSH
36769: LD_STRING 
36771: EQUAL
36772: NOT
36773: IFFALSE 36829
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36775: LD_EXP 59
36779: PUSH
36780: LD_VAR 0 1
36784: ARRAY
36785: PUSH
36786: LD_INT 1
36788: ARRAY
36789: PPUSH
36790: CALL_OW 257
36794: PUSH
36795: LD_INT 2
36797: EQUAL
36798: IFFALSE 36827
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36800: LD_VAR 0 1
36804: PPUSH
36805: LD_STRING ToDep
36807: PPUSH
36808: LD_EXP 59
36812: PUSH
36813: LD_VAR 0 1
36817: ARRAY
36818: PUSH
36819: LD_INT 1
36821: ARRAY
36822: PPUSH
36823: CALL 14466 0 3
// end else
36827: GO 36855
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36829: LD_ADDR_EXP 59
36833: PUSH
36834: LD_EXP 59
36838: PPUSH
36839: LD_VAR 0 1
36843: PPUSH
36844: LD_INT 1
36846: PPUSH
36847: LD_INT 0
36849: PPUSH
36850: CALL 31125 0 4
36854: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36855: LD_EXP 57
36859: PUSH
36860: LD_VAR 0 1
36864: ARRAY
36865: PUSH
36866: LD_STRING 
36868: EQUAL
36869: NOT
36870: IFFALSE 36926
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36872: LD_EXP 57
36876: PUSH
36877: LD_VAR 0 1
36881: ARRAY
36882: PUSH
36883: LD_INT 1
36885: ARRAY
36886: PPUSH
36887: CALL_OW 257
36891: PUSH
36892: LD_INT 3
36894: EQUAL
36895: IFFALSE 36924
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36897: LD_VAR 0 1
36901: PPUSH
36902: LD_STRING ToFac
36904: PPUSH
36905: LD_EXP 57
36909: PUSH
36910: LD_VAR 0 1
36914: ARRAY
36915: PUSH
36916: LD_INT 1
36918: ARRAY
36919: PPUSH
36920: CALL 14466 0 3
// end else
36924: GO 36952
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36926: LD_ADDR_EXP 57
36930: PUSH
36931: LD_EXP 57
36935: PPUSH
36936: LD_VAR 0 1
36940: PPUSH
36941: LD_INT 1
36943: PPUSH
36944: LD_INT 0
36946: PPUSH
36947: CALL 31125 0 4
36951: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36952: LD_EXP 56
36956: PUSH
36957: LD_VAR 0 1
36961: ARRAY
36962: PUSH
36963: LD_STRING 
36965: EQUAL
36966: NOT
36967: IFFALSE 37023
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36969: LD_EXP 56
36973: PUSH
36974: LD_VAR 0 1
36978: ARRAY
36979: PUSH
36980: LD_INT 1
36982: ARRAY
36983: PPUSH
36984: CALL_OW 257
36988: PUSH
36989: LD_INT 4
36991: EQUAL
36992: IFFALSE 37021
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36994: LD_VAR 0 1
36998: PPUSH
36999: LD_STRING ToLab
37001: PPUSH
37002: LD_EXP 56
37006: PUSH
37007: LD_VAR 0 1
37011: ARRAY
37012: PUSH
37013: LD_INT 1
37015: ARRAY
37016: PPUSH
37017: CALL 14466 0 3
// end else
37021: GO 37049
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
37023: LD_ADDR_EXP 56
37027: PUSH
37028: LD_EXP 56
37032: PPUSH
37033: LD_VAR 0 1
37037: PPUSH
37038: LD_INT 1
37040: PPUSH
37041: LD_INT 0
37043: PPUSH
37044: CALL 31125 0 4
37048: ST_TO_ADDR
// if mode = 0 then
37049: LD_VAR 0 2
37053: PUSH
37054: LD_INT 0
37056: EQUAL
37057: IFFALSE 38895
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
37059: LD_VAR 0 1
37063: PPUSH
37064: LD_INT 30
37066: PUSH
37067: LD_INT 1
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PPUSH
37074: CALL 11587 0 2
37078: PUSH
37079: LD_VAR 0 1
37083: PPUSH
37084: LD_INT 21
37086: PUSH
37087: LD_INT 3
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PPUSH
37094: CALL 11587 0 2
37098: PUSH
37099: LD_INT 1
37101: EQUAL
37102: AND
37103: IFFALSE 37168
// begin if all then
37105: LD_VAR 0 17
37109: IFFALSE 37166
// for i in ( all diff eng ) do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 17
37120: PUSH
37121: LD_VAR 0 14
37125: DIFF
37126: PUSH
37127: FOR_IN
37128: IFFALSE 37164
// if GetTag ( i ) = 0 then
37130: LD_VAR 0 4
37134: PPUSH
37135: CALL_OW 110
37139: PUSH
37140: LD_INT 0
37142: EQUAL
37143: IFFALSE 37162
// MCH_ChangeClass ( side , i , 2 ) ;
37145: LD_VAR 0 1
37149: PPUSH
37150: LD_VAR 0 4
37154: PPUSH
37155: LD_INT 2
37157: PPUSH
37158: CALL 16494 0 3
37162: GO 37127
37164: POP
37165: POP
// end else
37166: GO 37487
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
37168: LD_VAR 0 13
37172: PUSH
37173: LD_EXP 58
37177: PUSH
37178: LD_VAR 0 1
37182: ARRAY
37183: PLUS
37184: PUSH
37185: LD_INT 22
37187: PUSH
37188: LD_VAR 0 1
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 30
37199: PUSH
37200: LD_INT 32
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: PPUSH
37211: CALL_OW 69
37215: LESS
37216: IFFALSE 37241
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
37218: LD_VAR 0 1
37222: PPUSH
37223: LD_VAR 0 14
37227: PUSH
37228: LD_INT 1
37230: ARRAY
37231: PPUSH
37232: LD_INT 1
37234: PPUSH
37235: CALL 16494 0 3
// end else
37239: GO 37487
// if sci < 6 and MCF_Lab ( side ) then
37241: LD_VAR 0 16
37245: PUSH
37246: LD_INT 6
37248: LESS
37249: PUSH
37250: LD_VAR 0 1
37254: PPUSH
37255: CALL 11626 0 1
37259: AND
37260: IFFALSE 37365
// begin if MREG_ToBunker [ side ] then
37262: LD_EXP 70
37266: PUSH
37267: LD_VAR 0 1
37271: ARRAY
37272: IFFALSE 37298
// tmp := sol diff MREG_ToBunker [ side ] else
37274: LD_ADDR_VAR 0 12
37278: PUSH
37279: LD_VAR 0 13
37283: PUSH
37284: LD_EXP 70
37288: PUSH
37289: LD_VAR 0 1
37293: ARRAY
37294: DIFF
37295: ST_TO_ADDR
37296: GO 37308
// tmp := sol ;
37298: LD_ADDR_VAR 0 12
37302: PUSH
37303: LD_VAR 0 13
37307: ST_TO_ADDR
// if tmp then
37308: LD_VAR 0 12
37312: IFFALSE 37363
// for i in tmp do
37314: LD_ADDR_VAR 0 4
37318: PUSH
37319: LD_VAR 0 12
37323: PUSH
37324: FOR_IN
37325: IFFALSE 37361
// if GetTag ( i ) = 0 then
37327: LD_VAR 0 4
37331: PPUSH
37332: CALL_OW 110
37336: PUSH
37337: LD_INT 0
37339: EQUAL
37340: IFFALSE 37359
// MCH_ChangeClass ( side , i , 4 ) ;
37342: LD_VAR 0 1
37346: PPUSH
37347: LD_VAR 0 4
37351: PPUSH
37352: LD_INT 4
37354: PPUSH
37355: CALL 16494 0 3
37359: GO 37324
37361: POP
37362: POP
// end else
37363: GO 37487
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37365: LD_VAR 0 1
37369: PPUSH
37370: LD_INT 30
37372: PUSH
37373: LD_INT 1
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PPUSH
37380: CALL 11587 0 2
37384: IFFALSE 37487
// begin if MREG_ToBunker [ side ] then
37386: LD_EXP 70
37390: PUSH
37391: LD_VAR 0 1
37395: ARRAY
37396: IFFALSE 37422
// tmp := sol diff MREG_ToBunker [ side ] else
37398: LD_ADDR_VAR 0 12
37402: PUSH
37403: LD_VAR 0 13
37407: PUSH
37408: LD_EXP 70
37412: PUSH
37413: LD_VAR 0 1
37417: ARRAY
37418: DIFF
37419: ST_TO_ADDR
37420: GO 37432
// tmp := sol ;
37422: LD_ADDR_VAR 0 12
37426: PUSH
37427: LD_VAR 0 13
37431: ST_TO_ADDR
// if tmp then
37432: LD_VAR 0 12
37436: IFFALSE 37487
// for i in tmp do
37438: LD_ADDR_VAR 0 4
37442: PUSH
37443: LD_VAR 0 12
37447: PUSH
37448: FOR_IN
37449: IFFALSE 37485
// if GetTag ( i ) = 0 then
37451: LD_VAR 0 4
37455: PPUSH
37456: CALL_OW 110
37460: PUSH
37461: LD_INT 0
37463: EQUAL
37464: IFFALSE 37483
// MCH_ChangeClass ( side , i , 2 ) ;
37466: LD_VAR 0 1
37470: PPUSH
37471: LD_VAR 0 4
37475: PPUSH
37476: LD_INT 2
37478: PPUSH
37479: CALL 16494 0 3
37483: GO 37448
37485: POP
37486: POP
// end ; if MCF_Lab ( side ) then
37487: LD_VAR 0 1
37491: PPUSH
37492: CALL 11626 0 1
37496: IFFALSE 38036
// begin if MCL_GetTechList ( side ) then
37498: LD_VAR 0 1
37502: PPUSH
37503: CALL 17970 0 1
37507: IFFALSE 37633
// begin if MREG_ToLab [ side ] then
37509: LD_EXP 56
37513: PUSH
37514: LD_VAR 0 1
37518: ARRAY
37519: IFFALSE 37539
// k := MREG_ToLab [ side ] else
37521: LD_ADDR_VAR 0 8
37525: PUSH
37526: LD_EXP 56
37530: PUSH
37531: LD_VAR 0 1
37535: ARRAY
37536: ST_TO_ADDR
37537: GO 37547
// k := 0 ;
37539: LD_ADDR_VAR 0 8
37543: PUSH
37544: LD_INT 0
37546: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37547: LD_VAR 0 16
37551: PUSH
37552: LD_VAR 0 8
37556: PLUS
37557: PUSH
37558: LD_INT 6
37560: LESSEQUAL
37561: PUSH
37562: LD_VAR 0 17
37566: PUSH
37567: LD_INT 6
37569: GREATER
37570: AND
37571: IFFALSE 37587
// MCH_TrainScientist ( side , 1 ) else
37573: LD_VAR 0 1
37577: PPUSH
37578: LD_INT 1
37580: PPUSH
37581: CALL 16046 0 2
37585: GO 37631
// if all < 6 then
37587: LD_VAR 0 17
37591: PUSH
37592: LD_INT 6
37594: LESS
37595: IFFALSE 37631
// if sci + k < all / 2 then
37597: LD_VAR 0 16
37601: PUSH
37602: LD_VAR 0 8
37606: PLUS
37607: PUSH
37608: LD_VAR 0 17
37612: PUSH
37613: LD_INT 2
37615: DIVREAL
37616: LESS
37617: IFFALSE 37631
// MCH_TrainScientist ( side , 1 ) ;
37619: LD_VAR 0 1
37623: PPUSH
37624: LD_INT 1
37626: PPUSH
37627: CALL 16046 0 2
// end else
37631: GO 37709
// begin if sci > 2 then
37633: LD_VAR 0 16
37637: PUSH
37638: LD_INT 2
37640: GREATER
37641: IFFALSE 37709
// for i = sci downto 2 do
37643: LD_ADDR_VAR 0 4
37647: PUSH
37648: DOUBLE
37649: LD_VAR 0 16
37653: INC
37654: ST_TO_ADDR
37655: LD_INT 2
37657: PUSH
37658: FOR_DOWNTO
37659: IFFALSE 37707
// if GetTag ( sci [ i ] ) = 0 then
37661: LD_VAR 0 16
37665: PUSH
37666: LD_VAR 0 4
37670: ARRAY
37671: PPUSH
37672: CALL_OW 110
37676: PUSH
37677: LD_INT 0
37679: EQUAL
37680: IFFALSE 37705
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37682: LD_VAR 0 1
37686: PPUSH
37687: LD_VAR 0 16
37691: PUSH
37692: LD_VAR 0 4
37696: ARRAY
37697: PPUSH
37698: LD_INT 2
37700: PPUSH
37701: CALL 16494 0 3
37705: GO 37658
37707: POP
37708: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37709: LD_VAR 0 1
37713: PPUSH
37714: CALL 17970 0 1
37718: PUSH
37719: LD_VAR 0 1
37723: PPUSH
37724: CALL 11626 0 1
37728: AND
37729: PUSH
37730: LD_EXP 37
37734: PUSH
37735: LD_VAR 0 1
37739: ARRAY
37740: NOT
37741: AND
37742: IFFALSE 38036
// begin for j = 1 to MCF_Lab ( side ) do
37744: LD_ADDR_VAR 0 5
37748: PUSH
37749: DOUBLE
37750: LD_INT 1
37752: DEC
37753: ST_TO_ADDR
37754: LD_VAR 0 1
37758: PPUSH
37759: CALL 11626 0 1
37763: PUSH
37764: FOR_TO
37765: IFFALSE 37825
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37767: LD_VAR 0 1
37771: PPUSH
37772: CALL 11626 0 1
37776: PUSH
37777: LD_VAR 0 5
37781: ARRAY
37782: PPUSH
37783: CALL_OW 461
37787: PUSH
37788: LD_INT 3
37790: PUSH
37791: LD_INT 6
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: IN
37798: IFFALSE 37823
// begin b := MCF_Lab ( side ) [ j ] ;
37800: LD_ADDR_VAR 0 11
37804: PUSH
37805: LD_VAR 0 1
37809: PPUSH
37810: CALL 11626 0 1
37814: PUSH
37815: LD_VAR 0 5
37819: ARRAY
37820: ST_TO_ADDR
// break ;
37821: GO 37825
// end ;
37823: GO 37764
37825: POP
37826: POP
// if MCF_Class ( side , 4 , [ ] ) then
37827: LD_VAR 0 1
37831: PPUSH
37832: LD_INT 4
37834: PPUSH
37835: EMPTY
37836: PPUSH
37837: CALL 11670 0 3
37841: IFFALSE 38036
// for j in MCF_Class ( side , 4 , [ ] ) do
37843: LD_ADDR_VAR 0 5
37847: PUSH
37848: LD_VAR 0 1
37852: PPUSH
37853: LD_INT 4
37855: PPUSH
37856: EMPTY
37857: PPUSH
37858: CALL 11670 0 3
37862: PUSH
37863: FOR_IN
37864: IFFALSE 38034
// begin if GetTag ( j ) = 0 then
37866: LD_VAR 0 5
37870: PPUSH
37871: CALL_OW 110
37875: PUSH
37876: LD_INT 0
37878: EQUAL
37879: IFFALSE 37970
// begin if IsInUnit ( j ) and b then
37881: LD_VAR 0 5
37885: PPUSH
37886: CALL_OW 310
37890: PUSH
37891: LD_VAR 0 11
37895: AND
37896: IFFALSE 37944
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37898: LD_VAR 0 5
37902: PPUSH
37903: CALL_OW 310
37907: PPUSH
37908: CALL_OW 461
37912: PUSH
37913: LD_INT 2
37915: EQUAL
37916: PUSH
37917: LD_VAR 0 5
37921: PPUSH
37922: CALL_OW 310
37926: PUSH
37927: LD_VAR 0 11
37931: NONEQUAL
37932: AND
37933: IFFALSE 37944
// ComExitBuilding ( j ) ;
37935: LD_VAR 0 5
37939: PPUSH
37940: CALL_OW 122
// if not IsInUnit ( j ) then
37944: LD_VAR 0 5
37948: PPUSH
37949: CALL_OW 310
37953: NOT
37954: IFFALSE 37970
// ComEnterUnit ( j , b ) ;
37956: LD_VAR 0 5
37960: PPUSH
37961: LD_VAR 0 11
37965: PPUSH
37966: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37970: LD_INT 1
37972: PPUSH
37973: LD_VAR 0 5
37977: PPUSH
37978: CALL_OW 255
37982: PPUSH
37983: CALL_OW 321
37987: PUSH
37988: LD_INT 2
37990: EQUAL
37991: PUSH
37992: LD_VAR 0 5
37996: PPUSH
37997: CALL_OW 255
38001: PPUSH
38002: CALL 24988 0 1
38006: PUSH
38007: LD_INT 0
38009: EQUAL
38010: AND
38011: IFFALSE 38032
// MCN_Tame ( GetSide ( j ) , j ) ;
38013: LD_VAR 0 5
38017: PPUSH
38018: CALL_OW 255
38022: PPUSH
38023: LD_VAR 0 5
38027: PPUSH
38028: CALL 18489 0 2
// end ;
38032: GO 37863
38034: POP
38035: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
38036: LD_VAR 0 1
38040: PPUSH
38041: LD_INT 30
38043: PUSH
38044: LD_INT 3
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PPUSH
38051: CALL 11587 0 2
38055: IFFALSE 38314
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
38057: LD_ADDR_VAR 0 11
38061: PUSH
38062: LD_VAR 0 1
38066: PPUSH
38067: LD_INT 30
38069: PUSH
38070: LD_INT 3
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PPUSH
38077: CALL 11587 0 2
38081: PUSH
38082: LD_INT 1
38084: ARRAY
38085: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
38086: LD_ADDR_VAR 0 12
38090: PUSH
38091: LD_VAR 0 1
38095: PPUSH
38096: LD_INT 0
38098: PPUSH
38099: LD_INT 25
38101: PUSH
38102: LD_INT 3
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PPUSH
38109: CALL 12290 0 3
38113: ST_TO_ADDR
// for i = 1 to tmp do
38114: LD_ADDR_VAR 0 4
38118: PUSH
38119: DOUBLE
38120: LD_INT 1
38122: DEC
38123: ST_TO_ADDR
38124: LD_VAR 0 12
38128: PUSH
38129: FOR_TO
38130: IFFALSE 38190
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
38132: LD_VAR 0 12
38136: PUSH
38137: LD_VAR 0 4
38141: ARRAY
38142: PPUSH
38143: CALL_OW 310
38147: NOT
38148: PUSH
38149: LD_VAR 0 12
38153: PUSH
38154: LD_VAR 0 4
38158: ARRAY
38159: PPUSH
38160: CALL_OW 314
38164: NOT
38165: AND
38166: IFFALSE 38188
// ComEnterUnit ( tmp [ i ] , b ) ;
38168: LD_VAR 0 12
38172: PUSH
38173: LD_VAR 0 4
38177: ARRAY
38178: PPUSH
38179: LD_VAR 0 11
38183: PPUSH
38184: CALL_OW 120
38188: GO 38129
38190: POP
38191: POP
// if MREG_ToFac [ side ] then
38192: LD_EXP 57
38196: PUSH
38197: LD_VAR 0 1
38201: ARRAY
38202: IFFALSE 38222
// k := MREG_ToFac [ side ] else
38204: LD_ADDR_VAR 0 8
38208: PUSH
38209: LD_EXP 57
38213: PUSH
38214: LD_VAR 0 1
38218: ARRAY
38219: ST_TO_ADDR
38220: GO 38230
// k := 0 ;
38222: LD_ADDR_VAR 0 8
38226: PUSH
38227: LD_INT 0
38229: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
38230: LD_VAR 0 15
38234: PUSH
38235: LD_VAR 0 8
38239: PLUS
38240: PUSH
38241: LD_INT 6
38243: LESSEQUAL
38244: PUSH
38245: LD_VAR 0 17
38249: PUSH
38250: LD_INT 6
38252: GREATER
38253: AND
38254: IFFALSE 38270
// MCH_TrainMechanic ( side , 1 ) else
38256: LD_VAR 0 1
38260: PPUSH
38261: LD_INT 1
38263: PPUSH
38264: CALL 15788 0 2
38268: GO 38314
// if all < 6 then
38270: LD_VAR 0 17
38274: PUSH
38275: LD_INT 6
38277: LESS
38278: IFFALSE 38314
// if mech + k < all / 2 then
38280: LD_VAR 0 15
38284: PUSH
38285: LD_VAR 0 8
38289: PLUS
38290: PUSH
38291: LD_VAR 0 17
38295: PUSH
38296: LD_INT 2
38298: DIVREAL
38299: LESS
38300: IFFALSE 38314
// MCH_TrainMechanic ( side , 1 ) ;
38302: LD_VAR 0 1
38306: PPUSH
38307: LD_INT 1
38309: PPUSH
38310: CALL 15788 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38314: LD_ADDR_VAR 0 10
38318: PUSH
38319: LD_VAR 0 1
38323: PPUSH
38324: LD_INT 30
38326: PUSH
38327: LD_INT 36
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PPUSH
38334: CALL 11587 0 2
38338: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38339: LD_VAR 0 10
38343: PUSH
38344: LD_VAR 0 15
38348: AND
38349: PUSH
38350: LD_VAR 0 1
38354: PPUSH
38355: LD_INT 3
38357: PPUSH
38358: EMPTY
38359: PPUSH
38360: CALL 11670 0 3
38364: AND
38365: IFFALSE 38523
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38367: LD_VAR 0 1
38371: PPUSH
38372: LD_INT 9
38374: PPUSH
38375: EMPTY
38376: PPUSH
38377: CALL 12290 0 3
38381: PUSH
38382: LD_INT 3
38384: LESS
38385: IFFALSE 38523
// begin if mech < 3 then
38387: LD_VAR 0 15
38391: PUSH
38392: LD_INT 3
38394: LESS
38395: IFFALSE 38409
// k := mech else
38397: LD_ADDR_VAR 0 8
38401: PUSH
38402: LD_VAR 0 15
38406: ST_TO_ADDR
38407: GO 38417
// k := 3 ;
38409: LD_ADDR_VAR 0 8
38413: PUSH
38414: LD_INT 3
38416: ST_TO_ADDR
// for j = 1 to k do
38417: LD_ADDR_VAR 0 5
38421: PUSH
38422: DOUBLE
38423: LD_INT 1
38425: DEC
38426: ST_TO_ADDR
38427: LD_VAR 0 8
38431: PUSH
38432: FOR_TO
38433: IFFALSE 38491
// if GetClass ( mech [ j ] ) = 3 then
38435: LD_VAR 0 15
38439: PUSH
38440: LD_VAR 0 5
38444: ARRAY
38445: PPUSH
38446: CALL_OW 257
38450: PUSH
38451: LD_INT 3
38453: EQUAL
38454: IFFALSE 38489
// begin SetTag ( mech [ j ] , 9 ) ;
38456: LD_VAR 0 15
38460: PUSH
38461: LD_VAR 0 5
38465: ARRAY
38466: PPUSH
38467: LD_INT 9
38469: PPUSH
38470: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38474: LD_VAR 0 15
38478: PUSH
38479: LD_VAR 0 5
38483: ARRAY
38484: PPUSH
38485: CALL_OW 122
// end ;
38489: GO 38432
38491: POP
38492: POP
// if mech < 6 + k then
38493: LD_VAR 0 15
38497: PUSH
38498: LD_INT 6
38500: PUSH
38501: LD_VAR 0 8
38505: PLUS
38506: LESS
38507: IFFALSE 38523
// MCH_TrainMechanic ( side , k ) ;
38509: LD_VAR 0 1
38513: PPUSH
38514: LD_VAR 0 8
38518: PPUSH
38519: CALL 15788 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38523: LD_VAR 0 1
38527: PPUSH
38528: LD_INT 9
38530: PPUSH
38531: EMPTY
38532: PPUSH
38533: CALL 12290 0 3
38537: IFFALSE 38628
// for j in MCF_Tag ( side , 9 , [ ] ) do
38539: LD_ADDR_VAR 0 5
38543: PUSH
38544: LD_VAR 0 1
38548: PPUSH
38549: LD_INT 9
38551: PPUSH
38552: EMPTY
38553: PPUSH
38554: CALL 12290 0 3
38558: PUSH
38559: FOR_IN
38560: IFFALSE 38626
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38562: LD_VAR 0 5
38566: PPUSH
38567: CALL_OW 310
38571: NOT
38572: PUSH
38573: LD_VAR 0 5
38577: PPUSH
38578: CALL 31768 0 1
38582: NOT
38583: AND
38584: IFFALSE 38624
// if ct then
38586: LD_VAR 0 10
38590: IFFALSE 38612
// ComEnterUnit ( j , ct [ 1 ] ) else
38592: LD_VAR 0 5
38596: PPUSH
38597: LD_VAR 0 10
38601: PUSH
38602: LD_INT 1
38604: ARRAY
38605: PPUSH
38606: CALL_OW 120
38610: GO 38624
// SetTag ( j , 0 ) ;
38612: LD_VAR 0 5
38616: PPUSH
38617: LD_INT 0
38619: PPUSH
38620: CALL_OW 109
38624: GO 38559
38626: POP
38627: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38628: LD_INT 1
38630: PPUSH
38631: LD_VAR 0 1
38635: PPUSH
38636: CALL_OW 321
38640: PUSH
38641: LD_INT 2
38643: EQUAL
38644: PUSH
38645: LD_EXP 37
38649: PUSH
38650: LD_VAR 0 1
38654: ARRAY
38655: NOT
38656: AND
38657: PUSH
38658: LD_VAR 0 1
38662: PPUSH
38663: LD_INT 4
38665: PPUSH
38666: EMPTY
38667: PPUSH
38668: CALL 11670 0 3
38672: AND
38673: IFFALSE 38721
// for j in MCF_Class ( side , 4 , [ ] ) do
38675: LD_ADDR_VAR 0 5
38679: PUSH
38680: LD_VAR 0 1
38684: PPUSH
38685: LD_INT 4
38687: PPUSH
38688: EMPTY
38689: PPUSH
38690: CALL 11670 0 3
38694: PUSH
38695: FOR_IN
38696: IFFALSE 38719
// MCN_Tame ( GetSide ( j ) , j ) ;
38698: LD_VAR 0 5
38702: PPUSH
38703: CALL_OW 255
38707: PPUSH
38708: LD_VAR 0 5
38712: PPUSH
38713: CALL 18489 0 2
38717: GO 38695
38719: POP
38720: POP
// if MREG_DefVeh [ side ] then
38721: LD_EXP 69
38725: PUSH
38726: LD_VAR 0 1
38730: ARRAY
38731: IFFALSE 38895
// begin for i in MREG_DefVeh [ side ] do
38733: LD_ADDR_VAR 0 4
38737: PUSH
38738: LD_EXP 69
38742: PUSH
38743: LD_VAR 0 1
38747: ARRAY
38748: PUSH
38749: FOR_IN
38750: IFFALSE 38803
// begin SetTag ( i , 0 ) ;
38752: LD_VAR 0 4
38756: PPUSH
38757: LD_INT 0
38759: PPUSH
38760: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38764: LD_VAR 0 4
38768: PPUSH
38769: LD_EXP 66
38773: PUSH
38774: LD_VAR 0 1
38778: ARRAY
38779: PPUSH
38780: CALL_OW 308
38784: NOT
38785: IFFALSE 38801
// MCV_Parking ( side , i ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: CALL 25748 0 2
// end ;
38801: GO 38749
38803: POP
38804: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38805: LD_VAR 0 1
38809: PPUSH
38810: LD_INT 36
38812: PPUSH
38813: EMPTY
38814: PPUSH
38815: CALL 12290 0 3
38819: IFFALSE 38860
// for i in MCF_Tag ( side , 36 , [ ] ) do
38821: LD_ADDR_VAR 0 4
38825: PUSH
38826: LD_VAR 0 1
38830: PPUSH
38831: LD_INT 36
38833: PPUSH
38834: EMPTY
38835: PPUSH
38836: CALL 12290 0 3
38840: PUSH
38841: FOR_IN
38842: IFFALSE 38858
// SetTag ( i , 0 ) ;
38844: LD_VAR 0 4
38848: PPUSH
38849: LD_INT 0
38851: PPUSH
38852: CALL_OW 109
38856: GO 38841
38858: POP
38859: POP
// if MREG_DefMobActive [ side ] then
38860: LD_EXP 72
38864: PUSH
38865: LD_VAR 0 1
38869: ARRAY
38870: IFFALSE 38895
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38872: LD_ADDR_EXP 72
38876: PUSH
38877: LD_EXP 72
38881: PPUSH
38882: LD_VAR 0 1
38886: PPUSH
38887: LD_INT 0
38889: PPUSH
38890: CALL_OW 1
38894: ST_TO_ADDR
// end ; end ; if mode > 0 then
38895: LD_VAR 0 2
38899: PUSH
38900: LD_INT 0
38902: GREATER
38903: IFFALSE 40918
// begin if tick <= 15 15$00 then
38905: LD_OWVAR 1
38909: PUSH
38910: LD_INT 31500
38912: LESSEQUAL
38913: IFFALSE 39337
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38915: LD_VAR 0 13
38919: PUSH
38920: LD_INT 4
38922: GREATER
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: CALL 24988 0 1
38933: PUSH
38934: LD_INT 4
38936: LESS
38937: AND
38938: IFFALSE 39049
// for i in sol do
38940: LD_ADDR_VAR 0 4
38944: PUSH
38945: LD_VAR 0 13
38949: PUSH
38950: FOR_IN
38951: IFFALSE 39047
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38953: LD_ADDR_VAR 0 8
38957: PUSH
38958: LD_VAR 0 1
38962: PPUSH
38963: CALL 24988 0 1
38967: PPUSH
38968: LD_VAR 0 4
38972: PPUSH
38973: CALL_OW 74
38977: ST_TO_ADDR
// if IsInUnit ( i ) then
38978: LD_VAR 0 4
38982: PPUSH
38983: CALL_OW 310
38987: IFFALSE 38998
// ComExitBuilding ( i ) ;
38989: LD_VAR 0 4
38993: PPUSH
38994: CALL_OW 122
// if not HasTask ( i ) and k then
38998: LD_VAR 0 4
39002: PPUSH
39003: CALL_OW 314
39007: NOT
39008: PUSH
39009: LD_VAR 0 8
39013: AND
39014: IFFALSE 39045
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
39016: LD_VAR 0 4
39020: PPUSH
39021: LD_VAR 0 8
39025: PPUSH
39026: CALL_OW 250
39030: PPUSH
39031: LD_VAR 0 8
39035: PPUSH
39036: CALL_OW 251
39040: PPUSH
39041: CALL_OW 114
// end ;
39045: GO 38950
39047: POP
39048: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39049: LD_VAR 0 1
39053: PPUSH
39054: LD_INT 30
39056: PUSH
39057: LD_INT 5
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PPUSH
39064: CALL 11587 0 2
39068: IFFALSE 39335
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39070: LD_ADDR_VAR 0 11
39074: PUSH
39075: LD_VAR 0 1
39079: PPUSH
39080: LD_INT 30
39082: PUSH
39083: LD_INT 5
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PPUSH
39090: CALL 11587 0 2
39094: PUSH
39095: LD_INT 1
39097: ARRAY
39098: ST_TO_ADDR
// if mech then
39099: LD_VAR 0 15
39103: IFFALSE 39139
// for i in mech do
39105: LD_ADDR_VAR 0 4
39109: PUSH
39110: LD_VAR 0 15
39114: PUSH
39115: FOR_IN
39116: IFFALSE 39137
// MCH_ChangeClass ( side , i , 1 ) ;
39118: LD_VAR 0 1
39122: PPUSH
39123: LD_VAR 0 4
39127: PPUSH
39128: LD_INT 1
39130: PPUSH
39131: CALL 16494 0 3
39135: GO 39115
39137: POP
39138: POP
// if eng > 1 then
39139: LD_VAR 0 14
39143: PUSH
39144: LD_INT 1
39146: GREATER
39147: IFFALSE 39194
// for i = eng downto 2 do
39149: LD_ADDR_VAR 0 4
39153: PUSH
39154: DOUBLE
39155: LD_VAR 0 14
39159: INC
39160: ST_TO_ADDR
39161: LD_INT 2
39163: PUSH
39164: FOR_DOWNTO
39165: IFFALSE 39192
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39167: LD_VAR 0 1
39171: PPUSH
39172: LD_VAR 0 14
39176: PUSH
39177: LD_VAR 0 4
39181: ARRAY
39182: PPUSH
39183: LD_INT 1
39185: PPUSH
39186: CALL 16494 0 3
39190: GO 39164
39192: POP
39193: POP
// if UnitsInside ( b ) = 6 then
39194: LD_VAR 0 11
39198: PPUSH
39199: CALL_OW 313
39203: PUSH
39204: LD_INT 6
39206: EQUAL
39207: IFFALSE 39335
// begin un := UnitsInside ( b ) [ 1 ] ;
39209: LD_ADDR_VAR 0 9
39213: PUSH
39214: LD_VAR 0 11
39218: PPUSH
39219: CALL_OW 313
39223: PUSH
39224: LD_INT 1
39226: ARRAY
39227: ST_TO_ADDR
// ComExitBuilding ( un ) ;
39228: LD_VAR 0 9
39232: PPUSH
39233: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
39237: LD_VAR 0 1
39241: PPUSH
39242: LD_INT 30
39244: PUSH
39245: LD_INT 5
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PPUSH
39252: CALL 11587 0 2
39256: PUSH
39257: LD_INT 1
39259: GREATER
39260: PUSH
39261: LD_VAR 0 1
39265: PPUSH
39266: CALL 24988 0 1
39270: PUSH
39271: LD_INT 4
39273: GREATEREQUAL
39274: AND
39275: IFFALSE 39335
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39277: LD_ADDR_VAR 0 8
39281: PUSH
39282: LD_VAR 0 1
39286: PPUSH
39287: LD_INT 30
39289: PUSH
39290: LD_INT 5
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PPUSH
39297: CALL 11587 0 2
39301: PUSH
39302: LD_INT 2
39304: ARRAY
39305: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39306: LD_VAR 0 8
39310: PPUSH
39311: CALL_OW 313
39315: PUSH
39316: LD_INT 6
39318: LESS
39319: IFFALSE 39335
// AddComEnterUnit ( un , k ) ;
39321: LD_VAR 0 9
39325: PPUSH
39326: LD_VAR 0 8
39330: PPUSH
39331: CALL_OW 180
// end ; end ; end ; end else
39335: GO 40918
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39337: LD_VAR 0 1
39341: PPUSH
39342: LD_INT 1
39344: PPUSH
39345: LD_EXP 67
39349: PUSH
39350: LD_VAR 0 1
39354: ARRAY
39355: PUSH
39356: LD_INT 1
39358: ARRAY
39359: PPUSH
39360: CALL 34070 0 3
39364: IFFALSE 39503
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39366: LD_ADDR_VAR 0 12
39370: PUSH
39371: LD_VAR 0 1
39375: PPUSH
39376: LD_INT 21
39378: PUSH
39379: LD_INT 1
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PPUSH
39386: CALL 11587 0 2
39390: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39391: LD_ADDR_VAR 0 11
39395: PUSH
39396: LD_VAR 0 1
39400: PPUSH
39401: LD_INT 30
39403: PUSH
39404: LD_INT 1
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PPUSH
39411: CALL 11587 0 2
39415: ST_TO_ADDR
// if b then
39416: LD_VAR 0 11
39420: IFFALSE 39503
// for i in tmp do
39422: LD_ADDR_VAR 0 4
39426: PUSH
39427: LD_VAR 0 12
39431: PUSH
39432: FOR_IN
39433: IFFALSE 39501
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39435: LD_VAR 0 4
39439: PPUSH
39440: LD_EXP 67
39444: PUSH
39445: LD_VAR 0 1
39449: ARRAY
39450: PUSH
39451: LD_INT 1
39453: ARRAY
39454: PPUSH
39455: CALL_OW 308
39459: NOT
39460: IFFALSE 39499
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39462: LD_VAR 0 4
39466: PPUSH
39467: LD_VAR 0 11
39471: PUSH
39472: LD_INT 1
39474: ARRAY
39475: PPUSH
39476: CALL_OW 250
39480: PPUSH
39481: LD_VAR 0 11
39485: PUSH
39486: LD_INT 1
39488: ARRAY
39489: PPUSH
39490: CALL_OW 251
39494: PPUSH
39495: CALL_OW 111
39499: GO 39432
39501: POP
39502: POP
// end ; if MREG_DefVeh [ side ] then
39503: LD_EXP 69
39507: PUSH
39508: LD_VAR 0 1
39512: ARRAY
39513: IFFALSE 40081
// begin tmp := [ ] ;
39515: LD_ADDR_VAR 0 12
39519: PUSH
39520: EMPTY
39521: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39522: LD_EXP 72
39526: PUSH
39527: LD_VAR 0 1
39531: ARRAY
39532: PUSH
39533: LD_INT 0
39535: EQUAL
39536: IFFALSE 39676
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39538: LD_ADDR_VAR 0 8
39542: PUSH
39543: LD_VAR 0 1
39547: PPUSH
39548: LD_INT 0
39550: PPUSH
39551: LD_INT 25
39553: PUSH
39554: LD_INT 3
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PPUSH
39561: CALL 12290 0 3
39565: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39566: LD_VAR 0 8
39570: PUSH
39571: LD_EXP 69
39575: PUSH
39576: LD_VAR 0 1
39580: ARRAY
39581: GREATER
39582: IFFALSE 39643
// begin for i = 1 to MREG_DefVeh [ side ] do
39584: LD_ADDR_VAR 0 4
39588: PUSH
39589: DOUBLE
39590: LD_INT 1
39592: DEC
39593: ST_TO_ADDR
39594: LD_EXP 69
39598: PUSH
39599: LD_VAR 0 1
39603: ARRAY
39604: PUSH
39605: FOR_TO
39606: IFFALSE 39639
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39608: LD_ADDR_VAR 0 12
39612: PUSH
39613: LD_VAR 0 12
39617: PPUSH
39618: LD_INT 1
39620: PPUSH
39621: LD_VAR 0 8
39625: PUSH
39626: LD_VAR 0 4
39630: ARRAY
39631: PPUSH
39632: CALL_OW 2
39636: ST_TO_ADDR
39637: GO 39605
39639: POP
39640: POP
// end else
39641: GO 39653
// tmp := k ;
39643: LD_ADDR_VAR 0 12
39647: PUSH
39648: LD_VAR 0 8
39652: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39653: LD_ADDR_EXP 72
39657: PUSH
39658: LD_EXP 72
39662: PPUSH
39663: LD_VAR 0 1
39667: PPUSH
39668: LD_INT 1
39670: PPUSH
39671: CALL_OW 1
39675: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39676: LD_ADDR_VAR 0 4
39680: PUSH
39681: LD_EXP 69
39685: PUSH
39686: LD_VAR 0 1
39690: ARRAY
39691: PUSH
39692: FOR_IN
39693: IFFALSE 40079
// begin if not GetDriver ( i ) then
39695: LD_VAR 0 4
39699: PPUSH
39700: CALL 31819 0 1
39704: NOT
39705: IFFALSE 39780
// begin if tmp then
39707: LD_VAR 0 12
39711: IFFALSE 39778
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39713: LD_VAR 0 12
39717: PUSH
39718: LD_INT 1
39720: ARRAY
39721: PPUSH
39722: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39726: LD_VAR 0 12
39730: PUSH
39731: LD_INT 1
39733: ARRAY
39734: PPUSH
39735: LD_VAR 0 4
39739: PPUSH
39740: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39744: LD_VAR 0 12
39748: PUSH
39749: LD_INT 1
39751: ARRAY
39752: PPUSH
39753: LD_INT 36
39755: PPUSH
39756: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39760: LD_ADDR_VAR 0 12
39764: PUSH
39765: LD_VAR 0 12
39769: PPUSH
39770: LD_INT 1
39772: PPUSH
39773: CALL_OW 3
39777: ST_TO_ADDR
// end ; end else
39778: GO 40077
// begin if GetTag ( i ) = 0 then
39780: LD_VAR 0 4
39784: PPUSH
39785: CALL_OW 110
39789: PUSH
39790: LD_INT 0
39792: EQUAL
39793: IFFALSE 39809
// SetTag ( i , 31 ) else
39795: LD_VAR 0 4
39799: PPUSH
39800: LD_INT 31
39802: PPUSH
39803: CALL_OW 109
39807: GO 40077
// if GetTag ( i ) = 31 then
39809: LD_VAR 0 4
39813: PPUSH
39814: CALL_OW 110
39818: PUSH
39819: LD_INT 31
39821: EQUAL
39822: IFFALSE 40077
// begin if GetFuel ( i ) < 20 then
39824: LD_VAR 0 4
39828: PPUSH
39829: CALL_OW 261
39833: PUSH
39834: LD_INT 20
39836: LESS
39837: IFFALSE 39862
// begin SetTag ( i , 21 ) ;
39839: LD_VAR 0 4
39843: PPUSH
39844: LD_INT 21
39846: PPUSH
39847: CALL_OW 109
// MCV_Refuel ( i ) ;
39851: LD_VAR 0 4
39855: PPUSH
39856: CALL 26285 0 1
// continue ;
39860: GO 39692
// end ; if GetLives ( i ) < 700 then
39862: LD_VAR 0 4
39866: PPUSH
39867: CALL_OW 256
39871: PUSH
39872: LD_INT 700
39874: LESS
39875: IFFALSE 39987
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39877: LD_VAR 0 4
39881: PPUSH
39882: LD_EXP 60
39886: PUSH
39887: LD_VAR 0 1
39891: ARRAY
39892: PPUSH
39893: CALL_OW 308
39897: NOT
39898: IFFALSE 39922
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39900: LD_VAR 0 4
39904: PPUSH
39905: LD_EXP 60
39909: PUSH
39910: LD_VAR 0 1
39914: ARRAY
39915: PPUSH
39916: CALL_OW 113
39920: GO 39985
// if GetDriver ( i ) then
39922: LD_VAR 0 4
39926: PPUSH
39927: CALL 31819 0 1
39931: IFFALSE 39985
// begin k := GetDriver ( i ) ;
39933: LD_ADDR_VAR 0 8
39937: PUSH
39938: LD_VAR 0 4
39942: PPUSH
39943: CALL 31819 0 1
39947: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39948: LD_VAR 0 8
39952: PPUSH
39953: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39957: LD_VAR 0 8
39961: PPUSH
39962: LD_VAR 0 4
39966: PPUSH
39967: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39971: LD_VAR 0 8
39975: PPUSH
39976: LD_VAR 0 4
39980: PPUSH
39981: CALL_OW 180
// end ; end else
39985: GO 40077
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39987: LD_ADDR_VAR 0 8
39991: PUSH
39992: LD_VAR 0 1
39996: PPUSH
39997: CALL 24988 0 1
40001: PPUSH
40002: LD_VAR 0 4
40006: PPUSH
40007: CALL_OW 74
40011: ST_TO_ADDR
// if k then
40012: LD_VAR 0 8
40016: IFFALSE 40034
// ComAttackUnit ( i , k ) else
40018: LD_VAR 0 4
40022: PPUSH
40023: LD_VAR 0 8
40027: PPUSH
40028: CALL_OW 115
40032: GO 40077
// if not IsInArea ( i , MREG_Parking [ side ] ) then
40034: LD_VAR 0 4
40038: PPUSH
40039: LD_EXP 60
40043: PUSH
40044: LD_VAR 0 1
40048: ARRAY
40049: PPUSH
40050: CALL_OW 308
40054: NOT
40055: IFFALSE 40077
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
40057: LD_VAR 0 4
40061: PPUSH
40062: LD_EXP 60
40066: PUSH
40067: LD_VAR 0 1
40071: ARRAY
40072: PPUSH
40073: CALL_OW 113
// end ; end ; end ; end ;
40077: GO 39692
40079: POP
40080: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
40081: LD_VAR 0 1
40085: PPUSH
40086: LD_INT 30
40088: PUSH
40089: LD_INT 5
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PPUSH
40096: CALL 11587 0 2
40100: IFFALSE 40918
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
40102: LD_ADDR_VAR 0 11
40106: PUSH
40107: LD_VAR 0 1
40111: PPUSH
40112: LD_INT 30
40114: PUSH
40115: LD_INT 5
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PPUSH
40122: CALL 11587 0 2
40126: PUSH
40127: LD_INT 1
40129: ARRAY
40130: ST_TO_ADDR
// if eng > 1 then
40131: LD_VAR 0 14
40135: PUSH
40136: LD_INT 1
40138: GREATER
40139: IFFALSE 40186
// for i = eng downto 2 do
40141: LD_ADDR_VAR 0 4
40145: PUSH
40146: DOUBLE
40147: LD_VAR 0 14
40151: INC
40152: ST_TO_ADDR
40153: LD_INT 2
40155: PUSH
40156: FOR_DOWNTO
40157: IFFALSE 40184
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
40159: LD_VAR 0 1
40163: PPUSH
40164: LD_VAR 0 14
40168: PUSH
40169: LD_VAR 0 4
40173: ARRAY
40174: PPUSH
40175: LD_INT 1
40177: PPUSH
40178: CALL 16494 0 3
40182: GO 40156
40184: POP
40185: POP
// if sci > 1 then
40186: LD_VAR 0 16
40190: PUSH
40191: LD_INT 1
40193: GREATER
40194: IFFALSE 40241
// for i = sci downto 2 do
40196: LD_ADDR_VAR 0 4
40200: PUSH
40201: DOUBLE
40202: LD_VAR 0 16
40206: INC
40207: ST_TO_ADDR
40208: LD_INT 2
40210: PUSH
40211: FOR_DOWNTO
40212: IFFALSE 40239
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
40214: LD_VAR 0 1
40218: PPUSH
40219: LD_VAR 0 16
40223: PUSH
40224: LD_VAR 0 4
40228: ARRAY
40229: PPUSH
40230: LD_INT 1
40232: PPUSH
40233: CALL 16494 0 3
40237: GO 40211
40239: POP
40240: POP
// if sol then
40241: LD_VAR 0 13
40245: IFFALSE 40918
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
40247: LD_VAR 0 13
40251: PUSH
40252: LD_EXP 70
40256: PUSH
40257: LD_VAR 0 1
40261: ARRAY
40262: DIFF
40263: PUSH
40264: LD_INT 22
40266: PUSH
40267: LD_VAR 0 1
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 58
40278: PUSH
40279: EMPTY
40280: LIST
40281: PUSH
40282: LD_INT 2
40284: PUSH
40285: LD_INT 30
40287: PUSH
40288: LD_INT 32
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 30
40297: PUSH
40298: LD_INT 31
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: LIST
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: LIST
40314: PPUSH
40315: CALL_OW 69
40319: PUSH
40320: LD_INT 0
40322: EQUAL
40323: AND
40324: IFFALSE 40918
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40326: LD_ADDR_VAR 0 12
40330: PUSH
40331: LD_VAR 0 13
40335: PUSH
40336: LD_EXP 70
40340: PUSH
40341: LD_VAR 0 1
40345: ARRAY
40346: DIFF
40347: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40348: LD_VAR 0 1
40352: PPUSH
40353: LD_INT 30
40355: PUSH
40356: LD_INT 5
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PPUSH
40363: CALL 11587 0 2
40367: PUSH
40368: LD_INT 1
40370: GREATER
40371: IFFALSE 40402
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40373: LD_ADDR_VAR 0 8
40377: PUSH
40378: LD_VAR 0 1
40382: PPUSH
40383: LD_INT 30
40385: PUSH
40386: LD_INT 5
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PPUSH
40393: CALL 11587 0 2
40397: PUSH
40398: LD_INT 2
40400: ARRAY
40401: ST_TO_ADDR
// for j in tmp do
40402: LD_ADDR_VAR 0 5
40406: PUSH
40407: LD_VAR 0 12
40411: PUSH
40412: FOR_IN
40413: IFFALSE 40916
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40415: LD_VAR 0 5
40419: PUSH
40420: LD_VAR 0 11
40424: PPUSH
40425: CALL_OW 313
40429: IN
40430: PUSH
40431: LD_VAR 0 11
40435: PPUSH
40436: CALL_OW 313
40440: PUSH
40441: LD_INT 6
40443: EQUAL
40444: AND
40445: PUSH
40446: LD_VAR 0 8
40450: AND
40451: PUSH
40452: LD_VAR 0 8
40456: PPUSH
40457: CALL_OW 313
40461: PUSH
40462: LD_INT 6
40464: LESS
40465: AND
40466: IFFALSE 40493
// begin ComExitBuilding ( j ) ;
40468: LD_VAR 0 5
40472: PPUSH
40473: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40477: LD_VAR 0 5
40481: PPUSH
40482: LD_VAR 0 8
40486: PPUSH
40487: CALL_OW 180
// continue ;
40491: GO 40412
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40493: LD_VAR 0 5
40497: PPUSH
40498: CALL_OW 314
40502: NOT
40503: PUSH
40504: LD_VAR 0 5
40508: PPUSH
40509: CALL_OW 110
40513: PUSH
40514: LD_INT 0
40516: EQUAL
40517: AND
40518: PUSH
40519: LD_VAR 0 5
40523: PPUSH
40524: CALL_OW 310
40528: NOT
40529: AND
40530: IFFALSE 40636
// begin if k then
40532: LD_VAR 0 8
40536: IFFALSE 40607
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40538: LD_VAR 0 8
40542: PPUSH
40543: CALL_OW 313
40547: PUSH
40548: LD_VAR 0 11
40552: PPUSH
40553: CALL_OW 313
40557: LESS
40558: IFFALSE 40576
// ComEnterUnit ( j , k ) else
40560: LD_VAR 0 5
40564: PPUSH
40565: LD_VAR 0 8
40569: PPUSH
40570: CALL_OW 120
40574: GO 40605
// if UnitsInside ( b ) < 6 then
40576: LD_VAR 0 11
40580: PPUSH
40581: CALL_OW 313
40585: PUSH
40586: LD_INT 6
40588: LESS
40589: IFFALSE 40605
// ComEnterUnit ( j , b ) ;
40591: LD_VAR 0 5
40595: PPUSH
40596: LD_VAR 0 11
40600: PPUSH
40601: CALL_OW 120
// end else
40605: GO 40636
// if UnitsInside ( b ) < 6 then
40607: LD_VAR 0 11
40611: PPUSH
40612: CALL_OW 313
40616: PUSH
40617: LD_INT 6
40619: LESS
40620: IFFALSE 40636
// ComEnterUnit ( j , b ) ;
40622: LD_VAR 0 5
40626: PPUSH
40627: LD_VAR 0 11
40631: PPUSH
40632: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40636: LD_VAR 0 5
40640: PUSH
40641: LD_VAR 0 1
40645: PPUSH
40646: LD_INT 54
40648: PUSH
40649: EMPTY
40650: LIST
40651: PPUSH
40652: CALL 11587 0 2
40656: IN
40657: PUSH
40658: LD_VAR 0 5
40662: PPUSH
40663: CALL_OW 257
40667: PUSH
40668: LD_INT 1
40670: EQUAL
40671: AND
40672: IFFALSE 40914
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40674: LD_EXP 64
40678: PUSH
40679: LD_VAR 0 1
40683: ARRAY
40684: PUSH
40685: LD_INT 1
40687: ARRAY
40688: PUSH
40689: LD_INT 12
40691: PPUSH
40692: LD_VAR 0 1
40696: PPUSH
40697: CALL_OW 321
40701: PUSH
40702: LD_INT 2
40704: EQUAL
40705: AND
40706: IFFALSE 40754
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40708: LD_VAR 0 1
40712: PPUSH
40713: LD_INT 5
40715: PPUSH
40716: EMPTY
40717: PPUSH
40718: CALL 11670 0 3
40722: PUSH
40723: LD_EXP 64
40727: PUSH
40728: LD_VAR 0 1
40732: ARRAY
40733: PUSH
40734: LD_INT 1
40736: ARRAY
40737: LESS
40738: IFFALSE 40754
// begin SetClass ( j , class_sniper ) ;
40740: LD_VAR 0 5
40744: PPUSH
40745: LD_INT 5
40747: PPUSH
40748: CALL_OW 336
// continue ;
40752: GO 40412
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40754: LD_EXP 64
40758: PUSH
40759: LD_VAR 0 1
40763: ARRAY
40764: PUSH
40765: LD_INT 2
40767: ARRAY
40768: PUSH
40769: LD_INT 41
40771: PPUSH
40772: LD_VAR 0 1
40776: PPUSH
40777: CALL_OW 321
40781: PUSH
40782: LD_INT 2
40784: EQUAL
40785: AND
40786: IFFALSE 40834
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40788: LD_VAR 0 1
40792: PPUSH
40793: LD_INT 8
40795: PPUSH
40796: EMPTY
40797: PPUSH
40798: CALL 11670 0 3
40802: PUSH
40803: LD_EXP 64
40807: PUSH
40808: LD_VAR 0 1
40812: ARRAY
40813: PUSH
40814: LD_INT 2
40816: ARRAY
40817: LESS
40818: IFFALSE 40834
// begin SetClass ( j , class_mortar ) ;
40820: LD_VAR 0 5
40824: PPUSH
40825: LD_INT 8
40827: PPUSH
40828: CALL_OW 336
// continue ;
40832: GO 40412
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40834: LD_EXP 64
40838: PUSH
40839: LD_VAR 0 1
40843: ARRAY
40844: PUSH
40845: LD_INT 3
40847: ARRAY
40848: PUSH
40849: LD_INT 44
40851: PPUSH
40852: LD_VAR 0 1
40856: PPUSH
40857: CALL_OW 321
40861: PUSH
40862: LD_INT 2
40864: EQUAL
40865: AND
40866: IFFALSE 40914
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40868: LD_VAR 0 1
40872: PPUSH
40873: LD_INT 9
40875: PPUSH
40876: EMPTY
40877: PPUSH
40878: CALL 11670 0 3
40882: PUSH
40883: LD_EXP 64
40887: PUSH
40888: LD_VAR 0 1
40892: ARRAY
40893: PUSH
40894: LD_INT 3
40896: ARRAY
40897: LESS
40898: IFFALSE 40914
// begin SetClass ( j , class_bazooker ) ;
40900: LD_VAR 0 5
40904: PPUSH
40905: LD_INT 9
40907: PPUSH
40908: CALL_OW 336
// continue ;
40912: GO 40412
// end ; end ; end ;
40914: GO 40412
40916: POP
40917: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40918: LD_INT 22
40920: PUSH
40921: LD_VAR 0 1
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 58
40932: PUSH
40933: EMPTY
40934: LIST
40935: PUSH
40936: LD_INT 30
40938: PUSH
40939: LD_INT 32
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: LIST
40950: PPUSH
40951: CALL_OW 69
40955: IFFALSE 41105
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40957: LD_ADDR_VAR 0 12
40961: PUSH
40962: LD_INT 22
40964: PUSH
40965: LD_VAR 0 1
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 58
40976: PUSH
40977: EMPTY
40978: LIST
40979: PUSH
40980: LD_INT 30
40982: PUSH
40983: LD_INT 32
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: LIST
40994: PPUSH
40995: CALL_OW 69
40999: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
41000: LD_ADDR_VAR 0 8
41004: PUSH
41005: LD_VAR 0 13
41009: PUSH
41010: LD_EXP 70
41014: PUSH
41015: LD_VAR 0 1
41019: ARRAY
41020: DIFF
41021: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
41022: LD_VAR 0 12
41026: PUSH
41027: LD_INT 1
41029: ARRAY
41030: PPUSH
41031: CALL_OW 461
41035: PUSH
41036: LD_INT 2
41038: EQUAL
41039: PUSH
41040: LD_VAR 0 12
41044: PUSH
41045: LD_INT 1
41047: ARRAY
41048: PUSH
41049: LD_EXP 70
41053: PUSH
41054: LD_VAR 0 1
41058: ARRAY
41059: IN
41060: NOT
41061: AND
41062: PUSH
41063: LD_VAR 0 8
41067: AND
41068: IFFALSE 41105
// begin ComExitBuilding ( k [ 1 ] ) ;
41070: LD_VAR 0 8
41074: PUSH
41075: LD_INT 1
41077: ARRAY
41078: PPUSH
41079: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
41083: LD_VAR 0 8
41087: PUSH
41088: LD_INT 1
41090: ARRAY
41091: PPUSH
41092: LD_VAR 0 12
41096: PUSH
41097: LD_INT 1
41099: ARRAY
41100: PPUSH
41101: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
41105: LD_EXP 37
41109: PUSH
41110: LD_VAR 0 1
41114: ARRAY
41115: IFFALSE 41263
// begin if MCF_Class ( side , 4 , [ ] ) then
41117: LD_VAR 0 1
41121: PPUSH
41122: LD_INT 4
41124: PPUSH
41125: EMPTY
41126: PPUSH
41127: CALL 11670 0 3
41131: IFFALSE 41261
// for j in MCF_Class ( side , 4 , [ ] ) do
41133: LD_ADDR_VAR 0 5
41137: PUSH
41138: LD_VAR 0 1
41142: PPUSH
41143: LD_INT 4
41145: PPUSH
41146: EMPTY
41147: PPUSH
41148: CALL 11670 0 3
41152: PUSH
41153: FOR_IN
41154: IFFALSE 41259
// begin if not GetTag ( j ) = 4 then
41156: LD_VAR 0 5
41160: PPUSH
41161: CALL_OW 110
41165: PUSH
41166: LD_INT 4
41168: EQUAL
41169: NOT
41170: IFFALSE 41206
// begin SetTag ( j , 4 ) ;
41172: LD_VAR 0 5
41176: PPUSH
41177: LD_INT 4
41179: PPUSH
41180: CALL_OW 109
// if IsInUnit ( j ) then
41184: LD_VAR 0 5
41188: PPUSH
41189: CALL_OW 310
41193: IFFALSE 41204
// ComExitBuilding ( j ) ;
41195: LD_VAR 0 5
41199: PPUSH
41200: CALL_OW 122
// end else
41204: GO 41257
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
41206: LD_VAR 0 5
41210: PPUSH
41211: LD_EXP 37
41215: PUSH
41216: LD_VAR 0 1
41220: ARRAY
41221: PUSH
41222: LD_INT 1
41224: ARRAY
41225: PPUSH
41226: CALL 32510 0 2
41230: NOT
41231: IFFALSE 41257
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
41233: LD_VAR 0 5
41237: PPUSH
41238: LD_EXP 37
41242: PUSH
41243: LD_VAR 0 1
41247: ARRAY
41248: PUSH
41249: LD_INT 1
41251: ARRAY
41252: PPUSH
41253: CALL 19157 0 2
// end ;
41257: GO 41153
41259: POP
41260: POP
// end else
41261: GO 41495
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
41263: LD_VAR 0 1
41267: PPUSH
41268: LD_INT 4
41270: PPUSH
41271: EMPTY
41272: PPUSH
41273: CALL 11670 0 3
41277: PUSH
41278: LD_VAR 0 1
41282: PPUSH
41283: LD_INT 4
41285: PPUSH
41286: EMPTY
41287: PPUSH
41288: CALL 12290 0 3
41292: AND
41293: IFFALSE 41495
// for j in MCF_Class ( side , 4 , [ ] ) do
41295: LD_ADDR_VAR 0 5
41299: PUSH
41300: LD_VAR 0 1
41304: PPUSH
41305: LD_INT 4
41307: PPUSH
41308: EMPTY
41309: PPUSH
41310: CALL 11670 0 3
41314: PUSH
41315: FOR_IN
41316: IFFALSE 41493
// begin if GetTag ( j ) = 4 then
41318: LD_VAR 0 5
41322: PPUSH
41323: CALL_OW 110
41327: PUSH
41328: LD_INT 4
41330: EQUAL
41331: IFFALSE 41491
// begin SetTag ( j , 0 ) ;
41333: LD_VAR 0 5
41337: PPUSH
41338: LD_INT 0
41340: PPUSH
41341: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41345: LD_VAR 0 1
41349: PPUSH
41350: CALL 11626 0 1
41354: PUSH
41355: LD_VAR 0 1
41359: PPUSH
41360: CALL 17970 0 1
41364: NOT
41365: AND
41366: IFFALSE 41391
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41368: LD_VAR 0 5
41372: PPUSH
41373: LD_VAR 0 1
41377: PPUSH
41378: CALL 11626 0 1
41382: PUSH
41383: LD_INT 1
41385: ARRAY
41386: PPUSH
41387: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41391: LD_VAR 0 1
41395: PPUSH
41396: CALL 11626 0 1
41400: NOT
41401: PUSH
41402: LD_VAR 0 1
41406: PPUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 1
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PPUSH
41417: CALL 11587 0 2
41421: AND
41422: IFFALSE 41491
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41424: LD_VAR 0 5
41428: PPUSH
41429: LD_VAR 0 1
41433: PPUSH
41434: LD_INT 30
41436: PUSH
41437: LD_INT 1
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PPUSH
41444: CALL 11587 0 2
41448: PUSH
41449: LD_INT 1
41451: ARRAY
41452: PPUSH
41453: CALL_OW 250
41457: PPUSH
41458: LD_VAR 0 1
41462: PPUSH
41463: LD_INT 30
41465: PUSH
41466: LD_INT 1
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PPUSH
41473: CALL 11587 0 2
41477: PUSH
41478: LD_INT 1
41480: ARRAY
41481: PPUSH
41482: CALL_OW 251
41486: PPUSH
41487: CALL_OW 111
// end ; end ;
41491: GO 41315
41493: POP
41494: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41495: LD_VAR 0 1
41499: PPUSH
41500: LD_INT 3
41502: PPUSH
41503: EMPTY
41504: PPUSH
41505: CALL 11670 0 3
41509: PUSH
41510: LD_EXP 60
41514: PUSH
41515: LD_VAR 0 1
41519: ARRAY
41520: AND
41521: PUSH
41522: LD_VAR 0 1
41526: PPUSH
41527: LD_INT 6
41529: PPUSH
41530: EMPTY
41531: PPUSH
41532: CALL 12290 0 3
41536: AND
41537: IFFALSE 42068
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41539: LD_ADDR_VAR 0 6
41543: PUSH
41544: LD_EXP 60
41548: PUSH
41549: LD_VAR 0 1
41553: ARRAY
41554: PPUSH
41555: LD_INT 0
41557: PPUSH
41558: CALL_OW 517
41562: PUSH
41563: LD_INT 1
41565: ARRAY
41566: PUSH
41567: LD_INT 1
41569: ARRAY
41570: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41571: LD_ADDR_VAR 0 7
41575: PUSH
41576: LD_EXP 60
41580: PUSH
41581: LD_VAR 0 1
41585: ARRAY
41586: PPUSH
41587: LD_INT 0
41589: PPUSH
41590: CALL_OW 517
41594: PUSH
41595: LD_INT 2
41597: ARRAY
41598: PUSH
41599: LD_INT 1
41601: ARRAY
41602: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41603: LD_VAR 0 1
41607: PPUSH
41608: LD_INT 6
41610: PPUSH
41611: EMPTY
41612: PPUSH
41613: CALL 12290 0 3
41617: IFFALSE 42066
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41619: LD_ADDR_VAR 0 8
41623: PUSH
41624: LD_VAR 0 1
41628: PPUSH
41629: LD_INT 6
41631: PPUSH
41632: EMPTY
41633: PPUSH
41634: CALL 12290 0 3
41638: PUSH
41639: FOR_IN
41640: IFFALSE 41671
// if GetLives ( k ) = 1000 then
41642: LD_VAR 0 8
41646: PPUSH
41647: CALL_OW 256
41651: PUSH
41652: LD_INT 1000
41654: EQUAL
41655: IFFALSE 41669
// SetTag ( k , 0 ) ;
41657: LD_VAR 0 8
41661: PPUSH
41662: LD_INT 0
41664: PPUSH
41665: CALL_OW 109
41669: GO 41639
41671: POP
41672: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41673: LD_VAR 0 1
41677: PPUSH
41678: LD_INT 0
41680: PPUSH
41681: LD_INT 25
41683: PUSH
41684: LD_INT 3
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: PPUSH
41691: CALL 12290 0 3
41695: IFFALSE 41759
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41697: LD_ADDR_VAR 0 8
41701: PUSH
41702: LD_VAR 0 4
41706: PPUSH
41707: LD_INT 0
41709: PPUSH
41710: LD_INT 25
41712: PUSH
41713: LD_INT 3
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PPUSH
41720: CALL 12290 0 3
41724: PUSH
41725: FOR_IN
41726: IFFALSE 41757
// if GetTag ( k ) = 0 then
41728: LD_VAR 0 8
41732: PPUSH
41733: CALL_OW 110
41737: PUSH
41738: LD_INT 0
41740: EQUAL
41741: IFFALSE 41755
// begin SetTag ( k , 8 ) ;
41743: LD_VAR 0 8
41747: PPUSH
41748: LD_INT 8
41750: PPUSH
41751: CALL_OW 109
// end ;
41755: GO 41725
41757: POP
41758: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41759: LD_VAR 0 1
41763: PPUSH
41764: LD_INT 6
41766: PPUSH
41767: LD_INT 92
41769: PUSH
41770: LD_VAR 0 6
41774: PUSH
41775: LD_VAR 0 7
41779: PUSH
41780: LD_INT 10
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: PPUSH
41789: CALL 12290 0 3
41793: IFFALSE 41917
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41795: LD_ADDR_VAR 0 5
41799: PUSH
41800: LD_VAR 0 4
41804: PPUSH
41805: LD_INT 6
41807: PPUSH
41808: LD_INT 92
41810: PUSH
41811: LD_VAR 0 6
41815: PUSH
41816: LD_VAR 0 7
41820: PUSH
41821: LD_INT 10
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: LIST
41828: LIST
41829: PPUSH
41830: CALL 12290 0 3
41834: PUSH
41835: FOR_IN
41836: IFFALSE 41915
// begin if not HasTask ( j ) and GetDriver ( j ) then
41838: LD_VAR 0 5
41842: PPUSH
41843: CALL_OW 314
41847: NOT
41848: PUSH
41849: LD_VAR 0 5
41853: PPUSH
41854: CALL 31819 0 1
41858: AND
41859: IFFALSE 41913
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41861: LD_VAR 0 5
41865: PPUSH
41866: CALL 31819 0 1
41870: PPUSH
41871: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41875: LD_VAR 0 5
41879: PPUSH
41880: CALL 31819 0 1
41884: PPUSH
41885: LD_VAR 0 5
41889: PPUSH
41890: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41894: LD_VAR 0 5
41898: PPUSH
41899: CALL 31819 0 1
41903: PPUSH
41904: LD_VAR 0 5
41908: PPUSH
41909: CALL_OW 180
// end ; end ;
41913: GO 41835
41915: POP
41916: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41917: LD_VAR 0 1
41921: PPUSH
41922: LD_INT 6
41924: PPUSH
41925: LD_INT 92
41927: PUSH
41928: LD_VAR 0 6
41932: PUSH
41933: LD_VAR 0 7
41937: PUSH
41938: LD_INT 10
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: PPUSH
41947: CALL 12290 0 3
41951: PUSH
41952: LD_VAR 0 1
41956: PPUSH
41957: LD_INT 8
41959: PPUSH
41960: EMPTY
41961: PPUSH
41962: CALL 12290 0 3
41966: AND
41967: IFFALSE 42066
// for j in MCF_Tag ( side , 8 , [ ] ) do
41969: LD_ADDR_VAR 0 5
41973: PUSH
41974: LD_VAR 0 1
41978: PPUSH
41979: LD_INT 8
41981: PPUSH
41982: EMPTY
41983: PPUSH
41984: CALL 12290 0 3
41988: PUSH
41989: FOR_IN
41990: IFFALSE 42064
// begin if IsInUnit ( j ) then
41992: LD_VAR 0 5
41996: PPUSH
41997: CALL_OW 310
42001: IFFALSE 42014
// ComExitBuilding ( j ) else
42003: LD_VAR 0 5
42007: PPUSH
42008: CALL_OW 122
42012: GO 42062
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
42014: LD_VAR 0 5
42018: PPUSH
42019: LD_VAR 0 1
42023: PPUSH
42024: LD_INT 6
42026: PPUSH
42027: LD_INT 92
42029: PUSH
42030: LD_VAR 0 6
42034: PUSH
42035: LD_VAR 0 7
42039: PUSH
42040: LD_INT 10
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: PPUSH
42049: CALL 12290 0 3
42053: PUSH
42054: LD_INT 1
42056: ARRAY
42057: PPUSH
42058: CALL_OW 129
// end ;
42062: GO 41989
42064: POP
42065: POP
// end ; end else
42066: GO 42123
// if MCF_Tag ( side , 8 , [ ] ) then
42068: LD_VAR 0 1
42072: PPUSH
42073: LD_INT 8
42075: PPUSH
42076: EMPTY
42077: PPUSH
42078: CALL 12290 0 3
42082: IFFALSE 42123
// for k in MCF_Tag ( side , 8 , [ ] ) do
42084: LD_ADDR_VAR 0 8
42088: PUSH
42089: LD_VAR 0 1
42093: PPUSH
42094: LD_INT 8
42096: PPUSH
42097: EMPTY
42098: PPUSH
42099: CALL 12290 0 3
42103: PUSH
42104: FOR_IN
42105: IFFALSE 42121
// SetTag ( k , 0 ) ;
42107: LD_VAR 0 8
42111: PPUSH
42112: LD_INT 0
42114: PPUSH
42115: CALL_OW 109
42119: GO 42104
42121: POP
42122: POP
// end ; end_of_file
42123: LD_VAR 0 3
42127: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
42128: LD_INT 0
42130: PPUSH
// MREG_Game := [ ] ;
42131: LD_ADDR_EXP 35
42135: PUSH
42136: EMPTY
42137: ST_TO_ADDR
// MREG_Crates := [ ] ;
42138: LD_ADDR_EXP 36
42142: PUSH
42143: EMPTY
42144: ST_TO_ADDR
// MREG_Heal := [ ] ;
42145: LD_ADDR_EXP 37
42149: PUSH
42150: EMPTY
42151: ST_TO_ADDR
// MREG_Tame := [ ] ;
42152: LD_ADDR_EXP 39
42156: PUSH
42157: EMPTY
42158: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
42159: LD_ADDR_EXP 40
42163: PUSH
42164: EMPTY
42165: ST_TO_ADDR
// MREG_SidesList := [ ] ;
42166: LD_ADDR_EXP 41
42170: PUSH
42171: EMPTY
42172: ST_TO_ADDR
// MREG_LabList := [ ] ;
42173: LD_ADDR_EXP 42
42177: PUSH
42178: EMPTY
42179: ST_TO_ADDR
// MREG_Cargo := [ ] ;
42180: LD_ADDR_EXP 43
42184: PUSH
42185: EMPTY
42186: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
42187: LD_ADDR_EXP 44
42191: PUSH
42192: EMPTY
42193: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
42194: LD_ADDR_EXP 45
42198: PUSH
42199: EMPTY
42200: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
42201: LD_ADDR_EXP 46
42205: PUSH
42206: EMPTY
42207: ST_TO_ADDR
// MREG_Status := [ ] ;
42208: LD_ADDR_EXP 47
42212: PUSH
42213: EMPTY
42214: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
42215: LD_ADDR_EXP 48
42219: PUSH
42220: EMPTY
42221: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
42222: LD_ADDR_EXP 49
42226: PUSH
42227: EMPTY
42228: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
42229: LD_ADDR_EXP 50
42233: PUSH
42234: EMPTY
42235: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
42236: LD_ADDR_EXP 51
42240: PUSH
42241: EMPTY
42242: ST_TO_ADDR
// MREG_ToRes := [ ] ;
42243: LD_ADDR_EXP 52
42247: PUSH
42248: EMPTY
42249: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
42250: LD_ADDR_EXP 53
42254: PUSH
42255: EMPTY
42256: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
42257: LD_ADDR_EXP 54
42261: PUSH
42262: EMPTY
42263: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42264: LD_ADDR_EXP 55
42268: PUSH
42269: EMPTY
42270: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42271: LD_ADDR_EXP 56
42275: PUSH
42276: EMPTY
42277: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42278: LD_ADDR_EXP 57
42282: PUSH
42283: EMPTY
42284: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42285: LD_ADDR_EXP 58
42289: PUSH
42290: EMPTY
42291: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42292: LD_ADDR_EXP 59
42296: PUSH
42297: EMPTY
42298: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42299: LD_ADDR_EXP 63
42303: PUSH
42304: EMPTY
42305: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42306: LD_ADDR_EXP 64
42310: PUSH
42311: EMPTY
42312: ST_TO_ADDR
// MREG_Parking := [ ] ;
42313: LD_ADDR_EXP 60
42317: PUSH
42318: EMPTY
42319: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42320: LD_ADDR_EXP 61
42324: PUSH
42325: EMPTY
42326: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42327: LD_ADDR_EXP 65
42331: PUSH
42332: EMPTY
42333: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42334: LD_ADDR_EXP 66
42338: PUSH
42339: EMPTY
42340: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42341: LD_ADDR_EXP 67
42345: PUSH
42346: EMPTY
42347: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42348: LD_ADDR_EXP 69
42352: PUSH
42353: EMPTY
42354: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42355: LD_ADDR_EXP 70
42359: PUSH
42360: EMPTY
42361: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42362: LD_ADDR_EXP 71
42366: PUSH
42367: EMPTY
42368: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42369: LD_ADDR_EXP 73
42373: PUSH
42374: EMPTY
42375: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42376: LD_ADDR_EXP 72
42380: PUSH
42381: EMPTY
42382: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42383: LD_ADDR_EXP 74
42387: PUSH
42388: LD_INT 300
42390: PUSH
42391: LD_INT 100
42393: PUSH
42394: LD_INT 25
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: LIST
42401: ST_TO_ADDR
// end ;
42402: LD_VAR 0 1
42406: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42407: LD_INT 0
42409: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42410: LD_VAR 0 2
42414: PUSH
42415: LD_VAR 0 3
42419: PUSH
42420: LD_VAR 0 4
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: LIST
42429: PUSH
42430: LD_VAR 0 1
42434: IN
42435: IFFALSE 42449
// result := mreg_list else
42437: LD_ADDR_VAR 0 5
42441: PUSH
42442: LD_VAR 0 1
42446: ST_TO_ADDR
42447: GO 42483
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42449: LD_ADDR_VAR 0 1
42453: PUSH
42454: LD_VAR 0 1
42458: PUSH
42459: LD_VAR 0 2
42463: PUSH
42464: LD_VAR 0 3
42468: PUSH
42469: LD_VAR 0 4
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: ADD
42482: ST_TO_ADDR
// result := mreg_list ;
42483: LD_ADDR_VAR 0 5
42487: PUSH
42488: LD_VAR 0 1
42492: ST_TO_ADDR
// end ;
42493: LD_VAR 0 5
42497: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42498: LD_INT 0
42500: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42501: LD_VAR 0 2
42505: PUSH
42506: LD_VAR 0 3
42510: PUSH
42511: LD_VAR 0 4
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: LIST
42520: PUSH
42521: LD_VAR 0 1
42525: IN
42526: IFFALSE 42564
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42528: LD_ADDR_VAR 0 5
42532: PUSH
42533: LD_VAR 0 1
42537: PUSH
42538: LD_VAR 0 2
42542: PUSH
42543: LD_VAR 0 3
42547: PUSH
42548: LD_VAR 0 4
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: LIST
42557: PUSH
42558: EMPTY
42559: LIST
42560: DIFF
42561: ST_TO_ADDR
42562: GO 42574
// result := mreg_list ;
42564: LD_ADDR_VAR 0 5
42568: PUSH
42569: LD_VAR 0 1
42573: ST_TO_ADDR
// end ;
42574: LD_VAR 0 5
42578: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42579: LD_INT 0
42581: PPUSH
42582: PPUSH
42583: PPUSH
// for j = 1 to 8 do
42584: LD_ADDR_VAR 0 3
42588: PUSH
42589: DOUBLE
42590: LD_INT 1
42592: DEC
42593: ST_TO_ADDR
42594: LD_INT 8
42596: PUSH
42597: FOR_TO
42598: IFFALSE 43439
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42600: LD_VAR 0 3
42604: PPUSH
42605: LD_INT 51
42607: PUSH
42608: EMPTY
42609: LIST
42610: PPUSH
42611: CALL 11587 0 2
42615: PUSH
42616: LD_OWVAR 2
42620: PUSH
42621: LD_VAR 0 3
42625: EQUAL
42626: NOT
42627: AND
42628: IFFALSE 42646
// MREG_SidesList := MREG_SidesList ^ 1 else
42630: LD_ADDR_EXP 41
42634: PUSH
42635: LD_EXP 41
42639: PUSH
42640: LD_INT 1
42642: ADD
42643: ST_TO_ADDR
42644: GO 42660
// MREG_SidesList := MREG_SidesList ^ 0 ;
42646: LD_ADDR_EXP 41
42650: PUSH
42651: LD_EXP 41
42655: PUSH
42656: LD_INT 0
42658: ADD
42659: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42660: LD_VAR 0 3
42664: PPUSH
42665: LD_INT 2
42667: PUSH
42668: LD_INT 34
42670: PUSH
42671: LD_INT 12
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 34
42680: PUSH
42681: LD_INT 32
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 34
42690: PUSH
42691: LD_INT 51
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: PUSH
42704: EMPTY
42705: LIST
42706: PPUSH
42707: CALL 11888 0 2
42711: IFFALSE 42812
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42713: LD_ADDR_VAR 0 2
42717: PUSH
42718: LD_VAR 0 3
42722: PPUSH
42723: LD_INT 2
42725: PUSH
42726: LD_INT 34
42728: PUSH
42729: LD_INT 12
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 34
42738: PUSH
42739: LD_INT 32
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 34
42748: PUSH
42749: LD_INT 51
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: LIST
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: PPUSH
42765: CALL 11888 0 2
42769: PUSH
42770: FOR_IN
42771: IFFALSE 42810
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42773: LD_ADDR_EXP 43
42777: PUSH
42778: LD_EXP 43
42782: PPUSH
42783: LD_VAR 0 3
42787: PPUSH
42788: LD_VAR 0 2
42792: PPUSH
42793: LD_VAR 0 2
42797: PPUSH
42798: CALL_OW 264
42802: PPUSH
42803: CALL 42407 0 4
42807: ST_TO_ADDR
42808: GO 42770
42810: POP
42811: POP
// if MCF_Class ( j , 4 , [ ] ) then
42812: LD_VAR 0 3
42816: PPUSH
42817: LD_INT 4
42819: PPUSH
42820: EMPTY
42821: PPUSH
42822: CALL 11670 0 3
42826: IFFALSE 42859
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42828: LD_ADDR_EXP 56
42832: PUSH
42833: LD_EXP 56
42837: PUSH
42838: LD_VAR 0 3
42842: PPUSH
42843: LD_INT 4
42845: PPUSH
42846: EMPTY
42847: PPUSH
42848: CALL 11670 0 3
42852: PUSH
42853: EMPTY
42854: LIST
42855: ADD
42856: ST_TO_ADDR
42857: GO 42876
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42859: LD_ADDR_EXP 56
42863: PUSH
42864: LD_EXP 56
42868: PUSH
42869: LD_INT 0
42871: PUSH
42872: EMPTY
42873: LIST
42874: ADD
42875: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42876: LD_VAR 0 3
42880: PPUSH
42881: LD_INT 3
42883: PPUSH
42884: EMPTY
42885: PPUSH
42886: CALL 11670 0 3
42890: IFFALSE 42923
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42892: LD_ADDR_EXP 57
42896: PUSH
42897: LD_EXP 57
42901: PUSH
42902: LD_VAR 0 3
42906: PPUSH
42907: LD_INT 3
42909: PPUSH
42910: EMPTY
42911: PPUSH
42912: CALL 11670 0 3
42916: PUSH
42917: EMPTY
42918: LIST
42919: ADD
42920: ST_TO_ADDR
42921: GO 42940
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42923: LD_ADDR_EXP 57
42927: PUSH
42928: LD_EXP 57
42932: PUSH
42933: LD_INT 0
42935: PUSH
42936: EMPTY
42937: LIST
42938: ADD
42939: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42940: LD_VAR 0 3
42944: PPUSH
42945: LD_INT 1
42947: PPUSH
42948: EMPTY
42949: PPUSH
42950: CALL 11670 0 3
42954: IFFALSE 42987
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42956: LD_ADDR_EXP 58
42960: PUSH
42961: LD_EXP 58
42965: PUSH
42966: LD_VAR 0 3
42970: PPUSH
42971: LD_INT 1
42973: PPUSH
42974: EMPTY
42975: PPUSH
42976: CALL 11670 0 3
42980: PUSH
42981: EMPTY
42982: LIST
42983: ADD
42984: ST_TO_ADDR
42985: GO 43004
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42987: LD_ADDR_EXP 58
42991: PUSH
42992: LD_EXP 58
42996: PUSH
42997: LD_INT 0
42999: PUSH
43000: EMPTY
43001: LIST
43002: ADD
43003: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
43004: LD_VAR 0 3
43008: PPUSH
43009: LD_INT 2
43011: PPUSH
43012: EMPTY
43013: PPUSH
43014: CALL 11670 0 3
43018: IFFALSE 43051
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
43020: LD_ADDR_EXP 59
43024: PUSH
43025: LD_EXP 59
43029: PUSH
43030: LD_VAR 0 3
43034: PPUSH
43035: LD_INT 2
43037: PPUSH
43038: EMPTY
43039: PPUSH
43040: CALL 11670 0 3
43044: PUSH
43045: EMPTY
43046: LIST
43047: ADD
43048: ST_TO_ADDR
43049: GO 43068
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
43051: LD_ADDR_EXP 59
43055: PUSH
43056: LD_EXP 59
43060: PUSH
43061: LD_INT 0
43063: PUSH
43064: EMPTY
43065: LIST
43066: ADD
43067: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
43068: LD_ADDR_EXP 49
43072: PUSH
43073: LD_EXP 49
43077: PUSH
43078: LD_INT 0
43080: PUSH
43081: EMPTY
43082: LIST
43083: ADD
43084: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
43085: LD_ADDR_EXP 37
43089: PUSH
43090: LD_EXP 37
43094: PUSH
43095: LD_INT 0
43097: PUSH
43098: EMPTY
43099: LIST
43100: ADD
43101: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
43102: LD_ADDR_EXP 39
43106: PUSH
43107: LD_EXP 39
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: ADD
43118: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
43119: LD_ADDR_EXP 60
43123: PUSH
43124: LD_EXP 60
43128: PUSH
43129: LD_INT 0
43131: PUSH
43132: EMPTY
43133: LIST
43134: ADD
43135: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
43136: LD_ADDR_EXP 61
43140: PUSH
43141: LD_EXP 61
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: ADD
43152: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
43153: LD_ADDR_EXP 53
43157: PUSH
43158: LD_EXP 53
43162: PUSH
43163: LD_INT 0
43165: PUSH
43166: EMPTY
43167: LIST
43168: ADD
43169: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
43170: LD_ADDR_EXP 40
43174: PUSH
43175: LD_EXP 40
43179: PUSH
43180: LD_INT 0
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: LD_INT 0
43188: PUSH
43189: LD_INT 0
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: PUSH
43198: EMPTY
43199: LIST
43200: ADD
43201: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
43202: LD_ADDR_EXP 62
43206: PUSH
43207: LD_EXP 62
43211: PUSH
43212: LD_INT 0
43214: PUSH
43215: EMPTY
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: EMPTY
43222: LIST
43223: ADD
43224: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
43225: LD_ADDR_EXP 63
43229: PUSH
43230: LD_EXP 63
43234: PUSH
43235: LD_INT 0
43237: PUSH
43238: EMPTY
43239: LIST
43240: PUSH
43241: EMPTY
43242: LIST
43243: ADD
43244: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
43245: LD_ADDR_EXP 44
43249: PUSH
43250: LD_EXP 44
43254: PUSH
43255: LD_INT 0
43257: PUSH
43258: EMPTY
43259: LIST
43260: ADD
43261: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
43262: LD_ADDR_EXP 65
43266: PUSH
43267: LD_EXP 65
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: ADD
43278: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43279: LD_ADDR_EXP 66
43283: PUSH
43284: LD_EXP 66
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: EMPTY
43293: LIST
43294: ADD
43295: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43296: LD_ADDR_EXP 67
43300: PUSH
43301: LD_EXP 67
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: EMPTY
43310: LIST
43311: ADD
43312: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43313: LD_ADDR_EXP 68
43317: PUSH
43318: LD_EXP 68
43322: PUSH
43323: LD_INT 0
43325: PUSH
43326: EMPTY
43327: LIST
43328: ADD
43329: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43330: LD_ADDR_EXP 69
43334: PUSH
43335: LD_EXP 69
43339: PUSH
43340: LD_INT 0
43342: PUSH
43343: EMPTY
43344: LIST
43345: ADD
43346: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43347: LD_ADDR_EXP 70
43351: PUSH
43352: LD_EXP 70
43356: PUSH
43357: LD_INT 0
43359: PUSH
43360: EMPTY
43361: LIST
43362: ADD
43363: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43364: LD_ADDR_EXP 71
43368: PUSH
43369: LD_EXP 71
43373: PUSH
43374: LD_INT 0
43376: PUSH
43377: EMPTY
43378: LIST
43379: ADD
43380: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43381: LD_ADDR_EXP 73
43385: PUSH
43386: LD_EXP 73
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: EMPTY
43395: LIST
43396: ADD
43397: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43398: LD_ADDR_EXP 72
43402: PUSH
43403: LD_EXP 72
43407: PUSH
43408: LD_INT 0
43410: ADD
43411: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43412: LD_ADDR_EXP 64
43416: PUSH
43417: LD_EXP 64
43421: PUSH
43422: LD_INT 0
43424: PUSH
43425: LD_INT 0
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: LIST
43435: ADD
43436: ST_TO_ADDR
// end ;
43437: GO 42597
43439: POP
43440: POP
// end ;
43441: LD_VAR 0 1
43445: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43446: LD_INT 0
43448: PPUSH
43449: PPUSH
43450: PPUSH
// m := false ;
43451: LD_ADDR_VAR 0 5
43455: PUSH
43456: LD_INT 0
43458: ST_TO_ADDR
// for i = 1 to mreg do
43459: LD_ADDR_VAR 0 4
43463: PUSH
43464: DOUBLE
43465: LD_INT 1
43467: DEC
43468: ST_TO_ADDR
43469: LD_VAR 0 2
43473: PUSH
43474: FOR_TO
43475: IFFALSE 43511
// if mreg [ i ] [ 1 ] = side then
43477: LD_VAR 0 2
43481: PUSH
43482: LD_VAR 0 4
43486: ARRAY
43487: PUSH
43488: LD_INT 1
43490: ARRAY
43491: PUSH
43492: LD_VAR 0 1
43496: EQUAL
43497: IFFALSE 43509
// begin m := true ;
43499: LD_ADDR_VAR 0 5
43503: PUSH
43504: LD_INT 1
43506: ST_TO_ADDR
// break ;
43507: GO 43511
// end ;
43509: GO 43474
43511: POP
43512: POP
// result := m ;
43513: LD_ADDR_VAR 0 3
43517: PUSH
43518: LD_VAR 0 5
43522: ST_TO_ADDR
// end ;
43523: LD_VAR 0 3
43527: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43528: LD_INT 0
43530: PPUSH
43531: PPUSH
43532: PPUSH
// m := 0 ;
43533: LD_ADDR_VAR 0 5
43537: PUSH
43538: LD_INT 0
43540: ST_TO_ADDR
// for i = 1 to mreg do
43541: LD_ADDR_VAR 0 4
43545: PUSH
43546: DOUBLE
43547: LD_INT 1
43549: DEC
43550: ST_TO_ADDR
43551: LD_VAR 0 2
43555: PUSH
43556: FOR_TO
43557: IFFALSE 43597
// if mreg [ i ] [ 1 ] = side then
43559: LD_VAR 0 2
43563: PUSH
43564: LD_VAR 0 4
43568: ARRAY
43569: PUSH
43570: LD_INT 1
43572: ARRAY
43573: PUSH
43574: LD_VAR 0 1
43578: EQUAL
43579: IFFALSE 43595
// begin m := m + 1 ;
43581: LD_ADDR_VAR 0 5
43585: PUSH
43586: LD_VAR 0 5
43590: PUSH
43591: LD_INT 1
43593: PLUS
43594: ST_TO_ADDR
// end ;
43595: GO 43556
43597: POP
43598: POP
// result := m ;
43599: LD_ADDR_VAR 0 3
43603: PUSH
43604: LD_VAR 0 5
43608: ST_TO_ADDR
// end ;
43609: LD_VAR 0 3
43613: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43614: LD_INT 0
43616: PPUSH
43617: PPUSH
// result := 0 ;
43618: LD_ADDR_VAR 0 3
43622: PUSH
43623: LD_INT 0
43625: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43626: LD_ADDR_VAR 0 4
43630: PUSH
43631: DOUBLE
43632: LD_INT 1
43634: DEC
43635: ST_TO_ADDR
43636: LD_EXP 55
43640: PUSH
43641: FOR_TO
43642: IFFALSE 43704
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43644: LD_EXP 55
43648: PUSH
43649: LD_VAR 0 4
43653: ARRAY
43654: PUSH
43655: LD_INT 1
43657: ARRAY
43658: PUSH
43659: LD_VAR 0 1
43663: EQUAL
43664: PUSH
43665: LD_EXP 55
43669: PUSH
43670: LD_VAR 0 4
43674: ARRAY
43675: PUSH
43676: LD_INT 2
43678: ARRAY
43679: PUSH
43680: LD_VAR 0 2
43684: EQUAL
43685: AND
43686: IFFALSE 43702
// begin result := result + 1 ;
43688: LD_ADDR_VAR 0 3
43692: PUSH
43693: LD_VAR 0 3
43697: PUSH
43698: LD_INT 1
43700: PLUS
43701: ST_TO_ADDR
// end ;
43702: GO 43641
43704: POP
43705: POP
// end ; end_of_file
43706: LD_VAR 0 3
43710: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
43711: GO 43713
43713: DISABLE
// begin ru_radar := 98 ;
43714: LD_ADDR_EXP 75
43718: PUSH
43719: LD_INT 98
43721: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43722: LD_ADDR_EXP 76
43726: PUSH
43727: LD_INT 89
43729: ST_TO_ADDR
// us_hack := 99 ;
43730: LD_ADDR_EXP 77
43734: PUSH
43735: LD_INT 99
43737: ST_TO_ADDR
// us_artillery := 97 ;
43738: LD_ADDR_EXP 78
43742: PUSH
43743: LD_INT 97
43745: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43746: LD_ADDR_EXP 79
43750: PUSH
43751: LD_INT 91
43753: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
43754: LD_ADDR_EXP 80
43758: PUSH
43759: LD_INT 92
43761: ST_TO_ADDR
// tech_Artillery := 80 ;
43762: LD_ADDR_EXP 81
43766: PUSH
43767: LD_INT 80
43769: ST_TO_ADDR
// tech_RadMat := 81 ;
43770: LD_ADDR_EXP 82
43774: PUSH
43775: LD_INT 81
43777: ST_TO_ADDR
// tech_BasicTools := 82 ;
43778: LD_ADDR_EXP 83
43782: PUSH
43783: LD_INT 82
43785: ST_TO_ADDR
// tech_Cargo := 83 ;
43786: LD_ADDR_EXP 84
43790: PUSH
43791: LD_INT 83
43793: ST_TO_ADDR
// tech_Track := 84 ;
43794: LD_ADDR_EXP 85
43798: PUSH
43799: LD_INT 84
43801: ST_TO_ADDR
// tech_Crane := 85 ;
43802: LD_ADDR_EXP 86
43806: PUSH
43807: LD_INT 85
43809: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43810: LD_ADDR_EXP 87
43814: PUSH
43815: LD_INT 86
43817: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43818: LD_ADDR_EXP 88
43822: PUSH
43823: LD_INT 87
43825: ST_TO_ADDR
// end ; end_of_file end_of_file
43826: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
43827: GO 43829
43829: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
43830: LD_STRING initStreamRollete();
43832: PPUSH
43833: CALL_OW 559
// InitStreamMode ;
43837: CALL 43846 0 0
// DefineStreamItems ( ) ;
43841: CALL 44286 0 0
// end ;
43845: END
// function InitStreamMode ; begin
43846: LD_INT 0
43848: PPUSH
// streamModeActive := false ;
43849: LD_ADDR_EXP 89
43853: PUSH
43854: LD_INT 0
43856: ST_TO_ADDR
// normalCounter := 36 ;
43857: LD_ADDR_EXP 90
43861: PUSH
43862: LD_INT 36
43864: ST_TO_ADDR
// hardcoreCounter := 16 ;
43865: LD_ADDR_EXP 91
43869: PUSH
43870: LD_INT 16
43872: ST_TO_ADDR
// sRocket := false ;
43873: LD_ADDR_EXP 94
43877: PUSH
43878: LD_INT 0
43880: ST_TO_ADDR
// sSpeed := false ;
43881: LD_ADDR_EXP 93
43885: PUSH
43886: LD_INT 0
43888: ST_TO_ADDR
// sEngine := false ;
43889: LD_ADDR_EXP 95
43893: PUSH
43894: LD_INT 0
43896: ST_TO_ADDR
// sSpec := false ;
43897: LD_ADDR_EXP 92
43901: PUSH
43902: LD_INT 0
43904: ST_TO_ADDR
// sLevel := false ;
43905: LD_ADDR_EXP 96
43909: PUSH
43910: LD_INT 0
43912: ST_TO_ADDR
// sArmoury := false ;
43913: LD_ADDR_EXP 97
43917: PUSH
43918: LD_INT 0
43920: ST_TO_ADDR
// sRadar := false ;
43921: LD_ADDR_EXP 98
43925: PUSH
43926: LD_INT 0
43928: ST_TO_ADDR
// sBunker := false ;
43929: LD_ADDR_EXP 99
43933: PUSH
43934: LD_INT 0
43936: ST_TO_ADDR
// sHack := false ;
43937: LD_ADDR_EXP 100
43941: PUSH
43942: LD_INT 0
43944: ST_TO_ADDR
// sFire := false ;
43945: LD_ADDR_EXP 101
43949: PUSH
43950: LD_INT 0
43952: ST_TO_ADDR
// sRefresh := false ;
43953: LD_ADDR_EXP 102
43957: PUSH
43958: LD_INT 0
43960: ST_TO_ADDR
// sExp := false ;
43961: LD_ADDR_EXP 103
43965: PUSH
43966: LD_INT 0
43968: ST_TO_ADDR
// sDepot := false ;
43969: LD_ADDR_EXP 104
43973: PUSH
43974: LD_INT 0
43976: ST_TO_ADDR
// sFlag := false ;
43977: LD_ADDR_EXP 105
43981: PUSH
43982: LD_INT 0
43984: ST_TO_ADDR
// sKamikadze := false ;
43985: LD_ADDR_EXP 113
43989: PUSH
43990: LD_INT 0
43992: ST_TO_ADDR
// sTroll := false ;
43993: LD_ADDR_EXP 114
43997: PUSH
43998: LD_INT 0
44000: ST_TO_ADDR
// sSlow := false ;
44001: LD_ADDR_EXP 115
44005: PUSH
44006: LD_INT 0
44008: ST_TO_ADDR
// sLack := false ;
44009: LD_ADDR_EXP 116
44013: PUSH
44014: LD_INT 0
44016: ST_TO_ADDR
// sTank := false ;
44017: LD_ADDR_EXP 118
44021: PUSH
44022: LD_INT 0
44024: ST_TO_ADDR
// sRemote := false ;
44025: LD_ADDR_EXP 119
44029: PUSH
44030: LD_INT 0
44032: ST_TO_ADDR
// sPowell := false ;
44033: LD_ADDR_EXP 120
44037: PUSH
44038: LD_INT 0
44040: ST_TO_ADDR
// sTeleport := false ;
44041: LD_ADDR_EXP 123
44045: PUSH
44046: LD_INT 0
44048: ST_TO_ADDR
// sOilTower := false ;
44049: LD_ADDR_EXP 125
44053: PUSH
44054: LD_INT 0
44056: ST_TO_ADDR
// sShovel := false ;
44057: LD_ADDR_EXP 126
44061: PUSH
44062: LD_INT 0
44064: ST_TO_ADDR
// sSheik := false ;
44065: LD_ADDR_EXP 127
44069: PUSH
44070: LD_INT 0
44072: ST_TO_ADDR
// sEarthquake := false ;
44073: LD_ADDR_EXP 129
44077: PUSH
44078: LD_INT 0
44080: ST_TO_ADDR
// sAI := false ;
44081: LD_ADDR_EXP 130
44085: PUSH
44086: LD_INT 0
44088: ST_TO_ADDR
// sCargo := false ;
44089: LD_ADDR_EXP 133
44093: PUSH
44094: LD_INT 0
44096: ST_TO_ADDR
// sDLaser := false ;
44097: LD_ADDR_EXP 134
44101: PUSH
44102: LD_INT 0
44104: ST_TO_ADDR
// sExchange := false ;
44105: LD_ADDR_EXP 135
44109: PUSH
44110: LD_INT 0
44112: ST_TO_ADDR
// sFac := false ;
44113: LD_ADDR_EXP 136
44117: PUSH
44118: LD_INT 0
44120: ST_TO_ADDR
// sPower := false ;
44121: LD_ADDR_EXP 137
44125: PUSH
44126: LD_INT 0
44128: ST_TO_ADDR
// sRandom := false ;
44129: LD_ADDR_EXP 138
44133: PUSH
44134: LD_INT 0
44136: ST_TO_ADDR
// sShield := false ;
44137: LD_ADDR_EXP 139
44141: PUSH
44142: LD_INT 0
44144: ST_TO_ADDR
// sTime := false ;
44145: LD_ADDR_EXP 140
44149: PUSH
44150: LD_INT 0
44152: ST_TO_ADDR
// sTools := false ;
44153: LD_ADDR_EXP 141
44157: PUSH
44158: LD_INT 0
44160: ST_TO_ADDR
// sSold := false ;
44161: LD_ADDR_EXP 106
44165: PUSH
44166: LD_INT 0
44168: ST_TO_ADDR
// sDiff := false ;
44169: LD_ADDR_EXP 107
44173: PUSH
44174: LD_INT 0
44176: ST_TO_ADDR
// sFog := false ;
44177: LD_ADDR_EXP 110
44181: PUSH
44182: LD_INT 0
44184: ST_TO_ADDR
// sReset := false ;
44185: LD_ADDR_EXP 111
44189: PUSH
44190: LD_INT 0
44192: ST_TO_ADDR
// sSun := false ;
44193: LD_ADDR_EXP 112
44197: PUSH
44198: LD_INT 0
44200: ST_TO_ADDR
// sTiger := false ;
44201: LD_ADDR_EXP 108
44205: PUSH
44206: LD_INT 0
44208: ST_TO_ADDR
// sBomb := false ;
44209: LD_ADDR_EXP 109
44213: PUSH
44214: LD_INT 0
44216: ST_TO_ADDR
// sWound := false ;
44217: LD_ADDR_EXP 117
44221: PUSH
44222: LD_INT 0
44224: ST_TO_ADDR
// sBetray := false ;
44225: LD_ADDR_EXP 121
44229: PUSH
44230: LD_INT 0
44232: ST_TO_ADDR
// sContamin := false ;
44233: LD_ADDR_EXP 122
44237: PUSH
44238: LD_INT 0
44240: ST_TO_ADDR
// sOil := false ;
44241: LD_ADDR_EXP 124
44245: PUSH
44246: LD_INT 0
44248: ST_TO_ADDR
// sStu := false ;
44249: LD_ADDR_EXP 128
44253: PUSH
44254: LD_INT 0
44256: ST_TO_ADDR
// sBazooka := false ;
44257: LD_ADDR_EXP 131
44261: PUSH
44262: LD_INT 0
44264: ST_TO_ADDR
// sMortar := false ;
44265: LD_ADDR_EXP 132
44269: PUSH
44270: LD_INT 0
44272: ST_TO_ADDR
// sRanger := false ;
44273: LD_ADDR_EXP 142
44277: PUSH
44278: LD_INT 0
44280: ST_TO_ADDR
// end ;
44281: LD_VAR 0 1
44285: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44286: LD_INT 0
44288: PPUSH
44289: PPUSH
44290: PPUSH
44291: PPUSH
44292: PPUSH
// result := [ ] ;
44293: LD_ADDR_VAR 0 1
44297: PUSH
44298: EMPTY
44299: ST_TO_ADDR
// if campaign_id = 1 then
44300: LD_OWVAR 69
44304: PUSH
44305: LD_INT 1
44307: EQUAL
44308: IFFALSE 47246
// begin case mission_number of 1 :
44310: LD_OWVAR 70
44314: PUSH
44315: LD_INT 1
44317: DOUBLE
44318: EQUAL
44319: IFTRUE 44323
44321: GO 44387
44323: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44324: LD_ADDR_VAR 0 1
44328: PUSH
44329: LD_INT 2
44331: PUSH
44332: LD_INT 4
44334: PUSH
44335: LD_INT 11
44337: PUSH
44338: LD_INT 12
44340: PUSH
44341: LD_INT 15
44343: PUSH
44344: LD_INT 16
44346: PUSH
44347: LD_INT 22
44349: PUSH
44350: LD_INT 23
44352: PUSH
44353: LD_INT 26
44355: PUSH
44356: EMPTY
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: PUSH
44367: LD_INT 101
44369: PUSH
44370: LD_INT 102
44372: PUSH
44373: LD_INT 106
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: LIST
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: ST_TO_ADDR
44385: GO 47244
44387: LD_INT 2
44389: DOUBLE
44390: EQUAL
44391: IFTRUE 44395
44393: GO 44467
44395: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44396: LD_ADDR_VAR 0 1
44400: PUSH
44401: LD_INT 2
44403: PUSH
44404: LD_INT 4
44406: PUSH
44407: LD_INT 11
44409: PUSH
44410: LD_INT 12
44412: PUSH
44413: LD_INT 15
44415: PUSH
44416: LD_INT 16
44418: PUSH
44419: LD_INT 22
44421: PUSH
44422: LD_INT 23
44424: PUSH
44425: LD_INT 26
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 101
44441: PUSH
44442: LD_INT 102
44444: PUSH
44445: LD_INT 105
44447: PUSH
44448: LD_INT 106
44450: PUSH
44451: LD_INT 108
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: ST_TO_ADDR
44465: GO 47244
44467: LD_INT 3
44469: DOUBLE
44470: EQUAL
44471: IFTRUE 44475
44473: GO 44551
44475: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
44476: LD_ADDR_VAR 0 1
44480: PUSH
44481: LD_INT 2
44483: PUSH
44484: LD_INT 4
44486: PUSH
44487: LD_INT 5
44489: PUSH
44490: LD_INT 11
44492: PUSH
44493: LD_INT 12
44495: PUSH
44496: LD_INT 15
44498: PUSH
44499: LD_INT 16
44501: PUSH
44502: LD_INT 22
44504: PUSH
44505: LD_INT 26
44507: PUSH
44508: LD_INT 36
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: PUSH
44523: LD_INT 101
44525: PUSH
44526: LD_INT 102
44528: PUSH
44529: LD_INT 105
44531: PUSH
44532: LD_INT 106
44534: PUSH
44535: LD_INT 108
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: ST_TO_ADDR
44549: GO 47244
44551: LD_INT 4
44553: DOUBLE
44554: EQUAL
44555: IFTRUE 44559
44557: GO 44643
44559: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
44560: LD_ADDR_VAR 0 1
44564: PUSH
44565: LD_INT 2
44567: PUSH
44568: LD_INT 4
44570: PUSH
44571: LD_INT 5
44573: PUSH
44574: LD_INT 8
44576: PUSH
44577: LD_INT 11
44579: PUSH
44580: LD_INT 12
44582: PUSH
44583: LD_INT 15
44585: PUSH
44586: LD_INT 16
44588: PUSH
44589: LD_INT 22
44591: PUSH
44592: LD_INT 23
44594: PUSH
44595: LD_INT 26
44597: PUSH
44598: LD_INT 36
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: PUSH
44615: LD_INT 101
44617: PUSH
44618: LD_INT 102
44620: PUSH
44621: LD_INT 105
44623: PUSH
44624: LD_INT 106
44626: PUSH
44627: LD_INT 108
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: ST_TO_ADDR
44641: GO 47244
44643: LD_INT 5
44645: DOUBLE
44646: EQUAL
44647: IFTRUE 44651
44649: GO 44751
44651: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
44652: LD_ADDR_VAR 0 1
44656: PUSH
44657: LD_INT 2
44659: PUSH
44660: LD_INT 4
44662: PUSH
44663: LD_INT 5
44665: PUSH
44666: LD_INT 6
44668: PUSH
44669: LD_INT 8
44671: PUSH
44672: LD_INT 11
44674: PUSH
44675: LD_INT 12
44677: PUSH
44678: LD_INT 15
44680: PUSH
44681: LD_INT 16
44683: PUSH
44684: LD_INT 22
44686: PUSH
44687: LD_INT 23
44689: PUSH
44690: LD_INT 25
44692: PUSH
44693: LD_INT 26
44695: PUSH
44696: LD_INT 36
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 101
44717: PUSH
44718: LD_INT 102
44720: PUSH
44721: LD_INT 105
44723: PUSH
44724: LD_INT 106
44726: PUSH
44727: LD_INT 108
44729: PUSH
44730: LD_INT 109
44732: PUSH
44733: LD_INT 112
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: ST_TO_ADDR
44749: GO 47244
44751: LD_INT 6
44753: DOUBLE
44754: EQUAL
44755: IFTRUE 44759
44757: GO 44879
44759: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
44760: LD_ADDR_VAR 0 1
44764: PUSH
44765: LD_INT 2
44767: PUSH
44768: LD_INT 4
44770: PUSH
44771: LD_INT 5
44773: PUSH
44774: LD_INT 6
44776: PUSH
44777: LD_INT 8
44779: PUSH
44780: LD_INT 11
44782: PUSH
44783: LD_INT 12
44785: PUSH
44786: LD_INT 15
44788: PUSH
44789: LD_INT 16
44791: PUSH
44792: LD_INT 20
44794: PUSH
44795: LD_INT 21
44797: PUSH
44798: LD_INT 22
44800: PUSH
44801: LD_INT 23
44803: PUSH
44804: LD_INT 25
44806: PUSH
44807: LD_INT 26
44809: PUSH
44810: LD_INT 30
44812: PUSH
44813: LD_INT 31
44815: PUSH
44816: LD_INT 32
44818: PUSH
44819: LD_INT 36
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 101
44845: PUSH
44846: LD_INT 102
44848: PUSH
44849: LD_INT 105
44851: PUSH
44852: LD_INT 106
44854: PUSH
44855: LD_INT 108
44857: PUSH
44858: LD_INT 109
44860: PUSH
44861: LD_INT 112
44863: PUSH
44864: EMPTY
44865: LIST
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: LIST
44871: LIST
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: ST_TO_ADDR
44877: GO 47244
44879: LD_INT 7
44881: DOUBLE
44882: EQUAL
44883: IFTRUE 44887
44885: GO 44987
44887: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
44888: LD_ADDR_VAR 0 1
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 4
44898: PUSH
44899: LD_INT 5
44901: PUSH
44902: LD_INT 7
44904: PUSH
44905: LD_INT 11
44907: PUSH
44908: LD_INT 12
44910: PUSH
44911: LD_INT 15
44913: PUSH
44914: LD_INT 16
44916: PUSH
44917: LD_INT 20
44919: PUSH
44920: LD_INT 21
44922: PUSH
44923: LD_INT 22
44925: PUSH
44926: LD_INT 23
44928: PUSH
44929: LD_INT 25
44931: PUSH
44932: LD_INT 26
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 101
44953: PUSH
44954: LD_INT 102
44956: PUSH
44957: LD_INT 103
44959: PUSH
44960: LD_INT 105
44962: PUSH
44963: LD_INT 106
44965: PUSH
44966: LD_INT 108
44968: PUSH
44969: LD_INT 112
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: LIST
44976: LIST
44977: LIST
44978: LIST
44979: LIST
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: ST_TO_ADDR
44985: GO 47244
44987: LD_INT 8
44989: DOUBLE
44990: EQUAL
44991: IFTRUE 44995
44993: GO 45123
44995: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
44996: LD_ADDR_VAR 0 1
45000: PUSH
45001: LD_INT 2
45003: PUSH
45004: LD_INT 4
45006: PUSH
45007: LD_INT 5
45009: PUSH
45010: LD_INT 6
45012: PUSH
45013: LD_INT 7
45015: PUSH
45016: LD_INT 8
45018: PUSH
45019: LD_INT 11
45021: PUSH
45022: LD_INT 12
45024: PUSH
45025: LD_INT 15
45027: PUSH
45028: LD_INT 16
45030: PUSH
45031: LD_INT 20
45033: PUSH
45034: LD_INT 21
45036: PUSH
45037: LD_INT 22
45039: PUSH
45040: LD_INT 23
45042: PUSH
45043: LD_INT 25
45045: PUSH
45046: LD_INT 26
45048: PUSH
45049: LD_INT 30
45051: PUSH
45052: LD_INT 31
45054: PUSH
45055: LD_INT 32
45057: PUSH
45058: LD_INT 36
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: PUSH
45083: LD_INT 101
45085: PUSH
45086: LD_INT 102
45088: PUSH
45089: LD_INT 103
45091: PUSH
45092: LD_INT 105
45094: PUSH
45095: LD_INT 106
45097: PUSH
45098: LD_INT 108
45100: PUSH
45101: LD_INT 109
45103: PUSH
45104: LD_INT 112
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: LIST
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: ST_TO_ADDR
45121: GO 47244
45123: LD_INT 9
45125: DOUBLE
45126: EQUAL
45127: IFTRUE 45131
45129: GO 45267
45131: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45132: LD_ADDR_VAR 0 1
45136: PUSH
45137: LD_INT 2
45139: PUSH
45140: LD_INT 4
45142: PUSH
45143: LD_INT 5
45145: PUSH
45146: LD_INT 6
45148: PUSH
45149: LD_INT 7
45151: PUSH
45152: LD_INT 8
45154: PUSH
45155: LD_INT 11
45157: PUSH
45158: LD_INT 12
45160: PUSH
45161: LD_INT 15
45163: PUSH
45164: LD_INT 16
45166: PUSH
45167: LD_INT 20
45169: PUSH
45170: LD_INT 21
45172: PUSH
45173: LD_INT 22
45175: PUSH
45176: LD_INT 23
45178: PUSH
45179: LD_INT 25
45181: PUSH
45182: LD_INT 26
45184: PUSH
45185: LD_INT 28
45187: PUSH
45188: LD_INT 30
45190: PUSH
45191: LD_INT 31
45193: PUSH
45194: LD_INT 32
45196: PUSH
45197: LD_INT 36
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: PUSH
45223: LD_INT 101
45225: PUSH
45226: LD_INT 102
45228: PUSH
45229: LD_INT 103
45231: PUSH
45232: LD_INT 105
45234: PUSH
45235: LD_INT 106
45237: PUSH
45238: LD_INT 108
45240: PUSH
45241: LD_INT 109
45243: PUSH
45244: LD_INT 112
45246: PUSH
45247: LD_INT 114
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: ST_TO_ADDR
45265: GO 47244
45267: LD_INT 10
45269: DOUBLE
45270: EQUAL
45271: IFTRUE 45275
45273: GO 45459
45275: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45276: LD_ADDR_VAR 0 1
45280: PUSH
45281: LD_INT 2
45283: PUSH
45284: LD_INT 4
45286: PUSH
45287: LD_INT 5
45289: PUSH
45290: LD_INT 6
45292: PUSH
45293: LD_INT 7
45295: PUSH
45296: LD_INT 8
45298: PUSH
45299: LD_INT 9
45301: PUSH
45302: LD_INT 10
45304: PUSH
45305: LD_INT 11
45307: PUSH
45308: LD_INT 12
45310: PUSH
45311: LD_INT 13
45313: PUSH
45314: LD_INT 14
45316: PUSH
45317: LD_INT 15
45319: PUSH
45320: LD_INT 16
45322: PUSH
45323: LD_INT 17
45325: PUSH
45326: LD_INT 18
45328: PUSH
45329: LD_INT 19
45331: PUSH
45332: LD_INT 20
45334: PUSH
45335: LD_INT 21
45337: PUSH
45338: LD_INT 22
45340: PUSH
45341: LD_INT 23
45343: PUSH
45344: LD_INT 24
45346: PUSH
45347: LD_INT 25
45349: PUSH
45350: LD_INT 26
45352: PUSH
45353: LD_INT 28
45355: PUSH
45356: LD_INT 30
45358: PUSH
45359: LD_INT 31
45361: PUSH
45362: LD_INT 32
45364: PUSH
45365: LD_INT 36
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: LIST
45387: LIST
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 101
45401: PUSH
45402: LD_INT 102
45404: PUSH
45405: LD_INT 103
45407: PUSH
45408: LD_INT 104
45410: PUSH
45411: LD_INT 105
45413: PUSH
45414: LD_INT 106
45416: PUSH
45417: LD_INT 107
45419: PUSH
45420: LD_INT 108
45422: PUSH
45423: LD_INT 109
45425: PUSH
45426: LD_INT 110
45428: PUSH
45429: LD_INT 111
45431: PUSH
45432: LD_INT 112
45434: PUSH
45435: LD_INT 114
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: ST_TO_ADDR
45457: GO 47244
45459: LD_INT 11
45461: DOUBLE
45462: EQUAL
45463: IFTRUE 45467
45465: GO 45659
45467: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
45468: LD_ADDR_VAR 0 1
45472: PUSH
45473: LD_INT 2
45475: PUSH
45476: LD_INT 3
45478: PUSH
45479: LD_INT 4
45481: PUSH
45482: LD_INT 5
45484: PUSH
45485: LD_INT 6
45487: PUSH
45488: LD_INT 7
45490: PUSH
45491: LD_INT 8
45493: PUSH
45494: LD_INT 9
45496: PUSH
45497: LD_INT 10
45499: PUSH
45500: LD_INT 11
45502: PUSH
45503: LD_INT 12
45505: PUSH
45506: LD_INT 13
45508: PUSH
45509: LD_INT 14
45511: PUSH
45512: LD_INT 15
45514: PUSH
45515: LD_INT 16
45517: PUSH
45518: LD_INT 17
45520: PUSH
45521: LD_INT 18
45523: PUSH
45524: LD_INT 19
45526: PUSH
45527: LD_INT 20
45529: PUSH
45530: LD_INT 21
45532: PUSH
45533: LD_INT 22
45535: PUSH
45536: LD_INT 23
45538: PUSH
45539: LD_INT 24
45541: PUSH
45542: LD_INT 25
45544: PUSH
45545: LD_INT 26
45547: PUSH
45548: LD_INT 28
45550: PUSH
45551: LD_INT 30
45553: PUSH
45554: LD_INT 31
45556: PUSH
45557: LD_INT 32
45559: PUSH
45560: LD_INT 34
45562: PUSH
45563: LD_INT 36
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: LIST
45595: LIST
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 101
45601: PUSH
45602: LD_INT 102
45604: PUSH
45605: LD_INT 103
45607: PUSH
45608: LD_INT 104
45610: PUSH
45611: LD_INT 105
45613: PUSH
45614: LD_INT 106
45616: PUSH
45617: LD_INT 107
45619: PUSH
45620: LD_INT 108
45622: PUSH
45623: LD_INT 109
45625: PUSH
45626: LD_INT 110
45628: PUSH
45629: LD_INT 111
45631: PUSH
45632: LD_INT 112
45634: PUSH
45635: LD_INT 114
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: ST_TO_ADDR
45657: GO 47244
45659: LD_INT 12
45661: DOUBLE
45662: EQUAL
45663: IFTRUE 45667
45665: GO 45875
45667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
45668: LD_ADDR_VAR 0 1
45672: PUSH
45673: LD_INT 1
45675: PUSH
45676: LD_INT 2
45678: PUSH
45679: LD_INT 3
45681: PUSH
45682: LD_INT 4
45684: PUSH
45685: LD_INT 5
45687: PUSH
45688: LD_INT 6
45690: PUSH
45691: LD_INT 7
45693: PUSH
45694: LD_INT 8
45696: PUSH
45697: LD_INT 9
45699: PUSH
45700: LD_INT 10
45702: PUSH
45703: LD_INT 11
45705: PUSH
45706: LD_INT 12
45708: PUSH
45709: LD_INT 13
45711: PUSH
45712: LD_INT 14
45714: PUSH
45715: LD_INT 15
45717: PUSH
45718: LD_INT 16
45720: PUSH
45721: LD_INT 17
45723: PUSH
45724: LD_INT 18
45726: PUSH
45727: LD_INT 19
45729: PUSH
45730: LD_INT 20
45732: PUSH
45733: LD_INT 21
45735: PUSH
45736: LD_INT 22
45738: PUSH
45739: LD_INT 23
45741: PUSH
45742: LD_INT 24
45744: PUSH
45745: LD_INT 25
45747: PUSH
45748: LD_INT 26
45750: PUSH
45751: LD_INT 27
45753: PUSH
45754: LD_INT 28
45756: PUSH
45757: LD_INT 30
45759: PUSH
45760: LD_INT 31
45762: PUSH
45763: LD_INT 32
45765: PUSH
45766: LD_INT 33
45768: PUSH
45769: LD_INT 34
45771: PUSH
45772: LD_INT 36
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: LIST
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 101
45813: PUSH
45814: LD_INT 102
45816: PUSH
45817: LD_INT 103
45819: PUSH
45820: LD_INT 104
45822: PUSH
45823: LD_INT 105
45825: PUSH
45826: LD_INT 106
45828: PUSH
45829: LD_INT 107
45831: PUSH
45832: LD_INT 108
45834: PUSH
45835: LD_INT 109
45837: PUSH
45838: LD_INT 110
45840: PUSH
45841: LD_INT 111
45843: PUSH
45844: LD_INT 112
45846: PUSH
45847: LD_INT 113
45849: PUSH
45850: LD_INT 114
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: ST_TO_ADDR
45873: GO 47244
45875: LD_INT 13
45877: DOUBLE
45878: EQUAL
45879: IFTRUE 45883
45881: GO 46079
45883: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
45884: LD_ADDR_VAR 0 1
45888: PUSH
45889: LD_INT 1
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: LD_INT 3
45897: PUSH
45898: LD_INT 4
45900: PUSH
45901: LD_INT 5
45903: PUSH
45904: LD_INT 8
45906: PUSH
45907: LD_INT 9
45909: PUSH
45910: LD_INT 10
45912: PUSH
45913: LD_INT 11
45915: PUSH
45916: LD_INT 12
45918: PUSH
45919: LD_INT 14
45921: PUSH
45922: LD_INT 15
45924: PUSH
45925: LD_INT 16
45927: PUSH
45928: LD_INT 17
45930: PUSH
45931: LD_INT 18
45933: PUSH
45934: LD_INT 19
45936: PUSH
45937: LD_INT 20
45939: PUSH
45940: LD_INT 21
45942: PUSH
45943: LD_INT 22
45945: PUSH
45946: LD_INT 23
45948: PUSH
45949: LD_INT 24
45951: PUSH
45952: LD_INT 25
45954: PUSH
45955: LD_INT 26
45957: PUSH
45958: LD_INT 27
45960: PUSH
45961: LD_INT 28
45963: PUSH
45964: LD_INT 30
45966: PUSH
45967: LD_INT 31
45969: PUSH
45970: LD_INT 32
45972: PUSH
45973: LD_INT 33
45975: PUSH
45976: LD_INT 34
45978: PUSH
45979: LD_INT 36
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: PUSH
46015: LD_INT 101
46017: PUSH
46018: LD_INT 102
46020: PUSH
46021: LD_INT 103
46023: PUSH
46024: LD_INT 104
46026: PUSH
46027: LD_INT 105
46029: PUSH
46030: LD_INT 106
46032: PUSH
46033: LD_INT 107
46035: PUSH
46036: LD_INT 108
46038: PUSH
46039: LD_INT 109
46041: PUSH
46042: LD_INT 110
46044: PUSH
46045: LD_INT 111
46047: PUSH
46048: LD_INT 112
46050: PUSH
46051: LD_INT 113
46053: PUSH
46054: LD_INT 114
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: ST_TO_ADDR
46077: GO 47244
46079: LD_INT 14
46081: DOUBLE
46082: EQUAL
46083: IFTRUE 46087
46085: GO 46299
46087: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46088: LD_ADDR_VAR 0 1
46092: PUSH
46093: LD_INT 1
46095: PUSH
46096: LD_INT 2
46098: PUSH
46099: LD_INT 3
46101: PUSH
46102: LD_INT 4
46104: PUSH
46105: LD_INT 5
46107: PUSH
46108: LD_INT 6
46110: PUSH
46111: LD_INT 7
46113: PUSH
46114: LD_INT 8
46116: PUSH
46117: LD_INT 9
46119: PUSH
46120: LD_INT 10
46122: PUSH
46123: LD_INT 11
46125: PUSH
46126: LD_INT 12
46128: PUSH
46129: LD_INT 13
46131: PUSH
46132: LD_INT 14
46134: PUSH
46135: LD_INT 15
46137: PUSH
46138: LD_INT 16
46140: PUSH
46141: LD_INT 17
46143: PUSH
46144: LD_INT 18
46146: PUSH
46147: LD_INT 19
46149: PUSH
46150: LD_INT 20
46152: PUSH
46153: LD_INT 21
46155: PUSH
46156: LD_INT 22
46158: PUSH
46159: LD_INT 23
46161: PUSH
46162: LD_INT 24
46164: PUSH
46165: LD_INT 25
46167: PUSH
46168: LD_INT 26
46170: PUSH
46171: LD_INT 27
46173: PUSH
46174: LD_INT 28
46176: PUSH
46177: LD_INT 29
46179: PUSH
46180: LD_INT 30
46182: PUSH
46183: LD_INT 31
46185: PUSH
46186: LD_INT 32
46188: PUSH
46189: LD_INT 33
46191: PUSH
46192: LD_INT 34
46194: PUSH
46195: LD_INT 36
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 101
46237: PUSH
46238: LD_INT 102
46240: PUSH
46241: LD_INT 103
46243: PUSH
46244: LD_INT 104
46246: PUSH
46247: LD_INT 105
46249: PUSH
46250: LD_INT 106
46252: PUSH
46253: LD_INT 107
46255: PUSH
46256: LD_INT 108
46258: PUSH
46259: LD_INT 109
46261: PUSH
46262: LD_INT 110
46264: PUSH
46265: LD_INT 111
46267: PUSH
46268: LD_INT 112
46270: PUSH
46271: LD_INT 113
46273: PUSH
46274: LD_INT 114
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: LIST
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: ST_TO_ADDR
46297: GO 47244
46299: LD_INT 15
46301: DOUBLE
46302: EQUAL
46303: IFTRUE 46307
46305: GO 46519
46307: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46308: LD_ADDR_VAR 0 1
46312: PUSH
46313: LD_INT 1
46315: PUSH
46316: LD_INT 2
46318: PUSH
46319: LD_INT 3
46321: PUSH
46322: LD_INT 4
46324: PUSH
46325: LD_INT 5
46327: PUSH
46328: LD_INT 6
46330: PUSH
46331: LD_INT 7
46333: PUSH
46334: LD_INT 8
46336: PUSH
46337: LD_INT 9
46339: PUSH
46340: LD_INT 10
46342: PUSH
46343: LD_INT 11
46345: PUSH
46346: LD_INT 12
46348: PUSH
46349: LD_INT 13
46351: PUSH
46352: LD_INT 14
46354: PUSH
46355: LD_INT 15
46357: PUSH
46358: LD_INT 16
46360: PUSH
46361: LD_INT 17
46363: PUSH
46364: LD_INT 18
46366: PUSH
46367: LD_INT 19
46369: PUSH
46370: LD_INT 20
46372: PUSH
46373: LD_INT 21
46375: PUSH
46376: LD_INT 22
46378: PUSH
46379: LD_INT 23
46381: PUSH
46382: LD_INT 24
46384: PUSH
46385: LD_INT 25
46387: PUSH
46388: LD_INT 26
46390: PUSH
46391: LD_INT 27
46393: PUSH
46394: LD_INT 28
46396: PUSH
46397: LD_INT 29
46399: PUSH
46400: LD_INT 30
46402: PUSH
46403: LD_INT 31
46405: PUSH
46406: LD_INT 32
46408: PUSH
46409: LD_INT 33
46411: PUSH
46412: LD_INT 34
46414: PUSH
46415: LD_INT 36
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: PUSH
46455: LD_INT 101
46457: PUSH
46458: LD_INT 102
46460: PUSH
46461: LD_INT 103
46463: PUSH
46464: LD_INT 104
46466: PUSH
46467: LD_INT 105
46469: PUSH
46470: LD_INT 106
46472: PUSH
46473: LD_INT 107
46475: PUSH
46476: LD_INT 108
46478: PUSH
46479: LD_INT 109
46481: PUSH
46482: LD_INT 110
46484: PUSH
46485: LD_INT 111
46487: PUSH
46488: LD_INT 112
46490: PUSH
46491: LD_INT 113
46493: PUSH
46494: LD_INT 114
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: ST_TO_ADDR
46517: GO 47244
46519: LD_INT 16
46521: DOUBLE
46522: EQUAL
46523: IFTRUE 46527
46525: GO 46651
46527: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
46528: LD_ADDR_VAR 0 1
46532: PUSH
46533: LD_INT 2
46535: PUSH
46536: LD_INT 4
46538: PUSH
46539: LD_INT 5
46541: PUSH
46542: LD_INT 7
46544: PUSH
46545: LD_INT 11
46547: PUSH
46548: LD_INT 12
46550: PUSH
46551: LD_INT 15
46553: PUSH
46554: LD_INT 16
46556: PUSH
46557: LD_INT 20
46559: PUSH
46560: LD_INT 21
46562: PUSH
46563: LD_INT 22
46565: PUSH
46566: LD_INT 23
46568: PUSH
46569: LD_INT 25
46571: PUSH
46572: LD_INT 26
46574: PUSH
46575: LD_INT 30
46577: PUSH
46578: LD_INT 31
46580: PUSH
46581: LD_INT 32
46583: PUSH
46584: LD_INT 33
46586: PUSH
46587: LD_INT 34
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: PUSH
46611: LD_INT 101
46613: PUSH
46614: LD_INT 102
46616: PUSH
46617: LD_INT 103
46619: PUSH
46620: LD_INT 106
46622: PUSH
46623: LD_INT 108
46625: PUSH
46626: LD_INT 112
46628: PUSH
46629: LD_INT 113
46631: PUSH
46632: LD_INT 114
46634: PUSH
46635: EMPTY
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: ST_TO_ADDR
46649: GO 47244
46651: LD_INT 17
46653: DOUBLE
46654: EQUAL
46655: IFTRUE 46659
46657: GO 46871
46659: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
46660: LD_ADDR_VAR 0 1
46664: PUSH
46665: LD_INT 1
46667: PUSH
46668: LD_INT 2
46670: PUSH
46671: LD_INT 3
46673: PUSH
46674: LD_INT 4
46676: PUSH
46677: LD_INT 5
46679: PUSH
46680: LD_INT 6
46682: PUSH
46683: LD_INT 7
46685: PUSH
46686: LD_INT 8
46688: PUSH
46689: LD_INT 9
46691: PUSH
46692: LD_INT 10
46694: PUSH
46695: LD_INT 11
46697: PUSH
46698: LD_INT 12
46700: PUSH
46701: LD_INT 13
46703: PUSH
46704: LD_INT 14
46706: PUSH
46707: LD_INT 15
46709: PUSH
46710: LD_INT 16
46712: PUSH
46713: LD_INT 17
46715: PUSH
46716: LD_INT 18
46718: PUSH
46719: LD_INT 19
46721: PUSH
46722: LD_INT 20
46724: PUSH
46725: LD_INT 21
46727: PUSH
46728: LD_INT 22
46730: PUSH
46731: LD_INT 23
46733: PUSH
46734: LD_INT 24
46736: PUSH
46737: LD_INT 25
46739: PUSH
46740: LD_INT 26
46742: PUSH
46743: LD_INT 27
46745: PUSH
46746: LD_INT 28
46748: PUSH
46749: LD_INT 29
46751: PUSH
46752: LD_INT 30
46754: PUSH
46755: LD_INT 31
46757: PUSH
46758: LD_INT 32
46760: PUSH
46761: LD_INT 33
46763: PUSH
46764: LD_INT 34
46766: PUSH
46767: LD_INT 36
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: PUSH
46807: LD_INT 101
46809: PUSH
46810: LD_INT 102
46812: PUSH
46813: LD_INT 103
46815: PUSH
46816: LD_INT 104
46818: PUSH
46819: LD_INT 105
46821: PUSH
46822: LD_INT 106
46824: PUSH
46825: LD_INT 107
46827: PUSH
46828: LD_INT 108
46830: PUSH
46831: LD_INT 109
46833: PUSH
46834: LD_INT 110
46836: PUSH
46837: LD_INT 111
46839: PUSH
46840: LD_INT 112
46842: PUSH
46843: LD_INT 113
46845: PUSH
46846: LD_INT 114
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: LIST
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: ST_TO_ADDR
46869: GO 47244
46871: LD_INT 18
46873: DOUBLE
46874: EQUAL
46875: IFTRUE 46879
46877: GO 47015
46879: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
46880: LD_ADDR_VAR 0 1
46884: PUSH
46885: LD_INT 2
46887: PUSH
46888: LD_INT 4
46890: PUSH
46891: LD_INT 5
46893: PUSH
46894: LD_INT 7
46896: PUSH
46897: LD_INT 11
46899: PUSH
46900: LD_INT 12
46902: PUSH
46903: LD_INT 15
46905: PUSH
46906: LD_INT 16
46908: PUSH
46909: LD_INT 20
46911: PUSH
46912: LD_INT 21
46914: PUSH
46915: LD_INT 22
46917: PUSH
46918: LD_INT 23
46920: PUSH
46921: LD_INT 25
46923: PUSH
46924: LD_INT 26
46926: PUSH
46927: LD_INT 30
46929: PUSH
46930: LD_INT 31
46932: PUSH
46933: LD_INT 32
46935: PUSH
46936: LD_INT 33
46938: PUSH
46939: LD_INT 34
46941: PUSH
46942: LD_INT 35
46944: PUSH
46945: LD_INT 36
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 101
46973: PUSH
46974: LD_INT 102
46976: PUSH
46977: LD_INT 103
46979: PUSH
46980: LD_INT 106
46982: PUSH
46983: LD_INT 108
46985: PUSH
46986: LD_INT 112
46988: PUSH
46989: LD_INT 113
46991: PUSH
46992: LD_INT 114
46994: PUSH
46995: LD_INT 115
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: LIST
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: ST_TO_ADDR
47013: GO 47244
47015: LD_INT 19
47017: DOUBLE
47018: EQUAL
47019: IFTRUE 47023
47021: GO 47243
47023: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47024: LD_ADDR_VAR 0 1
47028: PUSH
47029: LD_INT 1
47031: PUSH
47032: LD_INT 2
47034: PUSH
47035: LD_INT 3
47037: PUSH
47038: LD_INT 4
47040: PUSH
47041: LD_INT 5
47043: PUSH
47044: LD_INT 6
47046: PUSH
47047: LD_INT 7
47049: PUSH
47050: LD_INT 8
47052: PUSH
47053: LD_INT 9
47055: PUSH
47056: LD_INT 10
47058: PUSH
47059: LD_INT 11
47061: PUSH
47062: LD_INT 12
47064: PUSH
47065: LD_INT 13
47067: PUSH
47068: LD_INT 14
47070: PUSH
47071: LD_INT 15
47073: PUSH
47074: LD_INT 16
47076: PUSH
47077: LD_INT 17
47079: PUSH
47080: LD_INT 18
47082: PUSH
47083: LD_INT 19
47085: PUSH
47086: LD_INT 20
47088: PUSH
47089: LD_INT 21
47091: PUSH
47092: LD_INT 22
47094: PUSH
47095: LD_INT 23
47097: PUSH
47098: LD_INT 24
47100: PUSH
47101: LD_INT 25
47103: PUSH
47104: LD_INT 26
47106: PUSH
47107: LD_INT 27
47109: PUSH
47110: LD_INT 28
47112: PUSH
47113: LD_INT 29
47115: PUSH
47116: LD_INT 30
47118: PUSH
47119: LD_INT 31
47121: PUSH
47122: LD_INT 32
47124: PUSH
47125: LD_INT 33
47127: PUSH
47128: LD_INT 34
47130: PUSH
47131: LD_INT 35
47133: PUSH
47134: LD_INT 36
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: LIST
47166: LIST
47167: LIST
47168: LIST
47169: LIST
47170: LIST
47171: LIST
47172: LIST
47173: LIST
47174: PUSH
47175: LD_INT 101
47177: PUSH
47178: LD_INT 102
47180: PUSH
47181: LD_INT 103
47183: PUSH
47184: LD_INT 104
47186: PUSH
47187: LD_INT 105
47189: PUSH
47190: LD_INT 106
47192: PUSH
47193: LD_INT 107
47195: PUSH
47196: LD_INT 108
47198: PUSH
47199: LD_INT 109
47201: PUSH
47202: LD_INT 110
47204: PUSH
47205: LD_INT 111
47207: PUSH
47208: LD_INT 112
47210: PUSH
47211: LD_INT 113
47213: PUSH
47214: LD_INT 114
47216: PUSH
47217: LD_INT 115
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: PUSH
47237: EMPTY
47238: LIST
47239: LIST
47240: ST_TO_ADDR
47241: GO 47244
47243: POP
// end else
47244: GO 47463
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47246: LD_ADDR_VAR 0 1
47250: PUSH
47251: LD_INT 1
47253: PUSH
47254: LD_INT 2
47256: PUSH
47257: LD_INT 3
47259: PUSH
47260: LD_INT 4
47262: PUSH
47263: LD_INT 5
47265: PUSH
47266: LD_INT 6
47268: PUSH
47269: LD_INT 7
47271: PUSH
47272: LD_INT 8
47274: PUSH
47275: LD_INT 9
47277: PUSH
47278: LD_INT 10
47280: PUSH
47281: LD_INT 11
47283: PUSH
47284: LD_INT 12
47286: PUSH
47287: LD_INT 13
47289: PUSH
47290: LD_INT 14
47292: PUSH
47293: LD_INT 15
47295: PUSH
47296: LD_INT 16
47298: PUSH
47299: LD_INT 17
47301: PUSH
47302: LD_INT 18
47304: PUSH
47305: LD_INT 19
47307: PUSH
47308: LD_INT 20
47310: PUSH
47311: LD_INT 21
47313: PUSH
47314: LD_INT 22
47316: PUSH
47317: LD_INT 23
47319: PUSH
47320: LD_INT 24
47322: PUSH
47323: LD_INT 25
47325: PUSH
47326: LD_INT 26
47328: PUSH
47329: LD_INT 27
47331: PUSH
47332: LD_INT 28
47334: PUSH
47335: LD_INT 29
47337: PUSH
47338: LD_INT 30
47340: PUSH
47341: LD_INT 31
47343: PUSH
47344: LD_INT 32
47346: PUSH
47347: LD_INT 33
47349: PUSH
47350: LD_INT 34
47352: PUSH
47353: LD_INT 35
47355: PUSH
47356: LD_INT 36
47358: PUSH
47359: EMPTY
47360: LIST
47361: LIST
47362: LIST
47363: LIST
47364: LIST
47365: LIST
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 101
47399: PUSH
47400: LD_INT 102
47402: PUSH
47403: LD_INT 103
47405: PUSH
47406: LD_INT 104
47408: PUSH
47409: LD_INT 105
47411: PUSH
47412: LD_INT 106
47414: PUSH
47415: LD_INT 107
47417: PUSH
47418: LD_INT 108
47420: PUSH
47421: LD_INT 109
47423: PUSH
47424: LD_INT 110
47426: PUSH
47427: LD_INT 111
47429: PUSH
47430: LD_INT 112
47432: PUSH
47433: LD_INT 113
47435: PUSH
47436: LD_INT 114
47438: PUSH
47439: LD_INT 115
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: ST_TO_ADDR
// if result then
47463: LD_VAR 0 1
47467: IFFALSE 47756
// begin normal :=  ;
47469: LD_ADDR_VAR 0 3
47473: PUSH
47474: LD_STRING 
47476: ST_TO_ADDR
// hardcore :=  ;
47477: LD_ADDR_VAR 0 4
47481: PUSH
47482: LD_STRING 
47484: ST_TO_ADDR
// for i = 1 to normalCounter do
47485: LD_ADDR_VAR 0 5
47489: PUSH
47490: DOUBLE
47491: LD_INT 1
47493: DEC
47494: ST_TO_ADDR
47495: LD_EXP 90
47499: PUSH
47500: FOR_TO
47501: IFFALSE 47602
// begin tmp := 0 ;
47503: LD_ADDR_VAR 0 2
47507: PUSH
47508: LD_STRING 0
47510: ST_TO_ADDR
// if result [ 1 ] then
47511: LD_VAR 0 1
47515: PUSH
47516: LD_INT 1
47518: ARRAY
47519: IFFALSE 47584
// if result [ 1 ] [ 1 ] = i then
47521: LD_VAR 0 1
47525: PUSH
47526: LD_INT 1
47528: ARRAY
47529: PUSH
47530: LD_INT 1
47532: ARRAY
47533: PUSH
47534: LD_VAR 0 5
47538: EQUAL
47539: IFFALSE 47584
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
47541: LD_ADDR_VAR 0 1
47545: PUSH
47546: LD_VAR 0 1
47550: PPUSH
47551: LD_INT 1
47553: PPUSH
47554: LD_VAR 0 1
47558: PUSH
47559: LD_INT 1
47561: ARRAY
47562: PPUSH
47563: LD_INT 1
47565: PPUSH
47566: CALL_OW 3
47570: PPUSH
47571: CALL_OW 1
47575: ST_TO_ADDR
// tmp := 1 ;
47576: LD_ADDR_VAR 0 2
47580: PUSH
47581: LD_STRING 1
47583: ST_TO_ADDR
// end ; normal := normal & tmp ;
47584: LD_ADDR_VAR 0 3
47588: PUSH
47589: LD_VAR 0 3
47593: PUSH
47594: LD_VAR 0 2
47598: STR
47599: ST_TO_ADDR
// end ;
47600: GO 47500
47602: POP
47603: POP
// for i = 1 to hardcoreCounter do
47604: LD_ADDR_VAR 0 5
47608: PUSH
47609: DOUBLE
47610: LD_INT 1
47612: DEC
47613: ST_TO_ADDR
47614: LD_EXP 91
47618: PUSH
47619: FOR_TO
47620: IFFALSE 47725
// begin tmp := 0 ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_STRING 0
47629: ST_TO_ADDR
// if result [ 2 ] then
47630: LD_VAR 0 1
47634: PUSH
47635: LD_INT 2
47637: ARRAY
47638: IFFALSE 47707
// if result [ 2 ] [ 1 ] = 100 + i then
47640: LD_VAR 0 1
47644: PUSH
47645: LD_INT 2
47647: ARRAY
47648: PUSH
47649: LD_INT 1
47651: ARRAY
47652: PUSH
47653: LD_INT 100
47655: PUSH
47656: LD_VAR 0 5
47660: PLUS
47661: EQUAL
47662: IFFALSE 47707
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
47664: LD_ADDR_VAR 0 1
47668: PUSH
47669: LD_VAR 0 1
47673: PPUSH
47674: LD_INT 2
47676: PPUSH
47677: LD_VAR 0 1
47681: PUSH
47682: LD_INT 2
47684: ARRAY
47685: PPUSH
47686: LD_INT 1
47688: PPUSH
47689: CALL_OW 3
47693: PPUSH
47694: CALL_OW 1
47698: ST_TO_ADDR
// tmp := 1 ;
47699: LD_ADDR_VAR 0 2
47703: PUSH
47704: LD_STRING 1
47706: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
47707: LD_ADDR_VAR 0 4
47711: PUSH
47712: LD_VAR 0 4
47716: PUSH
47717: LD_VAR 0 2
47721: STR
47722: ST_TO_ADDR
// end ;
47723: GO 47619
47725: POP
47726: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
47727: LD_STRING getStreamItemsFromMission("
47729: PUSH
47730: LD_VAR 0 3
47734: STR
47735: PUSH
47736: LD_STRING ","
47738: STR
47739: PUSH
47740: LD_VAR 0 4
47744: STR
47745: PUSH
47746: LD_STRING ")
47748: STR
47749: PPUSH
47750: CALL_OW 559
// end else
47754: GO 47763
// ToLua ( getStreamItemsFromMission("","") ) ;
47756: LD_STRING getStreamItemsFromMission("","")
47758: PPUSH
47759: CALL_OW 559
// end ;
47763: LD_VAR 0 1
47767: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
47768: LD_VAR 0 2
47772: PUSH
47773: LD_INT 100
47775: EQUAL
47776: IFFALSE 48725
// begin if not StreamModeActive then
47778: LD_EXP 89
47782: NOT
47783: IFFALSE 47793
// StreamModeActive := true ;
47785: LD_ADDR_EXP 89
47789: PUSH
47790: LD_INT 1
47792: ST_TO_ADDR
// if p3 = 0 then
47793: LD_VAR 0 3
47797: PUSH
47798: LD_INT 0
47800: EQUAL
47801: IFFALSE 47807
// InitStreamMode ;
47803: CALL 43846 0 0
// if p3 = 1 then
47807: LD_VAR 0 3
47811: PUSH
47812: LD_INT 1
47814: EQUAL
47815: IFFALSE 47825
// sRocket := true ;
47817: LD_ADDR_EXP 94
47821: PUSH
47822: LD_INT 1
47824: ST_TO_ADDR
// if p3 = 2 then
47825: LD_VAR 0 3
47829: PUSH
47830: LD_INT 2
47832: EQUAL
47833: IFFALSE 47843
// sSpeed := true ;
47835: LD_ADDR_EXP 93
47839: PUSH
47840: LD_INT 1
47842: ST_TO_ADDR
// if p3 = 3 then
47843: LD_VAR 0 3
47847: PUSH
47848: LD_INT 3
47850: EQUAL
47851: IFFALSE 47861
// sEngine := true ;
47853: LD_ADDR_EXP 95
47857: PUSH
47858: LD_INT 1
47860: ST_TO_ADDR
// if p3 = 4 then
47861: LD_VAR 0 3
47865: PUSH
47866: LD_INT 4
47868: EQUAL
47869: IFFALSE 47879
// sSpec := true ;
47871: LD_ADDR_EXP 92
47875: PUSH
47876: LD_INT 1
47878: ST_TO_ADDR
// if p3 = 5 then
47879: LD_VAR 0 3
47883: PUSH
47884: LD_INT 5
47886: EQUAL
47887: IFFALSE 47897
// sLevel := true ;
47889: LD_ADDR_EXP 96
47893: PUSH
47894: LD_INT 1
47896: ST_TO_ADDR
// if p3 = 6 then
47897: LD_VAR 0 3
47901: PUSH
47902: LD_INT 6
47904: EQUAL
47905: IFFALSE 47915
// sArmoury := true ;
47907: LD_ADDR_EXP 97
47911: PUSH
47912: LD_INT 1
47914: ST_TO_ADDR
// if p3 = 7 then
47915: LD_VAR 0 3
47919: PUSH
47920: LD_INT 7
47922: EQUAL
47923: IFFALSE 47933
// sRadar := true ;
47925: LD_ADDR_EXP 98
47929: PUSH
47930: LD_INT 1
47932: ST_TO_ADDR
// if p3 = 8 then
47933: LD_VAR 0 3
47937: PUSH
47938: LD_INT 8
47940: EQUAL
47941: IFFALSE 47951
// sBunker := true ;
47943: LD_ADDR_EXP 99
47947: PUSH
47948: LD_INT 1
47950: ST_TO_ADDR
// if p3 = 9 then
47951: LD_VAR 0 3
47955: PUSH
47956: LD_INT 9
47958: EQUAL
47959: IFFALSE 47969
// sHack := true ;
47961: LD_ADDR_EXP 100
47965: PUSH
47966: LD_INT 1
47968: ST_TO_ADDR
// if p3 = 10 then
47969: LD_VAR 0 3
47973: PUSH
47974: LD_INT 10
47976: EQUAL
47977: IFFALSE 47987
// sFire := true ;
47979: LD_ADDR_EXP 101
47983: PUSH
47984: LD_INT 1
47986: ST_TO_ADDR
// if p3 = 11 then
47987: LD_VAR 0 3
47991: PUSH
47992: LD_INT 11
47994: EQUAL
47995: IFFALSE 48005
// sRefresh := true ;
47997: LD_ADDR_EXP 102
48001: PUSH
48002: LD_INT 1
48004: ST_TO_ADDR
// if p3 = 12 then
48005: LD_VAR 0 3
48009: PUSH
48010: LD_INT 12
48012: EQUAL
48013: IFFALSE 48023
// sExp := true ;
48015: LD_ADDR_EXP 103
48019: PUSH
48020: LD_INT 1
48022: ST_TO_ADDR
// if p3 = 13 then
48023: LD_VAR 0 3
48027: PUSH
48028: LD_INT 13
48030: EQUAL
48031: IFFALSE 48041
// sDepot := true ;
48033: LD_ADDR_EXP 104
48037: PUSH
48038: LD_INT 1
48040: ST_TO_ADDR
// if p3 = 14 then
48041: LD_VAR 0 3
48045: PUSH
48046: LD_INT 14
48048: EQUAL
48049: IFFALSE 48059
// sFlag := true ;
48051: LD_ADDR_EXP 105
48055: PUSH
48056: LD_INT 1
48058: ST_TO_ADDR
// if p3 = 15 then
48059: LD_VAR 0 3
48063: PUSH
48064: LD_INT 15
48066: EQUAL
48067: IFFALSE 48077
// sKamikadze := true ;
48069: LD_ADDR_EXP 113
48073: PUSH
48074: LD_INT 1
48076: ST_TO_ADDR
// if p3 = 16 then
48077: LD_VAR 0 3
48081: PUSH
48082: LD_INT 16
48084: EQUAL
48085: IFFALSE 48095
// sTroll := true ;
48087: LD_ADDR_EXP 114
48091: PUSH
48092: LD_INT 1
48094: ST_TO_ADDR
// if p3 = 17 then
48095: LD_VAR 0 3
48099: PUSH
48100: LD_INT 17
48102: EQUAL
48103: IFFALSE 48113
// sSlow := true ;
48105: LD_ADDR_EXP 115
48109: PUSH
48110: LD_INT 1
48112: ST_TO_ADDR
// if p3 = 18 then
48113: LD_VAR 0 3
48117: PUSH
48118: LD_INT 18
48120: EQUAL
48121: IFFALSE 48131
// sLack := true ;
48123: LD_ADDR_EXP 116
48127: PUSH
48128: LD_INT 1
48130: ST_TO_ADDR
// if p3 = 19 then
48131: LD_VAR 0 3
48135: PUSH
48136: LD_INT 19
48138: EQUAL
48139: IFFALSE 48149
// sTank := true ;
48141: LD_ADDR_EXP 118
48145: PUSH
48146: LD_INT 1
48148: ST_TO_ADDR
// if p3 = 20 then
48149: LD_VAR 0 3
48153: PUSH
48154: LD_INT 20
48156: EQUAL
48157: IFFALSE 48167
// sRemote := true ;
48159: LD_ADDR_EXP 119
48163: PUSH
48164: LD_INT 1
48166: ST_TO_ADDR
// if p3 = 21 then
48167: LD_VAR 0 3
48171: PUSH
48172: LD_INT 21
48174: EQUAL
48175: IFFALSE 48185
// sPowell := true ;
48177: LD_ADDR_EXP 120
48181: PUSH
48182: LD_INT 1
48184: ST_TO_ADDR
// if p3 = 22 then
48185: LD_VAR 0 3
48189: PUSH
48190: LD_INT 22
48192: EQUAL
48193: IFFALSE 48203
// sTeleport := true ;
48195: LD_ADDR_EXP 123
48199: PUSH
48200: LD_INT 1
48202: ST_TO_ADDR
// if p3 = 23 then
48203: LD_VAR 0 3
48207: PUSH
48208: LD_INT 23
48210: EQUAL
48211: IFFALSE 48221
// sOilTower := true ;
48213: LD_ADDR_EXP 125
48217: PUSH
48218: LD_INT 1
48220: ST_TO_ADDR
// if p3 = 24 then
48221: LD_VAR 0 3
48225: PUSH
48226: LD_INT 24
48228: EQUAL
48229: IFFALSE 48239
// sShovel := true ;
48231: LD_ADDR_EXP 126
48235: PUSH
48236: LD_INT 1
48238: ST_TO_ADDR
// if p3 = 25 then
48239: LD_VAR 0 3
48243: PUSH
48244: LD_INT 25
48246: EQUAL
48247: IFFALSE 48257
// sSheik := true ;
48249: LD_ADDR_EXP 127
48253: PUSH
48254: LD_INT 1
48256: ST_TO_ADDR
// if p3 = 26 then
48257: LD_VAR 0 3
48261: PUSH
48262: LD_INT 26
48264: EQUAL
48265: IFFALSE 48275
// sEarthquake := true ;
48267: LD_ADDR_EXP 129
48271: PUSH
48272: LD_INT 1
48274: ST_TO_ADDR
// if p3 = 27 then
48275: LD_VAR 0 3
48279: PUSH
48280: LD_INT 27
48282: EQUAL
48283: IFFALSE 48293
// sAI := true ;
48285: LD_ADDR_EXP 130
48289: PUSH
48290: LD_INT 1
48292: ST_TO_ADDR
// if p3 = 28 then
48293: LD_VAR 0 3
48297: PUSH
48298: LD_INT 28
48300: EQUAL
48301: IFFALSE 48311
// sCargo := true ;
48303: LD_ADDR_EXP 133
48307: PUSH
48308: LD_INT 1
48310: ST_TO_ADDR
// if p3 = 29 then
48311: LD_VAR 0 3
48315: PUSH
48316: LD_INT 29
48318: EQUAL
48319: IFFALSE 48329
// sDLaser := true ;
48321: LD_ADDR_EXP 134
48325: PUSH
48326: LD_INT 1
48328: ST_TO_ADDR
// if p3 = 30 then
48329: LD_VAR 0 3
48333: PUSH
48334: LD_INT 30
48336: EQUAL
48337: IFFALSE 48347
// sExchange := true ;
48339: LD_ADDR_EXP 135
48343: PUSH
48344: LD_INT 1
48346: ST_TO_ADDR
// if p3 = 31 then
48347: LD_VAR 0 3
48351: PUSH
48352: LD_INT 31
48354: EQUAL
48355: IFFALSE 48365
// sFac := true ;
48357: LD_ADDR_EXP 136
48361: PUSH
48362: LD_INT 1
48364: ST_TO_ADDR
// if p3 = 32 then
48365: LD_VAR 0 3
48369: PUSH
48370: LD_INT 32
48372: EQUAL
48373: IFFALSE 48383
// sPower := true ;
48375: LD_ADDR_EXP 137
48379: PUSH
48380: LD_INT 1
48382: ST_TO_ADDR
// if p3 = 33 then
48383: LD_VAR 0 3
48387: PUSH
48388: LD_INT 33
48390: EQUAL
48391: IFFALSE 48401
// sRandom := true ;
48393: LD_ADDR_EXP 138
48397: PUSH
48398: LD_INT 1
48400: ST_TO_ADDR
// if p3 = 34 then
48401: LD_VAR 0 3
48405: PUSH
48406: LD_INT 34
48408: EQUAL
48409: IFFALSE 48419
// sShield := true ;
48411: LD_ADDR_EXP 139
48415: PUSH
48416: LD_INT 1
48418: ST_TO_ADDR
// if p3 = 35 then
48419: LD_VAR 0 3
48423: PUSH
48424: LD_INT 35
48426: EQUAL
48427: IFFALSE 48437
// sTime := true ;
48429: LD_ADDR_EXP 140
48433: PUSH
48434: LD_INT 1
48436: ST_TO_ADDR
// if p3 = 36 then
48437: LD_VAR 0 3
48441: PUSH
48442: LD_INT 36
48444: EQUAL
48445: IFFALSE 48455
// sTools := true ;
48447: LD_ADDR_EXP 141
48451: PUSH
48452: LD_INT 1
48454: ST_TO_ADDR
// if p3 = 101 then
48455: LD_VAR 0 3
48459: PUSH
48460: LD_INT 101
48462: EQUAL
48463: IFFALSE 48473
// sSold := true ;
48465: LD_ADDR_EXP 106
48469: PUSH
48470: LD_INT 1
48472: ST_TO_ADDR
// if p3 = 102 then
48473: LD_VAR 0 3
48477: PUSH
48478: LD_INT 102
48480: EQUAL
48481: IFFALSE 48491
// sDiff := true ;
48483: LD_ADDR_EXP 107
48487: PUSH
48488: LD_INT 1
48490: ST_TO_ADDR
// if p3 = 103 then
48491: LD_VAR 0 3
48495: PUSH
48496: LD_INT 103
48498: EQUAL
48499: IFFALSE 48509
// sFog := true ;
48501: LD_ADDR_EXP 110
48505: PUSH
48506: LD_INT 1
48508: ST_TO_ADDR
// if p3 = 104 then
48509: LD_VAR 0 3
48513: PUSH
48514: LD_INT 104
48516: EQUAL
48517: IFFALSE 48527
// sReset := true ;
48519: LD_ADDR_EXP 111
48523: PUSH
48524: LD_INT 1
48526: ST_TO_ADDR
// if p3 = 105 then
48527: LD_VAR 0 3
48531: PUSH
48532: LD_INT 105
48534: EQUAL
48535: IFFALSE 48545
// sSun := true ;
48537: LD_ADDR_EXP 112
48541: PUSH
48542: LD_INT 1
48544: ST_TO_ADDR
// if p3 = 106 then
48545: LD_VAR 0 3
48549: PUSH
48550: LD_INT 106
48552: EQUAL
48553: IFFALSE 48563
// sTiger := true ;
48555: LD_ADDR_EXP 108
48559: PUSH
48560: LD_INT 1
48562: ST_TO_ADDR
// if p3 = 107 then
48563: LD_VAR 0 3
48567: PUSH
48568: LD_INT 107
48570: EQUAL
48571: IFFALSE 48581
// sBomb := true ;
48573: LD_ADDR_EXP 109
48577: PUSH
48578: LD_INT 1
48580: ST_TO_ADDR
// if p3 = 108 then
48581: LD_VAR 0 3
48585: PUSH
48586: LD_INT 108
48588: EQUAL
48589: IFFALSE 48599
// sWound := true ;
48591: LD_ADDR_EXP 117
48595: PUSH
48596: LD_INT 1
48598: ST_TO_ADDR
// if p3 = 109 then
48599: LD_VAR 0 3
48603: PUSH
48604: LD_INT 109
48606: EQUAL
48607: IFFALSE 48617
// sBetray := true ;
48609: LD_ADDR_EXP 121
48613: PUSH
48614: LD_INT 1
48616: ST_TO_ADDR
// if p3 = 110 then
48617: LD_VAR 0 3
48621: PUSH
48622: LD_INT 110
48624: EQUAL
48625: IFFALSE 48635
// sContamin := true ;
48627: LD_ADDR_EXP 122
48631: PUSH
48632: LD_INT 1
48634: ST_TO_ADDR
// if p3 = 111 then
48635: LD_VAR 0 3
48639: PUSH
48640: LD_INT 111
48642: EQUAL
48643: IFFALSE 48653
// sOil := true ;
48645: LD_ADDR_EXP 124
48649: PUSH
48650: LD_INT 1
48652: ST_TO_ADDR
// if p3 = 112 then
48653: LD_VAR 0 3
48657: PUSH
48658: LD_INT 112
48660: EQUAL
48661: IFFALSE 48671
// sStu := true ;
48663: LD_ADDR_EXP 128
48667: PUSH
48668: LD_INT 1
48670: ST_TO_ADDR
// if p3 = 113 then
48671: LD_VAR 0 3
48675: PUSH
48676: LD_INT 113
48678: EQUAL
48679: IFFALSE 48689
// sBazooka := true ;
48681: LD_ADDR_EXP 131
48685: PUSH
48686: LD_INT 1
48688: ST_TO_ADDR
// if p3 = 114 then
48689: LD_VAR 0 3
48693: PUSH
48694: LD_INT 114
48696: EQUAL
48697: IFFALSE 48707
// sMortar := true ;
48699: LD_ADDR_EXP 132
48703: PUSH
48704: LD_INT 1
48706: ST_TO_ADDR
// if p3 = 115 then
48707: LD_VAR 0 3
48711: PUSH
48712: LD_INT 115
48714: EQUAL
48715: IFFALSE 48725
// sRanger := true ;
48717: LD_ADDR_EXP 142
48721: PUSH
48722: LD_INT 1
48724: ST_TO_ADDR
// end ; end ;
48725: PPOPN 6
48727: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48728: LD_EXP 89
48732: PUSH
48733: LD_EXP 94
48737: AND
48738: IFFALSE 48862
48740: GO 48742
48742: DISABLE
48743: LD_INT 0
48745: PPUSH
48746: PPUSH
// begin enable ;
48747: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48748: LD_ADDR_VAR 0 2
48752: PUSH
48753: LD_INT 22
48755: PUSH
48756: LD_OWVAR 2
48760: PUSH
48761: EMPTY
48762: LIST
48763: LIST
48764: PUSH
48765: LD_INT 2
48767: PUSH
48768: LD_INT 34
48770: PUSH
48771: LD_INT 7
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 34
48780: PUSH
48781: LD_INT 45
48783: PUSH
48784: EMPTY
48785: LIST
48786: LIST
48787: PUSH
48788: LD_INT 34
48790: PUSH
48791: LD_INT 28
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: PUSH
48798: LD_INT 34
48800: PUSH
48801: LD_INT 47
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PPUSH
48819: CALL_OW 69
48823: ST_TO_ADDR
// if not tmp then
48824: LD_VAR 0 2
48828: NOT
48829: IFFALSE 48833
// exit ;
48831: GO 48862
// for i in tmp do
48833: LD_ADDR_VAR 0 1
48837: PUSH
48838: LD_VAR 0 2
48842: PUSH
48843: FOR_IN
48844: IFFALSE 48860
// begin SetLives ( i , 0 ) ;
48846: LD_VAR 0 1
48850: PPUSH
48851: LD_INT 0
48853: PPUSH
48854: CALL_OW 234
// end ;
48858: GO 48843
48860: POP
48861: POP
// end ;
48862: PPOPN 2
48864: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48865: LD_EXP 89
48869: PUSH
48870: LD_EXP 95
48874: AND
48875: IFFALSE 48959
48877: GO 48879
48879: DISABLE
48880: LD_INT 0
48882: PPUSH
48883: PPUSH
// begin enable ;
48884: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48885: LD_ADDR_VAR 0 2
48889: PUSH
48890: LD_INT 22
48892: PUSH
48893: LD_OWVAR 2
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PUSH
48902: LD_INT 32
48904: PUSH
48905: LD_INT 3
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: PPUSH
48916: CALL_OW 69
48920: ST_TO_ADDR
// if not tmp then
48921: LD_VAR 0 2
48925: NOT
48926: IFFALSE 48930
// exit ;
48928: GO 48959
// for i in tmp do
48930: LD_ADDR_VAR 0 1
48934: PUSH
48935: LD_VAR 0 2
48939: PUSH
48940: FOR_IN
48941: IFFALSE 48957
// begin SetLives ( i , 0 ) ;
48943: LD_VAR 0 1
48947: PPUSH
48948: LD_INT 0
48950: PPUSH
48951: CALL_OW 234
// end ;
48955: GO 48940
48957: POP
48958: POP
// end ;
48959: PPOPN 2
48961: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48962: LD_EXP 89
48966: PUSH
48967: LD_EXP 92
48971: AND
48972: IFFALSE 49065
48974: GO 48976
48976: DISABLE
48977: LD_INT 0
48979: PPUSH
// begin enable ;
48980: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48981: LD_ADDR_VAR 0 1
48985: PUSH
48986: LD_INT 22
48988: PUSH
48989: LD_OWVAR 2
48993: PUSH
48994: EMPTY
48995: LIST
48996: LIST
48997: PUSH
48998: LD_INT 2
49000: PUSH
49001: LD_INT 25
49003: PUSH
49004: LD_INT 5
49006: PUSH
49007: EMPTY
49008: LIST
49009: LIST
49010: PUSH
49011: LD_INT 25
49013: PUSH
49014: LD_INT 9
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 25
49023: PUSH
49024: LD_INT 8
49026: PUSH
49027: EMPTY
49028: LIST
49029: LIST
49030: PUSH
49031: EMPTY
49032: LIST
49033: LIST
49034: LIST
49035: LIST
49036: PUSH
49037: EMPTY
49038: LIST
49039: LIST
49040: PPUSH
49041: CALL_OW 69
49045: PUSH
49046: FOR_IN
49047: IFFALSE 49063
// begin SetClass ( i , 1 ) ;
49049: LD_VAR 0 1
49053: PPUSH
49054: LD_INT 1
49056: PPUSH
49057: CALL_OW 336
// end ;
49061: GO 49046
49063: POP
49064: POP
// end ;
49065: PPOPN 1
49067: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49068: LD_EXP 89
49072: PUSH
49073: LD_EXP 93
49077: AND
49078: PUSH
49079: LD_OWVAR 65
49083: PUSH
49084: LD_INT 7
49086: LESS
49087: AND
49088: IFFALSE 49102
49090: GO 49092
49092: DISABLE
// begin enable ;
49093: ENABLE
// game_speed := 7 ;
49094: LD_ADDR_OWVAR 65
49098: PUSH
49099: LD_INT 7
49101: ST_TO_ADDR
// end ;
49102: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49103: LD_EXP 89
49107: PUSH
49108: LD_EXP 96
49112: AND
49113: IFFALSE 49315
49115: GO 49117
49117: DISABLE
49118: LD_INT 0
49120: PPUSH
49121: PPUSH
49122: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49123: LD_ADDR_VAR 0 3
49127: PUSH
49128: LD_INT 81
49130: PUSH
49131: LD_OWVAR 2
49135: PUSH
49136: EMPTY
49137: LIST
49138: LIST
49139: PUSH
49140: LD_INT 21
49142: PUSH
49143: LD_INT 1
49145: PUSH
49146: EMPTY
49147: LIST
49148: LIST
49149: PUSH
49150: EMPTY
49151: LIST
49152: LIST
49153: PPUSH
49154: CALL_OW 69
49158: ST_TO_ADDR
// if not tmp then
49159: LD_VAR 0 3
49163: NOT
49164: IFFALSE 49168
// exit ;
49166: GO 49315
// if tmp > 5 then
49168: LD_VAR 0 3
49172: PUSH
49173: LD_INT 5
49175: GREATER
49176: IFFALSE 49188
// k := 5 else
49178: LD_ADDR_VAR 0 2
49182: PUSH
49183: LD_INT 5
49185: ST_TO_ADDR
49186: GO 49198
// k := tmp ;
49188: LD_ADDR_VAR 0 2
49192: PUSH
49193: LD_VAR 0 3
49197: ST_TO_ADDR
// for i := 1 to k do
49198: LD_ADDR_VAR 0 1
49202: PUSH
49203: DOUBLE
49204: LD_INT 1
49206: DEC
49207: ST_TO_ADDR
49208: LD_VAR 0 2
49212: PUSH
49213: FOR_TO
49214: IFFALSE 49313
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49216: LD_VAR 0 3
49220: PUSH
49221: LD_VAR 0 1
49225: ARRAY
49226: PPUSH
49227: LD_VAR 0 1
49231: PUSH
49232: LD_INT 4
49234: MOD
49235: PUSH
49236: LD_INT 1
49238: PLUS
49239: PPUSH
49240: CALL_OW 259
49244: PUSH
49245: LD_INT 10
49247: LESS
49248: IFFALSE 49311
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49250: LD_VAR 0 3
49254: PUSH
49255: LD_VAR 0 1
49259: ARRAY
49260: PPUSH
49261: LD_VAR 0 1
49265: PUSH
49266: LD_INT 4
49268: MOD
49269: PUSH
49270: LD_INT 1
49272: PLUS
49273: PPUSH
49274: LD_VAR 0 3
49278: PUSH
49279: LD_VAR 0 1
49283: ARRAY
49284: PPUSH
49285: LD_VAR 0 1
49289: PUSH
49290: LD_INT 4
49292: MOD
49293: PUSH
49294: LD_INT 1
49296: PLUS
49297: PPUSH
49298: CALL_OW 259
49302: PUSH
49303: LD_INT 1
49305: PLUS
49306: PPUSH
49307: CALL_OW 237
49311: GO 49213
49313: POP
49314: POP
// end ;
49315: PPOPN 3
49317: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49318: LD_EXP 89
49322: PUSH
49323: LD_EXP 97
49327: AND
49328: IFFALSE 49348
49330: GO 49332
49332: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49333: LD_INT 4
49335: PPUSH
49336: LD_OWVAR 2
49340: PPUSH
49341: LD_INT 0
49343: PPUSH
49344: CALL_OW 324
49348: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49349: LD_EXP 89
49353: PUSH
49354: LD_EXP 126
49358: AND
49359: IFFALSE 49379
49361: GO 49363
49363: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49364: LD_INT 19
49366: PPUSH
49367: LD_OWVAR 2
49371: PPUSH
49372: LD_INT 0
49374: PPUSH
49375: CALL_OW 324
49379: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49380: LD_EXP 89
49384: PUSH
49385: LD_EXP 98
49389: AND
49390: IFFALSE 49492
49392: GO 49394
49394: DISABLE
49395: LD_INT 0
49397: PPUSH
49398: PPUSH
// begin enable ;
49399: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49400: LD_ADDR_VAR 0 2
49404: PUSH
49405: LD_INT 22
49407: PUSH
49408: LD_OWVAR 2
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: PUSH
49417: LD_INT 2
49419: PUSH
49420: LD_INT 34
49422: PUSH
49423: LD_INT 11
49425: PUSH
49426: EMPTY
49427: LIST
49428: LIST
49429: PUSH
49430: LD_INT 34
49432: PUSH
49433: LD_INT 30
49435: PUSH
49436: EMPTY
49437: LIST
49438: LIST
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: LIST
49444: PUSH
49445: EMPTY
49446: LIST
49447: LIST
49448: PPUSH
49449: CALL_OW 69
49453: ST_TO_ADDR
// if not tmp then
49454: LD_VAR 0 2
49458: NOT
49459: IFFALSE 49463
// exit ;
49461: GO 49492
// for i in tmp do
49463: LD_ADDR_VAR 0 1
49467: PUSH
49468: LD_VAR 0 2
49472: PUSH
49473: FOR_IN
49474: IFFALSE 49490
// begin SetLives ( i , 0 ) ;
49476: LD_VAR 0 1
49480: PPUSH
49481: LD_INT 0
49483: PPUSH
49484: CALL_OW 234
// end ;
49488: GO 49473
49490: POP
49491: POP
// end ;
49492: PPOPN 2
49494: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49495: LD_EXP 89
49499: PUSH
49500: LD_EXP 99
49504: AND
49505: IFFALSE 49525
49507: GO 49509
49509: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49510: LD_INT 32
49512: PPUSH
49513: LD_OWVAR 2
49517: PPUSH
49518: LD_INT 0
49520: PPUSH
49521: CALL_OW 324
49525: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49526: LD_EXP 89
49530: PUSH
49531: LD_EXP 100
49535: AND
49536: IFFALSE 49717
49538: GO 49540
49540: DISABLE
49541: LD_INT 0
49543: PPUSH
49544: PPUSH
49545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49546: LD_ADDR_VAR 0 2
49550: PUSH
49551: LD_INT 22
49553: PUSH
49554: LD_OWVAR 2
49558: PUSH
49559: EMPTY
49560: LIST
49561: LIST
49562: PUSH
49563: LD_INT 33
49565: PUSH
49566: LD_INT 3
49568: PUSH
49569: EMPTY
49570: LIST
49571: LIST
49572: PUSH
49573: EMPTY
49574: LIST
49575: LIST
49576: PPUSH
49577: CALL_OW 69
49581: ST_TO_ADDR
// if not tmp then
49582: LD_VAR 0 2
49586: NOT
49587: IFFALSE 49591
// exit ;
49589: GO 49717
// side := 0 ;
49591: LD_ADDR_VAR 0 3
49595: PUSH
49596: LD_INT 0
49598: ST_TO_ADDR
// for i := 1 to 8 do
49599: LD_ADDR_VAR 0 1
49603: PUSH
49604: DOUBLE
49605: LD_INT 1
49607: DEC
49608: ST_TO_ADDR
49609: LD_INT 8
49611: PUSH
49612: FOR_TO
49613: IFFALSE 49661
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49615: LD_OWVAR 2
49619: PUSH
49620: LD_VAR 0 1
49624: NONEQUAL
49625: PUSH
49626: LD_OWVAR 2
49630: PPUSH
49631: LD_VAR 0 1
49635: PPUSH
49636: CALL_OW 81
49640: PUSH
49641: LD_INT 2
49643: EQUAL
49644: AND
49645: IFFALSE 49659
// begin side := i ;
49647: LD_ADDR_VAR 0 3
49651: PUSH
49652: LD_VAR 0 1
49656: ST_TO_ADDR
// break ;
49657: GO 49661
// end ;
49659: GO 49612
49661: POP
49662: POP
// if not side then
49663: LD_VAR 0 3
49667: NOT
49668: IFFALSE 49672
// exit ;
49670: GO 49717
// for i := 1 to tmp do
49672: LD_ADDR_VAR 0 1
49676: PUSH
49677: DOUBLE
49678: LD_INT 1
49680: DEC
49681: ST_TO_ADDR
49682: LD_VAR 0 2
49686: PUSH
49687: FOR_TO
49688: IFFALSE 49715
// if Prob ( 60 ) then
49690: LD_INT 60
49692: PPUSH
49693: CALL_OW 13
49697: IFFALSE 49713
// SetSide ( i , side ) ;
49699: LD_VAR 0 1
49703: PPUSH
49704: LD_VAR 0 3
49708: PPUSH
49709: CALL_OW 235
49713: GO 49687
49715: POP
49716: POP
// end ;
49717: PPOPN 3
49719: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49720: LD_EXP 89
49724: PUSH
49725: LD_EXP 102
49729: AND
49730: IFFALSE 49849
49732: GO 49734
49734: DISABLE
49735: LD_INT 0
49737: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49738: LD_ADDR_VAR 0 1
49742: PUSH
49743: LD_INT 22
49745: PUSH
49746: LD_OWVAR 2
49750: PUSH
49751: EMPTY
49752: LIST
49753: LIST
49754: PUSH
49755: LD_INT 21
49757: PUSH
49758: LD_INT 1
49760: PUSH
49761: EMPTY
49762: LIST
49763: LIST
49764: PUSH
49765: LD_INT 3
49767: PUSH
49768: LD_INT 23
49770: PUSH
49771: LD_INT 0
49773: PUSH
49774: EMPTY
49775: LIST
49776: LIST
49777: PUSH
49778: EMPTY
49779: LIST
49780: LIST
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: LIST
49786: PPUSH
49787: CALL_OW 69
49791: PUSH
49792: FOR_IN
49793: IFFALSE 49847
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49795: LD_VAR 0 1
49799: PPUSH
49800: CALL_OW 257
49804: PUSH
49805: LD_INT 1
49807: PUSH
49808: LD_INT 2
49810: PUSH
49811: LD_INT 3
49813: PUSH
49814: LD_INT 4
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: LIST
49821: LIST
49822: IN
49823: IFFALSE 49845
// SetClass ( un , rand ( 1 , 4 ) ) ;
49825: LD_VAR 0 1
49829: PPUSH
49830: LD_INT 1
49832: PPUSH
49833: LD_INT 4
49835: PPUSH
49836: CALL_OW 12
49840: PPUSH
49841: CALL_OW 336
49845: GO 49792
49847: POP
49848: POP
// end ;
49849: PPOPN 1
49851: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49852: LD_EXP 89
49856: PUSH
49857: LD_EXP 101
49861: AND
49862: IFFALSE 49941
49864: GO 49866
49866: DISABLE
49867: LD_INT 0
49869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49870: LD_ADDR_VAR 0 1
49874: PUSH
49875: LD_INT 22
49877: PUSH
49878: LD_OWVAR 2
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: PUSH
49887: LD_INT 21
49889: PUSH
49890: LD_INT 3
49892: PUSH
49893: EMPTY
49894: LIST
49895: LIST
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PPUSH
49901: CALL_OW 69
49905: ST_TO_ADDR
// if not tmp then
49906: LD_VAR 0 1
49910: NOT
49911: IFFALSE 49915
// exit ;
49913: GO 49941
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49915: LD_VAR 0 1
49919: PUSH
49920: LD_INT 1
49922: PPUSH
49923: LD_VAR 0 1
49927: PPUSH
49928: CALL_OW 12
49932: ARRAY
49933: PPUSH
49934: LD_INT 100
49936: PPUSH
49937: CALL_OW 234
// end ;
49941: PPOPN 1
49943: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49944: LD_EXP 89
49948: PUSH
49949: LD_EXP 103
49953: AND
49954: IFFALSE 50052
49956: GO 49958
49958: DISABLE
49959: LD_INT 0
49961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49962: LD_ADDR_VAR 0 1
49966: PUSH
49967: LD_INT 22
49969: PUSH
49970: LD_OWVAR 2
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: LD_INT 21
49981: PUSH
49982: LD_INT 1
49984: PUSH
49985: EMPTY
49986: LIST
49987: LIST
49988: PUSH
49989: EMPTY
49990: LIST
49991: LIST
49992: PPUSH
49993: CALL_OW 69
49997: ST_TO_ADDR
// if not tmp then
49998: LD_VAR 0 1
50002: NOT
50003: IFFALSE 50007
// exit ;
50005: GO 50052
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50007: LD_VAR 0 1
50011: PUSH
50012: LD_INT 1
50014: PPUSH
50015: LD_VAR 0 1
50019: PPUSH
50020: CALL_OW 12
50024: ARRAY
50025: PPUSH
50026: LD_INT 1
50028: PPUSH
50029: LD_INT 4
50031: PPUSH
50032: CALL_OW 12
50036: PPUSH
50037: LD_INT 3000
50039: PPUSH
50040: LD_INT 9000
50042: PPUSH
50043: CALL_OW 12
50047: PPUSH
50048: CALL_OW 492
// end ;
50052: PPOPN 1
50054: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50055: LD_EXP 89
50059: PUSH
50060: LD_EXP 104
50064: AND
50065: IFFALSE 50085
50067: GO 50069
50069: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50070: LD_INT 1
50072: PPUSH
50073: LD_OWVAR 2
50077: PPUSH
50078: LD_INT 0
50080: PPUSH
50081: CALL_OW 324
50085: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50086: LD_EXP 89
50090: PUSH
50091: LD_EXP 105
50095: AND
50096: IFFALSE 50179
50098: GO 50100
50100: DISABLE
50101: LD_INT 0
50103: PPUSH
50104: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50105: LD_ADDR_VAR 0 2
50109: PUSH
50110: LD_INT 22
50112: PUSH
50113: LD_OWVAR 2
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PUSH
50122: LD_INT 21
50124: PUSH
50125: LD_INT 3
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: PUSH
50132: EMPTY
50133: LIST
50134: LIST
50135: PPUSH
50136: CALL_OW 69
50140: ST_TO_ADDR
// if not tmp then
50141: LD_VAR 0 2
50145: NOT
50146: IFFALSE 50150
// exit ;
50148: GO 50179
// for i in tmp do
50150: LD_ADDR_VAR 0 1
50154: PUSH
50155: LD_VAR 0 2
50159: PUSH
50160: FOR_IN
50161: IFFALSE 50177
// SetBLevel ( i , 10 ) ;
50163: LD_VAR 0 1
50167: PPUSH
50168: LD_INT 10
50170: PPUSH
50171: CALL_OW 241
50175: GO 50160
50177: POP
50178: POP
// end ;
50179: PPOPN 2
50181: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50182: LD_EXP 89
50186: PUSH
50187: LD_EXP 106
50191: AND
50192: IFFALSE 50303
50194: GO 50196
50196: DISABLE
50197: LD_INT 0
50199: PPUSH
50200: PPUSH
50201: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50202: LD_ADDR_VAR 0 3
50206: PUSH
50207: LD_INT 22
50209: PUSH
50210: LD_OWVAR 2
50214: PUSH
50215: EMPTY
50216: LIST
50217: LIST
50218: PUSH
50219: LD_INT 25
50221: PUSH
50222: LD_INT 1
50224: PUSH
50225: EMPTY
50226: LIST
50227: LIST
50228: PUSH
50229: EMPTY
50230: LIST
50231: LIST
50232: PPUSH
50233: CALL_OW 69
50237: ST_TO_ADDR
// if not tmp then
50238: LD_VAR 0 3
50242: NOT
50243: IFFALSE 50247
// exit ;
50245: GO 50303
// un := tmp [ rand ( 1 , tmp ) ] ;
50247: LD_ADDR_VAR 0 2
50251: PUSH
50252: LD_VAR 0 3
50256: PUSH
50257: LD_INT 1
50259: PPUSH
50260: LD_VAR 0 3
50264: PPUSH
50265: CALL_OW 12
50269: ARRAY
50270: ST_TO_ADDR
// if Crawls ( un ) then
50271: LD_VAR 0 2
50275: PPUSH
50276: CALL_OW 318
50280: IFFALSE 50291
// ComWalk ( un ) ;
50282: LD_VAR 0 2
50286: PPUSH
50287: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50291: LD_VAR 0 2
50295: PPUSH
50296: LD_INT 5
50298: PPUSH
50299: CALL_OW 336
// end ;
50303: PPOPN 3
50305: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
50306: LD_EXP 89
50310: PUSH
50311: LD_EXP 107
50315: AND
50316: PUSH
50317: LD_OWVAR 67
50321: PUSH
50322: LD_INT 3
50324: LESS
50325: AND
50326: IFFALSE 50345
50328: GO 50330
50330: DISABLE
// Difficulty := Difficulty + 1 ;
50331: LD_ADDR_OWVAR 67
50335: PUSH
50336: LD_OWVAR 67
50340: PUSH
50341: LD_INT 1
50343: PLUS
50344: ST_TO_ADDR
50345: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50346: LD_EXP 89
50350: PUSH
50351: LD_EXP 108
50355: AND
50356: IFFALSE 50459
50358: GO 50360
50360: DISABLE
50361: LD_INT 0
50363: PPUSH
// begin for i := 1 to 5 do
50364: LD_ADDR_VAR 0 1
50368: PUSH
50369: DOUBLE
50370: LD_INT 1
50372: DEC
50373: ST_TO_ADDR
50374: LD_INT 5
50376: PUSH
50377: FOR_TO
50378: IFFALSE 50457
// begin uc_nation := nation_nature ;
50380: LD_ADDR_OWVAR 21
50384: PUSH
50385: LD_INT 0
50387: ST_TO_ADDR
// uc_side := 0 ;
50388: LD_ADDR_OWVAR 20
50392: PUSH
50393: LD_INT 0
50395: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50396: LD_ADDR_OWVAR 29
50400: PUSH
50401: LD_INT 12
50403: PUSH
50404: LD_INT 12
50406: PUSH
50407: EMPTY
50408: LIST
50409: LIST
50410: ST_TO_ADDR
// hc_agressivity := 20 ;
50411: LD_ADDR_OWVAR 35
50415: PUSH
50416: LD_INT 20
50418: ST_TO_ADDR
// hc_class := class_tiger ;
50419: LD_ADDR_OWVAR 28
50423: PUSH
50424: LD_INT 14
50426: ST_TO_ADDR
// hc_gallery :=  ;
50427: LD_ADDR_OWVAR 33
50431: PUSH
50432: LD_STRING 
50434: ST_TO_ADDR
// hc_name :=  ;
50435: LD_ADDR_OWVAR 26
50439: PUSH
50440: LD_STRING 
50442: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50443: CALL_OW 44
50447: PPUSH
50448: LD_INT 0
50450: PPUSH
50451: CALL_OW 51
// end ;
50455: GO 50377
50457: POP
50458: POP
// end ;
50459: PPOPN 1
50461: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50462: LD_EXP 89
50466: PUSH
50467: LD_EXP 109
50471: AND
50472: IFFALSE 50481
50474: GO 50476
50476: DISABLE
// StreamSibBomb ;
50477: CALL 50482 0 0
50481: END
// export function StreamSibBomb ; var i , x , y ; begin
50482: LD_INT 0
50484: PPUSH
50485: PPUSH
50486: PPUSH
50487: PPUSH
// result := false ;
50488: LD_ADDR_VAR 0 1
50492: PUSH
50493: LD_INT 0
50495: ST_TO_ADDR
// for i := 1 to 16 do
50496: LD_ADDR_VAR 0 2
50500: PUSH
50501: DOUBLE
50502: LD_INT 1
50504: DEC
50505: ST_TO_ADDR
50506: LD_INT 16
50508: PUSH
50509: FOR_TO
50510: IFFALSE 50709
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50512: LD_ADDR_VAR 0 3
50516: PUSH
50517: LD_INT 10
50519: PUSH
50520: LD_INT 20
50522: PUSH
50523: LD_INT 30
50525: PUSH
50526: LD_INT 40
50528: PUSH
50529: LD_INT 50
50531: PUSH
50532: LD_INT 60
50534: PUSH
50535: LD_INT 70
50537: PUSH
50538: LD_INT 80
50540: PUSH
50541: LD_INT 90
50543: PUSH
50544: LD_INT 100
50546: PUSH
50547: LD_INT 110
50549: PUSH
50550: LD_INT 120
50552: PUSH
50553: LD_INT 130
50555: PUSH
50556: LD_INT 140
50558: PUSH
50559: LD_INT 150
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: PUSH
50579: LD_INT 1
50581: PPUSH
50582: LD_INT 15
50584: PPUSH
50585: CALL_OW 12
50589: ARRAY
50590: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50591: LD_ADDR_VAR 0 4
50595: PUSH
50596: LD_INT 10
50598: PUSH
50599: LD_INT 20
50601: PUSH
50602: LD_INT 30
50604: PUSH
50605: LD_INT 40
50607: PUSH
50608: LD_INT 50
50610: PUSH
50611: LD_INT 60
50613: PUSH
50614: LD_INT 70
50616: PUSH
50617: LD_INT 80
50619: PUSH
50620: LD_INT 90
50622: PUSH
50623: LD_INT 100
50625: PUSH
50626: LD_INT 110
50628: PUSH
50629: LD_INT 120
50631: PUSH
50632: LD_INT 130
50634: PUSH
50635: LD_INT 140
50637: PUSH
50638: LD_INT 150
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: LIST
50645: LIST
50646: LIST
50647: LIST
50648: LIST
50649: LIST
50650: LIST
50651: LIST
50652: LIST
50653: LIST
50654: LIST
50655: LIST
50656: LIST
50657: PUSH
50658: LD_INT 1
50660: PPUSH
50661: LD_INT 15
50663: PPUSH
50664: CALL_OW 12
50668: ARRAY
50669: ST_TO_ADDR
// if ValidHex ( x , y ) then
50670: LD_VAR 0 3
50674: PPUSH
50675: LD_VAR 0 4
50679: PPUSH
50680: CALL_OW 488
50684: IFFALSE 50707
// begin result := [ x , y ] ;
50686: LD_ADDR_VAR 0 1
50690: PUSH
50691: LD_VAR 0 3
50695: PUSH
50696: LD_VAR 0 4
50700: PUSH
50701: EMPTY
50702: LIST
50703: LIST
50704: ST_TO_ADDR
// break ;
50705: GO 50709
// end ; end ;
50707: GO 50509
50709: POP
50710: POP
// if result then
50711: LD_VAR 0 1
50715: IFFALSE 50775
// begin ToLua ( playSibBomb() ) ;
50717: LD_STRING playSibBomb()
50719: PPUSH
50720: CALL_OW 559
// wait ( 0 0$14 ) ;
50724: LD_INT 490
50726: PPUSH
50727: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50731: LD_VAR 0 1
50735: PUSH
50736: LD_INT 1
50738: ARRAY
50739: PPUSH
50740: LD_VAR 0 1
50744: PUSH
50745: LD_INT 2
50747: ARRAY
50748: PPUSH
50749: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50753: LD_VAR 0 1
50757: PUSH
50758: LD_INT 1
50760: ARRAY
50761: PPUSH
50762: LD_VAR 0 1
50766: PUSH
50767: LD_INT 2
50769: ARRAY
50770: PPUSH
50771: CALL_OW 429
// end ; end ;
50775: LD_VAR 0 1
50779: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50780: LD_EXP 89
50784: PUSH
50785: LD_EXP 111
50789: AND
50790: IFFALSE 50802
50792: GO 50794
50794: DISABLE
// YouLost (  ) ;
50795: LD_STRING 
50797: PPUSH
50798: CALL_OW 104
50802: END
// every 0 0$1 trigger StreamModeActive and sFog do
50803: LD_EXP 89
50807: PUSH
50808: LD_EXP 110
50812: AND
50813: IFFALSE 50827
50815: GO 50817
50817: DISABLE
// FogOff ( your_side ) ;
50818: LD_OWVAR 2
50822: PPUSH
50823: CALL_OW 344
50827: END
// every 0 0$1 trigger StreamModeActive and sSun do
50828: LD_EXP 89
50832: PUSH
50833: LD_EXP 112
50837: AND
50838: IFFALSE 50866
50840: GO 50842
50842: DISABLE
// begin solar_recharge_percent := 0 ;
50843: LD_ADDR_OWVAR 79
50847: PUSH
50848: LD_INT 0
50850: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50851: LD_INT 10500
50853: PPUSH
50854: CALL_OW 67
// solar_recharge_percent := 100 ;
50858: LD_ADDR_OWVAR 79
50862: PUSH
50863: LD_INT 100
50865: ST_TO_ADDR
// end ;
50866: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50867: LD_EXP 89
50871: PUSH
50872: LD_EXP 113
50876: AND
50877: IFFALSE 51116
50879: GO 50881
50881: DISABLE
50882: LD_INT 0
50884: PPUSH
50885: PPUSH
50886: PPUSH
// begin tmp := [ ] ;
50887: LD_ADDR_VAR 0 3
50891: PUSH
50892: EMPTY
50893: ST_TO_ADDR
// for i := 1 to 6 do
50894: LD_ADDR_VAR 0 1
50898: PUSH
50899: DOUBLE
50900: LD_INT 1
50902: DEC
50903: ST_TO_ADDR
50904: LD_INT 6
50906: PUSH
50907: FOR_TO
50908: IFFALSE 51013
// begin uc_nation := nation_nature ;
50910: LD_ADDR_OWVAR 21
50914: PUSH
50915: LD_INT 0
50917: ST_TO_ADDR
// uc_side := 0 ;
50918: LD_ADDR_OWVAR 20
50922: PUSH
50923: LD_INT 0
50925: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50926: LD_ADDR_OWVAR 29
50930: PUSH
50931: LD_INT 12
50933: PUSH
50934: LD_INT 12
50936: PUSH
50937: EMPTY
50938: LIST
50939: LIST
50940: ST_TO_ADDR
// hc_agressivity := 20 ;
50941: LD_ADDR_OWVAR 35
50945: PUSH
50946: LD_INT 20
50948: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50949: LD_ADDR_OWVAR 28
50953: PUSH
50954: LD_INT 17
50956: ST_TO_ADDR
// hc_gallery :=  ;
50957: LD_ADDR_OWVAR 33
50961: PUSH
50962: LD_STRING 
50964: ST_TO_ADDR
// hc_name :=  ;
50965: LD_ADDR_OWVAR 26
50969: PUSH
50970: LD_STRING 
50972: ST_TO_ADDR
// un := CreateHuman ;
50973: LD_ADDR_VAR 0 2
50977: PUSH
50978: CALL_OW 44
50982: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50983: LD_VAR 0 2
50987: PPUSH
50988: LD_INT 1
50990: PPUSH
50991: CALL_OW 51
// tmp := tmp ^ un ;
50995: LD_ADDR_VAR 0 3
50999: PUSH
51000: LD_VAR 0 3
51004: PUSH
51005: LD_VAR 0 2
51009: ADD
51010: ST_TO_ADDR
// end ;
51011: GO 50907
51013: POP
51014: POP
// repeat wait ( 0 0$1 ) ;
51015: LD_INT 35
51017: PPUSH
51018: CALL_OW 67
// for un in tmp do
51022: LD_ADDR_VAR 0 2
51026: PUSH
51027: LD_VAR 0 3
51031: PUSH
51032: FOR_IN
51033: IFFALSE 51107
// begin if IsDead ( un ) then
51035: LD_VAR 0 2
51039: PPUSH
51040: CALL_OW 301
51044: IFFALSE 51064
// begin tmp := tmp diff un ;
51046: LD_ADDR_VAR 0 3
51050: PUSH
51051: LD_VAR 0 3
51055: PUSH
51056: LD_VAR 0 2
51060: DIFF
51061: ST_TO_ADDR
// continue ;
51062: GO 51032
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51064: LD_VAR 0 2
51068: PPUSH
51069: LD_INT 3
51071: PUSH
51072: LD_INT 22
51074: PUSH
51075: LD_INT 0
51077: PUSH
51078: EMPTY
51079: LIST
51080: LIST
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: PPUSH
51086: CALL_OW 69
51090: PPUSH
51091: LD_VAR 0 2
51095: PPUSH
51096: CALL_OW 74
51100: PPUSH
51101: CALL_OW 115
// end ;
51105: GO 51032
51107: POP
51108: POP
// until not tmp ;
51109: LD_VAR 0 3
51113: NOT
51114: IFFALSE 51015
// end ;
51116: PPOPN 3
51118: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51119: LD_EXP 89
51123: PUSH
51124: LD_EXP 114
51128: AND
51129: IFFALSE 51183
51131: GO 51133
51133: DISABLE
// begin ToLua ( displayTroll(); ) ;
51134: LD_STRING displayTroll();
51136: PPUSH
51137: CALL_OW 559
// wait ( 3 3$00 ) ;
51141: LD_INT 6300
51143: PPUSH
51144: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51148: LD_STRING hideTroll();
51150: PPUSH
51151: CALL_OW 559
// wait ( 1 1$00 ) ;
51155: LD_INT 2100
51157: PPUSH
51158: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51162: LD_STRING displayTroll();
51164: PPUSH
51165: CALL_OW 559
// wait ( 1 1$00 ) ;
51169: LD_INT 2100
51171: PPUSH
51172: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51176: LD_STRING hideTroll();
51178: PPUSH
51179: CALL_OW 559
// end ;
51183: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51184: LD_EXP 89
51188: PUSH
51189: LD_EXP 115
51193: AND
51194: IFFALSE 51257
51196: GO 51198
51198: DISABLE
51199: LD_INT 0
51201: PPUSH
// begin p := 0 ;
51202: LD_ADDR_VAR 0 1
51206: PUSH
51207: LD_INT 0
51209: ST_TO_ADDR
// repeat game_speed := 1 ;
51210: LD_ADDR_OWVAR 65
51214: PUSH
51215: LD_INT 1
51217: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51218: LD_INT 35
51220: PPUSH
51221: CALL_OW 67
// p := p + 1 ;
51225: LD_ADDR_VAR 0 1
51229: PUSH
51230: LD_VAR 0 1
51234: PUSH
51235: LD_INT 1
51237: PLUS
51238: ST_TO_ADDR
// until p >= 60 ;
51239: LD_VAR 0 1
51243: PUSH
51244: LD_INT 60
51246: GREATEREQUAL
51247: IFFALSE 51210
// game_speed := 4 ;
51249: LD_ADDR_OWVAR 65
51253: PUSH
51254: LD_INT 4
51256: ST_TO_ADDR
// end ;
51257: PPOPN 1
51259: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51260: LD_EXP 89
51264: PUSH
51265: LD_EXP 116
51269: AND
51270: IFFALSE 51416
51272: GO 51274
51274: DISABLE
51275: LD_INT 0
51277: PPUSH
51278: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51279: LD_ADDR_VAR 0 1
51283: PUSH
51284: LD_INT 22
51286: PUSH
51287: LD_OWVAR 2
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PUSH
51296: LD_INT 2
51298: PUSH
51299: LD_INT 30
51301: PUSH
51302: LD_INT 0
51304: PUSH
51305: EMPTY
51306: LIST
51307: LIST
51308: PUSH
51309: LD_INT 30
51311: PUSH
51312: LD_INT 1
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: PUSH
51319: EMPTY
51320: LIST
51321: LIST
51322: LIST
51323: PUSH
51324: EMPTY
51325: LIST
51326: LIST
51327: PPUSH
51328: CALL_OW 69
51332: ST_TO_ADDR
// if not depot then
51333: LD_VAR 0 1
51337: NOT
51338: IFFALSE 51342
// exit ;
51340: GO 51416
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51342: LD_ADDR_VAR 0 2
51346: PUSH
51347: LD_VAR 0 1
51351: PUSH
51352: LD_INT 1
51354: PPUSH
51355: LD_VAR 0 1
51359: PPUSH
51360: CALL_OW 12
51364: ARRAY
51365: PPUSH
51366: CALL_OW 274
51370: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51371: LD_VAR 0 2
51375: PPUSH
51376: LD_INT 1
51378: PPUSH
51379: LD_INT 0
51381: PPUSH
51382: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51386: LD_VAR 0 2
51390: PPUSH
51391: LD_INT 2
51393: PPUSH
51394: LD_INT 0
51396: PPUSH
51397: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51401: LD_VAR 0 2
51405: PPUSH
51406: LD_INT 3
51408: PPUSH
51409: LD_INT 0
51411: PPUSH
51412: CALL_OW 277
// end ;
51416: PPOPN 2
51418: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51419: LD_EXP 89
51423: PUSH
51424: LD_EXP 117
51428: AND
51429: IFFALSE 51526
51431: GO 51433
51433: DISABLE
51434: LD_INT 0
51436: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51437: LD_ADDR_VAR 0 1
51441: PUSH
51442: LD_INT 22
51444: PUSH
51445: LD_OWVAR 2
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: PUSH
51454: LD_INT 21
51456: PUSH
51457: LD_INT 1
51459: PUSH
51460: EMPTY
51461: LIST
51462: LIST
51463: PUSH
51464: LD_INT 3
51466: PUSH
51467: LD_INT 23
51469: PUSH
51470: LD_INT 0
51472: PUSH
51473: EMPTY
51474: LIST
51475: LIST
51476: PUSH
51477: EMPTY
51478: LIST
51479: LIST
51480: PUSH
51481: EMPTY
51482: LIST
51483: LIST
51484: LIST
51485: PPUSH
51486: CALL_OW 69
51490: ST_TO_ADDR
// if not tmp then
51491: LD_VAR 0 1
51495: NOT
51496: IFFALSE 51500
// exit ;
51498: GO 51526
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51500: LD_VAR 0 1
51504: PUSH
51505: LD_INT 1
51507: PPUSH
51508: LD_VAR 0 1
51512: PPUSH
51513: CALL_OW 12
51517: ARRAY
51518: PPUSH
51519: LD_INT 200
51521: PPUSH
51522: CALL_OW 234
// end ;
51526: PPOPN 1
51528: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51529: LD_EXP 89
51533: PUSH
51534: LD_EXP 118
51538: AND
51539: IFFALSE 51618
51541: GO 51543
51543: DISABLE
51544: LD_INT 0
51546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51547: LD_ADDR_VAR 0 1
51551: PUSH
51552: LD_INT 22
51554: PUSH
51555: LD_OWVAR 2
51559: PUSH
51560: EMPTY
51561: LIST
51562: LIST
51563: PUSH
51564: LD_INT 21
51566: PUSH
51567: LD_INT 2
51569: PUSH
51570: EMPTY
51571: LIST
51572: LIST
51573: PUSH
51574: EMPTY
51575: LIST
51576: LIST
51577: PPUSH
51578: CALL_OW 69
51582: ST_TO_ADDR
// if not tmp then
51583: LD_VAR 0 1
51587: NOT
51588: IFFALSE 51592
// exit ;
51590: GO 51618
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51592: LD_VAR 0 1
51596: PUSH
51597: LD_INT 1
51599: PPUSH
51600: LD_VAR 0 1
51604: PPUSH
51605: CALL_OW 12
51609: ARRAY
51610: PPUSH
51611: LD_INT 60
51613: PPUSH
51614: CALL_OW 234
// end ;
51618: PPOPN 1
51620: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51621: LD_EXP 89
51625: PUSH
51626: LD_EXP 119
51630: AND
51631: IFFALSE 51730
51633: GO 51635
51635: DISABLE
51636: LD_INT 0
51638: PPUSH
51639: PPUSH
// begin enable ;
51640: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51641: LD_ADDR_VAR 0 1
51645: PUSH
51646: LD_INT 22
51648: PUSH
51649: LD_OWVAR 2
51653: PUSH
51654: EMPTY
51655: LIST
51656: LIST
51657: PUSH
51658: LD_INT 61
51660: PUSH
51661: EMPTY
51662: LIST
51663: PUSH
51664: LD_INT 33
51666: PUSH
51667: LD_INT 2
51669: PUSH
51670: EMPTY
51671: LIST
51672: LIST
51673: PUSH
51674: EMPTY
51675: LIST
51676: LIST
51677: LIST
51678: PPUSH
51679: CALL_OW 69
51683: ST_TO_ADDR
// if not tmp then
51684: LD_VAR 0 1
51688: NOT
51689: IFFALSE 51693
// exit ;
51691: GO 51730
// for i in tmp do
51693: LD_ADDR_VAR 0 2
51697: PUSH
51698: LD_VAR 0 1
51702: PUSH
51703: FOR_IN
51704: IFFALSE 51728
// if IsControledBy ( i ) then
51706: LD_VAR 0 2
51710: PPUSH
51711: CALL_OW 312
51715: IFFALSE 51726
// ComUnlink ( i ) ;
51717: LD_VAR 0 2
51721: PPUSH
51722: CALL_OW 136
51726: GO 51703
51728: POP
51729: POP
// end ;
51730: PPOPN 2
51732: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51733: LD_EXP 89
51737: PUSH
51738: LD_EXP 120
51742: AND
51743: IFFALSE 51883
51745: GO 51747
51747: DISABLE
51748: LD_INT 0
51750: PPUSH
51751: PPUSH
// begin ToLua ( displayPowell(); ) ;
51752: LD_STRING displayPowell();
51754: PPUSH
51755: CALL_OW 559
// uc_side := 0 ;
51759: LD_ADDR_OWVAR 20
51763: PUSH
51764: LD_INT 0
51766: ST_TO_ADDR
// uc_nation := 2 ;
51767: LD_ADDR_OWVAR 21
51771: PUSH
51772: LD_INT 2
51774: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51775: LD_ADDR_OWVAR 37
51779: PUSH
51780: LD_INT 14
51782: ST_TO_ADDR
// vc_engine := engine_siberite ;
51783: LD_ADDR_OWVAR 39
51787: PUSH
51788: LD_INT 3
51790: ST_TO_ADDR
// vc_control := control_apeman ;
51791: LD_ADDR_OWVAR 38
51795: PUSH
51796: LD_INT 5
51798: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51799: LD_ADDR_OWVAR 40
51803: PUSH
51804: LD_INT 29
51806: ST_TO_ADDR
// un := CreateVehicle ;
51807: LD_ADDR_VAR 0 2
51811: PUSH
51812: CALL_OW 45
51816: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51817: LD_VAR 0 2
51821: PPUSH
51822: LD_INT 1
51824: PPUSH
51825: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51829: LD_INT 35
51831: PPUSH
51832: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51836: LD_VAR 0 2
51840: PPUSH
51841: LD_INT 22
51843: PUSH
51844: LD_OWVAR 2
51848: PUSH
51849: EMPTY
51850: LIST
51851: LIST
51852: PPUSH
51853: CALL_OW 69
51857: PPUSH
51858: LD_VAR 0 2
51862: PPUSH
51863: CALL_OW 74
51867: PPUSH
51868: CALL_OW 115
// until IsDead ( un ) ;
51872: LD_VAR 0 2
51876: PPUSH
51877: CALL_OW 301
51881: IFFALSE 51829
// end ;
51883: PPOPN 2
51885: END
// every 0 0$1 trigger StreamModeActive and sStu do
51886: LD_EXP 89
51890: PUSH
51891: LD_EXP 128
51895: AND
51896: IFFALSE 51912
51898: GO 51900
51900: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51901: LD_STRING displayStucuk();
51903: PPUSH
51904: CALL_OW 559
// ResetFog ;
51908: CALL_OW 335
// end ;
51912: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51913: LD_EXP 89
51917: PUSH
51918: LD_EXP 121
51922: AND
51923: IFFALSE 52064
51925: GO 51927
51927: DISABLE
51928: LD_INT 0
51930: PPUSH
51931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51932: LD_ADDR_VAR 0 2
51936: PUSH
51937: LD_INT 22
51939: PUSH
51940: LD_OWVAR 2
51944: PUSH
51945: EMPTY
51946: LIST
51947: LIST
51948: PUSH
51949: LD_INT 21
51951: PUSH
51952: LD_INT 1
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: PUSH
51959: EMPTY
51960: LIST
51961: LIST
51962: PPUSH
51963: CALL_OW 69
51967: ST_TO_ADDR
// if not tmp then
51968: LD_VAR 0 2
51972: NOT
51973: IFFALSE 51977
// exit ;
51975: GO 52064
// un := tmp [ rand ( 1 , tmp ) ] ;
51977: LD_ADDR_VAR 0 1
51981: PUSH
51982: LD_VAR 0 2
51986: PUSH
51987: LD_INT 1
51989: PPUSH
51990: LD_VAR 0 2
51994: PPUSH
51995: CALL_OW 12
51999: ARRAY
52000: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52001: LD_VAR 0 1
52005: PPUSH
52006: LD_INT 0
52008: PPUSH
52009: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52013: LD_VAR 0 1
52017: PPUSH
52018: LD_OWVAR 3
52022: PUSH
52023: LD_VAR 0 1
52027: DIFF
52028: PPUSH
52029: LD_VAR 0 1
52033: PPUSH
52034: CALL_OW 74
52038: PPUSH
52039: CALL_OW 115
// wait ( 0 0$20 ) ;
52043: LD_INT 700
52045: PPUSH
52046: CALL_OW 67
// SetSide ( un , your_side ) ;
52050: LD_VAR 0 1
52054: PPUSH
52055: LD_OWVAR 2
52059: PPUSH
52060: CALL_OW 235
// end ;
52064: PPOPN 2
52066: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52067: LD_EXP 89
52071: PUSH
52072: LD_EXP 122
52076: AND
52077: IFFALSE 52183
52079: GO 52081
52081: DISABLE
52082: LD_INT 0
52084: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52085: LD_ADDR_VAR 0 1
52089: PUSH
52090: LD_INT 22
52092: PUSH
52093: LD_OWVAR 2
52097: PUSH
52098: EMPTY
52099: LIST
52100: LIST
52101: PUSH
52102: LD_INT 2
52104: PUSH
52105: LD_INT 30
52107: PUSH
52108: LD_INT 0
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: PUSH
52115: LD_INT 30
52117: PUSH
52118: LD_INT 1
52120: PUSH
52121: EMPTY
52122: LIST
52123: LIST
52124: PUSH
52125: EMPTY
52126: LIST
52127: LIST
52128: LIST
52129: PUSH
52130: EMPTY
52131: LIST
52132: LIST
52133: PPUSH
52134: CALL_OW 69
52138: ST_TO_ADDR
// if not depot then
52139: LD_VAR 0 1
52143: NOT
52144: IFFALSE 52148
// exit ;
52146: GO 52183
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52148: LD_VAR 0 1
52152: PUSH
52153: LD_INT 1
52155: ARRAY
52156: PPUSH
52157: CALL_OW 250
52161: PPUSH
52162: LD_VAR 0 1
52166: PUSH
52167: LD_INT 1
52169: ARRAY
52170: PPUSH
52171: CALL_OW 251
52175: PPUSH
52176: LD_INT 70
52178: PPUSH
52179: CALL_OW 495
// end ;
52183: PPOPN 1
52185: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52186: LD_EXP 89
52190: PUSH
52191: LD_EXP 123
52195: AND
52196: IFFALSE 52407
52198: GO 52200
52200: DISABLE
52201: LD_INT 0
52203: PPUSH
52204: PPUSH
52205: PPUSH
52206: PPUSH
52207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52208: LD_ADDR_VAR 0 5
52212: PUSH
52213: LD_INT 22
52215: PUSH
52216: LD_OWVAR 2
52220: PUSH
52221: EMPTY
52222: LIST
52223: LIST
52224: PUSH
52225: LD_INT 21
52227: PUSH
52228: LD_INT 1
52230: PUSH
52231: EMPTY
52232: LIST
52233: LIST
52234: PUSH
52235: EMPTY
52236: LIST
52237: LIST
52238: PPUSH
52239: CALL_OW 69
52243: ST_TO_ADDR
// if not tmp then
52244: LD_VAR 0 5
52248: NOT
52249: IFFALSE 52253
// exit ;
52251: GO 52407
// for i in tmp do
52253: LD_ADDR_VAR 0 1
52257: PUSH
52258: LD_VAR 0 5
52262: PUSH
52263: FOR_IN
52264: IFFALSE 52405
// begin d := rand ( 0 , 5 ) ;
52266: LD_ADDR_VAR 0 4
52270: PUSH
52271: LD_INT 0
52273: PPUSH
52274: LD_INT 5
52276: PPUSH
52277: CALL_OW 12
52281: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52282: LD_ADDR_VAR 0 2
52286: PUSH
52287: LD_VAR 0 1
52291: PPUSH
52292: CALL_OW 250
52296: PPUSH
52297: LD_VAR 0 4
52301: PPUSH
52302: LD_INT 3
52304: PPUSH
52305: LD_INT 12
52307: PPUSH
52308: CALL_OW 12
52312: PPUSH
52313: CALL_OW 272
52317: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52318: LD_ADDR_VAR 0 3
52322: PUSH
52323: LD_VAR 0 1
52327: PPUSH
52328: CALL_OW 251
52332: PPUSH
52333: LD_VAR 0 4
52337: PPUSH
52338: LD_INT 3
52340: PPUSH
52341: LD_INT 12
52343: PPUSH
52344: CALL_OW 12
52348: PPUSH
52349: CALL_OW 273
52353: ST_TO_ADDR
// if ValidHex ( x , y ) then
52354: LD_VAR 0 2
52358: PPUSH
52359: LD_VAR 0 3
52363: PPUSH
52364: CALL_OW 488
52368: IFFALSE 52403
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52370: LD_VAR 0 1
52374: PPUSH
52375: LD_VAR 0 2
52379: PPUSH
52380: LD_VAR 0 3
52384: PPUSH
52385: LD_INT 3
52387: PPUSH
52388: LD_INT 6
52390: PPUSH
52391: CALL_OW 12
52395: PPUSH
52396: LD_INT 1
52398: PPUSH
52399: CALL_OW 483
// end ;
52403: GO 52263
52405: POP
52406: POP
// end ;
52407: PPOPN 5
52409: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52410: LD_EXP 89
52414: PUSH
52415: LD_EXP 124
52419: AND
52420: IFFALSE 52514
52422: GO 52424
52424: DISABLE
52425: LD_INT 0
52427: PPUSH
52428: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52429: LD_ADDR_VAR 0 2
52433: PUSH
52434: LD_INT 22
52436: PUSH
52437: LD_OWVAR 2
52441: PUSH
52442: EMPTY
52443: LIST
52444: LIST
52445: PUSH
52446: LD_INT 32
52448: PUSH
52449: LD_INT 1
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: PUSH
52456: LD_INT 21
52458: PUSH
52459: LD_INT 2
52461: PUSH
52462: EMPTY
52463: LIST
52464: LIST
52465: PUSH
52466: EMPTY
52467: LIST
52468: LIST
52469: LIST
52470: PPUSH
52471: CALL_OW 69
52475: ST_TO_ADDR
// if not tmp then
52476: LD_VAR 0 2
52480: NOT
52481: IFFALSE 52485
// exit ;
52483: GO 52514
// for i in tmp do
52485: LD_ADDR_VAR 0 1
52489: PUSH
52490: LD_VAR 0 2
52494: PUSH
52495: FOR_IN
52496: IFFALSE 52512
// SetFuel ( i , 0 ) ;
52498: LD_VAR 0 1
52502: PPUSH
52503: LD_INT 0
52505: PPUSH
52506: CALL_OW 240
52510: GO 52495
52512: POP
52513: POP
// end ;
52514: PPOPN 2
52516: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52517: LD_EXP 89
52521: PUSH
52522: LD_EXP 125
52526: AND
52527: IFFALSE 52593
52529: GO 52531
52531: DISABLE
52532: LD_INT 0
52534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52535: LD_ADDR_VAR 0 1
52539: PUSH
52540: LD_INT 22
52542: PUSH
52543: LD_OWVAR 2
52547: PUSH
52548: EMPTY
52549: LIST
52550: LIST
52551: PUSH
52552: LD_INT 30
52554: PUSH
52555: LD_INT 29
52557: PUSH
52558: EMPTY
52559: LIST
52560: LIST
52561: PUSH
52562: EMPTY
52563: LIST
52564: LIST
52565: PPUSH
52566: CALL_OW 69
52570: ST_TO_ADDR
// if not tmp then
52571: LD_VAR 0 1
52575: NOT
52576: IFFALSE 52580
// exit ;
52578: GO 52593
// DestroyUnit ( tmp [ 1 ] ) ;
52580: LD_VAR 0 1
52584: PUSH
52585: LD_INT 1
52587: ARRAY
52588: PPUSH
52589: CALL_OW 65
// end ;
52593: PPOPN 1
52595: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52596: LD_EXP 89
52600: PUSH
52601: LD_EXP 127
52605: AND
52606: IFFALSE 52735
52608: GO 52610
52610: DISABLE
52611: LD_INT 0
52613: PPUSH
// begin uc_side := 0 ;
52614: LD_ADDR_OWVAR 20
52618: PUSH
52619: LD_INT 0
52621: ST_TO_ADDR
// uc_nation := nation_arabian ;
52622: LD_ADDR_OWVAR 21
52626: PUSH
52627: LD_INT 2
52629: ST_TO_ADDR
// hc_gallery :=  ;
52630: LD_ADDR_OWVAR 33
52634: PUSH
52635: LD_STRING 
52637: ST_TO_ADDR
// hc_name :=  ;
52638: LD_ADDR_OWVAR 26
52642: PUSH
52643: LD_STRING 
52645: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52646: LD_INT 1
52648: PPUSH
52649: LD_INT 11
52651: PPUSH
52652: LD_INT 10
52654: PPUSH
52655: CALL_OW 380
// un := CreateHuman ;
52659: LD_ADDR_VAR 0 1
52663: PUSH
52664: CALL_OW 44
52668: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52669: LD_VAR 0 1
52673: PPUSH
52674: LD_INT 1
52676: PPUSH
52677: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52681: LD_INT 35
52683: PPUSH
52684: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52688: LD_VAR 0 1
52692: PPUSH
52693: LD_INT 22
52695: PUSH
52696: LD_OWVAR 2
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: PPUSH
52705: CALL_OW 69
52709: PPUSH
52710: LD_VAR 0 1
52714: PPUSH
52715: CALL_OW 74
52719: PPUSH
52720: CALL_OW 115
// until IsDead ( un ) ;
52724: LD_VAR 0 1
52728: PPUSH
52729: CALL_OW 301
52733: IFFALSE 52681
// end ;
52735: PPOPN 1
52737: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52738: LD_EXP 89
52742: PUSH
52743: LD_EXP 129
52747: AND
52748: IFFALSE 52760
52750: GO 52752
52752: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52753: LD_STRING earthquake(getX(game), 0, 32)
52755: PPUSH
52756: CALL_OW 559
52760: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52761: LD_EXP 89
52765: PUSH
52766: LD_EXP 130
52770: AND
52771: IFFALSE 52862
52773: GO 52775
52775: DISABLE
52776: LD_INT 0
52778: PPUSH
// begin enable ;
52779: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52780: LD_ADDR_VAR 0 1
52784: PUSH
52785: LD_INT 22
52787: PUSH
52788: LD_OWVAR 2
52792: PUSH
52793: EMPTY
52794: LIST
52795: LIST
52796: PUSH
52797: LD_INT 21
52799: PUSH
52800: LD_INT 2
52802: PUSH
52803: EMPTY
52804: LIST
52805: LIST
52806: PUSH
52807: LD_INT 33
52809: PUSH
52810: LD_INT 3
52812: PUSH
52813: EMPTY
52814: LIST
52815: LIST
52816: PUSH
52817: EMPTY
52818: LIST
52819: LIST
52820: LIST
52821: PPUSH
52822: CALL_OW 69
52826: ST_TO_ADDR
// if not tmp then
52827: LD_VAR 0 1
52831: NOT
52832: IFFALSE 52836
// exit ;
52834: GO 52862
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52836: LD_VAR 0 1
52840: PUSH
52841: LD_INT 1
52843: PPUSH
52844: LD_VAR 0 1
52848: PPUSH
52849: CALL_OW 12
52853: ARRAY
52854: PPUSH
52855: LD_INT 1
52857: PPUSH
52858: CALL_OW 234
// end ;
52862: PPOPN 1
52864: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52865: LD_EXP 89
52869: PUSH
52870: LD_EXP 131
52874: AND
52875: IFFALSE 53016
52877: GO 52879
52879: DISABLE
52880: LD_INT 0
52882: PPUSH
52883: PPUSH
52884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52885: LD_ADDR_VAR 0 3
52889: PUSH
52890: LD_INT 22
52892: PUSH
52893: LD_OWVAR 2
52897: PUSH
52898: EMPTY
52899: LIST
52900: LIST
52901: PUSH
52902: LD_INT 25
52904: PUSH
52905: LD_INT 1
52907: PUSH
52908: EMPTY
52909: LIST
52910: LIST
52911: PUSH
52912: EMPTY
52913: LIST
52914: LIST
52915: PPUSH
52916: CALL_OW 69
52920: ST_TO_ADDR
// if not tmp then
52921: LD_VAR 0 3
52925: NOT
52926: IFFALSE 52930
// exit ;
52928: GO 53016
// un := tmp [ rand ( 1 , tmp ) ] ;
52930: LD_ADDR_VAR 0 2
52934: PUSH
52935: LD_VAR 0 3
52939: PUSH
52940: LD_INT 1
52942: PPUSH
52943: LD_VAR 0 3
52947: PPUSH
52948: CALL_OW 12
52952: ARRAY
52953: ST_TO_ADDR
// if Crawls ( un ) then
52954: LD_VAR 0 2
52958: PPUSH
52959: CALL_OW 318
52963: IFFALSE 52974
// ComWalk ( un ) ;
52965: LD_VAR 0 2
52969: PPUSH
52970: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52974: LD_VAR 0 2
52978: PPUSH
52979: LD_INT 9
52981: PPUSH
52982: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52986: LD_INT 28
52988: PPUSH
52989: LD_OWVAR 2
52993: PPUSH
52994: LD_INT 2
52996: PPUSH
52997: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53001: LD_INT 29
53003: PPUSH
53004: LD_OWVAR 2
53008: PPUSH
53009: LD_INT 2
53011: PPUSH
53012: CALL_OW 322
// end ;
53016: PPOPN 3
53018: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53019: LD_EXP 89
53023: PUSH
53024: LD_EXP 132
53028: AND
53029: IFFALSE 53140
53031: GO 53033
53033: DISABLE
53034: LD_INT 0
53036: PPUSH
53037: PPUSH
53038: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53039: LD_ADDR_VAR 0 3
53043: PUSH
53044: LD_INT 22
53046: PUSH
53047: LD_OWVAR 2
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: PUSH
53056: LD_INT 25
53058: PUSH
53059: LD_INT 1
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: PPUSH
53070: CALL_OW 69
53074: ST_TO_ADDR
// if not tmp then
53075: LD_VAR 0 3
53079: NOT
53080: IFFALSE 53084
// exit ;
53082: GO 53140
// un := tmp [ rand ( 1 , tmp ) ] ;
53084: LD_ADDR_VAR 0 2
53088: PUSH
53089: LD_VAR 0 3
53093: PUSH
53094: LD_INT 1
53096: PPUSH
53097: LD_VAR 0 3
53101: PPUSH
53102: CALL_OW 12
53106: ARRAY
53107: ST_TO_ADDR
// if Crawls ( un ) then
53108: LD_VAR 0 2
53112: PPUSH
53113: CALL_OW 318
53117: IFFALSE 53128
// ComWalk ( un ) ;
53119: LD_VAR 0 2
53123: PPUSH
53124: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53128: LD_VAR 0 2
53132: PPUSH
53133: LD_INT 8
53135: PPUSH
53136: CALL_OW 336
// end ;
53140: PPOPN 3
53142: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53143: LD_EXP 89
53147: PUSH
53148: LD_EXP 133
53152: AND
53153: IFFALSE 53297
53155: GO 53157
53157: DISABLE
53158: LD_INT 0
53160: PPUSH
53161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53162: LD_ADDR_VAR 0 2
53166: PUSH
53167: LD_INT 22
53169: PUSH
53170: LD_OWVAR 2
53174: PUSH
53175: EMPTY
53176: LIST
53177: LIST
53178: PUSH
53179: LD_INT 21
53181: PUSH
53182: LD_INT 2
53184: PUSH
53185: EMPTY
53186: LIST
53187: LIST
53188: PUSH
53189: LD_INT 2
53191: PUSH
53192: LD_INT 34
53194: PUSH
53195: LD_INT 12
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: LD_INT 34
53204: PUSH
53205: LD_INT 51
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: PUSH
53212: LD_INT 34
53214: PUSH
53215: LD_INT 32
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PUSH
53222: EMPTY
53223: LIST
53224: LIST
53225: LIST
53226: LIST
53227: PUSH
53228: EMPTY
53229: LIST
53230: LIST
53231: LIST
53232: PPUSH
53233: CALL_OW 69
53237: ST_TO_ADDR
// if not tmp then
53238: LD_VAR 0 2
53242: NOT
53243: IFFALSE 53247
// exit ;
53245: GO 53297
// for i in tmp do
53247: LD_ADDR_VAR 0 1
53251: PUSH
53252: LD_VAR 0 2
53256: PUSH
53257: FOR_IN
53258: IFFALSE 53295
// if GetCargo ( i , mat_artifact ) = 0 then
53260: LD_VAR 0 1
53264: PPUSH
53265: LD_INT 4
53267: PPUSH
53268: CALL_OW 289
53272: PUSH
53273: LD_INT 0
53275: EQUAL
53276: IFFALSE 53293
// SetCargo ( i , mat_siberit , 100 ) ;
53278: LD_VAR 0 1
53282: PPUSH
53283: LD_INT 3
53285: PPUSH
53286: LD_INT 100
53288: PPUSH
53289: CALL_OW 290
53293: GO 53257
53295: POP
53296: POP
// end ;
53297: PPOPN 2
53299: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53300: LD_EXP 89
53304: PUSH
53305: LD_EXP 134
53309: AND
53310: IFFALSE 53493
53312: GO 53314
53314: DISABLE
53315: LD_INT 0
53317: PPUSH
53318: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53319: LD_ADDR_VAR 0 2
53323: PUSH
53324: LD_INT 22
53326: PUSH
53327: LD_OWVAR 2
53331: PUSH
53332: EMPTY
53333: LIST
53334: LIST
53335: PPUSH
53336: CALL_OW 69
53340: ST_TO_ADDR
// if not tmp then
53341: LD_VAR 0 2
53345: NOT
53346: IFFALSE 53350
// exit ;
53348: GO 53493
// for i := 1 to 2 do
53350: LD_ADDR_VAR 0 1
53354: PUSH
53355: DOUBLE
53356: LD_INT 1
53358: DEC
53359: ST_TO_ADDR
53360: LD_INT 2
53362: PUSH
53363: FOR_TO
53364: IFFALSE 53491
// begin uc_side := your_side ;
53366: LD_ADDR_OWVAR 20
53370: PUSH
53371: LD_OWVAR 2
53375: ST_TO_ADDR
// uc_nation := nation_american ;
53376: LD_ADDR_OWVAR 21
53380: PUSH
53381: LD_INT 1
53383: ST_TO_ADDR
// vc_chassis := us_morphling ;
53384: LD_ADDR_OWVAR 37
53388: PUSH
53389: LD_INT 5
53391: ST_TO_ADDR
// vc_engine := engine_siberite ;
53392: LD_ADDR_OWVAR 39
53396: PUSH
53397: LD_INT 3
53399: ST_TO_ADDR
// vc_control := control_computer ;
53400: LD_ADDR_OWVAR 38
53404: PUSH
53405: LD_INT 3
53407: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53408: LD_ADDR_OWVAR 40
53412: PUSH
53413: LD_INT 10
53415: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53416: LD_VAR 0 2
53420: PUSH
53421: LD_INT 1
53423: ARRAY
53424: PPUSH
53425: CALL_OW 310
53429: NOT
53430: IFFALSE 53477
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53432: CALL_OW 45
53436: PPUSH
53437: LD_VAR 0 2
53441: PUSH
53442: LD_INT 1
53444: ARRAY
53445: PPUSH
53446: CALL_OW 250
53450: PPUSH
53451: LD_VAR 0 2
53455: PUSH
53456: LD_INT 1
53458: ARRAY
53459: PPUSH
53460: CALL_OW 251
53464: PPUSH
53465: LD_INT 12
53467: PPUSH
53468: LD_INT 1
53470: PPUSH
53471: CALL_OW 50
53475: GO 53489
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53477: CALL_OW 45
53481: PPUSH
53482: LD_INT 1
53484: PPUSH
53485: CALL_OW 51
// end ;
53489: GO 53363
53491: POP
53492: POP
// end ;
53493: PPOPN 2
53495: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53496: LD_EXP 89
53500: PUSH
53501: LD_EXP 135
53505: AND
53506: IFFALSE 53728
53508: GO 53510
53510: DISABLE
53511: LD_INT 0
53513: PPUSH
53514: PPUSH
53515: PPUSH
53516: PPUSH
53517: PPUSH
53518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53519: LD_ADDR_VAR 0 6
53523: PUSH
53524: LD_INT 22
53526: PUSH
53527: LD_OWVAR 2
53531: PUSH
53532: EMPTY
53533: LIST
53534: LIST
53535: PUSH
53536: LD_INT 21
53538: PUSH
53539: LD_INT 1
53541: PUSH
53542: EMPTY
53543: LIST
53544: LIST
53545: PUSH
53546: LD_INT 3
53548: PUSH
53549: LD_INT 23
53551: PUSH
53552: LD_INT 0
53554: PUSH
53555: EMPTY
53556: LIST
53557: LIST
53558: PUSH
53559: EMPTY
53560: LIST
53561: LIST
53562: PUSH
53563: EMPTY
53564: LIST
53565: LIST
53566: LIST
53567: PPUSH
53568: CALL_OW 69
53572: ST_TO_ADDR
// if not tmp then
53573: LD_VAR 0 6
53577: NOT
53578: IFFALSE 53582
// exit ;
53580: GO 53728
// s1 := rand ( 1 , 4 ) ;
53582: LD_ADDR_VAR 0 2
53586: PUSH
53587: LD_INT 1
53589: PPUSH
53590: LD_INT 4
53592: PPUSH
53593: CALL_OW 12
53597: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53598: LD_ADDR_VAR 0 4
53602: PUSH
53603: LD_VAR 0 6
53607: PUSH
53608: LD_INT 1
53610: ARRAY
53611: PPUSH
53612: LD_VAR 0 2
53616: PPUSH
53617: CALL_OW 259
53621: ST_TO_ADDR
// if s1 = 1 then
53622: LD_VAR 0 2
53626: PUSH
53627: LD_INT 1
53629: EQUAL
53630: IFFALSE 53650
// s2 := rand ( 2 , 4 ) else
53632: LD_ADDR_VAR 0 3
53636: PUSH
53637: LD_INT 2
53639: PPUSH
53640: LD_INT 4
53642: PPUSH
53643: CALL_OW 12
53647: ST_TO_ADDR
53648: GO 53658
// s2 := 1 ;
53650: LD_ADDR_VAR 0 3
53654: PUSH
53655: LD_INT 1
53657: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53658: LD_ADDR_VAR 0 5
53662: PUSH
53663: LD_VAR 0 6
53667: PUSH
53668: LD_INT 1
53670: ARRAY
53671: PPUSH
53672: LD_VAR 0 3
53676: PPUSH
53677: CALL_OW 259
53681: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53682: LD_VAR 0 6
53686: PUSH
53687: LD_INT 1
53689: ARRAY
53690: PPUSH
53691: LD_VAR 0 2
53695: PPUSH
53696: LD_VAR 0 5
53700: PPUSH
53701: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53705: LD_VAR 0 6
53709: PUSH
53710: LD_INT 1
53712: ARRAY
53713: PPUSH
53714: LD_VAR 0 3
53718: PPUSH
53719: LD_VAR 0 4
53723: PPUSH
53724: CALL_OW 237
// end ;
53728: PPOPN 6
53730: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53731: LD_EXP 89
53735: PUSH
53736: LD_EXP 136
53740: AND
53741: IFFALSE 53820
53743: GO 53745
53745: DISABLE
53746: LD_INT 0
53748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53749: LD_ADDR_VAR 0 1
53753: PUSH
53754: LD_INT 22
53756: PUSH
53757: LD_OWVAR 2
53761: PUSH
53762: EMPTY
53763: LIST
53764: LIST
53765: PUSH
53766: LD_INT 30
53768: PUSH
53769: LD_INT 3
53771: PUSH
53772: EMPTY
53773: LIST
53774: LIST
53775: PUSH
53776: EMPTY
53777: LIST
53778: LIST
53779: PPUSH
53780: CALL_OW 69
53784: ST_TO_ADDR
// if not tmp then
53785: LD_VAR 0 1
53789: NOT
53790: IFFALSE 53794
// exit ;
53792: GO 53820
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53794: LD_VAR 0 1
53798: PUSH
53799: LD_INT 1
53801: PPUSH
53802: LD_VAR 0 1
53806: PPUSH
53807: CALL_OW 12
53811: ARRAY
53812: PPUSH
53813: LD_INT 1
53815: PPUSH
53816: CALL_OW 234
// end ;
53820: PPOPN 1
53822: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53823: LD_EXP 89
53827: PUSH
53828: LD_EXP 137
53832: AND
53833: IFFALSE 53945
53835: GO 53837
53837: DISABLE
53838: LD_INT 0
53840: PPUSH
53841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53842: LD_ADDR_VAR 0 2
53846: PUSH
53847: LD_INT 22
53849: PUSH
53850: LD_OWVAR 2
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: PUSH
53859: LD_INT 2
53861: PUSH
53862: LD_INT 30
53864: PUSH
53865: LD_INT 27
53867: PUSH
53868: EMPTY
53869: LIST
53870: LIST
53871: PUSH
53872: LD_INT 30
53874: PUSH
53875: LD_INT 26
53877: PUSH
53878: EMPTY
53879: LIST
53880: LIST
53881: PUSH
53882: LD_INT 30
53884: PUSH
53885: LD_INT 28
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: PUSH
53892: EMPTY
53893: LIST
53894: LIST
53895: LIST
53896: LIST
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: PPUSH
53902: CALL_OW 69
53906: ST_TO_ADDR
// if not tmp then
53907: LD_VAR 0 2
53911: NOT
53912: IFFALSE 53916
// exit ;
53914: GO 53945
// for i in tmp do
53916: LD_ADDR_VAR 0 1
53920: PUSH
53921: LD_VAR 0 2
53925: PUSH
53926: FOR_IN
53927: IFFALSE 53943
// SetLives ( i , 1 ) ;
53929: LD_VAR 0 1
53933: PPUSH
53934: LD_INT 1
53936: PPUSH
53937: CALL_OW 234
53941: GO 53926
53943: POP
53944: POP
// end ;
53945: PPOPN 2
53947: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53948: LD_EXP 89
53952: PUSH
53953: LD_EXP 138
53957: AND
53958: IFFALSE 54232
53960: GO 53962
53962: DISABLE
53963: LD_INT 0
53965: PPUSH
53966: PPUSH
53967: PPUSH
// begin i := rand ( 1 , 7 ) ;
53968: LD_ADDR_VAR 0 1
53972: PUSH
53973: LD_INT 1
53975: PPUSH
53976: LD_INT 7
53978: PPUSH
53979: CALL_OW 12
53983: ST_TO_ADDR
// case i of 1 :
53984: LD_VAR 0 1
53988: PUSH
53989: LD_INT 1
53991: DOUBLE
53992: EQUAL
53993: IFTRUE 53997
53995: GO 54007
53997: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53998: LD_STRING earthquake(getX(game), 0, 32)
54000: PPUSH
54001: CALL_OW 559
54005: GO 54232
54007: LD_INT 2
54009: DOUBLE
54010: EQUAL
54011: IFTRUE 54015
54013: GO 54029
54015: POP
// begin ToLua ( displayStucuk(); ) ;
54016: LD_STRING displayStucuk();
54018: PPUSH
54019: CALL_OW 559
// ResetFog ;
54023: CALL_OW 335
// end ; 3 :
54027: GO 54232
54029: LD_INT 3
54031: DOUBLE
54032: EQUAL
54033: IFTRUE 54037
54035: GO 54141
54037: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54038: LD_ADDR_VAR 0 2
54042: PUSH
54043: LD_INT 22
54045: PUSH
54046: LD_OWVAR 2
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: PUSH
54055: LD_INT 25
54057: PUSH
54058: LD_INT 1
54060: PUSH
54061: EMPTY
54062: LIST
54063: LIST
54064: PUSH
54065: EMPTY
54066: LIST
54067: LIST
54068: PPUSH
54069: CALL_OW 69
54073: ST_TO_ADDR
// if not tmp then
54074: LD_VAR 0 2
54078: NOT
54079: IFFALSE 54083
// exit ;
54081: GO 54232
// un := tmp [ rand ( 1 , tmp ) ] ;
54083: LD_ADDR_VAR 0 3
54087: PUSH
54088: LD_VAR 0 2
54092: PUSH
54093: LD_INT 1
54095: PPUSH
54096: LD_VAR 0 2
54100: PPUSH
54101: CALL_OW 12
54105: ARRAY
54106: ST_TO_ADDR
// if Crawls ( un ) then
54107: LD_VAR 0 3
54111: PPUSH
54112: CALL_OW 318
54116: IFFALSE 54127
// ComWalk ( un ) ;
54118: LD_VAR 0 3
54122: PPUSH
54123: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54127: LD_VAR 0 3
54131: PPUSH
54132: LD_INT 8
54134: PPUSH
54135: CALL_OW 336
// end ; 4 :
54139: GO 54232
54141: LD_INT 4
54143: DOUBLE
54144: EQUAL
54145: IFTRUE 54149
54147: GO 54210
54149: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54150: LD_ADDR_VAR 0 2
54154: PUSH
54155: LD_INT 22
54157: PUSH
54158: LD_OWVAR 2
54162: PUSH
54163: EMPTY
54164: LIST
54165: LIST
54166: PUSH
54167: LD_INT 30
54169: PUSH
54170: LD_INT 29
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: PUSH
54177: EMPTY
54178: LIST
54179: LIST
54180: PPUSH
54181: CALL_OW 69
54185: ST_TO_ADDR
// if not tmp then
54186: LD_VAR 0 2
54190: NOT
54191: IFFALSE 54195
// exit ;
54193: GO 54232
// DestroyUnit ( tmp [ 1 ] ) ;
54195: LD_VAR 0 2
54199: PUSH
54200: LD_INT 1
54202: ARRAY
54203: PPUSH
54204: CALL_OW 65
// end ; 5 .. 7 :
54208: GO 54232
54210: LD_INT 5
54212: DOUBLE
54213: GREATEREQUAL
54214: IFFALSE 54222
54216: LD_INT 7
54218: DOUBLE
54219: LESSEQUAL
54220: IFTRUE 54224
54222: GO 54231
54224: POP
// StreamSibBomb ; end ;
54225: CALL 50482 0 0
54229: GO 54232
54231: POP
// end ;
54232: PPOPN 3
54234: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54235: LD_EXP 89
54239: PUSH
54240: LD_EXP 139
54244: AND
54245: IFFALSE 54401
54247: GO 54249
54249: DISABLE
54250: LD_INT 0
54252: PPUSH
54253: PPUSH
54254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54255: LD_ADDR_VAR 0 2
54259: PUSH
54260: LD_INT 81
54262: PUSH
54263: LD_OWVAR 2
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: PUSH
54272: LD_INT 2
54274: PUSH
54275: LD_INT 21
54277: PUSH
54278: LD_INT 1
54280: PUSH
54281: EMPTY
54282: LIST
54283: LIST
54284: PUSH
54285: LD_INT 21
54287: PUSH
54288: LD_INT 2
54290: PUSH
54291: EMPTY
54292: LIST
54293: LIST
54294: PUSH
54295: EMPTY
54296: LIST
54297: LIST
54298: LIST
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: PPUSH
54304: CALL_OW 69
54308: ST_TO_ADDR
// if not tmp then
54309: LD_VAR 0 2
54313: NOT
54314: IFFALSE 54318
// exit ;
54316: GO 54401
// p := 0 ;
54318: LD_ADDR_VAR 0 3
54322: PUSH
54323: LD_INT 0
54325: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54326: LD_INT 35
54328: PPUSH
54329: CALL_OW 67
// p := p + 1 ;
54333: LD_ADDR_VAR 0 3
54337: PUSH
54338: LD_VAR 0 3
54342: PUSH
54343: LD_INT 1
54345: PLUS
54346: ST_TO_ADDR
// for i in tmp do
54347: LD_ADDR_VAR 0 1
54351: PUSH
54352: LD_VAR 0 2
54356: PUSH
54357: FOR_IN
54358: IFFALSE 54389
// if GetLives ( i ) < 1000 then
54360: LD_VAR 0 1
54364: PPUSH
54365: CALL_OW 256
54369: PUSH
54370: LD_INT 1000
54372: LESS
54373: IFFALSE 54387
// SetLives ( i , 1000 ) ;
54375: LD_VAR 0 1
54379: PPUSH
54380: LD_INT 1000
54382: PPUSH
54383: CALL_OW 234
54387: GO 54357
54389: POP
54390: POP
// until p > 20 ;
54391: LD_VAR 0 3
54395: PUSH
54396: LD_INT 20
54398: GREATER
54399: IFFALSE 54326
// end ;
54401: PPOPN 3
54403: END
// every 0 0$1 trigger StreamModeActive and sTime do
54404: LD_EXP 89
54408: PUSH
54409: LD_EXP 140
54413: AND
54414: IFFALSE 54449
54416: GO 54418
54418: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54419: LD_INT 28
54421: PPUSH
54422: LD_OWVAR 2
54426: PPUSH
54427: LD_INT 2
54429: PPUSH
54430: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54434: LD_INT 30
54436: PPUSH
54437: LD_OWVAR 2
54441: PPUSH
54442: LD_INT 2
54444: PPUSH
54445: CALL_OW 322
// end ;
54449: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54450: LD_EXP 89
54454: PUSH
54455: LD_EXP 141
54459: AND
54460: IFFALSE 54581
54462: GO 54464
54464: DISABLE
54465: LD_INT 0
54467: PPUSH
54468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54469: LD_ADDR_VAR 0 2
54473: PUSH
54474: LD_INT 22
54476: PUSH
54477: LD_OWVAR 2
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: LD_INT 21
54488: PUSH
54489: LD_INT 1
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PUSH
54496: LD_INT 3
54498: PUSH
54499: LD_INT 23
54501: PUSH
54502: LD_INT 0
54504: PUSH
54505: EMPTY
54506: LIST
54507: LIST
54508: PUSH
54509: EMPTY
54510: LIST
54511: LIST
54512: PUSH
54513: EMPTY
54514: LIST
54515: LIST
54516: LIST
54517: PPUSH
54518: CALL_OW 69
54522: ST_TO_ADDR
// if not tmp then
54523: LD_VAR 0 2
54527: NOT
54528: IFFALSE 54532
// exit ;
54530: GO 54581
// for i in tmp do
54532: LD_ADDR_VAR 0 1
54536: PUSH
54537: LD_VAR 0 2
54541: PUSH
54542: FOR_IN
54543: IFFALSE 54579
// begin if Crawls ( i ) then
54545: LD_VAR 0 1
54549: PPUSH
54550: CALL_OW 318
54554: IFFALSE 54565
// ComWalk ( i ) ;
54556: LD_VAR 0 1
54560: PPUSH
54561: CALL_OW 138
// SetClass ( i , 2 ) ;
54565: LD_VAR 0 1
54569: PPUSH
54570: LD_INT 2
54572: PPUSH
54573: CALL_OW 336
// end ;
54577: GO 54542
54579: POP
54580: POP
// end ;
54581: PPOPN 2
54583: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54584: LD_EXP 89
54588: PUSH
54589: LD_EXP 142
54593: AND
54594: IFFALSE 54875
54596: GO 54598
54598: DISABLE
54599: LD_INT 0
54601: PPUSH
54602: PPUSH
54603: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54604: LD_OWVAR 2
54608: PPUSH
54609: LD_INT 9
54611: PPUSH
54612: LD_INT 1
54614: PPUSH
54615: LD_INT 1
54617: PPUSH
54618: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54622: LD_INT 9
54624: PPUSH
54625: LD_OWVAR 2
54629: PPUSH
54630: CALL_OW 343
// uc_side := 9 ;
54634: LD_ADDR_OWVAR 20
54638: PUSH
54639: LD_INT 9
54641: ST_TO_ADDR
// uc_nation := 2 ;
54642: LD_ADDR_OWVAR 21
54646: PUSH
54647: LD_INT 2
54649: ST_TO_ADDR
// hc_name := Dark Warrior ;
54650: LD_ADDR_OWVAR 26
54654: PUSH
54655: LD_STRING Dark Warrior
54657: ST_TO_ADDR
// hc_gallery :=  ;
54658: LD_ADDR_OWVAR 33
54662: PUSH
54663: LD_STRING 
54665: ST_TO_ADDR
// hc_noskilllimit := true ;
54666: LD_ADDR_OWVAR 76
54670: PUSH
54671: LD_INT 1
54673: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54674: LD_ADDR_OWVAR 31
54678: PUSH
54679: LD_INT 30
54681: PUSH
54682: LD_INT 30
54684: PUSH
54685: LD_INT 30
54687: PUSH
54688: LD_INT 30
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: LIST
54695: LIST
54696: ST_TO_ADDR
// un := CreateHuman ;
54697: LD_ADDR_VAR 0 3
54701: PUSH
54702: CALL_OW 44
54706: ST_TO_ADDR
// hc_noskilllimit := false ;
54707: LD_ADDR_OWVAR 76
54711: PUSH
54712: LD_INT 0
54714: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54715: LD_VAR 0 3
54719: PPUSH
54720: LD_INT 1
54722: PPUSH
54723: CALL_OW 51
// p := 0 ;
54727: LD_ADDR_VAR 0 2
54731: PUSH
54732: LD_INT 0
54734: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54735: LD_INT 35
54737: PPUSH
54738: CALL_OW 67
// p := p + 1 ;
54742: LD_ADDR_VAR 0 2
54746: PUSH
54747: LD_VAR 0 2
54751: PUSH
54752: LD_INT 1
54754: PLUS
54755: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54756: LD_VAR 0 3
54760: PPUSH
54761: CALL_OW 256
54765: PUSH
54766: LD_INT 1000
54768: LESS
54769: IFFALSE 54783
// SetLives ( un , 1000 ) ;
54771: LD_VAR 0 3
54775: PPUSH
54776: LD_INT 1000
54778: PPUSH
54779: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54783: LD_VAR 0 3
54787: PPUSH
54788: LD_INT 81
54790: PUSH
54791: LD_OWVAR 2
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PUSH
54800: LD_INT 91
54802: PUSH
54803: LD_VAR 0 3
54807: PUSH
54808: LD_INT 30
54810: PUSH
54811: EMPTY
54812: LIST
54813: LIST
54814: LIST
54815: PUSH
54816: EMPTY
54817: LIST
54818: LIST
54819: PPUSH
54820: CALL_OW 69
54824: PPUSH
54825: LD_VAR 0 3
54829: PPUSH
54830: CALL_OW 74
54834: PPUSH
54835: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54839: LD_VAR 0 2
54843: PUSH
54844: LD_INT 60
54846: GREATER
54847: PUSH
54848: LD_VAR 0 3
54852: PPUSH
54853: CALL_OW 301
54857: OR
54858: IFFALSE 54735
// if un then
54860: LD_VAR 0 3
54864: IFFALSE 54875
// RemoveUnit ( un ) ;
54866: LD_VAR 0 3
54870: PPUSH
54871: CALL_OW 64
// end ; end_of_file
54875: PPOPN 3
54877: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
54878: LD_INT 0
54880: PPUSH
54881: PPUSH
54882: PPUSH
54883: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
54884: LD_VAR 0 1
54888: PPUSH
54889: CALL_OW 264
54893: PUSH
54894: LD_EXP 79
54898: EQUAL
54899: IFFALSE 54971
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
54901: LD_INT 68
54903: PPUSH
54904: LD_VAR 0 1
54908: PPUSH
54909: CALL_OW 255
54913: PPUSH
54914: CALL_OW 321
54918: PUSH
54919: LD_INT 2
54921: EQUAL
54922: IFFALSE 54934
// eff := 70 else
54924: LD_ADDR_VAR 0 4
54928: PUSH
54929: LD_INT 70
54931: ST_TO_ADDR
54932: GO 54942
// eff := 30 ;
54934: LD_ADDR_VAR 0 4
54938: PUSH
54939: LD_INT 30
54941: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
54942: LD_VAR 0 1
54946: PPUSH
54947: CALL_OW 250
54951: PPUSH
54952: LD_VAR 0 1
54956: PPUSH
54957: CALL_OW 251
54961: PPUSH
54962: LD_VAR 0 4
54966: PPUSH
54967: CALL_OW 495
// end ; end ;
54971: LD_VAR 0 2
54975: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
54976: LD_INT 0
54978: PPUSH
// end ;
54979: LD_VAR 0 4
54983: RET
// export function SOS_Command ( cmd ) ; begin
54984: LD_INT 0
54986: PPUSH
// end ;
54987: LD_VAR 0 2
54991: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
54992: LD_VAR 0 1
54996: PUSH
54997: LD_INT 255
54999: EQUAL
55000: PUSH
55001: LD_VAR 0 2
55005: PPUSH
55006: CALL_OW 264
55010: PUSH
55011: LD_INT 14
55013: PUSH
55014: LD_INT 53
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: IN
55021: AND
55022: PUSH
55023: LD_VAR 0 4
55027: PPUSH
55028: LD_VAR 0 5
55032: PPUSH
55033: CALL_OW 488
55037: AND
55038: IFFALSE 55062
// CutTreeXYR ( unit , x , y , 12 ) ;
55040: LD_VAR 0 2
55044: PPUSH
55045: LD_VAR 0 4
55049: PPUSH
55050: LD_VAR 0 5
55054: PPUSH
55055: LD_INT 12
55057: PPUSH
55058: CALL 55065 0 4
// end ;
55062: PPOPN 5
55064: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
55065: LD_INT 0
55067: PPUSH
55068: PPUSH
55069: PPUSH
55070: PPUSH
55071: PPUSH
55072: PPUSH
55073: PPUSH
55074: PPUSH
55075: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
55076: LD_VAR 0 1
55080: NOT
55081: PUSH
55082: LD_VAR 0 2
55086: PPUSH
55087: LD_VAR 0 3
55091: PPUSH
55092: CALL_OW 488
55096: NOT
55097: OR
55098: PUSH
55099: LD_VAR 0 4
55103: NOT
55104: OR
55105: IFFALSE 55109
// exit ;
55107: GO 55449
// list := [ ] ;
55109: LD_ADDR_VAR 0 13
55113: PUSH
55114: EMPTY
55115: ST_TO_ADDR
// if x - r < 0 then
55116: LD_VAR 0 2
55120: PUSH
55121: LD_VAR 0 4
55125: MINUS
55126: PUSH
55127: LD_INT 0
55129: LESS
55130: IFFALSE 55142
// min_x := 0 else
55132: LD_ADDR_VAR 0 7
55136: PUSH
55137: LD_INT 0
55139: ST_TO_ADDR
55140: GO 55158
// min_x := x - r ;
55142: LD_ADDR_VAR 0 7
55146: PUSH
55147: LD_VAR 0 2
55151: PUSH
55152: LD_VAR 0 4
55156: MINUS
55157: ST_TO_ADDR
// if y - r < 0 then
55158: LD_VAR 0 3
55162: PUSH
55163: LD_VAR 0 4
55167: MINUS
55168: PUSH
55169: LD_INT 0
55171: LESS
55172: IFFALSE 55184
// min_y := 0 else
55174: LD_ADDR_VAR 0 8
55178: PUSH
55179: LD_INT 0
55181: ST_TO_ADDR
55182: GO 55200
// min_y := y - r ;
55184: LD_ADDR_VAR 0 8
55188: PUSH
55189: LD_VAR 0 3
55193: PUSH
55194: LD_VAR 0 4
55198: MINUS
55199: ST_TO_ADDR
// max_x := x + r ;
55200: LD_ADDR_VAR 0 9
55204: PUSH
55205: LD_VAR 0 2
55209: PUSH
55210: LD_VAR 0 4
55214: PLUS
55215: ST_TO_ADDR
// max_y := y + r ;
55216: LD_ADDR_VAR 0 10
55220: PUSH
55221: LD_VAR 0 3
55225: PUSH
55226: LD_VAR 0 4
55230: PLUS
55231: ST_TO_ADDR
// for _x = min_x to max_x do
55232: LD_ADDR_VAR 0 11
55236: PUSH
55237: DOUBLE
55238: LD_VAR 0 7
55242: DEC
55243: ST_TO_ADDR
55244: LD_VAR 0 9
55248: PUSH
55249: FOR_TO
55250: IFFALSE 55367
// for _y = min_y to max_y do
55252: LD_ADDR_VAR 0 12
55256: PUSH
55257: DOUBLE
55258: LD_VAR 0 8
55262: DEC
55263: ST_TO_ADDR
55264: LD_VAR 0 10
55268: PUSH
55269: FOR_TO
55270: IFFALSE 55363
// begin if not ValidHex ( _x , _y ) then
55272: LD_VAR 0 11
55276: PPUSH
55277: LD_VAR 0 12
55281: PPUSH
55282: CALL_OW 488
55286: NOT
55287: IFFALSE 55291
// continue ;
55289: GO 55269
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
55291: LD_VAR 0 11
55295: PPUSH
55296: LD_VAR 0 12
55300: PPUSH
55301: CALL_OW 351
55305: PUSH
55306: LD_VAR 0 11
55310: PPUSH
55311: LD_VAR 0 12
55315: PPUSH
55316: CALL_OW 554
55320: AND
55321: IFFALSE 55361
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
55323: LD_ADDR_VAR 0 13
55327: PUSH
55328: LD_VAR 0 13
55332: PPUSH
55333: LD_VAR 0 13
55337: PUSH
55338: LD_INT 1
55340: PLUS
55341: PPUSH
55342: LD_VAR 0 11
55346: PUSH
55347: LD_VAR 0 12
55351: PUSH
55352: EMPTY
55353: LIST
55354: LIST
55355: PPUSH
55356: CALL_OW 2
55360: ST_TO_ADDR
// end ;
55361: GO 55269
55363: POP
55364: POP
55365: GO 55249
55367: POP
55368: POP
// if not list then
55369: LD_VAR 0 13
55373: NOT
55374: IFFALSE 55378
// exit ;
55376: GO 55449
// for i in list do
55378: LD_ADDR_VAR 0 6
55382: PUSH
55383: LD_VAR 0 13
55387: PUSH
55388: FOR_IN
55389: IFFALSE 55447
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
55391: LD_VAR 0 1
55395: PPUSH
55396: LD_STRING M
55398: PUSH
55399: LD_VAR 0 6
55403: PUSH
55404: LD_INT 1
55406: ARRAY
55407: PUSH
55408: LD_VAR 0 6
55412: PUSH
55413: LD_INT 2
55415: ARRAY
55416: PUSH
55417: LD_INT 0
55419: PUSH
55420: LD_INT 0
55422: PUSH
55423: LD_INT 0
55425: PUSH
55426: LD_INT 0
55428: PUSH
55429: EMPTY
55430: LIST
55431: LIST
55432: LIST
55433: LIST
55434: LIST
55435: LIST
55436: LIST
55437: PUSH
55438: EMPTY
55439: LIST
55440: PPUSH
55441: CALL_OW 447
55445: GO 55388
55447: POP
55448: POP
// end ;
55449: LD_VAR 0 5
55453: RET
