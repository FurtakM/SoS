// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7590 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4623 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4862 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41562 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42013 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21330 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21266 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18259 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21166 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22180 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21407 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21200 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21233 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18038 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22088 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20345 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 20920 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 20920 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20717 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20381 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20557 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19841 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20455 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 20956 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21696 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21266 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18259 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21166 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21407 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18038 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22088 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20345 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 20920 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 20920 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20717 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20381 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20557 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19841 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20455 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 20956 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21696 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19841 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11546 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 21914 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11546 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 21914 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11546 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 21914 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11546 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 21914 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7809 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7809 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7809 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4342
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3744
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// end ; gorki :
3742: GO 4342
3744: LD_EXP 20
3748: DOUBLE
3749: EQUAL
3750: IFTRUE 3754
3752: GO 4035
3754: POP
// begin for i = 1 to 10 do
3755: LD_ADDR_VAR 0 3
3759: PUSH
3760: DOUBLE
3761: LD_INT 1
3763: DEC
3764: ST_TO_ADDR
3765: LD_INT 10
3767: PUSH
3768: FOR_TO
3769: IFFALSE 3823
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3771: LD_INT 0
3773: PPUSH
3774: LD_INT 3
3776: PPUSH
3777: LD_VAR 0 4
3781: PUSH
3782: LD_INT 1
3784: PLUS
3785: PPUSH
3786: CALL_OW 380
// team := team ^ CreateHuman ;
3790: LD_ADDR_VAR 0 6
3794: PUSH
3795: LD_VAR 0 6
3799: PUSH
3800: CALL_OW 44
3804: ADD
3805: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3806: LD_VAR 0 6
3810: PUSH
3811: LD_VAR 0 6
3815: ARRAY
3816: PPUSH
3817: CALL 7809 0 1
// end ;
3821: GO 3768
3823: POP
3824: POP
// for i = 1 to 15 do
3825: LD_ADDR_VAR 0 3
3829: PUSH
3830: DOUBLE
3831: LD_INT 1
3833: DEC
3834: ST_TO_ADDR
3835: LD_INT 15
3837: PUSH
3838: FOR_TO
3839: IFFALSE 3912
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3841: LD_INT 0
3843: PPUSH
3844: LD_INT 1
3846: PUSH
3847: LD_INT 2
3849: PUSH
3850: LD_INT 4
3852: PUSH
3853: EMPTY
3854: LIST
3855: LIST
3856: LIST
3857: PUSH
3858: LD_INT 1
3860: PPUSH
3861: LD_INT 3
3863: PPUSH
3864: CALL_OW 12
3868: ARRAY
3869: PPUSH
3870: LD_VAR 0 4
3874: PPUSH
3875: CALL_OW 380
// team := team ^ CreateHuman ;
3879: LD_ADDR_VAR 0 6
3883: PUSH
3884: LD_VAR 0 6
3888: PUSH
3889: CALL_OW 44
3893: ADD
3894: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3895: LD_VAR 0 6
3899: PUSH
3900: LD_VAR 0 6
3904: ARRAY
3905: PPUSH
3906: CALL 7809 0 1
// end ;
3910: GO 3838
3912: POP
3913: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3914: LD_INT 40
3916: PPUSH
3917: LD_INT 3
3919: PPUSH
3920: LD_INT 1
3922: PPUSH
3923: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3927: LD_INT 34
3929: PPUSH
3930: LD_INT 3
3932: PPUSH
3933: LD_INT 1
3935: PPUSH
3936: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3940: LD_INT 18
3942: PPUSH
3943: LD_INT 3
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3953: LD_ADDR_OWVAR 37
3957: PUSH
3958: LD_INT 22
3960: ST_TO_ADDR
// vc_engine := engine_combustion ;
3961: LD_ADDR_OWVAR 39
3965: PUSH
3966: LD_INT 1
3968: ST_TO_ADDR
// vc_control := control_manual ;
3969: LD_ADDR_OWVAR 38
3973: PUSH
3974: LD_INT 1
3976: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3977: LD_ADDR_OWVAR 40
3981: PUSH
3982: LD_INT 45
3984: ST_TO_ADDR
// vc_fuel_battery := 3 ;
3985: LD_ADDR_OWVAR 41
3989: PUSH
3990: LD_INT 3
3992: ST_TO_ADDR
// veh := CreateVehicle ;
3993: LD_ADDR_VAR 0 7
3997: PUSH
3998: CALL_OW 45
4002: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4003: LD_VAR 0 7
4007: PPUSH
4008: LD_INT 1
4010: PPUSH
4011: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4015: LD_VAR 0 7
4019: PPUSH
4020: LD_INT 107
4022: PPUSH
4023: LD_INT 83
4025: PPUSH
4026: LD_INT 0
4028: PPUSH
4029: CALL_OW 48
// end ; stolypin :
4033: GO 4342
4035: LD_EXP 21
4039: DOUBLE
4040: EQUAL
4041: IFTRUE 4045
4043: GO 4341
4045: POP
// begin for i = 1 to 10 do
4046: LD_ADDR_VAR 0 3
4050: PUSH
4051: DOUBLE
4052: LD_INT 1
4054: DEC
4055: ST_TO_ADDR
4056: LD_INT 10
4058: PUSH
4059: FOR_TO
4060: IFFALSE 4099
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4062: LD_INT 0
4064: PPUSH
4065: LD_INT 2
4067: PPUSH
4068: LD_VAR 0 4
4072: PUSH
4073: LD_INT 1
4075: PLUS
4076: PPUSH
4077: CALL_OW 380
// team := team ^ CreateHuman ;
4081: LD_ADDR_VAR 0 6
4085: PUSH
4086: LD_VAR 0 6
4090: PUSH
4091: CALL_OW 44
4095: ADD
4096: ST_TO_ADDR
// end ;
4097: GO 4059
4099: POP
4100: POP
// for i = 1 to 15 do
4101: LD_ADDR_VAR 0 3
4105: PUSH
4106: DOUBLE
4107: LD_INT 1
4109: DEC
4110: ST_TO_ADDR
4111: LD_INT 15
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4173
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4117: LD_INT 0
4119: PPUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 3
4125: PUSH
4126: LD_INT 4
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 1
4136: PPUSH
4137: LD_INT 3
4139: PPUSH
4140: CALL_OW 12
4144: ARRAY
4145: PPUSH
4146: LD_VAR 0 4
4150: PPUSH
4151: CALL_OW 380
// team := team ^ CreateHuman ;
4155: LD_ADDR_VAR 0 6
4159: PUSH
4160: LD_VAR 0 6
4164: PUSH
4165: CALL_OW 44
4169: ADD
4170: ST_TO_ADDR
// end ;
4171: GO 4114
4173: POP
4174: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4175: LD_INT 34
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: LD_INT 1
4183: PPUSH
4184: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4188: LD_ADDR_OWVAR 37
4192: PUSH
4193: LD_INT 22
4195: ST_TO_ADDR
// vc_engine := engine_combustion ;
4196: LD_ADDR_OWVAR 39
4200: PUSH
4201: LD_INT 1
4203: ST_TO_ADDR
// vc_control := control_manual ;
4204: LD_ADDR_OWVAR 38
4208: PUSH
4209: LD_INT 1
4211: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4212: LD_ADDR_OWVAR 40
4216: PUSH
4217: LD_INT 51
4219: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4220: LD_ADDR_OWVAR 41
4224: PUSH
4225: LD_INT 30
4227: ST_TO_ADDR
// veh := CreateVehicle ;
4228: LD_ADDR_VAR 0 7
4232: PUSH
4233: CALL_OW 45
4237: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4238: LD_VAR 0 7
4242: PPUSH
4243: LD_INT 1
4245: PPUSH
4246: LD_INT 100
4248: PPUSH
4249: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4253: LD_VAR 0 7
4257: PPUSH
4258: LD_INT 107
4260: PPUSH
4261: LD_INT 83
4263: PPUSH
4264: LD_INT 0
4266: PPUSH
4267: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4271: LD_ADDR_OWVAR 37
4275: PUSH
4276: LD_INT 22
4278: ST_TO_ADDR
// vc_engine := engine_combustion ;
4279: LD_ADDR_OWVAR 39
4283: PUSH
4284: LD_INT 1
4286: ST_TO_ADDR
// vc_control := control_manual ;
4287: LD_ADDR_OWVAR 38
4291: PUSH
4292: LD_INT 1
4294: ST_TO_ADDR
// vc_weapon := ru_crane ;
4295: LD_ADDR_OWVAR 40
4299: PUSH
4300: LD_INT 52
4302: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4303: LD_ADDR_OWVAR 41
4307: PUSH
4308: LD_INT 30
4310: ST_TO_ADDR
// veh := CreateVehicle ;
4311: LD_ADDR_VAR 0 7
4315: PUSH
4316: CALL_OW 45
4320: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4321: LD_VAR 0 7
4325: PPUSH
4326: LD_INT 115
4328: PPUSH
4329: LD_INT 96
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 48
// end ; end ;
4339: GO 4342
4341: POP
// if isTest then
4342: LD_EXP 1
4346: IFFALSE 4360
// tmp := team else
4348: LD_ADDR_VAR 0 5
4352: PUSH
4353: LD_VAR 0 6
4357: ST_TO_ADDR
4358: GO 4451
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4360: LD_ADDR_VAR 0 5
4364: PUSH
4365: LD_STRING text
4367: PPUSH
4368: LD_INT 10
4370: PUSH
4371: LD_INT 9
4373: PUSH
4374: LD_INT 8
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: LD_OWVAR 67
4386: ARRAY
4387: PPUSH
4388: LD_INT 10
4390: PUSH
4391: LD_INT 9
4393: PUSH
4394: LD_INT 8
4396: PUSH
4397: EMPTY
4398: LIST
4399: LIST
4400: LIST
4401: PUSH
4402: LD_OWVAR 67
4406: ARRAY
4407: PPUSH
4408: LD_INT -2
4410: PUSH
4411: LD_INT -5
4413: PUSH
4414: LD_INT -3
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: LIST
4421: PUSH
4422: LD_VAR 0 6
4426: ADD
4427: PPUSH
4428: LD_INT 1
4430: PUSH
4431: LD_INT 2
4433: PUSH
4434: LD_INT 3
4436: PUSH
4437: LD_INT 4
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: PPUSH
4446: CALL_OW 42
4450: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4451: LD_EXP 23
4455: PPUSH
4456: LD_INT 4
4458: PPUSH
4459: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4463: LD_EXP 23
4467: PPUSH
4468: LD_INT 18
4470: PPUSH
4471: LD_INT 0
4473: PPUSH
4474: CALL_OW 49
// ComHold ( player_com ) ;
4478: LD_EXP 23
4482: PPUSH
4483: CALL_OW 140
// for i in tmp do
4487: LD_ADDR_VAR 0 3
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: FOR_IN
4498: IFFALSE 4514
// SetSide ( i , 6 ) ;
4500: LD_VAR 0 3
4504: PPUSH
4505: LD_INT 6
4507: PPUSH
4508: CALL_OW 235
4512: GO 4497
4514: POP
4515: POP
// for i = 1 to 4 do
4516: LD_ADDR_VAR 0 3
4520: PUSH
4521: DOUBLE
4522: LD_INT 1
4524: DEC
4525: ST_TO_ADDR
4526: LD_INT 4
4528: PUSH
4529: FOR_TO
4530: IFFALSE 4593
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4532: LD_VAR 0 5
4536: PUSH
4537: LD_INT 1
4539: ARRAY
4540: PPUSH
4541: LD_INT 4
4543: PPUSH
4544: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4548: LD_VAR 0 5
4552: PUSH
4553: LD_INT 1
4555: ARRAY
4556: PPUSH
4557: LD_INT 104
4559: PPUSH
4560: LD_INT 88
4562: PPUSH
4563: LD_INT 3
4565: PPUSH
4566: LD_INT 0
4568: PPUSH
4569: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4573: LD_ADDR_VAR 0 5
4577: PUSH
4578: LD_VAR 0 5
4582: PPUSH
4583: LD_INT 1
4585: PPUSH
4586: CALL_OW 3
4590: ST_TO_ADDR
// end ;
4591: GO 4529
4593: POP
4594: POP
// player_squad := tmp ;
4595: LD_ADDR_EXP 22
4599: PUSH
4600: LD_VAR 0 5
4604: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4605: LD_INT 17
4607: PPUSH
4608: LD_INT 5
4610: PPUSH
4611: LD_INT 1
4613: PPUSH
4614: CALL 18259 0 3
// end ;
4618: LD_VAR 0 2
4622: RET
// export Popov ; export function InitAction ; var commander ; begin
4623: LD_INT 0
4625: PPUSH
4626: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4627: LD_INT 6
4629: PPUSH
4630: LD_INT 3
4632: PPUSH
4633: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4637: LD_INT 1
4639: PPUSH
4640: LD_INT 1
4642: PPUSH
4643: CALL_OW 86
// uc_side := 6 ;
4647: LD_ADDR_OWVAR 20
4651: PUSH
4652: LD_INT 6
4654: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4655: LD_ADDR_EXP 24
4659: PUSH
4660: LD_STRING Popov
4662: PPUSH
4663: CALL_OW 25
4667: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4668: LD_ADDR_OWVAR 67
4672: PUSH
4673: LD_INT 0
4675: PPUSH
4676: CALL_OW 426
4680: ST_TO_ADDR
// if not Difficulty then
4681: LD_OWVAR 67
4685: NOT
4686: IFFALSE 4696
// Difficulty := 2 ;
4688: LD_ADDR_OWVAR 67
4692: PUSH
4693: LD_INT 2
4695: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4696: LD_ADDR_VAR 0 2
4700: PUSH
4701: LD_INT 1
4703: PPUSH
4704: CALL_OW 426
4708: ST_TO_ADDR
// if not commander then
4709: LD_VAR 0 2
4713: NOT
4714: IFFALSE 4724
// commander := 1 ;
4716: LD_ADDR_VAR 0 2
4720: PUSH
4721: LD_INT 1
4723: ST_TO_ADDR
// InitCommanders ( commander ) ;
4724: LD_VAR 0 2
4728: PPUSH
4729: CALL 3102 0 1
// end ;
4733: LD_VAR 0 1
4737: RET
// every 1 1$45 trigger player_squad do var i ;
4738: LD_EXP 22
4742: IFFALSE 4859
4744: GO 4746
4746: DISABLE
4747: LD_INT 0
4749: PPUSH
// begin enable ;
4750: ENABLE
// for i := 1 to 3 do
4751: LD_ADDR_VAR 0 1
4755: PUSH
4756: DOUBLE
4757: LD_INT 1
4759: DEC
4760: ST_TO_ADDR
4761: LD_INT 3
4763: PUSH
4764: FOR_TO
4765: IFFALSE 4857
// begin if player_squad < i then
4767: LD_EXP 22
4771: PUSH
4772: LD_VAR 0 1
4776: LESS
4777: IFFALSE 4783
// exit ;
4779: POP
4780: POP
4781: GO 4859
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4783: LD_EXP 22
4787: PUSH
4788: LD_INT 1
4790: ARRAY
4791: PPUSH
4792: LD_INT 18
4794: PPUSH
4795: LD_INT 0
4797: PPUSH
4798: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4802: LD_EXP 22
4806: PUSH
4807: LD_INT 1
4809: ARRAY
4810: PPUSH
4811: LD_INT 107
4813: PPUSH
4814: LD_INT 88
4816: PPUSH
4817: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4821: LD_EXP 22
4825: PUSH
4826: LD_INT 1
4828: ARRAY
4829: PPUSH
4830: LD_INT 3
4832: PPUSH
4833: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4837: LD_ADDR_EXP 22
4841: PUSH
4842: LD_EXP 22
4846: PPUSH
4847: LD_INT 1
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
// end ;
4855: GO 4764
4857: POP
4858: POP
// end ;
4859: PPOPN 1
4861: END
// export function Dialog ; var i ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
// if not isTest then
4866: LD_EXP 1
4870: NOT
4871: IFFALSE 4893
// case query ( task ) of 1 :
4873: LD_STRING task
4875: PPUSH
4876: CALL_OW 97
4880: PUSH
4881: LD_INT 1
4883: DOUBLE
4884: EQUAL
4885: IFTRUE 4889
4887: GO 4892
4889: POP
// ; end ;
4890: GO 4893
4892: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4893: LD_INT 105
4895: PPUSH
4896: LD_INT 84
4898: PPUSH
4899: LD_INT 3
4901: PPUSH
4902: LD_INT 30
4904: NEG
4905: PPUSH
4906: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4910: LD_INT 105
4912: PPUSH
4913: LD_INT 84
4915: PPUSH
4916: LD_INT 3
4918: PPUSH
4919: CALL_OW 331
// InGameOn ;
4923: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4927: LD_INT 128
4929: PPUSH
4930: LD_INT 64
4932: PPUSH
4933: CALL_OW 86
// if isTest then
4937: LD_EXP 1
4941: IFFALSE 4951
// dialogue_skipped := true ;
4943: LD_ADDR_OWVAR 59
4947: PUSH
4948: LD_INT 1
4950: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4951: LD_EXP 24
4955: PPUSH
4956: LD_STRING DR1
4958: PPUSH
4959: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4963: LD_EXP 24
4967: PPUSH
4968: LD_STRING DR2
4970: PPUSH
4971: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4975: LD_EXP 24
4979: PPUSH
4980: LD_STRING DR3
4982: PPUSH
4983: CALL_OW 94
// InGameOff ;
4987: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4991: LD_STRING C1
4993: PPUSH
4994: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
4998: LD_INT 35
5000: PPUSH
5001: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5005: LD_INT 9
5007: PPUSH
5008: LD_INT 22
5010: PUSH
5011: LD_INT 3
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PPUSH
5018: CALL_OW 70
5022: IFFALSE 4998
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5024: LD_ADDR_VAR 0 2
5028: PUSH
5029: LD_INT 9
5031: PPUSH
5032: LD_INT 22
5034: PUSH
5035: LD_INT 6
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: PPUSH
5042: CALL_OW 70
5046: PUSH
5047: FOR_IN
5048: IFFALSE 5064
// SetSide ( i , 3 ) ;
5050: LD_VAR 0 2
5054: PPUSH
5055: LD_INT 3
5057: PPUSH
5058: CALL_OW 235
5062: GO 5047
5064: POP
5065: POP
// if not isTest then
5066: LD_EXP 1
5070: NOT
5071: IFFALSE 5093
// case query ( support ) of 1 :
5073: LD_STRING support
5075: PPUSH
5076: CALL_OW 97
5080: PUSH
5081: LD_INT 1
5083: DOUBLE
5084: EQUAL
5085: IFTRUE 5089
5087: GO 5092
5089: POP
// ; end ;
5090: GO 5093
5092: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5093: LD_INT 3
5095: PPUSH
5096: LD_INT 12
5098: PPUSH
5099: LD_INT 2
5101: PPUSH
5102: LD_INT 22
5104: PUSH
5105: LD_INT 3
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: PUSH
5112: LD_INT 30
5114: PUSH
5115: LD_INT 0
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: PUSH
5131: LD_INT 1
5133: ARRAY
5134: PPUSH
5135: CALL_OW 468
// if player_com = stolypin then
5139: LD_EXP 23
5143: PUSH
5144: LD_EXP 21
5148: EQUAL
5149: IFFALSE 5178
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5151: LD_INT 18
5153: PPUSH
5154: LD_INT 3
5156: PUSH
5157: LD_INT 3
5159: PUSH
5160: LD_INT 2
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: LIST
5167: PUSH
5168: LD_OWVAR 67
5172: ARRAY
5173: PPUSH
5174: CALL 6590 0 2
// end ;
5178: LD_VAR 0 1
5182: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5183: LD_EXP 11
5187: PUSH
5188: LD_OWVAR 1
5192: PUSH
5193: LD_INT 31500
5195: LESS
5196: AND
5197: IFFALSE 5365
// case query ( call1 ) of 1 :
5199: LD_STRING call1
5201: PPUSH
5202: CALL_OW 97
5206: PUSH
5207: LD_INT 1
5209: DOUBLE
5210: EQUAL
5211: IFTRUE 5215
5213: GO 5353
5215: POP
// begin callUsed := true ;
5216: LD_ADDR_EXP 3
5220: PUSH
5221: LD_INT 1
5223: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5224: LD_INT 3
5226: PPUSH
5227: LD_INT 12
5229: PPUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_INT 1
5235: PPUSH
5236: CALL_OW 468
// call := false ;
5240: LD_ADDR_EXP 11
5244: PUSH
5245: LD_INT 0
5247: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5248: LD_EXP 24
5252: PPUSH
5253: LD_STRING DR6
5255: PPUSH
5256: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5260: LD_INT 6300
5262: PPUSH
5263: LD_INT 8400
5265: PPUSH
5266: CALL_OW 12
5270: PPUSH
5271: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5275: LD_INT 18
5277: PUSH
5278: LD_INT 19
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: PUSH
5285: LD_INT 1
5287: PPUSH
5288: LD_INT 2
5290: PPUSH
5291: CALL_OW 12
5295: ARRAY
5296: PPUSH
5297: LD_INT 1
5299: PPUSH
5300: LD_INT 2
5302: PPUSH
5303: CALL_OW 12
5307: PPUSH
5308: CALL 6590 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5312: LD_INT 25200
5314: PPUSH
5315: LD_INT 35700
5317: PPUSH
5318: CALL_OW 12
5322: PPUSH
5323: CALL_OW 67
// call := true ;
5327: LD_ADDR_EXP 11
5331: PUSH
5332: LD_INT 1
5334: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5335: LD_INT 3
5337: PPUSH
5338: LD_INT 12
5340: PPUSH
5341: LD_INT 2
5343: PPUSH
5344: LD_INT 1
5346: PPUSH
5347: CALL_OW 468
// end ; 2 :
5351: GO 5365
5353: LD_INT 2
5355: DOUBLE
5356: EQUAL
5357: IFTRUE 5361
5359: GO 5364
5361: POP
// ; end ;
5362: GO 5365
5364: POP
// if call and tick >= 15 15$00 then
5365: LD_EXP 11
5369: PUSH
5370: LD_OWVAR 1
5374: PUSH
5375: LD_INT 31500
5377: GREATEREQUAL
5378: AND
5379: IFFALSE 5818
// case query ( call2 ) of 1 :
5381: LD_STRING call2
5383: PPUSH
5384: CALL_OW 97
5388: PUSH
5389: LD_INT 1
5391: DOUBLE
5392: EQUAL
5393: IFTRUE 5397
5395: GO 5639
5397: POP
// begin callUsed := true ;
5398: LD_ADDR_EXP 3
5402: PUSH
5403: LD_INT 1
5405: ST_TO_ADDR
// call := false ;
5406: LD_ADDR_EXP 11
5410: PUSH
5411: LD_INT 0
5413: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5414: LD_INT 1
5416: PPUSH
5417: LD_INT 21
5419: PUSH
5420: LD_INT 3
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: CALL 11546 0 2
5431: PUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11546 0 2
5449: AND
5450: IFFALSE 5498
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5452: LD_INT 18
5454: PUSH
5455: LD_INT 19
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 1
5464: PPUSH
5465: LD_INT 2
5467: PPUSH
5468: CALL_OW 12
5472: ARRAY
5473: PPUSH
5474: LD_INT 5
5476: PUSH
5477: LD_INT 4
5479: PUSH
5480: LD_INT 4
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: LD_OWVAR 67
5492: ARRAY
5493: PPUSH
5494: CALL 6351 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5498: LD_INT 1
5500: PPUSH
5501: LD_INT 21
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL 11546 0 2
5515: PUSH
5516: LD_INT 0
5518: EQUAL
5519: IFFALSE 5548
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5521: LD_INT 19
5523: PPUSH
5524: LD_INT 5
5526: PUSH
5527: LD_INT 4
5529: PUSH
5530: LD_INT 3
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: LD_OWVAR 67
5542: ARRAY
5543: PPUSH
5544: CALL 6351 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5548: LD_INT 4
5550: PPUSH
5551: LD_INT 21
5553: PUSH
5554: LD_INT 3
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PPUSH
5561: CALL 11546 0 2
5565: PUSH
5566: LD_INT 0
5568: EQUAL
5569: IFFALSE 5598
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5571: LD_INT 18
5573: PPUSH
5574: LD_INT 5
5576: PUSH
5577: LD_INT 4
5579: PUSH
5580: LD_INT 4
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: PUSH
5588: LD_OWVAR 67
5592: ARRAY
5593: PPUSH
5594: CALL 6351 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5598: LD_INT 10500
5600: PPUSH
5601: LD_INT 23100
5603: PPUSH
5604: CALL_OW 12
5608: PPUSH
5609: CALL_OW 67
// call := true ;
5613: LD_ADDR_EXP 11
5617: PUSH
5618: LD_INT 1
5620: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 12
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_INT 1
5632: PPUSH
5633: CALL_OW 468
// end ; 2 :
5637: GO 5818
5639: LD_INT 2
5641: DOUBLE
5642: EQUAL
5643: IFTRUE 5647
5645: GO 5806
5647: POP
// begin callUsed := true ;
5648: LD_ADDR_EXP 3
5652: PUSH
5653: LD_INT 1
5655: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5656: LD_INT 3
5658: PPUSH
5659: LD_INT 12
5661: PPUSH
5662: LD_INT 1
5664: PPUSH
5665: LD_INT 1
5667: PPUSH
5668: CALL_OW 468
// call := false ;
5672: LD_ADDR_EXP 11
5676: PUSH
5677: LD_INT 0
5679: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5680: LD_EXP 24
5684: PPUSH
5685: LD_STRING DR6
5687: PPUSH
5688: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5692: LD_INT 6300
5694: PPUSH
5695: LD_INT 8400
5697: PPUSH
5698: CALL_OW 12
5702: PPUSH
5703: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5707: LD_INT 18
5709: PUSH
5710: LD_INT 19
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: PUSH
5717: LD_INT 1
5719: PPUSH
5720: LD_INT 2
5722: PPUSH
5723: CALL_OW 12
5727: ARRAY
5728: PPUSH
5729: LD_INT 3
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: LD_OWVAR 67
5747: ARRAY
5748: PUSH
5749: LD_INT 0
5751: PPUSH
5752: LD_INT 1
5754: PPUSH
5755: CALL_OW 12
5759: MINUS
5760: PPUSH
5761: CALL 6590 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5765: LD_INT 35700
5767: PPUSH
5768: LD_INT 44100
5770: PPUSH
5771: CALL_OW 12
5775: PPUSH
5776: CALL_OW 67
// call := true ;
5780: LD_ADDR_EXP 11
5784: PUSH
5785: LD_INT 1
5787: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5788: LD_INT 3
5790: PPUSH
5791: LD_INT 12
5793: PPUSH
5794: LD_INT 2
5796: PPUSH
5797: LD_INT 1
5799: PPUSH
5800: CALL_OW 468
// end ; 3 :
5804: GO 5818
5806: LD_INT 3
5808: DOUBLE
5809: EQUAL
5810: IFTRUE 5814
5812: GO 5817
5814: POP
// ; end ;
5815: GO 5818
5817: POP
// end ;
5818: PPOPN 4
5820: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5821: LD_INT 22
5823: PUSH
5824: LD_INT 1
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: PUSH
5831: LD_INT 21
5833: PUSH
5834: LD_INT 1
5836: PUSH
5837: EMPTY
5838: LIST
5839: LIST
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PPUSH
5845: CALL_OW 69
5849: PUSH
5850: LD_INT 0
5852: EQUAL
5853: PUSH
5854: LD_INT 22
5856: PUSH
5857: LD_INT 4
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 21
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PPUSH
5878: CALL_OW 69
5882: PUSH
5883: LD_INT 0
5885: EQUAL
5886: AND
5887: IFFALSE 6191
5889: GO 5891
5891: DISABLE
// begin DialogueOn ;
5892: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5896: LD_EXP 24
5900: PPUSH
5901: LD_STRING DR7
5903: PPUSH
5904: CALL_OW 94
// case player_com of Gorki :
5908: LD_EXP 23
5912: PUSH
5913: LD_EXP 20
5917: DOUBLE
5918: EQUAL
5919: IFTRUE 5923
5921: GO 5933
5923: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5924: LD_STRING ACH_GORKI
5926: PPUSH
5927: CALL_OW 543
5931: GO 5994
5933: LD_EXP 21
5937: DOUBLE
5938: EQUAL
5939: IFTRUE 5943
5941: GO 5953
5943: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5944: LD_STRING ACH_STOLYP
5946: PPUSH
5947: CALL_OW 543
5951: GO 5994
5953: LD_EXP 19
5957: DOUBLE
5958: EQUAL
5959: IFTRUE 5963
5961: GO 5973
5963: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5964: LD_STRING ACH_DAVIDOV
5966: PPUSH
5967: CALL_OW 543
5971: GO 5994
5973: LD_EXP 18
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 5993
5983: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5984: LD_STRING ACH_GLADKOV
5986: PPUSH
5987: CALL_OW 543
5991: GO 5994
5993: POP
// if not callUsed then
5994: LD_EXP 3
5998: NOT
5999: IFFALSE 6008
// SetAchievement ( ACH_NOSUPP ) ;
6001: LD_STRING ACH_NOSUPP
6003: PPUSH
6004: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6008: LD_OWVAR 1
6012: PUSH
6013: LD_INT 116550
6015: PUSH
6016: LD_INT 95550
6018: PUSH
6019: LD_INT 89250
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_OWVAR 67
6031: ARRAY
6032: LESS
6033: IFFALSE 6047
// AddMedal ( med1 , 1 ) else
6035: LD_STRING med1
6037: PPUSH
6038: LD_INT 1
6040: PPUSH
6041: CALL_OW 101
6045: GO 6058
// AddMedal ( med1 , - 1 ) ;
6047: LD_STRING med1
6049: PPUSH
6050: LD_INT 1
6052: NEG
6053: PPUSH
6054: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6058: LD_INT 81
6060: PUSH
6061: LD_INT 3
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 21
6070: PUSH
6071: LD_INT 3
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: PPUSH
6082: CALL_OW 69
6086: PUSH
6087: LD_INT 0
6089: EQUAL
6090: IFFALSE 6104
// AddMedal ( med3 , 1 ) else
6092: LD_STRING med3
6094: PPUSH
6095: LD_INT 1
6097: PPUSH
6098: CALL_OW 101
6102: GO 6115
// AddMedal ( med3 , - 1 ) ;
6104: LD_STRING med3
6106: PPUSH
6107: LD_INT 1
6109: NEG
6110: PPUSH
6111: CALL_OW 101
// if player_loss = 0 then
6115: LD_EXP 10
6119: PUSH
6120: LD_INT 0
6122: EQUAL
6123: IFFALSE 6137
// AddMedal ( med2 , 1 ) else
6125: LD_STRING med2
6127: PPUSH
6128: LD_INT 1
6130: PPUSH
6131: CALL_OW 101
6135: GO 6180
// if player_loss > 0 and player_loss < 3 then
6137: LD_EXP 10
6141: PUSH
6142: LD_INT 0
6144: GREATER
6145: PUSH
6146: LD_EXP 10
6150: PUSH
6151: LD_INT 3
6153: LESS
6154: AND
6155: IFFALSE 6169
// AddMedal ( med2 , 2 ) else
6157: LD_STRING med2
6159: PPUSH
6160: LD_INT 2
6162: PPUSH
6163: CALL_OW 101
6167: GO 6180
// AddMedal ( med2 , - 1 ) ;
6169: LD_STRING med2
6171: PPUSH
6172: LD_INT 1
6174: NEG
6175: PPUSH
6176: CALL_OW 101
// GiveMedals ( MAIN ) ;
6180: LD_STRING MAIN
6182: PPUSH
6183: CALL_OW 102
// YouWin ;
6187: CALL_OW 103
// end ;
6191: END
// every 0 0$01 trigger IsDead ( player_com ) do
6192: LD_EXP 23
6196: PPUSH
6197: CALL_OW 301
6201: IFFALSE 6268
6203: GO 6205
6205: DISABLE
// begin if IsLive ( Houten ) then
6206: LD_EXP 4
6210: PPUSH
6211: CALL_OW 300
6215: IFFALSE 6231
// SayRadio ( Houten , DJ5 ) else
6217: LD_EXP 4
6221: PPUSH
6222: LD_STRING DJ5
6224: PPUSH
6225: CALL_OW 94
6229: GO 6254
// if IsLive ( Brown ) then
6231: LD_EXP 5
6235: PPUSH
6236: CALL_OW 300
6240: IFFALSE 6254
// SayRadio ( Brown , DS5 ) ;
6242: LD_EXP 5
6246: PPUSH
6247: LD_STRING DS5
6249: PPUSH
6250: CALL_OW 94
// Wait ( 0 0$01 ) ;
6254: LD_INT 35
6256: PPUSH
6257: CALL_OW 67
// YouLost ( dead ) ;
6261: LD_STRING dead
6263: PPUSH
6264: CALL_OW 104
// end ;
6268: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6269: LD_INT 1
6271: PPUSH
6272: CALL_OW 301
6276: PUSH
6277: LD_EXP 1
6281: NOT
6282: AND
6283: IFFALSE 6350
6285: GO 6287
6287: DISABLE
// begin if IsLive ( Brown ) then
6288: LD_EXP 5
6292: PPUSH
6293: CALL_OW 300
6297: IFFALSE 6313
// SayRadio ( Brown , DS5 ) else
6299: LD_EXP 5
6303: PPUSH
6304: LD_STRING DS5
6306: PPUSH
6307: CALL_OW 94
6311: GO 6336
// if IsLive ( Houten ) then
6313: LD_EXP 4
6317: PPUSH
6318: CALL_OW 300
6322: IFFALSE 6336
// SayRadio ( Houten , DJ5 ) ;
6324: LD_EXP 4
6328: PPUSH
6329: LD_STRING DJ5
6331: PPUSH
6332: CALL_OW 94
// Wait ( 0 0$01 ) ;
6336: LD_INT 35
6338: PPUSH
6339: CALL_OW 67
// YouLost ( depot ) ;
6343: LD_STRING depot
6345: PPUSH
6346: CALL_OW 104
// end ;
6350: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6351: LD_INT 0
6353: PPUSH
6354: PPUSH
6355: PPUSH
// for i = 1 to n do
6356: LD_ADDR_VAR 0 4
6360: PUSH
6361: DOUBLE
6362: LD_INT 1
6364: DEC
6365: ST_TO_ADDR
6366: LD_VAR 0 2
6370: PUSH
6371: FOR_TO
6372: IFFALSE 6575
// begin uc_side := 6 ;
6374: LD_ADDR_OWVAR 20
6378: PUSH
6379: LD_INT 6
6381: ST_TO_ADDR
// uc_nation := 3 ;
6382: LD_ADDR_OWVAR 21
6386: PUSH
6387: LD_INT 3
6389: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6390: LD_ADDR_OWVAR 37
6394: PUSH
6395: LD_INT 23
6397: PUSH
6398: LD_INT 22
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 2
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: ST_TO_ADDR
// vc_control := control_computer ;
6417: LD_ADDR_OWVAR 38
6421: PUSH
6422: LD_INT 3
6424: ST_TO_ADDR
// vc_engine := engine_siberite ;
6425: LD_ADDR_OWVAR 39
6429: PUSH
6430: LD_INT 3
6432: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6433: LD_ADDR_OWVAR 40
6437: PUSH
6438: LD_INT 43
6440: PUSH
6441: LD_INT 44
6443: PUSH
6444: LD_INT 44
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: LIST
6451: PUSH
6452: LD_INT 1
6454: PPUSH
6455: LD_INT 3
6457: PPUSH
6458: CALL_OW 12
6462: ARRAY
6463: ST_TO_ADDR
// un := CreateVehicle ;
6464: LD_ADDR_VAR 0 5
6468: PUSH
6469: CALL_OW 45
6473: ST_TO_ADDR
// case area of east_arr :
6474: LD_VAR 0 1
6478: PUSH
6479: LD_INT 18
6481: DOUBLE
6482: EQUAL
6483: IFTRUE 6487
6485: GO 6522
6487: POP
// begin PlaceUnitArea ( un , area , false ) ;
6488: LD_VAR 0 5
6492: PPUSH
6493: LD_VAR 0 1
6497: PPUSH
6498: LD_INT 0
6500: PPUSH
6501: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6505: LD_VAR 0 5
6509: PPUSH
6510: LD_INT 79
6512: PPUSH
6513: LD_INT 33
6515: PPUSH
6516: CALL_OW 111
// end ; south_arr :
6520: GO 6566
6522: LD_INT 19
6524: DOUBLE
6525: EQUAL
6526: IFTRUE 6530
6528: GO 6565
6530: POP
// begin PlaceUnitArea ( un , area , false ) ;
6531: LD_VAR 0 5
6535: PPUSH
6536: LD_VAR 0 1
6540: PPUSH
6541: LD_INT 0
6543: PPUSH
6544: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6548: LD_VAR 0 5
6552: PPUSH
6553: LD_INT 131
6555: PPUSH
6556: LD_INT 148
6558: PPUSH
6559: CALL_OW 111
// end ; end ;
6563: GO 6566
6565: POP
// Wait ( 0 0$02 ) ;
6566: LD_INT 70
6568: PPUSH
6569: CALL_OW 67
// end ;
6573: GO 6371
6575: POP
6576: POP
// pink_attack := true ;
6577: LD_ADDR_EXP 12
6581: PUSH
6582: LD_INT 1
6584: ST_TO_ADDR
// end ;
6585: LD_VAR 0 3
6589: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6590: LD_INT 0
6592: PPUSH
6593: PPUSH
6594: PPUSH
// for i = 1 to n do
6595: LD_ADDR_VAR 0 4
6599: PUSH
6600: DOUBLE
6601: LD_INT 1
6603: DEC
6604: ST_TO_ADDR
6605: LD_VAR 0 2
6609: PUSH
6610: FOR_TO
6611: IFFALSE 6837
// begin uc_side := 6 ;
6613: LD_ADDR_OWVAR 20
6617: PUSH
6618: LD_INT 6
6620: ST_TO_ADDR
// uc_nation := 3 ;
6621: LD_ADDR_OWVAR 21
6625: PUSH
6626: LD_INT 3
6628: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6629: LD_INT 0
6631: PPUSH
6632: LD_INT 3
6634: PPUSH
6635: LD_INT 4
6637: PPUSH
6638: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6642: LD_ADDR_OWVAR 37
6646: PUSH
6647: LD_INT 22
6649: ST_TO_ADDR
// vc_control := control_manual ;
6650: LD_ADDR_OWVAR 38
6654: PUSH
6655: LD_INT 1
6657: ST_TO_ADDR
// vc_engine := engine_combustion ;
6658: LD_ADDR_OWVAR 39
6662: PUSH
6663: LD_INT 1
6665: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6666: LD_ADDR_OWVAR 40
6670: PUSH
6671: LD_INT 51
6673: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6674: LD_ADDR_OWVAR 41
6678: PUSH
6679: LD_INT 50
6681: ST_TO_ADDR
// un := CreateVehicle ;
6682: LD_ADDR_VAR 0 5
6686: PUSH
6687: CALL_OW 45
6691: ST_TO_ADDR
// case area of east_arr :
6692: LD_VAR 0 1
6696: PUSH
6697: LD_INT 18
6699: DOUBLE
6700: EQUAL
6701: IFTRUE 6705
6703: GO 6720
6705: POP
// SetDir ( un , 4 ) ; south_arr :
6706: LD_VAR 0 5
6710: PPUSH
6711: LD_INT 4
6713: PPUSH
6714: CALL_OW 233
6718: GO 6744
6720: LD_INT 19
6722: DOUBLE
6723: EQUAL
6724: IFTRUE 6728
6726: GO 6743
6728: POP
// SetDir ( un , 5 ) ; end ;
6729: LD_VAR 0 5
6733: PPUSH
6734: LD_INT 5
6736: PPUSH
6737: CALL_OW 233
6741: GO 6744
6743: POP
// PlaceUnitArea ( un , area , false ) ;
6744: LD_VAR 0 5
6748: PPUSH
6749: LD_VAR 0 1
6753: PPUSH
6754: LD_INT 0
6756: PPUSH
6757: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6761: CALL_OW 44
6765: PPUSH
6766: LD_VAR 0 5
6770: PPUSH
6771: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6775: LD_VAR 0 5
6779: PPUSH
6780: LD_INT 1
6782: PPUSH
6783: LD_INT 100
6785: PPUSH
6786: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6790: LD_VAR 0 5
6794: PPUSH
6795: LD_INT 106
6797: PPUSH
6798: LD_INT 88
6800: PPUSH
6801: CALL_OW 111
// AddComUnload ( un ) ;
6805: LD_VAR 0 5
6809: PPUSH
6810: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6814: LD_VAR 0 5
6818: PPUSH
6819: LD_VAR 0 1
6823: PPUSH
6824: CALL_OW 173
// Wait ( 0 0$02 ) ;
6828: LD_INT 70
6830: PPUSH
6831: CALL_OW 67
// end ;
6835: GO 6610
6837: POP
6838: POP
// Wait ( 0 0$05 ) ;
6839: LD_INT 175
6841: PPUSH
6842: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6846: LD_INT 6
6848: PPUSH
6849: LD_INT 34
6851: PUSH
6852: LD_INT 51
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: PPUSH
6859: CALL 11546 0 2
6863: IFFALSE 7051
// begin wait ( 0 0$01 ) ;
6865: LD_INT 35
6867: PPUSH
6868: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6872: LD_ADDR_VAR 0 4
6876: PUSH
6877: LD_INT 6
6879: PPUSH
6880: LD_INT 34
6882: PUSH
6883: LD_INT 51
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PPUSH
6890: CALL 11546 0 2
6894: PUSH
6895: FOR_IN
6896: IFFALSE 7047
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6898: LD_VAR 0 4
6902: PPUSH
6903: LD_INT 9
6905: PPUSH
6906: CALL_OW 308
6910: PUSH
6911: LD_VAR 0 4
6915: PPUSH
6916: CALL 31654 0 1
6920: PPUSH
6921: CALL_OW 258
6925: PUSH
6926: LD_INT 1
6928: EQUAL
6929: AND
6930: PUSH
6931: LD_EXP 9
6935: AND
6936: IFFALSE 6963
// begin Say ( GetDriver ( i ) , Dtran ) ;
6938: LD_VAR 0 4
6942: PPUSH
6943: CALL 31654 0 1
6947: PPUSH
6948: LD_STRING Dtran
6950: PPUSH
6951: CALL_OW 88
// dialog_trans := false ;
6955: LD_ADDR_EXP 9
6959: PUSH
6960: LD_INT 0
6962: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6963: LD_VAR 0 4
6967: PPUSH
6968: CALL_OW 316
6972: IFFALSE 6988
// ComMoveToArea ( i , area ) ;
6974: LD_VAR 0 4
6978: PPUSH
6979: LD_VAR 0 1
6983: PPUSH
6984: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6988: LD_VAR 0 4
6992: PPUSH
6993: LD_VAR 0 1
6997: PPUSH
6998: CALL_OW 308
7002: PUSH
7003: LD_VAR 0 4
7007: PPUSH
7008: LD_INT 1
7010: PPUSH
7011: CALL_OW 289
7015: PUSH
7016: LD_INT 0
7018: EQUAL
7019: AND
7020: IFFALSE 7045
// begin RemoveUnit ( GetDriver ( i ) ) ;
7022: LD_VAR 0 4
7026: PPUSH
7027: CALL 31654 0 1
7031: PPUSH
7032: CALL_OW 64
// RemoveUnit ( i ) ;
7036: LD_VAR 0 4
7040: PPUSH
7041: CALL_OW 64
// end ; end ;
7045: GO 6895
7047: POP
7048: POP
// end ;
7049: GO 6846
// end ;
7051: LD_VAR 0 3
7055: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7056: LD_INT 0
7058: PPUSH
7059: PPUSH
7060: PPUSH
7061: PPUSH
// if isTest then
7062: LD_EXP 1
7066: IFFALSE 7070
// exit ;
7068: GO 7459
// for i = 1 to n do
7070: LD_ADDR_VAR 0 4
7074: PUSH
7075: DOUBLE
7076: LD_INT 1
7078: DEC
7079: ST_TO_ADDR
7080: LD_VAR 0 2
7084: PUSH
7085: FOR_TO
7086: IFFALSE 7318
// begin uc_side := 8 ;
7088: LD_ADDR_OWVAR 20
7092: PUSH
7093: LD_INT 8
7095: ST_TO_ADDR
// uc_nation := 1 ;
7096: LD_ADDR_OWVAR 21
7100: PUSH
7101: LD_INT 1
7103: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7104: LD_ADDR_VAR 0 6
7108: PUSH
7109: LD_INT 3
7111: PUSH
7112: LD_INT 4
7114: PUSH
7115: LD_INT 4
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 1
7125: PPUSH
7126: LD_OWVAR 67
7130: PPUSH
7131: CALL_OW 12
7135: ARRAY
7136: ST_TO_ADDR
// vc_chassis := ch ;
7137: LD_ADDR_OWVAR 37
7141: PUSH
7142: LD_VAR 0 6
7146: ST_TO_ADDR
// vc_control := control_computer ;
7147: LD_ADDR_OWVAR 38
7151: PUSH
7152: LD_INT 3
7154: ST_TO_ADDR
// vc_engine := engine_combustion ;
7155: LD_ADDR_OWVAR 39
7159: PUSH
7160: LD_INT 1
7162: ST_TO_ADDR
// if ch = us_medium_tracked then
7163: LD_VAR 0 6
7167: PUSH
7168: LD_INT 3
7170: EQUAL
7171: IFFALSE 7218
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7173: LD_ADDR_OWVAR 40
7177: PUSH
7178: LD_INT 3
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: LD_INT 5
7186: PUSH
7187: LD_INT 7
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_OWVAR 67
7200: PPUSH
7201: LD_OWVAR 67
7205: PUSH
7206: LD_INT 1
7208: PLUS
7209: PPUSH
7210: CALL_OW 12
7214: ARRAY
7215: ST_TO_ADDR
7216: GO 7259
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7218: LD_ADDR_OWVAR 40
7222: PUSH
7223: LD_INT 5
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 7
7231: PUSH
7232: LD_INT 7
7234: PUSH
7235: EMPTY
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 1
7243: PPUSH
7244: LD_OWVAR 67
7248: PUSH
7249: LD_INT 1
7251: PLUS
7252: PPUSH
7253: CALL_OW 12
7257: ARRAY
7258: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7259: LD_ADDR_OWVAR 41
7263: PUSH
7264: LD_INT 70
7266: ST_TO_ADDR
// un := CreateVehicle ;
7267: LD_ADDR_VAR 0 5
7271: PUSH
7272: CALL_OW 45
7276: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7277: LD_VAR 0 5
7281: PPUSH
7282: LD_VAR 0 1
7286: PPUSH
7287: LD_INT 0
7289: PPUSH
7290: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7294: LD_VAR 0 5
7298: PPUSH
7299: LD_INT 65
7301: PPUSH
7302: LD_INT 9
7304: PPUSH
7305: CALL_OW 111
// Wait ( 0 0$02 ) ;
7309: LD_INT 70
7311: PPUSH
7312: CALL_OW 67
// end ;
7316: GO 7085
7318: POP
7319: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7320: LD_INT 90
7322: PUSH
7323: LD_INT 80
7325: PUSH
7326: LD_INT 70
7328: PUSH
7329: EMPTY
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_OWVAR 67
7338: ARRAY
7339: PPUSH
7340: CALL_OW 13
7344: IFFALSE 7451
// begin uc_side := 8 ;
7346: LD_ADDR_OWVAR 20
7350: PUSH
7351: LD_INT 8
7353: ST_TO_ADDR
// uc_nation := 1 ;
7354: LD_ADDR_OWVAR 21
7358: PUSH
7359: LD_INT 1
7361: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7362: LD_ADDR_OWVAR 37
7366: PUSH
7367: LD_INT 4
7369: ST_TO_ADDR
// vc_control := control_computer ;
7370: LD_ADDR_OWVAR 38
7374: PUSH
7375: LD_INT 3
7377: ST_TO_ADDR
// vc_engine := engine_combustion ;
7378: LD_ADDR_OWVAR 39
7382: PUSH
7383: LD_INT 1
7385: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7386: LD_ADDR_OWVAR 40
7390: PUSH
7391: LD_INT 14
7393: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7394: LD_ADDR_OWVAR 41
7398: PUSH
7399: LD_INT 70
7401: ST_TO_ADDR
// un := CreateVehicle ;
7402: LD_ADDR_VAR 0 5
7406: PUSH
7407: CALL_OW 45
7411: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7412: LD_VAR 0 5
7416: PPUSH
7417: LD_VAR 0 1
7421: PPUSH
7422: LD_INT 0
7424: PPUSH
7425: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7429: LD_VAR 0 5
7433: PPUSH
7434: LD_INT 65
7436: PPUSH
7437: LD_INT 9
7439: PPUSH
7440: CALL_OW 111
// Wait ( 0 0$02 ) ;
7444: LD_INT 70
7446: PPUSH
7447: CALL_OW 67
// end ; alfa_support := true ;
7451: LD_ADDR_EXP 13
7455: PUSH
7456: LD_INT 1
7458: ST_TO_ADDR
// end ;
7459: LD_VAR 0 3
7463: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7464: LD_OWVAR 1
7468: PUSH
7469: LD_INT 21000
7471: PUSH
7472: LD_INT 18900
7474: PUSH
7475: LD_INT 16800
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: LIST
7482: PUSH
7483: LD_OWVAR 67
7487: ARRAY
7488: GREATER
7489: IFFALSE 7589
7491: GO 7493
7493: DISABLE
// begin repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7494: LD_INT 1050
7496: PPUSH
7497: LD_INT 4200
7499: PPUSH
7500: CALL_OW 12
7504: PPUSH
7505: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7509: LD_INT 20
7511: PPUSH
7512: LD_INT 5
7514: PUSH
7515: LD_INT 6
7517: PUSH
7518: LD_INT 8
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: LIST
7525: PUSH
7526: LD_OWVAR 67
7530: ARRAY
7531: PPUSH
7532: CALL 7056 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7536: LD_INT 22
7538: PUSH
7539: LD_INT 8
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PPUSH
7546: CALL_OW 69
7550: IFFALSE 7564
// SayRadio ( Popov , DR5 ) ;
7552: LD_EXP 24
7556: PPUSH
7557: LD_STRING DR5
7559: PPUSH
7560: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7564: LD_INT 8400
7566: PPUSH
7567: LD_INT 12600
7569: PPUSH
7570: CALL_OW 12
7574: PPUSH
7575: CALL_OW 67
// until tick >= 120 120$00 ;
7579: LD_OWVAR 1
7583: PUSH
7584: LD_INT 252000
7586: GREATEREQUAL
7587: IFFALSE 7494
// end ; end_of_file
7589: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7590: LD_INT 0
7592: PPUSH
// enable_addtolog := isTest ;
7593: LD_ADDR_OWVAR 81
7597: PUSH
7598: LD_EXP 1
7602: ST_TO_ADDR
// lines_break_limit := 5 ;
7603: LD_ADDR_EXP 26
7607: PUSH
7608: LD_INT 5
7610: ST_TO_ADDR
// lines_break_type := --- ;
7611: LD_ADDR_EXP 27
7615: PUSH
7616: LD_STRING ---
7618: ST_TO_ADDR
// lines_counter := 0 ;
7619: LD_ADDR_EXP 25
7623: PUSH
7624: LD_INT 0
7626: ST_TO_ADDR
// show_line_index := true ;
7627: LD_ADDR_EXP 28
7631: PUSH
7632: LD_INT 1
7634: ST_TO_ADDR
// tick_log := true ;
7635: LD_ADDR_EXP 29
7639: PUSH
7640: LD_INT 1
7642: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7643: LD_STRING ----------SAND OF SIBERIA LOG----------
7645: PPUSH
7646: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7650: LD_STRING Map Name: 
7652: PUSH
7653: LD_OWVAR 68
7657: STR
7658: PPUSH
7659: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7663: LD_STRING Map Number: 
7665: PUSH
7666: LD_OWVAR 70
7670: STR
7671: PPUSH
7672: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7676: LD_STRING Difficulty: 
7678: PUSH
7679: LD_OWVAR 67
7683: STR
7684: PPUSH
7685: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7689: LD_STRING ---------------------------------------
7691: PPUSH
7692: CALL_OW 561
// end ;
7696: LD_VAR 0 1
7700: RET
// function Log ( text ) ; begin
7701: LD_INT 0
7703: PPUSH
// if show_line_index then
7704: LD_EXP 28
7708: IFFALSE 7720
// result := lines_counter ;
7710: LD_ADDR_VAR 0 2
7714: PUSH
7715: LD_EXP 25
7719: ST_TO_ADDR
// if tick_log then
7720: LD_EXP 29
7724: IFFALSE 7750
// result := result &  T:  & tick &   ;
7726: LD_ADDR_VAR 0 2
7730: PUSH
7731: LD_VAR 0 2
7735: PUSH
7736: LD_STRING  T: 
7738: STR
7739: PUSH
7740: LD_OWVAR 1
7744: STR
7745: PUSH
7746: LD_STRING  
7748: STR
7749: ST_TO_ADDR
// AddToLog ( result & text ) ;
7750: LD_VAR 0 2
7754: PUSH
7755: LD_VAR 0 1
7759: STR
7760: PPUSH
7761: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7765: LD_ADDR_EXP 25
7769: PUSH
7770: LD_EXP 25
7774: PUSH
7775: LD_INT 1
7777: PLUS
7778: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7779: LD_EXP 25
7783: PUSH
7784: LD_EXP 26
7788: MOD
7789: PUSH
7790: LD_INT 0
7792: EQUAL
7793: IFFALSE 7804
// AddToLog ( lines_break_type ) ;
7795: LD_EXP 27
7799: PPUSH
7800: CALL_OW 561
// end ;
7804: LD_VAR 0 2
7808: RET
// export function LogHuman ( id ) ; begin
7809: LD_INT 0
7811: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7812: LD_STRING Human Created. id: 
7814: PUSH
7815: LD_VAR 0 1
7819: STR
7820: PUSH
7821: LD_STRING ; side: 
7823: STR
7824: PUSH
7825: LD_VAR 0 1
7829: PPUSH
7830: CALL_OW 255
7834: STR
7835: PUSH
7836: LD_STRING ; class: 
7838: STR
7839: PUSH
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 257
7849: STR
7850: PUSH
7851: LD_STRING ; 
7853: STR
7854: PPUSH
7855: CALL 7701 0 1
// end ;
7859: LD_VAR 0 2
7863: RET
// export function LogVeh ( id ) ; begin
7864: LD_INT 0
7866: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7867: LD_STRING Vehicle Created. id: 
7869: PUSH
7870: LD_VAR 0 1
7874: STR
7875: PUSH
7876: LD_STRING ; side: 
7878: STR
7879: PUSH
7880: LD_VAR 0 1
7884: PPUSH
7885: CALL_OW 255
7889: STR
7890: PUSH
7891: LD_STRING ; nation: 
7893: STR
7894: PUSH
7895: LD_VAR 0 1
7899: PPUSH
7900: CALL_OW 248
7904: STR
7905: PUSH
7906: LD_STRING ; weapon: 
7908: STR
7909: PUSH
7910: LD_VAR 0 1
7914: PPUSH
7915: CALL_OW 264
7919: STR
7920: PUSH
7921: LD_STRING ; 
7923: STR
7924: PPUSH
7925: CALL 7701 0 1
// end ;
7929: LD_VAR 0 2
7933: RET
// export function LogEvent ( event ) ; begin
7934: LD_INT 0
7936: PPUSH
// Log ( Event Executed. id:  & event ) ;
7937: LD_STRING Event Executed. id: 
7939: PUSH
7940: LD_VAR 0 1
7944: STR
7945: PPUSH
7946: CALL 7701 0 1
// end ; end_of_file
7950: LD_VAR 0 2
7954: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7955: LD_INT 0
7957: PPUSH
7958: PPUSH
7959: PPUSH
7960: PPUSH
7961: PPUSH
7962: PPUSH
7963: PPUSH
7964: PPUSH
// if unit then
7965: LD_VAR 0 1
7969: IFFALSE 8369
// begin if mode = 0 then
7971: LD_VAR 0 3
7975: PUSH
7976: LD_INT 0
7978: EQUAL
7979: IFFALSE 8127
// begin if coords then
7981: LD_VAR 0 2
7985: IFFALSE 8125
// while ( coords > 1 ) do
7987: LD_VAR 0 2
7991: PUSH
7992: LD_INT 1
7994: GREATER
7995: IFFALSE 8125
// if not HasTask ( unit ) then
7997: LD_VAR 0 1
8001: PPUSH
8002: CALL_OW 314
8006: NOT
8007: IFFALSE 8123
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_VAR 0 2
8018: PUSH
8019: LD_INT 1
8021: ARRAY
8022: PPUSH
8023: LD_VAR 0 2
8027: PUSH
8028: LD_INT 2
8030: ARRAY
8031: PPUSH
8032: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8036: LD_INT 35
8038: PPUSH
8039: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8043: LD_VAR 0 1
8047: PPUSH
8048: CALL_OW 250
8052: PUSH
8053: LD_VAR 0 2
8057: PUSH
8058: LD_INT 1
8060: ARRAY
8061: EQUAL
8062: PUSH
8063: LD_VAR 0 1
8067: PPUSH
8068: CALL_OW 251
8072: PUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: EQUAL
8082: AND
8083: IFFALSE 8036
// for i = 1 to 2 do
8085: LD_ADDR_VAR 0 5
8089: PUSH
8090: DOUBLE
8091: LD_INT 1
8093: DEC
8094: ST_TO_ADDR
8095: LD_INT 2
8097: PUSH
8098: FOR_TO
8099: IFFALSE 8121
// coords := Delete ( coords , 1 ) ;
8101: LD_ADDR_VAR 0 2
8105: PUSH
8106: LD_VAR 0 2
8110: PPUSH
8111: LD_INT 1
8113: PPUSH
8114: CALL_OW 3
8118: ST_TO_ADDR
8119: GO 8098
8121: POP
8122: POP
// end ;
8123: GO 7987
// end else
8125: GO 8369
// begin if coords then
8127: LD_VAR 0 2
8131: IFFALSE 8369
// begin x := GetX ( unit ) ;
8133: LD_ADDR_VAR 0 6
8137: PUSH
8138: LD_VAR 0 1
8142: PPUSH
8143: CALL_OW 250
8147: ST_TO_ADDR
// y := GetY ( unit ) ;
8148: LD_ADDR_VAR 0 7
8152: PUSH
8153: LD_VAR 0 1
8157: PPUSH
8158: CALL_OW 251
8162: ST_TO_ADDR
// while ( coords > 1 ) do
8163: LD_VAR 0 2
8167: PUSH
8168: LD_INT 1
8170: GREATER
8171: IFFALSE 8369
// begin Wait ( 0 0$0.3 ) ;
8173: LD_INT 10
8175: PPUSH
8176: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8180: LD_VAR 0 1
8184: PPUSH
8185: CALL_OW 255
8189: PPUSH
8190: LD_VAR 0 1
8194: PPUSH
8195: CALL_OW 250
8199: PPUSH
8200: LD_VAR 0 1
8204: PPUSH
8205: CALL_OW 251
8209: PPUSH
8210: LD_INT 14
8212: PPUSH
8213: CALL 22716 0 4
8217: IFFALSE 8248
// begin ComMoveXY ( unit , x , y ) ;
8219: LD_VAR 0 1
8223: PPUSH
8224: LD_VAR 0 6
8228: PPUSH
8229: LD_VAR 0 7
8233: PPUSH
8234: CALL_OW 111
// result := false ;
8238: LD_ADDR_VAR 0 4
8242: PUSH
8243: LD_INT 0
8245: ST_TO_ADDR
// end else
8246: GO 8287
// if not HasTask ( unit ) then
8248: LD_VAR 0 1
8252: PPUSH
8253: CALL_OW 314
8257: NOT
8258: IFFALSE 8287
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: LD_VAR 0 2
8269: PUSH
8270: LD_INT 1
8272: ARRAY
8273: PPUSH
8274: LD_VAR 0 2
8278: PUSH
8279: LD_INT 2
8281: ARRAY
8282: PPUSH
8283: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8287: LD_VAR 0 1
8291: PPUSH
8292: CALL_OW 250
8296: PUSH
8297: LD_VAR 0 2
8301: PUSH
8302: LD_INT 1
8304: ARRAY
8305: EQUAL
8306: PUSH
8307: LD_VAR 0 1
8311: PPUSH
8312: CALL_OW 251
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 2
8324: ARRAY
8325: EQUAL
8326: AND
8327: IFFALSE 8367
// for i = 1 to 2 do
8329: LD_ADDR_VAR 0 5
8333: PUSH
8334: DOUBLE
8335: LD_INT 1
8337: DEC
8338: ST_TO_ADDR
8339: LD_INT 2
8341: PUSH
8342: FOR_TO
8343: IFFALSE 8365
// coords := Delete ( coords , 1 ) ;
8345: LD_ADDR_VAR 0 2
8349: PUSH
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_INT 1
8357: PPUSH
8358: CALL_OW 3
8362: ST_TO_ADDR
8363: GO 8342
8365: POP
8366: POP
// end ;
8367: GO 8163
// end ; end ; end ; result := true ;
8369: LD_ADDR_VAR 0 4
8373: PUSH
8374: LD_INT 1
8376: ST_TO_ADDR
// end ;
8377: LD_VAR 0 4
8381: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8382: LD_INT 0
8384: PPUSH
8385: PPUSH
8386: PPUSH
// if not units then
8387: LD_VAR 0 2
8391: NOT
8392: IFFALSE 8396
// exit ;
8394: GO 8459
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8396: LD_ADDR_VAR 0 5
8400: PUSH
8401: LD_INT 81
8403: PUSH
8404: LD_VAR 0 1
8408: PUSH
8409: EMPTY
8410: LIST
8411: LIST
8412: PPUSH
8413: CALL_OW 69
8417: ST_TO_ADDR
// for i in units do
8418: LD_ADDR_VAR 0 4
8422: PUSH
8423: LD_VAR 0 2
8427: PUSH
8428: FOR_IN
8429: IFFALSE 8457
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8431: LD_VAR 0 4
8435: PPUSH
8436: LD_VAR 0 5
8440: PPUSH
8441: LD_VAR 0 4
8445: PPUSH
8446: CALL_OW 74
8450: PPUSH
8451: CALL_OW 115
// end ;
8455: GO 8428
8457: POP
8458: POP
// end ;
8459: LD_VAR 0 3
8463: RET
// export function MC_Show ( string ) ; begin
8464: LD_INT 0
8466: PPUSH
// display_strings := string ;
8467: LD_ADDR_OWVAR 47
8471: PUSH
8472: LD_VAR 0 1
8476: ST_TO_ADDR
// end ; end_of_file
8477: LD_VAR 0 2
8481: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8482: LD_INT 0
8484: PPUSH
8485: PPUSH
8486: PPUSH
8487: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8488: LD_ADDR_VAR 0 8
8492: PUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: LD_INT 2
8500: PPUSH
8501: EMPTY
8502: PPUSH
8503: CALL 11629 0 3
8507: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8508: LD_VAR 0 8
8512: PUSH
8513: LD_VAR 0 2
8517: PPUSH
8518: LD_VAR 0 3
8522: PPUSH
8523: CALL_OW 428
8527: PUSH
8528: LD_INT 0
8530: EQUAL
8531: AND
8532: IFFALSE 8606
// for i = 1 to plist do
8534: LD_ADDR_VAR 0 6
8538: PUSH
8539: DOUBLE
8540: LD_INT 1
8542: DEC
8543: ST_TO_ADDR
8544: LD_VAR 0 8
8548: PUSH
8549: FOR_TO
8550: IFFALSE 8604
// if NotTask ( plist [ i ] ) then
8552: LD_VAR 0 8
8556: PUSH
8557: LD_VAR 0 6
8561: ARRAY
8562: PPUSH
8563: CALL 32117 0 1
8567: IFFALSE 8602
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8569: LD_VAR 0 8
8573: PUSH
8574: LD_VAR 0 6
8578: ARRAY
8579: PPUSH
8580: LD_INT 0
8582: PPUSH
8583: LD_VAR 0 2
8587: PPUSH
8588: LD_VAR 0 3
8592: PPUSH
8593: LD_VAR 0 4
8597: PPUSH
8598: CALL_OW 145
// end ;
8602: GO 8549
8604: POP
8605: POP
// end ;
8606: LD_VAR 0 5
8610: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8611: LD_INT 0
8613: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 6
8621: PPUSH
8622: LD_VAR 0 2
8626: PPUSH
8627: LD_VAR 0 3
8631: PPUSH
8632: LD_VAR 0 4
8636: PPUSH
8637: CALL 10115 0 5
// end ;
8641: LD_VAR 0 5
8645: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8646: LD_INT 0
8648: PPUSH
8649: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8650: LD_ADDR_VAR 0 4
8654: PUSH
8655: LD_INT 22
8657: PUSH
8658: LD_VAR 0 1
8662: PUSH
8663: EMPTY
8664: LIST
8665: LIST
8666: PUSH
8667: LD_INT 2
8669: PUSH
8670: LD_INT 30
8672: PUSH
8673: LD_INT 0
8675: PUSH
8676: EMPTY
8677: LIST
8678: LIST
8679: PUSH
8680: LD_INT 30
8682: PUSH
8683: LD_INT 1
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: LIST
8694: PUSH
8695: EMPTY
8696: LIST
8697: LIST
8698: PUSH
8699: EMPTY
8700: LIST
8701: PPUSH
8702: CALL_OW 69
8706: PPUSH
8707: LD_VAR 0 2
8711: PPUSH
8712: CALL_OW 250
8716: PPUSH
8717: LD_VAR 0 2
8721: PPUSH
8722: CALL_OW 251
8726: PPUSH
8727: CALL_OW 73
8731: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8732: LD_VAR 0 4
8736: PPUSH
8737: LD_VAR 0 2
8741: PPUSH
8742: CALL 10404 0 2
8746: IFFALSE 8805
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8748: LD_VAR 0 1
8752: PPUSH
8753: LD_INT 30
8755: PUSH
8756: LD_VAR 0 2
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: PPUSH
8765: CALL 11546 0 2
8769: PUSH
8770: LD_INT 1
8772: ARRAY
8773: PPUSH
8774: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8778: LD_ADDR_EXP 48
8782: PUSH
8783: LD_EXP 48
8787: PPUSH
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_VAR 0 2
8797: PPUSH
8798: EMPTY
8799: PPUSH
8800: CALL 41932 0 4
8804: ST_TO_ADDR
// end ; end ;
8805: LD_VAR 0 3
8809: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8810: LD_INT 0
8812: PPUSH
8813: PPUSH
8814: PPUSH
8815: PPUSH
8816: PPUSH
8817: PPUSH
// result := false ;
8818: LD_ADDR_VAR 0 4
8822: PUSH
8823: LD_INT 0
8825: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8826: LD_VAR 0 1
8830: PPUSH
8831: LD_EXP 40
8835: PPUSH
8836: CALL 42880 0 2
8840: IFFALSE 9053
// for i = 1 to MREG_LabList do
8842: LD_ADDR_VAR 0 5
8846: PUSH
8847: DOUBLE
8848: LD_INT 1
8850: DEC
8851: ST_TO_ADDR
8852: LD_EXP 40
8856: PUSH
8857: FOR_TO
8858: IFFALSE 9051
// begin if MREG_LabList [ i ] [ 1 ] = side then
8860: LD_EXP 40
8864: PUSH
8865: LD_VAR 0 5
8869: ARRAY
8870: PUSH
8871: LD_INT 1
8873: ARRAY
8874: PUSH
8875: LD_VAR 0 1
8879: EQUAL
8880: IFFALSE 9049
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8882: LD_ADDR_VAR 0 7
8886: PUSH
8887: LD_EXP 40
8891: PUSH
8892: LD_VAR 0 5
8896: ARRAY
8897: PUSH
8898: LD_INT 2
8900: ARRAY
8901: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8902: LD_ADDR_VAR 0 9
8906: PUSH
8907: LD_INT 22
8909: PUSH
8910: LD_VAR 0 1
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: LD_INT 2
8921: PUSH
8922: LD_INT 30
8924: PUSH
8925: LD_INT 0
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PUSH
8932: LD_INT 30
8934: PUSH
8935: LD_INT 1
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: LIST
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: PUSH
8951: EMPTY
8952: LIST
8953: PPUSH
8954: CALL_OW 69
8958: PPUSH
8959: LD_VAR 0 7
8963: PPUSH
8964: CALL_OW 250
8968: PPUSH
8969: LD_VAR 0 7
8973: PPUSH
8974: CALL_OW 251
8978: PPUSH
8979: CALL_OW 73
8983: ST_TO_ADDR
// if dep then
8984: LD_VAR 0 9
8988: IFFALSE 9047
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8990: LD_VAR 0 9
8994: PPUSH
8995: LD_VAR 0 2
8999: PPUSH
9000: LD_VAR 0 3
9004: PPUSH
9005: CALL 10520 0 3
9009: IFFALSE 9047
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9011: LD_VAR 0 7
9015: PPUSH
9016: LD_VAR 0 2
9020: PPUSH
9021: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9025: LD_VAR 0 7
9029: PPUSH
9030: LD_VAR 0 3
9034: PPUSH
9035: CALL_OW 207
// result := true ;
9039: LD_ADDR_VAR 0 4
9043: PUSH
9044: LD_INT 1
9046: ST_TO_ADDR
// end ; end ; break ;
9047: GO 9051
// end ; end ;
9049: GO 8857
9051: POP
9052: POP
// end ;
9053: LD_VAR 0 4
9057: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9058: LD_INT 0
9060: PPUSH
9061: PPUSH
9062: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9063: LD_ADDR_VAR 0 7
9067: PUSH
9068: LD_VAR 0 2
9072: PPUSH
9073: LD_VAR 0 3
9077: PPUSH
9078: LD_VAR 0 4
9082: PPUSH
9083: CALL 9245 0 3
9087: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9088: LD_ADDR_EXP 46
9092: PUSH
9093: LD_EXP 46
9097: PPUSH
9098: LD_VAR 0 1
9102: PPUSH
9103: LD_INT 2
9105: PPUSH
9106: LD_VAR 0 2
9110: PUSH
9111: LD_VAR 0 3
9115: PUSH
9116: LD_VAR 0 4
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: LIST
9125: PPUSH
9126: CALL 41841 0 4
9130: ST_TO_ADDR
// if ext_list then
9131: LD_VAR 0 5
9135: IFFALSE 9240
// for i = 1 to ext_list do
9137: LD_ADDR_VAR 0 8
9141: PUSH
9142: DOUBLE
9143: LD_INT 1
9145: DEC
9146: ST_TO_ADDR
9147: LD_VAR 0 5
9151: PUSH
9152: FOR_TO
9153: IFFALSE 9238
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9155: LD_ADDR_EXP 46
9159: PUSH
9160: LD_EXP 46
9164: PPUSH
9165: LD_VAR 0 1
9169: PPUSH
9170: LD_VAR 0 5
9174: PUSH
9175: LD_VAR 0 8
9179: ARRAY
9180: PPUSH
9181: LD_VAR 0 7
9185: PUSH
9186: LD_VAR 0 8
9190: ARRAY
9191: PUSH
9192: LD_INT 1
9194: ARRAY
9195: PUSH
9196: LD_VAR 0 7
9200: PUSH
9201: LD_VAR 0 8
9205: ARRAY
9206: PUSH
9207: LD_INT 2
9209: ARRAY
9210: PUSH
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PUSH
9222: LD_INT 3
9224: ARRAY
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41841 0 4
9235: ST_TO_ADDR
9236: GO 9152
9238: POP
9239: POP
// end ;
9240: LD_VAR 0 6
9244: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9245: LD_INT 0
9247: PPUSH
9248: PPUSH
// list := [ ] ;
9249: LD_ADDR_VAR 0 5
9253: PUSH
9254: EMPTY
9255: ST_TO_ADDR
// case d of 0 :
9256: LD_VAR 0 3
9260: PUSH
9261: LD_INT 0
9263: DOUBLE
9264: EQUAL
9265: IFTRUE 9269
9267: GO 9402
9269: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9270: LD_ADDR_VAR 0 5
9274: PUSH
9275: LD_VAR 0 1
9279: PUSH
9280: LD_INT 4
9282: MINUS
9283: PUSH
9284: LD_VAR 0 2
9288: PUSH
9289: LD_INT 4
9291: MINUS
9292: PUSH
9293: LD_INT 2
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: LIST
9300: PUSH
9301: LD_VAR 0 1
9305: PUSH
9306: LD_INT 3
9308: MINUS
9309: PUSH
9310: LD_VAR 0 2
9314: PUSH
9315: LD_INT 1
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: LIST
9322: PUSH
9323: LD_VAR 0 1
9327: PUSH
9328: LD_INT 4
9330: PLUS
9331: PUSH
9332: LD_VAR 0 2
9336: PUSH
9337: LD_INT 4
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: PUSH
9345: LD_VAR 0 1
9349: PUSH
9350: LD_INT 3
9352: PLUS
9353: PUSH
9354: LD_VAR 0 2
9358: PUSH
9359: LD_INT 3
9361: PLUS
9362: PUSH
9363: LD_INT 5
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: LIST
9370: PUSH
9371: LD_VAR 0 1
9375: PUSH
9376: LD_VAR 0 2
9380: PUSH
9381: LD_INT 4
9383: PLUS
9384: PUSH
9385: LD_INT 0
9387: PUSH
9388: EMPTY
9389: LIST
9390: LIST
9391: LIST
9392: PUSH
9393: EMPTY
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: ST_TO_ADDR
// end ; 1 :
9400: GO 10100
9402: LD_INT 1
9404: DOUBLE
9405: EQUAL
9406: IFTRUE 9410
9408: GO 9543
9410: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9411: LD_ADDR_VAR 0 5
9415: PUSH
9416: LD_VAR 0 1
9420: PUSH
9421: LD_VAR 0 2
9425: PUSH
9426: LD_INT 4
9428: MINUS
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: LIST
9437: PUSH
9438: LD_VAR 0 1
9442: PUSH
9443: LD_INT 3
9445: MINUS
9446: PUSH
9447: LD_VAR 0 2
9451: PUSH
9452: LD_INT 3
9454: MINUS
9455: PUSH
9456: LD_INT 2
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: LIST
9463: PUSH
9464: LD_VAR 0 1
9468: PUSH
9469: LD_INT 4
9471: MINUS
9472: PUSH
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 1
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_VAR 0 1
9490: PUSH
9491: LD_VAR 0 2
9495: PUSH
9496: LD_INT 3
9498: PLUS
9499: PUSH
9500: LD_INT 0
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: LIST
9507: PUSH
9508: LD_VAR 0 1
9512: PUSH
9513: LD_INT 4
9515: PLUS
9516: PUSH
9517: LD_VAR 0 2
9521: PUSH
9522: LD_INT 4
9524: PLUS
9525: PUSH
9526: LD_INT 5
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: LIST
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: LIST
9540: ST_TO_ADDR
// end ; 2 :
9541: GO 10100
9543: LD_INT 2
9545: DOUBLE
9546: EQUAL
9547: IFTRUE 9551
9549: GO 9680
9551: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9552: LD_ADDR_VAR 0 5
9556: PUSH
9557: LD_VAR 0 1
9561: PUSH
9562: LD_VAR 0 2
9566: PUSH
9567: LD_INT 3
9569: MINUS
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: PUSH
9579: LD_VAR 0 1
9583: PUSH
9584: LD_INT 4
9586: PLUS
9587: PUSH
9588: LD_VAR 0 2
9592: PUSH
9593: LD_INT 4
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: PUSH
9601: LD_VAR 0 1
9605: PUSH
9606: LD_VAR 0 2
9610: PUSH
9611: LD_INT 4
9613: PLUS
9614: PUSH
9615: LD_INT 0
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: LIST
9622: PUSH
9623: LD_VAR 0 1
9627: PUSH
9628: LD_INT 3
9630: MINUS
9631: PUSH
9632: LD_VAR 0 2
9636: PUSH
9637: LD_INT 1
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_VAR 0 1
9649: PUSH
9650: LD_INT 4
9652: MINUS
9653: PUSH
9654: LD_VAR 0 2
9658: PUSH
9659: LD_INT 4
9661: MINUS
9662: PUSH
9663: LD_INT 2
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// end ; 3 :
9678: GO 10100
9680: LD_INT 3
9682: DOUBLE
9683: EQUAL
9684: IFTRUE 9688
9686: GO 9821
9688: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9689: LD_ADDR_VAR 0 5
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: LD_INT 3
9701: PLUS
9702: PUSH
9703: LD_VAR 0 2
9707: PUSH
9708: LD_INT 4
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: LIST
9715: PUSH
9716: LD_VAR 0 1
9720: PUSH
9721: LD_INT 4
9723: PLUS
9724: PUSH
9725: LD_VAR 0 2
9729: PUSH
9730: LD_INT 4
9732: PLUS
9733: PUSH
9734: LD_INT 5
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: LD_VAR 0 1
9746: PUSH
9747: LD_INT 4
9749: MINUS
9750: PUSH
9751: LD_VAR 0 2
9755: PUSH
9756: LD_INT 1
9758: PUSH
9759: EMPTY
9760: LIST
9761: LIST
9762: LIST
9763: PUSH
9764: LD_VAR 0 1
9768: PUSH
9769: LD_VAR 0 2
9773: PUSH
9774: LD_INT 4
9776: MINUS
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: LIST
9785: PUSH
9786: LD_VAR 0 1
9790: PUSH
9791: LD_INT 3
9793: MINUS
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: LD_INT 3
9802: MINUS
9803: PUSH
9804: LD_INT 2
9806: PUSH
9807: EMPTY
9808: LIST
9809: LIST
9810: LIST
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: ST_TO_ADDR
// end ; 4 :
9819: GO 10100
9821: LD_INT 4
9823: DOUBLE
9824: EQUAL
9825: IFTRUE 9829
9827: GO 9962
9829: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9830: LD_ADDR_VAR 0 5
9834: PUSH
9835: LD_VAR 0 1
9839: PUSH
9840: LD_VAR 0 2
9844: PUSH
9845: LD_INT 4
9847: PLUS
9848: PUSH
9849: LD_INT 0
9851: PUSH
9852: EMPTY
9853: LIST
9854: LIST
9855: LIST
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 3
9864: PLUS
9865: PUSH
9866: LD_VAR 0 2
9870: PUSH
9871: LD_INT 3
9873: PLUS
9874: PUSH
9875: LD_INT 5
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: LIST
9882: PUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 3
9890: PLUS
9891: PUSH
9892: LD_VAR 0 2
9896: PUSH
9897: LD_INT 4
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_VAR 0 1
9909: PUSH
9910: LD_VAR 0 2
9914: PUSH
9915: LD_INT 3
9917: MINUS
9918: PUSH
9919: LD_INT 3
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: LIST
9926: PUSH
9927: LD_VAR 0 1
9931: PUSH
9932: LD_INT 4
9934: MINUS
9935: PUSH
9936: LD_VAR 0 2
9940: PUSH
9941: LD_INT 4
9943: MINUS
9944: PUSH
9945: LD_INT 2
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: LIST
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: ST_TO_ADDR
// end ; 5 :
9960: GO 10100
9962: LD_INT 5
9964: DOUBLE
9965: EQUAL
9966: IFTRUE 9970
9968: GO 10099
9970: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9971: LD_ADDR_VAR 0 5
9975: PUSH
9976: LD_VAR 0 1
9980: PUSH
9981: LD_INT 4
9983: MINUS
9984: PUSH
9985: LD_VAR 0 2
9989: PUSH
9990: LD_INT 1
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: LIST
9997: PUSH
9998: LD_VAR 0 1
10002: PUSH
10003: LD_VAR 0 2
10007: PUSH
10008: LD_INT 4
10010: MINUS
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: LIST
10019: PUSH
10020: LD_VAR 0 1
10024: PUSH
10025: LD_INT 4
10027: PLUS
10028: PUSH
10029: LD_VAR 0 2
10033: PUSH
10034: LD_INT 4
10036: PLUS
10037: PUSH
10038: LD_INT 5
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: LIST
10045: PUSH
10046: LD_VAR 0 1
10050: PUSH
10051: LD_INT 3
10053: PLUS
10054: PUSH
10055: LD_VAR 0 2
10059: PUSH
10060: LD_INT 4
10062: PUSH
10063: EMPTY
10064: LIST
10065: LIST
10066: LIST
10067: PUSH
10068: LD_VAR 0 1
10072: PUSH
10073: LD_VAR 0 2
10077: PUSH
10078: LD_INT 3
10080: PLUS
10081: PUSH
10082: LD_INT 0
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: LIST
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: ST_TO_ADDR
// end ; end ;
10097: GO 10100
10099: POP
// result := list ;
10100: LD_ADDR_VAR 0 4
10104: PUSH
10105: LD_VAR 0 5
10109: ST_TO_ADDR
// end ;
10110: LD_VAR 0 4
10114: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10115: LD_INT 0
10117: PPUSH
10118: PPUSH
10119: PPUSH
10120: PPUSH
10121: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10122: LD_ADDR_VAR 0 10
10126: PUSH
10127: LD_VAR 0 1
10131: PPUSH
10132: LD_INT 2
10134: PPUSH
10135: EMPTY
10136: PPUSH
10137: CALL 11629 0 3
10141: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10142: LD_ADDR_VAR 0 9
10146: PUSH
10147: LD_INT 22
10149: PUSH
10150: LD_VAR 0 1
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: PUSH
10159: LD_INT 2
10161: PUSH
10162: LD_INT 30
10164: PUSH
10165: LD_INT 0
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PUSH
10172: LD_INT 30
10174: PUSH
10175: LD_INT 1
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: PUSH
10182: EMPTY
10183: LIST
10184: LIST
10185: LIST
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: EMPTY
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: PPUSH
10199: LD_VAR 0 3
10203: PPUSH
10204: LD_VAR 0 4
10208: PPUSH
10209: CALL_OW 73
10213: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10214: LD_ADDR_VAR 0 8
10218: PUSH
10219: LD_VAR 0 9
10223: PPUSH
10224: LD_VAR 0 2
10228: PPUSH
10229: CALL 10404 0 2
10233: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10234: LD_VAR 0 10
10238: PUSH
10239: LD_VAR 0 8
10243: AND
10244: PUSH
10245: LD_VAR 0 9
10249: PPUSH
10250: LD_VAR 0 3
10254: PPUSH
10255: LD_VAR 0 4
10259: PPUSH
10260: CALL_OW 297
10264: PUSH
10265: LD_INT 26
10267: LESSEQUAL
10268: AND
10269: PUSH
10270: LD_VAR 0 3
10274: PPUSH
10275: LD_VAR 0 4
10279: PPUSH
10280: CALL_OW 428
10284: PUSH
10285: LD_INT 0
10287: EQUAL
10288: AND
10289: IFFALSE 10399
// for i = 1 to plist do
10291: LD_ADDR_VAR 0 7
10295: PUSH
10296: DOUBLE
10297: LD_INT 1
10299: DEC
10300: ST_TO_ADDR
10301: LD_VAR 0 10
10305: PUSH
10306: FOR_TO
10307: IFFALSE 10397
// if IsInUnit ( plist [ i ] ) then
10309: LD_VAR 0 10
10313: PUSH
10314: LD_VAR 0 7
10318: ARRAY
10319: PPUSH
10320: CALL_OW 310
10324: IFFALSE 10343
// ComExitBuilding ( plist [ i ] ) else
10326: LD_VAR 0 10
10330: PUSH
10331: LD_VAR 0 7
10335: ARRAY
10336: PPUSH
10337: CALL_OW 122
10341: GO 10395
// if NotTask ( plist [ i ] ) then
10343: LD_VAR 0 10
10347: PUSH
10348: LD_VAR 0 7
10352: ARRAY
10353: PPUSH
10354: CALL 32117 0 1
10358: IFFALSE 10395
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10360: LD_VAR 0 10
10364: PUSH
10365: LD_VAR 0 7
10369: ARRAY
10370: PPUSH
10371: LD_VAR 0 2
10375: PPUSH
10376: LD_VAR 0 3
10380: PPUSH
10381: LD_VAR 0 4
10385: PPUSH
10386: LD_VAR 0 5
10390: PPUSH
10391: CALL_OW 145
// end ;
10395: GO 10306
10397: POP
10398: POP
// end ;
10399: LD_VAR 0 6
10403: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10404: LD_INT 0
10406: PPUSH
10407: PPUSH
10408: PPUSH
// pom := GetBase ( bdepot ) ;
10409: LD_ADDR_VAR 0 4
10413: PUSH
10414: LD_VAR 0 1
10418: PPUSH
10419: CALL_OW 274
10423: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10424: LD_ADDR_VAR 0 5
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_VAR 0 1
10438: PPUSH
10439: CALL_OW 248
10443: PPUSH
10444: CALL_OW 450
10448: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10449: LD_VAR 0 4
10453: PPUSH
10454: LD_INT 1
10456: PPUSH
10457: CALL_OW 275
10461: PUSH
10462: LD_VAR 0 5
10466: PUSH
10467: LD_INT 1
10469: ARRAY
10470: GREATEREQUAL
10471: PUSH
10472: LD_VAR 0 4
10476: PPUSH
10477: LD_INT 3
10479: PPUSH
10480: CALL_OW 275
10484: PUSH
10485: LD_VAR 0 5
10489: PUSH
10490: LD_INT 3
10492: ARRAY
10493: GREATEREQUAL
10494: AND
10495: IFFALSE 10507
// result := true else
10497: LD_ADDR_VAR 0 3
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
10505: GO 10515
// result := false ;
10507: LD_ADDR_VAR 0 3
10511: PUSH
10512: LD_INT 0
10514: ST_TO_ADDR
// end ;
10515: LD_VAR 0 3
10519: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10520: LD_INT 0
10522: PPUSH
10523: PPUSH
10524: PPUSH
10525: PPUSH
10526: PPUSH
// pom := GetBase ( bdepot ) ;
10527: LD_ADDR_VAR 0 5
10531: PUSH
10532: LD_VAR 0 1
10536: PPUSH
10537: CALL_OW 274
10541: ST_TO_ADDR
// cost := [ ] ;
10542: LD_ADDR_VAR 0 8
10546: PUSH
10547: EMPTY
10548: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10549: LD_ADDR_VAR 0 6
10553: PUSH
10554: LD_VAR 0 2
10558: PPUSH
10559: LD_VAR 0 1
10563: PPUSH
10564: CALL_OW 248
10568: PPUSH
10569: CALL_OW 450
10573: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10574: LD_ADDR_VAR 0 7
10578: PUSH
10579: LD_VAR 0 3
10583: PPUSH
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL_OW 248
10593: PPUSH
10594: CALL_OW 450
10598: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10599: LD_ADDR_VAR 0 8
10603: PUSH
10604: LD_VAR 0 8
10608: PPUSH
10609: LD_INT 1
10611: PPUSH
10612: LD_VAR 0 6
10616: PUSH
10617: LD_INT 1
10619: ARRAY
10620: PUSH
10621: LD_VAR 0 7
10625: PUSH
10626: LD_INT 1
10628: ARRAY
10629: PLUS
10630: PPUSH
10631: CALL_OW 1
10635: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10636: LD_ADDR_VAR 0 8
10640: PUSH
10641: LD_VAR 0 8
10645: PPUSH
10646: LD_INT 2
10648: PPUSH
10649: LD_VAR 0 6
10653: PUSH
10654: LD_INT 2
10656: ARRAY
10657: PUSH
10658: LD_VAR 0 7
10662: PUSH
10663: LD_INT 2
10665: ARRAY
10666: PLUS
10667: PPUSH
10668: CALL_OW 1
10672: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10673: LD_ADDR_VAR 0 8
10677: PUSH
10678: LD_VAR 0 8
10682: PPUSH
10683: LD_INT 3
10685: PPUSH
10686: LD_VAR 0 6
10690: PUSH
10691: LD_INT 3
10693: ARRAY
10694: PUSH
10695: LD_VAR 0 7
10699: PUSH
10700: LD_INT 3
10702: ARRAY
10703: PLUS
10704: PPUSH
10705: CALL_OW 1
10709: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10710: LD_VAR 0 5
10714: PPUSH
10715: LD_INT 1
10717: PPUSH
10718: CALL_OW 275
10722: PUSH
10723: LD_VAR 0 8
10727: PUSH
10728: LD_INT 1
10730: ARRAY
10731: GREATEREQUAL
10732: PUSH
10733: LD_VAR 0 5
10737: PPUSH
10738: LD_INT 3
10740: PPUSH
10741: CALL_OW 275
10745: PUSH
10746: LD_VAR 0 8
10750: PUSH
10751: LD_INT 3
10753: ARRAY
10754: GREATEREQUAL
10755: AND
10756: IFFALSE 10768
// result := true else
10758: LD_ADDR_VAR 0 4
10762: PUSH
10763: LD_INT 1
10765: ST_TO_ADDR
10766: GO 10776
// result := false ;
10768: LD_ADDR_VAR 0 4
10772: PUSH
10773: LD_INT 0
10775: ST_TO_ADDR
// end ;
10776: LD_VAR 0 4
10780: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10781: LD_INT 0
10783: PPUSH
10784: PPUSH
10785: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10786: LD_ADDR_VAR 0 5
10790: PUSH
10791: LD_VAR 0 1
10795: PPUSH
10796: LD_INT 2
10798: PPUSH
10799: EMPTY
10800: PPUSH
10801: CALL 11629 0 3
10805: ST_TO_ADDR
// if unit and plist then
10806: LD_VAR 0 2
10810: PUSH
10811: LD_VAR 0 5
10815: AND
10816: IFFALSE 10877
// for i = 1 to plist do
10818: LD_ADDR_VAR 0 4
10822: PUSH
10823: DOUBLE
10824: LD_INT 1
10826: DEC
10827: ST_TO_ADDR
10828: LD_VAR 0 5
10832: PUSH
10833: FOR_TO
10834: IFFALSE 10875
// if NotTask ( plist [ i ] ) then
10836: LD_VAR 0 5
10840: PUSH
10841: LD_VAR 0 4
10845: ARRAY
10846: PPUSH
10847: CALL 32117 0 1
10851: IFFALSE 10873
// ComDismantle ( plist [ i ] , unit ) ;
10853: LD_VAR 0 5
10857: PUSH
10858: LD_VAR 0 4
10862: ARRAY
10863: PPUSH
10864: LD_VAR 0 2
10868: PPUSH
10869: CALL_OW 167
10873: GO 10833
10875: POP
10876: POP
// result := true ;
10877: LD_ADDR_VAR 0 3
10881: PUSH
10882: LD_INT 1
10884: ST_TO_ADDR
// end ;
10885: LD_VAR 0 3
10889: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10890: LD_INT 0
10892: PPUSH
10893: PPUSH
10894: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10895: LD_ADDR_VAR 0 5
10899: PUSH
10900: LD_VAR 0 1
10904: PPUSH
10905: LD_INT 2
10907: PPUSH
10908: EMPTY
10909: PPUSH
10910: CALL 11629 0 3
10914: ST_TO_ADDR
// if unit and plist then
10915: LD_VAR 0 2
10919: PUSH
10920: LD_VAR 0 5
10924: AND
10925: IFFALSE 10986
// for i = 1 to plist do
10927: LD_ADDR_VAR 0 4
10931: PUSH
10932: DOUBLE
10933: LD_INT 1
10935: DEC
10936: ST_TO_ADDR
10937: LD_VAR 0 5
10941: PUSH
10942: FOR_TO
10943: IFFALSE 10984
// if NotTask ( plist [ i ] ) then
10945: LD_VAR 0 5
10949: PUSH
10950: LD_VAR 0 4
10954: ARRAY
10955: PPUSH
10956: CALL 32117 0 1
10960: IFFALSE 10982
// ComComplete ( plist [ i ] , unit ) ;
10962: LD_VAR 0 5
10966: PUSH
10967: LD_VAR 0 4
10971: ARRAY
10972: PPUSH
10973: LD_VAR 0 2
10977: PPUSH
10978: CALL 68349 0 2
10982: GO 10942
10984: POP
10985: POP
// result := true ;
10986: LD_ADDR_VAR 0 3
10990: PUSH
10991: LD_INT 1
10993: ST_TO_ADDR
// end ;
10994: LD_VAR 0 3
10998: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10999: LD_INT 0
11001: PPUSH
11002: PPUSH
11003: PPUSH
11004: PPUSH
11005: PPUSH
11006: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11007: LD_ADDR_VAR 0 5
11011: PUSH
11012: LD_INT 22
11014: PUSH
11015: LD_VAR 0 1
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 21
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 3
11036: PUSH
11037: LD_INT 57
11039: PUSH
11040: EMPTY
11041: LIST
11042: PUSH
11043: EMPTY
11044: LIST
11045: LIST
11046: PUSH
11047: LD_INT 3
11049: PUSH
11050: LD_INT 24
11052: PUSH
11053: LD_INT 1000
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: PPUSH
11070: CALL_OW 69
11074: ST_TO_ADDR
// r := [ ] ;
11075: LD_ADDR_VAR 0 6
11079: PUSH
11080: EMPTY
11081: ST_TO_ADDR
// if not tmp then
11082: LD_VAR 0 5
11086: NOT
11087: IFFALSE 11093
// exit else
11089: GO 11281
11091: GO 11261
// begin r := [ tmp [ 1 ] ] ;
11093: LD_ADDR_VAR 0 6
11097: PUSH
11098: LD_VAR 0 5
11102: PUSH
11103: LD_INT 1
11105: ARRAY
11106: PUSH
11107: EMPTY
11108: LIST
11109: ST_TO_ADDR
// for i = 2 to tmp do
11110: LD_ADDR_VAR 0 3
11114: PUSH
11115: DOUBLE
11116: LD_INT 2
11118: DEC
11119: ST_TO_ADDR
11120: LD_VAR 0 5
11124: PUSH
11125: FOR_TO
11126: IFFALSE 11259
// begin m := false ;
11128: LD_ADDR_VAR 0 7
11132: PUSH
11133: LD_INT 0
11135: ST_TO_ADDR
// for j = 1 to r do
11136: LD_ADDR_VAR 0 4
11140: PUSH
11141: DOUBLE
11142: LD_INT 1
11144: DEC
11145: ST_TO_ADDR
11146: LD_VAR 0 6
11150: PUSH
11151: FOR_TO
11152: IFFALSE 11226
// if GetLives ( tmp [ i ] ) < r [ j ] then
11154: LD_VAR 0 5
11158: PUSH
11159: LD_VAR 0 3
11163: ARRAY
11164: PPUSH
11165: CALL_OW 256
11169: PUSH
11170: LD_VAR 0 6
11174: PUSH
11175: LD_VAR 0 4
11179: ARRAY
11180: LESS
11181: IFFALSE 11224
// begin r := Insert ( r , j , tmp [ i ] ) ;
11183: LD_ADDR_VAR 0 6
11187: PUSH
11188: LD_VAR 0 6
11192: PPUSH
11193: LD_VAR 0 4
11197: PPUSH
11198: LD_VAR 0 5
11202: PUSH
11203: LD_VAR 0 3
11207: ARRAY
11208: PPUSH
11209: CALL_OW 2
11213: ST_TO_ADDR
// m := true ;
11214: LD_ADDR_VAR 0 7
11218: PUSH
11219: LD_INT 1
11221: ST_TO_ADDR
// break ;
11222: GO 11226
// end ;
11224: GO 11151
11226: POP
11227: POP
// if not m then
11228: LD_VAR 0 7
11232: NOT
11233: IFFALSE 11257
// r := r ^ tmp [ i ] ;
11235: LD_ADDR_VAR 0 6
11239: PUSH
11240: LD_VAR 0 6
11244: PUSH
11245: LD_VAR 0 5
11249: PUSH
11250: LD_VAR 0 3
11254: ARRAY
11255: ADD
11256: ST_TO_ADDR
// end ;
11257: GO 11125
11259: POP
11260: POP
// end ; if r then
11261: LD_VAR 0 6
11265: IFFALSE 11279
// result := r else
11267: LD_ADDR_VAR 0 2
11271: PUSH
11272: LD_VAR 0 6
11276: ST_TO_ADDR
11277: GO 11281
// exit ;
11279: GO 11281
// end ;
11281: LD_VAR 0 2
11285: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11286: LD_INT 0
11288: PPUSH
11289: PPUSH
11290: PPUSH
11291: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11292: LD_ADDR_VAR 0 5
11296: PUSH
11297: LD_INT 22
11299: PUSH
11300: LD_VAR 0 1
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: LD_INT 2
11311: PUSH
11312: LD_INT 25
11314: PUSH
11315: LD_INT 2
11317: PUSH
11318: EMPTY
11319: LIST
11320: LIST
11321: PUSH
11322: LD_INT 25
11324: PUSH
11325: LD_INT 16
11327: PUSH
11328: EMPTY
11329: LIST
11330: LIST
11331: PUSH
11332: LD_INT 34
11334: PUSH
11335: LD_INT 13
11337: PUSH
11338: EMPTY
11339: LIST
11340: LIST
11341: PUSH
11342: LD_INT 34
11344: PUSH
11345: LD_INT 52
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: PUSH
11352: EMPTY
11353: LIST
11354: LIST
11355: LIST
11356: LIST
11357: LIST
11358: PUSH
11359: LD_INT 24
11361: PUSH
11362: LD_INT 650
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: LIST
11373: PPUSH
11374: CALL_OW 69
11378: ST_TO_ADDR
// p := 1 ;
11379: LD_ADDR_VAR 0 4
11383: PUSH
11384: LD_INT 1
11386: ST_TO_ADDR
// for i = 1 to repairs do
11387: LD_ADDR_VAR 0 3
11391: PUSH
11392: DOUBLE
11393: LD_INT 1
11395: DEC
11396: ST_TO_ADDR
11397: LD_VAR 0 5
11401: PUSH
11402: FOR_TO
11403: IFFALSE 11539
// begin if IsInUnit ( repairs [ i ] ) then
11405: LD_VAR 0 5
11409: PUSH
11410: LD_VAR 0 3
11414: ARRAY
11415: PPUSH
11416: CALL_OW 310
11420: IFFALSE 11439
// ComExitBuilding ( repairs [ i ] ) else
11422: LD_VAR 0 5
11426: PUSH
11427: LD_VAR 0 3
11431: ARRAY
11432: PPUSH
11433: CALL_OW 122
11437: GO 11537
// if not HasTask ( repairs [ i ] ) then
11439: LD_VAR 0 5
11443: PUSH
11444: LD_VAR 0 3
11448: ARRAY
11449: PPUSH
11450: CALL_OW 314
11454: NOT
11455: IFFALSE 11537
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11457: LD_VAR 0 5
11461: PUSH
11462: LD_VAR 0 3
11466: ARRAY
11467: PPUSH
11468: LD_EXP 47
11472: PUSH
11473: LD_VAR 0 1
11477: ARRAY
11478: PUSH
11479: LD_VAR 0 4
11483: ARRAY
11484: PPUSH
11485: CALL_OW 130
// if i mod 3 = 0 then
11489: LD_VAR 0 3
11493: PUSH
11494: LD_INT 3
11496: MOD
11497: PUSH
11498: LD_INT 0
11500: EQUAL
11501: IFFALSE 11517
// p := p + 1 ;
11503: LD_ADDR_VAR 0 4
11507: PUSH
11508: LD_VAR 0 4
11512: PUSH
11513: LD_INT 1
11515: PLUS
11516: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11517: LD_EXP 47
11521: PUSH
11522: LD_VAR 0 1
11526: ARRAY
11527: PUSH
11528: LD_VAR 0 4
11532: LESS
11533: IFFALSE 11537
// break ;
11535: GO 11539
// end ; end ;
11537: GO 11402
11539: POP
11540: POP
// end ; end_of_file
11541: LD_VAR 0 2
11545: RET
// export function MCF_Get ( side , filter ) ; begin
11546: LD_INT 0
11548: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11549: LD_ADDR_VAR 0 3
11553: PUSH
11554: LD_INT 22
11556: PUSH
11557: LD_VAR 0 1
11561: PUSH
11562: EMPTY
11563: LIST
11564: LIST
11565: PUSH
11566: LD_VAR 0 2
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: PPUSH
11575: CALL_OW 69
11579: ST_TO_ADDR
// end ;
11580: LD_VAR 0 3
11584: RET
// export function MCF_Lab ( side ) ; begin
11585: LD_INT 0
11587: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11588: LD_ADDR_VAR 0 2
11592: PUSH
11593: LD_INT 22
11595: PUSH
11596: LD_VAR 0 1
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: PUSH
11605: LD_INT 30
11607: PUSH
11608: LD_INT 8
11610: PUSH
11611: EMPTY
11612: LIST
11613: LIST
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PPUSH
11619: CALL_OW 69
11623: ST_TO_ADDR
// end ;
11624: LD_VAR 0 2
11628: RET
// export function MCF_Class ( side , class , filter ) ; begin
11629: LD_INT 0
11631: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11632: LD_ADDR_VAR 0 4
11636: PUSH
11637: LD_INT 22
11639: PUSH
11640: LD_VAR 0 1
11644: PUSH
11645: EMPTY
11646: LIST
11647: LIST
11648: PUSH
11649: LD_INT 25
11651: PUSH
11652: LD_VAR 0 2
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PUSH
11661: LD_VAR 0 3
11665: PUSH
11666: EMPTY
11667: LIST
11668: LIST
11669: LIST
11670: PPUSH
11671: CALL_OW 69
11675: ST_TO_ADDR
// end ;
11676: LD_VAR 0 4
11680: RET
// export function MCF_All ( side , filter ) ; begin
11681: LD_INT 0
11683: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11684: LD_ADDR_VAR 0 3
11688: PUSH
11689: LD_INT 22
11691: PUSH
11692: LD_VAR 0 1
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: LD_INT 2
11703: PUSH
11704: LD_INT 25
11706: PUSH
11707: LD_INT 1
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: LD_INT 25
11716: PUSH
11717: LD_INT 2
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: LD_INT 25
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 25
11736: PUSH
11737: LD_INT 4
11739: PUSH
11740: EMPTY
11741: LIST
11742: LIST
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: PUSH
11751: LD_VAR 0 2
11755: PUSH
11756: EMPTY
11757: LIST
11758: LIST
11759: LIST
11760: PPUSH
11761: CALL_OW 69
11765: ST_TO_ADDR
// end ;
11766: LD_VAR 0 3
11770: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11771: LD_INT 0
11773: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11774: LD_ADDR_VAR 0 4
11778: PUSH
11779: LD_INT 22
11781: PUSH
11782: LD_VAR 0 1
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: LD_INT 92
11793: PUSH
11794: LD_VAR 0 2
11798: PUSH
11799: LD_INT 1
11801: ARRAY
11802: PUSH
11803: LD_VAR 0 2
11807: PUSH
11808: LD_INT 2
11810: ARRAY
11811: PUSH
11812: LD_VAR 0 2
11816: PUSH
11817: LD_INT 3
11819: ARRAY
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: PUSH
11827: LD_VAR 0 3
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: LIST
11836: PPUSH
11837: CALL_OW 69
11841: ST_TO_ADDR
// end ;
11842: LD_VAR 0 4
11846: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11847: LD_INT 0
11849: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_INT 22
11857: PUSH
11858: LD_VAR 0 1
11862: PUSH
11863: EMPTY
11864: LIST
11865: LIST
11866: PUSH
11867: LD_INT 21
11869: PUSH
11870: LD_INT 2
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_VAR 0 2
11881: PUSH
11882: EMPTY
11883: LIST
11884: LIST
11885: LIST
11886: PPUSH
11887: CALL_OW 69
11891: ST_TO_ADDR
// end ;
11892: LD_VAR 0 3
11896: RET
// export function MCF_Cargo ( side ) ; begin
11897: LD_INT 0
11899: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11900: LD_ADDR_VAR 0 2
11904: PUSH
11905: LD_VAR 0 1
11909: PPUSH
11910: LD_INT 2
11912: PUSH
11913: LD_INT 34
11915: PUSH
11916: LD_INT 12
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PUSH
11923: LD_INT 34
11925: PUSH
11926: LD_INT 32
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PUSH
11933: LD_INT 34
11935: PUSH
11936: LD_INT 51
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: LIST
11947: LIST
11948: PPUSH
11949: CALL 11847 0 2
11953: ST_TO_ADDR
// end ;
11954: LD_VAR 0 2
11958: RET
// export function MCF_Ape ( side ) ; begin
11959: LD_INT 0
11961: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11962: LD_ADDR_VAR 0 2
11966: PUSH
11967: LD_INT 22
11969: PUSH
11970: LD_VAR 0 1
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PUSH
11979: LD_INT 2
11981: PUSH
11982: LD_INT 25
11984: PUSH
11985: LD_INT 12
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 25
11994: PUSH
11995: LD_INT 15
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: LD_INT 25
12004: PUSH
12005: LD_INT 16
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 25
12014: PUSH
12015: LD_INT 17
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: LIST
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PPUSH
12033: CALL_OW 69
12037: ST_TO_ADDR
// end ;
12038: LD_VAR 0 2
12042: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12043: LD_INT 0
12045: PPUSH
12046: PPUSH
12047: PPUSH
12048: PPUSH
// result := [ ] ;
12049: LD_ADDR_VAR 0 3
12053: PUSH
12054: EMPTY
12055: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12056: LD_ADDR_VAR 0 4
12060: PUSH
12061: LD_VAR 0 1
12065: PPUSH
12066: CALL 11959 0 1
12070: ST_TO_ADDR
// case type of 0 , normal :
12071: LD_VAR 0 2
12075: PUSH
12076: LD_INT 0
12078: DOUBLE
12079: EQUAL
12080: IFTRUE 12090
12082: LD_STRING normal
12084: DOUBLE
12085: EQUAL
12086: IFTRUE 12090
12088: GO 12101
12090: POP
// cl := class_apeman ; 1 , soldier :
12091: LD_ADDR_VAR 0 5
12095: PUSH
12096: LD_INT 12
12098: ST_TO_ADDR
12099: GO 12177
12101: LD_INT 1
12103: DOUBLE
12104: EQUAL
12105: IFTRUE 12115
12107: LD_STRING soldier
12109: DOUBLE
12110: EQUAL
12111: IFTRUE 12115
12113: GO 12126
12115: POP
// cl := class_apeman_soldier ; 2 , engineer :
12116: LD_ADDR_VAR 0 5
12120: PUSH
12121: LD_INT 15
12123: ST_TO_ADDR
12124: GO 12177
12126: LD_INT 2
12128: DOUBLE
12129: EQUAL
12130: IFTRUE 12140
12132: LD_STRING engineer
12134: DOUBLE
12135: EQUAL
12136: IFTRUE 12140
12138: GO 12151
12140: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12141: LD_ADDR_VAR 0 5
12145: PUSH
12146: LD_INT 16
12148: ST_TO_ADDR
12149: GO 12177
12151: LD_INT 3
12153: DOUBLE
12154: EQUAL
12155: IFTRUE 12165
12157: LD_STRING kamikaze
12159: DOUBLE
12160: EQUAL
12161: IFTRUE 12165
12163: GO 12176
12165: POP
// cl := class_apeman_kamikaze ; end ;
12166: LD_ADDR_VAR 0 5
12170: PUSH
12171: LD_INT 17
12173: ST_TO_ADDR
12174: GO 12177
12176: POP
// for i = 1 to tmp do
12177: LD_ADDR_VAR 0 6
12181: PUSH
12182: DOUBLE
12183: LD_INT 1
12185: DEC
12186: ST_TO_ADDR
12187: LD_VAR 0 4
12191: PUSH
12192: FOR_TO
12193: IFFALSE 12242
// if GetClass ( tmp [ i ] ) = cl then
12195: LD_VAR 0 4
12199: PUSH
12200: LD_VAR 0 6
12204: ARRAY
12205: PPUSH
12206: CALL_OW 257
12210: PUSH
12211: LD_VAR 0 5
12215: EQUAL
12216: IFFALSE 12240
// result := result ^ tmp [ i ] ;
12218: LD_ADDR_VAR 0 3
12222: PUSH
12223: LD_VAR 0 3
12227: PUSH
12228: LD_VAR 0 4
12232: PUSH
12233: LD_VAR 0 6
12237: ARRAY
12238: ADD
12239: ST_TO_ADDR
12240: GO 12192
12242: POP
12243: POP
// end ;
12244: LD_VAR 0 3
12248: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12249: LD_INT 0
12251: PPUSH
12252: PPUSH
12253: PPUSH
12254: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12255: LD_ADDR_VAR 0 5
12259: PUSH
12260: LD_INT 22
12262: PUSH
12263: LD_VAR 0 1
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PUSH
12272: LD_VAR 0 3
12276: PUSH
12277: EMPTY
12278: LIST
12279: LIST
12280: PPUSH
12281: CALL_OW 69
12285: ST_TO_ADDR
// r := [ ] ;
12286: LD_ADDR_VAR 0 6
12290: PUSH
12291: EMPTY
12292: ST_TO_ADDR
// if tmp then
12293: LD_VAR 0 5
12297: IFFALSE 12366
// for i = 1 to tmp do
12299: LD_ADDR_VAR 0 7
12303: PUSH
12304: DOUBLE
12305: LD_INT 1
12307: DEC
12308: ST_TO_ADDR
12309: LD_VAR 0 5
12313: PUSH
12314: FOR_TO
12315: IFFALSE 12364
// if GetTag ( tmp [ i ] ) = tag then
12317: LD_VAR 0 5
12321: PUSH
12322: LD_VAR 0 7
12326: ARRAY
12327: PPUSH
12328: CALL_OW 110
12332: PUSH
12333: LD_VAR 0 2
12337: EQUAL
12338: IFFALSE 12362
// r := r ^ tmp [ i ] ;
12340: LD_ADDR_VAR 0 6
12344: PUSH
12345: LD_VAR 0 6
12349: PUSH
12350: LD_VAR 0 5
12354: PUSH
12355: LD_VAR 0 7
12359: ARRAY
12360: ADD
12361: ST_TO_ADDR
12362: GO 12314
12364: POP
12365: POP
// result := r ;
12366: LD_ADDR_VAR 0 4
12370: PUSH
12371: LD_VAR 0 6
12375: ST_TO_ADDR
// end ;
12376: LD_VAR 0 4
12380: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12381: LD_INT 0
12383: PPUSH
12384: PPUSH
12385: PPUSH
// tmp := plist ;
12386: LD_ADDR_VAR 0 5
12390: PUSH
12391: LD_VAR 0 2
12395: ST_TO_ADDR
// if tmp then
12396: LD_VAR 0 5
12400: IFFALSE 12477
// begin for i = 1 to tmp do
12402: LD_ADDR_VAR 0 6
12406: PUSH
12407: DOUBLE
12408: LD_INT 1
12410: DEC
12411: ST_TO_ADDR
12412: LD_VAR 0 5
12416: PUSH
12417: FOR_TO
12418: IFFALSE 12465
// if GetTag ( tmp [ i ] ) <> tag then
12420: LD_VAR 0 5
12424: PUSH
12425: LD_VAR 0 6
12429: ARRAY
12430: PPUSH
12431: CALL_OW 110
12435: PUSH
12436: LD_VAR 0 3
12440: NONEQUAL
12441: IFFALSE 12463
// SetTag ( tmp [ i ] , tag ) ;
12443: LD_VAR 0 5
12447: PUSH
12448: LD_VAR 0 6
12452: ARRAY
12453: PPUSH
12454: LD_VAR 0 3
12458: PPUSH
12459: CALL_OW 109
12463: GO 12417
12465: POP
12466: POP
// result := true ;
12467: LD_ADDR_VAR 0 4
12471: PUSH
12472: LD_INT 1
12474: ST_TO_ADDR
// end else
12475: GO 12485
// result := false ;
12477: LD_ADDR_VAR 0 4
12481: PUSH
12482: LD_INT 0
12484: ST_TO_ADDR
// end ;
12485: LD_VAR 0 4
12489: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12490: LD_INT 0
12492: PPUSH
12493: PPUSH
12494: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12495: LD_ADDR_VAR 0 4
12499: PUSH
12500: LD_VAR 0 1
12504: PPUSH
12505: LD_VAR 0 2
12509: PPUSH
12510: EMPTY
12511: PPUSH
12512: CALL 12249 0 3
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 4
12521: IFFALSE 12573
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 5
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 4
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12561
// SetTag ( tmp [ i ] , 0 ) ;
12541: LD_VAR 0 4
12545: PUSH
12546: LD_VAR 0 5
12550: ARRAY
12551: PPUSH
12552: LD_INT 0
12554: PPUSH
12555: CALL_OW 109
12559: GO 12538
12561: POP
12562: POP
// result := true ;
12563: LD_ADDR_VAR 0 3
12567: PUSH
12568: LD_INT 1
12570: ST_TO_ADDR
// end else
12571: GO 12581
// result := false ;
12573: LD_ADDR_VAR 0 3
12577: PUSH
12578: LD_INT 0
12580: ST_TO_ADDR
// end ;
12581: LD_VAR 0 3
12585: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12586: LD_INT 0
12588: PPUSH
12589: PPUSH
12590: PPUSH
12591: PPUSH
12592: PPUSH
// sort_list := [ ] ;
12593: LD_ADDR_VAR 0 5
12597: PUSH
12598: EMPTY
12599: ST_TO_ADDR
// for i = 1 to list do
12600: LD_ADDR_VAR 0 3
12604: PUSH
12605: DOUBLE
12606: LD_INT 1
12608: DEC
12609: ST_TO_ADDR
12610: LD_VAR 0 1
12614: PUSH
12615: FOR_TO
12616: IFFALSE 12778
// begin if i = 1 then
12618: LD_VAR 0 3
12622: PUSH
12623: LD_INT 1
12625: EQUAL
12626: IFFALSE 12652
// sort_list := sort_list ^ list [ i ] else
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: LD_VAR 0 5
12637: PUSH
12638: LD_VAR 0 1
12642: PUSH
12643: LD_VAR 0 3
12647: ARRAY
12648: ADD
12649: ST_TO_ADDR
12650: GO 12776
// begin for j = 1 to sort_list do
12652: LD_ADDR_VAR 0 4
12656: PUSH
12657: DOUBLE
12658: LD_INT 1
12660: DEC
12661: ST_TO_ADDR
12662: LD_VAR 0 5
12666: PUSH
12667: FOR_TO
12668: IFFALSE 12745
// begin add := false ;
12670: LD_ADDR_VAR 0 6
12674: PUSH
12675: LD_INT 0
12677: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12678: LD_VAR 0 1
12682: PUSH
12683: LD_VAR 0 3
12687: ARRAY
12688: PUSH
12689: LD_VAR 0 5
12693: PUSH
12694: LD_VAR 0 4
12698: ARRAY
12699: LESS
12700: IFFALSE 12743
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12702: LD_ADDR_VAR 0 5
12706: PUSH
12707: LD_VAR 0 5
12711: PPUSH
12712: LD_VAR 0 4
12716: PPUSH
12717: LD_VAR 0 1
12721: PUSH
12722: LD_VAR 0 3
12726: ARRAY
12727: PPUSH
12728: CALL_OW 2
12732: ST_TO_ADDR
// add := true ;
12733: LD_ADDR_VAR 0 6
12737: PUSH
12738: LD_INT 1
12740: ST_TO_ADDR
// break ;
12741: GO 12745
// end ; end ;
12743: GO 12667
12745: POP
12746: POP
// if not add then
12747: LD_VAR 0 6
12751: NOT
12752: IFFALSE 12776
// sort_list := sort_list ^ list [ i ] ;
12754: LD_ADDR_VAR 0 5
12758: PUSH
12759: LD_VAR 0 5
12763: PUSH
12764: LD_VAR 0 1
12768: PUSH
12769: LD_VAR 0 3
12773: ARRAY
12774: ADD
12775: ST_TO_ADDR
// end ; end ;
12776: GO 12615
12778: POP
12779: POP
// result := sort_list ;
12780: LD_ADDR_VAR 0 2
12784: PUSH
12785: LD_VAR 0 5
12789: ST_TO_ADDR
// end ;
12790: LD_VAR 0 2
12794: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12795: LD_INT 0
12797: PPUSH
12798: PPUSH
12799: PPUSH
12800: PPUSH
12801: PPUSH
// sort_list := [ ] ;
12802: LD_ADDR_VAR 0 5
12806: PUSH
12807: EMPTY
12808: ST_TO_ADDR
// for i = 1 to list do
12809: LD_ADDR_VAR 0 3
12813: PUSH
12814: DOUBLE
12815: LD_INT 1
12817: DEC
12818: ST_TO_ADDR
12819: LD_VAR 0 1
12823: PUSH
12824: FOR_TO
12825: IFFALSE 12987
// begin if i = 1 then
12827: LD_VAR 0 3
12831: PUSH
12832: LD_INT 1
12834: EQUAL
12835: IFFALSE 12861
// sort_list := sort_list ^ list [ i ] else
12837: LD_ADDR_VAR 0 5
12841: PUSH
12842: LD_VAR 0 5
12846: PUSH
12847: LD_VAR 0 1
12851: PUSH
12852: LD_VAR 0 3
12856: ARRAY
12857: ADD
12858: ST_TO_ADDR
12859: GO 12985
// begin for j = 1 to sort_list do
12861: LD_ADDR_VAR 0 4
12865: PUSH
12866: DOUBLE
12867: LD_INT 1
12869: DEC
12870: ST_TO_ADDR
12871: LD_VAR 0 5
12875: PUSH
12876: FOR_TO
12877: IFFALSE 12954
// begin add := false ;
12879: LD_ADDR_VAR 0 6
12883: PUSH
12884: LD_INT 0
12886: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12887: LD_VAR 0 1
12891: PUSH
12892: LD_VAR 0 3
12896: ARRAY
12897: PUSH
12898: LD_VAR 0 5
12902: PUSH
12903: LD_VAR 0 4
12907: ARRAY
12908: GREATER
12909: IFFALSE 12952
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12911: LD_ADDR_VAR 0 5
12915: PUSH
12916: LD_VAR 0 5
12920: PPUSH
12921: LD_VAR 0 4
12925: PPUSH
12926: LD_VAR 0 1
12930: PUSH
12931: LD_VAR 0 3
12935: ARRAY
12936: PPUSH
12937: CALL_OW 2
12941: ST_TO_ADDR
// add := true ;
12942: LD_ADDR_VAR 0 6
12946: PUSH
12947: LD_INT 1
12949: ST_TO_ADDR
// break ;
12950: GO 12954
// end ; end ;
12952: GO 12876
12954: POP
12955: POP
// if not add then
12956: LD_VAR 0 6
12960: NOT
12961: IFFALSE 12985
// sort_list := sort_list ^ list [ i ] ;
12963: LD_ADDR_VAR 0 5
12967: PUSH
12968: LD_VAR 0 5
12972: PUSH
12973: LD_VAR 0 1
12977: PUSH
12978: LD_VAR 0 3
12982: ARRAY
12983: ADD
12984: ST_TO_ADDR
// end ; end ;
12985: GO 12824
12987: POP
12988: POP
// result := sort_list ;
12989: LD_ADDR_VAR 0 2
12993: PUSH
12994: LD_VAR 0 5
12998: ST_TO_ADDR
// end ;
12999: LD_VAR 0 2
13003: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13004: LD_INT 0
13006: PPUSH
13007: PPUSH
13008: PPUSH
13009: PPUSH
13010: PPUSH
13011: PPUSH
// tmp := [ ] ;
13012: LD_ADDR_VAR 0 8
13016: PUSH
13017: EMPTY
13018: ST_TO_ADDR
// r := [ ] ;
13019: LD_ADDR_VAR 0 7
13023: PUSH
13024: EMPTY
13025: ST_TO_ADDR
// add := false ;
13026: LD_ADDR_VAR 0 9
13030: PUSH
13031: LD_INT 0
13033: ST_TO_ADDR
// if plist then
13034: LD_VAR 0 2
13038: IFFALSE 13114
// begin for i = 1 to plist do
13040: LD_ADDR_VAR 0 5
13044: PUSH
13045: DOUBLE
13046: LD_INT 1
13048: DEC
13049: ST_TO_ADDR
13050: LD_VAR 0 2
13054: PUSH
13055: FOR_TO
13056: IFFALSE 13110
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13058: LD_ADDR_VAR 0 8
13062: PUSH
13063: LD_VAR 0 8
13067: PUSH
13068: LD_VAR 0 2
13072: PUSH
13073: LD_VAR 0 5
13077: ARRAY
13078: PUSH
13079: LD_VAR 0 2
13083: PUSH
13084: LD_VAR 0 5
13088: ARRAY
13089: PPUSH
13090: LD_VAR 0 3
13094: PPUSH
13095: CALL_OW 259
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: PUSH
13104: EMPTY
13105: LIST
13106: ADD
13107: ST_TO_ADDR
// end ;
13108: GO 13055
13110: POP
13111: POP
// end else
13112: GO 13122
// result := false ;
13114: LD_ADDR_VAR 0 4
13118: PUSH
13119: LD_INT 0
13121: ST_TO_ADDR
// if tmp then
13122: LD_VAR 0 8
13126: IFFALSE 13300
// begin r := r ^ [ tmp [ 1 ] ] ;
13128: LD_ADDR_VAR 0 7
13132: PUSH
13133: LD_VAR 0 7
13137: PUSH
13138: LD_VAR 0 8
13142: PUSH
13143: LD_INT 1
13145: ARRAY
13146: PUSH
13147: EMPTY
13148: LIST
13149: ADD
13150: ST_TO_ADDR
// for i = 2 to tmp do
13151: LD_ADDR_VAR 0 5
13155: PUSH
13156: DOUBLE
13157: LD_INT 2
13159: DEC
13160: ST_TO_ADDR
13161: LD_VAR 0 8
13165: PUSH
13166: FOR_TO
13167: IFFALSE 13298
// begin for j = 1 to r do
13169: LD_ADDR_VAR 0 6
13173: PUSH
13174: DOUBLE
13175: LD_INT 1
13177: DEC
13178: ST_TO_ADDR
13179: LD_VAR 0 7
13183: PUSH
13184: FOR_TO
13185: IFFALSE 13262
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13187: LD_VAR 0 8
13191: PUSH
13192: LD_VAR 0 5
13196: ARRAY
13197: PUSH
13198: LD_INT 2
13200: ARRAY
13201: PUSH
13202: LD_VAR 0 7
13206: PUSH
13207: LD_VAR 0 6
13211: ARRAY
13212: PUSH
13213: LD_INT 2
13215: ARRAY
13216: LESS
13217: IFFALSE 13260
// begin r := Insert ( r , j , tmp [ i ] ) ;
13219: LD_ADDR_VAR 0 7
13223: PUSH
13224: LD_VAR 0 7
13228: PPUSH
13229: LD_VAR 0 6
13233: PPUSH
13234: LD_VAR 0 8
13238: PUSH
13239: LD_VAR 0 5
13243: ARRAY
13244: PPUSH
13245: CALL_OW 2
13249: ST_TO_ADDR
// add := true ;
13250: LD_ADDR_VAR 0 9
13254: PUSH
13255: LD_INT 1
13257: ST_TO_ADDR
// break ;
13258: GO 13262
// end ; end ;
13260: GO 13184
13262: POP
13263: POP
// if not add then
13264: LD_VAR 0 9
13268: NOT
13269: IFFALSE 13296
// r := r ^ [ tmp [ i ] ] ;
13271: LD_ADDR_VAR 0 7
13275: PUSH
13276: LD_VAR 0 7
13280: PUSH
13281: LD_VAR 0 8
13285: PUSH
13286: LD_VAR 0 5
13290: ARRAY
13291: PUSH
13292: EMPTY
13293: LIST
13294: ADD
13295: ST_TO_ADDR
// end ;
13296: GO 13166
13298: POP
13299: POP
// end ; result := r ;
13300: LD_ADDR_VAR 0 4
13304: PUSH
13305: LD_VAR 0 7
13309: ST_TO_ADDR
// end ;
13310: LD_VAR 0 4
13314: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13315: LD_INT 0
13317: PPUSH
13318: PPUSH
13319: PPUSH
13320: PPUSH
13321: PPUSH
13322: PPUSH
// tmp := [ ] ;
13323: LD_ADDR_VAR 0 8
13327: PUSH
13328: EMPTY
13329: ST_TO_ADDR
// r := [ ] ;
13330: LD_ADDR_VAR 0 7
13334: PUSH
13335: EMPTY
13336: ST_TO_ADDR
// add := false ;
13337: LD_ADDR_VAR 0 9
13341: PUSH
13342: LD_INT 0
13344: ST_TO_ADDR
// if plist then
13345: LD_VAR 0 2
13349: IFFALSE 13425
// begin for i = 1 to plist do
13351: LD_ADDR_VAR 0 5
13355: PUSH
13356: DOUBLE
13357: LD_INT 1
13359: DEC
13360: ST_TO_ADDR
13361: LD_VAR 0 2
13365: PUSH
13366: FOR_TO
13367: IFFALSE 13421
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13369: LD_ADDR_VAR 0 8
13373: PUSH
13374: LD_VAR 0 8
13378: PUSH
13379: LD_VAR 0 2
13383: PUSH
13384: LD_VAR 0 5
13388: ARRAY
13389: PUSH
13390: LD_VAR 0 2
13394: PUSH
13395: LD_VAR 0 5
13399: ARRAY
13400: PPUSH
13401: LD_VAR 0 3
13405: PPUSH
13406: CALL_OW 259
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PUSH
13415: EMPTY
13416: LIST
13417: ADD
13418: ST_TO_ADDR
// end ;
13419: GO 13366
13421: POP
13422: POP
// end else
13423: GO 13433
// result := false ;
13425: LD_ADDR_VAR 0 4
13429: PUSH
13430: LD_INT 0
13432: ST_TO_ADDR
// if tmp then
13433: LD_VAR 0 8
13437: IFFALSE 13611
// begin r := r ^ [ tmp [ 1 ] ] ;
13439: LD_ADDR_VAR 0 7
13443: PUSH
13444: LD_VAR 0 7
13448: PUSH
13449: LD_VAR 0 8
13453: PUSH
13454: LD_INT 1
13456: ARRAY
13457: PUSH
13458: EMPTY
13459: LIST
13460: ADD
13461: ST_TO_ADDR
// for i = 2 to tmp do
13462: LD_ADDR_VAR 0 5
13466: PUSH
13467: DOUBLE
13468: LD_INT 2
13470: DEC
13471: ST_TO_ADDR
13472: LD_VAR 0 8
13476: PUSH
13477: FOR_TO
13478: IFFALSE 13609
// begin for j = 1 to r do
13480: LD_ADDR_VAR 0 6
13484: PUSH
13485: DOUBLE
13486: LD_INT 1
13488: DEC
13489: ST_TO_ADDR
13490: LD_VAR 0 7
13494: PUSH
13495: FOR_TO
13496: IFFALSE 13573
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13498: LD_VAR 0 8
13502: PUSH
13503: LD_VAR 0 5
13507: ARRAY
13508: PUSH
13509: LD_INT 2
13511: ARRAY
13512: PUSH
13513: LD_VAR 0 7
13517: PUSH
13518: LD_VAR 0 6
13522: ARRAY
13523: PUSH
13524: LD_INT 2
13526: ARRAY
13527: GREATER
13528: IFFALSE 13571
// begin r := Insert ( r , j , tmp [ i ] ) ;
13530: LD_ADDR_VAR 0 7
13534: PUSH
13535: LD_VAR 0 7
13539: PPUSH
13540: LD_VAR 0 6
13544: PPUSH
13545: LD_VAR 0 8
13549: PUSH
13550: LD_VAR 0 5
13554: ARRAY
13555: PPUSH
13556: CALL_OW 2
13560: ST_TO_ADDR
// add := true ;
13561: LD_ADDR_VAR 0 9
13565: PUSH
13566: LD_INT 1
13568: ST_TO_ADDR
// break ;
13569: GO 13573
// end ; end ;
13571: GO 13495
13573: POP
13574: POP
// if not add then
13575: LD_VAR 0 9
13579: NOT
13580: IFFALSE 13607
// r := r ^ [ tmp [ i ] ] ;
13582: LD_ADDR_VAR 0 7
13586: PUSH
13587: LD_VAR 0 7
13591: PUSH
13592: LD_VAR 0 8
13596: PUSH
13597: LD_VAR 0 5
13601: ARRAY
13602: PUSH
13603: EMPTY
13604: LIST
13605: ADD
13606: ST_TO_ADDR
// end ;
13607: GO 13477
13609: POP
13610: POP
// end ; result := r ;
13611: LD_ADDR_VAR 0 4
13615: PUSH
13616: LD_VAR 0 7
13620: ST_TO_ADDR
// end ;
13621: LD_VAR 0 4
13625: RET
// export function MCF_Clear ( side ) ; var i ; begin
13626: LD_INT 0
13628: PPUSH
13629: PPUSH
// for i = 1 to 100 do
13630: LD_ADDR_VAR 0 3
13634: PUSH
13635: DOUBLE
13636: LD_INT 1
13638: DEC
13639: ST_TO_ADDR
13640: LD_INT 100
13642: PUSH
13643: FOR_TO
13644: IFFALSE 13680
// if MCF_Tag ( side , i , [ ] ) then
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_VAR 0 3
13655: PPUSH
13656: EMPTY
13657: PPUSH
13658: CALL 12249 0 3
13662: IFFALSE 13678
// MCF_ClearTag ( side , i ) ;
13664: LD_VAR 0 1
13668: PPUSH
13669: LD_VAR 0 3
13673: PPUSH
13674: CALL 12490 0 2
13678: GO 13643
13680: POP
13681: POP
// result := true ;
13682: LD_ADDR_VAR 0 2
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// end ;
13690: LD_VAR 0 2
13694: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13695: LD_INT 0
13697: PPUSH
13698: PPUSH
13699: PPUSH
// for i = 1 to plist do
13700: LD_ADDR_VAR 0 4
13704: PUSH
13705: DOUBLE
13706: LD_INT 1
13708: DEC
13709: ST_TO_ADDR
13710: LD_VAR 0 1
13714: PUSH
13715: FOR_TO
13716: IFFALSE 13765
// if MCF_HasClass ( plist [ i ] ) = n then
13718: LD_VAR 0 1
13722: PUSH
13723: LD_VAR 0 4
13727: ARRAY
13728: PPUSH
13729: CALL 14252 0 1
13733: PUSH
13734: LD_VAR 0 2
13738: EQUAL
13739: IFFALSE 13763
// tmp := tmp ^ plist [ i ] ;
13741: LD_ADDR_VAR 0 5
13745: PUSH
13746: LD_VAR 0 5
13750: PUSH
13751: LD_VAR 0 1
13755: PUSH
13756: LD_VAR 0 4
13760: ARRAY
13761: ADD
13762: ST_TO_ADDR
13763: GO 13715
13765: POP
13766: POP
// result := tmp ;
13767: LD_ADDR_VAR 0 3
13771: PUSH
13772: LD_VAR 0 5
13776: ST_TO_ADDR
// end ;
13777: LD_VAR 0 3
13781: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13782: LD_INT 0
13784: PPUSH
13785: PPUSH
13786: PPUSH
// if mreg = ToArm then
13787: LD_VAR 0 2
13791: PUSH
13792: LD_STRING ToArm
13794: EQUAL
13795: IFFALSE 13900
// begin tmp := MREG_ToArm [ side ] ;
13797: LD_ADDR_VAR 0 6
13801: PUSH
13802: LD_EXP 56
13806: PUSH
13807: LD_VAR 0 1
13811: ARRAY
13812: ST_TO_ADDR
// if tmp = 0 then
13813: LD_VAR 0 6
13817: PUSH
13818: LD_INT 0
13820: EQUAL
13821: IFFALSE 13827
// exit else
13823: GO 14247
13825: GO 13900
// begin for i = MREG_ToArm [ side ] downto n do
13827: LD_ADDR_VAR 0 5
13831: PUSH
13832: DOUBLE
13833: LD_EXP 56
13837: PUSH
13838: LD_VAR 0 1
13842: ARRAY
13843: INC
13844: ST_TO_ADDR
13845: LD_VAR 0 3
13849: PUSH
13850: FOR_DOWNTO
13851: IFFALSE 13873
// tmp := Delete ( tmp , 1 ) ;
13853: LD_ADDR_VAR 0 6
13857: PUSH
13858: LD_VAR 0 6
13862: PPUSH
13863: LD_INT 1
13865: PPUSH
13866: CALL_OW 3
13870: ST_TO_ADDR
13871: GO 13850
13873: POP
13874: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13875: LD_ADDR_EXP 56
13879: PUSH
13880: LD_EXP 56
13884: PPUSH
13885: LD_VAR 0 1
13889: PPUSH
13890: LD_VAR 0 6
13894: PPUSH
13895: CALL_OW 1
13899: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13900: LD_VAR 0 2
13904: PUSH
13905: LD_STRING ToDep
13907: EQUAL
13908: IFFALSE 14013
// begin tmp := MREG_ToDep [ side ] ;
13910: LD_ADDR_VAR 0 6
13914: PUSH
13915: LD_EXP 57
13919: PUSH
13920: LD_VAR 0 1
13924: ARRAY
13925: ST_TO_ADDR
// if tmp = 0 then
13926: LD_VAR 0 6
13930: PUSH
13931: LD_INT 0
13933: EQUAL
13934: IFFALSE 13940
// exit else
13936: GO 14247
13938: GO 14013
// begin for i = MREG_ToDep [ side ] downto n do
13940: LD_ADDR_VAR 0 5
13944: PUSH
13945: DOUBLE
13946: LD_EXP 57
13950: PUSH
13951: LD_VAR 0 1
13955: ARRAY
13956: INC
13957: ST_TO_ADDR
13958: LD_VAR 0 3
13962: PUSH
13963: FOR_DOWNTO
13964: IFFALSE 13986
// tmp := Delete ( tmp , 1 ) ;
13966: LD_ADDR_VAR 0 6
13970: PUSH
13971: LD_VAR 0 6
13975: PPUSH
13976: LD_INT 1
13978: PPUSH
13979: CALL_OW 3
13983: ST_TO_ADDR
13984: GO 13963
13986: POP
13987: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13988: LD_ADDR_EXP 57
13992: PUSH
13993: LD_EXP 57
13997: PPUSH
13998: LD_VAR 0 1
14002: PPUSH
14003: LD_VAR 0 6
14007: PPUSH
14008: CALL_OW 1
14012: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14013: LD_VAR 0 2
14017: PUSH
14018: LD_STRING ToFac
14020: EQUAL
14021: IFFALSE 14126
// begin tmp := MREG_ToFac [ side ] ;
14023: LD_ADDR_VAR 0 6
14027: PUSH
14028: LD_EXP 55
14032: PUSH
14033: LD_VAR 0 1
14037: ARRAY
14038: ST_TO_ADDR
// if tmp = 0 then
14039: LD_VAR 0 6
14043: PUSH
14044: LD_INT 0
14046: EQUAL
14047: IFFALSE 14053
// exit else
14049: GO 14247
14051: GO 14126
// begin for i = MREG_ToFac [ side ] downto n do
14053: LD_ADDR_VAR 0 5
14057: PUSH
14058: DOUBLE
14059: LD_EXP 55
14063: PUSH
14064: LD_VAR 0 1
14068: ARRAY
14069: INC
14070: ST_TO_ADDR
14071: LD_VAR 0 3
14075: PUSH
14076: FOR_DOWNTO
14077: IFFALSE 14099
// tmp := Delete ( tmp , 1 ) ;
14079: LD_ADDR_VAR 0 6
14083: PUSH
14084: LD_VAR 0 6
14088: PPUSH
14089: LD_INT 1
14091: PPUSH
14092: CALL_OW 3
14096: ST_TO_ADDR
14097: GO 14076
14099: POP
14100: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14101: LD_ADDR_EXP 55
14105: PUSH
14106: LD_EXP 55
14110: PPUSH
14111: LD_VAR 0 1
14115: PPUSH
14116: LD_VAR 0 6
14120: PPUSH
14121: CALL_OW 1
14125: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14126: LD_VAR 0 2
14130: PUSH
14131: LD_STRING ToLab
14133: EQUAL
14134: IFFALSE 14239
// begin tmp := MREG_ToLab [ side ] ;
14136: LD_ADDR_VAR 0 6
14140: PUSH
14141: LD_EXP 54
14145: PUSH
14146: LD_VAR 0 1
14150: ARRAY
14151: ST_TO_ADDR
// if tmp = 0 then
14152: LD_VAR 0 6
14156: PUSH
14157: LD_INT 0
14159: EQUAL
14160: IFFALSE 14166
// exit else
14162: GO 14247
14164: GO 14239
// begin for i = MREG_ToLab [ side ] downto n do
14166: LD_ADDR_VAR 0 5
14170: PUSH
14171: DOUBLE
14172: LD_EXP 54
14176: PUSH
14177: LD_VAR 0 1
14181: ARRAY
14182: INC
14183: ST_TO_ADDR
14184: LD_VAR 0 3
14188: PUSH
14189: FOR_DOWNTO
14190: IFFALSE 14212
// tmp := Delete ( tmp , 1 ) ;
14192: LD_ADDR_VAR 0 6
14196: PUSH
14197: LD_VAR 0 6
14201: PPUSH
14202: LD_INT 1
14204: PPUSH
14205: CALL_OW 3
14209: ST_TO_ADDR
14210: GO 14189
14212: POP
14213: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14214: LD_ADDR_EXP 54
14218: PUSH
14219: LD_EXP 54
14223: PPUSH
14224: LD_VAR 0 1
14228: PPUSH
14229: LD_VAR 0 6
14233: PPUSH
14234: CALL_OW 1
14238: ST_TO_ADDR
// end ; end ; result := true ;
14239: LD_ADDR_VAR 0 4
14243: PUSH
14244: LD_INT 1
14246: ST_TO_ADDR
// end ;
14247: LD_VAR 0 4
14251: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14252: LD_INT 0
14254: PPUSH
14255: PPUSH
14256: PPUSH
// side := GetSide ( unit ) ;
14257: LD_ADDR_VAR 0 4
14261: PUSH
14262: LD_VAR 0 1
14266: PPUSH
14267: CALL_OW 255
14271: ST_TO_ADDR
// tmp := 0 ;
14272: LD_ADDR_VAR 0 3
14276: PUSH
14277: LD_INT 0
14279: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14280: LD_VAR 0 1
14284: PUSH
14285: LD_EXP 56
14289: PUSH
14290: LD_VAR 0 4
14294: ARRAY
14295: IN
14296: IFFALSE 14306
// tmp := 1 ;
14298: LD_ADDR_VAR 0 3
14302: PUSH
14303: LD_INT 1
14305: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14306: LD_VAR 0 1
14310: PUSH
14311: LD_EXP 57
14315: PUSH
14316: LD_VAR 0 4
14320: ARRAY
14321: IN
14322: IFFALSE 14332
// tmp := 2 ;
14324: LD_ADDR_VAR 0 3
14328: PUSH
14329: LD_INT 2
14331: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14332: LD_VAR 0 1
14336: PUSH
14337: LD_EXP 55
14341: PUSH
14342: LD_VAR 0 4
14346: ARRAY
14347: IN
14348: IFFALSE 14358
// tmp := 3 ;
14350: LD_ADDR_VAR 0 3
14354: PUSH
14355: LD_INT 3
14357: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14358: LD_VAR 0 1
14362: PUSH
14363: LD_EXP 54
14367: PUSH
14368: LD_VAR 0 4
14372: ARRAY
14373: IN
14374: IFFALSE 14384
// tmp := 4 ;
14376: LD_ADDR_VAR 0 3
14380: PUSH
14381: LD_INT 4
14383: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14384: LD_VAR 0 1
14388: PUSH
14389: LD_EXP 68
14393: PUSH
14394: LD_VAR 0 4
14398: ARRAY
14399: IN
14400: IFFALSE 14410
// tmp := 5 ;
14402: LD_ADDR_VAR 0 3
14406: PUSH
14407: LD_INT 5
14409: ST_TO_ADDR
// result := tmp ;
14410: LD_ADDR_VAR 0 2
14414: PUSH
14415: LD_VAR 0 3
14419: ST_TO_ADDR
// end ;
14420: LD_VAR 0 2
14424: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14425: LD_INT 0
14427: PPUSH
14428: PPUSH
// if mreg = ToArm then
14429: LD_VAR 0 2
14433: PUSH
14434: LD_STRING ToArm
14436: EQUAL
14437: IFFALSE 14526
// for i = MREG_ToArm [ side ] downto 1 do
14439: LD_ADDR_VAR 0 5
14443: PUSH
14444: DOUBLE
14445: LD_EXP 56
14449: PUSH
14450: LD_VAR 0 1
14454: ARRAY
14455: INC
14456: ST_TO_ADDR
14457: LD_INT 1
14459: PUSH
14460: FOR_DOWNTO
14461: IFFALSE 14524
// if MREG_ToArm [ side ] [ i ] = unit then
14463: LD_EXP 56
14467: PUSH
14468: LD_VAR 0 1
14472: ARRAY
14473: PUSH
14474: LD_VAR 0 5
14478: ARRAY
14479: PUSH
14480: LD_VAR 0 3
14484: EQUAL
14485: IFFALSE 14522
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14487: LD_ADDR_EXP 56
14491: PUSH
14492: LD_EXP 56
14496: PPUSH
14497: LD_EXP 56
14501: PUSH
14502: LD_VAR 0 1
14506: ARRAY
14507: PUSH
14508: LD_VAR 0 5
14512: ARRAY
14513: PPUSH
14514: LD_INT 1
14516: PPUSH
14517: CALL 31170 0 3
14521: ST_TO_ADDR
// end ;
14522: GO 14460
14524: POP
14525: POP
// if mreg = ToDep then
14526: LD_VAR 0 2
14530: PUSH
14531: LD_STRING ToDep
14533: EQUAL
14534: IFFALSE 14623
// for i = MREG_ToDep [ side ] downto 1 do
14536: LD_ADDR_VAR 0 5
14540: PUSH
14541: DOUBLE
14542: LD_EXP 57
14546: PUSH
14547: LD_VAR 0 1
14551: ARRAY
14552: INC
14553: ST_TO_ADDR
14554: LD_INT 1
14556: PUSH
14557: FOR_DOWNTO
14558: IFFALSE 14621
// if MREG_ToDep [ side ] [ i ] = unit then
14560: LD_EXP 57
14564: PUSH
14565: LD_VAR 0 1
14569: ARRAY
14570: PUSH
14571: LD_VAR 0 5
14575: ARRAY
14576: PUSH
14577: LD_VAR 0 3
14581: EQUAL
14582: IFFALSE 14619
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14584: LD_ADDR_EXP 57
14588: PUSH
14589: LD_EXP 57
14593: PPUSH
14594: LD_EXP 57
14598: PUSH
14599: LD_VAR 0 1
14603: ARRAY
14604: PUSH
14605: LD_VAR 0 5
14609: ARRAY
14610: PPUSH
14611: LD_INT 1
14613: PPUSH
14614: CALL 31170 0 3
14618: ST_TO_ADDR
// end ;
14619: GO 14557
14621: POP
14622: POP
// if mreg = ToFac then
14623: LD_VAR 0 2
14627: PUSH
14628: LD_STRING ToFac
14630: EQUAL
14631: IFFALSE 14720
// for i = MREG_ToFac [ side ] downto 1 do
14633: LD_ADDR_VAR 0 5
14637: PUSH
14638: DOUBLE
14639: LD_EXP 55
14643: PUSH
14644: LD_VAR 0 1
14648: ARRAY
14649: INC
14650: ST_TO_ADDR
14651: LD_INT 1
14653: PUSH
14654: FOR_DOWNTO
14655: IFFALSE 14718
// if MREG_ToFac [ side ] [ i ] = unit then
14657: LD_EXP 55
14661: PUSH
14662: LD_VAR 0 1
14666: ARRAY
14667: PUSH
14668: LD_VAR 0 5
14672: ARRAY
14673: PUSH
14674: LD_VAR 0 3
14678: EQUAL
14679: IFFALSE 14716
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14681: LD_ADDR_EXP 55
14685: PUSH
14686: LD_EXP 55
14690: PPUSH
14691: LD_EXP 55
14695: PUSH
14696: LD_VAR 0 1
14700: ARRAY
14701: PUSH
14702: LD_VAR 0 5
14706: ARRAY
14707: PPUSH
14708: LD_INT 1
14710: PPUSH
14711: CALL 31170 0 3
14715: ST_TO_ADDR
// end ;
14716: GO 14654
14718: POP
14719: POP
// if mreg = ToLab then
14720: LD_VAR 0 2
14724: PUSH
14725: LD_STRING ToLab
14727: EQUAL
14728: IFFALSE 14817
// for i = MREG_ToLab [ side ] downto 1 do
14730: LD_ADDR_VAR 0 5
14734: PUSH
14735: DOUBLE
14736: LD_EXP 54
14740: PUSH
14741: LD_VAR 0 1
14745: ARRAY
14746: INC
14747: ST_TO_ADDR
14748: LD_INT 1
14750: PUSH
14751: FOR_DOWNTO
14752: IFFALSE 14815
// if MREG_ToLab [ side ] [ i ] = unit then
14754: LD_EXP 54
14758: PUSH
14759: LD_VAR 0 1
14763: ARRAY
14764: PUSH
14765: LD_VAR 0 5
14769: ARRAY
14770: PUSH
14771: LD_VAR 0 3
14775: EQUAL
14776: IFFALSE 14813
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14778: LD_ADDR_EXP 54
14782: PUSH
14783: LD_EXP 54
14787: PPUSH
14788: LD_EXP 54
14792: PUSH
14793: LD_VAR 0 1
14797: ARRAY
14798: PUSH
14799: LD_VAR 0 5
14803: ARRAY
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL 31170 0 3
14812: ST_TO_ADDR
// end ;
14813: GO 14751
14815: POP
14816: POP
// end ;
14817: LD_VAR 0 4
14821: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14822: LD_INT 0
14824: PPUSH
14825: PPUSH
// result := false ;
14826: LD_ADDR_VAR 0 2
14830: PUSH
14831: LD_INT 0
14833: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14834: LD_ADDR_VAR 0 3
14838: PUSH
14839: DOUBLE
14840: LD_INT 1
14842: DEC
14843: ST_TO_ADDR
14844: LD_EXP 46
14848: PUSH
14849: FOR_TO
14850: IFFALSE 14914
// if MREG_ToBuild [ i ] [ 1 ] = side then
14852: LD_EXP 46
14856: PUSH
14857: LD_VAR 0 3
14861: ARRAY
14862: PUSH
14863: LD_INT 1
14865: ARRAY
14866: PUSH
14867: LD_VAR 0 1
14871: EQUAL
14872: IFFALSE 14912
// begin if MREG_ToBuild [ i ] [ 1 ] then
14874: LD_EXP 46
14878: PUSH
14879: LD_VAR 0 3
14883: ARRAY
14884: PUSH
14885: LD_INT 1
14887: ARRAY
14888: IFFALSE 14912
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14890: LD_ADDR_VAR 0 2
14894: PUSH
14895: LD_EXP 46
14899: PUSH
14900: LD_VAR 0 3
14904: ARRAY
14905: PUSH
14906: LD_INT 1
14908: ARRAY
14909: ST_TO_ADDR
// break ;
14910: GO 14914
// end ; end ;
14912: GO 14849
14914: POP
14915: POP
// for i = 1 to MREG_ToRepair do
14916: LD_ADDR_VAR 0 3
14920: PUSH
14921: DOUBLE
14922: LD_INT 1
14924: DEC
14925: ST_TO_ADDR
14926: LD_EXP 47
14930: PUSH
14931: FOR_TO
14932: IFFALSE 14996
// if MREG_ToRepair [ i ] [ 1 ] = side then
14934: LD_EXP 47
14938: PUSH
14939: LD_VAR 0 3
14943: ARRAY
14944: PUSH
14945: LD_INT 1
14947: ARRAY
14948: PUSH
14949: LD_VAR 0 1
14953: EQUAL
14954: IFFALSE 14994
// begin if MREG_ToRepair [ i ] [ 1 ] then
14956: LD_EXP 47
14960: PUSH
14961: LD_VAR 0 3
14965: ARRAY
14966: PUSH
14967: LD_INT 1
14969: ARRAY
14970: IFFALSE 14994
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14972: LD_ADDR_VAR 0 2
14976: PUSH
14977: LD_EXP 47
14981: PUSH
14982: LD_VAR 0 3
14986: ARRAY
14987: PUSH
14988: LD_INT 1
14990: ARRAY
14991: ST_TO_ADDR
// break ;
14992: GO 14996
// end ; end ;
14994: GO 14931
14996: POP
14997: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14998: LD_VAR 0 1
15002: PPUSH
15003: LD_INT 57
15005: PUSH
15006: EMPTY
15007: LIST
15008: PPUSH
15009: CALL 11546 0 2
15013: IFFALSE 15040
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15015: LD_ADDR_VAR 0 2
15019: PUSH
15020: LD_VAR 0 1
15024: PPUSH
15025: LD_INT 57
15027: PUSH
15028: EMPTY
15029: LIST
15030: PPUSH
15031: CALL 11546 0 2
15035: PUSH
15036: LD_INT 1
15038: ARRAY
15039: ST_TO_ADDR
// end ;
15040: LD_VAR 0 2
15044: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15045: LD_INT 0
15047: PPUSH
15048: PPUSH
15049: PPUSH
15050: PPUSH
15051: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15052: LD_ADDR_VAR 0 6
15056: PUSH
15057: LD_VAR 0 1
15061: PPUSH
15062: LD_INT 21
15064: PUSH
15065: LD_INT 3
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PPUSH
15072: CALL 11546 0 2
15076: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15077: LD_ADDR_VAR 0 7
15081: PUSH
15082: LD_VAR 0 1
15086: PPUSH
15087: LD_INT 81
15089: PUSH
15090: LD_VAR 0 1
15094: PUSH
15095: EMPTY
15096: LIST
15097: LIST
15098: PPUSH
15099: CALL 11546 0 2
15103: ST_TO_ADDR
// if not enemy then
15104: LD_VAR 0 7
15108: NOT
15109: IFFALSE 15121
// result := false else
15111: LD_ADDR_VAR 0 3
15115: PUSH
15116: LD_INT 0
15118: ST_TO_ADDR
15119: GO 15175
// begin scan := NearestUnit ( b , enemy ) ;
15121: LD_ADDR_VAR 0 5
15125: PUSH
15126: LD_VAR 0 6
15130: PPUSH
15131: LD_VAR 0 7
15135: PPUSH
15136: CALL 32163 0 2
15140: ST_TO_ADDR
// if scan [ 2 ] < dist then
15141: LD_VAR 0 5
15145: PUSH
15146: LD_INT 2
15148: ARRAY
15149: PUSH
15150: LD_VAR 0 2
15154: LESS
15155: IFFALSE 15167
// result := true else
15157: LD_ADDR_VAR 0 3
15161: PUSH
15162: LD_INT 1
15164: ST_TO_ADDR
15165: GO 15175
// result := false ;
15167: LD_ADDR_VAR 0 3
15171: PUSH
15172: LD_INT 0
15174: ST_TO_ADDR
// end ; end ;
15175: LD_VAR 0 3
15179: RET
// export function MCF_Info ( ) ; begin
15180: LD_INT 0
15182: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15183: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15185: PUSH
15186: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15188: ADD
15189: PUSH
15190: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15192: ADD
15193: PUSH
15194: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15196: ADD
15197: PUSH
15198: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15200: ADD
15201: PUSH
15202: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15204: ADD
15205: PUSH
15206: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15208: ADD
15209: PUSH
15210: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15212: ADD
15213: PUSH
15214: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15216: ADD
15217: PUSH
15218: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15220: ADD
15221: PPUSH
15222: CALL 8464 0 1
// end ; end_of_file
15226: LD_VAR 0 1
15230: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
15235: PPUSH
15236: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15237: LD_ADDR_VAR 0 5
15241: PUSH
15242: LD_VAR 0 1
15246: PPUSH
15247: LD_INT 2
15249: PUSH
15250: LD_INT 25
15252: PUSH
15253: LD_INT 2
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: PUSH
15260: LD_INT 25
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: PUSH
15270: LD_INT 25
15272: PUSH
15273: LD_INT 4
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: LIST
15284: LIST
15285: PPUSH
15286: CALL 11546 0 2
15290: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15291: LD_ADDR_VAR 0 5
15295: PUSH
15296: LD_VAR 0 5
15300: PPUSH
15301: LD_INT 0
15303: PPUSH
15304: CALL 13695 0 2
15308: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15309: LD_ADDR_VAR 0 6
15313: PUSH
15314: LD_VAR 0 1
15318: PPUSH
15319: LD_VAR 0 5
15323: PPUSH
15324: LD_INT 1
15326: PPUSH
15327: CALL 13315 0 3
15331: ST_TO_ADDR
// if n > sk then
15332: LD_VAR 0 2
15336: PUSH
15337: LD_VAR 0 6
15341: GREATER
15342: IFFALSE 15354
// n := sk ;
15344: LD_ADDR_VAR 0 2
15348: PUSH
15349: LD_VAR 0 6
15353: ST_TO_ADDR
// for i = 1 to n do
15354: LD_ADDR_VAR 0 4
15358: PUSH
15359: DOUBLE
15360: LD_INT 1
15362: DEC
15363: ST_TO_ADDR
15364: LD_VAR 0 2
15368: PUSH
15369: FOR_TO
15370: IFFALSE 15482
// if ( sk [ i ] [ 1 ] ) <> 0 then
15372: LD_VAR 0 6
15376: PUSH
15377: LD_VAR 0 4
15381: ARRAY
15382: PUSH
15383: LD_INT 1
15385: ARRAY
15386: PUSH
15387: LD_INT 0
15389: NONEQUAL
15390: IFFALSE 15480
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15392: LD_ADDR_EXP 53
15396: PUSH
15397: LD_EXP 53
15401: PPUSH
15402: LD_VAR 0 1
15406: PPUSH
15407: LD_VAR 0 6
15411: PUSH
15412: LD_VAR 0 4
15416: ARRAY
15417: PUSH
15418: LD_INT 1
15420: ARRAY
15421: PPUSH
15422: LD_INT 1
15424: PPUSH
15425: CALL 41841 0 4
15429: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15430: LD_ADDR_EXP 56
15434: PUSH
15435: LD_EXP 56
15439: PPUSH
15440: LD_VAR 0 1
15444: PPUSH
15445: LD_EXP 56
15449: PUSH
15450: LD_VAR 0 1
15454: ARRAY
15455: PUSH
15456: LD_INT 1
15458: PLUS
15459: PPUSH
15460: LD_VAR 0 6
15464: PUSH
15465: LD_VAR 0 4
15469: ARRAY
15470: PUSH
15471: LD_INT 1
15473: ARRAY
15474: PPUSH
15475: CALL 31011 0 4
15479: ST_TO_ADDR
// end ;
15480: GO 15369
15482: POP
15483: POP
// end ;
15484: LD_VAR 0 3
15488: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15489: LD_INT 0
15491: PPUSH
15492: PPUSH
15493: PPUSH
15494: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15495: LD_ADDR_VAR 0 5
15499: PUSH
15500: LD_VAR 0 1
15504: PPUSH
15505: LD_INT 2
15507: PUSH
15508: LD_INT 25
15510: PUSH
15511: LD_INT 1
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: LD_INT 25
15520: PUSH
15521: LD_INT 3
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PUSH
15528: LD_INT 25
15530: PUSH
15531: LD_INT 4
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL 11546 0 2
15548: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15549: LD_ADDR_VAR 0 5
15553: PUSH
15554: LD_VAR 0 5
15558: PPUSH
15559: LD_INT 0
15561: PPUSH
15562: CALL 13695 0 2
15566: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15567: LD_ADDR_VAR 0 6
15571: PUSH
15572: LD_VAR 0 1
15576: PPUSH
15577: LD_VAR 0 5
15581: PPUSH
15582: LD_INT 2
15584: PPUSH
15585: CALL 13315 0 3
15589: ST_TO_ADDR
// if n > sk then
15590: LD_VAR 0 2
15594: PUSH
15595: LD_VAR 0 6
15599: GREATER
15600: IFFALSE 15612
// n := sk ;
15602: LD_ADDR_VAR 0 2
15606: PUSH
15607: LD_VAR 0 6
15611: ST_TO_ADDR
// for i = 1 to n do
15612: LD_ADDR_VAR 0 4
15616: PUSH
15617: DOUBLE
15618: LD_INT 1
15620: DEC
15621: ST_TO_ADDR
15622: LD_VAR 0 2
15626: PUSH
15627: FOR_TO
15628: IFFALSE 15740
// if ( sk [ i ] [ 1 ] ) <> 0 then
15630: LD_VAR 0 6
15634: PUSH
15635: LD_VAR 0 4
15639: ARRAY
15640: PUSH
15641: LD_INT 1
15643: ARRAY
15644: PUSH
15645: LD_INT 0
15647: NONEQUAL
15648: IFFALSE 15738
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15650: LD_ADDR_EXP 53
15654: PUSH
15655: LD_EXP 53
15659: PPUSH
15660: LD_VAR 0 1
15664: PPUSH
15665: LD_VAR 0 6
15669: PUSH
15670: LD_VAR 0 4
15674: ARRAY
15675: PUSH
15676: LD_INT 1
15678: ARRAY
15679: PPUSH
15680: LD_INT 2
15682: PPUSH
15683: CALL 41841 0 4
15687: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15688: LD_ADDR_EXP 57
15692: PUSH
15693: LD_EXP 57
15697: PPUSH
15698: LD_VAR 0 1
15702: PPUSH
15703: LD_EXP 57
15707: PUSH
15708: LD_VAR 0 1
15712: ARRAY
15713: PUSH
15714: LD_INT 1
15716: PLUS
15717: PPUSH
15718: LD_VAR 0 6
15722: PUSH
15723: LD_VAR 0 4
15727: ARRAY
15728: PUSH
15729: LD_INT 1
15731: ARRAY
15732: PPUSH
15733: CALL 31011 0 4
15737: ST_TO_ADDR
// end ;
15738: GO 15627
15740: POP
15741: POP
// end ;
15742: LD_VAR 0 3
15746: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15747: LD_INT 0
15749: PPUSH
15750: PPUSH
15751: PPUSH
15752: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15753: LD_ADDR_VAR 0 5
15757: PUSH
15758: LD_VAR 0 1
15762: PPUSH
15763: LD_INT 2
15765: PUSH
15766: LD_INT 25
15768: PUSH
15769: LD_INT 1
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PUSH
15776: LD_INT 25
15778: PUSH
15779: LD_INT 2
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: PUSH
15786: LD_INT 25
15788: PUSH
15789: LD_INT 4
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: PPUSH
15802: CALL 11546 0 2
15806: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15807: LD_ADDR_VAR 0 5
15811: PUSH
15812: LD_VAR 0 5
15816: PPUSH
15817: LD_INT 0
15819: PPUSH
15820: CALL 13695 0 2
15824: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15825: LD_ADDR_VAR 0 6
15829: PUSH
15830: LD_VAR 0 1
15834: PPUSH
15835: LD_VAR 0 5
15839: PPUSH
15840: LD_INT 3
15842: PPUSH
15843: CALL 13315 0 3
15847: ST_TO_ADDR
// if n > sk then
15848: LD_VAR 0 2
15852: PUSH
15853: LD_VAR 0 6
15857: GREATER
15858: IFFALSE 15870
// n := sk ;
15860: LD_ADDR_VAR 0 2
15864: PUSH
15865: LD_VAR 0 6
15869: ST_TO_ADDR
// for i = 1 to n do
15870: LD_ADDR_VAR 0 4
15874: PUSH
15875: DOUBLE
15876: LD_INT 1
15878: DEC
15879: ST_TO_ADDR
15880: LD_VAR 0 2
15884: PUSH
15885: FOR_TO
15886: IFFALSE 15998
// if ( sk [ i ] [ 1 ] ) <> 0 then
15888: LD_VAR 0 6
15892: PUSH
15893: LD_VAR 0 4
15897: ARRAY
15898: PUSH
15899: LD_INT 1
15901: ARRAY
15902: PUSH
15903: LD_INT 0
15905: NONEQUAL
15906: IFFALSE 15996
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15908: LD_ADDR_EXP 53
15912: PUSH
15913: LD_EXP 53
15917: PPUSH
15918: LD_VAR 0 1
15922: PPUSH
15923: LD_VAR 0 6
15927: PUSH
15928: LD_VAR 0 4
15932: ARRAY
15933: PUSH
15934: LD_INT 1
15936: ARRAY
15937: PPUSH
15938: LD_INT 3
15940: PPUSH
15941: CALL 41841 0 4
15945: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15946: LD_ADDR_EXP 55
15950: PUSH
15951: LD_EXP 55
15955: PPUSH
15956: LD_VAR 0 1
15960: PPUSH
15961: LD_EXP 55
15965: PUSH
15966: LD_VAR 0 1
15970: ARRAY
15971: PUSH
15972: LD_INT 1
15974: PLUS
15975: PPUSH
15976: LD_VAR 0 6
15980: PUSH
15981: LD_VAR 0 4
15985: ARRAY
15986: PUSH
15987: LD_INT 1
15989: ARRAY
15990: PPUSH
15991: CALL 31011 0 4
15995: ST_TO_ADDR
// end ;
15996: GO 15885
15998: POP
15999: POP
// end ;
16000: LD_VAR 0 3
16004: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16005: LD_INT 0
16007: PPUSH
16008: PPUSH
16009: PPUSH
16010: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16011: LD_ADDR_VAR 0 5
16015: PUSH
16016: LD_VAR 0 1
16020: PPUSH
16021: LD_INT 2
16023: PUSH
16024: LD_INT 25
16026: PUSH
16027: LD_INT 1
16029: PUSH
16030: EMPTY
16031: LIST
16032: LIST
16033: PUSH
16034: LD_INT 25
16036: PUSH
16037: LD_INT 2
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: LIST
16048: PPUSH
16049: CALL 11546 0 2
16053: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16054: LD_ADDR_VAR 0 5
16058: PUSH
16059: LD_VAR 0 5
16063: PPUSH
16064: LD_INT 0
16066: PPUSH
16067: CALL 13695 0 2
16071: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16072: LD_ADDR_VAR 0 6
16076: PUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_VAR 0 5
16086: PPUSH
16087: LD_INT 4
16089: PPUSH
16090: CALL 13315 0 3
16094: ST_TO_ADDR
// if n > sk then
16095: LD_VAR 0 2
16099: PUSH
16100: LD_VAR 0 6
16104: GREATER
16105: IFFALSE 16117
// n := sk ;
16107: LD_ADDR_VAR 0 2
16111: PUSH
16112: LD_VAR 0 6
16116: ST_TO_ADDR
// for i = 1 to n do
16117: LD_ADDR_VAR 0 4
16121: PUSH
16122: DOUBLE
16123: LD_INT 1
16125: DEC
16126: ST_TO_ADDR
16127: LD_VAR 0 2
16131: PUSH
16132: FOR_TO
16133: IFFALSE 16245
// if ( sk [ i ] [ 1 ] ) <> 0 then
16135: LD_VAR 0 6
16139: PUSH
16140: LD_VAR 0 4
16144: ARRAY
16145: PUSH
16146: LD_INT 1
16148: ARRAY
16149: PUSH
16150: LD_INT 0
16152: NONEQUAL
16153: IFFALSE 16243
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16155: LD_ADDR_EXP 53
16159: PUSH
16160: LD_EXP 53
16164: PPUSH
16165: LD_VAR 0 1
16169: PPUSH
16170: LD_VAR 0 6
16174: PUSH
16175: LD_VAR 0 4
16179: ARRAY
16180: PUSH
16181: LD_INT 1
16183: ARRAY
16184: PPUSH
16185: LD_INT 4
16187: PPUSH
16188: CALL 41841 0 4
16192: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16193: LD_ADDR_EXP 54
16197: PUSH
16198: LD_EXP 54
16202: PPUSH
16203: LD_VAR 0 1
16207: PPUSH
16208: LD_EXP 54
16212: PUSH
16213: LD_VAR 0 1
16217: ARRAY
16218: PUSH
16219: LD_INT 1
16221: PLUS
16222: PPUSH
16223: LD_VAR 0 6
16227: PUSH
16228: LD_VAR 0 4
16232: ARRAY
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: CALL 31011 0 4
16242: ST_TO_ADDR
// end ;
16243: GO 16132
16245: POP
16246: POP
// end ;
16247: LD_VAR 0 3
16251: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16252: LD_INT 0
16254: PPUSH
16255: PPUSH
16256: PPUSH
16257: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16258: LD_ADDR_VAR 0 6
16262: PUSH
16263: LD_VAR 0 1
16267: PPUSH
16268: LD_INT 2
16270: PUSH
16271: LD_INT 25
16273: PUSH
16274: LD_INT 1
16276: PUSH
16277: EMPTY
16278: LIST
16279: LIST
16280: PUSH
16281: LD_INT 25
16283: PUSH
16284: LD_INT 2
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PUSH
16291: LD_INT 25
16293: PUSH
16294: LD_INT 3
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PUSH
16301: LD_INT 25
16303: PUSH
16304: LD_INT 4
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: LIST
16315: LIST
16316: LIST
16317: PPUSH
16318: CALL 11546 0 2
16322: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16323: LD_ADDR_VAR 0 6
16327: PUSH
16328: LD_VAR 0 6
16332: PPUSH
16333: LD_INT 0
16335: PPUSH
16336: CALL 13695 0 2
16340: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16341: LD_ADDR_VAR 0 7
16345: PUSH
16346: LD_VAR 0 1
16350: PPUSH
16351: LD_VAR 0 6
16355: PPUSH
16356: LD_INT 1
16358: PPUSH
16359: CALL 13315 0 3
16363: ST_TO_ADDR
// if n > sk then
16364: LD_VAR 0 2
16368: PUSH
16369: LD_VAR 0 7
16373: GREATER
16374: IFFALSE 16386
// n := sk ;
16376: LD_ADDR_VAR 0 2
16380: PUSH
16381: LD_VAR 0 7
16385: ST_TO_ADDR
// for i = 1 to n do
16386: LD_ADDR_VAR 0 5
16390: PUSH
16391: DOUBLE
16392: LD_INT 1
16394: DEC
16395: ST_TO_ADDR
16396: LD_VAR 0 2
16400: PUSH
16401: FOR_TO
16402: IFFALSE 16446
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16404: LD_ADDR_EXP 53
16408: PUSH
16409: LD_EXP 53
16413: PPUSH
16414: LD_VAR 0 1
16418: PPUSH
16419: LD_VAR 0 7
16423: PUSH
16424: LD_VAR 0 5
16428: ARRAY
16429: PUSH
16430: LD_INT 1
16432: ARRAY
16433: PPUSH
16434: LD_VAR 0 3
16438: PPUSH
16439: CALL 41841 0 4
16443: ST_TO_ADDR
// end ;
16444: GO 16401
16446: POP
16447: POP
// end ;
16448: LD_VAR 0 4
16452: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16453: LD_INT 0
16455: PPUSH
16456: PPUSH
16457: PPUSH
// b := false ;
16458: LD_ADDR_VAR 0 6
16462: PUSH
16463: LD_INT 0
16465: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16466: LD_VAR 0 3
16470: PUSH
16471: LD_INT 1
16473: PUSH
16474: LD_INT 9
16476: PUSH
16477: LD_INT 5
16479: PUSH
16480: LD_INT 8
16482: PUSH
16483: EMPTY
16484: LIST
16485: LIST
16486: LIST
16487: LIST
16488: IN
16489: IFFALSE 16577
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16491: LD_VAR 0 1
16495: PPUSH
16496: LD_INT 2
16498: PUSH
16499: LD_INT 30
16501: PUSH
16502: LD_INT 4
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: PUSH
16509: LD_INT 30
16511: PUSH
16512: LD_INT 5
16514: PUSH
16515: EMPTY
16516: LIST
16517: LIST
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: LIST
16523: PPUSH
16524: CALL 11546 0 2
16528: IFFALSE 16577
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16530: LD_ADDR_VAR 0 6
16534: PUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_INT 2
16542: PUSH
16543: LD_INT 30
16545: PUSH
16546: LD_INT 4
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PUSH
16553: LD_INT 30
16555: PUSH
16556: LD_INT 5
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: LIST
16567: PPUSH
16568: CALL 11546 0 2
16572: PUSH
16573: LD_INT 1
16575: ARRAY
16576: ST_TO_ADDR
// if class = class_engineer then
16577: LD_VAR 0 3
16581: PUSH
16582: LD_INT 2
16584: EQUAL
16585: IFFALSE 16673
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16587: LD_VAR 0 1
16591: PPUSH
16592: LD_INT 2
16594: PUSH
16595: LD_INT 30
16597: PUSH
16598: LD_INT 0
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PUSH
16605: LD_INT 30
16607: PUSH
16608: LD_INT 1
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: LIST
16619: PPUSH
16620: CALL 11546 0 2
16624: IFFALSE 16673
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16626: LD_ADDR_VAR 0 6
16630: PUSH
16631: LD_VAR 0 1
16635: PPUSH
16636: LD_INT 2
16638: PUSH
16639: LD_INT 30
16641: PUSH
16642: LD_INT 0
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PUSH
16649: LD_INT 30
16651: PUSH
16652: LD_INT 1
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: LIST
16663: PPUSH
16664: CALL 11546 0 2
16668: PUSH
16669: LD_INT 1
16671: ARRAY
16672: ST_TO_ADDR
// if class = class_mechanic then
16673: LD_VAR 0 3
16677: PUSH
16678: LD_INT 3
16680: EQUAL
16681: IFFALSE 16751
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16683: LD_VAR 0 1
16687: PPUSH
16688: LD_INT 30
16690: PUSH
16691: LD_INT 3
16693: PUSH
16694: EMPTY
16695: LIST
16696: LIST
16697: PPUSH
16698: CALL 11546 0 2
16702: IFFALSE 16751
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16704: LD_ADDR_VAR 0 6
16708: PUSH
16709: LD_VAR 0 1
16713: PPUSH
16714: LD_INT 2
16716: PUSH
16717: LD_INT 30
16719: PUSH
16720: LD_INT 2
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: PUSH
16727: LD_INT 30
16729: PUSH
16730: LD_INT 3
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PUSH
16737: EMPTY
16738: LIST
16739: LIST
16740: LIST
16741: PPUSH
16742: CALL 11546 0 2
16746: PUSH
16747: LD_INT 1
16749: ARRAY
16750: ST_TO_ADDR
// if class = class_scientistic then
16751: LD_VAR 0 3
16755: PUSH
16756: LD_INT 4
16758: EQUAL
16759: IFFALSE 16869
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16761: LD_VAR 0 1
16765: PPUSH
16766: LD_INT 2
16768: PUSH
16769: LD_INT 30
16771: PUSH
16772: LD_INT 6
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: PUSH
16779: LD_INT 30
16781: PUSH
16782: LD_INT 7
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 30
16791: PUSH
16792: LD_INT 8
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: LIST
16803: LIST
16804: PPUSH
16805: CALL 11546 0 2
16809: IFFALSE 16869
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16811: LD_ADDR_VAR 0 6
16815: PUSH
16816: LD_VAR 0 1
16820: PPUSH
16821: LD_INT 2
16823: PUSH
16824: LD_INT 30
16826: PUSH
16827: LD_INT 6
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: PUSH
16834: LD_INT 30
16836: PUSH
16837: LD_INT 7
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: PUSH
16844: LD_INT 30
16846: PUSH
16847: LD_INT 8
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: PPUSH
16860: CALL 11546 0 2
16864: PUSH
16865: LD_INT 1
16867: ARRAY
16868: ST_TO_ADDR
// if GetClass ( unit ) = class then
16869: LD_VAR 0 2
16873: PPUSH
16874: CALL_OW 257
16878: PUSH
16879: LD_VAR 0 3
16883: EQUAL
16884: IFFALSE 16918
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16886: LD_ADDR_EXP 53
16890: PUSH
16891: LD_EXP 53
16895: PPUSH
16896: LD_VAR 0 1
16900: PPUSH
16901: LD_VAR 0 2
16905: PPUSH
16906: LD_VAR 0 3
16910: PPUSH
16911: CALL 41932 0 4
16915: ST_TO_ADDR
// end else
16916: GO 17011
// if b then
16918: LD_VAR 0 6
16922: IFFALSE 17003
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16924: LD_VAR 0 2
16928: PPUSH
16929: CALL_OW 310
16933: PUSH
16934: LD_VAR 0 2
16938: PPUSH
16939: CALL_OW 310
16943: PUSH
16944: LD_VAR 0 6
16948: NONEQUAL
16949: AND
16950: IFFALSE 16961
// ComExitBuilding ( unit ) ;
16952: LD_VAR 0 2
16956: PPUSH
16957: CALL_OW 122
// if not IsInUnit ( unit ) then
16961: LD_VAR 0 2
16965: PPUSH
16966: CALL_OW 310
16970: NOT
16971: IFFALSE 16987
// ComEnterUnit ( unit , b ) ;
16973: LD_VAR 0 2
16977: PPUSH
16978: LD_VAR 0 6
16982: PPUSH
16983: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16987: LD_VAR 0 2
16991: PPUSH
16992: LD_VAR 0 3
16996: PPUSH
16997: CALL_OW 183
// end else
17001: GO 17011
// result := false ;
17003: LD_ADDR_VAR 0 4
17007: PUSH
17008: LD_INT 0
17010: ST_TO_ADDR
// end ; end_of_file
17011: LD_VAR 0 4
17015: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17016: LD_INT 0
17018: PPUSH
17019: PPUSH
17020: PPUSH
17021: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_INT 35
17029: PUSH
17030: LD_INT 45
17032: PUSH
17033: LD_INT 46
17035: PUSH
17036: LD_INT 47
17038: PUSH
17039: LD_INT 1
17041: PUSH
17042: LD_INT 2
17044: PUSH
17045: LD_INT 48
17047: PUSH
17048: LD_INT 49
17050: PUSH
17051: LD_INT 50
17053: PUSH
17054: LD_INT 20
17056: PUSH
17057: EMPTY
17058: LIST
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: LIST
17066: LIST
17067: LIST
17068: ST_TO_ADDR
// if MCF_Lab ( side ) then
17069: LD_VAR 0 1
17073: PPUSH
17074: CALL 11585 0 1
17078: IFFALSE 17317
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17080: LD_VAR 0 1
17084: PPUSH
17085: CALL 11585 0 1
17089: PUSH
17090: LD_INT 1
17092: ARRAY
17093: PPUSH
17094: CALL_OW 461
17098: PUSH
17099: LD_INT 2
17101: EQUAL
17102: IFFALSE 17241
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17104: LD_VAR 0 1
17108: PPUSH
17109: CALL 11585 0 1
17113: PUSH
17114: LD_INT 1
17116: ARRAY
17117: PPUSH
17118: LD_VAR 0 2
17122: PPUSH
17123: CALL 17413 0 2
17127: IFFALSE 17154
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17129: LD_VAR 0 1
17133: PPUSH
17134: CALL 11585 0 1
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: LD_VAR 0 2
17147: PPUSH
17148: CALL_OW 124
17152: GO 17241
// if MCF_Lab ( side ) > 1 then
17154: LD_VAR 0 1
17158: PPUSH
17159: CALL 11585 0 1
17163: PUSH
17164: LD_INT 1
17166: GREATER
17167: IFFALSE 17241
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL 11585 0 1
17178: PUSH
17179: LD_INT 2
17181: ARRAY
17182: PPUSH
17183: CALL_OW 461
17187: PUSH
17188: LD_INT 2
17190: EQUAL
17191: IFFALSE 17241
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17193: LD_VAR 0 1
17197: PPUSH
17198: CALL 11585 0 1
17202: PUSH
17203: LD_INT 2
17205: ARRAY
17206: PPUSH
17207: LD_VAR 0 2
17211: PPUSH
17212: CALL 17413 0 2
17216: IFFALSE 17241
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17218: LD_VAR 0 1
17222: PPUSH
17223: CALL 11585 0 1
17227: PUSH
17228: LD_INT 2
17230: ARRAY
17231: PPUSH
17232: LD_VAR 0 2
17236: PPUSH
17237: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17241: LD_VAR 0 2
17245: PUSH
17246: LD_INT 2
17248: PUSH
17249: LD_INT 11
17251: PUSH
17252: LD_INT 4
17254: PUSH
17255: LD_INT 3
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: IN
17264: IFFALSE 17317
// begin for lab in MCF_Lab ( side ) do
17266: LD_ADDR_VAR 0 6
17270: PUSH
17271: LD_VAR 0 1
17275: PPUSH
17276: CALL 11585 0 1
17280: PUSH
17281: FOR_IN
17282: IFFALSE 17315
// if BuildingStatus ( lab ) = bs_need_ape then
17284: LD_VAR 0 6
17288: PPUSH
17289: CALL_OW 461
17293: PUSH
17294: LD_INT 10
17296: EQUAL
17297: IFFALSE 17313
// MCL_ResTame ( side , lab ) ;
17299: LD_VAR 0 1
17303: PPUSH
17304: LD_VAR 0 6
17308: PPUSH
17309: CALL 17538 0 2
17313: GO 17281
17315: POP
17316: POP
// end ; end ; end ;
17317: LD_VAR 0 3
17321: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17322: LD_INT 0
17324: PPUSH
17325: PPUSH
// tmp := [ ] ;
17326: LD_ADDR_VAR 0 3
17330: PUSH
17331: EMPTY
17332: ST_TO_ADDR
// if not lab then
17333: LD_VAR 0 1
17337: NOT
17338: IFFALSE 17350
// result := false else
17340: LD_ADDR_VAR 0 2
17344: PUSH
17345: LD_INT 0
17347: ST_TO_ADDR
17348: GO 17408
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17350: LD_ADDR_VAR 0 3
17354: PUSH
17355: LD_VAR 0 3
17359: PUSH
17360: LD_VAR 0 1
17364: PPUSH
17365: LD_INT 1
17367: PPUSH
17368: CALL_OW 268
17372: ADD
17373: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17374: LD_ADDR_VAR 0 3
17378: PUSH
17379: LD_VAR 0 3
17383: PUSH
17384: LD_VAR 0 1
17388: PPUSH
17389: LD_INT 2
17391: PPUSH
17392: CALL_OW 268
17396: ADD
17397: ST_TO_ADDR
// result := tmp ;
17398: LD_ADDR_VAR 0 2
17402: PUSH
17403: LD_VAR 0 3
17407: ST_TO_ADDR
// end ; end ;
17408: LD_VAR 0 2
17412: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17413: LD_INT 0
17415: PPUSH
17416: PPUSH
17417: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17418: LD_ADDR_VAR 0 5
17422: PUSH
17423: LD_INT 35
17425: PUSH
17426: LD_INT 45
17428: PUSH
17429: LD_INT 46
17431: PUSH
17432: LD_INT 47
17434: PUSH
17435: LD_INT 1
17437: PUSH
17438: LD_INT 2
17440: PUSH
17441: LD_INT 48
17443: PUSH
17444: LD_INT 49
17446: PUSH
17447: LD_INT 50
17449: PUSH
17450: LD_INT 20
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: LIST
17457: LIST
17458: LIST
17459: LIST
17460: LIST
17461: LIST
17462: LIST
17463: LIST
17464: ST_TO_ADDR
// if lab then
17465: LD_VAR 0 1
17469: IFFALSE 17525
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17471: LD_VAR 0 2
17475: PUSH
17476: LD_VAR 0 5
17480: IN
17481: PUSH
17482: LD_VAR 0 2
17486: PPUSH
17487: CALL_OW 481
17491: PUSH
17492: LD_VAR 0 1
17496: PPUSH
17497: CALL 17322 0 1
17501: IN
17502: OR
17503: IFFALSE 17515
// result := true else
17505: LD_ADDR_VAR 0 3
17509: PUSH
17510: LD_INT 1
17512: ST_TO_ADDR
17513: GO 17523
// result := false ;
17515: LD_ADDR_VAR 0 3
17519: PUSH
17520: LD_INT 0
17522: ST_TO_ADDR
// end else
17523: GO 17533
// result := false ;
17525: LD_ADDR_VAR 0 3
17529: PUSH
17530: LD_INT 0
17532: ST_TO_ADDR
// end ;
17533: LD_VAR 0 3
17537: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17538: LD_INT 0
17540: PPUSH
17541: PPUSH
17542: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17543: LD_ADDR_VAR 0 4
17547: PUSH
17548: LD_VAR 0 1
17552: PPUSH
17553: LD_INT 171
17555: PPUSH
17556: EMPTY
17557: PPUSH
17558: CALL 12249 0 3
17562: ST_TO_ADDR
// if not ape then
17563: LD_VAR 0 4
17567: NOT
17568: IFFALSE 17600
// if MCF_Ape ( side ) then
17570: LD_VAR 0 1
17574: PPUSH
17575: CALL 11959 0 1
17579: IFFALSE 17600
// ape := MCF_Ape ( side ) [ 1 ] ;
17581: LD_ADDR_VAR 0 4
17585: PUSH
17586: LD_VAR 0 1
17590: PPUSH
17591: CALL 11959 0 1
17595: PUSH
17596: LD_INT 1
17598: ARRAY
17599: ST_TO_ADDR
// if ape then
17600: LD_VAR 0 4
17604: IFFALSE 17655
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17606: LD_VAR 0 4
17610: PUSH
17611: LD_INT 1
17613: ARRAY
17614: PPUSH
17615: CALL_OW 310
17619: PUSH
17620: LD_VAR 0 4
17624: PUSH
17625: LD_INT 1
17627: ARRAY
17628: PPUSH
17629: CALL_OW 310
17633: PUSH
17634: LD_VAR 0 2
17638: NONEQUAL
17639: AND
17640: IFFALSE 17655
// ComExitBuilding ( ape [ 1 ] ) ;
17642: LD_VAR 0 4
17646: PUSH
17647: LD_INT 1
17649: ARRAY
17650: PPUSH
17651: CALL_OW 122
// if not lab then
17655: LD_VAR 0 2
17659: NOT
17660: IFFALSE 17666
// exit else
17662: GO 17814
17664: GO 17774
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17666: LD_VAR 0 1
17670: PPUSH
17671: LD_INT 16
17673: PPUSH
17674: LD_INT 25
17676: PUSH
17677: LD_INT 4
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PPUSH
17684: CALL 12249 0 3
17688: PUSH
17689: LD_INT 0
17691: EQUAL
17692: PUSH
17693: LD_VAR 0 2
17697: PPUSH
17698: CALL_OW 313
17702: PUSH
17703: LD_INT 6
17705: EQUAL
17706: AND
17707: IFFALSE 17774
// begin tmp := UnitsInside ( lab ) ;
17709: LD_ADDR_VAR 0 5
17713: PUSH
17714: LD_VAR 0 2
17718: PPUSH
17719: CALL_OW 313
17723: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17724: LD_VAR 0 5
17728: PUSH
17729: LD_VAR 0 5
17733: ARRAY
17734: PPUSH
17735: LD_INT 16
17737: PPUSH
17738: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17742: LD_VAR 0 5
17746: PUSH
17747: LD_VAR 0 5
17751: ARRAY
17752: PPUSH
17753: CALL_OW 310
17757: IFFALSE 17774
// ComExitBuilding ( tmp [ tmp ] ) ;
17759: LD_VAR 0 5
17763: PUSH
17764: LD_VAR 0 5
17768: ARRAY
17769: PPUSH
17770: CALL_OW 122
// end ; if ape then
17774: LD_VAR 0 4
17778: IFFALSE 17814
// if not IsInUnit ( ape [ 1 ] ) then
17780: LD_VAR 0 4
17784: PUSH
17785: LD_INT 1
17787: ARRAY
17788: PPUSH
17789: CALL_OW 310
17793: NOT
17794: IFFALSE 17814
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17796: LD_VAR 0 4
17800: PUSH
17801: LD_INT 1
17803: ARRAY
17804: PPUSH
17805: LD_VAR 0 2
17809: PPUSH
17810: CALL_OW 120
// end ;
17814: LD_VAR 0 3
17818: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17819: LD_INT 0
17821: PPUSH
17822: PPUSH
17823: PPUSH
// result := false ;
17824: LD_ADDR_VAR 0 2
17828: PUSH
17829: LD_INT 0
17831: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17832: LD_ADDR_VAR 0 3
17836: PUSH
17837: LD_VAR 0 1
17841: PPUSH
17842: CALL 17929 0 1
17846: ST_TO_ADDR
// if techs then
17847: LD_VAR 0 3
17851: IFFALSE 17881
// if techs [ 2 ] then
17853: LD_VAR 0 3
17857: PUSH
17858: LD_INT 2
17860: ARRAY
17861: IFFALSE 17873
// result := true else
17863: LD_ADDR_VAR 0 2
17867: PUSH
17868: LD_INT 1
17870: ST_TO_ADDR
17871: GO 17881
// result := false ;
17873: LD_ADDR_VAR 0 2
17877: PUSH
17878: LD_INT 0
17880: ST_TO_ADDR
// end ;
17881: LD_VAR 0 2
17885: RET
// export function MCL_Start ( side ) ; var i ; begin
17886: LD_INT 0
17888: PPUSH
17889: PPUSH
// if MCL_GetTechList ( side ) then
17890: LD_VAR 0 1
17894: PPUSH
17895: CALL 17929 0 1
17899: IFFALSE 17924
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17901: LD_VAR 0 1
17905: PPUSH
17906: LD_VAR 0 1
17910: PPUSH
17911: CALL 17929 0 1
17915: PUSH
17916: LD_INT 1
17918: ARRAY
17919: PPUSH
17920: CALL 17016 0 2
// end ;
17924: LD_VAR 0 2
17928: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17929: LD_INT 0
17931: PPUSH
17932: PPUSH
17933: PPUSH
// if MREG_ToRes then
17934: LD_EXP 50
17938: IFFALSE 18023
// for i = 1 to MREG_ToRes do
17940: LD_ADDR_VAR 0 3
17944: PUSH
17945: DOUBLE
17946: LD_INT 1
17948: DEC
17949: ST_TO_ADDR
17950: LD_EXP 50
17954: PUSH
17955: FOR_TO
17956: IFFALSE 18021
// if MREG_ToRes [ i ] [ 1 ] = side then
17958: LD_EXP 50
17962: PUSH
17963: LD_VAR 0 3
17967: ARRAY
17968: PUSH
17969: LD_INT 1
17971: ARRAY
17972: PUSH
17973: LD_VAR 0 1
17977: EQUAL
17978: IFFALSE 18019
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17980: LD_ADDR_VAR 0 4
17984: PUSH
17985: LD_VAR 0 4
17989: PPUSH
17990: LD_VAR 0 4
17994: PUSH
17995: LD_INT 1
17997: PLUS
17998: PPUSH
17999: LD_EXP 50
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 2
18012: ARRAY
18013: PPUSH
18014: CALL_OW 1
18018: ST_TO_ADDR
// end ;
18019: GO 17955
18021: POP
18022: POP
// result := techs ;
18023: LD_ADDR_VAR 0 2
18027: PUSH
18028: LD_VAR 0 4
18032: ST_TO_ADDR
// end ;
18033: LD_VAR 0 2
18037: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18038: LD_INT 0
18040: PPUSH
18041: PPUSH
// for i = 1 to tech_list do
18042: LD_ADDR_VAR 0 4
18046: PUSH
18047: DOUBLE
18048: LD_INT 1
18050: DEC
18051: ST_TO_ADDR
18052: LD_VAR 0 2
18056: PUSH
18057: FOR_TO
18058: IFFALSE 18112
// if not tech_list [ i ] = 20 then
18060: LD_VAR 0 2
18064: PUSH
18065: LD_VAR 0 4
18069: ARRAY
18070: PUSH
18071: LD_INT 20
18073: EQUAL
18074: NOT
18075: IFFALSE 18110
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18077: LD_ADDR_EXP 50
18081: PUSH
18082: LD_EXP 50
18086: PPUSH
18087: LD_VAR 0 1
18091: PPUSH
18092: LD_VAR 0 2
18096: PUSH
18097: LD_VAR 0 4
18101: ARRAY
18102: PPUSH
18103: EMPTY
18104: PPUSH
18105: CALL 41841 0 4
18109: ST_TO_ADDR
18110: GO 18057
18112: POP
18113: POP
// result := true ;
18114: LD_ADDR_VAR 0 3
18118: PUSH
18119: LD_INT 1
18121: ST_TO_ADDR
// end ;
18122: LD_VAR 0 3
18126: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18127: LD_INT 0
18129: PPUSH
18130: PPUSH
// for i = MREG_ToRes downto 1 do
18131: LD_ADDR_VAR 0 3
18135: PUSH
18136: DOUBLE
18137: LD_EXP 50
18141: INC
18142: ST_TO_ADDR
18143: LD_INT 1
18145: PUSH
18146: FOR_DOWNTO
18147: IFFALSE 18193
// if MREG_ToRes [ i ] [ 1 ] = side then
18149: LD_EXP 50
18153: PUSH
18154: LD_VAR 0 3
18158: ARRAY
18159: PUSH
18160: LD_INT 1
18162: ARRAY
18163: PUSH
18164: LD_VAR 0 1
18168: EQUAL
18169: IFFALSE 18191
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18171: LD_ADDR_EXP 50
18175: PUSH
18176: LD_EXP 50
18180: PPUSH
18181: LD_VAR 0 3
18185: PPUSH
18186: CALL_OW 3
18190: ST_TO_ADDR
18191: GO 18146
18193: POP
18194: POP
// result := true ;
18195: LD_ADDR_VAR 0 2
18199: PUSH
18200: LD_INT 1
18202: ST_TO_ADDR
// end ;
18203: LD_VAR 0 2
18207: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18208: LD_INT 0
18210: PPUSH
// result := GetTechProgress ( side , tech ) ;
18211: LD_ADDR_VAR 0 3
18215: PUSH
18216: LD_VAR 0 1
18220: PPUSH
18221: LD_VAR 0 2
18225: PPUSH
18226: CALL_OW 326
18230: ST_TO_ADDR
// end ;
18231: LD_VAR 0 3
18235: RET
// export function MCL_Require ( tech ) ; begin
18236: LD_INT 0
18238: PPUSH
// result := GetTechTechsReq ( tech ) ;
18239: LD_ADDR_VAR 0 2
18243: PUSH
18244: LD_VAR 0 1
18248: PPUSH
18249: CALL_OW 480
18253: ST_TO_ADDR
// end ; end_of_file
18254: LD_VAR 0 2
18258: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18259: LD_INT 0
18261: PPUSH
18262: PPUSH
18263: PPUSH
// uc_side := 0 ;
18264: LD_ADDR_OWVAR 20
18268: PUSH
18269: LD_INT 0
18271: ST_TO_ADDR
// uc_nation := 0 ;
18272: LD_ADDR_OWVAR 21
18276: PUSH
18277: LD_INT 0
18279: ST_TO_ADDR
// for i = 1 to n do
18280: LD_ADDR_VAR 0 5
18284: PUSH
18285: DOUBLE
18286: LD_INT 1
18288: DEC
18289: ST_TO_ADDR
18290: LD_VAR 0 2
18294: PUSH
18295: FOR_TO
18296: IFFALSE 18441
// begin hc_importance := 0 ;
18298: LD_ADDR_OWVAR 32
18302: PUSH
18303: LD_INT 0
18305: ST_TO_ADDR
// hc_gallery :=  ;
18306: LD_ADDR_OWVAR 33
18310: PUSH
18311: LD_STRING 
18313: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18314: LD_ADDR_OWVAR 35
18318: PUSH
18319: LD_VAR 0 3
18323: PUSH
18324: LD_INT 20
18326: MINUS
18327: PPUSH
18328: LD_VAR 0 3
18332: PUSH
18333: LD_INT 20
18335: PLUS
18336: PPUSH
18337: CALL_OW 12
18341: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18342: LD_ADDR_OWVAR 31
18346: PUSH
18347: LD_INT 0
18349: PPUSH
18350: LD_INT 2
18352: PPUSH
18353: CALL_OW 12
18357: PUSH
18358: LD_INT 0
18360: PUSH
18361: LD_INT 0
18363: PUSH
18364: LD_INT 0
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: LIST
18371: LIST
18372: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18373: LD_ADDR_OWVAR 30
18377: PUSH
18378: LD_INT 0
18380: PUSH
18381: LD_INT 0
18383: PUSH
18384: LD_INT 0
18386: PUSH
18387: LD_INT 0
18389: PUSH
18390: EMPTY
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: ST_TO_ADDR
// hc_name :=  ;
18396: LD_ADDR_OWVAR 26
18400: PUSH
18401: LD_STRING 
18403: ST_TO_ADDR
// hc_class := class_apeman ;
18404: LD_ADDR_OWVAR 28
18408: PUSH
18409: LD_INT 12
18411: ST_TO_ADDR
// ape := CreateHuman ;
18412: LD_ADDR_VAR 0 6
18416: PUSH
18417: CALL_OW 44
18421: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18422: LD_VAR 0 6
18426: PPUSH
18427: LD_VAR 0 1
18431: PPUSH
18432: LD_INT 0
18434: PPUSH
18435: CALL_OW 49
// end ;
18439: GO 18295
18441: POP
18442: POP
// end ;
18443: LD_VAR 0 4
18447: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18448: LD_INT 0
18450: PPUSH
18451: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18452: LD_VAR 0 1
18456: PPUSH
18457: CALL 11959 0 1
18461: PUSH
18462: LD_EXP 37
18466: PUSH
18467: LD_VAR 0 1
18471: ARRAY
18472: GREATEREQUAL
18473: IFFALSE 18650
// begin if GetTag ( unit ) = 17 then
18475: LD_VAR 0 2
18479: PPUSH
18480: CALL_OW 110
18484: PUSH
18485: LD_INT 17
18487: EQUAL
18488: IFFALSE 18648
// begin SetTag ( unit , 0 ) ;
18490: LD_VAR 0 2
18494: PPUSH
18495: LD_INT 0
18497: PPUSH
18498: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18502: LD_VAR 0 1
18506: PPUSH
18507: CALL 11585 0 1
18511: PUSH
18512: LD_VAR 0 1
18516: PPUSH
18517: CALL 17929 0 1
18521: NOT
18522: AND
18523: IFFALSE 18548
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18525: LD_VAR 0 2
18529: PPUSH
18530: LD_VAR 0 1
18534: PPUSH
18535: CALL 11585 0 1
18539: PUSH
18540: LD_INT 1
18542: ARRAY
18543: PPUSH
18544: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18548: LD_VAR 0 1
18552: PPUSH
18553: CALL 11585 0 1
18557: NOT
18558: PUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: LD_INT 30
18566: PUSH
18567: LD_INT 1
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: PPUSH
18574: CALL 11546 0 2
18578: AND
18579: IFFALSE 18648
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18581: LD_VAR 0 2
18585: PPUSH
18586: LD_VAR 0 1
18590: PPUSH
18591: LD_INT 30
18593: PUSH
18594: LD_INT 1
18596: PUSH
18597: EMPTY
18598: LIST
18599: LIST
18600: PPUSH
18601: CALL 11546 0 2
18605: PUSH
18606: LD_INT 1
18608: ARRAY
18609: PPUSH
18610: CALL_OW 250
18614: PPUSH
18615: LD_VAR 0 1
18619: PPUSH
18620: LD_INT 30
18622: PUSH
18623: LD_INT 1
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: PPUSH
18630: CALL 11546 0 2
18634: PUSH
18635: LD_INT 1
18637: ARRAY
18638: PPUSH
18639: CALL_OW 251
18643: PPUSH
18644: CALL_OW 111
// end ; end else
18648: GO 18834
// if GetClass ( unit ) <> 4 then
18650: LD_VAR 0 2
18654: PPUSH
18655: CALL_OW 257
18659: PUSH
18660: LD_INT 4
18662: NONEQUAL
18663: IFFALSE 18669
// exit else
18665: GO 18834
18667: GO 18834
// if GetTag ( unit ) = 0 then
18669: LD_VAR 0 2
18673: PPUSH
18674: CALL_OW 110
18678: PUSH
18679: LD_INT 0
18681: EQUAL
18682: IFFALSE 18698
// SetTag ( unit , 17 ) else
18684: LD_VAR 0 2
18688: PPUSH
18689: LD_INT 17
18691: PPUSH
18692: CALL_OW 109
18696: GO 18834
// begin if IsInUnit ( unit ) then
18698: LD_VAR 0 2
18702: PPUSH
18703: CALL_OW 310
18707: IFFALSE 18718
// ComExitBuilding ( unit ) ;
18709: LD_VAR 0 2
18713: PPUSH
18714: CALL_OW 122
// Wait ( 1 ) ;
18718: LD_INT 1
18720: PPUSH
18721: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18725: LD_ADDR_VAR 0 4
18729: PUSH
18730: LD_INT 22
18732: PUSH
18733: LD_INT 0
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: PUSH
18740: LD_INT 25
18742: PUSH
18743: LD_INT 12
18745: PUSH
18746: EMPTY
18747: LIST
18748: LIST
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: PPUSH
18754: CALL_OW 69
18758: PPUSH
18759: LD_VAR 0 2
18763: PPUSH
18764: CALL_OW 74
18768: ST_TO_ADDR
// if not ape then
18769: LD_VAR 0 4
18773: NOT
18774: IFFALSE 18780
// exit else
18776: GO 18834
18778: GO 18789
// ComHold ( ape ) ;
18780: LD_VAR 0 4
18784: PPUSH
18785: CALL_OW 140
// if not HasTask ( unit ) then
18789: LD_VAR 0 2
18793: PPUSH
18794: CALL_OW 314
18798: NOT
18799: IFFALSE 18832
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18801: LD_VAR 0 2
18805: PPUSH
18806: LD_VAR 0 4
18810: PPUSH
18811: CALL_OW 250
18815: PPUSH
18816: LD_VAR 0 4
18820: PPUSH
18821: CALL_OW 251
18825: PPUSH
18826: CALL_OW 131
18830: GO 18834
// exit ;
18832: GO 18834
// end ; end ;
18834: LD_VAR 0 3
18838: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18839: LD_INT 0
18841: PPUSH
18842: PPUSH
18843: PPUSH
18844: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18845: LD_ADDR_VAR 0 4
18849: PUSH
18850: LD_EXP 38
18854: PUSH
18855: LD_VAR 0 1
18859: ARRAY
18860: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18861: LD_ADDR_VAR 0 5
18865: PUSH
18866: LD_VAR 0 1
18870: PPUSH
18871: LD_STRING normal
18873: PPUSH
18874: CALL 12043 0 2
18878: ST_TO_ADDR
// if apes then
18879: LD_VAR 0 5
18883: IFFALSE 19111
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18885: LD_INT 2
18887: PPUSH
18888: LD_VAR 0 1
18892: PPUSH
18893: CALL_OW 321
18897: PUSH
18898: LD_INT 2
18900: EQUAL
18901: PUSH
18902: LD_VAR 0 4
18906: PUSH
18907: LD_INT 2
18909: ARRAY
18910: PUSH
18911: LD_INT 1
18913: EQUAL
18914: AND
18915: PUSH
18916: LD_VAR 0 1
18920: PPUSH
18921: LD_STRING engineer
18923: PPUSH
18924: CALL 12043 0 2
18928: PUSH
18929: LD_INT 3
18931: LESS
18932: AND
18933: PUSH
18934: LD_VAR 0 1
18938: PPUSH
18939: LD_INT 30
18941: PUSH
18942: LD_INT 1
18944: PUSH
18945: EMPTY
18946: LIST
18947: LIST
18948: PPUSH
18949: CALL 11546 0 2
18953: AND
18954: IFFALSE 19008
// begin for i in apes do
18956: LD_ADDR_VAR 0 3
18960: PUSH
18961: LD_VAR 0 5
18965: PUSH
18966: FOR_IN
18967: IFFALSE 19004
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18969: LD_VAR 0 3
18973: PPUSH
18974: LD_VAR 0 1
18978: PPUSH
18979: LD_INT 30
18981: PUSH
18982: LD_INT 1
18984: PUSH
18985: EMPTY
18986: LIST
18987: LIST
18988: PPUSH
18989: CALL 11546 0 2
18993: PUSH
18994: LD_INT 1
18996: ARRAY
18997: PPUSH
18998: CALL_OW 120
// end ;
19002: GO 18966
19004: POP
19005: POP
// end else
19006: GO 19111
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19008: LD_INT 11
19010: PPUSH
19011: LD_VAR 0 1
19015: PPUSH
19016: CALL_OW 321
19020: PUSH
19021: LD_INT 2
19023: EQUAL
19024: PUSH
19025: LD_VAR 0 4
19029: PUSH
19030: LD_INT 1
19032: ARRAY
19033: PUSH
19034: LD_INT 1
19036: EQUAL
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 5
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11546 0 2
19058: AND
19059: IFFALSE 19111
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 5
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11546 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end ; end ; end ; end_of_file
19111: LD_VAR 0 2
19115: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19116: LD_INT 0
19118: PPUSH
19119: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19120: LD_VAR 0 1
19124: PPUSH
19125: CALL_OW 257
19129: PUSH
19130: LD_INT 4
19132: EQUAL
19133: NOT
19134: PUSH
19135: LD_VAR 0 2
19139: NOT
19140: OR
19141: IFFALSE 19147
// exit else
19143: GO 19181
19145: GO 19181
// if not GetTag ( unit ) = 4 then
19147: LD_VAR 0 1
19151: PPUSH
19152: CALL_OW 110
19156: PUSH
19157: LD_INT 4
19159: EQUAL
19160: NOT
19161: IFFALSE 19167
// exit else
19163: GO 19181
19165: GO 19181
// ComHeal ( unit , target ) ;
19167: LD_VAR 0 1
19171: PPUSH
19172: LD_VAR 0 2
19176: PPUSH
19177: CALL_OW 128
// end ;
19181: LD_VAR 0 3
19185: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19186: LD_INT 0
19188: PPUSH
19189: PPUSH
19190: PPUSH
19191: PPUSH
19192: PPUSH
19193: PPUSH
19194: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19195: LD_ADDR_VAR 0 5
19199: PUSH
19200: LD_INT 22
19202: PUSH
19203: LD_VAR 0 1
19207: PUSH
19208: EMPTY
19209: LIST
19210: LIST
19211: PUSH
19212: LD_INT 21
19214: PUSH
19215: LD_INT 1
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: PUSH
19222: LD_INT 3
19224: PUSH
19225: LD_INT 55
19227: PUSH
19228: EMPTY
19229: LIST
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: PUSH
19235: LD_INT 3
19237: PUSH
19238: LD_INT 54
19240: PUSH
19241: EMPTY
19242: LIST
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: PUSH
19248: LD_INT 3
19250: PUSH
19251: LD_INT 24
19253: PUSH
19254: LD_INT 1000
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19277: LD_ADDR_VAR 0 8
19281: PUSH
19282: LD_VAR 0 1
19286: PPUSH
19287: LD_INT 30
19289: PUSH
19290: LD_INT 1
19292: PUSH
19293: EMPTY
19294: LIST
19295: LIST
19296: PPUSH
19297: CALL 11546 0 2
19301: ST_TO_ADDR
// r := [ ] ;
19302: LD_ADDR_VAR 0 6
19306: PUSH
19307: EMPTY
19308: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19309: LD_VAR 0 1
19313: PPUSH
19314: LD_INT 5
19316: PPUSH
19317: EMPTY
19318: PPUSH
19319: CALL 12249 0 3
19323: IFFALSE 19379
// for j in MCF_Tag ( side , 5 , [ ] ) do
19325: LD_ADDR_VAR 0 4
19329: PUSH
19330: LD_VAR 0 1
19334: PPUSH
19335: LD_INT 5
19337: PPUSH
19338: EMPTY
19339: PPUSH
19340: CALL 12249 0 3
19344: PUSH
19345: FOR_IN
19346: IFFALSE 19377
// if GetLives ( j ) = 1000 then
19348: LD_VAR 0 4
19352: PPUSH
19353: CALL_OW 256
19357: PUSH
19358: LD_INT 1000
19360: EQUAL
19361: IFFALSE 19375
// SetTag ( j , 0 ) ;
19363: LD_VAR 0 4
19367: PPUSH
19368: LD_INT 0
19370: PPUSH
19371: CALL_OW 109
19375: GO 19345
19377: POP
19378: POP
// if tmp then
19379: LD_VAR 0 5
19383: IFFALSE 19712
// begin r := [ tmp [ 1 ] ] ;
19385: LD_ADDR_VAR 0 6
19389: PUSH
19390: LD_VAR 0 5
19394: PUSH
19395: LD_INT 1
19397: ARRAY
19398: PUSH
19399: EMPTY
19400: LIST
19401: ST_TO_ADDR
// for i = 2 to tmp do
19402: LD_ADDR_VAR 0 3
19406: PUSH
19407: DOUBLE
19408: LD_INT 2
19410: DEC
19411: ST_TO_ADDR
19412: LD_VAR 0 5
19416: PUSH
19417: FOR_TO
19418: IFFALSE 19710
// begin m := false ;
19420: LD_ADDR_VAR 0 7
19424: PUSH
19425: LD_INT 0
19427: ST_TO_ADDR
// if d then
19428: LD_VAR 0 8
19432: IFFALSE 19587
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19434: LD_VAR 0 5
19438: PUSH
19439: LD_VAR 0 3
19443: ARRAY
19444: PPUSH
19445: CALL_OW 256
19449: PUSH
19450: LD_INT 650
19452: LESS
19453: PUSH
19454: LD_VAR 0 5
19458: PUSH
19459: LD_VAR 0 3
19463: ARRAY
19464: PPUSH
19465: LD_VAR 0 8
19469: PUSH
19470: LD_INT 1
19472: ARRAY
19473: PPUSH
19474: CALL_OW 250
19478: PPUSH
19479: LD_VAR 0 8
19483: PUSH
19484: LD_INT 1
19486: ARRAY
19487: PPUSH
19488: CALL_OW 251
19492: PPUSH
19493: CALL_OW 297
19497: PUSH
19498: LD_INT 10
19500: GREATER
19501: AND
19502: IFFALSE 19587
// begin if not GetTag ( tmp [ i ] ) = 5 then
19504: LD_VAR 0 5
19508: PUSH
19509: LD_VAR 0 3
19513: ARRAY
19514: PPUSH
19515: CALL_OW 110
19519: PUSH
19520: LD_INT 5
19522: EQUAL
19523: NOT
19524: IFFALSE 19544
// SetTag ( tmp [ i ] , 5 ) ;
19526: LD_VAR 0 5
19530: PUSH
19531: LD_VAR 0 3
19535: ARRAY
19536: PPUSH
19537: LD_INT 5
19539: PPUSH
19540: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19544: LD_VAR 0 5
19548: PUSH
19549: LD_VAR 0 3
19553: ARRAY
19554: PPUSH
19555: LD_VAR 0 8
19559: PUSH
19560: LD_INT 1
19562: ARRAY
19563: PPUSH
19564: CALL_OW 250
19568: PPUSH
19569: LD_VAR 0 8
19573: PUSH
19574: LD_INT 1
19576: ARRAY
19577: PPUSH
19578: CALL_OW 251
19582: PPUSH
19583: CALL_OW 111
// end ; for j = 1 to r do
19587: LD_ADDR_VAR 0 4
19591: PUSH
19592: DOUBLE
19593: LD_INT 1
19595: DEC
19596: ST_TO_ADDR
19597: LD_VAR 0 6
19601: PUSH
19602: FOR_TO
19603: IFFALSE 19677
// if GetLives ( tmp [ i ] ) < r [ j ] then
19605: LD_VAR 0 5
19609: PUSH
19610: LD_VAR 0 3
19614: ARRAY
19615: PPUSH
19616: CALL_OW 256
19620: PUSH
19621: LD_VAR 0 6
19625: PUSH
19626: LD_VAR 0 4
19630: ARRAY
19631: LESS
19632: IFFALSE 19675
// begin r := Insert ( r , j , tmp [ i ] ) ;
19634: LD_ADDR_VAR 0 6
19638: PUSH
19639: LD_VAR 0 6
19643: PPUSH
19644: LD_VAR 0 4
19648: PPUSH
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: CALL_OW 2
19664: ST_TO_ADDR
// m := true ;
19665: LD_ADDR_VAR 0 7
19669: PUSH
19670: LD_INT 1
19672: ST_TO_ADDR
// break ;
19673: GO 19677
// end ;
19675: GO 19602
19677: POP
19678: POP
// if not m then
19679: LD_VAR 0 7
19683: NOT
19684: IFFALSE 19708
// r := r ^ tmp [ i ] ;
19686: LD_ADDR_VAR 0 6
19690: PUSH
19691: LD_VAR 0 6
19695: PUSH
19696: LD_VAR 0 5
19700: PUSH
19701: LD_VAR 0 3
19705: ARRAY
19706: ADD
19707: ST_TO_ADDR
// end ;
19708: GO 19417
19710: POP
19711: POP
// end ; result := r end ; end_of_file
19712: LD_ADDR_VAR 0 2
19716: PUSH
19717: LD_VAR 0 6
19721: ST_TO_ADDR
19722: LD_VAR 0 2
19726: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19727: LD_INT 0
19729: PPUSH
19730: PPUSH
19731: PPUSH
// pom := GetBase ( bdepot ) ;
19732: LD_ADDR_VAR 0 3
19736: PUSH
19737: LD_VAR 0 1
19741: PPUSH
19742: CALL_OW 274
19746: ST_TO_ADDR
// sor := [ ] ;
19747: LD_ADDR_VAR 0 4
19751: PUSH
19752: EMPTY
19753: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19754: LD_ADDR_VAR 0 4
19758: PUSH
19759: LD_VAR 0 4
19763: PUSH
19764: LD_VAR 0 3
19768: PPUSH
19769: LD_INT 1
19771: PPUSH
19772: CALL_OW 275
19776: ADD
19777: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19778: LD_ADDR_VAR 0 4
19782: PUSH
19783: LD_VAR 0 4
19787: PUSH
19788: LD_VAR 0 3
19792: PPUSH
19793: LD_INT 2
19795: PPUSH
19796: CALL_OW 275
19800: ADD
19801: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19802: LD_ADDR_VAR 0 4
19806: PUSH
19807: LD_VAR 0 4
19811: PUSH
19812: LD_VAR 0 3
19816: PPUSH
19817: LD_INT 3
19819: PPUSH
19820: CALL_OW 275
19824: ADD
19825: ST_TO_ADDR
// result := sor ;
19826: LD_ADDR_VAR 0 2
19830: PUSH
19831: LD_VAR 0 4
19835: ST_TO_ADDR
// end ;
19836: LD_VAR 0 2
19840: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19841: LD_INT 0
19843: PPUSH
19844: PPUSH
// while ( coord_list ) do
19845: LD_VAR 0 3
19849: IFFALSE 20023
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19851: LD_ADDR_EXP 46
19855: PUSH
19856: LD_EXP 46
19860: PPUSH
19861: LD_VAR 0 1
19865: PPUSH
19866: LD_VAR 0 2
19870: PPUSH
19871: LD_VAR 0 3
19875: PUSH
19876: LD_INT 1
19878: ARRAY
19879: PUSH
19880: LD_VAR 0 3
19884: PUSH
19885: LD_INT 2
19887: ARRAY
19888: PUSH
19889: LD_VAR 0 3
19893: PUSH
19894: LD_INT 3
19896: ARRAY
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: LIST
19902: PPUSH
19903: CALL 41841 0 4
19907: ST_TO_ADDR
// if weapon_list then
19908: LD_VAR 0 4
19912: IFFALSE 19983
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19914: LD_ADDR_EXP 43
19918: PUSH
19919: LD_EXP 43
19923: PPUSH
19924: LD_VAR 0 1
19928: PPUSH
19929: LD_VAR 0 4
19933: PUSH
19934: LD_INT 1
19936: ARRAY
19937: PPUSH
19938: LD_VAR 0 3
19942: PUSH
19943: LD_INT 1
19945: ARRAY
19946: PUSH
19947: LD_VAR 0 3
19951: PUSH
19952: LD_INT 2
19954: ARRAY
19955: PUSH
19956: EMPTY
19957: LIST
19958: LIST
19959: PPUSH
19960: CALL 41841 0 4
19964: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19965: LD_ADDR_VAR 0 4
19969: PUSH
19970: LD_VAR 0 4
19974: PPUSH
19975: LD_INT 1
19977: PPUSH
19978: CALL_OW 3
19982: ST_TO_ADDR
// end ; for i = 1 to 3 do
19983: LD_ADDR_VAR 0 6
19987: PUSH
19988: DOUBLE
19989: LD_INT 1
19991: DEC
19992: ST_TO_ADDR
19993: LD_INT 3
19995: PUSH
19996: FOR_TO
19997: IFFALSE 20019
// coord_list := Delete ( coord_list , 1 ) ;
19999: LD_ADDR_VAR 0 3
20003: PUSH
20004: LD_VAR 0 3
20008: PPUSH
20009: LD_INT 1
20011: PPUSH
20012: CALL_OW 3
20016: ST_TO_ADDR
20017: GO 19996
20019: POP
20020: POP
// end ;
20021: GO 19845
// result := true ;
20023: LD_ADDR_VAR 0 5
20027: PUSH
20028: LD_INT 1
20030: ST_TO_ADDR
// end ;
20031: LD_VAR 0 5
20035: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20036: LD_INT 0
20038: PPUSH
20039: PPUSH
// if not weapon_list then
20040: LD_VAR 0 3
20044: NOT
20045: IFFALSE 20049
// exit ;
20047: GO 20164
// while ( coord_list ) do
20049: LD_VAR 0 2
20053: IFFALSE 20164
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20055: LD_ADDR_EXP 43
20059: PUSH
20060: LD_EXP 43
20064: PPUSH
20065: LD_VAR 0 1
20069: PPUSH
20070: LD_VAR 0 3
20074: PUSH
20075: LD_INT 1
20077: ARRAY
20078: PPUSH
20079: LD_VAR 0 2
20083: PUSH
20084: LD_INT 1
20086: ARRAY
20087: PUSH
20088: LD_VAR 0 2
20092: PUSH
20093: LD_INT 2
20095: ARRAY
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: PPUSH
20101: CALL 41841 0 4
20105: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20106: LD_ADDR_VAR 0 3
20110: PUSH
20111: LD_VAR 0 3
20115: PPUSH
20116: LD_INT 1
20118: PPUSH
20119: CALL_OW 3
20123: ST_TO_ADDR
// for i = 1 to 2 do
20124: LD_ADDR_VAR 0 5
20128: PUSH
20129: DOUBLE
20130: LD_INT 1
20132: DEC
20133: ST_TO_ADDR
20134: LD_INT 2
20136: PUSH
20137: FOR_TO
20138: IFFALSE 20160
// coord_list := Delete ( coord_list , 1 ) ;
20140: LD_ADDR_VAR 0 2
20144: PUSH
20145: LD_VAR 0 2
20149: PPUSH
20150: LD_INT 1
20152: PPUSH
20153: CALL_OW 3
20157: ST_TO_ADDR
20158: GO 20137
20160: POP
20161: POP
// end ;
20162: GO 20049
// end ;
20164: LD_VAR 0 4
20168: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20169: LD_INT 0
20171: PPUSH
20172: PPUSH
// while ( coord_list ) do
20173: LD_VAR 0 2
20177: IFFALSE 20332
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20179: LD_VAR 0 2
20183: PUSH
20184: LD_INT 1
20186: ARRAY
20187: PPUSH
20188: LD_VAR 0 2
20192: PUSH
20193: LD_INT 2
20195: ARRAY
20196: PPUSH
20197: CALL_OW 428
20201: IFFALSE 20292
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20203: LD_VAR 0 2
20207: PUSH
20208: LD_INT 1
20210: ARRAY
20211: PPUSH
20212: LD_VAR 0 2
20216: PUSH
20217: LD_INT 2
20219: ARRAY
20220: PPUSH
20221: CALL_OW 428
20225: PPUSH
20226: CALL_OW 266
20230: PUSH
20231: LD_INT 31
20233: PUSH
20234: LD_INT 32
20236: PUSH
20237: LD_INT 33
20239: PUSH
20240: EMPTY
20241: LIST
20242: LIST
20243: LIST
20244: IN
20245: IFFALSE 20292
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20247: LD_ADDR_EXP 52
20251: PUSH
20252: LD_EXP 52
20256: PPUSH
20257: LD_VAR 0 1
20261: PPUSH
20262: LD_VAR 0 2
20266: PUSH
20267: LD_INT 1
20269: ARRAY
20270: PPUSH
20271: LD_VAR 0 2
20275: PUSH
20276: LD_INT 2
20278: ARRAY
20279: PPUSH
20280: CALL_OW 428
20284: PPUSH
20285: EMPTY
20286: PPUSH
20287: CALL 41841 0 4
20291: ST_TO_ADDR
// for i = 1 to 3 do
20292: LD_ADDR_VAR 0 4
20296: PUSH
20297: DOUBLE
20298: LD_INT 1
20300: DEC
20301: ST_TO_ADDR
20302: LD_INT 3
20304: PUSH
20305: FOR_TO
20306: IFFALSE 20328
// coord_list := Delete ( coord_list , 1 ) ;
20308: LD_ADDR_VAR 0 2
20312: PUSH
20313: LD_VAR 0 2
20317: PPUSH
20318: LD_INT 1
20320: PPUSH
20321: CALL_OW 3
20325: ST_TO_ADDR
20326: GO 20305
20328: POP
20329: POP
// end ;
20330: GO 20173
// result := true ;
20332: LD_ADDR_VAR 0 3
20336: PUSH
20337: LD_INT 1
20339: ST_TO_ADDR
// end ;
20340: LD_VAR 0 3
20344: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20345: LD_INT 0
20347: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20348: LD_ADDR_EXP 46
20352: PUSH
20353: LD_EXP 46
20357: PPUSH
20358: LD_VAR 0 1
20362: PPUSH
20363: LD_INT 0
20365: PPUSH
20366: LD_VAR 0 2
20370: PPUSH
20371: CALL 41841 0 4
20375: ST_TO_ADDR
// end ;
20376: LD_VAR 0 3
20380: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20381: LD_INT 0
20383: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20384: LD_ADDR_EXP 46
20388: PUSH
20389: LD_EXP 46
20393: PPUSH
20394: LD_VAR 0 1
20398: PPUSH
20399: LD_INT 6
20401: PPUSH
20402: LD_VAR 0 2
20406: PPUSH
20407: CALL 41841 0 4
20411: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20412: LD_ADDR_EXP 49
20416: PUSH
20417: LD_EXP 49
20421: PPUSH
20422: LD_VAR 0 1
20426: PPUSH
20427: LD_VAR 0 3
20431: PUSH
20432: LD_INT 1
20434: ARRAY
20435: PPUSH
20436: LD_VAR 0 3
20440: PUSH
20441: LD_INT 2
20443: ARRAY
20444: PPUSH
20445: CALL 41841 0 4
20449: ST_TO_ADDR
// end ;
20450: LD_VAR 0 4
20454: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20455: LD_INT 0
20457: PPUSH
20458: PPUSH
// if ext_list > 5 then
20459: LD_VAR 0 3
20463: PUSH
20464: LD_INT 5
20466: GREATER
20467: IFFALSE 20511
// for i = 6 to ext_list do
20469: LD_ADDR_VAR 0 5
20473: PUSH
20474: DOUBLE
20475: LD_INT 6
20477: DEC
20478: ST_TO_ADDR
20479: LD_VAR 0 3
20483: PUSH
20484: FOR_TO
20485: IFFALSE 20509
// ext_list := Delete ( ext_list , ext_list ) ;
20487: LD_ADDR_VAR 0 3
20491: PUSH
20492: LD_VAR 0 3
20496: PPUSH
20497: LD_VAR 0 3
20501: PPUSH
20502: CALL_OW 3
20506: ST_TO_ADDR
20507: GO 20484
20509: POP
20510: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20511: LD_VAR 0 1
20515: PPUSH
20516: LD_VAR 0 2
20520: PUSH
20521: LD_INT 1
20523: ARRAY
20524: PPUSH
20525: LD_VAR 0 2
20529: PUSH
20530: LD_INT 2
20532: ARRAY
20533: PPUSH
20534: LD_VAR 0 2
20538: PUSH
20539: LD_INT 3
20541: ARRAY
20542: PPUSH
20543: LD_VAR 0 3
20547: PPUSH
20548: CALL 9058 0 5
// end ;
20552: LD_VAR 0 4
20556: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20557: LD_INT 0
20559: PPUSH
20560: PPUSH
20561: PPUSH
// p := 1 ;
20562: LD_ADDR_VAR 0 6
20566: PUSH
20567: LD_INT 1
20569: ST_TO_ADDR
// if type_list = [ ] then
20570: LD_VAR 0 3
20574: PUSH
20575: EMPTY
20576: EQUAL
20577: IFFALSE 20587
// type_list := b_oil_power ;
20579: LD_ADDR_VAR 0 3
20583: PUSH
20584: LD_INT 26
20586: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20587: LD_ADDR_VAR 0 5
20591: PUSH
20592: DOUBLE
20593: LD_INT 1
20595: DEC
20596: ST_TO_ADDR
20597: LD_VAR 0 2
20601: PUSH
20602: LD_INT 3
20604: DIVREAL
20605: PUSH
20606: FOR_TO
20607: IFFALSE 20710
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20609: LD_ADDR_EXP 46
20613: PUSH
20614: LD_EXP 46
20618: PPUSH
20619: LD_VAR 0 1
20623: PPUSH
20624: LD_VAR 0 3
20628: PUSH
20629: LD_INT 1
20631: PPUSH
20632: LD_VAR 0 3
20636: PPUSH
20637: CALL_OW 12
20641: ARRAY
20642: PPUSH
20643: LD_VAR 0 2
20647: PUSH
20648: LD_VAR 0 6
20652: ARRAY
20653: PUSH
20654: LD_VAR 0 2
20658: PUSH
20659: LD_VAR 0 6
20663: PUSH
20664: LD_INT 1
20666: PLUS
20667: ARRAY
20668: PUSH
20669: LD_VAR 0 2
20673: PUSH
20674: LD_VAR 0 6
20678: PUSH
20679: LD_INT 2
20681: PLUS
20682: ARRAY
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: PPUSH
20689: CALL 41841 0 4
20693: ST_TO_ADDR
// p := p + 3 ;
20694: LD_ADDR_VAR 0 6
20698: PUSH
20699: LD_VAR 0 6
20703: PUSH
20704: LD_INT 3
20706: PLUS
20707: ST_TO_ADDR
// end ;
20708: GO 20606
20710: POP
20711: POP
// end ;
20712: LD_VAR 0 4
20716: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20717: LD_INT 0
20719: PPUSH
20720: PPUSH
20721: PPUSH
20722: PPUSH
// if not MREG_Deposit [ side ] then
20723: LD_EXP 61
20727: PUSH
20728: LD_VAR 0 1
20732: ARRAY
20733: NOT
20734: IFFALSE 20738
// exit ;
20736: GO 20915
// p := 1 ;
20738: LD_ADDR_VAR 0 4
20742: PUSH
20743: LD_INT 1
20745: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20746: LD_ADDR_VAR 0 3
20750: PUSH
20751: DOUBLE
20752: LD_INT 1
20754: DEC
20755: ST_TO_ADDR
20756: LD_EXP 61
20760: PUSH
20761: LD_VAR 0 1
20765: ARRAY
20766: PUSH
20767: LD_INT 3
20769: DIVREAL
20770: PUSH
20771: FOR_TO
20772: IFFALSE 20913
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20774: LD_EXP 61
20778: PUSH
20779: LD_VAR 0 1
20783: ARRAY
20784: PUSH
20785: LD_VAR 0 4
20789: PUSH
20790: LD_INT 2
20792: PLUS
20793: ARRAY
20794: PUSH
20795: LD_INT 2
20797: EQUAL
20798: IFFALSE 20810
// b := b_oil_mine else
20800: LD_ADDR_VAR 0 5
20804: PUSH
20805: LD_INT 29
20807: ST_TO_ADDR
20808: GO 20818
// b := b_siberite_mine ;
20810: LD_ADDR_VAR 0 5
20814: PUSH
20815: LD_INT 30
20817: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20818: LD_ADDR_EXP 46
20822: PUSH
20823: LD_EXP 46
20827: PPUSH
20828: LD_VAR 0 1
20832: PPUSH
20833: LD_VAR 0 5
20837: PPUSH
20838: LD_EXP 61
20842: PUSH
20843: LD_VAR 0 1
20847: ARRAY
20848: PUSH
20849: LD_VAR 0 4
20853: ARRAY
20854: PUSH
20855: LD_EXP 61
20859: PUSH
20860: LD_VAR 0 1
20864: ARRAY
20865: PUSH
20866: LD_VAR 0 4
20870: PUSH
20871: LD_INT 1
20873: PLUS
20874: ARRAY
20875: PUSH
20876: LD_INT 0
20878: PPUSH
20879: LD_INT 5
20881: PPUSH
20882: CALL_OW 12
20886: PUSH
20887: EMPTY
20888: LIST
20889: LIST
20890: LIST
20891: PPUSH
20892: CALL 41841 0 4
20896: ST_TO_ADDR
// p := p + 3 ;
20897: LD_ADDR_VAR 0 4
20901: PUSH
20902: LD_VAR 0 4
20906: PUSH
20907: LD_INT 3
20909: PLUS
20910: ST_TO_ADDR
// end ;
20911: GO 20771
20913: POP
20914: POP
// end ;
20915: LD_VAR 0 2
20919: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20920: LD_INT 0
20922: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_INT 4
20940: PPUSH
20941: LD_VAR 0 2
20945: PPUSH
20946: CALL 41841 0 4
20950: ST_TO_ADDR
// end ;
20951: LD_VAR 0 3
20955: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20956: LD_INT 0
20958: PPUSH
// case nation of 1 , us :
20959: LD_VAR 0 2
20963: PUSH
20964: LD_INT 1
20966: DOUBLE
20967: EQUAL
20968: IFTRUE 20978
20970: LD_STRING us
20972: DOUBLE
20973: EQUAL
20974: IFTRUE 20978
20976: GO 21009
20978: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20979: LD_ADDR_EXP 46
20983: PUSH
20984: LD_EXP 46
20988: PPUSH
20989: LD_VAR 0 1
20993: PPUSH
20994: LD_INT 36
20996: PPUSH
20997: LD_VAR 0 3
21001: PPUSH
21002: CALL 41841 0 4
21006: ST_TO_ADDR
21007: GO 21060
21009: LD_INT 2
21011: DOUBLE
21012: EQUAL
21013: IFTRUE 21023
21015: LD_STRING ar
21017: DOUBLE
21018: EQUAL
21019: IFTRUE 21023
21021: GO 21059
21023: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21024: LD_ADDR_EXP 46
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: LD_INT 14
21036: PUSH
21037: LD_INT 2
21039: PUSH
21040: LD_INT 1
21042: PUSH
21043: LD_INT 31
21045: PUSH
21046: EMPTY
21047: LIST
21048: LIST
21049: LIST
21050: LIST
21051: PPUSH
21052: CALL 21065 0 2
21056: ST_TO_ADDR
21057: GO 21060
21059: POP
// end ;
21060: LD_VAR 0 4
21064: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21065: LD_INT 0
21067: PPUSH
21068: PPUSH
// for i = 1 to list do
21069: LD_ADDR_VAR 0 4
21073: PUSH
21074: DOUBLE
21075: LD_INT 1
21077: DEC
21078: ST_TO_ADDR
21079: LD_VAR 0 2
21083: PUSH
21084: FOR_TO
21085: IFFALSE 21135
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21087: LD_ADDR_EXP 51
21091: PUSH
21092: LD_EXP 51
21096: PPUSH
21097: LD_VAR 0 1
21101: PPUSH
21102: LD_EXP 51
21106: PUSH
21107: LD_VAR 0 1
21111: ARRAY
21112: PUSH
21113: LD_INT 1
21115: PLUS
21116: PPUSH
21117: LD_VAR 0 2
21121: PUSH
21122: LD_VAR 0 4
21126: ARRAY
21127: PPUSH
21128: CALL 31011 0 4
21132: ST_TO_ADDR
21133: GO 21084
21135: POP
21136: POP
// end ;
21137: LD_VAR 0 3
21141: RET
// export function MCS_GetVehicleList ( side ) ; begin
21142: LD_INT 0
21144: PPUSH
// result := MREG_ToConstruct [ side ] ;
21145: LD_ADDR_VAR 0 2
21149: PUSH
21150: LD_EXP 51
21154: PUSH
21155: LD_VAR 0 1
21159: ARRAY
21160: ST_TO_ADDR
// end ;
21161: LD_VAR 0 2
21165: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21166: LD_INT 0
21168: PPUSH
21169: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21170: LD_ADDR_EXP 58
21174: PUSH
21175: LD_EXP 58
21179: PPUSH
21180: LD_VAR 0 1
21184: PPUSH
21185: LD_VAR 0 2
21189: PPUSH
21190: CALL_OW 1
21194: ST_TO_ADDR
// end ;
21195: LD_VAR 0 3
21199: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21200: LD_INT 0
21202: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21203: LD_ADDR_EXP 37
21207: PUSH
21208: LD_EXP 37
21212: PPUSH
21213: LD_VAR 0 1
21217: PPUSH
21218: LD_VAR 0 2
21222: PPUSH
21223: CALL_OW 1
21227: ST_TO_ADDR
// end ;
21228: LD_VAR 0 3
21232: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21233: LD_INT 0
21235: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21236: LD_ADDR_EXP 38
21240: PUSH
21241: LD_EXP 38
21245: PPUSH
21246: LD_VAR 0 1
21250: PPUSH
21251: LD_VAR 0 2
21255: PPUSH
21256: CALL_OW 1
21260: ST_TO_ADDR
// end ;
21261: LD_VAR 0 3
21265: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21266: LD_INT 0
21268: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21269: LD_ADDR_EXP 60
21273: PUSH
21274: LD_EXP 60
21278: PPUSH
21279: LD_VAR 0 1
21283: PPUSH
21284: LD_INT 1
21286: PPUSH
21287: LD_VAR 0 2
21291: PPUSH
21292: CALL 31011 0 4
21296: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21297: LD_ADDR_EXP 60
21301: PUSH
21302: LD_EXP 60
21306: PPUSH
21307: LD_VAR 0 1
21311: PPUSH
21312: LD_INT 2
21314: PPUSH
21315: LD_VAR 0 3
21319: PPUSH
21320: CALL 31011 0 4
21324: ST_TO_ADDR
// end ;
21325: LD_VAR 0 4
21329: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21330: LD_INT 0
21332: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21333: LD_ADDR_EXP 72
21337: PUSH
21338: LD_EXP 72
21342: PPUSH
21343: LD_INT 1
21345: PPUSH
21346: LD_VAR 0 1
21350: PPUSH
21351: CALL_OW 1
21355: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21356: LD_ADDR_EXP 72
21360: PUSH
21361: LD_EXP 72
21365: PPUSH
21366: LD_INT 2
21368: PPUSH
21369: LD_VAR 0 2
21373: PPUSH
21374: CALL_OW 1
21378: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21379: LD_ADDR_EXP 72
21383: PUSH
21384: LD_EXP 72
21388: PPUSH
21389: LD_INT 3
21391: PPUSH
21392: LD_VAR 0 3
21396: PPUSH
21397: CALL_OW 1
21401: ST_TO_ADDR
// end ;
21402: LD_VAR 0 4
21406: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21407: LD_INT 0
21409: PPUSH
21410: PPUSH
21411: PPUSH
// if not side or not list then
21412: LD_VAR 0 1
21416: NOT
21417: PUSH
21418: LD_VAR 0 2
21422: NOT
21423: OR
21424: IFFALSE 21428
// exit ;
21426: GO 21596
// SetTech ( 20 , side , state_researched ) ;
21428: LD_INT 20
21430: PPUSH
21431: LD_VAR 0 1
21435: PPUSH
21436: LD_INT 2
21438: PPUSH
21439: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21443: LD_ADDR_EXP 61
21447: PUSH
21448: LD_EXP 61
21452: PPUSH
21453: LD_VAR 0 1
21457: PPUSH
21458: LD_VAR 0 2
21462: PPUSH
21463: CALL_OW 2
21467: ST_TO_ADDR
// p := 1 ;
21468: LD_ADDR_VAR 0 5
21472: PUSH
21473: LD_INT 1
21475: ST_TO_ADDR
// for i = 1 to list / 3 do
21476: LD_ADDR_VAR 0 4
21480: PUSH
21481: DOUBLE
21482: LD_INT 1
21484: DEC
21485: ST_TO_ADDR
21486: LD_VAR 0 2
21490: PUSH
21491: LD_INT 3
21493: DIVREAL
21494: PUSH
21495: FOR_TO
21496: IFFALSE 21594
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21498: LD_VAR 0 2
21502: PUSH
21503: LD_VAR 0 5
21507: ARRAY
21508: PPUSH
21509: LD_VAR 0 2
21513: PUSH
21514: LD_VAR 0 5
21518: PUSH
21519: LD_INT 1
21521: PLUS
21522: ARRAY
21523: PPUSH
21524: LD_VAR 0 2
21528: PUSH
21529: LD_VAR 0 5
21533: PUSH
21534: LD_INT 2
21536: PLUS
21537: ARRAY
21538: PPUSH
21539: CALL 22298 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21543: LD_VAR 0 2
21547: PUSH
21548: LD_VAR 0 5
21552: ARRAY
21553: PPUSH
21554: LD_VAR 0 2
21558: PUSH
21559: LD_VAR 0 5
21563: PUSH
21564: LD_INT 1
21566: PLUS
21567: ARRAY
21568: PPUSH
21569: LD_VAR 0 1
21573: PPUSH
21574: CALL_OW 441
// p := p + 3 ;
21578: LD_ADDR_VAR 0 5
21582: PUSH
21583: LD_VAR 0 5
21587: PUSH
21588: LD_INT 3
21590: PLUS
21591: ST_TO_ADDR
// end ;
21592: GO 21495
21594: POP
21595: POP
// end ;
21596: LD_VAR 0 3
21600: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21601: LD_INT 0
21603: PPUSH
21604: PPUSH
// if nat = nation_arabian then
21605: LD_VAR 0 2
21609: PUSH
21610: LD_INT 2
21612: EQUAL
21613: IFFALSE 21619
// exit else
21615: GO 21691
21617: GO 21677
// if nat = nation_american then
21619: LD_VAR 0 2
21623: PUSH
21624: LD_INT 1
21626: EQUAL
21627: IFFALSE 21654
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21629: LD_ADDR_VAR 0 4
21633: PUSH
21634: LD_INT 4
21636: PUSH
21637: LD_INT 3
21639: PUSH
21640: LD_INT 1
21642: PUSH
21643: LD_INT 8
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: ST_TO_ADDR
21652: GO 21677
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21654: LD_ADDR_VAR 0 4
21658: PUSH
21659: LD_INT 24
21661: PUSH
21662: LD_INT 3
21664: PUSH
21665: LD_INT 1
21667: PUSH
21668: LD_INT 48
21670: PUSH
21671: EMPTY
21672: LIST
21673: LIST
21674: LIST
21675: LIST
21676: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21677: LD_VAR 0 1
21681: PPUSH
21682: LD_VAR 0 4
21686: PPUSH
21687: CALL 21065 0 2
// end ;
21691: LD_VAR 0 3
21695: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21696: LD_INT 0
21698: PPUSH
21699: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21700: LD_ADDR_EXP 63
21704: PUSH
21705: LD_EXP 63
21709: PPUSH
21710: LD_VAR 0 1
21714: PPUSH
21715: LD_INT 1
21717: PPUSH
21718: LD_VAR 0 4
21722: PPUSH
21723: CALL 31011 0 4
21727: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21728: LD_ADDR_EXP 64
21732: PUSH
21733: LD_EXP 64
21737: PPUSH
21738: LD_VAR 0 1
21742: PPUSH
21743: LD_INT 1
21745: PPUSH
21746: LD_VAR 0 2
21750: PPUSH
21751: CALL 31011 0 4
21755: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21756: LD_ADDR_EXP 65
21760: PUSH
21761: LD_EXP 65
21765: PPUSH
21766: LD_VAR 0 1
21770: PPUSH
21771: LD_INT 1
21773: PPUSH
21774: LD_VAR 0 3
21778: PPUSH
21779: CALL 31011 0 4
21783: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21784: LD_ADDR_EXP 66
21788: PUSH
21789: LD_EXP 66
21793: PPUSH
21794: LD_VAR 0 1
21798: PPUSH
21799: LD_INT 1
21801: PPUSH
21802: LD_VAR 0 5
21806: PPUSH
21807: CALL 31011 0 4
21811: ST_TO_ADDR
// while squad do
21812: LD_VAR 0 5
21816: IFFALSE 21909
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21818: LD_VAR 0 1
21822: PPUSH
21823: LD_VAR 0 5
21827: PUSH
21828: LD_INT 1
21830: ARRAY
21831: PUSH
21832: LD_VAR 0 5
21836: PUSH
21837: LD_INT 2
21839: ARRAY
21840: PUSH
21841: LD_VAR 0 5
21845: PUSH
21846: LD_INT 3
21848: ARRAY
21849: PUSH
21850: LD_VAR 0 5
21854: PUSH
21855: LD_INT 4
21857: ARRAY
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: LIST
21863: LIST
21864: PPUSH
21865: CALL 21065 0 2
// for i = 1 to 4 do
21869: LD_ADDR_VAR 0 7
21873: PUSH
21874: DOUBLE
21875: LD_INT 1
21877: DEC
21878: ST_TO_ADDR
21879: LD_INT 4
21881: PUSH
21882: FOR_TO
21883: IFFALSE 21905
// squad := Delete ( squad , 1 ) ;
21885: LD_ADDR_VAR 0 5
21889: PUSH
21890: LD_VAR 0 5
21894: PPUSH
21895: LD_INT 1
21897: PPUSH
21898: CALL_OW 3
21902: ST_TO_ADDR
21903: GO 21882
21905: POP
21906: POP
// end ;
21907: GO 21812
// end ;
21909: LD_VAR 0 6
21913: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21914: LD_INT 0
21916: PPUSH
21917: PPUSH
// for i = 1 to squad do
21918: LD_ADDR_VAR 0 4
21922: PUSH
21923: DOUBLE
21924: LD_INT 1
21926: DEC
21927: ST_TO_ADDR
21928: LD_VAR 0 2
21932: PUSH
21933: FOR_TO
21934: IFFALSE 21984
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21936: LD_ADDR_EXP 69
21940: PUSH
21941: LD_EXP 69
21945: PPUSH
21946: LD_VAR 0 1
21950: PPUSH
21951: LD_EXP 69
21955: PUSH
21956: LD_VAR 0 1
21960: ARRAY
21961: PUSH
21962: LD_INT 1
21964: PLUS
21965: PPUSH
21966: LD_VAR 0 2
21970: PUSH
21971: LD_VAR 0 4
21975: ARRAY
21976: PPUSH
21977: CALL 31011 0 4
21981: ST_TO_ADDR
21982: GO 21933
21984: POP
21985: POP
// while squad do
21986: LD_VAR 0 2
21990: IFFALSE 22083
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21992: LD_VAR 0 1
21996: PPUSH
21997: LD_VAR 0 2
22001: PUSH
22002: LD_INT 1
22004: ARRAY
22005: PUSH
22006: LD_VAR 0 2
22010: PUSH
22011: LD_INT 2
22013: ARRAY
22014: PUSH
22015: LD_VAR 0 2
22019: PUSH
22020: LD_INT 3
22022: ARRAY
22023: PUSH
22024: LD_VAR 0 2
22028: PUSH
22029: LD_INT 4
22031: ARRAY
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: PPUSH
22039: CALL 21065 0 2
// for i = 1 to 4 do
22043: LD_ADDR_VAR 0 4
22047: PUSH
22048: DOUBLE
22049: LD_INT 1
22051: DEC
22052: ST_TO_ADDR
22053: LD_INT 4
22055: PUSH
22056: FOR_TO
22057: IFFALSE 22079
// squad := Delete ( squad , 1 ) ;
22059: LD_ADDR_VAR 0 2
22063: PUSH
22064: LD_VAR 0 2
22068: PPUSH
22069: LD_INT 1
22071: PPUSH
22072: CALL_OW 3
22076: ST_TO_ADDR
22077: GO 22056
22079: POP
22080: POP
// end ;
22081: GO 21986
// end ;
22083: LD_VAR 0 3
22087: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22088: LD_INT 0
22090: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22091: LD_ADDR_EXP 62
22095: PUSH
22096: LD_EXP 62
22100: PPUSH
22101: LD_VAR 0 1
22105: PPUSH
22106: LD_INT 1
22108: PPUSH
22109: LD_VAR 0 2
22113: PPUSH
22114: CALL 31011 0 4
22118: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22119: LD_ADDR_EXP 62
22123: PUSH
22124: LD_EXP 62
22128: PPUSH
22129: LD_VAR 0 1
22133: PPUSH
22134: LD_INT 2
22136: PPUSH
22137: LD_VAR 0 3
22141: PPUSH
22142: CALL 31011 0 4
22146: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22147: LD_ADDR_EXP 62
22151: PUSH
22152: LD_EXP 62
22156: PPUSH
22157: LD_VAR 0 1
22161: PPUSH
22162: LD_INT 3
22164: PPUSH
22165: LD_VAR 0 4
22169: PPUSH
22170: CALL 31011 0 4
22174: ST_TO_ADDR
// end ; end_of_file
22175: LD_VAR 0 5
22179: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22180: LD_INT 0
22182: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22183: LD_ADDR_EXP 42
22187: PUSH
22188: LD_EXP 42
22192: PPUSH
22193: LD_VAR 0 1
22197: PPUSH
22198: LD_INT 1
22200: PPUSH
22201: LD_VAR 0 2
22205: PPUSH
22206: CALL 31011 0 4
22210: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22211: LD_VAR 0 1
22215: PPUSH
22216: EMPTY
22217: PPUSH
22218: CALL 11681 0 2
22222: PUSH
22223: LD_INT 1
22225: ARRAY
22226: PPUSH
22227: CALL_OW 248
22231: PUSH
22232: LD_INT 1
22234: EQUAL
22235: IFFALSE 22266
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22237: LD_VAR 0 1
22241: PPUSH
22242: LD_INT 4
22244: PUSH
22245: LD_INT 1
22247: PUSH
22248: LD_INT 1
22250: PUSH
22251: LD_INT 14
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: LIST
22258: LIST
22259: PPUSH
22260: CALL 21065 0 2
22264: GO 22293
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22266: LD_VAR 0 1
22270: PPUSH
22271: LD_INT 24
22273: PUSH
22274: LD_INT 1
22276: PUSH
22277: LD_INT 1
22279: PUSH
22280: LD_INT 53
22282: PUSH
22283: EMPTY
22284: LIST
22285: LIST
22286: LIST
22287: LIST
22288: PPUSH
22289: CALL 21065 0 2
// end ;
22293: LD_VAR 0 3
22297: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22298: LD_INT 0
22300: PPUSH
// CreateDepositXY ( x , y , t ) ;
22301: LD_VAR 0 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: LD_VAR 0 3
22315: PPUSH
22316: CALL_OW 62
// end ;
22320: LD_VAR 0 4
22324: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22325: LD_INT 0
22327: PPUSH
22328: PPUSH
// c := 1 ;
22329: LD_ADDR_VAR 0 5
22333: PUSH
22334: LD_INT 1
22336: ST_TO_ADDR
// case color of red :
22337: LD_VAR 0 3
22341: PUSH
22342: LD_STRING red
22344: DOUBLE
22345: EQUAL
22346: IFTRUE 22350
22348: GO 22361
22350: POP
// c = 1 ; dark-green :
22351: LD_ADDR_VAR 0 5
22355: PUSH
22356: LD_INT 1
22358: ST_TO_ADDR
22359: GO 22647
22361: LD_STRING dark-green
22363: DOUBLE
22364: EQUAL
22365: IFTRUE 22369
22367: GO 22380
22369: POP
// c = 2 ; purple :
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 2
22377: ST_TO_ADDR
22378: GO 22647
22380: LD_STRING purple
22382: DOUBLE
22383: EQUAL
22384: IFTRUE 22388
22386: GO 22399
22388: POP
// c = 3 ; aqua :
22389: LD_ADDR_VAR 0 5
22393: PUSH
22394: LD_INT 3
22396: ST_TO_ADDR
22397: GO 22647
22399: LD_STRING aqua
22401: DOUBLE
22402: EQUAL
22403: IFTRUE 22407
22405: GO 22418
22407: POP
// c = 4 ; grey :
22408: LD_ADDR_VAR 0 5
22412: PUSH
22413: LD_INT 4
22415: ST_TO_ADDR
22416: GO 22647
22418: LD_STRING grey
22420: DOUBLE
22421: EQUAL
22422: IFTRUE 22426
22424: GO 22437
22426: POP
// c = 5 ; lime :
22427: LD_ADDR_VAR 0 5
22431: PUSH
22432: LD_INT 5
22434: ST_TO_ADDR
22435: GO 22647
22437: LD_STRING lime
22439: DOUBLE
22440: EQUAL
22441: IFTRUE 22445
22443: GO 22456
22445: POP
// c = 6 ; tan :
22446: LD_ADDR_VAR 0 5
22450: PUSH
22451: LD_INT 6
22453: ST_TO_ADDR
22454: GO 22647
22456: LD_STRING tan
22458: DOUBLE
22459: EQUAL
22460: IFTRUE 22464
22462: GO 22475
22464: POP
// c = 7 ; pink :
22465: LD_ADDR_VAR 0 5
22469: PUSH
22470: LD_INT 7
22472: ST_TO_ADDR
22473: GO 22647
22475: LD_STRING pink
22477: DOUBLE
22478: EQUAL
22479: IFTRUE 22483
22481: GO 22494
22483: POP
// c = 8 ; green :
22484: LD_ADDR_VAR 0 5
22488: PUSH
22489: LD_INT 8
22491: ST_TO_ADDR
22492: GO 22647
22494: LD_STRING green
22496: DOUBLE
22497: EQUAL
22498: IFTRUE 22502
22500: GO 22513
22502: POP
// c = 9 ; blue :
22503: LD_ADDR_VAR 0 5
22507: PUSH
22508: LD_INT 9
22510: ST_TO_ADDR
22511: GO 22647
22513: LD_STRING blue
22515: DOUBLE
22516: EQUAL
22517: IFTRUE 22521
22519: GO 22532
22521: POP
// c = 10 ; yellow :
22522: LD_ADDR_VAR 0 5
22526: PUSH
22527: LD_INT 10
22529: ST_TO_ADDR
22530: GO 22647
22532: LD_STRING yellow
22534: DOUBLE
22535: EQUAL
22536: IFTRUE 22540
22538: GO 22551
22540: POP
// c = 11 ; brown :
22541: LD_ADDR_VAR 0 5
22545: PUSH
22546: LD_INT 11
22548: ST_TO_ADDR
22549: GO 22647
22551: LD_STRING brown
22553: DOUBLE
22554: EQUAL
22555: IFTRUE 22559
22557: GO 22570
22559: POP
// c = 12 ; black :
22560: LD_ADDR_VAR 0 5
22564: PUSH
22565: LD_INT 12
22567: ST_TO_ADDR
22568: GO 22647
22570: LD_STRING black
22572: DOUBLE
22573: EQUAL
22574: IFTRUE 22578
22576: GO 22589
22578: POP
// c = 13 ; aqua2 :
22579: LD_ADDR_VAR 0 5
22583: PUSH
22584: LD_INT 13
22586: ST_TO_ADDR
22587: GO 22647
22589: LD_STRING aqua2
22591: DOUBLE
22592: EQUAL
22593: IFTRUE 22597
22595: GO 22608
22597: POP
// c = 14 ; orange :
22598: LD_ADDR_VAR 0 5
22602: PUSH
22603: LD_INT 14
22605: ST_TO_ADDR
22606: GO 22647
22608: LD_STRING orange
22610: DOUBLE
22611: EQUAL
22612: IFTRUE 22616
22614: GO 22627
22616: POP
// c = 15 ; white :
22617: LD_ADDR_VAR 0 5
22621: PUSH
22622: LD_INT 15
22624: ST_TO_ADDR
22625: GO 22647
22627: LD_STRING white
22629: DOUBLE
22630: EQUAL
22631: IFTRUE 22635
22633: GO 22646
22635: POP
// c = 16 ; end ;
22636: LD_ADDR_VAR 0 5
22640: PUSH
22641: LD_INT 16
22643: ST_TO_ADDR
22644: GO 22647
22646: POP
// if HexInfo ( x , y ) = 0 then
22647: LD_VAR 0 1
22651: PPUSH
22652: LD_VAR 0 2
22656: PPUSH
22657: CALL_OW 428
22661: PUSH
22662: LD_INT 0
22664: EQUAL
22665: IFFALSE 22689
// PlaceEnvironment ( x , y , 58 , c ) ;
22667: LD_VAR 0 1
22671: PPUSH
22672: LD_VAR 0 2
22676: PPUSH
22677: LD_INT 58
22679: PPUSH
22680: LD_VAR 0 5
22684: PPUSH
22685: CALL_OW 349
// end ;
22689: LD_VAR 0 4
22693: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22694: LD_INT 0
22696: PPUSH
// RemoveEnvironment ( x , y ) ;
22697: LD_VAR 0 1
22701: PPUSH
22702: LD_VAR 0 2
22706: PPUSH
22707: CALL_OW 347
// end ;
22711: LD_VAR 0 3
22715: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22716: LD_INT 0
22718: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 81
22726: PUSH
22727: LD_VAR 0 1
22731: PUSH
22732: EMPTY
22733: LIST
22734: LIST
22735: PUSH
22736: LD_INT 92
22738: PUSH
22739: LD_VAR 0 2
22743: PUSH
22744: LD_VAR 0 3
22748: PUSH
22749: LD_VAR 0 4
22753: PUSH
22754: EMPTY
22755: LIST
22756: LIST
22757: LIST
22758: LIST
22759: PUSH
22760: EMPTY
22761: LIST
22762: LIST
22763: PPUSH
22764: CALL_OW 69
22768: ST_TO_ADDR
// end ;
22769: LD_VAR 0 5
22773: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22774: LD_INT 0
22776: PPUSH
22777: PPUSH
22778: PPUSH
22779: PPUSH
22780: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22781: LD_VAR 0 1
22785: PPUSH
22786: LD_INT 81
22788: PUSH
22789: LD_VAR 0 1
22793: PPUSH
22794: CALL_OW 255
22798: PUSH
22799: EMPTY
22800: LIST
22801: LIST
22802: PPUSH
22803: CALL_OW 69
22807: PPUSH
22808: LD_VAR 0 1
22812: PPUSH
22813: CALL_OW 74
22817: PPUSH
22818: CALL_OW 119
// dir := GetDir ( un ) ;
22822: LD_ADDR_VAR 0 4
22826: PUSH
22827: LD_VAR 0 1
22831: PPUSH
22832: CALL_OW 254
22836: ST_TO_ADDR
// dir := dir - 3 ;
22837: LD_ADDR_VAR 0 4
22841: PUSH
22842: LD_VAR 0 4
22846: PUSH
22847: LD_INT 3
22849: MINUS
22850: ST_TO_ADDR
// if dir < 0 then
22851: LD_VAR 0 4
22855: PUSH
22856: LD_INT 0
22858: LESS
22859: IFFALSE 22875
// dir := dir + 6 ;
22861: LD_ADDR_VAR 0 4
22865: PUSH
22866: LD_VAR 0 4
22870: PUSH
22871: LD_INT 6
22873: PLUS
22874: ST_TO_ADDR
// while true do
22875: LD_INT 1
22877: IFFALSE 23374
// begin coord_dist := 3 ;
22879: LD_ADDR_VAR 0 3
22883: PUSH
22884: LD_INT 3
22886: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22887: LD_ADDR_VAR 0 5
22891: PUSH
22892: LD_VAR 0 1
22896: PPUSH
22897: CALL_OW 250
22901: PPUSH
22902: LD_VAR 0 4
22906: PPUSH
22907: LD_VAR 0 3
22911: PPUSH
22912: CALL_OW 272
22916: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22917: LD_ADDR_VAR 0 6
22921: PUSH
22922: LD_VAR 0 1
22926: PPUSH
22927: CALL_OW 251
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: LD_VAR 0 3
22941: PPUSH
22942: CALL_OW 273
22946: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22947: LD_VAR 0 1
22951: PPUSH
22952: CALL_OW 255
22956: PPUSH
22957: LD_VAR 0 1
22961: PPUSH
22962: CALL_OW 250
22966: PPUSH
22967: LD_VAR 0 1
22971: PPUSH
22972: CALL_OW 251
22976: PPUSH
22977: LD_INT 14
22979: PPUSH
22980: CALL 22716 0 4
22984: PUSH
22985: LD_VAR 0 5
22989: PPUSH
22990: LD_VAR 0 6
22994: PPUSH
22995: CALL_OW 351
22999: OR
23000: PUSH
23001: LD_VAR 0 5
23005: PPUSH
23006: LD_VAR 0 6
23010: PPUSH
23011: CALL_OW 488
23015: PUSH
23016: LD_INT 0
23018: EQUAL
23019: OR
23020: PUSH
23021: LD_VAR 0 5
23025: PPUSH
23026: LD_VAR 0 6
23030: PPUSH
23031: CALL_OW 546
23035: PUSH
23036: LD_INT 1
23038: EQUAL
23039: OR
23040: PUSH
23041: LD_VAR 0 5
23045: PPUSH
23046: LD_VAR 0 6
23050: PPUSH
23051: CALL_OW 428
23055: PUSH
23056: LD_INT 0
23058: NONEQUAL
23059: OR
23060: IFFALSE 23288
// begin repeat begin Wait ( 0 0$0.3 ) ;
23062: LD_INT 10
23064: PPUSH
23065: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23069: LD_ADDR_VAR 0 3
23073: PUSH
23074: LD_VAR 0 3
23078: PUSH
23079: LD_INT 1
23081: PLUS
23082: ST_TO_ADDR
// dir := dir + 1 ;
23083: LD_ADDR_VAR 0 4
23087: PUSH
23088: LD_VAR 0 4
23092: PUSH
23093: LD_INT 1
23095: PLUS
23096: ST_TO_ADDR
// if dir > 5 then
23097: LD_VAR 0 4
23101: PUSH
23102: LD_INT 5
23104: GREATER
23105: IFFALSE 23115
// dir = 0 ;
23107: LD_ADDR_VAR 0 4
23111: PUSH
23112: LD_INT 0
23114: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23115: LD_ADDR_VAR 0 5
23119: PUSH
23120: LD_VAR 0 1
23124: PPUSH
23125: CALL_OW 250
23129: PPUSH
23130: LD_VAR 0 4
23134: PPUSH
23135: LD_VAR 0 3
23139: PPUSH
23140: CALL_OW 272
23144: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23145: LD_ADDR_VAR 0 6
23149: PUSH
23150: LD_VAR 0 1
23154: PPUSH
23155: CALL_OW 251
23159: PPUSH
23160: LD_VAR 0 4
23164: PPUSH
23165: LD_VAR 0 3
23169: PPUSH
23170: CALL_OW 273
23174: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23175: LD_VAR 0 1
23179: PPUSH
23180: CALL_OW 255
23184: PPUSH
23185: LD_VAR 0 1
23189: PPUSH
23190: CALL_OW 250
23194: PPUSH
23195: LD_VAR 0 1
23199: PPUSH
23200: CALL_OW 251
23204: PPUSH
23205: LD_INT 14
23207: PPUSH
23208: CALL 22716 0 4
23212: NOT
23213: PUSH
23214: LD_VAR 0 5
23218: PPUSH
23219: LD_VAR 0 6
23223: PPUSH
23224: CALL_OW 351
23228: NOT
23229: AND
23230: PUSH
23231: LD_VAR 0 5
23235: PPUSH
23236: LD_VAR 0 6
23240: PPUSH
23241: CALL_OW 488
23245: AND
23246: PUSH
23247: LD_VAR 0 5
23251: PPUSH
23252: LD_VAR 0 6
23256: PPUSH
23257: CALL_OW 546
23261: PUSH
23262: LD_INT 0
23264: EQUAL
23265: AND
23266: PUSH
23267: LD_VAR 0 5
23271: PPUSH
23272: LD_VAR 0 6
23276: PPUSH
23277: CALL_OW 428
23281: PUSH
23282: LD_INT 0
23284: EQUAL
23285: AND
23286: IFFALSE 23062
// end ; ComMoveXY ( un , x , y ) ;
23288: LD_VAR 0 1
23292: PPUSH
23293: LD_VAR 0 5
23297: PPUSH
23298: LD_VAR 0 6
23302: PPUSH
23303: CALL_OW 111
// Wait ( 0 0$1 ) ;
23307: LD_INT 35
23309: PPUSH
23310: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23314: LD_VAR 0 1
23318: PPUSH
23319: LD_INT 81
23321: PUSH
23322: LD_VAR 0 1
23326: PPUSH
23327: CALL_OW 255
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: PPUSH
23336: CALL_OW 69
23340: PPUSH
23341: LD_VAR 0 1
23345: PPUSH
23346: CALL_OW 74
23350: PPUSH
23351: CALL_OW 296
23355: PUSH
23356: LD_INT 14
23358: GREATEREQUAL
23359: IFFALSE 23372
// begin ComStop ( un ) ;
23361: LD_VAR 0 1
23365: PPUSH
23366: CALL_OW 141
// break ;
23370: GO 23374
// end ; end ;
23372: GO 22875
// end ;
23374: LD_VAR 0 2
23378: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23379: LD_INT 0
23381: PPUSH
23382: PPUSH
23383: PPUSH
23384: PPUSH
23385: PPUSH
23386: PPUSH
23387: PPUSH
23388: PPUSH
// x := GetX ( unit ) ;
23389: LD_ADDR_VAR 0 3
23393: PUSH
23394: LD_VAR 0 1
23398: PPUSH
23399: CALL_OW 250
23403: ST_TO_ADDR
// y := GetY ( unit ) ;
23404: LD_ADDR_VAR 0 4
23408: PUSH
23409: LD_VAR 0 1
23413: PPUSH
23414: CALL_OW 251
23418: ST_TO_ADDR
// i := 0 ;
23419: LD_ADDR_VAR 0 8
23423: PUSH
23424: LD_INT 0
23426: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23427: LD_VAR 0 1
23431: PPUSH
23432: LD_INT 81
23434: PUSH
23435: LD_VAR 0 1
23439: PPUSH
23440: CALL_OW 255
23444: PUSH
23445: EMPTY
23446: LIST
23447: LIST
23448: PPUSH
23449: CALL_OW 69
23453: PPUSH
23454: LD_VAR 0 1
23458: PPUSH
23459: CALL_OW 74
23463: PPUSH
23464: CALL_OW 119
// dir := GetDir ( unit ) ;
23468: LD_ADDR_VAR 0 7
23472: PUSH
23473: LD_VAR 0 1
23477: PPUSH
23478: CALL_OW 254
23482: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23483: LD_ADDR_VAR 0 9
23487: PUSH
23488: LD_INT 0
23490: PPUSH
23491: LD_INT 1
23493: PPUSH
23494: CALL_OW 12
23498: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23499: LD_INT 10
23501: PPUSH
23502: CALL_OW 67
// if mode then
23506: LD_VAR 0 9
23510: IFFALSE 23528
// dir := dir + 1 else
23512: LD_ADDR_VAR 0 7
23516: PUSH
23517: LD_VAR 0 7
23521: PUSH
23522: LD_INT 1
23524: PLUS
23525: ST_TO_ADDR
23526: GO 23542
// dir := dir - 1 ;
23528: LD_ADDR_VAR 0 7
23532: PUSH
23533: LD_VAR 0 7
23537: PUSH
23538: LD_INT 1
23540: MINUS
23541: ST_TO_ADDR
// if ( dir < 0 ) then
23542: LD_VAR 0 7
23546: PUSH
23547: LD_INT 0
23549: LESS
23550: IFFALSE 23560
// dir := 5 ;
23552: LD_ADDR_VAR 0 7
23556: PUSH
23557: LD_INT 5
23559: ST_TO_ADDR
// if ( dir > 5 ) then
23560: LD_VAR 0 7
23564: PUSH
23565: LD_INT 5
23567: GREATER
23568: IFFALSE 23578
// dir := 0 ;
23570: LD_ADDR_VAR 0 7
23574: PUSH
23575: LD_INT 0
23577: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23578: LD_ADDR_VAR 0 5
23582: PUSH
23583: LD_VAR 0 3
23587: PPUSH
23588: LD_VAR 0 7
23592: PPUSH
23593: LD_INT 4
23595: PPUSH
23596: CALL_OW 272
23600: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23601: LD_ADDR_VAR 0 6
23605: PUSH
23606: LD_VAR 0 4
23610: PPUSH
23611: LD_VAR 0 7
23615: PPUSH
23616: LD_INT 4
23618: PPUSH
23619: CALL_OW 273
23623: ST_TO_ADDR
// i := i + 1 ;
23624: LD_ADDR_VAR 0 8
23628: PUSH
23629: LD_VAR 0 8
23633: PUSH
23634: LD_INT 1
23636: PLUS
23637: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23638: LD_VAR 0 1
23642: PPUSH
23643: CALL_OW 255
23647: PPUSH
23648: LD_VAR 0 5
23652: PPUSH
23653: LD_VAR 0 6
23657: PPUSH
23658: LD_INT 14
23660: PPUSH
23661: CALL 22716 0 4
23665: PUSH
23666: LD_INT 0
23668: EQUAL
23669: PUSH
23670: LD_VAR 0 5
23674: PPUSH
23675: LD_VAR 0 6
23679: PPUSH
23680: CALL_OW 546
23684: PUSH
23685: LD_INT 0
23687: EQUAL
23688: AND
23689: PUSH
23690: LD_VAR 0 5
23694: PPUSH
23695: LD_VAR 0 6
23699: PPUSH
23700: CALL_OW 428
23704: PUSH
23705: LD_INT 0
23707: EQUAL
23708: AND
23709: IFFALSE 23713
// break ;
23711: GO 23723
// end until i > 4 ;
23713: LD_VAR 0 8
23717: PUSH
23718: LD_INT 4
23720: GREATER
23721: IFFALSE 23499
// if x2 and y2 then
23723: LD_VAR 0 5
23727: PUSH
23728: LD_VAR 0 6
23732: AND
23733: IFFALSE 23756
// result := [ x2 , y2 ] else
23735: LD_ADDR_VAR 0 2
23739: PUSH
23740: LD_VAR 0 5
23744: PUSH
23745: LD_VAR 0 6
23749: PUSH
23750: EMPTY
23751: LIST
23752: LIST
23753: ST_TO_ADDR
23754: GO 23785
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23756: LD_ADDR_VAR 0 2
23760: PUSH
23761: LD_VAR 0 1
23765: PPUSH
23766: CALL_OW 250
23770: PUSH
23771: LD_VAR 0 1
23775: PPUSH
23776: CALL_OW 251
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: ST_TO_ADDR
// end ;
23785: LD_VAR 0 2
23789: RET
// export function MCT_Hex ( x , y ) ; begin
23790: LD_INT 0
23792: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23793: LD_ADDR_VAR 0 3
23797: PUSH
23798: LD_VAR 0 1
23802: PPUSH
23803: LD_VAR 0 2
23807: PPUSH
23808: CALL_OW 546
23812: PUSH
23813: LD_VAR 0 1
23817: PPUSH
23818: LD_VAR 0 2
23822: PPUSH
23823: CALL_OW 428
23827: PUSH
23828: EMPTY
23829: LIST
23830: PUSH
23831: EMPTY
23832: LIST
23833: LIST
23834: ST_TO_ADDR
// end ;
23835: LD_VAR 0 3
23839: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23840: LD_INT 0
23842: PPUSH
23843: PPUSH
23844: PPUSH
23845: PPUSH
23846: PPUSH
23847: PPUSH
23848: PPUSH
23849: PPUSH
23850: PPUSH
23851: PPUSH
23852: PPUSH
23853: PPUSH
23854: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23855: LD_ADDR_VAR 0 10
23859: PUSH
23860: LD_EXP 60
23864: PUSH
23865: LD_VAR 0 1
23869: ARRAY
23870: PUSH
23871: LD_INT 1
23873: ARRAY
23874: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23875: LD_ADDR_VAR 0 11
23879: PUSH
23880: LD_EXP 60
23884: PUSH
23885: LD_VAR 0 1
23889: ARRAY
23890: PUSH
23891: LD_INT 2
23893: ARRAY
23894: ST_TO_ADDR
// collectors := [ ] ;
23895: LD_ADDR_VAR 0 12
23899: PUSH
23900: EMPTY
23901: ST_TO_ADDR
// is_cargo := false ;
23902: LD_ADDR_VAR 0 13
23906: PUSH
23907: LD_INT 0
23909: ST_TO_ADDR
// if isTest then
23910: LD_EXP 1
23914: IFFALSE 23920
// TimerStart ( ) ;
23916: CALL_OW 548
// if MCF_Cargo ( side ) then
23920: LD_VAR 0 1
23924: PPUSH
23925: CALL 11897 0 1
23929: IFFALSE 23956
// begin collectors := MCF_Cargo ( side ) ;
23931: LD_ADDR_VAR 0 12
23935: PUSH
23936: LD_VAR 0 1
23940: PPUSH
23941: CALL 11897 0 1
23945: ST_TO_ADDR
// is_cargo := true ;
23946: LD_ADDR_VAR 0 13
23950: PUSH
23951: LD_INT 1
23953: ST_TO_ADDR
// end else
23954: GO 24105
// begin if MCF_ApeSpec ( side , engineer ) then
23956: LD_VAR 0 1
23960: PPUSH
23961: LD_STRING engineer
23963: PPUSH
23964: CALL 12043 0 2
23968: IFFALSE 23988
// collectors := MCF_ApeSpec ( side , engineer ) ;
23970: LD_ADDR_VAR 0 12
23974: PUSH
23975: LD_VAR 0 1
23979: PPUSH
23980: LD_STRING engineer
23982: PPUSH
23983: CALL 12043 0 2
23987: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23988: LD_VAR 0 1
23992: PPUSH
23993: LD_INT 2
23995: PPUSH
23996: EMPTY
23997: PPUSH
23998: CALL 11629 0 3
24002: IFFALSE 24105
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24004: LD_ADDR_VAR 0 7
24008: PUSH
24009: LD_VAR 0 1
24013: PPUSH
24014: LD_INT 2
24016: PPUSH
24017: EMPTY
24018: PPUSH
24019: CALL 11629 0 3
24023: ST_TO_ADDR
// if z > 5 then
24024: LD_VAR 0 7
24028: PUSH
24029: LD_INT 5
24031: GREATER
24032: IFFALSE 24044
// t1 := 5 else
24034: LD_ADDR_VAR 0 8
24038: PUSH
24039: LD_INT 5
24041: ST_TO_ADDR
24042: GO 24054
// t1 := z ;
24044: LD_ADDR_VAR 0 8
24048: PUSH
24049: LD_VAR 0 7
24053: ST_TO_ADDR
// for t2 = 1 to t1 do
24054: LD_ADDR_VAR 0 9
24058: PUSH
24059: DOUBLE
24060: LD_INT 1
24062: DEC
24063: ST_TO_ADDR
24064: LD_VAR 0 8
24068: PUSH
24069: FOR_TO
24070: IFFALSE 24103
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24072: LD_ADDR_VAR 0 12
24076: PUSH
24077: LD_VAR 0 12
24081: PPUSH
24082: LD_INT 1
24084: PPUSH
24085: LD_VAR 0 7
24089: PUSH
24090: LD_VAR 0 9
24094: ARRAY
24095: PPUSH
24096: CALL_OW 2
24100: ST_TO_ADDR
24101: GO 24069
24103: POP
24104: POP
// end ; end ; if not mode then
24105: LD_VAR 0 10
24109: NOT
24110: IFFALSE 24116
// exit else
24112: GO 24375
24114: GO 24375
// begin if collectors then
24116: LD_VAR 0 12
24120: IFFALSE 24375
// for i in areas do
24122: LD_ADDR_VAR 0 3
24126: PUSH
24127: LD_VAR 0 11
24131: PUSH
24132: FOR_IN
24133: IFFALSE 24373
// if GetListOfCratesInArea ( i ) then
24135: LD_VAR 0 3
24139: PPUSH
24140: CALL_OW 435
24144: IFFALSE 24371
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24146: LD_ADDR_VAR 0 5
24150: PUSH
24151: LD_VAR 0 3
24155: PPUSH
24156: CALL_OW 435
24160: PUSH
24161: LD_INT 1
24163: ARRAY
24164: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24165: LD_ADDR_VAR 0 6
24169: PUSH
24170: LD_VAR 0 3
24174: PPUSH
24175: CALL_OW 435
24179: PUSH
24180: LD_INT 2
24182: ARRAY
24183: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24184: LD_VAR 0 13
24188: PUSH
24189: LD_VAR 0 12
24193: PUSH
24194: LD_INT 1
24196: ARRAY
24197: PPUSH
24198: CALL_OW 110
24202: PUSH
24203: LD_INT 0
24205: EQUAL
24206: AND
24207: IFFALSE 24269
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24209: LD_VAR 0 12
24213: PUSH
24214: LD_INT 1
24216: ARRAY
24217: PPUSH
24218: CALL_OW 314
24222: NOT
24223: PUSH
24224: LD_VAR 0 12
24228: PUSH
24229: LD_INT 1
24231: ARRAY
24232: PPUSH
24233: CALL_OW 110
24237: PUSH
24238: LD_INT 0
24240: EQUAL
24241: AND
24242: IFFALSE 24267
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24244: LD_VAR 0 12
24248: PUSH
24249: LD_INT 1
24251: ARRAY
24252: PPUSH
24253: LD_VAR 0 5
24257: PPUSH
24258: LD_VAR 0 6
24262: PPUSH
24263: CALL_OW 117
// end ; end else
24267: GO 24355
// begin for j = 1 to collectors do
24269: LD_ADDR_VAR 0 4
24273: PUSH
24274: DOUBLE
24275: LD_INT 1
24277: DEC
24278: ST_TO_ADDR
24279: LD_VAR 0 12
24283: PUSH
24284: FOR_TO
24285: IFFALSE 24353
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24287: LD_VAR 0 12
24291: PUSH
24292: LD_VAR 0 4
24296: ARRAY
24297: PPUSH
24298: CALL_OW 314
24302: NOT
24303: PUSH
24304: LD_VAR 0 12
24308: PUSH
24309: LD_VAR 0 4
24313: ARRAY
24314: PPUSH
24315: CALL_OW 110
24319: PUSH
24320: LD_INT 0
24322: EQUAL
24323: AND
24324: IFFALSE 24351
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24326: LD_VAR 0 12
24330: PUSH
24331: LD_VAR 0 4
24335: ARRAY
24336: PPUSH
24337: LD_VAR 0 5
24341: PPUSH
24342: LD_VAR 0 6
24346: PPUSH
24347: CALL 24746 0 3
// end ;
24351: GO 24284
24353: POP
24354: POP
// end ; if isTest then
24355: LD_EXP 1
24359: IFFALSE 24371
// begin debug_time := TimerEnd ( ) ;
24361: LD_ADDR_VAR 0 14
24365: PUSH
24366: CALL_OW 549
24370: ST_TO_ADDR
// end ; end ;
24371: GO 24132
24373: POP
24374: POP
// end ; end ;
24375: LD_VAR 0 2
24379: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24380: LD_INT 0
24382: PPUSH
24383: PPUSH
24384: PPUSH
24385: PPUSH
24386: PPUSH
24387: PPUSH
// if not area then
24388: LD_VAR 0 1
24392: NOT
24393: IFFALSE 24399
// exit else
24395: GO 24661
24397: GO 24661
// if tick mod interval = 0 and Prob ( percent ) then
24399: LD_OWVAR 1
24403: PUSH
24404: LD_VAR 0 4
24408: MOD
24409: PUSH
24410: LD_INT 0
24412: EQUAL
24413: PUSH
24414: LD_VAR 0 3
24418: PPUSH
24419: CALL_OW 13
24423: AND
24424: IFFALSE 24661
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24426: LD_VAR 0 1
24430: PPUSH
24431: CALL_OW 435
24435: PUSH
24436: LD_VAR 0 5
24440: LESS
24441: PUSH
24442: LD_VAR 0 5
24446: PUSH
24447: LD_INT 0
24449: EQUAL
24450: OR
24451: IFFALSE 24661
// begin Randomize ;
24453: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24457: LD_ADDR_VAR 0 7
24461: PUSH
24462: LD_INT 1
24464: PPUSH
24465: LD_VAR 0 2
24469: PPUSH
24470: CALL_OW 12
24474: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24475: LD_ADDR_VAR 0 9
24479: PUSH
24480: LD_VAR 0 1
24484: PPUSH
24485: LD_INT 0
24487: PPUSH
24488: CALL_OW 517
24492: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24493: LD_ADDR_VAR 0 8
24497: PUSH
24498: LD_INT 1
24500: PPUSH
24501: LD_VAR 0 9
24505: PUSH
24506: LD_INT 1
24508: ARRAY
24509: PPUSH
24510: CALL_OW 12
24514: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24515: LD_VAR 0 9
24519: PUSH
24520: LD_INT 1
24522: ARRAY
24523: PUSH
24524: LD_VAR 0 8
24528: ARRAY
24529: PPUSH
24530: LD_VAR 0 9
24534: PUSH
24535: LD_INT 2
24537: ARRAY
24538: PUSH
24539: LD_VAR 0 8
24543: ARRAY
24544: PPUSH
24545: CALL_OW 428
24549: PUSH
24550: LD_INT 0
24552: GREATER
24553: PUSH
24554: LD_VAR 0 9
24558: PUSH
24559: LD_INT 1
24561: ARRAY
24562: PUSH
24563: LD_VAR 0 8
24567: ARRAY
24568: PPUSH
24569: LD_VAR 0 9
24573: PUSH
24574: LD_INT 2
24576: ARRAY
24577: PUSH
24578: LD_VAR 0 8
24582: ARRAY
24583: PPUSH
24584: CALL_OW 284
24588: PUSH
24589: LD_INT 0
24591: GREATER
24592: AND
24593: IFFALSE 24619
// c := Rand ( 1 , tmp [ 1 ] ) ;
24595: LD_ADDR_VAR 0 8
24599: PUSH
24600: LD_INT 1
24602: PPUSH
24603: LD_VAR 0 9
24607: PUSH
24608: LD_INT 1
24610: ARRAY
24611: PPUSH
24612: CALL_OW 12
24616: ST_TO_ADDR
24617: GO 24515
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24619: LD_VAR 0 7
24623: PPUSH
24624: LD_VAR 0 9
24628: PUSH
24629: LD_INT 1
24631: ARRAY
24632: PUSH
24633: LD_VAR 0 8
24637: ARRAY
24638: PPUSH
24639: LD_VAR 0 9
24643: PUSH
24644: LD_INT 2
24646: ARRAY
24647: PUSH
24648: LD_VAR 0 8
24652: ARRAY
24653: PPUSH
24654: LD_INT 1
24656: PPUSH
24657: CALL_OW 54
// end ; end ; end ;
24661: LD_VAR 0 6
24665: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24666: LD_INT 0
24668: PPUSH
24669: PPUSH
// if not MREG_Crates then
24670: LD_EXP 34
24674: NOT
24675: IFFALSE 24679
// exit ;
24677: GO 24741
// for i = MREG_Crates downto 1 do
24679: LD_ADDR_VAR 0 2
24683: PUSH
24684: DOUBLE
24685: LD_EXP 34
24689: INC
24690: ST_TO_ADDR
24691: LD_INT 1
24693: PUSH
24694: FOR_DOWNTO
24695: IFFALSE 24739
// if MREG_Crates [ i ] [ 3 ] = 0 then
24697: LD_EXP 34
24701: PUSH
24702: LD_VAR 0 2
24706: ARRAY
24707: PUSH
24708: LD_INT 3
24710: ARRAY
24711: PUSH
24712: LD_INT 0
24714: EQUAL
24715: IFFALSE 24737
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24717: LD_ADDR_EXP 34
24721: PUSH
24722: LD_EXP 34
24726: PPUSH
24727: LD_VAR 0 2
24731: PPUSH
24732: CALL_OW 3
24736: ST_TO_ADDR
24737: GO 24694
24739: POP
24740: POP
// end ;
24741: LD_VAR 0 1
24745: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24746: LD_INT 0
24748: PPUSH
24749: PPUSH
24750: PPUSH
24751: PPUSH
// if not unit then
24752: LD_VAR 0 1
24756: NOT
24757: IFFALSE 24761
// exit ;
24759: GO 24896
// if HasTask ( unit ) or not CanCarry ( unit ) then
24761: LD_VAR 0 1
24765: PPUSH
24766: CALL_OW 314
24770: PUSH
24771: LD_VAR 0 1
24775: PPUSH
24776: CALL_OW 280
24780: NOT
24781: OR
24782: IFFALSE 24786
// exit ;
24784: GO 24896
// side := GetSide ( unit ) ;
24786: LD_ADDR_VAR 0 6
24790: PUSH
24791: LD_VAR 0 1
24795: PPUSH
24796: CALL_OW 255
24800: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24801: LD_ADDR_VAR 0 7
24805: PUSH
24806: LD_VAR 0 6
24810: PPUSH
24811: LD_INT 30
24813: PUSH
24814: LD_INT 1
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PPUSH
24821: CALL 11546 0 2
24825: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24826: LD_VAR 0 1
24830: PPUSH
24831: CALL_OW 281
24835: PUSH
24836: LD_VAR 0 7
24840: NOT
24841: OR
24842: IFFALSE 24848
// exit else
24844: GO 24896
24846: GO 24896
// if GetResourceAmountXY ( x , y ) then
24848: LD_VAR 0 2
24852: PPUSH
24853: LD_VAR 0 3
24857: PPUSH
24858: CALL_OW 284
24862: IFFALSE 24894
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24864: LD_VAR 0 1
24868: PPUSH
24869: LD_VAR 0 2
24873: PPUSH
24874: LD_VAR 0 3
24878: PPUSH
24879: LD_VAR 0 7
24883: PUSH
24884: LD_INT 1
24886: ARRAY
24887: PPUSH
24888: CALL 31942 0 4
// end else
24892: GO 24896
// exit ;
24894: GO 24896
// end ;
24896: LD_VAR 0 4
24900: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24901: LD_INT 0
24903: PPUSH
24904: PPUSH
24905: PPUSH
24906: PPUSH
24907: PPUSH
// result := [ ] ;
24908: LD_ADDR_VAR 0 2
24912: PUSH
24913: EMPTY
24914: ST_TO_ADDR
// p := 1 ;
24915: LD_ADDR_VAR 0 4
24919: PUSH
24920: LD_INT 1
24922: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24923: LD_ADDR_VAR 0 3
24927: PUSH
24928: DOUBLE
24929: LD_INT 1
24931: DEC
24932: ST_TO_ADDR
24933: LD_EXP 63
24937: PUSH
24938: LD_VAR 0 1
24942: ARRAY
24943: PUSH
24944: LD_INT 1
24946: ARRAY
24947: PUSH
24948: LD_INT 2
24950: DIVREAL
24951: PUSH
24952: FOR_TO
24953: IFFALSE 25077
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24955: LD_ADDR_VAR 0 5
24959: PUSH
24960: LD_INT 81
24962: PUSH
24963: LD_VAR 0 1
24967: PUSH
24968: EMPTY
24969: LIST
24970: LIST
24971: PUSH
24972: LD_INT 92
24974: PUSH
24975: LD_EXP 63
24979: PUSH
24980: LD_VAR 0 1
24984: ARRAY
24985: PUSH
24986: LD_INT 1
24988: ARRAY
24989: PUSH
24990: LD_VAR 0 4
24994: ARRAY
24995: PUSH
24996: LD_EXP 63
25000: PUSH
25001: LD_VAR 0 1
25005: ARRAY
25006: PUSH
25007: LD_INT 1
25009: ARRAY
25010: PUSH
25011: LD_VAR 0 4
25015: PUSH
25016: LD_INT 1
25018: PLUS
25019: ARRAY
25020: PUSH
25021: LD_INT 12
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: LIST
25028: LIST
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PPUSH
25034: CALL_OW 69
25038: ST_TO_ADDR
// if tmp then
25039: LD_VAR 0 5
25043: IFFALSE 25061
// result := result union tmp ;
25045: LD_ADDR_VAR 0 2
25049: PUSH
25050: LD_VAR 0 2
25054: PUSH
25055: LD_VAR 0 5
25059: UNION
25060: ST_TO_ADDR
// p := p + 2 ;
25061: LD_ADDR_VAR 0 4
25065: PUSH
25066: LD_VAR 0 4
25070: PUSH
25071: LD_INT 2
25073: PLUS
25074: ST_TO_ADDR
// end ;
25075: GO 24952
25077: POP
25078: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25079: LD_EXP 64
25083: PUSH
25084: LD_VAR 0 1
25088: ARRAY
25089: PPUSH
25090: LD_INT 81
25092: PUSH
25093: LD_VAR 0 1
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PPUSH
25102: CALL_OW 70
25106: IFFALSE 25147
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25108: LD_ADDR_VAR 0 2
25112: PUSH
25113: LD_VAR 0 2
25117: PUSH
25118: LD_EXP 64
25122: PUSH
25123: LD_VAR 0 1
25127: ARRAY
25128: PPUSH
25129: LD_INT 81
25131: PUSH
25132: LD_VAR 0 1
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PPUSH
25141: CALL_OW 70
25145: UNION
25146: ST_TO_ADDR
// end ; end_of_file
25147: LD_VAR 0 2
25151: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25152: LD_INT 0
25154: PPUSH
25155: PPUSH
25156: PPUSH
// pom := GetBase ( fac ) ;
25157: LD_ADDR_VAR 0 5
25161: PUSH
25162: LD_VAR 0 1
25166: PPUSH
25167: CALL_OW 274
25171: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25172: LD_ADDR_VAR 0 4
25176: PUSH
25177: LD_VAR 0 2
25181: PUSH
25182: LD_INT 1
25184: ARRAY
25185: PPUSH
25186: LD_VAR 0 2
25190: PUSH
25191: LD_INT 2
25193: ARRAY
25194: PPUSH
25195: LD_VAR 0 2
25199: PUSH
25200: LD_INT 3
25202: ARRAY
25203: PPUSH
25204: LD_VAR 0 2
25208: PUSH
25209: LD_INT 4
25211: ARRAY
25212: PPUSH
25213: CALL_OW 449
25217: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25218: LD_ADDR_VAR 0 3
25222: PUSH
25223: LD_VAR 0 5
25227: PPUSH
25228: LD_INT 1
25230: PPUSH
25231: CALL_OW 275
25235: PUSH
25236: LD_VAR 0 4
25240: PUSH
25241: LD_INT 1
25243: ARRAY
25244: GREATEREQUAL
25245: PUSH
25246: LD_VAR 0 5
25250: PPUSH
25251: LD_INT 2
25253: PPUSH
25254: CALL_OW 275
25258: PUSH
25259: LD_VAR 0 4
25263: PUSH
25264: LD_INT 2
25266: ARRAY
25267: GREATEREQUAL
25268: AND
25269: PUSH
25270: LD_VAR 0 5
25274: PPUSH
25275: LD_INT 3
25277: PPUSH
25278: CALL_OW 275
25282: PUSH
25283: LD_VAR 0 4
25287: PUSH
25288: LD_INT 3
25290: ARRAY
25291: GREATEREQUAL
25292: AND
25293: ST_TO_ADDR
// end ;
25294: LD_VAR 0 3
25298: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25299: LD_INT 0
25301: PPUSH
25302: PPUSH
25303: PPUSH
// result := false ;
25304: LD_ADDR_VAR 0 3
25308: PUSH
25309: LD_INT 0
25311: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25312: LD_ADDR_VAR 0 4
25316: PUSH
25317: LD_EXP 51
25321: PUSH
25322: LD_VAR 0 1
25326: ARRAY
25327: ST_TO_ADDR
// if tmp then
25328: LD_VAR 0 4
25332: IFFALSE 25386
// for i = 1 to tmp do
25334: LD_ADDR_VAR 0 5
25338: PUSH
25339: DOUBLE
25340: LD_INT 1
25342: DEC
25343: ST_TO_ADDR
25344: LD_VAR 0 4
25348: PUSH
25349: FOR_TO
25350: IFFALSE 25384
// if component = tmp [ i ] then
25352: LD_VAR 0 2
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_VAR 0 5
25366: ARRAY
25367: EQUAL
25368: IFFALSE 25382
// begin result := true ;
25370: LD_ADDR_VAR 0 3
25374: PUSH
25375: LD_INT 1
25377: ST_TO_ADDR
// exit ;
25378: POP
25379: POP
25380: GO 25386
// end ;
25382: GO 25349
25384: POP
25385: POP
// end ;
25386: LD_VAR 0 3
25390: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25391: LD_INT 0
25393: PPUSH
25394: PPUSH
25395: PPUSH
// result := false ;
25396: LD_ADDR_VAR 0 4
25400: PUSH
25401: LD_INT 0
25403: ST_TO_ADDR
// if fac then
25404: LD_VAR 0 2
25408: IFFALSE 25631
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25410: LD_VAR 0 2
25414: PPUSH
25415: LD_VAR 0 3
25419: PPUSH
25420: CALL 25152 0 2
25424: PUSH
25425: LD_VAR 0 2
25429: PPUSH
25430: CALL_OW 461
25434: PUSH
25435: LD_INT 2
25437: EQUAL
25438: AND
25439: PUSH
25440: LD_VAR 0 2
25444: PPUSH
25445: LD_VAR 0 3
25449: PUSH
25450: LD_INT 1
25452: ARRAY
25453: PPUSH
25454: LD_VAR 0 3
25458: PUSH
25459: LD_INT 2
25461: ARRAY
25462: PPUSH
25463: LD_VAR 0 3
25467: PUSH
25468: LD_INT 3
25470: ARRAY
25471: PPUSH
25472: LD_VAR 0 3
25476: PUSH
25477: LD_INT 4
25479: ARRAY
25480: PPUSH
25481: CALL_OW 448
25485: AND
25486: IFFALSE 25631
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25488: LD_VAR 0 2
25492: PPUSH
25493: LD_VAR 0 3
25497: PUSH
25498: LD_INT 1
25500: ARRAY
25501: PPUSH
25502: LD_VAR 0 3
25506: PUSH
25507: LD_INT 2
25509: ARRAY
25510: PPUSH
25511: LD_VAR 0 3
25515: PUSH
25516: LD_INT 3
25518: ARRAY
25519: PPUSH
25520: LD_VAR 0 3
25524: PUSH
25525: LD_INT 4
25527: ARRAY
25528: PPUSH
25529: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25533: LD_ADDR_VAR 0 6
25537: PUSH
25538: LD_EXP 51
25542: PUSH
25543: LD_VAR 0 1
25547: ARRAY
25548: ST_TO_ADDR
// for i = 4 downto 1 do
25549: LD_ADDR_VAR 0 5
25553: PUSH
25554: DOUBLE
25555: LD_INT 4
25557: INC
25558: ST_TO_ADDR
25559: LD_INT 1
25561: PUSH
25562: FOR_DOWNTO
25563: IFFALSE 25596
// tab := Remove ( tab , list [ i ] , true ) ;
25565: LD_ADDR_VAR 0 6
25569: PUSH
25570: LD_VAR 0 6
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_VAR 0 5
25584: ARRAY
25585: PPUSH
25586: LD_INT 1
25588: PPUSH
25589: CALL 31170 0 3
25593: ST_TO_ADDR
25594: GO 25562
25596: POP
25597: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25598: LD_ADDR_EXP 51
25602: PUSH
25603: LD_EXP 51
25607: PPUSH
25608: LD_VAR 0 1
25612: PPUSH
25613: LD_VAR 0 6
25617: PPUSH
25618: CALL_OW 1
25622: ST_TO_ADDR
// result := true ;
25623: LD_ADDR_VAR 0 4
25627: PUSH
25628: LD_INT 1
25630: ST_TO_ADDR
// end ; end ; end ;
25631: LD_VAR 0 4
25635: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25636: LD_INT 0
25638: PPUSH
25639: PPUSH
// if not veh then
25640: LD_VAR 0 2
25644: NOT
25645: IFFALSE 25649
// exit ;
25647: GO 25823
// if MREG_Parking [ side ] then
25649: LD_EXP 58
25653: PUSH
25654: LD_VAR 0 1
25658: ARRAY
25659: IFFALSE 25823
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25661: LD_VAR 0 2
25665: PPUSH
25666: LD_EXP 58
25670: PUSH
25671: LD_VAR 0 1
25675: ARRAY
25676: PPUSH
25677: CALL_OW 308
25681: NOT
25682: IFFALSE 25823
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25684: LD_VAR 0 2
25688: PPUSH
25689: LD_EXP 58
25693: PUSH
25694: LD_VAR 0 1
25698: ARRAY
25699: PPUSH
25700: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25704: LD_VAR 0 2
25708: PPUSH
25709: CALL_OW 263
25713: PUSH
25714: LD_INT 1
25716: EQUAL
25717: IFFALSE 25823
// begin i := GetDriver ( veh ) ;
25719: LD_ADDR_VAR 0 4
25723: PUSH
25724: LD_VAR 0 2
25728: PPUSH
25729: CALL 31654 0 1
25733: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25734: LD_INT 35
25736: PPUSH
25737: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25741: LD_VAR 0 2
25745: PPUSH
25746: LD_EXP 58
25750: PUSH
25751: LD_VAR 0 1
25755: ARRAY
25756: PPUSH
25757: CALL_OW 308
25761: PUSH
25762: LD_VAR 0 2
25766: PPUSH
25767: CALL_OW 301
25771: OR
25772: IFFALSE 25734
// ComExitVehicle ( i ) ;
25774: LD_VAR 0 4
25778: PPUSH
25779: CALL_OW 121
// Wait ( 1 ) ;
25783: LD_INT 1
25785: PPUSH
25786: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25790: LD_VAR 0 4
25794: PPUSH
25795: LD_VAR 0 1
25799: PPUSH
25800: LD_INT 30
25802: PUSH
25803: LD_INT 3
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PPUSH
25810: CALL 11546 0 2
25814: PUSH
25815: LD_INT 1
25817: ARRAY
25818: PPUSH
25819: CALL_OW 180
// end ; end ; end ;
25823: LD_VAR 0 3
25827: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25828: LD_INT 0
25830: PPUSH
25831: PPUSH
25832: PPUSH
25833: PPUSH
25834: PPUSH
25835: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25836: LD_VAR 0 1
25840: PPUSH
25841: LD_INT 30
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PPUSH
25851: CALL 11546 0 2
25855: IFFALSE 26039
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25857: LD_VAR 0 1
25861: PPUSH
25862: LD_INT 30
25864: PUSH
25865: LD_INT 3
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PPUSH
25872: CALL 11546 0 2
25876: PUSH
25877: LD_INT 1
25879: ARRAY
25880: PPUSH
25881: CALL_OW 461
25885: PUSH
25886: LD_INT 2
25888: EQUAL
25889: IFFALSE 26039
// begin for i = 1 to MREG_TurretWeapon do
25891: LD_ADDR_VAR 0 3
25895: PUSH
25896: DOUBLE
25897: LD_INT 1
25899: DEC
25900: ST_TO_ADDR
25901: LD_EXP 43
25905: PUSH
25906: FOR_TO
25907: IFFALSE 26037
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25909: LD_EXP 43
25913: PUSH
25914: LD_VAR 0 3
25918: ARRAY
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PUSH
25924: LD_VAR 0 1
25928: EQUAL
25929: IFFALSE 26035
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25931: LD_ADDR_VAR 0 5
25935: PUSH
25936: LD_EXP 43
25940: PUSH
25941: LD_VAR 0 3
25945: ARRAY
25946: PUSH
25947: LD_INT 2
25949: ARRAY
25950: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25951: LD_ADDR_VAR 0 6
25955: PUSH
25956: LD_EXP 43
25960: PUSH
25961: LD_VAR 0 3
25965: ARRAY
25966: PUSH
25967: LD_INT 3
25969: ARRAY
25970: PUSH
25971: LD_INT 1
25973: ARRAY
25974: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25975: LD_ADDR_VAR 0 7
25979: PUSH
25980: LD_EXP 43
25984: PUSH
25985: LD_VAR 0 3
25989: ARRAY
25990: PUSH
25991: LD_INT 3
25993: ARRAY
25994: PUSH
25995: LD_INT 2
25997: ARRAY
25998: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25999: LD_ADDR_VAR 0 4
26003: PUSH
26004: LD_VAR 0 6
26008: PPUSH
26009: LD_VAR 0 7
26013: PPUSH
26014: CALL_OW 428
26018: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26019: LD_VAR 0 4
26023: PPUSH
26024: LD_VAR 0 5
26028: PPUSH
26029: CALL_OW 148
// break ;
26033: GO 26037
// end ;
26035: GO 25906
26037: POP
26038: POP
// end ; end ;
26039: LD_VAR 0 2
26043: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26044: LD_INT 0
26046: PPUSH
26047: PPUSH
26048: PPUSH
26049: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26050: LD_ADDR_VAR 0 4
26054: PUSH
26055: LD_VAR 0 1
26059: PPUSH
26060: LD_INT 32
26062: PUSH
26063: LD_INT 1
26065: PUSH
26066: EMPTY
26067: LIST
26068: LIST
26069: PPUSH
26070: CALL 11546 0 2
26074: ST_TO_ADDR
// if not tmp then
26075: LD_VAR 0 4
26079: NOT
26080: IFFALSE 26086
// exit else
26082: GO 26168
26084: GO 26168
// begin for i = 1 to tmp do
26086: LD_ADDR_VAR 0 3
26090: PUSH
26091: DOUBLE
26092: LD_INT 1
26094: DEC
26095: ST_TO_ADDR
26096: LD_VAR 0 4
26100: PUSH
26101: FOR_TO
26102: IFFALSE 26166
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26104: LD_VAR 0 4
26108: PUSH
26109: LD_VAR 0 3
26113: ARRAY
26114: PPUSH
26115: CALL_OW 261
26119: PUSH
26120: LD_INT 20
26122: LESS
26123: PUSH
26124: LD_VAR 0 4
26128: PUSH
26129: LD_VAR 0 3
26133: ARRAY
26134: PPUSH
26135: CALL_OW 110
26139: PUSH
26140: LD_INT 0
26142: EQUAL
26143: AND
26144: IFFALSE 26164
// begin SetTag ( tmp [ i ] , 21 ) ;
26146: LD_VAR 0 4
26150: PUSH
26151: LD_VAR 0 3
26155: ARRAY
26156: PPUSH
26157: LD_INT 21
26159: PPUSH
26160: CALL_OW 109
// end ;
26164: GO 26101
26166: POP
26167: POP
// end ; end ;
26168: LD_VAR 0 2
26172: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26173: LD_INT 0
26175: PPUSH
26176: PPUSH
26177: PPUSH
26178: PPUSH
26179: PPUSH
// if not unit then
26180: LD_VAR 0 1
26184: NOT
26185: IFFALSE 26189
// exit ;
26187: GO 26377
// side := GetSide ( unit ) ;
26189: LD_ADDR_VAR 0 3
26193: PUSH
26194: LD_VAR 0 1
26198: PPUSH
26199: CALL_OW 255
26203: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26204: LD_ADDR_VAR 0 5
26208: PUSH
26209: LD_VAR 0 3
26213: PPUSH
26214: LD_INT 2
26216: PUSH
26217: LD_INT 30
26219: PUSH
26220: LD_INT 1
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 30
26229: PUSH
26230: LD_INT 3
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: PUSH
26237: LD_INT 30
26239: PUSH
26240: LD_INT 29
26242: PUSH
26243: EMPTY
26244: LIST
26245: LIST
26246: PUSH
26247: EMPTY
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: PPUSH
26253: CALL 11546 0 2
26257: ST_TO_ADDR
// if not b then
26258: LD_VAR 0 5
26262: NOT
26263: IFFALSE 26267
// exit ;
26265: GO 26377
// if GetTag ( unit ) = 21 then
26267: LD_VAR 0 1
26271: PPUSH
26272: CALL_OW 110
26276: PUSH
26277: LD_INT 21
26279: EQUAL
26280: IFFALSE 26377
// begin c := NearestUnitToUnit ( b , unit ) ;
26282: LD_ADDR_VAR 0 6
26286: PUSH
26287: LD_VAR 0 5
26291: PPUSH
26292: LD_VAR 0 1
26296: PPUSH
26297: CALL_OW 74
26301: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26302: LD_VAR 0 1
26306: PPUSH
26307: LD_VAR 0 6
26311: PPUSH
26312: CALL_OW 250
26316: PPUSH
26317: LD_VAR 0 6
26321: PPUSH
26322: CALL_OW 251
26326: PPUSH
26327: CALL_OW 297
26331: PUSH
26332: LD_INT 6
26334: GREATER
26335: IFFALSE 26353
// ComMoveUnit ( unit , c ) else
26337: LD_VAR 0 1
26341: PPUSH
26342: LD_VAR 0 6
26346: PPUSH
26347: CALL_OW 112
26351: GO 26377
// begin SetFuel ( unit , 100 ) ;
26353: LD_VAR 0 1
26357: PPUSH
26358: LD_INT 100
26360: PPUSH
26361: CALL_OW 240
// SetTag ( unit , 0 ) ;
26365: LD_VAR 0 1
26369: PPUSH
26370: LD_INT 0
26372: PPUSH
26373: CALL_OW 109
// end ; end ; end ;
26377: LD_VAR 0 2
26381: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26382: LD_INT 0
26384: PPUSH
26385: PPUSH
26386: PPUSH
26387: PPUSH
26388: PPUSH
26389: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26390: LD_ADDR_VAR 0 7
26394: PUSH
26395: LD_VAR 0 1
26399: PPUSH
26400: LD_INT 33
26402: PUSH
26403: LD_INT 2
26405: PUSH
26406: EMPTY
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 3
26412: PUSH
26413: LD_INT 61
26415: PUSH
26416: EMPTY
26417: LIST
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PPUSH
26427: CALL 11546 0 2
26431: ST_TO_ADDR
// if not vehs then
26432: LD_VAR 0 7
26436: NOT
26437: IFFALSE 26441
// exit ;
26439: GO 26726
// if nation = 1 then
26441: LD_VAR 0 2
26445: PUSH
26446: LD_INT 1
26448: EQUAL
26449: IFFALSE 26619
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26451: LD_VAR 0 1
26455: PPUSH
26456: LD_INT 30
26458: PUSH
26459: LD_INT 36
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PPUSH
26466: CALL 11546 0 2
26470: NOT
26471: IFFALSE 26477
// exit else
26473: GO 26726
26475: GO 26617
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26477: LD_ADDR_VAR 0 5
26481: PUSH
26482: LD_VAR 0 1
26486: PPUSH
26487: LD_INT 30
26489: PUSH
26490: LD_INT 36
26492: PUSH
26493: EMPTY
26494: LIST
26495: LIST
26496: PPUSH
26497: CALL 11546 0 2
26501: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26502: LD_ADDR_VAR 0 6
26506: PUSH
26507: LD_VAR 0 5
26511: PUSH
26512: LD_INT 1
26514: ARRAY
26515: PPUSH
26516: CALL_OW 313
26520: ST_TO_ADDR
// for i = vehs downto 1 do
26521: LD_ADDR_VAR 0 4
26525: PUSH
26526: DOUBLE
26527: LD_VAR 0 7
26531: INC
26532: ST_TO_ADDR
26533: LD_INT 1
26535: PUSH
26536: FOR_DOWNTO
26537: IFFALSE 26615
// begin if not IsControledBy ( vehs [ i ] ) then
26539: LD_VAR 0 7
26543: PUSH
26544: LD_VAR 0 4
26548: ARRAY
26549: PPUSH
26550: CALL_OW 312
26554: NOT
26555: IFFALSE 26613
// begin tmp := MCV_RemoteDriver ( oper ) ;
26557: LD_ADDR_VAR 0 8
26561: PUSH
26562: LD_VAR 0 6
26566: PPUSH
26567: CALL 26731 0 1
26571: ST_TO_ADDR
// if not tmp then
26572: LD_VAR 0 8
26576: NOT
26577: IFFALSE 26585
// exit else
26579: POP
26580: POP
26581: GO 26726
26583: GO 26613
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26585: LD_VAR 0 7
26589: PUSH
26590: LD_VAR 0 4
26594: ARRAY
26595: PPUSH
26596: LD_VAR 0 8
26600: PUSH
26601: LD_INT 1
26603: ARRAY
26604: PUSH
26605: LD_INT 1
26607: ARRAY
26608: PPUSH
26609: CALL_OW 135
// end ; end ;
26613: GO 26536
26615: POP
26616: POP
// end ; end else
26617: GO 26726
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26619: LD_VAR 0 1
26623: PPUSH
26624: LD_INT 34
26626: PUSH
26627: LD_INT 31
26629: PUSH
26630: EMPTY
26631: LIST
26632: LIST
26633: PPUSH
26634: CALL 11546 0 2
26638: NOT
26639: IFFALSE 26645
// exit else
26641: GO 26726
26643: GO 26726
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26645: LD_ADDR_VAR 0 5
26649: PUSH
26650: LD_VAR 0 1
26654: PPUSH
26655: LD_INT 34
26657: PUSH
26658: LD_INT 31
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PPUSH
26665: CALL 11546 0 2
26669: ST_TO_ADDR
// oper := [ ] ;
26670: LD_ADDR_VAR 0 6
26674: PUSH
26675: EMPTY
26676: ST_TO_ADDR
// for i = 1 to ct do
26677: LD_ADDR_VAR 0 4
26681: PUSH
26682: DOUBLE
26683: LD_INT 1
26685: DEC
26686: ST_TO_ADDR
26687: LD_VAR 0 5
26691: PUSH
26692: FOR_TO
26693: IFFALSE 26724
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26695: LD_ADDR_VAR 0 6
26699: PUSH
26700: LD_VAR 0 6
26704: PUSH
26705: LD_VAR 0 5
26709: PUSH
26710: LD_VAR 0 4
26714: ARRAY
26715: PPUSH
26716: CALL 31654 0 1
26720: ADD
26721: ST_TO_ADDR
26722: GO 26692
26724: POP
26725: POP
// end ; end ; end ;
26726: LD_VAR 0 3
26730: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26731: LD_INT 0
26733: PPUSH
26734: PPUSH
26735: PPUSH
26736: PPUSH
26737: PPUSH
26738: PPUSH
// if not drivers then
26739: LD_VAR 0 1
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 27030
26748: GO 27030
// begin linked := [ ] ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: EMPTY
26756: ST_TO_ADDR
// for i = 1 to drivers do
26757: LD_ADDR_VAR 0 3
26761: PUSH
26762: DOUBLE
26763: LD_INT 1
26765: DEC
26766: ST_TO_ADDR
26767: LD_VAR 0 1
26771: PUSH
26772: FOR_TO
26773: IFFALSE 27018
// begin if CanControl ( drivers [ i ] ) then
26775: LD_VAR 0 1
26779: PUSH
26780: LD_VAR 0 3
26784: ARRAY
26785: PPUSH
26786: CALL 32044 0 1
26790: IFFALSE 27016
// if i > 1 then
26792: LD_VAR 0 3
26796: PUSH
26797: LD_INT 1
26799: GREATER
26800: IFFALSE 26977
// begin m := false ;
26802: LD_ADDR_VAR 0 6
26806: PUSH
26807: LD_INT 0
26809: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26810: LD_ADDR_VAR 0 7
26814: PUSH
26815: LD_VAR 0 1
26819: PUSH
26820: LD_VAR 0 3
26824: ARRAY
26825: PPUSH
26826: CALL_OW 432
26830: ST_TO_ADDR
// for j = 1 to linked do
26831: LD_ADDR_VAR 0 4
26835: PUSH
26836: DOUBLE
26837: LD_INT 1
26839: DEC
26840: ST_TO_ADDR
26841: LD_VAR 0 5
26845: PUSH
26846: FOR_TO
26847: IFFALSE 26921
// begin if l < linked [ j ] [ 2 ] then
26849: LD_VAR 0 7
26853: PUSH
26854: LD_VAR 0 5
26858: PUSH
26859: LD_VAR 0 4
26863: ARRAY
26864: PUSH
26865: LD_INT 2
26867: ARRAY
26868: LESS
26869: IFFALSE 26919
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: LD_VAR 0 5
26880: PPUSH
26881: LD_INT 1
26883: PPUSH
26884: LD_VAR 0 1
26888: PUSH
26889: LD_VAR 0 3
26893: ARRAY
26894: PUSH
26895: LD_VAR 0 7
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: PPUSH
26904: CALL_OW 2
26908: ST_TO_ADDR
// m := true ;
26909: LD_ADDR_VAR 0 6
26913: PUSH
26914: LD_INT 1
26916: ST_TO_ADDR
// break ;
26917: GO 26921
// end ; end ;
26919: GO 26846
26921: POP
26922: POP
// if not m then
26923: LD_VAR 0 6
26927: NOT
26928: IFFALSE 26975
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26930: LD_ADDR_VAR 0 5
26934: PUSH
26935: LD_VAR 0 5
26939: PUSH
26940: LD_VAR 0 1
26944: PUSH
26945: LD_VAR 0 3
26949: ARRAY
26950: PUSH
26951: LD_VAR 0 1
26955: PUSH
26956: LD_VAR 0 3
26960: ARRAY
26961: PPUSH
26962: CALL_OW 432
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: EMPTY
26972: LIST
26973: ADD
26974: ST_TO_ADDR
// end else
26975: GO 27016
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26977: LD_ADDR_VAR 0 5
26981: PUSH
26982: LD_VAR 0 1
26986: PUSH
26987: LD_VAR 0 3
26991: ARRAY
26992: PUSH
26993: LD_VAR 0 1
26997: PUSH
26998: LD_VAR 0 3
27002: ARRAY
27003: PPUSH
27004: CALL_OW 432
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: EMPTY
27014: LIST
27015: ST_TO_ADDR
// end ;
27016: GO 26772
27018: POP
27019: POP
// result := linked ;
27020: LD_ADDR_VAR 0 2
27024: PUSH
27025: LD_VAR 0 5
27029: ST_TO_ADDR
// end ; end ;
27030: LD_VAR 0 2
27034: RET
// export function MCV_ToRepair ( unit ) ; begin
27035: LD_INT 0
27037: PPUSH
// if not unit then
27038: LD_VAR 0 1
27042: NOT
27043: IFFALSE 27047
// exit ;
27045: GO 27078
// SetTag ( unit , 6 ) ;
27047: LD_VAR 0 1
27051: PPUSH
27052: LD_INT 6
27054: PPUSH
27055: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27059: LD_VAR 0 1
27063: PPUSH
27064: CALL_OW 255
27068: PPUSH
27069: LD_VAR 0 1
27073: PPUSH
27074: CALL 25636 0 2
// end ;
27078: LD_VAR 0 2
27082: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27083: LD_INT 0
27085: PPUSH
27086: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27087: LD_VAR 0 1
27091: PPUSH
27092: LD_INT 6
27094: PPUSH
27095: EMPTY
27096: PPUSH
27097: CALL 12249 0 3
27101: IFFALSE 27194
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27103: LD_ADDR_VAR 0 3
27107: PUSH
27108: DOUBLE
27109: LD_VAR 0 1
27113: PPUSH
27114: LD_INT 6
27116: PPUSH
27117: EMPTY
27118: PPUSH
27119: CALL 12249 0 3
27123: INC
27124: ST_TO_ADDR
27125: LD_INT 1
27127: PUSH
27128: FOR_DOWNTO
27129: IFFALSE 27192
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27131: LD_VAR 0 1
27135: PPUSH
27136: LD_INT 6
27138: PPUSH
27139: EMPTY
27140: PPUSH
27141: CALL 12249 0 3
27145: PUSH
27146: LD_VAR 0 3
27150: ARRAY
27151: PPUSH
27152: CALL_OW 256
27156: PUSH
27157: LD_INT 1000
27159: EQUAL
27160: IFFALSE 27190
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27162: LD_VAR 0 1
27166: PPUSH
27167: LD_INT 6
27169: PPUSH
27170: EMPTY
27171: PPUSH
27172: CALL 12249 0 3
27176: PUSH
27177: LD_VAR 0 3
27181: ARRAY
27182: PPUSH
27183: LD_INT 0
27185: PPUSH
27186: CALL_OW 109
27190: GO 27128
27192: POP
27193: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27194: LD_VAR 0 1
27198: PPUSH
27199: LD_INT 10
27201: PPUSH
27202: EMPTY
27203: PPUSH
27204: CALL 12249 0 3
27208: IFFALSE 27325
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27210: LD_ADDR_VAR 0 3
27214: PUSH
27215: DOUBLE
27216: LD_VAR 0 1
27220: PPUSH
27221: LD_INT 10
27223: PPUSH
27224: EMPTY
27225: PPUSH
27226: CALL 12249 0 3
27230: INC
27231: ST_TO_ADDR
27232: LD_INT 1
27234: PUSH
27235: FOR_DOWNTO
27236: IFFALSE 27323
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27238: LD_VAR 0 1
27242: PPUSH
27243: LD_INT 10
27245: PPUSH
27246: EMPTY
27247: PPUSH
27248: CALL 12249 0 3
27252: PUSH
27253: LD_VAR 0 3
27257: ARRAY
27258: PPUSH
27259: CALL_OW 302
27263: NOT
27264: PUSH
27265: LD_VAR 0 1
27269: PPUSH
27270: LD_INT 10
27272: PPUSH
27273: EMPTY
27274: PPUSH
27275: CALL 12249 0 3
27279: PUSH
27280: LD_VAR 0 3
27284: ARRAY
27285: PPUSH
27286: CALL_OW 301
27290: OR
27291: IFFALSE 27321
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27293: LD_VAR 0 1
27297: PPUSH
27298: LD_INT 10
27300: PPUSH
27301: EMPTY
27302: PPUSH
27303: CALL 12249 0 3
27307: PUSH
27308: LD_VAR 0 3
27312: ARRAY
27313: PPUSH
27314: LD_INT 0
27316: PPUSH
27317: CALL_OW 109
27321: GO 27235
27323: POP
27324: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27325: LD_ADDR_VAR 0 3
27329: PUSH
27330: LD_VAR 0 1
27334: PPUSH
27335: EMPTY
27336: PPUSH
27337: CALL 11847 0 2
27341: PUSH
27342: LD_VAR 0 1
27346: PPUSH
27347: LD_INT 7
27349: PPUSH
27350: EMPTY
27351: PPUSH
27352: CALL 12249 0 3
27356: DIFF
27357: PUSH
27358: FOR_IN
27359: IFFALSE 27403
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27361: LD_VAR 0 3
27365: PPUSH
27366: CALL_OW 256
27370: PUSH
27371: LD_INT 650
27373: LESS
27374: PUSH
27375: LD_VAR 0 3
27379: PPUSH
27380: CALL_OW 110
27384: PUSH
27385: LD_INT 6
27387: EQUAL
27388: NOT
27389: AND
27390: IFFALSE 27401
// MCV_ToRepair ( i ) ;
27392: LD_VAR 0 3
27396: PPUSH
27397: CALL 27035 0 1
27401: GO 27358
27403: POP
27404: POP
// end ; end_of_file end_of_file
27405: LD_VAR 0 2
27409: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27410: LD_STRING SAILEvent [
27412: PUSH
27413: LD_VAR 0 1
27417: STR
27418: PUSH
27419: LD_STRING ]
27421: STR
27422: PPUSH
27423: CALL 7934 0 1
// if event = 101 and dialog_north then
27427: LD_VAR 0 1
27431: PUSH
27432: LD_INT 101
27434: EQUAL
27435: PUSH
27436: LD_EXP 6
27440: AND
27441: IFFALSE 27505
// begin dialog_north := false ;
27443: LD_ADDR_EXP 6
27447: PUSH
27448: LD_INT 0
27450: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27451: LD_EXP 5
27455: PPUSH
27456: LD_STRING DS1
27458: PUSH
27459: LD_STRING DS2
27461: PUSH
27462: LD_STRING DS3
27464: PUSH
27465: LD_STRING DS6
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: LIST
27472: LIST
27473: PUSH
27474: LD_INT 1
27476: PPUSH
27477: LD_INT 4
27479: PPUSH
27480: CALL_OW 12
27484: ARRAY
27485: PPUSH
27486: CALL_OW 94
// Wait ( 4 4$00 ) ;
27490: LD_INT 8400
27492: PPUSH
27493: CALL_OW 67
// dialog_north := true ;
27497: LD_ADDR_EXP 6
27501: PUSH
27502: LD_INT 1
27504: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27505: LD_VAR 0 1
27509: PUSH
27510: LD_INT 102
27512: EQUAL
27513: PUSH
27514: LD_EXP 7
27518: AND
27519: IFFALSE 27579
// begin dialog_south := false ;
27521: LD_ADDR_EXP 7
27525: PUSH
27526: LD_INT 0
27528: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27529: LD_EXP 4
27533: PPUSH
27534: LD_STRING DJ1
27536: PUSH
27537: LD_STRING DJ4
27539: PUSH
27540: LD_STRING DJ6
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 1
27550: PPUSH
27551: LD_INT 3
27553: PPUSH
27554: CALL_OW 12
27558: ARRAY
27559: PPUSH
27560: CALL_OW 94
// Wait ( 4 4$00 ) ;
27564: LD_INT 8400
27566: PPUSH
27567: CALL_OW 67
// dialog_south := true ;
27571: LD_ADDR_EXP 7
27575: PUSH
27576: LD_INT 1
27578: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27579: LD_VAR 0 1
27583: PUSH
27584: LD_INT 104
27586: EQUAL
27587: PUSH
27588: LD_EXP 8
27592: AND
27593: IFFALSE 27615
// begin dialog_popov := false ;
27595: LD_ADDR_EXP 8
27599: PUSH
27600: LD_INT 0
27602: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27603: LD_EXP 24
27607: PPUSH
27608: LD_STRING DR4
27610: PPUSH
27611: CALL_OW 94
// end ; end ;
27615: PPOPN 1
27617: END
// on BuildingStarted ( b , unit ) do var side , i ;
27618: LD_INT 0
27620: PPUSH
27621: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27622: LD_EXP 39
27626: PUSH
27627: LD_VAR 0 1
27631: PPUSH
27632: CALL_OW 255
27636: ARRAY
27637: IFFALSE 27815
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27639: LD_STRING BuildingStarted [side: 
27641: PUSH
27642: LD_VAR 0 1
27646: PPUSH
27647: CALL_OW 255
27651: STR
27652: PUSH
27653: LD_STRING ; btype: 
27655: STR
27656: PUSH
27657: LD_VAR 0 1
27661: PPUSH
27662: CALL_OW 266
27666: STR
27667: PUSH
27668: LD_STRING ; unit: 
27670: STR
27671: PUSH
27672: LD_VAR 0 2
27676: STR
27677: PUSH
27678: LD_STRING ]
27680: STR
27681: PPUSH
27682: CALL 7934 0 1
// side := GetSide ( b ) ;
27686: LD_ADDR_VAR 0 3
27690: PUSH
27691: LD_VAR 0 1
27695: PPUSH
27696: CALL_OW 255
27700: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27701: LD_VAR 0 3
27705: PPUSH
27706: LD_INT 21
27708: PUSH
27709: LD_INT 3
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PPUSH
27716: CALL 11546 0 2
27720: PUSH
27721: LD_INT 1
27723: EQUAL
27724: IFFALSE 27815
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27726: LD_ADDR_VAR 0 4
27730: PUSH
27731: LD_VAR 0 3
27735: PPUSH
27736: LD_INT 21
27738: PUSH
27739: LD_INT 1
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PPUSH
27746: CALL 11546 0 2
27750: PUSH
27751: LD_VAR 0 3
27755: PPUSH
27756: LD_INT 2
27758: PPUSH
27759: EMPTY
27760: PPUSH
27761: CALL 11629 0 3
27765: DIFF
27766: PUSH
27767: FOR_IN
27768: IFFALSE 27813
// if not HasTask ( i ) then
27770: LD_VAR 0 4
27774: PPUSH
27775: CALL_OW 314
27779: NOT
27780: IFFALSE 27811
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27782: LD_VAR 0 4
27786: PPUSH
27787: LD_VAR 0 1
27791: PPUSH
27792: CALL_OW 250
27796: PPUSH
27797: LD_VAR 0 1
27801: PPUSH
27802: CALL_OW 251
27806: PPUSH
27807: CALL_OW 111
27811: GO 27767
27813: POP
27814: POP
// end ;
27815: PPOPN 4
27817: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27818: LD_EXP 39
27822: PUSH
27823: LD_VAR 0 1
27827: PPUSH
27828: CALL_OW 255
27832: ARRAY
27833: IFFALSE 28202
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27835: LD_STRING BuildingComplete [side: 
27837: PUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 255
27847: STR
27848: PUSH
27849: LD_STRING ; btype: 
27851: STR
27852: PUSH
27853: LD_VAR 0 1
27857: PPUSH
27858: CALL_OW 266
27862: STR
27863: PUSH
27864: LD_STRING ]
27866: STR
27867: PPUSH
27868: CALL 7934 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27872: LD_ADDR_EXP 46
27876: PUSH
27877: LD_EXP 46
27881: PPUSH
27882: LD_VAR 0 1
27886: PPUSH
27887: CALL_OW 255
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 266
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 250
27911: PUSH
27912: LD_VAR 0 1
27916: PPUSH
27917: CALL_OW 251
27921: PUSH
27922: LD_VAR 0 1
27926: PPUSH
27927: CALL_OW 254
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: LIST
27936: PPUSH
27937: CALL 41932 0 4
27941: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27942: LD_VAR 0 1
27946: PPUSH
27947: CALL_OW 266
27951: PUSH
27952: LD_INT 6
27954: EQUAL
27955: IFFALSE 27989
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27957: LD_ADDR_EXP 40
27961: PUSH
27962: LD_EXP 40
27966: PPUSH
27967: LD_VAR 0 1
27971: PPUSH
27972: CALL_OW 255
27976: PPUSH
27977: LD_VAR 0 1
27981: PPUSH
27982: EMPTY
27983: PPUSH
27984: CALL 41841 0 4
27988: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27989: LD_VAR 0 1
27993: PPUSH
27994: CALL_OW 266
27998: PUSH
27999: LD_INT 0
28001: EQUAL
28002: IFFALSE 28112
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28004: LD_ADDR_EXP 48
28008: PUSH
28009: LD_EXP 48
28013: PPUSH
28014: LD_VAR 0 1
28018: PPUSH
28019: CALL_OW 255
28023: PPUSH
28024: LD_INT 0
28026: PPUSH
28027: EMPTY
28028: PPUSH
28029: CALL 41841 0 4
28033: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28034: LD_VAR 0 1
28038: PPUSH
28039: CALL_OW 274
28043: PPUSH
28044: LD_INT 1
28046: PPUSH
28047: LD_EXP 72
28051: PUSH
28052: LD_INT 1
28054: ARRAY
28055: PPUSH
28056: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28060: LD_VAR 0 1
28064: PPUSH
28065: CALL_OW 274
28069: PPUSH
28070: LD_INT 2
28072: PPUSH
28073: LD_EXP 72
28077: PUSH
28078: LD_INT 2
28080: ARRAY
28081: PPUSH
28082: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28086: LD_VAR 0 1
28090: PPUSH
28091: CALL_OW 274
28095: PPUSH
28096: LD_INT 3
28098: PPUSH
28099: LD_EXP 72
28103: PUSH
28104: LD_INT 3
28106: ARRAY
28107: PPUSH
28108: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28112: LD_VAR 0 1
28116: PPUSH
28117: CALL_OW 266
28121: PUSH
28122: LD_INT 2
28124: EQUAL
28125: IFFALSE 28157
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28127: LD_ADDR_EXP 48
28131: PUSH
28132: LD_EXP 48
28136: PPUSH
28137: LD_VAR 0 1
28141: PPUSH
28142: CALL_OW 255
28146: PPUSH
28147: LD_INT 2
28149: PPUSH
28150: EMPTY
28151: PPUSH
28152: CALL 41841 0 4
28156: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28157: LD_VAR 0 1
28161: PPUSH
28162: CALL_OW 266
28166: PUSH
28167: LD_INT 4
28169: EQUAL
28170: IFFALSE 28202
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28172: LD_ADDR_EXP 48
28176: PUSH
28177: LD_EXP 48
28181: PPUSH
28182: LD_VAR 0 1
28186: PPUSH
28187: CALL_OW 255
28191: PPUSH
28192: LD_INT 4
28194: PPUSH
28195: EMPTY
28196: PPUSH
28197: CALL 41841 0 4
28201: ST_TO_ADDR
// end ;
28202: PPOPN 1
28204: END
// on ResearchComplete ( tech , lab ) do var i ;
28205: LD_INT 0
28207: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28208: LD_EXP 39
28212: PUSH
28213: LD_VAR 0 2
28217: PPUSH
28218: CALL_OW 255
28222: ARRAY
28223: IFFALSE 28507
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28225: LD_STRING ResearchComplete [side: 
28227: PUSH
28228: LD_VAR 0 2
28232: PPUSH
28233: CALL_OW 255
28237: PPUSH
28238: CALL_OW 255
28242: STR
28243: PUSH
28244: LD_STRING ; tech:
28246: STR
28247: PUSH
28248: LD_VAR 0 1
28252: STR
28253: PUSH
28254: LD_STRING ]
28256: STR
28257: PPUSH
28258: CALL 7934 0 1
// for i = 1 to MREG_ToRes do
28262: LD_ADDR_VAR 0 3
28266: PUSH
28267: DOUBLE
28268: LD_INT 1
28270: DEC
28271: ST_TO_ADDR
28272: LD_EXP 50
28276: PUSH
28277: FOR_TO
28278: IFFALSE 28365
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28280: LD_EXP 50
28284: PUSH
28285: LD_VAR 0 3
28289: ARRAY
28290: PUSH
28291: LD_INT 1
28293: ARRAY
28294: PUSH
28295: LD_VAR 0 2
28299: PPUSH
28300: CALL_OW 255
28304: EQUAL
28305: PUSH
28306: LD_EXP 50
28310: PUSH
28311: LD_VAR 0 3
28315: ARRAY
28316: PUSH
28317: LD_INT 2
28319: ARRAY
28320: PUSH
28321: LD_VAR 0 1
28325: EQUAL
28326: AND
28327: IFFALSE 28363
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28329: LD_ADDR_EXP 50
28333: PUSH
28334: LD_EXP 50
28338: PPUSH
28339: LD_VAR 0 2
28343: PPUSH
28344: CALL_OW 255
28348: PPUSH
28349: LD_VAR 0 1
28353: PPUSH
28354: EMPTY
28355: PPUSH
28356: CALL 41932 0 4
28360: ST_TO_ADDR
// break ;
28361: GO 28365
// end ;
28363: GO 28277
28365: POP
28366: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28367: LD_VAR 0 1
28371: PUSH
28372: LD_INT 2
28374: PUSH
28375: LD_INT 11
28377: PUSH
28378: LD_INT 4
28380: PUSH
28381: LD_INT 3
28383: PUSH
28384: EMPTY
28385: LIST
28386: LIST
28387: LIST
28388: LIST
28389: IN
28390: IFFALSE 28507
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28392: LD_ADDR_VAR 0 3
28396: PUSH
28397: LD_VAR 0 2
28401: PPUSH
28402: CALL_OW 255
28406: PPUSH
28407: LD_INT 16
28409: PPUSH
28410: LD_INT 25
28412: PUSH
28413: LD_INT 4
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PPUSH
28420: CALL 12249 0 3
28424: ST_TO_ADDR
// if i then
28425: LD_VAR 0 3
28429: IFFALSE 28447
// SetTag ( i [ 1 ] , 0 ) ;
28431: LD_VAR 0 3
28435: PUSH
28436: LD_INT 1
28438: ARRAY
28439: PPUSH
28440: LD_INT 0
28442: PPUSH
28443: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28447: LD_ADDR_VAR 0 3
28451: PUSH
28452: LD_VAR 0 2
28456: PPUSH
28457: CALL_OW 255
28461: PPUSH
28462: LD_INT 171
28464: PPUSH
28465: EMPTY
28466: PPUSH
28467: CALL 12249 0 3
28471: ST_TO_ADDR
// if i then
28472: LD_VAR 0 3
28476: IFFALSE 28507
// begin SetTag ( i [ 1 ] , 0 ) ;
28478: LD_VAR 0 3
28482: PUSH
28483: LD_INT 1
28485: ARRAY
28486: PPUSH
28487: LD_INT 0
28489: PPUSH
28490: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28494: LD_VAR 0 3
28498: PUSH
28499: LD_INT 1
28501: ARRAY
28502: PPUSH
28503: CALL_OW 122
// end ; end ; end ;
28507: PPOPN 3
28509: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28510: LD_INT 0
28512: PPUSH
28513: PPUSH
28514: PPUSH
28515: PPUSH
28516: PPUSH
28517: PPUSH
28518: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28519: LD_EXP 39
28523: PUSH
28524: LD_VAR 0 2
28528: PPUSH
28529: CALL_OW 255
28533: ARRAY
28534: IFFALSE 29261
// begin side := GetSide ( veh ) ;
28536: LD_ADDR_VAR 0 4
28540: PUSH
28541: LD_VAR 0 1
28545: PPUSH
28546: CALL_OW 255
28550: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28551: LD_ADDR_VAR 0 6
28555: PUSH
28556: LD_VAR 0 1
28560: PPUSH
28561: CALL_OW 265
28565: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28566: LD_ADDR_VAR 0 7
28570: PUSH
28571: LD_VAR 0 1
28575: PPUSH
28576: CALL_OW 262
28580: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28581: LD_ADDR_VAR 0 8
28585: PUSH
28586: LD_VAR 0 1
28590: PPUSH
28591: CALL_OW 263
28595: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28596: LD_ADDR_VAR 0 9
28600: PUSH
28601: LD_VAR 0 1
28605: PPUSH
28606: CALL_OW 264
28610: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28611: LD_STRING VehicleConstructed [side: 
28613: PUSH
28614: LD_VAR 0 4
28618: STR
28619: PUSH
28620: LD_STRING ; id:
28622: STR
28623: PUSH
28624: LD_VAR 0 1
28628: STR
28629: PUSH
28630: LD_STRING ; components: [
28632: STR
28633: PUSH
28634: LD_VAR 0 6
28638: STR
28639: PUSH
28640: LD_STRING , 
28642: STR
28643: PUSH
28644: LD_VAR 0 7
28648: STR
28649: PUSH
28650: LD_STRING , 
28652: STR
28653: PUSH
28654: LD_VAR 0 8
28658: STR
28659: PUSH
28660: LD_STRING , 
28662: STR
28663: PUSH
28664: LD_VAR 0 9
28668: STR
28669: PUSH
28670: LD_STRING ]]
28672: STR
28673: PPUSH
28674: CALL 7934 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28678: LD_VAR 0 1
28682: PPUSH
28683: CALL_OW 264
28687: PUSH
28688: LD_INT 13
28690: PUSH
28691: LD_INT 12
28693: PUSH
28694: LD_INT 14
28696: PUSH
28697: LD_INT 51
28699: PUSH
28700: LD_INT 53
28702: PUSH
28703: LD_INT 52
28705: PUSH
28706: LD_INT 32
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: IN
28718: NOT
28719: IFFALSE 28761
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28721: LD_ADDR_EXP 59
28725: PUSH
28726: LD_EXP 59
28730: PPUSH
28731: LD_VAR 0 4
28735: PPUSH
28736: LD_EXP 59
28740: PUSH
28741: LD_VAR 0 4
28745: ARRAY
28746: PUSH
28747: LD_INT 1
28749: PLUS
28750: PPUSH
28751: LD_VAR 0 1
28755: PPUSH
28756: CALL 31011 0 4
28760: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28761: LD_VAR 0 1
28765: PPUSH
28766: CALL_OW 264
28770: PUSH
28771: LD_INT 31
28773: EQUAL
28774: IFFALSE 28793
// SetTag ( GetDriver ( veh ) , 9 ) ;
28776: LD_VAR 0 1
28780: PPUSH
28781: CALL 31654 0 1
28785: PPUSH
28786: LD_INT 9
28788: PPUSH
28789: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28793: LD_VAR 0 1
28797: PPUSH
28798: CALL_OW 264
28802: PUSH
28803: LD_INT 14
28805: PUSH
28806: LD_INT 53
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: IN
28813: IFFALSE 28850
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28815: LD_ADDR_EXP 42
28819: PUSH
28820: LD_EXP 42
28824: PPUSH
28825: LD_VAR 0 1
28829: PPUSH
28830: CALL_OW 255
28834: PPUSH
28835: LD_INT 2
28837: PPUSH
28838: LD_VAR 0 1
28842: PPUSH
28843: CALL 31011 0 4
28847: ST_TO_ADDR
// exit ;
28848: GO 29261
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28850: LD_VAR 0 1
28854: PPUSH
28855: CALL_OW 265
28859: PUSH
28860: LD_EXP 66
28864: PUSH
28865: LD_VAR 0 4
28869: ARRAY
28870: PUSH
28871: LD_INT 1
28873: ARRAY
28874: IN
28875: PUSH
28876: LD_VAR 0 1
28880: PPUSH
28881: CALL_OW 262
28885: PUSH
28886: LD_EXP 66
28890: PUSH
28891: LD_VAR 0 4
28895: ARRAY
28896: PUSH
28897: LD_INT 1
28899: ARRAY
28900: IN
28901: AND
28902: PUSH
28903: LD_VAR 0 1
28907: PPUSH
28908: CALL_OW 263
28912: PUSH
28913: LD_EXP 66
28917: PUSH
28918: LD_VAR 0 4
28922: ARRAY
28923: PUSH
28924: LD_INT 1
28926: ARRAY
28927: IN
28928: AND
28929: PUSH
28930: LD_VAR 0 1
28934: PPUSH
28935: CALL_OW 264
28939: PUSH
28940: LD_EXP 66
28944: PUSH
28945: LD_VAR 0 4
28949: ARRAY
28950: PUSH
28951: LD_INT 1
28953: ARRAY
28954: IN
28955: AND
28956: IFFALSE 29000
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28958: LD_ADDR_EXP 67
28962: PUSH
28963: LD_EXP 67
28967: PPUSH
28968: LD_VAR 0 4
28972: PPUSH
28973: LD_EXP 67
28977: PUSH
28978: LD_VAR 0 4
28982: ARRAY
28983: PUSH
28984: LD_INT 1
28986: PLUS
28987: PPUSH
28988: LD_VAR 0 1
28992: PPUSH
28993: CALL 31011 0 4
28997: ST_TO_ADDR
// exit ;
28998: GO 29261
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29000: LD_VAR 0 6
29004: PUSH
29005: LD_EXP 69
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: EQUAL
29020: PUSH
29021: LD_VAR 0 7
29025: PUSH
29026: LD_EXP 69
29030: PUSH
29031: LD_VAR 0 4
29035: ARRAY
29036: PUSH
29037: LD_INT 2
29039: ARRAY
29040: EQUAL
29041: AND
29042: PUSH
29043: LD_VAR 0 8
29047: PUSH
29048: LD_EXP 69
29052: PUSH
29053: LD_VAR 0 4
29057: ARRAY
29058: PUSH
29059: LD_INT 3
29061: ARRAY
29062: EQUAL
29063: AND
29064: PUSH
29065: LD_VAR 0 9
29069: PUSH
29070: LD_EXP 69
29074: PUSH
29075: LD_VAR 0 4
29079: ARRAY
29080: PUSH
29081: LD_INT 4
29083: ARRAY
29084: EQUAL
29085: AND
29086: IFFALSE 29242
// begin tmp := MREG_ToAttack [ side ] ;
29088: LD_ADDR_VAR 0 5
29092: PUSH
29093: LD_EXP 69
29097: PUSH
29098: LD_VAR 0 4
29102: ARRAY
29103: ST_TO_ADDR
// for i = 1 to 4 do
29104: LD_ADDR_VAR 0 3
29108: PUSH
29109: DOUBLE
29110: LD_INT 1
29112: DEC
29113: ST_TO_ADDR
29114: LD_INT 4
29116: PUSH
29117: FOR_TO
29118: IFFALSE 29140
// tmp := Delete ( tmp , 1 ) ;
29120: LD_ADDR_VAR 0 5
29124: PUSH
29125: LD_VAR 0 5
29129: PPUSH
29130: LD_INT 1
29132: PPUSH
29133: CALL_OW 3
29137: ST_TO_ADDR
29138: GO 29117
29140: POP
29141: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29142: LD_ADDR_EXP 69
29146: PUSH
29147: LD_EXP 69
29151: PPUSH
29152: LD_VAR 0 4
29156: PPUSH
29157: LD_VAR 0 5
29161: PPUSH
29162: CALL_OW 1
29166: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29167: LD_ADDR_EXP 71
29171: PUSH
29172: LD_EXP 71
29176: PPUSH
29177: LD_VAR 0 4
29181: PPUSH
29182: LD_EXP 71
29186: PUSH
29187: LD_VAR 0 4
29191: ARRAY
29192: PUSH
29193: LD_INT 1
29195: PLUS
29196: PPUSH
29197: LD_VAR 0 1
29201: PPUSH
29202: CALL 31011 0 4
29206: ST_TO_ADDR
// if tmp = 0 then
29207: LD_VAR 0 5
29211: PUSH
29212: LD_INT 0
29214: EQUAL
29215: IFFALSE 29240
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29217: LD_ADDR_EXP 69
29221: PUSH
29222: LD_EXP 69
29226: PPUSH
29227: LD_VAR 0 4
29231: PPUSH
29232: LD_INT 0
29234: PPUSH
29235: CALL_OW 1
29239: ST_TO_ADDR
// exit ;
29240: GO 29261
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29242: LD_VAR 0 1
29246: PPUSH
29247: CALL_OW 255
29251: PPUSH
29252: LD_VAR 0 1
29256: PPUSH
29257: CALL 25636 0 2
// end ;
29261: PPOPN 9
29263: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29264: LD_EXP 39
29268: PUSH
29269: LD_VAR 0 2
29273: PPUSH
29274: CALL_OW 255
29278: ARRAY
29279: IFFALSE 29511
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29281: LD_STRING ApemanTamed [side: 
29283: PUSH
29284: LD_VAR 0 2
29288: PPUSH
29289: CALL_OW 255
29293: STR
29294: PUSH
29295: LD_STRING ; sci: 
29297: STR
29298: PUSH
29299: LD_VAR 0 2
29303: STR
29304: PUSH
29305: LD_STRING ; ape: 
29307: STR
29308: PUSH
29309: LD_VAR 0 1
29313: STR
29314: PUSH
29315: LD_STRING ]
29317: STR
29318: PPUSH
29319: CALL 7934 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29323: LD_INT 11
29325: PPUSH
29326: LD_VAR 0 2
29330: PPUSH
29331: CALL_OW 255
29335: PPUSH
29336: CALL_OW 321
29340: PUSH
29341: LD_INT 2
29343: EQUAL
29344: NOT
29345: PUSH
29346: LD_INT 2
29348: PPUSH
29349: LD_VAR 0 2
29353: PPUSH
29354: CALL_OW 255
29358: PPUSH
29359: CALL_OW 321
29363: PUSH
29364: LD_INT 2
29366: EQUAL
29367: NOT
29368: OR
29369: PUSH
29370: LD_VAR 0 2
29374: PPUSH
29375: CALL_OW 255
29379: PPUSH
29380: LD_INT 171
29382: PPUSH
29383: EMPTY
29384: PPUSH
29385: CALL 12249 0 3
29389: PUSH
29390: LD_INT 0
29392: EQUAL
29393: AND
29394: IFFALSE 29408
// begin SetTag ( ape , 171 ) ;
29396: LD_VAR 0 1
29400: PPUSH
29401: LD_INT 171
29403: PPUSH
29404: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29408: LD_VAR 0 2
29412: PPUSH
29413: CALL_OW 255
29417: PPUSH
29418: LD_INT 30
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PPUSH
29428: CALL 11546 0 2
29432: IFFALSE 29511
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29434: LD_VAR 0 1
29438: PPUSH
29439: LD_VAR 0 2
29443: PPUSH
29444: CALL_OW 255
29448: PPUSH
29449: LD_INT 30
29451: PUSH
29452: LD_INT 1
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PPUSH
29459: CALL 11546 0 2
29463: PUSH
29464: LD_INT 1
29466: ARRAY
29467: PPUSH
29468: CALL_OW 250
29472: PPUSH
29473: LD_VAR 0 2
29477: PPUSH
29478: CALL_OW 255
29482: PPUSH
29483: LD_INT 30
29485: PUSH
29486: LD_INT 1
29488: PUSH
29489: EMPTY
29490: LIST
29491: LIST
29492: PPUSH
29493: CALL 11546 0 2
29497: PUSH
29498: LD_INT 1
29500: ARRAY
29501: PPUSH
29502: CALL_OW 251
29506: PPUSH
29507: CALL_OW 111
// end ;
29511: PPOPN 2
29513: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29514: LD_EXP 39
29518: PUSH
29519: LD_VAR 0 1
29523: PPUSH
29524: CALL_OW 255
29528: ARRAY
29529: IFFALSE 29807
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29531: LD_VAR 0 2
29535: PUSH
29536: LD_VAR 0 2
29540: PPUSH
29541: CALL_OW 255
29545: PPUSH
29546: CALL 11959 0 1
29550: IN
29551: IFFALSE 29692
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29553: LD_VAR 0 1
29557: PPUSH
29558: CALL_OW 266
29562: PUSH
29563: LD_INT 0
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: IN
29573: IFFALSE 29603
// begin Wait ( 0 0$0.3 ) ;
29575: LD_INT 10
29577: PPUSH
29578: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29582: LD_VAR 0 2
29586: PPUSH
29587: LD_INT 16
29589: PPUSH
29590: CALL_OW 336
// ComExitBuilding ( un ) ;
29594: LD_VAR 0 2
29598: PPUSH
29599: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29603: LD_VAR 0 1
29607: PPUSH
29608: CALL_OW 266
29612: PUSH
29613: LD_INT 4
29615: PUSH
29616: LD_INT 5
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: IN
29623: IFFALSE 29692
// begin Wait ( 0 0$0.3 ) ;
29625: LD_INT 10
29627: PPUSH
29628: CALL_OW 67
// if GetTag ( un ) = 0 then
29632: LD_VAR 0 2
29636: PPUSH
29637: CALL_OW 110
29641: PUSH
29642: LD_INT 0
29644: EQUAL
29645: IFFALSE 29661
// SetClass ( un , class_apeman_soldier ) else
29647: LD_VAR 0 2
29651: PPUSH
29652: LD_INT 15
29654: PPUSH
29655: CALL_OW 336
29659: GO 29692
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29661: LD_INT 3
29663: PPUSH
29664: LD_VAR 0 2
29668: PPUSH
29669: CALL_OW 255
29673: PPUSH
29674: CALL_OW 321
29678: IFFALSE 29692
// SetClass ( un , class_apeman_kamikaze ) ;
29680: LD_VAR 0 2
29684: PPUSH
29685: LD_INT 17
29687: PPUSH
29688: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29692: LD_VAR 0 1
29696: PPUSH
29697: CALL_OW 266
29701: PUSH
29702: LD_INT 32
29704: EQUAL
29705: IFFALSE 29807
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29707: LD_ADDR_EXP 68
29711: PUSH
29712: LD_EXP 68
29716: PPUSH
29717: LD_VAR 0 1
29721: PPUSH
29722: CALL_OW 255
29726: PPUSH
29727: LD_EXP 68
29731: PUSH
29732: LD_VAR 0 1
29736: PPUSH
29737: CALL_OW 255
29741: ARRAY
29742: PUSH
29743: LD_INT 1
29745: PLUS
29746: PPUSH
29747: LD_VAR 0 1
29751: PPUSH
29752: CALL 31011 0 4
29756: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29757: LD_ADDR_EXP 68
29761: PUSH
29762: LD_EXP 68
29766: PPUSH
29767: LD_VAR 0 1
29771: PPUSH
29772: CALL_OW 255
29776: PPUSH
29777: LD_EXP 68
29781: PUSH
29782: LD_VAR 0 1
29786: PPUSH
29787: CALL_OW 255
29791: ARRAY
29792: PUSH
29793: LD_INT 1
29795: PLUS
29796: PPUSH
29797: LD_VAR 0 2
29801: PPUSH
29802: CALL 31011 0 4
29806: ST_TO_ADDR
// end ; end ;
29807: PPOPN 2
29809: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29810: LD_VAR 0 1
29814: PPUSH
29815: CALL 56485 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29819: LD_VAR 0 1
29823: PUSH
29824: LD_INT 22
29826: PUSH
29827: LD_INT 3
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: LD_INT 23
29836: PUSH
29837: LD_INT 3
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: PUSH
29844: LD_INT 21
29846: PUSH
29847: LD_INT 1
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: LIST
29858: PPUSH
29859: CALL_OW 69
29863: IN
29864: IFFALSE 29880
// player_loss := player_loss + 1 ;
29866: LD_ADDR_EXP 10
29870: PUSH
29871: LD_EXP 10
29875: PUSH
29876: LD_INT 1
29878: PLUS
29879: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29880: LD_VAR 0 1
29884: PUSH
29885: LD_INT 22
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: LD_INT 21
29897: PUSH
29898: LD_INT 3
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PPUSH
29909: CALL_OW 69
29913: IN
29914: PUSH
29915: LD_EXP 14
29919: NOT
29920: AND
29921: IFFALSE 29984
// begin alfa_north_triggered := true ;
29923: LD_ADDR_EXP 14
29927: PUSH
29928: LD_INT 1
29930: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29931: LD_EXP 5
29935: PPUSH
29936: LD_STRING DS4
29938: PPUSH
29939: CALL_OW 94
// Wait ( 1 1$25 ) ;
29943: LD_INT 2975
29945: PPUSH
29946: CALL_OW 67
// if not isTest then
29950: LD_EXP 1
29954: NOT
29955: IFFALSE 29984
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29957: LD_INT 20
29959: PPUSH
29960: LD_INT 5
29962: PUSH
29963: LD_INT 6
29965: PUSH
29966: LD_INT 7
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: LIST
29973: PUSH
29974: LD_OWVAR 67
29978: ARRAY
29979: PPUSH
29980: CALL 7056 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29984: LD_VAR 0 1
29988: PUSH
29989: LD_INT 22
29991: PUSH
29992: LD_INT 4
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 21
30001: PUSH
30002: LD_INT 3
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PPUSH
30013: CALL_OW 69
30017: IN
30018: PUSH
30019: LD_EXP 15
30023: NOT
30024: AND
30025: IFFALSE 30088
// begin alfa_south_triggered := true ;
30027: LD_ADDR_EXP 15
30031: PUSH
30032: LD_INT 1
30034: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30035: LD_EXP 4
30039: PPUSH
30040: LD_STRING DJ3
30042: PPUSH
30043: CALL_OW 94
// Wait ( 0 0$45 ) ;
30047: LD_INT 1575
30049: PPUSH
30050: CALL_OW 67
// if not isTest then
30054: LD_EXP 1
30058: NOT
30059: IFFALSE 30088
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30061: LD_INT 20
30063: PPUSH
30064: LD_INT 5
30066: PUSH
30067: LD_INT 6
30069: PUSH
30070: LD_INT 7
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: LIST
30077: PUSH
30078: LD_OWVAR 67
30082: ARRAY
30083: PPUSH
30084: CALL 7056 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30088: LD_VAR 0 1
30092: PPUSH
30093: CALL_OW 266
30097: PUSH
30098: LD_INT 1
30100: EQUAL
30101: PUSH
30102: LD_VAR 0 1
30106: PPUSH
30107: CALL_OW 255
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: LD_INT 4
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: IN
30122: AND
30123: IFFALSE 30132
// RaiseSailEvent ( 104 ) ;
30125: LD_INT 104
30127: PPUSH
30128: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30132: LD_EXP 39
30136: PUSH
30137: LD_VAR 0 1
30141: PPUSH
30142: CALL_OW 255
30146: ARRAY
30147: IFFALSE 30534
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30149: LD_STRING UnitDestroyed [side 
30151: PUSH
30152: LD_VAR 0 1
30156: PPUSH
30157: CALL_OW 255
30161: STR
30162: PUSH
30163: LD_STRING ; id: 
30165: STR
30166: PUSH
30167: LD_VAR 0 1
30171: STR
30172: PUSH
30173: LD_STRING ; type: 
30175: STR
30176: PUSH
30177: LD_VAR 0 1
30181: PPUSH
30182: CALL_OW 247
30186: STR
30187: PUSH
30188: LD_STRING ]
30190: STR
30191: PPUSH
30192: CALL 7934 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30196: LD_VAR 0 1
30200: PUSH
30201: LD_VAR 0 1
30205: PPUSH
30206: CALL_OW 255
30210: PPUSH
30211: LD_INT 21
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PPUSH
30221: CALL 11546 0 2
30225: IN
30226: IFFALSE 30382
// begin if MCF_HasClass ( un ) then
30228: LD_VAR 0 1
30232: PPUSH
30233: CALL 14252 0 1
30237: IFFALSE 30382
// case MCF_HasClass ( un ) of 1 :
30239: LD_VAR 0 1
30243: PPUSH
30244: CALL 14252 0 1
30248: PUSH
30249: LD_INT 1
30251: DOUBLE
30252: EQUAL
30253: IFTRUE 30257
30255: GO 30282
30257: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30258: LD_VAR 0 1
30262: PPUSH
30263: CALL_OW 255
30267: PPUSH
30268: LD_STRING ToArm
30270: PPUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL 14425 0 3
30280: GO 30382
30282: LD_INT 2
30284: DOUBLE
30285: EQUAL
30286: IFTRUE 30290
30288: GO 30315
30290: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30291: LD_VAR 0 1
30295: PPUSH
30296: CALL_OW 255
30300: PPUSH
30301: LD_STRING ToDep
30303: PPUSH
30304: LD_VAR 0 1
30308: PPUSH
30309: CALL 14425 0 3
30313: GO 30382
30315: LD_INT 3
30317: DOUBLE
30318: EQUAL
30319: IFTRUE 30323
30321: GO 30348
30323: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30324: LD_VAR 0 1
30328: PPUSH
30329: CALL_OW 255
30333: PPUSH
30334: LD_STRING ToFac
30336: PPUSH
30337: LD_VAR 0 1
30341: PPUSH
30342: CALL 14425 0 3
30346: GO 30382
30348: LD_INT 4
30350: DOUBLE
30351: EQUAL
30352: IFTRUE 30356
30354: GO 30381
30356: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30357: LD_VAR 0 1
30361: PPUSH
30362: CALL_OW 255
30366: PPUSH
30367: LD_STRING ToLab
30369: PPUSH
30370: LD_VAR 0 1
30374: PPUSH
30375: CALL 14425 0 3
30379: GO 30382
30381: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30382: LD_VAR 0 1
30386: PUSH
30387: LD_EXP 67
30391: PUSH
30392: LD_VAR 0 1
30396: PPUSH
30397: CALL_OW 255
30401: ARRAY
30402: IN
30403: IFFALSE 30488
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30405: LD_ADDR_EXP 67
30409: PUSH
30410: LD_EXP 67
30414: PPUSH
30415: LD_VAR 0 1
30419: PPUSH
30420: LD_INT 0
30422: PPUSH
30423: CALL 31170 0 3
30427: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30428: LD_VAR 0 1
30432: PPUSH
30433: CALL_OW 255
30437: PPUSH
30438: LD_VAR 0 1
30442: PPUSH
30443: CALL_OW 265
30447: PUSH
30448: LD_VAR 0 1
30452: PPUSH
30453: CALL_OW 262
30457: PUSH
30458: LD_VAR 0 1
30462: PPUSH
30463: CALL_OW 263
30467: PUSH
30468: LD_VAR 0 1
30472: PPUSH
30473: CALL_OW 264
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: PPUSH
30484: CALL 21065 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30488: LD_VAR 0 1
30492: PUSH
30493: LD_EXP 71
30497: PUSH
30498: LD_VAR 0 1
30502: PPUSH
30503: CALL_OW 255
30507: ARRAY
30508: IN
30509: IFFALSE 30534
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30511: LD_ADDR_EXP 71
30515: PUSH
30516: LD_EXP 71
30520: PPUSH
30521: LD_VAR 0 1
30525: PPUSH
30526: LD_INT 0
30528: PPUSH
30529: CALL 31170 0 3
30533: ST_TO_ADDR
// end ; end ;
30534: PPOPN 1
30536: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30537: LD_EXP 39
30541: PUSH
30542: LD_VAR 0 2
30546: PPUSH
30547: CALL_OW 255
30551: ARRAY
30552: IFFALSE 30724
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30554: LD_VAR 0 2
30558: PUSH
30559: LD_EXP 68
30563: PUSH
30564: LD_VAR 0 2
30568: PPUSH
30569: CALL_OW 255
30573: ARRAY
30574: IN
30575: PUSH
30576: LD_VAR 0 1
30580: PPUSH
30581: CALL_OW 266
30585: PUSH
30586: LD_INT 32
30588: PUSH
30589: LD_INT 31
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: IN
30596: AND
30597: IFFALSE 30697
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30599: LD_ADDR_EXP 68
30603: PUSH
30604: LD_EXP 68
30608: PPUSH
30609: LD_VAR 0 1
30613: PPUSH
30614: LD_INT 0
30616: PPUSH
30617: CALL 31170 0 3
30621: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30622: LD_ADDR_EXP 68
30626: PUSH
30627: LD_EXP 68
30631: PPUSH
30632: LD_VAR 0 2
30636: PPUSH
30637: LD_INT 0
30639: PPUSH
30640: CALL 31170 0 3
30644: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30645: LD_EXP 68
30649: PUSH
30650: LD_VAR 0 2
30654: PPUSH
30655: CALL_OW 255
30659: ARRAY
30660: PUSH
30661: LD_STRING 
30663: EQUAL
30664: IFFALSE 30697
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30666: LD_ADDR_EXP 68
30670: PUSH
30671: LD_EXP 68
30675: PPUSH
30676: LD_VAR 0 2
30680: PPUSH
30681: CALL_OW 255
30685: PPUSH
30686: LD_INT 1
30688: PPUSH
30689: LD_INT 0
30691: PPUSH
30692: CALL 31011 0 4
30696: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30697: LD_VAR 0 1
30701: PPUSH
30702: CALL_OW 266
30706: PUSH
30707: LD_INT 36
30709: IN
30710: IFFALSE 30724
// SetTag ( un , 0 ) ;
30712: LD_VAR 0 2
30716: PPUSH
30717: LD_INT 0
30719: PPUSH
30720: CALL_OW 109
// end ;
30724: PPOPN 2
30726: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30727: LD_EXP 39
30731: PUSH
30732: LD_VAR 0 1
30736: PPUSH
30737: CALL_OW 255
30741: ARRAY
30742: IFFALSE 30768
// begin if GetControl ( un ) = control_remote then
30744: LD_VAR 0 1
30748: PPUSH
30749: CALL_OW 263
30753: PUSH
30754: LD_INT 2
30756: EQUAL
30757: IFFALSE 30768
// ComUnlink ( un ) ;
30759: LD_VAR 0 1
30763: PPUSH
30764: CALL_OW 136
// end ;
30768: PPOPN 1
30770: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30771: LD_EXP 39
30775: PUSH
30776: LD_VAR 0 1
30780: PPUSH
30781: CALL_OW 255
30785: ARRAY
30786: IFFALSE 30815
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30788: LD_VAR 0 2
30792: PPUSH
30793: CALL_OW 264
30797: PUSH
30798: LD_INT 31
30800: IN
30801: IFFALSE 30815
// SetTag ( driver , 0 ) ;
30803: LD_VAR 0 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL_OW 109
// end ;
30815: PPOPN 4
30817: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30818: LD_INT 0
30820: PPUSH
30821: PPUSH
30822: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30823: LD_ADDR_VAR 0 3
30827: PUSH
30828: LD_VAR 0 1
30832: PPUSH
30833: CALL_OW 269
30837: ST_TO_ADDR
// x := GetX ( building ) ;
30838: LD_ADDR_VAR 0 4
30842: PUSH
30843: LD_VAR 0 1
30847: PPUSH
30848: CALL_OW 250
30852: ST_TO_ADDR
// y := GetY ( building ) ;
30853: LD_ADDR_VAR 0 5
30857: PUSH
30858: LD_VAR 0 1
30862: PPUSH
30863: CALL_OW 251
30867: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30868: LD_ADDR_EXP 43
30872: PUSH
30873: LD_EXP 43
30877: PPUSH
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 255
30887: PPUSH
30888: LD_VAR 0 3
30892: PPUSH
30893: LD_VAR 0 4
30897: PUSH
30898: LD_VAR 0 5
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PPUSH
30907: CALL 41932 0 4
30911: ST_TO_ADDR
// end ;
30912: PPOPN 5
30914: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30915: LD_VAR 0 1
30919: PUSH
30920: LD_EXP 30
30924: IN
30925: NOT
30926: IFFALSE 30974
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30928: LD_ADDR_EXP 30
30932: PUSH
30933: LD_EXP 30
30937: PPUSH
30938: LD_EXP 30
30942: PUSH
30943: LD_INT 1
30945: PLUS
30946: PPUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 2
30956: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30957: LD_STRING DestinationUnrechable. [unit: 
30959: PUSH
30960: LD_VAR 0 1
30964: STR
30965: PUSH
30966: LD_STRING ]
30968: STR
30969: PPUSH
30970: CALL 7934 0 1
// end ; end ;
30974: PPOPN 1
30976: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
30977: LD_VAR 0 1
30981: PPUSH
30982: LD_VAR 0 2
30986: PPUSH
30987: LD_VAR 0 3
30991: PPUSH
30992: CALL 56583 0 3
// end ;
30996: PPOPN 3
30998: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
30999: LD_VAR 0 1
31003: PPUSH
31004: CALL 56591 0 1
// end ; end_of_file
31008: PPOPN 1
31010: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31011: LD_INT 0
31013: PPUSH
31014: PPUSH
31015: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31016: LD_ADDR_VAR 0 7
31020: PUSH
31021: LD_VAR 0 1
31025: PUSH
31026: LD_VAR 0 2
31030: ARRAY
31031: PPUSH
31032: LD_VAR 0 3
31036: PPUSH
31037: LD_VAR 0 4
31041: PPUSH
31042: CALL_OW 1
31046: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31047: LD_ADDR_VAR 0 1
31051: PUSH
31052: LD_VAR 0 1
31056: PPUSH
31057: LD_VAR 0 2
31061: PPUSH
31062: LD_VAR 0 7
31066: PPUSH
31067: CALL_OW 1
31071: ST_TO_ADDR
// result := tab ;
31072: LD_ADDR_VAR 0 5
31076: PUSH
31077: LD_VAR 0 1
31081: ST_TO_ADDR
// end ;
31082: LD_VAR 0 5
31086: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31087: LD_INT 0
31089: PPUSH
31090: PPUSH
31091: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31092: LD_ADDR_VAR 0 5
31096: PUSH
31097: LD_VAR 0 1
31101: PUSH
31102: LD_VAR 0 2
31106: PUSH
31107: LD_INT 1
31109: ARRAY
31110: ARRAY
31111: PPUSH
31112: LD_VAR 0 2
31116: PUSH
31117: LD_INT 2
31119: ARRAY
31120: PPUSH
31121: CALL_OW 3
31125: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31126: LD_ADDR_VAR 0 1
31130: PUSH
31131: LD_VAR 0 1
31135: PPUSH
31136: LD_VAR 0 2
31140: PUSH
31141: LD_INT 1
31143: ARRAY
31144: PPUSH
31145: LD_VAR 0 5
31149: PPUSH
31150: CALL_OW 1
31154: ST_TO_ADDR
// result := tab ;
31155: LD_ADDR_VAR 0 3
31159: PUSH
31160: LD_VAR 0 1
31164: ST_TO_ADDR
// end ;
31165: LD_VAR 0 3
31169: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31170: LD_INT 0
31172: PPUSH
31173: PPUSH
31174: PPUSH
31175: PPUSH
// i := 1 ;
31176: LD_ADDR_VAR 0 5
31180: PUSH
31181: LD_INT 1
31183: ST_TO_ADDR
// while ( i <= tab ) do
31184: LD_VAR 0 5
31188: PUSH
31189: LD_VAR 0 1
31193: LESSEQUAL
31194: IFFALSE 31569
// begin if not tab [ i ] then
31196: LD_VAR 0 1
31200: PUSH
31201: LD_VAR 0 5
31205: ARRAY
31206: NOT
31207: IFFALSE 31211
// break ;
31209: GO 31569
// if value in tab then
31211: LD_VAR 0 2
31215: PUSH
31216: LD_VAR 0 1
31220: IN
31221: IFFALSE 31334
// begin if not mode then
31223: LD_VAR 0 3
31227: NOT
31228: IFFALSE 31248
// tab := tab diff value else
31230: LD_ADDR_VAR 0 1
31234: PUSH
31235: LD_VAR 0 1
31239: PUSH
31240: LD_VAR 0 2
31244: DIFF
31245: ST_TO_ADDR
31246: GO 31310
// for j = 1 to tab do
31248: LD_ADDR_VAR 0 6
31252: PUSH
31253: DOUBLE
31254: LD_INT 1
31256: DEC
31257: ST_TO_ADDR
31258: LD_VAR 0 1
31262: PUSH
31263: FOR_TO
31264: IFFALSE 31308
// if tab [ j ] = value then
31266: LD_VAR 0 1
31270: PUSH
31271: LD_VAR 0 6
31275: ARRAY
31276: PUSH
31277: LD_VAR 0 2
31281: EQUAL
31282: IFFALSE 31306
// begin tab := Delete ( tab , j ) ;
31284: LD_ADDR_VAR 0 1
31288: PUSH
31289: LD_VAR 0 1
31293: PPUSH
31294: LD_VAR 0 6
31298: PPUSH
31299: CALL_OW 3
31303: ST_TO_ADDR
// break ;
31304: GO 31308
// end ;
31306: GO 31263
31308: POP
31309: POP
// i := i - 1 ;
31310: LD_ADDR_VAR 0 5
31314: PUSH
31315: LD_VAR 0 5
31319: PUSH
31320: LD_INT 1
31322: MINUS
31323: ST_TO_ADDR
// if mode then
31324: LD_VAR 0 3
31328: IFFALSE 31332
// break ;
31330: GO 31569
// end else
31332: GO 31553
// if tab [ i ] and value in tab [ i ] then
31334: LD_VAR 0 1
31338: PUSH
31339: LD_VAR 0 5
31343: ARRAY
31344: PUSH
31345: LD_VAR 0 2
31349: PUSH
31350: LD_VAR 0 1
31354: PUSH
31355: LD_VAR 0 5
31359: ARRAY
31360: IN
31361: AND
31362: IFFALSE 31553
// begin if not mode then
31364: LD_VAR 0 3
31368: NOT
31369: IFFALSE 31395
// tmp := tab [ i ] diff value else
31371: LD_ADDR_VAR 0 7
31375: PUSH
31376: LD_VAR 0 1
31380: PUSH
31381: LD_VAR 0 5
31385: ARRAY
31386: PUSH
31387: LD_VAR 0 2
31391: DIFF
31392: ST_TO_ADDR
31393: GO 31475
// for j = 1 to tab [ i ] do
31395: LD_ADDR_VAR 0 6
31399: PUSH
31400: DOUBLE
31401: LD_INT 1
31403: DEC
31404: ST_TO_ADDR
31405: LD_VAR 0 1
31409: PUSH
31410: LD_VAR 0 5
31414: ARRAY
31415: PUSH
31416: FOR_TO
31417: IFFALSE 31473
// if value = tab [ i ] [ j ] then
31419: LD_VAR 0 2
31423: PUSH
31424: LD_VAR 0 1
31428: PUSH
31429: LD_VAR 0 5
31433: ARRAY
31434: PUSH
31435: LD_VAR 0 6
31439: ARRAY
31440: EQUAL
31441: IFFALSE 31471
// begin tmp := Delete ( tab [ i ] , j ) ;
31443: LD_ADDR_VAR 0 7
31447: PUSH
31448: LD_VAR 0 1
31452: PUSH
31453: LD_VAR 0 5
31457: ARRAY
31458: PPUSH
31459: LD_VAR 0 6
31463: PPUSH
31464: CALL_OW 3
31468: ST_TO_ADDR
// break ;
31469: GO 31473
// end ;
31471: GO 31416
31473: POP
31474: POP
// if tmp = [ ] then
31475: LD_VAR 0 7
31479: PUSH
31480: EMPTY
31481: EQUAL
31482: IFFALSE 31506
// begin tab := Delete ( tab , i ) ;
31484: LD_ADDR_VAR 0 1
31488: PUSH
31489: LD_VAR 0 1
31493: PPUSH
31494: LD_VAR 0 5
31498: PPUSH
31499: CALL_OW 3
31503: ST_TO_ADDR
// end else
31504: GO 31531
// tab := Replace ( tab , i , tmp ) ;
31506: LD_ADDR_VAR 0 1
31510: PUSH
31511: LD_VAR 0 1
31515: PPUSH
31516: LD_VAR 0 5
31520: PPUSH
31521: LD_VAR 0 7
31525: PPUSH
31526: CALL_OW 1
31530: ST_TO_ADDR
// i := i - 1 ;
31531: LD_ADDR_VAR 0 5
31535: PUSH
31536: LD_VAR 0 5
31540: PUSH
31541: LD_INT 1
31543: MINUS
31544: ST_TO_ADDR
// if mode then
31545: LD_VAR 0 3
31549: IFFALSE 31553
// break ;
31551: GO 31569
// end ; i := i + 1 ;
31553: LD_ADDR_VAR 0 5
31557: PUSH
31558: LD_VAR 0 5
31562: PUSH
31563: LD_INT 1
31565: PLUS
31566: ST_TO_ADDR
// end ;
31567: GO 31184
// result := tab ;
31569: LD_ADDR_VAR 0 4
31573: PUSH
31574: LD_VAR 0 1
31578: ST_TO_ADDR
// end ;
31579: LD_VAR 0 4
31583: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31584: LD_INT 0
31586: PPUSH
31587: PPUSH
// for i = 1 to values do
31588: LD_ADDR_VAR 0 4
31592: PUSH
31593: DOUBLE
31594: LD_INT 1
31596: DEC
31597: ST_TO_ADDR
31598: LD_VAR 0 2
31602: PUSH
31603: FOR_TO
31604: IFFALSE 31637
// tab := Remove ( tab , values [ i ] , false ) ;
31606: LD_ADDR_VAR 0 1
31610: PUSH
31611: LD_VAR 0 1
31615: PPUSH
31616: LD_VAR 0 2
31620: PUSH
31621: LD_VAR 0 4
31625: ARRAY
31626: PPUSH
31627: LD_INT 0
31629: PPUSH
31630: CALL 31170 0 3
31634: ST_TO_ADDR
31635: GO 31603
31637: POP
31638: POP
// result := tab ;
31639: LD_ADDR_VAR 0 3
31643: PUSH
31644: LD_VAR 0 1
31648: ST_TO_ADDR
// end ;
31649: LD_VAR 0 3
31653: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31654: LD_INT 0
31656: PPUSH
31657: PPUSH
31658: PPUSH
// if not GetControl ( veh ) = control_manual then
31659: LD_VAR 0 1
31663: PPUSH
31664: CALL_OW 263
31668: PUSH
31669: LD_INT 1
31671: EQUAL
31672: NOT
31673: IFFALSE 31685
// result := false else
31675: LD_ADDR_VAR 0 2
31679: PUSH
31680: LD_INT 0
31682: ST_TO_ADDR
31683: GO 31830
// if veh in FilterAllUnits ( [ f_empty ] ) then
31685: LD_VAR 0 1
31689: PUSH
31690: LD_INT 58
31692: PUSH
31693: EMPTY
31694: LIST
31695: PPUSH
31696: CALL_OW 69
31700: IN
31701: IFFALSE 31713
// result := false else
31703: LD_ADDR_VAR 0 2
31707: PUSH
31708: LD_INT 0
31710: ST_TO_ADDR
31711: GO 31830
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31713: LD_ADDR_VAR 0 4
31717: PUSH
31718: LD_INT 22
31720: PUSH
31721: LD_VAR 0 1
31725: PPUSH
31726: CALL_OW 255
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 55
31737: PUSH
31738: EMPTY
31739: LIST
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PPUSH
31745: CALL_OW 69
31749: ST_TO_ADDR
// if not filter then
31750: LD_VAR 0 4
31754: NOT
31755: IFFALSE 31767
// result := false else
31757: LD_ADDR_VAR 0 2
31761: PUSH
31762: LD_INT 0
31764: ST_TO_ADDR
31765: GO 31830
// for i = 1 to filter do
31767: LD_ADDR_VAR 0 3
31771: PUSH
31772: DOUBLE
31773: LD_INT 1
31775: DEC
31776: ST_TO_ADDR
31777: LD_VAR 0 4
31781: PUSH
31782: FOR_TO
31783: IFFALSE 31828
// if IsDriver ( filter [ i ] ) = veh then
31785: LD_VAR 0 4
31789: PUSH
31790: LD_VAR 0 3
31794: ARRAY
31795: PPUSH
31796: CALL 94844 0 1
31800: PUSH
31801: LD_VAR 0 1
31805: EQUAL
31806: IFFALSE 31826
// begin result := filter [ i ] ;
31808: LD_ADDR_VAR 0 2
31812: PUSH
31813: LD_VAR 0 4
31817: PUSH
31818: LD_VAR 0 3
31822: ARRAY
31823: ST_TO_ADDR
// break ;
31824: GO 31828
// end ;
31826: GO 31782
31828: POP
31829: POP
// end ; end ;
31830: LD_VAR 0 2
31834: RET
// export function Compare ( val1 , val2 ) ; begin
31835: LD_INT 0
31837: PPUSH
// if val1 = val2 then
31838: LD_VAR 0 1
31842: PUSH
31843: LD_VAR 0 2
31847: EQUAL
31848: IFFALSE 31860
// result := true else
31850: LD_ADDR_VAR 0 3
31854: PUSH
31855: LD_INT 1
31857: ST_TO_ADDR
31858: GO 31868
// result := false ;
31860: LD_ADDR_VAR 0 3
31864: PUSH
31865: LD_INT 0
31867: ST_TO_ADDR
// end ;
31868: LD_VAR 0 3
31872: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31873: LD_INT 0
31875: PPUSH
31876: PPUSH
// result := false ;
31877: LD_ADDR_VAR 0 3
31881: PUSH
31882: LD_INT 0
31884: ST_TO_ADDR
// for j = 1 to e2 do
31885: LD_ADDR_VAR 0 4
31889: PUSH
31890: DOUBLE
31891: LD_INT 1
31893: DEC
31894: ST_TO_ADDR
31895: LD_VAR 0 2
31899: PUSH
31900: FOR_TO
31901: IFFALSE 31935
// if Compare ( e1 , e2 [ j ] ) then
31903: LD_VAR 0 1
31907: PPUSH
31908: LD_VAR 0 2
31912: PUSH
31913: LD_VAR 0 4
31917: ARRAY
31918: PPUSH
31919: CALL 31835 0 2
31923: IFFALSE 31933
// result := true ;
31925: LD_ADDR_VAR 0 3
31929: PUSH
31930: LD_INT 1
31932: ST_TO_ADDR
31933: GO 31900
31935: POP
31936: POP
// end ;
31937: LD_VAR 0 3
31941: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
31942: LD_INT 0
31944: PPUSH
31945: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
31946: LD_VAR 0 1
31950: PPUSH
31951: LD_STRING C
31953: PUSH
31954: LD_VAR 0 2
31958: PUSH
31959: LD_VAR 0 3
31963: PUSH
31964: LD_INT 0
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 0
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: LIST
31980: LIST
31981: LIST
31982: LIST
31983: LIST
31984: PUSH
31985: LD_STRING v
31987: PUSH
31988: LD_VAR 0 4
31992: PPUSH
31993: CALL_OW 250
31997: PUSH
31998: LD_VAR 0 4
32002: PPUSH
32003: CALL_OW 251
32007: PUSH
32008: LD_VAR 0 4
32012: PUSH
32013: LD_INT 0
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: LD_INT 0
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PPUSH
32035: CALL_OW 446
// end ;
32039: LD_VAR 0 5
32043: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32044: LD_INT 0
32046: PPUSH
32047: PPUSH
32048: PPUSH
// linked := UnitsLinked ( unit ) ;
32049: LD_ADDR_VAR 0 4
32053: PUSH
32054: LD_VAR 0 1
32058: PPUSH
32059: CALL_OW 432
32063: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32064: LD_ADDR_VAR 0 3
32068: PUSH
32069: LD_VAR 0 1
32073: PPUSH
32074: LD_INT 3
32076: PPUSH
32077: CALL_OW 259
32081: ST_TO_ADDR
// if sk > linked then
32082: LD_VAR 0 3
32086: PUSH
32087: LD_VAR 0 4
32091: GREATER
32092: IFFALSE 32104
// result := true else
32094: LD_ADDR_VAR 0 2
32098: PUSH
32099: LD_INT 1
32101: ST_TO_ADDR
32102: GO 32112
// result := false ;
32104: LD_ADDR_VAR 0 2
32108: PUSH
32109: LD_INT 0
32111: ST_TO_ADDR
// end ;
32112: LD_VAR 0 2
32116: RET
// export function NotTask ( unit ) ; begin
32117: LD_INT 0
32119: PPUSH
// result := true ;
32120: LD_ADDR_VAR 0 2
32124: PUSH
32125: LD_INT 1
32127: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32128: LD_VAR 0 1
32132: PPUSH
32133: CALL_OW 437
32137: PUSH
32138: LD_VAR 0 1
32142: PPUSH
32143: CALL_OW 314
32147: OR
32148: IFFALSE 32158
// result := false ;
32150: LD_ADDR_VAR 0 2
32154: PUSH
32155: LD_INT 0
32157: ST_TO_ADDR
// end ;
32158: LD_VAR 0 2
32162: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
32168: PPUSH
32169: PPUSH
// dist := 99999 ;
32170: LD_ADDR_VAR 0 7
32174: PUSH
32175: LD_INT 99999
32177: ST_TO_ADDR
// un := - 1 ;
32178: LD_ADDR_VAR 0 6
32182: PUSH
32183: LD_INT 1
32185: NEG
32186: ST_TO_ADDR
// if units1 and units2 then
32187: LD_VAR 0 1
32191: PUSH
32192: LD_VAR 0 2
32196: AND
32197: IFFALSE 32285
// for i in units1 do
32199: LD_ADDR_VAR 0 4
32203: PUSH
32204: LD_VAR 0 1
32208: PUSH
32209: FOR_IN
32210: IFFALSE 32283
// for j in units2 do
32212: LD_ADDR_VAR 0 5
32216: PUSH
32217: LD_VAR 0 2
32221: PUSH
32222: FOR_IN
32223: IFFALSE 32279
// if GetDistUnits ( i , j ) < dist then
32225: LD_VAR 0 4
32229: PPUSH
32230: LD_VAR 0 5
32234: PPUSH
32235: CALL_OW 296
32239: PUSH
32240: LD_VAR 0 7
32244: LESS
32245: IFFALSE 32277
// begin un := i ;
32247: LD_ADDR_VAR 0 6
32251: PUSH
32252: LD_VAR 0 4
32256: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32257: LD_ADDR_VAR 0 7
32261: PUSH
32262: LD_VAR 0 4
32266: PPUSH
32267: LD_VAR 0 5
32271: PPUSH
32272: CALL_OW 296
32276: ST_TO_ADDR
// end ;
32277: GO 32222
32279: POP
32280: POP
32281: GO 32209
32283: POP
32284: POP
// result := [ un , dist ] ;
32285: LD_ADDR_VAR 0 3
32289: PUSH
32290: LD_VAR 0 6
32294: PUSH
32295: LD_VAR 0 7
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: ST_TO_ADDR
// end ;
32304: LD_VAR 0 3
32308: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32309: LD_INT 0
32311: PPUSH
32312: PPUSH
32313: PPUSH
32314: PPUSH
32315: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32316: LD_VAR 0 1
32320: NOT
32321: PUSH
32322: LD_VAR 0 1
32326: PPUSH
32327: CALL_OW 256
32331: PUSH
32332: LD_INT 250
32334: LESS
32335: OR
32336: PUSH
32337: LD_VAR 0 1
32341: PPUSH
32342: CALL_OW 314
32346: PUSH
32347: LD_VAR 0 1
32351: PPUSH
32352: CALL_OW 261
32356: PUSH
32357: LD_INT 20
32359: GREATER
32360: AND
32361: OR
32362: IFFALSE 32366
// exit ;
32364: GO 32740
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32366: LD_VAR 0 1
32370: PPUSH
32371: CALL_OW 261
32375: PUSH
32376: LD_INT 20
32378: LESS
32379: PUSH
32380: LD_VAR 0 1
32384: PPUSH
32385: CALL_OW 110
32389: PUSH
32390: LD_INT 21
32392: EQUAL
32393: NOT
32394: AND
32395: IFFALSE 32431
// begin ComStop ( bulldozer ) ;
32397: LD_VAR 0 1
32401: PPUSH
32402: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32406: LD_VAR 0 1
32410: PPUSH
32411: LD_INT 21
32413: PPUSH
32414: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32418: LD_VAR 0 1
32422: PPUSH
32423: CALL 26173 0 1
// exit ;
32427: GO 32740
// end else
32429: GO 32458
// if GetFuel ( bulldozer ) > 20 then
32431: LD_VAR 0 1
32435: PPUSH
32436: CALL_OW 261
32440: PUSH
32441: LD_INT 20
32443: GREATER
32444: IFFALSE 32458
// SetTag ( bulldozer , 0 ) ;
32446: LD_VAR 0 1
32450: PPUSH
32451: LD_INT 0
32453: PPUSH
32454: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32458: LD_ADDR_VAR 0 5
32462: PUSH
32463: LD_VAR 0 2
32467: PPUSH
32468: CALL_OW 353
32472: ST_TO_ADDR
// tmp := [ ] ;
32473: LD_ADDR_VAR 0 6
32477: PUSH
32478: EMPTY
32479: ST_TO_ADDR
// for i = 1 to list do
32480: LD_ADDR_VAR 0 4
32484: PUSH
32485: DOUBLE
32486: LD_INT 1
32488: DEC
32489: ST_TO_ADDR
32490: LD_VAR 0 5
32494: PUSH
32495: FOR_TO
32496: IFFALSE 32594
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32498: LD_VAR 0 5
32502: PUSH
32503: LD_VAR 0 4
32507: ARRAY
32508: PUSH
32509: LD_INT 1
32511: ARRAY
32512: PPUSH
32513: LD_VAR 0 5
32517: PUSH
32518: LD_VAR 0 4
32522: ARRAY
32523: PUSH
32524: LD_INT 2
32526: ARRAY
32527: PPUSH
32528: CALL_OW 554
32532: IFFALSE 32592
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32534: LD_ADDR_VAR 0 6
32538: PUSH
32539: LD_VAR 0 6
32543: PPUSH
32544: LD_VAR 0 6
32548: PUSH
32549: LD_INT 1
32551: PLUS
32552: PPUSH
32553: LD_VAR 0 5
32557: PUSH
32558: LD_VAR 0 4
32562: ARRAY
32563: PUSH
32564: LD_INT 1
32566: ARRAY
32567: PUSH
32568: LD_VAR 0 5
32572: PUSH
32573: LD_VAR 0 4
32577: ARRAY
32578: PUSH
32579: LD_INT 2
32581: ARRAY
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PPUSH
32587: CALL_OW 1
32591: ST_TO_ADDR
// end ;
32592: GO 32495
32594: POP
32595: POP
// ComStop ( bulldozer ) ;
32596: LD_VAR 0 1
32600: PPUSH
32601: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32605: LD_ADDR_VAR 0 7
32609: PUSH
32610: LD_VAR 0 1
32614: PPUSH
32615: CALL_OW 250
32619: PUSH
32620: LD_VAR 0 1
32624: PPUSH
32625: CALL_OW 251
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: ST_TO_ADDR
// for i = tmp downto 1 do
32634: LD_ADDR_VAR 0 4
32638: PUSH
32639: DOUBLE
32640: LD_VAR 0 6
32644: INC
32645: ST_TO_ADDR
32646: LD_INT 1
32648: PUSH
32649: FOR_DOWNTO
32650: IFFALSE 32738
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32652: LD_ADDR_VAR 0 7
32656: PUSH
32657: LD_VAR 0 7
32661: PUSH
32662: LD_INT 1
32664: ARRAY
32665: PPUSH
32666: LD_VAR 0 7
32670: PUSH
32671: LD_INT 2
32673: ARRAY
32674: PPUSH
32675: LD_VAR 0 6
32679: PPUSH
32680: CALL 32841 0 3
32684: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32685: LD_VAR 0 1
32689: PPUSH
32690: LD_VAR 0 7
32694: PUSH
32695: LD_INT 1
32697: ARRAY
32698: PPUSH
32699: LD_VAR 0 7
32703: PUSH
32704: LD_INT 2
32706: ARRAY
32707: PPUSH
32708: CALL 32745 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32712: LD_ADDR_VAR 0 6
32716: PUSH
32717: LD_VAR 0 6
32721: PPUSH
32722: LD_VAR 0 7
32726: PUSH
32727: LD_INT 3
32729: ARRAY
32730: PPUSH
32731: CALL_OW 3
32735: ST_TO_ADDR
// end ;
32736: GO 32649
32738: POP
32739: POP
// end ;
32740: LD_VAR 0 3
32744: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32745: LD_INT 0
32747: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32748: LD_VAR 0 2
32752: PPUSH
32753: LD_VAR 0 3
32757: PPUSH
32758: CALL_OW 351
32762: PUSH
32763: LD_VAR 0 2
32767: PPUSH
32768: LD_VAR 0 3
32772: PPUSH
32773: CALL_OW 554
32777: AND
32778: PUSH
32779: LD_VAR 0 2
32783: PPUSH
32784: LD_VAR 0 3
32788: PPUSH
32789: CALL_OW 488
32793: AND
32794: PUSH
32795: LD_VAR 0 2
32799: PPUSH
32800: LD_VAR 0 3
32804: PPUSH
32805: CALL_OW 428
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: EQUAL
32814: AND
32815: IFFALSE 32836
// AddComMoveXY ( bulldozer , x , y ) ;
32817: LD_VAR 0 1
32821: PPUSH
32822: LD_VAR 0 2
32826: PPUSH
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL_OW 171
// end ;
32836: LD_VAR 0 4
32840: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32841: LD_INT 0
32843: PPUSH
32844: PPUSH
32845: PPUSH
32846: PPUSH
32847: PPUSH
32848: PPUSH
32849: PPUSH
// dist := 99999 ;
32850: LD_ADDR_VAR 0 6
32854: PUSH
32855: LD_INT 99999
32857: ST_TO_ADDR
// for i = 1 to list do
32858: LD_ADDR_VAR 0 5
32862: PUSH
32863: DOUBLE
32864: LD_INT 1
32866: DEC
32867: ST_TO_ADDR
32868: LD_VAR 0 3
32872: PUSH
32873: FOR_TO
32874: IFFALSE 33012
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32876: LD_ADDR_VAR 0 7
32880: PUSH
32881: LD_VAR 0 1
32885: PPUSH
32886: LD_VAR 0 2
32890: PPUSH
32891: LD_VAR 0 3
32895: PUSH
32896: LD_VAR 0 5
32900: ARRAY
32901: PUSH
32902: LD_INT 1
32904: ARRAY
32905: PPUSH
32906: LD_VAR 0 3
32910: PUSH
32911: LD_VAR 0 5
32915: ARRAY
32916: PUSH
32917: LD_INT 2
32919: ARRAY
32920: PPUSH
32921: CALL_OW 298
32925: ST_TO_ADDR
// if d = 0 then
32926: LD_VAR 0 7
32930: PUSH
32931: LD_INT 0
32933: EQUAL
32934: IFFALSE 32938
// continue ;
32936: GO 32873
// if d < dist then
32938: LD_VAR 0 7
32942: PUSH
32943: LD_VAR 0 6
32947: LESS
32948: IFFALSE 33010
// begin _x := list [ i ] [ 1 ] ;
32950: LD_ADDR_VAR 0 8
32954: PUSH
32955: LD_VAR 0 3
32959: PUSH
32960: LD_VAR 0 5
32964: ARRAY
32965: PUSH
32966: LD_INT 1
32968: ARRAY
32969: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
32970: LD_ADDR_VAR 0 9
32974: PUSH
32975: LD_VAR 0 3
32979: PUSH
32980: LD_VAR 0 5
32984: ARRAY
32985: PUSH
32986: LD_INT 2
32988: ARRAY
32989: ST_TO_ADDR
// _i := i ;
32990: LD_ADDR_VAR 0 10
32994: PUSH
32995: LD_VAR 0 5
32999: ST_TO_ADDR
// dist := d ;
33000: LD_ADDR_VAR 0 6
33004: PUSH
33005: LD_VAR 0 7
33009: ST_TO_ADDR
// end ; end ;
33010: GO 32873
33012: POP
33013: POP
// result := [ _x , _y , _i , dist ] ;
33014: LD_ADDR_VAR 0 4
33018: PUSH
33019: LD_VAR 0 8
33023: PUSH
33024: LD_VAR 0 9
33028: PUSH
33029: LD_VAR 0 10
33033: PUSH
33034: LD_VAR 0 6
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: ST_TO_ADDR
// end ;
33045: LD_VAR 0 4
33049: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33050: LD_INT 0
33052: PPUSH
33053: PPUSH
33054: PPUSH
33055: PPUSH
33056: PPUSH
// for i = 1 to list do
33057: LD_ADDR_VAR 0 5
33061: PUSH
33062: DOUBLE
33063: LD_INT 1
33065: DEC
33066: ST_TO_ADDR
33067: LD_VAR 0 1
33071: PUSH
33072: FOR_TO
33073: IFFALSE 33387
// begin for j = list downto 2 do
33075: LD_ADDR_VAR 0 6
33079: PUSH
33080: DOUBLE
33081: LD_VAR 0 1
33085: INC
33086: ST_TO_ADDR
33087: LD_INT 2
33089: PUSH
33090: FOR_DOWNTO
33091: IFFALSE 33383
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33093: LD_VAR 0 2
33097: PPUSH
33098: LD_VAR 0 3
33102: PPUSH
33103: LD_VAR 0 1
33107: PUSH
33108: LD_VAR 0 6
33112: ARRAY
33113: PUSH
33114: LD_INT 1
33116: ARRAY
33117: PPUSH
33118: LD_VAR 0 1
33122: PUSH
33123: LD_VAR 0 6
33127: ARRAY
33128: PUSH
33129: LD_INT 2
33131: ARRAY
33132: PPUSH
33133: CALL_OW 298
33137: PUSH
33138: LD_VAR 0 2
33142: PPUSH
33143: LD_VAR 0 3
33147: PPUSH
33148: LD_VAR 0 1
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: LD_INT 1
33160: MINUS
33161: ARRAY
33162: PUSH
33163: LD_INT 1
33165: ARRAY
33166: PPUSH
33167: LD_VAR 0 1
33171: PUSH
33172: LD_VAR 0 6
33176: PUSH
33177: LD_INT 1
33179: MINUS
33180: ARRAY
33181: PUSH
33182: LD_INT 2
33184: ARRAY
33185: PPUSH
33186: CALL_OW 298
33190: LESS
33191: IFFALSE 33381
// begin _x := list [ j ] [ 1 ] ;
33193: LD_ADDR_VAR 0 7
33197: PUSH
33198: LD_VAR 0 1
33202: PUSH
33203: LD_VAR 0 6
33207: ARRAY
33208: PUSH
33209: LD_INT 1
33211: ARRAY
33212: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33213: LD_ADDR_VAR 0 8
33217: PUSH
33218: LD_VAR 0 1
33222: PUSH
33223: LD_VAR 0 6
33227: ARRAY
33228: PUSH
33229: LD_INT 2
33231: ARRAY
33232: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33233: LD_ADDR_VAR 0 1
33237: PUSH
33238: LD_VAR 0 1
33242: PPUSH
33243: LD_VAR 0 6
33247: PPUSH
33248: LD_INT 1
33250: PPUSH
33251: LD_VAR 0 1
33255: PUSH
33256: LD_VAR 0 6
33260: PUSH
33261: LD_INT 1
33263: MINUS
33264: ARRAY
33265: PUSH
33266: LD_INT 1
33268: ARRAY
33269: PPUSH
33270: CALL 31011 0 4
33274: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33275: LD_ADDR_VAR 0 1
33279: PUSH
33280: LD_VAR 0 1
33284: PPUSH
33285: LD_VAR 0 6
33289: PPUSH
33290: LD_INT 2
33292: PPUSH
33293: LD_VAR 0 1
33297: PUSH
33298: LD_VAR 0 6
33302: PUSH
33303: LD_INT 1
33305: MINUS
33306: ARRAY
33307: PUSH
33308: LD_INT 2
33310: ARRAY
33311: PPUSH
33312: CALL 31011 0 4
33316: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33317: LD_ADDR_VAR 0 1
33321: PUSH
33322: LD_VAR 0 1
33326: PPUSH
33327: LD_VAR 0 6
33331: PUSH
33332: LD_INT 1
33334: MINUS
33335: PPUSH
33336: LD_INT 1
33338: PPUSH
33339: LD_VAR 0 7
33343: PPUSH
33344: CALL 31011 0 4
33348: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33349: LD_ADDR_VAR 0 1
33353: PUSH
33354: LD_VAR 0 1
33358: PPUSH
33359: LD_VAR 0 6
33363: PUSH
33364: LD_INT 1
33366: MINUS
33367: PPUSH
33368: LD_INT 2
33370: PPUSH
33371: LD_VAR 0 8
33375: PPUSH
33376: CALL 31011 0 4
33380: ST_TO_ADDR
// end ; end ;
33381: GO 33090
33383: POP
33384: POP
// end ;
33385: GO 33072
33387: POP
33388: POP
// result := list ;
33389: LD_ADDR_VAR 0 4
33393: PUSH
33394: LD_VAR 0 1
33398: ST_TO_ADDR
// end ;
33399: LD_VAR 0 4
33403: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33404: LD_INT 0
33406: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33407: LD_ADDR_VAR 0 5
33411: PUSH
33412: LD_VAR 0 1
33416: PPUSH
33417: LD_VAR 0 2
33421: PPUSH
33422: CALL_OW 546
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PUSH
33431: LD_VAR 0 3
33435: PPUSH
33436: LD_VAR 0 4
33440: PPUSH
33441: CALL_OW 546
33445: PUSH
33446: LD_INT 2
33448: ARRAY
33449: MINUS
33450: ST_TO_ADDR
// if result < 0 then
33451: LD_VAR 0 5
33455: PUSH
33456: LD_INT 0
33458: LESS
33459: IFFALSE 33476
// result := result * - 1 ;
33461: LD_ADDR_VAR 0 5
33465: PUSH
33466: LD_VAR 0 5
33470: PUSH
33471: LD_INT 1
33473: NEG
33474: MUL
33475: ST_TO_ADDR
// end ;
33476: LD_VAR 0 5
33480: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33481: LD_INT 0
33483: PPUSH
33484: PPUSH
// area = ListEnvironmentArea ( area ) ;
33485: LD_ADDR_VAR 0 2
33489: PUSH
33490: LD_VAR 0 2
33494: PPUSH
33495: CALL_OW 353
33499: ST_TO_ADDR
// if bulldozer > 0 then
33500: LD_VAR 0 1
33504: PUSH
33505: LD_INT 0
33507: GREATER
33508: IFFALSE 33619
// for i = area downto 1 do
33510: LD_ADDR_VAR 0 4
33514: PUSH
33515: DOUBLE
33516: LD_VAR 0 2
33520: INC
33521: ST_TO_ADDR
33522: LD_INT 1
33524: PUSH
33525: FOR_DOWNTO
33526: IFFALSE 33617
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33528: LD_VAR 0 2
33532: PUSH
33533: LD_VAR 0 4
33537: ARRAY
33538: PUSH
33539: LD_INT 1
33541: ARRAY
33542: PPUSH
33543: LD_VAR 0 2
33547: PUSH
33548: LD_VAR 0 4
33552: ARRAY
33553: PUSH
33554: LD_INT 2
33556: ARRAY
33557: PPUSH
33558: CALL_OW 351
33562: IFFALSE 33615
// if not HasTask ( bulldozer ) then
33564: LD_VAR 0 1
33568: PPUSH
33569: CALL_OW 314
33573: NOT
33574: IFFALSE 33615
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33576: LD_VAR 0 1
33580: PPUSH
33581: LD_VAR 0 2
33585: PUSH
33586: LD_VAR 0 4
33590: ARRAY
33591: PUSH
33592: LD_INT 1
33594: ARRAY
33595: PPUSH
33596: LD_VAR 0 2
33600: PUSH
33601: LD_VAR 0 4
33605: ARRAY
33606: PUSH
33607: LD_INT 2
33609: ARRAY
33610: PPUSH
33611: CALL_OW 171
33615: GO 33525
33617: POP
33618: POP
// end ;
33619: LD_VAR 0 3
33623: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33624: LD_INT 0
33626: PPUSH
33627: PPUSH
33628: PPUSH
33629: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33630: LD_ADDR_VAR 0 6
33634: PUSH
33635: LD_INT 22
33637: PUSH
33638: LD_VAR 0 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 21
33649: PUSH
33650: LD_VAR 0 2
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PPUSH
33663: CALL_OW 69
33667: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33668: LD_ADDR_VAR 0 7
33672: PUSH
33673: LD_VAR 0 3
33677: PPUSH
33678: LD_INT 22
33680: PUSH
33681: LD_VAR 0 1
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 21
33692: PUSH
33693: LD_VAR 0 2
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PPUSH
33706: CALL_OW 70
33710: ST_TO_ADDR
// if tmp and pom then
33711: LD_VAR 0 6
33715: PUSH
33716: LD_VAR 0 7
33720: AND
33721: IFFALSE 33741
// result := tmp diff pom else
33723: LD_ADDR_VAR 0 4
33727: PUSH
33728: LD_VAR 0 6
33732: PUSH
33733: LD_VAR 0 7
33737: DIFF
33738: ST_TO_ADDR
33739: GO 33749
// result := false ;
33741: LD_ADDR_VAR 0 4
33745: PUSH
33746: LD_INT 0
33748: ST_TO_ADDR
// end ;
33749: LD_VAR 0 4
33753: RET
// export function SavePosition ( unit ) ; begin
33754: LD_INT 0
33756: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33757: LD_VAR 0 1
33761: PPUSH
33762: LD_VAR 0 1
33766: PPUSH
33767: CALL_OW 250
33771: PPUSH
33772: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33776: LD_VAR 0 1
33780: PPUSH
33781: LD_VAR 0 1
33785: PPUSH
33786: CALL_OW 251
33790: PPUSH
33791: CALL_OW 232
// end ;
33795: LD_VAR 0 2
33799: RET
// export function GetPosition ( unit ) ; begin
33800: LD_INT 0
33802: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33803: LD_ADDR_VAR 0 2
33807: PUSH
33808: LD_VAR 0 1
33812: PPUSH
33813: CALL_OW 252
33817: PUSH
33818: LD_VAR 0 1
33822: PPUSH
33823: CALL_OW 253
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: ST_TO_ADDR
// end ;
33832: LD_VAR 0 2
33836: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33837: LD_INT 0
33839: PPUSH
// if unit in unreachableList then
33840: LD_VAR 0 1
33844: PUSH
33845: LD_EXP 30
33849: IN
33850: IFFALSE 33868
// unreachableList := unreachableList diff unit ;
33852: LD_ADDR_EXP 30
33856: PUSH
33857: LD_EXP 30
33861: PUSH
33862: LD_VAR 0 1
33866: DIFF
33867: ST_TO_ADDR
// if ValidHex ( x , y ) then
33868: LD_VAR 0 2
33872: PPUSH
33873: LD_VAR 0 3
33877: PPUSH
33878: CALL_OW 488
33882: IFFALSE 33908
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33884: LD_VAR 0 1
33888: PPUSH
33889: LD_VAR 0 2
33893: PPUSH
33894: LD_VAR 0 3
33898: PPUSH
33899: CALL_OW 428
33903: PPUSH
33904: CALL_OW 115
// Wait ( 3 ) ;
33908: LD_INT 3
33910: PPUSH
33911: CALL_OW 67
// if unit in unreachableList then
33915: LD_VAR 0 1
33919: PUSH
33920: LD_EXP 30
33924: IN
33925: IFFALSE 33937
// result := false else
33927: LD_ADDR_VAR 0 4
33931: PUSH
33932: LD_INT 0
33934: ST_TO_ADDR
33935: GO 33945
// result := true ;
33937: LD_ADDR_VAR 0 4
33941: PUSH
33942: LD_INT 1
33944: ST_TO_ADDR
// end ; end_of_file
33945: LD_VAR 0 4
33949: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
33950: LD_EXP 31
33954: IFFALSE 34016
33956: GO 33958
33958: DISABLE
33959: LD_INT 0
33961: PPUSH
// begin enable ;
33962: ENABLE
// for i = 1 to mc_crates_list do
33963: LD_ADDR_VAR 0 1
33967: PUSH
33968: DOUBLE
33969: LD_INT 1
33971: DEC
33972: ST_TO_ADDR
33973: LD_EXP 32
33977: PUSH
33978: FOR_TO
33979: IFFALSE 34010
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
33981: LD_EXP 32
33985: PUSH
33986: LD_VAR 0 1
33990: ARRAY
33991: PPUSH
33992: LD_INT 5
33994: PPUSH
33995: LD_INT 50
33997: PPUSH
33998: LD_INT 700
34000: PPUSH
34001: LD_INT 20
34003: PPUSH
34004: CALL 24380 0 5
34008: GO 33978
34010: POP
34011: POP
// MC_Game ( ) ;
34012: CALL 34019 0 0
// end ;
34016: PPOPN 1
34018: END
// export function MC_Game ( ) ; var i , side , un ; begin
34019: LD_INT 0
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
// if not isTest then
34025: LD_EXP 1
34029: NOT
34030: IFFALSE 34050
// MC_Show ( [ #tick , tick ] ) else
34032: LD_STRING #tick
34034: PUSH
34035: LD_OWVAR 1
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PPUSH
34044: CALL 8464 0 1
34048: GO 34059
// MC_Show ( debug_string ) ;
34050: LD_EXP 2
34054: PPUSH
34055: CALL 8464 0 1
// for side = 1 to 8 do
34059: LD_ADDR_VAR 0 3
34063: PUSH
34064: DOUBLE
34065: LD_INT 1
34067: DEC
34068: ST_TO_ADDR
34069: LD_INT 8
34071: PUSH
34072: FOR_TO
34073: IFFALSE 36073
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34075: LD_EXP 39
34079: PUSH
34080: LD_VAR 0 3
34084: ARRAY
34085: PUSH
34086: LD_INT 0
34088: EQUAL
34089: PUSH
34090: LD_VAR 0 3
34094: PPUSH
34095: EMPTY
34096: PPUSH
34097: CALL 11681 0 2
34101: PUSH
34102: LD_INT 0
34104: EQUAL
34105: OR
34106: IFFALSE 34110
// continue ;
34108: GO 34072
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34110: LD_VAR 0 3
34114: PPUSH
34115: LD_VAR 0 3
34119: PPUSH
34120: CALL 24901 0 1
34124: PPUSH
34125: CALL 36080 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34129: LD_EXP 71
34133: PUSH
34134: LD_VAR 0 3
34138: ARRAY
34139: PUSH
34140: LD_INT 1
34142: ARRAY
34143: PUSH
34144: LD_INT 0
34146: GREATER
34147: PUSH
34148: LD_EXP 69
34152: PUSH
34153: LD_VAR 0 3
34157: ARRAY
34158: PUSH
34159: LD_INT 1
34161: ARRAY
34162: PUSH
34163: LD_INT 0
34165: EQUAL
34166: AND
34167: PUSH
34168: LD_VAR 0 3
34172: PPUSH
34173: LD_INT 7
34175: PPUSH
34176: EMPTY
34177: PPUSH
34178: CALL 12249 0 3
34182: NOT
34183: AND
34184: IFFALSE 34221
// begin for i in MREG_Attackers [ side ] do
34186: LD_ADDR_VAR 0 2
34190: PUSH
34191: LD_EXP 71
34195: PUSH
34196: LD_VAR 0 3
34200: ARRAY
34201: PUSH
34202: FOR_IN
34203: IFFALSE 34219
// SetTag ( i , 7 ) ;
34205: LD_VAR 0 2
34209: PPUSH
34210: LD_INT 7
34212: PPUSH
34213: CALL_OW 109
34217: GO 34202
34219: POP
34220: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34221: LD_VAR 0 3
34225: PPUSH
34226: LD_INT 7
34228: PPUSH
34229: EMPTY
34230: PPUSH
34231: CALL 12249 0 3
34235: IFFALSE 34295
// begin if side = 1 then
34237: LD_VAR 0 3
34241: PUSH
34242: LD_INT 1
34244: EQUAL
34245: IFFALSE 34254
// RaiseSailEvent ( 101 ) ;
34247: LD_INT 101
34249: PPUSH
34250: CALL_OW 427
// if side = 4 then
34254: LD_VAR 0 3
34258: PUSH
34259: LD_INT 4
34261: EQUAL
34262: IFFALSE 34271
// RaiseSailEvent ( 102 ) ;
34264: LD_INT 102
34266: PPUSH
34267: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34271: LD_VAR 0 3
34275: PPUSH
34276: LD_VAR 0 3
34280: PPUSH
34281: LD_INT 7
34283: PPUSH
34284: EMPTY
34285: PPUSH
34286: CALL 12249 0 3
34290: PPUSH
34291: CALL 8382 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34295: LD_VAR 0 3
34299: PPUSH
34300: CALL 17929 0 1
34304: PUSH
34305: LD_VAR 0 3
34309: PPUSH
34310: CALL 11585 0 1
34314: AND
34315: IFFALSE 34326
// MCL_Start ( side ) ;
34317: LD_VAR 0 3
34321: PPUSH
34322: CALL 17886 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34326: LD_ADDR_EXP 35
34330: PUSH
34331: LD_EXP 35
34335: PPUSH
34336: LD_VAR 0 3
34340: PPUSH
34341: LD_VAR 0 3
34345: PPUSH
34346: CALL 19186 0 1
34350: PPUSH
34351: CALL_OW 1
34355: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34356: LD_ADDR_EXP 47
34360: PUSH
34361: LD_EXP 47
34365: PPUSH
34366: LD_VAR 0 3
34370: PPUSH
34371: LD_VAR 0 3
34375: PPUSH
34376: CALL 10999 0 1
34380: PPUSH
34381: CALL_OW 1
34385: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34386: LD_VAR 0 3
34390: PPUSH
34391: LD_INT 21
34393: PUSH
34394: LD_INT 2
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PPUSH
34401: CALL 11546 0 2
34405: IFFALSE 34416
// MCV_CheckStatus ( side ) ;
34407: LD_VAR 0 3
34411: PPUSH
34412: CALL 27083 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34416: LD_VAR 0 3
34420: PPUSH
34421: LD_EXP 53
34425: PPUSH
34426: CALL 42880 0 2
34430: IFFALSE 34515
// begin for i = MREG_ToChangeClass downto 1 do
34432: LD_ADDR_VAR 0 2
34436: PUSH
34437: DOUBLE
34438: LD_EXP 53
34442: INC
34443: ST_TO_ADDR
34444: LD_INT 1
34446: PUSH
34447: FOR_DOWNTO
34448: IFFALSE 34513
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34450: LD_EXP 53
34454: PUSH
34455: LD_VAR 0 2
34459: ARRAY
34460: PUSH
34461: LD_INT 1
34463: ARRAY
34464: PUSH
34465: LD_VAR 0 3
34469: EQUAL
34470: IFFALSE 34511
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34472: LD_VAR 0 3
34476: PPUSH
34477: LD_EXP 53
34481: PUSH
34482: LD_VAR 0 2
34486: ARRAY
34487: PUSH
34488: LD_INT 2
34490: ARRAY
34491: PPUSH
34492: LD_EXP 53
34496: PUSH
34497: LD_VAR 0 2
34501: ARRAY
34502: PUSH
34503: LD_INT 3
34505: ARRAY
34506: PPUSH
34507: CALL 16453 0 3
// end ; end ;
34511: GO 34447
34513: POP
34514: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34515: LD_INT 1
34517: PUSH
34518: LD_EXP 38
34522: PUSH
34523: LD_VAR 0 3
34527: ARRAY
34528: IN
34529: IFFALSE 34540
// begin MCN_TrainApe ( side ) ;
34531: LD_VAR 0 3
34535: PPUSH
34536: CALL 18839 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34540: LD_VAR 0 3
34544: PPUSH
34545: LD_INT 30
34547: PUSH
34548: LD_INT 3
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PPUSH
34555: CALL 11546 0 2
34559: IFFALSE 34733
// begin if MCF_Tag ( side , 10 , [ ] ) then
34561: LD_VAR 0 3
34565: PPUSH
34566: LD_INT 10
34568: PPUSH
34569: EMPTY
34570: PPUSH
34571: CALL 12249 0 3
34575: IFFALSE 34622
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34577: LD_VAR 0 3
34581: PPUSH
34582: LD_INT 10
34584: PPUSH
34585: EMPTY
34586: PPUSH
34587: CALL 12249 0 3
34591: PPUSH
34592: LD_VAR 0 3
34596: PPUSH
34597: LD_INT 30
34599: PUSH
34600: LD_INT 3
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PPUSH
34607: CALL 11546 0 2
34611: PUSH
34612: LD_INT 1
34614: ARRAY
34615: PPUSH
34616: CALL_OW 168
// end else
34620: GO 34733
// if MREG_ToConstruct [ side ] then
34622: LD_EXP 51
34626: PUSH
34627: LD_VAR 0 3
34631: ARRAY
34632: IFFALSE 34733
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34634: LD_VAR 0 3
34638: PPUSH
34639: LD_VAR 0 3
34643: PPUSH
34644: LD_INT 30
34646: PUSH
34647: LD_INT 3
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PPUSH
34654: CALL 11546 0 2
34658: PUSH
34659: LD_INT 1
34661: ARRAY
34662: PPUSH
34663: LD_EXP 51
34667: PUSH
34668: LD_VAR 0 3
34672: ARRAY
34673: PUSH
34674: LD_INT 1
34676: ARRAY
34677: PUSH
34678: LD_EXP 51
34682: PUSH
34683: LD_VAR 0 3
34687: ARRAY
34688: PUSH
34689: LD_INT 2
34691: ARRAY
34692: PUSH
34693: LD_EXP 51
34697: PUSH
34698: LD_VAR 0 3
34702: ARRAY
34703: PUSH
34704: LD_INT 3
34706: ARRAY
34707: PUSH
34708: LD_EXP 51
34712: PUSH
34713: LD_VAR 0 3
34717: ARRAY
34718: PUSH
34719: LD_INT 4
34721: ARRAY
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: PPUSH
34729: CALL 25391 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34733: LD_VAR 0 3
34737: PPUSH
34738: LD_INT 30
34740: PUSH
34741: LD_INT 3
34743: PUSH
34744: EMPTY
34745: LIST
34746: LIST
34747: PPUSH
34748: CALL 11546 0 2
34752: PUSH
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_EXP 43
34762: PPUSH
34763: CALL 42880 0 2
34767: AND
34768: PUSH
34769: LD_INT 22
34771: PUSH
34772: LD_VAR 0 3
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 2
34783: PUSH
34784: LD_INT 30
34786: PUSH
34787: LD_INT 33
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 30
34796: PUSH
34797: LD_INT 32
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 35
34811: PUSH
34812: LD_INT 0
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: LIST
34823: PPUSH
34824: CALL_OW 69
34828: AND
34829: IFFALSE 34840
// MCV_Turret ( side ) ;
34831: LD_VAR 0 3
34835: PPUSH
34836: CALL 25828 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34840: LD_EXP 42
34844: PUSH
34845: LD_VAR 0 3
34849: ARRAY
34850: PUSH
34851: LD_INT 1
34853: GREATER
34854: PUSH
34855: LD_VAR 0 3
34859: PPUSH
34860: CALL 24901 0 1
34864: PUSH
34865: LD_INT 0
34867: EQUAL
34868: AND
34869: IFFALSE 35031
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34871: LD_EXP 42
34875: PUSH
34876: LD_VAR 0 3
34880: ARRAY
34881: PUSH
34882: LD_INT 1
34884: ARRAY
34885: PPUSH
34886: CALL_OW 353
34890: IFFALSE 34928
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
34892: LD_EXP 42
34896: PUSH
34897: LD_VAR 0 3
34901: ARRAY
34902: PUSH
34903: LD_INT 2
34905: ARRAY
34906: PPUSH
34907: LD_EXP 42
34911: PUSH
34912: LD_VAR 0 3
34916: ARRAY
34917: PUSH
34918: LD_INT 1
34920: ARRAY
34921: PPUSH
34922: CALL 32309 0 2
34926: GO 35031
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
34928: LD_VAR 0 3
34932: PPUSH
34933: LD_INT 30
34935: PUSH
34936: LD_INT 3
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL 11546 0 2
34947: IFFALSE 35031
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
34949: LD_VAR 0 3
34953: PPUSH
34954: LD_INT 30
34956: PUSH
34957: LD_INT 3
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PPUSH
34964: CALL 11546 0 2
34968: PUSH
34969: LD_INT 1
34971: ARRAY
34972: PPUSH
34973: CALL_OW 461
34977: PUSH
34978: LD_INT 2
34980: EQUAL
34981: IFFALSE 35031
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
34983: LD_EXP 42
34987: PUSH
34988: LD_VAR 0 3
34992: ARRAY
34993: PUSH
34994: LD_INT 2
34996: ARRAY
34997: PPUSH
34998: LD_INT 10
35000: PPUSH
35001: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35005: LD_ADDR_EXP 42
35009: PUSH
35010: LD_EXP 42
35014: PPUSH
35015: LD_VAR 0 3
35019: PPUSH
35020: LD_INT 0
35022: PUSH
35023: EMPTY
35024: LIST
35025: PPUSH
35026: CALL_OW 1
35030: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35031: LD_VAR 0 3
35035: PPUSH
35036: LD_INT 33
35038: PUSH
35039: LD_INT 2
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PPUSH
35046: CALL 11546 0 2
35050: IFFALSE 35090
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35052: LD_VAR 0 3
35056: PPUSH
35057: LD_VAR 0 3
35061: PPUSH
35062: LD_INT 33
35064: PUSH
35065: LD_INT 2
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PPUSH
35072: CALL 11546 0 2
35076: PUSH
35077: LD_INT 1
35079: ARRAY
35080: PPUSH
35081: CALL_OW 248
35085: PPUSH
35086: CALL 26382 0 2
// if MREG_ToRepair [ side ] then
35090: LD_EXP 47
35094: PUSH
35095: LD_VAR 0 3
35099: ARRAY
35100: IFFALSE 35113
// begin MCB_Repair ( side ) ;
35102: LD_VAR 0 3
35106: PPUSH
35107: CALL 11286 0 1
// end else
35111: GO 36026
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35113: LD_VAR 0 3
35117: PPUSH
35118: LD_EXP 49
35122: PPUSH
35123: CALL 42880 0 2
35127: PUSH
35128: LD_VAR 0 3
35132: PPUSH
35133: LD_EXP 40
35137: PPUSH
35138: CALL 42880 0 2
35142: AND
35143: IFFALSE 35351
// begin for i = 1 to MREG_ToUpLab do
35145: LD_ADDR_VAR 0 2
35149: PUSH
35150: DOUBLE
35151: LD_INT 1
35153: DEC
35154: ST_TO_ADDR
35155: LD_EXP 49
35159: PUSH
35160: FOR_TO
35161: IFFALSE 35347
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35163: LD_EXP 49
35167: PUSH
35168: LD_VAR 0 2
35172: ARRAY
35173: PUSH
35174: LD_INT 1
35176: ARRAY
35177: PUSH
35178: LD_VAR 0 3
35182: EQUAL
35183: IFFALSE 35345
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35185: LD_EXP 49
35189: PUSH
35190: LD_VAR 0 2
35194: ARRAY
35195: PUSH
35196: LD_INT 2
35198: ARRAY
35199: PUSH
35200: LD_EXP 49
35204: PUSH
35205: LD_VAR 0 2
35209: ARRAY
35210: PUSH
35211: LD_INT 3
35213: ARRAY
35214: AND
35215: IFFALSE 35343
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35217: LD_VAR 0 3
35221: PPUSH
35222: LD_EXP 49
35226: PUSH
35227: LD_VAR 0 2
35231: ARRAY
35232: PUSH
35233: LD_INT 2
35235: ARRAY
35236: PPUSH
35237: LD_EXP 49
35241: PUSH
35242: LD_VAR 0 2
35246: ARRAY
35247: PUSH
35248: LD_INT 3
35250: ARRAY
35251: PPUSH
35252: CALL 8810 0 3
35256: IFFALSE 35343
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35258: LD_ADDR_EXP 49
35262: PUSH
35263: LD_EXP 49
35267: PPUSH
35268: LD_VAR 0 3
35272: PPUSH
35273: LD_EXP 49
35277: PUSH
35278: LD_VAR 0 2
35282: ARRAY
35283: PUSH
35284: LD_INT 2
35286: ARRAY
35287: PPUSH
35288: LD_EXP 49
35292: PUSH
35293: LD_VAR 0 2
35297: ARRAY
35298: PUSH
35299: LD_INT 3
35301: ARRAY
35302: PPUSH
35303: CALL 41932 0 4
35307: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35308: LD_ADDR_EXP 40
35312: PUSH
35313: LD_EXP 40
35317: PPUSH
35318: LD_VAR 0 3
35322: PPUSH
35323: LD_EXP 40
35327: PUSH
35328: LD_INT 1
35330: ARRAY
35331: PUSH
35332: LD_INT 2
35334: ARRAY
35335: PPUSH
35336: EMPTY
35337: PPUSH
35338: CALL 41932 0 4
35342: ST_TO_ADDR
// end ; break ;
35343: GO 35347
// end ;
35345: GO 35160
35347: POP
35348: POP
// end else
35349: GO 36026
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35351: LD_VAR 0 3
35355: PPUSH
35356: LD_EXP 48
35360: PPUSH
35361: CALL 42880 0 2
35365: IFFALSE 35439
// begin for i = 1 to MREG_ToUpdate do
35367: LD_ADDR_VAR 0 2
35371: PUSH
35372: DOUBLE
35373: LD_INT 1
35375: DEC
35376: ST_TO_ADDR
35377: LD_EXP 48
35381: PUSH
35382: FOR_TO
35383: IFFALSE 35435
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35385: LD_EXP 48
35389: PUSH
35390: LD_VAR 0 2
35394: ARRAY
35395: PUSH
35396: LD_INT 1
35398: ARRAY
35399: PUSH
35400: LD_VAR 0 3
35404: EQUAL
35405: IFFALSE 35433
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35407: LD_VAR 0 3
35411: PPUSH
35412: LD_EXP 48
35416: PUSH
35417: LD_VAR 0 2
35421: ARRAY
35422: PUSH
35423: LD_INT 2
35425: ARRAY
35426: PPUSH
35427: CALL 8646 0 2
// break ;
35431: GO 35435
// end ;
35433: GO 35382
35435: POP
35436: POP
// end else
35437: GO 36026
// if MCF_Get ( side , [ f_constructed ] ) then
35439: LD_VAR 0 3
35443: PPUSH
35444: LD_INT 57
35446: PUSH
35447: EMPTY
35448: LIST
35449: PPUSH
35450: CALL 11546 0 2
35454: IFFALSE 35487
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35456: LD_VAR 0 3
35460: PPUSH
35461: LD_VAR 0 3
35465: PPUSH
35466: LD_INT 57
35468: PUSH
35469: EMPTY
35470: LIST
35471: PPUSH
35472: CALL 11546 0 2
35476: PUSH
35477: LD_INT 1
35479: ARRAY
35480: PPUSH
35481: CALL 10890 0 2
35485: GO 36026
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35487: LD_VAR 0 3
35491: PPUSH
35492: LD_EXP 46
35496: PPUSH
35497: CALL 42880 0 2
35501: PUSH
35502: LD_VAR 0 3
35506: PPUSH
35507: CALL_OW 345
35511: NOT
35512: AND
35513: PUSH
35514: LD_VAR 0 3
35518: PPUSH
35519: CALL 24901 0 1
35523: PUSH
35524: LD_INT 0
35526: EQUAL
35527: AND
35528: IFFALSE 35927
// begin for i = 1 to MREG_ToBuild do
35530: LD_ADDR_VAR 0 2
35534: PUSH
35535: DOUBLE
35536: LD_INT 1
35538: DEC
35539: ST_TO_ADDR
35540: LD_EXP 46
35544: PUSH
35545: FOR_TO
35546: IFFALSE 35923
// if MREG_ToBuild [ i ] [ 1 ] = side then
35548: LD_EXP 46
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: PUSH
35559: LD_INT 1
35561: ARRAY
35562: PUSH
35563: LD_VAR 0 3
35567: EQUAL
35568: IFFALSE 35921
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35570: LD_OWVAR 84
35574: PUSH
35575: LD_EXP 46
35579: PUSH
35580: LD_VAR 0 2
35584: ARRAY
35585: PUSH
35586: LD_INT 3
35588: ARRAY
35589: PUSH
35590: LD_INT 1
35592: ARRAY
35593: PPUSH
35594: LD_EXP 46
35598: PUSH
35599: LD_VAR 0 2
35603: ARRAY
35604: PUSH
35605: LD_INT 3
35607: ARRAY
35608: PUSH
35609: LD_INT 2
35611: ARRAY
35612: PPUSH
35613: CALL_OW 351
35617: AND
35618: IFFALSE 35662
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35620: LD_EXP 46
35624: PUSH
35625: LD_VAR 0 2
35629: ARRAY
35630: PUSH
35631: LD_INT 3
35633: ARRAY
35634: PUSH
35635: LD_INT 1
35637: ARRAY
35638: PPUSH
35639: LD_EXP 46
35643: PUSH
35644: LD_VAR 0 2
35648: ARRAY
35649: PUSH
35650: LD_INT 3
35652: ARRAY
35653: PUSH
35654: LD_INT 2
35656: ARRAY
35657: PPUSH
35658: CALL 22694 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35662: LD_EXP 46
35666: PUSH
35667: LD_VAR 0 2
35671: ARRAY
35672: PUSH
35673: LD_INT 2
35675: ARRAY
35676: PUSH
35677: LD_INT 0
35679: EQUAL
35680: IFFALSE 35750
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35682: LD_VAR 0 3
35686: PPUSH
35687: LD_EXP 46
35691: PUSH
35692: LD_VAR 0 2
35696: ARRAY
35697: PUSH
35698: LD_INT 3
35700: ARRAY
35701: PUSH
35702: LD_INT 1
35704: ARRAY
35705: PPUSH
35706: LD_EXP 46
35710: PUSH
35711: LD_VAR 0 2
35715: ARRAY
35716: PUSH
35717: LD_INT 3
35719: ARRAY
35720: PUSH
35721: LD_INT 2
35723: ARRAY
35724: PPUSH
35725: LD_EXP 46
35729: PUSH
35730: LD_VAR 0 2
35734: ARRAY
35735: PUSH
35736: LD_INT 3
35738: ARRAY
35739: PUSH
35740: LD_INT 3
35742: ARRAY
35743: PPUSH
35744: CALL 8482 0 4
35748: GO 35919
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35750: LD_EXP 46
35754: PUSH
35755: LD_VAR 0 2
35759: ARRAY
35760: PUSH
35761: LD_INT 2
35763: ARRAY
35764: PUSH
35765: LD_INT 6
35767: EQUAL
35768: IFFALSE 35838
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35770: LD_VAR 0 3
35774: PPUSH
35775: LD_EXP 46
35779: PUSH
35780: LD_VAR 0 2
35784: ARRAY
35785: PUSH
35786: LD_INT 3
35788: ARRAY
35789: PUSH
35790: LD_INT 1
35792: ARRAY
35793: PPUSH
35794: LD_EXP 46
35798: PUSH
35799: LD_VAR 0 2
35803: ARRAY
35804: PUSH
35805: LD_INT 3
35807: ARRAY
35808: PUSH
35809: LD_INT 2
35811: ARRAY
35812: PPUSH
35813: LD_EXP 46
35817: PUSH
35818: LD_VAR 0 2
35822: ARRAY
35823: PUSH
35824: LD_INT 3
35826: ARRAY
35827: PUSH
35828: LD_INT 3
35830: ARRAY
35831: PPUSH
35832: CALL 8611 0 4
35836: GO 35919
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35838: LD_VAR 0 3
35842: PPUSH
35843: LD_EXP 46
35847: PUSH
35848: LD_VAR 0 2
35852: ARRAY
35853: PUSH
35854: LD_INT 2
35856: ARRAY
35857: PPUSH
35858: LD_EXP 46
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_INT 3
35871: ARRAY
35872: PUSH
35873: LD_INT 1
35875: ARRAY
35876: PPUSH
35877: LD_EXP 46
35881: PUSH
35882: LD_VAR 0 2
35886: ARRAY
35887: PUSH
35888: LD_INT 3
35890: ARRAY
35891: PUSH
35892: LD_INT 2
35894: ARRAY
35895: PPUSH
35896: LD_EXP 46
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 3
35909: ARRAY
35910: PUSH
35911: LD_INT 3
35913: ARRAY
35914: PPUSH
35915: CALL 10115 0 5
// break ;
35919: GO 35923
// end ;
35921: GO 35545
35923: POP
35924: POP
// end else
35925: GO 36026
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
35927: LD_VAR 0 3
35931: PPUSH
35932: LD_EXP 52
35936: PPUSH
35937: CALL 42880 0 2
35941: PUSH
35942: LD_VAR 0 3
35946: PPUSH
35947: CALL 24901 0 1
35951: PUSH
35952: LD_INT 0
35954: EQUAL
35955: AND
35956: IFFALSE 36026
// begin for i = 1 to MREG_ToDismantle do
35958: LD_ADDR_VAR 0 2
35962: PUSH
35963: DOUBLE
35964: LD_INT 1
35966: DEC
35967: ST_TO_ADDR
35968: LD_EXP 52
35972: PUSH
35973: FOR_TO
35974: IFFALSE 36024
// if MREG_ToDismantle [ i ] [ 1 ] = side then
35976: LD_EXP 52
35980: PUSH
35981: LD_VAR 0 2
35985: ARRAY
35986: PUSH
35987: LD_INT 1
35989: ARRAY
35990: PUSH
35991: LD_VAR 0 3
35995: EQUAL
35996: IFFALSE 36022
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
35998: LD_VAR 0 3
36002: PPUSH
36003: LD_EXP 52
36007: PUSH
36008: LD_VAR 0 2
36012: ARRAY
36013: PUSH
36014: LD_INT 2
36016: ARRAY
36017: PPUSH
36018: CALL 10781 0 2
// end ;
36022: GO 35973
36024: POP
36025: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36026: LD_VAR 0 3
36030: PPUSH
36031: LD_INT 30
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PPUSH
36041: CALL 11546 0 2
36045: PUSH
36046: LD_VAR 0 3
36050: PPUSH
36051: CALL 24901 0 1
36055: PUSH
36056: LD_INT 0
36058: EQUAL
36059: AND
36060: IFFALSE 36071
// MCT_CollectCrates ( side ) ;
36062: LD_VAR 0 3
36066: PPUSH
36067: CALL 23840 0 1
// end ;
36071: GO 34072
36073: POP
36074: POP
// end ;
36075: LD_VAR 0 1
36079: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36080: LD_INT 0
36082: PPUSH
36083: PPUSH
36084: PPUSH
36085: PPUSH
36086: PPUSH
36087: PPUSH
36088: PPUSH
36089: PPUSH
36090: PPUSH
36091: PPUSH
36092: PPUSH
36093: PPUSH
36094: PPUSH
36095: PPUSH
36096: PPUSH
// all := MCF_All ( side , [ ] ) ;
36097: LD_ADDR_VAR 0 17
36101: PUSH
36102: LD_VAR 0 1
36106: PPUSH
36107: EMPTY
36108: PPUSH
36109: CALL 11681 0 2
36113: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36114: LD_ADDR_VAR 0 13
36118: PUSH
36119: LD_VAR 0 1
36123: PPUSH
36124: LD_INT 1
36126: PPUSH
36127: EMPTY
36128: PPUSH
36129: CALL 11629 0 3
36133: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36134: LD_ADDR_VAR 0 14
36138: PUSH
36139: LD_VAR 0 1
36143: PPUSH
36144: LD_INT 2
36146: PPUSH
36147: EMPTY
36148: PPUSH
36149: CALL 11629 0 3
36153: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36154: LD_ADDR_VAR 0 15
36158: PUSH
36159: LD_VAR 0 1
36163: PPUSH
36164: LD_INT 3
36166: PPUSH
36167: EMPTY
36168: PPUSH
36169: CALL 11629 0 3
36173: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36174: LD_ADDR_VAR 0 16
36178: PUSH
36179: LD_VAR 0 1
36183: PPUSH
36184: LD_INT 4
36186: PPUSH
36187: EMPTY
36188: PPUSH
36189: CALL 11629 0 3
36193: ST_TO_ADDR
// if mech then
36194: LD_VAR 0 15
36198: IFFALSE 36215
// mech := MCF_SortListDesc ( mech ) ;
36200: LD_ADDR_VAR 0 15
36204: PUSH
36205: LD_VAR 0 15
36209: PPUSH
36210: CALL 12795 0 1
36214: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36215: LD_EXP 56
36219: PUSH
36220: LD_VAR 0 1
36224: ARRAY
36225: PUSH
36226: LD_STRING 
36228: EQUAL
36229: NOT
36230: IFFALSE 36286
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36232: LD_EXP 56
36236: PUSH
36237: LD_VAR 0 1
36241: ARRAY
36242: PUSH
36243: LD_INT 1
36245: ARRAY
36246: PPUSH
36247: CALL_OW 257
36251: PUSH
36252: LD_INT 1
36254: EQUAL
36255: IFFALSE 36284
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36257: LD_VAR 0 1
36261: PPUSH
36262: LD_STRING ToArm
36264: PPUSH
36265: LD_EXP 56
36269: PUSH
36270: LD_VAR 0 1
36274: ARRAY
36275: PUSH
36276: LD_INT 1
36278: ARRAY
36279: PPUSH
36280: CALL 14425 0 3
// end else
36284: GO 36312
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36286: LD_ADDR_EXP 56
36290: PUSH
36291: LD_EXP 56
36295: PPUSH
36296: LD_VAR 0 1
36300: PPUSH
36301: LD_INT 1
36303: PPUSH
36304: LD_INT 0
36306: PPUSH
36307: CALL 31011 0 4
36311: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36312: LD_EXP 57
36316: PUSH
36317: LD_VAR 0 1
36321: ARRAY
36322: PUSH
36323: LD_STRING 
36325: EQUAL
36326: NOT
36327: IFFALSE 36383
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36329: LD_EXP 57
36333: PUSH
36334: LD_VAR 0 1
36338: ARRAY
36339: PUSH
36340: LD_INT 1
36342: ARRAY
36343: PPUSH
36344: CALL_OW 257
36348: PUSH
36349: LD_INT 2
36351: EQUAL
36352: IFFALSE 36381
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36354: LD_VAR 0 1
36358: PPUSH
36359: LD_STRING ToDep
36361: PPUSH
36362: LD_EXP 57
36366: PUSH
36367: LD_VAR 0 1
36371: ARRAY
36372: PUSH
36373: LD_INT 1
36375: ARRAY
36376: PPUSH
36377: CALL 14425 0 3
// end else
36381: GO 36409
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36383: LD_ADDR_EXP 57
36387: PUSH
36388: LD_EXP 57
36392: PPUSH
36393: LD_VAR 0 1
36397: PPUSH
36398: LD_INT 1
36400: PPUSH
36401: LD_INT 0
36403: PPUSH
36404: CALL 31011 0 4
36408: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36409: LD_EXP 55
36413: PUSH
36414: LD_VAR 0 1
36418: ARRAY
36419: PUSH
36420: LD_STRING 
36422: EQUAL
36423: NOT
36424: IFFALSE 36480
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36426: LD_EXP 55
36430: PUSH
36431: LD_VAR 0 1
36435: ARRAY
36436: PUSH
36437: LD_INT 1
36439: ARRAY
36440: PPUSH
36441: CALL_OW 257
36445: PUSH
36446: LD_INT 3
36448: EQUAL
36449: IFFALSE 36478
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36451: LD_VAR 0 1
36455: PPUSH
36456: LD_STRING ToFac
36458: PPUSH
36459: LD_EXP 55
36463: PUSH
36464: LD_VAR 0 1
36468: ARRAY
36469: PUSH
36470: LD_INT 1
36472: ARRAY
36473: PPUSH
36474: CALL 14425 0 3
// end else
36478: GO 36506
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36480: LD_ADDR_EXP 55
36484: PUSH
36485: LD_EXP 55
36489: PPUSH
36490: LD_VAR 0 1
36494: PPUSH
36495: LD_INT 1
36497: PPUSH
36498: LD_INT 0
36500: PPUSH
36501: CALL 31011 0 4
36505: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36506: LD_EXP 54
36510: PUSH
36511: LD_VAR 0 1
36515: ARRAY
36516: PUSH
36517: LD_STRING 
36519: EQUAL
36520: NOT
36521: IFFALSE 36577
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36523: LD_EXP 54
36527: PUSH
36528: LD_VAR 0 1
36532: ARRAY
36533: PUSH
36534: LD_INT 1
36536: ARRAY
36537: PPUSH
36538: CALL_OW 257
36542: PUSH
36543: LD_INT 4
36545: EQUAL
36546: IFFALSE 36575
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36548: LD_VAR 0 1
36552: PPUSH
36553: LD_STRING ToLab
36555: PPUSH
36556: LD_EXP 54
36560: PUSH
36561: LD_VAR 0 1
36565: ARRAY
36566: PUSH
36567: LD_INT 1
36569: ARRAY
36570: PPUSH
36571: CALL 14425 0 3
// end else
36575: GO 36603
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36577: LD_ADDR_EXP 54
36581: PUSH
36582: LD_EXP 54
36586: PPUSH
36587: LD_VAR 0 1
36591: PPUSH
36592: LD_INT 1
36594: PPUSH
36595: LD_INT 0
36597: PPUSH
36598: CALL 31011 0 4
36602: ST_TO_ADDR
// if mode = 0 then
36603: LD_VAR 0 2
36607: PUSH
36608: LD_INT 0
36610: EQUAL
36611: IFFALSE 38449
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36613: LD_VAR 0 1
36617: PPUSH
36618: LD_INT 30
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PPUSH
36628: CALL 11546 0 2
36632: PUSH
36633: LD_VAR 0 1
36637: PPUSH
36638: LD_INT 21
36640: PUSH
36641: LD_INT 3
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PPUSH
36648: CALL 11546 0 2
36652: PUSH
36653: LD_INT 1
36655: EQUAL
36656: AND
36657: IFFALSE 36722
// begin if all then
36659: LD_VAR 0 17
36663: IFFALSE 36720
// for i in ( all diff eng ) do
36665: LD_ADDR_VAR 0 4
36669: PUSH
36670: LD_VAR 0 17
36674: PUSH
36675: LD_VAR 0 14
36679: DIFF
36680: PUSH
36681: FOR_IN
36682: IFFALSE 36718
// if GetTag ( i ) = 0 then
36684: LD_VAR 0 4
36688: PPUSH
36689: CALL_OW 110
36693: PUSH
36694: LD_INT 0
36696: EQUAL
36697: IFFALSE 36716
// MCH_ChangeClass ( side , i , 2 ) ;
36699: LD_VAR 0 1
36703: PPUSH
36704: LD_VAR 0 4
36708: PPUSH
36709: LD_INT 2
36711: PPUSH
36712: CALL 16453 0 3
36716: GO 36681
36718: POP
36719: POP
// end else
36720: GO 37041
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36722: LD_VAR 0 13
36726: PUSH
36727: LD_EXP 56
36731: PUSH
36732: LD_VAR 0 1
36736: ARRAY
36737: PLUS
36738: PUSH
36739: LD_INT 22
36741: PUSH
36742: LD_VAR 0 1
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 30
36753: PUSH
36754: LD_INT 32
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PPUSH
36765: CALL_OW 69
36769: LESS
36770: IFFALSE 36795
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36772: LD_VAR 0 1
36776: PPUSH
36777: LD_VAR 0 14
36781: PUSH
36782: LD_INT 1
36784: ARRAY
36785: PPUSH
36786: LD_INT 1
36788: PPUSH
36789: CALL 16453 0 3
// end else
36793: GO 37041
// if sci < 6 and MCF_Lab ( side ) then
36795: LD_VAR 0 16
36799: PUSH
36800: LD_INT 6
36802: LESS
36803: PUSH
36804: LD_VAR 0 1
36808: PPUSH
36809: CALL 11585 0 1
36813: AND
36814: IFFALSE 36919
// begin if MREG_ToBunker [ side ] then
36816: LD_EXP 68
36820: PUSH
36821: LD_VAR 0 1
36825: ARRAY
36826: IFFALSE 36852
// tmp := sol diff MREG_ToBunker [ side ] else
36828: LD_ADDR_VAR 0 12
36832: PUSH
36833: LD_VAR 0 13
36837: PUSH
36838: LD_EXP 68
36842: PUSH
36843: LD_VAR 0 1
36847: ARRAY
36848: DIFF
36849: ST_TO_ADDR
36850: GO 36862
// tmp := sol ;
36852: LD_ADDR_VAR 0 12
36856: PUSH
36857: LD_VAR 0 13
36861: ST_TO_ADDR
// if tmp then
36862: LD_VAR 0 12
36866: IFFALSE 36917
// for i in tmp do
36868: LD_ADDR_VAR 0 4
36872: PUSH
36873: LD_VAR 0 12
36877: PUSH
36878: FOR_IN
36879: IFFALSE 36915
// if GetTag ( i ) = 0 then
36881: LD_VAR 0 4
36885: PPUSH
36886: CALL_OW 110
36890: PUSH
36891: LD_INT 0
36893: EQUAL
36894: IFFALSE 36913
// MCH_ChangeClass ( side , i , 4 ) ;
36896: LD_VAR 0 1
36900: PPUSH
36901: LD_VAR 0 4
36905: PPUSH
36906: LD_INT 4
36908: PPUSH
36909: CALL 16453 0 3
36913: GO 36878
36915: POP
36916: POP
// end else
36917: GO 37041
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
36919: LD_VAR 0 1
36923: PPUSH
36924: LD_INT 30
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PPUSH
36934: CALL 11546 0 2
36938: IFFALSE 37041
// begin if MREG_ToBunker [ side ] then
36940: LD_EXP 68
36944: PUSH
36945: LD_VAR 0 1
36949: ARRAY
36950: IFFALSE 36976
// tmp := sol diff MREG_ToBunker [ side ] else
36952: LD_ADDR_VAR 0 12
36956: PUSH
36957: LD_VAR 0 13
36961: PUSH
36962: LD_EXP 68
36966: PUSH
36967: LD_VAR 0 1
36971: ARRAY
36972: DIFF
36973: ST_TO_ADDR
36974: GO 36986
// tmp := sol ;
36976: LD_ADDR_VAR 0 12
36980: PUSH
36981: LD_VAR 0 13
36985: ST_TO_ADDR
// if tmp then
36986: LD_VAR 0 12
36990: IFFALSE 37041
// for i in tmp do
36992: LD_ADDR_VAR 0 4
36996: PUSH
36997: LD_VAR 0 12
37001: PUSH
37002: FOR_IN
37003: IFFALSE 37039
// if GetTag ( i ) = 0 then
37005: LD_VAR 0 4
37009: PPUSH
37010: CALL_OW 110
37014: PUSH
37015: LD_INT 0
37017: EQUAL
37018: IFFALSE 37037
// MCH_ChangeClass ( side , i , 2 ) ;
37020: LD_VAR 0 1
37024: PPUSH
37025: LD_VAR 0 4
37029: PPUSH
37030: LD_INT 2
37032: PPUSH
37033: CALL 16453 0 3
37037: GO 37002
37039: POP
37040: POP
// end ; if MCF_Lab ( side ) then
37041: LD_VAR 0 1
37045: PPUSH
37046: CALL 11585 0 1
37050: IFFALSE 37590
// begin if MCL_GetTechList ( side ) then
37052: LD_VAR 0 1
37056: PPUSH
37057: CALL 17929 0 1
37061: IFFALSE 37187
// begin if MREG_ToLab [ side ] then
37063: LD_EXP 54
37067: PUSH
37068: LD_VAR 0 1
37072: ARRAY
37073: IFFALSE 37093
// k := MREG_ToLab [ side ] else
37075: LD_ADDR_VAR 0 8
37079: PUSH
37080: LD_EXP 54
37084: PUSH
37085: LD_VAR 0 1
37089: ARRAY
37090: ST_TO_ADDR
37091: GO 37101
// k := 0 ;
37093: LD_ADDR_VAR 0 8
37097: PUSH
37098: LD_INT 0
37100: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37101: LD_VAR 0 16
37105: PUSH
37106: LD_VAR 0 8
37110: PLUS
37111: PUSH
37112: LD_INT 6
37114: LESSEQUAL
37115: PUSH
37116: LD_VAR 0 17
37120: PUSH
37121: LD_INT 6
37123: GREATER
37124: AND
37125: IFFALSE 37141
// MCH_TrainScientist ( side , 1 ) else
37127: LD_VAR 0 1
37131: PPUSH
37132: LD_INT 1
37134: PPUSH
37135: CALL 16005 0 2
37139: GO 37185
// if all < 6 then
37141: LD_VAR 0 17
37145: PUSH
37146: LD_INT 6
37148: LESS
37149: IFFALSE 37185
// if sci + k < all / 2 then
37151: LD_VAR 0 16
37155: PUSH
37156: LD_VAR 0 8
37160: PLUS
37161: PUSH
37162: LD_VAR 0 17
37166: PUSH
37167: LD_INT 2
37169: DIVREAL
37170: LESS
37171: IFFALSE 37185
// MCH_TrainScientist ( side , 1 ) ;
37173: LD_VAR 0 1
37177: PPUSH
37178: LD_INT 1
37180: PPUSH
37181: CALL 16005 0 2
// end else
37185: GO 37263
// begin if sci > 2 then
37187: LD_VAR 0 16
37191: PUSH
37192: LD_INT 2
37194: GREATER
37195: IFFALSE 37263
// for i = sci downto 2 do
37197: LD_ADDR_VAR 0 4
37201: PUSH
37202: DOUBLE
37203: LD_VAR 0 16
37207: INC
37208: ST_TO_ADDR
37209: LD_INT 2
37211: PUSH
37212: FOR_DOWNTO
37213: IFFALSE 37261
// if GetTag ( sci [ i ] ) = 0 then
37215: LD_VAR 0 16
37219: PUSH
37220: LD_VAR 0 4
37224: ARRAY
37225: PPUSH
37226: CALL_OW 110
37230: PUSH
37231: LD_INT 0
37233: EQUAL
37234: IFFALSE 37259
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37236: LD_VAR 0 1
37240: PPUSH
37241: LD_VAR 0 16
37245: PUSH
37246: LD_VAR 0 4
37250: ARRAY
37251: PPUSH
37252: LD_INT 2
37254: PPUSH
37255: CALL 16453 0 3
37259: GO 37212
37261: POP
37262: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37263: LD_VAR 0 1
37267: PPUSH
37268: CALL 17929 0 1
37272: PUSH
37273: LD_VAR 0 1
37277: PPUSH
37278: CALL 11585 0 1
37282: AND
37283: PUSH
37284: LD_EXP 35
37288: PUSH
37289: LD_VAR 0 1
37293: ARRAY
37294: NOT
37295: AND
37296: IFFALSE 37590
// begin for j = 1 to MCF_Lab ( side ) do
37298: LD_ADDR_VAR 0 5
37302: PUSH
37303: DOUBLE
37304: LD_INT 1
37306: DEC
37307: ST_TO_ADDR
37308: LD_VAR 0 1
37312: PPUSH
37313: CALL 11585 0 1
37317: PUSH
37318: FOR_TO
37319: IFFALSE 37379
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37321: LD_VAR 0 1
37325: PPUSH
37326: CALL 11585 0 1
37330: PUSH
37331: LD_VAR 0 5
37335: ARRAY
37336: PPUSH
37337: CALL_OW 461
37341: PUSH
37342: LD_INT 3
37344: PUSH
37345: LD_INT 6
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: IN
37352: IFFALSE 37377
// begin b := MCF_Lab ( side ) [ j ] ;
37354: LD_ADDR_VAR 0 11
37358: PUSH
37359: LD_VAR 0 1
37363: PPUSH
37364: CALL 11585 0 1
37368: PUSH
37369: LD_VAR 0 5
37373: ARRAY
37374: ST_TO_ADDR
// break ;
37375: GO 37379
// end ;
37377: GO 37318
37379: POP
37380: POP
// if MCF_Class ( side , 4 , [ ] ) then
37381: LD_VAR 0 1
37385: PPUSH
37386: LD_INT 4
37388: PPUSH
37389: EMPTY
37390: PPUSH
37391: CALL 11629 0 3
37395: IFFALSE 37590
// for j in MCF_Class ( side , 4 , [ ] ) do
37397: LD_ADDR_VAR 0 5
37401: PUSH
37402: LD_VAR 0 1
37406: PPUSH
37407: LD_INT 4
37409: PPUSH
37410: EMPTY
37411: PPUSH
37412: CALL 11629 0 3
37416: PUSH
37417: FOR_IN
37418: IFFALSE 37588
// begin if GetTag ( j ) = 0 then
37420: LD_VAR 0 5
37424: PPUSH
37425: CALL_OW 110
37429: PUSH
37430: LD_INT 0
37432: EQUAL
37433: IFFALSE 37524
// begin if IsInUnit ( j ) and b then
37435: LD_VAR 0 5
37439: PPUSH
37440: CALL_OW 310
37444: PUSH
37445: LD_VAR 0 11
37449: AND
37450: IFFALSE 37498
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37452: LD_VAR 0 5
37456: PPUSH
37457: CALL_OW 310
37461: PPUSH
37462: CALL_OW 461
37466: PUSH
37467: LD_INT 2
37469: EQUAL
37470: PUSH
37471: LD_VAR 0 5
37475: PPUSH
37476: CALL_OW 310
37480: PUSH
37481: LD_VAR 0 11
37485: NONEQUAL
37486: AND
37487: IFFALSE 37498
// ComExitBuilding ( j ) ;
37489: LD_VAR 0 5
37493: PPUSH
37494: CALL_OW 122
// if not IsInUnit ( j ) then
37498: LD_VAR 0 5
37502: PPUSH
37503: CALL_OW 310
37507: NOT
37508: IFFALSE 37524
// ComEnterUnit ( j , b ) ;
37510: LD_VAR 0 5
37514: PPUSH
37515: LD_VAR 0 11
37519: PPUSH
37520: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37524: LD_INT 1
37526: PPUSH
37527: LD_VAR 0 5
37531: PPUSH
37532: CALL_OW 255
37536: PPUSH
37537: CALL_OW 321
37541: PUSH
37542: LD_INT 2
37544: EQUAL
37545: PUSH
37546: LD_VAR 0 5
37550: PPUSH
37551: CALL_OW 255
37555: PPUSH
37556: CALL 24901 0 1
37560: PUSH
37561: LD_INT 0
37563: EQUAL
37564: AND
37565: IFFALSE 37586
// MCN_Tame ( GetSide ( j ) , j ) ;
37567: LD_VAR 0 5
37571: PPUSH
37572: CALL_OW 255
37576: PPUSH
37577: LD_VAR 0 5
37581: PPUSH
37582: CALL 18448 0 2
// end ;
37586: GO 37417
37588: POP
37589: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37590: LD_VAR 0 1
37594: PPUSH
37595: LD_INT 30
37597: PUSH
37598: LD_INT 3
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PPUSH
37605: CALL 11546 0 2
37609: IFFALSE 37868
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37611: LD_ADDR_VAR 0 11
37615: PUSH
37616: LD_VAR 0 1
37620: PPUSH
37621: LD_INT 30
37623: PUSH
37624: LD_INT 3
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PPUSH
37631: CALL 11546 0 2
37635: PUSH
37636: LD_INT 1
37638: ARRAY
37639: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37640: LD_ADDR_VAR 0 12
37644: PUSH
37645: LD_VAR 0 1
37649: PPUSH
37650: LD_INT 0
37652: PPUSH
37653: LD_INT 25
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PPUSH
37663: CALL 12249 0 3
37667: ST_TO_ADDR
// for i = 1 to tmp do
37668: LD_ADDR_VAR 0 4
37672: PUSH
37673: DOUBLE
37674: LD_INT 1
37676: DEC
37677: ST_TO_ADDR
37678: LD_VAR 0 12
37682: PUSH
37683: FOR_TO
37684: IFFALSE 37744
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37686: LD_VAR 0 12
37690: PUSH
37691: LD_VAR 0 4
37695: ARRAY
37696: PPUSH
37697: CALL_OW 310
37701: NOT
37702: PUSH
37703: LD_VAR 0 12
37707: PUSH
37708: LD_VAR 0 4
37712: ARRAY
37713: PPUSH
37714: CALL_OW 314
37718: NOT
37719: AND
37720: IFFALSE 37742
// ComEnterUnit ( tmp [ i ] , b ) ;
37722: LD_VAR 0 12
37726: PUSH
37727: LD_VAR 0 4
37731: ARRAY
37732: PPUSH
37733: LD_VAR 0 11
37737: PPUSH
37738: CALL_OW 120
37742: GO 37683
37744: POP
37745: POP
// if MREG_ToFac [ side ] then
37746: LD_EXP 55
37750: PUSH
37751: LD_VAR 0 1
37755: ARRAY
37756: IFFALSE 37776
// k := MREG_ToFac [ side ] else
37758: LD_ADDR_VAR 0 8
37762: PUSH
37763: LD_EXP 55
37767: PUSH
37768: LD_VAR 0 1
37772: ARRAY
37773: ST_TO_ADDR
37774: GO 37784
// k := 0 ;
37776: LD_ADDR_VAR 0 8
37780: PUSH
37781: LD_INT 0
37783: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37784: LD_VAR 0 15
37788: PUSH
37789: LD_VAR 0 8
37793: PLUS
37794: PUSH
37795: LD_INT 6
37797: LESSEQUAL
37798: PUSH
37799: LD_VAR 0 17
37803: PUSH
37804: LD_INT 6
37806: GREATER
37807: AND
37808: IFFALSE 37824
// MCH_TrainMechanic ( side , 1 ) else
37810: LD_VAR 0 1
37814: PPUSH
37815: LD_INT 1
37817: PPUSH
37818: CALL 15747 0 2
37822: GO 37868
// if all < 6 then
37824: LD_VAR 0 17
37828: PUSH
37829: LD_INT 6
37831: LESS
37832: IFFALSE 37868
// if mech + k < all / 2 then
37834: LD_VAR 0 15
37838: PUSH
37839: LD_VAR 0 8
37843: PLUS
37844: PUSH
37845: LD_VAR 0 17
37849: PUSH
37850: LD_INT 2
37852: DIVREAL
37853: LESS
37854: IFFALSE 37868
// MCH_TrainMechanic ( side , 1 ) ;
37856: LD_VAR 0 1
37860: PPUSH
37861: LD_INT 1
37863: PPUSH
37864: CALL 15747 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37868: LD_ADDR_VAR 0 10
37872: PUSH
37873: LD_VAR 0 1
37877: PPUSH
37878: LD_INT 30
37880: PUSH
37881: LD_INT 36
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PPUSH
37888: CALL 11546 0 2
37892: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
37893: LD_VAR 0 10
37897: PUSH
37898: LD_VAR 0 15
37902: AND
37903: PUSH
37904: LD_VAR 0 1
37908: PPUSH
37909: LD_INT 3
37911: PPUSH
37912: EMPTY
37913: PPUSH
37914: CALL 11629 0 3
37918: AND
37919: IFFALSE 38077
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
37921: LD_VAR 0 1
37925: PPUSH
37926: LD_INT 9
37928: PPUSH
37929: EMPTY
37930: PPUSH
37931: CALL 12249 0 3
37935: PUSH
37936: LD_INT 3
37938: LESS
37939: IFFALSE 38077
// begin if mech < 3 then
37941: LD_VAR 0 15
37945: PUSH
37946: LD_INT 3
37948: LESS
37949: IFFALSE 37963
// k := mech else
37951: LD_ADDR_VAR 0 8
37955: PUSH
37956: LD_VAR 0 15
37960: ST_TO_ADDR
37961: GO 37971
// k := 3 ;
37963: LD_ADDR_VAR 0 8
37967: PUSH
37968: LD_INT 3
37970: ST_TO_ADDR
// for j = 1 to k do
37971: LD_ADDR_VAR 0 5
37975: PUSH
37976: DOUBLE
37977: LD_INT 1
37979: DEC
37980: ST_TO_ADDR
37981: LD_VAR 0 8
37985: PUSH
37986: FOR_TO
37987: IFFALSE 38045
// if GetClass ( mech [ j ] ) = 3 then
37989: LD_VAR 0 15
37993: PUSH
37994: LD_VAR 0 5
37998: ARRAY
37999: PPUSH
38000: CALL_OW 257
38004: PUSH
38005: LD_INT 3
38007: EQUAL
38008: IFFALSE 38043
// begin SetTag ( mech [ j ] , 9 ) ;
38010: LD_VAR 0 15
38014: PUSH
38015: LD_VAR 0 5
38019: ARRAY
38020: PPUSH
38021: LD_INT 9
38023: PPUSH
38024: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38028: LD_VAR 0 15
38032: PUSH
38033: LD_VAR 0 5
38037: ARRAY
38038: PPUSH
38039: CALL_OW 122
// end ;
38043: GO 37986
38045: POP
38046: POP
// if mech < 6 + k then
38047: LD_VAR 0 15
38051: PUSH
38052: LD_INT 6
38054: PUSH
38055: LD_VAR 0 8
38059: PLUS
38060: LESS
38061: IFFALSE 38077
// MCH_TrainMechanic ( side , k ) ;
38063: LD_VAR 0 1
38067: PPUSH
38068: LD_VAR 0 8
38072: PPUSH
38073: CALL 15747 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38077: LD_VAR 0 1
38081: PPUSH
38082: LD_INT 9
38084: PPUSH
38085: EMPTY
38086: PPUSH
38087: CALL 12249 0 3
38091: IFFALSE 38182
// for j in MCF_Tag ( side , 9 , [ ] ) do
38093: LD_ADDR_VAR 0 5
38097: PUSH
38098: LD_VAR 0 1
38102: PPUSH
38103: LD_INT 9
38105: PPUSH
38106: EMPTY
38107: PPUSH
38108: CALL 12249 0 3
38112: PUSH
38113: FOR_IN
38114: IFFALSE 38180
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38116: LD_VAR 0 5
38120: PPUSH
38121: CALL_OW 310
38125: NOT
38126: PUSH
38127: LD_VAR 0 5
38131: PPUSH
38132: CALL 94844 0 1
38136: NOT
38137: AND
38138: IFFALSE 38178
// if ct then
38140: LD_VAR 0 10
38144: IFFALSE 38166
// ComEnterUnit ( j , ct [ 1 ] ) else
38146: LD_VAR 0 5
38150: PPUSH
38151: LD_VAR 0 10
38155: PUSH
38156: LD_INT 1
38158: ARRAY
38159: PPUSH
38160: CALL_OW 120
38164: GO 38178
// SetTag ( j , 0 ) ;
38166: LD_VAR 0 5
38170: PPUSH
38171: LD_INT 0
38173: PPUSH
38174: CALL_OW 109
38178: GO 38113
38180: POP
38181: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38182: LD_INT 1
38184: PPUSH
38185: LD_VAR 0 1
38189: PPUSH
38190: CALL_OW 321
38194: PUSH
38195: LD_INT 2
38197: EQUAL
38198: PUSH
38199: LD_EXP 35
38203: PUSH
38204: LD_VAR 0 1
38208: ARRAY
38209: NOT
38210: AND
38211: PUSH
38212: LD_VAR 0 1
38216: PPUSH
38217: LD_INT 4
38219: PPUSH
38220: EMPTY
38221: PPUSH
38222: CALL 11629 0 3
38226: AND
38227: IFFALSE 38275
// for j in MCF_Class ( side , 4 , [ ] ) do
38229: LD_ADDR_VAR 0 5
38233: PUSH
38234: LD_VAR 0 1
38238: PPUSH
38239: LD_INT 4
38241: PPUSH
38242: EMPTY
38243: PPUSH
38244: CALL 11629 0 3
38248: PUSH
38249: FOR_IN
38250: IFFALSE 38273
// MCN_Tame ( GetSide ( j ) , j ) ;
38252: LD_VAR 0 5
38256: PPUSH
38257: CALL_OW 255
38261: PPUSH
38262: LD_VAR 0 5
38266: PPUSH
38267: CALL 18448 0 2
38271: GO 38249
38273: POP
38274: POP
// if MREG_DefVeh [ side ] then
38275: LD_EXP 67
38279: PUSH
38280: LD_VAR 0 1
38284: ARRAY
38285: IFFALSE 38449
// begin for i in MREG_DefVeh [ side ] do
38287: LD_ADDR_VAR 0 4
38291: PUSH
38292: LD_EXP 67
38296: PUSH
38297: LD_VAR 0 1
38301: ARRAY
38302: PUSH
38303: FOR_IN
38304: IFFALSE 38357
// begin SetTag ( i , 0 ) ;
38306: LD_VAR 0 4
38310: PPUSH
38311: LD_INT 0
38313: PPUSH
38314: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38318: LD_VAR 0 4
38322: PPUSH
38323: LD_EXP 64
38327: PUSH
38328: LD_VAR 0 1
38332: ARRAY
38333: PPUSH
38334: CALL_OW 308
38338: NOT
38339: IFFALSE 38355
// MCV_Parking ( side , i ) ;
38341: LD_VAR 0 1
38345: PPUSH
38346: LD_VAR 0 4
38350: PPUSH
38351: CALL 25636 0 2
// end ;
38355: GO 38303
38357: POP
38358: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38359: LD_VAR 0 1
38363: PPUSH
38364: LD_INT 36
38366: PPUSH
38367: EMPTY
38368: PPUSH
38369: CALL 12249 0 3
38373: IFFALSE 38414
// for i in MCF_Tag ( side , 36 , [ ] ) do
38375: LD_ADDR_VAR 0 4
38379: PUSH
38380: LD_VAR 0 1
38384: PPUSH
38385: LD_INT 36
38387: PPUSH
38388: EMPTY
38389: PPUSH
38390: CALL 12249 0 3
38394: PUSH
38395: FOR_IN
38396: IFFALSE 38412
// SetTag ( i , 0 ) ;
38398: LD_VAR 0 4
38402: PPUSH
38403: LD_INT 0
38405: PPUSH
38406: CALL_OW 109
38410: GO 38395
38412: POP
38413: POP
// if MREG_DefMobActive [ side ] then
38414: LD_EXP 70
38418: PUSH
38419: LD_VAR 0 1
38423: ARRAY
38424: IFFALSE 38449
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38426: LD_ADDR_EXP 70
38430: PUSH
38431: LD_EXP 70
38435: PPUSH
38436: LD_VAR 0 1
38440: PPUSH
38441: LD_INT 0
38443: PPUSH
38444: CALL_OW 1
38448: ST_TO_ADDR
// end ; end ; if mode > 0 then
38449: LD_VAR 0 2
38453: PUSH
38454: LD_INT 0
38456: GREATER
38457: IFFALSE 40352
// begin if tick <= 15 15$00 then
38459: LD_OWVAR 1
38463: PUSH
38464: LD_INT 31500
38466: LESSEQUAL
38467: IFFALSE 38771
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38469: LD_VAR 0 13
38473: PUSH
38474: LD_VAR 0 1
38478: PPUSH
38479: CALL 24901 0 1
38483: PUSH
38484: LD_INT 4
38486: LESS
38487: AND
38488: IFFALSE 38599
// begin for i in sol do
38490: LD_ADDR_VAR 0 4
38494: PUSH
38495: LD_VAR 0 13
38499: PUSH
38500: FOR_IN
38501: IFFALSE 38597
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38503: LD_ADDR_VAR 0 8
38507: PUSH
38508: LD_VAR 0 1
38512: PPUSH
38513: CALL 24901 0 1
38517: PPUSH
38518: LD_VAR 0 4
38522: PPUSH
38523: CALL_OW 74
38527: ST_TO_ADDR
// if IsInUnit ( i ) then
38528: LD_VAR 0 4
38532: PPUSH
38533: CALL_OW 310
38537: IFFALSE 38548
// ComExitBuilding ( i ) ;
38539: LD_VAR 0 4
38543: PPUSH
38544: CALL_OW 122
// if not HasTask ( i ) and k then
38548: LD_VAR 0 4
38552: PPUSH
38553: CALL_OW 314
38557: NOT
38558: PUSH
38559: LD_VAR 0 8
38563: AND
38564: IFFALSE 38595
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38566: LD_VAR 0 4
38570: PPUSH
38571: LD_VAR 0 8
38575: PPUSH
38576: CALL_OW 250
38580: PPUSH
38581: LD_VAR 0 8
38585: PPUSH
38586: CALL_OW 251
38590: PPUSH
38591: CALL_OW 174
// end ;
38595: GO 38500
38597: POP
38598: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38599: LD_VAR 0 1
38603: PPUSH
38604: LD_INT 30
38606: PUSH
38607: LD_INT 5
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PPUSH
38614: CALL 11546 0 2
38618: IFFALSE 38769
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38620: LD_ADDR_VAR 0 11
38624: PUSH
38625: LD_VAR 0 1
38629: PPUSH
38630: LD_INT 30
38632: PUSH
38633: LD_INT 5
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PPUSH
38640: CALL 11546 0 2
38644: PUSH
38645: LD_INT 1
38647: ARRAY
38648: ST_TO_ADDR
// if mech then
38649: LD_VAR 0 15
38653: IFFALSE 38689
// for i in mech do
38655: LD_ADDR_VAR 0 4
38659: PUSH
38660: LD_VAR 0 15
38664: PUSH
38665: FOR_IN
38666: IFFALSE 38687
// MCH_ChangeClass ( side , i , 1 ) ;
38668: LD_VAR 0 1
38672: PPUSH
38673: LD_VAR 0 4
38677: PPUSH
38678: LD_INT 1
38680: PPUSH
38681: CALL 16453 0 3
38685: GO 38665
38687: POP
38688: POP
// if eng > 1 then
38689: LD_VAR 0 14
38693: PUSH
38694: LD_INT 1
38696: GREATER
38697: IFFALSE 38744
// for i = eng downto 2 do
38699: LD_ADDR_VAR 0 4
38703: PUSH
38704: DOUBLE
38705: LD_VAR 0 14
38709: INC
38710: ST_TO_ADDR
38711: LD_INT 2
38713: PUSH
38714: FOR_DOWNTO
38715: IFFALSE 38742
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38717: LD_VAR 0 1
38721: PPUSH
38722: LD_VAR 0 14
38726: PUSH
38727: LD_VAR 0 4
38731: ARRAY
38732: PPUSH
38733: LD_INT 1
38735: PPUSH
38736: CALL 16453 0 3
38740: GO 38714
38742: POP
38743: POP
// if UnitsInside ( b ) then
38744: LD_VAR 0 11
38748: PPUSH
38749: CALL_OW 313
38753: IFFALSE 38769
// ComExitBuilding ( UnitsInside ( b ) ) ;
38755: LD_VAR 0 11
38759: PPUSH
38760: CALL_OW 313
38764: PPUSH
38765: CALL_OW 122
// end ; end else
38769: GO 40352
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38771: LD_VAR 0 1
38775: PPUSH
38776: LD_INT 1
38778: PPUSH
38779: LD_EXP 65
38783: PUSH
38784: LD_VAR 0 1
38788: ARRAY
38789: PUSH
38790: LD_INT 1
38792: ARRAY
38793: PPUSH
38794: CALL 33624 0 3
38798: IFFALSE 38937
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38800: LD_ADDR_VAR 0 12
38804: PUSH
38805: LD_VAR 0 1
38809: PPUSH
38810: LD_INT 21
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PPUSH
38820: CALL 11546 0 2
38824: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38825: LD_ADDR_VAR 0 11
38829: PUSH
38830: LD_VAR 0 1
38834: PPUSH
38835: LD_INT 30
38837: PUSH
38838: LD_INT 1
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PPUSH
38845: CALL 11546 0 2
38849: ST_TO_ADDR
// if b then
38850: LD_VAR 0 11
38854: IFFALSE 38937
// for i in tmp do
38856: LD_ADDR_VAR 0 4
38860: PUSH
38861: LD_VAR 0 12
38865: PUSH
38866: FOR_IN
38867: IFFALSE 38935
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38869: LD_VAR 0 4
38873: PPUSH
38874: LD_EXP 65
38878: PUSH
38879: LD_VAR 0 1
38883: ARRAY
38884: PUSH
38885: LD_INT 1
38887: ARRAY
38888: PPUSH
38889: CALL_OW 308
38893: NOT
38894: IFFALSE 38933
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
38896: LD_VAR 0 4
38900: PPUSH
38901: LD_VAR 0 11
38905: PUSH
38906: LD_INT 1
38908: ARRAY
38909: PPUSH
38910: CALL_OW 250
38914: PPUSH
38915: LD_VAR 0 11
38919: PUSH
38920: LD_INT 1
38922: ARRAY
38923: PPUSH
38924: CALL_OW 251
38928: PPUSH
38929: CALL_OW 111
38933: GO 38866
38935: POP
38936: POP
// end ; if MREG_DefVeh [ side ] then
38937: LD_EXP 67
38941: PUSH
38942: LD_VAR 0 1
38946: ARRAY
38947: IFFALSE 39515
// begin tmp := [ ] ;
38949: LD_ADDR_VAR 0 12
38953: PUSH
38954: EMPTY
38955: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
38956: LD_EXP 70
38960: PUSH
38961: LD_VAR 0 1
38965: ARRAY
38966: PUSH
38967: LD_INT 0
38969: EQUAL
38970: IFFALSE 39110
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
38972: LD_ADDR_VAR 0 8
38976: PUSH
38977: LD_VAR 0 1
38981: PPUSH
38982: LD_INT 0
38984: PPUSH
38985: LD_INT 25
38987: PUSH
38988: LD_INT 3
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PPUSH
38995: CALL 12249 0 3
38999: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39000: LD_VAR 0 8
39004: PUSH
39005: LD_EXP 67
39009: PUSH
39010: LD_VAR 0 1
39014: ARRAY
39015: GREATER
39016: IFFALSE 39077
// begin for i = 1 to MREG_DefVeh [ side ] do
39018: LD_ADDR_VAR 0 4
39022: PUSH
39023: DOUBLE
39024: LD_INT 1
39026: DEC
39027: ST_TO_ADDR
39028: LD_EXP 67
39032: PUSH
39033: LD_VAR 0 1
39037: ARRAY
39038: PUSH
39039: FOR_TO
39040: IFFALSE 39073
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39042: LD_ADDR_VAR 0 12
39046: PUSH
39047: LD_VAR 0 12
39051: PPUSH
39052: LD_INT 1
39054: PPUSH
39055: LD_VAR 0 8
39059: PUSH
39060: LD_VAR 0 4
39064: ARRAY
39065: PPUSH
39066: CALL_OW 2
39070: ST_TO_ADDR
39071: GO 39039
39073: POP
39074: POP
// end else
39075: GO 39087
// tmp := k ;
39077: LD_ADDR_VAR 0 12
39081: PUSH
39082: LD_VAR 0 8
39086: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39087: LD_ADDR_EXP 70
39091: PUSH
39092: LD_EXP 70
39096: PPUSH
39097: LD_VAR 0 1
39101: PPUSH
39102: LD_INT 1
39104: PPUSH
39105: CALL_OW 1
39109: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39110: LD_ADDR_VAR 0 4
39114: PUSH
39115: LD_EXP 67
39119: PUSH
39120: LD_VAR 0 1
39124: ARRAY
39125: PUSH
39126: FOR_IN
39127: IFFALSE 39513
// begin if not GetDriver ( i ) then
39129: LD_VAR 0 4
39133: PPUSH
39134: CALL 31654 0 1
39138: NOT
39139: IFFALSE 39214
// begin if tmp then
39141: LD_VAR 0 12
39145: IFFALSE 39212
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39147: LD_VAR 0 12
39151: PUSH
39152: LD_INT 1
39154: ARRAY
39155: PPUSH
39156: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39160: LD_VAR 0 12
39164: PUSH
39165: LD_INT 1
39167: ARRAY
39168: PPUSH
39169: LD_VAR 0 4
39173: PPUSH
39174: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39178: LD_VAR 0 12
39182: PUSH
39183: LD_INT 1
39185: ARRAY
39186: PPUSH
39187: LD_INT 36
39189: PPUSH
39190: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39194: LD_ADDR_VAR 0 12
39198: PUSH
39199: LD_VAR 0 12
39203: PPUSH
39204: LD_INT 1
39206: PPUSH
39207: CALL_OW 3
39211: ST_TO_ADDR
// end ; end else
39212: GO 39511
// begin if GetTag ( i ) = 0 then
39214: LD_VAR 0 4
39218: PPUSH
39219: CALL_OW 110
39223: PUSH
39224: LD_INT 0
39226: EQUAL
39227: IFFALSE 39243
// SetTag ( i , 31 ) else
39229: LD_VAR 0 4
39233: PPUSH
39234: LD_INT 31
39236: PPUSH
39237: CALL_OW 109
39241: GO 39511
// if GetTag ( i ) = 31 then
39243: LD_VAR 0 4
39247: PPUSH
39248: CALL_OW 110
39252: PUSH
39253: LD_INT 31
39255: EQUAL
39256: IFFALSE 39511
// begin if GetFuel ( i ) < 20 then
39258: LD_VAR 0 4
39262: PPUSH
39263: CALL_OW 261
39267: PUSH
39268: LD_INT 20
39270: LESS
39271: IFFALSE 39296
// begin SetTag ( i , 21 ) ;
39273: LD_VAR 0 4
39277: PPUSH
39278: LD_INT 21
39280: PPUSH
39281: CALL_OW 109
// MCV_Refuel ( i ) ;
39285: LD_VAR 0 4
39289: PPUSH
39290: CALL 26173 0 1
// continue ;
39294: GO 39126
// end ; if GetLives ( i ) < 700 then
39296: LD_VAR 0 4
39300: PPUSH
39301: CALL_OW 256
39305: PUSH
39306: LD_INT 700
39308: LESS
39309: IFFALSE 39421
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39311: LD_VAR 0 4
39315: PPUSH
39316: LD_EXP 58
39320: PUSH
39321: LD_VAR 0 1
39325: ARRAY
39326: PPUSH
39327: CALL_OW 308
39331: NOT
39332: IFFALSE 39356
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39334: LD_VAR 0 4
39338: PPUSH
39339: LD_EXP 58
39343: PUSH
39344: LD_VAR 0 1
39348: ARRAY
39349: PPUSH
39350: CALL_OW 113
39354: GO 39419
// if GetDriver ( i ) then
39356: LD_VAR 0 4
39360: PPUSH
39361: CALL 31654 0 1
39365: IFFALSE 39419
// begin k := GetDriver ( i ) ;
39367: LD_ADDR_VAR 0 8
39371: PUSH
39372: LD_VAR 0 4
39376: PPUSH
39377: CALL 31654 0 1
39381: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39382: LD_VAR 0 8
39386: PPUSH
39387: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39391: LD_VAR 0 8
39395: PPUSH
39396: LD_VAR 0 4
39400: PPUSH
39401: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39405: LD_VAR 0 8
39409: PPUSH
39410: LD_VAR 0 4
39414: PPUSH
39415: CALL_OW 180
// end ; end else
39419: GO 39511
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39421: LD_ADDR_VAR 0 8
39425: PUSH
39426: LD_VAR 0 1
39430: PPUSH
39431: CALL 24901 0 1
39435: PPUSH
39436: LD_VAR 0 4
39440: PPUSH
39441: CALL_OW 74
39445: ST_TO_ADDR
// if k then
39446: LD_VAR 0 8
39450: IFFALSE 39468
// ComAttackUnit ( i , k ) else
39452: LD_VAR 0 4
39456: PPUSH
39457: LD_VAR 0 8
39461: PPUSH
39462: CALL_OW 115
39466: GO 39511
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39468: LD_VAR 0 4
39472: PPUSH
39473: LD_EXP 58
39477: PUSH
39478: LD_VAR 0 1
39482: ARRAY
39483: PPUSH
39484: CALL_OW 308
39488: NOT
39489: IFFALSE 39511
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39491: LD_VAR 0 4
39495: PPUSH
39496: LD_EXP 58
39500: PUSH
39501: LD_VAR 0 1
39505: ARRAY
39506: PPUSH
39507: CALL_OW 113
// end ; end ; end ; end ;
39511: GO 39126
39513: POP
39514: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39515: LD_VAR 0 1
39519: PPUSH
39520: LD_INT 30
39522: PUSH
39523: LD_INT 5
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PPUSH
39530: CALL 11546 0 2
39534: IFFALSE 40352
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39536: LD_ADDR_VAR 0 11
39540: PUSH
39541: LD_VAR 0 1
39545: PPUSH
39546: LD_INT 30
39548: PUSH
39549: LD_INT 5
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PPUSH
39556: CALL 11546 0 2
39560: PUSH
39561: LD_INT 1
39563: ARRAY
39564: ST_TO_ADDR
// if eng > 1 then
39565: LD_VAR 0 14
39569: PUSH
39570: LD_INT 1
39572: GREATER
39573: IFFALSE 39620
// for i = eng downto 2 do
39575: LD_ADDR_VAR 0 4
39579: PUSH
39580: DOUBLE
39581: LD_VAR 0 14
39585: INC
39586: ST_TO_ADDR
39587: LD_INT 2
39589: PUSH
39590: FOR_DOWNTO
39591: IFFALSE 39618
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39593: LD_VAR 0 1
39597: PPUSH
39598: LD_VAR 0 14
39602: PUSH
39603: LD_VAR 0 4
39607: ARRAY
39608: PPUSH
39609: LD_INT 1
39611: PPUSH
39612: CALL 16453 0 3
39616: GO 39590
39618: POP
39619: POP
// if sci > 1 then
39620: LD_VAR 0 16
39624: PUSH
39625: LD_INT 1
39627: GREATER
39628: IFFALSE 39675
// for i = sci downto 2 do
39630: LD_ADDR_VAR 0 4
39634: PUSH
39635: DOUBLE
39636: LD_VAR 0 16
39640: INC
39641: ST_TO_ADDR
39642: LD_INT 2
39644: PUSH
39645: FOR_DOWNTO
39646: IFFALSE 39673
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39648: LD_VAR 0 1
39652: PPUSH
39653: LD_VAR 0 16
39657: PUSH
39658: LD_VAR 0 4
39662: ARRAY
39663: PPUSH
39664: LD_INT 1
39666: PPUSH
39667: CALL 16453 0 3
39671: GO 39645
39673: POP
39674: POP
// if sol then
39675: LD_VAR 0 13
39679: IFFALSE 40352
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39681: LD_VAR 0 13
39685: PUSH
39686: LD_EXP 68
39690: PUSH
39691: LD_VAR 0 1
39695: ARRAY
39696: DIFF
39697: PUSH
39698: LD_INT 22
39700: PUSH
39701: LD_VAR 0 1
39705: PUSH
39706: EMPTY
39707: LIST
39708: LIST
39709: PUSH
39710: LD_INT 58
39712: PUSH
39713: EMPTY
39714: LIST
39715: PUSH
39716: LD_INT 2
39718: PUSH
39719: LD_INT 30
39721: PUSH
39722: LD_INT 32
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 30
39731: PUSH
39732: LD_INT 31
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: LIST
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: LIST
39748: PPUSH
39749: CALL_OW 69
39753: PUSH
39754: LD_INT 0
39756: EQUAL
39757: AND
39758: IFFALSE 40352
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39760: LD_ADDR_VAR 0 12
39764: PUSH
39765: LD_VAR 0 13
39769: PUSH
39770: LD_EXP 68
39774: PUSH
39775: LD_VAR 0 1
39779: ARRAY
39780: DIFF
39781: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39782: LD_VAR 0 1
39786: PPUSH
39787: LD_INT 30
39789: PUSH
39790: LD_INT 5
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PPUSH
39797: CALL 11546 0 2
39801: PUSH
39802: LD_INT 1
39804: GREATER
39805: IFFALSE 39836
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39807: LD_ADDR_VAR 0 8
39811: PUSH
39812: LD_VAR 0 1
39816: PPUSH
39817: LD_INT 30
39819: PUSH
39820: LD_INT 5
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PPUSH
39827: CALL 11546 0 2
39831: PUSH
39832: LD_INT 2
39834: ARRAY
39835: ST_TO_ADDR
// for j in tmp do
39836: LD_ADDR_VAR 0 5
39840: PUSH
39841: LD_VAR 0 12
39845: PUSH
39846: FOR_IN
39847: IFFALSE 40350
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39849: LD_VAR 0 5
39853: PUSH
39854: LD_VAR 0 11
39858: PPUSH
39859: CALL_OW 313
39863: IN
39864: PUSH
39865: LD_VAR 0 11
39869: PPUSH
39870: CALL_OW 313
39874: PUSH
39875: LD_INT 6
39877: EQUAL
39878: AND
39879: PUSH
39880: LD_VAR 0 8
39884: AND
39885: PUSH
39886: LD_VAR 0 8
39890: PPUSH
39891: CALL_OW 313
39895: PUSH
39896: LD_INT 6
39898: LESS
39899: AND
39900: IFFALSE 39927
// begin ComExitBuilding ( j ) ;
39902: LD_VAR 0 5
39906: PPUSH
39907: CALL_OW 122
// AddComEnterunit ( j , k ) ;
39911: LD_VAR 0 5
39915: PPUSH
39916: LD_VAR 0 8
39920: PPUSH
39921: CALL_OW 180
// continue ;
39925: GO 39846
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
39927: LD_VAR 0 5
39931: PPUSH
39932: CALL_OW 314
39936: NOT
39937: PUSH
39938: LD_VAR 0 5
39942: PPUSH
39943: CALL_OW 110
39947: PUSH
39948: LD_INT 0
39950: EQUAL
39951: AND
39952: PUSH
39953: LD_VAR 0 5
39957: PPUSH
39958: CALL_OW 310
39962: NOT
39963: AND
39964: IFFALSE 40070
// begin if k then
39966: LD_VAR 0 8
39970: IFFALSE 40041
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
39972: LD_VAR 0 8
39976: PPUSH
39977: CALL_OW 313
39981: PUSH
39982: LD_VAR 0 11
39986: PPUSH
39987: CALL_OW 313
39991: LESS
39992: IFFALSE 40010
// ComEnterUnit ( j , k ) else
39994: LD_VAR 0 5
39998: PPUSH
39999: LD_VAR 0 8
40003: PPUSH
40004: CALL_OW 120
40008: GO 40039
// if UnitsInside ( b ) < 6 then
40010: LD_VAR 0 11
40014: PPUSH
40015: CALL_OW 313
40019: PUSH
40020: LD_INT 6
40022: LESS
40023: IFFALSE 40039
// ComEnterUnit ( j , b ) ;
40025: LD_VAR 0 5
40029: PPUSH
40030: LD_VAR 0 11
40034: PPUSH
40035: CALL_OW 120
// end else
40039: GO 40070
// if UnitsInside ( b ) < 6 then
40041: LD_VAR 0 11
40045: PPUSH
40046: CALL_OW 313
40050: PUSH
40051: LD_INT 6
40053: LESS
40054: IFFALSE 40070
// ComEnterUnit ( j , b ) ;
40056: LD_VAR 0 5
40060: PPUSH
40061: LD_VAR 0 11
40065: PPUSH
40066: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40070: LD_VAR 0 5
40074: PUSH
40075: LD_VAR 0 1
40079: PPUSH
40080: LD_INT 54
40082: PUSH
40083: EMPTY
40084: LIST
40085: PPUSH
40086: CALL 11546 0 2
40090: IN
40091: PUSH
40092: LD_VAR 0 5
40096: PPUSH
40097: CALL_OW 257
40101: PUSH
40102: LD_INT 1
40104: EQUAL
40105: AND
40106: IFFALSE 40348
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40108: LD_EXP 62
40112: PUSH
40113: LD_VAR 0 1
40117: ARRAY
40118: PUSH
40119: LD_INT 1
40121: ARRAY
40122: PUSH
40123: LD_INT 12
40125: PPUSH
40126: LD_VAR 0 1
40130: PPUSH
40131: CALL_OW 321
40135: PUSH
40136: LD_INT 2
40138: EQUAL
40139: AND
40140: IFFALSE 40188
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40142: LD_VAR 0 1
40146: PPUSH
40147: LD_INT 5
40149: PPUSH
40150: EMPTY
40151: PPUSH
40152: CALL 11629 0 3
40156: PUSH
40157: LD_EXP 62
40161: PUSH
40162: LD_VAR 0 1
40166: ARRAY
40167: PUSH
40168: LD_INT 1
40170: ARRAY
40171: LESS
40172: IFFALSE 40188
// begin SetClass ( j , class_sniper ) ;
40174: LD_VAR 0 5
40178: PPUSH
40179: LD_INT 5
40181: PPUSH
40182: CALL_OW 336
// continue ;
40186: GO 39846
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40188: LD_EXP 62
40192: PUSH
40193: LD_VAR 0 1
40197: ARRAY
40198: PUSH
40199: LD_INT 2
40201: ARRAY
40202: PUSH
40203: LD_INT 41
40205: PPUSH
40206: LD_VAR 0 1
40210: PPUSH
40211: CALL_OW 321
40215: PUSH
40216: LD_INT 2
40218: EQUAL
40219: AND
40220: IFFALSE 40268
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40222: LD_VAR 0 1
40226: PPUSH
40227: LD_INT 8
40229: PPUSH
40230: EMPTY
40231: PPUSH
40232: CALL 11629 0 3
40236: PUSH
40237: LD_EXP 62
40241: PUSH
40242: LD_VAR 0 1
40246: ARRAY
40247: PUSH
40248: LD_INT 2
40250: ARRAY
40251: LESS
40252: IFFALSE 40268
// begin SetClass ( j , class_mortar ) ;
40254: LD_VAR 0 5
40258: PPUSH
40259: LD_INT 8
40261: PPUSH
40262: CALL_OW 336
// continue ;
40266: GO 39846
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40268: LD_EXP 62
40272: PUSH
40273: LD_VAR 0 1
40277: ARRAY
40278: PUSH
40279: LD_INT 3
40281: ARRAY
40282: PUSH
40283: LD_INT 44
40285: PPUSH
40286: LD_VAR 0 1
40290: PPUSH
40291: CALL_OW 321
40295: PUSH
40296: LD_INT 2
40298: EQUAL
40299: AND
40300: IFFALSE 40348
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40302: LD_VAR 0 1
40306: PPUSH
40307: LD_INT 9
40309: PPUSH
40310: EMPTY
40311: PPUSH
40312: CALL 11629 0 3
40316: PUSH
40317: LD_EXP 62
40321: PUSH
40322: LD_VAR 0 1
40326: ARRAY
40327: PUSH
40328: LD_INT 3
40330: ARRAY
40331: LESS
40332: IFFALSE 40348
// begin SetClass ( j , class_bazooker ) ;
40334: LD_VAR 0 5
40338: PPUSH
40339: LD_INT 9
40341: PPUSH
40342: CALL_OW 336
// continue ;
40346: GO 39846
// end ; end ; end ;
40348: GO 39846
40350: POP
40351: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40352: LD_INT 22
40354: PUSH
40355: LD_VAR 0 1
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 58
40366: PUSH
40367: EMPTY
40368: LIST
40369: PUSH
40370: LD_INT 30
40372: PUSH
40373: LD_INT 32
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: LIST
40384: PPUSH
40385: CALL_OW 69
40389: IFFALSE 40539
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40391: LD_ADDR_VAR 0 12
40395: PUSH
40396: LD_INT 22
40398: PUSH
40399: LD_VAR 0 1
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 58
40410: PUSH
40411: EMPTY
40412: LIST
40413: PUSH
40414: LD_INT 30
40416: PUSH
40417: LD_INT 32
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: LIST
40428: PPUSH
40429: CALL_OW 69
40433: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40434: LD_ADDR_VAR 0 8
40438: PUSH
40439: LD_VAR 0 13
40443: PUSH
40444: LD_EXP 68
40448: PUSH
40449: LD_VAR 0 1
40453: ARRAY
40454: DIFF
40455: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40456: LD_VAR 0 12
40460: PUSH
40461: LD_INT 1
40463: ARRAY
40464: PPUSH
40465: CALL_OW 461
40469: PUSH
40470: LD_INT 2
40472: EQUAL
40473: PUSH
40474: LD_VAR 0 12
40478: PUSH
40479: LD_INT 1
40481: ARRAY
40482: PUSH
40483: LD_EXP 68
40487: PUSH
40488: LD_VAR 0 1
40492: ARRAY
40493: IN
40494: NOT
40495: AND
40496: PUSH
40497: LD_VAR 0 8
40501: AND
40502: IFFALSE 40539
// begin ComExitBuilding ( k [ 1 ] ) ;
40504: LD_VAR 0 8
40508: PUSH
40509: LD_INT 1
40511: ARRAY
40512: PPUSH
40513: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40517: LD_VAR 0 8
40521: PUSH
40522: LD_INT 1
40524: ARRAY
40525: PPUSH
40526: LD_VAR 0 12
40530: PUSH
40531: LD_INT 1
40533: ARRAY
40534: PPUSH
40535: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40539: LD_EXP 35
40543: PUSH
40544: LD_VAR 0 1
40548: ARRAY
40549: IFFALSE 40697
// begin if MCF_Class ( side , 4 , [ ] ) then
40551: LD_VAR 0 1
40555: PPUSH
40556: LD_INT 4
40558: PPUSH
40559: EMPTY
40560: PPUSH
40561: CALL 11629 0 3
40565: IFFALSE 40695
// for j in MCF_Class ( side , 4 , [ ] ) do
40567: LD_ADDR_VAR 0 5
40571: PUSH
40572: LD_VAR 0 1
40576: PPUSH
40577: LD_INT 4
40579: PPUSH
40580: EMPTY
40581: PPUSH
40582: CALL 11629 0 3
40586: PUSH
40587: FOR_IN
40588: IFFALSE 40693
// begin if not GetTag ( j ) = 4 then
40590: LD_VAR 0 5
40594: PPUSH
40595: CALL_OW 110
40599: PUSH
40600: LD_INT 4
40602: EQUAL
40603: NOT
40604: IFFALSE 40640
// begin SetTag ( j , 4 ) ;
40606: LD_VAR 0 5
40610: PPUSH
40611: LD_INT 4
40613: PPUSH
40614: CALL_OW 109
// if IsInUnit ( j ) then
40618: LD_VAR 0 5
40622: PPUSH
40623: CALL_OW 310
40627: IFFALSE 40638
// ComExitBuilding ( j ) ;
40629: LD_VAR 0 5
40633: PPUSH
40634: CALL_OW 122
// end else
40638: GO 40691
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40640: LD_VAR 0 5
40644: PPUSH
40645: LD_EXP 35
40649: PUSH
40650: LD_VAR 0 1
40654: ARRAY
40655: PUSH
40656: LD_INT 1
40658: ARRAY
40659: PPUSH
40660: CALL 94468 0 2
40664: NOT
40665: IFFALSE 40691
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40667: LD_VAR 0 5
40671: PPUSH
40672: LD_EXP 35
40676: PUSH
40677: LD_VAR 0 1
40681: ARRAY
40682: PUSH
40683: LD_INT 1
40685: ARRAY
40686: PPUSH
40687: CALL 19116 0 2
// end ;
40691: GO 40587
40693: POP
40694: POP
// end else
40695: GO 40929
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40697: LD_VAR 0 1
40701: PPUSH
40702: LD_INT 4
40704: PPUSH
40705: EMPTY
40706: PPUSH
40707: CALL 11629 0 3
40711: PUSH
40712: LD_VAR 0 1
40716: PPUSH
40717: LD_INT 4
40719: PPUSH
40720: EMPTY
40721: PPUSH
40722: CALL 12249 0 3
40726: AND
40727: IFFALSE 40929
// for j in MCF_Class ( side , 4 , [ ] ) do
40729: LD_ADDR_VAR 0 5
40733: PUSH
40734: LD_VAR 0 1
40738: PPUSH
40739: LD_INT 4
40741: PPUSH
40742: EMPTY
40743: PPUSH
40744: CALL 11629 0 3
40748: PUSH
40749: FOR_IN
40750: IFFALSE 40927
// begin if GetTag ( j ) = 4 then
40752: LD_VAR 0 5
40756: PPUSH
40757: CALL_OW 110
40761: PUSH
40762: LD_INT 4
40764: EQUAL
40765: IFFALSE 40925
// begin SetTag ( j , 0 ) ;
40767: LD_VAR 0 5
40771: PPUSH
40772: LD_INT 0
40774: PPUSH
40775: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40779: LD_VAR 0 1
40783: PPUSH
40784: CALL 11585 0 1
40788: PUSH
40789: LD_VAR 0 1
40793: PPUSH
40794: CALL 17929 0 1
40798: NOT
40799: AND
40800: IFFALSE 40825
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40802: LD_VAR 0 5
40806: PPUSH
40807: LD_VAR 0 1
40811: PPUSH
40812: CALL 11585 0 1
40816: PUSH
40817: LD_INT 1
40819: ARRAY
40820: PPUSH
40821: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40825: LD_VAR 0 1
40829: PPUSH
40830: CALL 11585 0 1
40834: NOT
40835: PUSH
40836: LD_VAR 0 1
40840: PPUSH
40841: LD_INT 30
40843: PUSH
40844: LD_INT 1
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PPUSH
40851: CALL 11546 0 2
40855: AND
40856: IFFALSE 40925
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40858: LD_VAR 0 5
40862: PPUSH
40863: LD_VAR 0 1
40867: PPUSH
40868: LD_INT 30
40870: PUSH
40871: LD_INT 1
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PPUSH
40878: CALL 11546 0 2
40882: PUSH
40883: LD_INT 1
40885: ARRAY
40886: PPUSH
40887: CALL_OW 250
40891: PPUSH
40892: LD_VAR 0 1
40896: PPUSH
40897: LD_INT 30
40899: PUSH
40900: LD_INT 1
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PPUSH
40907: CALL 11546 0 2
40911: PUSH
40912: LD_INT 1
40914: ARRAY
40915: PPUSH
40916: CALL_OW 251
40920: PPUSH
40921: CALL_OW 111
// end ; end ;
40925: GO 40749
40927: POP
40928: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
40929: LD_VAR 0 1
40933: PPUSH
40934: LD_INT 3
40936: PPUSH
40937: EMPTY
40938: PPUSH
40939: CALL 11629 0 3
40943: PUSH
40944: LD_EXP 58
40948: PUSH
40949: LD_VAR 0 1
40953: ARRAY
40954: AND
40955: PUSH
40956: LD_VAR 0 1
40960: PPUSH
40961: LD_INT 6
40963: PPUSH
40964: EMPTY
40965: PPUSH
40966: CALL 12249 0 3
40970: AND
40971: IFFALSE 41502
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
40973: LD_ADDR_VAR 0 6
40977: PUSH
40978: LD_EXP 58
40982: PUSH
40983: LD_VAR 0 1
40987: ARRAY
40988: PPUSH
40989: LD_INT 0
40991: PPUSH
40992: CALL_OW 517
40996: PUSH
40997: LD_INT 1
40999: ARRAY
41000: PUSH
41001: LD_INT 1
41003: ARRAY
41004: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41005: LD_ADDR_VAR 0 7
41009: PUSH
41010: LD_EXP 58
41014: PUSH
41015: LD_VAR 0 1
41019: ARRAY
41020: PPUSH
41021: LD_INT 0
41023: PPUSH
41024: CALL_OW 517
41028: PUSH
41029: LD_INT 2
41031: ARRAY
41032: PUSH
41033: LD_INT 1
41035: ARRAY
41036: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41037: LD_VAR 0 1
41041: PPUSH
41042: LD_INT 6
41044: PPUSH
41045: EMPTY
41046: PPUSH
41047: CALL 12249 0 3
41051: IFFALSE 41500
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41053: LD_ADDR_VAR 0 8
41057: PUSH
41058: LD_VAR 0 1
41062: PPUSH
41063: LD_INT 6
41065: PPUSH
41066: EMPTY
41067: PPUSH
41068: CALL 12249 0 3
41072: PUSH
41073: FOR_IN
41074: IFFALSE 41105
// if GetLives ( k ) = 1000 then
41076: LD_VAR 0 8
41080: PPUSH
41081: CALL_OW 256
41085: PUSH
41086: LD_INT 1000
41088: EQUAL
41089: IFFALSE 41103
// SetTag ( k , 0 ) ;
41091: LD_VAR 0 8
41095: PPUSH
41096: LD_INT 0
41098: PPUSH
41099: CALL_OW 109
41103: GO 41073
41105: POP
41106: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41107: LD_VAR 0 1
41111: PPUSH
41112: LD_INT 0
41114: PPUSH
41115: LD_INT 25
41117: PUSH
41118: LD_INT 3
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PPUSH
41125: CALL 12249 0 3
41129: IFFALSE 41193
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41131: LD_ADDR_VAR 0 8
41135: PUSH
41136: LD_VAR 0 4
41140: PPUSH
41141: LD_INT 0
41143: PPUSH
41144: LD_INT 25
41146: PUSH
41147: LD_INT 3
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PPUSH
41154: CALL 12249 0 3
41158: PUSH
41159: FOR_IN
41160: IFFALSE 41191
// if GetTag ( k ) = 0 then
41162: LD_VAR 0 8
41166: PPUSH
41167: CALL_OW 110
41171: PUSH
41172: LD_INT 0
41174: EQUAL
41175: IFFALSE 41189
// begin SetTag ( k , 8 ) ;
41177: LD_VAR 0 8
41181: PPUSH
41182: LD_INT 8
41184: PPUSH
41185: CALL_OW 109
// end ;
41189: GO 41159
41191: POP
41192: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41193: LD_VAR 0 1
41197: PPUSH
41198: LD_INT 6
41200: PPUSH
41201: LD_INT 92
41203: PUSH
41204: LD_VAR 0 6
41208: PUSH
41209: LD_VAR 0 7
41213: PUSH
41214: LD_INT 10
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: PPUSH
41223: CALL 12249 0 3
41227: IFFALSE 41351
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41229: LD_ADDR_VAR 0 5
41233: PUSH
41234: LD_VAR 0 4
41238: PPUSH
41239: LD_INT 6
41241: PPUSH
41242: LD_INT 92
41244: PUSH
41245: LD_VAR 0 6
41249: PUSH
41250: LD_VAR 0 7
41254: PUSH
41255: LD_INT 10
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: PPUSH
41264: CALL 12249 0 3
41268: PUSH
41269: FOR_IN
41270: IFFALSE 41349
// begin if not HasTask ( j ) and GetDriver ( j ) then
41272: LD_VAR 0 5
41276: PPUSH
41277: CALL_OW 314
41281: NOT
41282: PUSH
41283: LD_VAR 0 5
41287: PPUSH
41288: CALL 31654 0 1
41292: AND
41293: IFFALSE 41347
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41295: LD_VAR 0 5
41299: PPUSH
41300: CALL 31654 0 1
41304: PPUSH
41305: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41309: LD_VAR 0 5
41313: PPUSH
41314: CALL 31654 0 1
41318: PPUSH
41319: LD_VAR 0 5
41323: PPUSH
41324: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41328: LD_VAR 0 5
41332: PPUSH
41333: CALL 31654 0 1
41337: PPUSH
41338: LD_VAR 0 5
41342: PPUSH
41343: CALL_OW 180
// end ; end ;
41347: GO 41269
41349: POP
41350: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41351: LD_VAR 0 1
41355: PPUSH
41356: LD_INT 6
41358: PPUSH
41359: LD_INT 92
41361: PUSH
41362: LD_VAR 0 6
41366: PUSH
41367: LD_VAR 0 7
41371: PUSH
41372: LD_INT 10
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: LIST
41379: LIST
41380: PPUSH
41381: CALL 12249 0 3
41385: PUSH
41386: LD_VAR 0 1
41390: PPUSH
41391: LD_INT 8
41393: PPUSH
41394: EMPTY
41395: PPUSH
41396: CALL 12249 0 3
41400: AND
41401: IFFALSE 41500
// for j in MCF_Tag ( side , 8 , [ ] ) do
41403: LD_ADDR_VAR 0 5
41407: PUSH
41408: LD_VAR 0 1
41412: PPUSH
41413: LD_INT 8
41415: PPUSH
41416: EMPTY
41417: PPUSH
41418: CALL 12249 0 3
41422: PUSH
41423: FOR_IN
41424: IFFALSE 41498
// begin if IsInUnit ( j ) then
41426: LD_VAR 0 5
41430: PPUSH
41431: CALL_OW 310
41435: IFFALSE 41448
// ComExitBuilding ( j ) else
41437: LD_VAR 0 5
41441: PPUSH
41442: CALL_OW 122
41446: GO 41496
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41448: LD_VAR 0 5
41452: PPUSH
41453: LD_VAR 0 1
41457: PPUSH
41458: LD_INT 6
41460: PPUSH
41461: LD_INT 92
41463: PUSH
41464: LD_VAR 0 6
41468: PUSH
41469: LD_VAR 0 7
41473: PUSH
41474: LD_INT 10
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: LIST
41481: LIST
41482: PPUSH
41483: CALL 12249 0 3
41487: PUSH
41488: LD_INT 1
41490: ARRAY
41491: PPUSH
41492: CALL_OW 129
// end ;
41496: GO 41423
41498: POP
41499: POP
// end ; end else
41500: GO 41557
// if MCF_Tag ( side , 8 , [ ] ) then
41502: LD_VAR 0 1
41506: PPUSH
41507: LD_INT 8
41509: PPUSH
41510: EMPTY
41511: PPUSH
41512: CALL 12249 0 3
41516: IFFALSE 41557
// for k in MCF_Tag ( side , 8 , [ ] ) do
41518: LD_ADDR_VAR 0 8
41522: PUSH
41523: LD_VAR 0 1
41527: PPUSH
41528: LD_INT 8
41530: PPUSH
41531: EMPTY
41532: PPUSH
41533: CALL 12249 0 3
41537: PUSH
41538: FOR_IN
41539: IFFALSE 41555
// SetTag ( k , 0 ) ;
41541: LD_VAR 0 8
41545: PPUSH
41546: LD_INT 0
41548: PPUSH
41549: CALL_OW 109
41553: GO 41538
41555: POP
41556: POP
// end ; end_of_file
41557: LD_VAR 0 3
41561: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41562: LD_INT 0
41564: PPUSH
// MREG_Game := [ ] ;
41565: LD_ADDR_EXP 33
41569: PUSH
41570: EMPTY
41571: ST_TO_ADDR
// MREG_Crates := [ ] ;
41572: LD_ADDR_EXP 34
41576: PUSH
41577: EMPTY
41578: ST_TO_ADDR
// MREG_Heal := [ ] ;
41579: LD_ADDR_EXP 35
41583: PUSH
41584: EMPTY
41585: ST_TO_ADDR
// MREG_Tame := [ ] ;
41586: LD_ADDR_EXP 37
41590: PUSH
41591: EMPTY
41592: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41593: LD_ADDR_EXP 38
41597: PUSH
41598: EMPTY
41599: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41600: LD_ADDR_EXP 39
41604: PUSH
41605: EMPTY
41606: ST_TO_ADDR
// MREG_LabList := [ ] ;
41607: LD_ADDR_EXP 40
41611: PUSH
41612: EMPTY
41613: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41614: LD_ADDR_EXP 41
41618: PUSH
41619: EMPTY
41620: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41621: LD_ADDR_EXP 42
41625: PUSH
41626: EMPTY
41627: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41628: LD_ADDR_EXP 43
41632: PUSH
41633: EMPTY
41634: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41635: LD_ADDR_EXP 44
41639: PUSH
41640: EMPTY
41641: ST_TO_ADDR
// MREG_Status := [ ] ;
41642: LD_ADDR_EXP 45
41646: PUSH
41647: EMPTY
41648: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41649: LD_ADDR_EXP 46
41653: PUSH
41654: EMPTY
41655: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41656: LD_ADDR_EXP 47
41660: PUSH
41661: EMPTY
41662: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41663: LD_ADDR_EXP 48
41667: PUSH
41668: EMPTY
41669: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41670: LD_ADDR_EXP 49
41674: PUSH
41675: EMPTY
41676: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41677: LD_ADDR_EXP 50
41681: PUSH
41682: EMPTY
41683: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41684: LD_ADDR_EXP 51
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41691: LD_ADDR_EXP 52
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41698: LD_ADDR_EXP 53
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41705: LD_ADDR_EXP 54
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41712: LD_ADDR_EXP 55
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41719: LD_ADDR_EXP 56
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41726: LD_ADDR_EXP 57
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41733: LD_ADDR_EXP 61
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41740: LD_ADDR_EXP 62
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_Parking := [ ] ;
41747: LD_ADDR_EXP 58
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41754: LD_ADDR_EXP 59
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41761: LD_ADDR_EXP 63
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41768: LD_ADDR_EXP 64
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41775: LD_ADDR_EXP 65
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41782: LD_ADDR_EXP 67
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41789: LD_ADDR_EXP 68
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41796: LD_ADDR_EXP 69
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41803: LD_ADDR_EXP 71
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41810: LD_ADDR_EXP 70
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41817: LD_ADDR_EXP 72
41821: PUSH
41822: LD_INT 300
41824: PUSH
41825: LD_INT 100
41827: PUSH
41828: LD_INT 25
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: LIST
41835: ST_TO_ADDR
// end ;
41836: LD_VAR 0 1
41840: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41841: LD_INT 0
41843: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41844: LD_VAR 0 2
41848: PUSH
41849: LD_VAR 0 3
41853: PUSH
41854: LD_VAR 0 4
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: LIST
41863: PUSH
41864: LD_VAR 0 1
41868: IN
41869: IFFALSE 41883
// result := mreg_list else
41871: LD_ADDR_VAR 0 5
41875: PUSH
41876: LD_VAR 0 1
41880: ST_TO_ADDR
41881: GO 41917
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
41883: LD_ADDR_VAR 0 1
41887: PUSH
41888: LD_VAR 0 1
41892: PUSH
41893: LD_VAR 0 2
41897: PUSH
41898: LD_VAR 0 3
41902: PUSH
41903: LD_VAR 0 4
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: LIST
41912: PUSH
41913: EMPTY
41914: LIST
41915: ADD
41916: ST_TO_ADDR
// result := mreg_list ;
41917: LD_ADDR_VAR 0 5
41921: PUSH
41922: LD_VAR 0 1
41926: ST_TO_ADDR
// end ;
41927: LD_VAR 0 5
41931: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
41932: LD_INT 0
41934: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41935: LD_VAR 0 2
41939: PUSH
41940: LD_VAR 0 3
41944: PUSH
41945: LD_VAR 0 4
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: PUSH
41955: LD_VAR 0 1
41959: IN
41960: IFFALSE 41998
// result := mreg_list diff [ [ side , unit , mreg ] ] else
41962: LD_ADDR_VAR 0 5
41966: PUSH
41967: LD_VAR 0 1
41971: PUSH
41972: LD_VAR 0 2
41976: PUSH
41977: LD_VAR 0 3
41981: PUSH
41982: LD_VAR 0 4
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: LIST
41991: PUSH
41992: EMPTY
41993: LIST
41994: DIFF
41995: ST_TO_ADDR
41996: GO 42008
// result := mreg_list ;
41998: LD_ADDR_VAR 0 5
42002: PUSH
42003: LD_VAR 0 1
42007: ST_TO_ADDR
// end ;
42008: LD_VAR 0 5
42012: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42013: LD_INT 0
42015: PPUSH
42016: PPUSH
42017: PPUSH
// for j = 1 to 8 do
42018: LD_ADDR_VAR 0 3
42022: PUSH
42023: DOUBLE
42024: LD_INT 1
42026: DEC
42027: ST_TO_ADDR
42028: LD_INT 8
42030: PUSH
42031: FOR_TO
42032: IFFALSE 42873
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42034: LD_VAR 0 3
42038: PPUSH
42039: LD_INT 51
42041: PUSH
42042: EMPTY
42043: LIST
42044: PPUSH
42045: CALL 11546 0 2
42049: PUSH
42050: LD_OWVAR 2
42054: PUSH
42055: LD_VAR 0 3
42059: EQUAL
42060: NOT
42061: AND
42062: IFFALSE 42080
// MREG_SidesList := MREG_SidesList ^ 1 else
42064: LD_ADDR_EXP 39
42068: PUSH
42069: LD_EXP 39
42073: PUSH
42074: LD_INT 1
42076: ADD
42077: ST_TO_ADDR
42078: GO 42094
// MREG_SidesList := MREG_SidesList ^ 0 ;
42080: LD_ADDR_EXP 39
42084: PUSH
42085: LD_EXP 39
42089: PUSH
42090: LD_INT 0
42092: ADD
42093: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42094: LD_VAR 0 3
42098: PPUSH
42099: LD_INT 2
42101: PUSH
42102: LD_INT 34
42104: PUSH
42105: LD_INT 12
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PUSH
42112: LD_INT 34
42114: PUSH
42115: LD_INT 32
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 34
42124: PUSH
42125: LD_INT 51
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: PUSH
42138: EMPTY
42139: LIST
42140: PPUSH
42141: CALL 11847 0 2
42145: IFFALSE 42246
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42147: LD_ADDR_VAR 0 2
42151: PUSH
42152: LD_VAR 0 3
42156: PPUSH
42157: LD_INT 2
42159: PUSH
42160: LD_INT 34
42162: PUSH
42163: LD_INT 12
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 34
42172: PUSH
42173: LD_INT 32
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 34
42182: PUSH
42183: LD_INT 51
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: LIST
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PPUSH
42199: CALL 11847 0 2
42203: PUSH
42204: FOR_IN
42205: IFFALSE 42244
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42207: LD_ADDR_EXP 41
42211: PUSH
42212: LD_EXP 41
42216: PPUSH
42217: LD_VAR 0 3
42221: PPUSH
42222: LD_VAR 0 2
42226: PPUSH
42227: LD_VAR 0 2
42231: PPUSH
42232: CALL_OW 264
42236: PPUSH
42237: CALL 41841 0 4
42241: ST_TO_ADDR
42242: GO 42204
42244: POP
42245: POP
// if MCF_Class ( j , 4 , [ ] ) then
42246: LD_VAR 0 3
42250: PPUSH
42251: LD_INT 4
42253: PPUSH
42254: EMPTY
42255: PPUSH
42256: CALL 11629 0 3
42260: IFFALSE 42293
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42262: LD_ADDR_EXP 54
42266: PUSH
42267: LD_EXP 54
42271: PUSH
42272: LD_VAR 0 3
42276: PPUSH
42277: LD_INT 4
42279: PPUSH
42280: EMPTY
42281: PPUSH
42282: CALL 11629 0 3
42286: PUSH
42287: EMPTY
42288: LIST
42289: ADD
42290: ST_TO_ADDR
42291: GO 42310
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42293: LD_ADDR_EXP 54
42297: PUSH
42298: LD_EXP 54
42302: PUSH
42303: LD_INT 0
42305: PUSH
42306: EMPTY
42307: LIST
42308: ADD
42309: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42310: LD_VAR 0 3
42314: PPUSH
42315: LD_INT 3
42317: PPUSH
42318: EMPTY
42319: PPUSH
42320: CALL 11629 0 3
42324: IFFALSE 42357
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42326: LD_ADDR_EXP 55
42330: PUSH
42331: LD_EXP 55
42335: PUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_INT 3
42343: PPUSH
42344: EMPTY
42345: PPUSH
42346: CALL 11629 0 3
42350: PUSH
42351: EMPTY
42352: LIST
42353: ADD
42354: ST_TO_ADDR
42355: GO 42374
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42357: LD_ADDR_EXP 55
42361: PUSH
42362: LD_EXP 55
42366: PUSH
42367: LD_INT 0
42369: PUSH
42370: EMPTY
42371: LIST
42372: ADD
42373: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42374: LD_VAR 0 3
42378: PPUSH
42379: LD_INT 1
42381: PPUSH
42382: EMPTY
42383: PPUSH
42384: CALL 11629 0 3
42388: IFFALSE 42421
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42390: LD_ADDR_EXP 56
42394: PUSH
42395: LD_EXP 56
42399: PUSH
42400: LD_VAR 0 3
42404: PPUSH
42405: LD_INT 1
42407: PPUSH
42408: EMPTY
42409: PPUSH
42410: CALL 11629 0 3
42414: PUSH
42415: EMPTY
42416: LIST
42417: ADD
42418: ST_TO_ADDR
42419: GO 42438
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42421: LD_ADDR_EXP 56
42425: PUSH
42426: LD_EXP 56
42430: PUSH
42431: LD_INT 0
42433: PUSH
42434: EMPTY
42435: LIST
42436: ADD
42437: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42438: LD_VAR 0 3
42442: PPUSH
42443: LD_INT 2
42445: PPUSH
42446: EMPTY
42447: PPUSH
42448: CALL 11629 0 3
42452: IFFALSE 42485
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42454: LD_ADDR_EXP 57
42458: PUSH
42459: LD_EXP 57
42463: PUSH
42464: LD_VAR 0 3
42468: PPUSH
42469: LD_INT 2
42471: PPUSH
42472: EMPTY
42473: PPUSH
42474: CALL 11629 0 3
42478: PUSH
42479: EMPTY
42480: LIST
42481: ADD
42482: ST_TO_ADDR
42483: GO 42502
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42485: LD_ADDR_EXP 57
42489: PUSH
42490: LD_EXP 57
42494: PUSH
42495: LD_INT 0
42497: PUSH
42498: EMPTY
42499: LIST
42500: ADD
42501: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42502: LD_ADDR_EXP 47
42506: PUSH
42507: LD_EXP 47
42511: PUSH
42512: LD_INT 0
42514: PUSH
42515: EMPTY
42516: LIST
42517: ADD
42518: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42519: LD_ADDR_EXP 35
42523: PUSH
42524: LD_EXP 35
42528: PUSH
42529: LD_INT 0
42531: PUSH
42532: EMPTY
42533: LIST
42534: ADD
42535: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42536: LD_ADDR_EXP 37
42540: PUSH
42541: LD_EXP 37
42545: PUSH
42546: LD_INT 0
42548: PUSH
42549: EMPTY
42550: LIST
42551: ADD
42552: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42553: LD_ADDR_EXP 58
42557: PUSH
42558: LD_EXP 58
42562: PUSH
42563: LD_INT 0
42565: PUSH
42566: EMPTY
42567: LIST
42568: ADD
42569: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42570: LD_ADDR_EXP 59
42574: PUSH
42575: LD_EXP 59
42579: PUSH
42580: LD_INT 0
42582: PUSH
42583: EMPTY
42584: LIST
42585: ADD
42586: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42587: LD_ADDR_EXP 51
42591: PUSH
42592: LD_EXP 51
42596: PUSH
42597: LD_INT 0
42599: PUSH
42600: EMPTY
42601: LIST
42602: ADD
42603: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42604: LD_ADDR_EXP 38
42608: PUSH
42609: LD_EXP 38
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: LD_INT 0
42619: PUSH
42620: LD_INT 0
42622: PUSH
42623: LD_INT 0
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: PUSH
42632: EMPTY
42633: LIST
42634: ADD
42635: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42636: LD_ADDR_EXP 60
42640: PUSH
42641: LD_EXP 60
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: EMPTY
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: EMPTY
42656: LIST
42657: ADD
42658: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42659: LD_ADDR_EXP 61
42663: PUSH
42664: LD_EXP 61
42668: PUSH
42669: LD_INT 0
42671: PUSH
42672: EMPTY
42673: LIST
42674: PUSH
42675: EMPTY
42676: LIST
42677: ADD
42678: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42679: LD_ADDR_EXP 42
42683: PUSH
42684: LD_EXP 42
42688: PUSH
42689: LD_INT 0
42691: PUSH
42692: EMPTY
42693: LIST
42694: ADD
42695: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42696: LD_ADDR_EXP 63
42700: PUSH
42701: LD_EXP 63
42705: PUSH
42706: LD_INT 0
42708: PUSH
42709: EMPTY
42710: LIST
42711: ADD
42712: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42713: LD_ADDR_EXP 64
42717: PUSH
42718: LD_EXP 64
42722: PUSH
42723: LD_INT 0
42725: PUSH
42726: EMPTY
42727: LIST
42728: ADD
42729: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42730: LD_ADDR_EXP 65
42734: PUSH
42735: LD_EXP 65
42739: PUSH
42740: LD_INT 0
42742: PUSH
42743: EMPTY
42744: LIST
42745: ADD
42746: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42747: LD_ADDR_EXP 66
42751: PUSH
42752: LD_EXP 66
42756: PUSH
42757: LD_INT 0
42759: PUSH
42760: EMPTY
42761: LIST
42762: ADD
42763: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42764: LD_ADDR_EXP 67
42768: PUSH
42769: LD_EXP 67
42773: PUSH
42774: LD_INT 0
42776: PUSH
42777: EMPTY
42778: LIST
42779: ADD
42780: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42781: LD_ADDR_EXP 68
42785: PUSH
42786: LD_EXP 68
42790: PUSH
42791: LD_INT 0
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42798: LD_ADDR_EXP 69
42802: PUSH
42803: LD_EXP 69
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42815: LD_ADDR_EXP 71
42819: PUSH
42820: LD_EXP 71
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42832: LD_ADDR_EXP 70
42836: PUSH
42837: LD_EXP 70
42841: PUSH
42842: LD_INT 0
42844: ADD
42845: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42846: LD_ADDR_EXP 62
42850: PUSH
42851: LD_EXP 62
42855: PUSH
42856: LD_INT 0
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: LD_INT 0
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: LIST
42869: ADD
42870: ST_TO_ADDR
// end ;
42871: GO 42031
42873: POP
42874: POP
// end ;
42875: LD_VAR 0 1
42879: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42880: LD_INT 0
42882: PPUSH
42883: PPUSH
42884: PPUSH
// m := false ;
42885: LD_ADDR_VAR 0 5
42889: PUSH
42890: LD_INT 0
42892: ST_TO_ADDR
// for i = 1 to mreg do
42893: LD_ADDR_VAR 0 4
42897: PUSH
42898: DOUBLE
42899: LD_INT 1
42901: DEC
42902: ST_TO_ADDR
42903: LD_VAR 0 2
42907: PUSH
42908: FOR_TO
42909: IFFALSE 42945
// if mreg [ i ] [ 1 ] = side then
42911: LD_VAR 0 2
42915: PUSH
42916: LD_VAR 0 4
42920: ARRAY
42921: PUSH
42922: LD_INT 1
42924: ARRAY
42925: PUSH
42926: LD_VAR 0 1
42930: EQUAL
42931: IFFALSE 42943
// begin m := true ;
42933: LD_ADDR_VAR 0 5
42937: PUSH
42938: LD_INT 1
42940: ST_TO_ADDR
// break ;
42941: GO 42945
// end ;
42943: GO 42908
42945: POP
42946: POP
// result := m ;
42947: LD_ADDR_VAR 0 3
42951: PUSH
42952: LD_VAR 0 5
42956: ST_TO_ADDR
// end ;
42957: LD_VAR 0 3
42961: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
42962: LD_INT 0
42964: PPUSH
42965: PPUSH
42966: PPUSH
// m := 0 ;
42967: LD_ADDR_VAR 0 5
42971: PUSH
42972: LD_INT 0
42974: ST_TO_ADDR
// for i = 1 to mreg do
42975: LD_ADDR_VAR 0 4
42979: PUSH
42980: DOUBLE
42981: LD_INT 1
42983: DEC
42984: ST_TO_ADDR
42985: LD_VAR 0 2
42989: PUSH
42990: FOR_TO
42991: IFFALSE 43031
// if mreg [ i ] [ 1 ] = side then
42993: LD_VAR 0 2
42997: PUSH
42998: LD_VAR 0 4
43002: ARRAY
43003: PUSH
43004: LD_INT 1
43006: ARRAY
43007: PUSH
43008: LD_VAR 0 1
43012: EQUAL
43013: IFFALSE 43029
// begin m := m + 1 ;
43015: LD_ADDR_VAR 0 5
43019: PUSH
43020: LD_VAR 0 5
43024: PUSH
43025: LD_INT 1
43027: PLUS
43028: ST_TO_ADDR
// end ;
43029: GO 42990
43031: POP
43032: POP
// result := m ;
43033: LD_ADDR_VAR 0 3
43037: PUSH
43038: LD_VAR 0 5
43042: ST_TO_ADDR
// end ;
43043: LD_VAR 0 3
43047: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43048: LD_INT 0
43050: PPUSH
43051: PPUSH
// result := 0 ;
43052: LD_ADDR_VAR 0 3
43056: PUSH
43057: LD_INT 0
43059: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43060: LD_ADDR_VAR 0 4
43064: PUSH
43065: DOUBLE
43066: LD_INT 1
43068: DEC
43069: ST_TO_ADDR
43070: LD_EXP 53
43074: PUSH
43075: FOR_TO
43076: IFFALSE 43138
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43078: LD_EXP 53
43082: PUSH
43083: LD_VAR 0 4
43087: ARRAY
43088: PUSH
43089: LD_INT 1
43091: ARRAY
43092: PUSH
43093: LD_VAR 0 1
43097: EQUAL
43098: PUSH
43099: LD_EXP 53
43103: PUSH
43104: LD_VAR 0 4
43108: ARRAY
43109: PUSH
43110: LD_INT 2
43112: ARRAY
43113: PUSH
43114: LD_VAR 0 2
43118: EQUAL
43119: AND
43120: IFFALSE 43136
// begin result := result + 1 ;
43122: LD_ADDR_VAR 0 3
43126: PUSH
43127: LD_VAR 0 3
43131: PUSH
43132: LD_INT 1
43134: PLUS
43135: ST_TO_ADDR
// end ;
43136: GO 43075
43138: POP
43139: POP
// end ; end_of_file
43140: LD_VAR 0 3
43144: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43145: LD_INT 0
43147: PPUSH
// ar_miner := 81 ;
43148: LD_ADDR_EXP 80
43152: PUSH
43153: LD_INT 81
43155: ST_TO_ADDR
// ar_crane := 88 ;
43156: LD_ADDR_EXP 79
43160: PUSH
43161: LD_INT 88
43163: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43164: LD_ADDR_EXP 74
43168: PUSH
43169: LD_INT 89
43171: ST_TO_ADDR
// us_hack := 99 ;
43172: LD_ADDR_EXP 75
43176: PUSH
43177: LD_INT 99
43179: ST_TO_ADDR
// us_artillery := 97 ;
43180: LD_ADDR_EXP 76
43184: PUSH
43185: LD_INT 97
43187: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43188: LD_ADDR_EXP 77
43192: PUSH
43193: LD_INT 91
43195: ST_TO_ADDR
// ar_mortar := 92 ;
43196: LD_ADDR_EXP 78
43200: PUSH
43201: LD_INT 92
43203: ST_TO_ADDR
// ru_radar := 98 ;
43204: LD_ADDR_EXP 73
43208: PUSH
43209: LD_INT 98
43211: ST_TO_ADDR
// tech_Artillery := 80 ;
43212: LD_ADDR_EXP 81
43216: PUSH
43217: LD_INT 80
43219: ST_TO_ADDR
// tech_RadMat := 81 ;
43220: LD_ADDR_EXP 82
43224: PUSH
43225: LD_INT 81
43227: ST_TO_ADDR
// tech_BasicTools := 82 ;
43228: LD_ADDR_EXP 83
43232: PUSH
43233: LD_INT 82
43235: ST_TO_ADDR
// tech_Cargo := 83 ;
43236: LD_ADDR_EXP 84
43240: PUSH
43241: LD_INT 83
43243: ST_TO_ADDR
// tech_Track := 84 ;
43244: LD_ADDR_EXP 85
43248: PUSH
43249: LD_INT 84
43251: ST_TO_ADDR
// tech_Crane := 85 ;
43252: LD_ADDR_EXP 86
43256: PUSH
43257: LD_INT 85
43259: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43260: LD_ADDR_EXP 87
43264: PUSH
43265: LD_INT 86
43267: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43268: LD_ADDR_EXP 88
43272: PUSH
43273: LD_INT 87
43275: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43276: LD_ADDR_EXP 89
43280: PUSH
43281: LD_INT 88
43283: ST_TO_ADDR
// class_mastodont := 31 ;
43284: LD_ADDR_EXP 90
43288: PUSH
43289: LD_INT 31
43291: ST_TO_ADDR
// class_horse := 21 ;
43292: LD_ADDR_EXP 91
43296: PUSH
43297: LD_INT 21
43299: ST_TO_ADDR
// end ;
43300: LD_VAR 0 1
43304: RET
// every 1 do
43305: GO 43307
43307: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43308: CALL 43145 0 0
43312: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43313: LD_INT 0
43315: PPUSH
// if p2 = 100 then
43316: LD_VAR 0 2
43320: PUSH
43321: LD_INT 100
43323: EQUAL
43324: IFFALSE 44273
// begin if not StreamModeActive then
43326: LD_EXP 92
43330: NOT
43331: IFFALSE 43341
// StreamModeActive := true ;
43333: LD_ADDR_EXP 92
43337: PUSH
43338: LD_INT 1
43340: ST_TO_ADDR
// if p3 = 0 then
43341: LD_VAR 0 3
43345: PUSH
43346: LD_INT 0
43348: EQUAL
43349: IFFALSE 43355
// InitStreamMode ;
43351: CALL 44433 0 0
// if p3 = 1 then
43355: LD_VAR 0 3
43359: PUSH
43360: LD_INT 1
43362: EQUAL
43363: IFFALSE 43373
// sRocket := true ;
43365: LD_ADDR_EXP 97
43369: PUSH
43370: LD_INT 1
43372: ST_TO_ADDR
// if p3 = 2 then
43373: LD_VAR 0 3
43377: PUSH
43378: LD_INT 2
43380: EQUAL
43381: IFFALSE 43391
// sSpeed := true ;
43383: LD_ADDR_EXP 96
43387: PUSH
43388: LD_INT 1
43390: ST_TO_ADDR
// if p3 = 3 then
43391: LD_VAR 0 3
43395: PUSH
43396: LD_INT 3
43398: EQUAL
43399: IFFALSE 43409
// sEngine := true ;
43401: LD_ADDR_EXP 98
43405: PUSH
43406: LD_INT 1
43408: ST_TO_ADDR
// if p3 = 4 then
43409: LD_VAR 0 3
43413: PUSH
43414: LD_INT 4
43416: EQUAL
43417: IFFALSE 43427
// sSpec := true ;
43419: LD_ADDR_EXP 95
43423: PUSH
43424: LD_INT 1
43426: ST_TO_ADDR
// if p3 = 5 then
43427: LD_VAR 0 3
43431: PUSH
43432: LD_INT 5
43434: EQUAL
43435: IFFALSE 43445
// sLevel := true ;
43437: LD_ADDR_EXP 99
43441: PUSH
43442: LD_INT 1
43444: ST_TO_ADDR
// if p3 = 6 then
43445: LD_VAR 0 3
43449: PUSH
43450: LD_INT 6
43452: EQUAL
43453: IFFALSE 43463
// sArmoury := true ;
43455: LD_ADDR_EXP 100
43459: PUSH
43460: LD_INT 1
43462: ST_TO_ADDR
// if p3 = 7 then
43463: LD_VAR 0 3
43467: PUSH
43468: LD_INT 7
43470: EQUAL
43471: IFFALSE 43481
// sRadar := true ;
43473: LD_ADDR_EXP 101
43477: PUSH
43478: LD_INT 1
43480: ST_TO_ADDR
// if p3 = 8 then
43481: LD_VAR 0 3
43485: PUSH
43486: LD_INT 8
43488: EQUAL
43489: IFFALSE 43499
// sBunker := true ;
43491: LD_ADDR_EXP 102
43495: PUSH
43496: LD_INT 1
43498: ST_TO_ADDR
// if p3 = 9 then
43499: LD_VAR 0 3
43503: PUSH
43504: LD_INT 9
43506: EQUAL
43507: IFFALSE 43517
// sHack := true ;
43509: LD_ADDR_EXP 103
43513: PUSH
43514: LD_INT 1
43516: ST_TO_ADDR
// if p3 = 10 then
43517: LD_VAR 0 3
43521: PUSH
43522: LD_INT 10
43524: EQUAL
43525: IFFALSE 43535
// sFire := true ;
43527: LD_ADDR_EXP 104
43531: PUSH
43532: LD_INT 1
43534: ST_TO_ADDR
// if p3 = 11 then
43535: LD_VAR 0 3
43539: PUSH
43540: LD_INT 11
43542: EQUAL
43543: IFFALSE 43553
// sRefresh := true ;
43545: LD_ADDR_EXP 105
43549: PUSH
43550: LD_INT 1
43552: ST_TO_ADDR
// if p3 = 12 then
43553: LD_VAR 0 3
43557: PUSH
43558: LD_INT 12
43560: EQUAL
43561: IFFALSE 43571
// sExp := true ;
43563: LD_ADDR_EXP 106
43567: PUSH
43568: LD_INT 1
43570: ST_TO_ADDR
// if p3 = 13 then
43571: LD_VAR 0 3
43575: PUSH
43576: LD_INT 13
43578: EQUAL
43579: IFFALSE 43589
// sDepot := true ;
43581: LD_ADDR_EXP 107
43585: PUSH
43586: LD_INT 1
43588: ST_TO_ADDR
// if p3 = 14 then
43589: LD_VAR 0 3
43593: PUSH
43594: LD_INT 14
43596: EQUAL
43597: IFFALSE 43607
// sFlag := true ;
43599: LD_ADDR_EXP 108
43603: PUSH
43604: LD_INT 1
43606: ST_TO_ADDR
// if p3 = 15 then
43607: LD_VAR 0 3
43611: PUSH
43612: LD_INT 15
43614: EQUAL
43615: IFFALSE 43625
// sKamikadze := true ;
43617: LD_ADDR_EXP 116
43621: PUSH
43622: LD_INT 1
43624: ST_TO_ADDR
// if p3 = 16 then
43625: LD_VAR 0 3
43629: PUSH
43630: LD_INT 16
43632: EQUAL
43633: IFFALSE 43643
// sTroll := true ;
43635: LD_ADDR_EXP 117
43639: PUSH
43640: LD_INT 1
43642: ST_TO_ADDR
// if p3 = 17 then
43643: LD_VAR 0 3
43647: PUSH
43648: LD_INT 17
43650: EQUAL
43651: IFFALSE 43661
// sSlow := true ;
43653: LD_ADDR_EXP 118
43657: PUSH
43658: LD_INT 1
43660: ST_TO_ADDR
// if p3 = 18 then
43661: LD_VAR 0 3
43665: PUSH
43666: LD_INT 18
43668: EQUAL
43669: IFFALSE 43679
// sLack := true ;
43671: LD_ADDR_EXP 119
43675: PUSH
43676: LD_INT 1
43678: ST_TO_ADDR
// if p3 = 19 then
43679: LD_VAR 0 3
43683: PUSH
43684: LD_INT 19
43686: EQUAL
43687: IFFALSE 43697
// sTank := true ;
43689: LD_ADDR_EXP 121
43693: PUSH
43694: LD_INT 1
43696: ST_TO_ADDR
// if p3 = 20 then
43697: LD_VAR 0 3
43701: PUSH
43702: LD_INT 20
43704: EQUAL
43705: IFFALSE 43715
// sRemote := true ;
43707: LD_ADDR_EXP 122
43711: PUSH
43712: LD_INT 1
43714: ST_TO_ADDR
// if p3 = 21 then
43715: LD_VAR 0 3
43719: PUSH
43720: LD_INT 21
43722: EQUAL
43723: IFFALSE 43733
// sPowell := true ;
43725: LD_ADDR_EXP 123
43729: PUSH
43730: LD_INT 1
43732: ST_TO_ADDR
// if p3 = 22 then
43733: LD_VAR 0 3
43737: PUSH
43738: LD_INT 22
43740: EQUAL
43741: IFFALSE 43751
// sTeleport := true ;
43743: LD_ADDR_EXP 126
43747: PUSH
43748: LD_INT 1
43750: ST_TO_ADDR
// if p3 = 23 then
43751: LD_VAR 0 3
43755: PUSH
43756: LD_INT 23
43758: EQUAL
43759: IFFALSE 43769
// sOilTower := true ;
43761: LD_ADDR_EXP 128
43765: PUSH
43766: LD_INT 1
43768: ST_TO_ADDR
// if p3 = 24 then
43769: LD_VAR 0 3
43773: PUSH
43774: LD_INT 24
43776: EQUAL
43777: IFFALSE 43787
// sShovel := true ;
43779: LD_ADDR_EXP 129
43783: PUSH
43784: LD_INT 1
43786: ST_TO_ADDR
// if p3 = 25 then
43787: LD_VAR 0 3
43791: PUSH
43792: LD_INT 25
43794: EQUAL
43795: IFFALSE 43805
// sSheik := true ;
43797: LD_ADDR_EXP 130
43801: PUSH
43802: LD_INT 1
43804: ST_TO_ADDR
// if p3 = 26 then
43805: LD_VAR 0 3
43809: PUSH
43810: LD_INT 26
43812: EQUAL
43813: IFFALSE 43823
// sEarthquake := true ;
43815: LD_ADDR_EXP 132
43819: PUSH
43820: LD_INT 1
43822: ST_TO_ADDR
// if p3 = 27 then
43823: LD_VAR 0 3
43827: PUSH
43828: LD_INT 27
43830: EQUAL
43831: IFFALSE 43841
// sAI := true ;
43833: LD_ADDR_EXP 133
43837: PUSH
43838: LD_INT 1
43840: ST_TO_ADDR
// if p3 = 28 then
43841: LD_VAR 0 3
43845: PUSH
43846: LD_INT 28
43848: EQUAL
43849: IFFALSE 43859
// sCargo := true ;
43851: LD_ADDR_EXP 136
43855: PUSH
43856: LD_INT 1
43858: ST_TO_ADDR
// if p3 = 29 then
43859: LD_VAR 0 3
43863: PUSH
43864: LD_INT 29
43866: EQUAL
43867: IFFALSE 43877
// sDLaser := true ;
43869: LD_ADDR_EXP 137
43873: PUSH
43874: LD_INT 1
43876: ST_TO_ADDR
// if p3 = 30 then
43877: LD_VAR 0 3
43881: PUSH
43882: LD_INT 30
43884: EQUAL
43885: IFFALSE 43895
// sExchange := true ;
43887: LD_ADDR_EXP 138
43891: PUSH
43892: LD_INT 1
43894: ST_TO_ADDR
// if p3 = 31 then
43895: LD_VAR 0 3
43899: PUSH
43900: LD_INT 31
43902: EQUAL
43903: IFFALSE 43913
// sFac := true ;
43905: LD_ADDR_EXP 139
43909: PUSH
43910: LD_INT 1
43912: ST_TO_ADDR
// if p3 = 32 then
43913: LD_VAR 0 3
43917: PUSH
43918: LD_INT 32
43920: EQUAL
43921: IFFALSE 43931
// sPower := true ;
43923: LD_ADDR_EXP 140
43927: PUSH
43928: LD_INT 1
43930: ST_TO_ADDR
// if p3 = 33 then
43931: LD_VAR 0 3
43935: PUSH
43936: LD_INT 33
43938: EQUAL
43939: IFFALSE 43949
// sRandom := true ;
43941: LD_ADDR_EXP 141
43945: PUSH
43946: LD_INT 1
43948: ST_TO_ADDR
// if p3 = 34 then
43949: LD_VAR 0 3
43953: PUSH
43954: LD_INT 34
43956: EQUAL
43957: IFFALSE 43967
// sShield := true ;
43959: LD_ADDR_EXP 142
43963: PUSH
43964: LD_INT 1
43966: ST_TO_ADDR
// if p3 = 35 then
43967: LD_VAR 0 3
43971: PUSH
43972: LD_INT 35
43974: EQUAL
43975: IFFALSE 43985
// sTime := true ;
43977: LD_ADDR_EXP 143
43981: PUSH
43982: LD_INT 1
43984: ST_TO_ADDR
// if p3 = 36 then
43985: LD_VAR 0 3
43989: PUSH
43990: LD_INT 36
43992: EQUAL
43993: IFFALSE 44003
// sTools := true ;
43995: LD_ADDR_EXP 144
43999: PUSH
44000: LD_INT 1
44002: ST_TO_ADDR
// if p3 = 101 then
44003: LD_VAR 0 3
44007: PUSH
44008: LD_INT 101
44010: EQUAL
44011: IFFALSE 44021
// sSold := true ;
44013: LD_ADDR_EXP 109
44017: PUSH
44018: LD_INT 1
44020: ST_TO_ADDR
// if p3 = 102 then
44021: LD_VAR 0 3
44025: PUSH
44026: LD_INT 102
44028: EQUAL
44029: IFFALSE 44039
// sDiff := true ;
44031: LD_ADDR_EXP 110
44035: PUSH
44036: LD_INT 1
44038: ST_TO_ADDR
// if p3 = 103 then
44039: LD_VAR 0 3
44043: PUSH
44044: LD_INT 103
44046: EQUAL
44047: IFFALSE 44057
// sFog := true ;
44049: LD_ADDR_EXP 113
44053: PUSH
44054: LD_INT 1
44056: ST_TO_ADDR
// if p3 = 104 then
44057: LD_VAR 0 3
44061: PUSH
44062: LD_INT 104
44064: EQUAL
44065: IFFALSE 44075
// sReset := true ;
44067: LD_ADDR_EXP 114
44071: PUSH
44072: LD_INT 1
44074: ST_TO_ADDR
// if p3 = 105 then
44075: LD_VAR 0 3
44079: PUSH
44080: LD_INT 105
44082: EQUAL
44083: IFFALSE 44093
// sSun := true ;
44085: LD_ADDR_EXP 115
44089: PUSH
44090: LD_INT 1
44092: ST_TO_ADDR
// if p3 = 106 then
44093: LD_VAR 0 3
44097: PUSH
44098: LD_INT 106
44100: EQUAL
44101: IFFALSE 44111
// sTiger := true ;
44103: LD_ADDR_EXP 111
44107: PUSH
44108: LD_INT 1
44110: ST_TO_ADDR
// if p3 = 107 then
44111: LD_VAR 0 3
44115: PUSH
44116: LD_INT 107
44118: EQUAL
44119: IFFALSE 44129
// sBomb := true ;
44121: LD_ADDR_EXP 112
44125: PUSH
44126: LD_INT 1
44128: ST_TO_ADDR
// if p3 = 108 then
44129: LD_VAR 0 3
44133: PUSH
44134: LD_INT 108
44136: EQUAL
44137: IFFALSE 44147
// sWound := true ;
44139: LD_ADDR_EXP 120
44143: PUSH
44144: LD_INT 1
44146: ST_TO_ADDR
// if p3 = 109 then
44147: LD_VAR 0 3
44151: PUSH
44152: LD_INT 109
44154: EQUAL
44155: IFFALSE 44165
// sBetray := true ;
44157: LD_ADDR_EXP 124
44161: PUSH
44162: LD_INT 1
44164: ST_TO_ADDR
// if p3 = 110 then
44165: LD_VAR 0 3
44169: PUSH
44170: LD_INT 110
44172: EQUAL
44173: IFFALSE 44183
// sContamin := true ;
44175: LD_ADDR_EXP 125
44179: PUSH
44180: LD_INT 1
44182: ST_TO_ADDR
// if p3 = 111 then
44183: LD_VAR 0 3
44187: PUSH
44188: LD_INT 111
44190: EQUAL
44191: IFFALSE 44201
// sOil := true ;
44193: LD_ADDR_EXP 127
44197: PUSH
44198: LD_INT 1
44200: ST_TO_ADDR
// if p3 = 112 then
44201: LD_VAR 0 3
44205: PUSH
44206: LD_INT 112
44208: EQUAL
44209: IFFALSE 44219
// sStu := true ;
44211: LD_ADDR_EXP 131
44215: PUSH
44216: LD_INT 1
44218: ST_TO_ADDR
// if p3 = 113 then
44219: LD_VAR 0 3
44223: PUSH
44224: LD_INT 113
44226: EQUAL
44227: IFFALSE 44237
// sBazooka := true ;
44229: LD_ADDR_EXP 134
44233: PUSH
44234: LD_INT 1
44236: ST_TO_ADDR
// if p3 = 114 then
44237: LD_VAR 0 3
44241: PUSH
44242: LD_INT 114
44244: EQUAL
44245: IFFALSE 44255
// sMortar := true ;
44247: LD_ADDR_EXP 135
44251: PUSH
44252: LD_INT 1
44254: ST_TO_ADDR
// if p3 = 115 then
44255: LD_VAR 0 3
44259: PUSH
44260: LD_INT 115
44262: EQUAL
44263: IFFALSE 44273
// sRanger := true ;
44265: LD_ADDR_EXP 145
44269: PUSH
44270: LD_INT 1
44272: ST_TO_ADDR
// end ; if p2 = 101 then
44273: LD_VAR 0 2
44277: PUSH
44278: LD_INT 101
44280: EQUAL
44281: IFFALSE 44409
// begin case p3 of 1 :
44283: LD_VAR 0 3
44287: PUSH
44288: LD_INT 1
44290: DOUBLE
44291: EQUAL
44292: IFTRUE 44296
44294: GO 44303
44296: POP
// hHackUnlimitedResources ; 2 :
44297: CALL 55446 0 0
44301: GO 44409
44303: LD_INT 2
44305: DOUBLE
44306: EQUAL
44307: IFTRUE 44311
44309: GO 44318
44311: POP
// hHackSetLevel10 ; 3 :
44312: CALL 55579 0 0
44316: GO 44409
44318: LD_INT 3
44320: DOUBLE
44321: EQUAL
44322: IFTRUE 44326
44324: GO 44333
44326: POP
// hHackSetLevel10YourUnits ; 4 :
44327: CALL 55664 0 0
44331: GO 44409
44333: LD_INT 4
44335: DOUBLE
44336: EQUAL
44337: IFTRUE 44341
44339: GO 44348
44341: POP
// hHackInvincible ; 5 :
44342: CALL 56112 0 0
44346: GO 44409
44348: LD_INT 5
44350: DOUBLE
44351: EQUAL
44352: IFTRUE 44356
44354: GO 44363
44356: POP
// hHackInvisible ; 6 :
44357: CALL 56223 0 0
44361: GO 44409
44363: LD_INT 6
44365: DOUBLE
44366: EQUAL
44367: IFTRUE 44371
44369: GO 44378
44371: POP
// hHackChangeYourSide ; 7 :
44372: CALL 56280 0 0
44376: GO 44409
44378: LD_INT 7
44380: DOUBLE
44381: EQUAL
44382: IFTRUE 44386
44384: GO 44393
44386: POP
// hHackChangeUnitSide ; 8 :
44387: CALL 56322 0 0
44391: GO 44409
44393: LD_INT 8
44395: DOUBLE
44396: EQUAL
44397: IFTRUE 44401
44399: GO 44408
44401: POP
// hHackFog ; end ;
44402: CALL 56423 0 0
44406: GO 44409
44408: POP
// end ; end ;
44409: LD_VAR 0 7
44413: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44414: GO 44416
44416: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44417: LD_STRING initStreamRollete();
44419: PPUSH
44420: CALL_OW 559
// InitStreamMode ;
44424: CALL 44433 0 0
// DefineStreamItems ( ) ;
44428: CALL 44873 0 0
// end ;
44432: END
// function InitStreamMode ; begin
44433: LD_INT 0
44435: PPUSH
// streamModeActive := false ;
44436: LD_ADDR_EXP 92
44440: PUSH
44441: LD_INT 0
44443: ST_TO_ADDR
// normalCounter := 36 ;
44444: LD_ADDR_EXP 93
44448: PUSH
44449: LD_INT 36
44451: ST_TO_ADDR
// hardcoreCounter := 16 ;
44452: LD_ADDR_EXP 94
44456: PUSH
44457: LD_INT 16
44459: ST_TO_ADDR
// sRocket := false ;
44460: LD_ADDR_EXP 97
44464: PUSH
44465: LD_INT 0
44467: ST_TO_ADDR
// sSpeed := false ;
44468: LD_ADDR_EXP 96
44472: PUSH
44473: LD_INT 0
44475: ST_TO_ADDR
// sEngine := false ;
44476: LD_ADDR_EXP 98
44480: PUSH
44481: LD_INT 0
44483: ST_TO_ADDR
// sSpec := false ;
44484: LD_ADDR_EXP 95
44488: PUSH
44489: LD_INT 0
44491: ST_TO_ADDR
// sLevel := false ;
44492: LD_ADDR_EXP 99
44496: PUSH
44497: LD_INT 0
44499: ST_TO_ADDR
// sArmoury := false ;
44500: LD_ADDR_EXP 100
44504: PUSH
44505: LD_INT 0
44507: ST_TO_ADDR
// sRadar := false ;
44508: LD_ADDR_EXP 101
44512: PUSH
44513: LD_INT 0
44515: ST_TO_ADDR
// sBunker := false ;
44516: LD_ADDR_EXP 102
44520: PUSH
44521: LD_INT 0
44523: ST_TO_ADDR
// sHack := false ;
44524: LD_ADDR_EXP 103
44528: PUSH
44529: LD_INT 0
44531: ST_TO_ADDR
// sFire := false ;
44532: LD_ADDR_EXP 104
44536: PUSH
44537: LD_INT 0
44539: ST_TO_ADDR
// sRefresh := false ;
44540: LD_ADDR_EXP 105
44544: PUSH
44545: LD_INT 0
44547: ST_TO_ADDR
// sExp := false ;
44548: LD_ADDR_EXP 106
44552: PUSH
44553: LD_INT 0
44555: ST_TO_ADDR
// sDepot := false ;
44556: LD_ADDR_EXP 107
44560: PUSH
44561: LD_INT 0
44563: ST_TO_ADDR
// sFlag := false ;
44564: LD_ADDR_EXP 108
44568: PUSH
44569: LD_INT 0
44571: ST_TO_ADDR
// sKamikadze := false ;
44572: LD_ADDR_EXP 116
44576: PUSH
44577: LD_INT 0
44579: ST_TO_ADDR
// sTroll := false ;
44580: LD_ADDR_EXP 117
44584: PUSH
44585: LD_INT 0
44587: ST_TO_ADDR
// sSlow := false ;
44588: LD_ADDR_EXP 118
44592: PUSH
44593: LD_INT 0
44595: ST_TO_ADDR
// sLack := false ;
44596: LD_ADDR_EXP 119
44600: PUSH
44601: LD_INT 0
44603: ST_TO_ADDR
// sTank := false ;
44604: LD_ADDR_EXP 121
44608: PUSH
44609: LD_INT 0
44611: ST_TO_ADDR
// sRemote := false ;
44612: LD_ADDR_EXP 122
44616: PUSH
44617: LD_INT 0
44619: ST_TO_ADDR
// sPowell := false ;
44620: LD_ADDR_EXP 123
44624: PUSH
44625: LD_INT 0
44627: ST_TO_ADDR
// sTeleport := false ;
44628: LD_ADDR_EXP 126
44632: PUSH
44633: LD_INT 0
44635: ST_TO_ADDR
// sOilTower := false ;
44636: LD_ADDR_EXP 128
44640: PUSH
44641: LD_INT 0
44643: ST_TO_ADDR
// sShovel := false ;
44644: LD_ADDR_EXP 129
44648: PUSH
44649: LD_INT 0
44651: ST_TO_ADDR
// sSheik := false ;
44652: LD_ADDR_EXP 130
44656: PUSH
44657: LD_INT 0
44659: ST_TO_ADDR
// sEarthquake := false ;
44660: LD_ADDR_EXP 132
44664: PUSH
44665: LD_INT 0
44667: ST_TO_ADDR
// sAI := false ;
44668: LD_ADDR_EXP 133
44672: PUSH
44673: LD_INT 0
44675: ST_TO_ADDR
// sCargo := false ;
44676: LD_ADDR_EXP 136
44680: PUSH
44681: LD_INT 0
44683: ST_TO_ADDR
// sDLaser := false ;
44684: LD_ADDR_EXP 137
44688: PUSH
44689: LD_INT 0
44691: ST_TO_ADDR
// sExchange := false ;
44692: LD_ADDR_EXP 138
44696: PUSH
44697: LD_INT 0
44699: ST_TO_ADDR
// sFac := false ;
44700: LD_ADDR_EXP 139
44704: PUSH
44705: LD_INT 0
44707: ST_TO_ADDR
// sPower := false ;
44708: LD_ADDR_EXP 140
44712: PUSH
44713: LD_INT 0
44715: ST_TO_ADDR
// sRandom := false ;
44716: LD_ADDR_EXP 141
44720: PUSH
44721: LD_INT 0
44723: ST_TO_ADDR
// sShield := false ;
44724: LD_ADDR_EXP 142
44728: PUSH
44729: LD_INT 0
44731: ST_TO_ADDR
// sTime := false ;
44732: LD_ADDR_EXP 143
44736: PUSH
44737: LD_INT 0
44739: ST_TO_ADDR
// sTools := false ;
44740: LD_ADDR_EXP 144
44744: PUSH
44745: LD_INT 0
44747: ST_TO_ADDR
// sSold := false ;
44748: LD_ADDR_EXP 109
44752: PUSH
44753: LD_INT 0
44755: ST_TO_ADDR
// sDiff := false ;
44756: LD_ADDR_EXP 110
44760: PUSH
44761: LD_INT 0
44763: ST_TO_ADDR
// sFog := false ;
44764: LD_ADDR_EXP 113
44768: PUSH
44769: LD_INT 0
44771: ST_TO_ADDR
// sReset := false ;
44772: LD_ADDR_EXP 114
44776: PUSH
44777: LD_INT 0
44779: ST_TO_ADDR
// sSun := false ;
44780: LD_ADDR_EXP 115
44784: PUSH
44785: LD_INT 0
44787: ST_TO_ADDR
// sTiger := false ;
44788: LD_ADDR_EXP 111
44792: PUSH
44793: LD_INT 0
44795: ST_TO_ADDR
// sBomb := false ;
44796: LD_ADDR_EXP 112
44800: PUSH
44801: LD_INT 0
44803: ST_TO_ADDR
// sWound := false ;
44804: LD_ADDR_EXP 120
44808: PUSH
44809: LD_INT 0
44811: ST_TO_ADDR
// sBetray := false ;
44812: LD_ADDR_EXP 124
44816: PUSH
44817: LD_INT 0
44819: ST_TO_ADDR
// sContamin := false ;
44820: LD_ADDR_EXP 125
44824: PUSH
44825: LD_INT 0
44827: ST_TO_ADDR
// sOil := false ;
44828: LD_ADDR_EXP 127
44832: PUSH
44833: LD_INT 0
44835: ST_TO_ADDR
// sStu := false ;
44836: LD_ADDR_EXP 131
44840: PUSH
44841: LD_INT 0
44843: ST_TO_ADDR
// sBazooka := false ;
44844: LD_ADDR_EXP 134
44848: PUSH
44849: LD_INT 0
44851: ST_TO_ADDR
// sMortar := false ;
44852: LD_ADDR_EXP 135
44856: PUSH
44857: LD_INT 0
44859: ST_TO_ADDR
// sRanger := false ;
44860: LD_ADDR_EXP 145
44864: PUSH
44865: LD_INT 0
44867: ST_TO_ADDR
// end ;
44868: LD_VAR 0 1
44872: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44873: LD_INT 0
44875: PPUSH
44876: PPUSH
44877: PPUSH
44878: PPUSH
44879: PPUSH
// result := [ ] ;
44880: LD_ADDR_VAR 0 1
44884: PUSH
44885: EMPTY
44886: ST_TO_ADDR
// if campaign_id = 1 then
44887: LD_OWVAR 69
44891: PUSH
44892: LD_INT 1
44894: EQUAL
44895: IFFALSE 47833
// begin case mission_number of 1 :
44897: LD_OWVAR 70
44901: PUSH
44902: LD_INT 1
44904: DOUBLE
44905: EQUAL
44906: IFTRUE 44910
44908: GO 44974
44910: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44911: LD_ADDR_VAR 0 1
44915: PUSH
44916: LD_INT 2
44918: PUSH
44919: LD_INT 4
44921: PUSH
44922: LD_INT 11
44924: PUSH
44925: LD_INT 12
44927: PUSH
44928: LD_INT 15
44930: PUSH
44931: LD_INT 16
44933: PUSH
44934: LD_INT 22
44936: PUSH
44937: LD_INT 23
44939: PUSH
44940: LD_INT 26
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 101
44956: PUSH
44957: LD_INT 102
44959: PUSH
44960: LD_INT 106
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: LIST
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: ST_TO_ADDR
44972: GO 47831
44974: LD_INT 2
44976: DOUBLE
44977: EQUAL
44978: IFTRUE 44982
44980: GO 45054
44982: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44983: LD_ADDR_VAR 0 1
44987: PUSH
44988: LD_INT 2
44990: PUSH
44991: LD_INT 4
44993: PUSH
44994: LD_INT 11
44996: PUSH
44997: LD_INT 12
44999: PUSH
45000: LD_INT 15
45002: PUSH
45003: LD_INT 16
45005: PUSH
45006: LD_INT 22
45008: PUSH
45009: LD_INT 23
45011: PUSH
45012: LD_INT 26
45014: PUSH
45015: EMPTY
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: LIST
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 101
45028: PUSH
45029: LD_INT 102
45031: PUSH
45032: LD_INT 105
45034: PUSH
45035: LD_INT 106
45037: PUSH
45038: LD_INT 108
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: ST_TO_ADDR
45052: GO 47831
45054: LD_INT 3
45056: DOUBLE
45057: EQUAL
45058: IFTRUE 45062
45060: GO 45138
45062: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45063: LD_ADDR_VAR 0 1
45067: PUSH
45068: LD_INT 2
45070: PUSH
45071: LD_INT 4
45073: PUSH
45074: LD_INT 5
45076: PUSH
45077: LD_INT 11
45079: PUSH
45080: LD_INT 12
45082: PUSH
45083: LD_INT 15
45085: PUSH
45086: LD_INT 16
45088: PUSH
45089: LD_INT 22
45091: PUSH
45092: LD_INT 26
45094: PUSH
45095: LD_INT 36
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 101
45112: PUSH
45113: LD_INT 102
45115: PUSH
45116: LD_INT 105
45118: PUSH
45119: LD_INT 106
45121: PUSH
45122: LD_INT 108
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: ST_TO_ADDR
45136: GO 47831
45138: LD_INT 4
45140: DOUBLE
45141: EQUAL
45142: IFTRUE 45146
45144: GO 45230
45146: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45147: LD_ADDR_VAR 0 1
45151: PUSH
45152: LD_INT 2
45154: PUSH
45155: LD_INT 4
45157: PUSH
45158: LD_INT 5
45160: PUSH
45161: LD_INT 8
45163: PUSH
45164: LD_INT 11
45166: PUSH
45167: LD_INT 12
45169: PUSH
45170: LD_INT 15
45172: PUSH
45173: LD_INT 16
45175: PUSH
45176: LD_INT 22
45178: PUSH
45179: LD_INT 23
45181: PUSH
45182: LD_INT 26
45184: PUSH
45185: LD_INT 36
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 101
45204: PUSH
45205: LD_INT 102
45207: PUSH
45208: LD_INT 105
45210: PUSH
45211: LD_INT 106
45213: PUSH
45214: LD_INT 108
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: ST_TO_ADDR
45228: GO 47831
45230: LD_INT 5
45232: DOUBLE
45233: EQUAL
45234: IFTRUE 45238
45236: GO 45338
45238: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45239: LD_ADDR_VAR 0 1
45243: PUSH
45244: LD_INT 2
45246: PUSH
45247: LD_INT 4
45249: PUSH
45250: LD_INT 5
45252: PUSH
45253: LD_INT 6
45255: PUSH
45256: LD_INT 8
45258: PUSH
45259: LD_INT 11
45261: PUSH
45262: LD_INT 12
45264: PUSH
45265: LD_INT 15
45267: PUSH
45268: LD_INT 16
45270: PUSH
45271: LD_INT 22
45273: PUSH
45274: LD_INT 23
45276: PUSH
45277: LD_INT 25
45279: PUSH
45280: LD_INT 26
45282: PUSH
45283: LD_INT 36
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 101
45304: PUSH
45305: LD_INT 102
45307: PUSH
45308: LD_INT 105
45310: PUSH
45311: LD_INT 106
45313: PUSH
45314: LD_INT 108
45316: PUSH
45317: LD_INT 109
45319: PUSH
45320: LD_INT 112
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: ST_TO_ADDR
45336: GO 47831
45338: LD_INT 6
45340: DOUBLE
45341: EQUAL
45342: IFTRUE 45346
45344: GO 45466
45346: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45347: LD_ADDR_VAR 0 1
45351: PUSH
45352: LD_INT 2
45354: PUSH
45355: LD_INT 4
45357: PUSH
45358: LD_INT 5
45360: PUSH
45361: LD_INT 6
45363: PUSH
45364: LD_INT 8
45366: PUSH
45367: LD_INT 11
45369: PUSH
45370: LD_INT 12
45372: PUSH
45373: LD_INT 15
45375: PUSH
45376: LD_INT 16
45378: PUSH
45379: LD_INT 20
45381: PUSH
45382: LD_INT 21
45384: PUSH
45385: LD_INT 22
45387: PUSH
45388: LD_INT 23
45390: PUSH
45391: LD_INT 25
45393: PUSH
45394: LD_INT 26
45396: PUSH
45397: LD_INT 30
45399: PUSH
45400: LD_INT 31
45402: PUSH
45403: LD_INT 32
45405: PUSH
45406: LD_INT 36
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: LIST
45415: LIST
45416: LIST
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: PUSH
45430: LD_INT 101
45432: PUSH
45433: LD_INT 102
45435: PUSH
45436: LD_INT 105
45438: PUSH
45439: LD_INT 106
45441: PUSH
45442: LD_INT 108
45444: PUSH
45445: LD_INT 109
45447: PUSH
45448: LD_INT 112
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: ST_TO_ADDR
45464: GO 47831
45466: LD_INT 7
45468: DOUBLE
45469: EQUAL
45470: IFTRUE 45474
45472: GO 45574
45474: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45475: LD_ADDR_VAR 0 1
45479: PUSH
45480: LD_INT 2
45482: PUSH
45483: LD_INT 4
45485: PUSH
45486: LD_INT 5
45488: PUSH
45489: LD_INT 7
45491: PUSH
45492: LD_INT 11
45494: PUSH
45495: LD_INT 12
45497: PUSH
45498: LD_INT 15
45500: PUSH
45501: LD_INT 16
45503: PUSH
45504: LD_INT 20
45506: PUSH
45507: LD_INT 21
45509: PUSH
45510: LD_INT 22
45512: PUSH
45513: LD_INT 23
45515: PUSH
45516: LD_INT 25
45518: PUSH
45519: LD_INT 26
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: PUSH
45538: LD_INT 101
45540: PUSH
45541: LD_INT 102
45543: PUSH
45544: LD_INT 103
45546: PUSH
45547: LD_INT 105
45549: PUSH
45550: LD_INT 106
45552: PUSH
45553: LD_INT 108
45555: PUSH
45556: LD_INT 112
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: PUSH
45568: EMPTY
45569: LIST
45570: LIST
45571: ST_TO_ADDR
45572: GO 47831
45574: LD_INT 8
45576: DOUBLE
45577: EQUAL
45578: IFTRUE 45582
45580: GO 45710
45582: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45583: LD_ADDR_VAR 0 1
45587: PUSH
45588: LD_INT 2
45590: PUSH
45591: LD_INT 4
45593: PUSH
45594: LD_INT 5
45596: PUSH
45597: LD_INT 6
45599: PUSH
45600: LD_INT 7
45602: PUSH
45603: LD_INT 8
45605: PUSH
45606: LD_INT 11
45608: PUSH
45609: LD_INT 12
45611: PUSH
45612: LD_INT 15
45614: PUSH
45615: LD_INT 16
45617: PUSH
45618: LD_INT 20
45620: PUSH
45621: LD_INT 21
45623: PUSH
45624: LD_INT 22
45626: PUSH
45627: LD_INT 23
45629: PUSH
45630: LD_INT 25
45632: PUSH
45633: LD_INT 26
45635: PUSH
45636: LD_INT 30
45638: PUSH
45639: LD_INT 31
45641: PUSH
45642: LD_INT 32
45644: PUSH
45645: LD_INT 36
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 101
45672: PUSH
45673: LD_INT 102
45675: PUSH
45676: LD_INT 103
45678: PUSH
45679: LD_INT 105
45681: PUSH
45682: LD_INT 106
45684: PUSH
45685: LD_INT 108
45687: PUSH
45688: LD_INT 109
45690: PUSH
45691: LD_INT 112
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: ST_TO_ADDR
45708: GO 47831
45710: LD_INT 9
45712: DOUBLE
45713: EQUAL
45714: IFTRUE 45718
45716: GO 45854
45718: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45719: LD_ADDR_VAR 0 1
45723: PUSH
45724: LD_INT 2
45726: PUSH
45727: LD_INT 4
45729: PUSH
45730: LD_INT 5
45732: PUSH
45733: LD_INT 6
45735: PUSH
45736: LD_INT 7
45738: PUSH
45739: LD_INT 8
45741: PUSH
45742: LD_INT 11
45744: PUSH
45745: LD_INT 12
45747: PUSH
45748: LD_INT 15
45750: PUSH
45751: LD_INT 16
45753: PUSH
45754: LD_INT 20
45756: PUSH
45757: LD_INT 21
45759: PUSH
45760: LD_INT 22
45762: PUSH
45763: LD_INT 23
45765: PUSH
45766: LD_INT 25
45768: PUSH
45769: LD_INT 26
45771: PUSH
45772: LD_INT 28
45774: PUSH
45775: LD_INT 30
45777: PUSH
45778: LD_INT 31
45780: PUSH
45781: LD_INT 32
45783: PUSH
45784: LD_INT 36
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: PUSH
45810: LD_INT 101
45812: PUSH
45813: LD_INT 102
45815: PUSH
45816: LD_INT 103
45818: PUSH
45819: LD_INT 105
45821: PUSH
45822: LD_INT 106
45824: PUSH
45825: LD_INT 108
45827: PUSH
45828: LD_INT 109
45830: PUSH
45831: LD_INT 112
45833: PUSH
45834: LD_INT 114
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: ST_TO_ADDR
45852: GO 47831
45854: LD_INT 10
45856: DOUBLE
45857: EQUAL
45858: IFTRUE 45862
45860: GO 46046
45862: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45863: LD_ADDR_VAR 0 1
45867: PUSH
45868: LD_INT 2
45870: PUSH
45871: LD_INT 4
45873: PUSH
45874: LD_INT 5
45876: PUSH
45877: LD_INT 6
45879: PUSH
45880: LD_INT 7
45882: PUSH
45883: LD_INT 8
45885: PUSH
45886: LD_INT 9
45888: PUSH
45889: LD_INT 10
45891: PUSH
45892: LD_INT 11
45894: PUSH
45895: LD_INT 12
45897: PUSH
45898: LD_INT 13
45900: PUSH
45901: LD_INT 14
45903: PUSH
45904: LD_INT 15
45906: PUSH
45907: LD_INT 16
45909: PUSH
45910: LD_INT 17
45912: PUSH
45913: LD_INT 18
45915: PUSH
45916: LD_INT 19
45918: PUSH
45919: LD_INT 20
45921: PUSH
45922: LD_INT 21
45924: PUSH
45925: LD_INT 22
45927: PUSH
45928: LD_INT 23
45930: PUSH
45931: LD_INT 24
45933: PUSH
45934: LD_INT 25
45936: PUSH
45937: LD_INT 26
45939: PUSH
45940: LD_INT 28
45942: PUSH
45943: LD_INT 30
45945: PUSH
45946: LD_INT 31
45948: PUSH
45949: LD_INT 32
45951: PUSH
45952: LD_INT 36
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 101
45988: PUSH
45989: LD_INT 102
45991: PUSH
45992: LD_INT 103
45994: PUSH
45995: LD_INT 104
45997: PUSH
45998: LD_INT 105
46000: PUSH
46001: LD_INT 106
46003: PUSH
46004: LD_INT 107
46006: PUSH
46007: LD_INT 108
46009: PUSH
46010: LD_INT 109
46012: PUSH
46013: LD_INT 110
46015: PUSH
46016: LD_INT 111
46018: PUSH
46019: LD_INT 112
46021: PUSH
46022: LD_INT 114
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: ST_TO_ADDR
46044: GO 47831
46046: LD_INT 11
46048: DOUBLE
46049: EQUAL
46050: IFTRUE 46054
46052: GO 46246
46054: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46055: LD_ADDR_VAR 0 1
46059: PUSH
46060: LD_INT 2
46062: PUSH
46063: LD_INT 3
46065: PUSH
46066: LD_INT 4
46068: PUSH
46069: LD_INT 5
46071: PUSH
46072: LD_INT 6
46074: PUSH
46075: LD_INT 7
46077: PUSH
46078: LD_INT 8
46080: PUSH
46081: LD_INT 9
46083: PUSH
46084: LD_INT 10
46086: PUSH
46087: LD_INT 11
46089: PUSH
46090: LD_INT 12
46092: PUSH
46093: LD_INT 13
46095: PUSH
46096: LD_INT 14
46098: PUSH
46099: LD_INT 15
46101: PUSH
46102: LD_INT 16
46104: PUSH
46105: LD_INT 17
46107: PUSH
46108: LD_INT 18
46110: PUSH
46111: LD_INT 19
46113: PUSH
46114: LD_INT 20
46116: PUSH
46117: LD_INT 21
46119: PUSH
46120: LD_INT 22
46122: PUSH
46123: LD_INT 23
46125: PUSH
46126: LD_INT 24
46128: PUSH
46129: LD_INT 25
46131: PUSH
46132: LD_INT 26
46134: PUSH
46135: LD_INT 28
46137: PUSH
46138: LD_INT 30
46140: PUSH
46141: LD_INT 31
46143: PUSH
46144: LD_INT 32
46146: PUSH
46147: LD_INT 34
46149: PUSH
46150: LD_INT 36
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: PUSH
46186: LD_INT 101
46188: PUSH
46189: LD_INT 102
46191: PUSH
46192: LD_INT 103
46194: PUSH
46195: LD_INT 104
46197: PUSH
46198: LD_INT 105
46200: PUSH
46201: LD_INT 106
46203: PUSH
46204: LD_INT 107
46206: PUSH
46207: LD_INT 108
46209: PUSH
46210: LD_INT 109
46212: PUSH
46213: LD_INT 110
46215: PUSH
46216: LD_INT 111
46218: PUSH
46219: LD_INT 112
46221: PUSH
46222: LD_INT 114
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: ST_TO_ADDR
46244: GO 47831
46246: LD_INT 12
46248: DOUBLE
46249: EQUAL
46250: IFTRUE 46254
46252: GO 46462
46254: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46255: LD_ADDR_VAR 0 1
46259: PUSH
46260: LD_INT 1
46262: PUSH
46263: LD_INT 2
46265: PUSH
46266: LD_INT 3
46268: PUSH
46269: LD_INT 4
46271: PUSH
46272: LD_INT 5
46274: PUSH
46275: LD_INT 6
46277: PUSH
46278: LD_INT 7
46280: PUSH
46281: LD_INT 8
46283: PUSH
46284: LD_INT 9
46286: PUSH
46287: LD_INT 10
46289: PUSH
46290: LD_INT 11
46292: PUSH
46293: LD_INT 12
46295: PUSH
46296: LD_INT 13
46298: PUSH
46299: LD_INT 14
46301: PUSH
46302: LD_INT 15
46304: PUSH
46305: LD_INT 16
46307: PUSH
46308: LD_INT 17
46310: PUSH
46311: LD_INT 18
46313: PUSH
46314: LD_INT 19
46316: PUSH
46317: LD_INT 20
46319: PUSH
46320: LD_INT 21
46322: PUSH
46323: LD_INT 22
46325: PUSH
46326: LD_INT 23
46328: PUSH
46329: LD_INT 24
46331: PUSH
46332: LD_INT 25
46334: PUSH
46335: LD_INT 26
46337: PUSH
46338: LD_INT 27
46340: PUSH
46341: LD_INT 28
46343: PUSH
46344: LD_INT 30
46346: PUSH
46347: LD_INT 31
46349: PUSH
46350: LD_INT 32
46352: PUSH
46353: LD_INT 33
46355: PUSH
46356: LD_INT 34
46358: PUSH
46359: LD_INT 36
46361: PUSH
46362: EMPTY
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: PUSH
46398: LD_INT 101
46400: PUSH
46401: LD_INT 102
46403: PUSH
46404: LD_INT 103
46406: PUSH
46407: LD_INT 104
46409: PUSH
46410: LD_INT 105
46412: PUSH
46413: LD_INT 106
46415: PUSH
46416: LD_INT 107
46418: PUSH
46419: LD_INT 108
46421: PUSH
46422: LD_INT 109
46424: PUSH
46425: LD_INT 110
46427: PUSH
46428: LD_INT 111
46430: PUSH
46431: LD_INT 112
46433: PUSH
46434: LD_INT 113
46436: PUSH
46437: LD_INT 114
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: PUSH
46456: EMPTY
46457: LIST
46458: LIST
46459: ST_TO_ADDR
46460: GO 47831
46462: LD_INT 13
46464: DOUBLE
46465: EQUAL
46466: IFTRUE 46470
46468: GO 46666
46470: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46471: LD_ADDR_VAR 0 1
46475: PUSH
46476: LD_INT 1
46478: PUSH
46479: LD_INT 2
46481: PUSH
46482: LD_INT 3
46484: PUSH
46485: LD_INT 4
46487: PUSH
46488: LD_INT 5
46490: PUSH
46491: LD_INT 8
46493: PUSH
46494: LD_INT 9
46496: PUSH
46497: LD_INT 10
46499: PUSH
46500: LD_INT 11
46502: PUSH
46503: LD_INT 12
46505: PUSH
46506: LD_INT 14
46508: PUSH
46509: LD_INT 15
46511: PUSH
46512: LD_INT 16
46514: PUSH
46515: LD_INT 17
46517: PUSH
46518: LD_INT 18
46520: PUSH
46521: LD_INT 19
46523: PUSH
46524: LD_INT 20
46526: PUSH
46527: LD_INT 21
46529: PUSH
46530: LD_INT 22
46532: PUSH
46533: LD_INT 23
46535: PUSH
46536: LD_INT 24
46538: PUSH
46539: LD_INT 25
46541: PUSH
46542: LD_INT 26
46544: PUSH
46545: LD_INT 27
46547: PUSH
46548: LD_INT 28
46550: PUSH
46551: LD_INT 30
46553: PUSH
46554: LD_INT 31
46556: PUSH
46557: LD_INT 32
46559: PUSH
46560: LD_INT 33
46562: PUSH
46563: LD_INT 34
46565: PUSH
46566: LD_INT 36
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: PUSH
46602: LD_INT 101
46604: PUSH
46605: LD_INT 102
46607: PUSH
46608: LD_INT 103
46610: PUSH
46611: LD_INT 104
46613: PUSH
46614: LD_INT 105
46616: PUSH
46617: LD_INT 106
46619: PUSH
46620: LD_INT 107
46622: PUSH
46623: LD_INT 108
46625: PUSH
46626: LD_INT 109
46628: PUSH
46629: LD_INT 110
46631: PUSH
46632: LD_INT 111
46634: PUSH
46635: LD_INT 112
46637: PUSH
46638: LD_INT 113
46640: PUSH
46641: LD_INT 114
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: LIST
46648: LIST
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: ST_TO_ADDR
46664: GO 47831
46666: LD_INT 14
46668: DOUBLE
46669: EQUAL
46670: IFTRUE 46674
46672: GO 46886
46674: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46675: LD_ADDR_VAR 0 1
46679: PUSH
46680: LD_INT 1
46682: PUSH
46683: LD_INT 2
46685: PUSH
46686: LD_INT 3
46688: PUSH
46689: LD_INT 4
46691: PUSH
46692: LD_INT 5
46694: PUSH
46695: LD_INT 6
46697: PUSH
46698: LD_INT 7
46700: PUSH
46701: LD_INT 8
46703: PUSH
46704: LD_INT 9
46706: PUSH
46707: LD_INT 10
46709: PUSH
46710: LD_INT 11
46712: PUSH
46713: LD_INT 12
46715: PUSH
46716: LD_INT 13
46718: PUSH
46719: LD_INT 14
46721: PUSH
46722: LD_INT 15
46724: PUSH
46725: LD_INT 16
46727: PUSH
46728: LD_INT 17
46730: PUSH
46731: LD_INT 18
46733: PUSH
46734: LD_INT 19
46736: PUSH
46737: LD_INT 20
46739: PUSH
46740: LD_INT 21
46742: PUSH
46743: LD_INT 22
46745: PUSH
46746: LD_INT 23
46748: PUSH
46749: LD_INT 24
46751: PUSH
46752: LD_INT 25
46754: PUSH
46755: LD_INT 26
46757: PUSH
46758: LD_INT 27
46760: PUSH
46761: LD_INT 28
46763: PUSH
46764: LD_INT 29
46766: PUSH
46767: LD_INT 30
46769: PUSH
46770: LD_INT 31
46772: PUSH
46773: LD_INT 32
46775: PUSH
46776: LD_INT 33
46778: PUSH
46779: LD_INT 34
46781: PUSH
46782: LD_INT 36
46784: PUSH
46785: EMPTY
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 101
46824: PUSH
46825: LD_INT 102
46827: PUSH
46828: LD_INT 103
46830: PUSH
46831: LD_INT 104
46833: PUSH
46834: LD_INT 105
46836: PUSH
46837: LD_INT 106
46839: PUSH
46840: LD_INT 107
46842: PUSH
46843: LD_INT 108
46845: PUSH
46846: LD_INT 109
46848: PUSH
46849: LD_INT 110
46851: PUSH
46852: LD_INT 111
46854: PUSH
46855: LD_INT 112
46857: PUSH
46858: LD_INT 113
46860: PUSH
46861: LD_INT 114
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: ST_TO_ADDR
46884: GO 47831
46886: LD_INT 15
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 47106
46894: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46895: LD_ADDR_VAR 0 1
46899: PUSH
46900: LD_INT 1
46902: PUSH
46903: LD_INT 2
46905: PUSH
46906: LD_INT 3
46908: PUSH
46909: LD_INT 4
46911: PUSH
46912: LD_INT 5
46914: PUSH
46915: LD_INT 6
46917: PUSH
46918: LD_INT 7
46920: PUSH
46921: LD_INT 8
46923: PUSH
46924: LD_INT 9
46926: PUSH
46927: LD_INT 10
46929: PUSH
46930: LD_INT 11
46932: PUSH
46933: LD_INT 12
46935: PUSH
46936: LD_INT 13
46938: PUSH
46939: LD_INT 14
46941: PUSH
46942: LD_INT 15
46944: PUSH
46945: LD_INT 16
46947: PUSH
46948: LD_INT 17
46950: PUSH
46951: LD_INT 18
46953: PUSH
46954: LD_INT 19
46956: PUSH
46957: LD_INT 20
46959: PUSH
46960: LD_INT 21
46962: PUSH
46963: LD_INT 22
46965: PUSH
46966: LD_INT 23
46968: PUSH
46969: LD_INT 24
46971: PUSH
46972: LD_INT 25
46974: PUSH
46975: LD_INT 26
46977: PUSH
46978: LD_INT 27
46980: PUSH
46981: LD_INT 28
46983: PUSH
46984: LD_INT 29
46986: PUSH
46987: LD_INT 30
46989: PUSH
46990: LD_INT 31
46992: PUSH
46993: LD_INT 32
46995: PUSH
46996: LD_INT 33
46998: PUSH
46999: LD_INT 34
47001: PUSH
47002: LD_INT 36
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: LIST
47012: LIST
47013: LIST
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: PUSH
47042: LD_INT 101
47044: PUSH
47045: LD_INT 102
47047: PUSH
47048: LD_INT 103
47050: PUSH
47051: LD_INT 104
47053: PUSH
47054: LD_INT 105
47056: PUSH
47057: LD_INT 106
47059: PUSH
47060: LD_INT 107
47062: PUSH
47063: LD_INT 108
47065: PUSH
47066: LD_INT 109
47068: PUSH
47069: LD_INT 110
47071: PUSH
47072: LD_INT 111
47074: PUSH
47075: LD_INT 112
47077: PUSH
47078: LD_INT 113
47080: PUSH
47081: LD_INT 114
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: ST_TO_ADDR
47104: GO 47831
47106: LD_INT 16
47108: DOUBLE
47109: EQUAL
47110: IFTRUE 47114
47112: GO 47238
47114: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47115: LD_ADDR_VAR 0 1
47119: PUSH
47120: LD_INT 2
47122: PUSH
47123: LD_INT 4
47125: PUSH
47126: LD_INT 5
47128: PUSH
47129: LD_INT 7
47131: PUSH
47132: LD_INT 11
47134: PUSH
47135: LD_INT 12
47137: PUSH
47138: LD_INT 15
47140: PUSH
47141: LD_INT 16
47143: PUSH
47144: LD_INT 20
47146: PUSH
47147: LD_INT 21
47149: PUSH
47150: LD_INT 22
47152: PUSH
47153: LD_INT 23
47155: PUSH
47156: LD_INT 25
47158: PUSH
47159: LD_INT 26
47161: PUSH
47162: LD_INT 30
47164: PUSH
47165: LD_INT 31
47167: PUSH
47168: LD_INT 32
47170: PUSH
47171: LD_INT 33
47173: PUSH
47174: LD_INT 34
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: PUSH
47198: LD_INT 101
47200: PUSH
47201: LD_INT 102
47203: PUSH
47204: LD_INT 103
47206: PUSH
47207: LD_INT 106
47209: PUSH
47210: LD_INT 108
47212: PUSH
47213: LD_INT 112
47215: PUSH
47216: LD_INT 113
47218: PUSH
47219: LD_INT 114
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: PUSH
47232: EMPTY
47233: LIST
47234: LIST
47235: ST_TO_ADDR
47236: GO 47831
47238: LD_INT 17
47240: DOUBLE
47241: EQUAL
47242: IFTRUE 47246
47244: GO 47458
47246: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47247: LD_ADDR_VAR 0 1
47251: PUSH
47252: LD_INT 1
47254: PUSH
47255: LD_INT 2
47257: PUSH
47258: LD_INT 3
47260: PUSH
47261: LD_INT 4
47263: PUSH
47264: LD_INT 5
47266: PUSH
47267: LD_INT 6
47269: PUSH
47270: LD_INT 7
47272: PUSH
47273: LD_INT 8
47275: PUSH
47276: LD_INT 9
47278: PUSH
47279: LD_INT 10
47281: PUSH
47282: LD_INT 11
47284: PUSH
47285: LD_INT 12
47287: PUSH
47288: LD_INT 13
47290: PUSH
47291: LD_INT 14
47293: PUSH
47294: LD_INT 15
47296: PUSH
47297: LD_INT 16
47299: PUSH
47300: LD_INT 17
47302: PUSH
47303: LD_INT 18
47305: PUSH
47306: LD_INT 19
47308: PUSH
47309: LD_INT 20
47311: PUSH
47312: LD_INT 21
47314: PUSH
47315: LD_INT 22
47317: PUSH
47318: LD_INT 23
47320: PUSH
47321: LD_INT 24
47323: PUSH
47324: LD_INT 25
47326: PUSH
47327: LD_INT 26
47329: PUSH
47330: LD_INT 27
47332: PUSH
47333: LD_INT 28
47335: PUSH
47336: LD_INT 29
47338: PUSH
47339: LD_INT 30
47341: PUSH
47342: LD_INT 31
47344: PUSH
47345: LD_INT 32
47347: PUSH
47348: LD_INT 33
47350: PUSH
47351: LD_INT 34
47353: PUSH
47354: LD_INT 36
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: LIST
47361: LIST
47362: LIST
47363: LIST
47364: LIST
47365: LIST
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: PUSH
47394: LD_INT 101
47396: PUSH
47397: LD_INT 102
47399: PUSH
47400: LD_INT 103
47402: PUSH
47403: LD_INT 104
47405: PUSH
47406: LD_INT 105
47408: PUSH
47409: LD_INT 106
47411: PUSH
47412: LD_INT 107
47414: PUSH
47415: LD_INT 108
47417: PUSH
47418: LD_INT 109
47420: PUSH
47421: LD_INT 110
47423: PUSH
47424: LD_INT 111
47426: PUSH
47427: LD_INT 112
47429: PUSH
47430: LD_INT 113
47432: PUSH
47433: LD_INT 114
47435: PUSH
47436: EMPTY
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: ST_TO_ADDR
47456: GO 47831
47458: LD_INT 18
47460: DOUBLE
47461: EQUAL
47462: IFTRUE 47466
47464: GO 47602
47466: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47467: LD_ADDR_VAR 0 1
47471: PUSH
47472: LD_INT 2
47474: PUSH
47475: LD_INT 4
47477: PUSH
47478: LD_INT 5
47480: PUSH
47481: LD_INT 7
47483: PUSH
47484: LD_INT 11
47486: PUSH
47487: LD_INT 12
47489: PUSH
47490: LD_INT 15
47492: PUSH
47493: LD_INT 16
47495: PUSH
47496: LD_INT 20
47498: PUSH
47499: LD_INT 21
47501: PUSH
47502: LD_INT 22
47504: PUSH
47505: LD_INT 23
47507: PUSH
47508: LD_INT 25
47510: PUSH
47511: LD_INT 26
47513: PUSH
47514: LD_INT 30
47516: PUSH
47517: LD_INT 31
47519: PUSH
47520: LD_INT 32
47522: PUSH
47523: LD_INT 33
47525: PUSH
47526: LD_INT 34
47528: PUSH
47529: LD_INT 35
47531: PUSH
47532: LD_INT 36
47534: PUSH
47535: EMPTY
47536: LIST
47537: LIST
47538: LIST
47539: LIST
47540: LIST
47541: LIST
47542: LIST
47543: LIST
47544: LIST
47545: LIST
47546: LIST
47547: LIST
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: PUSH
47558: LD_INT 101
47560: PUSH
47561: LD_INT 102
47563: PUSH
47564: LD_INT 103
47566: PUSH
47567: LD_INT 106
47569: PUSH
47570: LD_INT 108
47572: PUSH
47573: LD_INT 112
47575: PUSH
47576: LD_INT 113
47578: PUSH
47579: LD_INT 114
47581: PUSH
47582: LD_INT 115
47584: PUSH
47585: EMPTY
47586: LIST
47587: LIST
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: ST_TO_ADDR
47600: GO 47831
47602: LD_INT 19
47604: DOUBLE
47605: EQUAL
47606: IFTRUE 47610
47608: GO 47830
47610: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47611: LD_ADDR_VAR 0 1
47615: PUSH
47616: LD_INT 1
47618: PUSH
47619: LD_INT 2
47621: PUSH
47622: LD_INT 3
47624: PUSH
47625: LD_INT 4
47627: PUSH
47628: LD_INT 5
47630: PUSH
47631: LD_INT 6
47633: PUSH
47634: LD_INT 7
47636: PUSH
47637: LD_INT 8
47639: PUSH
47640: LD_INT 9
47642: PUSH
47643: LD_INT 10
47645: PUSH
47646: LD_INT 11
47648: PUSH
47649: LD_INT 12
47651: PUSH
47652: LD_INT 13
47654: PUSH
47655: LD_INT 14
47657: PUSH
47658: LD_INT 15
47660: PUSH
47661: LD_INT 16
47663: PUSH
47664: LD_INT 17
47666: PUSH
47667: LD_INT 18
47669: PUSH
47670: LD_INT 19
47672: PUSH
47673: LD_INT 20
47675: PUSH
47676: LD_INT 21
47678: PUSH
47679: LD_INT 22
47681: PUSH
47682: LD_INT 23
47684: PUSH
47685: LD_INT 24
47687: PUSH
47688: LD_INT 25
47690: PUSH
47691: LD_INT 26
47693: PUSH
47694: LD_INT 27
47696: PUSH
47697: LD_INT 28
47699: PUSH
47700: LD_INT 29
47702: PUSH
47703: LD_INT 30
47705: PUSH
47706: LD_INT 31
47708: PUSH
47709: LD_INT 32
47711: PUSH
47712: LD_INT 33
47714: PUSH
47715: LD_INT 34
47717: PUSH
47718: LD_INT 35
47720: PUSH
47721: LD_INT 36
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: LIST
47728: LIST
47729: LIST
47730: LIST
47731: LIST
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 101
47764: PUSH
47765: LD_INT 102
47767: PUSH
47768: LD_INT 103
47770: PUSH
47771: LD_INT 104
47773: PUSH
47774: LD_INT 105
47776: PUSH
47777: LD_INT 106
47779: PUSH
47780: LD_INT 107
47782: PUSH
47783: LD_INT 108
47785: PUSH
47786: LD_INT 109
47788: PUSH
47789: LD_INT 110
47791: PUSH
47792: LD_INT 111
47794: PUSH
47795: LD_INT 112
47797: PUSH
47798: LD_INT 113
47800: PUSH
47801: LD_INT 114
47803: PUSH
47804: LD_INT 115
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: ST_TO_ADDR
47828: GO 47831
47830: POP
// end else
47831: GO 48050
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47833: LD_ADDR_VAR 0 1
47837: PUSH
47838: LD_INT 1
47840: PUSH
47841: LD_INT 2
47843: PUSH
47844: LD_INT 3
47846: PUSH
47847: LD_INT 4
47849: PUSH
47850: LD_INT 5
47852: PUSH
47853: LD_INT 6
47855: PUSH
47856: LD_INT 7
47858: PUSH
47859: LD_INT 8
47861: PUSH
47862: LD_INT 9
47864: PUSH
47865: LD_INT 10
47867: PUSH
47868: LD_INT 11
47870: PUSH
47871: LD_INT 12
47873: PUSH
47874: LD_INT 13
47876: PUSH
47877: LD_INT 14
47879: PUSH
47880: LD_INT 15
47882: PUSH
47883: LD_INT 16
47885: PUSH
47886: LD_INT 17
47888: PUSH
47889: LD_INT 18
47891: PUSH
47892: LD_INT 19
47894: PUSH
47895: LD_INT 20
47897: PUSH
47898: LD_INT 21
47900: PUSH
47901: LD_INT 22
47903: PUSH
47904: LD_INT 23
47906: PUSH
47907: LD_INT 24
47909: PUSH
47910: LD_INT 25
47912: PUSH
47913: LD_INT 26
47915: PUSH
47916: LD_INT 27
47918: PUSH
47919: LD_INT 28
47921: PUSH
47922: LD_INT 29
47924: PUSH
47925: LD_INT 30
47927: PUSH
47928: LD_INT 31
47930: PUSH
47931: LD_INT 32
47933: PUSH
47934: LD_INT 33
47936: PUSH
47937: LD_INT 34
47939: PUSH
47940: LD_INT 35
47942: PUSH
47943: LD_INT 36
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: PUSH
47984: LD_INT 101
47986: PUSH
47987: LD_INT 102
47989: PUSH
47990: LD_INT 103
47992: PUSH
47993: LD_INT 104
47995: PUSH
47996: LD_INT 105
47998: PUSH
47999: LD_INT 106
48001: PUSH
48002: LD_INT 107
48004: PUSH
48005: LD_INT 108
48007: PUSH
48008: LD_INT 109
48010: PUSH
48011: LD_INT 110
48013: PUSH
48014: LD_INT 111
48016: PUSH
48017: LD_INT 112
48019: PUSH
48020: LD_INT 113
48022: PUSH
48023: LD_INT 114
48025: PUSH
48026: LD_INT 115
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: ST_TO_ADDR
// if result then
48050: LD_VAR 0 1
48054: IFFALSE 48343
// begin normal :=  ;
48056: LD_ADDR_VAR 0 3
48060: PUSH
48061: LD_STRING 
48063: ST_TO_ADDR
// hardcore :=  ;
48064: LD_ADDR_VAR 0 4
48068: PUSH
48069: LD_STRING 
48071: ST_TO_ADDR
// for i = 1 to normalCounter do
48072: LD_ADDR_VAR 0 5
48076: PUSH
48077: DOUBLE
48078: LD_INT 1
48080: DEC
48081: ST_TO_ADDR
48082: LD_EXP 93
48086: PUSH
48087: FOR_TO
48088: IFFALSE 48189
// begin tmp := 0 ;
48090: LD_ADDR_VAR 0 2
48094: PUSH
48095: LD_STRING 0
48097: ST_TO_ADDR
// if result [ 1 ] then
48098: LD_VAR 0 1
48102: PUSH
48103: LD_INT 1
48105: ARRAY
48106: IFFALSE 48171
// if result [ 1 ] [ 1 ] = i then
48108: LD_VAR 0 1
48112: PUSH
48113: LD_INT 1
48115: ARRAY
48116: PUSH
48117: LD_INT 1
48119: ARRAY
48120: PUSH
48121: LD_VAR 0 5
48125: EQUAL
48126: IFFALSE 48171
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48128: LD_ADDR_VAR 0 1
48132: PUSH
48133: LD_VAR 0 1
48137: PPUSH
48138: LD_INT 1
48140: PPUSH
48141: LD_VAR 0 1
48145: PUSH
48146: LD_INT 1
48148: ARRAY
48149: PPUSH
48150: LD_INT 1
48152: PPUSH
48153: CALL_OW 3
48157: PPUSH
48158: CALL_OW 1
48162: ST_TO_ADDR
// tmp := 1 ;
48163: LD_ADDR_VAR 0 2
48167: PUSH
48168: LD_STRING 1
48170: ST_TO_ADDR
// end ; normal := normal & tmp ;
48171: LD_ADDR_VAR 0 3
48175: PUSH
48176: LD_VAR 0 3
48180: PUSH
48181: LD_VAR 0 2
48185: STR
48186: ST_TO_ADDR
// end ;
48187: GO 48087
48189: POP
48190: POP
// for i = 1 to hardcoreCounter do
48191: LD_ADDR_VAR 0 5
48195: PUSH
48196: DOUBLE
48197: LD_INT 1
48199: DEC
48200: ST_TO_ADDR
48201: LD_EXP 94
48205: PUSH
48206: FOR_TO
48207: IFFALSE 48312
// begin tmp := 0 ;
48209: LD_ADDR_VAR 0 2
48213: PUSH
48214: LD_STRING 0
48216: ST_TO_ADDR
// if result [ 2 ] then
48217: LD_VAR 0 1
48221: PUSH
48222: LD_INT 2
48224: ARRAY
48225: IFFALSE 48294
// if result [ 2 ] [ 1 ] = 100 + i then
48227: LD_VAR 0 1
48231: PUSH
48232: LD_INT 2
48234: ARRAY
48235: PUSH
48236: LD_INT 1
48238: ARRAY
48239: PUSH
48240: LD_INT 100
48242: PUSH
48243: LD_VAR 0 5
48247: PLUS
48248: EQUAL
48249: IFFALSE 48294
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48251: LD_ADDR_VAR 0 1
48255: PUSH
48256: LD_VAR 0 1
48260: PPUSH
48261: LD_INT 2
48263: PPUSH
48264: LD_VAR 0 1
48268: PUSH
48269: LD_INT 2
48271: ARRAY
48272: PPUSH
48273: LD_INT 1
48275: PPUSH
48276: CALL_OW 3
48280: PPUSH
48281: CALL_OW 1
48285: ST_TO_ADDR
// tmp := 1 ;
48286: LD_ADDR_VAR 0 2
48290: PUSH
48291: LD_STRING 1
48293: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48294: LD_ADDR_VAR 0 4
48298: PUSH
48299: LD_VAR 0 4
48303: PUSH
48304: LD_VAR 0 2
48308: STR
48309: ST_TO_ADDR
// end ;
48310: GO 48206
48312: POP
48313: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48314: LD_STRING getStreamItemsFromMission("
48316: PUSH
48317: LD_VAR 0 3
48321: STR
48322: PUSH
48323: LD_STRING ","
48325: STR
48326: PUSH
48327: LD_VAR 0 4
48331: STR
48332: PUSH
48333: LD_STRING ")
48335: STR
48336: PPUSH
48337: CALL_OW 559
// end else
48341: GO 48350
// ToLua ( getStreamItemsFromMission("","") ) ;
48343: LD_STRING getStreamItemsFromMission("","")
48345: PPUSH
48346: CALL_OW 559
// end ;
48350: LD_VAR 0 1
48354: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48355: LD_EXP 92
48359: PUSH
48360: LD_EXP 97
48364: AND
48365: IFFALSE 48489
48367: GO 48369
48369: DISABLE
48370: LD_INT 0
48372: PPUSH
48373: PPUSH
// begin enable ;
48374: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48375: LD_ADDR_VAR 0 2
48379: PUSH
48380: LD_INT 22
48382: PUSH
48383: LD_OWVAR 2
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: PUSH
48392: LD_INT 2
48394: PUSH
48395: LD_INT 34
48397: PUSH
48398: LD_INT 7
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: PUSH
48405: LD_INT 34
48407: PUSH
48408: LD_INT 45
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 34
48417: PUSH
48418: LD_INT 28
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: LD_INT 34
48427: PUSH
48428: LD_INT 47
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PPUSH
48446: CALL_OW 69
48450: ST_TO_ADDR
// if not tmp then
48451: LD_VAR 0 2
48455: NOT
48456: IFFALSE 48460
// exit ;
48458: GO 48489
// for i in tmp do
48460: LD_ADDR_VAR 0 1
48464: PUSH
48465: LD_VAR 0 2
48469: PUSH
48470: FOR_IN
48471: IFFALSE 48487
// begin SetLives ( i , 0 ) ;
48473: LD_VAR 0 1
48477: PPUSH
48478: LD_INT 0
48480: PPUSH
48481: CALL_OW 234
// end ;
48485: GO 48470
48487: POP
48488: POP
// end ;
48489: PPOPN 2
48491: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48492: LD_EXP 92
48496: PUSH
48497: LD_EXP 98
48501: AND
48502: IFFALSE 48586
48504: GO 48506
48506: DISABLE
48507: LD_INT 0
48509: PPUSH
48510: PPUSH
// begin enable ;
48511: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48512: LD_ADDR_VAR 0 2
48516: PUSH
48517: LD_INT 22
48519: PUSH
48520: LD_OWVAR 2
48524: PUSH
48525: EMPTY
48526: LIST
48527: LIST
48528: PUSH
48529: LD_INT 32
48531: PUSH
48532: LD_INT 3
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PPUSH
48543: CALL_OW 69
48547: ST_TO_ADDR
// if not tmp then
48548: LD_VAR 0 2
48552: NOT
48553: IFFALSE 48557
// exit ;
48555: GO 48586
// for i in tmp do
48557: LD_ADDR_VAR 0 1
48561: PUSH
48562: LD_VAR 0 2
48566: PUSH
48567: FOR_IN
48568: IFFALSE 48584
// begin SetLives ( i , 0 ) ;
48570: LD_VAR 0 1
48574: PPUSH
48575: LD_INT 0
48577: PPUSH
48578: CALL_OW 234
// end ;
48582: GO 48567
48584: POP
48585: POP
// end ;
48586: PPOPN 2
48588: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48589: LD_EXP 92
48593: PUSH
48594: LD_EXP 95
48598: AND
48599: IFFALSE 48692
48601: GO 48603
48603: DISABLE
48604: LD_INT 0
48606: PPUSH
// begin enable ;
48607: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48608: LD_ADDR_VAR 0 1
48612: PUSH
48613: LD_INT 22
48615: PUSH
48616: LD_OWVAR 2
48620: PUSH
48621: EMPTY
48622: LIST
48623: LIST
48624: PUSH
48625: LD_INT 2
48627: PUSH
48628: LD_INT 25
48630: PUSH
48631: LD_INT 5
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 25
48640: PUSH
48641: LD_INT 9
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: PUSH
48648: LD_INT 25
48650: PUSH
48651: LD_INT 8
48653: PUSH
48654: EMPTY
48655: LIST
48656: LIST
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: PPUSH
48668: CALL_OW 69
48672: PUSH
48673: FOR_IN
48674: IFFALSE 48690
// begin SetClass ( i , 1 ) ;
48676: LD_VAR 0 1
48680: PPUSH
48681: LD_INT 1
48683: PPUSH
48684: CALL_OW 336
// end ;
48688: GO 48673
48690: POP
48691: POP
// end ;
48692: PPOPN 1
48694: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48695: LD_EXP 92
48699: PUSH
48700: LD_EXP 96
48704: AND
48705: PUSH
48706: LD_OWVAR 65
48710: PUSH
48711: LD_INT 7
48713: LESS
48714: AND
48715: IFFALSE 48729
48717: GO 48719
48719: DISABLE
// begin enable ;
48720: ENABLE
// game_speed := 7 ;
48721: LD_ADDR_OWVAR 65
48725: PUSH
48726: LD_INT 7
48728: ST_TO_ADDR
// end ;
48729: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48730: LD_EXP 92
48734: PUSH
48735: LD_EXP 99
48739: AND
48740: IFFALSE 48942
48742: GO 48744
48744: DISABLE
48745: LD_INT 0
48747: PPUSH
48748: PPUSH
48749: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48750: LD_ADDR_VAR 0 3
48754: PUSH
48755: LD_INT 81
48757: PUSH
48758: LD_OWVAR 2
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 21
48769: PUSH
48770: LD_INT 1
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: PPUSH
48781: CALL_OW 69
48785: ST_TO_ADDR
// if not tmp then
48786: LD_VAR 0 3
48790: NOT
48791: IFFALSE 48795
// exit ;
48793: GO 48942
// if tmp > 5 then
48795: LD_VAR 0 3
48799: PUSH
48800: LD_INT 5
48802: GREATER
48803: IFFALSE 48815
// k := 5 else
48805: LD_ADDR_VAR 0 2
48809: PUSH
48810: LD_INT 5
48812: ST_TO_ADDR
48813: GO 48825
// k := tmp ;
48815: LD_ADDR_VAR 0 2
48819: PUSH
48820: LD_VAR 0 3
48824: ST_TO_ADDR
// for i := 1 to k do
48825: LD_ADDR_VAR 0 1
48829: PUSH
48830: DOUBLE
48831: LD_INT 1
48833: DEC
48834: ST_TO_ADDR
48835: LD_VAR 0 2
48839: PUSH
48840: FOR_TO
48841: IFFALSE 48940
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48843: LD_VAR 0 3
48847: PUSH
48848: LD_VAR 0 1
48852: ARRAY
48853: PPUSH
48854: LD_VAR 0 1
48858: PUSH
48859: LD_INT 4
48861: MOD
48862: PUSH
48863: LD_INT 1
48865: PLUS
48866: PPUSH
48867: CALL_OW 259
48871: PUSH
48872: LD_INT 10
48874: LESS
48875: IFFALSE 48938
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48877: LD_VAR 0 3
48881: PUSH
48882: LD_VAR 0 1
48886: ARRAY
48887: PPUSH
48888: LD_VAR 0 1
48892: PUSH
48893: LD_INT 4
48895: MOD
48896: PUSH
48897: LD_INT 1
48899: PLUS
48900: PPUSH
48901: LD_VAR 0 3
48905: PUSH
48906: LD_VAR 0 1
48910: ARRAY
48911: PPUSH
48912: LD_VAR 0 1
48916: PUSH
48917: LD_INT 4
48919: MOD
48920: PUSH
48921: LD_INT 1
48923: PLUS
48924: PPUSH
48925: CALL_OW 259
48929: PUSH
48930: LD_INT 1
48932: PLUS
48933: PPUSH
48934: CALL_OW 237
48938: GO 48840
48940: POP
48941: POP
// end ;
48942: PPOPN 3
48944: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
48945: LD_EXP 92
48949: PUSH
48950: LD_EXP 100
48954: AND
48955: IFFALSE 48975
48957: GO 48959
48959: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
48960: LD_INT 4
48962: PPUSH
48963: LD_OWVAR 2
48967: PPUSH
48968: LD_INT 0
48970: PPUSH
48971: CALL_OW 324
48975: END
// every 0 0$1 trigger StreamModeActive and sShovel do
48976: LD_EXP 92
48980: PUSH
48981: LD_EXP 129
48985: AND
48986: IFFALSE 49006
48988: GO 48990
48990: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
48991: LD_INT 19
48993: PPUSH
48994: LD_OWVAR 2
48998: PPUSH
48999: LD_INT 0
49001: PPUSH
49002: CALL_OW 324
49006: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49007: LD_EXP 92
49011: PUSH
49012: LD_EXP 101
49016: AND
49017: IFFALSE 49119
49019: GO 49021
49021: DISABLE
49022: LD_INT 0
49024: PPUSH
49025: PPUSH
// begin enable ;
49026: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49027: LD_ADDR_VAR 0 2
49031: PUSH
49032: LD_INT 22
49034: PUSH
49035: LD_OWVAR 2
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 2
49046: PUSH
49047: LD_INT 34
49049: PUSH
49050: LD_INT 11
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: PUSH
49057: LD_INT 34
49059: PUSH
49060: LD_INT 30
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: LIST
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PPUSH
49076: CALL_OW 69
49080: ST_TO_ADDR
// if not tmp then
49081: LD_VAR 0 2
49085: NOT
49086: IFFALSE 49090
// exit ;
49088: GO 49119
// for i in tmp do
49090: LD_ADDR_VAR 0 1
49094: PUSH
49095: LD_VAR 0 2
49099: PUSH
49100: FOR_IN
49101: IFFALSE 49117
// begin SetLives ( i , 0 ) ;
49103: LD_VAR 0 1
49107: PPUSH
49108: LD_INT 0
49110: PPUSH
49111: CALL_OW 234
// end ;
49115: GO 49100
49117: POP
49118: POP
// end ;
49119: PPOPN 2
49121: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49122: LD_EXP 92
49126: PUSH
49127: LD_EXP 102
49131: AND
49132: IFFALSE 49152
49134: GO 49136
49136: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49137: LD_INT 32
49139: PPUSH
49140: LD_OWVAR 2
49144: PPUSH
49145: LD_INT 0
49147: PPUSH
49148: CALL_OW 324
49152: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49153: LD_EXP 92
49157: PUSH
49158: LD_EXP 103
49162: AND
49163: IFFALSE 49344
49165: GO 49167
49167: DISABLE
49168: LD_INT 0
49170: PPUSH
49171: PPUSH
49172: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49173: LD_ADDR_VAR 0 2
49177: PUSH
49178: LD_INT 22
49180: PUSH
49181: LD_OWVAR 2
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 33
49192: PUSH
49193: LD_INT 3
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: PPUSH
49204: CALL_OW 69
49208: ST_TO_ADDR
// if not tmp then
49209: LD_VAR 0 2
49213: NOT
49214: IFFALSE 49218
// exit ;
49216: GO 49344
// side := 0 ;
49218: LD_ADDR_VAR 0 3
49222: PUSH
49223: LD_INT 0
49225: ST_TO_ADDR
// for i := 1 to 8 do
49226: LD_ADDR_VAR 0 1
49230: PUSH
49231: DOUBLE
49232: LD_INT 1
49234: DEC
49235: ST_TO_ADDR
49236: LD_INT 8
49238: PUSH
49239: FOR_TO
49240: IFFALSE 49288
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49242: LD_OWVAR 2
49246: PUSH
49247: LD_VAR 0 1
49251: NONEQUAL
49252: PUSH
49253: LD_OWVAR 2
49257: PPUSH
49258: LD_VAR 0 1
49262: PPUSH
49263: CALL_OW 81
49267: PUSH
49268: LD_INT 2
49270: EQUAL
49271: AND
49272: IFFALSE 49286
// begin side := i ;
49274: LD_ADDR_VAR 0 3
49278: PUSH
49279: LD_VAR 0 1
49283: ST_TO_ADDR
// break ;
49284: GO 49288
// end ;
49286: GO 49239
49288: POP
49289: POP
// if not side then
49290: LD_VAR 0 3
49294: NOT
49295: IFFALSE 49299
// exit ;
49297: GO 49344
// for i := 1 to tmp do
49299: LD_ADDR_VAR 0 1
49303: PUSH
49304: DOUBLE
49305: LD_INT 1
49307: DEC
49308: ST_TO_ADDR
49309: LD_VAR 0 2
49313: PUSH
49314: FOR_TO
49315: IFFALSE 49342
// if Prob ( 60 ) then
49317: LD_INT 60
49319: PPUSH
49320: CALL_OW 13
49324: IFFALSE 49340
// SetSide ( i , side ) ;
49326: LD_VAR 0 1
49330: PPUSH
49331: LD_VAR 0 3
49335: PPUSH
49336: CALL_OW 235
49340: GO 49314
49342: POP
49343: POP
// end ;
49344: PPOPN 3
49346: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49347: LD_EXP 92
49351: PUSH
49352: LD_EXP 105
49356: AND
49357: IFFALSE 49476
49359: GO 49361
49361: DISABLE
49362: LD_INT 0
49364: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49365: LD_ADDR_VAR 0 1
49369: PUSH
49370: LD_INT 22
49372: PUSH
49373: LD_OWVAR 2
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 21
49384: PUSH
49385: LD_INT 1
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 3
49394: PUSH
49395: LD_INT 23
49397: PUSH
49398: LD_INT 0
49400: PUSH
49401: EMPTY
49402: LIST
49403: LIST
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: LIST
49413: PPUSH
49414: CALL_OW 69
49418: PUSH
49419: FOR_IN
49420: IFFALSE 49474
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49422: LD_VAR 0 1
49426: PPUSH
49427: CALL_OW 257
49431: PUSH
49432: LD_INT 1
49434: PUSH
49435: LD_INT 2
49437: PUSH
49438: LD_INT 3
49440: PUSH
49441: LD_INT 4
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: IN
49450: IFFALSE 49472
// SetClass ( un , rand ( 1 , 4 ) ) ;
49452: LD_VAR 0 1
49456: PPUSH
49457: LD_INT 1
49459: PPUSH
49460: LD_INT 4
49462: PPUSH
49463: CALL_OW 12
49467: PPUSH
49468: CALL_OW 336
49472: GO 49419
49474: POP
49475: POP
// end ;
49476: PPOPN 1
49478: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49479: LD_EXP 92
49483: PUSH
49484: LD_EXP 104
49488: AND
49489: IFFALSE 49568
49491: GO 49493
49493: DISABLE
49494: LD_INT 0
49496: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49497: LD_ADDR_VAR 0 1
49501: PUSH
49502: LD_INT 22
49504: PUSH
49505: LD_OWVAR 2
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 21
49516: PUSH
49517: LD_INT 3
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PPUSH
49528: CALL_OW 69
49532: ST_TO_ADDR
// if not tmp then
49533: LD_VAR 0 1
49537: NOT
49538: IFFALSE 49542
// exit ;
49540: GO 49568
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49542: LD_VAR 0 1
49546: PUSH
49547: LD_INT 1
49549: PPUSH
49550: LD_VAR 0 1
49554: PPUSH
49555: CALL_OW 12
49559: ARRAY
49560: PPUSH
49561: LD_INT 100
49563: PPUSH
49564: CALL_OW 234
// end ;
49568: PPOPN 1
49570: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49571: LD_EXP 92
49575: PUSH
49576: LD_EXP 106
49580: AND
49581: IFFALSE 49679
49583: GO 49585
49585: DISABLE
49586: LD_INT 0
49588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49589: LD_ADDR_VAR 0 1
49593: PUSH
49594: LD_INT 22
49596: PUSH
49597: LD_OWVAR 2
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 21
49608: PUSH
49609: LD_INT 1
49611: PUSH
49612: EMPTY
49613: LIST
49614: LIST
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PPUSH
49620: CALL_OW 69
49624: ST_TO_ADDR
// if not tmp then
49625: LD_VAR 0 1
49629: NOT
49630: IFFALSE 49634
// exit ;
49632: GO 49679
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49634: LD_VAR 0 1
49638: PUSH
49639: LD_INT 1
49641: PPUSH
49642: LD_VAR 0 1
49646: PPUSH
49647: CALL_OW 12
49651: ARRAY
49652: PPUSH
49653: LD_INT 1
49655: PPUSH
49656: LD_INT 4
49658: PPUSH
49659: CALL_OW 12
49663: PPUSH
49664: LD_INT 3000
49666: PPUSH
49667: LD_INT 9000
49669: PPUSH
49670: CALL_OW 12
49674: PPUSH
49675: CALL_OW 492
// end ;
49679: PPOPN 1
49681: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49682: LD_EXP 92
49686: PUSH
49687: LD_EXP 107
49691: AND
49692: IFFALSE 49712
49694: GO 49696
49696: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49697: LD_INT 1
49699: PPUSH
49700: LD_OWVAR 2
49704: PPUSH
49705: LD_INT 0
49707: PPUSH
49708: CALL_OW 324
49712: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49713: LD_EXP 92
49717: PUSH
49718: LD_EXP 108
49722: AND
49723: IFFALSE 49806
49725: GO 49727
49727: DISABLE
49728: LD_INT 0
49730: PPUSH
49731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49732: LD_ADDR_VAR 0 2
49736: PUSH
49737: LD_INT 22
49739: PUSH
49740: LD_OWVAR 2
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: LD_INT 21
49751: PUSH
49752: LD_INT 3
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: EMPTY
49760: LIST
49761: LIST
49762: PPUSH
49763: CALL_OW 69
49767: ST_TO_ADDR
// if not tmp then
49768: LD_VAR 0 2
49772: NOT
49773: IFFALSE 49777
// exit ;
49775: GO 49806
// for i in tmp do
49777: LD_ADDR_VAR 0 1
49781: PUSH
49782: LD_VAR 0 2
49786: PUSH
49787: FOR_IN
49788: IFFALSE 49804
// SetBLevel ( i , 10 ) ;
49790: LD_VAR 0 1
49794: PPUSH
49795: LD_INT 10
49797: PPUSH
49798: CALL_OW 241
49802: GO 49787
49804: POP
49805: POP
// end ;
49806: PPOPN 2
49808: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49809: LD_EXP 92
49813: PUSH
49814: LD_EXP 109
49818: AND
49819: IFFALSE 49930
49821: GO 49823
49823: DISABLE
49824: LD_INT 0
49826: PPUSH
49827: PPUSH
49828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49829: LD_ADDR_VAR 0 3
49833: PUSH
49834: LD_INT 22
49836: PUSH
49837: LD_OWVAR 2
49841: PUSH
49842: EMPTY
49843: LIST
49844: LIST
49845: PUSH
49846: LD_INT 25
49848: PUSH
49849: LD_INT 1
49851: PUSH
49852: EMPTY
49853: LIST
49854: LIST
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PPUSH
49860: CALL_OW 69
49864: ST_TO_ADDR
// if not tmp then
49865: LD_VAR 0 3
49869: NOT
49870: IFFALSE 49874
// exit ;
49872: GO 49930
// un := tmp [ rand ( 1 , tmp ) ] ;
49874: LD_ADDR_VAR 0 2
49878: PUSH
49879: LD_VAR 0 3
49883: PUSH
49884: LD_INT 1
49886: PPUSH
49887: LD_VAR 0 3
49891: PPUSH
49892: CALL_OW 12
49896: ARRAY
49897: ST_TO_ADDR
// if Crawls ( un ) then
49898: LD_VAR 0 2
49902: PPUSH
49903: CALL_OW 318
49907: IFFALSE 49918
// ComWalk ( un ) ;
49909: LD_VAR 0 2
49913: PPUSH
49914: CALL_OW 138
// SetClass ( un , class_sniper ) ;
49918: LD_VAR 0 2
49922: PPUSH
49923: LD_INT 5
49925: PPUSH
49926: CALL_OW 336
// end ;
49930: PPOPN 3
49932: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
49933: LD_EXP 92
49937: PUSH
49938: LD_EXP 110
49942: AND
49943: PUSH
49944: LD_OWVAR 67
49948: PUSH
49949: LD_INT 3
49951: LESS
49952: AND
49953: IFFALSE 49972
49955: GO 49957
49957: DISABLE
// Difficulty := Difficulty + 1 ;
49958: LD_ADDR_OWVAR 67
49962: PUSH
49963: LD_OWVAR 67
49967: PUSH
49968: LD_INT 1
49970: PLUS
49971: ST_TO_ADDR
49972: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
49973: LD_EXP 92
49977: PUSH
49978: LD_EXP 111
49982: AND
49983: IFFALSE 50086
49985: GO 49987
49987: DISABLE
49988: LD_INT 0
49990: PPUSH
// begin for i := 1 to 5 do
49991: LD_ADDR_VAR 0 1
49995: PUSH
49996: DOUBLE
49997: LD_INT 1
49999: DEC
50000: ST_TO_ADDR
50001: LD_INT 5
50003: PUSH
50004: FOR_TO
50005: IFFALSE 50084
// begin uc_nation := nation_nature ;
50007: LD_ADDR_OWVAR 21
50011: PUSH
50012: LD_INT 0
50014: ST_TO_ADDR
// uc_side := 0 ;
50015: LD_ADDR_OWVAR 20
50019: PUSH
50020: LD_INT 0
50022: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50023: LD_ADDR_OWVAR 29
50027: PUSH
50028: LD_INT 12
50030: PUSH
50031: LD_INT 12
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: ST_TO_ADDR
// hc_agressivity := 20 ;
50038: LD_ADDR_OWVAR 35
50042: PUSH
50043: LD_INT 20
50045: ST_TO_ADDR
// hc_class := class_tiger ;
50046: LD_ADDR_OWVAR 28
50050: PUSH
50051: LD_INT 14
50053: ST_TO_ADDR
// hc_gallery :=  ;
50054: LD_ADDR_OWVAR 33
50058: PUSH
50059: LD_STRING 
50061: ST_TO_ADDR
// hc_name :=  ;
50062: LD_ADDR_OWVAR 26
50066: PUSH
50067: LD_STRING 
50069: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50070: CALL_OW 44
50074: PPUSH
50075: LD_INT 0
50077: PPUSH
50078: CALL_OW 51
// end ;
50082: GO 50004
50084: POP
50085: POP
// end ;
50086: PPOPN 1
50088: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50089: LD_EXP 92
50093: PUSH
50094: LD_EXP 112
50098: AND
50099: IFFALSE 50108
50101: GO 50103
50103: DISABLE
// StreamSibBomb ;
50104: CALL 50109 0 0
50108: END
// export function StreamSibBomb ; var i , x , y ; begin
50109: LD_INT 0
50111: PPUSH
50112: PPUSH
50113: PPUSH
50114: PPUSH
// result := false ;
50115: LD_ADDR_VAR 0 1
50119: PUSH
50120: LD_INT 0
50122: ST_TO_ADDR
// for i := 1 to 16 do
50123: LD_ADDR_VAR 0 2
50127: PUSH
50128: DOUBLE
50129: LD_INT 1
50131: DEC
50132: ST_TO_ADDR
50133: LD_INT 16
50135: PUSH
50136: FOR_TO
50137: IFFALSE 50336
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50139: LD_ADDR_VAR 0 3
50143: PUSH
50144: LD_INT 10
50146: PUSH
50147: LD_INT 20
50149: PUSH
50150: LD_INT 30
50152: PUSH
50153: LD_INT 40
50155: PUSH
50156: LD_INT 50
50158: PUSH
50159: LD_INT 60
50161: PUSH
50162: LD_INT 70
50164: PUSH
50165: LD_INT 80
50167: PUSH
50168: LD_INT 90
50170: PUSH
50171: LD_INT 100
50173: PUSH
50174: LD_INT 110
50176: PUSH
50177: LD_INT 120
50179: PUSH
50180: LD_INT 130
50182: PUSH
50183: LD_INT 140
50185: PUSH
50186: LD_INT 150
50188: PUSH
50189: EMPTY
50190: LIST
50191: LIST
50192: LIST
50193: LIST
50194: LIST
50195: LIST
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: LIST
50202: LIST
50203: LIST
50204: LIST
50205: PUSH
50206: LD_INT 1
50208: PPUSH
50209: LD_INT 15
50211: PPUSH
50212: CALL_OW 12
50216: ARRAY
50217: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50218: LD_ADDR_VAR 0 4
50222: PUSH
50223: LD_INT 10
50225: PUSH
50226: LD_INT 20
50228: PUSH
50229: LD_INT 30
50231: PUSH
50232: LD_INT 40
50234: PUSH
50235: LD_INT 50
50237: PUSH
50238: LD_INT 60
50240: PUSH
50241: LD_INT 70
50243: PUSH
50244: LD_INT 80
50246: PUSH
50247: LD_INT 90
50249: PUSH
50250: LD_INT 100
50252: PUSH
50253: LD_INT 110
50255: PUSH
50256: LD_INT 120
50258: PUSH
50259: LD_INT 130
50261: PUSH
50262: LD_INT 140
50264: PUSH
50265: LD_INT 150
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: PUSH
50285: LD_INT 1
50287: PPUSH
50288: LD_INT 15
50290: PPUSH
50291: CALL_OW 12
50295: ARRAY
50296: ST_TO_ADDR
// if ValidHex ( x , y ) then
50297: LD_VAR 0 3
50301: PPUSH
50302: LD_VAR 0 4
50306: PPUSH
50307: CALL_OW 488
50311: IFFALSE 50334
// begin result := [ x , y ] ;
50313: LD_ADDR_VAR 0 1
50317: PUSH
50318: LD_VAR 0 3
50322: PUSH
50323: LD_VAR 0 4
50327: PUSH
50328: EMPTY
50329: LIST
50330: LIST
50331: ST_TO_ADDR
// break ;
50332: GO 50336
// end ; end ;
50334: GO 50136
50336: POP
50337: POP
// if result then
50338: LD_VAR 0 1
50342: IFFALSE 50402
// begin ToLua ( playSibBomb() ) ;
50344: LD_STRING playSibBomb()
50346: PPUSH
50347: CALL_OW 559
// wait ( 0 0$14 ) ;
50351: LD_INT 490
50353: PPUSH
50354: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50358: LD_VAR 0 1
50362: PUSH
50363: LD_INT 1
50365: ARRAY
50366: PPUSH
50367: LD_VAR 0 1
50371: PUSH
50372: LD_INT 2
50374: ARRAY
50375: PPUSH
50376: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50380: LD_VAR 0 1
50384: PUSH
50385: LD_INT 1
50387: ARRAY
50388: PPUSH
50389: LD_VAR 0 1
50393: PUSH
50394: LD_INT 2
50396: ARRAY
50397: PPUSH
50398: CALL_OW 429
// end ; end ;
50402: LD_VAR 0 1
50406: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50407: LD_EXP 92
50411: PUSH
50412: LD_EXP 114
50416: AND
50417: IFFALSE 50429
50419: GO 50421
50421: DISABLE
// YouLost (  ) ;
50422: LD_STRING 
50424: PPUSH
50425: CALL_OW 104
50429: END
// every 0 0$1 trigger StreamModeActive and sFog do
50430: LD_EXP 92
50434: PUSH
50435: LD_EXP 113
50439: AND
50440: IFFALSE 50454
50442: GO 50444
50444: DISABLE
// FogOff ( your_side ) ;
50445: LD_OWVAR 2
50449: PPUSH
50450: CALL_OW 344
50454: END
// every 0 0$1 trigger StreamModeActive and sSun do
50455: LD_EXP 92
50459: PUSH
50460: LD_EXP 115
50464: AND
50465: IFFALSE 50493
50467: GO 50469
50469: DISABLE
// begin solar_recharge_percent := 0 ;
50470: LD_ADDR_OWVAR 79
50474: PUSH
50475: LD_INT 0
50477: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50478: LD_INT 10500
50480: PPUSH
50481: CALL_OW 67
// solar_recharge_percent := 100 ;
50485: LD_ADDR_OWVAR 79
50489: PUSH
50490: LD_INT 100
50492: ST_TO_ADDR
// end ;
50493: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50494: LD_EXP 92
50498: PUSH
50499: LD_EXP 116
50503: AND
50504: IFFALSE 50743
50506: GO 50508
50508: DISABLE
50509: LD_INT 0
50511: PPUSH
50512: PPUSH
50513: PPUSH
// begin tmp := [ ] ;
50514: LD_ADDR_VAR 0 3
50518: PUSH
50519: EMPTY
50520: ST_TO_ADDR
// for i := 1 to 6 do
50521: LD_ADDR_VAR 0 1
50525: PUSH
50526: DOUBLE
50527: LD_INT 1
50529: DEC
50530: ST_TO_ADDR
50531: LD_INT 6
50533: PUSH
50534: FOR_TO
50535: IFFALSE 50640
// begin uc_nation := nation_nature ;
50537: LD_ADDR_OWVAR 21
50541: PUSH
50542: LD_INT 0
50544: ST_TO_ADDR
// uc_side := 0 ;
50545: LD_ADDR_OWVAR 20
50549: PUSH
50550: LD_INT 0
50552: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50553: LD_ADDR_OWVAR 29
50557: PUSH
50558: LD_INT 12
50560: PUSH
50561: LD_INT 12
50563: PUSH
50564: EMPTY
50565: LIST
50566: LIST
50567: ST_TO_ADDR
// hc_agressivity := 20 ;
50568: LD_ADDR_OWVAR 35
50572: PUSH
50573: LD_INT 20
50575: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50576: LD_ADDR_OWVAR 28
50580: PUSH
50581: LD_INT 17
50583: ST_TO_ADDR
// hc_gallery :=  ;
50584: LD_ADDR_OWVAR 33
50588: PUSH
50589: LD_STRING 
50591: ST_TO_ADDR
// hc_name :=  ;
50592: LD_ADDR_OWVAR 26
50596: PUSH
50597: LD_STRING 
50599: ST_TO_ADDR
// un := CreateHuman ;
50600: LD_ADDR_VAR 0 2
50604: PUSH
50605: CALL_OW 44
50609: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50610: LD_VAR 0 2
50614: PPUSH
50615: LD_INT 1
50617: PPUSH
50618: CALL_OW 51
// tmp := tmp ^ un ;
50622: LD_ADDR_VAR 0 3
50626: PUSH
50627: LD_VAR 0 3
50631: PUSH
50632: LD_VAR 0 2
50636: ADD
50637: ST_TO_ADDR
// end ;
50638: GO 50534
50640: POP
50641: POP
// repeat wait ( 0 0$1 ) ;
50642: LD_INT 35
50644: PPUSH
50645: CALL_OW 67
// for un in tmp do
50649: LD_ADDR_VAR 0 2
50653: PUSH
50654: LD_VAR 0 3
50658: PUSH
50659: FOR_IN
50660: IFFALSE 50734
// begin if IsDead ( un ) then
50662: LD_VAR 0 2
50666: PPUSH
50667: CALL_OW 301
50671: IFFALSE 50691
// begin tmp := tmp diff un ;
50673: LD_ADDR_VAR 0 3
50677: PUSH
50678: LD_VAR 0 3
50682: PUSH
50683: LD_VAR 0 2
50687: DIFF
50688: ST_TO_ADDR
// continue ;
50689: GO 50659
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50691: LD_VAR 0 2
50695: PPUSH
50696: LD_INT 3
50698: PUSH
50699: LD_INT 22
50701: PUSH
50702: LD_INT 0
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: PUSH
50709: EMPTY
50710: LIST
50711: LIST
50712: PPUSH
50713: CALL_OW 69
50717: PPUSH
50718: LD_VAR 0 2
50722: PPUSH
50723: CALL_OW 74
50727: PPUSH
50728: CALL_OW 115
// end ;
50732: GO 50659
50734: POP
50735: POP
// until not tmp ;
50736: LD_VAR 0 3
50740: NOT
50741: IFFALSE 50642
// end ;
50743: PPOPN 3
50745: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50746: LD_EXP 92
50750: PUSH
50751: LD_EXP 117
50755: AND
50756: IFFALSE 50810
50758: GO 50760
50760: DISABLE
// begin ToLua ( displayTroll(); ) ;
50761: LD_STRING displayTroll();
50763: PPUSH
50764: CALL_OW 559
// wait ( 3 3$00 ) ;
50768: LD_INT 6300
50770: PPUSH
50771: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50775: LD_STRING hideTroll();
50777: PPUSH
50778: CALL_OW 559
// wait ( 1 1$00 ) ;
50782: LD_INT 2100
50784: PPUSH
50785: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50789: LD_STRING displayTroll();
50791: PPUSH
50792: CALL_OW 559
// wait ( 1 1$00 ) ;
50796: LD_INT 2100
50798: PPUSH
50799: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50803: LD_STRING hideTroll();
50805: PPUSH
50806: CALL_OW 559
// end ;
50810: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50811: LD_EXP 92
50815: PUSH
50816: LD_EXP 118
50820: AND
50821: IFFALSE 50884
50823: GO 50825
50825: DISABLE
50826: LD_INT 0
50828: PPUSH
// begin p := 0 ;
50829: LD_ADDR_VAR 0 1
50833: PUSH
50834: LD_INT 0
50836: ST_TO_ADDR
// repeat game_speed := 1 ;
50837: LD_ADDR_OWVAR 65
50841: PUSH
50842: LD_INT 1
50844: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50845: LD_INT 35
50847: PPUSH
50848: CALL_OW 67
// p := p + 1 ;
50852: LD_ADDR_VAR 0 1
50856: PUSH
50857: LD_VAR 0 1
50861: PUSH
50862: LD_INT 1
50864: PLUS
50865: ST_TO_ADDR
// until p >= 60 ;
50866: LD_VAR 0 1
50870: PUSH
50871: LD_INT 60
50873: GREATEREQUAL
50874: IFFALSE 50837
// game_speed := 4 ;
50876: LD_ADDR_OWVAR 65
50880: PUSH
50881: LD_INT 4
50883: ST_TO_ADDR
// end ;
50884: PPOPN 1
50886: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
50887: LD_EXP 92
50891: PUSH
50892: LD_EXP 119
50896: AND
50897: IFFALSE 51043
50899: GO 50901
50901: DISABLE
50902: LD_INT 0
50904: PPUSH
50905: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
50906: LD_ADDR_VAR 0 1
50910: PUSH
50911: LD_INT 22
50913: PUSH
50914: LD_OWVAR 2
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: PUSH
50923: LD_INT 2
50925: PUSH
50926: LD_INT 30
50928: PUSH
50929: LD_INT 0
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: PUSH
50936: LD_INT 30
50938: PUSH
50939: LD_INT 1
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: LIST
50950: PUSH
50951: EMPTY
50952: LIST
50953: LIST
50954: PPUSH
50955: CALL_OW 69
50959: ST_TO_ADDR
// if not depot then
50960: LD_VAR 0 1
50964: NOT
50965: IFFALSE 50969
// exit ;
50967: GO 51043
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
50969: LD_ADDR_VAR 0 2
50973: PUSH
50974: LD_VAR 0 1
50978: PUSH
50979: LD_INT 1
50981: PPUSH
50982: LD_VAR 0 1
50986: PPUSH
50987: CALL_OW 12
50991: ARRAY
50992: PPUSH
50993: CALL_OW 274
50997: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
50998: LD_VAR 0 2
51002: PPUSH
51003: LD_INT 1
51005: PPUSH
51006: LD_INT 0
51008: PPUSH
51009: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51013: LD_VAR 0 2
51017: PPUSH
51018: LD_INT 2
51020: PPUSH
51021: LD_INT 0
51023: PPUSH
51024: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51028: LD_VAR 0 2
51032: PPUSH
51033: LD_INT 3
51035: PPUSH
51036: LD_INT 0
51038: PPUSH
51039: CALL_OW 277
// end ;
51043: PPOPN 2
51045: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51046: LD_EXP 92
51050: PUSH
51051: LD_EXP 120
51055: AND
51056: IFFALSE 51153
51058: GO 51060
51060: DISABLE
51061: LD_INT 0
51063: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51064: LD_ADDR_VAR 0 1
51068: PUSH
51069: LD_INT 22
51071: PUSH
51072: LD_OWVAR 2
51076: PUSH
51077: EMPTY
51078: LIST
51079: LIST
51080: PUSH
51081: LD_INT 21
51083: PUSH
51084: LD_INT 1
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: LD_INT 3
51093: PUSH
51094: LD_INT 23
51096: PUSH
51097: LD_INT 0
51099: PUSH
51100: EMPTY
51101: LIST
51102: LIST
51103: PUSH
51104: EMPTY
51105: LIST
51106: LIST
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: LIST
51112: PPUSH
51113: CALL_OW 69
51117: ST_TO_ADDR
// if not tmp then
51118: LD_VAR 0 1
51122: NOT
51123: IFFALSE 51127
// exit ;
51125: GO 51153
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51127: LD_VAR 0 1
51131: PUSH
51132: LD_INT 1
51134: PPUSH
51135: LD_VAR 0 1
51139: PPUSH
51140: CALL_OW 12
51144: ARRAY
51145: PPUSH
51146: LD_INT 200
51148: PPUSH
51149: CALL_OW 234
// end ;
51153: PPOPN 1
51155: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51156: LD_EXP 92
51160: PUSH
51161: LD_EXP 121
51165: AND
51166: IFFALSE 51245
51168: GO 51170
51170: DISABLE
51171: LD_INT 0
51173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51174: LD_ADDR_VAR 0 1
51178: PUSH
51179: LD_INT 22
51181: PUSH
51182: LD_OWVAR 2
51186: PUSH
51187: EMPTY
51188: LIST
51189: LIST
51190: PUSH
51191: LD_INT 21
51193: PUSH
51194: LD_INT 2
51196: PUSH
51197: EMPTY
51198: LIST
51199: LIST
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: PPUSH
51205: CALL_OW 69
51209: ST_TO_ADDR
// if not tmp then
51210: LD_VAR 0 1
51214: NOT
51215: IFFALSE 51219
// exit ;
51217: GO 51245
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51219: LD_VAR 0 1
51223: PUSH
51224: LD_INT 1
51226: PPUSH
51227: LD_VAR 0 1
51231: PPUSH
51232: CALL_OW 12
51236: ARRAY
51237: PPUSH
51238: LD_INT 60
51240: PPUSH
51241: CALL_OW 234
// end ;
51245: PPOPN 1
51247: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51248: LD_EXP 92
51252: PUSH
51253: LD_EXP 122
51257: AND
51258: IFFALSE 51357
51260: GO 51262
51262: DISABLE
51263: LD_INT 0
51265: PPUSH
51266: PPUSH
// begin enable ;
51267: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51268: LD_ADDR_VAR 0 1
51272: PUSH
51273: LD_INT 22
51275: PUSH
51276: LD_OWVAR 2
51280: PUSH
51281: EMPTY
51282: LIST
51283: LIST
51284: PUSH
51285: LD_INT 61
51287: PUSH
51288: EMPTY
51289: LIST
51290: PUSH
51291: LD_INT 33
51293: PUSH
51294: LD_INT 2
51296: PUSH
51297: EMPTY
51298: LIST
51299: LIST
51300: PUSH
51301: EMPTY
51302: LIST
51303: LIST
51304: LIST
51305: PPUSH
51306: CALL_OW 69
51310: ST_TO_ADDR
// if not tmp then
51311: LD_VAR 0 1
51315: NOT
51316: IFFALSE 51320
// exit ;
51318: GO 51357
// for i in tmp do
51320: LD_ADDR_VAR 0 2
51324: PUSH
51325: LD_VAR 0 1
51329: PUSH
51330: FOR_IN
51331: IFFALSE 51355
// if IsControledBy ( i ) then
51333: LD_VAR 0 2
51337: PPUSH
51338: CALL_OW 312
51342: IFFALSE 51353
// ComUnlink ( i ) ;
51344: LD_VAR 0 2
51348: PPUSH
51349: CALL_OW 136
51353: GO 51330
51355: POP
51356: POP
// end ;
51357: PPOPN 2
51359: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51360: LD_EXP 92
51364: PUSH
51365: LD_EXP 123
51369: AND
51370: IFFALSE 51510
51372: GO 51374
51374: DISABLE
51375: LD_INT 0
51377: PPUSH
51378: PPUSH
// begin ToLua ( displayPowell(); ) ;
51379: LD_STRING displayPowell();
51381: PPUSH
51382: CALL_OW 559
// uc_side := 0 ;
51386: LD_ADDR_OWVAR 20
51390: PUSH
51391: LD_INT 0
51393: ST_TO_ADDR
// uc_nation := 2 ;
51394: LD_ADDR_OWVAR 21
51398: PUSH
51399: LD_INT 2
51401: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51402: LD_ADDR_OWVAR 37
51406: PUSH
51407: LD_INT 14
51409: ST_TO_ADDR
// vc_engine := engine_siberite ;
51410: LD_ADDR_OWVAR 39
51414: PUSH
51415: LD_INT 3
51417: ST_TO_ADDR
// vc_control := control_apeman ;
51418: LD_ADDR_OWVAR 38
51422: PUSH
51423: LD_INT 5
51425: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51426: LD_ADDR_OWVAR 40
51430: PUSH
51431: LD_INT 29
51433: ST_TO_ADDR
// un := CreateVehicle ;
51434: LD_ADDR_VAR 0 2
51438: PUSH
51439: CALL_OW 45
51443: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51444: LD_VAR 0 2
51448: PPUSH
51449: LD_INT 1
51451: PPUSH
51452: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51456: LD_INT 35
51458: PPUSH
51459: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51463: LD_VAR 0 2
51467: PPUSH
51468: LD_INT 22
51470: PUSH
51471: LD_OWVAR 2
51475: PUSH
51476: EMPTY
51477: LIST
51478: LIST
51479: PPUSH
51480: CALL_OW 69
51484: PPUSH
51485: LD_VAR 0 2
51489: PPUSH
51490: CALL_OW 74
51494: PPUSH
51495: CALL_OW 115
// until IsDead ( un ) ;
51499: LD_VAR 0 2
51503: PPUSH
51504: CALL_OW 301
51508: IFFALSE 51456
// end ;
51510: PPOPN 2
51512: END
// every 0 0$1 trigger StreamModeActive and sStu do
51513: LD_EXP 92
51517: PUSH
51518: LD_EXP 131
51522: AND
51523: IFFALSE 51539
51525: GO 51527
51527: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51528: LD_STRING displayStucuk();
51530: PPUSH
51531: CALL_OW 559
// ResetFog ;
51535: CALL_OW 335
// end ;
51539: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51540: LD_EXP 92
51544: PUSH
51545: LD_EXP 124
51549: AND
51550: IFFALSE 51691
51552: GO 51554
51554: DISABLE
51555: LD_INT 0
51557: PPUSH
51558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51559: LD_ADDR_VAR 0 2
51563: PUSH
51564: LD_INT 22
51566: PUSH
51567: LD_OWVAR 2
51571: PUSH
51572: EMPTY
51573: LIST
51574: LIST
51575: PUSH
51576: LD_INT 21
51578: PUSH
51579: LD_INT 1
51581: PUSH
51582: EMPTY
51583: LIST
51584: LIST
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: PPUSH
51590: CALL_OW 69
51594: ST_TO_ADDR
// if not tmp then
51595: LD_VAR 0 2
51599: NOT
51600: IFFALSE 51604
// exit ;
51602: GO 51691
// un := tmp [ rand ( 1 , tmp ) ] ;
51604: LD_ADDR_VAR 0 1
51608: PUSH
51609: LD_VAR 0 2
51613: PUSH
51614: LD_INT 1
51616: PPUSH
51617: LD_VAR 0 2
51621: PPUSH
51622: CALL_OW 12
51626: ARRAY
51627: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51628: LD_VAR 0 1
51632: PPUSH
51633: LD_INT 0
51635: PPUSH
51636: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51640: LD_VAR 0 1
51644: PPUSH
51645: LD_OWVAR 3
51649: PUSH
51650: LD_VAR 0 1
51654: DIFF
51655: PPUSH
51656: LD_VAR 0 1
51660: PPUSH
51661: CALL_OW 74
51665: PPUSH
51666: CALL_OW 115
// wait ( 0 0$20 ) ;
51670: LD_INT 700
51672: PPUSH
51673: CALL_OW 67
// SetSide ( un , your_side ) ;
51677: LD_VAR 0 1
51681: PPUSH
51682: LD_OWVAR 2
51686: PPUSH
51687: CALL_OW 235
// end ;
51691: PPOPN 2
51693: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51694: LD_EXP 92
51698: PUSH
51699: LD_EXP 125
51703: AND
51704: IFFALSE 51810
51706: GO 51708
51708: DISABLE
51709: LD_INT 0
51711: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51712: LD_ADDR_VAR 0 1
51716: PUSH
51717: LD_INT 22
51719: PUSH
51720: LD_OWVAR 2
51724: PUSH
51725: EMPTY
51726: LIST
51727: LIST
51728: PUSH
51729: LD_INT 2
51731: PUSH
51732: LD_INT 30
51734: PUSH
51735: LD_INT 0
51737: PUSH
51738: EMPTY
51739: LIST
51740: LIST
51741: PUSH
51742: LD_INT 30
51744: PUSH
51745: LD_INT 1
51747: PUSH
51748: EMPTY
51749: LIST
51750: LIST
51751: PUSH
51752: EMPTY
51753: LIST
51754: LIST
51755: LIST
51756: PUSH
51757: EMPTY
51758: LIST
51759: LIST
51760: PPUSH
51761: CALL_OW 69
51765: ST_TO_ADDR
// if not depot then
51766: LD_VAR 0 1
51770: NOT
51771: IFFALSE 51775
// exit ;
51773: GO 51810
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51775: LD_VAR 0 1
51779: PUSH
51780: LD_INT 1
51782: ARRAY
51783: PPUSH
51784: CALL_OW 250
51788: PPUSH
51789: LD_VAR 0 1
51793: PUSH
51794: LD_INT 1
51796: ARRAY
51797: PPUSH
51798: CALL_OW 251
51802: PPUSH
51803: LD_INT 70
51805: PPUSH
51806: CALL_OW 495
// end ;
51810: PPOPN 1
51812: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51813: LD_EXP 92
51817: PUSH
51818: LD_EXP 126
51822: AND
51823: IFFALSE 52034
51825: GO 51827
51827: DISABLE
51828: LD_INT 0
51830: PPUSH
51831: PPUSH
51832: PPUSH
51833: PPUSH
51834: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51835: LD_ADDR_VAR 0 5
51839: PUSH
51840: LD_INT 22
51842: PUSH
51843: LD_OWVAR 2
51847: PUSH
51848: EMPTY
51849: LIST
51850: LIST
51851: PUSH
51852: LD_INT 21
51854: PUSH
51855: LD_INT 1
51857: PUSH
51858: EMPTY
51859: LIST
51860: LIST
51861: PUSH
51862: EMPTY
51863: LIST
51864: LIST
51865: PPUSH
51866: CALL_OW 69
51870: ST_TO_ADDR
// if not tmp then
51871: LD_VAR 0 5
51875: NOT
51876: IFFALSE 51880
// exit ;
51878: GO 52034
// for i in tmp do
51880: LD_ADDR_VAR 0 1
51884: PUSH
51885: LD_VAR 0 5
51889: PUSH
51890: FOR_IN
51891: IFFALSE 52032
// begin d := rand ( 0 , 5 ) ;
51893: LD_ADDR_VAR 0 4
51897: PUSH
51898: LD_INT 0
51900: PPUSH
51901: LD_INT 5
51903: PPUSH
51904: CALL_OW 12
51908: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
51909: LD_ADDR_VAR 0 2
51913: PUSH
51914: LD_VAR 0 1
51918: PPUSH
51919: CALL_OW 250
51923: PPUSH
51924: LD_VAR 0 4
51928: PPUSH
51929: LD_INT 3
51931: PPUSH
51932: LD_INT 12
51934: PPUSH
51935: CALL_OW 12
51939: PPUSH
51940: CALL_OW 272
51944: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
51945: LD_ADDR_VAR 0 3
51949: PUSH
51950: LD_VAR 0 1
51954: PPUSH
51955: CALL_OW 251
51959: PPUSH
51960: LD_VAR 0 4
51964: PPUSH
51965: LD_INT 3
51967: PPUSH
51968: LD_INT 12
51970: PPUSH
51971: CALL_OW 12
51975: PPUSH
51976: CALL_OW 273
51980: ST_TO_ADDR
// if ValidHex ( x , y ) then
51981: LD_VAR 0 2
51985: PPUSH
51986: LD_VAR 0 3
51990: PPUSH
51991: CALL_OW 488
51995: IFFALSE 52030
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
51997: LD_VAR 0 1
52001: PPUSH
52002: LD_VAR 0 2
52006: PPUSH
52007: LD_VAR 0 3
52011: PPUSH
52012: LD_INT 3
52014: PPUSH
52015: LD_INT 6
52017: PPUSH
52018: CALL_OW 12
52022: PPUSH
52023: LD_INT 1
52025: PPUSH
52026: CALL_OW 483
// end ;
52030: GO 51890
52032: POP
52033: POP
// end ;
52034: PPOPN 5
52036: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52037: LD_EXP 92
52041: PUSH
52042: LD_EXP 127
52046: AND
52047: IFFALSE 52141
52049: GO 52051
52051: DISABLE
52052: LD_INT 0
52054: PPUSH
52055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52056: LD_ADDR_VAR 0 2
52060: PUSH
52061: LD_INT 22
52063: PUSH
52064: LD_OWVAR 2
52068: PUSH
52069: EMPTY
52070: LIST
52071: LIST
52072: PUSH
52073: LD_INT 32
52075: PUSH
52076: LD_INT 1
52078: PUSH
52079: EMPTY
52080: LIST
52081: LIST
52082: PUSH
52083: LD_INT 21
52085: PUSH
52086: LD_INT 2
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: PUSH
52093: EMPTY
52094: LIST
52095: LIST
52096: LIST
52097: PPUSH
52098: CALL_OW 69
52102: ST_TO_ADDR
// if not tmp then
52103: LD_VAR 0 2
52107: NOT
52108: IFFALSE 52112
// exit ;
52110: GO 52141
// for i in tmp do
52112: LD_ADDR_VAR 0 1
52116: PUSH
52117: LD_VAR 0 2
52121: PUSH
52122: FOR_IN
52123: IFFALSE 52139
// SetFuel ( i , 0 ) ;
52125: LD_VAR 0 1
52129: PPUSH
52130: LD_INT 0
52132: PPUSH
52133: CALL_OW 240
52137: GO 52122
52139: POP
52140: POP
// end ;
52141: PPOPN 2
52143: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52144: LD_EXP 92
52148: PUSH
52149: LD_EXP 128
52153: AND
52154: IFFALSE 52220
52156: GO 52158
52158: DISABLE
52159: LD_INT 0
52161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52162: LD_ADDR_VAR 0 1
52166: PUSH
52167: LD_INT 22
52169: PUSH
52170: LD_OWVAR 2
52174: PUSH
52175: EMPTY
52176: LIST
52177: LIST
52178: PUSH
52179: LD_INT 30
52181: PUSH
52182: LD_INT 29
52184: PUSH
52185: EMPTY
52186: LIST
52187: LIST
52188: PUSH
52189: EMPTY
52190: LIST
52191: LIST
52192: PPUSH
52193: CALL_OW 69
52197: ST_TO_ADDR
// if not tmp then
52198: LD_VAR 0 1
52202: NOT
52203: IFFALSE 52207
// exit ;
52205: GO 52220
// DestroyUnit ( tmp [ 1 ] ) ;
52207: LD_VAR 0 1
52211: PUSH
52212: LD_INT 1
52214: ARRAY
52215: PPUSH
52216: CALL_OW 65
// end ;
52220: PPOPN 1
52222: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52223: LD_EXP 92
52227: PUSH
52228: LD_EXP 130
52232: AND
52233: IFFALSE 52362
52235: GO 52237
52237: DISABLE
52238: LD_INT 0
52240: PPUSH
// begin uc_side := 0 ;
52241: LD_ADDR_OWVAR 20
52245: PUSH
52246: LD_INT 0
52248: ST_TO_ADDR
// uc_nation := nation_arabian ;
52249: LD_ADDR_OWVAR 21
52253: PUSH
52254: LD_INT 2
52256: ST_TO_ADDR
// hc_gallery :=  ;
52257: LD_ADDR_OWVAR 33
52261: PUSH
52262: LD_STRING 
52264: ST_TO_ADDR
// hc_name :=  ;
52265: LD_ADDR_OWVAR 26
52269: PUSH
52270: LD_STRING 
52272: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52273: LD_INT 1
52275: PPUSH
52276: LD_INT 11
52278: PPUSH
52279: LD_INT 10
52281: PPUSH
52282: CALL_OW 380
// un := CreateHuman ;
52286: LD_ADDR_VAR 0 1
52290: PUSH
52291: CALL_OW 44
52295: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52296: LD_VAR 0 1
52300: PPUSH
52301: LD_INT 1
52303: PPUSH
52304: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52308: LD_INT 35
52310: PPUSH
52311: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52315: LD_VAR 0 1
52319: PPUSH
52320: LD_INT 22
52322: PUSH
52323: LD_OWVAR 2
52327: PUSH
52328: EMPTY
52329: LIST
52330: LIST
52331: PPUSH
52332: CALL_OW 69
52336: PPUSH
52337: LD_VAR 0 1
52341: PPUSH
52342: CALL_OW 74
52346: PPUSH
52347: CALL_OW 115
// until IsDead ( un ) ;
52351: LD_VAR 0 1
52355: PPUSH
52356: CALL_OW 301
52360: IFFALSE 52308
// end ;
52362: PPOPN 1
52364: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52365: LD_EXP 92
52369: PUSH
52370: LD_EXP 132
52374: AND
52375: IFFALSE 52387
52377: GO 52379
52379: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52380: LD_STRING earthquake(getX(game), 0, 32)
52382: PPUSH
52383: CALL_OW 559
52387: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52388: LD_EXP 92
52392: PUSH
52393: LD_EXP 133
52397: AND
52398: IFFALSE 52489
52400: GO 52402
52402: DISABLE
52403: LD_INT 0
52405: PPUSH
// begin enable ;
52406: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52407: LD_ADDR_VAR 0 1
52411: PUSH
52412: LD_INT 22
52414: PUSH
52415: LD_OWVAR 2
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: PUSH
52424: LD_INT 21
52426: PUSH
52427: LD_INT 2
52429: PUSH
52430: EMPTY
52431: LIST
52432: LIST
52433: PUSH
52434: LD_INT 33
52436: PUSH
52437: LD_INT 3
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: LIST
52448: PPUSH
52449: CALL_OW 69
52453: ST_TO_ADDR
// if not tmp then
52454: LD_VAR 0 1
52458: NOT
52459: IFFALSE 52463
// exit ;
52461: GO 52489
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52463: LD_VAR 0 1
52467: PUSH
52468: LD_INT 1
52470: PPUSH
52471: LD_VAR 0 1
52475: PPUSH
52476: CALL_OW 12
52480: ARRAY
52481: PPUSH
52482: LD_INT 1
52484: PPUSH
52485: CALL_OW 234
// end ;
52489: PPOPN 1
52491: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52492: LD_EXP 92
52496: PUSH
52497: LD_EXP 134
52501: AND
52502: IFFALSE 52643
52504: GO 52506
52506: DISABLE
52507: LD_INT 0
52509: PPUSH
52510: PPUSH
52511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52512: LD_ADDR_VAR 0 3
52516: PUSH
52517: LD_INT 22
52519: PUSH
52520: LD_OWVAR 2
52524: PUSH
52525: EMPTY
52526: LIST
52527: LIST
52528: PUSH
52529: LD_INT 25
52531: PUSH
52532: LD_INT 1
52534: PUSH
52535: EMPTY
52536: LIST
52537: LIST
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: PPUSH
52543: CALL_OW 69
52547: ST_TO_ADDR
// if not tmp then
52548: LD_VAR 0 3
52552: NOT
52553: IFFALSE 52557
// exit ;
52555: GO 52643
// un := tmp [ rand ( 1 , tmp ) ] ;
52557: LD_ADDR_VAR 0 2
52561: PUSH
52562: LD_VAR 0 3
52566: PUSH
52567: LD_INT 1
52569: PPUSH
52570: LD_VAR 0 3
52574: PPUSH
52575: CALL_OW 12
52579: ARRAY
52580: ST_TO_ADDR
// if Crawls ( un ) then
52581: LD_VAR 0 2
52585: PPUSH
52586: CALL_OW 318
52590: IFFALSE 52601
// ComWalk ( un ) ;
52592: LD_VAR 0 2
52596: PPUSH
52597: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52601: LD_VAR 0 2
52605: PPUSH
52606: LD_INT 9
52608: PPUSH
52609: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52613: LD_INT 28
52615: PPUSH
52616: LD_OWVAR 2
52620: PPUSH
52621: LD_INT 2
52623: PPUSH
52624: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52628: LD_INT 29
52630: PPUSH
52631: LD_OWVAR 2
52635: PPUSH
52636: LD_INT 2
52638: PPUSH
52639: CALL_OW 322
// end ;
52643: PPOPN 3
52645: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52646: LD_EXP 92
52650: PUSH
52651: LD_EXP 135
52655: AND
52656: IFFALSE 52767
52658: GO 52660
52660: DISABLE
52661: LD_INT 0
52663: PPUSH
52664: PPUSH
52665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52666: LD_ADDR_VAR 0 3
52670: PUSH
52671: LD_INT 22
52673: PUSH
52674: LD_OWVAR 2
52678: PUSH
52679: EMPTY
52680: LIST
52681: LIST
52682: PUSH
52683: LD_INT 25
52685: PUSH
52686: LD_INT 1
52688: PUSH
52689: EMPTY
52690: LIST
52691: LIST
52692: PUSH
52693: EMPTY
52694: LIST
52695: LIST
52696: PPUSH
52697: CALL_OW 69
52701: ST_TO_ADDR
// if not tmp then
52702: LD_VAR 0 3
52706: NOT
52707: IFFALSE 52711
// exit ;
52709: GO 52767
// un := tmp [ rand ( 1 , tmp ) ] ;
52711: LD_ADDR_VAR 0 2
52715: PUSH
52716: LD_VAR 0 3
52720: PUSH
52721: LD_INT 1
52723: PPUSH
52724: LD_VAR 0 3
52728: PPUSH
52729: CALL_OW 12
52733: ARRAY
52734: ST_TO_ADDR
// if Crawls ( un ) then
52735: LD_VAR 0 2
52739: PPUSH
52740: CALL_OW 318
52744: IFFALSE 52755
// ComWalk ( un ) ;
52746: LD_VAR 0 2
52750: PPUSH
52751: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52755: LD_VAR 0 2
52759: PPUSH
52760: LD_INT 8
52762: PPUSH
52763: CALL_OW 336
// end ;
52767: PPOPN 3
52769: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52770: LD_EXP 92
52774: PUSH
52775: LD_EXP 136
52779: AND
52780: IFFALSE 52924
52782: GO 52784
52784: DISABLE
52785: LD_INT 0
52787: PPUSH
52788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52789: LD_ADDR_VAR 0 2
52793: PUSH
52794: LD_INT 22
52796: PUSH
52797: LD_OWVAR 2
52801: PUSH
52802: EMPTY
52803: LIST
52804: LIST
52805: PUSH
52806: LD_INT 21
52808: PUSH
52809: LD_INT 2
52811: PUSH
52812: EMPTY
52813: LIST
52814: LIST
52815: PUSH
52816: LD_INT 2
52818: PUSH
52819: LD_INT 34
52821: PUSH
52822: LD_INT 12
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: LD_INT 34
52831: PUSH
52832: LD_INT 51
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: PUSH
52839: LD_INT 34
52841: PUSH
52842: LD_INT 32
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: PUSH
52849: EMPTY
52850: LIST
52851: LIST
52852: LIST
52853: LIST
52854: PUSH
52855: EMPTY
52856: LIST
52857: LIST
52858: LIST
52859: PPUSH
52860: CALL_OW 69
52864: ST_TO_ADDR
// if not tmp then
52865: LD_VAR 0 2
52869: NOT
52870: IFFALSE 52874
// exit ;
52872: GO 52924
// for i in tmp do
52874: LD_ADDR_VAR 0 1
52878: PUSH
52879: LD_VAR 0 2
52883: PUSH
52884: FOR_IN
52885: IFFALSE 52922
// if GetCargo ( i , mat_artifact ) = 0 then
52887: LD_VAR 0 1
52891: PPUSH
52892: LD_INT 4
52894: PPUSH
52895: CALL_OW 289
52899: PUSH
52900: LD_INT 0
52902: EQUAL
52903: IFFALSE 52920
// SetCargo ( i , mat_siberit , 100 ) ;
52905: LD_VAR 0 1
52909: PPUSH
52910: LD_INT 3
52912: PPUSH
52913: LD_INT 100
52915: PPUSH
52916: CALL_OW 290
52920: GO 52884
52922: POP
52923: POP
// end ;
52924: PPOPN 2
52926: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
52927: LD_EXP 92
52931: PUSH
52932: LD_EXP 137
52936: AND
52937: IFFALSE 53120
52939: GO 52941
52941: DISABLE
52942: LD_INT 0
52944: PPUSH
52945: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
52946: LD_ADDR_VAR 0 2
52950: PUSH
52951: LD_INT 22
52953: PUSH
52954: LD_OWVAR 2
52958: PUSH
52959: EMPTY
52960: LIST
52961: LIST
52962: PPUSH
52963: CALL_OW 69
52967: ST_TO_ADDR
// if not tmp then
52968: LD_VAR 0 2
52972: NOT
52973: IFFALSE 52977
// exit ;
52975: GO 53120
// for i := 1 to 2 do
52977: LD_ADDR_VAR 0 1
52981: PUSH
52982: DOUBLE
52983: LD_INT 1
52985: DEC
52986: ST_TO_ADDR
52987: LD_INT 2
52989: PUSH
52990: FOR_TO
52991: IFFALSE 53118
// begin uc_side := your_side ;
52993: LD_ADDR_OWVAR 20
52997: PUSH
52998: LD_OWVAR 2
53002: ST_TO_ADDR
// uc_nation := nation_american ;
53003: LD_ADDR_OWVAR 21
53007: PUSH
53008: LD_INT 1
53010: ST_TO_ADDR
// vc_chassis := us_morphling ;
53011: LD_ADDR_OWVAR 37
53015: PUSH
53016: LD_INT 5
53018: ST_TO_ADDR
// vc_engine := engine_siberite ;
53019: LD_ADDR_OWVAR 39
53023: PUSH
53024: LD_INT 3
53026: ST_TO_ADDR
// vc_control := control_computer ;
53027: LD_ADDR_OWVAR 38
53031: PUSH
53032: LD_INT 3
53034: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53035: LD_ADDR_OWVAR 40
53039: PUSH
53040: LD_INT 10
53042: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53043: LD_VAR 0 2
53047: PUSH
53048: LD_INT 1
53050: ARRAY
53051: PPUSH
53052: CALL_OW 310
53056: NOT
53057: IFFALSE 53104
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53059: CALL_OW 45
53063: PPUSH
53064: LD_VAR 0 2
53068: PUSH
53069: LD_INT 1
53071: ARRAY
53072: PPUSH
53073: CALL_OW 250
53077: PPUSH
53078: LD_VAR 0 2
53082: PUSH
53083: LD_INT 1
53085: ARRAY
53086: PPUSH
53087: CALL_OW 251
53091: PPUSH
53092: LD_INT 12
53094: PPUSH
53095: LD_INT 1
53097: PPUSH
53098: CALL_OW 50
53102: GO 53116
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53104: CALL_OW 45
53108: PPUSH
53109: LD_INT 1
53111: PPUSH
53112: CALL_OW 51
// end ;
53116: GO 52990
53118: POP
53119: POP
// end ;
53120: PPOPN 2
53122: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53123: LD_EXP 92
53127: PUSH
53128: LD_EXP 138
53132: AND
53133: IFFALSE 53355
53135: GO 53137
53137: DISABLE
53138: LD_INT 0
53140: PPUSH
53141: PPUSH
53142: PPUSH
53143: PPUSH
53144: PPUSH
53145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53146: LD_ADDR_VAR 0 6
53150: PUSH
53151: LD_INT 22
53153: PUSH
53154: LD_OWVAR 2
53158: PUSH
53159: EMPTY
53160: LIST
53161: LIST
53162: PUSH
53163: LD_INT 21
53165: PUSH
53166: LD_INT 1
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: PUSH
53173: LD_INT 3
53175: PUSH
53176: LD_INT 23
53178: PUSH
53179: LD_INT 0
53181: PUSH
53182: EMPTY
53183: LIST
53184: LIST
53185: PUSH
53186: EMPTY
53187: LIST
53188: LIST
53189: PUSH
53190: EMPTY
53191: LIST
53192: LIST
53193: LIST
53194: PPUSH
53195: CALL_OW 69
53199: ST_TO_ADDR
// if not tmp then
53200: LD_VAR 0 6
53204: NOT
53205: IFFALSE 53209
// exit ;
53207: GO 53355
// s1 := rand ( 1 , 4 ) ;
53209: LD_ADDR_VAR 0 2
53213: PUSH
53214: LD_INT 1
53216: PPUSH
53217: LD_INT 4
53219: PPUSH
53220: CALL_OW 12
53224: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53225: LD_ADDR_VAR 0 4
53229: PUSH
53230: LD_VAR 0 6
53234: PUSH
53235: LD_INT 1
53237: ARRAY
53238: PPUSH
53239: LD_VAR 0 2
53243: PPUSH
53244: CALL_OW 259
53248: ST_TO_ADDR
// if s1 = 1 then
53249: LD_VAR 0 2
53253: PUSH
53254: LD_INT 1
53256: EQUAL
53257: IFFALSE 53277
// s2 := rand ( 2 , 4 ) else
53259: LD_ADDR_VAR 0 3
53263: PUSH
53264: LD_INT 2
53266: PPUSH
53267: LD_INT 4
53269: PPUSH
53270: CALL_OW 12
53274: ST_TO_ADDR
53275: GO 53285
// s2 := 1 ;
53277: LD_ADDR_VAR 0 3
53281: PUSH
53282: LD_INT 1
53284: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53285: LD_ADDR_VAR 0 5
53289: PUSH
53290: LD_VAR 0 6
53294: PUSH
53295: LD_INT 1
53297: ARRAY
53298: PPUSH
53299: LD_VAR 0 3
53303: PPUSH
53304: CALL_OW 259
53308: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53309: LD_VAR 0 6
53313: PUSH
53314: LD_INT 1
53316: ARRAY
53317: PPUSH
53318: LD_VAR 0 2
53322: PPUSH
53323: LD_VAR 0 5
53327: PPUSH
53328: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53332: LD_VAR 0 6
53336: PUSH
53337: LD_INT 1
53339: ARRAY
53340: PPUSH
53341: LD_VAR 0 3
53345: PPUSH
53346: LD_VAR 0 4
53350: PPUSH
53351: CALL_OW 237
// end ;
53355: PPOPN 6
53357: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53358: LD_EXP 92
53362: PUSH
53363: LD_EXP 139
53367: AND
53368: IFFALSE 53447
53370: GO 53372
53372: DISABLE
53373: LD_INT 0
53375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53376: LD_ADDR_VAR 0 1
53380: PUSH
53381: LD_INT 22
53383: PUSH
53384: LD_OWVAR 2
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: PUSH
53393: LD_INT 30
53395: PUSH
53396: LD_INT 3
53398: PUSH
53399: EMPTY
53400: LIST
53401: LIST
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: PPUSH
53407: CALL_OW 69
53411: ST_TO_ADDR
// if not tmp then
53412: LD_VAR 0 1
53416: NOT
53417: IFFALSE 53421
// exit ;
53419: GO 53447
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53421: LD_VAR 0 1
53425: PUSH
53426: LD_INT 1
53428: PPUSH
53429: LD_VAR 0 1
53433: PPUSH
53434: CALL_OW 12
53438: ARRAY
53439: PPUSH
53440: LD_INT 1
53442: PPUSH
53443: CALL_OW 234
// end ;
53447: PPOPN 1
53449: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53450: LD_EXP 92
53454: PUSH
53455: LD_EXP 140
53459: AND
53460: IFFALSE 53572
53462: GO 53464
53464: DISABLE
53465: LD_INT 0
53467: PPUSH
53468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53469: LD_ADDR_VAR 0 2
53473: PUSH
53474: LD_INT 22
53476: PUSH
53477: LD_OWVAR 2
53481: PUSH
53482: EMPTY
53483: LIST
53484: LIST
53485: PUSH
53486: LD_INT 2
53488: PUSH
53489: LD_INT 30
53491: PUSH
53492: LD_INT 27
53494: PUSH
53495: EMPTY
53496: LIST
53497: LIST
53498: PUSH
53499: LD_INT 30
53501: PUSH
53502: LD_INT 26
53504: PUSH
53505: EMPTY
53506: LIST
53507: LIST
53508: PUSH
53509: LD_INT 30
53511: PUSH
53512: LD_INT 28
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: LIST
53523: LIST
53524: PUSH
53525: EMPTY
53526: LIST
53527: LIST
53528: PPUSH
53529: CALL_OW 69
53533: ST_TO_ADDR
// if not tmp then
53534: LD_VAR 0 2
53538: NOT
53539: IFFALSE 53543
// exit ;
53541: GO 53572
// for i in tmp do
53543: LD_ADDR_VAR 0 1
53547: PUSH
53548: LD_VAR 0 2
53552: PUSH
53553: FOR_IN
53554: IFFALSE 53570
// SetLives ( i , 1 ) ;
53556: LD_VAR 0 1
53560: PPUSH
53561: LD_INT 1
53563: PPUSH
53564: CALL_OW 234
53568: GO 53553
53570: POP
53571: POP
// end ;
53572: PPOPN 2
53574: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53575: LD_EXP 92
53579: PUSH
53580: LD_EXP 141
53584: AND
53585: IFFALSE 53859
53587: GO 53589
53589: DISABLE
53590: LD_INT 0
53592: PPUSH
53593: PPUSH
53594: PPUSH
// begin i := rand ( 1 , 7 ) ;
53595: LD_ADDR_VAR 0 1
53599: PUSH
53600: LD_INT 1
53602: PPUSH
53603: LD_INT 7
53605: PPUSH
53606: CALL_OW 12
53610: ST_TO_ADDR
// case i of 1 :
53611: LD_VAR 0 1
53615: PUSH
53616: LD_INT 1
53618: DOUBLE
53619: EQUAL
53620: IFTRUE 53624
53622: GO 53634
53624: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53625: LD_STRING earthquake(getX(game), 0, 32)
53627: PPUSH
53628: CALL_OW 559
53632: GO 53859
53634: LD_INT 2
53636: DOUBLE
53637: EQUAL
53638: IFTRUE 53642
53640: GO 53656
53642: POP
// begin ToLua ( displayStucuk(); ) ;
53643: LD_STRING displayStucuk();
53645: PPUSH
53646: CALL_OW 559
// ResetFog ;
53650: CALL_OW 335
// end ; 3 :
53654: GO 53859
53656: LD_INT 3
53658: DOUBLE
53659: EQUAL
53660: IFTRUE 53664
53662: GO 53768
53664: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53665: LD_ADDR_VAR 0 2
53669: PUSH
53670: LD_INT 22
53672: PUSH
53673: LD_OWVAR 2
53677: PUSH
53678: EMPTY
53679: LIST
53680: LIST
53681: PUSH
53682: LD_INT 25
53684: PUSH
53685: LD_INT 1
53687: PUSH
53688: EMPTY
53689: LIST
53690: LIST
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: PPUSH
53696: CALL_OW 69
53700: ST_TO_ADDR
// if not tmp then
53701: LD_VAR 0 2
53705: NOT
53706: IFFALSE 53710
// exit ;
53708: GO 53859
// un := tmp [ rand ( 1 , tmp ) ] ;
53710: LD_ADDR_VAR 0 3
53714: PUSH
53715: LD_VAR 0 2
53719: PUSH
53720: LD_INT 1
53722: PPUSH
53723: LD_VAR 0 2
53727: PPUSH
53728: CALL_OW 12
53732: ARRAY
53733: ST_TO_ADDR
// if Crawls ( un ) then
53734: LD_VAR 0 3
53738: PPUSH
53739: CALL_OW 318
53743: IFFALSE 53754
// ComWalk ( un ) ;
53745: LD_VAR 0 3
53749: PPUSH
53750: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53754: LD_VAR 0 3
53758: PPUSH
53759: LD_INT 8
53761: PPUSH
53762: CALL_OW 336
// end ; 4 :
53766: GO 53859
53768: LD_INT 4
53770: DOUBLE
53771: EQUAL
53772: IFTRUE 53776
53774: GO 53837
53776: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53777: LD_ADDR_VAR 0 2
53781: PUSH
53782: LD_INT 22
53784: PUSH
53785: LD_OWVAR 2
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PUSH
53794: LD_INT 30
53796: PUSH
53797: LD_INT 29
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: PPUSH
53808: CALL_OW 69
53812: ST_TO_ADDR
// if not tmp then
53813: LD_VAR 0 2
53817: NOT
53818: IFFALSE 53822
// exit ;
53820: GO 53859
// DestroyUnit ( tmp [ 1 ] ) ;
53822: LD_VAR 0 2
53826: PUSH
53827: LD_INT 1
53829: ARRAY
53830: PPUSH
53831: CALL_OW 65
// end ; 5 .. 7 :
53835: GO 53859
53837: LD_INT 5
53839: DOUBLE
53840: GREATEREQUAL
53841: IFFALSE 53849
53843: LD_INT 7
53845: DOUBLE
53846: LESSEQUAL
53847: IFTRUE 53851
53849: GO 53858
53851: POP
// StreamSibBomb ; end ;
53852: CALL 50109 0 0
53856: GO 53859
53858: POP
// end ;
53859: PPOPN 3
53861: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53862: LD_EXP 92
53866: PUSH
53867: LD_EXP 142
53871: AND
53872: IFFALSE 54028
53874: GO 53876
53876: DISABLE
53877: LD_INT 0
53879: PPUSH
53880: PPUSH
53881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
53882: LD_ADDR_VAR 0 2
53886: PUSH
53887: LD_INT 81
53889: PUSH
53890: LD_OWVAR 2
53894: PUSH
53895: EMPTY
53896: LIST
53897: LIST
53898: PUSH
53899: LD_INT 2
53901: PUSH
53902: LD_INT 21
53904: PUSH
53905: LD_INT 1
53907: PUSH
53908: EMPTY
53909: LIST
53910: LIST
53911: PUSH
53912: LD_INT 21
53914: PUSH
53915: LD_INT 2
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: LIST
53926: PUSH
53927: EMPTY
53928: LIST
53929: LIST
53930: PPUSH
53931: CALL_OW 69
53935: ST_TO_ADDR
// if not tmp then
53936: LD_VAR 0 2
53940: NOT
53941: IFFALSE 53945
// exit ;
53943: GO 54028
// p := 0 ;
53945: LD_ADDR_VAR 0 3
53949: PUSH
53950: LD_INT 0
53952: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53953: LD_INT 35
53955: PPUSH
53956: CALL_OW 67
// p := p + 1 ;
53960: LD_ADDR_VAR 0 3
53964: PUSH
53965: LD_VAR 0 3
53969: PUSH
53970: LD_INT 1
53972: PLUS
53973: ST_TO_ADDR
// for i in tmp do
53974: LD_ADDR_VAR 0 1
53978: PUSH
53979: LD_VAR 0 2
53983: PUSH
53984: FOR_IN
53985: IFFALSE 54016
// if GetLives ( i ) < 1000 then
53987: LD_VAR 0 1
53991: PPUSH
53992: CALL_OW 256
53996: PUSH
53997: LD_INT 1000
53999: LESS
54000: IFFALSE 54014
// SetLives ( i , 1000 ) ;
54002: LD_VAR 0 1
54006: PPUSH
54007: LD_INT 1000
54009: PPUSH
54010: CALL_OW 234
54014: GO 53984
54016: POP
54017: POP
// until p > 20 ;
54018: LD_VAR 0 3
54022: PUSH
54023: LD_INT 20
54025: GREATER
54026: IFFALSE 53953
// end ;
54028: PPOPN 3
54030: END
// every 0 0$1 trigger StreamModeActive and sTime do
54031: LD_EXP 92
54035: PUSH
54036: LD_EXP 143
54040: AND
54041: IFFALSE 54076
54043: GO 54045
54045: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54046: LD_INT 28
54048: PPUSH
54049: LD_OWVAR 2
54053: PPUSH
54054: LD_INT 2
54056: PPUSH
54057: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54061: LD_INT 30
54063: PPUSH
54064: LD_OWVAR 2
54068: PPUSH
54069: LD_INT 2
54071: PPUSH
54072: CALL_OW 322
// end ;
54076: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54077: LD_EXP 92
54081: PUSH
54082: LD_EXP 144
54086: AND
54087: IFFALSE 54208
54089: GO 54091
54091: DISABLE
54092: LD_INT 0
54094: PPUSH
54095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54096: LD_ADDR_VAR 0 2
54100: PUSH
54101: LD_INT 22
54103: PUSH
54104: LD_OWVAR 2
54108: PUSH
54109: EMPTY
54110: LIST
54111: LIST
54112: PUSH
54113: LD_INT 21
54115: PUSH
54116: LD_INT 1
54118: PUSH
54119: EMPTY
54120: LIST
54121: LIST
54122: PUSH
54123: LD_INT 3
54125: PUSH
54126: LD_INT 23
54128: PUSH
54129: LD_INT 0
54131: PUSH
54132: EMPTY
54133: LIST
54134: LIST
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: LIST
54144: PPUSH
54145: CALL_OW 69
54149: ST_TO_ADDR
// if not tmp then
54150: LD_VAR 0 2
54154: NOT
54155: IFFALSE 54159
// exit ;
54157: GO 54208
// for i in tmp do
54159: LD_ADDR_VAR 0 1
54163: PUSH
54164: LD_VAR 0 2
54168: PUSH
54169: FOR_IN
54170: IFFALSE 54206
// begin if Crawls ( i ) then
54172: LD_VAR 0 1
54176: PPUSH
54177: CALL_OW 318
54181: IFFALSE 54192
// ComWalk ( i ) ;
54183: LD_VAR 0 1
54187: PPUSH
54188: CALL_OW 138
// SetClass ( i , 2 ) ;
54192: LD_VAR 0 1
54196: PPUSH
54197: LD_INT 2
54199: PPUSH
54200: CALL_OW 336
// end ;
54204: GO 54169
54206: POP
54207: POP
// end ;
54208: PPOPN 2
54210: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54211: LD_EXP 92
54215: PUSH
54216: LD_EXP 145
54220: AND
54221: IFFALSE 54502
54223: GO 54225
54225: DISABLE
54226: LD_INT 0
54228: PPUSH
54229: PPUSH
54230: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54231: LD_OWVAR 2
54235: PPUSH
54236: LD_INT 9
54238: PPUSH
54239: LD_INT 1
54241: PPUSH
54242: LD_INT 1
54244: PPUSH
54245: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54249: LD_INT 9
54251: PPUSH
54252: LD_OWVAR 2
54256: PPUSH
54257: CALL_OW 343
// uc_side := 9 ;
54261: LD_ADDR_OWVAR 20
54265: PUSH
54266: LD_INT 9
54268: ST_TO_ADDR
// uc_nation := 2 ;
54269: LD_ADDR_OWVAR 21
54273: PUSH
54274: LD_INT 2
54276: ST_TO_ADDR
// hc_name := Dark Warrior ;
54277: LD_ADDR_OWVAR 26
54281: PUSH
54282: LD_STRING Dark Warrior
54284: ST_TO_ADDR
// hc_gallery :=  ;
54285: LD_ADDR_OWVAR 33
54289: PUSH
54290: LD_STRING 
54292: ST_TO_ADDR
// hc_noskilllimit := true ;
54293: LD_ADDR_OWVAR 76
54297: PUSH
54298: LD_INT 1
54300: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54301: LD_ADDR_OWVAR 31
54305: PUSH
54306: LD_INT 30
54308: PUSH
54309: LD_INT 30
54311: PUSH
54312: LD_INT 30
54314: PUSH
54315: LD_INT 30
54317: PUSH
54318: EMPTY
54319: LIST
54320: LIST
54321: LIST
54322: LIST
54323: ST_TO_ADDR
// un := CreateHuman ;
54324: LD_ADDR_VAR 0 3
54328: PUSH
54329: CALL_OW 44
54333: ST_TO_ADDR
// hc_noskilllimit := false ;
54334: LD_ADDR_OWVAR 76
54338: PUSH
54339: LD_INT 0
54341: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54342: LD_VAR 0 3
54346: PPUSH
54347: LD_INT 1
54349: PPUSH
54350: CALL_OW 51
// p := 0 ;
54354: LD_ADDR_VAR 0 2
54358: PUSH
54359: LD_INT 0
54361: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54362: LD_INT 35
54364: PPUSH
54365: CALL_OW 67
// p := p + 1 ;
54369: LD_ADDR_VAR 0 2
54373: PUSH
54374: LD_VAR 0 2
54378: PUSH
54379: LD_INT 1
54381: PLUS
54382: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54383: LD_VAR 0 3
54387: PPUSH
54388: CALL_OW 256
54392: PUSH
54393: LD_INT 1000
54395: LESS
54396: IFFALSE 54410
// SetLives ( un , 1000 ) ;
54398: LD_VAR 0 3
54402: PPUSH
54403: LD_INT 1000
54405: PPUSH
54406: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54410: LD_VAR 0 3
54414: PPUSH
54415: LD_INT 81
54417: PUSH
54418: LD_OWVAR 2
54422: PUSH
54423: EMPTY
54424: LIST
54425: LIST
54426: PUSH
54427: LD_INT 91
54429: PUSH
54430: LD_VAR 0 3
54434: PUSH
54435: LD_INT 30
54437: PUSH
54438: EMPTY
54439: LIST
54440: LIST
54441: LIST
54442: PUSH
54443: EMPTY
54444: LIST
54445: LIST
54446: PPUSH
54447: CALL_OW 69
54451: PPUSH
54452: LD_VAR 0 3
54456: PPUSH
54457: CALL_OW 74
54461: PPUSH
54462: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54466: LD_VAR 0 2
54470: PUSH
54471: LD_INT 60
54473: GREATER
54474: PUSH
54475: LD_VAR 0 3
54479: PPUSH
54480: CALL_OW 301
54484: OR
54485: IFFALSE 54362
// if un then
54487: LD_VAR 0 3
54491: IFFALSE 54502
// RemoveUnit ( un ) ;
54493: LD_VAR 0 3
54497: PPUSH
54498: CALL_OW 64
// end ;
54502: PPOPN 3
54504: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
54505: LD_INT 0
54507: PPUSH
// case cmd of 301 :
54508: LD_VAR 0 1
54512: PUSH
54513: LD_INT 301
54515: DOUBLE
54516: EQUAL
54517: IFTRUE 54521
54519: GO 54553
54521: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
54522: LD_VAR 0 6
54526: PPUSH
54527: LD_VAR 0 7
54531: PPUSH
54532: LD_VAR 0 8
54536: PPUSH
54537: LD_VAR 0 4
54541: PPUSH
54542: LD_VAR 0 5
54546: PPUSH
54547: CALL 55754 0 5
54551: GO 54674
54553: LD_INT 302
54555: DOUBLE
54556: EQUAL
54557: IFTRUE 54561
54559: GO 54598
54561: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
54562: LD_VAR 0 6
54566: PPUSH
54567: LD_VAR 0 7
54571: PPUSH
54572: LD_VAR 0 8
54576: PPUSH
54577: LD_VAR 0 9
54581: PPUSH
54582: LD_VAR 0 4
54586: PPUSH
54587: LD_VAR 0 5
54591: PPUSH
54592: CALL 55845 0 6
54596: GO 54674
54598: LD_INT 303
54600: DOUBLE
54601: EQUAL
54602: IFTRUE 54606
54604: GO 54643
54606: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
54607: LD_VAR 0 6
54611: PPUSH
54612: LD_VAR 0 7
54616: PPUSH
54617: LD_VAR 0 8
54621: PPUSH
54622: LD_VAR 0 9
54626: PPUSH
54627: LD_VAR 0 4
54631: PPUSH
54632: LD_VAR 0 5
54636: PPUSH
54637: CALL 54679 0 6
54641: GO 54674
54643: LD_INT 304
54645: DOUBLE
54646: EQUAL
54647: IFTRUE 54651
54649: GO 54673
54651: POP
// hHackTeleport ( unit , x , y ) ; end ;
54652: LD_VAR 0 2
54656: PPUSH
54657: LD_VAR 0 4
54661: PPUSH
54662: LD_VAR 0 5
54666: PPUSH
54667: CALL 56438 0 3
54671: GO 54674
54673: POP
// end ;
54674: LD_VAR 0 12
54678: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
54679: LD_INT 0
54681: PPUSH
54682: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
54683: LD_VAR 0 1
54687: PUSH
54688: LD_INT 1
54690: LESS
54691: PUSH
54692: LD_VAR 0 1
54696: PUSH
54697: LD_INT 3
54699: GREATER
54700: OR
54701: PUSH
54702: LD_VAR 0 5
54706: PPUSH
54707: LD_VAR 0 6
54711: PPUSH
54712: CALL_OW 428
54716: OR
54717: IFFALSE 54721
// exit ;
54719: GO 55441
// uc_side := your_side ;
54721: LD_ADDR_OWVAR 20
54725: PUSH
54726: LD_OWVAR 2
54730: ST_TO_ADDR
// uc_nation := nation ;
54731: LD_ADDR_OWVAR 21
54735: PUSH
54736: LD_VAR 0 1
54740: ST_TO_ADDR
// bc_level = 1 ;
54741: LD_ADDR_OWVAR 43
54745: PUSH
54746: LD_INT 1
54748: ST_TO_ADDR
// case btype of 1 :
54749: LD_VAR 0 2
54753: PUSH
54754: LD_INT 1
54756: DOUBLE
54757: EQUAL
54758: IFTRUE 54762
54760: GO 54773
54762: POP
// bc_type := b_depot ; 2 :
54763: LD_ADDR_OWVAR 42
54767: PUSH
54768: LD_INT 0
54770: ST_TO_ADDR
54771: GO 55385
54773: LD_INT 2
54775: DOUBLE
54776: EQUAL
54777: IFTRUE 54781
54779: GO 54792
54781: POP
// bc_type := b_warehouse ; 3 :
54782: LD_ADDR_OWVAR 42
54786: PUSH
54787: LD_INT 1
54789: ST_TO_ADDR
54790: GO 55385
54792: LD_INT 3
54794: DOUBLE
54795: EQUAL
54796: IFTRUE 54800
54798: GO 54811
54800: POP
// bc_type := b_lab ; 4 .. 9 :
54801: LD_ADDR_OWVAR 42
54805: PUSH
54806: LD_INT 6
54808: ST_TO_ADDR
54809: GO 55385
54811: LD_INT 4
54813: DOUBLE
54814: GREATEREQUAL
54815: IFFALSE 54823
54817: LD_INT 9
54819: DOUBLE
54820: LESSEQUAL
54821: IFTRUE 54825
54823: GO 54877
54825: POP
// begin bc_type := b_lab_half ;
54826: LD_ADDR_OWVAR 42
54830: PUSH
54831: LD_INT 7
54833: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
54834: LD_ADDR_OWVAR 44
54838: PUSH
54839: LD_INT 10
54841: PUSH
54842: LD_INT 11
54844: PUSH
54845: LD_INT 12
54847: PUSH
54848: LD_INT 15
54850: PUSH
54851: LD_INT 14
54853: PUSH
54854: LD_INT 13
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: PUSH
54865: LD_VAR 0 2
54869: PUSH
54870: LD_INT 3
54872: MINUS
54873: ARRAY
54874: ST_TO_ADDR
// end ; 10 .. 13 :
54875: GO 55385
54877: LD_INT 10
54879: DOUBLE
54880: GREATEREQUAL
54881: IFFALSE 54889
54883: LD_INT 13
54885: DOUBLE
54886: LESSEQUAL
54887: IFTRUE 54891
54889: GO 54968
54891: POP
// begin bc_type := b_lab_full ;
54892: LD_ADDR_OWVAR 42
54896: PUSH
54897: LD_INT 8
54899: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
54900: LD_ADDR_OWVAR 44
54904: PUSH
54905: LD_INT 10
54907: PUSH
54908: LD_INT 12
54910: PUSH
54911: LD_INT 14
54913: PUSH
54914: LD_INT 13
54916: PUSH
54917: EMPTY
54918: LIST
54919: LIST
54920: LIST
54921: LIST
54922: PUSH
54923: LD_VAR 0 2
54927: PUSH
54928: LD_INT 9
54930: MINUS
54931: ARRAY
54932: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
54933: LD_ADDR_OWVAR 45
54937: PUSH
54938: LD_INT 11
54940: PUSH
54941: LD_INT 15
54943: PUSH
54944: LD_INT 12
54946: PUSH
54947: LD_INT 15
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: LIST
54955: PUSH
54956: LD_VAR 0 2
54960: PUSH
54961: LD_INT 9
54963: MINUS
54964: ARRAY
54965: ST_TO_ADDR
// end ; 14 :
54966: GO 55385
54968: LD_INT 14
54970: DOUBLE
54971: EQUAL
54972: IFTRUE 54976
54974: GO 54987
54976: POP
// bc_type := b_workshop ; 15 :
54977: LD_ADDR_OWVAR 42
54981: PUSH
54982: LD_INT 2
54984: ST_TO_ADDR
54985: GO 55385
54987: LD_INT 15
54989: DOUBLE
54990: EQUAL
54991: IFTRUE 54995
54993: GO 55006
54995: POP
// bc_type := b_factory ; 16 :
54996: LD_ADDR_OWVAR 42
55000: PUSH
55001: LD_INT 3
55003: ST_TO_ADDR
55004: GO 55385
55006: LD_INT 16
55008: DOUBLE
55009: EQUAL
55010: IFTRUE 55014
55012: GO 55025
55014: POP
// bc_type := b_ext_gun ; 17 :
55015: LD_ADDR_OWVAR 42
55019: PUSH
55020: LD_INT 17
55022: ST_TO_ADDR
55023: GO 55385
55025: LD_INT 17
55027: DOUBLE
55028: EQUAL
55029: IFTRUE 55033
55031: GO 55061
55033: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55034: LD_ADDR_OWVAR 42
55038: PUSH
55039: LD_INT 19
55041: PUSH
55042: LD_INT 23
55044: PUSH
55045: LD_INT 19
55047: PUSH
55048: EMPTY
55049: LIST
55050: LIST
55051: LIST
55052: PUSH
55053: LD_VAR 0 1
55057: ARRAY
55058: ST_TO_ADDR
55059: GO 55385
55061: LD_INT 18
55063: DOUBLE
55064: EQUAL
55065: IFTRUE 55069
55067: GO 55080
55069: POP
// bc_type := b_ext_radar ; 19 :
55070: LD_ADDR_OWVAR 42
55074: PUSH
55075: LD_INT 20
55077: ST_TO_ADDR
55078: GO 55385
55080: LD_INT 19
55082: DOUBLE
55083: EQUAL
55084: IFTRUE 55088
55086: GO 55099
55088: POP
// bc_type := b_ext_radio ; 20 :
55089: LD_ADDR_OWVAR 42
55093: PUSH
55094: LD_INT 22
55096: ST_TO_ADDR
55097: GO 55385
55099: LD_INT 20
55101: DOUBLE
55102: EQUAL
55103: IFTRUE 55107
55105: GO 55118
55107: POP
// bc_type := b_ext_siberium ; 21 :
55108: LD_ADDR_OWVAR 42
55112: PUSH
55113: LD_INT 21
55115: ST_TO_ADDR
55116: GO 55385
55118: LD_INT 21
55120: DOUBLE
55121: EQUAL
55122: IFTRUE 55126
55124: GO 55137
55126: POP
// bc_type := b_ext_computer ; 22 :
55127: LD_ADDR_OWVAR 42
55131: PUSH
55132: LD_INT 24
55134: ST_TO_ADDR
55135: GO 55385
55137: LD_INT 22
55139: DOUBLE
55140: EQUAL
55141: IFTRUE 55145
55143: GO 55156
55145: POP
// bc_type := b_ext_track ; 23 :
55146: LD_ADDR_OWVAR 42
55150: PUSH
55151: LD_INT 16
55153: ST_TO_ADDR
55154: GO 55385
55156: LD_INT 23
55158: DOUBLE
55159: EQUAL
55160: IFTRUE 55164
55162: GO 55175
55164: POP
// bc_type := b_ext_laser ; 24 :
55165: LD_ADDR_OWVAR 42
55169: PUSH
55170: LD_INT 25
55172: ST_TO_ADDR
55173: GO 55385
55175: LD_INT 24
55177: DOUBLE
55178: EQUAL
55179: IFTRUE 55183
55181: GO 55194
55183: POP
// bc_type := b_control_tower ; 25 :
55184: LD_ADDR_OWVAR 42
55188: PUSH
55189: LD_INT 36
55191: ST_TO_ADDR
55192: GO 55385
55194: LD_INT 25
55196: DOUBLE
55197: EQUAL
55198: IFTRUE 55202
55200: GO 55213
55202: POP
// bc_type := b_breastwork ; 26 :
55203: LD_ADDR_OWVAR 42
55207: PUSH
55208: LD_INT 31
55210: ST_TO_ADDR
55211: GO 55385
55213: LD_INT 26
55215: DOUBLE
55216: EQUAL
55217: IFTRUE 55221
55219: GO 55232
55221: POP
// bc_type := b_bunker ; 27 :
55222: LD_ADDR_OWVAR 42
55226: PUSH
55227: LD_INT 32
55229: ST_TO_ADDR
55230: GO 55385
55232: LD_INT 27
55234: DOUBLE
55235: EQUAL
55236: IFTRUE 55240
55238: GO 55251
55240: POP
// bc_type := b_turret ; 28 :
55241: LD_ADDR_OWVAR 42
55245: PUSH
55246: LD_INT 33
55248: ST_TO_ADDR
55249: GO 55385
55251: LD_INT 28
55253: DOUBLE
55254: EQUAL
55255: IFTRUE 55259
55257: GO 55270
55259: POP
// bc_type := b_armoury ; 29 :
55260: LD_ADDR_OWVAR 42
55264: PUSH
55265: LD_INT 4
55267: ST_TO_ADDR
55268: GO 55385
55270: LD_INT 29
55272: DOUBLE
55273: EQUAL
55274: IFTRUE 55278
55276: GO 55289
55278: POP
// bc_type := b_barracks ; 30 :
55279: LD_ADDR_OWVAR 42
55283: PUSH
55284: LD_INT 5
55286: ST_TO_ADDR
55287: GO 55385
55289: LD_INT 30
55291: DOUBLE
55292: EQUAL
55293: IFTRUE 55297
55295: GO 55308
55297: POP
// bc_type := b_solar_power ; 31 :
55298: LD_ADDR_OWVAR 42
55302: PUSH
55303: LD_INT 27
55305: ST_TO_ADDR
55306: GO 55385
55308: LD_INT 31
55310: DOUBLE
55311: EQUAL
55312: IFTRUE 55316
55314: GO 55327
55316: POP
// bc_type := b_oil_power ; 32 :
55317: LD_ADDR_OWVAR 42
55321: PUSH
55322: LD_INT 26
55324: ST_TO_ADDR
55325: GO 55385
55327: LD_INT 32
55329: DOUBLE
55330: EQUAL
55331: IFTRUE 55335
55333: GO 55346
55335: POP
// bc_type := b_siberite_power ; 33 :
55336: LD_ADDR_OWVAR 42
55340: PUSH
55341: LD_INT 28
55343: ST_TO_ADDR
55344: GO 55385
55346: LD_INT 33
55348: DOUBLE
55349: EQUAL
55350: IFTRUE 55354
55352: GO 55365
55354: POP
// bc_type := b_oil_mine ; 34 :
55355: LD_ADDR_OWVAR 42
55359: PUSH
55360: LD_INT 29
55362: ST_TO_ADDR
55363: GO 55385
55365: LD_INT 34
55367: DOUBLE
55368: EQUAL
55369: IFTRUE 55373
55371: GO 55384
55373: POP
// bc_type := b_siberite_mine ; end ;
55374: LD_ADDR_OWVAR 42
55378: PUSH
55379: LD_INT 30
55381: ST_TO_ADDR
55382: GO 55385
55384: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
55385: LD_ADDR_VAR 0 8
55389: PUSH
55390: LD_VAR 0 5
55394: PPUSH
55395: LD_VAR 0 6
55399: PPUSH
55400: LD_VAR 0 3
55404: PPUSH
55405: CALL_OW 47
55409: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
55410: LD_OWVAR 42
55414: PUSH
55415: LD_INT 32
55417: PUSH
55418: LD_INT 33
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: IN
55425: IFFALSE 55441
// PlaceWeaponTurret ( b , weapon ) ;
55427: LD_VAR 0 8
55431: PPUSH
55432: LD_VAR 0 4
55436: PPUSH
55437: CALL_OW 431
// end ;
55441: LD_VAR 0 7
55445: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
55446: LD_INT 0
55448: PPUSH
55449: PPUSH
55450: PPUSH
55451: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
55452: LD_ADDR_VAR 0 4
55456: PUSH
55457: LD_INT 22
55459: PUSH
55460: LD_OWVAR 2
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 2
55471: PUSH
55472: LD_INT 30
55474: PUSH
55475: LD_INT 0
55477: PUSH
55478: EMPTY
55479: LIST
55480: LIST
55481: PUSH
55482: LD_INT 30
55484: PUSH
55485: LD_INT 1
55487: PUSH
55488: EMPTY
55489: LIST
55490: LIST
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: LIST
55496: PUSH
55497: EMPTY
55498: LIST
55499: LIST
55500: PPUSH
55501: CALL_OW 69
55505: ST_TO_ADDR
// if not tmp then
55506: LD_VAR 0 4
55510: NOT
55511: IFFALSE 55515
// exit ;
55513: GO 55574
// for i in tmp do
55515: LD_ADDR_VAR 0 2
55519: PUSH
55520: LD_VAR 0 4
55524: PUSH
55525: FOR_IN
55526: IFFALSE 55572
// for j = 1 to 3 do
55528: LD_ADDR_VAR 0 3
55532: PUSH
55533: DOUBLE
55534: LD_INT 1
55536: DEC
55537: ST_TO_ADDR
55538: LD_INT 3
55540: PUSH
55541: FOR_TO
55542: IFFALSE 55568
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
55544: LD_VAR 0 2
55548: PPUSH
55549: CALL_OW 274
55553: PPUSH
55554: LD_VAR 0 3
55558: PPUSH
55559: LD_INT 99999
55561: PPUSH
55562: CALL_OW 277
55566: GO 55541
55568: POP
55569: POP
55570: GO 55525
55572: POP
55573: POP
// end ;
55574: LD_VAR 0 1
55578: RET
// export function hHackSetLevel10 ; var i , j ; begin
55579: LD_INT 0
55581: PPUSH
55582: PPUSH
55583: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55584: LD_ADDR_VAR 0 2
55588: PUSH
55589: LD_INT 21
55591: PUSH
55592: LD_INT 1
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PPUSH
55599: CALL_OW 69
55603: PUSH
55604: FOR_IN
55605: IFFALSE 55657
// if IsSelected ( i ) then
55607: LD_VAR 0 2
55611: PPUSH
55612: CALL_OW 306
55616: IFFALSE 55655
// begin for j := 1 to 4 do
55618: LD_ADDR_VAR 0 3
55622: PUSH
55623: DOUBLE
55624: LD_INT 1
55626: DEC
55627: ST_TO_ADDR
55628: LD_INT 4
55630: PUSH
55631: FOR_TO
55632: IFFALSE 55653
// SetSkill ( i , j , 10 ) ;
55634: LD_VAR 0 2
55638: PPUSH
55639: LD_VAR 0 3
55643: PPUSH
55644: LD_INT 10
55646: PPUSH
55647: CALL_OW 237
55651: GO 55631
55653: POP
55654: POP
// end ;
55655: GO 55604
55657: POP
55658: POP
// end ;
55659: LD_VAR 0 1
55663: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
55664: LD_INT 0
55666: PPUSH
55667: PPUSH
55668: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55669: LD_ADDR_VAR 0 2
55673: PUSH
55674: LD_INT 22
55676: PUSH
55677: LD_OWVAR 2
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: PUSH
55686: LD_INT 21
55688: PUSH
55689: LD_INT 1
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PPUSH
55700: CALL_OW 69
55704: PUSH
55705: FOR_IN
55706: IFFALSE 55747
// begin for j := 1 to 4 do
55708: LD_ADDR_VAR 0 3
55712: PUSH
55713: DOUBLE
55714: LD_INT 1
55716: DEC
55717: ST_TO_ADDR
55718: LD_INT 4
55720: PUSH
55721: FOR_TO
55722: IFFALSE 55743
// SetSkill ( i , j , 10 ) ;
55724: LD_VAR 0 2
55728: PPUSH
55729: LD_VAR 0 3
55733: PPUSH
55734: LD_INT 10
55736: PPUSH
55737: CALL_OW 237
55741: GO 55721
55743: POP
55744: POP
// end ;
55745: GO 55705
55747: POP
55748: POP
// end ;
55749: LD_VAR 0 1
55753: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
55754: LD_INT 0
55756: PPUSH
// uc_side := your_side ;
55757: LD_ADDR_OWVAR 20
55761: PUSH
55762: LD_OWVAR 2
55766: ST_TO_ADDR
// uc_nation := nation ;
55767: LD_ADDR_OWVAR 21
55771: PUSH
55772: LD_VAR 0 1
55776: ST_TO_ADDR
// InitHc ;
55777: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55781: LD_INT 0
55783: PPUSH
55784: LD_VAR 0 2
55788: PPUSH
55789: LD_VAR 0 3
55793: PPUSH
55794: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
55798: LD_VAR 0 4
55802: PPUSH
55803: LD_VAR 0 5
55807: PPUSH
55808: CALL_OW 428
55812: PUSH
55813: LD_INT 0
55815: EQUAL
55816: IFFALSE 55840
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
55818: CALL_OW 44
55822: PPUSH
55823: LD_VAR 0 4
55827: PPUSH
55828: LD_VAR 0 5
55832: PPUSH
55833: LD_INT 1
55835: PPUSH
55836: CALL_OW 48
// end ;
55840: LD_VAR 0 6
55844: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
55845: LD_INT 0
55847: PPUSH
55848: PPUSH
// uc_side := your_side ;
55849: LD_ADDR_OWVAR 20
55853: PUSH
55854: LD_OWVAR 2
55858: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
55859: LD_VAR 0 1
55863: PUSH
55864: LD_INT 1
55866: PUSH
55867: LD_INT 2
55869: PUSH
55870: LD_INT 3
55872: PUSH
55873: LD_INT 4
55875: PUSH
55876: LD_INT 5
55878: PUSH
55879: EMPTY
55880: LIST
55881: LIST
55882: LIST
55883: LIST
55884: LIST
55885: IN
55886: IFFALSE 55898
// uc_nation := nation_american else
55888: LD_ADDR_OWVAR 21
55892: PUSH
55893: LD_INT 1
55895: ST_TO_ADDR
55896: GO 55941
// if chassis in [ 11 , 12 , 13 , 14 ] then
55898: LD_VAR 0 1
55902: PUSH
55903: LD_INT 11
55905: PUSH
55906: LD_INT 12
55908: PUSH
55909: LD_INT 13
55911: PUSH
55912: LD_INT 14
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: LIST
55919: LIST
55920: IN
55921: IFFALSE 55933
// uc_nation := nation_arabian else
55923: LD_ADDR_OWVAR 21
55927: PUSH
55928: LD_INT 2
55930: ST_TO_ADDR
55931: GO 55941
// uc_nation := nation_russian ;
55933: LD_ADDR_OWVAR 21
55937: PUSH
55938: LD_INT 3
55940: ST_TO_ADDR
// vc_chassis := chassis ;
55941: LD_ADDR_OWVAR 37
55945: PUSH
55946: LD_VAR 0 1
55950: ST_TO_ADDR
// vc_engine := engine ;
55951: LD_ADDR_OWVAR 39
55955: PUSH
55956: LD_VAR 0 2
55960: ST_TO_ADDR
// vc_control := control ;
55961: LD_ADDR_OWVAR 38
55965: PUSH
55966: LD_VAR 0 3
55970: ST_TO_ADDR
// vc_weapon := weapon ;
55971: LD_ADDR_OWVAR 40
55975: PUSH
55976: LD_VAR 0 4
55980: ST_TO_ADDR
// un := CreateVehicle ;
55981: LD_ADDR_VAR 0 8
55985: PUSH
55986: CALL_OW 45
55990: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
55991: LD_VAR 0 8
55995: PPUSH
55996: LD_INT 0
55998: PPUSH
55999: LD_INT 5
56001: PPUSH
56002: CALL_OW 12
56006: PPUSH
56007: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56011: LD_VAR 0 8
56015: PPUSH
56016: LD_VAR 0 5
56020: PPUSH
56021: LD_VAR 0 6
56025: PPUSH
56026: LD_INT 1
56028: PPUSH
56029: CALL_OW 48
// end ;
56033: LD_VAR 0 7
56037: RET
// export hInvincible ; every 1 do
56038: GO 56040
56040: DISABLE
// hInvincible := [ ] ;
56041: LD_ADDR_EXP 146
56045: PUSH
56046: EMPTY
56047: ST_TO_ADDR
56048: END
// every 10 do var i ;
56049: GO 56051
56051: DISABLE
56052: LD_INT 0
56054: PPUSH
// begin enable ;
56055: ENABLE
// if not hInvincible then
56056: LD_EXP 146
56060: NOT
56061: IFFALSE 56065
// exit ;
56063: GO 56109
// for i in hInvincible do
56065: LD_ADDR_VAR 0 1
56069: PUSH
56070: LD_EXP 146
56074: PUSH
56075: FOR_IN
56076: IFFALSE 56107
// if GetLives ( i ) < 1000 then
56078: LD_VAR 0 1
56082: PPUSH
56083: CALL_OW 256
56087: PUSH
56088: LD_INT 1000
56090: LESS
56091: IFFALSE 56105
// SetLives ( i , 1000 ) ;
56093: LD_VAR 0 1
56097: PPUSH
56098: LD_INT 1000
56100: PPUSH
56101: CALL_OW 234
56105: GO 56075
56107: POP
56108: POP
// end ;
56109: PPOPN 1
56111: END
// export function hHackInvincible ; var i ; begin
56112: LD_INT 0
56114: PPUSH
56115: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56116: LD_ADDR_VAR 0 2
56120: PUSH
56121: LD_INT 2
56123: PUSH
56124: LD_INT 21
56126: PUSH
56127: LD_INT 1
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: PUSH
56134: LD_INT 21
56136: PUSH
56137: LD_INT 2
56139: PUSH
56140: EMPTY
56141: LIST
56142: LIST
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: LIST
56148: PPUSH
56149: CALL_OW 69
56153: PUSH
56154: FOR_IN
56155: IFFALSE 56216
// if IsSelected ( i ) then
56157: LD_VAR 0 2
56161: PPUSH
56162: CALL_OW 306
56166: IFFALSE 56214
// begin if i in hInvincible then
56168: LD_VAR 0 2
56172: PUSH
56173: LD_EXP 146
56177: IN
56178: IFFALSE 56198
// hInvincible := hInvincible diff i else
56180: LD_ADDR_EXP 146
56184: PUSH
56185: LD_EXP 146
56189: PUSH
56190: LD_VAR 0 2
56194: DIFF
56195: ST_TO_ADDR
56196: GO 56214
// hInvincible := hInvincible union i ;
56198: LD_ADDR_EXP 146
56202: PUSH
56203: LD_EXP 146
56207: PUSH
56208: LD_VAR 0 2
56212: UNION
56213: ST_TO_ADDR
// end ;
56214: GO 56154
56216: POP
56217: POP
// end ;
56218: LD_VAR 0 1
56222: RET
// export function hHackInvisible ; var i , j ; begin
56223: LD_INT 0
56225: PPUSH
56226: PPUSH
56227: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56228: LD_ADDR_VAR 0 2
56232: PUSH
56233: LD_INT 21
56235: PUSH
56236: LD_INT 1
56238: PUSH
56239: EMPTY
56240: LIST
56241: LIST
56242: PPUSH
56243: CALL_OW 69
56247: PUSH
56248: FOR_IN
56249: IFFALSE 56273
// if IsSelected ( i ) then
56251: LD_VAR 0 2
56255: PPUSH
56256: CALL_OW 306
56260: IFFALSE 56271
// ComForceInvisible ( i ) ;
56262: LD_VAR 0 2
56266: PPUSH
56267: CALL_OW 496
56271: GO 56248
56273: POP
56274: POP
// end ;
56275: LD_VAR 0 1
56279: RET
// export function hHackChangeYourSide ; begin
56280: LD_INT 0
56282: PPUSH
// if your_side = 8 then
56283: LD_OWVAR 2
56287: PUSH
56288: LD_INT 8
56290: EQUAL
56291: IFFALSE 56303
// your_side := 0 else
56293: LD_ADDR_OWVAR 2
56297: PUSH
56298: LD_INT 0
56300: ST_TO_ADDR
56301: GO 56317
// your_side := your_side + 1 ;
56303: LD_ADDR_OWVAR 2
56307: PUSH
56308: LD_OWVAR 2
56312: PUSH
56313: LD_INT 1
56315: PLUS
56316: ST_TO_ADDR
// end ;
56317: LD_VAR 0 1
56321: RET
// export function hHackChangeUnitSide ; var i , j ; begin
56322: LD_INT 0
56324: PPUSH
56325: PPUSH
56326: PPUSH
// for i in all_units do
56327: LD_ADDR_VAR 0 2
56331: PUSH
56332: LD_OWVAR 3
56336: PUSH
56337: FOR_IN
56338: IFFALSE 56416
// if IsSelected ( i ) then
56340: LD_VAR 0 2
56344: PPUSH
56345: CALL_OW 306
56349: IFFALSE 56414
// begin j := GetSide ( i ) ;
56351: LD_ADDR_VAR 0 3
56355: PUSH
56356: LD_VAR 0 2
56360: PPUSH
56361: CALL_OW 255
56365: ST_TO_ADDR
// if j = 8 then
56366: LD_VAR 0 3
56370: PUSH
56371: LD_INT 8
56373: EQUAL
56374: IFFALSE 56386
// j := 0 else
56376: LD_ADDR_VAR 0 3
56380: PUSH
56381: LD_INT 0
56383: ST_TO_ADDR
56384: GO 56400
// j := j + 1 ;
56386: LD_ADDR_VAR 0 3
56390: PUSH
56391: LD_VAR 0 3
56395: PUSH
56396: LD_INT 1
56398: PLUS
56399: ST_TO_ADDR
// SetSide ( i , j ) ;
56400: LD_VAR 0 2
56404: PPUSH
56405: LD_VAR 0 3
56409: PPUSH
56410: CALL_OW 235
// end ;
56414: GO 56337
56416: POP
56417: POP
// end ;
56418: LD_VAR 0 1
56422: RET
// export function hHackFog ; begin
56423: LD_INT 0
56425: PPUSH
// FogOff ( true ) ;
56426: LD_INT 1
56428: PPUSH
56429: CALL_OW 344
// end ;
56433: LD_VAR 0 1
56437: RET
// export function hHackTeleport ( unit , x , y ) ; begin
56438: LD_INT 0
56440: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
56441: LD_VAR 0 1
56445: PPUSH
56446: LD_VAR 0 2
56450: PPUSH
56451: LD_VAR 0 3
56455: PPUSH
56456: LD_INT 1
56458: PPUSH
56459: LD_INT 1
56461: PPUSH
56462: CALL_OW 483
// CenterOnXY ( x , y ) ;
56466: LD_VAR 0 2
56470: PPUSH
56471: LD_VAR 0 3
56475: PPUSH
56476: CALL_OW 84
// end ; end_of_file
56480: LD_VAR 0 4
56484: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56485: LD_INT 0
56487: PPUSH
56488: PPUSH
56489: PPUSH
56490: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56491: LD_VAR 0 1
56495: PPUSH
56496: CALL_OW 264
56500: PUSH
56501: LD_EXP 77
56505: EQUAL
56506: IFFALSE 56578
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56508: LD_INT 68
56510: PPUSH
56511: LD_VAR 0 1
56515: PPUSH
56516: CALL_OW 255
56520: PPUSH
56521: CALL_OW 321
56525: PUSH
56526: LD_INT 2
56528: EQUAL
56529: IFFALSE 56541
// eff := 70 else
56531: LD_ADDR_VAR 0 4
56535: PUSH
56536: LD_INT 70
56538: ST_TO_ADDR
56539: GO 56549
// eff := 30 ;
56541: LD_ADDR_VAR 0 4
56545: PUSH
56546: LD_INT 30
56548: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56549: LD_VAR 0 1
56553: PPUSH
56554: CALL_OW 250
56558: PPUSH
56559: LD_VAR 0 1
56563: PPUSH
56564: CALL_OW 251
56568: PPUSH
56569: LD_VAR 0 4
56573: PPUSH
56574: CALL_OW 495
// end ; end ;
56578: LD_VAR 0 2
56582: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56583: LD_INT 0
56585: PPUSH
// end ;
56586: LD_VAR 0 4
56590: RET
// export function SOS_Command ( cmd ) ; begin
56591: LD_INT 0
56593: PPUSH
// end ;
56594: LD_VAR 0 2
56598: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
56599: LD_INT 0
56601: PPUSH
// if cmd = 121 then
56602: LD_VAR 0 1
56606: PUSH
56607: LD_INT 121
56609: EQUAL
56610: IFFALSE 56612
// end ;
56612: LD_VAR 0 6
56616: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56617: LD_INT 0
56619: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56620: LD_VAR 0 1
56624: PUSH
56625: LD_INT 250
56627: EQUAL
56628: PUSH
56629: LD_VAR 0 2
56633: PPUSH
56634: CALL_OW 264
56638: PUSH
56639: LD_EXP 80
56643: EQUAL
56644: AND
56645: IFFALSE 56666
// MinerPlaceMine ( unit , x , y ) ;
56647: LD_VAR 0 2
56651: PPUSH
56652: LD_VAR 0 4
56656: PPUSH
56657: LD_VAR 0 5
56661: PPUSH
56662: CALL 59015 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56666: LD_VAR 0 1
56670: PUSH
56671: LD_INT 251
56673: EQUAL
56674: PUSH
56675: LD_VAR 0 2
56679: PPUSH
56680: CALL_OW 264
56684: PUSH
56685: LD_EXP 80
56689: EQUAL
56690: AND
56691: IFFALSE 56712
// MinerDetonateMine ( unit , x , y ) ;
56693: LD_VAR 0 2
56697: PPUSH
56698: LD_VAR 0 4
56702: PPUSH
56703: LD_VAR 0 5
56707: PPUSH
56708: CALL 59292 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
56712: LD_VAR 0 1
56716: PUSH
56717: LD_INT 252
56719: EQUAL
56720: PUSH
56721: LD_VAR 0 2
56725: PPUSH
56726: CALL_OW 264
56730: PUSH
56731: LD_EXP 80
56735: EQUAL
56736: AND
56737: IFFALSE 56758
// MinerCreateMinefield ( unit , x , y ) ;
56739: LD_VAR 0 2
56743: PPUSH
56744: LD_VAR 0 4
56748: PPUSH
56749: LD_VAR 0 5
56753: PPUSH
56754: CALL 59709 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
56758: LD_VAR 0 1
56762: PUSH
56763: LD_INT 253
56765: EQUAL
56766: PUSH
56767: LD_VAR 0 2
56771: PPUSH
56772: CALL_OW 257
56776: PUSH
56777: LD_INT 5
56779: EQUAL
56780: AND
56781: IFFALSE 56802
// ComBinocular ( unit , x , y ) ;
56783: LD_VAR 0 2
56787: PPUSH
56788: LD_VAR 0 4
56792: PPUSH
56793: LD_VAR 0 5
56797: PPUSH
56798: CALL 60080 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56802: LD_VAR 0 1
56806: PUSH
56807: LD_INT 254
56809: EQUAL
56810: PUSH
56811: LD_VAR 0 2
56815: PPUSH
56816: CALL_OW 264
56820: PUSH
56821: LD_EXP 75
56825: EQUAL
56826: AND
56827: PUSH
56828: LD_VAR 0 3
56832: PPUSH
56833: CALL_OW 263
56837: PUSH
56838: LD_INT 3
56840: EQUAL
56841: AND
56842: IFFALSE 56858
// HackDestroyVehicle ( unit , selectedUnit ) ;
56844: LD_VAR 0 2
56848: PPUSH
56849: LD_VAR 0 3
56853: PPUSH
56854: CALL 58375 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56858: LD_VAR 0 1
56862: PUSH
56863: LD_INT 255
56865: EQUAL
56866: PUSH
56867: LD_VAR 0 2
56871: PPUSH
56872: CALL_OW 264
56876: PUSH
56877: LD_INT 14
56879: PUSH
56880: LD_INT 53
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: IN
56887: AND
56888: PUSH
56889: LD_VAR 0 4
56893: PPUSH
56894: LD_VAR 0 5
56898: PPUSH
56899: CALL_OW 488
56903: AND
56904: IFFALSE 56928
// CutTreeXYR ( unit , x , y , 12 ) ;
56906: LD_VAR 0 2
56910: PPUSH
56911: LD_VAR 0 4
56915: PPUSH
56916: LD_VAR 0 5
56920: PPUSH
56921: LD_INT 12
56923: PPUSH
56924: CALL 56941 0 4
// end ;
56928: LD_VAR 0 6
56932: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
56933: LD_INT 0
56935: PPUSH
// end ;
56936: LD_VAR 0 4
56940: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56941: LD_INT 0
56943: PPUSH
56944: PPUSH
56945: PPUSH
56946: PPUSH
56947: PPUSH
56948: PPUSH
56949: PPUSH
56950: PPUSH
56951: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56952: LD_VAR 0 1
56956: NOT
56957: PUSH
56958: LD_VAR 0 2
56962: PPUSH
56963: LD_VAR 0 3
56967: PPUSH
56968: CALL_OW 488
56972: NOT
56973: OR
56974: PUSH
56975: LD_VAR 0 4
56979: NOT
56980: OR
56981: IFFALSE 56985
// exit ;
56983: GO 57325
// list := [ ] ;
56985: LD_ADDR_VAR 0 13
56989: PUSH
56990: EMPTY
56991: ST_TO_ADDR
// if x - r < 0 then
56992: LD_VAR 0 2
56996: PUSH
56997: LD_VAR 0 4
57001: MINUS
57002: PUSH
57003: LD_INT 0
57005: LESS
57006: IFFALSE 57018
// min_x := 0 else
57008: LD_ADDR_VAR 0 7
57012: PUSH
57013: LD_INT 0
57015: ST_TO_ADDR
57016: GO 57034
// min_x := x - r ;
57018: LD_ADDR_VAR 0 7
57022: PUSH
57023: LD_VAR 0 2
57027: PUSH
57028: LD_VAR 0 4
57032: MINUS
57033: ST_TO_ADDR
// if y - r < 0 then
57034: LD_VAR 0 3
57038: PUSH
57039: LD_VAR 0 4
57043: MINUS
57044: PUSH
57045: LD_INT 0
57047: LESS
57048: IFFALSE 57060
// min_y := 0 else
57050: LD_ADDR_VAR 0 8
57054: PUSH
57055: LD_INT 0
57057: ST_TO_ADDR
57058: GO 57076
// min_y := y - r ;
57060: LD_ADDR_VAR 0 8
57064: PUSH
57065: LD_VAR 0 3
57069: PUSH
57070: LD_VAR 0 4
57074: MINUS
57075: ST_TO_ADDR
// max_x := x + r ;
57076: LD_ADDR_VAR 0 9
57080: PUSH
57081: LD_VAR 0 2
57085: PUSH
57086: LD_VAR 0 4
57090: PLUS
57091: ST_TO_ADDR
// max_y := y + r ;
57092: LD_ADDR_VAR 0 10
57096: PUSH
57097: LD_VAR 0 3
57101: PUSH
57102: LD_VAR 0 4
57106: PLUS
57107: ST_TO_ADDR
// for _x = min_x to max_x do
57108: LD_ADDR_VAR 0 11
57112: PUSH
57113: DOUBLE
57114: LD_VAR 0 7
57118: DEC
57119: ST_TO_ADDR
57120: LD_VAR 0 9
57124: PUSH
57125: FOR_TO
57126: IFFALSE 57243
// for _y = min_y to max_y do
57128: LD_ADDR_VAR 0 12
57132: PUSH
57133: DOUBLE
57134: LD_VAR 0 8
57138: DEC
57139: ST_TO_ADDR
57140: LD_VAR 0 10
57144: PUSH
57145: FOR_TO
57146: IFFALSE 57239
// begin if not ValidHex ( _x , _y ) then
57148: LD_VAR 0 11
57152: PPUSH
57153: LD_VAR 0 12
57157: PPUSH
57158: CALL_OW 488
57162: NOT
57163: IFFALSE 57167
// continue ;
57165: GO 57145
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57167: LD_VAR 0 11
57171: PPUSH
57172: LD_VAR 0 12
57176: PPUSH
57177: CALL_OW 351
57181: PUSH
57182: LD_VAR 0 11
57186: PPUSH
57187: LD_VAR 0 12
57191: PPUSH
57192: CALL_OW 554
57196: AND
57197: IFFALSE 57237
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57199: LD_ADDR_VAR 0 13
57203: PUSH
57204: LD_VAR 0 13
57208: PPUSH
57209: LD_VAR 0 13
57213: PUSH
57214: LD_INT 1
57216: PLUS
57217: PPUSH
57218: LD_VAR 0 11
57222: PUSH
57223: LD_VAR 0 12
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PPUSH
57232: CALL_OW 2
57236: ST_TO_ADDR
// end ;
57237: GO 57145
57239: POP
57240: POP
57241: GO 57125
57243: POP
57244: POP
// if not list then
57245: LD_VAR 0 13
57249: NOT
57250: IFFALSE 57254
// exit ;
57252: GO 57325
// for i in list do
57254: LD_ADDR_VAR 0 6
57258: PUSH
57259: LD_VAR 0 13
57263: PUSH
57264: FOR_IN
57265: IFFALSE 57323
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57267: LD_VAR 0 1
57271: PPUSH
57272: LD_STRING M
57274: PUSH
57275: LD_VAR 0 6
57279: PUSH
57280: LD_INT 1
57282: ARRAY
57283: PUSH
57284: LD_VAR 0 6
57288: PUSH
57289: LD_INT 2
57291: ARRAY
57292: PUSH
57293: LD_INT 0
57295: PUSH
57296: LD_INT 0
57298: PUSH
57299: LD_INT 0
57301: PUSH
57302: LD_INT 0
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: LIST
57309: LIST
57310: LIST
57311: LIST
57312: LIST
57313: PUSH
57314: EMPTY
57315: LIST
57316: PPUSH
57317: CALL_OW 447
57321: GO 57264
57323: POP
57324: POP
// end ;
57325: LD_VAR 0 5
57329: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57330: LD_EXP 149
57334: NOT
57335: IFFALSE 57385
57337: GO 57339
57339: DISABLE
// begin initHack := true ;
57340: LD_ADDR_EXP 149
57344: PUSH
57345: LD_INT 1
57347: ST_TO_ADDR
// hackTanks := [ ] ;
57348: LD_ADDR_EXP 150
57352: PUSH
57353: EMPTY
57354: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57355: LD_ADDR_EXP 151
57359: PUSH
57360: EMPTY
57361: ST_TO_ADDR
// hackLimit := 3 ;
57362: LD_ADDR_EXP 152
57366: PUSH
57367: LD_INT 3
57369: ST_TO_ADDR
// hackDist := 12 ;
57370: LD_ADDR_EXP 153
57374: PUSH
57375: LD_INT 12
57377: ST_TO_ADDR
// hackCounter := [ ] ;
57378: LD_ADDR_EXP 154
57382: PUSH
57383: EMPTY
57384: ST_TO_ADDR
// end ;
57385: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57386: LD_EXP 149
57390: PUSH
57391: LD_INT 34
57393: PUSH
57394: LD_EXP 75
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: PPUSH
57403: CALL_OW 69
57407: AND
57408: IFFALSE 57663
57410: GO 57412
57412: DISABLE
57413: LD_INT 0
57415: PPUSH
57416: PPUSH
// begin enable ;
57417: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57418: LD_ADDR_VAR 0 1
57422: PUSH
57423: LD_INT 34
57425: PUSH
57426: LD_EXP 75
57430: PUSH
57431: EMPTY
57432: LIST
57433: LIST
57434: PPUSH
57435: CALL_OW 69
57439: PUSH
57440: FOR_IN
57441: IFFALSE 57661
// begin if not i in hackTanks then
57443: LD_VAR 0 1
57447: PUSH
57448: LD_EXP 150
57452: IN
57453: NOT
57454: IFFALSE 57537
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57456: LD_ADDR_EXP 150
57460: PUSH
57461: LD_EXP 150
57465: PPUSH
57466: LD_EXP 150
57470: PUSH
57471: LD_INT 1
57473: PLUS
57474: PPUSH
57475: LD_VAR 0 1
57479: PPUSH
57480: CALL_OW 1
57484: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57485: LD_ADDR_EXP 151
57489: PUSH
57490: LD_EXP 151
57494: PPUSH
57495: LD_EXP 151
57499: PUSH
57500: LD_INT 1
57502: PLUS
57503: PPUSH
57504: EMPTY
57505: PPUSH
57506: CALL_OW 1
57510: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57511: LD_ADDR_EXP 154
57515: PUSH
57516: LD_EXP 154
57520: PPUSH
57521: LD_EXP 154
57525: PUSH
57526: LD_INT 1
57528: PLUS
57529: PPUSH
57530: EMPTY
57531: PPUSH
57532: CALL_OW 1
57536: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57537: LD_VAR 0 1
57541: PPUSH
57542: CALL_OW 302
57546: NOT
57547: IFFALSE 57560
// begin HackUnlinkAll ( i ) ;
57549: LD_VAR 0 1
57553: PPUSH
57554: CALL 57666 0 1
// continue ;
57558: GO 57440
// end ; HackCheckCapturedStatus ( i ) ;
57560: LD_VAR 0 1
57564: PPUSH
57565: CALL 58109 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57569: LD_ADDR_VAR 0 2
57573: PUSH
57574: LD_INT 81
57576: PUSH
57577: LD_VAR 0 1
57581: PPUSH
57582: CALL_OW 255
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: PUSH
57591: LD_INT 33
57593: PUSH
57594: LD_INT 3
57596: PUSH
57597: EMPTY
57598: LIST
57599: LIST
57600: PUSH
57601: LD_INT 91
57603: PUSH
57604: LD_VAR 0 1
57608: PUSH
57609: LD_EXP 153
57613: PUSH
57614: EMPTY
57615: LIST
57616: LIST
57617: LIST
57618: PUSH
57619: LD_INT 50
57621: PUSH
57622: EMPTY
57623: LIST
57624: PUSH
57625: EMPTY
57626: LIST
57627: LIST
57628: LIST
57629: LIST
57630: PPUSH
57631: CALL_OW 69
57635: ST_TO_ADDR
// if not tmp then
57636: LD_VAR 0 2
57640: NOT
57641: IFFALSE 57645
// continue ;
57643: GO 57440
// HackLink ( i , tmp ) ;
57645: LD_VAR 0 1
57649: PPUSH
57650: LD_VAR 0 2
57654: PPUSH
57655: CALL 57802 0 2
// end ;
57659: GO 57440
57661: POP
57662: POP
// end ;
57663: PPOPN 2
57665: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57666: LD_INT 0
57668: PPUSH
57669: PPUSH
57670: PPUSH
// if not hack in hackTanks then
57671: LD_VAR 0 1
57675: PUSH
57676: LD_EXP 150
57680: IN
57681: NOT
57682: IFFALSE 57686
// exit ;
57684: GO 57797
// index := GetElementIndex ( hackTanks , hack ) ;
57686: LD_ADDR_VAR 0 4
57690: PUSH
57691: LD_EXP 150
57695: PPUSH
57696: LD_VAR 0 1
57700: PPUSH
57701: CALL 65271 0 2
57705: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57706: LD_EXP 151
57710: PUSH
57711: LD_VAR 0 4
57715: ARRAY
57716: IFFALSE 57797
// begin for i in hackTanksCaptured [ index ] do
57718: LD_ADDR_VAR 0 3
57722: PUSH
57723: LD_EXP 151
57727: PUSH
57728: LD_VAR 0 4
57732: ARRAY
57733: PUSH
57734: FOR_IN
57735: IFFALSE 57761
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57737: LD_VAR 0 3
57741: PUSH
57742: LD_INT 1
57744: ARRAY
57745: PPUSH
57746: LD_VAR 0 3
57750: PUSH
57751: LD_INT 2
57753: ARRAY
57754: PPUSH
57755: CALL_OW 235
57759: GO 57734
57761: POP
57762: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57763: LD_ADDR_EXP 151
57767: PUSH
57768: LD_EXP 151
57772: PPUSH
57773: LD_VAR 0 4
57777: PPUSH
57778: EMPTY
57779: PPUSH
57780: CALL_OW 1
57784: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57785: LD_VAR 0 1
57789: PPUSH
57790: LD_INT 0
57792: PPUSH
57793: CALL_OW 505
// end ; end ;
57797: LD_VAR 0 2
57801: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57802: LD_INT 0
57804: PPUSH
57805: PPUSH
57806: PPUSH
// if not hack in hackTanks or not vehicles then
57807: LD_VAR 0 1
57811: PUSH
57812: LD_EXP 150
57816: IN
57817: NOT
57818: PUSH
57819: LD_VAR 0 2
57823: NOT
57824: OR
57825: IFFALSE 57829
// exit ;
57827: GO 58104
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57829: LD_ADDR_VAR 0 2
57833: PUSH
57834: LD_VAR 0 1
57838: PPUSH
57839: LD_VAR 0 2
57843: PPUSH
57844: LD_INT 1
57846: PPUSH
57847: LD_INT 1
57849: PPUSH
57850: CALL 65921 0 4
57854: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57855: LD_ADDR_VAR 0 5
57859: PUSH
57860: LD_EXP 150
57864: PPUSH
57865: LD_VAR 0 1
57869: PPUSH
57870: CALL 65271 0 2
57874: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57875: LD_EXP 151
57879: PUSH
57880: LD_VAR 0 5
57884: ARRAY
57885: PUSH
57886: LD_EXP 152
57890: LESS
57891: IFFALSE 58080
// begin for i := 1 to vehicles do
57893: LD_ADDR_VAR 0 4
57897: PUSH
57898: DOUBLE
57899: LD_INT 1
57901: DEC
57902: ST_TO_ADDR
57903: LD_VAR 0 2
57907: PUSH
57908: FOR_TO
57909: IFFALSE 58078
// begin if hackTanksCaptured [ index ] = hackLimit then
57911: LD_EXP 151
57915: PUSH
57916: LD_VAR 0 5
57920: ARRAY
57921: PUSH
57922: LD_EXP 152
57926: EQUAL
57927: IFFALSE 57931
// break ;
57929: GO 58078
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57931: LD_ADDR_EXP 154
57935: PUSH
57936: LD_EXP 154
57940: PPUSH
57941: LD_VAR 0 5
57945: PPUSH
57946: LD_EXP 154
57950: PUSH
57951: LD_VAR 0 5
57955: ARRAY
57956: PUSH
57957: LD_INT 1
57959: PLUS
57960: PPUSH
57961: CALL_OW 1
57965: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57966: LD_ADDR_EXP 151
57970: PUSH
57971: LD_EXP 151
57975: PPUSH
57976: LD_VAR 0 5
57980: PUSH
57981: LD_EXP 151
57985: PUSH
57986: LD_VAR 0 5
57990: ARRAY
57991: PUSH
57992: LD_INT 1
57994: PLUS
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: PPUSH
58000: LD_VAR 0 2
58004: PUSH
58005: LD_VAR 0 4
58009: ARRAY
58010: PUSH
58011: LD_VAR 0 2
58015: PUSH
58016: LD_VAR 0 4
58020: ARRAY
58021: PPUSH
58022: CALL_OW 255
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PPUSH
58031: CALL 65486 0 3
58035: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58036: LD_VAR 0 2
58040: PUSH
58041: LD_VAR 0 4
58045: ARRAY
58046: PPUSH
58047: LD_VAR 0 1
58051: PPUSH
58052: CALL_OW 255
58056: PPUSH
58057: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58061: LD_VAR 0 2
58065: PUSH
58066: LD_VAR 0 4
58070: ARRAY
58071: PPUSH
58072: CALL_OW 141
// end ;
58076: GO 57908
58078: POP
58079: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58080: LD_VAR 0 1
58084: PPUSH
58085: LD_EXP 151
58089: PUSH
58090: LD_VAR 0 5
58094: ARRAY
58095: PUSH
58096: LD_INT 0
58098: PLUS
58099: PPUSH
58100: CALL_OW 505
// end ;
58104: LD_VAR 0 3
58108: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58109: LD_INT 0
58111: PPUSH
58112: PPUSH
58113: PPUSH
58114: PPUSH
// if not hack in hackTanks then
58115: LD_VAR 0 1
58119: PUSH
58120: LD_EXP 150
58124: IN
58125: NOT
58126: IFFALSE 58130
// exit ;
58128: GO 58370
// index := GetElementIndex ( hackTanks , hack ) ;
58130: LD_ADDR_VAR 0 4
58134: PUSH
58135: LD_EXP 150
58139: PPUSH
58140: LD_VAR 0 1
58144: PPUSH
58145: CALL 65271 0 2
58149: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58150: LD_ADDR_VAR 0 3
58154: PUSH
58155: DOUBLE
58156: LD_EXP 151
58160: PUSH
58161: LD_VAR 0 4
58165: ARRAY
58166: INC
58167: ST_TO_ADDR
58168: LD_INT 1
58170: PUSH
58171: FOR_DOWNTO
58172: IFFALSE 58344
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58174: LD_ADDR_VAR 0 5
58178: PUSH
58179: LD_EXP 151
58183: PUSH
58184: LD_VAR 0 4
58188: ARRAY
58189: PUSH
58190: LD_VAR 0 3
58194: ARRAY
58195: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58196: LD_VAR 0 5
58200: PUSH
58201: LD_INT 1
58203: ARRAY
58204: PPUSH
58205: CALL_OW 302
58209: NOT
58210: PUSH
58211: LD_VAR 0 5
58215: PUSH
58216: LD_INT 1
58218: ARRAY
58219: PPUSH
58220: CALL_OW 255
58224: PUSH
58225: LD_VAR 0 1
58229: PPUSH
58230: CALL_OW 255
58234: NONEQUAL
58235: OR
58236: IFFALSE 58342
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58238: LD_VAR 0 5
58242: PUSH
58243: LD_INT 1
58245: ARRAY
58246: PPUSH
58247: CALL_OW 305
58251: PUSH
58252: LD_VAR 0 5
58256: PUSH
58257: LD_INT 1
58259: ARRAY
58260: PPUSH
58261: CALL_OW 255
58265: PUSH
58266: LD_VAR 0 1
58270: PPUSH
58271: CALL_OW 255
58275: EQUAL
58276: AND
58277: IFFALSE 58301
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58279: LD_VAR 0 5
58283: PUSH
58284: LD_INT 1
58286: ARRAY
58287: PPUSH
58288: LD_VAR 0 5
58292: PUSH
58293: LD_INT 2
58295: ARRAY
58296: PPUSH
58297: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58301: LD_ADDR_EXP 151
58305: PUSH
58306: LD_EXP 151
58310: PPUSH
58311: LD_VAR 0 4
58315: PPUSH
58316: LD_EXP 151
58320: PUSH
58321: LD_VAR 0 4
58325: ARRAY
58326: PPUSH
58327: LD_VAR 0 3
58331: PPUSH
58332: CALL_OW 3
58336: PPUSH
58337: CALL_OW 1
58341: ST_TO_ADDR
// end ; end ;
58342: GO 58171
58344: POP
58345: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58346: LD_VAR 0 1
58350: PPUSH
58351: LD_EXP 151
58355: PUSH
58356: LD_VAR 0 4
58360: ARRAY
58361: PUSH
58362: LD_INT 0
58364: PLUS
58365: PPUSH
58366: CALL_OW 505
// end ;
58370: LD_VAR 0 2
58374: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58375: LD_INT 0
58377: PPUSH
58378: PPUSH
58379: PPUSH
58380: PPUSH
// if not hack in hackTanks then
58381: LD_VAR 0 1
58385: PUSH
58386: LD_EXP 150
58390: IN
58391: NOT
58392: IFFALSE 58396
// exit ;
58394: GO 58481
// index := GetElementIndex ( hackTanks , hack ) ;
58396: LD_ADDR_VAR 0 5
58400: PUSH
58401: LD_EXP 150
58405: PPUSH
58406: LD_VAR 0 1
58410: PPUSH
58411: CALL 65271 0 2
58415: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58416: LD_ADDR_VAR 0 4
58420: PUSH
58421: DOUBLE
58422: LD_INT 1
58424: DEC
58425: ST_TO_ADDR
58426: LD_EXP 151
58430: PUSH
58431: LD_VAR 0 5
58435: ARRAY
58436: PUSH
58437: FOR_TO
58438: IFFALSE 58479
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58440: LD_EXP 151
58444: PUSH
58445: LD_VAR 0 5
58449: ARRAY
58450: PUSH
58451: LD_VAR 0 4
58455: ARRAY
58456: PUSH
58457: LD_INT 1
58459: ARRAY
58460: PUSH
58461: LD_VAR 0 2
58465: EQUAL
58466: IFFALSE 58477
// KillUnit ( vehicle ) ;
58468: LD_VAR 0 2
58472: PPUSH
58473: CALL_OW 66
58477: GO 58437
58479: POP
58480: POP
// end ;
58481: LD_VAR 0 3
58485: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58486: LD_EXP 155
58490: NOT
58491: IFFALSE 58526
58493: GO 58495
58495: DISABLE
// begin initMiner := true ;
58496: LD_ADDR_EXP 155
58500: PUSH
58501: LD_INT 1
58503: ST_TO_ADDR
// minersList := [ ] ;
58504: LD_ADDR_EXP 156
58508: PUSH
58509: EMPTY
58510: ST_TO_ADDR
// minerMinesList := [ ] ;
58511: LD_ADDR_EXP 157
58515: PUSH
58516: EMPTY
58517: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58518: LD_ADDR_EXP 158
58522: PUSH
58523: LD_INT 5
58525: ST_TO_ADDR
// end ;
58526: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58527: LD_EXP 155
58531: PUSH
58532: LD_INT 34
58534: PUSH
58535: LD_EXP 80
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: PPUSH
58544: CALL_OW 69
58548: AND
58549: IFFALSE 59012
58551: GO 58553
58553: DISABLE
58554: LD_INT 0
58556: PPUSH
58557: PPUSH
58558: PPUSH
58559: PPUSH
// begin enable ;
58560: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58561: LD_ADDR_VAR 0 1
58565: PUSH
58566: LD_INT 34
58568: PUSH
58569: LD_EXP 80
58573: PUSH
58574: EMPTY
58575: LIST
58576: LIST
58577: PPUSH
58578: CALL_OW 69
58582: PUSH
58583: FOR_IN
58584: IFFALSE 58656
// begin if not i in minersList then
58586: LD_VAR 0 1
58590: PUSH
58591: LD_EXP 156
58595: IN
58596: NOT
58597: IFFALSE 58654
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58599: LD_ADDR_EXP 156
58603: PUSH
58604: LD_EXP 156
58608: PPUSH
58609: LD_EXP 156
58613: PUSH
58614: LD_INT 1
58616: PLUS
58617: PPUSH
58618: LD_VAR 0 1
58622: PPUSH
58623: CALL_OW 1
58627: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58628: LD_ADDR_EXP 157
58632: PUSH
58633: LD_EXP 157
58637: PPUSH
58638: LD_EXP 157
58642: PUSH
58643: LD_INT 1
58645: PLUS
58646: PPUSH
58647: EMPTY
58648: PPUSH
58649: CALL_OW 1
58653: ST_TO_ADDR
// end end ;
58654: GO 58583
58656: POP
58657: POP
// for i := minerMinesList downto 1 do
58658: LD_ADDR_VAR 0 1
58662: PUSH
58663: DOUBLE
58664: LD_EXP 157
58668: INC
58669: ST_TO_ADDR
58670: LD_INT 1
58672: PUSH
58673: FOR_DOWNTO
58674: IFFALSE 59010
// begin if IsLive ( minersList [ i ] ) then
58676: LD_EXP 156
58680: PUSH
58681: LD_VAR 0 1
58685: ARRAY
58686: PPUSH
58687: CALL_OW 300
58691: IFFALSE 58719
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
58693: LD_EXP 156
58697: PUSH
58698: LD_VAR 0 1
58702: ARRAY
58703: PPUSH
58704: LD_EXP 157
58708: PUSH
58709: LD_VAR 0 1
58713: ARRAY
58714: PPUSH
58715: CALL_OW 505
// if not minerMinesList [ i ] then
58719: LD_EXP 157
58723: PUSH
58724: LD_VAR 0 1
58728: ARRAY
58729: NOT
58730: IFFALSE 58734
// continue ;
58732: GO 58673
// for j := minerMinesList [ i ] downto 1 do
58734: LD_ADDR_VAR 0 2
58738: PUSH
58739: DOUBLE
58740: LD_EXP 157
58744: PUSH
58745: LD_VAR 0 1
58749: ARRAY
58750: INC
58751: ST_TO_ADDR
58752: LD_INT 1
58754: PUSH
58755: FOR_DOWNTO
58756: IFFALSE 59006
// begin side := GetSide ( minersList [ i ] ) ;
58758: LD_ADDR_VAR 0 3
58762: PUSH
58763: LD_EXP 156
58767: PUSH
58768: LD_VAR 0 1
58772: ARRAY
58773: PPUSH
58774: CALL_OW 255
58778: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
58779: LD_ADDR_VAR 0 4
58783: PUSH
58784: LD_EXP 157
58788: PUSH
58789: LD_VAR 0 1
58793: ARRAY
58794: PUSH
58795: LD_VAR 0 2
58799: ARRAY
58800: PUSH
58801: LD_INT 1
58803: ARRAY
58804: PPUSH
58805: LD_EXP 157
58809: PUSH
58810: LD_VAR 0 1
58814: ARRAY
58815: PUSH
58816: LD_VAR 0 2
58820: ARRAY
58821: PUSH
58822: LD_INT 2
58824: ARRAY
58825: PPUSH
58826: CALL_OW 428
58830: ST_TO_ADDR
// if not tmp then
58831: LD_VAR 0 4
58835: NOT
58836: IFFALSE 58840
// continue ;
58838: GO 58755
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
58840: LD_VAR 0 4
58844: PUSH
58845: LD_INT 81
58847: PUSH
58848: LD_VAR 0 3
58852: PUSH
58853: EMPTY
58854: LIST
58855: LIST
58856: PPUSH
58857: CALL_OW 69
58861: IN
58862: PUSH
58863: LD_EXP 157
58867: PUSH
58868: LD_VAR 0 1
58872: ARRAY
58873: PUSH
58874: LD_VAR 0 2
58878: ARRAY
58879: PUSH
58880: LD_INT 1
58882: ARRAY
58883: PPUSH
58884: LD_EXP 157
58888: PUSH
58889: LD_VAR 0 1
58893: ARRAY
58894: PUSH
58895: LD_VAR 0 2
58899: ARRAY
58900: PUSH
58901: LD_INT 2
58903: ARRAY
58904: PPUSH
58905: CALL_OW 458
58909: AND
58910: IFFALSE 59004
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
58912: LD_EXP 157
58916: PUSH
58917: LD_VAR 0 1
58921: ARRAY
58922: PUSH
58923: LD_VAR 0 2
58927: ARRAY
58928: PUSH
58929: LD_INT 1
58931: ARRAY
58932: PPUSH
58933: LD_EXP 157
58937: PUSH
58938: LD_VAR 0 1
58942: ARRAY
58943: PUSH
58944: LD_VAR 0 2
58948: ARRAY
58949: PUSH
58950: LD_INT 2
58952: ARRAY
58953: PPUSH
58954: LD_VAR 0 3
58958: PPUSH
58959: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
58963: LD_ADDR_EXP 157
58967: PUSH
58968: LD_EXP 157
58972: PPUSH
58973: LD_VAR 0 1
58977: PPUSH
58978: LD_EXP 157
58982: PUSH
58983: LD_VAR 0 1
58987: ARRAY
58988: PPUSH
58989: LD_VAR 0 2
58993: PPUSH
58994: CALL_OW 3
58998: PPUSH
58999: CALL_OW 1
59003: ST_TO_ADDR
// end ; end ;
59004: GO 58755
59006: POP
59007: POP
// end ;
59008: GO 58673
59010: POP
59011: POP
// end ;
59012: PPOPN 4
59014: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59015: LD_INT 0
59017: PPUSH
59018: PPUSH
// result := false ;
59019: LD_ADDR_VAR 0 4
59023: PUSH
59024: LD_INT 0
59026: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59027: LD_VAR 0 1
59031: PPUSH
59032: CALL_OW 264
59036: PUSH
59037: LD_EXP 80
59041: EQUAL
59042: NOT
59043: IFFALSE 59047
// exit ;
59045: GO 59287
// index := GetElementIndex ( minersList , unit ) ;
59047: LD_ADDR_VAR 0 5
59051: PUSH
59052: LD_EXP 156
59056: PPUSH
59057: LD_VAR 0 1
59061: PPUSH
59062: CALL 65271 0 2
59066: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59067: LD_EXP 157
59071: PUSH
59072: LD_VAR 0 5
59076: ARRAY
59077: PUSH
59078: LD_EXP 158
59082: GREATEREQUAL
59083: IFFALSE 59087
// exit ;
59085: GO 59287
// ComMoveXY ( unit , x , y ) ;
59087: LD_VAR 0 1
59091: PPUSH
59092: LD_VAR 0 2
59096: PPUSH
59097: LD_VAR 0 3
59101: PPUSH
59102: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59106: LD_INT 35
59108: PPUSH
59109: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59113: LD_VAR 0 1
59117: PPUSH
59118: LD_VAR 0 2
59122: PPUSH
59123: LD_VAR 0 3
59127: PPUSH
59128: CALL 96044 0 3
59132: NOT
59133: PUSH
59134: LD_VAR 0 1
59138: PPUSH
59139: CALL_OW 314
59143: AND
59144: IFFALSE 59148
// exit ;
59146: GO 59287
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59148: LD_VAR 0 2
59152: PPUSH
59153: LD_VAR 0 3
59157: PPUSH
59158: CALL_OW 428
59162: PUSH
59163: LD_VAR 0 1
59167: EQUAL
59168: PUSH
59169: LD_VAR 0 1
59173: PPUSH
59174: CALL_OW 314
59178: NOT
59179: AND
59180: IFFALSE 59106
// PlaySoundXY ( x , y , PlantMine ) ;
59182: LD_VAR 0 2
59186: PPUSH
59187: LD_VAR 0 3
59191: PPUSH
59192: LD_STRING PlantMine
59194: PPUSH
59195: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59199: LD_VAR 0 2
59203: PPUSH
59204: LD_VAR 0 3
59208: PPUSH
59209: LD_VAR 0 1
59213: PPUSH
59214: CALL_OW 255
59218: PPUSH
59219: LD_INT 0
59221: PPUSH
59222: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59226: LD_ADDR_EXP 157
59230: PUSH
59231: LD_EXP 157
59235: PPUSH
59236: LD_VAR 0 5
59240: PUSH
59241: LD_EXP 157
59245: PUSH
59246: LD_VAR 0 5
59250: ARRAY
59251: PUSH
59252: LD_INT 1
59254: PLUS
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: PPUSH
59260: LD_VAR 0 2
59264: PUSH
59265: LD_VAR 0 3
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: PPUSH
59274: CALL 65486 0 3
59278: ST_TO_ADDR
// result := true ;
59279: LD_ADDR_VAR 0 4
59283: PUSH
59284: LD_INT 1
59286: ST_TO_ADDR
// end ;
59287: LD_VAR 0 4
59291: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59292: LD_INT 0
59294: PPUSH
59295: PPUSH
59296: PPUSH
// if not unit in minersList then
59297: LD_VAR 0 1
59301: PUSH
59302: LD_EXP 156
59306: IN
59307: NOT
59308: IFFALSE 59312
// exit ;
59310: GO 59704
// index := GetElementIndex ( minersList , unit ) ;
59312: LD_ADDR_VAR 0 6
59316: PUSH
59317: LD_EXP 156
59321: PPUSH
59322: LD_VAR 0 1
59326: PPUSH
59327: CALL 65271 0 2
59331: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59332: LD_ADDR_VAR 0 5
59336: PUSH
59337: DOUBLE
59338: LD_EXP 157
59342: PUSH
59343: LD_VAR 0 6
59347: ARRAY
59348: INC
59349: ST_TO_ADDR
59350: LD_INT 1
59352: PUSH
59353: FOR_DOWNTO
59354: IFFALSE 59515
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59356: LD_EXP 157
59360: PUSH
59361: LD_VAR 0 6
59365: ARRAY
59366: PUSH
59367: LD_VAR 0 5
59371: ARRAY
59372: PUSH
59373: LD_INT 1
59375: ARRAY
59376: PUSH
59377: LD_VAR 0 2
59381: EQUAL
59382: PUSH
59383: LD_EXP 157
59387: PUSH
59388: LD_VAR 0 6
59392: ARRAY
59393: PUSH
59394: LD_VAR 0 5
59398: ARRAY
59399: PUSH
59400: LD_INT 2
59402: ARRAY
59403: PUSH
59404: LD_VAR 0 3
59408: EQUAL
59409: AND
59410: IFFALSE 59513
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59412: LD_EXP 157
59416: PUSH
59417: LD_VAR 0 6
59421: ARRAY
59422: PUSH
59423: LD_VAR 0 5
59427: ARRAY
59428: PUSH
59429: LD_INT 1
59431: ARRAY
59432: PPUSH
59433: LD_EXP 157
59437: PUSH
59438: LD_VAR 0 6
59442: ARRAY
59443: PUSH
59444: LD_VAR 0 5
59448: ARRAY
59449: PUSH
59450: LD_INT 2
59452: ARRAY
59453: PPUSH
59454: LD_VAR 0 1
59458: PPUSH
59459: CALL_OW 255
59463: PPUSH
59464: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59468: LD_ADDR_EXP 157
59472: PUSH
59473: LD_EXP 157
59477: PPUSH
59478: LD_VAR 0 6
59482: PPUSH
59483: LD_EXP 157
59487: PUSH
59488: LD_VAR 0 6
59492: ARRAY
59493: PPUSH
59494: LD_VAR 0 5
59498: PPUSH
59499: CALL_OW 3
59503: PPUSH
59504: CALL_OW 1
59508: ST_TO_ADDR
// exit ;
59509: POP
59510: POP
59511: GO 59704
// end ; end ;
59513: GO 59353
59515: POP
59516: POP
// for i := minerMinesList [ index ] downto 1 do
59517: LD_ADDR_VAR 0 5
59521: PUSH
59522: DOUBLE
59523: LD_EXP 157
59527: PUSH
59528: LD_VAR 0 6
59532: ARRAY
59533: INC
59534: ST_TO_ADDR
59535: LD_INT 1
59537: PUSH
59538: FOR_DOWNTO
59539: IFFALSE 59702
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59541: LD_EXP 157
59545: PUSH
59546: LD_VAR 0 6
59550: ARRAY
59551: PUSH
59552: LD_VAR 0 5
59556: ARRAY
59557: PUSH
59558: LD_INT 1
59560: ARRAY
59561: PPUSH
59562: LD_EXP 157
59566: PUSH
59567: LD_VAR 0 6
59571: ARRAY
59572: PUSH
59573: LD_VAR 0 5
59577: ARRAY
59578: PUSH
59579: LD_INT 2
59581: ARRAY
59582: PPUSH
59583: LD_VAR 0 2
59587: PPUSH
59588: LD_VAR 0 3
59592: PPUSH
59593: CALL_OW 298
59597: PUSH
59598: LD_INT 6
59600: LESS
59601: IFFALSE 59700
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59603: LD_EXP 157
59607: PUSH
59608: LD_VAR 0 6
59612: ARRAY
59613: PUSH
59614: LD_VAR 0 5
59618: ARRAY
59619: PUSH
59620: LD_INT 1
59622: ARRAY
59623: PPUSH
59624: LD_EXP 157
59628: PUSH
59629: LD_VAR 0 6
59633: ARRAY
59634: PUSH
59635: LD_VAR 0 5
59639: ARRAY
59640: PUSH
59641: LD_INT 2
59643: ARRAY
59644: PPUSH
59645: LD_VAR 0 1
59649: PPUSH
59650: CALL_OW 255
59654: PPUSH
59655: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59659: LD_ADDR_EXP 157
59663: PUSH
59664: LD_EXP 157
59668: PPUSH
59669: LD_VAR 0 6
59673: PPUSH
59674: LD_EXP 157
59678: PUSH
59679: LD_VAR 0 6
59683: ARRAY
59684: PPUSH
59685: LD_VAR 0 5
59689: PPUSH
59690: CALL_OW 3
59694: PPUSH
59695: CALL_OW 1
59699: ST_TO_ADDR
// end ; end ;
59700: GO 59538
59702: POP
59703: POP
// end ;
59704: LD_VAR 0 4
59708: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
59709: LD_INT 0
59711: PPUSH
59712: PPUSH
59713: PPUSH
59714: PPUSH
59715: PPUSH
59716: PPUSH
59717: PPUSH
59718: PPUSH
59719: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
59720: LD_VAR 0 1
59724: PPUSH
59725: CALL_OW 264
59729: PUSH
59730: LD_EXP 80
59734: EQUAL
59735: NOT
59736: PUSH
59737: LD_VAR 0 1
59741: PUSH
59742: LD_EXP 156
59746: IN
59747: NOT
59748: OR
59749: IFFALSE 59753
// exit ;
59751: GO 60075
// index := GetElementIndex ( minersList , unit ) ;
59753: LD_ADDR_VAR 0 6
59757: PUSH
59758: LD_EXP 156
59762: PPUSH
59763: LD_VAR 0 1
59767: PPUSH
59768: CALL 65271 0 2
59772: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
59773: LD_ADDR_VAR 0 8
59777: PUSH
59778: LD_EXP 158
59782: PUSH
59783: LD_EXP 157
59787: PUSH
59788: LD_VAR 0 6
59792: ARRAY
59793: MINUS
59794: ST_TO_ADDR
// if not minesFreeAmount then
59795: LD_VAR 0 8
59799: NOT
59800: IFFALSE 59804
// exit ;
59802: GO 60075
// tmp := [ ] ;
59804: LD_ADDR_VAR 0 7
59808: PUSH
59809: EMPTY
59810: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
59811: LD_ADDR_VAR 0 5
59815: PUSH
59816: DOUBLE
59817: LD_INT 1
59819: DEC
59820: ST_TO_ADDR
59821: LD_VAR 0 8
59825: PUSH
59826: FOR_TO
59827: IFFALSE 60022
// begin _d := rand ( 0 , 5 ) ;
59829: LD_ADDR_VAR 0 11
59833: PUSH
59834: LD_INT 0
59836: PPUSH
59837: LD_INT 5
59839: PPUSH
59840: CALL_OW 12
59844: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
59845: LD_ADDR_VAR 0 12
59849: PUSH
59850: LD_INT 2
59852: PPUSH
59853: LD_INT 6
59855: PPUSH
59856: CALL_OW 12
59860: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
59861: LD_ADDR_VAR 0 9
59865: PUSH
59866: LD_VAR 0 2
59870: PPUSH
59871: LD_VAR 0 11
59875: PPUSH
59876: LD_VAR 0 12
59880: PPUSH
59881: CALL_OW 272
59885: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
59886: LD_ADDR_VAR 0 10
59890: PUSH
59891: LD_VAR 0 3
59895: PPUSH
59896: LD_VAR 0 11
59900: PPUSH
59901: LD_VAR 0 12
59905: PPUSH
59906: CALL_OW 273
59910: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
59911: LD_VAR 0 9
59915: PPUSH
59916: LD_VAR 0 10
59920: PPUSH
59921: CALL_OW 488
59925: PUSH
59926: LD_VAR 0 9
59930: PUSH
59931: LD_VAR 0 10
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_VAR 0 7
59944: IN
59945: NOT
59946: AND
59947: PUSH
59948: LD_VAR 0 9
59952: PPUSH
59953: LD_VAR 0 10
59957: PPUSH
59958: CALL_OW 458
59962: NOT
59963: AND
59964: IFFALSE 60006
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
59966: LD_ADDR_VAR 0 7
59970: PUSH
59971: LD_VAR 0 7
59975: PPUSH
59976: LD_VAR 0 7
59980: PUSH
59981: LD_INT 1
59983: PLUS
59984: PPUSH
59985: LD_VAR 0 9
59989: PUSH
59990: LD_VAR 0 10
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PPUSH
59999: CALL_OW 1
60003: ST_TO_ADDR
60004: GO 60020
// i := i - 1 ;
60006: LD_ADDR_VAR 0 5
60010: PUSH
60011: LD_VAR 0 5
60015: PUSH
60016: LD_INT 1
60018: MINUS
60019: ST_TO_ADDR
// end ;
60020: GO 59826
60022: POP
60023: POP
// for i in tmp do
60024: LD_ADDR_VAR 0 5
60028: PUSH
60029: LD_VAR 0 7
60033: PUSH
60034: FOR_IN
60035: IFFALSE 60073
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60037: LD_VAR 0 1
60041: PPUSH
60042: LD_VAR 0 5
60046: PUSH
60047: LD_INT 1
60049: ARRAY
60050: PPUSH
60051: LD_VAR 0 5
60055: PUSH
60056: LD_INT 2
60058: ARRAY
60059: PPUSH
60060: CALL 59015 0 3
60064: NOT
60065: IFFALSE 60071
// exit ;
60067: POP
60068: POP
60069: GO 60075
60071: GO 60034
60073: POP
60074: POP
// end ;
60075: LD_VAR 0 4
60079: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60080: LD_INT 0
60082: PPUSH
60083: PPUSH
60084: PPUSH
60085: PPUSH
60086: PPUSH
60087: PPUSH
60088: PPUSH
// if not GetClass ( unit ) = class_sniper then
60089: LD_VAR 0 1
60093: PPUSH
60094: CALL_OW 257
60098: PUSH
60099: LD_INT 5
60101: EQUAL
60102: NOT
60103: IFFALSE 60107
// exit ;
60105: GO 60495
// dist := 8 ;
60107: LD_ADDR_VAR 0 5
60111: PUSH
60112: LD_INT 8
60114: ST_TO_ADDR
// viewRange := 12 ;
60115: LD_ADDR_VAR 0 7
60119: PUSH
60120: LD_INT 12
60122: ST_TO_ADDR
// side := GetSide ( unit ) ;
60123: LD_ADDR_VAR 0 6
60127: PUSH
60128: LD_VAR 0 1
60132: PPUSH
60133: CALL_OW 255
60137: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60138: LD_INT 61
60140: PPUSH
60141: LD_VAR 0 6
60145: PPUSH
60146: CALL_OW 321
60150: PUSH
60151: LD_INT 2
60153: EQUAL
60154: IFFALSE 60164
// viewRange := 16 ;
60156: LD_ADDR_VAR 0 7
60160: PUSH
60161: LD_INT 16
60163: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60164: LD_VAR 0 1
60168: PPUSH
60169: LD_VAR 0 2
60173: PPUSH
60174: LD_VAR 0 3
60178: PPUSH
60179: CALL_OW 297
60183: PUSH
60184: LD_VAR 0 5
60188: GREATER
60189: IFFALSE 60268
// begin ComMoveXY ( unit , x , y ) ;
60191: LD_VAR 0 1
60195: PPUSH
60196: LD_VAR 0 2
60200: PPUSH
60201: LD_VAR 0 3
60205: PPUSH
60206: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60210: LD_INT 35
60212: PPUSH
60213: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60217: LD_VAR 0 1
60221: PPUSH
60222: LD_VAR 0 2
60226: PPUSH
60227: LD_VAR 0 3
60231: PPUSH
60232: CALL 96044 0 3
60236: NOT
60237: IFFALSE 60241
// exit ;
60239: GO 60495
// until GetDistUnitXY ( unit , x , y ) < dist ;
60241: LD_VAR 0 1
60245: PPUSH
60246: LD_VAR 0 2
60250: PPUSH
60251: LD_VAR 0 3
60255: PPUSH
60256: CALL_OW 297
60260: PUSH
60261: LD_VAR 0 5
60265: LESS
60266: IFFALSE 60210
// end ; ComTurnXY ( unit , x , y ) ;
60268: LD_VAR 0 1
60272: PPUSH
60273: LD_VAR 0 2
60277: PPUSH
60278: LD_VAR 0 3
60282: PPUSH
60283: CALL_OW 118
// wait ( 5 ) ;
60287: LD_INT 5
60289: PPUSH
60290: CALL_OW 67
// _d := GetDir ( unit ) ;
60294: LD_ADDR_VAR 0 10
60298: PUSH
60299: LD_VAR 0 1
60303: PPUSH
60304: CALL_OW 254
60308: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60309: LD_ADDR_VAR 0 8
60313: PUSH
60314: LD_VAR 0 1
60318: PPUSH
60319: CALL_OW 250
60323: PPUSH
60324: LD_VAR 0 10
60328: PPUSH
60329: LD_VAR 0 5
60333: PPUSH
60334: CALL_OW 272
60338: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60339: LD_ADDR_VAR 0 9
60343: PUSH
60344: LD_VAR 0 1
60348: PPUSH
60349: CALL_OW 251
60353: PPUSH
60354: LD_VAR 0 10
60358: PPUSH
60359: LD_VAR 0 5
60363: PPUSH
60364: CALL_OW 273
60368: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60369: LD_VAR 0 8
60373: PPUSH
60374: LD_VAR 0 9
60378: PPUSH
60379: CALL_OW 488
60383: NOT
60384: IFFALSE 60388
// exit ;
60386: GO 60495
// ComAnimCustom ( unit , 1 ) ;
60388: LD_VAR 0 1
60392: PPUSH
60393: LD_INT 1
60395: PPUSH
60396: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60400: LD_VAR 0 8
60404: PPUSH
60405: LD_VAR 0 9
60409: PPUSH
60410: LD_VAR 0 6
60414: PPUSH
60415: LD_VAR 0 7
60419: PPUSH
60420: CALL_OW 330
// repeat wait ( 1 ) ;
60424: LD_INT 1
60426: PPUSH
60427: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60431: LD_VAR 0 1
60435: PPUSH
60436: CALL_OW 316
60440: PUSH
60441: LD_VAR 0 1
60445: PPUSH
60446: CALL_OW 314
60450: OR
60451: PUSH
60452: LD_VAR 0 1
60456: PPUSH
60457: CALL_OW 302
60461: NOT
60462: OR
60463: PUSH
60464: LD_VAR 0 1
60468: PPUSH
60469: CALL_OW 301
60473: OR
60474: IFFALSE 60424
// RemoveSeeing ( _x , _y , side ) ;
60476: LD_VAR 0 8
60480: PPUSH
60481: LD_VAR 0 9
60485: PPUSH
60486: LD_VAR 0 6
60490: PPUSH
60491: CALL_OW 331
// end ; end_of_file
60495: LD_VAR 0 4
60499: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
60500: LD_INT 0
60502: PPUSH
60503: PPUSH
// if exist_mode then
60504: LD_VAR 0 2
60508: IFFALSE 60533
// unit := CreateCharacter ( prefix & ident ) else
60510: LD_ADDR_VAR 0 5
60514: PUSH
60515: LD_VAR 0 3
60519: PUSH
60520: LD_VAR 0 1
60524: STR
60525: PPUSH
60526: CALL_OW 34
60530: ST_TO_ADDR
60531: GO 60548
// unit := NewCharacter ( ident ) ;
60533: LD_ADDR_VAR 0 5
60537: PUSH
60538: LD_VAR 0 1
60542: PPUSH
60543: CALL_OW 25
60547: ST_TO_ADDR
// result := unit ;
60548: LD_ADDR_VAR 0 4
60552: PUSH
60553: LD_VAR 0 5
60557: ST_TO_ADDR
// end ;
60558: LD_VAR 0 4
60562: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
60563: LD_INT 0
60565: PPUSH
60566: PPUSH
// if not side or not nation then
60567: LD_VAR 0 1
60571: NOT
60572: PUSH
60573: LD_VAR 0 2
60577: NOT
60578: OR
60579: IFFALSE 60583
// exit ;
60581: GO 61351
// case nation of nation_american :
60583: LD_VAR 0 2
60587: PUSH
60588: LD_INT 1
60590: DOUBLE
60591: EQUAL
60592: IFTRUE 60596
60594: GO 60810
60596: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
60597: LD_ADDR_VAR 0 4
60601: PUSH
60602: LD_INT 35
60604: PUSH
60605: LD_INT 45
60607: PUSH
60608: LD_INT 46
60610: PUSH
60611: LD_INT 47
60613: PUSH
60614: LD_INT 82
60616: PUSH
60617: LD_INT 83
60619: PUSH
60620: LD_INT 84
60622: PUSH
60623: LD_INT 85
60625: PUSH
60626: LD_INT 86
60628: PUSH
60629: LD_INT 1
60631: PUSH
60632: LD_INT 2
60634: PUSH
60635: LD_INT 6
60637: PUSH
60638: LD_INT 15
60640: PUSH
60641: LD_INT 16
60643: PUSH
60644: LD_INT 7
60646: PUSH
60647: LD_INT 12
60649: PUSH
60650: LD_INT 13
60652: PUSH
60653: LD_INT 10
60655: PUSH
60656: LD_INT 14
60658: PUSH
60659: LD_INT 20
60661: PUSH
60662: LD_INT 21
60664: PUSH
60665: LD_INT 22
60667: PUSH
60668: LD_INT 25
60670: PUSH
60671: LD_INT 32
60673: PUSH
60674: LD_INT 27
60676: PUSH
60677: LD_INT 36
60679: PUSH
60680: LD_INT 69
60682: PUSH
60683: LD_INT 39
60685: PUSH
60686: LD_INT 34
60688: PUSH
60689: LD_INT 40
60691: PUSH
60692: LD_INT 48
60694: PUSH
60695: LD_INT 49
60697: PUSH
60698: LD_INT 50
60700: PUSH
60701: LD_INT 51
60703: PUSH
60704: LD_INT 52
60706: PUSH
60707: LD_INT 53
60709: PUSH
60710: LD_INT 54
60712: PUSH
60713: LD_INT 55
60715: PUSH
60716: LD_INT 56
60718: PUSH
60719: LD_INT 57
60721: PUSH
60722: LD_INT 58
60724: PUSH
60725: LD_INT 59
60727: PUSH
60728: LD_INT 60
60730: PUSH
60731: LD_INT 61
60733: PUSH
60734: LD_INT 62
60736: PUSH
60737: LD_INT 80
60739: PUSH
60740: LD_INT 82
60742: PUSH
60743: LD_INT 83
60745: PUSH
60746: LD_INT 84
60748: PUSH
60749: LD_INT 85
60751: PUSH
60752: LD_INT 86
60754: PUSH
60755: EMPTY
60756: LIST
60757: LIST
60758: LIST
60759: LIST
60760: LIST
60761: LIST
60762: LIST
60763: LIST
60764: LIST
60765: LIST
60766: LIST
60767: LIST
60768: LIST
60769: LIST
60770: LIST
60771: LIST
60772: LIST
60773: LIST
60774: LIST
60775: LIST
60776: LIST
60777: LIST
60778: LIST
60779: LIST
60780: LIST
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: LIST
60786: LIST
60787: LIST
60788: LIST
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: LIST
60798: LIST
60799: LIST
60800: LIST
60801: LIST
60802: LIST
60803: LIST
60804: LIST
60805: LIST
60806: LIST
60807: ST_TO_ADDR
60808: GO 61275
60810: LD_INT 2
60812: DOUBLE
60813: EQUAL
60814: IFTRUE 60818
60816: GO 61044
60818: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
60819: LD_ADDR_VAR 0 4
60823: PUSH
60824: LD_INT 35
60826: PUSH
60827: LD_INT 45
60829: PUSH
60830: LD_INT 46
60832: PUSH
60833: LD_INT 47
60835: PUSH
60836: LD_INT 82
60838: PUSH
60839: LD_INT 83
60841: PUSH
60842: LD_INT 84
60844: PUSH
60845: LD_INT 85
60847: PUSH
60848: LD_INT 87
60850: PUSH
60851: LD_INT 70
60853: PUSH
60854: LD_INT 1
60856: PUSH
60857: LD_INT 11
60859: PUSH
60860: LD_INT 3
60862: PUSH
60863: LD_INT 4
60865: PUSH
60866: LD_INT 5
60868: PUSH
60869: LD_INT 6
60871: PUSH
60872: LD_INT 15
60874: PUSH
60875: LD_INT 18
60877: PUSH
60878: LD_INT 7
60880: PUSH
60881: LD_INT 17
60883: PUSH
60884: LD_INT 8
60886: PUSH
60887: LD_INT 20
60889: PUSH
60890: LD_INT 21
60892: PUSH
60893: LD_INT 22
60895: PUSH
60896: LD_INT 72
60898: PUSH
60899: LD_INT 26
60901: PUSH
60902: LD_INT 69
60904: PUSH
60905: LD_INT 39
60907: PUSH
60908: LD_INT 40
60910: PUSH
60911: LD_INT 41
60913: PUSH
60914: LD_INT 42
60916: PUSH
60917: LD_INT 43
60919: PUSH
60920: LD_INT 48
60922: PUSH
60923: LD_INT 49
60925: PUSH
60926: LD_INT 50
60928: PUSH
60929: LD_INT 51
60931: PUSH
60932: LD_INT 52
60934: PUSH
60935: LD_INT 53
60937: PUSH
60938: LD_INT 54
60940: PUSH
60941: LD_INT 55
60943: PUSH
60944: LD_INT 56
60946: PUSH
60947: LD_INT 60
60949: PUSH
60950: LD_INT 61
60952: PUSH
60953: LD_INT 62
60955: PUSH
60956: LD_INT 66
60958: PUSH
60959: LD_INT 67
60961: PUSH
60962: LD_INT 68
60964: PUSH
60965: LD_INT 81
60967: PUSH
60968: LD_INT 82
60970: PUSH
60971: LD_INT 83
60973: PUSH
60974: LD_INT 84
60976: PUSH
60977: LD_INT 85
60979: PUSH
60980: LD_INT 87
60982: PUSH
60983: LD_INT 88
60985: PUSH
60986: EMPTY
60987: LIST
60988: LIST
60989: LIST
60990: LIST
60991: LIST
60992: LIST
60993: LIST
60994: LIST
60995: LIST
60996: LIST
60997: LIST
60998: LIST
60999: LIST
61000: LIST
61001: LIST
61002: LIST
61003: LIST
61004: LIST
61005: LIST
61006: LIST
61007: LIST
61008: LIST
61009: LIST
61010: LIST
61011: LIST
61012: LIST
61013: LIST
61014: LIST
61015: LIST
61016: LIST
61017: LIST
61018: LIST
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: LIST
61037: LIST
61038: LIST
61039: LIST
61040: LIST
61041: ST_TO_ADDR
61042: GO 61275
61044: LD_INT 3
61046: DOUBLE
61047: EQUAL
61048: IFTRUE 61052
61050: GO 61274
61052: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61053: LD_ADDR_VAR 0 4
61057: PUSH
61058: LD_INT 46
61060: PUSH
61061: LD_INT 47
61063: PUSH
61064: LD_INT 1
61066: PUSH
61067: LD_INT 2
61069: PUSH
61070: LD_INT 82
61072: PUSH
61073: LD_INT 83
61075: PUSH
61076: LD_INT 84
61078: PUSH
61079: LD_INT 85
61081: PUSH
61082: LD_INT 86
61084: PUSH
61085: LD_INT 11
61087: PUSH
61088: LD_INT 9
61090: PUSH
61091: LD_INT 20
61093: PUSH
61094: LD_INT 19
61096: PUSH
61097: LD_INT 21
61099: PUSH
61100: LD_INT 24
61102: PUSH
61103: LD_INT 22
61105: PUSH
61106: LD_INT 25
61108: PUSH
61109: LD_INT 28
61111: PUSH
61112: LD_INT 29
61114: PUSH
61115: LD_INT 30
61117: PUSH
61118: LD_INT 31
61120: PUSH
61121: LD_INT 37
61123: PUSH
61124: LD_INT 38
61126: PUSH
61127: LD_INT 32
61129: PUSH
61130: LD_INT 27
61132: PUSH
61133: LD_INT 33
61135: PUSH
61136: LD_INT 69
61138: PUSH
61139: LD_INT 39
61141: PUSH
61142: LD_INT 34
61144: PUSH
61145: LD_INT 40
61147: PUSH
61148: LD_INT 71
61150: PUSH
61151: LD_INT 23
61153: PUSH
61154: LD_INT 44
61156: PUSH
61157: LD_INT 48
61159: PUSH
61160: LD_INT 49
61162: PUSH
61163: LD_INT 50
61165: PUSH
61166: LD_INT 51
61168: PUSH
61169: LD_INT 52
61171: PUSH
61172: LD_INT 53
61174: PUSH
61175: LD_INT 54
61177: PUSH
61178: LD_INT 55
61180: PUSH
61181: LD_INT 56
61183: PUSH
61184: LD_INT 57
61186: PUSH
61187: LD_INT 58
61189: PUSH
61190: LD_INT 59
61192: PUSH
61193: LD_INT 63
61195: PUSH
61196: LD_INT 64
61198: PUSH
61199: LD_INT 65
61201: PUSH
61202: LD_INT 82
61204: PUSH
61205: LD_INT 83
61207: PUSH
61208: LD_INT 84
61210: PUSH
61211: LD_INT 85
61213: PUSH
61214: LD_INT 86
61216: PUSH
61217: EMPTY
61218: LIST
61219: LIST
61220: LIST
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: LIST
61254: LIST
61255: LIST
61256: LIST
61257: LIST
61258: LIST
61259: LIST
61260: LIST
61261: LIST
61262: LIST
61263: LIST
61264: LIST
61265: LIST
61266: LIST
61267: LIST
61268: LIST
61269: LIST
61270: LIST
61271: ST_TO_ADDR
61272: GO 61275
61274: POP
// if state > - 1 and state < 3 then
61275: LD_VAR 0 3
61279: PUSH
61280: LD_INT 1
61282: NEG
61283: GREATER
61284: PUSH
61285: LD_VAR 0 3
61289: PUSH
61290: LD_INT 3
61292: LESS
61293: AND
61294: IFFALSE 61351
// for i in result do
61296: LD_ADDR_VAR 0 5
61300: PUSH
61301: LD_VAR 0 4
61305: PUSH
61306: FOR_IN
61307: IFFALSE 61349
// if GetTech ( i , side ) <> state then
61309: LD_VAR 0 5
61313: PPUSH
61314: LD_VAR 0 1
61318: PPUSH
61319: CALL_OW 321
61323: PUSH
61324: LD_VAR 0 3
61328: NONEQUAL
61329: IFFALSE 61347
// result := result diff i ;
61331: LD_ADDR_VAR 0 4
61335: PUSH
61336: LD_VAR 0 4
61340: PUSH
61341: LD_VAR 0 5
61345: DIFF
61346: ST_TO_ADDR
61347: GO 61306
61349: POP
61350: POP
// end ;
61351: LD_VAR 0 4
61355: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
61356: LD_INT 0
61358: PPUSH
61359: PPUSH
61360: PPUSH
// result := true ;
61361: LD_ADDR_VAR 0 3
61365: PUSH
61366: LD_INT 1
61368: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
61369: LD_ADDR_VAR 0 5
61373: PUSH
61374: LD_VAR 0 2
61378: PPUSH
61379: CALL_OW 480
61383: ST_TO_ADDR
// if not tmp then
61384: LD_VAR 0 5
61388: NOT
61389: IFFALSE 61393
// exit ;
61391: GO 61442
// for i in tmp do
61393: LD_ADDR_VAR 0 4
61397: PUSH
61398: LD_VAR 0 5
61402: PUSH
61403: FOR_IN
61404: IFFALSE 61440
// if GetTech ( i , side ) <> state_researched then
61406: LD_VAR 0 4
61410: PPUSH
61411: LD_VAR 0 1
61415: PPUSH
61416: CALL_OW 321
61420: PUSH
61421: LD_INT 2
61423: NONEQUAL
61424: IFFALSE 61438
// begin result := false ;
61426: LD_ADDR_VAR 0 3
61430: PUSH
61431: LD_INT 0
61433: ST_TO_ADDR
// exit ;
61434: POP
61435: POP
61436: GO 61442
// end ;
61438: GO 61403
61440: POP
61441: POP
// end ;
61442: LD_VAR 0 3
61446: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
61447: LD_INT 0
61449: PPUSH
61450: PPUSH
61451: PPUSH
61452: PPUSH
61453: PPUSH
61454: PPUSH
61455: PPUSH
61456: PPUSH
61457: PPUSH
61458: PPUSH
61459: PPUSH
61460: PPUSH
61461: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
61462: LD_VAR 0 1
61466: NOT
61467: PUSH
61468: LD_VAR 0 1
61472: PPUSH
61473: CALL_OW 257
61477: PUSH
61478: LD_INT 9
61480: NONEQUAL
61481: OR
61482: IFFALSE 61486
// exit ;
61484: GO 62059
// side := GetSide ( unit ) ;
61486: LD_ADDR_VAR 0 9
61490: PUSH
61491: LD_VAR 0 1
61495: PPUSH
61496: CALL_OW 255
61500: ST_TO_ADDR
// tech_space := tech_spacanom ;
61501: LD_ADDR_VAR 0 12
61505: PUSH
61506: LD_INT 29
61508: ST_TO_ADDR
// tech_time := tech_taurad ;
61509: LD_ADDR_VAR 0 13
61513: PUSH
61514: LD_INT 28
61516: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
61517: LD_ADDR_VAR 0 11
61521: PUSH
61522: LD_VAR 0 1
61526: PPUSH
61527: CALL_OW 310
61531: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
61532: LD_VAR 0 11
61536: PPUSH
61537: CALL_OW 247
61541: PUSH
61542: LD_INT 2
61544: EQUAL
61545: IFFALSE 61549
// exit ;
61547: GO 62059
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61549: LD_ADDR_VAR 0 8
61553: PUSH
61554: LD_INT 81
61556: PUSH
61557: LD_VAR 0 9
61561: PUSH
61562: EMPTY
61563: LIST
61564: LIST
61565: PUSH
61566: LD_INT 3
61568: PUSH
61569: LD_INT 21
61571: PUSH
61572: LD_INT 3
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: PPUSH
61587: CALL_OW 69
61591: ST_TO_ADDR
// if not tmp then
61592: LD_VAR 0 8
61596: NOT
61597: IFFALSE 61601
// exit ;
61599: GO 62059
// if in_unit then
61601: LD_VAR 0 11
61605: IFFALSE 61629
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
61607: LD_ADDR_VAR 0 10
61611: PUSH
61612: LD_VAR 0 8
61616: PPUSH
61617: LD_VAR 0 11
61621: PPUSH
61622: CALL_OW 74
61626: ST_TO_ADDR
61627: GO 61649
// enemy := NearestUnitToUnit ( tmp , unit ) ;
61629: LD_ADDR_VAR 0 10
61633: PUSH
61634: LD_VAR 0 8
61638: PPUSH
61639: LD_VAR 0 1
61643: PPUSH
61644: CALL_OW 74
61648: ST_TO_ADDR
// if not enemy then
61649: LD_VAR 0 10
61653: NOT
61654: IFFALSE 61658
// exit ;
61656: GO 62059
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
61658: LD_VAR 0 11
61662: PUSH
61663: LD_VAR 0 11
61667: PPUSH
61668: LD_VAR 0 10
61672: PPUSH
61673: CALL_OW 296
61677: PUSH
61678: LD_INT 13
61680: GREATER
61681: AND
61682: PUSH
61683: LD_VAR 0 1
61687: PPUSH
61688: LD_VAR 0 10
61692: PPUSH
61693: CALL_OW 296
61697: PUSH
61698: LD_INT 12
61700: GREATER
61701: OR
61702: IFFALSE 61706
// exit ;
61704: GO 62059
// missile := [ 1 ] ;
61706: LD_ADDR_VAR 0 14
61710: PUSH
61711: LD_INT 1
61713: PUSH
61714: EMPTY
61715: LIST
61716: ST_TO_ADDR
// if Researched ( side , tech_space ) then
61717: LD_VAR 0 9
61721: PPUSH
61722: LD_VAR 0 12
61726: PPUSH
61727: CALL_OW 325
61731: IFFALSE 61760
// missile := Insert ( missile , missile + 1 , 2 ) ;
61733: LD_ADDR_VAR 0 14
61737: PUSH
61738: LD_VAR 0 14
61742: PPUSH
61743: LD_VAR 0 14
61747: PUSH
61748: LD_INT 1
61750: PLUS
61751: PPUSH
61752: LD_INT 2
61754: PPUSH
61755: CALL_OW 2
61759: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
61760: LD_VAR 0 9
61764: PPUSH
61765: LD_VAR 0 13
61769: PPUSH
61770: CALL_OW 325
61774: PUSH
61775: LD_VAR 0 10
61779: PPUSH
61780: CALL_OW 255
61784: PPUSH
61785: LD_VAR 0 13
61789: PPUSH
61790: CALL_OW 325
61794: NOT
61795: AND
61796: IFFALSE 61825
// missile := Insert ( missile , missile + 1 , 3 ) ;
61798: LD_ADDR_VAR 0 14
61802: PUSH
61803: LD_VAR 0 14
61807: PPUSH
61808: LD_VAR 0 14
61812: PUSH
61813: LD_INT 1
61815: PLUS
61816: PPUSH
61817: LD_INT 3
61819: PPUSH
61820: CALL_OW 2
61824: ST_TO_ADDR
// if missile < 2 then
61825: LD_VAR 0 14
61829: PUSH
61830: LD_INT 2
61832: LESS
61833: IFFALSE 61837
// exit ;
61835: GO 62059
// x := GetX ( enemy ) ;
61837: LD_ADDR_VAR 0 4
61841: PUSH
61842: LD_VAR 0 10
61846: PPUSH
61847: CALL_OW 250
61851: ST_TO_ADDR
// y := GetY ( enemy ) ;
61852: LD_ADDR_VAR 0 5
61856: PUSH
61857: LD_VAR 0 10
61861: PPUSH
61862: CALL_OW 251
61866: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
61867: LD_ADDR_VAR 0 6
61871: PUSH
61872: LD_VAR 0 4
61876: PUSH
61877: LD_INT 1
61879: NEG
61880: PPUSH
61881: LD_INT 1
61883: PPUSH
61884: CALL_OW 12
61888: PLUS
61889: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
61890: LD_ADDR_VAR 0 7
61894: PUSH
61895: LD_VAR 0 5
61899: PUSH
61900: LD_INT 1
61902: NEG
61903: PPUSH
61904: LD_INT 1
61906: PPUSH
61907: CALL_OW 12
61911: PLUS
61912: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
61913: LD_VAR 0 6
61917: PPUSH
61918: LD_VAR 0 7
61922: PPUSH
61923: CALL_OW 488
61927: NOT
61928: IFFALSE 61950
// begin _x := x ;
61930: LD_ADDR_VAR 0 6
61934: PUSH
61935: LD_VAR 0 4
61939: ST_TO_ADDR
// _y := y ;
61940: LD_ADDR_VAR 0 7
61944: PUSH
61945: LD_VAR 0 5
61949: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
61950: LD_ADDR_VAR 0 3
61954: PUSH
61955: LD_INT 1
61957: PPUSH
61958: LD_VAR 0 14
61962: PPUSH
61963: CALL_OW 12
61967: ST_TO_ADDR
// case i of 1 :
61968: LD_VAR 0 3
61972: PUSH
61973: LD_INT 1
61975: DOUBLE
61976: EQUAL
61977: IFTRUE 61981
61979: GO 61998
61981: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
61982: LD_VAR 0 1
61986: PPUSH
61987: LD_VAR 0 10
61991: PPUSH
61992: CALL_OW 115
61996: GO 62059
61998: LD_INT 2
62000: DOUBLE
62001: EQUAL
62002: IFTRUE 62006
62004: GO 62028
62006: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62007: LD_VAR 0 1
62011: PPUSH
62012: LD_VAR 0 6
62016: PPUSH
62017: LD_VAR 0 7
62021: PPUSH
62022: CALL_OW 153
62026: GO 62059
62028: LD_INT 3
62030: DOUBLE
62031: EQUAL
62032: IFTRUE 62036
62034: GO 62058
62036: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62037: LD_VAR 0 1
62041: PPUSH
62042: LD_VAR 0 6
62046: PPUSH
62047: LD_VAR 0 7
62051: PPUSH
62052: CALL_OW 154
62056: GO 62059
62058: POP
// end ;
62059: LD_VAR 0 2
62063: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62064: LD_INT 0
62066: PPUSH
62067: PPUSH
62068: PPUSH
62069: PPUSH
62070: PPUSH
62071: PPUSH
// if not unit or not building then
62072: LD_VAR 0 1
62076: NOT
62077: PUSH
62078: LD_VAR 0 2
62082: NOT
62083: OR
62084: IFFALSE 62088
// exit ;
62086: GO 62246
// x := GetX ( building ) ;
62088: LD_ADDR_VAR 0 5
62092: PUSH
62093: LD_VAR 0 2
62097: PPUSH
62098: CALL_OW 250
62102: ST_TO_ADDR
// y := GetY ( building ) ;
62103: LD_ADDR_VAR 0 6
62107: PUSH
62108: LD_VAR 0 2
62112: PPUSH
62113: CALL_OW 251
62117: ST_TO_ADDR
// for i = 0 to 5 do
62118: LD_ADDR_VAR 0 4
62122: PUSH
62123: DOUBLE
62124: LD_INT 0
62126: DEC
62127: ST_TO_ADDR
62128: LD_INT 5
62130: PUSH
62131: FOR_TO
62132: IFFALSE 62244
// begin _x := ShiftX ( x , i , 3 ) ;
62134: LD_ADDR_VAR 0 7
62138: PUSH
62139: LD_VAR 0 5
62143: PPUSH
62144: LD_VAR 0 4
62148: PPUSH
62149: LD_INT 3
62151: PPUSH
62152: CALL_OW 272
62156: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62157: LD_ADDR_VAR 0 8
62161: PUSH
62162: LD_VAR 0 6
62166: PPUSH
62167: LD_VAR 0 4
62171: PPUSH
62172: LD_INT 3
62174: PPUSH
62175: CALL_OW 273
62179: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62180: LD_VAR 0 7
62184: PPUSH
62185: LD_VAR 0 8
62189: PPUSH
62190: CALL_OW 488
62194: NOT
62195: IFFALSE 62199
// continue ;
62197: GO 62131
// if HexInfo ( _x , _y ) = 0 then
62199: LD_VAR 0 7
62203: PPUSH
62204: LD_VAR 0 8
62208: PPUSH
62209: CALL_OW 428
62213: PUSH
62214: LD_INT 0
62216: EQUAL
62217: IFFALSE 62242
// begin ComMoveXY ( unit , _x , _y ) ;
62219: LD_VAR 0 1
62223: PPUSH
62224: LD_VAR 0 7
62228: PPUSH
62229: LD_VAR 0 8
62233: PPUSH
62234: CALL_OW 111
// exit ;
62238: POP
62239: POP
62240: GO 62246
// end ; end ;
62242: GO 62131
62244: POP
62245: POP
// end ;
62246: LD_VAR 0 3
62250: RET
// export function ScanBase ( side , base_area ) ; begin
62251: LD_INT 0
62253: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62254: LD_ADDR_VAR 0 3
62258: PUSH
62259: LD_VAR 0 2
62263: PPUSH
62264: LD_INT 81
62266: PUSH
62267: LD_VAR 0 1
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PPUSH
62276: CALL_OW 70
62280: ST_TO_ADDR
// end ;
62281: LD_VAR 0 3
62285: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
62286: LD_INT 0
62288: PPUSH
62289: PPUSH
62290: PPUSH
62291: PPUSH
// result := false ;
62292: LD_ADDR_VAR 0 2
62296: PUSH
62297: LD_INT 0
62299: ST_TO_ADDR
// side := GetSide ( unit ) ;
62300: LD_ADDR_VAR 0 3
62304: PUSH
62305: LD_VAR 0 1
62309: PPUSH
62310: CALL_OW 255
62314: ST_TO_ADDR
// nat := GetNation ( unit ) ;
62315: LD_ADDR_VAR 0 4
62319: PUSH
62320: LD_VAR 0 1
62324: PPUSH
62325: CALL_OW 248
62329: ST_TO_ADDR
// case nat of 1 :
62330: LD_VAR 0 4
62334: PUSH
62335: LD_INT 1
62337: DOUBLE
62338: EQUAL
62339: IFTRUE 62343
62341: GO 62354
62343: POP
// tech := tech_lassight ; 2 :
62344: LD_ADDR_VAR 0 5
62348: PUSH
62349: LD_INT 12
62351: ST_TO_ADDR
62352: GO 62393
62354: LD_INT 2
62356: DOUBLE
62357: EQUAL
62358: IFTRUE 62362
62360: GO 62373
62362: POP
// tech := tech_mortar ; 3 :
62363: LD_ADDR_VAR 0 5
62367: PUSH
62368: LD_INT 41
62370: ST_TO_ADDR
62371: GO 62393
62373: LD_INT 3
62375: DOUBLE
62376: EQUAL
62377: IFTRUE 62381
62379: GO 62392
62381: POP
// tech := tech_bazooka ; end ;
62382: LD_ADDR_VAR 0 5
62386: PUSH
62387: LD_INT 44
62389: ST_TO_ADDR
62390: GO 62393
62392: POP
// if Researched ( side , tech ) then
62393: LD_VAR 0 3
62397: PPUSH
62398: LD_VAR 0 5
62402: PPUSH
62403: CALL_OW 325
62407: IFFALSE 62434
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
62409: LD_ADDR_VAR 0 2
62413: PUSH
62414: LD_INT 5
62416: PUSH
62417: LD_INT 8
62419: PUSH
62420: LD_INT 9
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: LIST
62427: PUSH
62428: LD_VAR 0 4
62432: ARRAY
62433: ST_TO_ADDR
// end ;
62434: LD_VAR 0 2
62438: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
62439: LD_INT 0
62441: PPUSH
62442: PPUSH
62443: PPUSH
// if not mines then
62444: LD_VAR 0 2
62448: NOT
62449: IFFALSE 62453
// exit ;
62451: GO 62597
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62453: LD_ADDR_VAR 0 5
62457: PUSH
62458: LD_INT 81
62460: PUSH
62461: LD_VAR 0 1
62465: PUSH
62466: EMPTY
62467: LIST
62468: LIST
62469: PUSH
62470: LD_INT 3
62472: PUSH
62473: LD_INT 21
62475: PUSH
62476: LD_INT 3
62478: PUSH
62479: EMPTY
62480: LIST
62481: LIST
62482: PUSH
62483: EMPTY
62484: LIST
62485: LIST
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PPUSH
62491: CALL_OW 69
62495: ST_TO_ADDR
// for i in mines do
62496: LD_ADDR_VAR 0 4
62500: PUSH
62501: LD_VAR 0 2
62505: PUSH
62506: FOR_IN
62507: IFFALSE 62595
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
62509: LD_VAR 0 4
62513: PUSH
62514: LD_INT 1
62516: ARRAY
62517: PPUSH
62518: LD_VAR 0 4
62522: PUSH
62523: LD_INT 2
62525: ARRAY
62526: PPUSH
62527: CALL_OW 458
62531: NOT
62532: IFFALSE 62536
// continue ;
62534: GO 62506
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
62536: LD_VAR 0 4
62540: PUSH
62541: LD_INT 1
62543: ARRAY
62544: PPUSH
62545: LD_VAR 0 4
62549: PUSH
62550: LD_INT 2
62552: ARRAY
62553: PPUSH
62554: CALL_OW 428
62558: PUSH
62559: LD_VAR 0 5
62563: IN
62564: IFFALSE 62593
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
62566: LD_VAR 0 4
62570: PUSH
62571: LD_INT 1
62573: ARRAY
62574: PPUSH
62575: LD_VAR 0 4
62579: PUSH
62580: LD_INT 2
62582: ARRAY
62583: PPUSH
62584: LD_VAR 0 1
62588: PPUSH
62589: CALL_OW 456
// end ;
62593: GO 62506
62595: POP
62596: POP
// end ;
62597: LD_VAR 0 3
62601: RET
// export function Count ( array ) ; var i ; begin
62602: LD_INT 0
62604: PPUSH
62605: PPUSH
// result := 0 ;
62606: LD_ADDR_VAR 0 2
62610: PUSH
62611: LD_INT 0
62613: ST_TO_ADDR
// for i in array do
62614: LD_ADDR_VAR 0 3
62618: PUSH
62619: LD_VAR 0 1
62623: PUSH
62624: FOR_IN
62625: IFFALSE 62649
// if i then
62627: LD_VAR 0 3
62631: IFFALSE 62647
// result := result + 1 ;
62633: LD_ADDR_VAR 0 2
62637: PUSH
62638: LD_VAR 0 2
62642: PUSH
62643: LD_INT 1
62645: PLUS
62646: ST_TO_ADDR
62647: GO 62624
62649: POP
62650: POP
// end ;
62651: LD_VAR 0 2
62655: RET
// export function IsEmpty ( building ) ; begin
62656: LD_INT 0
62658: PPUSH
// if not building then
62659: LD_VAR 0 1
62663: NOT
62664: IFFALSE 62668
// exit ;
62666: GO 62711
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
62668: LD_ADDR_VAR 0 2
62672: PUSH
62673: LD_VAR 0 1
62677: PUSH
62678: LD_INT 22
62680: PUSH
62681: LD_VAR 0 1
62685: PPUSH
62686: CALL_OW 255
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: PUSH
62695: LD_INT 58
62697: PUSH
62698: EMPTY
62699: LIST
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PPUSH
62705: CALL_OW 69
62709: IN
62710: ST_TO_ADDR
// end ;
62711: LD_VAR 0 2
62715: RET
// export function IsNotFull ( building ) ; begin
62716: LD_INT 0
62718: PPUSH
// if not building then
62719: LD_VAR 0 1
62723: NOT
62724: IFFALSE 62728
// exit ;
62726: GO 62747
// result := UnitsInside ( building ) < 6 ;
62728: LD_ADDR_VAR 0 2
62732: PUSH
62733: LD_VAR 0 1
62737: PPUSH
62738: CALL_OW 313
62742: PUSH
62743: LD_INT 6
62745: LESS
62746: ST_TO_ADDR
// end ;
62747: LD_VAR 0 2
62751: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
62752: LD_INT 0
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
// tmp := [ ] ;
62758: LD_ADDR_VAR 0 3
62762: PUSH
62763: EMPTY
62764: ST_TO_ADDR
// list := [ ] ;
62765: LD_ADDR_VAR 0 5
62769: PUSH
62770: EMPTY
62771: ST_TO_ADDR
// for i = 16 to 25 do
62772: LD_ADDR_VAR 0 4
62776: PUSH
62777: DOUBLE
62778: LD_INT 16
62780: DEC
62781: ST_TO_ADDR
62782: LD_INT 25
62784: PUSH
62785: FOR_TO
62786: IFFALSE 62859
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
62788: LD_ADDR_VAR 0 3
62792: PUSH
62793: LD_VAR 0 3
62797: PUSH
62798: LD_INT 22
62800: PUSH
62801: LD_VAR 0 1
62805: PPUSH
62806: CALL_OW 255
62810: PUSH
62811: EMPTY
62812: LIST
62813: LIST
62814: PUSH
62815: LD_INT 91
62817: PUSH
62818: LD_VAR 0 1
62822: PUSH
62823: LD_INT 6
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: LIST
62830: PUSH
62831: LD_INT 30
62833: PUSH
62834: LD_VAR 0 4
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: LIST
62847: PUSH
62848: EMPTY
62849: LIST
62850: PPUSH
62851: CALL_OW 69
62855: ADD
62856: ST_TO_ADDR
62857: GO 62785
62859: POP
62860: POP
// for i = 1 to tmp do
62861: LD_ADDR_VAR 0 4
62865: PUSH
62866: DOUBLE
62867: LD_INT 1
62869: DEC
62870: ST_TO_ADDR
62871: LD_VAR 0 3
62875: PUSH
62876: FOR_TO
62877: IFFALSE 62965
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
62879: LD_ADDR_VAR 0 5
62883: PUSH
62884: LD_VAR 0 5
62888: PUSH
62889: LD_VAR 0 3
62893: PUSH
62894: LD_VAR 0 4
62898: ARRAY
62899: PPUSH
62900: CALL_OW 266
62904: PUSH
62905: LD_VAR 0 3
62909: PUSH
62910: LD_VAR 0 4
62914: ARRAY
62915: PPUSH
62916: CALL_OW 250
62920: PUSH
62921: LD_VAR 0 3
62925: PUSH
62926: LD_VAR 0 4
62930: ARRAY
62931: PPUSH
62932: CALL_OW 251
62936: PUSH
62937: LD_VAR 0 3
62941: PUSH
62942: LD_VAR 0 4
62946: ARRAY
62947: PPUSH
62948: CALL_OW 254
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: LIST
62957: LIST
62958: PUSH
62959: EMPTY
62960: LIST
62961: ADD
62962: ST_TO_ADDR
62963: GO 62876
62965: POP
62966: POP
// result := list ;
62967: LD_ADDR_VAR 0 2
62971: PUSH
62972: LD_VAR 0 5
62976: ST_TO_ADDR
// end ;
62977: LD_VAR 0 2
62981: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
62982: LD_INT 0
62984: PPUSH
62985: PPUSH
62986: PPUSH
62987: PPUSH
62988: PPUSH
62989: PPUSH
62990: PPUSH
// if not factory then
62991: LD_VAR 0 1
62995: NOT
62996: IFFALSE 63000
// exit ;
62998: GO 63593
// if control = control_apeman then
63000: LD_VAR 0 4
63004: PUSH
63005: LD_INT 5
63007: EQUAL
63008: IFFALSE 63117
// begin tmp := UnitsInside ( factory ) ;
63010: LD_ADDR_VAR 0 8
63014: PUSH
63015: LD_VAR 0 1
63019: PPUSH
63020: CALL_OW 313
63024: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63025: LD_VAR 0 8
63029: PPUSH
63030: LD_INT 25
63032: PUSH
63033: LD_INT 12
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: PPUSH
63040: CALL_OW 72
63044: NOT
63045: IFFALSE 63055
// control := control_manual ;
63047: LD_ADDR_VAR 0 4
63051: PUSH
63052: LD_INT 1
63054: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63055: LD_ADDR_VAR 0 8
63059: PUSH
63060: LD_VAR 0 1
63064: PPUSH
63065: CALL 62752 0 1
63069: ST_TO_ADDR
// if tmp then
63070: LD_VAR 0 8
63074: IFFALSE 63117
// begin for i in tmp do
63076: LD_ADDR_VAR 0 7
63080: PUSH
63081: LD_VAR 0 8
63085: PUSH
63086: FOR_IN
63087: IFFALSE 63115
// if i [ 1 ] = b_ext_radio then
63089: LD_VAR 0 7
63093: PUSH
63094: LD_INT 1
63096: ARRAY
63097: PUSH
63098: LD_INT 22
63100: EQUAL
63101: IFFALSE 63113
// begin control := control_remote ;
63103: LD_ADDR_VAR 0 4
63107: PUSH
63108: LD_INT 2
63110: ST_TO_ADDR
// break ;
63111: GO 63115
// end ;
63113: GO 63086
63115: POP
63116: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63117: LD_VAR 0 1
63121: PPUSH
63122: LD_VAR 0 2
63126: PPUSH
63127: LD_VAR 0 3
63131: PPUSH
63132: LD_VAR 0 4
63136: PPUSH
63137: LD_VAR 0 5
63141: PPUSH
63142: CALL_OW 448
63146: IFFALSE 63181
// begin result := [ chassis , engine , control , weapon ] ;
63148: LD_ADDR_VAR 0 6
63152: PUSH
63153: LD_VAR 0 2
63157: PUSH
63158: LD_VAR 0 3
63162: PUSH
63163: LD_VAR 0 4
63167: PUSH
63168: LD_VAR 0 5
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: LIST
63177: LIST
63178: ST_TO_ADDR
// exit ;
63179: GO 63593
// end ; _chassis := AvailableChassisList ( factory ) ;
63181: LD_ADDR_VAR 0 9
63185: PUSH
63186: LD_VAR 0 1
63190: PPUSH
63191: CALL_OW 475
63195: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63196: LD_ADDR_VAR 0 11
63200: PUSH
63201: LD_VAR 0 1
63205: PPUSH
63206: CALL_OW 476
63210: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63211: LD_ADDR_VAR 0 12
63215: PUSH
63216: LD_VAR 0 1
63220: PPUSH
63221: CALL_OW 477
63225: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63226: LD_ADDR_VAR 0 10
63230: PUSH
63231: LD_VAR 0 1
63235: PPUSH
63236: CALL_OW 478
63240: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63241: LD_VAR 0 9
63245: NOT
63246: PUSH
63247: LD_VAR 0 11
63251: NOT
63252: OR
63253: PUSH
63254: LD_VAR 0 12
63258: NOT
63259: OR
63260: PUSH
63261: LD_VAR 0 10
63265: NOT
63266: OR
63267: IFFALSE 63302
// begin result := [ chassis , engine , control , weapon ] ;
63269: LD_ADDR_VAR 0 6
63273: PUSH
63274: LD_VAR 0 2
63278: PUSH
63279: LD_VAR 0 3
63283: PUSH
63284: LD_VAR 0 4
63288: PUSH
63289: LD_VAR 0 5
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: ST_TO_ADDR
// exit ;
63300: GO 63593
// end ; if not chassis in _chassis then
63302: LD_VAR 0 2
63306: PUSH
63307: LD_VAR 0 9
63311: IN
63312: NOT
63313: IFFALSE 63339
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
63315: LD_ADDR_VAR 0 2
63319: PUSH
63320: LD_VAR 0 9
63324: PUSH
63325: LD_INT 1
63327: PPUSH
63328: LD_VAR 0 9
63332: PPUSH
63333: CALL_OW 12
63337: ARRAY
63338: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
63339: LD_VAR 0 2
63343: PPUSH
63344: LD_VAR 0 3
63348: PPUSH
63349: CALL 63598 0 2
63353: NOT
63354: IFFALSE 63413
// repeat engine := _engine [ 1 ] ;
63356: LD_ADDR_VAR 0 3
63360: PUSH
63361: LD_VAR 0 11
63365: PUSH
63366: LD_INT 1
63368: ARRAY
63369: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
63370: LD_ADDR_VAR 0 11
63374: PUSH
63375: LD_VAR 0 11
63379: PPUSH
63380: LD_INT 1
63382: PPUSH
63383: CALL_OW 3
63387: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
63388: LD_VAR 0 2
63392: PPUSH
63393: LD_VAR 0 3
63397: PPUSH
63398: CALL 63598 0 2
63402: PUSH
63403: LD_VAR 0 11
63407: PUSH
63408: EMPTY
63409: EQUAL
63410: OR
63411: IFFALSE 63356
// if not control in _control then
63413: LD_VAR 0 4
63417: PUSH
63418: LD_VAR 0 12
63422: IN
63423: NOT
63424: IFFALSE 63450
// control := _control [ rand ( 1 , _control ) ] ;
63426: LD_ADDR_VAR 0 4
63430: PUSH
63431: LD_VAR 0 12
63435: PUSH
63436: LD_INT 1
63438: PPUSH
63439: LD_VAR 0 12
63443: PPUSH
63444: CALL_OW 12
63448: ARRAY
63449: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
63450: LD_VAR 0 2
63454: PPUSH
63455: LD_VAR 0 5
63459: PPUSH
63460: CALL 63818 0 2
63464: NOT
63465: IFFALSE 63524
// repeat weapon := _weapon [ 1 ] ;
63467: LD_ADDR_VAR 0 5
63471: PUSH
63472: LD_VAR 0 10
63476: PUSH
63477: LD_INT 1
63479: ARRAY
63480: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
63481: LD_ADDR_VAR 0 10
63485: PUSH
63486: LD_VAR 0 10
63490: PPUSH
63491: LD_INT 1
63493: PPUSH
63494: CALL_OW 3
63498: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
63499: LD_VAR 0 2
63503: PPUSH
63504: LD_VAR 0 5
63508: PPUSH
63509: CALL 63818 0 2
63513: PUSH
63514: LD_VAR 0 10
63518: PUSH
63519: EMPTY
63520: EQUAL
63521: OR
63522: IFFALSE 63467
// result := [ ] ;
63524: LD_ADDR_VAR 0 6
63528: PUSH
63529: EMPTY
63530: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63531: LD_VAR 0 1
63535: PPUSH
63536: LD_VAR 0 2
63540: PPUSH
63541: LD_VAR 0 3
63545: PPUSH
63546: LD_VAR 0 4
63550: PPUSH
63551: LD_VAR 0 5
63555: PPUSH
63556: CALL_OW 448
63560: IFFALSE 63593
// result := [ chassis , engine , control , weapon ] ;
63562: LD_ADDR_VAR 0 6
63566: PUSH
63567: LD_VAR 0 2
63571: PUSH
63572: LD_VAR 0 3
63576: PUSH
63577: LD_VAR 0 4
63581: PUSH
63582: LD_VAR 0 5
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: ST_TO_ADDR
// end ;
63593: LD_VAR 0 6
63597: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
63598: LD_INT 0
63600: PPUSH
// if not chassis or not engine then
63601: LD_VAR 0 1
63605: NOT
63606: PUSH
63607: LD_VAR 0 2
63611: NOT
63612: OR
63613: IFFALSE 63617
// exit ;
63615: GO 63813
// case engine of engine_solar :
63617: LD_VAR 0 2
63621: PUSH
63622: LD_INT 2
63624: DOUBLE
63625: EQUAL
63626: IFTRUE 63630
63628: GO 63668
63630: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
63631: LD_ADDR_VAR 0 3
63635: PUSH
63636: LD_INT 11
63638: PUSH
63639: LD_INT 12
63641: PUSH
63642: LD_INT 13
63644: PUSH
63645: LD_INT 14
63647: PUSH
63648: LD_INT 1
63650: PUSH
63651: LD_INT 2
63653: PUSH
63654: LD_INT 3
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: ST_TO_ADDR
63666: GO 63797
63668: LD_INT 1
63670: DOUBLE
63671: EQUAL
63672: IFTRUE 63676
63674: GO 63738
63676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
63677: LD_ADDR_VAR 0 3
63681: PUSH
63682: LD_INT 11
63684: PUSH
63685: LD_INT 12
63687: PUSH
63688: LD_INT 13
63690: PUSH
63691: LD_INT 14
63693: PUSH
63694: LD_INT 1
63696: PUSH
63697: LD_INT 2
63699: PUSH
63700: LD_INT 3
63702: PUSH
63703: LD_INT 4
63705: PUSH
63706: LD_INT 5
63708: PUSH
63709: LD_INT 21
63711: PUSH
63712: LD_INT 23
63714: PUSH
63715: LD_INT 22
63717: PUSH
63718: LD_INT 24
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: ST_TO_ADDR
63736: GO 63797
63738: LD_INT 3
63740: DOUBLE
63741: EQUAL
63742: IFTRUE 63746
63744: GO 63796
63746: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
63747: LD_ADDR_VAR 0 3
63751: PUSH
63752: LD_INT 13
63754: PUSH
63755: LD_INT 14
63757: PUSH
63758: LD_INT 2
63760: PUSH
63761: LD_INT 3
63763: PUSH
63764: LD_INT 4
63766: PUSH
63767: LD_INT 5
63769: PUSH
63770: LD_INT 21
63772: PUSH
63773: LD_INT 22
63775: PUSH
63776: LD_INT 23
63778: PUSH
63779: LD_INT 24
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: LIST
63786: LIST
63787: LIST
63788: LIST
63789: LIST
63790: LIST
63791: LIST
63792: LIST
63793: ST_TO_ADDR
63794: GO 63797
63796: POP
// result := ( chassis in result ) ;
63797: LD_ADDR_VAR 0 3
63801: PUSH
63802: LD_VAR 0 1
63806: PUSH
63807: LD_VAR 0 3
63811: IN
63812: ST_TO_ADDR
// end ;
63813: LD_VAR 0 3
63817: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
63818: LD_INT 0
63820: PPUSH
// if not chassis or not weapon then
63821: LD_VAR 0 1
63825: NOT
63826: PUSH
63827: LD_VAR 0 2
63831: NOT
63832: OR
63833: IFFALSE 63837
// exit ;
63835: GO 64899
// case weapon of us_machine_gun :
63837: LD_VAR 0 2
63841: PUSH
63842: LD_INT 2
63844: DOUBLE
63845: EQUAL
63846: IFTRUE 63850
63848: GO 63880
63850: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
63851: LD_ADDR_VAR 0 3
63855: PUSH
63856: LD_INT 1
63858: PUSH
63859: LD_INT 2
63861: PUSH
63862: LD_INT 3
63864: PUSH
63865: LD_INT 4
63867: PUSH
63868: LD_INT 5
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: ST_TO_ADDR
63878: GO 64883
63880: LD_INT 3
63882: DOUBLE
63883: EQUAL
63884: IFTRUE 63888
63886: GO 63918
63888: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
63889: LD_ADDR_VAR 0 3
63893: PUSH
63894: LD_INT 1
63896: PUSH
63897: LD_INT 2
63899: PUSH
63900: LD_INT 3
63902: PUSH
63903: LD_INT 4
63905: PUSH
63906: LD_INT 5
63908: PUSH
63909: EMPTY
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: LIST
63915: ST_TO_ADDR
63916: GO 64883
63918: LD_INT 11
63920: DOUBLE
63921: EQUAL
63922: IFTRUE 63926
63924: GO 63956
63926: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
63927: LD_ADDR_VAR 0 3
63931: PUSH
63932: LD_INT 1
63934: PUSH
63935: LD_INT 2
63937: PUSH
63938: LD_INT 3
63940: PUSH
63941: LD_INT 4
63943: PUSH
63944: LD_INT 5
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: ST_TO_ADDR
63954: GO 64883
63956: LD_INT 4
63958: DOUBLE
63959: EQUAL
63960: IFTRUE 63964
63962: GO 63990
63964: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
63965: LD_ADDR_VAR 0 3
63969: PUSH
63970: LD_INT 2
63972: PUSH
63973: LD_INT 3
63975: PUSH
63976: LD_INT 4
63978: PUSH
63979: LD_INT 5
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: LIST
63986: LIST
63987: ST_TO_ADDR
63988: GO 64883
63990: LD_INT 5
63992: DOUBLE
63993: EQUAL
63994: IFTRUE 63998
63996: GO 64024
63998: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
63999: LD_ADDR_VAR 0 3
64003: PUSH
64004: LD_INT 2
64006: PUSH
64007: LD_INT 3
64009: PUSH
64010: LD_INT 4
64012: PUSH
64013: LD_INT 5
64015: PUSH
64016: EMPTY
64017: LIST
64018: LIST
64019: LIST
64020: LIST
64021: ST_TO_ADDR
64022: GO 64883
64024: LD_INT 9
64026: DOUBLE
64027: EQUAL
64028: IFTRUE 64032
64030: GO 64058
64032: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64033: LD_ADDR_VAR 0 3
64037: PUSH
64038: LD_INT 2
64040: PUSH
64041: LD_INT 3
64043: PUSH
64044: LD_INT 4
64046: PUSH
64047: LD_INT 5
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: ST_TO_ADDR
64056: GO 64883
64058: LD_INT 7
64060: DOUBLE
64061: EQUAL
64062: IFTRUE 64066
64064: GO 64092
64066: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64067: LD_ADDR_VAR 0 3
64071: PUSH
64072: LD_INT 2
64074: PUSH
64075: LD_INT 3
64077: PUSH
64078: LD_INT 4
64080: PUSH
64081: LD_INT 5
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: ST_TO_ADDR
64090: GO 64883
64092: LD_INT 12
64094: DOUBLE
64095: EQUAL
64096: IFTRUE 64100
64098: GO 64126
64100: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64101: LD_ADDR_VAR 0 3
64105: PUSH
64106: LD_INT 2
64108: PUSH
64109: LD_INT 3
64111: PUSH
64112: LD_INT 4
64114: PUSH
64115: LD_INT 5
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: ST_TO_ADDR
64124: GO 64883
64126: LD_INT 13
64128: DOUBLE
64129: EQUAL
64130: IFTRUE 64134
64132: GO 64160
64134: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64135: LD_ADDR_VAR 0 3
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: LD_INT 3
64145: PUSH
64146: LD_INT 4
64148: PUSH
64149: LD_INT 5
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: LIST
64156: LIST
64157: ST_TO_ADDR
64158: GO 64883
64160: LD_INT 14
64162: DOUBLE
64163: EQUAL
64164: IFTRUE 64168
64166: GO 64186
64168: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64169: LD_ADDR_VAR 0 3
64173: PUSH
64174: LD_INT 4
64176: PUSH
64177: LD_INT 5
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: ST_TO_ADDR
64184: GO 64883
64186: LD_INT 6
64188: DOUBLE
64189: EQUAL
64190: IFTRUE 64194
64192: GO 64212
64194: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64195: LD_ADDR_VAR 0 3
64199: PUSH
64200: LD_INT 4
64202: PUSH
64203: LD_INT 5
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: ST_TO_ADDR
64210: GO 64883
64212: LD_INT 10
64214: DOUBLE
64215: EQUAL
64216: IFTRUE 64220
64218: GO 64238
64220: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64221: LD_ADDR_VAR 0 3
64225: PUSH
64226: LD_INT 4
64228: PUSH
64229: LD_INT 5
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: ST_TO_ADDR
64236: GO 64883
64238: LD_INT 22
64240: DOUBLE
64241: EQUAL
64242: IFTRUE 64246
64244: GO 64272
64246: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64247: LD_ADDR_VAR 0 3
64251: PUSH
64252: LD_INT 11
64254: PUSH
64255: LD_INT 12
64257: PUSH
64258: LD_INT 13
64260: PUSH
64261: LD_INT 14
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: LIST
64268: LIST
64269: ST_TO_ADDR
64270: GO 64883
64272: LD_INT 23
64274: DOUBLE
64275: EQUAL
64276: IFTRUE 64280
64278: GO 64306
64280: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
64281: LD_ADDR_VAR 0 3
64285: PUSH
64286: LD_INT 11
64288: PUSH
64289: LD_INT 12
64291: PUSH
64292: LD_INT 13
64294: PUSH
64295: LD_INT 14
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: ST_TO_ADDR
64304: GO 64883
64306: LD_INT 24
64308: DOUBLE
64309: EQUAL
64310: IFTRUE 64314
64312: GO 64340
64314: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
64315: LD_ADDR_VAR 0 3
64319: PUSH
64320: LD_INT 11
64322: PUSH
64323: LD_INT 12
64325: PUSH
64326: LD_INT 13
64328: PUSH
64329: LD_INT 14
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: ST_TO_ADDR
64338: GO 64883
64340: LD_INT 30
64342: DOUBLE
64343: EQUAL
64344: IFTRUE 64348
64346: GO 64374
64348: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
64349: LD_ADDR_VAR 0 3
64353: PUSH
64354: LD_INT 11
64356: PUSH
64357: LD_INT 12
64359: PUSH
64360: LD_INT 13
64362: PUSH
64363: LD_INT 14
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: LIST
64370: LIST
64371: ST_TO_ADDR
64372: GO 64883
64374: LD_INT 25
64376: DOUBLE
64377: EQUAL
64378: IFTRUE 64382
64380: GO 64400
64382: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
64383: LD_ADDR_VAR 0 3
64387: PUSH
64388: LD_INT 13
64390: PUSH
64391: LD_INT 14
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: ST_TO_ADDR
64398: GO 64883
64400: LD_INT 27
64402: DOUBLE
64403: EQUAL
64404: IFTRUE 64408
64406: GO 64426
64408: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
64409: LD_ADDR_VAR 0 3
64413: PUSH
64414: LD_INT 13
64416: PUSH
64417: LD_INT 14
64419: PUSH
64420: EMPTY
64421: LIST
64422: LIST
64423: ST_TO_ADDR
64424: GO 64883
64426: LD_EXP 78
64430: DOUBLE
64431: EQUAL
64432: IFTRUE 64436
64434: GO 64462
64436: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
64437: LD_ADDR_VAR 0 3
64441: PUSH
64442: LD_INT 11
64444: PUSH
64445: LD_INT 12
64447: PUSH
64448: LD_INT 13
64450: PUSH
64451: LD_INT 14
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: ST_TO_ADDR
64460: GO 64883
64462: LD_INT 28
64464: DOUBLE
64465: EQUAL
64466: IFTRUE 64470
64468: GO 64488
64470: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
64471: LD_ADDR_VAR 0 3
64475: PUSH
64476: LD_INT 13
64478: PUSH
64479: LD_INT 14
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: ST_TO_ADDR
64486: GO 64883
64488: LD_INT 29
64490: DOUBLE
64491: EQUAL
64492: IFTRUE 64496
64494: GO 64514
64496: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
64497: LD_ADDR_VAR 0 3
64501: PUSH
64502: LD_INT 13
64504: PUSH
64505: LD_INT 14
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: ST_TO_ADDR
64512: GO 64883
64514: LD_INT 31
64516: DOUBLE
64517: EQUAL
64518: IFTRUE 64522
64520: GO 64540
64522: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
64523: LD_ADDR_VAR 0 3
64527: PUSH
64528: LD_INT 13
64530: PUSH
64531: LD_INT 14
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: ST_TO_ADDR
64538: GO 64883
64540: LD_INT 26
64542: DOUBLE
64543: EQUAL
64544: IFTRUE 64548
64546: GO 64566
64548: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
64549: LD_ADDR_VAR 0 3
64553: PUSH
64554: LD_INT 13
64556: PUSH
64557: LD_INT 14
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: ST_TO_ADDR
64564: GO 64883
64566: LD_INT 42
64568: DOUBLE
64569: EQUAL
64570: IFTRUE 64574
64572: GO 64600
64574: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
64575: LD_ADDR_VAR 0 3
64579: PUSH
64580: LD_INT 21
64582: PUSH
64583: LD_INT 22
64585: PUSH
64586: LD_INT 23
64588: PUSH
64589: LD_INT 24
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: ST_TO_ADDR
64598: GO 64883
64600: LD_INT 43
64602: DOUBLE
64603: EQUAL
64604: IFTRUE 64608
64606: GO 64634
64608: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
64609: LD_ADDR_VAR 0 3
64613: PUSH
64614: LD_INT 21
64616: PUSH
64617: LD_INT 22
64619: PUSH
64620: LD_INT 23
64622: PUSH
64623: LD_INT 24
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: ST_TO_ADDR
64632: GO 64883
64634: LD_INT 44
64636: DOUBLE
64637: EQUAL
64638: IFTRUE 64642
64640: GO 64668
64642: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
64643: LD_ADDR_VAR 0 3
64647: PUSH
64648: LD_INT 21
64650: PUSH
64651: LD_INT 22
64653: PUSH
64654: LD_INT 23
64656: PUSH
64657: LD_INT 24
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: ST_TO_ADDR
64666: GO 64883
64668: LD_INT 45
64670: DOUBLE
64671: EQUAL
64672: IFTRUE 64676
64674: GO 64702
64676: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
64677: LD_ADDR_VAR 0 3
64681: PUSH
64682: LD_INT 21
64684: PUSH
64685: LD_INT 22
64687: PUSH
64688: LD_INT 23
64690: PUSH
64691: LD_INT 24
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: ST_TO_ADDR
64700: GO 64883
64702: LD_INT 49
64704: DOUBLE
64705: EQUAL
64706: IFTRUE 64710
64708: GO 64736
64710: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
64711: LD_ADDR_VAR 0 3
64715: PUSH
64716: LD_INT 21
64718: PUSH
64719: LD_INT 22
64721: PUSH
64722: LD_INT 23
64724: PUSH
64725: LD_INT 24
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: ST_TO_ADDR
64734: GO 64883
64736: LD_INT 51
64738: DOUBLE
64739: EQUAL
64740: IFTRUE 64744
64742: GO 64770
64744: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
64745: LD_ADDR_VAR 0 3
64749: PUSH
64750: LD_INT 21
64752: PUSH
64753: LD_INT 22
64755: PUSH
64756: LD_INT 23
64758: PUSH
64759: LD_INT 24
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: ST_TO_ADDR
64768: GO 64883
64770: LD_INT 52
64772: DOUBLE
64773: EQUAL
64774: IFTRUE 64778
64776: GO 64804
64778: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
64779: LD_ADDR_VAR 0 3
64783: PUSH
64784: LD_INT 21
64786: PUSH
64787: LD_INT 22
64789: PUSH
64790: LD_INT 23
64792: PUSH
64793: LD_INT 24
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: ST_TO_ADDR
64802: GO 64883
64804: LD_INT 53
64806: DOUBLE
64807: EQUAL
64808: IFTRUE 64812
64810: GO 64830
64812: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
64813: LD_ADDR_VAR 0 3
64817: PUSH
64818: LD_INT 23
64820: PUSH
64821: LD_INT 24
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: ST_TO_ADDR
64828: GO 64883
64830: LD_INT 46
64832: DOUBLE
64833: EQUAL
64834: IFTRUE 64838
64836: GO 64856
64838: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
64839: LD_ADDR_VAR 0 3
64843: PUSH
64844: LD_INT 23
64846: PUSH
64847: LD_INT 24
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: ST_TO_ADDR
64854: GO 64883
64856: LD_INT 47
64858: DOUBLE
64859: EQUAL
64860: IFTRUE 64864
64862: GO 64882
64864: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64865: LD_ADDR_VAR 0 3
64869: PUSH
64870: LD_INT 23
64872: PUSH
64873: LD_INT 24
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: ST_TO_ADDR
64880: GO 64883
64882: POP
// result := ( chassis in result ) ;
64883: LD_ADDR_VAR 0 3
64887: PUSH
64888: LD_VAR 0 1
64892: PUSH
64893: LD_VAR 0 3
64897: IN
64898: ST_TO_ADDR
// end ;
64899: LD_VAR 0 3
64903: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
64904: LD_INT 0
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
64910: PPUSH
64911: PPUSH
64912: PPUSH
// result := array ;
64913: LD_ADDR_VAR 0 5
64917: PUSH
64918: LD_VAR 0 1
64922: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
64923: LD_VAR 0 1
64927: NOT
64928: PUSH
64929: LD_VAR 0 2
64933: NOT
64934: OR
64935: PUSH
64936: LD_VAR 0 3
64940: NOT
64941: OR
64942: PUSH
64943: LD_VAR 0 2
64947: PUSH
64948: LD_VAR 0 1
64952: GREATER
64953: OR
64954: PUSH
64955: LD_VAR 0 3
64959: PUSH
64960: LD_VAR 0 1
64964: GREATER
64965: OR
64966: IFFALSE 64970
// exit ;
64968: GO 65266
// if direction then
64970: LD_VAR 0 4
64974: IFFALSE 65038
// begin d := 1 ;
64976: LD_ADDR_VAR 0 9
64980: PUSH
64981: LD_INT 1
64983: ST_TO_ADDR
// if i_from > i_to then
64984: LD_VAR 0 2
64988: PUSH
64989: LD_VAR 0 3
64993: GREATER
64994: IFFALSE 65020
// length := ( array - i_from ) + i_to else
64996: LD_ADDR_VAR 0 11
65000: PUSH
65001: LD_VAR 0 1
65005: PUSH
65006: LD_VAR 0 2
65010: MINUS
65011: PUSH
65012: LD_VAR 0 3
65016: PLUS
65017: ST_TO_ADDR
65018: GO 65036
// length := i_to - i_from ;
65020: LD_ADDR_VAR 0 11
65024: PUSH
65025: LD_VAR 0 3
65029: PUSH
65030: LD_VAR 0 2
65034: MINUS
65035: ST_TO_ADDR
// end else
65036: GO 65099
// begin d := - 1 ;
65038: LD_ADDR_VAR 0 9
65042: PUSH
65043: LD_INT 1
65045: NEG
65046: ST_TO_ADDR
// if i_from > i_to then
65047: LD_VAR 0 2
65051: PUSH
65052: LD_VAR 0 3
65056: GREATER
65057: IFFALSE 65077
// length := i_from - i_to else
65059: LD_ADDR_VAR 0 11
65063: PUSH
65064: LD_VAR 0 2
65068: PUSH
65069: LD_VAR 0 3
65073: MINUS
65074: ST_TO_ADDR
65075: GO 65099
// length := ( array - i_to ) + i_from ;
65077: LD_ADDR_VAR 0 11
65081: PUSH
65082: LD_VAR 0 1
65086: PUSH
65087: LD_VAR 0 3
65091: MINUS
65092: PUSH
65093: LD_VAR 0 2
65097: PLUS
65098: ST_TO_ADDR
// end ; if not length then
65099: LD_VAR 0 11
65103: NOT
65104: IFFALSE 65108
// exit ;
65106: GO 65266
// tmp := array ;
65108: LD_ADDR_VAR 0 10
65112: PUSH
65113: LD_VAR 0 1
65117: ST_TO_ADDR
// for i = 1 to length do
65118: LD_ADDR_VAR 0 6
65122: PUSH
65123: DOUBLE
65124: LD_INT 1
65126: DEC
65127: ST_TO_ADDR
65128: LD_VAR 0 11
65132: PUSH
65133: FOR_TO
65134: IFFALSE 65254
// begin for j = 1 to array do
65136: LD_ADDR_VAR 0 7
65140: PUSH
65141: DOUBLE
65142: LD_INT 1
65144: DEC
65145: ST_TO_ADDR
65146: LD_VAR 0 1
65150: PUSH
65151: FOR_TO
65152: IFFALSE 65240
// begin k := j + d ;
65154: LD_ADDR_VAR 0 8
65158: PUSH
65159: LD_VAR 0 7
65163: PUSH
65164: LD_VAR 0 9
65168: PLUS
65169: ST_TO_ADDR
// if k > array then
65170: LD_VAR 0 8
65174: PUSH
65175: LD_VAR 0 1
65179: GREATER
65180: IFFALSE 65190
// k := 1 ;
65182: LD_ADDR_VAR 0 8
65186: PUSH
65187: LD_INT 1
65189: ST_TO_ADDR
// if not k then
65190: LD_VAR 0 8
65194: NOT
65195: IFFALSE 65207
// k := array ;
65197: LD_ADDR_VAR 0 8
65201: PUSH
65202: LD_VAR 0 1
65206: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65207: LD_ADDR_VAR 0 10
65211: PUSH
65212: LD_VAR 0 10
65216: PPUSH
65217: LD_VAR 0 8
65221: PPUSH
65222: LD_VAR 0 1
65226: PUSH
65227: LD_VAR 0 7
65231: ARRAY
65232: PPUSH
65233: CALL_OW 1
65237: ST_TO_ADDR
// end ;
65238: GO 65151
65240: POP
65241: POP
// array := tmp ;
65242: LD_ADDR_VAR 0 1
65246: PUSH
65247: LD_VAR 0 10
65251: ST_TO_ADDR
// end ;
65252: GO 65133
65254: POP
65255: POP
// result := array ;
65256: LD_ADDR_VAR 0 5
65260: PUSH
65261: LD_VAR 0 1
65265: ST_TO_ADDR
// end ;
65266: LD_VAR 0 5
65270: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65271: LD_INT 0
65273: PPUSH
65274: PPUSH
// result := 0 ;
65275: LD_ADDR_VAR 0 3
65279: PUSH
65280: LD_INT 0
65282: ST_TO_ADDR
// if not array or not value in array then
65283: LD_VAR 0 1
65287: NOT
65288: PUSH
65289: LD_VAR 0 2
65293: PUSH
65294: LD_VAR 0 1
65298: IN
65299: NOT
65300: OR
65301: IFFALSE 65305
// exit ;
65303: GO 65359
// for i = 1 to array do
65305: LD_ADDR_VAR 0 4
65309: PUSH
65310: DOUBLE
65311: LD_INT 1
65313: DEC
65314: ST_TO_ADDR
65315: LD_VAR 0 1
65319: PUSH
65320: FOR_TO
65321: IFFALSE 65357
// if value = array [ i ] then
65323: LD_VAR 0 2
65327: PUSH
65328: LD_VAR 0 1
65332: PUSH
65333: LD_VAR 0 4
65337: ARRAY
65338: EQUAL
65339: IFFALSE 65355
// begin result := i ;
65341: LD_ADDR_VAR 0 3
65345: PUSH
65346: LD_VAR 0 4
65350: ST_TO_ADDR
// exit ;
65351: POP
65352: POP
65353: GO 65359
// end ;
65355: GO 65320
65357: POP
65358: POP
// end ;
65359: LD_VAR 0 3
65363: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
65364: LD_INT 0
65366: PPUSH
// vc_chassis := chassis ;
65367: LD_ADDR_OWVAR 37
65371: PUSH
65372: LD_VAR 0 1
65376: ST_TO_ADDR
// vc_engine := engine ;
65377: LD_ADDR_OWVAR 39
65381: PUSH
65382: LD_VAR 0 2
65386: ST_TO_ADDR
// vc_control := control ;
65387: LD_ADDR_OWVAR 38
65391: PUSH
65392: LD_VAR 0 3
65396: ST_TO_ADDR
// vc_weapon := weapon ;
65397: LD_ADDR_OWVAR 40
65401: PUSH
65402: LD_VAR 0 4
65406: ST_TO_ADDR
// vc_fuel_battery := fuel ;
65407: LD_ADDR_OWVAR 41
65411: PUSH
65412: LD_VAR 0 5
65416: ST_TO_ADDR
// end ;
65417: LD_VAR 0 6
65421: RET
// export function WantPlant ( unit ) ; var task ; begin
65422: LD_INT 0
65424: PPUSH
65425: PPUSH
// result := false ;
65426: LD_ADDR_VAR 0 2
65430: PUSH
65431: LD_INT 0
65433: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
65434: LD_ADDR_VAR 0 3
65438: PUSH
65439: LD_VAR 0 1
65443: PPUSH
65444: CALL_OW 437
65448: ST_TO_ADDR
// if task then
65449: LD_VAR 0 3
65453: IFFALSE 65481
// if task [ 1 ] [ 1 ] = p then
65455: LD_VAR 0 3
65459: PUSH
65460: LD_INT 1
65462: ARRAY
65463: PUSH
65464: LD_INT 1
65466: ARRAY
65467: PUSH
65468: LD_STRING p
65470: EQUAL
65471: IFFALSE 65481
// result := true ;
65473: LD_ADDR_VAR 0 2
65477: PUSH
65478: LD_INT 1
65480: ST_TO_ADDR
// end ;
65481: LD_VAR 0 2
65485: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
65486: LD_INT 0
65488: PPUSH
65489: PPUSH
65490: PPUSH
65491: PPUSH
// if pos < 1 then
65492: LD_VAR 0 2
65496: PUSH
65497: LD_INT 1
65499: LESS
65500: IFFALSE 65504
// exit ;
65502: GO 65807
// if pos = 1 then
65504: LD_VAR 0 2
65508: PUSH
65509: LD_INT 1
65511: EQUAL
65512: IFFALSE 65545
// result := Replace ( arr , pos [ 1 ] , value ) else
65514: LD_ADDR_VAR 0 4
65518: PUSH
65519: LD_VAR 0 1
65523: PPUSH
65524: LD_VAR 0 2
65528: PUSH
65529: LD_INT 1
65531: ARRAY
65532: PPUSH
65533: LD_VAR 0 3
65537: PPUSH
65538: CALL_OW 1
65542: ST_TO_ADDR
65543: GO 65807
// begin tmp := arr ;
65545: LD_ADDR_VAR 0 6
65549: PUSH
65550: LD_VAR 0 1
65554: ST_TO_ADDR
// s_arr := [ tmp ] ;
65555: LD_ADDR_VAR 0 7
65559: PUSH
65560: LD_VAR 0 6
65564: PUSH
65565: EMPTY
65566: LIST
65567: ST_TO_ADDR
// for i = 1 to pos - 1 do
65568: LD_ADDR_VAR 0 5
65572: PUSH
65573: DOUBLE
65574: LD_INT 1
65576: DEC
65577: ST_TO_ADDR
65578: LD_VAR 0 2
65582: PUSH
65583: LD_INT 1
65585: MINUS
65586: PUSH
65587: FOR_TO
65588: IFFALSE 65633
// begin tmp := tmp [ pos [ i ] ] ;
65590: LD_ADDR_VAR 0 6
65594: PUSH
65595: LD_VAR 0 6
65599: PUSH
65600: LD_VAR 0 2
65604: PUSH
65605: LD_VAR 0 5
65609: ARRAY
65610: ARRAY
65611: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
65612: LD_ADDR_VAR 0 7
65616: PUSH
65617: LD_VAR 0 7
65621: PUSH
65622: LD_VAR 0 6
65626: PUSH
65627: EMPTY
65628: LIST
65629: ADD
65630: ST_TO_ADDR
// end ;
65631: GO 65587
65633: POP
65634: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
65635: LD_ADDR_VAR 0 6
65639: PUSH
65640: LD_VAR 0 6
65644: PPUSH
65645: LD_VAR 0 2
65649: PUSH
65650: LD_VAR 0 2
65654: ARRAY
65655: PPUSH
65656: LD_VAR 0 3
65660: PPUSH
65661: CALL_OW 1
65665: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
65666: LD_ADDR_VAR 0 7
65670: PUSH
65671: LD_VAR 0 7
65675: PPUSH
65676: LD_VAR 0 7
65680: PPUSH
65681: LD_VAR 0 6
65685: PPUSH
65686: CALL_OW 1
65690: ST_TO_ADDR
// for i = s_arr downto 2 do
65691: LD_ADDR_VAR 0 5
65695: PUSH
65696: DOUBLE
65697: LD_VAR 0 7
65701: INC
65702: ST_TO_ADDR
65703: LD_INT 2
65705: PUSH
65706: FOR_DOWNTO
65707: IFFALSE 65791
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
65709: LD_ADDR_VAR 0 6
65713: PUSH
65714: LD_VAR 0 7
65718: PUSH
65719: LD_VAR 0 5
65723: PUSH
65724: LD_INT 1
65726: MINUS
65727: ARRAY
65728: PPUSH
65729: LD_VAR 0 2
65733: PUSH
65734: LD_VAR 0 5
65738: PUSH
65739: LD_INT 1
65741: MINUS
65742: ARRAY
65743: PPUSH
65744: LD_VAR 0 7
65748: PUSH
65749: LD_VAR 0 5
65753: ARRAY
65754: PPUSH
65755: CALL_OW 1
65759: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
65760: LD_ADDR_VAR 0 7
65764: PUSH
65765: LD_VAR 0 7
65769: PPUSH
65770: LD_VAR 0 5
65774: PUSH
65775: LD_INT 1
65777: MINUS
65778: PPUSH
65779: LD_VAR 0 6
65783: PPUSH
65784: CALL_OW 1
65788: ST_TO_ADDR
// end ;
65789: GO 65706
65791: POP
65792: POP
// result := s_arr [ 1 ] ;
65793: LD_ADDR_VAR 0 4
65797: PUSH
65798: LD_VAR 0 7
65802: PUSH
65803: LD_INT 1
65805: ARRAY
65806: ST_TO_ADDR
// end ; end ;
65807: LD_VAR 0 4
65811: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
65812: LD_INT 0
65814: PPUSH
65815: PPUSH
// if not list then
65816: LD_VAR 0 1
65820: NOT
65821: IFFALSE 65825
// exit ;
65823: GO 65916
// i := list [ pos1 ] ;
65825: LD_ADDR_VAR 0 5
65829: PUSH
65830: LD_VAR 0 1
65834: PUSH
65835: LD_VAR 0 2
65839: ARRAY
65840: ST_TO_ADDR
// if not i then
65841: LD_VAR 0 5
65845: NOT
65846: IFFALSE 65850
// exit ;
65848: GO 65916
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
65850: LD_ADDR_VAR 0 1
65854: PUSH
65855: LD_VAR 0 1
65859: PPUSH
65860: LD_VAR 0 2
65864: PPUSH
65865: LD_VAR 0 1
65869: PUSH
65870: LD_VAR 0 3
65874: ARRAY
65875: PPUSH
65876: CALL_OW 1
65880: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
65881: LD_ADDR_VAR 0 1
65885: PUSH
65886: LD_VAR 0 1
65890: PPUSH
65891: LD_VAR 0 3
65895: PPUSH
65896: LD_VAR 0 5
65900: PPUSH
65901: CALL_OW 1
65905: ST_TO_ADDR
// result := list ;
65906: LD_ADDR_VAR 0 4
65910: PUSH
65911: LD_VAR 0 1
65915: ST_TO_ADDR
// end ;
65916: LD_VAR 0 4
65920: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
65921: LD_INT 0
65923: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
65924: LD_ADDR_VAR 0 5
65928: PUSH
65929: LD_VAR 0 1
65933: PPUSH
65934: CALL_OW 250
65938: PPUSH
65939: LD_VAR 0 1
65943: PPUSH
65944: CALL_OW 251
65948: PPUSH
65949: LD_VAR 0 2
65953: PPUSH
65954: LD_VAR 0 3
65958: PPUSH
65959: LD_VAR 0 4
65963: PPUSH
65964: CALL 65974 0 5
65968: ST_TO_ADDR
// end ;
65969: LD_VAR 0 5
65973: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
65974: LD_INT 0
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
// if not list then
65980: LD_VAR 0 3
65984: NOT
65985: IFFALSE 65989
// exit ;
65987: GO 66377
// result := [ ] ;
65989: LD_ADDR_VAR 0 6
65993: PUSH
65994: EMPTY
65995: ST_TO_ADDR
// for i in list do
65996: LD_ADDR_VAR 0 7
66000: PUSH
66001: LD_VAR 0 3
66005: PUSH
66006: FOR_IN
66007: IFFALSE 66209
// begin tmp := GetDistUnitXY ( i , x , y ) ;
66009: LD_ADDR_VAR 0 9
66013: PUSH
66014: LD_VAR 0 7
66018: PPUSH
66019: LD_VAR 0 1
66023: PPUSH
66024: LD_VAR 0 2
66028: PPUSH
66029: CALL_OW 297
66033: ST_TO_ADDR
// if not result then
66034: LD_VAR 0 6
66038: NOT
66039: IFFALSE 66065
// result := [ [ i , tmp ] ] else
66041: LD_ADDR_VAR 0 6
66045: PUSH
66046: LD_VAR 0 7
66050: PUSH
66051: LD_VAR 0 9
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: EMPTY
66061: LIST
66062: ST_TO_ADDR
66063: GO 66207
// begin if result [ result ] [ 2 ] < tmp then
66065: LD_VAR 0 6
66069: PUSH
66070: LD_VAR 0 6
66074: ARRAY
66075: PUSH
66076: LD_INT 2
66078: ARRAY
66079: PUSH
66080: LD_VAR 0 9
66084: LESS
66085: IFFALSE 66127
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66087: LD_ADDR_VAR 0 6
66091: PUSH
66092: LD_VAR 0 6
66096: PPUSH
66097: LD_VAR 0 6
66101: PUSH
66102: LD_INT 1
66104: PLUS
66105: PPUSH
66106: LD_VAR 0 7
66110: PUSH
66111: LD_VAR 0 9
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PPUSH
66120: CALL_OW 2
66124: ST_TO_ADDR
66125: GO 66207
// for j = 1 to result do
66127: LD_ADDR_VAR 0 8
66131: PUSH
66132: DOUBLE
66133: LD_INT 1
66135: DEC
66136: ST_TO_ADDR
66137: LD_VAR 0 6
66141: PUSH
66142: FOR_TO
66143: IFFALSE 66205
// begin if tmp < result [ j ] [ 2 ] then
66145: LD_VAR 0 9
66149: PUSH
66150: LD_VAR 0 6
66154: PUSH
66155: LD_VAR 0 8
66159: ARRAY
66160: PUSH
66161: LD_INT 2
66163: ARRAY
66164: LESS
66165: IFFALSE 66203
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66167: LD_ADDR_VAR 0 6
66171: PUSH
66172: LD_VAR 0 6
66176: PPUSH
66177: LD_VAR 0 8
66181: PPUSH
66182: LD_VAR 0 7
66186: PUSH
66187: LD_VAR 0 9
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PPUSH
66196: CALL_OW 2
66200: ST_TO_ADDR
// break ;
66201: GO 66205
// end ; end ;
66203: GO 66142
66205: POP
66206: POP
// end ; end ;
66207: GO 66006
66209: POP
66210: POP
// if result and not asc then
66211: LD_VAR 0 6
66215: PUSH
66216: LD_VAR 0 4
66220: NOT
66221: AND
66222: IFFALSE 66297
// begin tmp := result ;
66224: LD_ADDR_VAR 0 9
66228: PUSH
66229: LD_VAR 0 6
66233: ST_TO_ADDR
// for i = tmp downto 1 do
66234: LD_ADDR_VAR 0 7
66238: PUSH
66239: DOUBLE
66240: LD_VAR 0 9
66244: INC
66245: ST_TO_ADDR
66246: LD_INT 1
66248: PUSH
66249: FOR_DOWNTO
66250: IFFALSE 66295
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66252: LD_ADDR_VAR 0 6
66256: PUSH
66257: LD_VAR 0 6
66261: PPUSH
66262: LD_VAR 0 9
66266: PUSH
66267: LD_VAR 0 7
66271: MINUS
66272: PUSH
66273: LD_INT 1
66275: PLUS
66276: PPUSH
66277: LD_VAR 0 9
66281: PUSH
66282: LD_VAR 0 7
66286: ARRAY
66287: PPUSH
66288: CALL_OW 1
66292: ST_TO_ADDR
66293: GO 66249
66295: POP
66296: POP
// end ; tmp := [ ] ;
66297: LD_ADDR_VAR 0 9
66301: PUSH
66302: EMPTY
66303: ST_TO_ADDR
// if mode then
66304: LD_VAR 0 5
66308: IFFALSE 66377
// begin for i = 1 to result do
66310: LD_ADDR_VAR 0 7
66314: PUSH
66315: DOUBLE
66316: LD_INT 1
66318: DEC
66319: ST_TO_ADDR
66320: LD_VAR 0 6
66324: PUSH
66325: FOR_TO
66326: IFFALSE 66365
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
66328: LD_ADDR_VAR 0 9
66332: PUSH
66333: LD_VAR 0 9
66337: PPUSH
66338: LD_VAR 0 7
66342: PPUSH
66343: LD_VAR 0 6
66347: PUSH
66348: LD_VAR 0 7
66352: ARRAY
66353: PUSH
66354: LD_INT 1
66356: ARRAY
66357: PPUSH
66358: CALL_OW 1
66362: ST_TO_ADDR
66363: GO 66325
66365: POP
66366: POP
// result := tmp ;
66367: LD_ADDR_VAR 0 6
66371: PUSH
66372: LD_VAR 0 9
66376: ST_TO_ADDR
// end ; end ;
66377: LD_VAR 0 6
66381: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
66382: LD_INT 0
66384: PPUSH
66385: PPUSH
66386: PPUSH
66387: PPUSH
66388: PPUSH
66389: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
66390: LD_ADDR_VAR 0 5
66394: PUSH
66395: LD_INT 0
66397: PUSH
66398: LD_INT 0
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: EMPTY
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: ST_TO_ADDR
// if not x or not y then
66412: LD_VAR 0 2
66416: NOT
66417: PUSH
66418: LD_VAR 0 3
66422: NOT
66423: OR
66424: IFFALSE 66428
// exit ;
66426: GO 68080
// if not range then
66428: LD_VAR 0 4
66432: NOT
66433: IFFALSE 66443
// range := 10 ;
66435: LD_ADDR_VAR 0 4
66439: PUSH
66440: LD_INT 10
66442: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66443: LD_ADDR_VAR 0 8
66447: PUSH
66448: LD_INT 81
66450: PUSH
66451: LD_VAR 0 1
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 92
66462: PUSH
66463: LD_VAR 0 2
66467: PUSH
66468: LD_VAR 0 3
66472: PUSH
66473: LD_VAR 0 4
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: PUSH
66484: LD_INT 3
66486: PUSH
66487: LD_INT 21
66489: PUSH
66490: LD_INT 3
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: LIST
66505: PPUSH
66506: CALL_OW 69
66510: ST_TO_ADDR
// if not tmp then
66511: LD_VAR 0 8
66515: NOT
66516: IFFALSE 66520
// exit ;
66518: GO 68080
// for i in tmp do
66520: LD_ADDR_VAR 0 6
66524: PUSH
66525: LD_VAR 0 8
66529: PUSH
66530: FOR_IN
66531: IFFALSE 68055
// begin points := [ 0 , 0 , 0 ] ;
66533: LD_ADDR_VAR 0 9
66537: PUSH
66538: LD_INT 0
66540: PUSH
66541: LD_INT 0
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: LIST
66551: ST_TO_ADDR
// bpoints := 1 ;
66552: LD_ADDR_VAR 0 10
66556: PUSH
66557: LD_INT 1
66559: ST_TO_ADDR
// case GetType ( i ) of unit_human :
66560: LD_VAR 0 6
66564: PPUSH
66565: CALL_OW 247
66569: PUSH
66570: LD_INT 1
66572: DOUBLE
66573: EQUAL
66574: IFTRUE 66578
66576: GO 67156
66578: POP
// begin if GetClass ( i ) = 1 then
66579: LD_VAR 0 6
66583: PPUSH
66584: CALL_OW 257
66588: PUSH
66589: LD_INT 1
66591: EQUAL
66592: IFFALSE 66613
// points := [ 10 , 5 , 3 ] ;
66594: LD_ADDR_VAR 0 9
66598: PUSH
66599: LD_INT 10
66601: PUSH
66602: LD_INT 5
66604: PUSH
66605: LD_INT 3
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: LIST
66612: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
66613: LD_VAR 0 6
66617: PPUSH
66618: CALL_OW 257
66622: PUSH
66623: LD_INT 2
66625: PUSH
66626: LD_INT 3
66628: PUSH
66629: LD_INT 4
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: LIST
66636: IN
66637: IFFALSE 66658
// points := [ 3 , 2 , 1 ] ;
66639: LD_ADDR_VAR 0 9
66643: PUSH
66644: LD_INT 3
66646: PUSH
66647: LD_INT 2
66649: PUSH
66650: LD_INT 1
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: LIST
66657: ST_TO_ADDR
// if GetClass ( i ) = 5 then
66658: LD_VAR 0 6
66662: PPUSH
66663: CALL_OW 257
66667: PUSH
66668: LD_INT 5
66670: EQUAL
66671: IFFALSE 66692
// points := [ 130 , 5 , 2 ] ;
66673: LD_ADDR_VAR 0 9
66677: PUSH
66678: LD_INT 130
66680: PUSH
66681: LD_INT 5
66683: PUSH
66684: LD_INT 2
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: LIST
66691: ST_TO_ADDR
// if GetClass ( i ) = 8 then
66692: LD_VAR 0 6
66696: PPUSH
66697: CALL_OW 257
66701: PUSH
66702: LD_INT 8
66704: EQUAL
66705: IFFALSE 66726
// points := [ 35 , 35 , 30 ] ;
66707: LD_ADDR_VAR 0 9
66711: PUSH
66712: LD_INT 35
66714: PUSH
66715: LD_INT 35
66717: PUSH
66718: LD_INT 30
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: LIST
66725: ST_TO_ADDR
// if GetClass ( i ) = 9 then
66726: LD_VAR 0 6
66730: PPUSH
66731: CALL_OW 257
66735: PUSH
66736: LD_INT 9
66738: EQUAL
66739: IFFALSE 66760
// points := [ 20 , 55 , 40 ] ;
66741: LD_ADDR_VAR 0 9
66745: PUSH
66746: LD_INT 20
66748: PUSH
66749: LD_INT 55
66751: PUSH
66752: LD_INT 40
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: LIST
66759: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
66760: LD_VAR 0 6
66764: PPUSH
66765: CALL_OW 257
66769: PUSH
66770: LD_INT 12
66772: PUSH
66773: LD_INT 16
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: IN
66780: IFFALSE 66801
// points := [ 5 , 3 , 2 ] ;
66782: LD_ADDR_VAR 0 9
66786: PUSH
66787: LD_INT 5
66789: PUSH
66790: LD_INT 3
66792: PUSH
66793: LD_INT 2
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: LIST
66800: ST_TO_ADDR
// if GetClass ( i ) = 17 then
66801: LD_VAR 0 6
66805: PPUSH
66806: CALL_OW 257
66810: PUSH
66811: LD_INT 17
66813: EQUAL
66814: IFFALSE 66835
// points := [ 100 , 50 , 75 ] ;
66816: LD_ADDR_VAR 0 9
66820: PUSH
66821: LD_INT 100
66823: PUSH
66824: LD_INT 50
66826: PUSH
66827: LD_INT 75
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: LIST
66834: ST_TO_ADDR
// if GetClass ( i ) = 15 then
66835: LD_VAR 0 6
66839: PPUSH
66840: CALL_OW 257
66844: PUSH
66845: LD_INT 15
66847: EQUAL
66848: IFFALSE 66869
// points := [ 10 , 5 , 3 ] ;
66850: LD_ADDR_VAR 0 9
66854: PUSH
66855: LD_INT 10
66857: PUSH
66858: LD_INT 5
66860: PUSH
66861: LD_INT 3
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: LIST
66868: ST_TO_ADDR
// if GetClass ( i ) = 14 then
66869: LD_VAR 0 6
66873: PPUSH
66874: CALL_OW 257
66878: PUSH
66879: LD_INT 14
66881: EQUAL
66882: IFFALSE 66903
// points := [ 10 , 0 , 0 ] ;
66884: LD_ADDR_VAR 0 9
66888: PUSH
66889: LD_INT 10
66891: PUSH
66892: LD_INT 0
66894: PUSH
66895: LD_INT 0
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: LIST
66902: ST_TO_ADDR
// if GetClass ( i ) = 11 then
66903: LD_VAR 0 6
66907: PPUSH
66908: CALL_OW 257
66912: PUSH
66913: LD_INT 11
66915: EQUAL
66916: IFFALSE 66937
// points := [ 30 , 10 , 5 ] ;
66918: LD_ADDR_VAR 0 9
66922: PUSH
66923: LD_INT 30
66925: PUSH
66926: LD_INT 10
66928: PUSH
66929: LD_INT 5
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: LIST
66936: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
66937: LD_VAR 0 1
66941: PPUSH
66942: LD_INT 5
66944: PPUSH
66945: CALL_OW 321
66949: PUSH
66950: LD_INT 2
66952: EQUAL
66953: IFFALSE 66970
// bpoints := bpoints * 1.8 ;
66955: LD_ADDR_VAR 0 10
66959: PUSH
66960: LD_VAR 0 10
66964: PUSH
66965: LD_REAL  1.80000000000000E+0000
66968: MUL
66969: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
66970: LD_VAR 0 6
66974: PPUSH
66975: CALL_OW 257
66979: PUSH
66980: LD_INT 1
66982: PUSH
66983: LD_INT 2
66985: PUSH
66986: LD_INT 3
66988: PUSH
66989: LD_INT 4
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: IN
66998: PUSH
66999: LD_VAR 0 1
67003: PPUSH
67004: LD_INT 51
67006: PPUSH
67007: CALL_OW 321
67011: PUSH
67012: LD_INT 2
67014: EQUAL
67015: AND
67016: IFFALSE 67033
// bpoints := bpoints * 1.2 ;
67018: LD_ADDR_VAR 0 10
67022: PUSH
67023: LD_VAR 0 10
67027: PUSH
67028: LD_REAL  1.20000000000000E+0000
67031: MUL
67032: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67033: LD_VAR 0 6
67037: PPUSH
67038: CALL_OW 257
67042: PUSH
67043: LD_INT 5
67045: PUSH
67046: LD_INT 7
67048: PUSH
67049: LD_INT 9
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: LIST
67056: IN
67057: PUSH
67058: LD_VAR 0 1
67062: PPUSH
67063: LD_INT 52
67065: PPUSH
67066: CALL_OW 321
67070: PUSH
67071: LD_INT 2
67073: EQUAL
67074: AND
67075: IFFALSE 67092
// bpoints := bpoints * 1.5 ;
67077: LD_ADDR_VAR 0 10
67081: PUSH
67082: LD_VAR 0 10
67086: PUSH
67087: LD_REAL  1.50000000000000E+0000
67090: MUL
67091: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67092: LD_VAR 0 1
67096: PPUSH
67097: LD_INT 66
67099: PPUSH
67100: CALL_OW 321
67104: PUSH
67105: LD_INT 2
67107: EQUAL
67108: IFFALSE 67125
// bpoints := bpoints * 1.1 ;
67110: LD_ADDR_VAR 0 10
67114: PUSH
67115: LD_VAR 0 10
67119: PUSH
67120: LD_REAL  1.10000000000000E+0000
67123: MUL
67124: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67125: LD_ADDR_VAR 0 10
67129: PUSH
67130: LD_VAR 0 10
67134: PUSH
67135: LD_VAR 0 6
67139: PPUSH
67140: LD_INT 1
67142: PPUSH
67143: CALL_OW 259
67147: PUSH
67148: LD_REAL  1.15000000000000E+0000
67151: MUL
67152: MUL
67153: ST_TO_ADDR
// end ; unit_vehicle :
67154: GO 67984
67156: LD_INT 2
67158: DOUBLE
67159: EQUAL
67160: IFTRUE 67164
67162: GO 67972
67164: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67165: LD_VAR 0 6
67169: PPUSH
67170: CALL_OW 264
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: LD_INT 42
67180: PUSH
67181: LD_INT 24
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: LIST
67188: IN
67189: IFFALSE 67210
// points := [ 25 , 5 , 3 ] ;
67191: LD_ADDR_VAR 0 9
67195: PUSH
67196: LD_INT 25
67198: PUSH
67199: LD_INT 5
67201: PUSH
67202: LD_INT 3
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: LIST
67209: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67210: LD_VAR 0 6
67214: PPUSH
67215: CALL_OW 264
67219: PUSH
67220: LD_INT 4
67222: PUSH
67223: LD_INT 43
67225: PUSH
67226: LD_INT 25
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: LIST
67233: IN
67234: IFFALSE 67255
// points := [ 40 , 15 , 5 ] ;
67236: LD_ADDR_VAR 0 9
67240: PUSH
67241: LD_INT 40
67243: PUSH
67244: LD_INT 15
67246: PUSH
67247: LD_INT 5
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: LIST
67254: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67255: LD_VAR 0 6
67259: PPUSH
67260: CALL_OW 264
67264: PUSH
67265: LD_INT 3
67267: PUSH
67268: LD_INT 23
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: IN
67275: IFFALSE 67296
// points := [ 7 , 25 , 8 ] ;
67277: LD_ADDR_VAR 0 9
67281: PUSH
67282: LD_INT 7
67284: PUSH
67285: LD_INT 25
67287: PUSH
67288: LD_INT 8
67290: PUSH
67291: EMPTY
67292: LIST
67293: LIST
67294: LIST
67295: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
67296: LD_VAR 0 6
67300: PPUSH
67301: CALL_OW 264
67305: PUSH
67306: LD_INT 5
67308: PUSH
67309: LD_INT 27
67311: PUSH
67312: LD_INT 44
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: LIST
67319: IN
67320: IFFALSE 67341
// points := [ 14 , 50 , 16 ] ;
67322: LD_ADDR_VAR 0 9
67326: PUSH
67327: LD_INT 14
67329: PUSH
67330: LD_INT 50
67332: PUSH
67333: LD_INT 16
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: LIST
67340: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
67341: LD_VAR 0 6
67345: PPUSH
67346: CALL_OW 264
67350: PUSH
67351: LD_INT 6
67353: PUSH
67354: LD_INT 46
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: IN
67361: IFFALSE 67382
// points := [ 32 , 120 , 70 ] ;
67363: LD_ADDR_VAR 0 9
67367: PUSH
67368: LD_INT 32
67370: PUSH
67371: LD_INT 120
67373: PUSH
67374: LD_INT 70
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: LIST
67381: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
67382: LD_VAR 0 6
67386: PPUSH
67387: CALL_OW 264
67391: PUSH
67392: LD_INT 7
67394: PUSH
67395: LD_INT 28
67397: PUSH
67398: LD_INT 45
67400: PUSH
67401: LD_EXP 78
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: LIST
67410: LIST
67411: IN
67412: IFFALSE 67433
// points := [ 35 , 20 , 45 ] ;
67414: LD_ADDR_VAR 0 9
67418: PUSH
67419: LD_INT 35
67421: PUSH
67422: LD_INT 20
67424: PUSH
67425: LD_INT 45
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: LIST
67432: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
67433: LD_VAR 0 6
67437: PPUSH
67438: CALL_OW 264
67442: PUSH
67443: LD_INT 47
67445: PUSH
67446: EMPTY
67447: LIST
67448: IN
67449: IFFALSE 67470
// points := [ 67 , 45 , 75 ] ;
67451: LD_ADDR_VAR 0 9
67455: PUSH
67456: LD_INT 67
67458: PUSH
67459: LD_INT 45
67461: PUSH
67462: LD_INT 75
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: LIST
67469: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
67470: LD_VAR 0 6
67474: PPUSH
67475: CALL_OW 264
67479: PUSH
67480: LD_INT 26
67482: PUSH
67483: EMPTY
67484: LIST
67485: IN
67486: IFFALSE 67507
// points := [ 120 , 30 , 80 ] ;
67488: LD_ADDR_VAR 0 9
67492: PUSH
67493: LD_INT 120
67495: PUSH
67496: LD_INT 30
67498: PUSH
67499: LD_INT 80
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: LIST
67506: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
67507: LD_VAR 0 6
67511: PPUSH
67512: CALL_OW 264
67516: PUSH
67517: LD_INT 22
67519: PUSH
67520: EMPTY
67521: LIST
67522: IN
67523: IFFALSE 67544
// points := [ 40 , 1 , 1 ] ;
67525: LD_ADDR_VAR 0 9
67529: PUSH
67530: LD_INT 40
67532: PUSH
67533: LD_INT 1
67535: PUSH
67536: LD_INT 1
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: LIST
67543: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
67544: LD_VAR 0 6
67548: PPUSH
67549: CALL_OW 264
67553: PUSH
67554: LD_INT 29
67556: PUSH
67557: EMPTY
67558: LIST
67559: IN
67560: IFFALSE 67581
// points := [ 70 , 200 , 400 ] ;
67562: LD_ADDR_VAR 0 9
67566: PUSH
67567: LD_INT 70
67569: PUSH
67570: LD_INT 200
67572: PUSH
67573: LD_INT 400
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: LIST
67580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
67581: LD_VAR 0 6
67585: PPUSH
67586: CALL_OW 264
67590: PUSH
67591: LD_INT 14
67593: PUSH
67594: LD_INT 53
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: IN
67601: IFFALSE 67622
// points := [ 40 , 10 , 20 ] ;
67603: LD_ADDR_VAR 0 9
67607: PUSH
67608: LD_INT 40
67610: PUSH
67611: LD_INT 10
67613: PUSH
67614: LD_INT 20
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: LIST
67621: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
67622: LD_VAR 0 6
67626: PPUSH
67627: CALL_OW 264
67631: PUSH
67632: LD_INT 9
67634: PUSH
67635: EMPTY
67636: LIST
67637: IN
67638: IFFALSE 67659
// points := [ 5 , 70 , 20 ] ;
67640: LD_ADDR_VAR 0 9
67644: PUSH
67645: LD_INT 5
67647: PUSH
67648: LD_INT 70
67650: PUSH
67651: LD_INT 20
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: LIST
67658: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
67659: LD_VAR 0 6
67663: PPUSH
67664: CALL_OW 264
67668: PUSH
67669: LD_INT 10
67671: PUSH
67672: EMPTY
67673: LIST
67674: IN
67675: IFFALSE 67696
// points := [ 35 , 110 , 70 ] ;
67677: LD_ADDR_VAR 0 9
67681: PUSH
67682: LD_INT 35
67684: PUSH
67685: LD_INT 110
67687: PUSH
67688: LD_INT 70
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: LIST
67695: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
67696: LD_VAR 0 6
67700: PPUSH
67701: CALL_OW 265
67705: PUSH
67706: LD_INT 25
67708: EQUAL
67709: IFFALSE 67730
// points := [ 80 , 65 , 100 ] ;
67711: LD_ADDR_VAR 0 9
67715: PUSH
67716: LD_INT 80
67718: PUSH
67719: LD_INT 65
67721: PUSH
67722: LD_INT 100
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: LIST
67729: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
67730: LD_VAR 0 6
67734: PPUSH
67735: CALL_OW 263
67739: PUSH
67740: LD_INT 1
67742: EQUAL
67743: IFFALSE 67778
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
67745: LD_ADDR_VAR 0 10
67749: PUSH
67750: LD_VAR 0 10
67754: PUSH
67755: LD_VAR 0 6
67759: PPUSH
67760: CALL_OW 311
67764: PPUSH
67765: LD_INT 3
67767: PPUSH
67768: CALL_OW 259
67772: PUSH
67773: LD_INT 4
67775: MUL
67776: MUL
67777: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
67778: LD_VAR 0 6
67782: PPUSH
67783: CALL_OW 263
67787: PUSH
67788: LD_INT 2
67790: EQUAL
67791: IFFALSE 67842
// begin j := IsControledBy ( i ) ;
67793: LD_ADDR_VAR 0 7
67797: PUSH
67798: LD_VAR 0 6
67802: PPUSH
67803: CALL_OW 312
67807: ST_TO_ADDR
// if j then
67808: LD_VAR 0 7
67812: IFFALSE 67842
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
67814: LD_ADDR_VAR 0 10
67818: PUSH
67819: LD_VAR 0 10
67823: PUSH
67824: LD_VAR 0 7
67828: PPUSH
67829: LD_INT 3
67831: PPUSH
67832: CALL_OW 259
67836: PUSH
67837: LD_INT 3
67839: MUL
67840: MUL
67841: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
67842: LD_VAR 0 6
67846: PPUSH
67847: CALL_OW 264
67851: PUSH
67852: LD_INT 5
67854: PUSH
67855: LD_INT 6
67857: PUSH
67858: LD_INT 46
67860: PUSH
67861: LD_INT 44
67863: PUSH
67864: LD_INT 47
67866: PUSH
67867: LD_INT 45
67869: PUSH
67870: LD_INT 28
67872: PUSH
67873: LD_INT 7
67875: PUSH
67876: LD_INT 27
67878: PUSH
67879: LD_INT 29
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: IN
67894: PUSH
67895: LD_VAR 0 1
67899: PPUSH
67900: LD_INT 52
67902: PPUSH
67903: CALL_OW 321
67907: PUSH
67908: LD_INT 2
67910: EQUAL
67911: AND
67912: IFFALSE 67929
// bpoints := bpoints * 1.2 ;
67914: LD_ADDR_VAR 0 10
67918: PUSH
67919: LD_VAR 0 10
67923: PUSH
67924: LD_REAL  1.20000000000000E+0000
67927: MUL
67928: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
67929: LD_VAR 0 6
67933: PPUSH
67934: CALL_OW 264
67938: PUSH
67939: LD_INT 6
67941: PUSH
67942: LD_INT 46
67944: PUSH
67945: LD_INT 47
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: LIST
67952: IN
67953: IFFALSE 67970
// bpoints := bpoints * 1.2 ;
67955: LD_ADDR_VAR 0 10
67959: PUSH
67960: LD_VAR 0 10
67964: PUSH
67965: LD_REAL  1.20000000000000E+0000
67968: MUL
67969: ST_TO_ADDR
// end ; unit_building :
67970: GO 67984
67972: LD_INT 3
67974: DOUBLE
67975: EQUAL
67976: IFTRUE 67980
67978: GO 67983
67980: POP
// ; end ;
67981: GO 67984
67983: POP
// for j = 1 to 3 do
67984: LD_ADDR_VAR 0 7
67988: PUSH
67989: DOUBLE
67990: LD_INT 1
67992: DEC
67993: ST_TO_ADDR
67994: LD_INT 3
67996: PUSH
67997: FOR_TO
67998: IFFALSE 68051
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
68000: LD_ADDR_VAR 0 5
68004: PUSH
68005: LD_VAR 0 5
68009: PPUSH
68010: LD_VAR 0 7
68014: PPUSH
68015: LD_VAR 0 5
68019: PUSH
68020: LD_VAR 0 7
68024: ARRAY
68025: PUSH
68026: LD_VAR 0 9
68030: PUSH
68031: LD_VAR 0 7
68035: ARRAY
68036: PUSH
68037: LD_VAR 0 10
68041: MUL
68042: PLUS
68043: PPUSH
68044: CALL_OW 1
68048: ST_TO_ADDR
68049: GO 67997
68051: POP
68052: POP
// end ;
68053: GO 66530
68055: POP
68056: POP
// result := Replace ( result , 4 , tmp ) ;
68057: LD_ADDR_VAR 0 5
68061: PUSH
68062: LD_VAR 0 5
68066: PPUSH
68067: LD_INT 4
68069: PPUSH
68070: LD_VAR 0 8
68074: PPUSH
68075: CALL_OW 1
68079: ST_TO_ADDR
// end ;
68080: LD_VAR 0 5
68084: RET
// export function DangerAtRange ( unit , range ) ; begin
68085: LD_INT 0
68087: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68088: LD_ADDR_VAR 0 3
68092: PUSH
68093: LD_VAR 0 1
68097: PPUSH
68098: CALL_OW 255
68102: PPUSH
68103: LD_VAR 0 1
68107: PPUSH
68108: CALL_OW 250
68112: PPUSH
68113: LD_VAR 0 1
68117: PPUSH
68118: CALL_OW 251
68122: PPUSH
68123: LD_VAR 0 2
68127: PPUSH
68128: CALL 66382 0 4
68132: ST_TO_ADDR
// end ;
68133: LD_VAR 0 3
68137: RET
// export function DangerInArea ( side , area ) ; begin
68138: LD_INT 0
68140: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68141: LD_ADDR_VAR 0 3
68145: PUSH
68146: LD_VAR 0 2
68150: PPUSH
68151: LD_INT 81
68153: PUSH
68154: LD_VAR 0 1
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PPUSH
68163: CALL_OW 70
68167: ST_TO_ADDR
// end ;
68168: LD_VAR 0 3
68172: RET
// export function IsExtension ( b ) ; begin
68173: LD_INT 0
68175: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68176: LD_ADDR_VAR 0 2
68180: PUSH
68181: LD_VAR 0 1
68185: PUSH
68186: LD_INT 23
68188: PUSH
68189: LD_INT 20
68191: PUSH
68192: LD_INT 22
68194: PUSH
68195: LD_INT 17
68197: PUSH
68198: LD_INT 24
68200: PUSH
68201: LD_INT 21
68203: PUSH
68204: LD_INT 19
68206: PUSH
68207: LD_INT 16
68209: PUSH
68210: LD_INT 25
68212: PUSH
68213: LD_INT 18
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: IN
68228: ST_TO_ADDR
// end ;
68229: LD_VAR 0 2
68233: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
68234: LD_INT 0
68236: PPUSH
68237: PPUSH
68238: PPUSH
// result := [ ] ;
68239: LD_ADDR_VAR 0 4
68243: PUSH
68244: EMPTY
68245: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68246: LD_ADDR_VAR 0 5
68250: PUSH
68251: LD_VAR 0 2
68255: PPUSH
68256: LD_INT 21
68258: PUSH
68259: LD_INT 3
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PPUSH
68266: CALL_OW 70
68270: ST_TO_ADDR
// if not tmp then
68271: LD_VAR 0 5
68275: NOT
68276: IFFALSE 68280
// exit ;
68278: GO 68344
// if checkLink then
68280: LD_VAR 0 3
68284: IFFALSE 68334
// begin for i in tmp do
68286: LD_ADDR_VAR 0 6
68290: PUSH
68291: LD_VAR 0 5
68295: PUSH
68296: FOR_IN
68297: IFFALSE 68332
// if GetBase ( i ) <> base then
68299: LD_VAR 0 6
68303: PPUSH
68304: CALL_OW 274
68308: PUSH
68309: LD_VAR 0 1
68313: NONEQUAL
68314: IFFALSE 68330
// ComLinkToBase ( base , i ) ;
68316: LD_VAR 0 1
68320: PPUSH
68321: LD_VAR 0 6
68325: PPUSH
68326: CALL_OW 169
68330: GO 68296
68332: POP
68333: POP
// end ; result := tmp ;
68334: LD_ADDR_VAR 0 4
68338: PUSH
68339: LD_VAR 0 5
68343: ST_TO_ADDR
// end ;
68344: LD_VAR 0 4
68348: RET
// export function ComComplete ( units , b ) ; var i ; begin
68349: LD_INT 0
68351: PPUSH
68352: PPUSH
// if not units then
68353: LD_VAR 0 1
68357: NOT
68358: IFFALSE 68362
// exit ;
68360: GO 68452
// for i in units do
68362: LD_ADDR_VAR 0 4
68366: PUSH
68367: LD_VAR 0 1
68371: PUSH
68372: FOR_IN
68373: IFFALSE 68450
// if BuildingStatus ( b ) = bs_build then
68375: LD_VAR 0 2
68379: PPUSH
68380: CALL_OW 461
68384: PUSH
68385: LD_INT 1
68387: EQUAL
68388: IFFALSE 68448
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
68390: LD_VAR 0 4
68394: PPUSH
68395: LD_STRING h
68397: PUSH
68398: LD_VAR 0 2
68402: PPUSH
68403: CALL_OW 250
68407: PUSH
68408: LD_VAR 0 2
68412: PPUSH
68413: CALL_OW 251
68417: PUSH
68418: LD_VAR 0 2
68422: PUSH
68423: LD_INT 0
68425: PUSH
68426: LD_INT 0
68428: PUSH
68429: LD_INT 0
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: PUSH
68441: EMPTY
68442: LIST
68443: PPUSH
68444: CALL_OW 446
68448: GO 68372
68450: POP
68451: POP
// end ;
68452: LD_VAR 0 3
68456: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
68457: LD_INT 0
68459: PPUSH
68460: PPUSH
68461: PPUSH
68462: PPUSH
68463: PPUSH
68464: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
68465: LD_VAR 0 1
68469: NOT
68470: PUSH
68471: LD_VAR 0 1
68475: PPUSH
68476: CALL_OW 263
68480: PUSH
68481: LD_INT 2
68483: EQUAL
68484: NOT
68485: OR
68486: IFFALSE 68490
// exit ;
68488: GO 68806
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
68490: LD_ADDR_VAR 0 6
68494: PUSH
68495: LD_INT 22
68497: PUSH
68498: LD_VAR 0 1
68502: PPUSH
68503: CALL_OW 255
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 2
68514: PUSH
68515: LD_INT 30
68517: PUSH
68518: LD_INT 36
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 34
68527: PUSH
68528: LD_INT 31
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: LIST
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PPUSH
68544: CALL_OW 69
68548: ST_TO_ADDR
// if not tmp then
68549: LD_VAR 0 6
68553: NOT
68554: IFFALSE 68558
// exit ;
68556: GO 68806
// result := [ ] ;
68558: LD_ADDR_VAR 0 2
68562: PUSH
68563: EMPTY
68564: ST_TO_ADDR
// for i in tmp do
68565: LD_ADDR_VAR 0 3
68569: PUSH
68570: LD_VAR 0 6
68574: PUSH
68575: FOR_IN
68576: IFFALSE 68647
// begin t := UnitsInside ( i ) ;
68578: LD_ADDR_VAR 0 4
68582: PUSH
68583: LD_VAR 0 3
68587: PPUSH
68588: CALL_OW 313
68592: ST_TO_ADDR
// if t then
68593: LD_VAR 0 4
68597: IFFALSE 68645
// for j in t do
68599: LD_ADDR_VAR 0 7
68603: PUSH
68604: LD_VAR 0 4
68608: PUSH
68609: FOR_IN
68610: IFFALSE 68643
// result := Insert ( result , result + 1 , j ) ;
68612: LD_ADDR_VAR 0 2
68616: PUSH
68617: LD_VAR 0 2
68621: PPUSH
68622: LD_VAR 0 2
68626: PUSH
68627: LD_INT 1
68629: PLUS
68630: PPUSH
68631: LD_VAR 0 7
68635: PPUSH
68636: CALL_OW 2
68640: ST_TO_ADDR
68641: GO 68609
68643: POP
68644: POP
// end ;
68645: GO 68575
68647: POP
68648: POP
// if not result then
68649: LD_VAR 0 2
68653: NOT
68654: IFFALSE 68658
// exit ;
68656: GO 68806
// mech := result [ 1 ] ;
68658: LD_ADDR_VAR 0 5
68662: PUSH
68663: LD_VAR 0 2
68667: PUSH
68668: LD_INT 1
68670: ARRAY
68671: ST_TO_ADDR
// if result > 1 then
68672: LD_VAR 0 2
68676: PUSH
68677: LD_INT 1
68679: GREATER
68680: IFFALSE 68792
// for i = 2 to result do
68682: LD_ADDR_VAR 0 3
68686: PUSH
68687: DOUBLE
68688: LD_INT 2
68690: DEC
68691: ST_TO_ADDR
68692: LD_VAR 0 2
68696: PUSH
68697: FOR_TO
68698: IFFALSE 68790
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
68700: LD_ADDR_VAR 0 4
68704: PUSH
68705: LD_VAR 0 2
68709: PUSH
68710: LD_VAR 0 3
68714: ARRAY
68715: PPUSH
68716: LD_INT 3
68718: PPUSH
68719: CALL_OW 259
68723: PUSH
68724: LD_VAR 0 2
68728: PUSH
68729: LD_VAR 0 3
68733: ARRAY
68734: PPUSH
68735: CALL_OW 432
68739: MINUS
68740: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
68741: LD_VAR 0 4
68745: PUSH
68746: LD_VAR 0 5
68750: PPUSH
68751: LD_INT 3
68753: PPUSH
68754: CALL_OW 259
68758: PUSH
68759: LD_VAR 0 5
68763: PPUSH
68764: CALL_OW 432
68768: MINUS
68769: GREATEREQUAL
68770: IFFALSE 68788
// mech := result [ i ] ;
68772: LD_ADDR_VAR 0 5
68776: PUSH
68777: LD_VAR 0 2
68781: PUSH
68782: LD_VAR 0 3
68786: ARRAY
68787: ST_TO_ADDR
// end ;
68788: GO 68697
68790: POP
68791: POP
// ComLinkTo ( vehicle , mech ) ;
68792: LD_VAR 0 1
68796: PPUSH
68797: LD_VAR 0 5
68801: PPUSH
68802: CALL_OW 135
// end ;
68806: LD_VAR 0 2
68810: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
68811: LD_INT 0
68813: PPUSH
68814: PPUSH
68815: PPUSH
68816: PPUSH
68817: PPUSH
68818: PPUSH
68819: PPUSH
68820: PPUSH
68821: PPUSH
68822: PPUSH
68823: PPUSH
68824: PPUSH
68825: PPUSH
// result := [ ] ;
68826: LD_ADDR_VAR 0 7
68830: PUSH
68831: EMPTY
68832: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
68833: LD_VAR 0 1
68837: PPUSH
68838: CALL_OW 266
68842: PUSH
68843: LD_INT 0
68845: PUSH
68846: LD_INT 1
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: IN
68853: NOT
68854: IFFALSE 68858
// exit ;
68856: GO 70492
// if name then
68858: LD_VAR 0 3
68862: IFFALSE 68878
// SetBName ( base_dep , name ) ;
68864: LD_VAR 0 1
68868: PPUSH
68869: LD_VAR 0 3
68873: PPUSH
68874: CALL_OW 500
// base := GetBase ( base_dep ) ;
68878: LD_ADDR_VAR 0 15
68882: PUSH
68883: LD_VAR 0 1
68887: PPUSH
68888: CALL_OW 274
68892: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
68893: LD_ADDR_VAR 0 16
68897: PUSH
68898: LD_VAR 0 1
68902: PPUSH
68903: CALL_OW 255
68907: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
68908: LD_ADDR_VAR 0 17
68912: PUSH
68913: LD_VAR 0 1
68917: PPUSH
68918: CALL_OW 248
68922: ST_TO_ADDR
// if sources then
68923: LD_VAR 0 5
68927: IFFALSE 68974
// for i = 1 to 3 do
68929: LD_ADDR_VAR 0 8
68933: PUSH
68934: DOUBLE
68935: LD_INT 1
68937: DEC
68938: ST_TO_ADDR
68939: LD_INT 3
68941: PUSH
68942: FOR_TO
68943: IFFALSE 68972
// AddResourceType ( base , i , sources [ i ] ) ;
68945: LD_VAR 0 15
68949: PPUSH
68950: LD_VAR 0 8
68954: PPUSH
68955: LD_VAR 0 5
68959: PUSH
68960: LD_VAR 0 8
68964: ARRAY
68965: PPUSH
68966: CALL_OW 276
68970: GO 68942
68972: POP
68973: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
68974: LD_ADDR_VAR 0 18
68978: PUSH
68979: LD_VAR 0 15
68983: PPUSH
68984: LD_VAR 0 2
68988: PPUSH
68989: LD_INT 1
68991: PPUSH
68992: CALL 68234 0 3
68996: ST_TO_ADDR
// InitHc ;
68997: CALL_OW 19
// InitUc ;
69001: CALL_OW 18
// uc_side := side ;
69005: LD_ADDR_OWVAR 20
69009: PUSH
69010: LD_VAR 0 16
69014: ST_TO_ADDR
// uc_nation := nation ;
69015: LD_ADDR_OWVAR 21
69019: PUSH
69020: LD_VAR 0 17
69024: ST_TO_ADDR
// if buildings then
69025: LD_VAR 0 18
69029: IFFALSE 70351
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
69031: LD_ADDR_VAR 0 19
69035: PUSH
69036: LD_VAR 0 18
69040: PPUSH
69041: LD_INT 2
69043: PUSH
69044: LD_INT 30
69046: PUSH
69047: LD_INT 29
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 30
69056: PUSH
69057: LD_INT 30
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: LIST
69068: PPUSH
69069: CALL_OW 72
69073: ST_TO_ADDR
// if tmp then
69074: LD_VAR 0 19
69078: IFFALSE 69126
// for i in tmp do
69080: LD_ADDR_VAR 0 8
69084: PUSH
69085: LD_VAR 0 19
69089: PUSH
69090: FOR_IN
69091: IFFALSE 69124
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69093: LD_VAR 0 8
69097: PPUSH
69098: CALL_OW 250
69102: PPUSH
69103: LD_VAR 0 8
69107: PPUSH
69108: CALL_OW 251
69112: PPUSH
69113: LD_VAR 0 16
69117: PPUSH
69118: CALL_OW 441
69122: GO 69090
69124: POP
69125: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69126: LD_VAR 0 18
69130: PPUSH
69131: LD_INT 2
69133: PUSH
69134: LD_INT 30
69136: PUSH
69137: LD_INT 32
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PUSH
69144: LD_INT 30
69146: PUSH
69147: LD_INT 33
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: LIST
69158: PPUSH
69159: CALL_OW 72
69163: IFFALSE 69251
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69165: LD_ADDR_VAR 0 8
69169: PUSH
69170: LD_VAR 0 18
69174: PPUSH
69175: LD_INT 2
69177: PUSH
69178: LD_INT 30
69180: PUSH
69181: LD_INT 32
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 30
69190: PUSH
69191: LD_INT 33
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: LIST
69202: PPUSH
69203: CALL_OW 72
69207: PUSH
69208: FOR_IN
69209: IFFALSE 69249
// begin if not GetBWeapon ( i ) then
69211: LD_VAR 0 8
69215: PPUSH
69216: CALL_OW 269
69220: NOT
69221: IFFALSE 69247
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69223: LD_VAR 0 8
69227: PPUSH
69228: LD_VAR 0 8
69232: PPUSH
69233: LD_VAR 0 2
69237: PPUSH
69238: CALL 70497 0 2
69242: PPUSH
69243: CALL_OW 431
// end ;
69247: GO 69208
69249: POP
69250: POP
// end ; for i = 1 to personel do
69251: LD_ADDR_VAR 0 8
69255: PUSH
69256: DOUBLE
69257: LD_INT 1
69259: DEC
69260: ST_TO_ADDR
69261: LD_VAR 0 6
69265: PUSH
69266: FOR_TO
69267: IFFALSE 70331
// begin if i > 4 then
69269: LD_VAR 0 8
69273: PUSH
69274: LD_INT 4
69276: GREATER
69277: IFFALSE 69281
// break ;
69279: GO 70331
// case i of 1 :
69281: LD_VAR 0 8
69285: PUSH
69286: LD_INT 1
69288: DOUBLE
69289: EQUAL
69290: IFTRUE 69294
69292: GO 69374
69294: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
69295: LD_ADDR_VAR 0 12
69299: PUSH
69300: LD_VAR 0 18
69304: PPUSH
69305: LD_INT 22
69307: PUSH
69308: LD_VAR 0 16
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 58
69319: PUSH
69320: EMPTY
69321: LIST
69322: PUSH
69323: LD_INT 2
69325: PUSH
69326: LD_INT 30
69328: PUSH
69329: LD_INT 32
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 30
69338: PUSH
69339: LD_INT 4
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 30
69348: PUSH
69349: LD_INT 5
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: LIST
69366: PPUSH
69367: CALL_OW 72
69371: ST_TO_ADDR
69372: GO 69596
69374: LD_INT 2
69376: DOUBLE
69377: EQUAL
69378: IFTRUE 69382
69380: GO 69444
69382: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
69383: LD_ADDR_VAR 0 12
69387: PUSH
69388: LD_VAR 0 18
69392: PPUSH
69393: LD_INT 22
69395: PUSH
69396: LD_VAR 0 16
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 2
69407: PUSH
69408: LD_INT 30
69410: PUSH
69411: LD_INT 0
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 30
69420: PUSH
69421: LD_INT 1
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: LIST
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PPUSH
69437: CALL_OW 72
69441: ST_TO_ADDR
69442: GO 69596
69444: LD_INT 3
69446: DOUBLE
69447: EQUAL
69448: IFTRUE 69452
69450: GO 69514
69452: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
69453: LD_ADDR_VAR 0 12
69457: PUSH
69458: LD_VAR 0 18
69462: PPUSH
69463: LD_INT 22
69465: PUSH
69466: LD_VAR 0 16
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 2
69477: PUSH
69478: LD_INT 30
69480: PUSH
69481: LD_INT 2
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 30
69490: PUSH
69491: LD_INT 3
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: LIST
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PPUSH
69507: CALL_OW 72
69511: ST_TO_ADDR
69512: GO 69596
69514: LD_INT 4
69516: DOUBLE
69517: EQUAL
69518: IFTRUE 69522
69520: GO 69595
69522: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
69523: LD_ADDR_VAR 0 12
69527: PUSH
69528: LD_VAR 0 18
69532: PPUSH
69533: LD_INT 22
69535: PUSH
69536: LD_VAR 0 16
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 2
69547: PUSH
69548: LD_INT 30
69550: PUSH
69551: LD_INT 6
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 30
69560: PUSH
69561: LD_INT 7
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: LD_INT 30
69570: PUSH
69571: LD_INT 8
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PPUSH
69588: CALL_OW 72
69592: ST_TO_ADDR
69593: GO 69596
69595: POP
// if i = 1 then
69596: LD_VAR 0 8
69600: PUSH
69601: LD_INT 1
69603: EQUAL
69604: IFFALSE 69715
// begin tmp := [ ] ;
69606: LD_ADDR_VAR 0 19
69610: PUSH
69611: EMPTY
69612: ST_TO_ADDR
// for j in f do
69613: LD_ADDR_VAR 0 9
69617: PUSH
69618: LD_VAR 0 12
69622: PUSH
69623: FOR_IN
69624: IFFALSE 69697
// if GetBType ( j ) = b_bunker then
69626: LD_VAR 0 9
69630: PPUSH
69631: CALL_OW 266
69635: PUSH
69636: LD_INT 32
69638: EQUAL
69639: IFFALSE 69666
// tmp := Insert ( tmp , 1 , j ) else
69641: LD_ADDR_VAR 0 19
69645: PUSH
69646: LD_VAR 0 19
69650: PPUSH
69651: LD_INT 1
69653: PPUSH
69654: LD_VAR 0 9
69658: PPUSH
69659: CALL_OW 2
69663: ST_TO_ADDR
69664: GO 69695
// tmp := Insert ( tmp , tmp + 1 , j ) ;
69666: LD_ADDR_VAR 0 19
69670: PUSH
69671: LD_VAR 0 19
69675: PPUSH
69676: LD_VAR 0 19
69680: PUSH
69681: LD_INT 1
69683: PLUS
69684: PPUSH
69685: LD_VAR 0 9
69689: PPUSH
69690: CALL_OW 2
69694: ST_TO_ADDR
69695: GO 69623
69697: POP
69698: POP
// if tmp then
69699: LD_VAR 0 19
69703: IFFALSE 69715
// f := tmp ;
69705: LD_ADDR_VAR 0 12
69709: PUSH
69710: LD_VAR 0 19
69714: ST_TO_ADDR
// end ; x := personel [ i ] ;
69715: LD_ADDR_VAR 0 13
69719: PUSH
69720: LD_VAR 0 6
69724: PUSH
69725: LD_VAR 0 8
69729: ARRAY
69730: ST_TO_ADDR
// if x = - 1 then
69731: LD_VAR 0 13
69735: PUSH
69736: LD_INT 1
69738: NEG
69739: EQUAL
69740: IFFALSE 69949
// begin for j in f do
69742: LD_ADDR_VAR 0 9
69746: PUSH
69747: LD_VAR 0 12
69751: PUSH
69752: FOR_IN
69753: IFFALSE 69945
// repeat InitHc ;
69755: CALL_OW 19
// if GetBType ( j ) = b_barracks then
69759: LD_VAR 0 9
69763: PPUSH
69764: CALL_OW 266
69768: PUSH
69769: LD_INT 5
69771: EQUAL
69772: IFFALSE 69842
// begin if UnitsInside ( j ) < 3 then
69774: LD_VAR 0 9
69778: PPUSH
69779: CALL_OW 313
69783: PUSH
69784: LD_INT 3
69786: LESS
69787: IFFALSE 69823
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
69789: LD_INT 0
69791: PPUSH
69792: LD_INT 5
69794: PUSH
69795: LD_INT 8
69797: PUSH
69798: LD_INT 9
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: LIST
69805: PUSH
69806: LD_VAR 0 17
69810: ARRAY
69811: PPUSH
69812: LD_VAR 0 4
69816: PPUSH
69817: CALL_OW 380
69821: GO 69840
// PrepareHuman ( false , i , skill ) ;
69823: LD_INT 0
69825: PPUSH
69826: LD_VAR 0 8
69830: PPUSH
69831: LD_VAR 0 4
69835: PPUSH
69836: CALL_OW 380
// end else
69840: GO 69859
// PrepareHuman ( false , i , skill ) ;
69842: LD_INT 0
69844: PPUSH
69845: LD_VAR 0 8
69849: PPUSH
69850: LD_VAR 0 4
69854: PPUSH
69855: CALL_OW 380
// un := CreateHuman ;
69859: LD_ADDR_VAR 0 14
69863: PUSH
69864: CALL_OW 44
69868: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69869: LD_ADDR_VAR 0 7
69873: PUSH
69874: LD_VAR 0 7
69878: PPUSH
69879: LD_INT 1
69881: PPUSH
69882: LD_VAR 0 14
69886: PPUSH
69887: CALL_OW 2
69891: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
69892: LD_VAR 0 14
69896: PPUSH
69897: LD_VAR 0 9
69901: PPUSH
69902: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
69906: LD_VAR 0 9
69910: PPUSH
69911: CALL_OW 313
69915: PUSH
69916: LD_INT 6
69918: EQUAL
69919: PUSH
69920: LD_VAR 0 9
69924: PPUSH
69925: CALL_OW 266
69929: PUSH
69930: LD_INT 32
69932: PUSH
69933: LD_INT 31
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: IN
69940: OR
69941: IFFALSE 69755
69943: GO 69752
69945: POP
69946: POP
// end else
69947: GO 70329
// for j = 1 to x do
69949: LD_ADDR_VAR 0 9
69953: PUSH
69954: DOUBLE
69955: LD_INT 1
69957: DEC
69958: ST_TO_ADDR
69959: LD_VAR 0 13
69963: PUSH
69964: FOR_TO
69965: IFFALSE 70327
// begin InitHc ;
69967: CALL_OW 19
// if not f then
69971: LD_VAR 0 12
69975: NOT
69976: IFFALSE 70065
// begin PrepareHuman ( false , i , skill ) ;
69978: LD_INT 0
69980: PPUSH
69981: LD_VAR 0 8
69985: PPUSH
69986: LD_VAR 0 4
69990: PPUSH
69991: CALL_OW 380
// un := CreateHuman ;
69995: LD_ADDR_VAR 0 14
69999: PUSH
70000: CALL_OW 44
70004: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70005: LD_ADDR_VAR 0 7
70009: PUSH
70010: LD_VAR 0 7
70014: PPUSH
70015: LD_INT 1
70017: PPUSH
70018: LD_VAR 0 14
70022: PPUSH
70023: CALL_OW 2
70027: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70028: LD_VAR 0 14
70032: PPUSH
70033: LD_VAR 0 1
70037: PPUSH
70038: CALL_OW 250
70042: PPUSH
70043: LD_VAR 0 1
70047: PPUSH
70048: CALL_OW 251
70052: PPUSH
70053: LD_INT 10
70055: PPUSH
70056: LD_INT 0
70058: PPUSH
70059: CALL_OW 50
// continue ;
70063: GO 69964
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70065: LD_VAR 0 12
70069: PUSH
70070: LD_INT 1
70072: ARRAY
70073: PPUSH
70074: CALL_OW 313
70078: PUSH
70079: LD_VAR 0 12
70083: PUSH
70084: LD_INT 1
70086: ARRAY
70087: PPUSH
70088: CALL_OW 266
70092: PUSH
70093: LD_INT 32
70095: PUSH
70096: LD_INT 31
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: IN
70103: AND
70104: PUSH
70105: LD_VAR 0 12
70109: PUSH
70110: LD_INT 1
70112: ARRAY
70113: PPUSH
70114: CALL_OW 313
70118: PUSH
70119: LD_INT 6
70121: EQUAL
70122: OR
70123: IFFALSE 70143
// f := Delete ( f , 1 ) ;
70125: LD_ADDR_VAR 0 12
70129: PUSH
70130: LD_VAR 0 12
70134: PPUSH
70135: LD_INT 1
70137: PPUSH
70138: CALL_OW 3
70142: ST_TO_ADDR
// if not f then
70143: LD_VAR 0 12
70147: NOT
70148: IFFALSE 70166
// begin x := x + 2 ;
70150: LD_ADDR_VAR 0 13
70154: PUSH
70155: LD_VAR 0 13
70159: PUSH
70160: LD_INT 2
70162: PLUS
70163: ST_TO_ADDR
// continue ;
70164: GO 69964
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70166: LD_VAR 0 12
70170: PUSH
70171: LD_INT 1
70173: ARRAY
70174: PPUSH
70175: CALL_OW 266
70179: PUSH
70180: LD_INT 5
70182: EQUAL
70183: IFFALSE 70257
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70185: LD_VAR 0 12
70189: PUSH
70190: LD_INT 1
70192: ARRAY
70193: PPUSH
70194: CALL_OW 313
70198: PUSH
70199: LD_INT 3
70201: LESS
70202: IFFALSE 70238
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70204: LD_INT 0
70206: PPUSH
70207: LD_INT 5
70209: PUSH
70210: LD_INT 8
70212: PUSH
70213: LD_INT 9
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: LIST
70220: PUSH
70221: LD_VAR 0 17
70225: ARRAY
70226: PPUSH
70227: LD_VAR 0 4
70231: PPUSH
70232: CALL_OW 380
70236: GO 70255
// PrepareHuman ( false , i , skill ) ;
70238: LD_INT 0
70240: PPUSH
70241: LD_VAR 0 8
70245: PPUSH
70246: LD_VAR 0 4
70250: PPUSH
70251: CALL_OW 380
// end else
70255: GO 70274
// PrepareHuman ( false , i , skill ) ;
70257: LD_INT 0
70259: PPUSH
70260: LD_VAR 0 8
70264: PPUSH
70265: LD_VAR 0 4
70269: PPUSH
70270: CALL_OW 380
// un := CreateHuman ;
70274: LD_ADDR_VAR 0 14
70278: PUSH
70279: CALL_OW 44
70283: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70284: LD_ADDR_VAR 0 7
70288: PUSH
70289: LD_VAR 0 7
70293: PPUSH
70294: LD_INT 1
70296: PPUSH
70297: LD_VAR 0 14
70301: PPUSH
70302: CALL_OW 2
70306: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
70307: LD_VAR 0 14
70311: PPUSH
70312: LD_VAR 0 12
70316: PUSH
70317: LD_INT 1
70319: ARRAY
70320: PPUSH
70321: CALL_OW 52
// end ;
70325: GO 69964
70327: POP
70328: POP
// end ;
70329: GO 69266
70331: POP
70332: POP
// result := result ^ buildings ;
70333: LD_ADDR_VAR 0 7
70337: PUSH
70338: LD_VAR 0 7
70342: PUSH
70343: LD_VAR 0 18
70347: ADD
70348: ST_TO_ADDR
// end else
70349: GO 70492
// begin for i = 1 to personel do
70351: LD_ADDR_VAR 0 8
70355: PUSH
70356: DOUBLE
70357: LD_INT 1
70359: DEC
70360: ST_TO_ADDR
70361: LD_VAR 0 6
70365: PUSH
70366: FOR_TO
70367: IFFALSE 70490
// begin if i > 4 then
70369: LD_VAR 0 8
70373: PUSH
70374: LD_INT 4
70376: GREATER
70377: IFFALSE 70381
// break ;
70379: GO 70490
// x := personel [ i ] ;
70381: LD_ADDR_VAR 0 13
70385: PUSH
70386: LD_VAR 0 6
70390: PUSH
70391: LD_VAR 0 8
70395: ARRAY
70396: ST_TO_ADDR
// if x = - 1 then
70397: LD_VAR 0 13
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: EQUAL
70406: IFFALSE 70410
// continue ;
70408: GO 70366
// PrepareHuman ( false , i , skill ) ;
70410: LD_INT 0
70412: PPUSH
70413: LD_VAR 0 8
70417: PPUSH
70418: LD_VAR 0 4
70422: PPUSH
70423: CALL_OW 380
// un := CreateHuman ;
70427: LD_ADDR_VAR 0 14
70431: PUSH
70432: CALL_OW 44
70436: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70437: LD_VAR 0 14
70441: PPUSH
70442: LD_VAR 0 1
70446: PPUSH
70447: CALL_OW 250
70451: PPUSH
70452: LD_VAR 0 1
70456: PPUSH
70457: CALL_OW 251
70461: PPUSH
70462: LD_INT 10
70464: PPUSH
70465: LD_INT 0
70467: PPUSH
70468: CALL_OW 50
// result := result ^ un ;
70472: LD_ADDR_VAR 0 7
70476: PUSH
70477: LD_VAR 0 7
70481: PUSH
70482: LD_VAR 0 14
70486: ADD
70487: ST_TO_ADDR
// end ;
70488: GO 70366
70490: POP
70491: POP
// end ; end ;
70492: LD_VAR 0 7
70496: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
70497: LD_INT 0
70499: PPUSH
70500: PPUSH
70501: PPUSH
70502: PPUSH
70503: PPUSH
70504: PPUSH
70505: PPUSH
70506: PPUSH
70507: PPUSH
70508: PPUSH
70509: PPUSH
70510: PPUSH
70511: PPUSH
70512: PPUSH
70513: PPUSH
70514: PPUSH
// result := false ;
70515: LD_ADDR_VAR 0 3
70519: PUSH
70520: LD_INT 0
70522: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
70523: LD_VAR 0 1
70527: NOT
70528: PUSH
70529: LD_VAR 0 1
70533: PPUSH
70534: CALL_OW 266
70538: PUSH
70539: LD_INT 32
70541: PUSH
70542: LD_INT 33
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: IN
70549: NOT
70550: OR
70551: IFFALSE 70555
// exit ;
70553: GO 71664
// nat := GetNation ( tower ) ;
70555: LD_ADDR_VAR 0 12
70559: PUSH
70560: LD_VAR 0 1
70564: PPUSH
70565: CALL_OW 248
70569: ST_TO_ADDR
// side := GetSide ( tower ) ;
70570: LD_ADDR_VAR 0 16
70574: PUSH
70575: LD_VAR 0 1
70579: PPUSH
70580: CALL_OW 255
70584: ST_TO_ADDR
// x := GetX ( tower ) ;
70585: LD_ADDR_VAR 0 10
70589: PUSH
70590: LD_VAR 0 1
70594: PPUSH
70595: CALL_OW 250
70599: ST_TO_ADDR
// y := GetY ( tower ) ;
70600: LD_ADDR_VAR 0 11
70604: PUSH
70605: LD_VAR 0 1
70609: PPUSH
70610: CALL_OW 251
70614: ST_TO_ADDR
// if not x or not y then
70615: LD_VAR 0 10
70619: NOT
70620: PUSH
70621: LD_VAR 0 11
70625: NOT
70626: OR
70627: IFFALSE 70631
// exit ;
70629: GO 71664
// weapon := 0 ;
70631: LD_ADDR_VAR 0 18
70635: PUSH
70636: LD_INT 0
70638: ST_TO_ADDR
// fac_list := [ ] ;
70639: LD_ADDR_VAR 0 17
70643: PUSH
70644: EMPTY
70645: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
70646: LD_ADDR_VAR 0 6
70650: PUSH
70651: LD_VAR 0 1
70655: PPUSH
70656: CALL_OW 274
70660: PPUSH
70661: LD_VAR 0 2
70665: PPUSH
70666: LD_INT 0
70668: PPUSH
70669: CALL 68234 0 3
70673: PPUSH
70674: LD_INT 30
70676: PUSH
70677: LD_INT 3
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PPUSH
70684: CALL_OW 72
70688: ST_TO_ADDR
// if not factories then
70689: LD_VAR 0 6
70693: NOT
70694: IFFALSE 70698
// exit ;
70696: GO 71664
// for i in factories do
70698: LD_ADDR_VAR 0 8
70702: PUSH
70703: LD_VAR 0 6
70707: PUSH
70708: FOR_IN
70709: IFFALSE 70734
// fac_list := fac_list union AvailableWeaponList ( i ) ;
70711: LD_ADDR_VAR 0 17
70715: PUSH
70716: LD_VAR 0 17
70720: PUSH
70721: LD_VAR 0 8
70725: PPUSH
70726: CALL_OW 478
70730: UNION
70731: ST_TO_ADDR
70732: GO 70708
70734: POP
70735: POP
// if not fac_list then
70736: LD_VAR 0 17
70740: NOT
70741: IFFALSE 70745
// exit ;
70743: GO 71664
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
70745: LD_ADDR_VAR 0 5
70749: PUSH
70750: LD_INT 4
70752: PUSH
70753: LD_INT 5
70755: PUSH
70756: LD_INT 9
70758: PUSH
70759: LD_INT 10
70761: PUSH
70762: LD_INT 6
70764: PUSH
70765: LD_INT 7
70767: PUSH
70768: LD_INT 11
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 27
70782: PUSH
70783: LD_INT 28
70785: PUSH
70786: LD_INT 26
70788: PUSH
70789: LD_INT 30
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: PUSH
70798: LD_INT 43
70800: PUSH
70801: LD_INT 44
70803: PUSH
70804: LD_INT 46
70806: PUSH
70807: LD_INT 45
70809: PUSH
70810: LD_INT 47
70812: PUSH
70813: LD_INT 49
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: LIST
70828: PUSH
70829: LD_VAR 0 12
70833: ARRAY
70834: ST_TO_ADDR
// list := list isect fac_list ;
70835: LD_ADDR_VAR 0 5
70839: PUSH
70840: LD_VAR 0 5
70844: PUSH
70845: LD_VAR 0 17
70849: ISECT
70850: ST_TO_ADDR
// if not list then
70851: LD_VAR 0 5
70855: NOT
70856: IFFALSE 70860
// exit ;
70858: GO 71664
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
70860: LD_VAR 0 12
70864: PUSH
70865: LD_INT 3
70867: EQUAL
70868: PUSH
70869: LD_INT 49
70871: PUSH
70872: LD_VAR 0 5
70876: IN
70877: AND
70878: PUSH
70879: LD_INT 31
70881: PPUSH
70882: LD_VAR 0 16
70886: PPUSH
70887: CALL_OW 321
70891: PUSH
70892: LD_INT 2
70894: EQUAL
70895: AND
70896: IFFALSE 70956
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
70898: LD_INT 22
70900: PUSH
70901: LD_VAR 0 16
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: LD_INT 35
70912: PUSH
70913: LD_INT 49
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 91
70922: PUSH
70923: LD_VAR 0 1
70927: PUSH
70928: LD_INT 10
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: LIST
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: LIST
70940: PPUSH
70941: CALL_OW 69
70945: NOT
70946: IFFALSE 70956
// weapon := ru_time_lapser ;
70948: LD_ADDR_VAR 0 18
70952: PUSH
70953: LD_INT 49
70955: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
70956: LD_VAR 0 12
70960: PUSH
70961: LD_INT 1
70963: PUSH
70964: LD_INT 2
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: IN
70971: PUSH
70972: LD_INT 11
70974: PUSH
70975: LD_VAR 0 5
70979: IN
70980: PUSH
70981: LD_INT 30
70983: PUSH
70984: LD_VAR 0 5
70988: IN
70989: OR
70990: AND
70991: PUSH
70992: LD_INT 6
70994: PPUSH
70995: LD_VAR 0 16
70999: PPUSH
71000: CALL_OW 321
71004: PUSH
71005: LD_INT 2
71007: EQUAL
71008: AND
71009: IFFALSE 71174
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71011: LD_INT 22
71013: PUSH
71014: LD_VAR 0 16
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 2
71025: PUSH
71026: LD_INT 35
71028: PUSH
71029: LD_INT 11
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 35
71038: PUSH
71039: LD_INT 30
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 91
71053: PUSH
71054: LD_VAR 0 1
71058: PUSH
71059: LD_INT 18
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: LIST
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: LIST
71071: PPUSH
71072: CALL_OW 69
71076: NOT
71077: PUSH
71078: LD_INT 22
71080: PUSH
71081: LD_VAR 0 16
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 2
71092: PUSH
71093: LD_INT 30
71095: PUSH
71096: LD_INT 32
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 30
71105: PUSH
71106: LD_INT 33
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 91
71120: PUSH
71121: LD_VAR 0 1
71125: PUSH
71126: LD_INT 12
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: LIST
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: LIST
71138: PUSH
71139: EMPTY
71140: LIST
71141: PPUSH
71142: CALL_OW 69
71146: PUSH
71147: LD_INT 2
71149: GREATER
71150: AND
71151: IFFALSE 71174
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71153: LD_ADDR_VAR 0 18
71157: PUSH
71158: LD_INT 11
71160: PUSH
71161: LD_INT 30
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_VAR 0 12
71172: ARRAY
71173: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71174: LD_VAR 0 18
71178: NOT
71179: PUSH
71180: LD_INT 40
71182: PPUSH
71183: LD_VAR 0 16
71187: PPUSH
71188: CALL_OW 321
71192: PUSH
71193: LD_INT 2
71195: EQUAL
71196: AND
71197: PUSH
71198: LD_INT 7
71200: PUSH
71201: LD_VAR 0 5
71205: IN
71206: PUSH
71207: LD_INT 28
71209: PUSH
71210: LD_VAR 0 5
71214: IN
71215: OR
71216: PUSH
71217: LD_INT 45
71219: PUSH
71220: LD_VAR 0 5
71224: IN
71225: OR
71226: AND
71227: IFFALSE 71481
// begin hex := GetHexInfo ( x , y ) ;
71229: LD_ADDR_VAR 0 4
71233: PUSH
71234: LD_VAR 0 10
71238: PPUSH
71239: LD_VAR 0 11
71243: PPUSH
71244: CALL_OW 546
71248: ST_TO_ADDR
// if hex [ 1 ] then
71249: LD_VAR 0 4
71253: PUSH
71254: LD_INT 1
71256: ARRAY
71257: IFFALSE 71261
// exit ;
71259: GO 71664
// height := hex [ 2 ] ;
71261: LD_ADDR_VAR 0 15
71265: PUSH
71266: LD_VAR 0 4
71270: PUSH
71271: LD_INT 2
71273: ARRAY
71274: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71275: LD_ADDR_VAR 0 14
71279: PUSH
71280: LD_INT 0
71282: PUSH
71283: LD_INT 2
71285: PUSH
71286: LD_INT 3
71288: PUSH
71289: LD_INT 5
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: ST_TO_ADDR
// for i in tmp do
71298: LD_ADDR_VAR 0 8
71302: PUSH
71303: LD_VAR 0 14
71307: PUSH
71308: FOR_IN
71309: IFFALSE 71479
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
71311: LD_ADDR_VAR 0 9
71315: PUSH
71316: LD_VAR 0 10
71320: PPUSH
71321: LD_VAR 0 8
71325: PPUSH
71326: LD_INT 5
71328: PPUSH
71329: CALL_OW 272
71333: PUSH
71334: LD_VAR 0 11
71338: PPUSH
71339: LD_VAR 0 8
71343: PPUSH
71344: LD_INT 5
71346: PPUSH
71347: CALL_OW 273
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
71356: LD_VAR 0 9
71360: PUSH
71361: LD_INT 1
71363: ARRAY
71364: PPUSH
71365: LD_VAR 0 9
71369: PUSH
71370: LD_INT 2
71372: ARRAY
71373: PPUSH
71374: CALL_OW 488
71378: IFFALSE 71477
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
71380: LD_ADDR_VAR 0 4
71384: PUSH
71385: LD_VAR 0 9
71389: PUSH
71390: LD_INT 1
71392: ARRAY
71393: PPUSH
71394: LD_VAR 0 9
71398: PUSH
71399: LD_INT 2
71401: ARRAY
71402: PPUSH
71403: CALL_OW 546
71407: ST_TO_ADDR
// if hex [ 1 ] then
71408: LD_VAR 0 4
71412: PUSH
71413: LD_INT 1
71415: ARRAY
71416: IFFALSE 71420
// continue ;
71418: GO 71308
// h := hex [ 2 ] ;
71420: LD_ADDR_VAR 0 13
71424: PUSH
71425: LD_VAR 0 4
71429: PUSH
71430: LD_INT 2
71432: ARRAY
71433: ST_TO_ADDR
// if h + 7 < height then
71434: LD_VAR 0 13
71438: PUSH
71439: LD_INT 7
71441: PLUS
71442: PUSH
71443: LD_VAR 0 15
71447: LESS
71448: IFFALSE 71477
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
71450: LD_ADDR_VAR 0 18
71454: PUSH
71455: LD_INT 7
71457: PUSH
71458: LD_INT 28
71460: PUSH
71461: LD_INT 45
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: LIST
71468: PUSH
71469: LD_VAR 0 12
71473: ARRAY
71474: ST_TO_ADDR
// break ;
71475: GO 71479
// end ; end ; end ;
71477: GO 71308
71479: POP
71480: POP
// end ; if not weapon then
71481: LD_VAR 0 18
71485: NOT
71486: IFFALSE 71546
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
71488: LD_ADDR_VAR 0 5
71492: PUSH
71493: LD_VAR 0 5
71497: PUSH
71498: LD_INT 11
71500: PUSH
71501: LD_INT 30
71503: PUSH
71504: LD_INT 49
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: LIST
71511: DIFF
71512: ST_TO_ADDR
// if not list then
71513: LD_VAR 0 5
71517: NOT
71518: IFFALSE 71522
// exit ;
71520: GO 71664
// weapon := list [ rand ( 1 , list ) ] ;
71522: LD_ADDR_VAR 0 18
71526: PUSH
71527: LD_VAR 0 5
71531: PUSH
71532: LD_INT 1
71534: PPUSH
71535: LD_VAR 0 5
71539: PPUSH
71540: CALL_OW 12
71544: ARRAY
71545: ST_TO_ADDR
// end ; if weapon then
71546: LD_VAR 0 18
71550: IFFALSE 71664
// begin tmp := CostOfWeapon ( weapon ) ;
71552: LD_ADDR_VAR 0 14
71556: PUSH
71557: LD_VAR 0 18
71561: PPUSH
71562: CALL_OW 451
71566: ST_TO_ADDR
// j := GetBase ( tower ) ;
71567: LD_ADDR_VAR 0 9
71571: PUSH
71572: LD_VAR 0 1
71576: PPUSH
71577: CALL_OW 274
71581: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
71582: LD_VAR 0 9
71586: PPUSH
71587: LD_INT 1
71589: PPUSH
71590: CALL_OW 275
71594: PUSH
71595: LD_VAR 0 14
71599: PUSH
71600: LD_INT 1
71602: ARRAY
71603: GREATEREQUAL
71604: PUSH
71605: LD_VAR 0 9
71609: PPUSH
71610: LD_INT 2
71612: PPUSH
71613: CALL_OW 275
71617: PUSH
71618: LD_VAR 0 14
71622: PUSH
71623: LD_INT 2
71625: ARRAY
71626: GREATEREQUAL
71627: AND
71628: PUSH
71629: LD_VAR 0 9
71633: PPUSH
71634: LD_INT 3
71636: PPUSH
71637: CALL_OW 275
71641: PUSH
71642: LD_VAR 0 14
71646: PUSH
71647: LD_INT 3
71649: ARRAY
71650: GREATEREQUAL
71651: AND
71652: IFFALSE 71664
// result := weapon ;
71654: LD_ADDR_VAR 0 3
71658: PUSH
71659: LD_VAR 0 18
71663: ST_TO_ADDR
// end ; end ;
71664: LD_VAR 0 3
71668: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
71669: LD_INT 0
71671: PPUSH
71672: PPUSH
// result := true ;
71673: LD_ADDR_VAR 0 3
71677: PUSH
71678: LD_INT 1
71680: ST_TO_ADDR
// if array1 = array2 then
71681: LD_VAR 0 1
71685: PUSH
71686: LD_VAR 0 2
71690: EQUAL
71691: IFFALSE 71751
// begin for i = 1 to array1 do
71693: LD_ADDR_VAR 0 4
71697: PUSH
71698: DOUBLE
71699: LD_INT 1
71701: DEC
71702: ST_TO_ADDR
71703: LD_VAR 0 1
71707: PUSH
71708: FOR_TO
71709: IFFALSE 71747
// if array1 [ i ] <> array2 [ i ] then
71711: LD_VAR 0 1
71715: PUSH
71716: LD_VAR 0 4
71720: ARRAY
71721: PUSH
71722: LD_VAR 0 2
71726: PUSH
71727: LD_VAR 0 4
71731: ARRAY
71732: NONEQUAL
71733: IFFALSE 71745
// begin result := false ;
71735: LD_ADDR_VAR 0 3
71739: PUSH
71740: LD_INT 0
71742: ST_TO_ADDR
// break ;
71743: GO 71747
// end ;
71745: GO 71708
71747: POP
71748: POP
// end else
71749: GO 71759
// result := false ;
71751: LD_ADDR_VAR 0 3
71755: PUSH
71756: LD_INT 0
71758: ST_TO_ADDR
// end ;
71759: LD_VAR 0 3
71763: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
71764: LD_INT 0
71766: PPUSH
71767: PPUSH
// if not array1 or not array2 then
71768: LD_VAR 0 1
71772: NOT
71773: PUSH
71774: LD_VAR 0 2
71778: NOT
71779: OR
71780: IFFALSE 71784
// exit ;
71782: GO 71848
// result := true ;
71784: LD_ADDR_VAR 0 3
71788: PUSH
71789: LD_INT 1
71791: ST_TO_ADDR
// for i = 1 to array1 do
71792: LD_ADDR_VAR 0 4
71796: PUSH
71797: DOUBLE
71798: LD_INT 1
71800: DEC
71801: ST_TO_ADDR
71802: LD_VAR 0 1
71806: PUSH
71807: FOR_TO
71808: IFFALSE 71846
// if array1 [ i ] <> array2 [ i ] then
71810: LD_VAR 0 1
71814: PUSH
71815: LD_VAR 0 4
71819: ARRAY
71820: PUSH
71821: LD_VAR 0 2
71825: PUSH
71826: LD_VAR 0 4
71830: ARRAY
71831: NONEQUAL
71832: IFFALSE 71844
// begin result := false ;
71834: LD_ADDR_VAR 0 3
71838: PUSH
71839: LD_INT 0
71841: ST_TO_ADDR
// break ;
71842: GO 71846
// end ;
71844: GO 71807
71846: POP
71847: POP
// end ;
71848: LD_VAR 0 3
71852: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
71853: LD_INT 0
71855: PPUSH
71856: PPUSH
71857: PPUSH
// pom := GetBase ( fac ) ;
71858: LD_ADDR_VAR 0 5
71862: PUSH
71863: LD_VAR 0 1
71867: PPUSH
71868: CALL_OW 274
71872: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
71873: LD_ADDR_VAR 0 4
71877: PUSH
71878: LD_VAR 0 2
71882: PUSH
71883: LD_INT 1
71885: ARRAY
71886: PPUSH
71887: LD_VAR 0 2
71891: PUSH
71892: LD_INT 2
71894: ARRAY
71895: PPUSH
71896: LD_VAR 0 2
71900: PUSH
71901: LD_INT 3
71903: ARRAY
71904: PPUSH
71905: LD_VAR 0 2
71909: PUSH
71910: LD_INT 4
71912: ARRAY
71913: PPUSH
71914: CALL_OW 449
71918: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
71919: LD_ADDR_VAR 0 3
71923: PUSH
71924: LD_VAR 0 5
71928: PPUSH
71929: LD_INT 1
71931: PPUSH
71932: CALL_OW 275
71936: PUSH
71937: LD_VAR 0 4
71941: PUSH
71942: LD_INT 1
71944: ARRAY
71945: GREATEREQUAL
71946: PUSH
71947: LD_VAR 0 5
71951: PPUSH
71952: LD_INT 2
71954: PPUSH
71955: CALL_OW 275
71959: PUSH
71960: LD_VAR 0 4
71964: PUSH
71965: LD_INT 2
71967: ARRAY
71968: GREATEREQUAL
71969: AND
71970: PUSH
71971: LD_VAR 0 5
71975: PPUSH
71976: LD_INT 3
71978: PPUSH
71979: CALL_OW 275
71983: PUSH
71984: LD_VAR 0 4
71988: PUSH
71989: LD_INT 3
71991: ARRAY
71992: GREATEREQUAL
71993: AND
71994: ST_TO_ADDR
// end ;
71995: LD_VAR 0 3
71999: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
72000: LD_INT 0
72002: PPUSH
72003: PPUSH
72004: PPUSH
72005: PPUSH
// pom := GetBase ( building ) ;
72006: LD_ADDR_VAR 0 3
72010: PUSH
72011: LD_VAR 0 1
72015: PPUSH
72016: CALL_OW 274
72020: ST_TO_ADDR
// if not pom then
72021: LD_VAR 0 3
72025: NOT
72026: IFFALSE 72030
// exit ;
72028: GO 72200
// btype := GetBType ( building ) ;
72030: LD_ADDR_VAR 0 5
72034: PUSH
72035: LD_VAR 0 1
72039: PPUSH
72040: CALL_OW 266
72044: ST_TO_ADDR
// if btype = b_armoury then
72045: LD_VAR 0 5
72049: PUSH
72050: LD_INT 4
72052: EQUAL
72053: IFFALSE 72063
// btype := b_barracks ;
72055: LD_ADDR_VAR 0 5
72059: PUSH
72060: LD_INT 5
72062: ST_TO_ADDR
// if btype = b_depot then
72063: LD_VAR 0 5
72067: PUSH
72068: LD_INT 0
72070: EQUAL
72071: IFFALSE 72081
// btype := b_warehouse ;
72073: LD_ADDR_VAR 0 5
72077: PUSH
72078: LD_INT 1
72080: ST_TO_ADDR
// if btype = b_workshop then
72081: LD_VAR 0 5
72085: PUSH
72086: LD_INT 2
72088: EQUAL
72089: IFFALSE 72099
// btype := b_factory ;
72091: LD_ADDR_VAR 0 5
72095: PUSH
72096: LD_INT 3
72098: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72099: LD_ADDR_VAR 0 4
72103: PUSH
72104: LD_VAR 0 5
72108: PPUSH
72109: LD_VAR 0 1
72113: PPUSH
72114: CALL_OW 248
72118: PPUSH
72119: CALL_OW 450
72123: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72124: LD_ADDR_VAR 0 2
72128: PUSH
72129: LD_VAR 0 3
72133: PPUSH
72134: LD_INT 1
72136: PPUSH
72137: CALL_OW 275
72141: PUSH
72142: LD_VAR 0 4
72146: PUSH
72147: LD_INT 1
72149: ARRAY
72150: GREATEREQUAL
72151: PUSH
72152: LD_VAR 0 3
72156: PPUSH
72157: LD_INT 2
72159: PPUSH
72160: CALL_OW 275
72164: PUSH
72165: LD_VAR 0 4
72169: PUSH
72170: LD_INT 2
72172: ARRAY
72173: GREATEREQUAL
72174: AND
72175: PUSH
72176: LD_VAR 0 3
72180: PPUSH
72181: LD_INT 3
72183: PPUSH
72184: CALL_OW 275
72188: PUSH
72189: LD_VAR 0 4
72193: PUSH
72194: LD_INT 3
72196: ARRAY
72197: GREATEREQUAL
72198: AND
72199: ST_TO_ADDR
// end ;
72200: LD_VAR 0 2
72204: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72205: LD_INT 0
72207: PPUSH
72208: PPUSH
72209: PPUSH
// pom := GetBase ( building ) ;
72210: LD_ADDR_VAR 0 4
72214: PUSH
72215: LD_VAR 0 1
72219: PPUSH
72220: CALL_OW 274
72224: ST_TO_ADDR
// if not pom then
72225: LD_VAR 0 4
72229: NOT
72230: IFFALSE 72234
// exit ;
72232: GO 72335
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72234: LD_ADDR_VAR 0 5
72238: PUSH
72239: LD_VAR 0 2
72243: PPUSH
72244: LD_VAR 0 1
72248: PPUSH
72249: CALL_OW 248
72253: PPUSH
72254: CALL_OW 450
72258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72259: LD_ADDR_VAR 0 3
72263: PUSH
72264: LD_VAR 0 4
72268: PPUSH
72269: LD_INT 1
72271: PPUSH
72272: CALL_OW 275
72276: PUSH
72277: LD_VAR 0 5
72281: PUSH
72282: LD_INT 1
72284: ARRAY
72285: GREATEREQUAL
72286: PUSH
72287: LD_VAR 0 4
72291: PPUSH
72292: LD_INT 2
72294: PPUSH
72295: CALL_OW 275
72299: PUSH
72300: LD_VAR 0 5
72304: PUSH
72305: LD_INT 2
72307: ARRAY
72308: GREATEREQUAL
72309: AND
72310: PUSH
72311: LD_VAR 0 4
72315: PPUSH
72316: LD_INT 3
72318: PPUSH
72319: CALL_OW 275
72323: PUSH
72324: LD_VAR 0 5
72328: PUSH
72329: LD_INT 3
72331: ARRAY
72332: GREATEREQUAL
72333: AND
72334: ST_TO_ADDR
// end ;
72335: LD_VAR 0 3
72339: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
72340: LD_INT 0
72342: PPUSH
72343: PPUSH
72344: PPUSH
72345: PPUSH
72346: PPUSH
72347: PPUSH
72348: PPUSH
72349: PPUSH
72350: PPUSH
72351: PPUSH
72352: PPUSH
// result := false ;
72353: LD_ADDR_VAR 0 8
72357: PUSH
72358: LD_INT 0
72360: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
72361: LD_VAR 0 5
72365: NOT
72366: PUSH
72367: LD_VAR 0 1
72371: NOT
72372: OR
72373: PUSH
72374: LD_VAR 0 2
72378: NOT
72379: OR
72380: PUSH
72381: LD_VAR 0 3
72385: NOT
72386: OR
72387: IFFALSE 72391
// exit ;
72389: GO 73205
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
72391: LD_ADDR_VAR 0 14
72395: PUSH
72396: LD_VAR 0 1
72400: PPUSH
72401: LD_VAR 0 2
72405: PPUSH
72406: LD_VAR 0 3
72410: PPUSH
72411: LD_VAR 0 4
72415: PPUSH
72416: LD_VAR 0 5
72420: PUSH
72421: LD_INT 1
72423: ARRAY
72424: PPUSH
72425: CALL_OW 248
72429: PPUSH
72430: LD_INT 0
72432: PPUSH
72433: CALL 74442 0 6
72437: ST_TO_ADDR
// if not hexes then
72438: LD_VAR 0 14
72442: NOT
72443: IFFALSE 72447
// exit ;
72445: GO 73205
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72447: LD_ADDR_VAR 0 17
72451: PUSH
72452: LD_VAR 0 5
72456: PPUSH
72457: LD_INT 22
72459: PUSH
72460: LD_VAR 0 13
72464: PPUSH
72465: CALL_OW 255
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: PUSH
72474: LD_INT 2
72476: PUSH
72477: LD_INT 30
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 30
72489: PUSH
72490: LD_INT 1
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: LIST
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: PPUSH
72506: CALL_OW 72
72510: ST_TO_ADDR
// for i = 1 to hexes do
72511: LD_ADDR_VAR 0 9
72515: PUSH
72516: DOUBLE
72517: LD_INT 1
72519: DEC
72520: ST_TO_ADDR
72521: LD_VAR 0 14
72525: PUSH
72526: FOR_TO
72527: IFFALSE 73203
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
72529: LD_ADDR_VAR 0 13
72533: PUSH
72534: LD_VAR 0 14
72538: PUSH
72539: LD_VAR 0 9
72543: ARRAY
72544: PUSH
72545: LD_INT 1
72547: ARRAY
72548: PPUSH
72549: LD_VAR 0 14
72553: PUSH
72554: LD_VAR 0 9
72558: ARRAY
72559: PUSH
72560: LD_INT 2
72562: ARRAY
72563: PPUSH
72564: CALL_OW 428
72568: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
72569: LD_VAR 0 14
72573: PUSH
72574: LD_VAR 0 9
72578: ARRAY
72579: PUSH
72580: LD_INT 1
72582: ARRAY
72583: PPUSH
72584: LD_VAR 0 14
72588: PUSH
72589: LD_VAR 0 9
72593: ARRAY
72594: PUSH
72595: LD_INT 2
72597: ARRAY
72598: PPUSH
72599: CALL_OW 351
72603: PUSH
72604: LD_VAR 0 14
72608: PUSH
72609: LD_VAR 0 9
72613: ARRAY
72614: PUSH
72615: LD_INT 1
72617: ARRAY
72618: PPUSH
72619: LD_VAR 0 14
72623: PUSH
72624: LD_VAR 0 9
72628: ARRAY
72629: PUSH
72630: LD_INT 2
72632: ARRAY
72633: PPUSH
72634: CALL_OW 488
72638: NOT
72639: OR
72640: PUSH
72641: LD_VAR 0 13
72645: PPUSH
72646: CALL_OW 247
72650: PUSH
72651: LD_INT 3
72653: EQUAL
72654: OR
72655: IFFALSE 72661
// exit ;
72657: POP
72658: POP
72659: GO 73205
// if not tmp then
72661: LD_VAR 0 13
72665: NOT
72666: IFFALSE 72670
// continue ;
72668: GO 72526
// result := true ;
72670: LD_ADDR_VAR 0 8
72674: PUSH
72675: LD_INT 1
72677: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
72678: LD_VAR 0 6
72682: PUSH
72683: LD_VAR 0 13
72687: PPUSH
72688: CALL_OW 247
72692: PUSH
72693: LD_INT 2
72695: EQUAL
72696: AND
72697: PUSH
72698: LD_VAR 0 13
72702: PPUSH
72703: CALL_OW 263
72707: PUSH
72708: LD_INT 1
72710: EQUAL
72711: AND
72712: IFFALSE 72876
// begin if IsDrivenBy ( tmp ) then
72714: LD_VAR 0 13
72718: PPUSH
72719: CALL_OW 311
72723: IFFALSE 72727
// continue ;
72725: GO 72526
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
72727: LD_VAR 0 6
72731: PPUSH
72732: LD_INT 3
72734: PUSH
72735: LD_INT 60
72737: PUSH
72738: EMPTY
72739: LIST
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 3
72747: PUSH
72748: LD_INT 55
72750: PUSH
72751: EMPTY
72752: LIST
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PPUSH
72762: CALL_OW 72
72766: IFFALSE 72874
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
72768: LD_ADDR_VAR 0 18
72772: PUSH
72773: LD_VAR 0 6
72777: PPUSH
72778: LD_INT 3
72780: PUSH
72781: LD_INT 60
72783: PUSH
72784: EMPTY
72785: LIST
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 3
72793: PUSH
72794: LD_INT 55
72796: PUSH
72797: EMPTY
72798: LIST
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PPUSH
72808: CALL_OW 72
72812: PUSH
72813: LD_INT 1
72815: ARRAY
72816: ST_TO_ADDR
// if IsInUnit ( driver ) then
72817: LD_VAR 0 18
72821: PPUSH
72822: CALL_OW 310
72826: IFFALSE 72837
// ComExit ( driver ) ;
72828: LD_VAR 0 18
72832: PPUSH
72833: CALL 97626 0 1
// AddComEnterUnit ( driver , tmp ) ;
72837: LD_VAR 0 18
72841: PPUSH
72842: LD_VAR 0 13
72846: PPUSH
72847: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
72851: LD_VAR 0 18
72855: PPUSH
72856: LD_VAR 0 7
72860: PPUSH
72861: CALL_OW 173
// AddComExitVehicle ( driver ) ;
72865: LD_VAR 0 18
72869: PPUSH
72870: CALL_OW 181
// end ; continue ;
72874: GO 72526
// end ; if not cleaners or not tmp in cleaners then
72876: LD_VAR 0 6
72880: NOT
72881: PUSH
72882: LD_VAR 0 13
72886: PUSH
72887: LD_VAR 0 6
72891: IN
72892: NOT
72893: OR
72894: IFFALSE 73201
// begin if dep then
72896: LD_VAR 0 17
72900: IFFALSE 73036
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
72902: LD_ADDR_VAR 0 16
72906: PUSH
72907: LD_VAR 0 17
72911: PUSH
72912: LD_INT 1
72914: ARRAY
72915: PPUSH
72916: CALL_OW 250
72920: PPUSH
72921: LD_VAR 0 17
72925: PUSH
72926: LD_INT 1
72928: ARRAY
72929: PPUSH
72930: CALL_OW 254
72934: PPUSH
72935: LD_INT 5
72937: PPUSH
72938: CALL_OW 272
72942: PUSH
72943: LD_VAR 0 17
72947: PUSH
72948: LD_INT 1
72950: ARRAY
72951: PPUSH
72952: CALL_OW 251
72956: PPUSH
72957: LD_VAR 0 17
72961: PUSH
72962: LD_INT 1
72964: ARRAY
72965: PPUSH
72966: CALL_OW 254
72970: PPUSH
72971: LD_INT 5
72973: PPUSH
72974: CALL_OW 273
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
72983: LD_VAR 0 16
72987: PUSH
72988: LD_INT 1
72990: ARRAY
72991: PPUSH
72992: LD_VAR 0 16
72996: PUSH
72997: LD_INT 2
72999: ARRAY
73000: PPUSH
73001: CALL_OW 488
73005: IFFALSE 73036
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73007: LD_VAR 0 13
73011: PPUSH
73012: LD_VAR 0 16
73016: PUSH
73017: LD_INT 1
73019: ARRAY
73020: PPUSH
73021: LD_VAR 0 16
73025: PUSH
73026: LD_INT 2
73028: ARRAY
73029: PPUSH
73030: CALL_OW 111
// continue ;
73034: GO 72526
// end ; end ; r := GetDir ( tmp ) ;
73036: LD_ADDR_VAR 0 15
73040: PUSH
73041: LD_VAR 0 13
73045: PPUSH
73046: CALL_OW 254
73050: ST_TO_ADDR
// if r = 5 then
73051: LD_VAR 0 15
73055: PUSH
73056: LD_INT 5
73058: EQUAL
73059: IFFALSE 73069
// r := 0 ;
73061: LD_ADDR_VAR 0 15
73065: PUSH
73066: LD_INT 0
73068: ST_TO_ADDR
// for j = r to 5 do
73069: LD_ADDR_VAR 0 10
73073: PUSH
73074: DOUBLE
73075: LD_VAR 0 15
73079: DEC
73080: ST_TO_ADDR
73081: LD_INT 5
73083: PUSH
73084: FOR_TO
73085: IFFALSE 73199
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73087: LD_ADDR_VAR 0 11
73091: PUSH
73092: LD_VAR 0 13
73096: PPUSH
73097: CALL_OW 250
73101: PPUSH
73102: LD_VAR 0 10
73106: PPUSH
73107: LD_INT 2
73109: PPUSH
73110: CALL_OW 272
73114: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73115: LD_ADDR_VAR 0 12
73119: PUSH
73120: LD_VAR 0 13
73124: PPUSH
73125: CALL_OW 251
73129: PPUSH
73130: LD_VAR 0 10
73134: PPUSH
73135: LD_INT 2
73137: PPUSH
73138: CALL_OW 273
73142: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73143: LD_VAR 0 11
73147: PPUSH
73148: LD_VAR 0 12
73152: PPUSH
73153: CALL_OW 488
73157: PUSH
73158: LD_VAR 0 11
73162: PPUSH
73163: LD_VAR 0 12
73167: PPUSH
73168: CALL_OW 428
73172: NOT
73173: AND
73174: IFFALSE 73197
// begin ComMoveXY ( tmp , _x , _y ) ;
73176: LD_VAR 0 13
73180: PPUSH
73181: LD_VAR 0 11
73185: PPUSH
73186: LD_VAR 0 12
73190: PPUSH
73191: CALL_OW 111
// break ;
73195: GO 73199
// end ; end ;
73197: GO 73084
73199: POP
73200: POP
// end ; end ;
73201: GO 72526
73203: POP
73204: POP
// end ;
73205: LD_VAR 0 8
73209: RET
// export function BuildingTechInvented ( side , btype ) ; begin
73210: LD_INT 0
73212: PPUSH
// result := true ;
73213: LD_ADDR_VAR 0 3
73217: PUSH
73218: LD_INT 1
73220: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
73221: LD_VAR 0 2
73225: PUSH
73226: LD_INT 24
73228: DOUBLE
73229: EQUAL
73230: IFTRUE 73240
73232: LD_INT 33
73234: DOUBLE
73235: EQUAL
73236: IFTRUE 73240
73238: GO 73265
73240: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
73241: LD_ADDR_VAR 0 3
73245: PUSH
73246: LD_INT 32
73248: PPUSH
73249: LD_VAR 0 1
73253: PPUSH
73254: CALL_OW 321
73258: PUSH
73259: LD_INT 2
73261: EQUAL
73262: ST_TO_ADDR
73263: GO 73585
73265: LD_INT 20
73267: DOUBLE
73268: EQUAL
73269: IFTRUE 73273
73271: GO 73298
73273: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
73274: LD_ADDR_VAR 0 3
73278: PUSH
73279: LD_INT 6
73281: PPUSH
73282: LD_VAR 0 1
73286: PPUSH
73287: CALL_OW 321
73291: PUSH
73292: LD_INT 2
73294: EQUAL
73295: ST_TO_ADDR
73296: GO 73585
73298: LD_INT 22
73300: DOUBLE
73301: EQUAL
73302: IFTRUE 73312
73304: LD_INT 36
73306: DOUBLE
73307: EQUAL
73308: IFTRUE 73312
73310: GO 73337
73312: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
73313: LD_ADDR_VAR 0 3
73317: PUSH
73318: LD_INT 15
73320: PPUSH
73321: LD_VAR 0 1
73325: PPUSH
73326: CALL_OW 321
73330: PUSH
73331: LD_INT 2
73333: EQUAL
73334: ST_TO_ADDR
73335: GO 73585
73337: LD_INT 30
73339: DOUBLE
73340: EQUAL
73341: IFTRUE 73345
73343: GO 73370
73345: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
73346: LD_ADDR_VAR 0 3
73350: PUSH
73351: LD_INT 20
73353: PPUSH
73354: LD_VAR 0 1
73358: PPUSH
73359: CALL_OW 321
73363: PUSH
73364: LD_INT 2
73366: EQUAL
73367: ST_TO_ADDR
73368: GO 73585
73370: LD_INT 28
73372: DOUBLE
73373: EQUAL
73374: IFTRUE 73384
73376: LD_INT 21
73378: DOUBLE
73379: EQUAL
73380: IFTRUE 73384
73382: GO 73409
73384: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
73385: LD_ADDR_VAR 0 3
73389: PUSH
73390: LD_INT 21
73392: PPUSH
73393: LD_VAR 0 1
73397: PPUSH
73398: CALL_OW 321
73402: PUSH
73403: LD_INT 2
73405: EQUAL
73406: ST_TO_ADDR
73407: GO 73585
73409: LD_INT 16
73411: DOUBLE
73412: EQUAL
73413: IFTRUE 73417
73415: GO 73444
73417: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
73418: LD_ADDR_VAR 0 3
73422: PUSH
73423: LD_EXP 85
73427: PPUSH
73428: LD_VAR 0 1
73432: PPUSH
73433: CALL_OW 321
73437: PUSH
73438: LD_INT 2
73440: EQUAL
73441: ST_TO_ADDR
73442: GO 73585
73444: LD_INT 19
73446: DOUBLE
73447: EQUAL
73448: IFTRUE 73458
73450: LD_INT 23
73452: DOUBLE
73453: EQUAL
73454: IFTRUE 73458
73456: GO 73485
73458: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
73459: LD_ADDR_VAR 0 3
73463: PUSH
73464: LD_EXP 84
73468: PPUSH
73469: LD_VAR 0 1
73473: PPUSH
73474: CALL_OW 321
73478: PUSH
73479: LD_INT 2
73481: EQUAL
73482: ST_TO_ADDR
73483: GO 73585
73485: LD_INT 17
73487: DOUBLE
73488: EQUAL
73489: IFTRUE 73493
73491: GO 73518
73493: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
73494: LD_ADDR_VAR 0 3
73498: PUSH
73499: LD_INT 39
73501: PPUSH
73502: LD_VAR 0 1
73506: PPUSH
73507: CALL_OW 321
73511: PUSH
73512: LD_INT 2
73514: EQUAL
73515: ST_TO_ADDR
73516: GO 73585
73518: LD_INT 18
73520: DOUBLE
73521: EQUAL
73522: IFTRUE 73526
73524: GO 73551
73526: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
73527: LD_ADDR_VAR 0 3
73531: PUSH
73532: LD_INT 40
73534: PPUSH
73535: LD_VAR 0 1
73539: PPUSH
73540: CALL_OW 321
73544: PUSH
73545: LD_INT 2
73547: EQUAL
73548: ST_TO_ADDR
73549: GO 73585
73551: LD_INT 27
73553: DOUBLE
73554: EQUAL
73555: IFTRUE 73559
73557: GO 73584
73559: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
73560: LD_ADDR_VAR 0 3
73564: PUSH
73565: LD_INT 35
73567: PPUSH
73568: LD_VAR 0 1
73572: PPUSH
73573: CALL_OW 321
73577: PUSH
73578: LD_INT 2
73580: EQUAL
73581: ST_TO_ADDR
73582: GO 73585
73584: POP
// end ;
73585: LD_VAR 0 3
73589: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
73590: LD_INT 0
73592: PPUSH
73593: PPUSH
73594: PPUSH
73595: PPUSH
73596: PPUSH
73597: PPUSH
73598: PPUSH
73599: PPUSH
73600: PPUSH
73601: PPUSH
73602: PPUSH
// result := false ;
73603: LD_ADDR_VAR 0 6
73607: PUSH
73608: LD_INT 0
73610: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
73611: LD_VAR 0 1
73615: NOT
73616: PUSH
73617: LD_VAR 0 1
73621: PPUSH
73622: CALL_OW 266
73626: PUSH
73627: LD_INT 0
73629: PUSH
73630: LD_INT 1
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: IN
73637: NOT
73638: OR
73639: PUSH
73640: LD_VAR 0 2
73644: NOT
73645: OR
73646: PUSH
73647: LD_VAR 0 5
73651: PUSH
73652: LD_INT 0
73654: PUSH
73655: LD_INT 1
73657: PUSH
73658: LD_INT 2
73660: PUSH
73661: LD_INT 3
73663: PUSH
73664: LD_INT 4
73666: PUSH
73667: LD_INT 5
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: LIST
73674: LIST
73675: LIST
73676: LIST
73677: IN
73678: NOT
73679: OR
73680: PUSH
73681: LD_VAR 0 3
73685: PPUSH
73686: LD_VAR 0 4
73690: PPUSH
73691: CALL_OW 488
73695: NOT
73696: OR
73697: IFFALSE 73701
// exit ;
73699: GO 74437
// side := GetSide ( depot ) ;
73701: LD_ADDR_VAR 0 9
73705: PUSH
73706: LD_VAR 0 1
73710: PPUSH
73711: CALL_OW 255
73715: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
73716: LD_VAR 0 9
73720: PPUSH
73721: LD_VAR 0 2
73725: PPUSH
73726: CALL 73210 0 2
73730: NOT
73731: IFFALSE 73735
// exit ;
73733: GO 74437
// pom := GetBase ( depot ) ;
73735: LD_ADDR_VAR 0 10
73739: PUSH
73740: LD_VAR 0 1
73744: PPUSH
73745: CALL_OW 274
73749: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
73750: LD_ADDR_VAR 0 11
73754: PUSH
73755: LD_VAR 0 2
73759: PPUSH
73760: LD_VAR 0 1
73764: PPUSH
73765: CALL_OW 248
73769: PPUSH
73770: CALL_OW 450
73774: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
73775: LD_VAR 0 10
73779: PPUSH
73780: LD_INT 1
73782: PPUSH
73783: CALL_OW 275
73787: PUSH
73788: LD_VAR 0 11
73792: PUSH
73793: LD_INT 1
73795: ARRAY
73796: GREATEREQUAL
73797: PUSH
73798: LD_VAR 0 10
73802: PPUSH
73803: LD_INT 2
73805: PPUSH
73806: CALL_OW 275
73810: PUSH
73811: LD_VAR 0 11
73815: PUSH
73816: LD_INT 2
73818: ARRAY
73819: GREATEREQUAL
73820: AND
73821: PUSH
73822: LD_VAR 0 10
73826: PPUSH
73827: LD_INT 3
73829: PPUSH
73830: CALL_OW 275
73834: PUSH
73835: LD_VAR 0 11
73839: PUSH
73840: LD_INT 3
73842: ARRAY
73843: GREATEREQUAL
73844: AND
73845: NOT
73846: IFFALSE 73850
// exit ;
73848: GO 74437
// if GetBType ( depot ) = b_depot then
73850: LD_VAR 0 1
73854: PPUSH
73855: CALL_OW 266
73859: PUSH
73860: LD_INT 0
73862: EQUAL
73863: IFFALSE 73875
// dist := 28 else
73865: LD_ADDR_VAR 0 14
73869: PUSH
73870: LD_INT 28
73872: ST_TO_ADDR
73873: GO 73883
// dist := 36 ;
73875: LD_ADDR_VAR 0 14
73879: PUSH
73880: LD_INT 36
73882: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
73883: LD_VAR 0 1
73887: PPUSH
73888: LD_VAR 0 3
73892: PPUSH
73893: LD_VAR 0 4
73897: PPUSH
73898: CALL_OW 297
73902: PUSH
73903: LD_VAR 0 14
73907: GREATER
73908: IFFALSE 73912
// exit ;
73910: GO 74437
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
73912: LD_ADDR_VAR 0 12
73916: PUSH
73917: LD_VAR 0 2
73921: PPUSH
73922: LD_VAR 0 3
73926: PPUSH
73927: LD_VAR 0 4
73931: PPUSH
73932: LD_VAR 0 5
73936: PPUSH
73937: LD_VAR 0 1
73941: PPUSH
73942: CALL_OW 248
73946: PPUSH
73947: LD_INT 0
73949: PPUSH
73950: CALL 74442 0 6
73954: ST_TO_ADDR
// if not hexes then
73955: LD_VAR 0 12
73959: NOT
73960: IFFALSE 73964
// exit ;
73962: GO 74437
// hex := GetHexInfo ( x , y ) ;
73964: LD_ADDR_VAR 0 15
73968: PUSH
73969: LD_VAR 0 3
73973: PPUSH
73974: LD_VAR 0 4
73978: PPUSH
73979: CALL_OW 546
73983: ST_TO_ADDR
// if hex [ 1 ] then
73984: LD_VAR 0 15
73988: PUSH
73989: LD_INT 1
73991: ARRAY
73992: IFFALSE 73996
// exit ;
73994: GO 74437
// height := hex [ 2 ] ;
73996: LD_ADDR_VAR 0 13
74000: PUSH
74001: LD_VAR 0 15
74005: PUSH
74006: LD_INT 2
74008: ARRAY
74009: ST_TO_ADDR
// for i = 1 to hexes do
74010: LD_ADDR_VAR 0 7
74014: PUSH
74015: DOUBLE
74016: LD_INT 1
74018: DEC
74019: ST_TO_ADDR
74020: LD_VAR 0 12
74024: PUSH
74025: FOR_TO
74026: IFFALSE 74356
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
74028: LD_VAR 0 12
74032: PUSH
74033: LD_VAR 0 7
74037: ARRAY
74038: PUSH
74039: LD_INT 1
74041: ARRAY
74042: PPUSH
74043: LD_VAR 0 12
74047: PUSH
74048: LD_VAR 0 7
74052: ARRAY
74053: PUSH
74054: LD_INT 2
74056: ARRAY
74057: PPUSH
74058: CALL_OW 488
74062: NOT
74063: PUSH
74064: LD_VAR 0 12
74068: PUSH
74069: LD_VAR 0 7
74073: ARRAY
74074: PUSH
74075: LD_INT 1
74077: ARRAY
74078: PPUSH
74079: LD_VAR 0 12
74083: PUSH
74084: LD_VAR 0 7
74088: ARRAY
74089: PUSH
74090: LD_INT 2
74092: ARRAY
74093: PPUSH
74094: CALL_OW 428
74098: PUSH
74099: LD_INT 0
74101: GREATER
74102: OR
74103: PUSH
74104: LD_VAR 0 12
74108: PUSH
74109: LD_VAR 0 7
74113: ARRAY
74114: PUSH
74115: LD_INT 1
74117: ARRAY
74118: PPUSH
74119: LD_VAR 0 12
74123: PUSH
74124: LD_VAR 0 7
74128: ARRAY
74129: PUSH
74130: LD_INT 2
74132: ARRAY
74133: PPUSH
74134: CALL_OW 351
74138: OR
74139: IFFALSE 74145
// exit ;
74141: POP
74142: POP
74143: GO 74437
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74145: LD_ADDR_VAR 0 8
74149: PUSH
74150: LD_VAR 0 12
74154: PUSH
74155: LD_VAR 0 7
74159: ARRAY
74160: PUSH
74161: LD_INT 1
74163: ARRAY
74164: PPUSH
74165: LD_VAR 0 12
74169: PUSH
74170: LD_VAR 0 7
74174: ARRAY
74175: PUSH
74176: LD_INT 2
74178: ARRAY
74179: PPUSH
74180: CALL_OW 546
74184: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
74185: LD_VAR 0 8
74189: PUSH
74190: LD_INT 1
74192: ARRAY
74193: PUSH
74194: LD_VAR 0 8
74198: PUSH
74199: LD_INT 2
74201: ARRAY
74202: PUSH
74203: LD_VAR 0 13
74207: PUSH
74208: LD_INT 2
74210: PLUS
74211: GREATER
74212: OR
74213: PUSH
74214: LD_VAR 0 8
74218: PUSH
74219: LD_INT 2
74221: ARRAY
74222: PUSH
74223: LD_VAR 0 13
74227: PUSH
74228: LD_INT 2
74230: MINUS
74231: LESS
74232: OR
74233: PUSH
74234: LD_VAR 0 8
74238: PUSH
74239: LD_INT 3
74241: ARRAY
74242: PUSH
74243: LD_INT 0
74245: PUSH
74246: LD_INT 8
74248: PUSH
74249: LD_INT 9
74251: PUSH
74252: LD_INT 10
74254: PUSH
74255: LD_INT 11
74257: PUSH
74258: LD_INT 12
74260: PUSH
74261: LD_INT 13
74263: PUSH
74264: LD_INT 16
74266: PUSH
74267: LD_INT 17
74269: PUSH
74270: LD_INT 18
74272: PUSH
74273: LD_INT 19
74275: PUSH
74276: LD_INT 20
74278: PUSH
74279: LD_INT 21
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: LIST
74295: LIST
74296: IN
74297: NOT
74298: OR
74299: PUSH
74300: LD_VAR 0 8
74304: PUSH
74305: LD_INT 5
74307: ARRAY
74308: NOT
74309: OR
74310: PUSH
74311: LD_VAR 0 8
74315: PUSH
74316: LD_INT 6
74318: ARRAY
74319: PUSH
74320: LD_INT 1
74322: PUSH
74323: LD_INT 2
74325: PUSH
74326: LD_INT 7
74328: PUSH
74329: LD_INT 9
74331: PUSH
74332: LD_INT 10
74334: PUSH
74335: LD_INT 11
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: IN
74346: NOT
74347: OR
74348: IFFALSE 74354
// exit ;
74350: POP
74351: POP
74352: GO 74437
// end ;
74354: GO 74025
74356: POP
74357: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74358: LD_VAR 0 9
74362: PPUSH
74363: LD_VAR 0 3
74367: PPUSH
74368: LD_VAR 0 4
74372: PPUSH
74373: LD_INT 20
74375: PPUSH
74376: CALL 66382 0 4
74380: PUSH
74381: LD_INT 4
74383: ARRAY
74384: IFFALSE 74388
// exit ;
74386: GO 74437
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
74388: LD_VAR 0 2
74392: PUSH
74393: LD_INT 29
74395: PUSH
74396: LD_INT 30
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: IN
74403: PUSH
74404: LD_VAR 0 3
74408: PPUSH
74409: LD_VAR 0 4
74413: PPUSH
74414: LD_VAR 0 9
74418: PPUSH
74419: CALL_OW 440
74423: NOT
74424: AND
74425: IFFALSE 74429
// exit ;
74427: GO 74437
// result := true ;
74429: LD_ADDR_VAR 0 6
74433: PUSH
74434: LD_INT 1
74436: ST_TO_ADDR
// end ;
74437: LD_VAR 0 6
74441: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
74442: LD_INT 0
74444: PPUSH
74445: PPUSH
74446: PPUSH
74447: PPUSH
74448: PPUSH
74449: PPUSH
74450: PPUSH
74451: PPUSH
74452: PPUSH
74453: PPUSH
74454: PPUSH
74455: PPUSH
74456: PPUSH
74457: PPUSH
74458: PPUSH
74459: PPUSH
74460: PPUSH
74461: PPUSH
74462: PPUSH
74463: PPUSH
74464: PPUSH
74465: PPUSH
74466: PPUSH
74467: PPUSH
74468: PPUSH
74469: PPUSH
74470: PPUSH
74471: PPUSH
74472: PPUSH
74473: PPUSH
74474: PPUSH
74475: PPUSH
74476: PPUSH
74477: PPUSH
74478: PPUSH
74479: PPUSH
74480: PPUSH
74481: PPUSH
74482: PPUSH
74483: PPUSH
74484: PPUSH
74485: PPUSH
74486: PPUSH
74487: PPUSH
74488: PPUSH
74489: PPUSH
74490: PPUSH
74491: PPUSH
74492: PPUSH
74493: PPUSH
74494: PPUSH
74495: PPUSH
74496: PPUSH
74497: PPUSH
74498: PPUSH
74499: PPUSH
74500: PPUSH
74501: PPUSH
// result = [ ] ;
74502: LD_ADDR_VAR 0 7
74506: PUSH
74507: EMPTY
74508: ST_TO_ADDR
// temp_list = [ ] ;
74509: LD_ADDR_VAR 0 9
74513: PUSH
74514: EMPTY
74515: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
74516: LD_VAR 0 4
74520: PUSH
74521: LD_INT 0
74523: PUSH
74524: LD_INT 1
74526: PUSH
74527: LD_INT 2
74529: PUSH
74530: LD_INT 3
74532: PUSH
74533: LD_INT 4
74535: PUSH
74536: LD_INT 5
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: LIST
74543: LIST
74544: LIST
74545: LIST
74546: IN
74547: NOT
74548: PUSH
74549: LD_VAR 0 1
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: LD_INT 1
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: IN
74564: PUSH
74565: LD_VAR 0 5
74569: PUSH
74570: LD_INT 1
74572: PUSH
74573: LD_INT 2
74575: PUSH
74576: LD_INT 3
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: LIST
74583: IN
74584: NOT
74585: AND
74586: OR
74587: IFFALSE 74591
// exit ;
74589: GO 92982
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
74591: LD_VAR 0 1
74595: PUSH
74596: LD_INT 6
74598: PUSH
74599: LD_INT 7
74601: PUSH
74602: LD_INT 8
74604: PUSH
74605: LD_INT 13
74607: PUSH
74608: LD_INT 12
74610: PUSH
74611: LD_INT 15
74613: PUSH
74614: LD_INT 11
74616: PUSH
74617: LD_INT 14
74619: PUSH
74620: LD_INT 10
74622: PUSH
74623: EMPTY
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: IN
74634: IFFALSE 74644
// btype = b_lab ;
74636: LD_ADDR_VAR 0 1
74640: PUSH
74641: LD_INT 6
74643: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
74644: LD_VAR 0 6
74648: PUSH
74649: LD_INT 0
74651: PUSH
74652: LD_INT 1
74654: PUSH
74655: LD_INT 2
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: LIST
74662: IN
74663: NOT
74664: PUSH
74665: LD_VAR 0 1
74669: PUSH
74670: LD_INT 0
74672: PUSH
74673: LD_INT 1
74675: PUSH
74676: LD_INT 2
74678: PUSH
74679: LD_INT 3
74681: PUSH
74682: LD_INT 6
74684: PUSH
74685: LD_INT 36
74687: PUSH
74688: LD_INT 4
74690: PUSH
74691: LD_INT 5
74693: PUSH
74694: LD_INT 31
74696: PUSH
74697: LD_INT 32
74699: PUSH
74700: LD_INT 33
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: LIST
74707: LIST
74708: LIST
74709: LIST
74710: LIST
74711: LIST
74712: LIST
74713: LIST
74714: LIST
74715: IN
74716: NOT
74717: PUSH
74718: LD_VAR 0 6
74722: PUSH
74723: LD_INT 1
74725: EQUAL
74726: AND
74727: OR
74728: PUSH
74729: LD_VAR 0 1
74733: PUSH
74734: LD_INT 2
74736: PUSH
74737: LD_INT 3
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: IN
74744: NOT
74745: PUSH
74746: LD_VAR 0 6
74750: PUSH
74751: LD_INT 2
74753: EQUAL
74754: AND
74755: OR
74756: IFFALSE 74766
// mode = 0 ;
74758: LD_ADDR_VAR 0 6
74762: PUSH
74763: LD_INT 0
74765: ST_TO_ADDR
// case mode of 0 :
74766: LD_VAR 0 6
74770: PUSH
74771: LD_INT 0
74773: DOUBLE
74774: EQUAL
74775: IFTRUE 74779
74777: GO 86232
74779: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74780: LD_ADDR_VAR 0 11
74784: PUSH
74785: LD_INT 0
74787: PUSH
74788: LD_INT 0
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: LD_INT 0
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 1
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 1
74818: PUSH
74819: LD_INT 1
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 0
74828: PUSH
74829: LD_INT 1
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: PUSH
74836: LD_INT 1
74838: NEG
74839: PUSH
74840: LD_INT 0
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 1
74849: NEG
74850: PUSH
74851: LD_INT 1
74853: NEG
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 1
74861: NEG
74862: PUSH
74863: LD_INT 2
74865: NEG
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: LD_INT 2
74876: NEG
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 1
74884: PUSH
74885: LD_INT 1
74887: NEG
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 1
74895: PUSH
74896: LD_INT 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 0
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 1
74915: NEG
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: LD_INT 1
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: LD_INT 3
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 1
74946: NEG
74947: PUSH
74948: LD_INT 2
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74973: LD_ADDR_VAR 0 12
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: LD_INT 0
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 0
74990: PUSH
74991: LD_INT 1
74993: NEG
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: PUSH
74999: LD_INT 1
75001: PUSH
75002: LD_INT 0
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 1
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PUSH
75019: LD_INT 0
75021: PUSH
75022: LD_INT 1
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PUSH
75029: LD_INT 1
75031: NEG
75032: PUSH
75033: LD_INT 0
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: LD_INT 1
75042: NEG
75043: PUSH
75044: LD_INT 1
75046: NEG
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 1
75054: PUSH
75055: LD_INT 1
75057: NEG
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 2
75065: PUSH
75066: LD_INT 0
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 2
75075: PUSH
75076: LD_INT 1
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 1
75085: NEG
75086: PUSH
75087: LD_INT 1
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 2
75096: NEG
75097: PUSH
75098: LD_INT 0
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 2
75107: NEG
75108: PUSH
75109: LD_INT 1
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 2
75119: NEG
75120: PUSH
75121: LD_INT 1
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 3
75130: NEG
75131: PUSH
75132: LD_INT 0
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 3
75141: NEG
75142: PUSH
75143: LD_INT 1
75145: NEG
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: LIST
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: LIST
75164: LIST
75165: LIST
75166: LIST
75167: LIST
75168: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75169: LD_ADDR_VAR 0 13
75173: PUSH
75174: LD_INT 0
75176: PUSH
75177: LD_INT 0
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 0
75186: PUSH
75187: LD_INT 1
75189: NEG
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: LD_INT 1
75197: PUSH
75198: LD_INT 0
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 1
75207: PUSH
75208: LD_INT 1
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 0
75217: PUSH
75218: LD_INT 1
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 1
75227: NEG
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 1
75238: NEG
75239: PUSH
75240: LD_INT 1
75242: NEG
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: PUSH
75248: LD_INT 1
75250: NEG
75251: PUSH
75252: LD_INT 2
75254: NEG
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 2
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 2
75272: PUSH
75273: LD_INT 2
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: PUSH
75280: LD_INT 1
75282: PUSH
75283: LD_INT 2
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 2
75292: NEG
75293: PUSH
75294: LD_INT 1
75296: NEG
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 2
75304: NEG
75305: PUSH
75306: LD_INT 2
75308: NEG
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: LD_INT 2
75316: NEG
75317: PUSH
75318: LD_INT 3
75320: NEG
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 3
75328: NEG
75329: PUSH
75330: LD_INT 2
75332: NEG
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 3
75340: NEG
75341: PUSH
75342: LD_INT 3
75344: NEG
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75368: LD_ADDR_VAR 0 14
75372: PUSH
75373: LD_INT 0
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PUSH
75383: LD_INT 0
75385: PUSH
75386: LD_INT 1
75388: NEG
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 1
75396: PUSH
75397: LD_INT 0
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: PUSH
75404: LD_INT 1
75406: PUSH
75407: LD_INT 1
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: LD_INT 0
75416: PUSH
75417: LD_INT 1
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 1
75426: NEG
75427: PUSH
75428: LD_INT 0
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 1
75437: NEG
75438: PUSH
75439: LD_INT 1
75441: NEG
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 1
75449: NEG
75450: PUSH
75451: LD_INT 2
75453: NEG
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 0
75461: PUSH
75462: LD_INT 2
75464: NEG
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 1
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: LD_INT 0
75493: PUSH
75494: LD_INT 2
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PUSH
75501: LD_INT 1
75503: NEG
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 1
75514: NEG
75515: PUSH
75516: LD_INT 3
75518: NEG
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 0
75526: PUSH
75527: LD_INT 3
75529: NEG
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 1
75537: PUSH
75538: LD_INT 2
75540: NEG
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75564: LD_ADDR_VAR 0 15
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: LD_INT 0
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 0
75581: PUSH
75582: LD_INT 1
75584: NEG
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 1
75592: PUSH
75593: LD_INT 0
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 1
75602: PUSH
75603: LD_INT 1
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 0
75612: PUSH
75613: LD_INT 1
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 1
75622: NEG
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 1
75633: NEG
75634: PUSH
75635: LD_INT 1
75637: NEG
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 1
75645: PUSH
75646: LD_INT 1
75648: NEG
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: LD_INT 2
75656: PUSH
75657: LD_INT 0
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 2
75666: PUSH
75667: LD_INT 1
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: LD_INT 1
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 2
75687: NEG
75688: PUSH
75689: LD_INT 0
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 2
75698: NEG
75699: PUSH
75700: LD_INT 1
75702: NEG
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 2
75710: PUSH
75711: LD_INT 1
75713: NEG
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 3
75721: PUSH
75722: LD_INT 0
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 3
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75757: LD_ADDR_VAR 0 16
75761: PUSH
75762: LD_INT 0
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 0
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 1
75785: PUSH
75786: LD_INT 0
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 1
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 0
75805: PUSH
75806: LD_INT 1
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 1
75815: NEG
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 1
75826: NEG
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: LD_INT 2
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 2
75850: PUSH
75851: LD_INT 1
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: PUSH
75858: LD_INT 2
75860: PUSH
75861: LD_INT 2
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 1
75870: PUSH
75871: LD_INT 2
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 2
75880: NEG
75881: PUSH
75882: LD_INT 1
75884: NEG
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 2
75892: NEG
75893: PUSH
75894: LD_INT 2
75896: NEG
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 3
75904: PUSH
75905: LD_INT 2
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 3
75914: PUSH
75915: LD_INT 3
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 2
75924: PUSH
75925: LD_INT 3
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: LIST
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: LIST
75948: LIST
75949: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75950: LD_ADDR_VAR 0 17
75954: PUSH
75955: LD_INT 0
75957: PUSH
75958: LD_INT 0
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 0
75967: PUSH
75968: LD_INT 1
75970: NEG
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 1
75978: PUSH
75979: LD_INT 0
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 1
75988: PUSH
75989: LD_INT 1
75991: PUSH
75992: EMPTY
75993: LIST
75994: LIST
75995: PUSH
75996: LD_INT 0
75998: PUSH
75999: LD_INT 1
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: LD_INT 1
76008: NEG
76009: PUSH
76010: LD_INT 0
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: LD_INT 1
76023: NEG
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 1
76031: NEG
76032: PUSH
76033: LD_INT 2
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 0
76043: PUSH
76044: LD_INT 2
76046: NEG
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 1
76054: PUSH
76055: LD_INT 1
76057: NEG
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 2
76065: PUSH
76066: LD_INT 0
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 2
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 2
76085: PUSH
76086: LD_INT 2
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 1
76095: PUSH
76096: LD_INT 2
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: LD_INT 2
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 1
76115: NEG
76116: PUSH
76117: LD_INT 1
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 2
76126: NEG
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 2
76137: NEG
76138: PUSH
76139: LD_INT 1
76141: NEG
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 2
76149: NEG
76150: PUSH
76151: LD_INT 2
76153: NEG
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: LIST
76163: LIST
76164: LIST
76165: LIST
76166: LIST
76167: LIST
76168: LIST
76169: LIST
76170: LIST
76171: LIST
76172: LIST
76173: LIST
76174: LIST
76175: LIST
76176: LIST
76177: LIST
76178: LIST
76179: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76180: LD_ADDR_VAR 0 18
76184: PUSH
76185: LD_INT 0
76187: PUSH
76188: LD_INT 0
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 0
76197: PUSH
76198: LD_INT 1
76200: NEG
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 1
76208: PUSH
76209: LD_INT 0
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 1
76218: PUSH
76219: LD_INT 1
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 0
76228: PUSH
76229: LD_INT 1
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 1
76238: NEG
76239: PUSH
76240: LD_INT 0
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 1
76249: NEG
76250: PUSH
76251: LD_INT 1
76253: NEG
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: PUSH
76259: LD_INT 1
76261: NEG
76262: PUSH
76263: LD_INT 2
76265: NEG
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PUSH
76271: LD_INT 0
76273: PUSH
76274: LD_INT 2
76276: NEG
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 1
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 2
76295: PUSH
76296: LD_INT 0
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 2
76315: PUSH
76316: LD_INT 2
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 1
76325: PUSH
76326: LD_INT 2
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: LD_INT 2
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: NEG
76346: PUSH
76347: LD_INT 1
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 2
76356: NEG
76357: PUSH
76358: LD_INT 0
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 2
76367: NEG
76368: PUSH
76369: LD_INT 1
76371: NEG
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 2
76379: NEG
76380: PUSH
76381: LD_INT 2
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: LIST
76393: LIST
76394: LIST
76395: LIST
76396: LIST
76397: LIST
76398: LIST
76399: LIST
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76410: LD_ADDR_VAR 0 19
76414: PUSH
76415: LD_INT 0
76417: PUSH
76418: LD_INT 0
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 0
76427: PUSH
76428: LD_INT 1
76430: NEG
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 1
76438: PUSH
76439: LD_INT 0
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 1
76448: PUSH
76449: LD_INT 1
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 0
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 1
76468: NEG
76469: PUSH
76470: LD_INT 0
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 1
76479: NEG
76480: PUSH
76481: LD_INT 1
76483: NEG
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 1
76491: NEG
76492: PUSH
76493: LD_INT 2
76495: NEG
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 0
76503: PUSH
76504: LD_INT 2
76506: NEG
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 1
76514: PUSH
76515: LD_INT 1
76517: NEG
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 2
76525: PUSH
76526: LD_INT 0
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 2
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 2
76545: PUSH
76546: LD_INT 2
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 1
76555: PUSH
76556: LD_INT 2
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 0
76565: PUSH
76566: LD_INT 2
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 1
76575: NEG
76576: PUSH
76577: LD_INT 1
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 2
76586: NEG
76587: PUSH
76588: LD_INT 0
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 2
76597: NEG
76598: PUSH
76599: LD_INT 1
76601: NEG
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: LD_INT 2
76609: NEG
76610: PUSH
76611: LD_INT 2
76613: NEG
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: LIST
76623: LIST
76624: LIST
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: LIST
76639: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76640: LD_ADDR_VAR 0 20
76644: PUSH
76645: LD_INT 0
76647: PUSH
76648: LD_INT 0
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 0
76657: PUSH
76658: LD_INT 1
76660: NEG
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: LD_INT 0
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 1
76678: PUSH
76679: LD_INT 1
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 0
76688: PUSH
76689: LD_INT 1
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: LD_INT 1
76698: NEG
76699: PUSH
76700: LD_INT 0
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: LD_INT 1
76713: NEG
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 1
76721: NEG
76722: PUSH
76723: LD_INT 2
76725: NEG
76726: PUSH
76727: EMPTY
76728: LIST
76729: LIST
76730: PUSH
76731: LD_INT 0
76733: PUSH
76734: LD_INT 2
76736: NEG
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 1
76744: PUSH
76745: LD_INT 1
76747: NEG
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 2
76755: PUSH
76756: LD_INT 0
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 2
76765: PUSH
76766: LD_INT 1
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 2
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 1
76785: PUSH
76786: LD_INT 2
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 0
76795: PUSH
76796: LD_INT 2
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: NEG
76806: PUSH
76807: LD_INT 1
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: LD_INT 2
76816: NEG
76817: PUSH
76818: LD_INT 0
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 2
76827: NEG
76828: PUSH
76829: LD_INT 1
76831: NEG
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 2
76839: NEG
76840: PUSH
76841: LD_INT 2
76843: NEG
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: EMPTY
76850: LIST
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76870: LD_ADDR_VAR 0 21
76874: PUSH
76875: LD_INT 0
76877: PUSH
76878: LD_INT 0
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 0
76887: PUSH
76888: LD_INT 1
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: LD_INT 0
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 1
76908: PUSH
76909: LD_INT 1
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 0
76918: PUSH
76919: LD_INT 1
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 1
76928: NEG
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: LD_INT 1
76943: NEG
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 1
76951: NEG
76952: PUSH
76953: LD_INT 2
76955: NEG
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 0
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 1
76974: PUSH
76975: LD_INT 1
76977: NEG
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 2
76985: PUSH
76986: LD_INT 0
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 2
76995: PUSH
76996: LD_INT 1
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 2
77005: PUSH
77006: LD_INT 2
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 1
77015: PUSH
77016: LD_INT 2
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 0
77025: PUSH
77026: LD_INT 2
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 1
77035: NEG
77036: PUSH
77037: LD_INT 1
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 2
77046: NEG
77047: PUSH
77048: LD_INT 0
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 2
77057: NEG
77058: PUSH
77059: LD_INT 1
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 2
77069: NEG
77070: PUSH
77071: LD_INT 2
77073: NEG
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77100: LD_ADDR_VAR 0 22
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: LD_INT 0
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: PUSH
77115: LD_INT 0
77117: PUSH
77118: LD_INT 1
77120: NEG
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 1
77128: PUSH
77129: LD_INT 0
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 1
77138: PUSH
77139: LD_INT 1
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PUSH
77146: LD_INT 0
77148: PUSH
77149: LD_INT 1
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: PUSH
77156: LD_INT 1
77158: NEG
77159: PUSH
77160: LD_INT 0
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PUSH
77167: LD_INT 1
77169: NEG
77170: PUSH
77171: LD_INT 1
77173: NEG
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 1
77181: NEG
77182: PUSH
77183: LD_INT 2
77185: NEG
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 0
77193: PUSH
77194: LD_INT 2
77196: NEG
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 1
77204: PUSH
77205: LD_INT 1
77207: NEG
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 2
77215: PUSH
77216: LD_INT 0
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 2
77225: PUSH
77226: LD_INT 1
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 2
77235: PUSH
77236: LD_INT 2
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: LD_INT 1
77245: PUSH
77246: LD_INT 2
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 0
77255: PUSH
77256: LD_INT 2
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 1
77265: NEG
77266: PUSH
77267: LD_INT 1
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 2
77276: NEG
77277: PUSH
77278: LD_INT 0
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 2
77287: NEG
77288: PUSH
77289: LD_INT 1
77291: NEG
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 2
77299: NEG
77300: PUSH
77301: LD_INT 2
77303: NEG
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: LIST
77323: LIST
77324: LIST
77325: LIST
77326: LIST
77327: LIST
77328: LIST
77329: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77330: LD_ADDR_VAR 0 23
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: LD_INT 0
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 0
77347: PUSH
77348: LD_INT 1
77350: NEG
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 1
77358: PUSH
77359: LD_INT 0
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 1
77368: PUSH
77369: LD_INT 1
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 0
77378: PUSH
77379: LD_INT 1
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: LD_INT 0
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 1
77399: NEG
77400: PUSH
77401: LD_INT 1
77403: NEG
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: LD_INT 2
77415: NEG
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 0
77423: PUSH
77424: LD_INT 2
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 1
77434: PUSH
77435: LD_INT 1
77437: NEG
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 2
77445: PUSH
77446: LD_INT 0
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: LD_INT 2
77455: PUSH
77456: LD_INT 1
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 2
77465: PUSH
77466: LD_INT 2
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PUSH
77473: LD_INT 1
77475: PUSH
77476: LD_INT 2
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 0
77485: PUSH
77486: LD_INT 2
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: LD_INT 1
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 2
77506: NEG
77507: PUSH
77508: LD_INT 0
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 2
77517: NEG
77518: PUSH
77519: LD_INT 1
77521: NEG
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 2
77529: NEG
77530: PUSH
77531: LD_INT 2
77533: NEG
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 2
77541: NEG
77542: PUSH
77543: LD_INT 3
77545: NEG
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 1
77553: NEG
77554: PUSH
77555: LD_INT 3
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 1
77565: PUSH
77566: LD_INT 2
77568: NEG
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 2
77576: PUSH
77577: LD_INT 1
77579: NEG
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
77610: LD_ADDR_VAR 0 24
77614: PUSH
77615: LD_INT 0
77617: PUSH
77618: LD_INT 0
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 0
77627: PUSH
77628: LD_INT 1
77630: NEG
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 1
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 1
77648: PUSH
77649: LD_INT 1
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 0
77658: PUSH
77659: LD_INT 1
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 1
77668: NEG
77669: PUSH
77670: LD_INT 0
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: LD_INT 1
77683: NEG
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: LD_INT 1
77691: NEG
77692: PUSH
77693: LD_INT 2
77695: NEG
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: LD_INT 2
77706: NEG
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 1
77714: PUSH
77715: LD_INT 1
77717: NEG
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 2
77725: PUSH
77726: LD_INT 0
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 2
77735: PUSH
77736: LD_INT 1
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 2
77745: PUSH
77746: LD_INT 2
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: LD_INT 1
77755: PUSH
77756: LD_INT 2
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 0
77765: PUSH
77766: LD_INT 2
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: LD_INT 1
77775: NEG
77776: PUSH
77777: LD_INT 1
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: LD_INT 2
77786: NEG
77787: PUSH
77788: LD_INT 0
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 2
77797: NEG
77798: PUSH
77799: LD_INT 1
77801: NEG
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 2
77809: NEG
77810: PUSH
77811: LD_INT 2
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 1
77821: PUSH
77822: LD_INT 2
77824: NEG
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 2
77832: PUSH
77833: LD_INT 1
77835: NEG
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 3
77843: PUSH
77844: LD_INT 1
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 3
77853: PUSH
77854: LD_INT 2
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: LIST
77865: LIST
77866: LIST
77867: LIST
77868: LIST
77869: LIST
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: LIST
77875: LIST
77876: LIST
77877: LIST
77878: LIST
77879: LIST
77880: LIST
77881: LIST
77882: LIST
77883: LIST
77884: LIST
77885: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
77886: LD_ADDR_VAR 0 25
77890: PUSH
77891: LD_INT 0
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 0
77903: PUSH
77904: LD_INT 1
77906: NEG
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 1
77914: PUSH
77915: LD_INT 0
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 1
77924: PUSH
77925: LD_INT 1
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: LD_INT 0
77934: PUSH
77935: LD_INT 1
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 1
77944: NEG
77945: PUSH
77946: LD_INT 0
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 1
77955: NEG
77956: PUSH
77957: LD_INT 1
77959: NEG
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 1
77967: NEG
77968: PUSH
77969: LD_INT 2
77971: NEG
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: PUSH
77977: LD_INT 0
77979: PUSH
77980: LD_INT 2
77982: NEG
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 1
77990: PUSH
77991: LD_INT 1
77993: NEG
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: PUSH
77999: LD_INT 2
78001: PUSH
78002: LD_INT 0
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 2
78011: PUSH
78012: LD_INT 1
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 2
78021: PUSH
78022: LD_INT 2
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 1
78031: PUSH
78032: LD_INT 2
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: LD_INT 2
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 1
78051: NEG
78052: PUSH
78053: LD_INT 1
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 2
78062: NEG
78063: PUSH
78064: LD_INT 0
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 2
78073: NEG
78074: PUSH
78075: LD_INT 1
78077: NEG
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 2
78085: NEG
78086: PUSH
78087: LD_INT 2
78089: NEG
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 3
78097: PUSH
78098: LD_INT 1
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PUSH
78105: LD_INT 3
78107: PUSH
78108: LD_INT 2
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 2
78117: PUSH
78118: LD_INT 3
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: LD_INT 1
78127: PUSH
78128: LD_INT 3
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78160: LD_ADDR_VAR 0 26
78164: PUSH
78165: LD_INT 0
78167: PUSH
78168: LD_INT 0
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 0
78177: PUSH
78178: LD_INT 1
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 1
78188: PUSH
78189: LD_INT 0
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: LD_INT 1
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 0
78208: PUSH
78209: LD_INT 1
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: LD_INT 0
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 1
78229: NEG
78230: PUSH
78231: LD_INT 1
78233: NEG
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: LD_INT 2
78245: NEG
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: LD_INT 2
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 1
78264: PUSH
78265: LD_INT 1
78267: NEG
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 2
78275: PUSH
78276: LD_INT 0
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 2
78285: PUSH
78286: LD_INT 1
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 2
78295: PUSH
78296: LD_INT 2
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 1
78305: PUSH
78306: LD_INT 2
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 0
78315: PUSH
78316: LD_INT 2
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 1
78325: NEG
78326: PUSH
78327: LD_INT 1
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 2
78336: NEG
78337: PUSH
78338: LD_INT 0
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PUSH
78345: LD_INT 2
78347: NEG
78348: PUSH
78349: LD_INT 1
78351: NEG
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 2
78359: NEG
78360: PUSH
78361: LD_INT 2
78363: NEG
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 2
78371: PUSH
78372: LD_INT 3
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 1
78381: PUSH
78382: LD_INT 3
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: LD_INT 1
78391: NEG
78392: PUSH
78393: LD_INT 2
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 2
78402: NEG
78403: PUSH
78404: LD_INT 1
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: LIST
78430: LIST
78431: LIST
78432: LIST
78433: LIST
78434: LIST
78435: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78436: LD_ADDR_VAR 0 27
78440: PUSH
78441: LD_INT 0
78443: PUSH
78444: LD_INT 0
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 0
78453: PUSH
78454: LD_INT 1
78456: NEG
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 1
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 1
78474: PUSH
78475: LD_INT 1
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 0
78484: PUSH
78485: LD_INT 1
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 1
78494: NEG
78495: PUSH
78496: LD_INT 0
78498: PUSH
78499: EMPTY
78500: LIST
78501: LIST
78502: PUSH
78503: LD_INT 1
78505: NEG
78506: PUSH
78507: LD_INT 1
78509: NEG
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 1
78517: NEG
78518: PUSH
78519: LD_INT 2
78521: NEG
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 0
78529: PUSH
78530: LD_INT 2
78532: NEG
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: LD_INT 1
78540: PUSH
78541: LD_INT 1
78543: NEG
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 2
78551: PUSH
78552: LD_INT 0
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 2
78561: PUSH
78562: LD_INT 1
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 2
78571: PUSH
78572: LD_INT 2
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 1
78581: PUSH
78582: LD_INT 2
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 0
78591: PUSH
78592: LD_INT 2
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 1
78601: NEG
78602: PUSH
78603: LD_INT 1
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 2
78612: NEG
78613: PUSH
78614: LD_INT 0
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: PUSH
78621: LD_INT 2
78623: NEG
78624: PUSH
78625: LD_INT 1
78627: NEG
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: LD_INT 2
78635: NEG
78636: PUSH
78637: LD_INT 2
78639: NEG
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 1
78647: NEG
78648: PUSH
78649: LD_INT 2
78651: PUSH
78652: EMPTY
78653: LIST
78654: LIST
78655: PUSH
78656: LD_INT 2
78658: NEG
78659: PUSH
78660: LD_INT 1
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 3
78669: NEG
78670: PUSH
78671: LD_INT 1
78673: NEG
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 3
78681: NEG
78682: PUSH
78683: LD_INT 2
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78716: LD_ADDR_VAR 0 28
78720: PUSH
78721: LD_INT 0
78723: PUSH
78724: LD_INT 0
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: LD_INT 1
78736: NEG
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 1
78744: PUSH
78745: LD_INT 0
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: LD_INT 1
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: LD_INT 0
78764: PUSH
78765: LD_INT 1
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 1
78774: NEG
78775: PUSH
78776: LD_INT 0
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 1
78785: NEG
78786: PUSH
78787: LD_INT 1
78789: NEG
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 1
78797: NEG
78798: PUSH
78799: LD_INT 2
78801: NEG
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PUSH
78807: LD_INT 0
78809: PUSH
78810: LD_INT 2
78812: NEG
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 1
78820: PUSH
78821: LD_INT 1
78823: NEG
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 2
78831: PUSH
78832: LD_INT 0
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 2
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 2
78851: PUSH
78852: LD_INT 2
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 1
78861: PUSH
78862: LD_INT 2
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 0
78871: PUSH
78872: LD_INT 2
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: LD_INT 1
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 2
78892: NEG
78893: PUSH
78894: LD_INT 0
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 2
78903: NEG
78904: PUSH
78905: LD_INT 1
78907: NEG
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 2
78915: NEG
78916: PUSH
78917: LD_INT 2
78919: NEG
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 2
78927: NEG
78928: PUSH
78929: LD_INT 3
78931: NEG
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 1
78939: NEG
78940: PUSH
78941: LD_INT 3
78943: NEG
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 3
78951: NEG
78952: PUSH
78953: LD_INT 1
78955: NEG
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 3
78963: NEG
78964: PUSH
78965: LD_INT 2
78967: NEG
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
78998: LD_ADDR_VAR 0 29
79002: PUSH
79003: LD_INT 0
79005: PUSH
79006: LD_INT 0
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 0
79015: PUSH
79016: LD_INT 1
79018: NEG
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 1
79026: PUSH
79027: LD_INT 0
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 1
79036: PUSH
79037: LD_INT 1
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 0
79046: PUSH
79047: LD_INT 1
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 1
79056: NEG
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 1
79067: NEG
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 1
79079: NEG
79080: PUSH
79081: LD_INT 2
79083: NEG
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 0
79091: PUSH
79092: LD_INT 2
79094: NEG
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 1
79102: PUSH
79103: LD_INT 1
79105: NEG
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 2
79113: PUSH
79114: LD_INT 0
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 2
79123: PUSH
79124: LD_INT 1
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 1
79133: PUSH
79134: LD_INT 2
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 0
79143: PUSH
79144: LD_INT 2
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 1
79153: NEG
79154: PUSH
79155: LD_INT 1
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 2
79164: NEG
79165: PUSH
79166: LD_INT 1
79168: NEG
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 2
79176: NEG
79177: PUSH
79178: LD_INT 2
79180: NEG
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 2
79188: NEG
79189: PUSH
79190: LD_INT 3
79192: NEG
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 2
79200: PUSH
79201: LD_INT 1
79203: NEG
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 3
79211: PUSH
79212: LD_INT 1
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 1
79221: PUSH
79222: LD_INT 3
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 1
79231: NEG
79232: PUSH
79233: LD_INT 2
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 3
79242: NEG
79243: PUSH
79244: LD_INT 2
79246: NEG
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79277: LD_ADDR_VAR 0 30
79281: PUSH
79282: LD_INT 0
79284: PUSH
79285: LD_INT 0
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 0
79294: PUSH
79295: LD_INT 1
79297: NEG
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 1
79305: PUSH
79306: LD_INT 0
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 1
79315: PUSH
79316: LD_INT 1
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 0
79325: PUSH
79326: LD_INT 1
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 1
79335: NEG
79336: PUSH
79337: LD_INT 0
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 1
79346: NEG
79347: PUSH
79348: LD_INT 1
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: LD_INT 2
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 0
79370: PUSH
79371: LD_INT 2
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 1
79381: PUSH
79382: LD_INT 1
79384: NEG
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 2
79392: PUSH
79393: LD_INT 0
79395: PUSH
79396: EMPTY
79397: LIST
79398: LIST
79399: PUSH
79400: LD_INT 2
79402: PUSH
79403: LD_INT 1
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PUSH
79410: LD_INT 2
79412: PUSH
79413: LD_INT 2
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 1
79422: PUSH
79423: LD_INT 2
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 1
79432: NEG
79433: PUSH
79434: LD_INT 1
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 2
79443: NEG
79444: PUSH
79445: LD_INT 0
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 2
79454: NEG
79455: PUSH
79456: LD_INT 1
79458: NEG
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 1
79466: NEG
79467: PUSH
79468: LD_INT 3
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 1
79478: PUSH
79479: LD_INT 2
79481: NEG
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 3
79489: PUSH
79490: LD_INT 2
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: LD_INT 3
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 2
79509: NEG
79510: PUSH
79511: LD_INT 1
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 3
79520: NEG
79521: PUSH
79522: LD_INT 1
79524: NEG
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79555: LD_ADDR_VAR 0 31
79559: PUSH
79560: LD_INT 0
79562: PUSH
79563: LD_INT 0
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: LD_INT 0
79572: PUSH
79573: LD_INT 1
79575: NEG
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 1
79583: PUSH
79584: LD_INT 0
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 1
79593: PUSH
79594: LD_INT 1
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: LD_INT 0
79603: PUSH
79604: LD_INT 1
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 1
79613: NEG
79614: PUSH
79615: LD_INT 0
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 1
79624: NEG
79625: PUSH
79626: LD_INT 1
79628: NEG
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 1
79636: NEG
79637: PUSH
79638: LD_INT 2
79640: NEG
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 1
79648: PUSH
79649: LD_INT 1
79651: NEG
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 2
79659: PUSH
79660: LD_INT 0
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 2
79679: PUSH
79680: LD_INT 2
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 1
79689: PUSH
79690: LD_INT 2
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 0
79699: PUSH
79700: LD_INT 2
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 1
79709: NEG
79710: PUSH
79711: LD_INT 1
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 2
79720: NEG
79721: PUSH
79722: LD_INT 1
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 2
79732: NEG
79733: PUSH
79734: LD_INT 2
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 2
79744: NEG
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 2
79756: PUSH
79757: LD_INT 1
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 3
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 1
79777: PUSH
79778: LD_INT 3
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 1
79787: NEG
79788: PUSH
79789: LD_INT 2
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 3
79798: NEG
79799: PUSH
79800: LD_INT 2
79802: NEG
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: LIST
79812: LIST
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: LIST
79827: LIST
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79833: LD_ADDR_VAR 0 32
79837: PUSH
79838: LD_INT 0
79840: PUSH
79841: LD_INT 0
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 0
79850: PUSH
79851: LD_INT 1
79853: NEG
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 1
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 0
79881: PUSH
79882: LD_INT 1
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: LD_INT 1
79891: NEG
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 1
79902: NEG
79903: PUSH
79904: LD_INT 1
79906: NEG
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 1
79914: NEG
79915: PUSH
79916: LD_INT 2
79918: NEG
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 0
79926: PUSH
79927: LD_INT 2
79929: NEG
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 1
79937: PUSH
79938: LD_INT 1
79940: NEG
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 2
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 2
79958: PUSH
79959: LD_INT 2
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 1
79968: PUSH
79969: LD_INT 2
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 0
79978: PUSH
79979: LD_INT 2
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 1
79988: NEG
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 2
79999: NEG
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 2
80010: NEG
80011: PUSH
80012: LD_INT 1
80014: NEG
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PUSH
80020: LD_INT 1
80022: NEG
80023: PUSH
80024: LD_INT 3
80026: NEG
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 1
80034: PUSH
80035: LD_INT 2
80037: NEG
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 3
80045: PUSH
80046: LD_INT 2
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 2
80055: PUSH
80056: LD_INT 3
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 2
80065: NEG
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 3
80076: NEG
80077: PUSH
80078: LD_INT 1
80080: NEG
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80111: LD_ADDR_VAR 0 33
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: LD_INT 0
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 0
80128: PUSH
80129: LD_INT 1
80131: NEG
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 1
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: LD_INT 1
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 0
80159: PUSH
80160: LD_INT 1
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 1
80169: NEG
80170: PUSH
80171: LD_INT 0
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 1
80180: NEG
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 1
80192: NEG
80193: PUSH
80194: LD_INT 2
80196: NEG
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 2
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 2
80225: PUSH
80226: LD_INT 1
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 1
80235: PUSH
80236: LD_INT 2
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 1
80255: NEG
80256: PUSH
80257: LD_INT 1
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: PUSH
80264: LD_INT 2
80266: NEG
80267: PUSH
80268: LD_INT 0
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 2
80277: NEG
80278: PUSH
80279: LD_INT 1
80281: NEG
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 2
80289: NEG
80290: PUSH
80291: LD_INT 2
80293: NEG
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 2
80301: NEG
80302: PUSH
80303: LD_INT 3
80305: NEG
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: PUSH
80311: LD_INT 2
80313: PUSH
80314: LD_INT 1
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 3
80324: PUSH
80325: LD_INT 1
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: LD_INT 3
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: LD_INT 2
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 3
80355: NEG
80356: PUSH
80357: LD_INT 2
80359: NEG
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80390: LD_ADDR_VAR 0 34
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: LD_INT 0
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: LD_INT 1
80410: NEG
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: LD_INT 0
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 1
80428: PUSH
80429: LD_INT 1
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 0
80438: PUSH
80439: LD_INT 1
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 1
80448: NEG
80449: PUSH
80450: LD_INT 0
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 1
80471: NEG
80472: PUSH
80473: LD_INT 2
80475: NEG
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 0
80483: PUSH
80484: LD_INT 2
80486: NEG
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 1
80494: PUSH
80495: LD_INT 1
80497: NEG
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 2
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 2
80515: PUSH
80516: LD_INT 2
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: LD_INT 2
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: LD_INT 1
80535: NEG
80536: PUSH
80537: LD_INT 1
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 2
80546: NEG
80547: PUSH
80548: LD_INT 0
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 2
80557: NEG
80558: PUSH
80559: LD_INT 1
80561: NEG
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 2
80569: NEG
80570: PUSH
80571: LD_INT 2
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 1
80581: NEG
80582: PUSH
80583: LD_INT 3
80585: NEG
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: LD_INT 2
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 3
80604: PUSH
80605: LD_INT 2
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 2
80614: PUSH
80615: LD_INT 3
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 2
80624: NEG
80625: PUSH
80626: LD_INT 1
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 3
80635: NEG
80636: PUSH
80637: LD_INT 1
80639: NEG
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80670: LD_ADDR_VAR 0 35
80674: PUSH
80675: LD_INT 0
80677: PUSH
80678: LD_INT 0
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 0
80687: PUSH
80688: LD_INT 1
80690: NEG
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 1
80698: PUSH
80699: LD_INT 0
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 1
80708: PUSH
80709: LD_INT 1
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 0
80718: PUSH
80719: LD_INT 1
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 1
80728: NEG
80729: PUSH
80730: LD_INT 0
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 1
80739: NEG
80740: PUSH
80741: LD_INT 1
80743: NEG
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: PUSH
80749: LD_INT 2
80751: PUSH
80752: LD_INT 1
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 2
80761: NEG
80762: PUSH
80763: LD_INT 1
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80782: LD_ADDR_VAR 0 36
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 0
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: LD_INT 0
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 1
80820: PUSH
80821: LD_INT 1
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 0
80830: PUSH
80831: LD_INT 1
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 1
80840: NEG
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 1
80863: NEG
80864: PUSH
80865: LD_INT 2
80867: NEG
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: LD_INT 2
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80894: LD_ADDR_VAR 0 37
80898: PUSH
80899: LD_INT 0
80901: PUSH
80902: LD_INT 0
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 0
80911: PUSH
80912: LD_INT 1
80914: NEG
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 1
80922: PUSH
80923: LD_INT 0
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 1
80932: PUSH
80933: LD_INT 1
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 0
80942: PUSH
80943: LD_INT 1
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: LD_INT 0
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: LD_INT 1
80967: NEG
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 1
80975: PUSH
80976: LD_INT 1
80978: NEG
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 1
80986: NEG
80987: PUSH
80988: LD_INT 1
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
81006: LD_ADDR_VAR 0 38
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: LD_INT 0
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 0
81023: PUSH
81024: LD_INT 1
81026: NEG
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: PUSH
81035: LD_INT 0
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: LD_INT 1
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 0
81054: PUSH
81055: LD_INT 1
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 1
81064: NEG
81065: PUSH
81066: LD_INT 0
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: LD_INT 1
81079: NEG
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 2
81087: PUSH
81088: LD_INT 1
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 2
81097: NEG
81098: PUSH
81099: LD_INT 1
81101: NEG
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81118: LD_ADDR_VAR 0 39
81122: PUSH
81123: LD_INT 0
81125: PUSH
81126: LD_INT 0
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 0
81135: PUSH
81136: LD_INT 1
81138: NEG
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 1
81146: PUSH
81147: LD_INT 0
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 1
81156: PUSH
81157: LD_INT 1
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 0
81166: PUSH
81167: LD_INT 1
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: LD_INT 1
81176: NEG
81177: PUSH
81178: LD_INT 0
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 1
81187: NEG
81188: PUSH
81189: LD_INT 1
81191: NEG
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: LD_INT 2
81203: NEG
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 1
81211: PUSH
81212: LD_INT 2
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: LIST
81225: LIST
81226: LIST
81227: LIST
81228: LIST
81229: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81230: LD_ADDR_VAR 0 40
81234: PUSH
81235: LD_INT 0
81237: PUSH
81238: LD_INT 0
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 0
81247: PUSH
81248: LD_INT 1
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 1
81258: PUSH
81259: LD_INT 0
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 1
81268: PUSH
81269: LD_INT 1
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 0
81278: PUSH
81279: LD_INT 1
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 1
81288: NEG
81289: PUSH
81290: LD_INT 0
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 1
81299: NEG
81300: PUSH
81301: LD_INT 1
81303: NEG
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 1
81311: PUSH
81312: LD_INT 1
81314: NEG
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 1
81322: NEG
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81342: LD_ADDR_VAR 0 41
81346: PUSH
81347: LD_INT 0
81349: PUSH
81350: LD_INT 0
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 1
81370: PUSH
81371: LD_INT 0
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: LD_INT 1
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 0
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 1
81400: NEG
81401: PUSH
81402: LD_INT 0
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 1
81411: NEG
81412: PUSH
81413: LD_INT 1
81415: NEG
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 1
81423: NEG
81424: PUSH
81425: LD_INT 2
81427: NEG
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 1
81435: PUSH
81436: LD_INT 1
81438: NEG
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 2
81446: PUSH
81447: LD_INT 0
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 2
81456: PUSH
81457: LD_INT 1
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: LD_INT 2
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 1
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 1
81486: NEG
81487: PUSH
81488: LD_INT 1
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: PUSH
81495: LD_INT 2
81497: NEG
81498: PUSH
81499: LD_INT 0
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 2
81508: NEG
81509: PUSH
81510: LD_INT 1
81512: NEG
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 2
81520: NEG
81521: PUSH
81522: LD_INT 2
81524: NEG
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 2
81532: NEG
81533: PUSH
81534: LD_INT 3
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 2
81544: PUSH
81545: LD_INT 1
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 3
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 3
81565: PUSH
81566: LD_INT 1
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 3
81575: PUSH
81576: LD_INT 2
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 3
81585: PUSH
81586: LD_INT 3
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: LD_INT 2
81595: PUSH
81596: LD_INT 3
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 2
81605: NEG
81606: PUSH
81607: LD_INT 1
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 3
81616: NEG
81617: PUSH
81618: LD_INT 0
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 3
81627: NEG
81628: PUSH
81629: LD_INT 1
81631: NEG
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 3
81639: NEG
81640: PUSH
81641: LD_INT 2
81643: NEG
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 3
81651: NEG
81652: PUSH
81653: LD_INT 3
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: LIST
81670: LIST
81671: LIST
81672: LIST
81673: LIST
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81692: LD_ADDR_VAR 0 42
81696: PUSH
81697: LD_INT 0
81699: PUSH
81700: LD_INT 0
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: LD_INT 1
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 1
81720: PUSH
81721: LD_INT 0
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: LD_INT 1
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 0
81740: PUSH
81741: LD_INT 1
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 1
81750: NEG
81751: PUSH
81752: LD_INT 0
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 1
81761: NEG
81762: PUSH
81763: LD_INT 1
81765: NEG
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 1
81773: NEG
81774: PUSH
81775: LD_INT 2
81777: NEG
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 0
81785: PUSH
81786: LD_INT 2
81788: NEG
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: LD_INT 1
81796: PUSH
81797: LD_INT 1
81799: NEG
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 2
81807: PUSH
81808: LD_INT 1
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 2
81817: PUSH
81818: LD_INT 2
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 1
81827: PUSH
81828: LD_INT 2
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 0
81837: PUSH
81838: LD_INT 2
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 1
81847: NEG
81848: PUSH
81849: LD_INT 1
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 2
81858: NEG
81859: PUSH
81860: LD_INT 1
81862: NEG
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 2
81870: NEG
81871: PUSH
81872: LD_INT 2
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 2
81882: NEG
81883: PUSH
81884: LD_INT 3
81886: NEG
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: LD_INT 3
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: LD_INT 3
81909: NEG
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 1
81917: PUSH
81918: LD_INT 2
81920: NEG
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 3
81928: PUSH
81929: LD_INT 2
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 3
81938: PUSH
81939: LD_INT 3
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 2
81948: PUSH
81949: LD_INT 3
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 1
81958: PUSH
81959: LD_INT 3
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 0
81968: PUSH
81969: LD_INT 3
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 1
81978: NEG
81979: PUSH
81980: LD_INT 2
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 3
81989: NEG
81990: PUSH
81991: LD_INT 2
81993: NEG
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 3
82001: NEG
82002: PUSH
82003: LD_INT 3
82005: NEG
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82042: LD_ADDR_VAR 0 43
82046: PUSH
82047: LD_INT 0
82049: PUSH
82050: LD_INT 0
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 0
82059: PUSH
82060: LD_INT 1
82062: NEG
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 1
82070: PUSH
82071: LD_INT 0
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 1
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 0
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 1
82100: NEG
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 1
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: NEG
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: LD_INT 2
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: LD_INT 2
82138: NEG
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 1
82146: PUSH
82147: LD_INT 1
82149: NEG
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PUSH
82155: LD_INT 2
82157: PUSH
82158: LD_INT 0
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: PUSH
82168: LD_INT 1
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 1
82177: PUSH
82178: LD_INT 2
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 0
82187: PUSH
82188: LD_INT 2
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 1
82197: NEG
82198: PUSH
82199: LD_INT 1
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 2
82208: NEG
82209: PUSH
82210: LD_INT 0
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 2
82219: NEG
82220: PUSH
82221: LD_INT 1
82223: NEG
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 1
82231: NEG
82232: PUSH
82233: LD_INT 3
82235: NEG
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 0
82243: PUSH
82244: LD_INT 3
82246: NEG
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 1
82254: PUSH
82255: LD_INT 2
82257: NEG
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 2
82265: PUSH
82266: LD_INT 1
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 3
82276: PUSH
82277: LD_INT 0
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 3
82286: PUSH
82287: LD_INT 1
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 1
82296: PUSH
82297: LD_INT 3
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 0
82306: PUSH
82307: LD_INT 3
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 1
82316: NEG
82317: PUSH
82318: LD_INT 2
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 2
82327: NEG
82328: PUSH
82329: LD_INT 1
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PUSH
82336: LD_INT 3
82338: NEG
82339: PUSH
82340: LD_INT 0
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 3
82349: NEG
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82390: LD_ADDR_VAR 0 44
82394: PUSH
82395: LD_INT 0
82397: PUSH
82398: LD_INT 0
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 0
82407: PUSH
82408: LD_INT 1
82410: NEG
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 1
82418: PUSH
82419: LD_INT 0
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 1
82428: PUSH
82429: LD_INT 1
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: LD_INT 1
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 1
82448: NEG
82449: PUSH
82450: LD_INT 0
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 1
82459: NEG
82460: PUSH
82461: LD_INT 1
82463: NEG
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 1
82471: NEG
82472: PUSH
82473: LD_INT 2
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 1
82483: PUSH
82484: LD_INT 1
82486: NEG
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 2
82494: PUSH
82495: LD_INT 0
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 2
82504: PUSH
82505: LD_INT 1
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 2
82514: PUSH
82515: LD_INT 2
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 1
82524: PUSH
82525: LD_INT 2
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 1
82534: NEG
82535: PUSH
82536: LD_INT 1
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 2
82545: NEG
82546: PUSH
82547: LD_INT 0
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 2
82556: NEG
82557: PUSH
82558: LD_INT 1
82560: NEG
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 2
82568: NEG
82569: PUSH
82570: LD_INT 2
82572: NEG
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 2
82580: NEG
82581: PUSH
82582: LD_INT 3
82584: NEG
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 2
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 3
82603: PUSH
82604: LD_INT 0
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 3
82613: PUSH
82614: LD_INT 1
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 3
82623: PUSH
82624: LD_INT 2
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 3
82633: PUSH
82634: LD_INT 3
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: PUSH
82641: LD_INT 2
82643: PUSH
82644: LD_INT 3
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 2
82653: NEG
82654: PUSH
82655: LD_INT 1
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 3
82664: NEG
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 3
82675: NEG
82676: PUSH
82677: LD_INT 1
82679: NEG
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 3
82687: NEG
82688: PUSH
82689: LD_INT 2
82691: NEG
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 3
82699: NEG
82700: PUSH
82701: LD_INT 3
82703: NEG
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82740: LD_ADDR_VAR 0 45
82744: PUSH
82745: LD_INT 0
82747: PUSH
82748: LD_INT 0
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 0
82757: PUSH
82758: LD_INT 1
82760: NEG
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 1
82768: PUSH
82769: LD_INT 0
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 1
82778: PUSH
82779: LD_INT 1
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 0
82788: PUSH
82789: LD_INT 1
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 1
82798: NEG
82799: PUSH
82800: LD_INT 0
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: LD_INT 1
82809: NEG
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 1
82821: NEG
82822: PUSH
82823: LD_INT 2
82825: NEG
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 0
82833: PUSH
82834: LD_INT 2
82836: NEG
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 1
82844: PUSH
82845: LD_INT 1
82847: NEG
82848: PUSH
82849: EMPTY
82850: LIST
82851: LIST
82852: PUSH
82853: LD_INT 2
82855: PUSH
82856: LD_INT 1
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: PUSH
82863: LD_INT 2
82865: PUSH
82866: LD_INT 2
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 1
82875: PUSH
82876: LD_INT 2
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 0
82885: PUSH
82886: LD_INT 2
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 1
82895: NEG
82896: PUSH
82897: LD_INT 1
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 2
82906: NEG
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 2
82918: NEG
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 2
82930: NEG
82931: PUSH
82932: LD_INT 3
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: LD_INT 3
82946: NEG
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: LD_INT 3
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 2
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 3
82976: PUSH
82977: LD_INT 2
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 3
82986: PUSH
82987: LD_INT 3
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 2
82996: PUSH
82997: LD_INT 3
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 1
83006: PUSH
83007: LD_INT 3
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 3
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: LD_INT 1
83026: NEG
83027: PUSH
83028: LD_INT 2
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 3
83037: NEG
83038: PUSH
83039: LD_INT 2
83041: NEG
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 3
83049: NEG
83050: PUSH
83051: LD_INT 3
83053: NEG
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83090: LD_ADDR_VAR 0 46
83094: PUSH
83095: LD_INT 0
83097: PUSH
83098: LD_INT 0
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 0
83107: PUSH
83108: LD_INT 1
83110: NEG
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 1
83118: PUSH
83119: LD_INT 0
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 1
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 0
83138: PUSH
83139: LD_INT 1
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 1
83148: NEG
83149: PUSH
83150: LD_INT 0
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: NEG
83160: PUSH
83161: LD_INT 1
83163: NEG
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: LD_INT 2
83175: NEG
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 0
83183: PUSH
83184: LD_INT 2
83186: NEG
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 1
83194: PUSH
83195: LD_INT 1
83197: NEG
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 2
83205: PUSH
83206: LD_INT 0
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 2
83215: PUSH
83216: LD_INT 1
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: LD_INT 1
83225: PUSH
83226: LD_INT 2
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 0
83235: PUSH
83236: LD_INT 2
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 1
83245: NEG
83246: PUSH
83247: LD_INT 1
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: LD_INT 2
83256: NEG
83257: PUSH
83258: LD_INT 0
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 2
83267: NEG
83268: PUSH
83269: LD_INT 1
83271: NEG
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 1
83279: NEG
83280: PUSH
83281: LD_INT 3
83283: NEG
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 0
83291: PUSH
83292: LD_INT 3
83294: NEG
83295: PUSH
83296: EMPTY
83297: LIST
83298: LIST
83299: PUSH
83300: LD_INT 1
83302: PUSH
83303: LD_INT 2
83305: NEG
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 2
83313: PUSH
83314: LD_INT 1
83316: NEG
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 3
83324: PUSH
83325: LD_INT 0
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 3
83334: PUSH
83335: LD_INT 1
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 1
83344: PUSH
83345: LD_INT 3
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 0
83354: PUSH
83355: LD_INT 3
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 1
83364: NEG
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: LD_INT 2
83375: NEG
83376: PUSH
83377: LD_INT 1
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 3
83386: NEG
83387: PUSH
83388: LD_INT 0
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 3
83397: NEG
83398: PUSH
83399: LD_INT 1
83401: NEG
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83438: LD_ADDR_VAR 0 47
83442: PUSH
83443: LD_INT 0
83445: PUSH
83446: LD_INT 0
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 0
83455: PUSH
83456: LD_INT 1
83458: NEG
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 1
83466: PUSH
83467: LD_INT 0
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: LD_INT 1
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: LD_INT 1
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 1
83496: NEG
83497: PUSH
83498: LD_INT 0
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 1
83507: NEG
83508: PUSH
83509: LD_INT 1
83511: NEG
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 1
83519: NEG
83520: PUSH
83521: LD_INT 2
83523: NEG
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 0
83531: PUSH
83532: LD_INT 2
83534: NEG
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: LD_INT 1
83542: PUSH
83543: LD_INT 1
83545: NEG
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 2
83553: NEG
83554: PUSH
83555: LD_INT 1
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: NEG
83566: PUSH
83567: LD_INT 2
83569: NEG
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83589: LD_ADDR_VAR 0 48
83593: PUSH
83594: LD_INT 0
83596: PUSH
83597: LD_INT 0
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: LD_INT 1
83609: NEG
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 1
83627: PUSH
83628: LD_INT 1
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: LD_INT 1
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 1
83647: NEG
83648: PUSH
83649: LD_INT 0
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 1
83658: NEG
83659: PUSH
83660: LD_INT 1
83662: NEG
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: PUSH
83668: LD_INT 1
83670: NEG
83671: PUSH
83672: LD_INT 2
83674: NEG
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 0
83682: PUSH
83683: LD_INT 2
83685: NEG
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 1
83693: PUSH
83694: LD_INT 1
83696: NEG
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 2
83704: PUSH
83705: LD_INT 0
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 2
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83736: LD_ADDR_VAR 0 49
83740: PUSH
83741: LD_INT 0
83743: PUSH
83744: LD_INT 0
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 0
83753: PUSH
83754: LD_INT 1
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 1
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 1
83774: PUSH
83775: LD_INT 1
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 0
83784: PUSH
83785: LD_INT 1
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 1
83794: NEG
83795: PUSH
83796: LD_INT 0
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 1
83805: NEG
83806: PUSH
83807: LD_INT 1
83809: NEG
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 1
83817: PUSH
83818: LD_INT 1
83820: NEG
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: LD_INT 2
83828: PUSH
83829: LD_INT 0
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: PUSH
83836: LD_INT 2
83838: PUSH
83839: LD_INT 1
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 2
83848: PUSH
83849: LD_INT 2
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: LD_INT 2
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83880: LD_ADDR_VAR 0 50
83884: PUSH
83885: LD_INT 0
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: LD_INT 1
83900: NEG
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 1
83908: PUSH
83909: LD_INT 0
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 1
83918: PUSH
83919: LD_INT 1
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: LD_INT 1
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 1
83938: NEG
83939: PUSH
83940: LD_INT 0
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 1
83949: NEG
83950: PUSH
83951: LD_INT 1
83953: NEG
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 2
83961: PUSH
83962: LD_INT 1
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 2
83971: PUSH
83972: LD_INT 2
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: LD_INT 2
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: LD_INT 2
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 1
84001: NEG
84002: PUSH
84003: LD_INT 1
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
84024: LD_ADDR_VAR 0 51
84028: PUSH
84029: LD_INT 0
84031: PUSH
84032: LD_INT 0
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 0
84041: PUSH
84042: LD_INT 1
84044: NEG
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: LD_INT 0
84055: PUSH
84056: EMPTY
84057: LIST
84058: LIST
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 0
84072: PUSH
84073: LD_INT 1
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: NEG
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: LD_INT 1
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 1
84105: PUSH
84106: LD_INT 2
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 0
84115: PUSH
84116: LD_INT 2
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: LD_INT 1
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 2
84136: NEG
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 2
84147: NEG
84148: PUSH
84149: LD_INT 1
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84171: LD_ADDR_VAR 0 52
84175: PUSH
84176: LD_INT 0
84178: PUSH
84179: LD_INT 0
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 0
84188: PUSH
84189: LD_INT 1
84191: NEG
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 1
84199: PUSH
84200: LD_INT 0
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: PUSH
84207: LD_INT 1
84209: PUSH
84210: LD_INT 1
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: PUSH
84217: LD_INT 0
84219: PUSH
84220: LD_INT 1
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 1
84229: NEG
84230: PUSH
84231: LD_INT 0
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: PUSH
84238: LD_INT 1
84240: NEG
84241: PUSH
84242: LD_INT 1
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: NEG
84253: PUSH
84254: LD_INT 2
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: LD_INT 1
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 2
84275: NEG
84276: PUSH
84277: LD_INT 0
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: LD_INT 2
84286: NEG
84287: PUSH
84288: LD_INT 1
84290: NEG
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: LD_INT 2
84298: NEG
84299: PUSH
84300: LD_INT 2
84302: NEG
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84322: LD_ADDR_VAR 0 53
84326: PUSH
84327: LD_INT 0
84329: PUSH
84330: LD_INT 0
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 0
84339: PUSH
84340: LD_INT 1
84342: NEG
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: PUSH
84351: LD_INT 0
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: LD_INT 1
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 0
84370: PUSH
84371: LD_INT 1
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: PUSH
84378: LD_INT 1
84380: NEG
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 1
84391: NEG
84392: PUSH
84393: LD_INT 1
84395: NEG
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: LD_INT 2
84407: NEG
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 0
84415: PUSH
84416: LD_INT 2
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: PUSH
84427: LD_INT 1
84429: NEG
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 2
84437: PUSH
84438: LD_INT 0
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 2
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 2
84457: PUSH
84458: LD_INT 2
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 1
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 0
84477: PUSH
84478: LD_INT 2
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 1
84487: NEG
84488: PUSH
84489: LD_INT 1
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 2
84498: NEG
84499: PUSH
84500: LD_INT 0
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 2
84509: NEG
84510: PUSH
84511: LD_INT 1
84513: NEG
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 2
84521: NEG
84522: PUSH
84523: LD_INT 2
84525: NEG
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84552: LD_ADDR_VAR 0 54
84556: PUSH
84557: LD_INT 0
84559: PUSH
84560: LD_INT 0
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 0
84569: PUSH
84570: LD_INT 1
84572: NEG
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 1
84580: PUSH
84581: LD_INT 0
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 1
84590: PUSH
84591: LD_INT 1
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 0
84600: PUSH
84601: LD_INT 1
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: LD_INT 1
84610: NEG
84611: PUSH
84612: LD_INT 0
84614: PUSH
84615: EMPTY
84616: LIST
84617: LIST
84618: PUSH
84619: LD_INT 1
84621: NEG
84622: PUSH
84623: LD_INT 1
84625: NEG
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: LD_INT 1
84633: NEG
84634: PUSH
84635: LD_INT 2
84637: NEG
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: LD_INT 2
84648: NEG
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 1
84656: PUSH
84657: LD_INT 1
84659: NEG
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 2
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 2
84677: PUSH
84678: LD_INT 1
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 2
84687: PUSH
84688: LD_INT 2
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: PUSH
84695: LD_INT 1
84697: PUSH
84698: LD_INT 2
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 0
84707: PUSH
84708: LD_INT 2
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: PUSH
84715: LD_INT 1
84717: NEG
84718: PUSH
84719: LD_INT 1
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 2
84728: NEG
84729: PUSH
84730: LD_INT 0
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 2
84739: NEG
84740: PUSH
84741: LD_INT 1
84743: NEG
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PUSH
84749: LD_INT 2
84751: NEG
84752: PUSH
84753: LD_INT 2
84755: NEG
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84782: LD_ADDR_VAR 0 55
84786: PUSH
84787: LD_INT 0
84789: PUSH
84790: LD_INT 0
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: LD_INT 1
84802: NEG
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 1
84810: PUSH
84811: LD_INT 0
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 0
84830: PUSH
84831: LD_INT 1
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: LD_INT 1
84840: NEG
84841: PUSH
84842: LD_INT 0
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PUSH
84849: LD_INT 1
84851: NEG
84852: PUSH
84853: LD_INT 1
84855: NEG
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 1
84863: NEG
84864: PUSH
84865: LD_INT 2
84867: NEG
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: LD_INT 2
84878: NEG
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: LD_INT 1
84889: NEG
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 2
84897: PUSH
84898: LD_INT 0
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 2
84907: PUSH
84908: LD_INT 1
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 2
84917: PUSH
84918: LD_INT 2
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: PUSH
84928: LD_INT 2
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 0
84937: PUSH
84938: LD_INT 2
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 1
84947: NEG
84948: PUSH
84949: LD_INT 1
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 2
84958: NEG
84959: PUSH
84960: LD_INT 0
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 2
84969: NEG
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 2
84981: NEG
84982: PUSH
84983: LD_INT 2
84985: NEG
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85012: LD_ADDR_VAR 0 56
85016: PUSH
85017: LD_INT 0
85019: PUSH
85020: LD_INT 0
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 0
85029: PUSH
85030: LD_INT 1
85032: NEG
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 1
85040: PUSH
85041: LD_INT 0
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: PUSH
85051: LD_INT 1
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 0
85060: PUSH
85061: LD_INT 1
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 1
85070: NEG
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 1
85081: NEG
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: LD_INT 2
85097: NEG
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 0
85105: PUSH
85106: LD_INT 2
85108: NEG
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: LD_INT 1
85119: NEG
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 2
85127: PUSH
85128: LD_INT 0
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: PUSH
85135: LD_INT 2
85137: PUSH
85138: LD_INT 1
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 2
85147: PUSH
85148: LD_INT 2
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 1
85157: PUSH
85158: LD_INT 2
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_INT 0
85167: PUSH
85168: LD_INT 2
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 1
85177: NEG
85178: PUSH
85179: LD_INT 1
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 2
85188: NEG
85189: PUSH
85190: LD_INT 0
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_INT 2
85199: NEG
85200: PUSH
85201: LD_INT 1
85203: NEG
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 2
85211: NEG
85212: PUSH
85213: LD_INT 2
85215: NEG
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85242: LD_ADDR_VAR 0 57
85246: PUSH
85247: LD_INT 0
85249: PUSH
85250: LD_INT 0
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: LD_INT 1
85262: NEG
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: LD_INT 0
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 1
85280: PUSH
85281: LD_INT 1
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 0
85290: PUSH
85291: LD_INT 1
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 1
85300: NEG
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 1
85311: NEG
85312: PUSH
85313: LD_INT 1
85315: NEG
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 1
85323: NEG
85324: PUSH
85325: LD_INT 2
85327: NEG
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 0
85335: PUSH
85336: LD_INT 2
85338: NEG
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 1
85346: PUSH
85347: LD_INT 1
85349: NEG
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 2
85357: PUSH
85358: LD_INT 0
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 2
85367: PUSH
85368: LD_INT 1
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 2
85377: PUSH
85378: LD_INT 2
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: PUSH
85388: LD_INT 2
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PUSH
85395: LD_INT 0
85397: PUSH
85398: LD_INT 2
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 1
85407: NEG
85408: PUSH
85409: LD_INT 1
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 2
85418: NEG
85419: PUSH
85420: LD_INT 0
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 2
85429: NEG
85430: PUSH
85431: LD_INT 1
85433: NEG
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 2
85441: NEG
85442: PUSH
85443: LD_INT 2
85445: NEG
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85472: LD_ADDR_VAR 0 58
85476: PUSH
85477: LD_INT 0
85479: PUSH
85480: LD_INT 0
85482: PUSH
85483: EMPTY
85484: LIST
85485: LIST
85486: PUSH
85487: LD_INT 0
85489: PUSH
85490: LD_INT 1
85492: NEG
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: PUSH
85498: LD_INT 1
85500: PUSH
85501: LD_INT 0
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: PUSH
85508: LD_INT 1
85510: PUSH
85511: LD_INT 1
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 0
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 1
85530: NEG
85531: PUSH
85532: LD_INT 0
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 1
85541: NEG
85542: PUSH
85543: LD_INT 1
85545: NEG
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 2
85557: NEG
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: LD_INT 2
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 1
85576: PUSH
85577: LD_INT 1
85579: NEG
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: LD_INT 2
85587: PUSH
85588: LD_INT 0
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: PUSH
85595: LD_INT 2
85597: PUSH
85598: LD_INT 1
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 2
85607: PUSH
85608: LD_INT 2
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PUSH
85615: LD_INT 1
85617: PUSH
85618: LD_INT 2
85620: PUSH
85621: EMPTY
85622: LIST
85623: LIST
85624: PUSH
85625: LD_INT 0
85627: PUSH
85628: LD_INT 2
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 1
85637: NEG
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 2
85648: NEG
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 2
85659: NEG
85660: PUSH
85661: LD_INT 1
85663: NEG
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 2
85671: NEG
85672: PUSH
85673: LD_INT 2
85675: NEG
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85702: LD_ADDR_VAR 0 59
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 1
85722: NEG
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 1
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 0
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: NEG
85761: PUSH
85762: LD_INT 0
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 1
85771: NEG
85772: PUSH
85773: LD_INT 1
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85790: LD_ADDR_VAR 0 60
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: LD_INT 0
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 0
85807: PUSH
85808: LD_INT 1
85810: NEG
85811: PUSH
85812: EMPTY
85813: LIST
85814: LIST
85815: PUSH
85816: LD_INT 1
85818: PUSH
85819: LD_INT 0
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: LD_INT 1
85828: PUSH
85829: LD_INT 1
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 0
85838: PUSH
85839: LD_INT 1
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 1
85848: NEG
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 1
85859: NEG
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85878: LD_ADDR_VAR 0 61
85882: PUSH
85883: LD_INT 0
85885: PUSH
85886: LD_INT 0
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PUSH
85893: LD_INT 0
85895: PUSH
85896: LD_INT 1
85898: NEG
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 1
85906: PUSH
85907: LD_INT 0
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: PUSH
85917: LD_INT 1
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: LD_INT 0
85926: PUSH
85927: LD_INT 1
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 1
85936: NEG
85937: PUSH
85938: LD_INT 0
85940: PUSH
85941: EMPTY
85942: LIST
85943: LIST
85944: PUSH
85945: LD_INT 1
85947: NEG
85948: PUSH
85949: LD_INT 1
85951: NEG
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85966: LD_ADDR_VAR 0 62
85970: PUSH
85971: LD_INT 0
85973: PUSH
85974: LD_INT 0
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 0
85983: PUSH
85984: LD_INT 1
85986: NEG
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 1
85994: PUSH
85995: LD_INT 0
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: LD_INT 1
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: LD_INT 1
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: NEG
86025: PUSH
86026: LD_INT 0
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 1
86035: NEG
86036: PUSH
86037: LD_INT 1
86039: NEG
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86054: LD_ADDR_VAR 0 63
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PUSH
86069: LD_INT 0
86071: PUSH
86072: LD_INT 1
86074: NEG
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 1
86082: PUSH
86083: LD_INT 0
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 1
86092: PUSH
86093: LD_INT 1
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 0
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 1
86112: NEG
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: NEG
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86142: LD_ADDR_VAR 0 64
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: LD_INT 0
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 0
86159: PUSH
86160: LD_INT 1
86162: NEG
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 1
86170: PUSH
86171: LD_INT 0
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 1
86180: PUSH
86181: LD_INT 1
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 0
86190: PUSH
86191: LD_INT 1
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 1
86200: NEG
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 1
86211: NEG
86212: PUSH
86213: LD_INT 1
86215: NEG
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: ST_TO_ADDR
// end ; 1 :
86230: GO 92127
86232: LD_INT 1
86234: DOUBLE
86235: EQUAL
86236: IFTRUE 86240
86238: GO 88863
86240: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86241: LD_ADDR_VAR 0 11
86245: PUSH
86246: LD_INT 1
86248: NEG
86249: PUSH
86250: LD_INT 3
86252: NEG
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: LD_INT 3
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: LIST
86284: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86285: LD_ADDR_VAR 0 12
86289: PUSH
86290: LD_INT 2
86292: PUSH
86293: LD_INT 1
86295: NEG
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 3
86303: PUSH
86304: LD_INT 0
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 3
86313: PUSH
86314: LD_INT 1
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: LIST
86325: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86326: LD_ADDR_VAR 0 13
86330: PUSH
86331: LD_INT 3
86333: PUSH
86334: LD_INT 2
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 3
86343: PUSH
86344: LD_INT 3
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: PUSH
86351: LD_INT 2
86353: PUSH
86354: LD_INT 3
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: LIST
86365: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86366: LD_ADDR_VAR 0 14
86370: PUSH
86371: LD_INT 1
86373: PUSH
86374: LD_INT 3
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 0
86383: PUSH
86384: LD_INT 3
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 1
86393: NEG
86394: PUSH
86395: LD_INT 2
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: LIST
86406: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86407: LD_ADDR_VAR 0 15
86411: PUSH
86412: LD_INT 2
86414: NEG
86415: PUSH
86416: LD_INT 1
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_INT 3
86425: NEG
86426: PUSH
86427: LD_INT 0
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 3
86436: NEG
86437: PUSH
86438: LD_INT 1
86440: NEG
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: LIST
86450: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86451: LD_ADDR_VAR 0 16
86455: PUSH
86456: LD_INT 2
86458: NEG
86459: PUSH
86460: LD_INT 3
86462: NEG
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 3
86470: NEG
86471: PUSH
86472: LD_INT 2
86474: NEG
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 3
86482: NEG
86483: PUSH
86484: LD_INT 3
86486: NEG
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: LIST
86496: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86497: LD_ADDR_VAR 0 17
86501: PUSH
86502: LD_INT 1
86504: NEG
86505: PUSH
86506: LD_INT 3
86508: NEG
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 0
86516: PUSH
86517: LD_INT 3
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 1
86527: PUSH
86528: LD_INT 2
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: LIST
86540: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86541: LD_ADDR_VAR 0 18
86545: PUSH
86546: LD_INT 2
86548: PUSH
86549: LD_INT 1
86551: NEG
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: PUSH
86557: LD_INT 3
86559: PUSH
86560: LD_INT 0
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 3
86569: PUSH
86570: LD_INT 1
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: LIST
86581: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86582: LD_ADDR_VAR 0 19
86586: PUSH
86587: LD_INT 3
86589: PUSH
86590: LD_INT 2
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 3
86599: PUSH
86600: LD_INT 3
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 2
86609: PUSH
86610: LD_INT 3
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: LIST
86621: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86622: LD_ADDR_VAR 0 20
86626: PUSH
86627: LD_INT 1
86629: PUSH
86630: LD_INT 3
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: LD_INT 0
86639: PUSH
86640: LD_INT 3
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 1
86649: NEG
86650: PUSH
86651: LD_INT 2
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: LIST
86662: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86663: LD_ADDR_VAR 0 21
86667: PUSH
86668: LD_INT 2
86670: NEG
86671: PUSH
86672: LD_INT 1
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 3
86681: NEG
86682: PUSH
86683: LD_INT 0
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 3
86692: NEG
86693: PUSH
86694: LD_INT 1
86696: NEG
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: LIST
86706: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86707: LD_ADDR_VAR 0 22
86711: PUSH
86712: LD_INT 2
86714: NEG
86715: PUSH
86716: LD_INT 3
86718: NEG
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 3
86726: NEG
86727: PUSH
86728: LD_INT 2
86730: NEG
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 3
86738: NEG
86739: PUSH
86740: LD_INT 3
86742: NEG
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: LIST
86752: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
86753: LD_ADDR_VAR 0 23
86757: PUSH
86758: LD_INT 0
86760: PUSH
86761: LD_INT 3
86763: NEG
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 1
86771: NEG
86772: PUSH
86773: LD_INT 4
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: LD_INT 3
86786: NEG
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: LIST
86796: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
86797: LD_ADDR_VAR 0 24
86801: PUSH
86802: LD_INT 3
86804: PUSH
86805: LD_INT 0
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 3
86814: PUSH
86815: LD_INT 1
86817: NEG
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 4
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: LIST
86837: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
86838: LD_ADDR_VAR 0 25
86842: PUSH
86843: LD_INT 3
86845: PUSH
86846: LD_INT 3
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PUSH
86853: LD_INT 4
86855: PUSH
86856: LD_INT 3
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 3
86865: PUSH
86866: LD_INT 4
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: LIST
86877: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
86878: LD_ADDR_VAR 0 26
86882: PUSH
86883: LD_INT 0
86885: PUSH
86886: LD_INT 3
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: LD_INT 1
86895: PUSH
86896: LD_INT 4
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 1
86905: NEG
86906: PUSH
86907: LD_INT 3
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: LIST
86918: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
86919: LD_ADDR_VAR 0 27
86923: PUSH
86924: LD_INT 3
86926: NEG
86927: PUSH
86928: LD_INT 0
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: PUSH
86935: LD_INT 3
86937: NEG
86938: PUSH
86939: LD_INT 1
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: LD_INT 4
86948: NEG
86949: PUSH
86950: LD_INT 1
86952: NEG
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: LIST
86962: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
86963: LD_ADDR_VAR 0 28
86967: PUSH
86968: LD_INT 3
86970: NEG
86971: PUSH
86972: LD_INT 3
86974: NEG
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 3
86982: NEG
86983: PUSH
86984: LD_INT 4
86986: NEG
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 4
86994: NEG
86995: PUSH
86996: LD_INT 3
86998: NEG
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: LIST
87008: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
87009: LD_ADDR_VAR 0 29
87013: PUSH
87014: LD_INT 1
87016: NEG
87017: PUSH
87018: LD_INT 3
87020: NEG
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PUSH
87026: LD_INT 0
87028: PUSH
87029: LD_INT 3
87031: NEG
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: LD_INT 1
87039: PUSH
87040: LD_INT 2
87042: NEG
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 1
87050: NEG
87051: PUSH
87052: LD_INT 4
87054: NEG
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: LD_INT 4
87065: NEG
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 1
87073: PUSH
87074: LD_INT 3
87076: NEG
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 1
87084: NEG
87085: PUSH
87086: LD_INT 5
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 0
87096: PUSH
87097: LD_INT 5
87099: NEG
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 1
87107: PUSH
87108: LD_INT 4
87110: NEG
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PUSH
87116: LD_INT 1
87118: NEG
87119: PUSH
87120: LD_INT 6
87122: NEG
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: LD_INT 6
87133: NEG
87134: PUSH
87135: EMPTY
87136: LIST
87137: LIST
87138: PUSH
87139: LD_INT 1
87141: PUSH
87142: LD_INT 5
87144: NEG
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
87164: LD_ADDR_VAR 0 30
87168: PUSH
87169: LD_INT 2
87171: PUSH
87172: LD_INT 1
87174: NEG
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 3
87182: PUSH
87183: LD_INT 0
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 3
87192: PUSH
87193: LD_INT 1
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 3
87202: PUSH
87203: LD_INT 1
87205: NEG
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 4
87213: PUSH
87214: LD_INT 0
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 4
87223: PUSH
87224: LD_INT 1
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 4
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 5
87244: PUSH
87245: LD_INT 0
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 5
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 5
87264: PUSH
87265: LD_INT 1
87267: NEG
87268: PUSH
87269: EMPTY
87270: LIST
87271: LIST
87272: PUSH
87273: LD_INT 6
87275: PUSH
87276: LD_INT 0
87278: PUSH
87279: EMPTY
87280: LIST
87281: LIST
87282: PUSH
87283: LD_INT 6
87285: PUSH
87286: LD_INT 1
87288: PUSH
87289: EMPTY
87290: LIST
87291: LIST
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: LIST
87297: LIST
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: LIST
87306: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
87307: LD_ADDR_VAR 0 31
87311: PUSH
87312: LD_INT 3
87314: PUSH
87315: LD_INT 2
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 3
87324: PUSH
87325: LD_INT 3
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 2
87334: PUSH
87335: LD_INT 3
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 4
87344: PUSH
87345: LD_INT 3
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 4
87354: PUSH
87355: LD_INT 4
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 3
87364: PUSH
87365: LD_INT 4
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 5
87374: PUSH
87375: LD_INT 4
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 5
87384: PUSH
87385: LD_INT 5
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 4
87394: PUSH
87395: LD_INT 5
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 6
87404: PUSH
87405: LD_INT 5
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: LD_INT 6
87414: PUSH
87415: LD_INT 6
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 5
87424: PUSH
87425: LD_INT 6
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
87446: LD_ADDR_VAR 0 32
87450: PUSH
87451: LD_INT 1
87453: PUSH
87454: LD_INT 3
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: LD_INT 3
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 1
87473: NEG
87474: PUSH
87475: LD_INT 2
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 1
87484: PUSH
87485: LD_INT 4
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 0
87494: PUSH
87495: LD_INT 4
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: NEG
87505: PUSH
87506: LD_INT 3
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 1
87515: PUSH
87516: LD_INT 5
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 0
87525: PUSH
87526: LD_INT 5
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 1
87535: NEG
87536: PUSH
87537: LD_INT 4
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: PUSH
87544: LD_INT 1
87546: PUSH
87547: LD_INT 6
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: PUSH
87554: LD_INT 0
87556: PUSH
87557: LD_INT 6
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: PUSH
87564: LD_INT 1
87566: NEG
87567: PUSH
87568: LD_INT 5
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
87589: LD_ADDR_VAR 0 33
87593: PUSH
87594: LD_INT 2
87596: NEG
87597: PUSH
87598: LD_INT 1
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 3
87607: NEG
87608: PUSH
87609: LD_INT 0
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 3
87618: NEG
87619: PUSH
87620: LD_INT 1
87622: NEG
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 3
87630: NEG
87631: PUSH
87632: LD_INT 1
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 4
87641: NEG
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 4
87652: NEG
87653: PUSH
87654: LD_INT 1
87656: NEG
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 4
87664: NEG
87665: PUSH
87666: LD_INT 1
87668: PUSH
87669: EMPTY
87670: LIST
87671: LIST
87672: PUSH
87673: LD_INT 5
87675: NEG
87676: PUSH
87677: LD_INT 0
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 5
87686: NEG
87687: PUSH
87688: LD_INT 1
87690: NEG
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 5
87698: NEG
87699: PUSH
87700: LD_INT 1
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 6
87709: NEG
87710: PUSH
87711: LD_INT 0
87713: PUSH
87714: EMPTY
87715: LIST
87716: LIST
87717: PUSH
87718: LD_INT 6
87720: NEG
87721: PUSH
87722: LD_INT 1
87724: NEG
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
87744: LD_ADDR_VAR 0 34
87748: PUSH
87749: LD_INT 2
87751: NEG
87752: PUSH
87753: LD_INT 3
87755: NEG
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 3
87763: NEG
87764: PUSH
87765: LD_INT 2
87767: NEG
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: LD_INT 3
87775: NEG
87776: PUSH
87777: LD_INT 3
87779: NEG
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: PUSH
87785: LD_INT 3
87787: NEG
87788: PUSH
87789: LD_INT 4
87791: NEG
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 4
87799: NEG
87800: PUSH
87801: LD_INT 3
87803: NEG
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 4
87811: NEG
87812: PUSH
87813: LD_INT 4
87815: NEG
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: PUSH
87821: LD_INT 4
87823: NEG
87824: PUSH
87825: LD_INT 5
87827: NEG
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 5
87835: NEG
87836: PUSH
87837: LD_INT 4
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 5
87847: NEG
87848: PUSH
87849: LD_INT 5
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 5
87859: NEG
87860: PUSH
87861: LD_INT 6
87863: NEG
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 6
87871: NEG
87872: PUSH
87873: LD_INT 5
87875: NEG
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 6
87883: NEG
87884: PUSH
87885: LD_INT 6
87887: NEG
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
87907: LD_ADDR_VAR 0 41
87911: PUSH
87912: LD_INT 0
87914: PUSH
87915: LD_INT 2
87917: NEG
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 1
87925: NEG
87926: PUSH
87927: LD_INT 3
87929: NEG
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: LD_INT 2
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: LIST
87950: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
87951: LD_ADDR_VAR 0 42
87955: PUSH
87956: LD_INT 2
87958: PUSH
87959: LD_INT 0
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: PUSH
87969: LD_INT 1
87971: NEG
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 3
87979: PUSH
87980: LD_INT 1
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: LIST
87991: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
87992: LD_ADDR_VAR 0 43
87996: PUSH
87997: LD_INT 2
87999: PUSH
88000: LD_INT 2
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 3
88009: PUSH
88010: LD_INT 2
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: LD_INT 2
88019: PUSH
88020: LD_INT 3
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: LIST
88031: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
88032: LD_ADDR_VAR 0 44
88036: PUSH
88037: LD_INT 0
88039: PUSH
88040: LD_INT 2
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: LD_INT 1
88049: PUSH
88050: LD_INT 3
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 1
88059: NEG
88060: PUSH
88061: LD_INT 2
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: LIST
88072: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88073: LD_ADDR_VAR 0 45
88077: PUSH
88078: LD_INT 2
88080: NEG
88081: PUSH
88082: LD_INT 0
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: LD_INT 1
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 3
88102: NEG
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: LIST
88116: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
88117: LD_ADDR_VAR 0 46
88121: PUSH
88122: LD_INT 2
88124: NEG
88125: PUSH
88126: LD_INT 2
88128: NEG
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 2
88136: NEG
88137: PUSH
88138: LD_INT 3
88140: NEG
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: LD_INT 3
88148: NEG
88149: PUSH
88150: LD_INT 2
88152: NEG
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: LIST
88162: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
88163: LD_ADDR_VAR 0 47
88167: PUSH
88168: LD_INT 2
88170: NEG
88171: PUSH
88172: LD_INT 3
88174: NEG
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 1
88182: NEG
88183: PUSH
88184: LD_INT 3
88186: NEG
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88196: LD_ADDR_VAR 0 48
88200: PUSH
88201: LD_INT 1
88203: PUSH
88204: LD_INT 2
88206: NEG
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: LD_INT 2
88214: PUSH
88215: LD_INT 1
88217: NEG
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
88227: LD_ADDR_VAR 0 49
88231: PUSH
88232: LD_INT 3
88234: PUSH
88235: LD_INT 1
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: LD_INT 3
88244: PUSH
88245: LD_INT 2
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
88256: LD_ADDR_VAR 0 50
88260: PUSH
88261: LD_INT 2
88263: PUSH
88264: LD_INT 3
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 1
88273: PUSH
88274: LD_INT 3
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88285: LD_ADDR_VAR 0 51
88289: PUSH
88290: LD_INT 1
88292: NEG
88293: PUSH
88294: LD_INT 2
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 2
88303: NEG
88304: PUSH
88305: LD_INT 1
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88316: LD_ADDR_VAR 0 52
88320: PUSH
88321: LD_INT 3
88323: NEG
88324: PUSH
88325: LD_INT 1
88327: NEG
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 3
88335: NEG
88336: PUSH
88337: LD_INT 2
88339: NEG
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: PUSH
88345: EMPTY
88346: LIST
88347: LIST
88348: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88349: LD_ADDR_VAR 0 53
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: LD_INT 3
88360: NEG
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: LD_INT 3
88371: NEG
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 1
88379: PUSH
88380: LD_INT 2
88382: NEG
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: LIST
88392: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88393: LD_ADDR_VAR 0 54
88397: PUSH
88398: LD_INT 2
88400: PUSH
88401: LD_INT 1
88403: NEG
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 3
88411: PUSH
88412: LD_INT 0
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 3
88421: PUSH
88422: LD_INT 1
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: LIST
88433: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88434: LD_ADDR_VAR 0 55
88438: PUSH
88439: LD_INT 3
88441: PUSH
88442: LD_INT 2
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 3
88451: PUSH
88452: LD_INT 3
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 2
88461: PUSH
88462: LD_INT 3
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: LIST
88473: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88474: LD_ADDR_VAR 0 56
88478: PUSH
88479: LD_INT 1
88481: PUSH
88482: LD_INT 3
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 0
88491: PUSH
88492: LD_INT 3
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 1
88501: NEG
88502: PUSH
88503: LD_INT 2
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: LIST
88514: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88515: LD_ADDR_VAR 0 57
88519: PUSH
88520: LD_INT 2
88522: NEG
88523: PUSH
88524: LD_INT 1
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 3
88533: NEG
88534: PUSH
88535: LD_INT 0
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 3
88544: NEG
88545: PUSH
88546: LD_INT 1
88548: NEG
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: LIST
88558: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88559: LD_ADDR_VAR 0 58
88563: PUSH
88564: LD_INT 2
88566: NEG
88567: PUSH
88568: LD_INT 3
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 3
88578: NEG
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 3
88590: NEG
88591: PUSH
88592: LD_INT 3
88594: NEG
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: LIST
88604: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
88605: LD_ADDR_VAR 0 59
88609: PUSH
88610: LD_INT 1
88612: NEG
88613: PUSH
88614: LD_INT 2
88616: NEG
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: LD_INT 0
88624: PUSH
88625: LD_INT 2
88627: NEG
88628: PUSH
88629: EMPTY
88630: LIST
88631: LIST
88632: PUSH
88633: LD_INT 1
88635: PUSH
88636: LD_INT 1
88638: NEG
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: LIST
88648: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88649: LD_ADDR_VAR 0 60
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: LD_INT 1
88659: NEG
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 2
88667: PUSH
88668: LD_INT 0
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: LD_INT 2
88677: PUSH
88678: LD_INT 1
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: LIST
88689: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88690: LD_ADDR_VAR 0 61
88694: PUSH
88695: LD_INT 2
88697: PUSH
88698: LD_INT 1
88700: PUSH
88701: EMPTY
88702: LIST
88703: LIST
88704: PUSH
88705: LD_INT 2
88707: PUSH
88708: LD_INT 2
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: LD_INT 1
88717: PUSH
88718: LD_INT 2
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: LIST
88729: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88730: LD_ADDR_VAR 0 62
88734: PUSH
88735: LD_INT 1
88737: PUSH
88738: LD_INT 2
88740: PUSH
88741: EMPTY
88742: LIST
88743: LIST
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: LD_INT 2
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: LD_INT 1
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: LIST
88770: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88771: LD_ADDR_VAR 0 63
88775: PUSH
88776: LD_INT 1
88778: NEG
88779: PUSH
88780: LD_INT 1
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 2
88789: NEG
88790: PUSH
88791: LD_INT 0
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 2
88800: NEG
88801: PUSH
88802: LD_INT 1
88804: NEG
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: LIST
88814: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88815: LD_ADDR_VAR 0 64
88819: PUSH
88820: LD_INT 1
88822: NEG
88823: PUSH
88824: LD_INT 2
88826: NEG
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PUSH
88832: LD_INT 2
88834: NEG
88835: PUSH
88836: LD_INT 1
88838: NEG
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 2
88846: NEG
88847: PUSH
88848: LD_INT 2
88850: NEG
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: LIST
88860: ST_TO_ADDR
// end ; 2 :
88861: GO 92127
88863: LD_INT 2
88865: DOUBLE
88866: EQUAL
88867: IFTRUE 88871
88869: GO 92126
88871: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
88872: LD_ADDR_VAR 0 29
88876: PUSH
88877: LD_INT 4
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 4
88889: PUSH
88890: LD_INT 1
88892: NEG
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 5
88900: PUSH
88901: LD_INT 0
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 5
88910: PUSH
88911: LD_INT 1
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 4
88920: PUSH
88921: LD_INT 1
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 3
88930: PUSH
88931: LD_INT 0
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 3
88940: PUSH
88941: LD_INT 1
88943: NEG
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 3
88951: PUSH
88952: LD_INT 2
88954: NEG
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 5
88962: PUSH
88963: LD_INT 2
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 3
88972: PUSH
88973: LD_INT 3
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 3
88982: PUSH
88983: LD_INT 2
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: LD_INT 4
88992: PUSH
88993: LD_INT 3
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 4
89002: PUSH
89003: LD_INT 4
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 3
89012: PUSH
89013: LD_INT 4
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: LD_INT 2
89022: PUSH
89023: LD_INT 3
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 2
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 4
89042: PUSH
89043: LD_INT 2
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 2
89052: PUSH
89053: LD_INT 4
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 0
89062: PUSH
89063: LD_INT 4
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: PUSH
89070: LD_INT 0
89072: PUSH
89073: LD_INT 3
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 1
89082: PUSH
89083: LD_INT 4
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 1
89092: PUSH
89093: LD_INT 5
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 0
89102: PUSH
89103: LD_INT 5
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 1
89112: NEG
89113: PUSH
89114: LD_INT 4
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 1
89123: NEG
89124: PUSH
89125: LD_INT 3
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 2
89134: PUSH
89135: LD_INT 5
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 2
89144: NEG
89145: PUSH
89146: LD_INT 3
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 3
89155: NEG
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 3
89166: NEG
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 2
89178: NEG
89179: PUSH
89180: LD_INT 0
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 2
89189: NEG
89190: PUSH
89191: LD_INT 1
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: LD_INT 3
89200: NEG
89201: PUSH
89202: LD_INT 1
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: PUSH
89209: LD_INT 4
89211: NEG
89212: PUSH
89213: LD_INT 0
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 4
89222: NEG
89223: PUSH
89224: LD_INT 1
89226: NEG
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 4
89234: NEG
89235: PUSH
89236: LD_INT 2
89238: NEG
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 2
89246: NEG
89247: PUSH
89248: LD_INT 2
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 4
89257: NEG
89258: PUSH
89259: LD_INT 4
89261: NEG
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PUSH
89267: LD_INT 4
89269: NEG
89270: PUSH
89271: LD_INT 5
89273: NEG
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 3
89281: NEG
89282: PUSH
89283: LD_INT 4
89285: NEG
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: PUSH
89291: LD_INT 3
89293: NEG
89294: PUSH
89295: LD_INT 3
89297: NEG
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 4
89305: NEG
89306: PUSH
89307: LD_INT 3
89309: NEG
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PUSH
89315: LD_INT 5
89317: NEG
89318: PUSH
89319: LD_INT 4
89321: NEG
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: PUSH
89327: LD_INT 5
89329: NEG
89330: PUSH
89331: LD_INT 5
89333: NEG
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 3
89341: NEG
89342: PUSH
89343: LD_INT 5
89345: NEG
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 5
89353: NEG
89354: PUSH
89355: LD_INT 3
89357: NEG
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
89410: LD_ADDR_VAR 0 30
89414: PUSH
89415: LD_INT 4
89417: PUSH
89418: LD_INT 4
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: LD_INT 4
89427: PUSH
89428: LD_INT 3
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 5
89437: PUSH
89438: LD_INT 4
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: PUSH
89445: LD_INT 5
89447: PUSH
89448: LD_INT 5
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 4
89457: PUSH
89458: LD_INT 5
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 3
89467: PUSH
89468: LD_INT 4
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 3
89477: PUSH
89478: LD_INT 3
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 5
89487: PUSH
89488: LD_INT 3
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: LD_INT 3
89497: PUSH
89498: LD_INT 5
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 0
89507: PUSH
89508: LD_INT 3
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 0
89517: PUSH
89518: LD_INT 2
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 1
89527: PUSH
89528: LD_INT 3
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: LD_INT 4
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: LD_INT 4
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 1
89557: NEG
89558: PUSH
89559: LD_INT 3
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PUSH
89566: LD_INT 1
89568: NEG
89569: PUSH
89570: LD_INT 2
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 2
89579: PUSH
89580: LD_INT 4
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: LD_INT 2
89589: NEG
89590: PUSH
89591: LD_INT 2
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 4
89600: NEG
89601: PUSH
89602: LD_INT 0
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 4
89611: NEG
89612: PUSH
89613: LD_INT 1
89615: NEG
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 3
89623: NEG
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 3
89634: NEG
89635: PUSH
89636: LD_INT 1
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 4
89645: NEG
89646: PUSH
89647: LD_INT 1
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: PUSH
89654: LD_INT 5
89656: NEG
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: LD_INT 5
89667: NEG
89668: PUSH
89669: LD_INT 1
89671: NEG
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 5
89679: NEG
89680: PUSH
89681: LD_INT 2
89683: NEG
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 3
89691: NEG
89692: PUSH
89693: LD_INT 2
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 3
89702: NEG
89703: PUSH
89704: LD_INT 3
89706: NEG
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 3
89714: NEG
89715: PUSH
89716: LD_INT 4
89718: NEG
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 2
89726: NEG
89727: PUSH
89728: LD_INT 3
89730: NEG
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: LD_INT 2
89738: NEG
89739: PUSH
89740: LD_INT 2
89742: NEG
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 3
89750: NEG
89751: PUSH
89752: LD_INT 2
89754: NEG
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 4
89762: NEG
89763: PUSH
89764: LD_INT 3
89766: NEG
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 4
89774: NEG
89775: PUSH
89776: LD_INT 4
89778: NEG
89779: PUSH
89780: EMPTY
89781: LIST
89782: LIST
89783: PUSH
89784: LD_INT 2
89786: NEG
89787: PUSH
89788: LD_INT 4
89790: NEG
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: PUSH
89796: LD_INT 4
89798: NEG
89799: PUSH
89800: LD_INT 2
89802: NEG
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 0
89810: PUSH
89811: LD_INT 4
89813: NEG
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 0
89821: PUSH
89822: LD_INT 5
89824: NEG
89825: PUSH
89826: EMPTY
89827: LIST
89828: LIST
89829: PUSH
89830: LD_INT 1
89832: PUSH
89833: LD_INT 4
89835: NEG
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: LD_INT 3
89846: NEG
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 0
89854: PUSH
89855: LD_INT 3
89857: NEG
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 1
89865: NEG
89866: PUSH
89867: LD_INT 4
89869: NEG
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 1
89877: NEG
89878: PUSH
89879: LD_INT 5
89881: NEG
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 2
89889: PUSH
89890: LD_INT 3
89892: NEG
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 2
89900: NEG
89901: PUSH
89902: LD_INT 5
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
89957: LD_ADDR_VAR 0 31
89961: PUSH
89962: LD_INT 0
89964: PUSH
89965: LD_INT 4
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 0
89974: PUSH
89975: LD_INT 3
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: PUSH
89985: LD_INT 4
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 5
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: LD_INT 5
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 1
90014: NEG
90015: PUSH
90016: LD_INT 4
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: NEG
90026: PUSH
90027: LD_INT 3
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 2
90036: PUSH
90037: LD_INT 5
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 2
90046: NEG
90047: PUSH
90048: LD_INT 3
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 3
90057: NEG
90058: PUSH
90059: LD_INT 0
90061: PUSH
90062: EMPTY
90063: LIST
90064: LIST
90065: PUSH
90066: LD_INT 3
90068: NEG
90069: PUSH
90070: LD_INT 1
90072: NEG
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 2
90080: NEG
90081: PUSH
90082: LD_INT 0
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 2
90091: NEG
90092: PUSH
90093: LD_INT 1
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: LD_INT 3
90102: NEG
90103: PUSH
90104: LD_INT 1
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 4
90113: NEG
90114: PUSH
90115: LD_INT 0
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 4
90124: NEG
90125: PUSH
90126: LD_INT 1
90128: NEG
90129: PUSH
90130: EMPTY
90131: LIST
90132: LIST
90133: PUSH
90134: LD_INT 4
90136: NEG
90137: PUSH
90138: LD_INT 2
90140: NEG
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 2
90148: NEG
90149: PUSH
90150: LD_INT 2
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 4
90159: NEG
90160: PUSH
90161: LD_INT 4
90163: NEG
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 4
90171: NEG
90172: PUSH
90173: LD_INT 5
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 3
90183: NEG
90184: PUSH
90185: LD_INT 4
90187: NEG
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: LD_INT 3
90195: NEG
90196: PUSH
90197: LD_INT 3
90199: NEG
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: PUSH
90205: LD_INT 4
90207: NEG
90208: PUSH
90209: LD_INT 3
90211: NEG
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: PUSH
90217: LD_INT 5
90219: NEG
90220: PUSH
90221: LD_INT 4
90223: NEG
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 5
90231: NEG
90232: PUSH
90233: LD_INT 5
90235: NEG
90236: PUSH
90237: EMPTY
90238: LIST
90239: LIST
90240: PUSH
90241: LD_INT 3
90243: NEG
90244: PUSH
90245: LD_INT 5
90247: NEG
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 5
90255: NEG
90256: PUSH
90257: LD_INT 3
90259: NEG
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 0
90267: PUSH
90268: LD_INT 3
90270: NEG
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: LD_INT 0
90278: PUSH
90279: LD_INT 4
90281: NEG
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 1
90289: PUSH
90290: LD_INT 3
90292: NEG
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: LD_INT 1
90300: PUSH
90301: LD_INT 2
90303: NEG
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 0
90311: PUSH
90312: LD_INT 2
90314: NEG
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 1
90322: NEG
90323: PUSH
90324: LD_INT 3
90326: NEG
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 1
90334: NEG
90335: PUSH
90336: LD_INT 4
90338: NEG
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 2
90346: PUSH
90347: LD_INT 2
90349: NEG
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 2
90357: NEG
90358: PUSH
90359: LD_INT 4
90361: NEG
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: PUSH
90367: LD_INT 4
90369: PUSH
90370: LD_INT 0
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 4
90379: PUSH
90380: LD_INT 1
90382: NEG
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 5
90390: PUSH
90391: LD_INT 0
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: PUSH
90398: LD_INT 5
90400: PUSH
90401: LD_INT 1
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 4
90410: PUSH
90411: LD_INT 1
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 3
90420: PUSH
90421: LD_INT 0
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: LD_INT 3
90430: PUSH
90431: LD_INT 1
90433: NEG
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PUSH
90439: LD_INT 3
90441: PUSH
90442: LD_INT 2
90444: NEG
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: PUSH
90450: LD_INT 5
90452: PUSH
90453: LD_INT 2
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
90507: LD_ADDR_VAR 0 32
90511: PUSH
90512: LD_INT 4
90514: NEG
90515: PUSH
90516: LD_INT 0
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 4
90525: NEG
90526: PUSH
90527: LD_INT 1
90529: NEG
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: LD_INT 3
90537: NEG
90538: PUSH
90539: LD_INT 0
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 3
90548: NEG
90549: PUSH
90550: LD_INT 1
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 4
90559: NEG
90560: PUSH
90561: LD_INT 1
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 5
90570: NEG
90571: PUSH
90572: LD_INT 0
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: LD_INT 5
90581: NEG
90582: PUSH
90583: LD_INT 1
90585: NEG
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 5
90593: NEG
90594: PUSH
90595: LD_INT 2
90597: NEG
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: LD_INT 3
90605: NEG
90606: PUSH
90607: LD_INT 2
90609: PUSH
90610: EMPTY
90611: LIST
90612: LIST
90613: PUSH
90614: LD_INT 3
90616: NEG
90617: PUSH
90618: LD_INT 3
90620: NEG
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 3
90628: NEG
90629: PUSH
90630: LD_INT 4
90632: NEG
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: PUSH
90638: LD_INT 2
90640: NEG
90641: PUSH
90642: LD_INT 3
90644: NEG
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 2
90652: NEG
90653: PUSH
90654: LD_INT 2
90656: NEG
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 3
90664: NEG
90665: PUSH
90666: LD_INT 2
90668: NEG
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 4
90676: NEG
90677: PUSH
90678: LD_INT 3
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 4
90688: NEG
90689: PUSH
90690: LD_INT 4
90692: NEG
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 2
90700: NEG
90701: PUSH
90702: LD_INT 4
90704: NEG
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 4
90712: NEG
90713: PUSH
90714: LD_INT 2
90716: NEG
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: PUSH
90722: LD_INT 0
90724: PUSH
90725: LD_INT 4
90727: NEG
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 0
90735: PUSH
90736: LD_INT 5
90738: NEG
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 1
90746: PUSH
90747: LD_INT 4
90749: NEG
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 1
90757: PUSH
90758: LD_INT 3
90760: NEG
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: LD_INT 0
90768: PUSH
90769: LD_INT 3
90771: NEG
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: LD_INT 1
90779: NEG
90780: PUSH
90781: LD_INT 4
90783: NEG
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 1
90791: NEG
90792: PUSH
90793: LD_INT 5
90795: NEG
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 2
90803: PUSH
90804: LD_INT 3
90806: NEG
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 2
90814: NEG
90815: PUSH
90816: LD_INT 5
90818: NEG
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 3
90826: PUSH
90827: LD_INT 0
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 3
90836: PUSH
90837: LD_INT 1
90839: NEG
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 4
90847: PUSH
90848: LD_INT 0
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 4
90857: PUSH
90858: LD_INT 1
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 3
90867: PUSH
90868: LD_INT 1
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 2
90877: PUSH
90878: LD_INT 0
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 2
90887: PUSH
90888: LD_INT 1
90890: NEG
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 2
90898: PUSH
90899: LD_INT 2
90901: NEG
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 4
90909: PUSH
90910: LD_INT 2
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 4
90919: PUSH
90920: LD_INT 4
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 4
90929: PUSH
90930: LD_INT 3
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 5
90939: PUSH
90940: LD_INT 4
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 5
90949: PUSH
90950: LD_INT 5
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 4
90959: PUSH
90960: LD_INT 5
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 3
90969: PUSH
90970: LD_INT 4
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 3
90979: PUSH
90980: LD_INT 3
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 5
90989: PUSH
90990: LD_INT 3
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 3
90999: PUSH
91000: LD_INT 5
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
91054: LD_ADDR_VAR 0 33
91058: PUSH
91059: LD_INT 4
91061: NEG
91062: PUSH
91063: LD_INT 4
91065: NEG
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 4
91073: NEG
91074: PUSH
91075: LD_INT 5
91077: NEG
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 3
91085: NEG
91086: PUSH
91087: LD_INT 4
91089: NEG
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 3
91097: NEG
91098: PUSH
91099: LD_INT 3
91101: NEG
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: PUSH
91107: LD_INT 4
91109: NEG
91110: PUSH
91111: LD_INT 3
91113: NEG
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 5
91121: NEG
91122: PUSH
91123: LD_INT 4
91125: NEG
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 5
91133: NEG
91134: PUSH
91135: LD_INT 5
91137: NEG
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 3
91145: NEG
91146: PUSH
91147: LD_INT 5
91149: NEG
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 5
91157: NEG
91158: PUSH
91159: LD_INT 3
91161: NEG
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 0
91169: PUSH
91170: LD_INT 3
91172: NEG
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: LD_INT 4
91183: NEG
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 1
91191: PUSH
91192: LD_INT 3
91194: NEG
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 1
91202: PUSH
91203: LD_INT 2
91205: NEG
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: LD_INT 0
91213: PUSH
91214: LD_INT 2
91216: NEG
91217: PUSH
91218: EMPTY
91219: LIST
91220: LIST
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: LD_INT 3
91228: NEG
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 1
91236: NEG
91237: PUSH
91238: LD_INT 4
91240: NEG
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 2
91248: PUSH
91249: LD_INT 2
91251: NEG
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 2
91259: NEG
91260: PUSH
91261: LD_INT 4
91263: NEG
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 4
91271: PUSH
91272: LD_INT 0
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: LD_INT 4
91281: PUSH
91282: LD_INT 1
91284: NEG
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: PUSH
91290: LD_INT 5
91292: PUSH
91293: LD_INT 0
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: PUSH
91300: LD_INT 5
91302: PUSH
91303: LD_INT 1
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 4
91312: PUSH
91313: LD_INT 1
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: PUSH
91320: LD_INT 3
91322: PUSH
91323: LD_INT 0
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 3
91332: PUSH
91333: LD_INT 1
91335: NEG
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 3
91343: PUSH
91344: LD_INT 2
91346: NEG
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 5
91354: PUSH
91355: LD_INT 2
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: PUSH
91362: LD_INT 3
91364: PUSH
91365: LD_INT 3
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: LD_INT 3
91374: PUSH
91375: LD_INT 2
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: PUSH
91382: LD_INT 4
91384: PUSH
91385: LD_INT 3
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PUSH
91392: LD_INT 4
91394: PUSH
91395: LD_INT 4
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PUSH
91402: LD_INT 3
91404: PUSH
91405: LD_INT 4
91407: PUSH
91408: EMPTY
91409: LIST
91410: LIST
91411: PUSH
91412: LD_INT 2
91414: PUSH
91415: LD_INT 3
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: PUSH
91422: LD_INT 2
91424: PUSH
91425: LD_INT 2
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: PUSH
91432: LD_INT 4
91434: PUSH
91435: LD_INT 2
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: LD_INT 2
91444: PUSH
91445: LD_INT 4
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: LD_INT 0
91454: PUSH
91455: LD_INT 4
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 0
91464: PUSH
91465: LD_INT 3
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 1
91474: PUSH
91475: LD_INT 4
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 1
91484: PUSH
91485: LD_INT 5
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: LD_INT 0
91494: PUSH
91495: LD_INT 5
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 1
91504: NEG
91505: PUSH
91506: LD_INT 4
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 1
91515: NEG
91516: PUSH
91517: LD_INT 3
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 2
91526: PUSH
91527: LD_INT 5
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 2
91536: NEG
91537: PUSH
91538: LD_INT 3
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: LIST
91582: LIST
91583: LIST
91584: LIST
91585: LIST
91586: LIST
91587: LIST
91588: LIST
91589: LIST
91590: LIST
91591: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
91592: LD_ADDR_VAR 0 34
91596: PUSH
91597: LD_INT 0
91599: PUSH
91600: LD_INT 4
91602: NEG
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: LD_INT 0
91610: PUSH
91611: LD_INT 5
91613: NEG
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: LD_INT 1
91621: PUSH
91622: LD_INT 4
91624: NEG
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 1
91632: PUSH
91633: LD_INT 3
91635: NEG
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: LD_INT 3
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 1
91654: NEG
91655: PUSH
91656: LD_INT 4
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 1
91666: NEG
91667: PUSH
91668: LD_INT 5
91670: NEG
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 2
91678: PUSH
91679: LD_INT 3
91681: NEG
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 2
91689: NEG
91690: PUSH
91691: LD_INT 5
91693: NEG
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 3
91701: PUSH
91702: LD_INT 0
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: LD_INT 3
91711: PUSH
91712: LD_INT 1
91714: NEG
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 4
91722: PUSH
91723: LD_INT 0
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: LD_INT 4
91732: PUSH
91733: LD_INT 1
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 3
91742: PUSH
91743: LD_INT 1
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 2
91752: PUSH
91753: LD_INT 0
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: LD_INT 2
91762: PUSH
91763: LD_INT 1
91765: NEG
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 2
91773: PUSH
91774: LD_INT 2
91776: NEG
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: PUSH
91782: LD_INT 4
91784: PUSH
91785: LD_INT 2
91787: PUSH
91788: EMPTY
91789: LIST
91790: LIST
91791: PUSH
91792: LD_INT 4
91794: PUSH
91795: LD_INT 4
91797: PUSH
91798: EMPTY
91799: LIST
91800: LIST
91801: PUSH
91802: LD_INT 4
91804: PUSH
91805: LD_INT 3
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 5
91814: PUSH
91815: LD_INT 4
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 5
91824: PUSH
91825: LD_INT 5
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 4
91834: PUSH
91835: LD_INT 5
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 3
91844: PUSH
91845: LD_INT 4
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 3
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 5
91864: PUSH
91865: LD_INT 3
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 3
91874: PUSH
91875: LD_INT 5
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 0
91894: PUSH
91895: LD_INT 2
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: LD_INT 1
91904: PUSH
91905: LD_INT 3
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: LD_INT 1
91914: PUSH
91915: LD_INT 4
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 0
91924: PUSH
91925: LD_INT 4
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: NEG
91935: PUSH
91936: LD_INT 3
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 1
91945: NEG
91946: PUSH
91947: LD_INT 2
91949: PUSH
91950: EMPTY
91951: LIST
91952: LIST
91953: PUSH
91954: LD_INT 2
91956: PUSH
91957: LD_INT 4
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: LD_INT 2
91966: NEG
91967: PUSH
91968: LD_INT 2
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 4
91977: NEG
91978: PUSH
91979: LD_INT 0
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: LD_INT 4
91988: NEG
91989: PUSH
91990: LD_INT 1
91992: NEG
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 3
92000: NEG
92001: PUSH
92002: LD_INT 0
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: PUSH
92009: LD_INT 3
92011: NEG
92012: PUSH
92013: LD_INT 1
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: PUSH
92020: LD_INT 4
92022: NEG
92023: PUSH
92024: LD_INT 1
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 5
92033: NEG
92034: PUSH
92035: LD_INT 0
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: LD_INT 5
92044: NEG
92045: PUSH
92046: LD_INT 1
92048: NEG
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: LD_INT 5
92056: NEG
92057: PUSH
92058: LD_INT 2
92060: NEG
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 3
92068: NEG
92069: PUSH
92070: LD_INT 2
92072: PUSH
92073: EMPTY
92074: LIST
92075: LIST
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: LIST
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: ST_TO_ADDR
// end ; end ;
92124: GO 92127
92126: POP
// case btype of b_depot , b_warehouse :
92127: LD_VAR 0 1
92131: PUSH
92132: LD_INT 0
92134: DOUBLE
92135: EQUAL
92136: IFTRUE 92146
92138: LD_INT 1
92140: DOUBLE
92141: EQUAL
92142: IFTRUE 92146
92144: GO 92347
92146: POP
// case nation of nation_american :
92147: LD_VAR 0 5
92151: PUSH
92152: LD_INT 1
92154: DOUBLE
92155: EQUAL
92156: IFTRUE 92160
92158: GO 92216
92160: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
92161: LD_ADDR_VAR 0 9
92165: PUSH
92166: LD_VAR 0 11
92170: PUSH
92171: LD_VAR 0 12
92175: PUSH
92176: LD_VAR 0 13
92180: PUSH
92181: LD_VAR 0 14
92185: PUSH
92186: LD_VAR 0 15
92190: PUSH
92191: LD_VAR 0 16
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: PUSH
92204: LD_VAR 0 4
92208: PUSH
92209: LD_INT 1
92211: PLUS
92212: ARRAY
92213: ST_TO_ADDR
92214: GO 92345
92216: LD_INT 2
92218: DOUBLE
92219: EQUAL
92220: IFTRUE 92224
92222: GO 92280
92224: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
92225: LD_ADDR_VAR 0 9
92229: PUSH
92230: LD_VAR 0 17
92234: PUSH
92235: LD_VAR 0 18
92239: PUSH
92240: LD_VAR 0 19
92244: PUSH
92245: LD_VAR 0 20
92249: PUSH
92250: LD_VAR 0 21
92254: PUSH
92255: LD_VAR 0 22
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: PUSH
92268: LD_VAR 0 4
92272: PUSH
92273: LD_INT 1
92275: PLUS
92276: ARRAY
92277: ST_TO_ADDR
92278: GO 92345
92280: LD_INT 3
92282: DOUBLE
92283: EQUAL
92284: IFTRUE 92288
92286: GO 92344
92288: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
92289: LD_ADDR_VAR 0 9
92293: PUSH
92294: LD_VAR 0 23
92298: PUSH
92299: LD_VAR 0 24
92303: PUSH
92304: LD_VAR 0 25
92308: PUSH
92309: LD_VAR 0 26
92313: PUSH
92314: LD_VAR 0 27
92318: PUSH
92319: LD_VAR 0 28
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: PUSH
92332: LD_VAR 0 4
92336: PUSH
92337: LD_INT 1
92339: PLUS
92340: ARRAY
92341: ST_TO_ADDR
92342: GO 92345
92344: POP
92345: GO 92900
92347: LD_INT 2
92349: DOUBLE
92350: EQUAL
92351: IFTRUE 92361
92353: LD_INT 3
92355: DOUBLE
92356: EQUAL
92357: IFTRUE 92361
92359: GO 92417
92361: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
92362: LD_ADDR_VAR 0 9
92366: PUSH
92367: LD_VAR 0 29
92371: PUSH
92372: LD_VAR 0 30
92376: PUSH
92377: LD_VAR 0 31
92381: PUSH
92382: LD_VAR 0 32
92386: PUSH
92387: LD_VAR 0 33
92391: PUSH
92392: LD_VAR 0 34
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: PUSH
92405: LD_VAR 0 4
92409: PUSH
92410: LD_INT 1
92412: PLUS
92413: ARRAY
92414: ST_TO_ADDR
92415: GO 92900
92417: LD_INT 16
92419: DOUBLE
92420: EQUAL
92421: IFTRUE 92479
92423: LD_INT 17
92425: DOUBLE
92426: EQUAL
92427: IFTRUE 92479
92429: LD_INT 18
92431: DOUBLE
92432: EQUAL
92433: IFTRUE 92479
92435: LD_INT 19
92437: DOUBLE
92438: EQUAL
92439: IFTRUE 92479
92441: LD_INT 22
92443: DOUBLE
92444: EQUAL
92445: IFTRUE 92479
92447: LD_INT 20
92449: DOUBLE
92450: EQUAL
92451: IFTRUE 92479
92453: LD_INT 21
92455: DOUBLE
92456: EQUAL
92457: IFTRUE 92479
92459: LD_INT 23
92461: DOUBLE
92462: EQUAL
92463: IFTRUE 92479
92465: LD_INT 24
92467: DOUBLE
92468: EQUAL
92469: IFTRUE 92479
92471: LD_INT 25
92473: DOUBLE
92474: EQUAL
92475: IFTRUE 92479
92477: GO 92535
92479: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
92480: LD_ADDR_VAR 0 9
92484: PUSH
92485: LD_VAR 0 35
92489: PUSH
92490: LD_VAR 0 36
92494: PUSH
92495: LD_VAR 0 37
92499: PUSH
92500: LD_VAR 0 38
92504: PUSH
92505: LD_VAR 0 39
92509: PUSH
92510: LD_VAR 0 40
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: PUSH
92523: LD_VAR 0 4
92527: PUSH
92528: LD_INT 1
92530: PLUS
92531: ARRAY
92532: ST_TO_ADDR
92533: GO 92900
92535: LD_INT 6
92537: DOUBLE
92538: EQUAL
92539: IFTRUE 92591
92541: LD_INT 7
92543: DOUBLE
92544: EQUAL
92545: IFTRUE 92591
92547: LD_INT 8
92549: DOUBLE
92550: EQUAL
92551: IFTRUE 92591
92553: LD_INT 13
92555: DOUBLE
92556: EQUAL
92557: IFTRUE 92591
92559: LD_INT 12
92561: DOUBLE
92562: EQUAL
92563: IFTRUE 92591
92565: LD_INT 15
92567: DOUBLE
92568: EQUAL
92569: IFTRUE 92591
92571: LD_INT 11
92573: DOUBLE
92574: EQUAL
92575: IFTRUE 92591
92577: LD_INT 14
92579: DOUBLE
92580: EQUAL
92581: IFTRUE 92591
92583: LD_INT 10
92585: DOUBLE
92586: EQUAL
92587: IFTRUE 92591
92589: GO 92647
92591: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
92592: LD_ADDR_VAR 0 9
92596: PUSH
92597: LD_VAR 0 41
92601: PUSH
92602: LD_VAR 0 42
92606: PUSH
92607: LD_VAR 0 43
92611: PUSH
92612: LD_VAR 0 44
92616: PUSH
92617: LD_VAR 0 45
92621: PUSH
92622: LD_VAR 0 46
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: PUSH
92635: LD_VAR 0 4
92639: PUSH
92640: LD_INT 1
92642: PLUS
92643: ARRAY
92644: ST_TO_ADDR
92645: GO 92900
92647: LD_INT 36
92649: DOUBLE
92650: EQUAL
92651: IFTRUE 92655
92653: GO 92711
92655: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
92656: LD_ADDR_VAR 0 9
92660: PUSH
92661: LD_VAR 0 47
92665: PUSH
92666: LD_VAR 0 48
92670: PUSH
92671: LD_VAR 0 49
92675: PUSH
92676: LD_VAR 0 50
92680: PUSH
92681: LD_VAR 0 51
92685: PUSH
92686: LD_VAR 0 52
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: PUSH
92699: LD_VAR 0 4
92703: PUSH
92704: LD_INT 1
92706: PLUS
92707: ARRAY
92708: ST_TO_ADDR
92709: GO 92900
92711: LD_INT 4
92713: DOUBLE
92714: EQUAL
92715: IFTRUE 92737
92717: LD_INT 5
92719: DOUBLE
92720: EQUAL
92721: IFTRUE 92737
92723: LD_INT 34
92725: DOUBLE
92726: EQUAL
92727: IFTRUE 92737
92729: LD_INT 37
92731: DOUBLE
92732: EQUAL
92733: IFTRUE 92737
92735: GO 92793
92737: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
92738: LD_ADDR_VAR 0 9
92742: PUSH
92743: LD_VAR 0 53
92747: PUSH
92748: LD_VAR 0 54
92752: PUSH
92753: LD_VAR 0 55
92757: PUSH
92758: LD_VAR 0 56
92762: PUSH
92763: LD_VAR 0 57
92767: PUSH
92768: LD_VAR 0 58
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: PUSH
92781: LD_VAR 0 4
92785: PUSH
92786: LD_INT 1
92788: PLUS
92789: ARRAY
92790: ST_TO_ADDR
92791: GO 92900
92793: LD_INT 31
92795: DOUBLE
92796: EQUAL
92797: IFTRUE 92843
92799: LD_INT 32
92801: DOUBLE
92802: EQUAL
92803: IFTRUE 92843
92805: LD_INT 33
92807: DOUBLE
92808: EQUAL
92809: IFTRUE 92843
92811: LD_INT 27
92813: DOUBLE
92814: EQUAL
92815: IFTRUE 92843
92817: LD_INT 26
92819: DOUBLE
92820: EQUAL
92821: IFTRUE 92843
92823: LD_INT 28
92825: DOUBLE
92826: EQUAL
92827: IFTRUE 92843
92829: LD_INT 29
92831: DOUBLE
92832: EQUAL
92833: IFTRUE 92843
92835: LD_INT 30
92837: DOUBLE
92838: EQUAL
92839: IFTRUE 92843
92841: GO 92899
92843: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
92844: LD_ADDR_VAR 0 9
92848: PUSH
92849: LD_VAR 0 59
92853: PUSH
92854: LD_VAR 0 60
92858: PUSH
92859: LD_VAR 0 61
92863: PUSH
92864: LD_VAR 0 62
92868: PUSH
92869: LD_VAR 0 63
92873: PUSH
92874: LD_VAR 0 64
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: PUSH
92887: LD_VAR 0 4
92891: PUSH
92892: LD_INT 1
92894: PLUS
92895: ARRAY
92896: ST_TO_ADDR
92897: GO 92900
92899: POP
// temp_list2 = [ ] ;
92900: LD_ADDR_VAR 0 10
92904: PUSH
92905: EMPTY
92906: ST_TO_ADDR
// for i in temp_list do
92907: LD_ADDR_VAR 0 8
92911: PUSH
92912: LD_VAR 0 9
92916: PUSH
92917: FOR_IN
92918: IFFALSE 92970
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
92920: LD_ADDR_VAR 0 10
92924: PUSH
92925: LD_VAR 0 10
92929: PUSH
92930: LD_VAR 0 8
92934: PUSH
92935: LD_INT 1
92937: ARRAY
92938: PUSH
92939: LD_VAR 0 2
92943: PLUS
92944: PUSH
92945: LD_VAR 0 8
92949: PUSH
92950: LD_INT 2
92952: ARRAY
92953: PUSH
92954: LD_VAR 0 3
92958: PLUS
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: EMPTY
92965: LIST
92966: ADD
92967: ST_TO_ADDR
92968: GO 92917
92970: POP
92971: POP
// result = temp_list2 ;
92972: LD_ADDR_VAR 0 7
92976: PUSH
92977: LD_VAR 0 10
92981: ST_TO_ADDR
// end ;
92982: LD_VAR 0 7
92986: RET
// export function EnemyInRange ( unit , dist ) ; begin
92987: LD_INT 0
92989: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
92990: LD_ADDR_VAR 0 3
92994: PUSH
92995: LD_VAR 0 1
92999: PPUSH
93000: CALL_OW 255
93004: PPUSH
93005: LD_VAR 0 1
93009: PPUSH
93010: CALL_OW 250
93014: PPUSH
93015: LD_VAR 0 1
93019: PPUSH
93020: CALL_OW 251
93024: PPUSH
93025: LD_VAR 0 2
93029: PPUSH
93030: CALL 66382 0 4
93034: PUSH
93035: LD_INT 4
93037: ARRAY
93038: ST_TO_ADDR
// end ;
93039: LD_VAR 0 3
93043: RET
// export function PlayerSeeMe ( unit ) ; begin
93044: LD_INT 0
93046: PPUSH
// result := See ( your_side , unit ) ;
93047: LD_ADDR_VAR 0 2
93051: PUSH
93052: LD_OWVAR 2
93056: PPUSH
93057: LD_VAR 0 1
93061: PPUSH
93062: CALL_OW 292
93066: ST_TO_ADDR
// end ;
93067: LD_VAR 0 2
93071: RET
// export function ReverseDir ( unit ) ; begin
93072: LD_INT 0
93074: PPUSH
// if not unit then
93075: LD_VAR 0 1
93079: NOT
93080: IFFALSE 93084
// exit ;
93082: GO 93107
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
93084: LD_ADDR_VAR 0 2
93088: PUSH
93089: LD_VAR 0 1
93093: PPUSH
93094: CALL_OW 254
93098: PUSH
93099: LD_INT 3
93101: PLUS
93102: PUSH
93103: LD_INT 6
93105: MOD
93106: ST_TO_ADDR
// end ;
93107: LD_VAR 0 2
93111: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
93112: LD_INT 0
93114: PPUSH
93115: PPUSH
93116: PPUSH
93117: PPUSH
93118: PPUSH
// if not hexes then
93119: LD_VAR 0 2
93123: NOT
93124: IFFALSE 93128
// exit ;
93126: GO 93276
// dist := 9999 ;
93128: LD_ADDR_VAR 0 5
93132: PUSH
93133: LD_INT 9999
93135: ST_TO_ADDR
// for i = 1 to hexes do
93136: LD_ADDR_VAR 0 4
93140: PUSH
93141: DOUBLE
93142: LD_INT 1
93144: DEC
93145: ST_TO_ADDR
93146: LD_VAR 0 2
93150: PUSH
93151: FOR_TO
93152: IFFALSE 93264
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
93154: LD_VAR 0 1
93158: PPUSH
93159: LD_VAR 0 2
93163: PUSH
93164: LD_VAR 0 4
93168: ARRAY
93169: PUSH
93170: LD_INT 1
93172: ARRAY
93173: PPUSH
93174: LD_VAR 0 2
93178: PUSH
93179: LD_VAR 0 4
93183: ARRAY
93184: PUSH
93185: LD_INT 2
93187: ARRAY
93188: PPUSH
93189: CALL_OW 297
93193: PUSH
93194: LD_VAR 0 5
93198: LESS
93199: IFFALSE 93262
// begin hex := hexes [ i ] ;
93201: LD_ADDR_VAR 0 7
93205: PUSH
93206: LD_VAR 0 2
93210: PUSH
93211: LD_VAR 0 4
93215: ARRAY
93216: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
93217: LD_ADDR_VAR 0 5
93221: PUSH
93222: LD_VAR 0 1
93226: PPUSH
93227: LD_VAR 0 2
93231: PUSH
93232: LD_VAR 0 4
93236: ARRAY
93237: PUSH
93238: LD_INT 1
93240: ARRAY
93241: PPUSH
93242: LD_VAR 0 2
93246: PUSH
93247: LD_VAR 0 4
93251: ARRAY
93252: PUSH
93253: LD_INT 2
93255: ARRAY
93256: PPUSH
93257: CALL_OW 297
93261: ST_TO_ADDR
// end ; end ;
93262: GO 93151
93264: POP
93265: POP
// result := hex ;
93266: LD_ADDR_VAR 0 3
93270: PUSH
93271: LD_VAR 0 7
93275: ST_TO_ADDR
// end ;
93276: LD_VAR 0 3
93280: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
93281: LD_INT 0
93283: PPUSH
93284: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
93285: LD_VAR 0 1
93289: NOT
93290: PUSH
93291: LD_VAR 0 1
93295: PUSH
93296: LD_INT 21
93298: PUSH
93299: LD_INT 2
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 23
93308: PUSH
93309: LD_INT 2
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PPUSH
93320: CALL_OW 69
93324: IN
93325: NOT
93326: OR
93327: IFFALSE 93331
// exit ;
93329: GO 93378
// for i = 1 to 3 do
93331: LD_ADDR_VAR 0 3
93335: PUSH
93336: DOUBLE
93337: LD_INT 1
93339: DEC
93340: ST_TO_ADDR
93341: LD_INT 3
93343: PUSH
93344: FOR_TO
93345: IFFALSE 93376
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
93347: LD_VAR 0 1
93351: PPUSH
93352: CALL_OW 250
93356: PPUSH
93357: LD_VAR 0 1
93361: PPUSH
93362: CALL_OW 251
93366: PPUSH
93367: LD_INT 1
93369: PPUSH
93370: CALL_OW 453
93374: GO 93344
93376: POP
93377: POP
// end ;
93378: LD_VAR 0 2
93382: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
93383: LD_INT 0
93385: PPUSH
93386: PPUSH
93387: PPUSH
93388: PPUSH
93389: PPUSH
93390: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
93391: LD_VAR 0 1
93395: NOT
93396: PUSH
93397: LD_VAR 0 2
93401: NOT
93402: OR
93403: PUSH
93404: LD_VAR 0 1
93408: PPUSH
93409: CALL_OW 314
93413: OR
93414: IFFALSE 93418
// exit ;
93416: GO 93859
// x := GetX ( enemy_unit ) ;
93418: LD_ADDR_VAR 0 7
93422: PUSH
93423: LD_VAR 0 2
93427: PPUSH
93428: CALL_OW 250
93432: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
93433: LD_ADDR_VAR 0 8
93437: PUSH
93438: LD_VAR 0 2
93442: PPUSH
93443: CALL_OW 251
93447: ST_TO_ADDR
// if not x or not y then
93448: LD_VAR 0 7
93452: NOT
93453: PUSH
93454: LD_VAR 0 8
93458: NOT
93459: OR
93460: IFFALSE 93464
// exit ;
93462: GO 93859
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
93464: LD_ADDR_VAR 0 6
93468: PUSH
93469: LD_VAR 0 7
93473: PPUSH
93474: LD_INT 0
93476: PPUSH
93477: LD_INT 4
93479: PPUSH
93480: CALL_OW 272
93484: PUSH
93485: LD_VAR 0 8
93489: PPUSH
93490: LD_INT 0
93492: PPUSH
93493: LD_INT 4
93495: PPUSH
93496: CALL_OW 273
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_VAR 0 7
93509: PPUSH
93510: LD_INT 1
93512: PPUSH
93513: LD_INT 4
93515: PPUSH
93516: CALL_OW 272
93520: PUSH
93521: LD_VAR 0 8
93525: PPUSH
93526: LD_INT 1
93528: PPUSH
93529: LD_INT 4
93531: PPUSH
93532: CALL_OW 273
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_VAR 0 7
93545: PPUSH
93546: LD_INT 2
93548: PPUSH
93549: LD_INT 4
93551: PPUSH
93552: CALL_OW 272
93556: PUSH
93557: LD_VAR 0 8
93561: PPUSH
93562: LD_INT 2
93564: PPUSH
93565: LD_INT 4
93567: PPUSH
93568: CALL_OW 273
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_VAR 0 7
93581: PPUSH
93582: LD_INT 3
93584: PPUSH
93585: LD_INT 4
93587: PPUSH
93588: CALL_OW 272
93592: PUSH
93593: LD_VAR 0 8
93597: PPUSH
93598: LD_INT 3
93600: PPUSH
93601: LD_INT 4
93603: PPUSH
93604: CALL_OW 273
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: PUSH
93613: LD_VAR 0 7
93617: PPUSH
93618: LD_INT 4
93620: PPUSH
93621: LD_INT 4
93623: PPUSH
93624: CALL_OW 272
93628: PUSH
93629: LD_VAR 0 8
93633: PPUSH
93634: LD_INT 4
93636: PPUSH
93637: LD_INT 4
93639: PPUSH
93640: CALL_OW 273
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_VAR 0 7
93653: PPUSH
93654: LD_INT 5
93656: PPUSH
93657: LD_INT 4
93659: PPUSH
93660: CALL_OW 272
93664: PUSH
93665: LD_VAR 0 8
93669: PPUSH
93670: LD_INT 5
93672: PPUSH
93673: LD_INT 4
93675: PPUSH
93676: CALL_OW 273
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: ST_TO_ADDR
// for i = tmp downto 1 do
93693: LD_ADDR_VAR 0 4
93697: PUSH
93698: DOUBLE
93699: LD_VAR 0 6
93703: INC
93704: ST_TO_ADDR
93705: LD_INT 1
93707: PUSH
93708: FOR_DOWNTO
93709: IFFALSE 93810
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
93711: LD_VAR 0 6
93715: PUSH
93716: LD_VAR 0 4
93720: ARRAY
93721: PUSH
93722: LD_INT 1
93724: ARRAY
93725: PPUSH
93726: LD_VAR 0 6
93730: PUSH
93731: LD_VAR 0 4
93735: ARRAY
93736: PUSH
93737: LD_INT 2
93739: ARRAY
93740: PPUSH
93741: CALL_OW 488
93745: NOT
93746: PUSH
93747: LD_VAR 0 6
93751: PUSH
93752: LD_VAR 0 4
93756: ARRAY
93757: PUSH
93758: LD_INT 1
93760: ARRAY
93761: PPUSH
93762: LD_VAR 0 6
93766: PUSH
93767: LD_VAR 0 4
93771: ARRAY
93772: PUSH
93773: LD_INT 2
93775: ARRAY
93776: PPUSH
93777: CALL_OW 428
93781: PUSH
93782: LD_INT 0
93784: NONEQUAL
93785: OR
93786: IFFALSE 93808
// tmp := Delete ( tmp , i ) ;
93788: LD_ADDR_VAR 0 6
93792: PUSH
93793: LD_VAR 0 6
93797: PPUSH
93798: LD_VAR 0 4
93802: PPUSH
93803: CALL_OW 3
93807: ST_TO_ADDR
93808: GO 93708
93810: POP
93811: POP
// j := GetClosestHex ( unit , tmp ) ;
93812: LD_ADDR_VAR 0 5
93816: PUSH
93817: LD_VAR 0 1
93821: PPUSH
93822: LD_VAR 0 6
93826: PPUSH
93827: CALL 93112 0 2
93831: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
93832: LD_VAR 0 1
93836: PPUSH
93837: LD_VAR 0 5
93841: PUSH
93842: LD_INT 1
93844: ARRAY
93845: PPUSH
93846: LD_VAR 0 5
93850: PUSH
93851: LD_INT 2
93853: ARRAY
93854: PPUSH
93855: CALL_OW 111
// end ;
93859: LD_VAR 0 3
93863: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
93864: LD_INT 0
93866: PPUSH
93867: PPUSH
93868: PPUSH
// uc_side = 0 ;
93869: LD_ADDR_OWVAR 20
93873: PUSH
93874: LD_INT 0
93876: ST_TO_ADDR
// uc_nation = 0 ;
93877: LD_ADDR_OWVAR 21
93881: PUSH
93882: LD_INT 0
93884: ST_TO_ADDR
// InitHc_All ( ) ;
93885: CALL_OW 584
// InitVc ;
93889: CALL_OW 20
// if mastodonts then
93893: LD_VAR 0 6
93897: IFFALSE 93964
// for i = 1 to mastodonts do
93899: LD_ADDR_VAR 0 11
93903: PUSH
93904: DOUBLE
93905: LD_INT 1
93907: DEC
93908: ST_TO_ADDR
93909: LD_VAR 0 6
93913: PUSH
93914: FOR_TO
93915: IFFALSE 93962
// begin vc_chassis := 31 ;
93917: LD_ADDR_OWVAR 37
93921: PUSH
93922: LD_INT 31
93924: ST_TO_ADDR
// vc_control := control_rider ;
93925: LD_ADDR_OWVAR 38
93929: PUSH
93930: LD_INT 4
93932: ST_TO_ADDR
// animal := CreateVehicle ;
93933: LD_ADDR_VAR 0 12
93937: PUSH
93938: CALL_OW 45
93942: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93943: LD_VAR 0 12
93947: PPUSH
93948: LD_VAR 0 8
93952: PPUSH
93953: LD_INT 0
93955: PPUSH
93956: CALL 96152 0 3
// end ;
93960: GO 93914
93962: POP
93963: POP
// if horses then
93964: LD_VAR 0 5
93968: IFFALSE 94035
// for i = 1 to horses do
93970: LD_ADDR_VAR 0 11
93974: PUSH
93975: DOUBLE
93976: LD_INT 1
93978: DEC
93979: ST_TO_ADDR
93980: LD_VAR 0 5
93984: PUSH
93985: FOR_TO
93986: IFFALSE 94033
// begin hc_class := 21 ;
93988: LD_ADDR_OWVAR 28
93992: PUSH
93993: LD_INT 21
93995: ST_TO_ADDR
// hc_gallery :=  ;
93996: LD_ADDR_OWVAR 33
94000: PUSH
94001: LD_STRING 
94003: ST_TO_ADDR
// animal := CreateHuman ;
94004: LD_ADDR_VAR 0 12
94008: PUSH
94009: CALL_OW 44
94013: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94014: LD_VAR 0 12
94018: PPUSH
94019: LD_VAR 0 8
94023: PPUSH
94024: LD_INT 0
94026: PPUSH
94027: CALL 96152 0 3
// end ;
94031: GO 93985
94033: POP
94034: POP
// if birds then
94035: LD_VAR 0 1
94039: IFFALSE 94106
// for i = 1 to birds do
94041: LD_ADDR_VAR 0 11
94045: PUSH
94046: DOUBLE
94047: LD_INT 1
94049: DEC
94050: ST_TO_ADDR
94051: LD_VAR 0 1
94055: PUSH
94056: FOR_TO
94057: IFFALSE 94104
// begin hc_class = 18 ;
94059: LD_ADDR_OWVAR 28
94063: PUSH
94064: LD_INT 18
94066: ST_TO_ADDR
// hc_gallery =  ;
94067: LD_ADDR_OWVAR 33
94071: PUSH
94072: LD_STRING 
94074: ST_TO_ADDR
// animal := CreateHuman ;
94075: LD_ADDR_VAR 0 12
94079: PUSH
94080: CALL_OW 44
94084: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94085: LD_VAR 0 12
94089: PPUSH
94090: LD_VAR 0 8
94094: PPUSH
94095: LD_INT 0
94097: PPUSH
94098: CALL 96152 0 3
// end ;
94102: GO 94056
94104: POP
94105: POP
// if tigers then
94106: LD_VAR 0 2
94110: IFFALSE 94194
// for i = 1 to tigers do
94112: LD_ADDR_VAR 0 11
94116: PUSH
94117: DOUBLE
94118: LD_INT 1
94120: DEC
94121: ST_TO_ADDR
94122: LD_VAR 0 2
94126: PUSH
94127: FOR_TO
94128: IFFALSE 94192
// begin hc_class = class_tiger ;
94130: LD_ADDR_OWVAR 28
94134: PUSH
94135: LD_INT 14
94137: ST_TO_ADDR
// hc_gallery =  ;
94138: LD_ADDR_OWVAR 33
94142: PUSH
94143: LD_STRING 
94145: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
94146: LD_ADDR_OWVAR 35
94150: PUSH
94151: LD_INT 7
94153: NEG
94154: PPUSH
94155: LD_INT 7
94157: PPUSH
94158: CALL_OW 12
94162: ST_TO_ADDR
// animal := CreateHuman ;
94163: LD_ADDR_VAR 0 12
94167: PUSH
94168: CALL_OW 44
94172: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94173: LD_VAR 0 12
94177: PPUSH
94178: LD_VAR 0 8
94182: PPUSH
94183: LD_INT 0
94185: PPUSH
94186: CALL 96152 0 3
// end ;
94190: GO 94127
94192: POP
94193: POP
// if apemans then
94194: LD_VAR 0 3
94198: IFFALSE 94321
// for i = 1 to apemans do
94200: LD_ADDR_VAR 0 11
94204: PUSH
94205: DOUBLE
94206: LD_INT 1
94208: DEC
94209: ST_TO_ADDR
94210: LD_VAR 0 3
94214: PUSH
94215: FOR_TO
94216: IFFALSE 94319
// begin hc_class = class_apeman ;
94218: LD_ADDR_OWVAR 28
94222: PUSH
94223: LD_INT 12
94225: ST_TO_ADDR
// hc_gallery =  ;
94226: LD_ADDR_OWVAR 33
94230: PUSH
94231: LD_STRING 
94233: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
94234: LD_ADDR_OWVAR 35
94238: PUSH
94239: LD_INT 2
94241: NEG
94242: PPUSH
94243: LD_INT 2
94245: PPUSH
94246: CALL_OW 12
94250: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
94251: LD_ADDR_OWVAR 31
94255: PUSH
94256: LD_INT 1
94258: PPUSH
94259: LD_INT 3
94261: PPUSH
94262: CALL_OW 12
94266: PUSH
94267: LD_INT 1
94269: PPUSH
94270: LD_INT 3
94272: PPUSH
94273: CALL_OW 12
94277: PUSH
94278: LD_INT 0
94280: PUSH
94281: LD_INT 0
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: ST_TO_ADDR
// animal := CreateHuman ;
94290: LD_ADDR_VAR 0 12
94294: PUSH
94295: CALL_OW 44
94299: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94300: LD_VAR 0 12
94304: PPUSH
94305: LD_VAR 0 8
94309: PPUSH
94310: LD_INT 0
94312: PPUSH
94313: CALL 96152 0 3
// end ;
94317: GO 94215
94319: POP
94320: POP
// if enchidnas then
94321: LD_VAR 0 4
94325: IFFALSE 94392
// for i = 1 to enchidnas do
94327: LD_ADDR_VAR 0 11
94331: PUSH
94332: DOUBLE
94333: LD_INT 1
94335: DEC
94336: ST_TO_ADDR
94337: LD_VAR 0 4
94341: PUSH
94342: FOR_TO
94343: IFFALSE 94390
// begin hc_class = 13 ;
94345: LD_ADDR_OWVAR 28
94349: PUSH
94350: LD_INT 13
94352: ST_TO_ADDR
// hc_gallery =  ;
94353: LD_ADDR_OWVAR 33
94357: PUSH
94358: LD_STRING 
94360: ST_TO_ADDR
// animal := CreateHuman ;
94361: LD_ADDR_VAR 0 12
94365: PUSH
94366: CALL_OW 44
94370: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94371: LD_VAR 0 12
94375: PPUSH
94376: LD_VAR 0 8
94380: PPUSH
94381: LD_INT 0
94383: PPUSH
94384: CALL 96152 0 3
// end ;
94388: GO 94342
94390: POP
94391: POP
// if fishes then
94392: LD_VAR 0 7
94396: IFFALSE 94463
// for i = 1 to fishes do
94398: LD_ADDR_VAR 0 11
94402: PUSH
94403: DOUBLE
94404: LD_INT 1
94406: DEC
94407: ST_TO_ADDR
94408: LD_VAR 0 7
94412: PUSH
94413: FOR_TO
94414: IFFALSE 94461
// begin hc_class = 20 ;
94416: LD_ADDR_OWVAR 28
94420: PUSH
94421: LD_INT 20
94423: ST_TO_ADDR
// hc_gallery =  ;
94424: LD_ADDR_OWVAR 33
94428: PUSH
94429: LD_STRING 
94431: ST_TO_ADDR
// animal := CreateHuman ;
94432: LD_ADDR_VAR 0 12
94436: PUSH
94437: CALL_OW 44
94441: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
94442: LD_VAR 0 12
94446: PPUSH
94447: LD_VAR 0 9
94451: PPUSH
94452: LD_INT 0
94454: PPUSH
94455: CALL 96152 0 3
// end ;
94459: GO 94413
94461: POP
94462: POP
// end ;
94463: LD_VAR 0 10
94467: RET
// export function WantHeal ( sci , unit ) ; begin
94468: LD_INT 0
94470: PPUSH
// if GetTaskList ( sci ) > 0 then
94471: LD_VAR 0 1
94475: PPUSH
94476: CALL_OW 437
94480: PUSH
94481: LD_INT 0
94483: GREATER
94484: IFFALSE 94554
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
94486: LD_VAR 0 1
94490: PPUSH
94491: CALL_OW 437
94495: PUSH
94496: LD_INT 1
94498: ARRAY
94499: PUSH
94500: LD_INT 1
94502: ARRAY
94503: PUSH
94504: LD_STRING l
94506: EQUAL
94507: PUSH
94508: LD_VAR 0 1
94512: PPUSH
94513: CALL_OW 437
94517: PUSH
94518: LD_INT 1
94520: ARRAY
94521: PUSH
94522: LD_INT 4
94524: ARRAY
94525: PUSH
94526: LD_VAR 0 2
94530: EQUAL
94531: AND
94532: IFFALSE 94544
// result := true else
94534: LD_ADDR_VAR 0 3
94538: PUSH
94539: LD_INT 1
94541: ST_TO_ADDR
94542: GO 94552
// result := false ;
94544: LD_ADDR_VAR 0 3
94548: PUSH
94549: LD_INT 0
94551: ST_TO_ADDR
// end else
94552: GO 94562
// result := false ;
94554: LD_ADDR_VAR 0 3
94558: PUSH
94559: LD_INT 0
94561: ST_TO_ADDR
// end ;
94562: LD_VAR 0 3
94566: RET
// export function HealTarget ( sci ) ; begin
94567: LD_INT 0
94569: PPUSH
// if not sci then
94570: LD_VAR 0 1
94574: NOT
94575: IFFALSE 94579
// exit ;
94577: GO 94644
// result := 0 ;
94579: LD_ADDR_VAR 0 2
94583: PUSH
94584: LD_INT 0
94586: ST_TO_ADDR
// if GetTaskList ( sci ) then
94587: LD_VAR 0 1
94591: PPUSH
94592: CALL_OW 437
94596: IFFALSE 94644
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
94598: LD_VAR 0 1
94602: PPUSH
94603: CALL_OW 437
94607: PUSH
94608: LD_INT 1
94610: ARRAY
94611: PUSH
94612: LD_INT 1
94614: ARRAY
94615: PUSH
94616: LD_STRING l
94618: EQUAL
94619: IFFALSE 94644
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
94621: LD_ADDR_VAR 0 2
94625: PUSH
94626: LD_VAR 0 1
94630: PPUSH
94631: CALL_OW 437
94635: PUSH
94636: LD_INT 1
94638: ARRAY
94639: PUSH
94640: LD_INT 4
94642: ARRAY
94643: ST_TO_ADDR
// end ;
94644: LD_VAR 0 2
94648: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
94649: LD_INT 0
94651: PPUSH
94652: PPUSH
94653: PPUSH
94654: PPUSH
// if not base_units then
94655: LD_VAR 0 1
94659: NOT
94660: IFFALSE 94664
// exit ;
94662: GO 94751
// result := false ;
94664: LD_ADDR_VAR 0 2
94668: PUSH
94669: LD_INT 0
94671: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
94672: LD_ADDR_VAR 0 5
94676: PUSH
94677: LD_VAR 0 1
94681: PPUSH
94682: LD_INT 21
94684: PUSH
94685: LD_INT 3
94687: PUSH
94688: EMPTY
94689: LIST
94690: LIST
94691: PPUSH
94692: CALL_OW 72
94696: ST_TO_ADDR
// if not tmp then
94697: LD_VAR 0 5
94701: NOT
94702: IFFALSE 94706
// exit ;
94704: GO 94751
// for i in tmp do
94706: LD_ADDR_VAR 0 3
94710: PUSH
94711: LD_VAR 0 5
94715: PUSH
94716: FOR_IN
94717: IFFALSE 94749
// begin result := EnemyInRange ( i , 22 ) ;
94719: LD_ADDR_VAR 0 2
94723: PUSH
94724: LD_VAR 0 3
94728: PPUSH
94729: LD_INT 22
94731: PPUSH
94732: CALL 92987 0 2
94736: ST_TO_ADDR
// if result then
94737: LD_VAR 0 2
94741: IFFALSE 94747
// exit ;
94743: POP
94744: POP
94745: GO 94751
// end ;
94747: GO 94716
94749: POP
94750: POP
// end ;
94751: LD_VAR 0 2
94755: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
94756: LD_INT 0
94758: PPUSH
94759: PPUSH
// if not units then
94760: LD_VAR 0 1
94764: NOT
94765: IFFALSE 94769
// exit ;
94767: GO 94839
// result := [ ] ;
94769: LD_ADDR_VAR 0 3
94773: PUSH
94774: EMPTY
94775: ST_TO_ADDR
// for i in units do
94776: LD_ADDR_VAR 0 4
94780: PUSH
94781: LD_VAR 0 1
94785: PUSH
94786: FOR_IN
94787: IFFALSE 94837
// if GetTag ( i ) = tag then
94789: LD_VAR 0 4
94793: PPUSH
94794: CALL_OW 110
94798: PUSH
94799: LD_VAR 0 2
94803: EQUAL
94804: IFFALSE 94835
// result := Insert ( result , result + 1 , i ) ;
94806: LD_ADDR_VAR 0 3
94810: PUSH
94811: LD_VAR 0 3
94815: PPUSH
94816: LD_VAR 0 3
94820: PUSH
94821: LD_INT 1
94823: PLUS
94824: PPUSH
94825: LD_VAR 0 4
94829: PPUSH
94830: CALL_OW 2
94834: ST_TO_ADDR
94835: GO 94786
94837: POP
94838: POP
// end ;
94839: LD_VAR 0 3
94843: RET
// export function IsDriver ( un ) ; begin
94844: LD_INT 0
94846: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
94847: LD_ADDR_VAR 0 2
94851: PUSH
94852: LD_VAR 0 1
94856: PUSH
94857: LD_INT 55
94859: PUSH
94860: EMPTY
94861: LIST
94862: PPUSH
94863: CALL_OW 69
94867: IN
94868: ST_TO_ADDR
// end ;
94869: LD_VAR 0 2
94873: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
94874: LD_INT 0
94876: PPUSH
94877: PPUSH
// list := [ ] ;
94878: LD_ADDR_VAR 0 5
94882: PUSH
94883: EMPTY
94884: ST_TO_ADDR
// case d of 0 :
94885: LD_VAR 0 3
94889: PUSH
94890: LD_INT 0
94892: DOUBLE
94893: EQUAL
94894: IFTRUE 94898
94896: GO 95031
94898: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
94899: LD_ADDR_VAR 0 5
94903: PUSH
94904: LD_VAR 0 1
94908: PUSH
94909: LD_INT 4
94911: MINUS
94912: PUSH
94913: LD_VAR 0 2
94917: PUSH
94918: LD_INT 4
94920: MINUS
94921: PUSH
94922: LD_INT 2
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: LIST
94929: PUSH
94930: LD_VAR 0 1
94934: PUSH
94935: LD_INT 3
94937: MINUS
94938: PUSH
94939: LD_VAR 0 2
94943: PUSH
94944: LD_INT 1
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: LIST
94951: PUSH
94952: LD_VAR 0 1
94956: PUSH
94957: LD_INT 4
94959: PLUS
94960: PUSH
94961: LD_VAR 0 2
94965: PUSH
94966: LD_INT 4
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: LIST
94973: PUSH
94974: LD_VAR 0 1
94978: PUSH
94979: LD_INT 3
94981: PLUS
94982: PUSH
94983: LD_VAR 0 2
94987: PUSH
94988: LD_INT 3
94990: PLUS
94991: PUSH
94992: LD_INT 5
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: LIST
94999: PUSH
95000: LD_VAR 0 1
95004: PUSH
95005: LD_VAR 0 2
95009: PUSH
95010: LD_INT 4
95012: PLUS
95013: PUSH
95014: LD_INT 0
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: LIST
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: ST_TO_ADDR
// end ; 1 :
95029: GO 95729
95031: LD_INT 1
95033: DOUBLE
95034: EQUAL
95035: IFTRUE 95039
95037: GO 95172
95039: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
95040: LD_ADDR_VAR 0 5
95044: PUSH
95045: LD_VAR 0 1
95049: PUSH
95050: LD_VAR 0 2
95054: PUSH
95055: LD_INT 4
95057: MINUS
95058: PUSH
95059: LD_INT 3
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: LIST
95066: PUSH
95067: LD_VAR 0 1
95071: PUSH
95072: LD_INT 3
95074: MINUS
95075: PUSH
95076: LD_VAR 0 2
95080: PUSH
95081: LD_INT 3
95083: MINUS
95084: PUSH
95085: LD_INT 2
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: LIST
95092: PUSH
95093: LD_VAR 0 1
95097: PUSH
95098: LD_INT 4
95100: MINUS
95101: PUSH
95102: LD_VAR 0 2
95106: PUSH
95107: LD_INT 1
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: LIST
95114: PUSH
95115: LD_VAR 0 1
95119: PUSH
95120: LD_VAR 0 2
95124: PUSH
95125: LD_INT 3
95127: PLUS
95128: PUSH
95129: LD_INT 0
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: LIST
95136: PUSH
95137: LD_VAR 0 1
95141: PUSH
95142: LD_INT 4
95144: PLUS
95145: PUSH
95146: LD_VAR 0 2
95150: PUSH
95151: LD_INT 4
95153: PLUS
95154: PUSH
95155: LD_INT 5
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: LIST
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: ST_TO_ADDR
// end ; 2 :
95170: GO 95729
95172: LD_INT 2
95174: DOUBLE
95175: EQUAL
95176: IFTRUE 95180
95178: GO 95309
95180: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
95181: LD_ADDR_VAR 0 5
95185: PUSH
95186: LD_VAR 0 1
95190: PUSH
95191: LD_VAR 0 2
95195: PUSH
95196: LD_INT 3
95198: MINUS
95199: PUSH
95200: LD_INT 3
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: LIST
95207: PUSH
95208: LD_VAR 0 1
95212: PUSH
95213: LD_INT 4
95215: PLUS
95216: PUSH
95217: LD_VAR 0 2
95221: PUSH
95222: LD_INT 4
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: LIST
95229: PUSH
95230: LD_VAR 0 1
95234: PUSH
95235: LD_VAR 0 2
95239: PUSH
95240: LD_INT 4
95242: PLUS
95243: PUSH
95244: LD_INT 0
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: LIST
95251: PUSH
95252: LD_VAR 0 1
95256: PUSH
95257: LD_INT 3
95259: MINUS
95260: PUSH
95261: LD_VAR 0 2
95265: PUSH
95266: LD_INT 1
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: LIST
95273: PUSH
95274: LD_VAR 0 1
95278: PUSH
95279: LD_INT 4
95281: MINUS
95282: PUSH
95283: LD_VAR 0 2
95287: PUSH
95288: LD_INT 4
95290: MINUS
95291: PUSH
95292: LD_INT 2
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: LIST
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: ST_TO_ADDR
// end ; 3 :
95307: GO 95729
95309: LD_INT 3
95311: DOUBLE
95312: EQUAL
95313: IFTRUE 95317
95315: GO 95450
95317: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
95318: LD_ADDR_VAR 0 5
95322: PUSH
95323: LD_VAR 0 1
95327: PUSH
95328: LD_INT 3
95330: PLUS
95331: PUSH
95332: LD_VAR 0 2
95336: PUSH
95337: LD_INT 4
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: LIST
95344: PUSH
95345: LD_VAR 0 1
95349: PUSH
95350: LD_INT 4
95352: PLUS
95353: PUSH
95354: LD_VAR 0 2
95358: PUSH
95359: LD_INT 4
95361: PLUS
95362: PUSH
95363: LD_INT 5
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: LIST
95370: PUSH
95371: LD_VAR 0 1
95375: PUSH
95376: LD_INT 4
95378: MINUS
95379: PUSH
95380: LD_VAR 0 2
95384: PUSH
95385: LD_INT 1
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: LIST
95392: PUSH
95393: LD_VAR 0 1
95397: PUSH
95398: LD_VAR 0 2
95402: PUSH
95403: LD_INT 4
95405: MINUS
95406: PUSH
95407: LD_INT 3
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: LIST
95414: PUSH
95415: LD_VAR 0 1
95419: PUSH
95420: LD_INT 3
95422: MINUS
95423: PUSH
95424: LD_VAR 0 2
95428: PUSH
95429: LD_INT 3
95431: MINUS
95432: PUSH
95433: LD_INT 2
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: LIST
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: ST_TO_ADDR
// end ; 4 :
95448: GO 95729
95450: LD_INT 4
95452: DOUBLE
95453: EQUAL
95454: IFTRUE 95458
95456: GO 95591
95458: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
95459: LD_ADDR_VAR 0 5
95463: PUSH
95464: LD_VAR 0 1
95468: PUSH
95469: LD_VAR 0 2
95473: PUSH
95474: LD_INT 4
95476: PLUS
95477: PUSH
95478: LD_INT 0
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: LIST
95485: PUSH
95486: LD_VAR 0 1
95490: PUSH
95491: LD_INT 3
95493: PLUS
95494: PUSH
95495: LD_VAR 0 2
95499: PUSH
95500: LD_INT 3
95502: PLUS
95503: PUSH
95504: LD_INT 5
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: LIST
95511: PUSH
95512: LD_VAR 0 1
95516: PUSH
95517: LD_INT 4
95519: PLUS
95520: PUSH
95521: LD_VAR 0 2
95525: PUSH
95526: LD_INT 4
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: LIST
95533: PUSH
95534: LD_VAR 0 1
95538: PUSH
95539: LD_VAR 0 2
95543: PUSH
95544: LD_INT 3
95546: MINUS
95547: PUSH
95548: LD_INT 3
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: LIST
95555: PUSH
95556: LD_VAR 0 1
95560: PUSH
95561: LD_INT 4
95563: MINUS
95564: PUSH
95565: LD_VAR 0 2
95569: PUSH
95570: LD_INT 4
95572: MINUS
95573: PUSH
95574: LD_INT 2
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: LIST
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: ST_TO_ADDR
// end ; 5 :
95589: GO 95729
95591: LD_INT 5
95593: DOUBLE
95594: EQUAL
95595: IFTRUE 95599
95597: GO 95728
95599: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
95600: LD_ADDR_VAR 0 5
95604: PUSH
95605: LD_VAR 0 1
95609: PUSH
95610: LD_INT 4
95612: MINUS
95613: PUSH
95614: LD_VAR 0 2
95618: PUSH
95619: LD_INT 1
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: LIST
95626: PUSH
95627: LD_VAR 0 1
95631: PUSH
95632: LD_VAR 0 2
95636: PUSH
95637: LD_INT 4
95639: MINUS
95640: PUSH
95641: LD_INT 3
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: LIST
95648: PUSH
95649: LD_VAR 0 1
95653: PUSH
95654: LD_INT 4
95656: PLUS
95657: PUSH
95658: LD_VAR 0 2
95662: PUSH
95663: LD_INT 4
95665: PLUS
95666: PUSH
95667: LD_INT 5
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: LIST
95674: PUSH
95675: LD_VAR 0 1
95679: PUSH
95680: LD_INT 3
95682: PLUS
95683: PUSH
95684: LD_VAR 0 2
95688: PUSH
95689: LD_INT 4
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: LIST
95696: PUSH
95697: LD_VAR 0 1
95701: PUSH
95702: LD_VAR 0 2
95706: PUSH
95707: LD_INT 3
95709: PLUS
95710: PUSH
95711: LD_INT 0
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: LIST
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: ST_TO_ADDR
// end ; end ;
95726: GO 95729
95728: POP
// result := list ;
95729: LD_ADDR_VAR 0 4
95733: PUSH
95734: LD_VAR 0 5
95738: ST_TO_ADDR
// end ;
95739: LD_VAR 0 4
95743: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
95744: LD_INT 0
95746: PPUSH
95747: PPUSH
95748: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
95749: LD_VAR 0 1
95753: NOT
95754: PUSH
95755: LD_VAR 0 2
95759: PUSH
95760: LD_INT 1
95762: PUSH
95763: LD_INT 2
95765: PUSH
95766: LD_INT 3
95768: PUSH
95769: LD_INT 4
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: IN
95778: NOT
95779: OR
95780: IFFALSE 95784
// exit ;
95782: GO 95876
// tmp := [ ] ;
95784: LD_ADDR_VAR 0 5
95788: PUSH
95789: EMPTY
95790: ST_TO_ADDR
// for i in units do
95791: LD_ADDR_VAR 0 4
95795: PUSH
95796: LD_VAR 0 1
95800: PUSH
95801: FOR_IN
95802: IFFALSE 95845
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
95804: LD_ADDR_VAR 0 5
95808: PUSH
95809: LD_VAR 0 5
95813: PPUSH
95814: LD_VAR 0 5
95818: PUSH
95819: LD_INT 1
95821: PLUS
95822: PPUSH
95823: LD_VAR 0 4
95827: PPUSH
95828: LD_VAR 0 2
95832: PPUSH
95833: CALL_OW 259
95837: PPUSH
95838: CALL_OW 2
95842: ST_TO_ADDR
95843: GO 95801
95845: POP
95846: POP
// if not tmp then
95847: LD_VAR 0 5
95851: NOT
95852: IFFALSE 95856
// exit ;
95854: GO 95876
// result := SortListByListDesc ( units , tmp ) ;
95856: LD_ADDR_VAR 0 3
95860: PUSH
95861: LD_VAR 0 1
95865: PPUSH
95866: LD_VAR 0 5
95870: PPUSH
95871: CALL_OW 77
95875: ST_TO_ADDR
// end ;
95876: LD_VAR 0 3
95880: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
95881: LD_INT 0
95883: PPUSH
95884: PPUSH
95885: PPUSH
// result := false ;
95886: LD_ADDR_VAR 0 3
95890: PUSH
95891: LD_INT 0
95893: ST_TO_ADDR
// x := GetX ( building ) ;
95894: LD_ADDR_VAR 0 4
95898: PUSH
95899: LD_VAR 0 2
95903: PPUSH
95904: CALL_OW 250
95908: ST_TO_ADDR
// y := GetY ( building ) ;
95909: LD_ADDR_VAR 0 5
95913: PUSH
95914: LD_VAR 0 2
95918: PPUSH
95919: CALL_OW 251
95923: ST_TO_ADDR
// if not building or not x or not y then
95924: LD_VAR 0 2
95928: NOT
95929: PUSH
95930: LD_VAR 0 4
95934: NOT
95935: OR
95936: PUSH
95937: LD_VAR 0 5
95941: NOT
95942: OR
95943: IFFALSE 95947
// exit ;
95945: GO 96039
// if GetTaskList ( unit ) then
95947: LD_VAR 0 1
95951: PPUSH
95952: CALL_OW 437
95956: IFFALSE 96039
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95958: LD_STRING e
95960: PUSH
95961: LD_VAR 0 1
95965: PPUSH
95966: CALL_OW 437
95970: PUSH
95971: LD_INT 1
95973: ARRAY
95974: PUSH
95975: LD_INT 1
95977: ARRAY
95978: EQUAL
95979: PUSH
95980: LD_VAR 0 4
95984: PUSH
95985: LD_VAR 0 1
95989: PPUSH
95990: CALL_OW 437
95994: PUSH
95995: LD_INT 1
95997: ARRAY
95998: PUSH
95999: LD_INT 2
96001: ARRAY
96002: EQUAL
96003: AND
96004: PUSH
96005: LD_VAR 0 5
96009: PUSH
96010: LD_VAR 0 1
96014: PPUSH
96015: CALL_OW 437
96019: PUSH
96020: LD_INT 1
96022: ARRAY
96023: PUSH
96024: LD_INT 3
96026: ARRAY
96027: EQUAL
96028: AND
96029: IFFALSE 96039
// result := true end ;
96031: LD_ADDR_VAR 0 3
96035: PUSH
96036: LD_INT 1
96038: ST_TO_ADDR
// end ;
96039: LD_VAR 0 3
96043: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
96044: LD_INT 0
96046: PPUSH
// result := false ;
96047: LD_ADDR_VAR 0 4
96051: PUSH
96052: LD_INT 0
96054: ST_TO_ADDR
// if GetTaskList ( unit ) then
96055: LD_VAR 0 1
96059: PPUSH
96060: CALL_OW 437
96064: IFFALSE 96147
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96066: LD_STRING M
96068: PUSH
96069: LD_VAR 0 1
96073: PPUSH
96074: CALL_OW 437
96078: PUSH
96079: LD_INT 1
96081: ARRAY
96082: PUSH
96083: LD_INT 1
96085: ARRAY
96086: EQUAL
96087: PUSH
96088: LD_VAR 0 2
96092: PUSH
96093: LD_VAR 0 1
96097: PPUSH
96098: CALL_OW 437
96102: PUSH
96103: LD_INT 1
96105: ARRAY
96106: PUSH
96107: LD_INT 2
96109: ARRAY
96110: EQUAL
96111: AND
96112: PUSH
96113: LD_VAR 0 3
96117: PUSH
96118: LD_VAR 0 1
96122: PPUSH
96123: CALL_OW 437
96127: PUSH
96128: LD_INT 1
96130: ARRAY
96131: PUSH
96132: LD_INT 3
96134: ARRAY
96135: EQUAL
96136: AND
96137: IFFALSE 96147
// result := true ;
96139: LD_ADDR_VAR 0 4
96143: PUSH
96144: LD_INT 1
96146: ST_TO_ADDR
// end ; end ;
96147: LD_VAR 0 4
96151: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
96152: LD_INT 0
96154: PPUSH
96155: PPUSH
96156: PPUSH
96157: PPUSH
// if not unit or not area then
96158: LD_VAR 0 1
96162: NOT
96163: PUSH
96164: LD_VAR 0 2
96168: NOT
96169: OR
96170: IFFALSE 96174
// exit ;
96172: GO 96338
// tmp := AreaToList ( area , i ) ;
96174: LD_ADDR_VAR 0 6
96178: PUSH
96179: LD_VAR 0 2
96183: PPUSH
96184: LD_VAR 0 5
96188: PPUSH
96189: CALL_OW 517
96193: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
96194: LD_ADDR_VAR 0 5
96198: PUSH
96199: DOUBLE
96200: LD_INT 1
96202: DEC
96203: ST_TO_ADDR
96204: LD_VAR 0 6
96208: PUSH
96209: LD_INT 1
96211: ARRAY
96212: PUSH
96213: FOR_TO
96214: IFFALSE 96336
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
96216: LD_ADDR_VAR 0 7
96220: PUSH
96221: LD_VAR 0 6
96225: PUSH
96226: LD_INT 1
96228: ARRAY
96229: PUSH
96230: LD_VAR 0 5
96234: ARRAY
96235: PUSH
96236: LD_VAR 0 6
96240: PUSH
96241: LD_INT 2
96243: ARRAY
96244: PUSH
96245: LD_VAR 0 5
96249: ARRAY
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
96255: LD_VAR 0 7
96259: PUSH
96260: LD_INT 1
96262: ARRAY
96263: PPUSH
96264: LD_VAR 0 7
96268: PUSH
96269: LD_INT 2
96271: ARRAY
96272: PPUSH
96273: CALL_OW 428
96277: PUSH
96278: LD_INT 0
96280: EQUAL
96281: IFFALSE 96334
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
96283: LD_VAR 0 1
96287: PPUSH
96288: LD_VAR 0 7
96292: PUSH
96293: LD_INT 1
96295: ARRAY
96296: PPUSH
96297: LD_VAR 0 7
96301: PUSH
96302: LD_INT 2
96304: ARRAY
96305: PPUSH
96306: LD_VAR 0 3
96310: PPUSH
96311: CALL_OW 48
// result := IsPlaced ( unit ) ;
96315: LD_ADDR_VAR 0 4
96319: PUSH
96320: LD_VAR 0 1
96324: PPUSH
96325: CALL_OW 305
96329: ST_TO_ADDR
// exit ;
96330: POP
96331: POP
96332: GO 96338
// end ; end ;
96334: GO 96213
96336: POP
96337: POP
// end ;
96338: LD_VAR 0 4
96342: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
96343: LD_INT 0
96345: PPUSH
96346: PPUSH
96347: PPUSH
// if not side or side > 8 then
96348: LD_VAR 0 1
96352: NOT
96353: PUSH
96354: LD_VAR 0 1
96358: PUSH
96359: LD_INT 8
96361: GREATER
96362: OR
96363: IFFALSE 96367
// exit ;
96365: GO 96554
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
96367: LD_ADDR_VAR 0 4
96371: PUSH
96372: LD_INT 22
96374: PUSH
96375: LD_VAR 0 1
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 21
96386: PUSH
96387: LD_INT 3
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PPUSH
96398: CALL_OW 69
96402: ST_TO_ADDR
// if not tmp then
96403: LD_VAR 0 4
96407: NOT
96408: IFFALSE 96412
// exit ;
96410: GO 96554
// enable_addtolog := true ;
96412: LD_ADDR_OWVAR 81
96416: PUSH
96417: LD_INT 1
96419: ST_TO_ADDR
// AddToLog ( [ ) ;
96420: LD_STRING [
96422: PPUSH
96423: CALL_OW 561
// for i in tmp do
96427: LD_ADDR_VAR 0 3
96431: PUSH
96432: LD_VAR 0 4
96436: PUSH
96437: FOR_IN
96438: IFFALSE 96545
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
96440: LD_STRING [
96442: PUSH
96443: LD_VAR 0 3
96447: PPUSH
96448: CALL_OW 266
96452: STR
96453: PUSH
96454: LD_STRING , 
96456: STR
96457: PUSH
96458: LD_VAR 0 3
96462: PPUSH
96463: CALL_OW 250
96467: STR
96468: PUSH
96469: LD_STRING , 
96471: STR
96472: PUSH
96473: LD_VAR 0 3
96477: PPUSH
96478: CALL_OW 251
96482: STR
96483: PUSH
96484: LD_STRING , 
96486: STR
96487: PUSH
96488: LD_VAR 0 3
96492: PPUSH
96493: CALL_OW 254
96497: STR
96498: PUSH
96499: LD_STRING , 
96501: STR
96502: PUSH
96503: LD_VAR 0 3
96507: PPUSH
96508: LD_INT 1
96510: PPUSH
96511: CALL_OW 268
96515: STR
96516: PUSH
96517: LD_STRING , 
96519: STR
96520: PUSH
96521: LD_VAR 0 3
96525: PPUSH
96526: LD_INT 2
96528: PPUSH
96529: CALL_OW 268
96533: STR
96534: PUSH
96535: LD_STRING ],
96537: STR
96538: PPUSH
96539: CALL_OW 561
// end ;
96543: GO 96437
96545: POP
96546: POP
// AddToLog ( ]; ) ;
96547: LD_STRING ];
96549: PPUSH
96550: CALL_OW 561
// end ;
96554: LD_VAR 0 2
96558: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
96559: LD_INT 0
96561: PPUSH
96562: PPUSH
96563: PPUSH
96564: PPUSH
96565: PPUSH
// if not area or not rate or not max then
96566: LD_VAR 0 1
96570: NOT
96571: PUSH
96572: LD_VAR 0 2
96576: NOT
96577: OR
96578: PUSH
96579: LD_VAR 0 4
96583: NOT
96584: OR
96585: IFFALSE 96589
// exit ;
96587: GO 96781
// while 1 do
96589: LD_INT 1
96591: IFFALSE 96781
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
96593: LD_ADDR_VAR 0 9
96597: PUSH
96598: LD_VAR 0 1
96602: PPUSH
96603: LD_INT 1
96605: PPUSH
96606: CALL_OW 287
96610: PUSH
96611: LD_INT 10
96613: MUL
96614: ST_TO_ADDR
// r := rate / 10 ;
96615: LD_ADDR_VAR 0 7
96619: PUSH
96620: LD_VAR 0 2
96624: PUSH
96625: LD_INT 10
96627: DIVREAL
96628: ST_TO_ADDR
// time := 1 1$00 ;
96629: LD_ADDR_VAR 0 8
96633: PUSH
96634: LD_INT 2100
96636: ST_TO_ADDR
// if amount < min then
96637: LD_VAR 0 9
96641: PUSH
96642: LD_VAR 0 3
96646: LESS
96647: IFFALSE 96665
// r := r * 2 else
96649: LD_ADDR_VAR 0 7
96653: PUSH
96654: LD_VAR 0 7
96658: PUSH
96659: LD_INT 2
96661: MUL
96662: ST_TO_ADDR
96663: GO 96691
// if amount > max then
96665: LD_VAR 0 9
96669: PUSH
96670: LD_VAR 0 4
96674: GREATER
96675: IFFALSE 96691
// r := r / 2 ;
96677: LD_ADDR_VAR 0 7
96681: PUSH
96682: LD_VAR 0 7
96686: PUSH
96687: LD_INT 2
96689: DIVREAL
96690: ST_TO_ADDR
// time := time / r ;
96691: LD_ADDR_VAR 0 8
96695: PUSH
96696: LD_VAR 0 8
96700: PUSH
96701: LD_VAR 0 7
96705: DIVREAL
96706: ST_TO_ADDR
// if time < 0 then
96707: LD_VAR 0 8
96711: PUSH
96712: LD_INT 0
96714: LESS
96715: IFFALSE 96732
// time := time * - 1 ;
96717: LD_ADDR_VAR 0 8
96721: PUSH
96722: LD_VAR 0 8
96726: PUSH
96727: LD_INT 1
96729: NEG
96730: MUL
96731: ST_TO_ADDR
// wait ( time ) ;
96732: LD_VAR 0 8
96736: PPUSH
96737: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
96741: LD_INT 35
96743: PPUSH
96744: LD_INT 875
96746: PPUSH
96747: CALL_OW 12
96751: PPUSH
96752: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
96756: LD_INT 1
96758: PPUSH
96759: LD_INT 5
96761: PPUSH
96762: CALL_OW 12
96766: PPUSH
96767: LD_VAR 0 1
96771: PPUSH
96772: LD_INT 1
96774: PPUSH
96775: CALL_OW 55
// end ;
96779: GO 96589
// end ;
96781: LD_VAR 0 5
96785: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
96786: LD_INT 0
96788: PPUSH
96789: PPUSH
96790: PPUSH
96791: PPUSH
96792: PPUSH
96793: PPUSH
96794: PPUSH
96795: PPUSH
// if not turrets or not factories then
96796: LD_VAR 0 1
96800: NOT
96801: PUSH
96802: LD_VAR 0 2
96806: NOT
96807: OR
96808: IFFALSE 96812
// exit ;
96810: GO 97119
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
96812: LD_ADDR_VAR 0 10
96816: PUSH
96817: LD_INT 5
96819: PUSH
96820: LD_INT 6
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: LD_INT 2
96829: PUSH
96830: LD_INT 4
96832: PUSH
96833: EMPTY
96834: LIST
96835: LIST
96836: PUSH
96837: LD_INT 3
96839: PUSH
96840: LD_INT 5
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: PUSH
96847: EMPTY
96848: LIST
96849: LIST
96850: LIST
96851: PUSH
96852: LD_INT 24
96854: PUSH
96855: LD_INT 25
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 23
96864: PUSH
96865: LD_INT 27
96867: PUSH
96868: EMPTY
96869: LIST
96870: LIST
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 42
96878: PUSH
96879: LD_INT 43
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 44
96888: PUSH
96889: LD_INT 46
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 45
96898: PUSH
96899: LD_INT 47
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: LIST
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: LIST
96915: ST_TO_ADDR
// result := [ ] ;
96916: LD_ADDR_VAR 0 3
96920: PUSH
96921: EMPTY
96922: ST_TO_ADDR
// for i in turrets do
96923: LD_ADDR_VAR 0 4
96927: PUSH
96928: LD_VAR 0 1
96932: PUSH
96933: FOR_IN
96934: IFFALSE 97117
// begin nat := GetNation ( i ) ;
96936: LD_ADDR_VAR 0 7
96940: PUSH
96941: LD_VAR 0 4
96945: PPUSH
96946: CALL_OW 248
96950: ST_TO_ADDR
// weapon := 0 ;
96951: LD_ADDR_VAR 0 8
96955: PUSH
96956: LD_INT 0
96958: ST_TO_ADDR
// if not nat then
96959: LD_VAR 0 7
96963: NOT
96964: IFFALSE 96968
// continue ;
96966: GO 96933
// for j in list [ nat ] do
96968: LD_ADDR_VAR 0 5
96972: PUSH
96973: LD_VAR 0 10
96977: PUSH
96978: LD_VAR 0 7
96982: ARRAY
96983: PUSH
96984: FOR_IN
96985: IFFALSE 97026
// if GetBWeapon ( i ) = j [ 1 ] then
96987: LD_VAR 0 4
96991: PPUSH
96992: CALL_OW 269
96996: PUSH
96997: LD_VAR 0 5
97001: PUSH
97002: LD_INT 1
97004: ARRAY
97005: EQUAL
97006: IFFALSE 97024
// begin weapon := j [ 2 ] ;
97008: LD_ADDR_VAR 0 8
97012: PUSH
97013: LD_VAR 0 5
97017: PUSH
97018: LD_INT 2
97020: ARRAY
97021: ST_TO_ADDR
// break ;
97022: GO 97026
// end ;
97024: GO 96984
97026: POP
97027: POP
// if not weapon then
97028: LD_VAR 0 8
97032: NOT
97033: IFFALSE 97037
// continue ;
97035: GO 96933
// for k in factories do
97037: LD_ADDR_VAR 0 6
97041: PUSH
97042: LD_VAR 0 2
97046: PUSH
97047: FOR_IN
97048: IFFALSE 97113
// begin weapons := AvailableWeaponList ( k ) ;
97050: LD_ADDR_VAR 0 9
97054: PUSH
97055: LD_VAR 0 6
97059: PPUSH
97060: CALL_OW 478
97064: ST_TO_ADDR
// if not weapons then
97065: LD_VAR 0 9
97069: NOT
97070: IFFALSE 97074
// continue ;
97072: GO 97047
// if weapon in weapons then
97074: LD_VAR 0 8
97078: PUSH
97079: LD_VAR 0 9
97083: IN
97084: IFFALSE 97111
// begin result := [ i , weapon ] ;
97086: LD_ADDR_VAR 0 3
97090: PUSH
97091: LD_VAR 0 4
97095: PUSH
97096: LD_VAR 0 8
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: ST_TO_ADDR
// exit ;
97105: POP
97106: POP
97107: POP
97108: POP
97109: GO 97119
// end ; end ;
97111: GO 97047
97113: POP
97114: POP
// end ;
97115: GO 96933
97117: POP
97118: POP
// end ;
97119: LD_VAR 0 3
97123: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
97124: LD_INT 0
97126: PPUSH
// if not side or side > 8 then
97127: LD_VAR 0 3
97131: NOT
97132: PUSH
97133: LD_VAR 0 3
97137: PUSH
97138: LD_INT 8
97140: GREATER
97141: OR
97142: IFFALSE 97146
// exit ;
97144: GO 97205
// if not range then
97146: LD_VAR 0 4
97150: NOT
97151: IFFALSE 97162
// range := - 12 ;
97153: LD_ADDR_VAR 0 4
97157: PUSH
97158: LD_INT 12
97160: NEG
97161: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
97162: LD_VAR 0 1
97166: PPUSH
97167: LD_VAR 0 2
97171: PPUSH
97172: LD_VAR 0 3
97176: PPUSH
97177: LD_VAR 0 4
97181: PPUSH
97182: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
97186: LD_VAR 0 1
97190: PPUSH
97191: LD_VAR 0 2
97195: PPUSH
97196: LD_VAR 0 3
97200: PPUSH
97201: CALL_OW 331
// end ;
97205: LD_VAR 0 5
97209: RET
// export function Video ( mode ) ; begin
97210: LD_INT 0
97212: PPUSH
// ingame_video = mode ;
97213: LD_ADDR_OWVAR 52
97217: PUSH
97218: LD_VAR 0 1
97222: ST_TO_ADDR
// interface_hidden = mode ;
97223: LD_ADDR_OWVAR 54
97227: PUSH
97228: LD_VAR 0 1
97232: ST_TO_ADDR
// end ;
97233: LD_VAR 0 2
97237: RET
// export function Join ( array , element ) ; begin
97238: LD_INT 0
97240: PPUSH
// result := Replace ( array , array + 1 , element ) ;
97241: LD_ADDR_VAR 0 3
97245: PUSH
97246: LD_VAR 0 1
97250: PPUSH
97251: LD_VAR 0 1
97255: PUSH
97256: LD_INT 1
97258: PLUS
97259: PPUSH
97260: LD_VAR 0 2
97264: PPUSH
97265: CALL_OW 1
97269: ST_TO_ADDR
// end ;
97270: LD_VAR 0 3
97274: RET
// export function JoinUnion ( array , element ) ; begin
97275: LD_INT 0
97277: PPUSH
// result := array union element ;
97278: LD_ADDR_VAR 0 3
97282: PUSH
97283: LD_VAR 0 1
97287: PUSH
97288: LD_VAR 0 2
97292: UNION
97293: ST_TO_ADDR
// end ;
97294: LD_VAR 0 3
97298: RET
// export function GetBehemoths ( side ) ; begin
97299: LD_INT 0
97301: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
97302: LD_ADDR_VAR 0 2
97306: PUSH
97307: LD_INT 22
97309: PUSH
97310: LD_VAR 0 1
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_INT 31
97321: PUSH
97322: LD_INT 25
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PPUSH
97333: CALL_OW 69
97337: ST_TO_ADDR
// end ;
97338: LD_VAR 0 2
97342: RET
// export function Shuffle ( array ) ; var i , index ; begin
97343: LD_INT 0
97345: PPUSH
97346: PPUSH
97347: PPUSH
// result := [ ] ;
97348: LD_ADDR_VAR 0 2
97352: PUSH
97353: EMPTY
97354: ST_TO_ADDR
// if not array then
97355: LD_VAR 0 1
97359: NOT
97360: IFFALSE 97364
// exit ;
97362: GO 97463
// Randomize ;
97364: CALL_OW 10
// for i = array downto 1 do
97368: LD_ADDR_VAR 0 3
97372: PUSH
97373: DOUBLE
97374: LD_VAR 0 1
97378: INC
97379: ST_TO_ADDR
97380: LD_INT 1
97382: PUSH
97383: FOR_DOWNTO
97384: IFFALSE 97461
// begin index := rand ( 1 , array ) ;
97386: LD_ADDR_VAR 0 4
97390: PUSH
97391: LD_INT 1
97393: PPUSH
97394: LD_VAR 0 1
97398: PPUSH
97399: CALL_OW 12
97403: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
97404: LD_ADDR_VAR 0 2
97408: PUSH
97409: LD_VAR 0 2
97413: PPUSH
97414: LD_VAR 0 2
97418: PUSH
97419: LD_INT 1
97421: PLUS
97422: PPUSH
97423: LD_VAR 0 1
97427: PUSH
97428: LD_VAR 0 4
97432: ARRAY
97433: PPUSH
97434: CALL_OW 2
97438: ST_TO_ADDR
// array := Delete ( array , index ) ;
97439: LD_ADDR_VAR 0 1
97443: PUSH
97444: LD_VAR 0 1
97448: PPUSH
97449: LD_VAR 0 4
97453: PPUSH
97454: CALL_OW 3
97458: ST_TO_ADDR
// end ;
97459: GO 97383
97461: POP
97462: POP
// end ;
97463: LD_VAR 0 2
97467: RET
// export function GetBaseMaterials ( base ) ; begin
97468: LD_INT 0
97470: PPUSH
// result := [ 0 , 0 , 0 ] ;
97471: LD_ADDR_VAR 0 2
97475: PUSH
97476: LD_INT 0
97478: PUSH
97479: LD_INT 0
97481: PUSH
97482: LD_INT 0
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: LIST
97489: ST_TO_ADDR
// if not base then
97490: LD_VAR 0 1
97494: NOT
97495: IFFALSE 97499
// exit ;
97497: GO 97548
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
97499: LD_ADDR_VAR 0 2
97503: PUSH
97504: LD_VAR 0 1
97508: PPUSH
97509: LD_INT 1
97511: PPUSH
97512: CALL_OW 275
97516: PUSH
97517: LD_VAR 0 1
97521: PPUSH
97522: LD_INT 2
97524: PPUSH
97525: CALL_OW 275
97529: PUSH
97530: LD_VAR 0 1
97534: PPUSH
97535: LD_INT 3
97537: PPUSH
97538: CALL_OW 275
97542: PUSH
97543: EMPTY
97544: LIST
97545: LIST
97546: LIST
97547: ST_TO_ADDR
// end ;
97548: LD_VAR 0 2
97552: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
97553: LD_INT 0
97555: PPUSH
97556: PPUSH
// result := array ;
97557: LD_ADDR_VAR 0 3
97561: PUSH
97562: LD_VAR 0 1
97566: ST_TO_ADDR
// if size > 0 then
97567: LD_VAR 0 2
97571: PUSH
97572: LD_INT 0
97574: GREATER
97575: IFFALSE 97621
// for i := array downto size do
97577: LD_ADDR_VAR 0 4
97581: PUSH
97582: DOUBLE
97583: LD_VAR 0 1
97587: INC
97588: ST_TO_ADDR
97589: LD_VAR 0 2
97593: PUSH
97594: FOR_DOWNTO
97595: IFFALSE 97619
// result := Delete ( result , result ) ;
97597: LD_ADDR_VAR 0 3
97601: PUSH
97602: LD_VAR 0 3
97606: PPUSH
97607: LD_VAR 0 3
97611: PPUSH
97612: CALL_OW 3
97616: ST_TO_ADDR
97617: GO 97594
97619: POP
97620: POP
// end ;
97621: LD_VAR 0 3
97625: RET
// export function ComExit ( unit ) ; var tmp ; begin
97626: LD_INT 0
97628: PPUSH
97629: PPUSH
// if not IsInUnit ( unit ) then
97630: LD_VAR 0 1
97634: PPUSH
97635: CALL_OW 310
97639: NOT
97640: IFFALSE 97644
// exit ;
97642: GO 97704
// tmp := IsInUnit ( unit ) ;
97644: LD_ADDR_VAR 0 3
97648: PUSH
97649: LD_VAR 0 1
97653: PPUSH
97654: CALL_OW 310
97658: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
97659: LD_VAR 0 3
97663: PPUSH
97664: CALL_OW 247
97668: PUSH
97669: LD_INT 2
97671: EQUAL
97672: IFFALSE 97685
// ComExitVehicle ( unit ) else
97674: LD_VAR 0 1
97678: PPUSH
97679: CALL_OW 121
97683: GO 97694
// ComExitBuilding ( unit ) ;
97685: LD_VAR 0 1
97689: PPUSH
97690: CALL_OW 122
// result := tmp ;
97694: LD_ADDR_VAR 0 2
97698: PUSH
97699: LD_VAR 0 3
97703: ST_TO_ADDR
// end ;
97704: LD_VAR 0 2
97708: RET
// export function ComExitAll ( units ) ; var i ; begin
97709: LD_INT 0
97711: PPUSH
97712: PPUSH
// if not units then
97713: LD_VAR 0 1
97717: NOT
97718: IFFALSE 97722
// exit ;
97720: GO 97748
// for i in units do
97722: LD_ADDR_VAR 0 3
97726: PUSH
97727: LD_VAR 0 1
97731: PUSH
97732: FOR_IN
97733: IFFALSE 97746
// ComExit ( i ) ;
97735: LD_VAR 0 3
97739: PPUSH
97740: CALL 97626 0 1
97744: GO 97732
97746: POP
97747: POP
// end ;
97748: LD_VAR 0 2
97752: RET
// export function ResetHc ; begin
97753: LD_INT 0
97755: PPUSH
// InitHc ;
97756: CALL_OW 19
// hc_importance := 0 ;
97760: LD_ADDR_OWVAR 32
97764: PUSH
97765: LD_INT 0
97767: ST_TO_ADDR
// end ;
97768: LD_VAR 0 1
97772: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
97773: LD_INT 0
97775: PPUSH
97776: PPUSH
97777: PPUSH
// _x := ( x1 + x2 ) div 2 ;
97778: LD_ADDR_VAR 0 6
97782: PUSH
97783: LD_VAR 0 1
97787: PUSH
97788: LD_VAR 0 3
97792: PLUS
97793: PUSH
97794: LD_INT 2
97796: DIV
97797: ST_TO_ADDR
// if _x < 0 then
97798: LD_VAR 0 6
97802: PUSH
97803: LD_INT 0
97805: LESS
97806: IFFALSE 97823
// _x := _x * - 1 ;
97808: LD_ADDR_VAR 0 6
97812: PUSH
97813: LD_VAR 0 6
97817: PUSH
97818: LD_INT 1
97820: NEG
97821: MUL
97822: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
97823: LD_ADDR_VAR 0 7
97827: PUSH
97828: LD_VAR 0 2
97832: PUSH
97833: LD_VAR 0 4
97837: PLUS
97838: PUSH
97839: LD_INT 2
97841: DIV
97842: ST_TO_ADDR
// if _y < 0 then
97843: LD_VAR 0 7
97847: PUSH
97848: LD_INT 0
97850: LESS
97851: IFFALSE 97868
// _y := _y * - 1 ;
97853: LD_ADDR_VAR 0 7
97857: PUSH
97858: LD_VAR 0 7
97862: PUSH
97863: LD_INT 1
97865: NEG
97866: MUL
97867: ST_TO_ADDR
// result := [ _x , _y ] ;
97868: LD_ADDR_VAR 0 5
97872: PUSH
97873: LD_VAR 0 6
97877: PUSH
97878: LD_VAR 0 7
97882: PUSH
97883: EMPTY
97884: LIST
97885: LIST
97886: ST_TO_ADDR
// end ;
97887: LD_VAR 0 5
97891: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
97892: LD_INT 0
97894: PPUSH
97895: PPUSH
97896: PPUSH
97897: PPUSH
// task := GetTaskList ( unit ) ;
97898: LD_ADDR_VAR 0 7
97902: PUSH
97903: LD_VAR 0 1
97907: PPUSH
97908: CALL_OW 437
97912: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
97913: LD_VAR 0 7
97917: NOT
97918: PUSH
97919: LD_VAR 0 1
97923: PPUSH
97924: LD_VAR 0 2
97928: PPUSH
97929: CALL_OW 308
97933: NOT
97934: AND
97935: IFFALSE 97939
// exit ;
97937: GO 98057
// if IsInArea ( unit , area ) then
97939: LD_VAR 0 1
97943: PPUSH
97944: LD_VAR 0 2
97948: PPUSH
97949: CALL_OW 308
97953: IFFALSE 97971
// begin ComMoveToArea ( unit , goAway ) ;
97955: LD_VAR 0 1
97959: PPUSH
97960: LD_VAR 0 3
97964: PPUSH
97965: CALL_OW 113
// exit ;
97969: GO 98057
// end ; if task [ 1 ] [ 1 ] <> M then
97971: LD_VAR 0 7
97975: PUSH
97976: LD_INT 1
97978: ARRAY
97979: PUSH
97980: LD_INT 1
97982: ARRAY
97983: PUSH
97984: LD_STRING M
97986: NONEQUAL
97987: IFFALSE 97991
// exit ;
97989: GO 98057
// x := task [ 1 ] [ 2 ] ;
97991: LD_ADDR_VAR 0 5
97995: PUSH
97996: LD_VAR 0 7
98000: PUSH
98001: LD_INT 1
98003: ARRAY
98004: PUSH
98005: LD_INT 2
98007: ARRAY
98008: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
98009: LD_ADDR_VAR 0 6
98013: PUSH
98014: LD_VAR 0 7
98018: PUSH
98019: LD_INT 1
98021: ARRAY
98022: PUSH
98023: LD_INT 3
98025: ARRAY
98026: ST_TO_ADDR
// if InArea ( x , y , area ) then
98027: LD_VAR 0 5
98031: PPUSH
98032: LD_VAR 0 6
98036: PPUSH
98037: LD_VAR 0 2
98041: PPUSH
98042: CALL_OW 309
98046: IFFALSE 98057
// ComStop ( unit ) ;
98048: LD_VAR 0 1
98052: PPUSH
98053: CALL_OW 141
// end ;
98057: LD_VAR 0 4
98061: RET
// export function Abs ( value ) ; begin
98062: LD_INT 0
98064: PPUSH
// result := value ;
98065: LD_ADDR_VAR 0 2
98069: PUSH
98070: LD_VAR 0 1
98074: ST_TO_ADDR
// if value < 0 then
98075: LD_VAR 0 1
98079: PUSH
98080: LD_INT 0
98082: LESS
98083: IFFALSE 98100
// result := value * - 1 ;
98085: LD_ADDR_VAR 0 2
98089: PUSH
98090: LD_VAR 0 1
98094: PUSH
98095: LD_INT 1
98097: NEG
98098: MUL
98099: ST_TO_ADDR
// end ;
98100: LD_VAR 0 2
98104: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
98105: LD_INT 0
98107: PPUSH
98108: PPUSH
98109: PPUSH
98110: PPUSH
98111: PPUSH
98112: PPUSH
98113: PPUSH
98114: PPUSH
// if not unit or not building then
98115: LD_VAR 0 1
98119: NOT
98120: PUSH
98121: LD_VAR 0 2
98125: NOT
98126: OR
98127: IFFALSE 98131
// exit ;
98129: GO 98357
// x := GetX ( building ) ;
98131: LD_ADDR_VAR 0 4
98135: PUSH
98136: LD_VAR 0 2
98140: PPUSH
98141: CALL_OW 250
98145: ST_TO_ADDR
// y := GetY ( building ) ;
98146: LD_ADDR_VAR 0 6
98150: PUSH
98151: LD_VAR 0 2
98155: PPUSH
98156: CALL_OW 251
98160: ST_TO_ADDR
// d := GetDir ( building ) ;
98161: LD_ADDR_VAR 0 8
98165: PUSH
98166: LD_VAR 0 2
98170: PPUSH
98171: CALL_OW 254
98175: ST_TO_ADDR
// r := 4 ;
98176: LD_ADDR_VAR 0 9
98180: PUSH
98181: LD_INT 4
98183: ST_TO_ADDR
// for i := 1 to 5 do
98184: LD_ADDR_VAR 0 10
98188: PUSH
98189: DOUBLE
98190: LD_INT 1
98192: DEC
98193: ST_TO_ADDR
98194: LD_INT 5
98196: PUSH
98197: FOR_TO
98198: IFFALSE 98355
// begin _x := ShiftX ( x , d , r + i ) ;
98200: LD_ADDR_VAR 0 5
98204: PUSH
98205: LD_VAR 0 4
98209: PPUSH
98210: LD_VAR 0 8
98214: PPUSH
98215: LD_VAR 0 9
98219: PUSH
98220: LD_VAR 0 10
98224: PLUS
98225: PPUSH
98226: CALL_OW 272
98230: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
98231: LD_ADDR_VAR 0 7
98235: PUSH
98236: LD_VAR 0 6
98240: PPUSH
98241: LD_VAR 0 8
98245: PPUSH
98246: LD_VAR 0 9
98250: PUSH
98251: LD_VAR 0 10
98255: PLUS
98256: PPUSH
98257: CALL_OW 273
98261: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
98262: LD_VAR 0 5
98266: PPUSH
98267: LD_VAR 0 7
98271: PPUSH
98272: CALL_OW 488
98276: PUSH
98277: LD_VAR 0 5
98281: PPUSH
98282: LD_VAR 0 7
98286: PPUSH
98287: CALL_OW 428
98291: PPUSH
98292: CALL_OW 247
98296: PUSH
98297: LD_INT 3
98299: PUSH
98300: LD_INT 2
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: IN
98307: NOT
98308: AND
98309: IFFALSE 98353
// begin ComMoveXY ( unit , _x , _y ) ;
98311: LD_VAR 0 1
98315: PPUSH
98316: LD_VAR 0 5
98320: PPUSH
98321: LD_VAR 0 7
98325: PPUSH
98326: CALL_OW 111
// result := [ _x , _y ] ;
98330: LD_ADDR_VAR 0 3
98334: PUSH
98335: LD_VAR 0 5
98339: PUSH
98340: LD_VAR 0 7
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: ST_TO_ADDR
// exit ;
98349: POP
98350: POP
98351: GO 98357
// end ; end ;
98353: GO 98197
98355: POP
98356: POP
// end ;
98357: LD_VAR 0 3
98361: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
98362: LD_INT 0
98364: PPUSH
98365: PPUSH
98366: PPUSH
// result := 0 ;
98367: LD_ADDR_VAR 0 3
98371: PUSH
98372: LD_INT 0
98374: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
98375: LD_VAR 0 1
98379: PUSH
98380: LD_INT 0
98382: LESS
98383: PUSH
98384: LD_VAR 0 1
98388: PUSH
98389: LD_INT 8
98391: GREATER
98392: OR
98393: PUSH
98394: LD_VAR 0 2
98398: PUSH
98399: LD_INT 0
98401: LESS
98402: OR
98403: PUSH
98404: LD_VAR 0 2
98408: PUSH
98409: LD_INT 8
98411: GREATER
98412: OR
98413: IFFALSE 98417
// exit ;
98415: GO 98492
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
98417: LD_ADDR_VAR 0 4
98421: PUSH
98422: LD_INT 22
98424: PUSH
98425: LD_VAR 0 2
98429: PUSH
98430: EMPTY
98431: LIST
98432: LIST
98433: PPUSH
98434: CALL_OW 69
98438: PUSH
98439: FOR_IN
98440: IFFALSE 98490
// begin un := UnitShoot ( i ) ;
98442: LD_ADDR_VAR 0 5
98446: PUSH
98447: LD_VAR 0 4
98451: PPUSH
98452: CALL_OW 504
98456: ST_TO_ADDR
// if GetSide ( un ) = side1 then
98457: LD_VAR 0 5
98461: PPUSH
98462: CALL_OW 255
98466: PUSH
98467: LD_VAR 0 1
98471: EQUAL
98472: IFFALSE 98488
// begin result := un ;
98474: LD_ADDR_VAR 0 3
98478: PUSH
98479: LD_VAR 0 5
98483: ST_TO_ADDR
// exit ;
98484: POP
98485: POP
98486: GO 98492
// end ; end ;
98488: GO 98439
98490: POP
98491: POP
// end ;
98492: LD_VAR 0 3
98496: RET
// export function GetCargoBay ( units ) ; begin
98497: LD_INT 0
98499: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
98500: LD_ADDR_VAR 0 2
98504: PUSH
98505: LD_VAR 0 1
98509: PPUSH
98510: LD_INT 2
98512: PUSH
98513: LD_INT 34
98515: PUSH
98516: LD_INT 12
98518: PUSH
98519: EMPTY
98520: LIST
98521: LIST
98522: PUSH
98523: LD_INT 34
98525: PUSH
98526: LD_INT 51
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PUSH
98533: LD_INT 34
98535: PUSH
98536: LD_INT 32
98538: PUSH
98539: EMPTY
98540: LIST
98541: LIST
98542: PUSH
98543: LD_INT 34
98545: PUSH
98546: LD_EXP 74
98550: PUSH
98551: EMPTY
98552: LIST
98553: LIST
98554: PUSH
98555: EMPTY
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: PPUSH
98562: CALL_OW 72
98566: ST_TO_ADDR
// end ;
98567: LD_VAR 0 2
98571: RET
// export function Negate ( value ) ; begin
98572: LD_INT 0
98574: PPUSH
// result := not value ;
98575: LD_ADDR_VAR 0 2
98579: PUSH
98580: LD_VAR 0 1
98584: NOT
98585: ST_TO_ADDR
// end ;
98586: LD_VAR 0 2
98590: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
98591: LD_INT 0
98593: PPUSH
// if x1 = x2 then
98594: LD_VAR 0 1
98598: PUSH
98599: LD_VAR 0 3
98603: EQUAL
98604: IFFALSE 98638
// begin if y1 > y2 then
98606: LD_VAR 0 2
98610: PUSH
98611: LD_VAR 0 4
98615: GREATER
98616: IFFALSE 98628
// result := 0 else
98618: LD_ADDR_VAR 0 5
98622: PUSH
98623: LD_INT 0
98625: ST_TO_ADDR
98626: GO 98636
// result := 3 ;
98628: LD_ADDR_VAR 0 5
98632: PUSH
98633: LD_INT 3
98635: ST_TO_ADDR
// exit ;
98636: GO 98724
// end ; if y1 = y2 then
98638: LD_VAR 0 2
98642: PUSH
98643: LD_VAR 0 4
98647: EQUAL
98648: IFFALSE 98682
// begin if x1 > x2 then
98650: LD_VAR 0 1
98654: PUSH
98655: LD_VAR 0 3
98659: GREATER
98660: IFFALSE 98672
// result := 1 else
98662: LD_ADDR_VAR 0 5
98666: PUSH
98667: LD_INT 1
98669: ST_TO_ADDR
98670: GO 98680
// result := 4 ;
98672: LD_ADDR_VAR 0 5
98676: PUSH
98677: LD_INT 4
98679: ST_TO_ADDR
// exit ;
98680: GO 98724
// end ; if x1 > x2 and y1 > y2 then
98682: LD_VAR 0 1
98686: PUSH
98687: LD_VAR 0 3
98691: GREATER
98692: PUSH
98693: LD_VAR 0 2
98697: PUSH
98698: LD_VAR 0 4
98702: GREATER
98703: AND
98704: IFFALSE 98716
// result := 2 else
98706: LD_ADDR_VAR 0 5
98710: PUSH
98711: LD_INT 2
98713: ST_TO_ADDR
98714: GO 98724
// result := 5 ;
98716: LD_ADDR_VAR 0 5
98720: PUSH
98721: LD_INT 5
98723: ST_TO_ADDR
// end ;
98724: LD_VAR 0 5
98728: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
98729: LD_INT 0
98731: PPUSH
98732: PPUSH
// if not driver or not IsInUnit ( driver ) then
98733: LD_VAR 0 1
98737: NOT
98738: PUSH
98739: LD_VAR 0 1
98743: PPUSH
98744: CALL_OW 310
98748: NOT
98749: OR
98750: IFFALSE 98754
// exit ;
98752: GO 98844
// vehicle := IsInUnit ( driver ) ;
98754: LD_ADDR_VAR 0 3
98758: PUSH
98759: LD_VAR 0 1
98763: PPUSH
98764: CALL_OW 310
98768: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
98769: LD_VAR 0 1
98773: PPUSH
98774: LD_STRING \
98776: PUSH
98777: LD_INT 0
98779: PUSH
98780: LD_INT 0
98782: PUSH
98783: LD_INT 0
98785: PUSH
98786: LD_INT 0
98788: PUSH
98789: LD_INT 0
98791: PUSH
98792: LD_INT 0
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: PUSH
98804: LD_STRING E
98806: PUSH
98807: LD_INT 0
98809: PUSH
98810: LD_INT 0
98812: PUSH
98813: LD_VAR 0 3
98817: PUSH
98818: LD_INT 0
98820: PUSH
98821: LD_INT 0
98823: PUSH
98824: LD_INT 0
98826: PUSH
98827: EMPTY
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: PUSH
98836: EMPTY
98837: LIST
98838: LIST
98839: PPUSH
98840: CALL_OW 446
// end ;
98844: LD_VAR 0 2
98848: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
98849: LD_INT 0
98851: PPUSH
98852: PPUSH
98853: PPUSH
// tmp := [ ] ;
98854: LD_ADDR_VAR 0 5
98858: PUSH
98859: EMPTY
98860: ST_TO_ADDR
// for i in units do
98861: LD_ADDR_VAR 0 4
98865: PUSH
98866: LD_VAR 0 1
98870: PUSH
98871: FOR_IN
98872: IFFALSE 98910
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
98874: LD_ADDR_VAR 0 5
98878: PUSH
98879: LD_VAR 0 5
98883: PPUSH
98884: LD_VAR 0 5
98888: PUSH
98889: LD_INT 1
98891: PLUS
98892: PPUSH
98893: LD_VAR 0 4
98897: PPUSH
98898: CALL_OW 256
98902: PPUSH
98903: CALL_OW 2
98907: ST_TO_ADDR
98908: GO 98871
98910: POP
98911: POP
// if not tmp then
98912: LD_VAR 0 5
98916: NOT
98917: IFFALSE 98921
// exit ;
98919: GO 98969
// if asc then
98921: LD_VAR 0 2
98925: IFFALSE 98949
// result := SortListByListAsc ( units , tmp ) else
98927: LD_ADDR_VAR 0 3
98931: PUSH
98932: LD_VAR 0 1
98936: PPUSH
98937: LD_VAR 0 5
98941: PPUSH
98942: CALL_OW 76
98946: ST_TO_ADDR
98947: GO 98969
// result := SortListByListDesc ( units , tmp ) ;
98949: LD_ADDR_VAR 0 3
98953: PUSH
98954: LD_VAR 0 1
98958: PPUSH
98959: LD_VAR 0 5
98963: PPUSH
98964: CALL_OW 77
98968: ST_TO_ADDR
// end ;
98969: LD_VAR 0 3
98973: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
98974: LD_INT 0
98976: PPUSH
98977: PPUSH
// task := GetTaskList ( mech ) ;
98978: LD_ADDR_VAR 0 4
98982: PUSH
98983: LD_VAR 0 1
98987: PPUSH
98988: CALL_OW 437
98992: ST_TO_ADDR
// if not task then
98993: LD_VAR 0 4
98997: NOT
98998: IFFALSE 99002
// exit ;
99000: GO 99044
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
99002: LD_ADDR_VAR 0 3
99006: PUSH
99007: LD_VAR 0 4
99011: PUSH
99012: LD_INT 1
99014: ARRAY
99015: PUSH
99016: LD_INT 1
99018: ARRAY
99019: PUSH
99020: LD_STRING r
99022: EQUAL
99023: PUSH
99024: LD_VAR 0 4
99028: PUSH
99029: LD_INT 1
99031: ARRAY
99032: PUSH
99033: LD_INT 4
99035: ARRAY
99036: PUSH
99037: LD_VAR 0 2
99041: EQUAL
99042: AND
99043: ST_TO_ADDR
// end ;
99044: LD_VAR 0 3
99048: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
99049: LD_INT 0
99051: PPUSH
// SetDir ( unit , d ) ;
99052: LD_VAR 0 1
99056: PPUSH
99057: LD_VAR 0 4
99061: PPUSH
99062: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
99066: LD_VAR 0 1
99070: PPUSH
99071: LD_VAR 0 2
99075: PPUSH
99076: LD_VAR 0 3
99080: PPUSH
99081: LD_VAR 0 5
99085: PPUSH
99086: CALL_OW 48
// end ; end_of_file
99090: LD_VAR 0 6
99094: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
99095: LD_VAR 0 1
99099: PUSH
99100: LD_INT 200
99102: DOUBLE
99103: GREATEREQUAL
99104: IFFALSE 99112
99106: LD_INT 299
99108: DOUBLE
99109: LESSEQUAL
99110: IFTRUE 99114
99112: GO 99146
99114: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
99115: LD_VAR 0 1
99119: PPUSH
99120: LD_VAR 0 2
99124: PPUSH
99125: LD_VAR 0 3
99129: PPUSH
99130: LD_VAR 0 4
99134: PPUSH
99135: LD_VAR 0 5
99139: PPUSH
99140: CALL 56617 0 5
99144: GO 99223
99146: LD_INT 300
99148: DOUBLE
99149: GREATEREQUAL
99150: IFFALSE 99158
99152: LD_INT 399
99154: DOUBLE
99155: LESSEQUAL
99156: IFTRUE 99160
99158: GO 99222
99160: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
99161: LD_VAR 0 1
99165: PPUSH
99166: LD_VAR 0 2
99170: PPUSH
99171: LD_VAR 0 3
99175: PPUSH
99176: LD_VAR 0 4
99180: PPUSH
99181: LD_VAR 0 5
99185: PPUSH
99186: LD_VAR 0 6
99190: PPUSH
99191: LD_VAR 0 7
99195: PPUSH
99196: LD_VAR 0 8
99200: PPUSH
99201: LD_VAR 0 9
99205: PPUSH
99206: LD_VAR 0 10
99210: PPUSH
99211: LD_VAR 0 11
99215: PPUSH
99216: CALL 54505 0 11
99220: GO 99223
99222: POP
// end ;
99223: PPOPN 11
99225: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
99226: LD_VAR 0 1
99230: PPUSH
99231: LD_VAR 0 2
99235: PPUSH
99236: LD_VAR 0 3
99240: PPUSH
99241: LD_VAR 0 4
99245: PPUSH
99246: LD_VAR 0 5
99250: PPUSH
99251: CALL 56599 0 5
// end ; end_of_file
99255: PPOPN 5
99257: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
99258: LD_VAR 0 1
99262: PPUSH
99263: LD_VAR 0 2
99267: PPUSH
99268: LD_VAR 0 3
99272: PPUSH
99273: LD_VAR 0 4
99277: PPUSH
99278: LD_VAR 0 5
99282: PPUSH
99283: LD_VAR 0 6
99287: PPUSH
99288: CALL 43313 0 6
// end ;
99292: PPOPN 6
99294: END
