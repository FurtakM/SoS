// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7462 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4583 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4882 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41846 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42297 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21193 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21129 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18122 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21029 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22043 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21270 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21063 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21096 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17901 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21951 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20208 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20783 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20783 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20580 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20244 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20420 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19704 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20318 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20819 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21559 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21129 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18122 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21029 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21270 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21063 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21096 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17901 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21951 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20208 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20783 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20783 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20580 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20244 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20420 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19704 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20318 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20819 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21559 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export ar_crane , ru_big_cargo_bay ; export dialog_north , dialog_south , dialog_popov , dialog_trans ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// ar_crane := 88 ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 88
1556: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 89
1564: ST_TO_ADDR
// dialog_north := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_south := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// dialog_popov := true ;
1581: LD_ADDR_EXP 9
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// dialog_trans := true ;
1589: LD_ADDR_EXP 10
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// call := true ;
1597: LD_ADDR_EXP 12
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// pink_attack := false ;
1605: LD_ADDR_EXP 13
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_support := false ;
1613: LD_ADDR_EXP 14
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// alfa_north_triggered := false ;
1621: LD_ADDR_EXP 15
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// alfa_south_triggered := false ;
1629: LD_ADDR_EXP 16
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19704 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11409 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21777 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11409 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21777 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11409 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21777 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11409 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21777 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 3
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 3
2743: PPUSH
2744: CALL 7681 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 3
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 4
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 4
2828: PPUSH
2829: CALL 7681 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 4
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7681 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7681 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7681 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4443
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 12
4392: PPUSH
4393: LD_INT -2
4395: PUSH
4396: LD_INT -5
4398: PUSH
4399: LD_INT -3
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PUSH
4407: LD_VAR 0 6
4411: ADD
4412: PPUSH
4413: LD_INT 1
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 3
4428: PUSH
4429: LD_INT 4
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: PPUSH
4438: CALL_OW 42
4442: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4443: LD_EXP 25
4447: PPUSH
4448: LD_INT 9
4450: PPUSH
4451: LD_INT 0
4453: PPUSH
4454: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4458: LD_VAR 0 5
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PPUSH
4467: LD_INT 2
4469: PPUSH
4470: CALL_OW 336
// for i = 1 to tmp do
4474: LD_ADDR_VAR 0 3
4478: PUSH
4479: DOUBLE
4480: LD_INT 1
4482: DEC
4483: ST_TO_ADDR
4484: LD_VAR 0 5
4488: PUSH
4489: FOR_TO
4490: IFFALSE 4545
// if i < 4 then
4492: LD_VAR 0 3
4496: PUSH
4497: LD_INT 4
4499: LESS
4500: IFFALSE 4525
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4502: LD_VAR 0 5
4506: PUSH
4507: LD_VAR 0 3
4511: ARRAY
4512: PPUSH
4513: LD_INT 9
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 49
4523: GO 4543
// SetSide ( tmp [ i ] , 6 ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 3
4534: ARRAY
4535: PPUSH
4536: LD_INT 6
4538: PPUSH
4539: CALL_OW 235
4543: GO 4489
4545: POP
4546: POP
// player_squad := tmp ;
4547: LD_ADDR_EXP 23
4551: PUSH
4552: LD_VAR 0 5
4556: ST_TO_ADDR
// pl_counter := 4 ;
4557: LD_ADDR_EXP 24
4561: PUSH
4562: LD_INT 4
4564: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4565: LD_INT 17
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: LD_INT 1
4573: PPUSH
4574: CALL 18122 0 3
// end ;
4578: LD_VAR 0 2
4582: RET
// export Popov ; export function InitAction ; var commander ; begin
4583: LD_INT 0
4585: PPUSH
4586: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4587: LD_INT 6
4589: PPUSH
4590: LD_INT 3
4592: PPUSH
4593: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4597: LD_INT 1
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: CALL_OW 86
// uc_side := 6 ;
4607: LD_ADDR_OWVAR 20
4611: PUSH
4612: LD_INT 6
4614: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4615: LD_ADDR_EXP 26
4619: PUSH
4620: LD_STRING Popov
4622: PPUSH
4623: CALL_OW 25
4627: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4628: LD_ADDR_OWVAR 67
4632: PUSH
4633: LD_INT 0
4635: PPUSH
4636: CALL_OW 426
4640: ST_TO_ADDR
// if not Difficulty then
4641: LD_OWVAR 67
4645: NOT
4646: IFFALSE 4656
// Difficulty := 2 ;
4648: LD_ADDR_OWVAR 67
4652: PUSH
4653: LD_INT 2
4655: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: LD_INT 1
4663: PPUSH
4664: CALL_OW 426
4668: ST_TO_ADDR
// if not commander then
4669: LD_VAR 0 2
4673: NOT
4674: IFFALSE 4684
// commander := 1 ;
4676: LD_ADDR_VAR 0 2
4680: PUSH
4681: LD_INT 1
4683: ST_TO_ADDR
// InitCommanders ( commander ) ;
4684: LD_VAR 0 2
4688: PPUSH
4689: CALL 3137 0 1
// end ;
4693: LD_VAR 0 1
4697: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4698: LD_EXP 24
4702: PUSH
4703: LD_INT 12
4705: LESS
4706: IFFALSE 4879
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
// begin enable ;
4714: ENABLE
// for i = pl_counter to pl_counter + 2 do
4715: LD_ADDR_VAR 0 1
4719: PUSH
4720: DOUBLE
4721: LD_EXP 24
4725: DEC
4726: ST_TO_ADDR
4727: LD_EXP 24
4731: PUSH
4732: LD_INT 2
4734: PLUS
4735: PUSH
4736: FOR_TO
4737: IFFALSE 4783
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4739: LD_EXP 23
4743: PUSH
4744: LD_VAR 0 1
4748: ARRAY
4749: PPUSH
4750: LD_INT 18
4752: PPUSH
4753: LD_INT 0
4755: PPUSH
4756: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4760: LD_EXP 23
4764: PUSH
4765: LD_VAR 0 1
4769: ARRAY
4770: PPUSH
4771: LD_INT 107
4773: PPUSH
4774: LD_INT 88
4776: PPUSH
4777: CALL_OW 111
// end ;
4781: GO 4736
4783: POP
4784: POP
// for i = pl_counter to pl_counter + 2 do
4785: LD_ADDR_VAR 0 1
4789: PUSH
4790: DOUBLE
4791: LD_EXP 24
4795: DEC
4796: ST_TO_ADDR
4797: LD_EXP 24
4801: PUSH
4802: LD_INT 2
4804: PLUS
4805: PUSH
4806: FOR_TO
4807: IFFALSE 4863
// begin repeat wait ( 0 0$01 ) ;
4809: LD_INT 35
4811: PPUSH
4812: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4816: LD_EXP 23
4820: PUSH
4821: LD_VAR 0 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 107
4829: PPUSH
4830: LD_INT 88
4832: PPUSH
4833: CALL_OW 297
4837: PUSH
4838: LD_INT 6
4840: LESS
4841: IFFALSE 4809
// SetSide ( player_squad [ i ] , 3 ) ;
4843: LD_EXP 23
4847: PUSH
4848: LD_VAR 0 1
4852: ARRAY
4853: PPUSH
4854: LD_INT 3
4856: PPUSH
4857: CALL_OW 235
// end ;
4861: GO 4806
4863: POP
4864: POP
// pl_counter := pl_counter + 3 ;
4865: LD_ADDR_EXP 24
4869: PUSH
4870: LD_EXP 24
4874: PUSH
4875: LD_INT 3
4877: PLUS
4878: ST_TO_ADDR
// end ;
4879: PPOPN 1
4881: END
// export function Dialog ; begin
4882: LD_INT 0
4884: PPUSH
// if not isTest then
4885: LD_EXP 1
4889: NOT
4890: IFFALSE 4912
// case query ( task ) of 1 :
4892: LD_STRING task
4894: PPUSH
4895: CALL_OW 97
4899: PUSH
4900: LD_INT 1
4902: DOUBLE
4903: EQUAL
4904: IFTRUE 4908
4906: GO 4911
4908: POP
// ; end ;
4909: GO 4912
4911: POP
// InGameOn ;
4912: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4916: LD_INT 107
4918: PPUSH
4919: LD_INT 84
4921: PPUSH
4922: CALL_OW 86
// if isTest then
4926: LD_EXP 1
4930: IFFALSE 4940
// dialogue_skipped := true ;
4932: LD_ADDR_OWVAR 59
4936: PUSH
4937: LD_INT 1
4939: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4940: LD_ADDR_EXP 11
4944: PUSH
4945: LD_EXP 23
4949: PUSH
4950: LD_INT 1
4952: ARRAY
4953: PPUSH
4954: LD_INT 0
4956: PPUSH
4957: LD_INT 96
4959: PPUSH
4960: LD_INT 79
4962: PPUSH
4963: LD_INT 2
4965: PPUSH
4966: CALL_OW 145
4970: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4971: LD_INT 35
4973: PPUSH
4974: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4978: LD_EXP 26
4982: PPUSH
4983: LD_STRING DR1
4985: PPUSH
4986: CALL_OW 94
// Wait ( 0 0$01 ) ;
4990: LD_INT 35
4992: PPUSH
4993: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4997: LD_EXP 26
5001: PPUSH
5002: LD_STRING DR2
5004: PPUSH
5005: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5009: LD_EXP 26
5013: PPUSH
5014: LD_STRING DR3
5016: PPUSH
5017: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5021: LD_INT 35
5023: PPUSH
5024: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5028: LD_INT 3
5030: PPUSH
5031: LD_INT 30
5033: PUSH
5034: LD_INT 0
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PPUSH
5041: CALL 11409 0 2
5045: PUSH
5046: LD_EXP 1
5050: OR
5051: IFFALSE 5021
// InGameOff ;
5053: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5057: LD_STRING C1
5059: PPUSH
5060: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5064: LD_INT 35
5066: PPUSH
5067: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5071: LD_EXP 11
5075: PPUSH
5076: CALL_OW 461
5080: PUSH
5081: LD_INT 2
5083: EQUAL
5084: IFFALSE 5064
// if not isTest then
5086: LD_EXP 1
5090: NOT
5091: IFFALSE 5113
// case query ( support ) of 1 :
5093: LD_STRING support
5095: PPUSH
5096: CALL_OW 97
5100: PUSH
5101: LD_INT 1
5103: DOUBLE
5104: EQUAL
5105: IFTRUE 5109
5107: GO 5112
5109: POP
// ; end ;
5110: GO 5113
5112: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5113: LD_INT 3
5115: PPUSH
5116: LD_INT 12
5118: PPUSH
5119: LD_INT 2
5121: PPUSH
5122: LD_INT 22
5124: PUSH
5125: LD_INT 3
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 30
5134: PUSH
5135: LD_INT 0
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: PUSH
5151: LD_INT 1
5153: ARRAY
5154: PPUSH
5155: CALL_OW 468
// if player_com = stolypin then
5159: LD_EXP 25
5163: PUSH
5164: LD_EXP 22
5168: EQUAL
5169: IFFALSE 5198
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5171: LD_INT 18
5173: PPUSH
5174: LD_INT 3
5176: PUSH
5177: LD_INT 3
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: PUSH
5188: LD_OWVAR 67
5192: ARRAY
5193: PPUSH
5194: CALL 6498 0 2
// end ;
5198: LD_VAR 0 1
5202: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5203: LD_EXP 12
5207: PUSH
5208: LD_OWVAR 1
5212: PUSH
5213: LD_INT 31500
5215: LESS
5216: AND
5217: IFFALSE 5381
// case query ( call1 ) of 1 :
5219: LD_STRING call1
5221: PPUSH
5222: CALL_OW 97
5226: PUSH
5227: LD_INT 1
5229: DOUBLE
5230: EQUAL
5231: IFTRUE 5235
5233: GO 5369
5235: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5236: LD_INT 3
5238: PPUSH
5239: LD_INT 12
5241: PPUSH
5242: LD_INT 1
5244: PPUSH
5245: LD_EXP 11
5249: PPUSH
5250: CALL_OW 468
// call := false ;
5254: LD_ADDR_EXP 12
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5262: LD_EXP 26
5266: PPUSH
5267: LD_STRING DR6
5269: PPUSH
5270: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5274: LD_INT 6300
5276: PPUSH
5277: LD_INT 8400
5279: PPUSH
5280: CALL_OW 12
5284: PPUSH
5285: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5289: LD_INT 18
5291: PUSH
5292: LD_INT 19
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: ARRAY
5310: PPUSH
5311: LD_INT 1
5313: PPUSH
5314: LD_INT 2
5316: PPUSH
5317: CALL_OW 12
5321: PPUSH
5322: CALL 6498 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5326: LD_INT 25200
5328: PPUSH
5329: LD_INT 35700
5331: PPUSH
5332: CALL_OW 12
5336: PPUSH
5337: CALL_OW 67
// call := true ;
5341: LD_ADDR_EXP 12
5345: PUSH
5346: LD_INT 1
5348: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5349: LD_INT 3
5351: PPUSH
5352: LD_INT 12
5354: PPUSH
5355: LD_INT 2
5357: PPUSH
5358: LD_EXP 11
5362: PPUSH
5363: CALL_OW 468
// end ; 2 :
5367: GO 5381
5369: LD_INT 2
5371: DOUBLE
5372: EQUAL
5373: IFTRUE 5377
5375: GO 5380
5377: POP
// ; end ;
5378: GO 5381
5380: POP
// if call and tick >= 15 15$00 then
5381: LD_EXP 12
5385: PUSH
5386: LD_OWVAR 1
5390: PUSH
5391: LD_INT 31500
5393: GREATEREQUAL
5394: AND
5395: IFFALSE 5824
// case query ( call2 ) of 1 :
5397: LD_STRING call2
5399: PPUSH
5400: CALL_OW 97
5404: PUSH
5405: LD_INT 1
5407: DOUBLE
5408: EQUAL
5409: IFTRUE 5413
5411: GO 5649
5413: POP
// begin call := false ;
5414: LD_ADDR_EXP 12
5418: PUSH
5419: LD_INT 0
5421: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5422: LD_INT 1
5424: PPUSH
5425: LD_INT 21
5427: PUSH
5428: LD_INT 3
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PPUSH
5435: CALL 11409 0 2
5439: PUSH
5440: LD_INT 4
5442: PPUSH
5443: LD_INT 21
5445: PUSH
5446: LD_INT 3
5448: PUSH
5449: EMPTY
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 11409 0 2
5457: AND
5458: IFFALSE 5506
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5460: LD_INT 18
5462: PUSH
5463: LD_INT 19
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 1
5472: PPUSH
5473: LD_INT 2
5475: PPUSH
5476: CALL_OW 12
5480: ARRAY
5481: PPUSH
5482: LD_INT 5
5484: PUSH
5485: LD_INT 4
5487: PUSH
5488: LD_INT 4
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PPUSH
5502: CALL 6259 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5506: LD_INT 1
5508: PPUSH
5509: LD_INT 21
5511: PUSH
5512: LD_INT 3
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PPUSH
5519: CALL 11409 0 2
5523: PUSH
5524: LD_INT 0
5526: EQUAL
5527: IFFALSE 5556
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5529: LD_INT 19
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 3
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6259 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 4
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11409 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5579: LD_INT 18
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 4
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6259 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5606: LD_INT 10500
5608: PPUSH
5609: LD_INT 23100
5611: PPUSH
5612: CALL_OW 12
5616: PPUSH
5617: CALL_OW 67
// call := true ;
5621: LD_ADDR_EXP 12
5625: PUSH
5626: LD_INT 1
5628: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5629: LD_INT 3
5631: PPUSH
5632: LD_INT 12
5634: PPUSH
5635: LD_INT 2
5637: PPUSH
5638: LD_EXP 11
5642: PPUSH
5643: CALL_OW 468
// end ; 2 :
5647: GO 5824
5649: LD_INT 2
5651: DOUBLE
5652: EQUAL
5653: IFTRUE 5657
5655: GO 5812
5657: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_EXP 11
5671: PPUSH
5672: CALL_OW 468
// call := false ;
5676: LD_ADDR_EXP 12
5680: PUSH
5681: LD_INT 0
5683: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5684: LD_EXP 26
5688: PPUSH
5689: LD_STRING DR6
5691: PPUSH
5692: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5696: LD_INT 6300
5698: PPUSH
5699: LD_INT 8400
5701: PPUSH
5702: CALL_OW 12
5706: PPUSH
5707: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5711: LD_INT 18
5713: PUSH
5714: LD_INT 19
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PUSH
5721: LD_INT 1
5723: PPUSH
5724: LD_INT 2
5726: PPUSH
5727: CALL_OW 12
5731: ARRAY
5732: PPUSH
5733: LD_INT 3
5735: PUSH
5736: LD_INT 2
5738: PUSH
5739: LD_INT 2
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_OWVAR 67
5751: ARRAY
5752: PUSH
5753: LD_INT 0
5755: PPUSH
5756: LD_INT 1
5758: PPUSH
5759: CALL_OW 12
5763: MINUS
5764: PPUSH
5765: CALL 6498 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5769: LD_INT 35700
5771: PPUSH
5772: LD_INT 44100
5774: PPUSH
5775: CALL_OW 12
5779: PPUSH
5780: CALL_OW 67
// call := true ;
5784: LD_ADDR_EXP 12
5788: PUSH
5789: LD_INT 1
5791: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5792: LD_INT 3
5794: PPUSH
5795: LD_INT 12
5797: PPUSH
5798: LD_INT 2
5800: PPUSH
5801: LD_EXP 11
5805: PPUSH
5806: CALL_OW 468
// end ; 3 :
5810: GO 5824
5812: LD_INT 3
5814: DOUBLE
5815: EQUAL
5816: IFTRUE 5820
5818: GO 5823
5820: POP
// ; end ;
5821: GO 5824
5823: POP
// end ;
5824: PPOPN 4
5826: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5827: LD_INT 22
5829: PUSH
5830: LD_INT 1
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: PUSH
5837: LD_INT 21
5839: PUSH
5840: LD_INT 1
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: CALL_OW 69
5855: PUSH
5856: LD_INT 0
5858: EQUAL
5859: PUSH
5860: LD_INT 22
5862: PUSH
5863: LD_INT 4
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 21
5872: PUSH
5873: LD_INT 1
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PPUSH
5884: CALL_OW 69
5888: PUSH
5889: LD_INT 0
5891: EQUAL
5892: AND
5893: IFFALSE 6097
5895: GO 5897
5897: DISABLE
// begin DialogueOn ;
5898: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5902: LD_EXP 26
5906: PPUSH
5907: LD_STRING DR7
5909: PPUSH
5910: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5914: LD_OWVAR 1
5918: PUSH
5919: LD_INT 116550
5921: PUSH
5922: LD_INT 95550
5924: PUSH
5925: LD_INT 89250
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: LIST
5932: PUSH
5933: LD_OWVAR 67
5937: ARRAY
5938: LESS
5939: IFFALSE 5953
// AddMedal ( med1 , 1 ) else
5941: LD_STRING med1
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: CALL_OW 101
5951: GO 5964
// AddMedal ( med1 , - 1 ) ;
5953: LD_STRING med1
5955: PPUSH
5956: LD_INT 1
5958: NEG
5959: PPUSH
5960: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5964: LD_INT 81
5966: PUSH
5967: LD_INT 3
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: PUSH
5974: LD_INT 21
5976: PUSH
5977: LD_INT 3
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: PPUSH
5988: CALL_OW 69
5992: PUSH
5993: LD_INT 0
5995: EQUAL
5996: IFFALSE 6010
// AddMedal ( med3 , 1 ) else
5998: LD_STRING med3
6000: PPUSH
6001: LD_INT 1
6003: PPUSH
6004: CALL_OW 101
6008: GO 6021
// AddMedal ( med3 , - 1 ) ;
6010: LD_STRING med3
6012: PPUSH
6013: LD_INT 1
6015: NEG
6016: PPUSH
6017: CALL_OW 101
// if player_squad = 15 then
6021: LD_EXP 23
6025: PUSH
6026: LD_INT 15
6028: EQUAL
6029: IFFALSE 6043
// AddMedal ( med2 , 1 ) else
6031: LD_STRING med2
6033: PPUSH
6034: LD_INT 1
6036: PPUSH
6037: CALL_OW 101
6041: GO 6086
// if player_squad > 12 and player_squad < 15 then
6043: LD_EXP 23
6047: PUSH
6048: LD_INT 12
6050: GREATER
6051: PUSH
6052: LD_EXP 23
6056: PUSH
6057: LD_INT 15
6059: LESS
6060: AND
6061: IFFALSE 6075
// AddMedal ( med2 , 2 ) else
6063: LD_STRING med2
6065: PPUSH
6066: LD_INT 2
6068: PPUSH
6069: CALL_OW 101
6073: GO 6086
// AddMedal ( med2 , - 1 ) ;
6075: LD_STRING med2
6077: PPUSH
6078: LD_INT 1
6080: NEG
6081: PPUSH
6082: CALL_OW 101
// GiveMedals ( MAIN ) ;
6086: LD_STRING MAIN
6088: PPUSH
6089: CALL_OW 102
// YouWin ;
6093: CALL_OW 103
// end ;
6097: END
// every 0 0$01 trigger IsDead ( player_com ) do
6098: LD_EXP 25
6102: PPUSH
6103: CALL_OW 301
6107: IFFALSE 6174
6109: GO 6111
6111: DISABLE
// begin if IsLive ( Houten ) then
6112: LD_EXP 3
6116: PPUSH
6117: CALL_OW 300
6121: IFFALSE 6137
// SayRadio ( Houten , DJ5 ) else
6123: LD_EXP 3
6127: PPUSH
6128: LD_STRING DJ5
6130: PPUSH
6131: CALL_OW 94
6135: GO 6160
// if IsLive ( Brown ) then
6137: LD_EXP 4
6141: PPUSH
6142: CALL_OW 300
6146: IFFALSE 6160
// SayRadio ( Brown , DS5 ) ;
6148: LD_EXP 4
6152: PPUSH
6153: LD_STRING DS5
6155: PPUSH
6156: CALL_OW 94
// Wait ( 0 0$01 ) ;
6160: LD_INT 35
6162: PPUSH
6163: CALL_OW 67
// YouLost ( dead ) ;
6167: LD_STRING dead
6169: PPUSH
6170: CALL_OW 104
// end ;
6174: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6175: LD_EXP 11
6179: PPUSH
6180: CALL_OW 301
6184: PUSH
6185: LD_EXP 1
6189: NOT
6190: AND
6191: IFFALSE 6258
6193: GO 6195
6195: DISABLE
// begin if IsLive ( Brown ) then
6196: LD_EXP 4
6200: PPUSH
6201: CALL_OW 300
6205: IFFALSE 6221
// SayRadio ( Brown , DS5 ) else
6207: LD_EXP 4
6211: PPUSH
6212: LD_STRING DS5
6214: PPUSH
6215: CALL_OW 94
6219: GO 6244
// if IsLive ( Houten ) then
6221: LD_EXP 3
6225: PPUSH
6226: CALL_OW 300
6230: IFFALSE 6244
// SayRadio ( Houten , DJ5 ) ;
6232: LD_EXP 3
6236: PPUSH
6237: LD_STRING DJ5
6239: PPUSH
6240: CALL_OW 94
// Wait ( 0 0$01 ) ;
6244: LD_INT 35
6246: PPUSH
6247: CALL_OW 67
// YouLost ( depot ) ;
6251: LD_STRING depot
6253: PPUSH
6254: CALL_OW 104
// end ;
6258: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6259: LD_INT 0
6261: PPUSH
6262: PPUSH
6263: PPUSH
// for i = 1 to n do
6264: LD_ADDR_VAR 0 4
6268: PUSH
6269: DOUBLE
6270: LD_INT 1
6272: DEC
6273: ST_TO_ADDR
6274: LD_VAR 0 2
6278: PUSH
6279: FOR_TO
6280: IFFALSE 6483
// begin uc_side := 6 ;
6282: LD_ADDR_OWVAR 20
6286: PUSH
6287: LD_INT 6
6289: ST_TO_ADDR
// uc_nation := 3 ;
6290: LD_ADDR_OWVAR 21
6294: PUSH
6295: LD_INT 3
6297: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6298: LD_ADDR_OWVAR 37
6302: PUSH
6303: LD_INT 23
6305: PUSH
6306: LD_INT 22
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: PUSH
6313: LD_INT 1
6315: PPUSH
6316: LD_INT 2
6318: PPUSH
6319: CALL_OW 12
6323: ARRAY
6324: ST_TO_ADDR
// vc_control := control_computer ;
6325: LD_ADDR_OWVAR 38
6329: PUSH
6330: LD_INT 3
6332: ST_TO_ADDR
// vc_engine := engine_siberite ;
6333: LD_ADDR_OWVAR 39
6337: PUSH
6338: LD_INT 3
6340: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6341: LD_ADDR_OWVAR 40
6345: PUSH
6346: LD_INT 43
6348: PUSH
6349: LD_INT 44
6351: PUSH
6352: LD_INT 44
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: LIST
6359: PUSH
6360: LD_INT 1
6362: PPUSH
6363: LD_INT 3
6365: PPUSH
6366: CALL_OW 12
6370: ARRAY
6371: ST_TO_ADDR
// un := CreateVehicle ;
6372: LD_ADDR_VAR 0 5
6376: PUSH
6377: CALL_OW 45
6381: ST_TO_ADDR
// case area of east_arr :
6382: LD_VAR 0 1
6386: PUSH
6387: LD_INT 18
6389: DOUBLE
6390: EQUAL
6391: IFTRUE 6395
6393: GO 6430
6395: POP
// begin PlaceUnitArea ( un , area , false ) ;
6396: LD_VAR 0 5
6400: PPUSH
6401: LD_VAR 0 1
6405: PPUSH
6406: LD_INT 0
6408: PPUSH
6409: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6413: LD_VAR 0 5
6417: PPUSH
6418: LD_INT 79
6420: PPUSH
6421: LD_INT 33
6423: PPUSH
6424: CALL_OW 111
// end ; south_arr :
6428: GO 6474
6430: LD_INT 19
6432: DOUBLE
6433: EQUAL
6434: IFTRUE 6438
6436: GO 6473
6438: POP
// begin PlaceUnitArea ( un , area , false ) ;
6439: LD_VAR 0 5
6443: PPUSH
6444: LD_VAR 0 1
6448: PPUSH
6449: LD_INT 0
6451: PPUSH
6452: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6456: LD_VAR 0 5
6460: PPUSH
6461: LD_INT 131
6463: PPUSH
6464: LD_INT 148
6466: PPUSH
6467: CALL_OW 111
// end ; end ;
6471: GO 6474
6473: POP
// Wait ( 0 0$02 ) ;
6474: LD_INT 70
6476: PPUSH
6477: CALL_OW 67
// end ;
6481: GO 6279
6483: POP
6484: POP
// pink_attack := true ;
6485: LD_ADDR_EXP 13
6489: PUSH
6490: LD_INT 1
6492: ST_TO_ADDR
// end ;
6493: LD_VAR 0 3
6497: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6498: LD_INT 0
6500: PPUSH
6501: PPUSH
6502: PPUSH
// for i = 1 to n do
6503: LD_ADDR_VAR 0 4
6507: PUSH
6508: DOUBLE
6509: LD_INT 1
6511: DEC
6512: ST_TO_ADDR
6513: LD_VAR 0 2
6517: PUSH
6518: FOR_TO
6519: IFFALSE 6745
// begin uc_side := 6 ;
6521: LD_ADDR_OWVAR 20
6525: PUSH
6526: LD_INT 6
6528: ST_TO_ADDR
// uc_nation := 3 ;
6529: LD_ADDR_OWVAR 21
6533: PUSH
6534: LD_INT 3
6536: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6537: LD_INT 0
6539: PPUSH
6540: LD_INT 3
6542: PPUSH
6543: LD_INT 4
6545: PPUSH
6546: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6550: LD_ADDR_OWVAR 37
6554: PUSH
6555: LD_INT 22
6557: ST_TO_ADDR
// vc_control := control_manual ;
6558: LD_ADDR_OWVAR 38
6562: PUSH
6563: LD_INT 1
6565: ST_TO_ADDR
// vc_engine := engine_combustion ;
6566: LD_ADDR_OWVAR 39
6570: PUSH
6571: LD_INT 1
6573: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6574: LD_ADDR_OWVAR 40
6578: PUSH
6579: LD_INT 51
6581: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6582: LD_ADDR_OWVAR 41
6586: PUSH
6587: LD_INT 50
6589: ST_TO_ADDR
// un := CreateVehicle ;
6590: LD_ADDR_VAR 0 5
6594: PUSH
6595: CALL_OW 45
6599: ST_TO_ADDR
// case area of east_arr :
6600: LD_VAR 0 1
6604: PUSH
6605: LD_INT 18
6607: DOUBLE
6608: EQUAL
6609: IFTRUE 6613
6611: GO 6628
6613: POP
// SetDir ( un , 4 ) ; south_arr :
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 4
6621: PPUSH
6622: CALL_OW 233
6626: GO 6652
6628: LD_INT 19
6630: DOUBLE
6631: EQUAL
6632: IFTRUE 6636
6634: GO 6651
6636: POP
// SetDir ( un , 5 ) ; end ;
6637: LD_VAR 0 5
6641: PPUSH
6642: LD_INT 5
6644: PPUSH
6645: CALL_OW 233
6649: GO 6652
6651: POP
// PlaceUnitArea ( un , area , false ) ;
6652: LD_VAR 0 5
6656: PPUSH
6657: LD_VAR 0 1
6661: PPUSH
6662: LD_INT 0
6664: PPUSH
6665: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6669: CALL_OW 44
6673: PPUSH
6674: LD_VAR 0 5
6678: PPUSH
6679: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6683: LD_VAR 0 5
6687: PPUSH
6688: LD_INT 1
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6698: LD_VAR 0 5
6702: PPUSH
6703: LD_INT 106
6705: PPUSH
6706: LD_INT 88
6708: PPUSH
6709: CALL_OW 111
// AddComUnload ( un ) ;
6713: LD_VAR 0 5
6717: PPUSH
6718: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6722: LD_VAR 0 5
6726: PPUSH
6727: LD_VAR 0 1
6731: PPUSH
6732: CALL_OW 173
// Wait ( 0 0$02 ) ;
6736: LD_INT 70
6738: PPUSH
6739: CALL_OW 67
// end ;
6743: GO 6518
6745: POP
6746: POP
// Wait ( 0 0$05 ) ;
6747: LD_INT 175
6749: PPUSH
6750: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6754: LD_INT 6
6756: PPUSH
6757: LD_INT 34
6759: PUSH
6760: LD_INT 51
6762: PUSH
6763: EMPTY
6764: LIST
6765: LIST
6766: PPUSH
6767: CALL 11409 0 2
6771: IFFALSE 6959
// begin wait ( 0 0$01 ) ;
6773: LD_INT 35
6775: PPUSH
6776: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6780: LD_ADDR_VAR 0 4
6784: PUSH
6785: LD_INT 6
6787: PPUSH
6788: LD_INT 34
6790: PUSH
6791: LD_INT 51
6793: PUSH
6794: EMPTY
6795: LIST
6796: LIST
6797: PPUSH
6798: CALL 11409 0 2
6802: PUSH
6803: FOR_IN
6804: IFFALSE 6955
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6806: LD_VAR 0 4
6810: PPUSH
6811: LD_INT 9
6813: PPUSH
6814: CALL_OW 308
6818: PUSH
6819: LD_VAR 0 4
6823: PPUSH
6824: CALL 31537 0 1
6828: PPUSH
6829: CALL_OW 258
6833: PUSH
6834: LD_INT 1
6836: EQUAL
6837: AND
6838: PUSH
6839: LD_EXP 10
6843: AND
6844: IFFALSE 6871
// begin Say ( GetDriver ( i ) , Dtran ) ;
6846: LD_VAR 0 4
6850: PPUSH
6851: CALL 31537 0 1
6855: PPUSH
6856: LD_STRING Dtran
6858: PPUSH
6859: CALL_OW 88
// dialog_trans := false ;
6863: LD_ADDR_EXP 10
6867: PUSH
6868: LD_INT 0
6870: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6871: LD_VAR 0 4
6875: PPUSH
6876: CALL_OW 316
6880: IFFALSE 6896
// ComMoveToArea ( i , area ) ;
6882: LD_VAR 0 4
6886: PPUSH
6887: LD_VAR 0 1
6891: PPUSH
6892: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6896: LD_VAR 0 4
6900: PPUSH
6901: LD_VAR 0 1
6905: PPUSH
6906: CALL_OW 308
6910: PUSH
6911: LD_VAR 0 4
6915: PPUSH
6916: LD_INT 1
6918: PPUSH
6919: CALL_OW 289
6923: PUSH
6924: LD_INT 0
6926: EQUAL
6927: AND
6928: IFFALSE 6953
// begin RemoveUnit ( GetDriver ( i ) ) ;
6930: LD_VAR 0 4
6934: PPUSH
6935: CALL 31537 0 1
6939: PPUSH
6940: CALL_OW 64
// RemoveUnit ( i ) ;
6944: LD_VAR 0 4
6948: PPUSH
6949: CALL_OW 64
// end ; end ;
6953: GO 6803
6955: POP
6956: POP
// end ;
6957: GO 6754
// end ;
6959: LD_VAR 0 3
6963: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6964: LD_INT 0
6966: PPUSH
6967: PPUSH
6968: PPUSH
6969: PPUSH
// if isTest then
6970: LD_EXP 1
6974: IFFALSE 6978
// exit ;
6976: GO 7367
// for i = 1 to n do
6978: LD_ADDR_VAR 0 4
6982: PUSH
6983: DOUBLE
6984: LD_INT 1
6986: DEC
6987: ST_TO_ADDR
6988: LD_VAR 0 2
6992: PUSH
6993: FOR_TO
6994: IFFALSE 7226
// begin uc_side := 8 ;
6996: LD_ADDR_OWVAR 20
7000: PUSH
7001: LD_INT 8
7003: ST_TO_ADDR
// uc_nation := 1 ;
7004: LD_ADDR_OWVAR 21
7008: PUSH
7009: LD_INT 1
7011: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7012: LD_ADDR_VAR 0 6
7016: PUSH
7017: LD_INT 3
7019: PUSH
7020: LD_INT 4
7022: PUSH
7023: LD_INT 4
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 1
7033: PPUSH
7034: LD_OWVAR 67
7038: PPUSH
7039: CALL_OW 12
7043: ARRAY
7044: ST_TO_ADDR
// vc_chassis := ch ;
7045: LD_ADDR_OWVAR 37
7049: PUSH
7050: LD_VAR 0 6
7054: ST_TO_ADDR
// vc_control := control_computer ;
7055: LD_ADDR_OWVAR 38
7059: PUSH
7060: LD_INT 3
7062: ST_TO_ADDR
// vc_engine := engine_combustion ;
7063: LD_ADDR_OWVAR 39
7067: PUSH
7068: LD_INT 1
7070: ST_TO_ADDR
// if ch = us_medium_tracked then
7071: LD_VAR 0 6
7075: PUSH
7076: LD_INT 3
7078: EQUAL
7079: IFFALSE 7126
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7081: LD_ADDR_OWVAR 40
7085: PUSH
7086: LD_INT 3
7088: PUSH
7089: LD_INT 4
7091: PUSH
7092: LD_INT 5
7094: PUSH
7095: LD_INT 7
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: LIST
7102: LIST
7103: PUSH
7104: LD_OWVAR 67
7108: PPUSH
7109: LD_OWVAR 67
7113: PUSH
7114: LD_INT 1
7116: PLUS
7117: PPUSH
7118: CALL_OW 12
7122: ARRAY
7123: ST_TO_ADDR
7124: GO 7167
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7126: LD_ADDR_OWVAR 40
7130: PUSH
7131: LD_INT 5
7133: PUSH
7134: LD_INT 6
7136: PUSH
7137: LD_INT 7
7139: PUSH
7140: LD_INT 7
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: LIST
7147: LIST
7148: PUSH
7149: LD_INT 1
7151: PPUSH
7152: LD_OWVAR 67
7156: PUSH
7157: LD_INT 1
7159: PLUS
7160: PPUSH
7161: CALL_OW 12
7165: ARRAY
7166: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7167: LD_ADDR_OWVAR 41
7171: PUSH
7172: LD_INT 70
7174: ST_TO_ADDR
// un := CreateVehicle ;
7175: LD_ADDR_VAR 0 5
7179: PUSH
7180: CALL_OW 45
7184: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7185: LD_VAR 0 5
7189: PPUSH
7190: LD_VAR 0 1
7194: PPUSH
7195: LD_INT 0
7197: PPUSH
7198: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7202: LD_VAR 0 5
7206: PPUSH
7207: LD_INT 65
7209: PPUSH
7210: LD_INT 9
7212: PPUSH
7213: CALL_OW 111
// Wait ( 0 0$02 ) ;
7217: LD_INT 70
7219: PPUSH
7220: CALL_OW 67
// end ;
7224: GO 6993
7226: POP
7227: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7228: LD_INT 90
7230: PUSH
7231: LD_INT 80
7233: PUSH
7234: LD_INT 70
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_OWVAR 67
7246: ARRAY
7247: PPUSH
7248: CALL_OW 13
7252: IFFALSE 7359
// begin uc_side := 8 ;
7254: LD_ADDR_OWVAR 20
7258: PUSH
7259: LD_INT 8
7261: ST_TO_ADDR
// uc_nation := 1 ;
7262: LD_ADDR_OWVAR 21
7266: PUSH
7267: LD_INT 1
7269: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7270: LD_ADDR_OWVAR 37
7274: PUSH
7275: LD_INT 4
7277: ST_TO_ADDR
// vc_control := control_computer ;
7278: LD_ADDR_OWVAR 38
7282: PUSH
7283: LD_INT 3
7285: ST_TO_ADDR
// vc_engine := engine_combustion ;
7286: LD_ADDR_OWVAR 39
7290: PUSH
7291: LD_INT 1
7293: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7294: LD_ADDR_OWVAR 40
7298: PUSH
7299: LD_INT 14
7301: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7302: LD_ADDR_OWVAR 41
7306: PUSH
7307: LD_INT 70
7309: ST_TO_ADDR
// un := CreateVehicle ;
7310: LD_ADDR_VAR 0 5
7314: PUSH
7315: CALL_OW 45
7319: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7320: LD_VAR 0 5
7324: PPUSH
7325: LD_VAR 0 1
7329: PPUSH
7330: LD_INT 0
7332: PPUSH
7333: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7337: LD_VAR 0 5
7341: PPUSH
7342: LD_INT 65
7344: PPUSH
7345: LD_INT 9
7347: PPUSH
7348: CALL_OW 111
// Wait ( 0 0$02 ) ;
7352: LD_INT 70
7354: PPUSH
7355: CALL_OW 67
// end ; alfa_support := true ;
7359: LD_ADDR_EXP 14
7363: PUSH
7364: LD_INT 1
7366: ST_TO_ADDR
// end ;
7367: LD_VAR 0 3
7371: RET
// every 0 0$01 trigger tick mod [ 21 21$00 , 16 16$00 , 12 12$00 ] [ Difficulty ] = 0 do
7372: LD_OWVAR 1
7376: PUSH
7377: LD_INT 44100
7379: PUSH
7380: LD_INT 33600
7382: PUSH
7383: LD_INT 25200
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: LIST
7390: PUSH
7391: LD_OWVAR 67
7395: ARRAY
7396: MOD
7397: PUSH
7398: LD_INT 0
7400: EQUAL
7401: IFFALSE 7461
7403: GO 7405
7405: DISABLE
// begin enable ;
7406: ENABLE
// SayRadio ( Popov , DR5 ) ;
7407: LD_EXP 26
7411: PPUSH
7412: LD_STRING DR5
7414: PPUSH
7415: CALL_OW 94
// Wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7419: LD_INT 1050
7421: PPUSH
7422: LD_INT 4200
7424: PPUSH
7425: CALL_OW 12
7429: PPUSH
7430: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7434: LD_INT 20
7436: PPUSH
7437: LD_INT 5
7439: PUSH
7440: LD_INT 6
7442: PUSH
7443: LD_INT 7
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: LIST
7450: PUSH
7451: LD_OWVAR 67
7455: ARRAY
7456: PPUSH
7457: CALL 6964 0 2
// end ; end_of_file
7461: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7462: LD_INT 0
7464: PPUSH
// enable_addtolog := isTest ;
7465: LD_ADDR_OWVAR 81
7469: PUSH
7470: LD_EXP 1
7474: ST_TO_ADDR
// lines_break_limit := 5 ;
7475: LD_ADDR_EXP 28
7479: PUSH
7480: LD_INT 5
7482: ST_TO_ADDR
// lines_break_type := --- ;
7483: LD_ADDR_EXP 29
7487: PUSH
7488: LD_STRING ---
7490: ST_TO_ADDR
// lines_counter := 0 ;
7491: LD_ADDR_EXP 27
7495: PUSH
7496: LD_INT 0
7498: ST_TO_ADDR
// show_line_index := true ;
7499: LD_ADDR_EXP 30
7503: PUSH
7504: LD_INT 1
7506: ST_TO_ADDR
// tick_log := true ;
7507: LD_ADDR_EXP 31
7511: PUSH
7512: LD_INT 1
7514: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7515: LD_STRING ----------SAND OF SIBERIA LOG----------
7517: PPUSH
7518: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7522: LD_STRING Map Name: 
7524: PUSH
7525: LD_OWVAR 68
7529: STR
7530: PPUSH
7531: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7535: LD_STRING Map Number: 
7537: PUSH
7538: LD_OWVAR 70
7542: STR
7543: PPUSH
7544: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7548: LD_STRING Difficulty: 
7550: PUSH
7551: LD_OWVAR 67
7555: STR
7556: PPUSH
7557: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7561: LD_STRING ---------------------------------------
7563: PPUSH
7564: CALL_OW 561
// end ;
7568: LD_VAR 0 1
7572: RET
// function Log ( text ) ; begin
7573: LD_INT 0
7575: PPUSH
// if show_line_index then
7576: LD_EXP 30
7580: IFFALSE 7592
// result := lines_counter ;
7582: LD_ADDR_VAR 0 2
7586: PUSH
7587: LD_EXP 27
7591: ST_TO_ADDR
// if tick_log then
7592: LD_EXP 31
7596: IFFALSE 7622
// result := result &  T:  & tick &   ;
7598: LD_ADDR_VAR 0 2
7602: PUSH
7603: LD_VAR 0 2
7607: PUSH
7608: LD_STRING  T: 
7610: STR
7611: PUSH
7612: LD_OWVAR 1
7616: STR
7617: PUSH
7618: LD_STRING  
7620: STR
7621: ST_TO_ADDR
// AddToLog ( result & text ) ;
7622: LD_VAR 0 2
7626: PUSH
7627: LD_VAR 0 1
7631: STR
7632: PPUSH
7633: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7637: LD_ADDR_EXP 27
7641: PUSH
7642: LD_EXP 27
7646: PUSH
7647: LD_INT 1
7649: PLUS
7650: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7651: LD_EXP 27
7655: PUSH
7656: LD_EXP 28
7660: MOD
7661: PUSH
7662: LD_INT 0
7664: EQUAL
7665: IFFALSE 7676
// AddToLog ( lines_break_type ) ;
7667: LD_EXP 29
7671: PPUSH
7672: CALL_OW 561
// end ;
7676: LD_VAR 0 2
7680: RET
// export function LogHuman ( id ) ; begin
7681: LD_INT 0
7683: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7684: LD_STRING Human Created. id: 
7686: PUSH
7687: LD_VAR 0 1
7691: STR
7692: PUSH
7693: LD_STRING ; side: 
7695: STR
7696: PUSH
7697: LD_VAR 0 1
7701: PPUSH
7702: CALL_OW 255
7706: STR
7707: PUSH
7708: LD_STRING ; class: 
7710: STR
7711: PUSH
7712: LD_VAR 0 1
7716: PPUSH
7717: CALL_OW 257
7721: STR
7722: PUSH
7723: LD_STRING ; 
7725: STR
7726: PPUSH
7727: CALL 7573 0 1
// end ;
7731: LD_VAR 0 2
7735: RET
// export function LogVeh ( id ) ; begin
7736: LD_INT 0
7738: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7739: LD_STRING Vehicle Created. id: 
7741: PUSH
7742: LD_VAR 0 1
7746: STR
7747: PUSH
7748: LD_STRING ; side: 
7750: STR
7751: PUSH
7752: LD_VAR 0 1
7756: PPUSH
7757: CALL_OW 255
7761: STR
7762: PUSH
7763: LD_STRING ; nation: 
7765: STR
7766: PUSH
7767: LD_VAR 0 1
7771: PPUSH
7772: CALL_OW 248
7776: STR
7777: PUSH
7778: LD_STRING ; weapon: 
7780: STR
7781: PUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 264
7791: STR
7792: PUSH
7793: LD_STRING ; 
7795: STR
7796: PPUSH
7797: CALL 7573 0 1
// end ;
7801: LD_VAR 0 2
7805: RET
// export function LogEvent ( event ) ; begin
7806: LD_INT 0
7808: PPUSH
// Log ( Event Executed. id:  & event ) ;
7809: LD_STRING Event Executed. id: 
7811: PUSH
7812: LD_VAR 0 1
7816: STR
7817: PPUSH
7818: CALL 7573 0 1
// end ; end_of_file
7822: LD_VAR 0 2
7826: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
7831: PPUSH
7832: PPUSH
7833: PPUSH
7834: PPUSH
7835: PPUSH
7836: PPUSH
// if unit then
7837: LD_VAR 0 1
7841: IFFALSE 8241
// begin if mode = 0 then
7843: LD_VAR 0 3
7847: PUSH
7848: LD_INT 0
7850: EQUAL
7851: IFFALSE 7999
// begin if coords then
7853: LD_VAR 0 2
7857: IFFALSE 7997
// while ( coords > 1 ) do
7859: LD_VAR 0 2
7863: PUSH
7864: LD_INT 1
7866: GREATER
7867: IFFALSE 7997
// if not HasTask ( unit ) then
7869: LD_VAR 0 1
7873: PPUSH
7874: CALL_OW 314
7878: NOT
7879: IFFALSE 7995
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7881: LD_VAR 0 1
7885: PPUSH
7886: LD_VAR 0 2
7890: PUSH
7891: LD_INT 1
7893: ARRAY
7894: PPUSH
7895: LD_VAR 0 2
7899: PUSH
7900: LD_INT 2
7902: ARRAY
7903: PPUSH
7904: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7908: LD_INT 35
7910: PPUSH
7911: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7915: LD_VAR 0 1
7919: PPUSH
7920: CALL_OW 250
7924: PUSH
7925: LD_VAR 0 2
7929: PUSH
7930: LD_INT 1
7932: ARRAY
7933: EQUAL
7934: PUSH
7935: LD_VAR 0 1
7939: PPUSH
7940: CALL_OW 251
7944: PUSH
7945: LD_VAR 0 2
7949: PUSH
7950: LD_INT 2
7952: ARRAY
7953: EQUAL
7954: AND
7955: IFFALSE 7908
// for i = 1 to 2 do
7957: LD_ADDR_VAR 0 5
7961: PUSH
7962: DOUBLE
7963: LD_INT 1
7965: DEC
7966: ST_TO_ADDR
7967: LD_INT 2
7969: PUSH
7970: FOR_TO
7971: IFFALSE 7993
// coords := Delete ( coords , 1 ) ;
7973: LD_ADDR_VAR 0 2
7977: PUSH
7978: LD_VAR 0 2
7982: PPUSH
7983: LD_INT 1
7985: PPUSH
7986: CALL_OW 3
7990: ST_TO_ADDR
7991: GO 7970
7993: POP
7994: POP
// end ;
7995: GO 7859
// end else
7997: GO 8241
// begin if coords then
7999: LD_VAR 0 2
8003: IFFALSE 8241
// begin x := GetX ( unit ) ;
8005: LD_ADDR_VAR 0 6
8009: PUSH
8010: LD_VAR 0 1
8014: PPUSH
8015: CALL_OW 250
8019: ST_TO_ADDR
// y := GetY ( unit ) ;
8020: LD_ADDR_VAR 0 7
8024: PUSH
8025: LD_VAR 0 1
8029: PPUSH
8030: CALL_OW 251
8034: ST_TO_ADDR
// while ( coords > 1 ) do
8035: LD_VAR 0 2
8039: PUSH
8040: LD_INT 1
8042: GREATER
8043: IFFALSE 8241
// begin Wait ( 0 0$0.3 ) ;
8045: LD_INT 10
8047: PPUSH
8048: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 255
8061: PPUSH
8062: LD_VAR 0 1
8066: PPUSH
8067: CALL_OW 250
8071: PPUSH
8072: LD_VAR 0 1
8076: PPUSH
8077: CALL_OW 251
8081: PPUSH
8082: LD_INT 14
8084: PPUSH
8085: CALL 22579 0 4
8089: IFFALSE 8120
// begin ComMoveXY ( unit , x , y ) ;
8091: LD_VAR 0 1
8095: PPUSH
8096: LD_VAR 0 6
8100: PPUSH
8101: LD_VAR 0 7
8105: PPUSH
8106: CALL_OW 111
// result := false ;
8110: LD_ADDR_VAR 0 4
8114: PUSH
8115: LD_INT 0
8117: ST_TO_ADDR
// end else
8118: GO 8159
// if not HasTask ( unit ) then
8120: LD_VAR 0 1
8124: PPUSH
8125: CALL_OW 314
8129: NOT
8130: IFFALSE 8159
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8132: LD_VAR 0 1
8136: PPUSH
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 1
8144: ARRAY
8145: PPUSH
8146: LD_VAR 0 2
8150: PUSH
8151: LD_INT 2
8153: ARRAY
8154: PPUSH
8155: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8159: LD_VAR 0 1
8163: PPUSH
8164: CALL_OW 250
8168: PUSH
8169: LD_VAR 0 2
8173: PUSH
8174: LD_INT 1
8176: ARRAY
8177: EQUAL
8178: PUSH
8179: LD_VAR 0 1
8183: PPUSH
8184: CALL_OW 251
8188: PUSH
8189: LD_VAR 0 2
8193: PUSH
8194: LD_INT 2
8196: ARRAY
8197: EQUAL
8198: AND
8199: IFFALSE 8239
// for i = 1 to 2 do
8201: LD_ADDR_VAR 0 5
8205: PUSH
8206: DOUBLE
8207: LD_INT 1
8209: DEC
8210: ST_TO_ADDR
8211: LD_INT 2
8213: PUSH
8214: FOR_TO
8215: IFFALSE 8237
// coords := Delete ( coords , 1 ) ;
8217: LD_ADDR_VAR 0 2
8221: PUSH
8222: LD_VAR 0 2
8226: PPUSH
8227: LD_INT 1
8229: PPUSH
8230: CALL_OW 3
8234: ST_TO_ADDR
8235: GO 8214
8237: POP
8238: POP
// end ;
8239: GO 8035
// end ; end ; end ; result := true ;
8241: LD_ADDR_VAR 0 4
8245: PUSH
8246: LD_INT 1
8248: ST_TO_ADDR
// end ;
8249: LD_VAR 0 4
8253: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8254: LD_INT 0
8256: PPUSH
8257: PPUSH
8258: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8259: LD_ADDR_VAR 0 5
8263: PUSH
8264: LD_INT 81
8266: PUSH
8267: LD_VAR 0 1
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: PPUSH
8276: CALL_OW 69
8280: ST_TO_ADDR
// for i in units do
8281: LD_ADDR_VAR 0 4
8285: PUSH
8286: LD_VAR 0 2
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8320
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8294: LD_VAR 0 4
8298: PPUSH
8299: LD_VAR 0 5
8303: PPUSH
8304: LD_VAR 0 4
8308: PPUSH
8309: CALL_OW 74
8313: PPUSH
8314: CALL_OW 115
// end ;
8318: GO 8291
8320: POP
8321: POP
// end ;
8322: LD_VAR 0 3
8326: RET
// export function MC_Show ( string ) ; begin
8327: LD_INT 0
8329: PPUSH
// display_strings := string ;
8330: LD_ADDR_OWVAR 47
8334: PUSH
8335: LD_VAR 0 1
8339: ST_TO_ADDR
// end ; end_of_file
8340: LD_VAR 0 2
8344: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8345: LD_INT 0
8347: PPUSH
8348: PPUSH
8349: PPUSH
8350: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8351: LD_ADDR_VAR 0 8
8355: PUSH
8356: LD_VAR 0 1
8360: PPUSH
8361: LD_INT 2
8363: PPUSH
8364: EMPTY
8365: PPUSH
8366: CALL 11492 0 3
8370: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8371: LD_VAR 0 8
8375: PUSH
8376: LD_VAR 0 2
8380: PPUSH
8381: LD_VAR 0 3
8385: PPUSH
8386: CALL_OW 428
8390: PUSH
8391: LD_INT 0
8393: EQUAL
8394: AND
8395: IFFALSE 8469
// for i = 1 to plist do
8397: LD_ADDR_VAR 0 6
8401: PUSH
8402: DOUBLE
8403: LD_INT 1
8405: DEC
8406: ST_TO_ADDR
8407: LD_VAR 0 8
8411: PUSH
8412: FOR_TO
8413: IFFALSE 8467
// if NotTask ( plist [ i ] ) then
8415: LD_VAR 0 8
8419: PUSH
8420: LD_VAR 0 6
8424: ARRAY
8425: PPUSH
8426: CALL 32182 0 1
8430: IFFALSE 8465
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8432: LD_VAR 0 8
8436: PUSH
8437: LD_VAR 0 6
8441: ARRAY
8442: PPUSH
8443: LD_INT 0
8445: PPUSH
8446: LD_VAR 0 2
8450: PPUSH
8451: LD_VAR 0 3
8455: PPUSH
8456: LD_VAR 0 4
8460: PPUSH
8461: CALL_OW 145
// end ;
8465: GO 8412
8467: POP
8468: POP
// end ;
8469: LD_VAR 0 5
8473: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8474: LD_INT 0
8476: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8477: LD_VAR 0 1
8481: PPUSH
8482: LD_INT 6
8484: PPUSH
8485: LD_VAR 0 2
8489: PPUSH
8490: LD_VAR 0 3
8494: PPUSH
8495: LD_VAR 0 4
8499: PPUSH
8500: CALL 9978 0 5
// end ;
8504: LD_VAR 0 5
8508: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8509: LD_INT 0
8511: PPUSH
8512: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8513: LD_ADDR_VAR 0 4
8517: PUSH
8518: LD_INT 22
8520: PUSH
8521: LD_VAR 0 1
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: LD_INT 2
8532: PUSH
8533: LD_INT 30
8535: PUSH
8536: LD_INT 0
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: PUSH
8543: LD_INT 30
8545: PUSH
8546: LD_INT 1
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: LIST
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PUSH
8562: EMPTY
8563: LIST
8564: PPUSH
8565: CALL_OW 69
8569: PPUSH
8570: LD_VAR 0 2
8574: PPUSH
8575: CALL_OW 250
8579: PPUSH
8580: LD_VAR 0 2
8584: PPUSH
8585: CALL_OW 251
8589: PPUSH
8590: CALL_OW 73
8594: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8595: LD_VAR 0 4
8599: PPUSH
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL 10267 0 2
8609: IFFALSE 8668
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8611: LD_VAR 0 1
8615: PPUSH
8616: LD_INT 30
8618: PUSH
8619: LD_VAR 0 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PPUSH
8628: CALL 11409 0 2
8632: PUSH
8633: LD_INT 1
8635: ARRAY
8636: PPUSH
8637: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8641: LD_ADDR_EXP 50
8645: PUSH
8646: LD_EXP 50
8650: PPUSH
8651: LD_VAR 0 1
8655: PPUSH
8656: LD_VAR 0 2
8660: PPUSH
8661: EMPTY
8662: PPUSH
8663: CALL 42216 0 4
8667: ST_TO_ADDR
// end ; end ;
8668: LD_VAR 0 3
8672: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8673: LD_INT 0
8675: PPUSH
8676: PPUSH
8677: PPUSH
8678: PPUSH
8679: PPUSH
8680: PPUSH
// result := false ;
8681: LD_ADDR_VAR 0 4
8685: PUSH
8686: LD_INT 0
8688: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8689: LD_VAR 0 1
8693: PPUSH
8694: LD_EXP 42
8698: PPUSH
8699: CALL 43164 0 2
8703: IFFALSE 8916
// for i = 1 to MREG_LabList do
8705: LD_ADDR_VAR 0 5
8709: PUSH
8710: DOUBLE
8711: LD_INT 1
8713: DEC
8714: ST_TO_ADDR
8715: LD_EXP 42
8719: PUSH
8720: FOR_TO
8721: IFFALSE 8914
// begin if MREG_LabList [ i ] [ 1 ] = side then
8723: LD_EXP 42
8727: PUSH
8728: LD_VAR 0 5
8732: ARRAY
8733: PUSH
8734: LD_INT 1
8736: ARRAY
8737: PUSH
8738: LD_VAR 0 1
8742: EQUAL
8743: IFFALSE 8912
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8745: LD_ADDR_VAR 0 7
8749: PUSH
8750: LD_EXP 42
8754: PUSH
8755: LD_VAR 0 5
8759: ARRAY
8760: PUSH
8761: LD_INT 2
8763: ARRAY
8764: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8765: LD_ADDR_VAR 0 9
8769: PUSH
8770: LD_INT 22
8772: PUSH
8773: LD_VAR 0 1
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 2
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 0
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: LD_INT 30
8797: PUSH
8798: LD_INT 1
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: EMPTY
8815: LIST
8816: PPUSH
8817: CALL_OW 69
8821: PPUSH
8822: LD_VAR 0 7
8826: PPUSH
8827: CALL_OW 250
8831: PPUSH
8832: LD_VAR 0 7
8836: PPUSH
8837: CALL_OW 251
8841: PPUSH
8842: CALL_OW 73
8846: ST_TO_ADDR
// if dep then
8847: LD_VAR 0 9
8851: IFFALSE 8910
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8853: LD_VAR 0 9
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: LD_VAR 0 3
8867: PPUSH
8868: CALL 10383 0 3
8872: IFFALSE 8910
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8874: LD_VAR 0 7
8878: PPUSH
8879: LD_VAR 0 2
8883: PPUSH
8884: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8888: LD_VAR 0 7
8892: PPUSH
8893: LD_VAR 0 3
8897: PPUSH
8898: CALL_OW 207
// result := true ;
8902: LD_ADDR_VAR 0 4
8906: PUSH
8907: LD_INT 1
8909: ST_TO_ADDR
// end ; end ; break ;
8910: GO 8914
// end ; end ;
8912: GO 8720
8914: POP
8915: POP
// end ;
8916: LD_VAR 0 4
8920: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8921: LD_INT 0
8923: PPUSH
8924: PPUSH
8925: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8926: LD_ADDR_VAR 0 7
8930: PUSH
8931: LD_VAR 0 2
8935: PPUSH
8936: LD_VAR 0 3
8940: PPUSH
8941: LD_VAR 0 4
8945: PPUSH
8946: CALL 9108 0 3
8950: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8951: LD_ADDR_EXP 48
8955: PUSH
8956: LD_EXP 48
8960: PPUSH
8961: LD_VAR 0 1
8965: PPUSH
8966: LD_INT 2
8968: PPUSH
8969: LD_VAR 0 2
8973: PUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_VAR 0 4
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL 42125 0 4
8993: ST_TO_ADDR
// if ext_list then
8994: LD_VAR 0 5
8998: IFFALSE 9103
// for i = 1 to ext_list do
9000: LD_ADDR_VAR 0 8
9004: PUSH
9005: DOUBLE
9006: LD_INT 1
9008: DEC
9009: ST_TO_ADDR
9010: LD_VAR 0 5
9014: PUSH
9015: FOR_TO
9016: IFFALSE 9101
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9018: LD_ADDR_EXP 48
9022: PUSH
9023: LD_EXP 48
9027: PPUSH
9028: LD_VAR 0 1
9032: PPUSH
9033: LD_VAR 0 5
9037: PUSH
9038: LD_VAR 0 8
9042: ARRAY
9043: PPUSH
9044: LD_VAR 0 7
9048: PUSH
9049: LD_VAR 0 8
9053: ARRAY
9054: PUSH
9055: LD_INT 1
9057: ARRAY
9058: PUSH
9059: LD_VAR 0 7
9063: PUSH
9064: LD_VAR 0 8
9068: ARRAY
9069: PUSH
9070: LD_INT 2
9072: ARRAY
9073: PUSH
9074: LD_VAR 0 7
9078: PUSH
9079: LD_VAR 0 8
9083: ARRAY
9084: PUSH
9085: LD_INT 3
9087: ARRAY
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: LIST
9093: PPUSH
9094: CALL 42125 0 4
9098: ST_TO_ADDR
9099: GO 9015
9101: POP
9102: POP
// end ;
9103: LD_VAR 0 6
9107: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9108: LD_INT 0
9110: PPUSH
9111: PPUSH
// list := [ ] ;
9112: LD_ADDR_VAR 0 5
9116: PUSH
9117: EMPTY
9118: ST_TO_ADDR
// case d of 0 :
9119: LD_VAR 0 3
9123: PUSH
9124: LD_INT 0
9126: DOUBLE
9127: EQUAL
9128: IFTRUE 9132
9130: GO 9265
9132: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9133: LD_ADDR_VAR 0 5
9137: PUSH
9138: LD_VAR 0 1
9142: PUSH
9143: LD_INT 4
9145: MINUS
9146: PUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_INT 4
9154: MINUS
9155: PUSH
9156: LD_INT 2
9158: PUSH
9159: EMPTY
9160: LIST
9161: LIST
9162: LIST
9163: PUSH
9164: LD_VAR 0 1
9168: PUSH
9169: LD_INT 3
9171: MINUS
9172: PUSH
9173: LD_VAR 0 2
9177: PUSH
9178: LD_INT 1
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: LIST
9185: PUSH
9186: LD_VAR 0 1
9190: PUSH
9191: LD_INT 4
9193: PLUS
9194: PUSH
9195: LD_VAR 0 2
9199: PUSH
9200: LD_INT 4
9202: PUSH
9203: EMPTY
9204: LIST
9205: LIST
9206: LIST
9207: PUSH
9208: LD_VAR 0 1
9212: PUSH
9213: LD_INT 3
9215: PLUS
9216: PUSH
9217: LD_VAR 0 2
9221: PUSH
9222: LD_INT 3
9224: PLUS
9225: PUSH
9226: LD_INT 5
9228: PUSH
9229: EMPTY
9230: LIST
9231: LIST
9232: LIST
9233: PUSH
9234: LD_VAR 0 1
9238: PUSH
9239: LD_VAR 0 2
9243: PUSH
9244: LD_INT 4
9246: PLUS
9247: PUSH
9248: LD_INT 0
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: LIST
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: LIST
9260: LIST
9261: LIST
9262: ST_TO_ADDR
// end ; 1 :
9263: GO 9963
9265: LD_INT 1
9267: DOUBLE
9268: EQUAL
9269: IFTRUE 9273
9271: GO 9406
9273: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9274: LD_ADDR_VAR 0 5
9278: PUSH
9279: LD_VAR 0 1
9283: PUSH
9284: LD_VAR 0 2
9288: PUSH
9289: LD_INT 4
9291: MINUS
9292: PUSH
9293: LD_INT 3
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: LIST
9300: PUSH
9301: LD_VAR 0 1
9305: PUSH
9306: LD_INT 3
9308: MINUS
9309: PUSH
9310: LD_VAR 0 2
9314: PUSH
9315: LD_INT 3
9317: MINUS
9318: PUSH
9319: LD_INT 2
9321: PUSH
9322: EMPTY
9323: LIST
9324: LIST
9325: LIST
9326: PUSH
9327: LD_VAR 0 1
9331: PUSH
9332: LD_INT 4
9334: MINUS
9335: PUSH
9336: LD_VAR 0 2
9340: PUSH
9341: LD_INT 1
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_VAR 0 1
9353: PUSH
9354: LD_VAR 0 2
9358: PUSH
9359: LD_INT 3
9361: PLUS
9362: PUSH
9363: LD_INT 0
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: LIST
9370: PUSH
9371: LD_VAR 0 1
9375: PUSH
9376: LD_INT 4
9378: PLUS
9379: PUSH
9380: LD_VAR 0 2
9384: PUSH
9385: LD_INT 4
9387: PLUS
9388: PUSH
9389: LD_INT 5
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: LIST
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: ST_TO_ADDR
// end ; 2 :
9404: GO 9963
9406: LD_INT 2
9408: DOUBLE
9409: EQUAL
9410: IFTRUE 9414
9412: GO 9543
9414: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9415: LD_ADDR_VAR 0 5
9419: PUSH
9420: LD_VAR 0 1
9424: PUSH
9425: LD_VAR 0 2
9429: PUSH
9430: LD_INT 3
9432: MINUS
9433: PUSH
9434: LD_INT 3
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: PUSH
9442: LD_VAR 0 1
9446: PUSH
9447: LD_INT 4
9449: PLUS
9450: PUSH
9451: LD_VAR 0 2
9455: PUSH
9456: LD_INT 4
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: LIST
9463: PUSH
9464: LD_VAR 0 1
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: LD_INT 4
9476: PLUS
9477: PUSH
9478: LD_INT 0
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_VAR 0 1
9490: PUSH
9491: LD_INT 3
9493: MINUS
9494: PUSH
9495: LD_VAR 0 2
9499: PUSH
9500: LD_INT 1
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: LIST
9507: PUSH
9508: LD_VAR 0 1
9512: PUSH
9513: LD_INT 4
9515: MINUS
9516: PUSH
9517: LD_VAR 0 2
9521: PUSH
9522: LD_INT 4
9524: MINUS
9525: PUSH
9526: LD_INT 2
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: LIST
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: LIST
9540: ST_TO_ADDR
// end ; 3 :
9541: GO 9963
9543: LD_INT 3
9545: DOUBLE
9546: EQUAL
9547: IFTRUE 9551
9549: GO 9684
9551: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9552: LD_ADDR_VAR 0 5
9556: PUSH
9557: LD_VAR 0 1
9561: PUSH
9562: LD_INT 3
9564: PLUS
9565: PUSH
9566: LD_VAR 0 2
9570: PUSH
9571: LD_INT 4
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: PUSH
9579: LD_VAR 0 1
9583: PUSH
9584: LD_INT 4
9586: PLUS
9587: PUSH
9588: LD_VAR 0 2
9592: PUSH
9593: LD_INT 4
9595: PLUS
9596: PUSH
9597: LD_INT 5
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: LIST
9604: PUSH
9605: LD_VAR 0 1
9609: PUSH
9610: LD_INT 4
9612: MINUS
9613: PUSH
9614: LD_VAR 0 2
9618: PUSH
9619: LD_INT 1
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: PUSH
9627: LD_VAR 0 1
9631: PUSH
9632: LD_VAR 0 2
9636: PUSH
9637: LD_INT 4
9639: MINUS
9640: PUSH
9641: LD_INT 3
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: LIST
9648: PUSH
9649: LD_VAR 0 1
9653: PUSH
9654: LD_INT 3
9656: MINUS
9657: PUSH
9658: LD_VAR 0 2
9662: PUSH
9663: LD_INT 3
9665: MINUS
9666: PUSH
9667: LD_INT 2
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: ST_TO_ADDR
// end ; 4 :
9682: GO 9963
9684: LD_INT 4
9686: DOUBLE
9687: EQUAL
9688: IFTRUE 9692
9690: GO 9825
9692: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9693: LD_ADDR_VAR 0 5
9697: PUSH
9698: LD_VAR 0 1
9702: PUSH
9703: LD_VAR 0 2
9707: PUSH
9708: LD_INT 4
9710: PLUS
9711: PUSH
9712: LD_INT 0
9714: PUSH
9715: EMPTY
9716: LIST
9717: LIST
9718: LIST
9719: PUSH
9720: LD_VAR 0 1
9724: PUSH
9725: LD_INT 3
9727: PLUS
9728: PUSH
9729: LD_VAR 0 2
9733: PUSH
9734: LD_INT 3
9736: PLUS
9737: PUSH
9738: LD_INT 5
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: PUSH
9746: LD_VAR 0 1
9750: PUSH
9751: LD_INT 3
9753: PLUS
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: LIST
9767: PUSH
9768: LD_VAR 0 1
9772: PUSH
9773: LD_VAR 0 2
9777: PUSH
9778: LD_INT 3
9780: MINUS
9781: PUSH
9782: LD_INT 3
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: LD_VAR 0 1
9794: PUSH
9795: LD_INT 4
9797: MINUS
9798: PUSH
9799: LD_VAR 0 2
9803: PUSH
9804: LD_INT 4
9806: MINUS
9807: PUSH
9808: LD_INT 2
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: LIST
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: LIST
9822: ST_TO_ADDR
// end ; 5 :
9823: GO 9963
9825: LD_INT 5
9827: DOUBLE
9828: EQUAL
9829: IFTRUE 9833
9831: GO 9962
9833: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9834: LD_ADDR_VAR 0 5
9838: PUSH
9839: LD_VAR 0 1
9843: PUSH
9844: LD_INT 4
9846: MINUS
9847: PUSH
9848: LD_VAR 0 2
9852: PUSH
9853: LD_INT 1
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: LIST
9860: PUSH
9861: LD_VAR 0 1
9865: PUSH
9866: LD_VAR 0 2
9870: PUSH
9871: LD_INT 4
9873: MINUS
9874: PUSH
9875: LD_INT 3
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: LIST
9882: PUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 4
9890: PLUS
9891: PUSH
9892: LD_VAR 0 2
9896: PUSH
9897: LD_INT 4
9899: PLUS
9900: PUSH
9901: LD_INT 5
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: LIST
9908: PUSH
9909: LD_VAR 0 1
9913: PUSH
9914: LD_INT 3
9916: PLUS
9917: PUSH
9918: LD_VAR 0 2
9922: PUSH
9923: LD_INT 4
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: LIST
9930: PUSH
9931: LD_VAR 0 1
9935: PUSH
9936: LD_VAR 0 2
9940: PUSH
9941: LD_INT 3
9943: PLUS
9944: PUSH
9945: LD_INT 0
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: LIST
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: ST_TO_ADDR
// end ; end ;
9960: GO 9963
9962: POP
// result := list ;
9963: LD_ADDR_VAR 0 4
9967: PUSH
9968: LD_VAR 0 5
9972: ST_TO_ADDR
// end ;
9973: LD_VAR 0 4
9977: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9978: LD_INT 0
9980: PPUSH
9981: PPUSH
9982: PPUSH
9983: PPUSH
9984: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9985: LD_ADDR_VAR 0 10
9989: PUSH
9990: LD_VAR 0 1
9994: PPUSH
9995: LD_INT 2
9997: PPUSH
9998: EMPTY
9999: PPUSH
10000: CALL 11492 0 3
10004: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10005: LD_ADDR_VAR 0 9
10009: PUSH
10010: LD_INT 22
10012: PUSH
10013: LD_VAR 0 1
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: PUSH
10022: LD_INT 2
10024: PUSH
10025: LD_INT 30
10027: PUSH
10028: LD_INT 0
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 1
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: LIST
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PUSH
10054: EMPTY
10055: LIST
10056: PPUSH
10057: CALL_OW 69
10061: PPUSH
10062: LD_VAR 0 3
10066: PPUSH
10067: LD_VAR 0 4
10071: PPUSH
10072: CALL_OW 73
10076: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10077: LD_ADDR_VAR 0 8
10081: PUSH
10082: LD_VAR 0 9
10086: PPUSH
10087: LD_VAR 0 2
10091: PPUSH
10092: CALL 10267 0 2
10096: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10097: LD_VAR 0 10
10101: PUSH
10102: LD_VAR 0 8
10106: AND
10107: PUSH
10108: LD_VAR 0 9
10112: PPUSH
10113: LD_VAR 0 3
10117: PPUSH
10118: LD_VAR 0 4
10122: PPUSH
10123: CALL_OW 297
10127: PUSH
10128: LD_INT 26
10130: LESSEQUAL
10131: AND
10132: PUSH
10133: LD_VAR 0 3
10137: PPUSH
10138: LD_VAR 0 4
10142: PPUSH
10143: CALL_OW 428
10147: PUSH
10148: LD_INT 0
10150: EQUAL
10151: AND
10152: IFFALSE 10262
// for i = 1 to plist do
10154: LD_ADDR_VAR 0 7
10158: PUSH
10159: DOUBLE
10160: LD_INT 1
10162: DEC
10163: ST_TO_ADDR
10164: LD_VAR 0 10
10168: PUSH
10169: FOR_TO
10170: IFFALSE 10260
// if IsInUnit ( plist [ i ] ) then
10172: LD_VAR 0 10
10176: PUSH
10177: LD_VAR 0 7
10181: ARRAY
10182: PPUSH
10183: CALL_OW 310
10187: IFFALSE 10206
// ComExitBuilding ( plist [ i ] ) else
10189: LD_VAR 0 10
10193: PUSH
10194: LD_VAR 0 7
10198: ARRAY
10199: PPUSH
10200: CALL_OW 122
10204: GO 10258
// if NotTask ( plist [ i ] ) then
10206: LD_VAR 0 10
10210: PUSH
10211: LD_VAR 0 7
10215: ARRAY
10216: PPUSH
10217: CALL 32182 0 1
10221: IFFALSE 10258
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10223: LD_VAR 0 10
10227: PUSH
10228: LD_VAR 0 7
10232: ARRAY
10233: PPUSH
10234: LD_VAR 0 2
10238: PPUSH
10239: LD_VAR 0 3
10243: PPUSH
10244: LD_VAR 0 4
10248: PPUSH
10249: LD_VAR 0 5
10253: PPUSH
10254: CALL_OW 145
// end ;
10258: GO 10169
10260: POP
10261: POP
// end ;
10262: LD_VAR 0 6
10266: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10267: LD_INT 0
10269: PPUSH
10270: PPUSH
10271: PPUSH
// pom := GetBase ( bdepot ) ;
10272: LD_ADDR_VAR 0 4
10276: PUSH
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 274
10286: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10287: LD_ADDR_VAR 0 5
10291: PUSH
10292: LD_VAR 0 2
10296: PPUSH
10297: LD_VAR 0 1
10301: PPUSH
10302: CALL_OW 248
10306: PPUSH
10307: CALL_OW 450
10311: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10312: LD_VAR 0 4
10316: PPUSH
10317: LD_INT 1
10319: PPUSH
10320: CALL_OW 275
10324: PUSH
10325: LD_VAR 0 5
10329: PUSH
10330: LD_INT 1
10332: ARRAY
10333: GREATEREQUAL
10334: PUSH
10335: LD_VAR 0 4
10339: PPUSH
10340: LD_INT 3
10342: PPUSH
10343: CALL_OW 275
10347: PUSH
10348: LD_VAR 0 5
10352: PUSH
10353: LD_INT 3
10355: ARRAY
10356: GREATEREQUAL
10357: AND
10358: IFFALSE 10370
// result := true else
10360: LD_ADDR_VAR 0 3
10364: PUSH
10365: LD_INT 1
10367: ST_TO_ADDR
10368: GO 10378
// result := false ;
10370: LD_ADDR_VAR 0 3
10374: PUSH
10375: LD_INT 0
10377: ST_TO_ADDR
// end ;
10378: LD_VAR 0 3
10382: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10383: LD_INT 0
10385: PPUSH
10386: PPUSH
10387: PPUSH
10388: PPUSH
10389: PPUSH
// pom := GetBase ( bdepot ) ;
10390: LD_ADDR_VAR 0 5
10394: PUSH
10395: LD_VAR 0 1
10399: PPUSH
10400: CALL_OW 274
10404: ST_TO_ADDR
// cost := [ ] ;
10405: LD_ADDR_VAR 0 8
10409: PUSH
10410: EMPTY
10411: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10412: LD_ADDR_VAR 0 6
10416: PUSH
10417: LD_VAR 0 2
10421: PPUSH
10422: LD_VAR 0 1
10426: PPUSH
10427: CALL_OW 248
10431: PPUSH
10432: CALL_OW 450
10436: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10437: LD_ADDR_VAR 0 7
10441: PUSH
10442: LD_VAR 0 3
10446: PPUSH
10447: LD_VAR 0 1
10451: PPUSH
10452: CALL_OW 248
10456: PPUSH
10457: CALL_OW 450
10461: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10462: LD_ADDR_VAR 0 8
10466: PUSH
10467: LD_VAR 0 8
10471: PPUSH
10472: LD_INT 1
10474: PPUSH
10475: LD_VAR 0 6
10479: PUSH
10480: LD_INT 1
10482: ARRAY
10483: PUSH
10484: LD_VAR 0 7
10488: PUSH
10489: LD_INT 1
10491: ARRAY
10492: PLUS
10493: PPUSH
10494: CALL_OW 1
10498: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10499: LD_ADDR_VAR 0 8
10503: PUSH
10504: LD_VAR 0 8
10508: PPUSH
10509: LD_INT 2
10511: PPUSH
10512: LD_VAR 0 6
10516: PUSH
10517: LD_INT 2
10519: ARRAY
10520: PUSH
10521: LD_VAR 0 7
10525: PUSH
10526: LD_INT 2
10528: ARRAY
10529: PLUS
10530: PPUSH
10531: CALL_OW 1
10535: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10536: LD_ADDR_VAR 0 8
10540: PUSH
10541: LD_VAR 0 8
10545: PPUSH
10546: LD_INT 3
10548: PPUSH
10549: LD_VAR 0 6
10553: PUSH
10554: LD_INT 3
10556: ARRAY
10557: PUSH
10558: LD_VAR 0 7
10562: PUSH
10563: LD_INT 3
10565: ARRAY
10566: PLUS
10567: PPUSH
10568: CALL_OW 1
10572: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10573: LD_VAR 0 5
10577: PPUSH
10578: LD_INT 1
10580: PPUSH
10581: CALL_OW 275
10585: PUSH
10586: LD_VAR 0 8
10590: PUSH
10591: LD_INT 1
10593: ARRAY
10594: GREATEREQUAL
10595: PUSH
10596: LD_VAR 0 5
10600: PPUSH
10601: LD_INT 3
10603: PPUSH
10604: CALL_OW 275
10608: PUSH
10609: LD_VAR 0 8
10613: PUSH
10614: LD_INT 3
10616: ARRAY
10617: GREATEREQUAL
10618: AND
10619: IFFALSE 10631
// result := true else
10621: LD_ADDR_VAR 0 4
10625: PUSH
10626: LD_INT 1
10628: ST_TO_ADDR
10629: GO 10639
// result := false ;
10631: LD_ADDR_VAR 0 4
10635: PUSH
10636: LD_INT 0
10638: ST_TO_ADDR
// end ;
10639: LD_VAR 0 4
10643: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10644: LD_INT 0
10646: PPUSH
10647: PPUSH
10648: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10649: LD_ADDR_VAR 0 5
10653: PUSH
10654: LD_VAR 0 1
10658: PPUSH
10659: LD_INT 2
10661: PPUSH
10662: EMPTY
10663: PPUSH
10664: CALL 11492 0 3
10668: ST_TO_ADDR
// if unit and plist then
10669: LD_VAR 0 2
10673: PUSH
10674: LD_VAR 0 5
10678: AND
10679: IFFALSE 10740
// for i = 1 to plist do
10681: LD_ADDR_VAR 0 4
10685: PUSH
10686: DOUBLE
10687: LD_INT 1
10689: DEC
10690: ST_TO_ADDR
10691: LD_VAR 0 5
10695: PUSH
10696: FOR_TO
10697: IFFALSE 10738
// if NotTask ( plist [ i ] ) then
10699: LD_VAR 0 5
10703: PUSH
10704: LD_VAR 0 4
10708: ARRAY
10709: PPUSH
10710: CALL 32182 0 1
10714: IFFALSE 10736
// ComDismantle ( plist [ i ] , unit ) ;
10716: LD_VAR 0 5
10720: PUSH
10721: LD_VAR 0 4
10725: ARRAY
10726: PPUSH
10727: LD_VAR 0 2
10731: PPUSH
10732: CALL_OW 167
10736: GO 10696
10738: POP
10739: POP
// result := true ;
10740: LD_ADDR_VAR 0 3
10744: PUSH
10745: LD_INT 1
10747: ST_TO_ADDR
// end ;
10748: LD_VAR 0 3
10752: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10753: LD_INT 0
10755: PPUSH
10756: PPUSH
10757: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10758: LD_ADDR_VAR 0 5
10762: PUSH
10763: LD_VAR 0 1
10767: PPUSH
10768: LD_INT 2
10770: PPUSH
10771: EMPTY
10772: PPUSH
10773: CALL 11492 0 3
10777: ST_TO_ADDR
// if unit and plist then
10778: LD_VAR 0 2
10782: PUSH
10783: LD_VAR 0 5
10787: AND
10788: IFFALSE 10849
// for i = 1 to plist do
10790: LD_ADDR_VAR 0 4
10794: PUSH
10795: DOUBLE
10796: LD_INT 1
10798: DEC
10799: ST_TO_ADDR
10800: LD_VAR 0 5
10804: PUSH
10805: FOR_TO
10806: IFFALSE 10847
// if NotTask ( plist [ i ] ) then
10808: LD_VAR 0 5
10812: PUSH
10813: LD_VAR 0 4
10817: ARRAY
10818: PPUSH
10819: CALL 32182 0 1
10823: IFFALSE 10845
// ComComplete ( plist [ i ] , unit ) ;
10825: LD_VAR 0 5
10829: PUSH
10830: LD_VAR 0 4
10834: ARRAY
10835: PPUSH
10836: LD_VAR 0 2
10840: PPUSH
10841: CALL 31718 0 2
10845: GO 10805
10847: POP
10848: POP
// result := true ;
10849: LD_ADDR_VAR 0 3
10853: PUSH
10854: LD_INT 1
10856: ST_TO_ADDR
// end ;
10857: LD_VAR 0 3
10861: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10862: LD_INT 0
10864: PPUSH
10865: PPUSH
10866: PPUSH
10867: PPUSH
10868: PPUSH
10869: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10870: LD_ADDR_VAR 0 5
10874: PUSH
10875: LD_INT 22
10877: PUSH
10878: LD_VAR 0 1
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: PUSH
10887: LD_INT 21
10889: PUSH
10890: LD_INT 3
10892: PUSH
10893: EMPTY
10894: LIST
10895: LIST
10896: PUSH
10897: LD_INT 3
10899: PUSH
10900: LD_INT 57
10902: PUSH
10903: EMPTY
10904: LIST
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PUSH
10910: LD_INT 3
10912: PUSH
10913: LD_INT 24
10915: PUSH
10916: LD_INT 1000
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: PUSH
10923: EMPTY
10924: LIST
10925: LIST
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: ST_TO_ADDR
// r := [ ] ;
10938: LD_ADDR_VAR 0 6
10942: PUSH
10943: EMPTY
10944: ST_TO_ADDR
// if not tmp then
10945: LD_VAR 0 5
10949: NOT
10950: IFFALSE 10956
// exit else
10952: GO 11144
10954: GO 11124
// begin r := [ tmp [ 1 ] ] ;
10956: LD_ADDR_VAR 0 6
10960: PUSH
10961: LD_VAR 0 5
10965: PUSH
10966: LD_INT 1
10968: ARRAY
10969: PUSH
10970: EMPTY
10971: LIST
10972: ST_TO_ADDR
// for i = 2 to tmp do
10973: LD_ADDR_VAR 0 3
10977: PUSH
10978: DOUBLE
10979: LD_INT 2
10981: DEC
10982: ST_TO_ADDR
10983: LD_VAR 0 5
10987: PUSH
10988: FOR_TO
10989: IFFALSE 11122
// begin m := false ;
10991: LD_ADDR_VAR 0 7
10995: PUSH
10996: LD_INT 0
10998: ST_TO_ADDR
// for j = 1 to r do
10999: LD_ADDR_VAR 0 4
11003: PUSH
11004: DOUBLE
11005: LD_INT 1
11007: DEC
11008: ST_TO_ADDR
11009: LD_VAR 0 6
11013: PUSH
11014: FOR_TO
11015: IFFALSE 11089
// if GetLives ( tmp [ i ] ) < r [ j ] then
11017: LD_VAR 0 5
11021: PUSH
11022: LD_VAR 0 3
11026: ARRAY
11027: PPUSH
11028: CALL_OW 256
11032: PUSH
11033: LD_VAR 0 6
11037: PUSH
11038: LD_VAR 0 4
11042: ARRAY
11043: LESS
11044: IFFALSE 11087
// begin r := Insert ( r , j , tmp [ i ] ) ;
11046: LD_ADDR_VAR 0 6
11050: PUSH
11051: LD_VAR 0 6
11055: PPUSH
11056: LD_VAR 0 4
11060: PPUSH
11061: LD_VAR 0 5
11065: PUSH
11066: LD_VAR 0 3
11070: ARRAY
11071: PPUSH
11072: CALL_OW 2
11076: ST_TO_ADDR
// m := true ;
11077: LD_ADDR_VAR 0 7
11081: PUSH
11082: LD_INT 1
11084: ST_TO_ADDR
// break ;
11085: GO 11089
// end ;
11087: GO 11014
11089: POP
11090: POP
// if not m then
11091: LD_VAR 0 7
11095: NOT
11096: IFFALSE 11120
// r := r ^ tmp [ i ] ;
11098: LD_ADDR_VAR 0 6
11102: PUSH
11103: LD_VAR 0 6
11107: PUSH
11108: LD_VAR 0 5
11112: PUSH
11113: LD_VAR 0 3
11117: ARRAY
11118: ADD
11119: ST_TO_ADDR
// end ;
11120: GO 10988
11122: POP
11123: POP
// end ; if r then
11124: LD_VAR 0 6
11128: IFFALSE 11142
// result := r else
11130: LD_ADDR_VAR 0 2
11134: PUSH
11135: LD_VAR 0 6
11139: ST_TO_ADDR
11140: GO 11144
// exit ;
11142: GO 11144
// end ;
11144: LD_VAR 0 2
11148: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11149: LD_INT 0
11151: PPUSH
11152: PPUSH
11153: PPUSH
11154: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11155: LD_ADDR_VAR 0 5
11159: PUSH
11160: LD_INT 22
11162: PUSH
11163: LD_VAR 0 1
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: PUSH
11172: LD_INT 2
11174: PUSH
11175: LD_INT 25
11177: PUSH
11178: LD_INT 2
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 25
11187: PUSH
11188: LD_INT 16
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: LD_INT 34
11197: PUSH
11198: LD_INT 13
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: LD_INT 34
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PUSH
11215: EMPTY
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: PUSH
11222: LD_INT 24
11224: PUSH
11225: LD_INT 650
11227: PUSH
11228: EMPTY
11229: LIST
11230: LIST
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: PPUSH
11237: CALL_OW 69
11241: ST_TO_ADDR
// p := 1 ;
11242: LD_ADDR_VAR 0 4
11246: PUSH
11247: LD_INT 1
11249: ST_TO_ADDR
// for i = 1 to repairs do
11250: LD_ADDR_VAR 0 3
11254: PUSH
11255: DOUBLE
11256: LD_INT 1
11258: DEC
11259: ST_TO_ADDR
11260: LD_VAR 0 5
11264: PUSH
11265: FOR_TO
11266: IFFALSE 11402
// begin if IsInUnit ( repairs [ i ] ) then
11268: LD_VAR 0 5
11272: PUSH
11273: LD_VAR 0 3
11277: ARRAY
11278: PPUSH
11279: CALL_OW 310
11283: IFFALSE 11302
// ComExitBuilding ( repairs [ i ] ) else
11285: LD_VAR 0 5
11289: PUSH
11290: LD_VAR 0 3
11294: ARRAY
11295: PPUSH
11296: CALL_OW 122
11300: GO 11400
// if not HasTask ( repairs [ i ] ) then
11302: LD_VAR 0 5
11306: PUSH
11307: LD_VAR 0 3
11311: ARRAY
11312: PPUSH
11313: CALL_OW 314
11317: NOT
11318: IFFALSE 11400
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11320: LD_VAR 0 5
11324: PUSH
11325: LD_VAR 0 3
11329: ARRAY
11330: PPUSH
11331: LD_EXP 49
11335: PUSH
11336: LD_VAR 0 1
11340: ARRAY
11341: PUSH
11342: LD_VAR 0 4
11346: ARRAY
11347: PPUSH
11348: CALL_OW 130
// if i mod 3 = 0 then
11352: LD_VAR 0 3
11356: PUSH
11357: LD_INT 3
11359: MOD
11360: PUSH
11361: LD_INT 0
11363: EQUAL
11364: IFFALSE 11380
// p := p + 1 ;
11366: LD_ADDR_VAR 0 4
11370: PUSH
11371: LD_VAR 0 4
11375: PUSH
11376: LD_INT 1
11378: PLUS
11379: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11380: LD_EXP 49
11384: PUSH
11385: LD_VAR 0 1
11389: ARRAY
11390: PUSH
11391: LD_VAR 0 4
11395: LESS
11396: IFFALSE 11400
// break ;
11398: GO 11402
// end ; end ;
11400: GO 11265
11402: POP
11403: POP
// end ; end_of_file
11404: LD_VAR 0 2
11408: RET
// export function MCF_Get ( side , filter ) ; begin
11409: LD_INT 0
11411: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11412: LD_ADDR_VAR 0 3
11416: PUSH
11417: LD_INT 22
11419: PUSH
11420: LD_VAR 0 1
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: PUSH
11429: LD_VAR 0 2
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PPUSH
11438: CALL_OW 69
11442: ST_TO_ADDR
// end ;
11443: LD_VAR 0 3
11447: RET
// export function MCF_Lab ( side ) ; begin
11448: LD_INT 0
11450: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11451: LD_ADDR_VAR 0 2
11455: PUSH
11456: LD_INT 22
11458: PUSH
11459: LD_VAR 0 1
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_INT 30
11470: PUSH
11471: LD_INT 8
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: PPUSH
11482: CALL_OW 69
11486: ST_TO_ADDR
// end ;
11487: LD_VAR 0 2
11491: RET
// export function MCF_Class ( side , class , filter ) ; begin
11492: LD_INT 0
11494: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11495: LD_ADDR_VAR 0 4
11499: PUSH
11500: LD_INT 22
11502: PUSH
11503: LD_VAR 0 1
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 25
11514: PUSH
11515: LD_VAR 0 2
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: LD_VAR 0 3
11528: PUSH
11529: EMPTY
11530: LIST
11531: LIST
11532: LIST
11533: PPUSH
11534: CALL_OW 69
11538: ST_TO_ADDR
// end ;
11539: LD_VAR 0 4
11543: RET
// export function MCF_All ( side , filter ) ; begin
11544: LD_INT 0
11546: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11547: LD_ADDR_VAR 0 3
11551: PUSH
11552: LD_INT 22
11554: PUSH
11555: LD_VAR 0 1
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 2
11566: PUSH
11567: LD_INT 25
11569: PUSH
11570: LD_INT 1
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 25
11579: PUSH
11580: LD_INT 2
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 25
11589: PUSH
11590: LD_INT 3
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 25
11599: PUSH
11600: LD_INT 4
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: PUSH
11614: LD_VAR 0 2
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: LIST
11623: PPUSH
11624: CALL_OW 69
11628: ST_TO_ADDR
// end ;
11629: LD_VAR 0 3
11633: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11634: LD_INT 0
11636: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11637: LD_ADDR_VAR 0 4
11641: PUSH
11642: LD_INT 22
11644: PUSH
11645: LD_VAR 0 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: LD_INT 92
11656: PUSH
11657: LD_VAR 0 2
11661: PUSH
11662: LD_INT 1
11664: ARRAY
11665: PUSH
11666: LD_VAR 0 2
11670: PUSH
11671: LD_INT 2
11673: ARRAY
11674: PUSH
11675: LD_VAR 0 2
11679: PUSH
11680: LD_INT 3
11682: ARRAY
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: PUSH
11690: LD_VAR 0 3
11694: PUSH
11695: EMPTY
11696: LIST
11697: LIST
11698: LIST
11699: PPUSH
11700: CALL_OW 69
11704: ST_TO_ADDR
// end ;
11705: LD_VAR 0 4
11709: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11710: LD_INT 0
11712: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11713: LD_ADDR_VAR 0 3
11717: PUSH
11718: LD_INT 22
11720: PUSH
11721: LD_VAR 0 1
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PUSH
11730: LD_INT 21
11732: PUSH
11733: LD_INT 2
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PUSH
11740: LD_VAR 0 2
11744: PUSH
11745: EMPTY
11746: LIST
11747: LIST
11748: LIST
11749: PPUSH
11750: CALL_OW 69
11754: ST_TO_ADDR
// end ;
11755: LD_VAR 0 3
11759: RET
// export function MCF_Cargo ( side ) ; begin
11760: LD_INT 0
11762: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11763: LD_ADDR_VAR 0 2
11767: PUSH
11768: LD_VAR 0 1
11772: PPUSH
11773: LD_INT 2
11775: PUSH
11776: LD_INT 34
11778: PUSH
11779: LD_INT 12
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: PUSH
11786: LD_INT 34
11788: PUSH
11789: LD_INT 32
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: PUSH
11796: LD_INT 34
11798: PUSH
11799: LD_INT 51
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: EMPTY
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: PPUSH
11812: CALL 11710 0 2
11816: ST_TO_ADDR
// end ;
11817: LD_VAR 0 2
11821: RET
// export function MCF_Ape ( side ) ; begin
11822: LD_INT 0
11824: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11825: LD_ADDR_VAR 0 2
11829: PUSH
11830: LD_INT 22
11832: PUSH
11833: LD_VAR 0 1
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PUSH
11842: LD_INT 2
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 12
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 15
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: LD_INT 25
11867: PUSH
11868: LD_INT 16
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PUSH
11875: LD_INT 25
11877: PUSH
11878: LD_INT 17
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PPUSH
11896: CALL_OW 69
11900: ST_TO_ADDR
// end ;
11901: LD_VAR 0 2
11905: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11906: LD_INT 0
11908: PPUSH
11909: PPUSH
11910: PPUSH
11911: PPUSH
// result := [ ] ;
11912: LD_ADDR_VAR 0 3
11916: PUSH
11917: EMPTY
11918: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11919: LD_ADDR_VAR 0 4
11923: PUSH
11924: LD_VAR 0 1
11928: PPUSH
11929: CALL 11822 0 1
11933: ST_TO_ADDR
// case type of 0 , normal :
11934: LD_VAR 0 2
11938: PUSH
11939: LD_INT 0
11941: DOUBLE
11942: EQUAL
11943: IFTRUE 11953
11945: LD_STRING normal
11947: DOUBLE
11948: EQUAL
11949: IFTRUE 11953
11951: GO 11964
11953: POP
// cl := class_apeman ; 1 , soldier :
11954: LD_ADDR_VAR 0 5
11958: PUSH
11959: LD_INT 12
11961: ST_TO_ADDR
11962: GO 12040
11964: LD_INT 1
11966: DOUBLE
11967: EQUAL
11968: IFTRUE 11978
11970: LD_STRING soldier
11972: DOUBLE
11973: EQUAL
11974: IFTRUE 11978
11976: GO 11989
11978: POP
// cl := class_apeman_soldier ; 2 , engineer :
11979: LD_ADDR_VAR 0 5
11983: PUSH
11984: LD_INT 15
11986: ST_TO_ADDR
11987: GO 12040
11989: LD_INT 2
11991: DOUBLE
11992: EQUAL
11993: IFTRUE 12003
11995: LD_STRING engineer
11997: DOUBLE
11998: EQUAL
11999: IFTRUE 12003
12001: GO 12014
12003: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12004: LD_ADDR_VAR 0 5
12008: PUSH
12009: LD_INT 16
12011: ST_TO_ADDR
12012: GO 12040
12014: LD_INT 3
12016: DOUBLE
12017: EQUAL
12018: IFTRUE 12028
12020: LD_STRING kamikaze
12022: DOUBLE
12023: EQUAL
12024: IFTRUE 12028
12026: GO 12039
12028: POP
// cl := class_apeman_kamikaze ; end ;
12029: LD_ADDR_VAR 0 5
12033: PUSH
12034: LD_INT 17
12036: ST_TO_ADDR
12037: GO 12040
12039: POP
// for i = 1 to tmp do
12040: LD_ADDR_VAR 0 6
12044: PUSH
12045: DOUBLE
12046: LD_INT 1
12048: DEC
12049: ST_TO_ADDR
12050: LD_VAR 0 4
12054: PUSH
12055: FOR_TO
12056: IFFALSE 12105
// if GetClass ( tmp [ i ] ) = cl then
12058: LD_VAR 0 4
12062: PUSH
12063: LD_VAR 0 6
12067: ARRAY
12068: PPUSH
12069: CALL_OW 257
12073: PUSH
12074: LD_VAR 0 5
12078: EQUAL
12079: IFFALSE 12103
// result := result ^ tmp [ i ] ;
12081: LD_ADDR_VAR 0 3
12085: PUSH
12086: LD_VAR 0 3
12090: PUSH
12091: LD_VAR 0 4
12095: PUSH
12096: LD_VAR 0 6
12100: ARRAY
12101: ADD
12102: ST_TO_ADDR
12103: GO 12055
12105: POP
12106: POP
// end ;
12107: LD_VAR 0 3
12111: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12112: LD_INT 0
12114: PPUSH
12115: PPUSH
12116: PPUSH
12117: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12118: LD_ADDR_VAR 0 5
12122: PUSH
12123: LD_INT 22
12125: PUSH
12126: LD_VAR 0 1
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_VAR 0 3
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 69
12148: ST_TO_ADDR
// r := [ ] ;
12149: LD_ADDR_VAR 0 6
12153: PUSH
12154: EMPTY
12155: ST_TO_ADDR
// if tmp then
12156: LD_VAR 0 5
12160: IFFALSE 12229
// for i = 1 to tmp do
12162: LD_ADDR_VAR 0 7
12166: PUSH
12167: DOUBLE
12168: LD_INT 1
12170: DEC
12171: ST_TO_ADDR
12172: LD_VAR 0 5
12176: PUSH
12177: FOR_TO
12178: IFFALSE 12227
// if GetTag ( tmp [ i ] ) = tag then
12180: LD_VAR 0 5
12184: PUSH
12185: LD_VAR 0 7
12189: ARRAY
12190: PPUSH
12191: CALL_OW 110
12195: PUSH
12196: LD_VAR 0 2
12200: EQUAL
12201: IFFALSE 12225
// r := r ^ tmp [ i ] ;
12203: LD_ADDR_VAR 0 6
12207: PUSH
12208: LD_VAR 0 6
12212: PUSH
12213: LD_VAR 0 5
12217: PUSH
12218: LD_VAR 0 7
12222: ARRAY
12223: ADD
12224: ST_TO_ADDR
12225: GO 12177
12227: POP
12228: POP
// result := r ;
12229: LD_ADDR_VAR 0 4
12233: PUSH
12234: LD_VAR 0 6
12238: ST_TO_ADDR
// end ;
12239: LD_VAR 0 4
12243: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12244: LD_INT 0
12246: PPUSH
12247: PPUSH
12248: PPUSH
// tmp := plist ;
12249: LD_ADDR_VAR 0 5
12253: PUSH
12254: LD_VAR 0 2
12258: ST_TO_ADDR
// if tmp then
12259: LD_VAR 0 5
12263: IFFALSE 12340
// begin for i = 1 to tmp do
12265: LD_ADDR_VAR 0 6
12269: PUSH
12270: DOUBLE
12271: LD_INT 1
12273: DEC
12274: ST_TO_ADDR
12275: LD_VAR 0 5
12279: PUSH
12280: FOR_TO
12281: IFFALSE 12328
// if GetTag ( tmp [ i ] ) <> tag then
12283: LD_VAR 0 5
12287: PUSH
12288: LD_VAR 0 6
12292: ARRAY
12293: PPUSH
12294: CALL_OW 110
12298: PUSH
12299: LD_VAR 0 3
12303: NONEQUAL
12304: IFFALSE 12326
// SetTag ( tmp [ i ] , tag ) ;
12306: LD_VAR 0 5
12310: PUSH
12311: LD_VAR 0 6
12315: ARRAY
12316: PPUSH
12317: LD_VAR 0 3
12321: PPUSH
12322: CALL_OW 109
12326: GO 12280
12328: POP
12329: POP
// result := true ;
12330: LD_ADDR_VAR 0 4
12334: PUSH
12335: LD_INT 1
12337: ST_TO_ADDR
// end else
12338: GO 12348
// result := false ;
12340: LD_ADDR_VAR 0 4
12344: PUSH
12345: LD_INT 0
12347: ST_TO_ADDR
// end ;
12348: LD_VAR 0 4
12352: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12353: LD_INT 0
12355: PPUSH
12356: PPUSH
12357: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12358: LD_ADDR_VAR 0 4
12362: PUSH
12363: LD_VAR 0 1
12367: PPUSH
12368: LD_VAR 0 2
12372: PPUSH
12373: EMPTY
12374: PPUSH
12375: CALL 12112 0 3
12379: ST_TO_ADDR
// if tmp then
12380: LD_VAR 0 4
12384: IFFALSE 12436
// begin for i = 1 to tmp do
12386: LD_ADDR_VAR 0 5
12390: PUSH
12391: DOUBLE
12392: LD_INT 1
12394: DEC
12395: ST_TO_ADDR
12396: LD_VAR 0 4
12400: PUSH
12401: FOR_TO
12402: IFFALSE 12424
// SetTag ( tmp [ i ] , 0 ) ;
12404: LD_VAR 0 4
12408: PUSH
12409: LD_VAR 0 5
12413: ARRAY
12414: PPUSH
12415: LD_INT 0
12417: PPUSH
12418: CALL_OW 109
12422: GO 12401
12424: POP
12425: POP
// result := true ;
12426: LD_ADDR_VAR 0 3
12430: PUSH
12431: LD_INT 1
12433: ST_TO_ADDR
// end else
12434: GO 12444
// result := false ;
12436: LD_ADDR_VAR 0 3
12440: PUSH
12441: LD_INT 0
12443: ST_TO_ADDR
// end ;
12444: LD_VAR 0 3
12448: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12449: LD_INT 0
12451: PPUSH
12452: PPUSH
12453: PPUSH
12454: PPUSH
12455: PPUSH
// sort_list := [ ] ;
12456: LD_ADDR_VAR 0 5
12460: PUSH
12461: EMPTY
12462: ST_TO_ADDR
// for i = 1 to list do
12463: LD_ADDR_VAR 0 3
12467: PUSH
12468: DOUBLE
12469: LD_INT 1
12471: DEC
12472: ST_TO_ADDR
12473: LD_VAR 0 1
12477: PUSH
12478: FOR_TO
12479: IFFALSE 12641
// begin if i = 1 then
12481: LD_VAR 0 3
12485: PUSH
12486: LD_INT 1
12488: EQUAL
12489: IFFALSE 12515
// sort_list := sort_list ^ list [ i ] else
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 5
12500: PUSH
12501: LD_VAR 0 1
12505: PUSH
12506: LD_VAR 0 3
12510: ARRAY
12511: ADD
12512: ST_TO_ADDR
12513: GO 12639
// begin for j = 1 to sort_list do
12515: LD_ADDR_VAR 0 4
12519: PUSH
12520: DOUBLE
12521: LD_INT 1
12523: DEC
12524: ST_TO_ADDR
12525: LD_VAR 0 5
12529: PUSH
12530: FOR_TO
12531: IFFALSE 12608
// begin add := false ;
12533: LD_ADDR_VAR 0 6
12537: PUSH
12538: LD_INT 0
12540: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12541: LD_VAR 0 1
12545: PUSH
12546: LD_VAR 0 3
12550: ARRAY
12551: PUSH
12552: LD_VAR 0 5
12556: PUSH
12557: LD_VAR 0 4
12561: ARRAY
12562: LESS
12563: IFFALSE 12606
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12565: LD_ADDR_VAR 0 5
12569: PUSH
12570: LD_VAR 0 5
12574: PPUSH
12575: LD_VAR 0 4
12579: PPUSH
12580: LD_VAR 0 1
12584: PUSH
12585: LD_VAR 0 3
12589: ARRAY
12590: PPUSH
12591: CALL_OW 2
12595: ST_TO_ADDR
// add := true ;
12596: LD_ADDR_VAR 0 6
12600: PUSH
12601: LD_INT 1
12603: ST_TO_ADDR
// break ;
12604: GO 12608
// end ; end ;
12606: GO 12530
12608: POP
12609: POP
// if not add then
12610: LD_VAR 0 6
12614: NOT
12615: IFFALSE 12639
// sort_list := sort_list ^ list [ i ] ;
12617: LD_ADDR_VAR 0 5
12621: PUSH
12622: LD_VAR 0 5
12626: PUSH
12627: LD_VAR 0 1
12631: PUSH
12632: LD_VAR 0 3
12636: ARRAY
12637: ADD
12638: ST_TO_ADDR
// end ; end ;
12639: GO 12478
12641: POP
12642: POP
// result := sort_list ;
12643: LD_ADDR_VAR 0 2
12647: PUSH
12648: LD_VAR 0 5
12652: ST_TO_ADDR
// end ;
12653: LD_VAR 0 2
12657: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12658: LD_INT 0
12660: PPUSH
12661: PPUSH
12662: PPUSH
12663: PPUSH
12664: PPUSH
// sort_list := [ ] ;
12665: LD_ADDR_VAR 0 5
12669: PUSH
12670: EMPTY
12671: ST_TO_ADDR
// for i = 1 to list do
12672: LD_ADDR_VAR 0 3
12676: PUSH
12677: DOUBLE
12678: LD_INT 1
12680: DEC
12681: ST_TO_ADDR
12682: LD_VAR 0 1
12686: PUSH
12687: FOR_TO
12688: IFFALSE 12850
// begin if i = 1 then
12690: LD_VAR 0 3
12694: PUSH
12695: LD_INT 1
12697: EQUAL
12698: IFFALSE 12724
// sort_list := sort_list ^ list [ i ] else
12700: LD_ADDR_VAR 0 5
12704: PUSH
12705: LD_VAR 0 5
12709: PUSH
12710: LD_VAR 0 1
12714: PUSH
12715: LD_VAR 0 3
12719: ARRAY
12720: ADD
12721: ST_TO_ADDR
12722: GO 12848
// begin for j = 1 to sort_list do
12724: LD_ADDR_VAR 0 4
12728: PUSH
12729: DOUBLE
12730: LD_INT 1
12732: DEC
12733: ST_TO_ADDR
12734: LD_VAR 0 5
12738: PUSH
12739: FOR_TO
12740: IFFALSE 12817
// begin add := false ;
12742: LD_ADDR_VAR 0 6
12746: PUSH
12747: LD_INT 0
12749: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12750: LD_VAR 0 1
12754: PUSH
12755: LD_VAR 0 3
12759: ARRAY
12760: PUSH
12761: LD_VAR 0 5
12765: PUSH
12766: LD_VAR 0 4
12770: ARRAY
12771: GREATER
12772: IFFALSE 12815
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12774: LD_ADDR_VAR 0 5
12778: PUSH
12779: LD_VAR 0 5
12783: PPUSH
12784: LD_VAR 0 4
12788: PPUSH
12789: LD_VAR 0 1
12793: PUSH
12794: LD_VAR 0 3
12798: ARRAY
12799: PPUSH
12800: CALL_OW 2
12804: ST_TO_ADDR
// add := true ;
12805: LD_ADDR_VAR 0 6
12809: PUSH
12810: LD_INT 1
12812: ST_TO_ADDR
// break ;
12813: GO 12817
// end ; end ;
12815: GO 12739
12817: POP
12818: POP
// if not add then
12819: LD_VAR 0 6
12823: NOT
12824: IFFALSE 12848
// sort_list := sort_list ^ list [ i ] ;
12826: LD_ADDR_VAR 0 5
12830: PUSH
12831: LD_VAR 0 5
12835: PUSH
12836: LD_VAR 0 1
12840: PUSH
12841: LD_VAR 0 3
12845: ARRAY
12846: ADD
12847: ST_TO_ADDR
// end ; end ;
12848: GO 12687
12850: POP
12851: POP
// result := sort_list ;
12852: LD_ADDR_VAR 0 2
12856: PUSH
12857: LD_VAR 0 5
12861: ST_TO_ADDR
// end ;
12862: LD_VAR 0 2
12866: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12867: LD_INT 0
12869: PPUSH
12870: PPUSH
12871: PPUSH
12872: PPUSH
12873: PPUSH
12874: PPUSH
// tmp := [ ] ;
12875: LD_ADDR_VAR 0 8
12879: PUSH
12880: EMPTY
12881: ST_TO_ADDR
// r := [ ] ;
12882: LD_ADDR_VAR 0 7
12886: PUSH
12887: EMPTY
12888: ST_TO_ADDR
// add := false ;
12889: LD_ADDR_VAR 0 9
12893: PUSH
12894: LD_INT 0
12896: ST_TO_ADDR
// if plist then
12897: LD_VAR 0 2
12901: IFFALSE 12977
// begin for i = 1 to plist do
12903: LD_ADDR_VAR 0 5
12907: PUSH
12908: DOUBLE
12909: LD_INT 1
12911: DEC
12912: ST_TO_ADDR
12913: LD_VAR 0 2
12917: PUSH
12918: FOR_TO
12919: IFFALSE 12973
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12921: LD_ADDR_VAR 0 8
12925: PUSH
12926: LD_VAR 0 8
12930: PUSH
12931: LD_VAR 0 2
12935: PUSH
12936: LD_VAR 0 5
12940: ARRAY
12941: PUSH
12942: LD_VAR 0 2
12946: PUSH
12947: LD_VAR 0 5
12951: ARRAY
12952: PPUSH
12953: LD_VAR 0 3
12957: PPUSH
12958: CALL_OW 259
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PUSH
12967: EMPTY
12968: LIST
12969: ADD
12970: ST_TO_ADDR
// end ;
12971: GO 12918
12973: POP
12974: POP
// end else
12975: GO 12985
// result := false ;
12977: LD_ADDR_VAR 0 4
12981: PUSH
12982: LD_INT 0
12984: ST_TO_ADDR
// if tmp then
12985: LD_VAR 0 8
12989: IFFALSE 13163
// begin r := r ^ [ tmp [ 1 ] ] ;
12991: LD_ADDR_VAR 0 7
12995: PUSH
12996: LD_VAR 0 7
13000: PUSH
13001: LD_VAR 0 8
13005: PUSH
13006: LD_INT 1
13008: ARRAY
13009: PUSH
13010: EMPTY
13011: LIST
13012: ADD
13013: ST_TO_ADDR
// for i = 2 to tmp do
13014: LD_ADDR_VAR 0 5
13018: PUSH
13019: DOUBLE
13020: LD_INT 2
13022: DEC
13023: ST_TO_ADDR
13024: LD_VAR 0 8
13028: PUSH
13029: FOR_TO
13030: IFFALSE 13161
// begin for j = 1 to r do
13032: LD_ADDR_VAR 0 6
13036: PUSH
13037: DOUBLE
13038: LD_INT 1
13040: DEC
13041: ST_TO_ADDR
13042: LD_VAR 0 7
13046: PUSH
13047: FOR_TO
13048: IFFALSE 13125
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13050: LD_VAR 0 8
13054: PUSH
13055: LD_VAR 0 5
13059: ARRAY
13060: PUSH
13061: LD_INT 2
13063: ARRAY
13064: PUSH
13065: LD_VAR 0 7
13069: PUSH
13070: LD_VAR 0 6
13074: ARRAY
13075: PUSH
13076: LD_INT 2
13078: ARRAY
13079: LESS
13080: IFFALSE 13123
// begin r := Insert ( r , j , tmp [ i ] ) ;
13082: LD_ADDR_VAR 0 7
13086: PUSH
13087: LD_VAR 0 7
13091: PPUSH
13092: LD_VAR 0 6
13096: PPUSH
13097: LD_VAR 0 8
13101: PUSH
13102: LD_VAR 0 5
13106: ARRAY
13107: PPUSH
13108: CALL_OW 2
13112: ST_TO_ADDR
// add := true ;
13113: LD_ADDR_VAR 0 9
13117: PUSH
13118: LD_INT 1
13120: ST_TO_ADDR
// break ;
13121: GO 13125
// end ; end ;
13123: GO 13047
13125: POP
13126: POP
// if not add then
13127: LD_VAR 0 9
13131: NOT
13132: IFFALSE 13159
// r := r ^ [ tmp [ i ] ] ;
13134: LD_ADDR_VAR 0 7
13138: PUSH
13139: LD_VAR 0 7
13143: PUSH
13144: LD_VAR 0 8
13148: PUSH
13149: LD_VAR 0 5
13153: ARRAY
13154: PUSH
13155: EMPTY
13156: LIST
13157: ADD
13158: ST_TO_ADDR
// end ;
13159: GO 13029
13161: POP
13162: POP
// end ; result := r ;
13163: LD_ADDR_VAR 0 4
13167: PUSH
13168: LD_VAR 0 7
13172: ST_TO_ADDR
// end ;
13173: LD_VAR 0 4
13177: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13178: LD_INT 0
13180: PPUSH
13181: PPUSH
13182: PPUSH
13183: PPUSH
13184: PPUSH
13185: PPUSH
// tmp := [ ] ;
13186: LD_ADDR_VAR 0 8
13190: PUSH
13191: EMPTY
13192: ST_TO_ADDR
// r := [ ] ;
13193: LD_ADDR_VAR 0 7
13197: PUSH
13198: EMPTY
13199: ST_TO_ADDR
// add := false ;
13200: LD_ADDR_VAR 0 9
13204: PUSH
13205: LD_INT 0
13207: ST_TO_ADDR
// if plist then
13208: LD_VAR 0 2
13212: IFFALSE 13288
// begin for i = 1 to plist do
13214: LD_ADDR_VAR 0 5
13218: PUSH
13219: DOUBLE
13220: LD_INT 1
13222: DEC
13223: ST_TO_ADDR
13224: LD_VAR 0 2
13228: PUSH
13229: FOR_TO
13230: IFFALSE 13284
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13232: LD_ADDR_VAR 0 8
13236: PUSH
13237: LD_VAR 0 8
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: LD_VAR 0 5
13251: ARRAY
13252: PUSH
13253: LD_VAR 0 2
13257: PUSH
13258: LD_VAR 0 5
13262: ARRAY
13263: PPUSH
13264: LD_VAR 0 3
13268: PPUSH
13269: CALL_OW 259
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: PUSH
13278: EMPTY
13279: LIST
13280: ADD
13281: ST_TO_ADDR
// end ;
13282: GO 13229
13284: POP
13285: POP
// end else
13286: GO 13296
// result := false ;
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: LD_INT 0
13295: ST_TO_ADDR
// if tmp then
13296: LD_VAR 0 8
13300: IFFALSE 13474
// begin r := r ^ [ tmp [ 1 ] ] ;
13302: LD_ADDR_VAR 0 7
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 8
13316: PUSH
13317: LD_INT 1
13319: ARRAY
13320: PUSH
13321: EMPTY
13322: LIST
13323: ADD
13324: ST_TO_ADDR
// for i = 2 to tmp do
13325: LD_ADDR_VAR 0 5
13329: PUSH
13330: DOUBLE
13331: LD_INT 2
13333: DEC
13334: ST_TO_ADDR
13335: LD_VAR 0 8
13339: PUSH
13340: FOR_TO
13341: IFFALSE 13472
// begin for j = 1 to r do
13343: LD_ADDR_VAR 0 6
13347: PUSH
13348: DOUBLE
13349: LD_INT 1
13351: DEC
13352: ST_TO_ADDR
13353: LD_VAR 0 7
13357: PUSH
13358: FOR_TO
13359: IFFALSE 13436
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13361: LD_VAR 0 8
13365: PUSH
13366: LD_VAR 0 5
13370: ARRAY
13371: PUSH
13372: LD_INT 2
13374: ARRAY
13375: PUSH
13376: LD_VAR 0 7
13380: PUSH
13381: LD_VAR 0 6
13385: ARRAY
13386: PUSH
13387: LD_INT 2
13389: ARRAY
13390: GREATER
13391: IFFALSE 13434
// begin r := Insert ( r , j , tmp [ i ] ) ;
13393: LD_ADDR_VAR 0 7
13397: PUSH
13398: LD_VAR 0 7
13402: PPUSH
13403: LD_VAR 0 6
13407: PPUSH
13408: LD_VAR 0 8
13412: PUSH
13413: LD_VAR 0 5
13417: ARRAY
13418: PPUSH
13419: CALL_OW 2
13423: ST_TO_ADDR
// add := true ;
13424: LD_ADDR_VAR 0 9
13428: PUSH
13429: LD_INT 1
13431: ST_TO_ADDR
// break ;
13432: GO 13436
// end ; end ;
13434: GO 13358
13436: POP
13437: POP
// if not add then
13438: LD_VAR 0 9
13442: NOT
13443: IFFALSE 13470
// r := r ^ [ tmp [ i ] ] ;
13445: LD_ADDR_VAR 0 7
13449: PUSH
13450: LD_VAR 0 7
13454: PUSH
13455: LD_VAR 0 8
13459: PUSH
13460: LD_VAR 0 5
13464: ARRAY
13465: PUSH
13466: EMPTY
13467: LIST
13468: ADD
13469: ST_TO_ADDR
// end ;
13470: GO 13340
13472: POP
13473: POP
// end ; result := r ;
13474: LD_ADDR_VAR 0 4
13478: PUSH
13479: LD_VAR 0 7
13483: ST_TO_ADDR
// end ;
13484: LD_VAR 0 4
13488: RET
// export function MCF_Clear ( side ) ; var i ; begin
13489: LD_INT 0
13491: PPUSH
13492: PPUSH
// for i = 1 to 100 do
13493: LD_ADDR_VAR 0 3
13497: PUSH
13498: DOUBLE
13499: LD_INT 1
13501: DEC
13502: ST_TO_ADDR
13503: LD_INT 100
13505: PUSH
13506: FOR_TO
13507: IFFALSE 13543
// if MCF_Tag ( side , i , [ ] ) then
13509: LD_VAR 0 1
13513: PPUSH
13514: LD_VAR 0 3
13518: PPUSH
13519: EMPTY
13520: PPUSH
13521: CALL 12112 0 3
13525: IFFALSE 13541
// MCF_ClearTag ( side , i ) ;
13527: LD_VAR 0 1
13531: PPUSH
13532: LD_VAR 0 3
13536: PPUSH
13537: CALL 12353 0 2
13541: GO 13506
13543: POP
13544: POP
// result := true ;
13545: LD_ADDR_VAR 0 2
13549: PUSH
13550: LD_INT 1
13552: ST_TO_ADDR
// end ;
13553: LD_VAR 0 2
13557: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13558: LD_INT 0
13560: PPUSH
13561: PPUSH
13562: PPUSH
// for i = 1 to plist do
13563: LD_ADDR_VAR 0 4
13567: PUSH
13568: DOUBLE
13569: LD_INT 1
13571: DEC
13572: ST_TO_ADDR
13573: LD_VAR 0 1
13577: PUSH
13578: FOR_TO
13579: IFFALSE 13628
// if MCF_HasClass ( plist [ i ] ) = n then
13581: LD_VAR 0 1
13585: PUSH
13586: LD_VAR 0 4
13590: ARRAY
13591: PPUSH
13592: CALL 14115 0 1
13596: PUSH
13597: LD_VAR 0 2
13601: EQUAL
13602: IFFALSE 13626
// tmp := tmp ^ plist [ i ] ;
13604: LD_ADDR_VAR 0 5
13608: PUSH
13609: LD_VAR 0 5
13613: PUSH
13614: LD_VAR 0 1
13618: PUSH
13619: LD_VAR 0 4
13623: ARRAY
13624: ADD
13625: ST_TO_ADDR
13626: GO 13578
13628: POP
13629: POP
// result := tmp ;
13630: LD_ADDR_VAR 0 3
13634: PUSH
13635: LD_VAR 0 5
13639: ST_TO_ADDR
// end ;
13640: LD_VAR 0 3
13644: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13645: LD_INT 0
13647: PPUSH
13648: PPUSH
13649: PPUSH
// if mreg = ToArm then
13650: LD_VAR 0 2
13654: PUSH
13655: LD_STRING ToArm
13657: EQUAL
13658: IFFALSE 13763
// begin tmp := MREG_ToArm [ side ] ;
13660: LD_ADDR_VAR 0 6
13664: PUSH
13665: LD_EXP 58
13669: PUSH
13670: LD_VAR 0 1
13674: ARRAY
13675: ST_TO_ADDR
// if tmp = 0 then
13676: LD_VAR 0 6
13680: PUSH
13681: LD_INT 0
13683: EQUAL
13684: IFFALSE 13690
// exit else
13686: GO 14110
13688: GO 13763
// begin for i = MREG_ToArm [ side ] downto n do
13690: LD_ADDR_VAR 0 5
13694: PUSH
13695: DOUBLE
13696: LD_EXP 58
13700: PUSH
13701: LD_VAR 0 1
13705: ARRAY
13706: INC
13707: ST_TO_ADDR
13708: LD_VAR 0 3
13712: PUSH
13713: FOR_DOWNTO
13714: IFFALSE 13736
// tmp := Delete ( tmp , 1 ) ;
13716: LD_ADDR_VAR 0 6
13720: PUSH
13721: LD_VAR 0 6
13725: PPUSH
13726: LD_INT 1
13728: PPUSH
13729: CALL_OW 3
13733: ST_TO_ADDR
13734: GO 13713
13736: POP
13737: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13738: LD_ADDR_EXP 58
13742: PUSH
13743: LD_EXP 58
13747: PPUSH
13748: LD_VAR 0 1
13752: PPUSH
13753: LD_VAR 0 6
13757: PPUSH
13758: CALL_OW 1
13762: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13763: LD_VAR 0 2
13767: PUSH
13768: LD_STRING ToDep
13770: EQUAL
13771: IFFALSE 13876
// begin tmp := MREG_ToDep [ side ] ;
13773: LD_ADDR_VAR 0 6
13777: PUSH
13778: LD_EXP 59
13782: PUSH
13783: LD_VAR 0 1
13787: ARRAY
13788: ST_TO_ADDR
// if tmp = 0 then
13789: LD_VAR 0 6
13793: PUSH
13794: LD_INT 0
13796: EQUAL
13797: IFFALSE 13803
// exit else
13799: GO 14110
13801: GO 13876
// begin for i = MREG_ToDep [ side ] downto n do
13803: LD_ADDR_VAR 0 5
13807: PUSH
13808: DOUBLE
13809: LD_EXP 59
13813: PUSH
13814: LD_VAR 0 1
13818: ARRAY
13819: INC
13820: ST_TO_ADDR
13821: LD_VAR 0 3
13825: PUSH
13826: FOR_DOWNTO
13827: IFFALSE 13849
// tmp := Delete ( tmp , 1 ) ;
13829: LD_ADDR_VAR 0 6
13833: PUSH
13834: LD_VAR 0 6
13838: PPUSH
13839: LD_INT 1
13841: PPUSH
13842: CALL_OW 3
13846: ST_TO_ADDR
13847: GO 13826
13849: POP
13850: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13851: LD_ADDR_EXP 59
13855: PUSH
13856: LD_EXP 59
13860: PPUSH
13861: LD_VAR 0 1
13865: PPUSH
13866: LD_VAR 0 6
13870: PPUSH
13871: CALL_OW 1
13875: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13876: LD_VAR 0 2
13880: PUSH
13881: LD_STRING ToFac
13883: EQUAL
13884: IFFALSE 13989
// begin tmp := MREG_ToFac [ side ] ;
13886: LD_ADDR_VAR 0 6
13890: PUSH
13891: LD_EXP 57
13895: PUSH
13896: LD_VAR 0 1
13900: ARRAY
13901: ST_TO_ADDR
// if tmp = 0 then
13902: LD_VAR 0 6
13906: PUSH
13907: LD_INT 0
13909: EQUAL
13910: IFFALSE 13916
// exit else
13912: GO 14110
13914: GO 13989
// begin for i = MREG_ToFac [ side ] downto n do
13916: LD_ADDR_VAR 0 5
13920: PUSH
13921: DOUBLE
13922: LD_EXP 57
13926: PUSH
13927: LD_VAR 0 1
13931: ARRAY
13932: INC
13933: ST_TO_ADDR
13934: LD_VAR 0 3
13938: PUSH
13939: FOR_DOWNTO
13940: IFFALSE 13962
// tmp := Delete ( tmp , 1 ) ;
13942: LD_ADDR_VAR 0 6
13946: PUSH
13947: LD_VAR 0 6
13951: PPUSH
13952: LD_INT 1
13954: PPUSH
13955: CALL_OW 3
13959: ST_TO_ADDR
13960: GO 13939
13962: POP
13963: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13964: LD_ADDR_EXP 57
13968: PUSH
13969: LD_EXP 57
13973: PPUSH
13974: LD_VAR 0 1
13978: PPUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: CALL_OW 1
13988: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
13989: LD_VAR 0 2
13993: PUSH
13994: LD_STRING ToLab
13996: EQUAL
13997: IFFALSE 14102
// begin tmp := MREG_ToLab [ side ] ;
13999: LD_ADDR_VAR 0 6
14003: PUSH
14004: LD_EXP 56
14008: PUSH
14009: LD_VAR 0 1
14013: ARRAY
14014: ST_TO_ADDR
// if tmp = 0 then
14015: LD_VAR 0 6
14019: PUSH
14020: LD_INT 0
14022: EQUAL
14023: IFFALSE 14029
// exit else
14025: GO 14110
14027: GO 14102
// begin for i = MREG_ToLab [ side ] downto n do
14029: LD_ADDR_VAR 0 5
14033: PUSH
14034: DOUBLE
14035: LD_EXP 56
14039: PUSH
14040: LD_VAR 0 1
14044: ARRAY
14045: INC
14046: ST_TO_ADDR
14047: LD_VAR 0 3
14051: PUSH
14052: FOR_DOWNTO
14053: IFFALSE 14075
// tmp := Delete ( tmp , 1 ) ;
14055: LD_ADDR_VAR 0 6
14059: PUSH
14060: LD_VAR 0 6
14064: PPUSH
14065: LD_INT 1
14067: PPUSH
14068: CALL_OW 3
14072: ST_TO_ADDR
14073: GO 14052
14075: POP
14076: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14077: LD_ADDR_EXP 56
14081: PUSH
14082: LD_EXP 56
14086: PPUSH
14087: LD_VAR 0 1
14091: PPUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: CALL_OW 1
14101: ST_TO_ADDR
// end ; end ; result := true ;
14102: LD_ADDR_VAR 0 4
14106: PUSH
14107: LD_INT 1
14109: ST_TO_ADDR
// end ;
14110: LD_VAR 0 4
14114: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14115: LD_INT 0
14117: PPUSH
14118: PPUSH
14119: PPUSH
// side := GetSide ( unit ) ;
14120: LD_ADDR_VAR 0 4
14124: PUSH
14125: LD_VAR 0 1
14129: PPUSH
14130: CALL_OW 255
14134: ST_TO_ADDR
// tmp := 0 ;
14135: LD_ADDR_VAR 0 3
14139: PUSH
14140: LD_INT 0
14142: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14143: LD_VAR 0 1
14147: PUSH
14148: LD_EXP 58
14152: PUSH
14153: LD_VAR 0 4
14157: ARRAY
14158: IN
14159: IFFALSE 14169
// tmp := 1 ;
14161: LD_ADDR_VAR 0 3
14165: PUSH
14166: LD_INT 1
14168: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14169: LD_VAR 0 1
14173: PUSH
14174: LD_EXP 59
14178: PUSH
14179: LD_VAR 0 4
14183: ARRAY
14184: IN
14185: IFFALSE 14195
// tmp := 2 ;
14187: LD_ADDR_VAR 0 3
14191: PUSH
14192: LD_INT 2
14194: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14195: LD_VAR 0 1
14199: PUSH
14200: LD_EXP 57
14204: PUSH
14205: LD_VAR 0 4
14209: ARRAY
14210: IN
14211: IFFALSE 14221
// tmp := 3 ;
14213: LD_ADDR_VAR 0 3
14217: PUSH
14218: LD_INT 3
14220: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14221: LD_VAR 0 1
14225: PUSH
14226: LD_EXP 56
14230: PUSH
14231: LD_VAR 0 4
14235: ARRAY
14236: IN
14237: IFFALSE 14247
// tmp := 4 ;
14239: LD_ADDR_VAR 0 3
14243: PUSH
14244: LD_INT 4
14246: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14247: LD_VAR 0 1
14251: PUSH
14252: LD_EXP 70
14256: PUSH
14257: LD_VAR 0 4
14261: ARRAY
14262: IN
14263: IFFALSE 14273
// tmp := 5 ;
14265: LD_ADDR_VAR 0 3
14269: PUSH
14270: LD_INT 5
14272: ST_TO_ADDR
// result := tmp ;
14273: LD_ADDR_VAR 0 2
14277: PUSH
14278: LD_VAR 0 3
14282: ST_TO_ADDR
// end ;
14283: LD_VAR 0 2
14287: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14288: LD_INT 0
14290: PPUSH
14291: PPUSH
// if mreg = ToArm then
14292: LD_VAR 0 2
14296: PUSH
14297: LD_STRING ToArm
14299: EQUAL
14300: IFFALSE 14389
// for i = MREG_ToArm [ side ] downto 1 do
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: DOUBLE
14308: LD_EXP 58
14312: PUSH
14313: LD_VAR 0 1
14317: ARRAY
14318: INC
14319: ST_TO_ADDR
14320: LD_INT 1
14322: PUSH
14323: FOR_DOWNTO
14324: IFFALSE 14387
// if MREG_ToArm [ side ] [ i ] = unit then
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 1
14335: ARRAY
14336: PUSH
14337: LD_VAR 0 5
14341: ARRAY
14342: PUSH
14343: LD_VAR 0 3
14347: EQUAL
14348: IFFALSE 14385
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14350: LD_ADDR_EXP 58
14354: PUSH
14355: LD_EXP 58
14359: PPUSH
14360: LD_EXP 58
14364: PUSH
14365: LD_VAR 0 1
14369: ARRAY
14370: PUSH
14371: LD_VAR 0 5
14375: ARRAY
14376: PPUSH
14377: LD_INT 1
14379: PPUSH
14380: CALL 31002 0 3
14384: ST_TO_ADDR
// end ;
14385: GO 14323
14387: POP
14388: POP
// if mreg = ToDep then
14389: LD_VAR 0 2
14393: PUSH
14394: LD_STRING ToDep
14396: EQUAL
14397: IFFALSE 14486
// for i = MREG_ToDep [ side ] downto 1 do
14399: LD_ADDR_VAR 0 5
14403: PUSH
14404: DOUBLE
14405: LD_EXP 59
14409: PUSH
14410: LD_VAR 0 1
14414: ARRAY
14415: INC
14416: ST_TO_ADDR
14417: LD_INT 1
14419: PUSH
14420: FOR_DOWNTO
14421: IFFALSE 14484
// if MREG_ToDep [ side ] [ i ] = unit then
14423: LD_EXP 59
14427: PUSH
14428: LD_VAR 0 1
14432: ARRAY
14433: PUSH
14434: LD_VAR 0 5
14438: ARRAY
14439: PUSH
14440: LD_VAR 0 3
14444: EQUAL
14445: IFFALSE 14482
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14447: LD_ADDR_EXP 59
14451: PUSH
14452: LD_EXP 59
14456: PPUSH
14457: LD_EXP 59
14461: PUSH
14462: LD_VAR 0 1
14466: ARRAY
14467: PUSH
14468: LD_VAR 0 5
14472: ARRAY
14473: PPUSH
14474: LD_INT 1
14476: PPUSH
14477: CALL 31002 0 3
14481: ST_TO_ADDR
// end ;
14482: GO 14420
14484: POP
14485: POP
// if mreg = ToFac then
14486: LD_VAR 0 2
14490: PUSH
14491: LD_STRING ToFac
14493: EQUAL
14494: IFFALSE 14583
// for i = MREG_ToFac [ side ] downto 1 do
14496: LD_ADDR_VAR 0 5
14500: PUSH
14501: DOUBLE
14502: LD_EXP 57
14506: PUSH
14507: LD_VAR 0 1
14511: ARRAY
14512: INC
14513: ST_TO_ADDR
14514: LD_INT 1
14516: PUSH
14517: FOR_DOWNTO
14518: IFFALSE 14581
// if MREG_ToFac [ side ] [ i ] = unit then
14520: LD_EXP 57
14524: PUSH
14525: LD_VAR 0 1
14529: ARRAY
14530: PUSH
14531: LD_VAR 0 5
14535: ARRAY
14536: PUSH
14537: LD_VAR 0 3
14541: EQUAL
14542: IFFALSE 14579
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14544: LD_ADDR_EXP 57
14548: PUSH
14549: LD_EXP 57
14553: PPUSH
14554: LD_EXP 57
14558: PUSH
14559: LD_VAR 0 1
14563: ARRAY
14564: PUSH
14565: LD_VAR 0 5
14569: ARRAY
14570: PPUSH
14571: LD_INT 1
14573: PPUSH
14574: CALL 31002 0 3
14578: ST_TO_ADDR
// end ;
14579: GO 14517
14581: POP
14582: POP
// if mreg = ToLab then
14583: LD_VAR 0 2
14587: PUSH
14588: LD_STRING ToLab
14590: EQUAL
14591: IFFALSE 14680
// for i = MREG_ToLab [ side ] downto 1 do
14593: LD_ADDR_VAR 0 5
14597: PUSH
14598: DOUBLE
14599: LD_EXP 56
14603: PUSH
14604: LD_VAR 0 1
14608: ARRAY
14609: INC
14610: ST_TO_ADDR
14611: LD_INT 1
14613: PUSH
14614: FOR_DOWNTO
14615: IFFALSE 14678
// if MREG_ToLab [ side ] [ i ] = unit then
14617: LD_EXP 56
14621: PUSH
14622: LD_VAR 0 1
14626: ARRAY
14627: PUSH
14628: LD_VAR 0 5
14632: ARRAY
14633: PUSH
14634: LD_VAR 0 3
14638: EQUAL
14639: IFFALSE 14676
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14641: LD_ADDR_EXP 56
14645: PUSH
14646: LD_EXP 56
14650: PPUSH
14651: LD_EXP 56
14655: PUSH
14656: LD_VAR 0 1
14660: ARRAY
14661: PUSH
14662: LD_VAR 0 5
14666: ARRAY
14667: PPUSH
14668: LD_INT 1
14670: PPUSH
14671: CALL 31002 0 3
14675: ST_TO_ADDR
// end ;
14676: GO 14614
14678: POP
14679: POP
// end ;
14680: LD_VAR 0 4
14684: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
// result := false ;
14689: LD_ADDR_VAR 0 2
14693: PUSH
14694: LD_INT 0
14696: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14697: LD_ADDR_VAR 0 3
14701: PUSH
14702: DOUBLE
14703: LD_INT 1
14705: DEC
14706: ST_TO_ADDR
14707: LD_EXP 48
14711: PUSH
14712: FOR_TO
14713: IFFALSE 14777
// if MREG_ToBuild [ i ] [ 1 ] = side then
14715: LD_EXP 48
14719: PUSH
14720: LD_VAR 0 3
14724: ARRAY
14725: PUSH
14726: LD_INT 1
14728: ARRAY
14729: PUSH
14730: LD_VAR 0 1
14734: EQUAL
14735: IFFALSE 14775
// begin if MREG_ToBuild [ i ] [ 1 ] then
14737: LD_EXP 48
14741: PUSH
14742: LD_VAR 0 3
14746: ARRAY
14747: PUSH
14748: LD_INT 1
14750: ARRAY
14751: IFFALSE 14775
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14753: LD_ADDR_VAR 0 2
14757: PUSH
14758: LD_EXP 48
14762: PUSH
14763: LD_VAR 0 3
14767: ARRAY
14768: PUSH
14769: LD_INT 1
14771: ARRAY
14772: ST_TO_ADDR
// break ;
14773: GO 14777
// end ; end ;
14775: GO 14712
14777: POP
14778: POP
// for i = 1 to MREG_ToRepair do
14779: LD_ADDR_VAR 0 3
14783: PUSH
14784: DOUBLE
14785: LD_INT 1
14787: DEC
14788: ST_TO_ADDR
14789: LD_EXP 49
14793: PUSH
14794: FOR_TO
14795: IFFALSE 14859
// if MREG_ToRepair [ i ] [ 1 ] = side then
14797: LD_EXP 49
14801: PUSH
14802: LD_VAR 0 3
14806: ARRAY
14807: PUSH
14808: LD_INT 1
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 1
14816: EQUAL
14817: IFFALSE 14857
// begin if MREG_ToRepair [ i ] [ 1 ] then
14819: LD_EXP 49
14823: PUSH
14824: LD_VAR 0 3
14828: ARRAY
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: IFFALSE 14857
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14835: LD_ADDR_VAR 0 2
14839: PUSH
14840: LD_EXP 49
14844: PUSH
14845: LD_VAR 0 3
14849: ARRAY
14850: PUSH
14851: LD_INT 1
14853: ARRAY
14854: ST_TO_ADDR
// break ;
14855: GO 14859
// end ; end ;
14857: GO 14794
14859: POP
14860: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14861: LD_VAR 0 1
14865: PPUSH
14866: LD_INT 57
14868: PUSH
14869: EMPTY
14870: LIST
14871: PPUSH
14872: CALL 11409 0 2
14876: IFFALSE 14903
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14878: LD_ADDR_VAR 0 2
14882: PUSH
14883: LD_VAR 0 1
14887: PPUSH
14888: LD_INT 57
14890: PUSH
14891: EMPTY
14892: LIST
14893: PPUSH
14894: CALL 11409 0 2
14898: PUSH
14899: LD_INT 1
14901: ARRAY
14902: ST_TO_ADDR
// end ;
14903: LD_VAR 0 2
14907: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14908: LD_INT 0
14910: PPUSH
14911: PPUSH
14912: PPUSH
14913: PPUSH
14914: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14915: LD_ADDR_VAR 0 6
14919: PUSH
14920: LD_VAR 0 1
14924: PPUSH
14925: LD_INT 21
14927: PUSH
14928: LD_INT 3
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: PPUSH
14935: CALL 11409 0 2
14939: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14940: LD_ADDR_VAR 0 7
14944: PUSH
14945: LD_VAR 0 1
14949: PPUSH
14950: LD_INT 81
14952: PUSH
14953: LD_VAR 0 1
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: PPUSH
14962: CALL 11409 0 2
14966: ST_TO_ADDR
// if not enemy then
14967: LD_VAR 0 7
14971: NOT
14972: IFFALSE 14984
// result := false else
14974: LD_ADDR_VAR 0 3
14978: PUSH
14979: LD_INT 0
14981: ST_TO_ADDR
14982: GO 15038
// begin scan := NearestUnit ( b , enemy ) ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_VAR 0 6
14993: PPUSH
14994: LD_VAR 0 7
14998: PPUSH
14999: CALL 32327 0 2
15003: ST_TO_ADDR
// if scan [ 2 ] < dist then
15004: LD_VAR 0 5
15008: PUSH
15009: LD_INT 2
15011: ARRAY
15012: PUSH
15013: LD_VAR 0 2
15017: LESS
15018: IFFALSE 15030
// result := true else
15020: LD_ADDR_VAR 0 3
15024: PUSH
15025: LD_INT 1
15027: ST_TO_ADDR
15028: GO 15038
// result := false ;
15030: LD_ADDR_VAR 0 3
15034: PUSH
15035: LD_INT 0
15037: ST_TO_ADDR
// end ; end ;
15038: LD_VAR 0 3
15042: RET
// export function MCF_Info ( ) ; begin
15043: LD_INT 0
15045: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15046: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15048: PUSH
15049: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15051: ADD
15052: PUSH
15053: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15055: ADD
15056: PUSH
15057: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15059: ADD
15060: PUSH
15061: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15063: ADD
15064: PUSH
15065: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15067: ADD
15068: PUSH
15069: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15071: ADD
15072: PUSH
15073: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15075: ADD
15076: PUSH
15077: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15079: ADD
15080: PUSH
15081: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15083: ADD
15084: PPUSH
15085: CALL 8327 0 1
// end ; end_of_file
15089: LD_VAR 0 1
15093: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15094: LD_INT 0
15096: PPUSH
15097: PPUSH
15098: PPUSH
15099: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15100: LD_ADDR_VAR 0 5
15104: PUSH
15105: LD_VAR 0 1
15109: PPUSH
15110: LD_INT 2
15112: PUSH
15113: LD_INT 25
15115: PUSH
15116: LD_INT 2
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: PUSH
15123: LD_INT 25
15125: PUSH
15126: LD_INT 3
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PUSH
15133: LD_INT 25
15135: PUSH
15136: LD_INT 4
15138: PUSH
15139: EMPTY
15140: LIST
15141: LIST
15142: PUSH
15143: EMPTY
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL 11409 0 2
15153: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15154: LD_ADDR_VAR 0 5
15158: PUSH
15159: LD_VAR 0 5
15163: PPUSH
15164: LD_INT 0
15166: PPUSH
15167: CALL 13558 0 2
15171: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15172: LD_ADDR_VAR 0 6
15176: PUSH
15177: LD_VAR 0 1
15181: PPUSH
15182: LD_VAR 0 5
15186: PPUSH
15187: LD_INT 1
15189: PPUSH
15190: CALL 13178 0 3
15194: ST_TO_ADDR
// if n > sk then
15195: LD_VAR 0 2
15199: PUSH
15200: LD_VAR 0 6
15204: GREATER
15205: IFFALSE 15217
// n := sk ;
15207: LD_ADDR_VAR 0 2
15211: PUSH
15212: LD_VAR 0 6
15216: ST_TO_ADDR
// for i = 1 to n do
15217: LD_ADDR_VAR 0 4
15221: PUSH
15222: DOUBLE
15223: LD_INT 1
15225: DEC
15226: ST_TO_ADDR
15227: LD_VAR 0 2
15231: PUSH
15232: FOR_TO
15233: IFFALSE 15345
// if ( sk [ i ] [ 1 ] ) <> 0 then
15235: LD_VAR 0 6
15239: PUSH
15240: LD_VAR 0 4
15244: ARRAY
15245: PUSH
15246: LD_INT 1
15248: ARRAY
15249: PUSH
15250: LD_INT 0
15252: NONEQUAL
15253: IFFALSE 15343
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15255: LD_ADDR_EXP 55
15259: PUSH
15260: LD_EXP 55
15264: PPUSH
15265: LD_VAR 0 1
15269: PPUSH
15270: LD_VAR 0 6
15274: PUSH
15275: LD_VAR 0 4
15279: ARRAY
15280: PUSH
15281: LD_INT 1
15283: ARRAY
15284: PPUSH
15285: LD_INT 1
15287: PPUSH
15288: CALL 42125 0 4
15292: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15293: LD_ADDR_EXP 58
15297: PUSH
15298: LD_EXP 58
15302: PPUSH
15303: LD_VAR 0 1
15307: PPUSH
15308: LD_EXP 58
15312: PUSH
15313: LD_VAR 0 1
15317: ARRAY
15318: PUSH
15319: LD_INT 1
15321: PLUS
15322: PPUSH
15323: LD_VAR 0 6
15327: PUSH
15328: LD_VAR 0 4
15332: ARRAY
15333: PUSH
15334: LD_INT 1
15336: ARRAY
15337: PPUSH
15338: CALL 30843 0 4
15342: ST_TO_ADDR
// end ;
15343: GO 15232
15345: POP
15346: POP
// end ;
15347: LD_VAR 0 3
15351: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 1
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11409 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13558 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 2
15447: PPUSH
15448: CALL 13178 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15513: LD_ADDR_EXP 55
15517: PUSH
15518: LD_EXP 55
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 2
15545: PPUSH
15546: CALL 42125 0 4
15550: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 59
15555: PUSH
15556: LD_EXP 59
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 59
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 30843 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 2
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11409 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13558 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 3
15705: PPUSH
15706: CALL 13178 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15771: LD_ADDR_EXP 55
15775: PUSH
15776: LD_EXP 55
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 3
15803: PPUSH
15804: CALL 42125 0 4
15808: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 30843 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: LIST
15911: PPUSH
15912: CALL 11409 0 2
15916: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15917: LD_ADDR_VAR 0 5
15921: PUSH
15922: LD_VAR 0 5
15926: PPUSH
15927: LD_INT 0
15929: PPUSH
15930: CALL 13558 0 2
15934: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15935: LD_ADDR_VAR 0 6
15939: PUSH
15940: LD_VAR 0 1
15944: PPUSH
15945: LD_VAR 0 5
15949: PPUSH
15950: LD_INT 4
15952: PPUSH
15953: CALL 13178 0 3
15957: ST_TO_ADDR
// if n > sk then
15958: LD_VAR 0 2
15962: PUSH
15963: LD_VAR 0 6
15967: GREATER
15968: IFFALSE 15980
// n := sk ;
15970: LD_ADDR_VAR 0 2
15974: PUSH
15975: LD_VAR 0 6
15979: ST_TO_ADDR
// for i = 1 to n do
15980: LD_ADDR_VAR 0 4
15984: PUSH
15985: DOUBLE
15986: LD_INT 1
15988: DEC
15989: ST_TO_ADDR
15990: LD_VAR 0 2
15994: PUSH
15995: FOR_TO
15996: IFFALSE 16108
// if ( sk [ i ] [ 1 ] ) <> 0 then
15998: LD_VAR 0 6
16002: PUSH
16003: LD_VAR 0 4
16007: ARRAY
16008: PUSH
16009: LD_INT 1
16011: ARRAY
16012: PUSH
16013: LD_INT 0
16015: NONEQUAL
16016: IFFALSE 16106
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16018: LD_ADDR_EXP 55
16022: PUSH
16023: LD_EXP 55
16027: PPUSH
16028: LD_VAR 0 1
16032: PPUSH
16033: LD_VAR 0 6
16037: PUSH
16038: LD_VAR 0 4
16042: ARRAY
16043: PUSH
16044: LD_INT 1
16046: ARRAY
16047: PPUSH
16048: LD_INT 4
16050: PPUSH
16051: CALL 42125 0 4
16055: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16056: LD_ADDR_EXP 56
16060: PUSH
16061: LD_EXP 56
16065: PPUSH
16066: LD_VAR 0 1
16070: PPUSH
16071: LD_EXP 56
16075: PUSH
16076: LD_VAR 0 1
16080: ARRAY
16081: PUSH
16082: LD_INT 1
16084: PLUS
16085: PPUSH
16086: LD_VAR 0 6
16090: PUSH
16091: LD_VAR 0 4
16095: ARRAY
16096: PUSH
16097: LD_INT 1
16099: ARRAY
16100: PPUSH
16101: CALL 30843 0 4
16105: ST_TO_ADDR
// end ;
16106: GO 15995
16108: POP
16109: POP
// end ;
16110: LD_VAR 0 3
16114: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16115: LD_INT 0
16117: PPUSH
16118: PPUSH
16119: PPUSH
16120: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16121: LD_ADDR_VAR 0 6
16125: PUSH
16126: LD_VAR 0 1
16130: PPUSH
16131: LD_INT 2
16133: PUSH
16134: LD_INT 25
16136: PUSH
16137: LD_INT 1
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: PUSH
16144: LD_INT 25
16146: PUSH
16147: LD_INT 2
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PUSH
16154: LD_INT 25
16156: PUSH
16157: LD_INT 3
16159: PUSH
16160: EMPTY
16161: LIST
16162: LIST
16163: PUSH
16164: LD_INT 25
16166: PUSH
16167: LD_INT 4
16169: PUSH
16170: EMPTY
16171: LIST
16172: LIST
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: PPUSH
16181: CALL 11409 0 2
16185: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16186: LD_ADDR_VAR 0 6
16190: PUSH
16191: LD_VAR 0 6
16195: PPUSH
16196: LD_INT 0
16198: PPUSH
16199: CALL 13558 0 2
16203: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16204: LD_ADDR_VAR 0 7
16208: PUSH
16209: LD_VAR 0 1
16213: PPUSH
16214: LD_VAR 0 6
16218: PPUSH
16219: LD_INT 1
16221: PPUSH
16222: CALL 13178 0 3
16226: ST_TO_ADDR
// if n > sk then
16227: LD_VAR 0 2
16231: PUSH
16232: LD_VAR 0 7
16236: GREATER
16237: IFFALSE 16249
// n := sk ;
16239: LD_ADDR_VAR 0 2
16243: PUSH
16244: LD_VAR 0 7
16248: ST_TO_ADDR
// for i = 1 to n do
16249: LD_ADDR_VAR 0 5
16253: PUSH
16254: DOUBLE
16255: LD_INT 1
16257: DEC
16258: ST_TO_ADDR
16259: LD_VAR 0 2
16263: PUSH
16264: FOR_TO
16265: IFFALSE 16309
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16267: LD_ADDR_EXP 55
16271: PUSH
16272: LD_EXP 55
16276: PPUSH
16277: LD_VAR 0 1
16281: PPUSH
16282: LD_VAR 0 7
16286: PUSH
16287: LD_VAR 0 5
16291: ARRAY
16292: PUSH
16293: LD_INT 1
16295: ARRAY
16296: PPUSH
16297: LD_VAR 0 3
16301: PPUSH
16302: CALL 42125 0 4
16306: ST_TO_ADDR
// end ;
16307: GO 16264
16309: POP
16310: POP
// end ;
16311: LD_VAR 0 4
16315: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16316: LD_INT 0
16318: PPUSH
16319: PPUSH
16320: PPUSH
// b := false ;
16321: LD_ADDR_VAR 0 6
16325: PUSH
16326: LD_INT 0
16328: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16329: LD_VAR 0 3
16333: PUSH
16334: LD_INT 1
16336: PUSH
16337: LD_INT 9
16339: PUSH
16340: LD_INT 5
16342: PUSH
16343: LD_INT 8
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: LIST
16350: LIST
16351: IN
16352: IFFALSE 16440
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16354: LD_VAR 0 1
16358: PPUSH
16359: LD_INT 2
16361: PUSH
16362: LD_INT 30
16364: PUSH
16365: LD_INT 4
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 30
16374: PUSH
16375: LD_INT 5
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: LIST
16386: PPUSH
16387: CALL 11409 0 2
16391: IFFALSE 16440
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16393: LD_ADDR_VAR 0 6
16397: PUSH
16398: LD_VAR 0 1
16402: PPUSH
16403: LD_INT 2
16405: PUSH
16406: LD_INT 30
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: LD_INT 30
16418: PUSH
16419: LD_INT 5
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: PUSH
16426: EMPTY
16427: LIST
16428: LIST
16429: LIST
16430: PPUSH
16431: CALL 11409 0 2
16435: PUSH
16436: LD_INT 1
16438: ARRAY
16439: ST_TO_ADDR
// if class = class_engineer then
16440: LD_VAR 0 3
16444: PUSH
16445: LD_INT 2
16447: EQUAL
16448: IFFALSE 16536
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16450: LD_VAR 0 1
16454: PPUSH
16455: LD_INT 2
16457: PUSH
16458: LD_INT 30
16460: PUSH
16461: LD_INT 0
16463: PUSH
16464: EMPTY
16465: LIST
16466: LIST
16467: PUSH
16468: LD_INT 30
16470: PUSH
16471: LD_INT 1
16473: PUSH
16474: EMPTY
16475: LIST
16476: LIST
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: LIST
16482: PPUSH
16483: CALL 11409 0 2
16487: IFFALSE 16536
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16489: LD_ADDR_VAR 0 6
16493: PUSH
16494: LD_VAR 0 1
16498: PPUSH
16499: LD_INT 2
16501: PUSH
16502: LD_INT 30
16504: PUSH
16505: LD_INT 0
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 30
16514: PUSH
16515: LD_INT 1
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: LIST
16526: PPUSH
16527: CALL 11409 0 2
16531: PUSH
16532: LD_INT 1
16534: ARRAY
16535: ST_TO_ADDR
// if class = class_mechanic then
16536: LD_VAR 0 3
16540: PUSH
16541: LD_INT 3
16543: EQUAL
16544: IFFALSE 16614
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16546: LD_VAR 0 1
16550: PPUSH
16551: LD_INT 30
16553: PUSH
16554: LD_INT 3
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PPUSH
16561: CALL 11409 0 2
16565: IFFALSE 16614
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16567: LD_ADDR_VAR 0 6
16571: PUSH
16572: LD_VAR 0 1
16576: PPUSH
16577: LD_INT 2
16579: PUSH
16580: LD_INT 30
16582: PUSH
16583: LD_INT 2
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: PUSH
16590: LD_INT 30
16592: PUSH
16593: LD_INT 3
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: LIST
16604: PPUSH
16605: CALL 11409 0 2
16609: PUSH
16610: LD_INT 1
16612: ARRAY
16613: ST_TO_ADDR
// if class = class_scientistic then
16614: LD_VAR 0 3
16618: PUSH
16619: LD_INT 4
16621: EQUAL
16622: IFFALSE 16732
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16624: LD_VAR 0 1
16628: PPUSH
16629: LD_INT 2
16631: PUSH
16632: LD_INT 30
16634: PUSH
16635: LD_INT 6
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: PUSH
16642: LD_INT 30
16644: PUSH
16645: LD_INT 7
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: PUSH
16652: LD_INT 30
16654: PUSH
16655: LD_INT 8
16657: PUSH
16658: EMPTY
16659: LIST
16660: LIST
16661: PUSH
16662: EMPTY
16663: LIST
16664: LIST
16665: LIST
16666: LIST
16667: PPUSH
16668: CALL 11409 0 2
16672: IFFALSE 16732
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16674: LD_ADDR_VAR 0 6
16678: PUSH
16679: LD_VAR 0 1
16683: PPUSH
16684: LD_INT 2
16686: PUSH
16687: LD_INT 30
16689: PUSH
16690: LD_INT 6
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: LD_INT 30
16699: PUSH
16700: LD_INT 7
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: PUSH
16707: LD_INT 30
16709: PUSH
16710: LD_INT 8
16712: PUSH
16713: EMPTY
16714: LIST
16715: LIST
16716: PUSH
16717: EMPTY
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: PPUSH
16723: CALL 11409 0 2
16727: PUSH
16728: LD_INT 1
16730: ARRAY
16731: ST_TO_ADDR
// if GetClass ( unit ) = class then
16732: LD_VAR 0 2
16736: PPUSH
16737: CALL_OW 257
16741: PUSH
16742: LD_VAR 0 3
16746: EQUAL
16747: IFFALSE 16781
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16749: LD_ADDR_EXP 55
16753: PUSH
16754: LD_EXP 55
16758: PPUSH
16759: LD_VAR 0 1
16763: PPUSH
16764: LD_VAR 0 2
16768: PPUSH
16769: LD_VAR 0 3
16773: PPUSH
16774: CALL 42216 0 4
16778: ST_TO_ADDR
// end else
16779: GO 16874
// if b then
16781: LD_VAR 0 6
16785: IFFALSE 16866
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16787: LD_VAR 0 2
16791: PPUSH
16792: CALL_OW 310
16796: PUSH
16797: LD_VAR 0 2
16801: PPUSH
16802: CALL_OW 310
16806: PUSH
16807: LD_VAR 0 6
16811: NONEQUAL
16812: AND
16813: IFFALSE 16824
// ComExitBuilding ( unit ) ;
16815: LD_VAR 0 2
16819: PPUSH
16820: CALL_OW 122
// if not IsInUnit ( unit ) then
16824: LD_VAR 0 2
16828: PPUSH
16829: CALL_OW 310
16833: NOT
16834: IFFALSE 16850
// ComEnterUnit ( unit , b ) ;
16836: LD_VAR 0 2
16840: PPUSH
16841: LD_VAR 0 6
16845: PPUSH
16846: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16850: LD_VAR 0 2
16854: PPUSH
16855: LD_VAR 0 3
16859: PPUSH
16860: CALL_OW 183
// end else
16864: GO 16874
// result := false ;
16866: LD_ADDR_VAR 0 4
16870: PUSH
16871: LD_INT 0
16873: ST_TO_ADDR
// end ; end_of_file
16874: LD_VAR 0 4
16878: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16879: LD_INT 0
16881: PPUSH
16882: PPUSH
16883: PPUSH
16884: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16885: LD_ADDR_VAR 0 5
16889: PUSH
16890: LD_INT 35
16892: PUSH
16893: LD_INT 45
16895: PUSH
16896: LD_INT 46
16898: PUSH
16899: LD_INT 47
16901: PUSH
16902: LD_INT 1
16904: PUSH
16905: LD_INT 2
16907: PUSH
16908: LD_INT 48
16910: PUSH
16911: LD_INT 49
16913: PUSH
16914: LD_INT 50
16916: PUSH
16917: LD_INT 20
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: ST_TO_ADDR
// if MCF_Lab ( side ) then
16932: LD_VAR 0 1
16936: PPUSH
16937: CALL 11448 0 1
16941: IFFALSE 17180
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16943: LD_VAR 0 1
16947: PPUSH
16948: CALL 11448 0 1
16952: PUSH
16953: LD_INT 1
16955: ARRAY
16956: PPUSH
16957: CALL_OW 461
16961: PUSH
16962: LD_INT 2
16964: EQUAL
16965: IFFALSE 17104
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16967: LD_VAR 0 1
16971: PPUSH
16972: CALL 11448 0 1
16976: PUSH
16977: LD_INT 1
16979: ARRAY
16980: PPUSH
16981: LD_VAR 0 2
16985: PPUSH
16986: CALL 17276 0 2
16990: IFFALSE 17017
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
16992: LD_VAR 0 1
16996: PPUSH
16997: CALL 11448 0 1
17001: PUSH
17002: LD_INT 1
17004: ARRAY
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: CALL_OW 124
17015: GO 17104
// if MCF_Lab ( side ) > 1 then
17017: LD_VAR 0 1
17021: PPUSH
17022: CALL 11448 0 1
17026: PUSH
17027: LD_INT 1
17029: GREATER
17030: IFFALSE 17104
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17032: LD_VAR 0 1
17036: PPUSH
17037: CALL 11448 0 1
17041: PUSH
17042: LD_INT 2
17044: ARRAY
17045: PPUSH
17046: CALL_OW 461
17050: PUSH
17051: LD_INT 2
17053: EQUAL
17054: IFFALSE 17104
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17056: LD_VAR 0 1
17060: PPUSH
17061: CALL 11448 0 1
17065: PUSH
17066: LD_INT 2
17068: ARRAY
17069: PPUSH
17070: LD_VAR 0 2
17074: PPUSH
17075: CALL 17276 0 2
17079: IFFALSE 17104
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17081: LD_VAR 0 1
17085: PPUSH
17086: CALL 11448 0 1
17090: PUSH
17091: LD_INT 2
17093: ARRAY
17094: PPUSH
17095: LD_VAR 0 2
17099: PPUSH
17100: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17104: LD_VAR 0 2
17108: PUSH
17109: LD_INT 2
17111: PUSH
17112: LD_INT 11
17114: PUSH
17115: LD_INT 4
17117: PUSH
17118: LD_INT 3
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: IN
17127: IFFALSE 17180
// begin for lab in MCF_Lab ( side ) do
17129: LD_ADDR_VAR 0 6
17133: PUSH
17134: LD_VAR 0 1
17138: PPUSH
17139: CALL 11448 0 1
17143: PUSH
17144: FOR_IN
17145: IFFALSE 17178
// if BuildingStatus ( lab ) = bs_need_ape then
17147: LD_VAR 0 6
17151: PPUSH
17152: CALL_OW 461
17156: PUSH
17157: LD_INT 10
17159: EQUAL
17160: IFFALSE 17176
// MCL_ResTame ( side , lab ) ;
17162: LD_VAR 0 1
17166: PPUSH
17167: LD_VAR 0 6
17171: PPUSH
17172: CALL 17401 0 2
17176: GO 17144
17178: POP
17179: POP
// end ; end ; end ;
17180: LD_VAR 0 3
17184: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17185: LD_INT 0
17187: PPUSH
17188: PPUSH
// tmp := [ ] ;
17189: LD_ADDR_VAR 0 3
17193: PUSH
17194: EMPTY
17195: ST_TO_ADDR
// if not lab then
17196: LD_VAR 0 1
17200: NOT
17201: IFFALSE 17213
// result := false else
17203: LD_ADDR_VAR 0 2
17207: PUSH
17208: LD_INT 0
17210: ST_TO_ADDR
17211: GO 17271
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17213: LD_ADDR_VAR 0 3
17217: PUSH
17218: LD_VAR 0 3
17222: PUSH
17223: LD_VAR 0 1
17227: PPUSH
17228: LD_INT 1
17230: PPUSH
17231: CALL_OW 268
17235: ADD
17236: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17237: LD_ADDR_VAR 0 3
17241: PUSH
17242: LD_VAR 0 3
17246: PUSH
17247: LD_VAR 0 1
17251: PPUSH
17252: LD_INT 2
17254: PPUSH
17255: CALL_OW 268
17259: ADD
17260: ST_TO_ADDR
// result := tmp ;
17261: LD_ADDR_VAR 0 2
17265: PUSH
17266: LD_VAR 0 3
17270: ST_TO_ADDR
// end ; end ;
17271: LD_VAR 0 2
17275: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17276: LD_INT 0
17278: PPUSH
17279: PPUSH
17280: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17281: LD_ADDR_VAR 0 5
17285: PUSH
17286: LD_INT 35
17288: PUSH
17289: LD_INT 45
17291: PUSH
17292: LD_INT 46
17294: PUSH
17295: LD_INT 47
17297: PUSH
17298: LD_INT 1
17300: PUSH
17301: LD_INT 2
17303: PUSH
17304: LD_INT 48
17306: PUSH
17307: LD_INT 49
17309: PUSH
17310: LD_INT 50
17312: PUSH
17313: LD_INT 20
17315: PUSH
17316: EMPTY
17317: LIST
17318: LIST
17319: LIST
17320: LIST
17321: LIST
17322: LIST
17323: LIST
17324: LIST
17325: LIST
17326: LIST
17327: ST_TO_ADDR
// if lab then
17328: LD_VAR 0 1
17332: IFFALSE 17388
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17334: LD_VAR 0 2
17338: PUSH
17339: LD_VAR 0 5
17343: IN
17344: PUSH
17345: LD_VAR 0 2
17349: PPUSH
17350: CALL_OW 481
17354: PUSH
17355: LD_VAR 0 1
17359: PPUSH
17360: CALL 17185 0 1
17364: IN
17365: OR
17366: IFFALSE 17378
// result := true else
17368: LD_ADDR_VAR 0 3
17372: PUSH
17373: LD_INT 1
17375: ST_TO_ADDR
17376: GO 17386
// result := false ;
17378: LD_ADDR_VAR 0 3
17382: PUSH
17383: LD_INT 0
17385: ST_TO_ADDR
// end else
17386: GO 17396
// result := false ;
17388: LD_ADDR_VAR 0 3
17392: PUSH
17393: LD_INT 0
17395: ST_TO_ADDR
// end ;
17396: LD_VAR 0 3
17400: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17401: LD_INT 0
17403: PPUSH
17404: PPUSH
17405: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17406: LD_ADDR_VAR 0 4
17410: PUSH
17411: LD_VAR 0 1
17415: PPUSH
17416: LD_INT 171
17418: PPUSH
17419: EMPTY
17420: PPUSH
17421: CALL 12112 0 3
17425: ST_TO_ADDR
// if not ape then
17426: LD_VAR 0 4
17430: NOT
17431: IFFALSE 17463
// if MCF_Ape ( side ) then
17433: LD_VAR 0 1
17437: PPUSH
17438: CALL 11822 0 1
17442: IFFALSE 17463
// ape := MCF_Ape ( side ) [ 1 ] ;
17444: LD_ADDR_VAR 0 4
17448: PUSH
17449: LD_VAR 0 1
17453: PPUSH
17454: CALL 11822 0 1
17458: PUSH
17459: LD_INT 1
17461: ARRAY
17462: ST_TO_ADDR
// if ape then
17463: LD_VAR 0 4
17467: IFFALSE 17518
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17469: LD_VAR 0 4
17473: PUSH
17474: LD_INT 1
17476: ARRAY
17477: PPUSH
17478: CALL_OW 310
17482: PUSH
17483: LD_VAR 0 4
17487: PUSH
17488: LD_INT 1
17490: ARRAY
17491: PPUSH
17492: CALL_OW 310
17496: PUSH
17497: LD_VAR 0 2
17501: NONEQUAL
17502: AND
17503: IFFALSE 17518
// ComExitBuilding ( ape [ 1 ] ) ;
17505: LD_VAR 0 4
17509: PUSH
17510: LD_INT 1
17512: ARRAY
17513: PPUSH
17514: CALL_OW 122
// if not lab then
17518: LD_VAR 0 2
17522: NOT
17523: IFFALSE 17529
// exit else
17525: GO 17677
17527: GO 17637
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 16
17536: PPUSH
17537: LD_INT 25
17539: PUSH
17540: LD_INT 4
17542: PUSH
17543: EMPTY
17544: LIST
17545: LIST
17546: PPUSH
17547: CALL 12112 0 3
17551: PUSH
17552: LD_INT 0
17554: EQUAL
17555: PUSH
17556: LD_VAR 0 2
17560: PPUSH
17561: CALL_OW 313
17565: PUSH
17566: LD_INT 6
17568: EQUAL
17569: AND
17570: IFFALSE 17637
// begin tmp := UnitsInside ( lab ) ;
17572: LD_ADDR_VAR 0 5
17576: PUSH
17577: LD_VAR 0 2
17581: PPUSH
17582: CALL_OW 313
17586: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17587: LD_VAR 0 5
17591: PUSH
17592: LD_VAR 0 5
17596: ARRAY
17597: PPUSH
17598: LD_INT 16
17600: PPUSH
17601: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17605: LD_VAR 0 5
17609: PUSH
17610: LD_VAR 0 5
17614: ARRAY
17615: PPUSH
17616: CALL_OW 310
17620: IFFALSE 17637
// ComExitBuilding ( tmp [ tmp ] ) ;
17622: LD_VAR 0 5
17626: PUSH
17627: LD_VAR 0 5
17631: ARRAY
17632: PPUSH
17633: CALL_OW 122
// end ; if ape then
17637: LD_VAR 0 4
17641: IFFALSE 17677
// if not IsInUnit ( ape [ 1 ] ) then
17643: LD_VAR 0 4
17647: PUSH
17648: LD_INT 1
17650: ARRAY
17651: PPUSH
17652: CALL_OW 310
17656: NOT
17657: IFFALSE 17677
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17659: LD_VAR 0 4
17663: PUSH
17664: LD_INT 1
17666: ARRAY
17667: PPUSH
17668: LD_VAR 0 2
17672: PPUSH
17673: CALL_OW 120
// end ;
17677: LD_VAR 0 3
17681: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17682: LD_INT 0
17684: PPUSH
17685: PPUSH
17686: PPUSH
// result := false ;
17687: LD_ADDR_VAR 0 2
17691: PUSH
17692: LD_INT 0
17694: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17695: LD_ADDR_VAR 0 3
17699: PUSH
17700: LD_VAR 0 1
17704: PPUSH
17705: CALL 17792 0 1
17709: ST_TO_ADDR
// if techs then
17710: LD_VAR 0 3
17714: IFFALSE 17744
// if techs [ 2 ] then
17716: LD_VAR 0 3
17720: PUSH
17721: LD_INT 2
17723: ARRAY
17724: IFFALSE 17736
// result := true else
17726: LD_ADDR_VAR 0 2
17730: PUSH
17731: LD_INT 1
17733: ST_TO_ADDR
17734: GO 17744
// result := false ;
17736: LD_ADDR_VAR 0 2
17740: PUSH
17741: LD_INT 0
17743: ST_TO_ADDR
// end ;
17744: LD_VAR 0 2
17748: RET
// export function MCL_Start ( side ) ; var i ; begin
17749: LD_INT 0
17751: PPUSH
17752: PPUSH
// if MCL_GetTechList ( side ) then
17753: LD_VAR 0 1
17757: PPUSH
17758: CALL 17792 0 1
17762: IFFALSE 17787
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17764: LD_VAR 0 1
17768: PPUSH
17769: LD_VAR 0 1
17773: PPUSH
17774: CALL 17792 0 1
17778: PUSH
17779: LD_INT 1
17781: ARRAY
17782: PPUSH
17783: CALL 16879 0 2
// end ;
17787: LD_VAR 0 2
17791: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17792: LD_INT 0
17794: PPUSH
17795: PPUSH
17796: PPUSH
// if MREG_ToRes then
17797: LD_EXP 52
17801: IFFALSE 17886
// for i = 1 to MREG_ToRes do
17803: LD_ADDR_VAR 0 3
17807: PUSH
17808: DOUBLE
17809: LD_INT 1
17811: DEC
17812: ST_TO_ADDR
17813: LD_EXP 52
17817: PUSH
17818: FOR_TO
17819: IFFALSE 17884
// if MREG_ToRes [ i ] [ 1 ] = side then
17821: LD_EXP 52
17825: PUSH
17826: LD_VAR 0 3
17830: ARRAY
17831: PUSH
17832: LD_INT 1
17834: ARRAY
17835: PUSH
17836: LD_VAR 0 1
17840: EQUAL
17841: IFFALSE 17882
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17843: LD_ADDR_VAR 0 4
17847: PUSH
17848: LD_VAR 0 4
17852: PPUSH
17853: LD_VAR 0 4
17857: PUSH
17858: LD_INT 1
17860: PLUS
17861: PPUSH
17862: LD_EXP 52
17866: PUSH
17867: LD_VAR 0 3
17871: ARRAY
17872: PUSH
17873: LD_INT 2
17875: ARRAY
17876: PPUSH
17877: CALL_OW 1
17881: ST_TO_ADDR
// end ;
17882: GO 17818
17884: POP
17885: POP
// result := techs ;
17886: LD_ADDR_VAR 0 2
17890: PUSH
17891: LD_VAR 0 4
17895: ST_TO_ADDR
// end ;
17896: LD_VAR 0 2
17900: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17901: LD_INT 0
17903: PPUSH
17904: PPUSH
// for i = 1 to tech_list do
17905: LD_ADDR_VAR 0 4
17909: PUSH
17910: DOUBLE
17911: LD_INT 1
17913: DEC
17914: ST_TO_ADDR
17915: LD_VAR 0 2
17919: PUSH
17920: FOR_TO
17921: IFFALSE 17975
// if not tech_list [ i ] = 20 then
17923: LD_VAR 0 2
17927: PUSH
17928: LD_VAR 0 4
17932: ARRAY
17933: PUSH
17934: LD_INT 20
17936: EQUAL
17937: NOT
17938: IFFALSE 17973
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17940: LD_ADDR_EXP 52
17944: PUSH
17945: LD_EXP 52
17949: PPUSH
17950: LD_VAR 0 1
17954: PPUSH
17955: LD_VAR 0 2
17959: PUSH
17960: LD_VAR 0 4
17964: ARRAY
17965: PPUSH
17966: EMPTY
17967: PPUSH
17968: CALL 42125 0 4
17972: ST_TO_ADDR
17973: GO 17920
17975: POP
17976: POP
// result := true ;
17977: LD_ADDR_VAR 0 3
17981: PUSH
17982: LD_INT 1
17984: ST_TO_ADDR
// end ;
17985: LD_VAR 0 3
17989: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
17990: LD_INT 0
17992: PPUSH
17993: PPUSH
// for i = MREG_ToRes downto 1 do
17994: LD_ADDR_VAR 0 3
17998: PUSH
17999: DOUBLE
18000: LD_EXP 52
18004: INC
18005: ST_TO_ADDR
18006: LD_INT 1
18008: PUSH
18009: FOR_DOWNTO
18010: IFFALSE 18056
// if MREG_ToRes [ i ] [ 1 ] = side then
18012: LD_EXP 52
18016: PUSH
18017: LD_VAR 0 3
18021: ARRAY
18022: PUSH
18023: LD_INT 1
18025: ARRAY
18026: PUSH
18027: LD_VAR 0 1
18031: EQUAL
18032: IFFALSE 18054
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18034: LD_ADDR_EXP 52
18038: PUSH
18039: LD_EXP 52
18043: PPUSH
18044: LD_VAR 0 3
18048: PPUSH
18049: CALL_OW 3
18053: ST_TO_ADDR
18054: GO 18009
18056: POP
18057: POP
// result := true ;
18058: LD_ADDR_VAR 0 2
18062: PUSH
18063: LD_INT 1
18065: ST_TO_ADDR
// end ;
18066: LD_VAR 0 2
18070: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18071: LD_INT 0
18073: PPUSH
// result := GetTechProgress ( side , tech ) ;
18074: LD_ADDR_VAR 0 3
18078: PUSH
18079: LD_VAR 0 1
18083: PPUSH
18084: LD_VAR 0 2
18088: PPUSH
18089: CALL_OW 326
18093: ST_TO_ADDR
// end ;
18094: LD_VAR 0 3
18098: RET
// export function MCL_Require ( tech ) ; begin
18099: LD_INT 0
18101: PPUSH
// result := GetTechTechsReq ( tech ) ;
18102: LD_ADDR_VAR 0 2
18106: PUSH
18107: LD_VAR 0 1
18111: PPUSH
18112: CALL_OW 480
18116: ST_TO_ADDR
// end ; end_of_file
18117: LD_VAR 0 2
18121: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18122: LD_INT 0
18124: PPUSH
18125: PPUSH
18126: PPUSH
// uc_side := 0 ;
18127: LD_ADDR_OWVAR 20
18131: PUSH
18132: LD_INT 0
18134: ST_TO_ADDR
// uc_nation := 0 ;
18135: LD_ADDR_OWVAR 21
18139: PUSH
18140: LD_INT 0
18142: ST_TO_ADDR
// for i = 1 to n do
18143: LD_ADDR_VAR 0 5
18147: PUSH
18148: DOUBLE
18149: LD_INT 1
18151: DEC
18152: ST_TO_ADDR
18153: LD_VAR 0 2
18157: PUSH
18158: FOR_TO
18159: IFFALSE 18304
// begin hc_importance := 0 ;
18161: LD_ADDR_OWVAR 32
18165: PUSH
18166: LD_INT 0
18168: ST_TO_ADDR
// hc_gallery :=  ;
18169: LD_ADDR_OWVAR 33
18173: PUSH
18174: LD_STRING 
18176: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18177: LD_ADDR_OWVAR 35
18181: PUSH
18182: LD_VAR 0 3
18186: PUSH
18187: LD_INT 20
18189: MINUS
18190: PPUSH
18191: LD_VAR 0 3
18195: PUSH
18196: LD_INT 20
18198: PLUS
18199: PPUSH
18200: CALL_OW 12
18204: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18205: LD_ADDR_OWVAR 31
18209: PUSH
18210: LD_INT 0
18212: PPUSH
18213: LD_INT 2
18215: PPUSH
18216: CALL_OW 12
18220: PUSH
18221: LD_INT 0
18223: PUSH
18224: LD_INT 0
18226: PUSH
18227: LD_INT 0
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18236: LD_ADDR_OWVAR 30
18240: PUSH
18241: LD_INT 0
18243: PUSH
18244: LD_INT 0
18246: PUSH
18247: LD_INT 0
18249: PUSH
18250: LD_INT 0
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: ST_TO_ADDR
// hc_name :=  ;
18259: LD_ADDR_OWVAR 26
18263: PUSH
18264: LD_STRING 
18266: ST_TO_ADDR
// hc_class := class_apeman ;
18267: LD_ADDR_OWVAR 28
18271: PUSH
18272: LD_INT 12
18274: ST_TO_ADDR
// ape := CreateHuman ;
18275: LD_ADDR_VAR 0 6
18279: PUSH
18280: CALL_OW 44
18284: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18285: LD_VAR 0 6
18289: PPUSH
18290: LD_VAR 0 1
18294: PPUSH
18295: LD_INT 0
18297: PPUSH
18298: CALL_OW 49
// end ;
18302: GO 18158
18304: POP
18305: POP
// end ;
18306: LD_VAR 0 4
18310: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18311: LD_INT 0
18313: PPUSH
18314: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18315: LD_VAR 0 1
18319: PPUSH
18320: CALL 11822 0 1
18324: PUSH
18325: LD_EXP 39
18329: PUSH
18330: LD_VAR 0 1
18334: ARRAY
18335: GREATEREQUAL
18336: IFFALSE 18513
// begin if GetTag ( unit ) = 17 then
18338: LD_VAR 0 2
18342: PPUSH
18343: CALL_OW 110
18347: PUSH
18348: LD_INT 17
18350: EQUAL
18351: IFFALSE 18511
// begin SetTag ( unit , 0 ) ;
18353: LD_VAR 0 2
18357: PPUSH
18358: LD_INT 0
18360: PPUSH
18361: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL 11448 0 1
18374: PUSH
18375: LD_VAR 0 1
18379: PPUSH
18380: CALL 17792 0 1
18384: NOT
18385: AND
18386: IFFALSE 18411
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18388: LD_VAR 0 2
18392: PPUSH
18393: LD_VAR 0 1
18397: PPUSH
18398: CALL 11448 0 1
18402: PUSH
18403: LD_INT 1
18405: ARRAY
18406: PPUSH
18407: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18411: LD_VAR 0 1
18415: PPUSH
18416: CALL 11448 0 1
18420: NOT
18421: PUSH
18422: LD_VAR 0 1
18426: PPUSH
18427: LD_INT 30
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL 11409 0 2
18441: AND
18442: IFFALSE 18511
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18444: LD_VAR 0 2
18448: PPUSH
18449: LD_VAR 0 1
18453: PPUSH
18454: LD_INT 30
18456: PUSH
18457: LD_INT 1
18459: PUSH
18460: EMPTY
18461: LIST
18462: LIST
18463: PPUSH
18464: CALL 11409 0 2
18468: PUSH
18469: LD_INT 1
18471: ARRAY
18472: PPUSH
18473: CALL_OW 250
18477: PPUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: LD_INT 30
18485: PUSH
18486: LD_INT 1
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PPUSH
18493: CALL 11409 0 2
18497: PUSH
18498: LD_INT 1
18500: ARRAY
18501: PPUSH
18502: CALL_OW 251
18506: PPUSH
18507: CALL_OW 111
// end ; end else
18511: GO 18697
// if GetClass ( unit ) <> 4 then
18513: LD_VAR 0 2
18517: PPUSH
18518: CALL_OW 257
18522: PUSH
18523: LD_INT 4
18525: NONEQUAL
18526: IFFALSE 18532
// exit else
18528: GO 18697
18530: GO 18697
// if GetTag ( unit ) = 0 then
18532: LD_VAR 0 2
18536: PPUSH
18537: CALL_OW 110
18541: PUSH
18542: LD_INT 0
18544: EQUAL
18545: IFFALSE 18561
// SetTag ( unit , 17 ) else
18547: LD_VAR 0 2
18551: PPUSH
18552: LD_INT 17
18554: PPUSH
18555: CALL_OW 109
18559: GO 18697
// begin if IsInUnit ( unit ) then
18561: LD_VAR 0 2
18565: PPUSH
18566: CALL_OW 310
18570: IFFALSE 18581
// ComExitBuilding ( unit ) ;
18572: LD_VAR 0 2
18576: PPUSH
18577: CALL_OW 122
// Wait ( 1 ) ;
18581: LD_INT 1
18583: PPUSH
18584: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18588: LD_ADDR_VAR 0 4
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 25
18605: PUSH
18606: LD_INT 12
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: PPUSH
18622: LD_VAR 0 2
18626: PPUSH
18627: CALL_OW 74
18631: ST_TO_ADDR
// if not ape then
18632: LD_VAR 0 4
18636: NOT
18637: IFFALSE 18643
// exit else
18639: GO 18697
18641: GO 18652
// ComHold ( ape ) ;
18643: LD_VAR 0 4
18647: PPUSH
18648: CALL_OW 140
// if not HasTask ( unit ) then
18652: LD_VAR 0 2
18656: PPUSH
18657: CALL_OW 314
18661: NOT
18662: IFFALSE 18695
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18664: LD_VAR 0 2
18668: PPUSH
18669: LD_VAR 0 4
18673: PPUSH
18674: CALL_OW 250
18678: PPUSH
18679: LD_VAR 0 4
18683: PPUSH
18684: CALL_OW 251
18688: PPUSH
18689: CALL_OW 131
18693: GO 18697
// exit ;
18695: GO 18697
// end ; end ;
18697: LD_VAR 0 3
18701: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18702: LD_INT 0
18704: PPUSH
18705: PPUSH
18706: PPUSH
18707: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18708: LD_ADDR_VAR 0 4
18712: PUSH
18713: LD_EXP 40
18717: PUSH
18718: LD_VAR 0 1
18722: ARRAY
18723: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18724: LD_ADDR_VAR 0 5
18728: PUSH
18729: LD_VAR 0 1
18733: PPUSH
18734: LD_STRING normal
18736: PPUSH
18737: CALL 11906 0 2
18741: ST_TO_ADDR
// if apes then
18742: LD_VAR 0 5
18746: IFFALSE 18974
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18748: LD_INT 2
18750: PPUSH
18751: LD_VAR 0 1
18755: PPUSH
18756: CALL_OW 321
18760: PUSH
18761: LD_INT 2
18763: EQUAL
18764: PUSH
18765: LD_VAR 0 4
18769: PUSH
18770: LD_INT 2
18772: ARRAY
18773: PUSH
18774: LD_INT 1
18776: EQUAL
18777: AND
18778: PUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: LD_STRING engineer
18786: PPUSH
18787: CALL 11906 0 2
18791: PUSH
18792: LD_INT 3
18794: LESS
18795: AND
18796: PUSH
18797: LD_VAR 0 1
18801: PPUSH
18802: LD_INT 30
18804: PUSH
18805: LD_INT 1
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PPUSH
18812: CALL 11409 0 2
18816: AND
18817: IFFALSE 18871
// begin for i in apes do
18819: LD_ADDR_VAR 0 3
18823: PUSH
18824: LD_VAR 0 5
18828: PUSH
18829: FOR_IN
18830: IFFALSE 18867
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18832: LD_VAR 0 3
18836: PPUSH
18837: LD_VAR 0 1
18841: PPUSH
18842: LD_INT 30
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PPUSH
18852: CALL 11409 0 2
18856: PUSH
18857: LD_INT 1
18859: ARRAY
18860: PPUSH
18861: CALL_OW 120
// end ;
18865: GO 18829
18867: POP
18868: POP
// end else
18869: GO 18974
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18871: LD_INT 11
18873: PPUSH
18874: LD_VAR 0 1
18878: PPUSH
18879: CALL_OW 321
18883: PUSH
18884: LD_INT 2
18886: EQUAL
18887: PUSH
18888: LD_VAR 0 4
18892: PUSH
18893: LD_INT 1
18895: ARRAY
18896: PUSH
18897: LD_INT 1
18899: EQUAL
18900: AND
18901: PUSH
18902: LD_VAR 0 1
18906: PPUSH
18907: LD_INT 30
18909: PUSH
18910: LD_INT 5
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PPUSH
18917: CALL 11409 0 2
18921: AND
18922: IFFALSE 18974
// begin for i in apes do
18924: LD_ADDR_VAR 0 3
18928: PUSH
18929: LD_VAR 0 5
18933: PUSH
18934: FOR_IN
18935: IFFALSE 18972
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18937: LD_VAR 0 3
18941: PPUSH
18942: LD_VAR 0 1
18946: PPUSH
18947: LD_INT 30
18949: PUSH
18950: LD_INT 5
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: PPUSH
18957: CALL 11409 0 2
18961: PUSH
18962: LD_INT 1
18964: ARRAY
18965: PPUSH
18966: CALL_OW 120
// end ;
18970: GO 18934
18972: POP
18973: POP
// end ; end ; end ; end_of_file
18974: LD_VAR 0 2
18978: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18979: LD_INT 0
18981: PPUSH
18982: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18983: LD_VAR 0 1
18987: PPUSH
18988: CALL_OW 257
18992: PUSH
18993: LD_INT 4
18995: EQUAL
18996: NOT
18997: PUSH
18998: LD_VAR 0 2
19002: NOT
19003: OR
19004: IFFALSE 19010
// exit else
19006: GO 19044
19008: GO 19044
// if not GetTag ( unit ) = 4 then
19010: LD_VAR 0 1
19014: PPUSH
19015: CALL_OW 110
19019: PUSH
19020: LD_INT 4
19022: EQUAL
19023: NOT
19024: IFFALSE 19030
// exit else
19026: GO 19044
19028: GO 19044
// ComHeal ( unit , target ) ;
19030: LD_VAR 0 1
19034: PPUSH
19035: LD_VAR 0 2
19039: PPUSH
19040: CALL_OW 128
// end ;
19044: LD_VAR 0 3
19048: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19049: LD_INT 0
19051: PPUSH
19052: PPUSH
19053: PPUSH
19054: PPUSH
19055: PPUSH
19056: PPUSH
19057: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19058: LD_ADDR_VAR 0 5
19062: PUSH
19063: LD_INT 22
19065: PUSH
19066: LD_VAR 0 1
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: PUSH
19075: LD_INT 21
19077: PUSH
19078: LD_INT 1
19080: PUSH
19081: EMPTY
19082: LIST
19083: LIST
19084: PUSH
19085: LD_INT 3
19087: PUSH
19088: LD_INT 55
19090: PUSH
19091: EMPTY
19092: LIST
19093: PUSH
19094: EMPTY
19095: LIST
19096: LIST
19097: PUSH
19098: LD_INT 3
19100: PUSH
19101: LD_INT 54
19103: PUSH
19104: EMPTY
19105: LIST
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PUSH
19111: LD_INT 3
19113: PUSH
19114: LD_INT 24
19116: PUSH
19117: LD_INT 1000
19119: PUSH
19120: EMPTY
19121: LIST
19122: LIST
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: PUSH
19128: EMPTY
19129: LIST
19130: LIST
19131: LIST
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL_OW 69
19139: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19140: LD_ADDR_VAR 0 8
19144: PUSH
19145: LD_VAR 0 1
19149: PPUSH
19150: LD_INT 30
19152: PUSH
19153: LD_INT 1
19155: PUSH
19156: EMPTY
19157: LIST
19158: LIST
19159: PPUSH
19160: CALL 11409 0 2
19164: ST_TO_ADDR
// r := [ ] ;
19165: LD_ADDR_VAR 0 6
19169: PUSH
19170: EMPTY
19171: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19172: LD_VAR 0 1
19176: PPUSH
19177: LD_INT 5
19179: PPUSH
19180: EMPTY
19181: PPUSH
19182: CALL 12112 0 3
19186: IFFALSE 19242
// for j in MCF_Tag ( side , 5 , [ ] ) do
19188: LD_ADDR_VAR 0 4
19192: PUSH
19193: LD_VAR 0 1
19197: PPUSH
19198: LD_INT 5
19200: PPUSH
19201: EMPTY
19202: PPUSH
19203: CALL 12112 0 3
19207: PUSH
19208: FOR_IN
19209: IFFALSE 19240
// if GetLives ( j ) = 1000 then
19211: LD_VAR 0 4
19215: PPUSH
19216: CALL_OW 256
19220: PUSH
19221: LD_INT 1000
19223: EQUAL
19224: IFFALSE 19238
// SetTag ( j , 0 ) ;
19226: LD_VAR 0 4
19230: PPUSH
19231: LD_INT 0
19233: PPUSH
19234: CALL_OW 109
19238: GO 19208
19240: POP
19241: POP
// if tmp then
19242: LD_VAR 0 5
19246: IFFALSE 19575
// begin r := [ tmp [ 1 ] ] ;
19248: LD_ADDR_VAR 0 6
19252: PUSH
19253: LD_VAR 0 5
19257: PUSH
19258: LD_INT 1
19260: ARRAY
19261: PUSH
19262: EMPTY
19263: LIST
19264: ST_TO_ADDR
// for i = 2 to tmp do
19265: LD_ADDR_VAR 0 3
19269: PUSH
19270: DOUBLE
19271: LD_INT 2
19273: DEC
19274: ST_TO_ADDR
19275: LD_VAR 0 5
19279: PUSH
19280: FOR_TO
19281: IFFALSE 19573
// begin m := false ;
19283: LD_ADDR_VAR 0 7
19287: PUSH
19288: LD_INT 0
19290: ST_TO_ADDR
// if d then
19291: LD_VAR 0 8
19295: IFFALSE 19450
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19297: LD_VAR 0 5
19301: PUSH
19302: LD_VAR 0 3
19306: ARRAY
19307: PPUSH
19308: CALL_OW 256
19312: PUSH
19313: LD_INT 650
19315: LESS
19316: PUSH
19317: LD_VAR 0 5
19321: PUSH
19322: LD_VAR 0 3
19326: ARRAY
19327: PPUSH
19328: LD_VAR 0 8
19332: PUSH
19333: LD_INT 1
19335: ARRAY
19336: PPUSH
19337: CALL_OW 250
19341: PPUSH
19342: LD_VAR 0 8
19346: PUSH
19347: LD_INT 1
19349: ARRAY
19350: PPUSH
19351: CALL_OW 251
19355: PPUSH
19356: CALL_OW 297
19360: PUSH
19361: LD_INT 10
19363: GREATER
19364: AND
19365: IFFALSE 19450
// begin if not GetTag ( tmp [ i ] ) = 5 then
19367: LD_VAR 0 5
19371: PUSH
19372: LD_VAR 0 3
19376: ARRAY
19377: PPUSH
19378: CALL_OW 110
19382: PUSH
19383: LD_INT 5
19385: EQUAL
19386: NOT
19387: IFFALSE 19407
// SetTag ( tmp [ i ] , 5 ) ;
19389: LD_VAR 0 5
19393: PUSH
19394: LD_VAR 0 3
19398: ARRAY
19399: PPUSH
19400: LD_INT 5
19402: PPUSH
19403: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19407: LD_VAR 0 5
19411: PUSH
19412: LD_VAR 0 3
19416: ARRAY
19417: PPUSH
19418: LD_VAR 0 8
19422: PUSH
19423: LD_INT 1
19425: ARRAY
19426: PPUSH
19427: CALL_OW 250
19431: PPUSH
19432: LD_VAR 0 8
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: CALL_OW 251
19445: PPUSH
19446: CALL_OW 111
// end ; for j = 1 to r do
19450: LD_ADDR_VAR 0 4
19454: PUSH
19455: DOUBLE
19456: LD_INT 1
19458: DEC
19459: ST_TO_ADDR
19460: LD_VAR 0 6
19464: PUSH
19465: FOR_TO
19466: IFFALSE 19540
// if GetLives ( tmp [ i ] ) < r [ j ] then
19468: LD_VAR 0 5
19472: PUSH
19473: LD_VAR 0 3
19477: ARRAY
19478: PPUSH
19479: CALL_OW 256
19483: PUSH
19484: LD_VAR 0 6
19488: PUSH
19489: LD_VAR 0 4
19493: ARRAY
19494: LESS
19495: IFFALSE 19538
// begin r := Insert ( r , j , tmp [ i ] ) ;
19497: LD_ADDR_VAR 0 6
19501: PUSH
19502: LD_VAR 0 6
19506: PPUSH
19507: LD_VAR 0 4
19511: PPUSH
19512: LD_VAR 0 5
19516: PUSH
19517: LD_VAR 0 3
19521: ARRAY
19522: PPUSH
19523: CALL_OW 2
19527: ST_TO_ADDR
// m := true ;
19528: LD_ADDR_VAR 0 7
19532: PUSH
19533: LD_INT 1
19535: ST_TO_ADDR
// break ;
19536: GO 19540
// end ;
19538: GO 19465
19540: POP
19541: POP
// if not m then
19542: LD_VAR 0 7
19546: NOT
19547: IFFALSE 19571
// r := r ^ tmp [ i ] ;
19549: LD_ADDR_VAR 0 6
19553: PUSH
19554: LD_VAR 0 6
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: ADD
19570: ST_TO_ADDR
// end ;
19571: GO 19280
19573: POP
19574: POP
// end ; result := r end ; end_of_file
19575: LD_ADDR_VAR 0 2
19579: PUSH
19580: LD_VAR 0 6
19584: ST_TO_ADDR
19585: LD_VAR 0 2
19589: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19590: LD_INT 0
19592: PPUSH
19593: PPUSH
19594: PPUSH
// pom := GetBase ( bdepot ) ;
19595: LD_ADDR_VAR 0 3
19599: PUSH
19600: LD_VAR 0 1
19604: PPUSH
19605: CALL_OW 274
19609: ST_TO_ADDR
// sor := [ ] ;
19610: LD_ADDR_VAR 0 4
19614: PUSH
19615: EMPTY
19616: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19617: LD_ADDR_VAR 0 4
19621: PUSH
19622: LD_VAR 0 4
19626: PUSH
19627: LD_VAR 0 3
19631: PPUSH
19632: LD_INT 1
19634: PPUSH
19635: CALL_OW 275
19639: ADD
19640: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19641: LD_ADDR_VAR 0 4
19645: PUSH
19646: LD_VAR 0 4
19650: PUSH
19651: LD_VAR 0 3
19655: PPUSH
19656: LD_INT 2
19658: PPUSH
19659: CALL_OW 275
19663: ADD
19664: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19665: LD_ADDR_VAR 0 4
19669: PUSH
19670: LD_VAR 0 4
19674: PUSH
19675: LD_VAR 0 3
19679: PPUSH
19680: LD_INT 3
19682: PPUSH
19683: CALL_OW 275
19687: ADD
19688: ST_TO_ADDR
// result := sor ;
19689: LD_ADDR_VAR 0 2
19693: PUSH
19694: LD_VAR 0 4
19698: ST_TO_ADDR
// end ;
19699: LD_VAR 0 2
19703: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19704: LD_INT 0
19706: PPUSH
19707: PPUSH
// while ( coord_list ) do
19708: LD_VAR 0 3
19712: IFFALSE 19886
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19714: LD_ADDR_EXP 48
19718: PUSH
19719: LD_EXP 48
19723: PPUSH
19724: LD_VAR 0 1
19728: PPUSH
19729: LD_VAR 0 2
19733: PPUSH
19734: LD_VAR 0 3
19738: PUSH
19739: LD_INT 1
19741: ARRAY
19742: PUSH
19743: LD_VAR 0 3
19747: PUSH
19748: LD_INT 2
19750: ARRAY
19751: PUSH
19752: LD_VAR 0 3
19756: PUSH
19757: LD_INT 3
19759: ARRAY
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: LIST
19765: PPUSH
19766: CALL 42125 0 4
19770: ST_TO_ADDR
// if weapon_list then
19771: LD_VAR 0 4
19775: IFFALSE 19846
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19777: LD_ADDR_EXP 45
19781: PUSH
19782: LD_EXP 45
19786: PPUSH
19787: LD_VAR 0 1
19791: PPUSH
19792: LD_VAR 0 4
19796: PUSH
19797: LD_INT 1
19799: ARRAY
19800: PPUSH
19801: LD_VAR 0 3
19805: PUSH
19806: LD_INT 1
19808: ARRAY
19809: PUSH
19810: LD_VAR 0 3
19814: PUSH
19815: LD_INT 2
19817: ARRAY
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: PPUSH
19823: CALL 42125 0 4
19827: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19828: LD_ADDR_VAR 0 4
19832: PUSH
19833: LD_VAR 0 4
19837: PPUSH
19838: LD_INT 1
19840: PPUSH
19841: CALL_OW 3
19845: ST_TO_ADDR
// end ; for i = 1 to 3 do
19846: LD_ADDR_VAR 0 6
19850: PUSH
19851: DOUBLE
19852: LD_INT 1
19854: DEC
19855: ST_TO_ADDR
19856: LD_INT 3
19858: PUSH
19859: FOR_TO
19860: IFFALSE 19882
// coord_list := Delete ( coord_list , 1 ) ;
19862: LD_ADDR_VAR 0 3
19866: PUSH
19867: LD_VAR 0 3
19871: PPUSH
19872: LD_INT 1
19874: PPUSH
19875: CALL_OW 3
19879: ST_TO_ADDR
19880: GO 19859
19882: POP
19883: POP
// end ;
19884: GO 19708
// result := true ;
19886: LD_ADDR_VAR 0 5
19890: PUSH
19891: LD_INT 1
19893: ST_TO_ADDR
// end ;
19894: LD_VAR 0 5
19898: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19899: LD_INT 0
19901: PPUSH
19902: PPUSH
// if not weapon_list then
19903: LD_VAR 0 3
19907: NOT
19908: IFFALSE 19912
// exit ;
19910: GO 20027
// while ( coord_list ) do
19912: LD_VAR 0 2
19916: IFFALSE 20027
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19918: LD_ADDR_EXP 45
19922: PUSH
19923: LD_EXP 45
19927: PPUSH
19928: LD_VAR 0 1
19932: PPUSH
19933: LD_VAR 0 3
19937: PUSH
19938: LD_INT 1
19940: ARRAY
19941: PPUSH
19942: LD_VAR 0 2
19946: PUSH
19947: LD_INT 1
19949: ARRAY
19950: PUSH
19951: LD_VAR 0 2
19955: PUSH
19956: LD_INT 2
19958: ARRAY
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: PPUSH
19964: CALL 42125 0 4
19968: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19969: LD_ADDR_VAR 0 3
19973: PUSH
19974: LD_VAR 0 3
19978: PPUSH
19979: LD_INT 1
19981: PPUSH
19982: CALL_OW 3
19986: ST_TO_ADDR
// for i = 1 to 2 do
19987: LD_ADDR_VAR 0 5
19991: PUSH
19992: DOUBLE
19993: LD_INT 1
19995: DEC
19996: ST_TO_ADDR
19997: LD_INT 2
19999: PUSH
20000: FOR_TO
20001: IFFALSE 20023
// coord_list := Delete ( coord_list , 1 ) ;
20003: LD_ADDR_VAR 0 2
20007: PUSH
20008: LD_VAR 0 2
20012: PPUSH
20013: LD_INT 1
20015: PPUSH
20016: CALL_OW 3
20020: ST_TO_ADDR
20021: GO 20000
20023: POP
20024: POP
// end ;
20025: GO 19912
// end ;
20027: LD_VAR 0 4
20031: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20032: LD_INT 0
20034: PPUSH
20035: PPUSH
// while ( coord_list ) do
20036: LD_VAR 0 2
20040: IFFALSE 20195
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20042: LD_VAR 0 2
20046: PUSH
20047: LD_INT 1
20049: ARRAY
20050: PPUSH
20051: LD_VAR 0 2
20055: PUSH
20056: LD_INT 2
20058: ARRAY
20059: PPUSH
20060: CALL_OW 428
20064: IFFALSE 20155
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20066: LD_VAR 0 2
20070: PUSH
20071: LD_INT 1
20073: ARRAY
20074: PPUSH
20075: LD_VAR 0 2
20079: PUSH
20080: LD_INT 2
20082: ARRAY
20083: PPUSH
20084: CALL_OW 428
20088: PPUSH
20089: CALL_OW 266
20093: PUSH
20094: LD_INT 31
20096: PUSH
20097: LD_INT 32
20099: PUSH
20100: LD_INT 33
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: LIST
20107: IN
20108: IFFALSE 20155
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20110: LD_ADDR_EXP 54
20114: PUSH
20115: LD_EXP 54
20119: PPUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: LD_VAR 0 2
20129: PUSH
20130: LD_INT 1
20132: ARRAY
20133: PPUSH
20134: LD_VAR 0 2
20138: PUSH
20139: LD_INT 2
20141: ARRAY
20142: PPUSH
20143: CALL_OW 428
20147: PPUSH
20148: EMPTY
20149: PPUSH
20150: CALL 42125 0 4
20154: ST_TO_ADDR
// for i = 1 to 3 do
20155: LD_ADDR_VAR 0 4
20159: PUSH
20160: DOUBLE
20161: LD_INT 1
20163: DEC
20164: ST_TO_ADDR
20165: LD_INT 3
20167: PUSH
20168: FOR_TO
20169: IFFALSE 20191
// coord_list := Delete ( coord_list , 1 ) ;
20171: LD_ADDR_VAR 0 2
20175: PUSH
20176: LD_VAR 0 2
20180: PPUSH
20181: LD_INT 1
20183: PPUSH
20184: CALL_OW 3
20188: ST_TO_ADDR
20189: GO 20168
20191: POP
20192: POP
// end ;
20193: GO 20036
// result := true ;
20195: LD_ADDR_VAR 0 3
20199: PUSH
20200: LD_INT 1
20202: ST_TO_ADDR
// end ;
20203: LD_VAR 0 3
20207: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20208: LD_INT 0
20210: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20211: LD_ADDR_EXP 48
20215: PUSH
20216: LD_EXP 48
20220: PPUSH
20221: LD_VAR 0 1
20225: PPUSH
20226: LD_INT 0
20228: PPUSH
20229: LD_VAR 0 2
20233: PPUSH
20234: CALL 42125 0 4
20238: ST_TO_ADDR
// end ;
20239: LD_VAR 0 3
20243: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20244: LD_INT 0
20246: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20247: LD_ADDR_EXP 48
20251: PUSH
20252: LD_EXP 48
20256: PPUSH
20257: LD_VAR 0 1
20261: PPUSH
20262: LD_INT 6
20264: PPUSH
20265: LD_VAR 0 2
20269: PPUSH
20270: CALL 42125 0 4
20274: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20275: LD_ADDR_EXP 51
20279: PUSH
20280: LD_EXP 51
20284: PPUSH
20285: LD_VAR 0 1
20289: PPUSH
20290: LD_VAR 0 3
20294: PUSH
20295: LD_INT 1
20297: ARRAY
20298: PPUSH
20299: LD_VAR 0 3
20303: PUSH
20304: LD_INT 2
20306: ARRAY
20307: PPUSH
20308: CALL 42125 0 4
20312: ST_TO_ADDR
// end ;
20313: LD_VAR 0 4
20317: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20318: LD_INT 0
20320: PPUSH
20321: PPUSH
// if ext_list > 5 then
20322: LD_VAR 0 3
20326: PUSH
20327: LD_INT 5
20329: GREATER
20330: IFFALSE 20374
// for i = 6 to ext_list do
20332: LD_ADDR_VAR 0 5
20336: PUSH
20337: DOUBLE
20338: LD_INT 6
20340: DEC
20341: ST_TO_ADDR
20342: LD_VAR 0 3
20346: PUSH
20347: FOR_TO
20348: IFFALSE 20372
// ext_list := Delete ( ext_list , ext_list ) ;
20350: LD_ADDR_VAR 0 3
20354: PUSH
20355: LD_VAR 0 3
20359: PPUSH
20360: LD_VAR 0 3
20364: PPUSH
20365: CALL_OW 3
20369: ST_TO_ADDR
20370: GO 20347
20372: POP
20373: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20374: LD_VAR 0 1
20378: PPUSH
20379: LD_VAR 0 2
20383: PUSH
20384: LD_INT 1
20386: ARRAY
20387: PPUSH
20388: LD_VAR 0 2
20392: PUSH
20393: LD_INT 2
20395: ARRAY
20396: PPUSH
20397: LD_VAR 0 2
20401: PUSH
20402: LD_INT 3
20404: ARRAY
20405: PPUSH
20406: LD_VAR 0 3
20410: PPUSH
20411: CALL 8921 0 5
// end ;
20415: LD_VAR 0 4
20419: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20420: LD_INT 0
20422: PPUSH
20423: PPUSH
20424: PPUSH
// p := 1 ;
20425: LD_ADDR_VAR 0 6
20429: PUSH
20430: LD_INT 1
20432: ST_TO_ADDR
// if type_list = [ ] then
20433: LD_VAR 0 3
20437: PUSH
20438: EMPTY
20439: EQUAL
20440: IFFALSE 20450
// type_list := b_oil_power ;
20442: LD_ADDR_VAR 0 3
20446: PUSH
20447: LD_INT 26
20449: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20450: LD_ADDR_VAR 0 5
20454: PUSH
20455: DOUBLE
20456: LD_INT 1
20458: DEC
20459: ST_TO_ADDR
20460: LD_VAR 0 2
20464: PUSH
20465: LD_INT 3
20467: DIVREAL
20468: PUSH
20469: FOR_TO
20470: IFFALSE 20573
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20472: LD_ADDR_EXP 48
20476: PUSH
20477: LD_EXP 48
20481: PPUSH
20482: LD_VAR 0 1
20486: PPUSH
20487: LD_VAR 0 3
20491: PUSH
20492: LD_INT 1
20494: PPUSH
20495: LD_VAR 0 3
20499: PPUSH
20500: CALL_OW 12
20504: ARRAY
20505: PPUSH
20506: LD_VAR 0 2
20510: PUSH
20511: LD_VAR 0 6
20515: ARRAY
20516: PUSH
20517: LD_VAR 0 2
20521: PUSH
20522: LD_VAR 0 6
20526: PUSH
20527: LD_INT 1
20529: PLUS
20530: ARRAY
20531: PUSH
20532: LD_VAR 0 2
20536: PUSH
20537: LD_VAR 0 6
20541: PUSH
20542: LD_INT 2
20544: PLUS
20545: ARRAY
20546: PUSH
20547: EMPTY
20548: LIST
20549: LIST
20550: LIST
20551: PPUSH
20552: CALL 42125 0 4
20556: ST_TO_ADDR
// p := p + 3 ;
20557: LD_ADDR_VAR 0 6
20561: PUSH
20562: LD_VAR 0 6
20566: PUSH
20567: LD_INT 3
20569: PLUS
20570: ST_TO_ADDR
// end ;
20571: GO 20469
20573: POP
20574: POP
// end ;
20575: LD_VAR 0 4
20579: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20580: LD_INT 0
20582: PPUSH
20583: PPUSH
20584: PPUSH
20585: PPUSH
// if not MREG_Deposit [ side ] then
20586: LD_EXP 63
20590: PUSH
20591: LD_VAR 0 1
20595: ARRAY
20596: NOT
20597: IFFALSE 20601
// exit ;
20599: GO 20778
// p := 1 ;
20601: LD_ADDR_VAR 0 4
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20609: LD_ADDR_VAR 0 3
20613: PUSH
20614: DOUBLE
20615: LD_INT 1
20617: DEC
20618: ST_TO_ADDR
20619: LD_EXP 63
20623: PUSH
20624: LD_VAR 0 1
20628: ARRAY
20629: PUSH
20630: LD_INT 3
20632: DIVREAL
20633: PUSH
20634: FOR_TO
20635: IFFALSE 20776
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20637: LD_EXP 63
20641: PUSH
20642: LD_VAR 0 1
20646: ARRAY
20647: PUSH
20648: LD_VAR 0 4
20652: PUSH
20653: LD_INT 2
20655: PLUS
20656: ARRAY
20657: PUSH
20658: LD_INT 2
20660: EQUAL
20661: IFFALSE 20673
// b := b_oil_mine else
20663: LD_ADDR_VAR 0 5
20667: PUSH
20668: LD_INT 29
20670: ST_TO_ADDR
20671: GO 20681
// b := b_siberite_mine ;
20673: LD_ADDR_VAR 0 5
20677: PUSH
20678: LD_INT 30
20680: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20681: LD_ADDR_EXP 48
20685: PUSH
20686: LD_EXP 48
20690: PPUSH
20691: LD_VAR 0 1
20695: PPUSH
20696: LD_VAR 0 5
20700: PPUSH
20701: LD_EXP 63
20705: PUSH
20706: LD_VAR 0 1
20710: ARRAY
20711: PUSH
20712: LD_VAR 0 4
20716: ARRAY
20717: PUSH
20718: LD_EXP 63
20722: PUSH
20723: LD_VAR 0 1
20727: ARRAY
20728: PUSH
20729: LD_VAR 0 4
20733: PUSH
20734: LD_INT 1
20736: PLUS
20737: ARRAY
20738: PUSH
20739: LD_INT 0
20741: PPUSH
20742: LD_INT 5
20744: PPUSH
20745: CALL_OW 12
20749: PUSH
20750: EMPTY
20751: LIST
20752: LIST
20753: LIST
20754: PPUSH
20755: CALL 42125 0 4
20759: ST_TO_ADDR
// p := p + 3 ;
20760: LD_ADDR_VAR 0 4
20764: PUSH
20765: LD_VAR 0 4
20769: PUSH
20770: LD_INT 3
20772: PLUS
20773: ST_TO_ADDR
// end ;
20774: GO 20634
20776: POP
20777: POP
// end ;
20778: LD_VAR 0 2
20782: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20783: LD_INT 0
20785: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20786: LD_ADDR_EXP 48
20790: PUSH
20791: LD_EXP 48
20795: PPUSH
20796: LD_VAR 0 1
20800: PPUSH
20801: LD_INT 4
20803: PPUSH
20804: LD_VAR 0 2
20808: PPUSH
20809: CALL 42125 0 4
20813: ST_TO_ADDR
// end ;
20814: LD_VAR 0 3
20818: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20819: LD_INT 0
20821: PPUSH
// case nation of 1 , us :
20822: LD_VAR 0 2
20826: PUSH
20827: LD_INT 1
20829: DOUBLE
20830: EQUAL
20831: IFTRUE 20841
20833: LD_STRING us
20835: DOUBLE
20836: EQUAL
20837: IFTRUE 20841
20839: GO 20872
20841: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20842: LD_ADDR_EXP 48
20846: PUSH
20847: LD_EXP 48
20851: PPUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: LD_INT 36
20859: PPUSH
20860: LD_VAR 0 3
20864: PPUSH
20865: CALL 42125 0 4
20869: ST_TO_ADDR
20870: GO 20923
20872: LD_INT 2
20874: DOUBLE
20875: EQUAL
20876: IFTRUE 20886
20878: LD_STRING ar
20880: DOUBLE
20881: EQUAL
20882: IFTRUE 20886
20884: GO 20922
20886: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20887: LD_ADDR_EXP 48
20891: PUSH
20892: LD_VAR 0 1
20896: PPUSH
20897: LD_INT 14
20899: PUSH
20900: LD_INT 2
20902: PUSH
20903: LD_INT 1
20905: PUSH
20906: LD_INT 31
20908: PUSH
20909: EMPTY
20910: LIST
20911: LIST
20912: LIST
20913: LIST
20914: PPUSH
20915: CALL 20928 0 2
20919: ST_TO_ADDR
20920: GO 20923
20922: POP
// end ;
20923: LD_VAR 0 4
20927: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20928: LD_INT 0
20930: PPUSH
20931: PPUSH
// for i = 1 to list do
20932: LD_ADDR_VAR 0 4
20936: PUSH
20937: DOUBLE
20938: LD_INT 1
20940: DEC
20941: ST_TO_ADDR
20942: LD_VAR 0 2
20946: PUSH
20947: FOR_TO
20948: IFFALSE 20998
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20950: LD_ADDR_EXP 53
20954: PUSH
20955: LD_EXP 53
20959: PPUSH
20960: LD_VAR 0 1
20964: PPUSH
20965: LD_EXP 53
20969: PUSH
20970: LD_VAR 0 1
20974: ARRAY
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: PPUSH
20980: LD_VAR 0 2
20984: PUSH
20985: LD_VAR 0 4
20989: ARRAY
20990: PPUSH
20991: CALL 30843 0 4
20995: ST_TO_ADDR
20996: GO 20947
20998: POP
20999: POP
// end ;
21000: LD_VAR 0 3
21004: RET
// export function MCS_GetVehicleList ( side ) ; begin
21005: LD_INT 0
21007: PPUSH
// result := MREG_ToConstruct [ side ] ;
21008: LD_ADDR_VAR 0 2
21012: PUSH
21013: LD_EXP 53
21017: PUSH
21018: LD_VAR 0 1
21022: ARRAY
21023: ST_TO_ADDR
// end ;
21024: LD_VAR 0 2
21028: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21029: LD_INT 0
21031: PPUSH
21032: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21033: LD_ADDR_EXP 60
21037: PUSH
21038: LD_EXP 60
21042: PPUSH
21043: LD_VAR 0 1
21047: PPUSH
21048: LD_VAR 0 2
21052: PPUSH
21053: CALL_OW 1
21057: ST_TO_ADDR
// end ;
21058: LD_VAR 0 3
21062: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21063: LD_INT 0
21065: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21066: LD_ADDR_EXP 39
21070: PUSH
21071: LD_EXP 39
21075: PPUSH
21076: LD_VAR 0 1
21080: PPUSH
21081: LD_VAR 0 2
21085: PPUSH
21086: CALL_OW 1
21090: ST_TO_ADDR
// end ;
21091: LD_VAR 0 3
21095: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21096: LD_INT 0
21098: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21099: LD_ADDR_EXP 40
21103: PUSH
21104: LD_EXP 40
21108: PPUSH
21109: LD_VAR 0 1
21113: PPUSH
21114: LD_VAR 0 2
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// end ;
21124: LD_VAR 0 3
21128: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21129: LD_INT 0
21131: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21132: LD_ADDR_EXP 62
21136: PUSH
21137: LD_EXP 62
21141: PPUSH
21142: LD_VAR 0 1
21146: PPUSH
21147: LD_INT 1
21149: PPUSH
21150: LD_VAR 0 2
21154: PPUSH
21155: CALL 30843 0 4
21159: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21160: LD_ADDR_EXP 62
21164: PUSH
21165: LD_EXP 62
21169: PPUSH
21170: LD_VAR 0 1
21174: PPUSH
21175: LD_INT 2
21177: PPUSH
21178: LD_VAR 0 3
21182: PPUSH
21183: CALL 30843 0 4
21187: ST_TO_ADDR
// end ;
21188: LD_VAR 0 4
21192: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21193: LD_INT 0
21195: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21196: LD_ADDR_EXP 74
21200: PUSH
21201: LD_EXP 74
21205: PPUSH
21206: LD_INT 1
21208: PPUSH
21209: LD_VAR 0 1
21213: PPUSH
21214: CALL_OW 1
21218: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21219: LD_ADDR_EXP 74
21223: PUSH
21224: LD_EXP 74
21228: PPUSH
21229: LD_INT 2
21231: PPUSH
21232: LD_VAR 0 2
21236: PPUSH
21237: CALL_OW 1
21241: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21242: LD_ADDR_EXP 74
21246: PUSH
21247: LD_EXP 74
21251: PPUSH
21252: LD_INT 3
21254: PPUSH
21255: LD_VAR 0 3
21259: PPUSH
21260: CALL_OW 1
21264: ST_TO_ADDR
// end ;
21265: LD_VAR 0 4
21269: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21270: LD_INT 0
21272: PPUSH
21273: PPUSH
21274: PPUSH
// if not side or not list then
21275: LD_VAR 0 1
21279: NOT
21280: PUSH
21281: LD_VAR 0 2
21285: NOT
21286: OR
21287: IFFALSE 21291
// exit ;
21289: GO 21459
// SetTech ( 20 , side , state_researched ) ;
21291: LD_INT 20
21293: PPUSH
21294: LD_VAR 0 1
21298: PPUSH
21299: LD_INT 2
21301: PPUSH
21302: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21306: LD_ADDR_EXP 63
21310: PUSH
21311: LD_EXP 63
21315: PPUSH
21316: LD_VAR 0 1
21320: PPUSH
21321: LD_VAR 0 2
21325: PPUSH
21326: CALL_OW 2
21330: ST_TO_ADDR
// p := 1 ;
21331: LD_ADDR_VAR 0 5
21335: PUSH
21336: LD_INT 1
21338: ST_TO_ADDR
// for i = 1 to list / 3 do
21339: LD_ADDR_VAR 0 4
21343: PUSH
21344: DOUBLE
21345: LD_INT 1
21347: DEC
21348: ST_TO_ADDR
21349: LD_VAR 0 2
21353: PUSH
21354: LD_INT 3
21356: DIVREAL
21357: PUSH
21358: FOR_TO
21359: IFFALSE 21457
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21361: LD_VAR 0 2
21365: PUSH
21366: LD_VAR 0 5
21370: ARRAY
21371: PPUSH
21372: LD_VAR 0 2
21376: PUSH
21377: LD_VAR 0 5
21381: PUSH
21382: LD_INT 1
21384: PLUS
21385: ARRAY
21386: PPUSH
21387: LD_VAR 0 2
21391: PUSH
21392: LD_VAR 0 5
21396: PUSH
21397: LD_INT 2
21399: PLUS
21400: ARRAY
21401: PPUSH
21402: CALL 22161 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21406: LD_VAR 0 2
21410: PUSH
21411: LD_VAR 0 5
21415: ARRAY
21416: PPUSH
21417: LD_VAR 0 2
21421: PUSH
21422: LD_VAR 0 5
21426: PUSH
21427: LD_INT 1
21429: PLUS
21430: ARRAY
21431: PPUSH
21432: LD_VAR 0 1
21436: PPUSH
21437: CALL_OW 441
// p := p + 3 ;
21441: LD_ADDR_VAR 0 5
21445: PUSH
21446: LD_VAR 0 5
21450: PUSH
21451: LD_INT 3
21453: PLUS
21454: ST_TO_ADDR
// end ;
21455: GO 21358
21457: POP
21458: POP
// end ;
21459: LD_VAR 0 3
21463: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21464: LD_INT 0
21466: PPUSH
21467: PPUSH
// if nat = nation_arabian then
21468: LD_VAR 0 2
21472: PUSH
21473: LD_INT 2
21475: EQUAL
21476: IFFALSE 21482
// exit else
21478: GO 21554
21480: GO 21540
// if nat = nation_american then
21482: LD_VAR 0 2
21486: PUSH
21487: LD_INT 1
21489: EQUAL
21490: IFFALSE 21517
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21492: LD_ADDR_VAR 0 4
21496: PUSH
21497: LD_INT 4
21499: PUSH
21500: LD_INT 3
21502: PUSH
21503: LD_INT 1
21505: PUSH
21506: LD_INT 8
21508: PUSH
21509: EMPTY
21510: LIST
21511: LIST
21512: LIST
21513: LIST
21514: ST_TO_ADDR
21515: GO 21540
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: LD_INT 24
21524: PUSH
21525: LD_INT 3
21527: PUSH
21528: LD_INT 1
21530: PUSH
21531: LD_INT 48
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21540: LD_VAR 0 1
21544: PPUSH
21545: LD_VAR 0 4
21549: PPUSH
21550: CALL 20928 0 2
// end ;
21554: LD_VAR 0 3
21558: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21559: LD_INT 0
21561: PPUSH
21562: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21563: LD_ADDR_EXP 65
21567: PUSH
21568: LD_EXP 65
21572: PPUSH
21573: LD_VAR 0 1
21577: PPUSH
21578: LD_INT 1
21580: PPUSH
21581: LD_VAR 0 4
21585: PPUSH
21586: CALL 30843 0 4
21590: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21591: LD_ADDR_EXP 66
21595: PUSH
21596: LD_EXP 66
21600: PPUSH
21601: LD_VAR 0 1
21605: PPUSH
21606: LD_INT 1
21608: PPUSH
21609: LD_VAR 0 2
21613: PPUSH
21614: CALL 30843 0 4
21618: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21619: LD_ADDR_EXP 67
21623: PUSH
21624: LD_EXP 67
21628: PPUSH
21629: LD_VAR 0 1
21633: PPUSH
21634: LD_INT 1
21636: PPUSH
21637: LD_VAR 0 3
21641: PPUSH
21642: CALL 30843 0 4
21646: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21647: LD_ADDR_EXP 68
21651: PUSH
21652: LD_EXP 68
21656: PPUSH
21657: LD_VAR 0 1
21661: PPUSH
21662: LD_INT 1
21664: PPUSH
21665: LD_VAR 0 5
21669: PPUSH
21670: CALL 30843 0 4
21674: ST_TO_ADDR
// while squad do
21675: LD_VAR 0 5
21679: IFFALSE 21772
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21681: LD_VAR 0 1
21685: PPUSH
21686: LD_VAR 0 5
21690: PUSH
21691: LD_INT 1
21693: ARRAY
21694: PUSH
21695: LD_VAR 0 5
21699: PUSH
21700: LD_INT 2
21702: ARRAY
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: ARRAY
21712: PUSH
21713: LD_VAR 0 5
21717: PUSH
21718: LD_INT 4
21720: ARRAY
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: LIST
21726: LIST
21727: PPUSH
21728: CALL 20928 0 2
// for i = 1 to 4 do
21732: LD_ADDR_VAR 0 7
21736: PUSH
21737: DOUBLE
21738: LD_INT 1
21740: DEC
21741: ST_TO_ADDR
21742: LD_INT 4
21744: PUSH
21745: FOR_TO
21746: IFFALSE 21768
// squad := Delete ( squad , 1 ) ;
21748: LD_ADDR_VAR 0 5
21752: PUSH
21753: LD_VAR 0 5
21757: PPUSH
21758: LD_INT 1
21760: PPUSH
21761: CALL_OW 3
21765: ST_TO_ADDR
21766: GO 21745
21768: POP
21769: POP
// end ;
21770: GO 21675
// end ;
21772: LD_VAR 0 6
21776: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21777: LD_INT 0
21779: PPUSH
21780: PPUSH
// for i = 1 to squad do
21781: LD_ADDR_VAR 0 4
21785: PUSH
21786: DOUBLE
21787: LD_INT 1
21789: DEC
21790: ST_TO_ADDR
21791: LD_VAR 0 2
21795: PUSH
21796: FOR_TO
21797: IFFALSE 21847
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21799: LD_ADDR_EXP 71
21803: PUSH
21804: LD_EXP 71
21808: PPUSH
21809: LD_VAR 0 1
21813: PPUSH
21814: LD_EXP 71
21818: PUSH
21819: LD_VAR 0 1
21823: ARRAY
21824: PUSH
21825: LD_INT 1
21827: PLUS
21828: PPUSH
21829: LD_VAR 0 2
21833: PUSH
21834: LD_VAR 0 4
21838: ARRAY
21839: PPUSH
21840: CALL 30843 0 4
21844: ST_TO_ADDR
21845: GO 21796
21847: POP
21848: POP
// while squad do
21849: LD_VAR 0 2
21853: IFFALSE 21946
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21855: LD_VAR 0 1
21859: PPUSH
21860: LD_VAR 0 2
21864: PUSH
21865: LD_INT 1
21867: ARRAY
21868: PUSH
21869: LD_VAR 0 2
21873: PUSH
21874: LD_INT 2
21876: ARRAY
21877: PUSH
21878: LD_VAR 0 2
21882: PUSH
21883: LD_INT 3
21885: ARRAY
21886: PUSH
21887: LD_VAR 0 2
21891: PUSH
21892: LD_INT 4
21894: ARRAY
21895: PUSH
21896: EMPTY
21897: LIST
21898: LIST
21899: LIST
21900: LIST
21901: PPUSH
21902: CALL 20928 0 2
// for i = 1 to 4 do
21906: LD_ADDR_VAR 0 4
21910: PUSH
21911: DOUBLE
21912: LD_INT 1
21914: DEC
21915: ST_TO_ADDR
21916: LD_INT 4
21918: PUSH
21919: FOR_TO
21920: IFFALSE 21942
// squad := Delete ( squad , 1 ) ;
21922: LD_ADDR_VAR 0 2
21926: PUSH
21927: LD_VAR 0 2
21931: PPUSH
21932: LD_INT 1
21934: PPUSH
21935: CALL_OW 3
21939: ST_TO_ADDR
21940: GO 21919
21942: POP
21943: POP
// end ;
21944: GO 21849
// end ;
21946: LD_VAR 0 3
21950: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21951: LD_INT 0
21953: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21954: LD_ADDR_EXP 64
21958: PUSH
21959: LD_EXP 64
21963: PPUSH
21964: LD_VAR 0 1
21968: PPUSH
21969: LD_INT 1
21971: PPUSH
21972: LD_VAR 0 2
21976: PPUSH
21977: CALL 30843 0 4
21981: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21982: LD_ADDR_EXP 64
21986: PUSH
21987: LD_EXP 64
21991: PPUSH
21992: LD_VAR 0 1
21996: PPUSH
21997: LD_INT 2
21999: PPUSH
22000: LD_VAR 0 3
22004: PPUSH
22005: CALL 30843 0 4
22009: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22010: LD_ADDR_EXP 64
22014: PUSH
22015: LD_EXP 64
22019: PPUSH
22020: LD_VAR 0 1
22024: PPUSH
22025: LD_INT 3
22027: PPUSH
22028: LD_VAR 0 4
22032: PPUSH
22033: CALL 30843 0 4
22037: ST_TO_ADDR
// end ; end_of_file
22038: LD_VAR 0 5
22042: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22043: LD_INT 0
22045: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22046: LD_ADDR_EXP 44
22050: PUSH
22051: LD_EXP 44
22055: PPUSH
22056: LD_VAR 0 1
22060: PPUSH
22061: LD_INT 1
22063: PPUSH
22064: LD_VAR 0 2
22068: PPUSH
22069: CALL 30843 0 4
22073: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22074: LD_VAR 0 1
22078: PPUSH
22079: EMPTY
22080: PPUSH
22081: CALL 11544 0 2
22085: PUSH
22086: LD_INT 1
22088: ARRAY
22089: PPUSH
22090: CALL_OW 248
22094: PUSH
22095: LD_INT 1
22097: EQUAL
22098: IFFALSE 22129
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22100: LD_VAR 0 1
22104: PPUSH
22105: LD_INT 4
22107: PUSH
22108: LD_INT 1
22110: PUSH
22111: LD_INT 1
22113: PUSH
22114: LD_INT 14
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: LIST
22121: LIST
22122: PPUSH
22123: CALL 20928 0 2
22127: GO 22156
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22129: LD_VAR 0 1
22133: PPUSH
22134: LD_INT 24
22136: PUSH
22137: LD_INT 1
22139: PUSH
22140: LD_INT 1
22142: PUSH
22143: LD_INT 53
22145: PUSH
22146: EMPTY
22147: LIST
22148: LIST
22149: LIST
22150: LIST
22151: PPUSH
22152: CALL 20928 0 2
// end ;
22156: LD_VAR 0 3
22160: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22161: LD_INT 0
22163: PPUSH
// CreateDepositXY ( x , y , t ) ;
22164: LD_VAR 0 1
22168: PPUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_VAR 0 3
22178: PPUSH
22179: CALL_OW 62
// end ;
22183: LD_VAR 0 4
22187: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22188: LD_INT 0
22190: PPUSH
22191: PPUSH
// c := 1 ;
22192: LD_ADDR_VAR 0 5
22196: PUSH
22197: LD_INT 1
22199: ST_TO_ADDR
// case color of red :
22200: LD_VAR 0 3
22204: PUSH
22205: LD_STRING red
22207: DOUBLE
22208: EQUAL
22209: IFTRUE 22213
22211: GO 22224
22213: POP
// c = 1 ; dark-green :
22214: LD_ADDR_VAR 0 5
22218: PUSH
22219: LD_INT 1
22221: ST_TO_ADDR
22222: GO 22510
22224: LD_STRING dark-green
22226: DOUBLE
22227: EQUAL
22228: IFTRUE 22232
22230: GO 22243
22232: POP
// c = 2 ; purple :
22233: LD_ADDR_VAR 0 5
22237: PUSH
22238: LD_INT 2
22240: ST_TO_ADDR
22241: GO 22510
22243: LD_STRING purple
22245: DOUBLE
22246: EQUAL
22247: IFTRUE 22251
22249: GO 22262
22251: POP
// c = 3 ; aqua :
22252: LD_ADDR_VAR 0 5
22256: PUSH
22257: LD_INT 3
22259: ST_TO_ADDR
22260: GO 22510
22262: LD_STRING aqua
22264: DOUBLE
22265: EQUAL
22266: IFTRUE 22270
22268: GO 22281
22270: POP
// c = 4 ; grey :
22271: LD_ADDR_VAR 0 5
22275: PUSH
22276: LD_INT 4
22278: ST_TO_ADDR
22279: GO 22510
22281: LD_STRING grey
22283: DOUBLE
22284: EQUAL
22285: IFTRUE 22289
22287: GO 22300
22289: POP
// c = 5 ; lime :
22290: LD_ADDR_VAR 0 5
22294: PUSH
22295: LD_INT 5
22297: ST_TO_ADDR
22298: GO 22510
22300: LD_STRING lime
22302: DOUBLE
22303: EQUAL
22304: IFTRUE 22308
22306: GO 22319
22308: POP
// c = 6 ; tan :
22309: LD_ADDR_VAR 0 5
22313: PUSH
22314: LD_INT 6
22316: ST_TO_ADDR
22317: GO 22510
22319: LD_STRING tan
22321: DOUBLE
22322: EQUAL
22323: IFTRUE 22327
22325: GO 22338
22327: POP
// c = 7 ; pink :
22328: LD_ADDR_VAR 0 5
22332: PUSH
22333: LD_INT 7
22335: ST_TO_ADDR
22336: GO 22510
22338: LD_STRING pink
22340: DOUBLE
22341: EQUAL
22342: IFTRUE 22346
22344: GO 22357
22346: POP
// c = 8 ; green :
22347: LD_ADDR_VAR 0 5
22351: PUSH
22352: LD_INT 8
22354: ST_TO_ADDR
22355: GO 22510
22357: LD_STRING green
22359: DOUBLE
22360: EQUAL
22361: IFTRUE 22365
22363: GO 22376
22365: POP
// c = 9 ; blue :
22366: LD_ADDR_VAR 0 5
22370: PUSH
22371: LD_INT 9
22373: ST_TO_ADDR
22374: GO 22510
22376: LD_STRING blue
22378: DOUBLE
22379: EQUAL
22380: IFTRUE 22384
22382: GO 22395
22384: POP
// c = 10 ; yellow :
22385: LD_ADDR_VAR 0 5
22389: PUSH
22390: LD_INT 10
22392: ST_TO_ADDR
22393: GO 22510
22395: LD_STRING yellow
22397: DOUBLE
22398: EQUAL
22399: IFTRUE 22403
22401: GO 22414
22403: POP
// c = 11 ; brown :
22404: LD_ADDR_VAR 0 5
22408: PUSH
22409: LD_INT 11
22411: ST_TO_ADDR
22412: GO 22510
22414: LD_STRING brown
22416: DOUBLE
22417: EQUAL
22418: IFTRUE 22422
22420: GO 22433
22422: POP
// c = 12 ; black :
22423: LD_ADDR_VAR 0 5
22427: PUSH
22428: LD_INT 12
22430: ST_TO_ADDR
22431: GO 22510
22433: LD_STRING black
22435: DOUBLE
22436: EQUAL
22437: IFTRUE 22441
22439: GO 22452
22441: POP
// c = 13 ; aqua2 :
22442: LD_ADDR_VAR 0 5
22446: PUSH
22447: LD_INT 13
22449: ST_TO_ADDR
22450: GO 22510
22452: LD_STRING aqua2
22454: DOUBLE
22455: EQUAL
22456: IFTRUE 22460
22458: GO 22471
22460: POP
// c = 14 ; orange :
22461: LD_ADDR_VAR 0 5
22465: PUSH
22466: LD_INT 14
22468: ST_TO_ADDR
22469: GO 22510
22471: LD_STRING orange
22473: DOUBLE
22474: EQUAL
22475: IFTRUE 22479
22477: GO 22490
22479: POP
// c = 15 ; white :
22480: LD_ADDR_VAR 0 5
22484: PUSH
22485: LD_INT 15
22487: ST_TO_ADDR
22488: GO 22510
22490: LD_STRING white
22492: DOUBLE
22493: EQUAL
22494: IFTRUE 22498
22496: GO 22509
22498: POP
// c = 16 ; end ;
22499: LD_ADDR_VAR 0 5
22503: PUSH
22504: LD_INT 16
22506: ST_TO_ADDR
22507: GO 22510
22509: POP
// if HexInfo ( x , y ) = 0 then
22510: LD_VAR 0 1
22514: PPUSH
22515: LD_VAR 0 2
22519: PPUSH
22520: CALL_OW 428
22524: PUSH
22525: LD_INT 0
22527: EQUAL
22528: IFFALSE 22552
// PlaceEnvironment ( x , y , 58 , c ) ;
22530: LD_VAR 0 1
22534: PPUSH
22535: LD_VAR 0 2
22539: PPUSH
22540: LD_INT 58
22542: PPUSH
22543: LD_VAR 0 5
22547: PPUSH
22548: CALL_OW 349
// end ;
22552: LD_VAR 0 4
22556: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22557: LD_INT 0
22559: PPUSH
// RemoveEnvironment ( x , y ) ;
22560: LD_VAR 0 1
22564: PPUSH
22565: LD_VAR 0 2
22569: PPUSH
22570: CALL_OW 347
// end ;
22574: LD_VAR 0 3
22578: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22579: LD_INT 0
22581: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22582: LD_INT 81
22584: PUSH
22585: LD_VAR 0 1
22589: PUSH
22590: EMPTY
22591: LIST
22592: LIST
22593: PPUSH
22594: CALL_OW 69
22598: PUSH
22599: LD_INT 0
22601: EQUAL
22602: IFFALSE 22614
// result := false else
22604: LD_ADDR_VAR 0 5
22608: PUSH
22609: LD_INT 0
22611: ST_TO_ADDR
22612: GO 22678
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22614: LD_INT 81
22616: PUSH
22617: LD_VAR 0 1
22621: PUSH
22622: EMPTY
22623: LIST
22624: LIST
22625: PUSH
22626: LD_INT 92
22628: PUSH
22629: LD_VAR 0 2
22633: PUSH
22634: LD_VAR 0 3
22638: PUSH
22639: LD_VAR 0 4
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: LIST
22648: LIST
22649: PUSH
22650: EMPTY
22651: LIST
22652: LIST
22653: PPUSH
22654: CALL_OW 69
22658: IFFALSE 22670
// result := true else
22660: LD_ADDR_VAR 0 5
22664: PUSH
22665: LD_INT 1
22667: ST_TO_ADDR
22668: GO 22678
// result := false ;
22670: LD_ADDR_VAR 0 5
22674: PUSH
22675: LD_INT 0
22677: ST_TO_ADDR
// end ;
22678: LD_VAR 0 5
22682: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22683: LD_INT 0
22685: PPUSH
22686: PPUSH
22687: PPUSH
22688: PPUSH
22689: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22690: LD_VAR 0 1
22694: PPUSH
22695: LD_INT 81
22697: PUSH
22698: LD_VAR 0 1
22702: PPUSH
22703: CALL_OW 255
22707: PUSH
22708: EMPTY
22709: LIST
22710: LIST
22711: PPUSH
22712: CALL_OW 69
22716: PPUSH
22717: LD_VAR 0 1
22721: PPUSH
22722: CALL_OW 74
22726: PPUSH
22727: CALL_OW 119
// dir := GetDir ( un ) ;
22731: LD_ADDR_VAR 0 4
22735: PUSH
22736: LD_VAR 0 1
22740: PPUSH
22741: CALL_OW 254
22745: ST_TO_ADDR
// dir := dir - 3 ;
22746: LD_ADDR_VAR 0 4
22750: PUSH
22751: LD_VAR 0 4
22755: PUSH
22756: LD_INT 3
22758: MINUS
22759: ST_TO_ADDR
// if dir < 0 then
22760: LD_VAR 0 4
22764: PUSH
22765: LD_INT 0
22767: LESS
22768: IFFALSE 22784
// dir := dir + 6 ;
22770: LD_ADDR_VAR 0 4
22774: PUSH
22775: LD_VAR 0 4
22779: PUSH
22780: LD_INT 6
22782: PLUS
22783: ST_TO_ADDR
// while true do
22784: LD_INT 1
22786: IFFALSE 23283
// begin coord_dist := 3 ;
22788: LD_ADDR_VAR 0 3
22792: PUSH
22793: LD_INT 3
22795: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22796: LD_ADDR_VAR 0 5
22800: PUSH
22801: LD_VAR 0 1
22805: PPUSH
22806: CALL_OW 250
22810: PPUSH
22811: LD_VAR 0 4
22815: PPUSH
22816: LD_VAR 0 3
22820: PPUSH
22821: CALL_OW 272
22825: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22826: LD_ADDR_VAR 0 6
22830: PUSH
22831: LD_VAR 0 1
22835: PPUSH
22836: CALL_OW 251
22840: PPUSH
22841: LD_VAR 0 4
22845: PPUSH
22846: LD_VAR 0 3
22850: PPUSH
22851: CALL_OW 273
22855: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22856: LD_VAR 0 1
22860: PPUSH
22861: CALL_OW 255
22865: PPUSH
22866: LD_VAR 0 1
22870: PPUSH
22871: CALL_OW 250
22875: PPUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 251
22885: PPUSH
22886: LD_INT 14
22888: PPUSH
22889: CALL 22579 0 4
22893: PUSH
22894: LD_VAR 0 5
22898: PPUSH
22899: LD_VAR 0 6
22903: PPUSH
22904: CALL_OW 351
22908: OR
22909: PUSH
22910: LD_VAR 0 5
22914: PPUSH
22915: LD_VAR 0 6
22919: PPUSH
22920: CALL_OW 488
22924: PUSH
22925: LD_INT 0
22927: EQUAL
22928: OR
22929: PUSH
22930: LD_VAR 0 5
22934: PPUSH
22935: LD_VAR 0 6
22939: PPUSH
22940: CALL_OW 546
22944: PUSH
22945: LD_INT 1
22947: EQUAL
22948: OR
22949: PUSH
22950: LD_VAR 0 5
22954: PPUSH
22955: LD_VAR 0 6
22959: PPUSH
22960: CALL_OW 428
22964: PUSH
22965: LD_INT 0
22967: NONEQUAL
22968: OR
22969: IFFALSE 23197
// begin repeat begin Wait ( 0 0$0.3 ) ;
22971: LD_INT 10
22973: PPUSH
22974: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22978: LD_ADDR_VAR 0 3
22982: PUSH
22983: LD_VAR 0 3
22987: PUSH
22988: LD_INT 1
22990: PLUS
22991: ST_TO_ADDR
// dir := dir + 1 ;
22992: LD_ADDR_VAR 0 4
22996: PUSH
22997: LD_VAR 0 4
23001: PUSH
23002: LD_INT 1
23004: PLUS
23005: ST_TO_ADDR
// if dir > 5 then
23006: LD_VAR 0 4
23010: PUSH
23011: LD_INT 5
23013: GREATER
23014: IFFALSE 23024
// dir = 0 ;
23016: LD_ADDR_VAR 0 4
23020: PUSH
23021: LD_INT 0
23023: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23024: LD_ADDR_VAR 0 5
23028: PUSH
23029: LD_VAR 0 1
23033: PPUSH
23034: CALL_OW 250
23038: PPUSH
23039: LD_VAR 0 4
23043: PPUSH
23044: LD_VAR 0 3
23048: PPUSH
23049: CALL_OW 272
23053: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23054: LD_ADDR_VAR 0 6
23058: PUSH
23059: LD_VAR 0 1
23063: PPUSH
23064: CALL_OW 251
23068: PPUSH
23069: LD_VAR 0 4
23073: PPUSH
23074: LD_VAR 0 3
23078: PPUSH
23079: CALL_OW 273
23083: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23084: LD_VAR 0 1
23088: PPUSH
23089: CALL_OW 255
23093: PPUSH
23094: LD_VAR 0 1
23098: PPUSH
23099: CALL_OW 250
23103: PPUSH
23104: LD_VAR 0 1
23108: PPUSH
23109: CALL_OW 251
23113: PPUSH
23114: LD_INT 14
23116: PPUSH
23117: CALL 22579 0 4
23121: NOT
23122: PUSH
23123: LD_VAR 0 5
23127: PPUSH
23128: LD_VAR 0 6
23132: PPUSH
23133: CALL_OW 351
23137: NOT
23138: AND
23139: PUSH
23140: LD_VAR 0 5
23144: PPUSH
23145: LD_VAR 0 6
23149: PPUSH
23150: CALL_OW 488
23154: AND
23155: PUSH
23156: LD_VAR 0 5
23160: PPUSH
23161: LD_VAR 0 6
23165: PPUSH
23166: CALL_OW 546
23170: PUSH
23171: LD_INT 0
23173: EQUAL
23174: AND
23175: PUSH
23176: LD_VAR 0 5
23180: PPUSH
23181: LD_VAR 0 6
23185: PPUSH
23186: CALL_OW 428
23190: PUSH
23191: LD_INT 0
23193: EQUAL
23194: AND
23195: IFFALSE 22971
// end ; ComMoveXY ( un , x , y ) ;
23197: LD_VAR 0 1
23201: PPUSH
23202: LD_VAR 0 5
23206: PPUSH
23207: LD_VAR 0 6
23211: PPUSH
23212: CALL_OW 111
// Wait ( 0 0$1 ) ;
23216: LD_INT 35
23218: PPUSH
23219: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23223: LD_VAR 0 1
23227: PPUSH
23228: LD_INT 81
23230: PUSH
23231: LD_VAR 0 1
23235: PPUSH
23236: CALL_OW 255
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: PPUSH
23245: CALL_OW 69
23249: PPUSH
23250: LD_VAR 0 1
23254: PPUSH
23255: CALL_OW 74
23259: PPUSH
23260: CALL_OW 296
23264: PUSH
23265: LD_INT 14
23267: GREATEREQUAL
23268: IFFALSE 23281
// begin ComStop ( un ) ;
23270: LD_VAR 0 1
23274: PPUSH
23275: CALL_OW 141
// break ;
23279: GO 23283
// end ; end ;
23281: GO 22784
// end ;
23283: LD_VAR 0 2
23287: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23288: LD_INT 0
23290: PPUSH
23291: PPUSH
23292: PPUSH
23293: PPUSH
23294: PPUSH
23295: PPUSH
23296: PPUSH
23297: PPUSH
// x := GetX ( unit ) ;
23298: LD_ADDR_VAR 0 3
23302: PUSH
23303: LD_VAR 0 1
23307: PPUSH
23308: CALL_OW 250
23312: ST_TO_ADDR
// y := GetY ( unit ) ;
23313: LD_ADDR_VAR 0 4
23317: PUSH
23318: LD_VAR 0 1
23322: PPUSH
23323: CALL_OW 251
23327: ST_TO_ADDR
// i := 0 ;
23328: LD_ADDR_VAR 0 8
23332: PUSH
23333: LD_INT 0
23335: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23336: LD_VAR 0 1
23340: PPUSH
23341: LD_INT 81
23343: PUSH
23344: LD_VAR 0 1
23348: PPUSH
23349: CALL_OW 255
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PPUSH
23358: CALL_OW 69
23362: PPUSH
23363: LD_VAR 0 1
23367: PPUSH
23368: CALL_OW 74
23372: PPUSH
23373: CALL_OW 119
// dir := GetDir ( unit ) ;
23377: LD_ADDR_VAR 0 7
23381: PUSH
23382: LD_VAR 0 1
23386: PPUSH
23387: CALL_OW 254
23391: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23392: LD_ADDR_VAR 0 9
23396: PUSH
23397: LD_INT 0
23399: PPUSH
23400: LD_INT 1
23402: PPUSH
23403: CALL_OW 12
23407: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23408: LD_INT 10
23410: PPUSH
23411: CALL_OW 67
// if mode then
23415: LD_VAR 0 9
23419: IFFALSE 23437
// dir := dir + 1 else
23421: LD_ADDR_VAR 0 7
23425: PUSH
23426: LD_VAR 0 7
23430: PUSH
23431: LD_INT 1
23433: PLUS
23434: ST_TO_ADDR
23435: GO 23451
// dir := dir - 1 ;
23437: LD_ADDR_VAR 0 7
23441: PUSH
23442: LD_VAR 0 7
23446: PUSH
23447: LD_INT 1
23449: MINUS
23450: ST_TO_ADDR
// if ( dir < 0 ) then
23451: LD_VAR 0 7
23455: PUSH
23456: LD_INT 0
23458: LESS
23459: IFFALSE 23469
// dir := 5 ;
23461: LD_ADDR_VAR 0 7
23465: PUSH
23466: LD_INT 5
23468: ST_TO_ADDR
// if ( dir > 5 ) then
23469: LD_VAR 0 7
23473: PUSH
23474: LD_INT 5
23476: GREATER
23477: IFFALSE 23487
// dir := 0 ;
23479: LD_ADDR_VAR 0 7
23483: PUSH
23484: LD_INT 0
23486: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23487: LD_ADDR_VAR 0 5
23491: PUSH
23492: LD_VAR 0 3
23496: PPUSH
23497: LD_VAR 0 7
23501: PPUSH
23502: LD_INT 4
23504: PPUSH
23505: CALL_OW 272
23509: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23510: LD_ADDR_VAR 0 6
23514: PUSH
23515: LD_VAR 0 4
23519: PPUSH
23520: LD_VAR 0 7
23524: PPUSH
23525: LD_INT 4
23527: PPUSH
23528: CALL_OW 273
23532: ST_TO_ADDR
// i := i + 1 ;
23533: LD_ADDR_VAR 0 8
23537: PUSH
23538: LD_VAR 0 8
23542: PUSH
23543: LD_INT 1
23545: PLUS
23546: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23547: LD_VAR 0 1
23551: PPUSH
23552: CALL_OW 255
23556: PPUSH
23557: LD_VAR 0 5
23561: PPUSH
23562: LD_VAR 0 6
23566: PPUSH
23567: LD_INT 14
23569: PPUSH
23570: CALL 22579 0 4
23574: PUSH
23575: LD_INT 0
23577: EQUAL
23578: PUSH
23579: LD_VAR 0 5
23583: PPUSH
23584: LD_VAR 0 6
23588: PPUSH
23589: CALL_OW 546
23593: PUSH
23594: LD_INT 0
23596: EQUAL
23597: AND
23598: PUSH
23599: LD_VAR 0 5
23603: PPUSH
23604: LD_VAR 0 6
23608: PPUSH
23609: CALL_OW 428
23613: PUSH
23614: LD_INT 0
23616: EQUAL
23617: AND
23618: IFFALSE 23622
// break ;
23620: GO 23632
// end until i > 4 ;
23622: LD_VAR 0 8
23626: PUSH
23627: LD_INT 4
23629: GREATER
23630: IFFALSE 23408
// if x2 and y2 then
23632: LD_VAR 0 5
23636: PUSH
23637: LD_VAR 0 6
23641: AND
23642: IFFALSE 23665
// result := [ x2 , y2 ] else
23644: LD_ADDR_VAR 0 2
23648: PUSH
23649: LD_VAR 0 5
23653: PUSH
23654: LD_VAR 0 6
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: ST_TO_ADDR
23663: GO 23694
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23665: LD_ADDR_VAR 0 2
23669: PUSH
23670: LD_VAR 0 1
23674: PPUSH
23675: CALL_OW 250
23679: PUSH
23680: LD_VAR 0 1
23684: PPUSH
23685: CALL_OW 251
23689: PUSH
23690: EMPTY
23691: LIST
23692: LIST
23693: ST_TO_ADDR
// end ;
23694: LD_VAR 0 2
23698: RET
// export function MCT_Hex ( x , y ) ; begin
23699: LD_INT 0
23701: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23702: LD_ADDR_VAR 0 3
23706: PUSH
23707: LD_VAR 0 1
23711: PPUSH
23712: LD_VAR 0 2
23716: PPUSH
23717: CALL_OW 546
23721: PUSH
23722: LD_VAR 0 1
23726: PPUSH
23727: LD_VAR 0 2
23731: PPUSH
23732: CALL_OW 428
23736: PUSH
23737: EMPTY
23738: LIST
23739: PUSH
23740: EMPTY
23741: LIST
23742: LIST
23743: ST_TO_ADDR
// end ;
23744: LD_VAR 0 3
23748: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23749: LD_INT 0
23751: PPUSH
23752: PPUSH
23753: PPUSH
23754: PPUSH
23755: PPUSH
23756: PPUSH
23757: PPUSH
23758: PPUSH
23759: PPUSH
23760: PPUSH
23761: PPUSH
23762: PPUSH
23763: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23764: LD_ADDR_VAR 0 10
23768: PUSH
23769: LD_EXP 62
23773: PUSH
23774: LD_VAR 0 1
23778: ARRAY
23779: PUSH
23780: LD_INT 1
23782: ARRAY
23783: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23784: LD_ADDR_VAR 0 11
23788: PUSH
23789: LD_EXP 62
23793: PUSH
23794: LD_VAR 0 1
23798: ARRAY
23799: PUSH
23800: LD_INT 2
23802: ARRAY
23803: ST_TO_ADDR
// collectors := [ ] ;
23804: LD_ADDR_VAR 0 12
23808: PUSH
23809: EMPTY
23810: ST_TO_ADDR
// is_cargo := false ;
23811: LD_ADDR_VAR 0 13
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// if isTest then
23819: LD_EXP 1
23823: IFFALSE 23829
// TimerStart ( ) ;
23825: CALL_OW 548
// if MCF_Cargo ( side ) then
23829: LD_VAR 0 1
23833: PPUSH
23834: CALL 11760 0 1
23838: IFFALSE 23865
// begin collectors := MCF_Cargo ( side ) ;
23840: LD_ADDR_VAR 0 12
23844: PUSH
23845: LD_VAR 0 1
23849: PPUSH
23850: CALL 11760 0 1
23854: ST_TO_ADDR
// is_cargo := true ;
23855: LD_ADDR_VAR 0 13
23859: PUSH
23860: LD_INT 1
23862: ST_TO_ADDR
// end else
23863: GO 24014
// begin if MCF_ApeSpec ( side , engineer ) then
23865: LD_VAR 0 1
23869: PPUSH
23870: LD_STRING engineer
23872: PPUSH
23873: CALL 11906 0 2
23877: IFFALSE 23897
// collectors := MCF_ApeSpec ( side , engineer ) ;
23879: LD_ADDR_VAR 0 12
23883: PUSH
23884: LD_VAR 0 1
23888: PPUSH
23889: LD_STRING engineer
23891: PPUSH
23892: CALL 11906 0 2
23896: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23897: LD_VAR 0 1
23901: PPUSH
23902: LD_INT 2
23904: PPUSH
23905: EMPTY
23906: PPUSH
23907: CALL 11492 0 3
23911: IFFALSE 24014
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23913: LD_ADDR_VAR 0 7
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_INT 2
23925: PPUSH
23926: EMPTY
23927: PPUSH
23928: CALL 11492 0 3
23932: ST_TO_ADDR
// if z > 5 then
23933: LD_VAR 0 7
23937: PUSH
23938: LD_INT 5
23940: GREATER
23941: IFFALSE 23953
// t1 := 5 else
23943: LD_ADDR_VAR 0 8
23947: PUSH
23948: LD_INT 5
23950: ST_TO_ADDR
23951: GO 23963
// t1 := z ;
23953: LD_ADDR_VAR 0 8
23957: PUSH
23958: LD_VAR 0 7
23962: ST_TO_ADDR
// for t2 = 1 to t1 do
23963: LD_ADDR_VAR 0 9
23967: PUSH
23968: DOUBLE
23969: LD_INT 1
23971: DEC
23972: ST_TO_ADDR
23973: LD_VAR 0 8
23977: PUSH
23978: FOR_TO
23979: IFFALSE 24012
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23981: LD_ADDR_VAR 0 12
23985: PUSH
23986: LD_VAR 0 12
23990: PPUSH
23991: LD_INT 1
23993: PPUSH
23994: LD_VAR 0 7
23998: PUSH
23999: LD_VAR 0 9
24003: ARRAY
24004: PPUSH
24005: CALL_OW 2
24009: ST_TO_ADDR
24010: GO 23978
24012: POP
24013: POP
// end ; end ; if not mode then
24014: LD_VAR 0 10
24018: NOT
24019: IFFALSE 24025
// exit else
24021: GO 24284
24023: GO 24284
// begin if collectors then
24025: LD_VAR 0 12
24029: IFFALSE 24284
// for i in areas do
24031: LD_ADDR_VAR 0 3
24035: PUSH
24036: LD_VAR 0 11
24040: PUSH
24041: FOR_IN
24042: IFFALSE 24282
// if GetListOfCratesInArea ( i ) then
24044: LD_VAR 0 3
24048: PPUSH
24049: CALL_OW 435
24053: IFFALSE 24280
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24055: LD_ADDR_VAR 0 5
24059: PUSH
24060: LD_VAR 0 3
24064: PPUSH
24065: CALL_OW 435
24069: PUSH
24070: LD_INT 1
24072: ARRAY
24073: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24074: LD_ADDR_VAR 0 6
24078: PUSH
24079: LD_VAR 0 3
24083: PPUSH
24084: CALL_OW 435
24088: PUSH
24089: LD_INT 2
24091: ARRAY
24092: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24093: LD_VAR 0 13
24097: PUSH
24098: LD_VAR 0 12
24102: PUSH
24103: LD_INT 1
24105: ARRAY
24106: PPUSH
24107: CALL_OW 110
24111: PUSH
24112: LD_INT 0
24114: EQUAL
24115: AND
24116: IFFALSE 24178
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24118: LD_VAR 0 12
24122: PUSH
24123: LD_INT 1
24125: ARRAY
24126: PPUSH
24127: CALL_OW 314
24131: NOT
24132: PUSH
24133: LD_VAR 0 12
24137: PUSH
24138: LD_INT 1
24140: ARRAY
24141: PPUSH
24142: CALL_OW 110
24146: PUSH
24147: LD_INT 0
24149: EQUAL
24150: AND
24151: IFFALSE 24176
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24153: LD_VAR 0 12
24157: PUSH
24158: LD_INT 1
24160: ARRAY
24161: PPUSH
24162: LD_VAR 0 5
24166: PPUSH
24167: LD_VAR 0 6
24171: PPUSH
24172: CALL_OW 117
// end ; end else
24176: GO 24264
// begin for j = 1 to collectors do
24178: LD_ADDR_VAR 0 4
24182: PUSH
24183: DOUBLE
24184: LD_INT 1
24186: DEC
24187: ST_TO_ADDR
24188: LD_VAR 0 12
24192: PUSH
24193: FOR_TO
24194: IFFALSE 24262
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24196: LD_VAR 0 12
24200: PUSH
24201: LD_VAR 0 4
24205: ARRAY
24206: PPUSH
24207: CALL_OW 314
24211: NOT
24212: PUSH
24213: LD_VAR 0 12
24217: PUSH
24218: LD_VAR 0 4
24222: ARRAY
24223: PPUSH
24224: CALL_OW 110
24228: PUSH
24229: LD_INT 0
24231: EQUAL
24232: AND
24233: IFFALSE 24260
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24235: LD_VAR 0 12
24239: PUSH
24240: LD_VAR 0 4
24244: ARRAY
24245: PPUSH
24246: LD_VAR 0 5
24250: PPUSH
24251: LD_VAR 0 6
24255: PPUSH
24256: CALL 24655 0 3
// end ;
24260: GO 24193
24262: POP
24263: POP
// end ; if isTest then
24264: LD_EXP 1
24268: IFFALSE 24280
// begin debug_time := TimerEnd ( ) ;
24270: LD_ADDR_VAR 0 14
24274: PUSH
24275: CALL_OW 549
24279: ST_TO_ADDR
// end ; end ;
24280: GO 24041
24282: POP
24283: POP
// end ; end ;
24284: LD_VAR 0 2
24288: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24289: LD_INT 0
24291: PPUSH
24292: PPUSH
24293: PPUSH
24294: PPUSH
24295: PPUSH
24296: PPUSH
// if not area then
24297: LD_VAR 0 1
24301: NOT
24302: IFFALSE 24308
// exit else
24304: GO 24570
24306: GO 24570
// if tick mod interval = 0 and Prob ( percent ) then
24308: LD_OWVAR 1
24312: PUSH
24313: LD_VAR 0 4
24317: MOD
24318: PUSH
24319: LD_INT 0
24321: EQUAL
24322: PUSH
24323: LD_VAR 0 3
24327: PPUSH
24328: CALL_OW 13
24332: AND
24333: IFFALSE 24570
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24335: LD_VAR 0 1
24339: PPUSH
24340: CALL_OW 435
24344: PUSH
24345: LD_VAR 0 5
24349: LESS
24350: PUSH
24351: LD_VAR 0 5
24355: PUSH
24356: LD_INT 0
24358: EQUAL
24359: OR
24360: IFFALSE 24570
// begin Randomize ;
24362: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24366: LD_ADDR_VAR 0 7
24370: PUSH
24371: LD_INT 1
24373: PPUSH
24374: LD_VAR 0 2
24378: PPUSH
24379: CALL_OW 12
24383: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24384: LD_ADDR_VAR 0 9
24388: PUSH
24389: LD_VAR 0 1
24393: PPUSH
24394: LD_INT 0
24396: PPUSH
24397: CALL_OW 517
24401: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24402: LD_ADDR_VAR 0 8
24406: PUSH
24407: LD_INT 1
24409: PPUSH
24410: LD_VAR 0 9
24414: PUSH
24415: LD_INT 1
24417: ARRAY
24418: PPUSH
24419: CALL_OW 12
24423: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24424: LD_VAR 0 9
24428: PUSH
24429: LD_INT 1
24431: ARRAY
24432: PUSH
24433: LD_VAR 0 8
24437: ARRAY
24438: PPUSH
24439: LD_VAR 0 9
24443: PUSH
24444: LD_INT 2
24446: ARRAY
24447: PUSH
24448: LD_VAR 0 8
24452: ARRAY
24453: PPUSH
24454: CALL_OW 428
24458: PUSH
24459: LD_INT 0
24461: GREATER
24462: PUSH
24463: LD_VAR 0 9
24467: PUSH
24468: LD_INT 1
24470: ARRAY
24471: PUSH
24472: LD_VAR 0 8
24476: ARRAY
24477: PPUSH
24478: LD_VAR 0 9
24482: PUSH
24483: LD_INT 2
24485: ARRAY
24486: PUSH
24487: LD_VAR 0 8
24491: ARRAY
24492: PPUSH
24493: CALL_OW 284
24497: PUSH
24498: LD_INT 0
24500: GREATER
24501: AND
24502: IFFALSE 24528
// c := Rand ( 1 , tmp [ 1 ] ) ;
24504: LD_ADDR_VAR 0 8
24508: PUSH
24509: LD_INT 1
24511: PPUSH
24512: LD_VAR 0 9
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: PPUSH
24521: CALL_OW 12
24525: ST_TO_ADDR
24526: GO 24424
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24528: LD_VAR 0 7
24532: PPUSH
24533: LD_VAR 0 9
24537: PUSH
24538: LD_INT 1
24540: ARRAY
24541: PUSH
24542: LD_VAR 0 8
24546: ARRAY
24547: PPUSH
24548: LD_VAR 0 9
24552: PUSH
24553: LD_INT 2
24555: ARRAY
24556: PUSH
24557: LD_VAR 0 8
24561: ARRAY
24562: PPUSH
24563: LD_INT 1
24565: PPUSH
24566: CALL_OW 54
// end ; end ; end ;
24570: LD_VAR 0 6
24574: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24575: LD_INT 0
24577: PPUSH
24578: PPUSH
// if not MREG_Crates then
24579: LD_EXP 36
24583: NOT
24584: IFFALSE 24588
// exit ;
24586: GO 24650
// for i = MREG_Crates downto 1 do
24588: LD_ADDR_VAR 0 2
24592: PUSH
24593: DOUBLE
24594: LD_EXP 36
24598: INC
24599: ST_TO_ADDR
24600: LD_INT 1
24602: PUSH
24603: FOR_DOWNTO
24604: IFFALSE 24648
// if MREG_Crates [ i ] [ 3 ] = 0 then
24606: LD_EXP 36
24610: PUSH
24611: LD_VAR 0 2
24615: ARRAY
24616: PUSH
24617: LD_INT 3
24619: ARRAY
24620: PUSH
24621: LD_INT 0
24623: EQUAL
24624: IFFALSE 24646
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24626: LD_ADDR_EXP 36
24630: PUSH
24631: LD_EXP 36
24635: PPUSH
24636: LD_VAR 0 2
24640: PPUSH
24641: CALL_OW 3
24645: ST_TO_ADDR
24646: GO 24603
24648: POP
24649: POP
// end ;
24650: LD_VAR 0 1
24654: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24655: LD_INT 0
24657: PPUSH
24658: PPUSH
24659: PPUSH
24660: PPUSH
// if not unit then
24661: LD_VAR 0 1
24665: NOT
24666: IFFALSE 24670
// exit ;
24668: GO 24805
// if HasTask ( unit ) or not CanCarry ( unit ) then
24670: LD_VAR 0 1
24674: PPUSH
24675: CALL_OW 314
24679: PUSH
24680: LD_VAR 0 1
24684: PPUSH
24685: CALL_OW 280
24689: NOT
24690: OR
24691: IFFALSE 24695
// exit ;
24693: GO 24805
// side := GetSide ( unit ) ;
24695: LD_ADDR_VAR 0 6
24699: PUSH
24700: LD_VAR 0 1
24704: PPUSH
24705: CALL_OW 255
24709: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24710: LD_ADDR_VAR 0 7
24714: PUSH
24715: LD_VAR 0 6
24719: PPUSH
24720: LD_INT 30
24722: PUSH
24723: LD_INT 1
24725: PUSH
24726: EMPTY
24727: LIST
24728: LIST
24729: PPUSH
24730: CALL 11409 0 2
24734: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24735: LD_VAR 0 1
24739: PPUSH
24740: CALL_OW 281
24744: PUSH
24745: LD_VAR 0 7
24749: NOT
24750: OR
24751: IFFALSE 24757
// exit else
24753: GO 24805
24755: GO 24805
// if GetResourceAmountXY ( x , y ) then
24757: LD_VAR 0 2
24761: PPUSH
24762: LD_VAR 0 3
24766: PPUSH
24767: CALL_OW 284
24771: IFFALSE 24803
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24773: LD_VAR 0 1
24777: PPUSH
24778: LD_VAR 0 2
24782: PPUSH
24783: LD_VAR 0 3
24787: PPUSH
24788: LD_VAR 0 7
24792: PUSH
24793: LD_INT 1
24795: ARRAY
24796: PPUSH
24797: CALL 32007 0 4
// end else
24801: GO 24805
// exit ;
24803: GO 24805
// end ;
24805: LD_VAR 0 4
24809: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24810: LD_INT 0
24812: PPUSH
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
// result := 0 ;
24817: LD_ADDR_VAR 0 2
24821: PUSH
24822: LD_INT 0
24824: ST_TO_ADDR
// p := 1 ;
24825: LD_ADDR_VAR 0 4
24829: PUSH
24830: LD_INT 1
24832: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24833: LD_ADDR_VAR 0 3
24837: PUSH
24838: DOUBLE
24839: LD_INT 1
24841: DEC
24842: ST_TO_ADDR
24843: LD_EXP 65
24847: PUSH
24848: LD_VAR 0 1
24852: ARRAY
24853: PUSH
24854: LD_INT 1
24856: ARRAY
24857: PUSH
24858: LD_INT 2
24860: DIVREAL
24861: PUSH
24862: FOR_TO
24863: IFFALSE 24987
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24865: LD_ADDR_VAR 0 5
24869: PUSH
24870: LD_INT 81
24872: PUSH
24873: LD_VAR 0 1
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PUSH
24882: LD_INT 92
24884: PUSH
24885: LD_EXP 65
24889: PUSH
24890: LD_VAR 0 1
24894: ARRAY
24895: PUSH
24896: LD_INT 1
24898: ARRAY
24899: PUSH
24900: LD_VAR 0 4
24904: ARRAY
24905: PUSH
24906: LD_EXP 65
24910: PUSH
24911: LD_VAR 0 1
24915: ARRAY
24916: PUSH
24917: LD_INT 1
24919: ARRAY
24920: PUSH
24921: LD_VAR 0 4
24925: PUSH
24926: LD_INT 1
24928: PLUS
24929: ARRAY
24930: PUSH
24931: LD_INT 12
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: PPUSH
24944: CALL_OW 69
24948: ST_TO_ADDR
// if tmp then
24949: LD_VAR 0 5
24953: IFFALSE 24971
// result := result ^ tmp ;
24955: LD_ADDR_VAR 0 2
24959: PUSH
24960: LD_VAR 0 2
24964: PUSH
24965: LD_VAR 0 5
24969: ADD
24970: ST_TO_ADDR
// p := p + 2 ;
24971: LD_ADDR_VAR 0 4
24975: PUSH
24976: LD_VAR 0 4
24980: PUSH
24981: LD_INT 2
24983: PLUS
24984: ST_TO_ADDR
// end ;
24985: GO 24862
24987: POP
24988: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
24989: LD_EXP 66
24993: PUSH
24994: LD_VAR 0 1
24998: ARRAY
24999: PPUSH
25000: LD_INT 81
25002: PUSH
25003: LD_VAR 0 1
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: PPUSH
25012: CALL_OW 70
25016: IFFALSE 25057
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25018: LD_ADDR_VAR 0 2
25022: PUSH
25023: LD_VAR 0 2
25027: PUSH
25028: LD_EXP 66
25032: PUSH
25033: LD_VAR 0 1
25037: ARRAY
25038: PPUSH
25039: LD_INT 81
25041: PUSH
25042: LD_VAR 0 1
25046: PUSH
25047: EMPTY
25048: LIST
25049: LIST
25050: PPUSH
25051: CALL_OW 70
25055: ADD
25056: ST_TO_ADDR
// end ; end_of_file
25057: LD_VAR 0 2
25061: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25062: LD_INT 0
25064: PPUSH
25065: PPUSH
25066: PPUSH
// pom := GetBase ( fac ) ;
25067: LD_ADDR_VAR 0 5
25071: PUSH
25072: LD_VAR 0 1
25076: PPUSH
25077: CALL_OW 274
25081: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25082: LD_ADDR_VAR 0 4
25086: PUSH
25087: LD_VAR 0 2
25091: PUSH
25092: LD_INT 1
25094: ARRAY
25095: PPUSH
25096: LD_VAR 0 2
25100: PUSH
25101: LD_INT 2
25103: ARRAY
25104: PPUSH
25105: LD_VAR 0 2
25109: PUSH
25110: LD_INT 3
25112: ARRAY
25113: PPUSH
25114: LD_VAR 0 2
25118: PUSH
25119: LD_INT 4
25121: ARRAY
25122: PPUSH
25123: CALL_OW 449
25127: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25128: LD_VAR 0 5
25132: PPUSH
25133: LD_INT 1
25135: PPUSH
25136: CALL_OW 275
25140: PUSH
25141: LD_VAR 0 4
25145: PUSH
25146: LD_INT 1
25148: ARRAY
25149: GREATEREQUAL
25150: PUSH
25151: LD_VAR 0 5
25155: PPUSH
25156: LD_INT 2
25158: PPUSH
25159: CALL_OW 275
25163: PUSH
25164: LD_VAR 0 4
25168: PUSH
25169: LD_INT 2
25171: ARRAY
25172: GREATEREQUAL
25173: AND
25174: PUSH
25175: LD_VAR 0 5
25179: PPUSH
25180: LD_INT 3
25182: PPUSH
25183: CALL_OW 275
25187: PUSH
25188: LD_VAR 0 4
25192: PUSH
25193: LD_INT 3
25195: ARRAY
25196: GREATEREQUAL
25197: AND
25198: IFFALSE 25210
// result := true else
25200: LD_ADDR_VAR 0 3
25204: PUSH
25205: LD_INT 1
25207: ST_TO_ADDR
25208: GO 25218
// result := false ;
25210: LD_ADDR_VAR 0 3
25214: PUSH
25215: LD_INT 0
25217: ST_TO_ADDR
// end ;
25218: LD_VAR 0 3
25222: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25223: LD_INT 0
25225: PPUSH
25226: PPUSH
25227: PPUSH
// result := false ;
25228: LD_ADDR_VAR 0 3
25232: PUSH
25233: LD_INT 0
25235: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25236: LD_ADDR_VAR 0 4
25240: PUSH
25241: LD_EXP 53
25245: PUSH
25246: LD_VAR 0 1
25250: ARRAY
25251: ST_TO_ADDR
// if tmp then
25252: LD_VAR 0 4
25256: IFFALSE 25308
// for i = 1 to tmp do
25258: LD_ADDR_VAR 0 5
25262: PUSH
25263: DOUBLE
25264: LD_INT 1
25266: DEC
25267: ST_TO_ADDR
25268: LD_VAR 0 4
25272: PUSH
25273: FOR_TO
25274: IFFALSE 25306
// if component = tmp [ i ] then
25276: LD_VAR 0 2
25280: PUSH
25281: LD_VAR 0 4
25285: PUSH
25286: LD_VAR 0 5
25290: ARRAY
25291: EQUAL
25292: IFFALSE 25304
// begin result := true ;
25294: LD_ADDR_VAR 0 3
25298: PUSH
25299: LD_INT 1
25301: ST_TO_ADDR
// break ;
25302: GO 25306
// end ;
25304: GO 25273
25306: POP
25307: POP
// end ;
25308: LD_VAR 0 3
25312: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25313: LD_INT 0
25315: PPUSH
25316: PPUSH
25317: PPUSH
// if fac then
25318: LD_VAR 0 2
25322: IFFALSE 25557
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25324: LD_VAR 0 2
25328: PPUSH
25329: LD_VAR 0 3
25333: PPUSH
25334: CALL 25062 0 2
25338: PUSH
25339: LD_VAR 0 2
25343: PPUSH
25344: CALL_OW 461
25348: PUSH
25349: LD_INT 2
25351: EQUAL
25352: AND
25353: PUSH
25354: LD_VAR 0 2
25358: PPUSH
25359: LD_VAR 0 3
25363: PUSH
25364: LD_INT 1
25366: ARRAY
25367: PPUSH
25368: LD_VAR 0 3
25372: PUSH
25373: LD_INT 2
25375: ARRAY
25376: PPUSH
25377: LD_VAR 0 3
25381: PUSH
25382: LD_INT 3
25384: ARRAY
25385: PPUSH
25386: LD_VAR 0 3
25390: PUSH
25391: LD_INT 4
25393: ARRAY
25394: PPUSH
25395: CALL_OW 448
25399: AND
25400: IFFALSE 25547
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25402: LD_VAR 0 2
25406: PPUSH
25407: LD_VAR 0 3
25411: PUSH
25412: LD_INT 1
25414: ARRAY
25415: PPUSH
25416: LD_VAR 0 3
25420: PUSH
25421: LD_INT 2
25423: ARRAY
25424: PPUSH
25425: LD_VAR 0 3
25429: PUSH
25430: LD_INT 3
25432: ARRAY
25433: PPUSH
25434: LD_VAR 0 3
25438: PUSH
25439: LD_INT 4
25441: ARRAY
25442: PPUSH
25443: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25447: LD_ADDR_VAR 0 6
25451: PUSH
25452: LD_EXP 53
25456: PUSH
25457: LD_VAR 0 1
25461: ARRAY
25462: ST_TO_ADDR
// for i = 4 downto 1 do
25463: LD_ADDR_VAR 0 5
25467: PUSH
25468: DOUBLE
25469: LD_INT 4
25471: INC
25472: ST_TO_ADDR
25473: LD_INT 1
25475: PUSH
25476: FOR_DOWNTO
25477: IFFALSE 25510
// tab := Remove ( tab , list [ i ] , true ) ;
25479: LD_ADDR_VAR 0 6
25483: PUSH
25484: LD_VAR 0 6
25488: PPUSH
25489: LD_VAR 0 3
25493: PUSH
25494: LD_VAR 0 5
25498: ARRAY
25499: PPUSH
25500: LD_INT 1
25502: PPUSH
25503: CALL 31002 0 3
25507: ST_TO_ADDR
25508: GO 25476
25510: POP
25511: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25512: LD_ADDR_EXP 53
25516: PUSH
25517: LD_EXP 53
25521: PPUSH
25522: LD_VAR 0 1
25526: PPUSH
25527: LD_VAR 0 6
25531: PPUSH
25532: CALL_OW 1
25536: ST_TO_ADDR
// result := true ;
25537: LD_ADDR_VAR 0 4
25541: PUSH
25542: LD_INT 1
25544: ST_TO_ADDR
// end else
25545: GO 25555
// result := false ;
25547: LD_ADDR_VAR 0 4
25551: PUSH
25552: LD_INT 0
25554: ST_TO_ADDR
// end else
25555: GO 25565
// result := false ;
25557: LD_ADDR_VAR 0 4
25561: PUSH
25562: LD_INT 0
25564: ST_TO_ADDR
// end ;
25565: LD_VAR 0 4
25569: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25570: LD_INT 0
25572: PPUSH
25573: PPUSH
// if not veh then
25574: LD_VAR 0 2
25578: NOT
25579: IFFALSE 25583
// exit ;
25581: GO 25757
// if MREG_Parking [ side ] then
25583: LD_EXP 60
25587: PUSH
25588: LD_VAR 0 1
25592: ARRAY
25593: IFFALSE 25757
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25595: LD_VAR 0 2
25599: PPUSH
25600: LD_EXP 60
25604: PUSH
25605: LD_VAR 0 1
25609: ARRAY
25610: PPUSH
25611: CALL_OW 308
25615: NOT
25616: IFFALSE 25757
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25618: LD_VAR 0 2
25622: PPUSH
25623: LD_EXP 60
25627: PUSH
25628: LD_VAR 0 1
25632: ARRAY
25633: PPUSH
25634: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25638: LD_VAR 0 2
25642: PPUSH
25643: CALL_OW 263
25647: PUSH
25648: LD_INT 1
25650: EQUAL
25651: IFFALSE 25757
// begin i := GetDriver ( veh ) ;
25653: LD_ADDR_VAR 0 4
25657: PUSH
25658: LD_VAR 0 2
25662: PPUSH
25663: CALL 31537 0 1
25667: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25668: LD_INT 35
25670: PPUSH
25671: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25675: LD_VAR 0 2
25679: PPUSH
25680: LD_EXP 60
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: CALL_OW 308
25695: PUSH
25696: LD_VAR 0 2
25700: PPUSH
25701: CALL_OW 301
25705: OR
25706: IFFALSE 25668
// ComExitVehicle ( i ) ;
25708: LD_VAR 0 4
25712: PPUSH
25713: CALL_OW 121
// Wait ( 1 ) ;
25717: LD_INT 1
25719: PPUSH
25720: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25724: LD_VAR 0 4
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_INT 30
25736: PUSH
25737: LD_INT 3
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PPUSH
25744: CALL 11409 0 2
25748: PUSH
25749: LD_INT 1
25751: ARRAY
25752: PPUSH
25753: CALL_OW 180
// end ; end ; end ;
25757: LD_VAR 0 3
25761: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25762: LD_INT 0
25764: PPUSH
25765: PPUSH
25766: PPUSH
25767: PPUSH
25768: PPUSH
25769: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25770: LD_VAR 0 1
25774: PPUSH
25775: LD_INT 30
25777: PUSH
25778: LD_INT 3
25780: PUSH
25781: EMPTY
25782: LIST
25783: LIST
25784: PPUSH
25785: CALL 11409 0 2
25789: IFFALSE 25973
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25791: LD_VAR 0 1
25795: PPUSH
25796: LD_INT 30
25798: PUSH
25799: LD_INT 3
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PPUSH
25806: CALL 11409 0 2
25810: PUSH
25811: LD_INT 1
25813: ARRAY
25814: PPUSH
25815: CALL_OW 461
25819: PUSH
25820: LD_INT 2
25822: EQUAL
25823: IFFALSE 25973
// begin for i = 1 to MREG_TurretWeapon do
25825: LD_ADDR_VAR 0 3
25829: PUSH
25830: DOUBLE
25831: LD_INT 1
25833: DEC
25834: ST_TO_ADDR
25835: LD_EXP 45
25839: PUSH
25840: FOR_TO
25841: IFFALSE 25971
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25843: LD_EXP 45
25847: PUSH
25848: LD_VAR 0 3
25852: ARRAY
25853: PUSH
25854: LD_INT 1
25856: ARRAY
25857: PUSH
25858: LD_VAR 0 1
25862: EQUAL
25863: IFFALSE 25969
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25865: LD_ADDR_VAR 0 5
25869: PUSH
25870: LD_EXP 45
25874: PUSH
25875: LD_VAR 0 3
25879: ARRAY
25880: PUSH
25881: LD_INT 2
25883: ARRAY
25884: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25885: LD_ADDR_VAR 0 6
25889: PUSH
25890: LD_EXP 45
25894: PUSH
25895: LD_VAR 0 3
25899: ARRAY
25900: PUSH
25901: LD_INT 3
25903: ARRAY
25904: PUSH
25905: LD_INT 1
25907: ARRAY
25908: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25909: LD_ADDR_VAR 0 7
25913: PUSH
25914: LD_EXP 45
25918: PUSH
25919: LD_VAR 0 3
25923: ARRAY
25924: PUSH
25925: LD_INT 3
25927: ARRAY
25928: PUSH
25929: LD_INT 2
25931: ARRAY
25932: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25933: LD_ADDR_VAR 0 4
25937: PUSH
25938: LD_VAR 0 6
25942: PPUSH
25943: LD_VAR 0 7
25947: PPUSH
25948: CALL_OW 428
25952: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25953: LD_VAR 0 4
25957: PPUSH
25958: LD_VAR 0 5
25962: PPUSH
25963: CALL_OW 148
// break ;
25967: GO 25971
// end ;
25969: GO 25840
25971: POP
25972: POP
// end ; end ;
25973: LD_VAR 0 2
25977: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25978: LD_INT 0
25980: PPUSH
25981: PPUSH
25982: PPUSH
25983: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25984: LD_ADDR_VAR 0 4
25988: PUSH
25989: LD_VAR 0 1
25993: PPUSH
25994: LD_INT 32
25996: PUSH
25997: LD_INT 1
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PPUSH
26004: CALL 11409 0 2
26008: ST_TO_ADDR
// if not tmp then
26009: LD_VAR 0 4
26013: NOT
26014: IFFALSE 26020
// exit else
26016: GO 26102
26018: GO 26102
// begin for i = 1 to tmp do
26020: LD_ADDR_VAR 0 3
26024: PUSH
26025: DOUBLE
26026: LD_INT 1
26028: DEC
26029: ST_TO_ADDR
26030: LD_VAR 0 4
26034: PUSH
26035: FOR_TO
26036: IFFALSE 26100
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26038: LD_VAR 0 4
26042: PUSH
26043: LD_VAR 0 3
26047: ARRAY
26048: PPUSH
26049: CALL_OW 261
26053: PUSH
26054: LD_INT 20
26056: LESS
26057: PUSH
26058: LD_VAR 0 4
26062: PUSH
26063: LD_VAR 0 3
26067: ARRAY
26068: PPUSH
26069: CALL_OW 110
26073: PUSH
26074: LD_INT 0
26076: EQUAL
26077: AND
26078: IFFALSE 26098
// begin SetTag ( tmp [ i ] , 21 ) ;
26080: LD_VAR 0 4
26084: PUSH
26085: LD_VAR 0 3
26089: ARRAY
26090: PPUSH
26091: LD_INT 21
26093: PPUSH
26094: CALL_OW 109
// end ;
26098: GO 26035
26100: POP
26101: POP
// end ; end ;
26102: LD_VAR 0 2
26106: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26107: LD_INT 0
26109: PPUSH
26110: PPUSH
26111: PPUSH
26112: PPUSH
26113: PPUSH
// if not unit then
26114: LD_VAR 0 1
26118: NOT
26119: IFFALSE 26123
// exit ;
26121: GO 26311
// side := GetSide ( unit ) ;
26123: LD_ADDR_VAR 0 3
26127: PUSH
26128: LD_VAR 0 1
26132: PPUSH
26133: CALL_OW 255
26137: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26138: LD_ADDR_VAR 0 5
26142: PUSH
26143: LD_VAR 0 3
26147: PPUSH
26148: LD_INT 2
26150: PUSH
26151: LD_INT 30
26153: PUSH
26154: LD_INT 1
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: PUSH
26161: LD_INT 30
26163: PUSH
26164: LD_INT 3
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 30
26173: PUSH
26174: LD_INT 29
26176: PUSH
26177: EMPTY
26178: LIST
26179: LIST
26180: PUSH
26181: EMPTY
26182: LIST
26183: LIST
26184: LIST
26185: LIST
26186: PPUSH
26187: CALL 11409 0 2
26191: ST_TO_ADDR
// if not b then
26192: LD_VAR 0 5
26196: NOT
26197: IFFALSE 26201
// exit ;
26199: GO 26311
// if GetTag ( unit ) = 21 then
26201: LD_VAR 0 1
26205: PPUSH
26206: CALL_OW 110
26210: PUSH
26211: LD_INT 21
26213: EQUAL
26214: IFFALSE 26311
// begin c := NearestUnitToUnit ( b , unit ) ;
26216: LD_ADDR_VAR 0 6
26220: PUSH
26221: LD_VAR 0 5
26225: PPUSH
26226: LD_VAR 0 1
26230: PPUSH
26231: CALL_OW 74
26235: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26236: LD_VAR 0 1
26240: PPUSH
26241: LD_VAR 0 6
26245: PPUSH
26246: CALL_OW 250
26250: PPUSH
26251: LD_VAR 0 6
26255: PPUSH
26256: CALL_OW 251
26260: PPUSH
26261: CALL_OW 297
26265: PUSH
26266: LD_INT 6
26268: GREATER
26269: IFFALSE 26287
// ComMoveUnit ( unit , c ) else
26271: LD_VAR 0 1
26275: PPUSH
26276: LD_VAR 0 6
26280: PPUSH
26281: CALL_OW 112
26285: GO 26311
// begin SetFuel ( unit , 100 ) ;
26287: LD_VAR 0 1
26291: PPUSH
26292: LD_INT 100
26294: PPUSH
26295: CALL_OW 240
// SetTag ( unit , 0 ) ;
26299: LD_VAR 0 1
26303: PPUSH
26304: LD_INT 0
26306: PPUSH
26307: CALL_OW 109
// end ; end ; end ;
26311: LD_VAR 0 2
26315: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26316: LD_INT 0
26318: PPUSH
26319: PPUSH
26320: PPUSH
26321: PPUSH
26322: PPUSH
26323: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26324: LD_ADDR_VAR 0 7
26328: PUSH
26329: LD_VAR 0 1
26333: PPUSH
26334: LD_INT 33
26336: PUSH
26337: LD_INT 2
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 3
26346: PUSH
26347: LD_INT 61
26349: PUSH
26350: EMPTY
26351: LIST
26352: PUSH
26353: EMPTY
26354: LIST
26355: LIST
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PPUSH
26361: CALL 11409 0 2
26365: ST_TO_ADDR
// if not vehs then
26366: LD_VAR 0 7
26370: NOT
26371: IFFALSE 26375
// exit ;
26373: GO 26660
// if nation = 1 then
26375: LD_VAR 0 2
26379: PUSH
26380: LD_INT 1
26382: EQUAL
26383: IFFALSE 26553
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26385: LD_VAR 0 1
26389: PPUSH
26390: LD_INT 30
26392: PUSH
26393: LD_INT 36
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PPUSH
26400: CALL 11409 0 2
26404: NOT
26405: IFFALSE 26411
// exit else
26407: GO 26660
26409: GO 26551
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26411: LD_ADDR_VAR 0 5
26415: PUSH
26416: LD_VAR 0 1
26420: PPUSH
26421: LD_INT 30
26423: PUSH
26424: LD_INT 36
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PPUSH
26431: CALL 11409 0 2
26435: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26436: LD_ADDR_VAR 0 6
26440: PUSH
26441: LD_VAR 0 5
26445: PUSH
26446: LD_INT 1
26448: ARRAY
26449: PPUSH
26450: CALL_OW 313
26454: ST_TO_ADDR
// for i = vehs downto 1 do
26455: LD_ADDR_VAR 0 4
26459: PUSH
26460: DOUBLE
26461: LD_VAR 0 7
26465: INC
26466: ST_TO_ADDR
26467: LD_INT 1
26469: PUSH
26470: FOR_DOWNTO
26471: IFFALSE 26549
// begin if not IsControledBy ( vehs [ i ] ) then
26473: LD_VAR 0 7
26477: PUSH
26478: LD_VAR 0 4
26482: ARRAY
26483: PPUSH
26484: CALL_OW 312
26488: NOT
26489: IFFALSE 26547
// begin tmp := MCV_RemoteDriver ( oper ) ;
26491: LD_ADDR_VAR 0 8
26495: PUSH
26496: LD_VAR 0 6
26500: PPUSH
26501: CALL 26665 0 1
26505: ST_TO_ADDR
// if not tmp then
26506: LD_VAR 0 8
26510: NOT
26511: IFFALSE 26519
// exit else
26513: POP
26514: POP
26515: GO 26660
26517: GO 26547
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26519: LD_VAR 0 7
26523: PUSH
26524: LD_VAR 0 4
26528: ARRAY
26529: PPUSH
26530: LD_VAR 0 8
26534: PUSH
26535: LD_INT 1
26537: ARRAY
26538: PUSH
26539: LD_INT 1
26541: ARRAY
26542: PPUSH
26543: CALL_OW 135
// end ; end ;
26547: GO 26470
26549: POP
26550: POP
// end ; end else
26551: GO 26660
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26553: LD_VAR 0 1
26557: PPUSH
26558: LD_INT 34
26560: PUSH
26561: LD_INT 31
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PPUSH
26568: CALL 11409 0 2
26572: NOT
26573: IFFALSE 26579
// exit else
26575: GO 26660
26577: GO 26660
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26579: LD_ADDR_VAR 0 5
26583: PUSH
26584: LD_VAR 0 1
26588: PPUSH
26589: LD_INT 34
26591: PUSH
26592: LD_INT 31
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: PPUSH
26599: CALL 11409 0 2
26603: ST_TO_ADDR
// oper := [ ] ;
26604: LD_ADDR_VAR 0 6
26608: PUSH
26609: EMPTY
26610: ST_TO_ADDR
// for i = 1 to ct do
26611: LD_ADDR_VAR 0 4
26615: PUSH
26616: DOUBLE
26617: LD_INT 1
26619: DEC
26620: ST_TO_ADDR
26621: LD_VAR 0 5
26625: PUSH
26626: FOR_TO
26627: IFFALSE 26658
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26629: LD_ADDR_VAR 0 6
26633: PUSH
26634: LD_VAR 0 6
26638: PUSH
26639: LD_VAR 0 5
26643: PUSH
26644: LD_VAR 0 4
26648: ARRAY
26649: PPUSH
26650: CALL 31537 0 1
26654: ADD
26655: ST_TO_ADDR
26656: GO 26626
26658: POP
26659: POP
// end ; end ; end ;
26660: LD_VAR 0 3
26664: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26665: LD_INT 0
26667: PPUSH
26668: PPUSH
26669: PPUSH
26670: PPUSH
26671: PPUSH
26672: PPUSH
// if not drivers then
26673: LD_VAR 0 1
26677: NOT
26678: IFFALSE 26684
// exit else
26680: GO 26964
26682: GO 26964
// begin linked := [ ] ;
26684: LD_ADDR_VAR 0 5
26688: PUSH
26689: EMPTY
26690: ST_TO_ADDR
// for i = 1 to drivers do
26691: LD_ADDR_VAR 0 3
26695: PUSH
26696: DOUBLE
26697: LD_INT 1
26699: DEC
26700: ST_TO_ADDR
26701: LD_VAR 0 1
26705: PUSH
26706: FOR_TO
26707: IFFALSE 26952
// begin if CanControl ( drivers [ i ] ) then
26709: LD_VAR 0 1
26713: PUSH
26714: LD_VAR 0 3
26718: ARRAY
26719: PPUSH
26720: CALL 32109 0 1
26724: IFFALSE 26950
// if i > 1 then
26726: LD_VAR 0 3
26730: PUSH
26731: LD_INT 1
26733: GREATER
26734: IFFALSE 26911
// begin m := false ;
26736: LD_ADDR_VAR 0 6
26740: PUSH
26741: LD_INT 0
26743: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26744: LD_ADDR_VAR 0 7
26748: PUSH
26749: LD_VAR 0 1
26753: PUSH
26754: LD_VAR 0 3
26758: ARRAY
26759: PPUSH
26760: CALL_OW 432
26764: ST_TO_ADDR
// for j = 1 to linked do
26765: LD_ADDR_VAR 0 4
26769: PUSH
26770: DOUBLE
26771: LD_INT 1
26773: DEC
26774: ST_TO_ADDR
26775: LD_VAR 0 5
26779: PUSH
26780: FOR_TO
26781: IFFALSE 26855
// begin if l < linked [ j ] [ 2 ] then
26783: LD_VAR 0 7
26787: PUSH
26788: LD_VAR 0 5
26792: PUSH
26793: LD_VAR 0 4
26797: ARRAY
26798: PUSH
26799: LD_INT 2
26801: ARRAY
26802: LESS
26803: IFFALSE 26853
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26805: LD_ADDR_VAR 0 5
26809: PUSH
26810: LD_VAR 0 5
26814: PPUSH
26815: LD_INT 1
26817: PPUSH
26818: LD_VAR 0 1
26822: PUSH
26823: LD_VAR 0 3
26827: ARRAY
26828: PUSH
26829: LD_VAR 0 7
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PPUSH
26838: CALL_OW 2
26842: ST_TO_ADDR
// m := true ;
26843: LD_ADDR_VAR 0 6
26847: PUSH
26848: LD_INT 1
26850: ST_TO_ADDR
// break ;
26851: GO 26855
// end ; end ;
26853: GO 26780
26855: POP
26856: POP
// if not m then
26857: LD_VAR 0 6
26861: NOT
26862: IFFALSE 26909
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26864: LD_ADDR_VAR 0 5
26868: PUSH
26869: LD_VAR 0 5
26873: PUSH
26874: LD_VAR 0 1
26878: PUSH
26879: LD_VAR 0 3
26883: ARRAY
26884: PUSH
26885: LD_VAR 0 1
26889: PUSH
26890: LD_VAR 0 3
26894: ARRAY
26895: PPUSH
26896: CALL_OW 432
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: EMPTY
26906: LIST
26907: ADD
26908: ST_TO_ADDR
// end else
26909: GO 26950
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26911: LD_ADDR_VAR 0 5
26915: PUSH
26916: LD_VAR 0 1
26920: PUSH
26921: LD_VAR 0 3
26925: ARRAY
26926: PUSH
26927: LD_VAR 0 1
26931: PUSH
26932: LD_VAR 0 3
26936: ARRAY
26937: PPUSH
26938: CALL_OW 432
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: PUSH
26947: EMPTY
26948: LIST
26949: ST_TO_ADDR
// end ;
26950: GO 26706
26952: POP
26953: POP
// result := linked ;
26954: LD_ADDR_VAR 0 2
26958: PUSH
26959: LD_VAR 0 5
26963: ST_TO_ADDR
// end ; end ;
26964: LD_VAR 0 2
26968: RET
// export function MCV_ToRepair ( unit ) ; begin
26969: LD_INT 0
26971: PPUSH
// if not unit then
26972: LD_VAR 0 1
26976: NOT
26977: IFFALSE 26983
// exit else
26979: GO 27014
26981: GO 27014
// begin SetTag ( unit , 6 ) ;
26983: LD_VAR 0 1
26987: PPUSH
26988: LD_INT 6
26990: PPUSH
26991: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
26995: LD_VAR 0 1
26999: PPUSH
27000: CALL_OW 255
27004: PPUSH
27005: LD_VAR 0 1
27009: PPUSH
27010: CALL 25570 0 2
// end ; end ;
27014: LD_VAR 0 2
27018: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27019: LD_INT 0
27021: PPUSH
27022: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27023: LD_VAR 0 1
27027: PPUSH
27028: LD_INT 6
27030: PPUSH
27031: EMPTY
27032: PPUSH
27033: CALL 12112 0 3
27037: IFFALSE 27130
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27039: LD_ADDR_VAR 0 3
27043: PUSH
27044: DOUBLE
27045: LD_VAR 0 1
27049: PPUSH
27050: LD_INT 6
27052: PPUSH
27053: EMPTY
27054: PPUSH
27055: CALL 12112 0 3
27059: INC
27060: ST_TO_ADDR
27061: LD_INT 1
27063: PUSH
27064: FOR_DOWNTO
27065: IFFALSE 27128
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27067: LD_VAR 0 1
27071: PPUSH
27072: LD_INT 6
27074: PPUSH
27075: EMPTY
27076: PPUSH
27077: CALL 12112 0 3
27081: PUSH
27082: LD_VAR 0 3
27086: ARRAY
27087: PPUSH
27088: CALL_OW 256
27092: PUSH
27093: LD_INT 1000
27095: EQUAL
27096: IFFALSE 27126
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27098: LD_VAR 0 1
27102: PPUSH
27103: LD_INT 6
27105: PPUSH
27106: EMPTY
27107: PPUSH
27108: CALL 12112 0 3
27112: PUSH
27113: LD_VAR 0 3
27117: ARRAY
27118: PPUSH
27119: LD_INT 0
27121: PPUSH
27122: CALL_OW 109
27126: GO 27064
27128: POP
27129: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27130: LD_VAR 0 1
27134: PPUSH
27135: LD_INT 10
27137: PPUSH
27138: EMPTY
27139: PPUSH
27140: CALL 12112 0 3
27144: IFFALSE 27261
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27146: LD_ADDR_VAR 0 3
27150: PUSH
27151: DOUBLE
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 10
27159: PPUSH
27160: EMPTY
27161: PPUSH
27162: CALL 12112 0 3
27166: INC
27167: ST_TO_ADDR
27168: LD_INT 1
27170: PUSH
27171: FOR_DOWNTO
27172: IFFALSE 27259
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27174: LD_VAR 0 1
27178: PPUSH
27179: LD_INT 10
27181: PPUSH
27182: EMPTY
27183: PPUSH
27184: CALL 12112 0 3
27188: PUSH
27189: LD_VAR 0 3
27193: ARRAY
27194: PPUSH
27195: CALL_OW 302
27199: NOT
27200: PUSH
27201: LD_VAR 0 1
27205: PPUSH
27206: LD_INT 10
27208: PPUSH
27209: EMPTY
27210: PPUSH
27211: CALL 12112 0 3
27215: PUSH
27216: LD_VAR 0 3
27220: ARRAY
27221: PPUSH
27222: CALL_OW 301
27226: OR
27227: IFFALSE 27257
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27229: LD_VAR 0 1
27233: PPUSH
27234: LD_INT 10
27236: PPUSH
27237: EMPTY
27238: PPUSH
27239: CALL 12112 0 3
27243: PUSH
27244: LD_VAR 0 3
27248: ARRAY
27249: PPUSH
27250: LD_INT 0
27252: PPUSH
27253: CALL_OW 109
27257: GO 27171
27259: POP
27260: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27261: LD_ADDR_VAR 0 3
27265: PUSH
27266: LD_VAR 0 1
27270: PPUSH
27271: EMPTY
27272: PPUSH
27273: CALL 11710 0 2
27277: PUSH
27278: LD_VAR 0 1
27282: PPUSH
27283: LD_INT 7
27285: PPUSH
27286: EMPTY
27287: PPUSH
27288: CALL 12112 0 3
27292: DIFF
27293: PUSH
27294: FOR_IN
27295: IFFALSE 27339
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27297: LD_VAR 0 3
27301: PPUSH
27302: CALL_OW 256
27306: PUSH
27307: LD_INT 650
27309: LESS
27310: PUSH
27311: LD_VAR 0 3
27315: PPUSH
27316: CALL_OW 110
27320: PUSH
27321: LD_INT 6
27323: EQUAL
27324: NOT
27325: AND
27326: IFFALSE 27337
// MCV_ToRepair ( i ) ;
27328: LD_VAR 0 3
27332: PPUSH
27333: CALL 26969 0 1
27337: GO 27294
27339: POP
27340: POP
// end ; end_of_file end_of_file
27341: LD_VAR 0 2
27345: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27346: LD_STRING SAILEvent [
27348: PUSH
27349: LD_VAR 0 1
27353: STR
27354: PUSH
27355: LD_STRING ]
27357: STR
27358: PPUSH
27359: CALL 7806 0 1
// if event = 101 and dialog_north then
27363: LD_VAR 0 1
27367: PUSH
27368: LD_INT 101
27370: EQUAL
27371: PUSH
27372: LD_EXP 7
27376: AND
27377: IFFALSE 27441
// begin dialog_north := false ;
27379: LD_ADDR_EXP 7
27383: PUSH
27384: LD_INT 0
27386: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27387: LD_EXP 4
27391: PPUSH
27392: LD_STRING DS1
27394: PUSH
27395: LD_STRING DS2
27397: PUSH
27398: LD_STRING DS3
27400: PUSH
27401: LD_STRING DS6
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 1
27412: PPUSH
27413: LD_INT 4
27415: PPUSH
27416: CALL_OW 12
27420: ARRAY
27421: PPUSH
27422: CALL_OW 94
// Wait ( 4 4$00 ) ;
27426: LD_INT 8400
27428: PPUSH
27429: CALL_OW 67
// dialog_north := true ;
27433: LD_ADDR_EXP 7
27437: PUSH
27438: LD_INT 1
27440: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27441: LD_VAR 0 1
27445: PUSH
27446: LD_INT 102
27448: EQUAL
27449: PUSH
27450: LD_EXP 8
27454: AND
27455: IFFALSE 27515
// begin dialog_south := false ;
27457: LD_ADDR_EXP 8
27461: PUSH
27462: LD_INT 0
27464: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27465: LD_EXP 3
27469: PPUSH
27470: LD_STRING DJ1
27472: PUSH
27473: LD_STRING DJ4
27475: PUSH
27476: LD_STRING DJ6
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 1
27486: PPUSH
27487: LD_INT 3
27489: PPUSH
27490: CALL_OW 12
27494: ARRAY
27495: PPUSH
27496: CALL_OW 94
// Wait ( 4 4$00 ) ;
27500: LD_INT 8400
27502: PPUSH
27503: CALL_OW 67
// dialog_south := true ;
27507: LD_ADDR_EXP 8
27511: PUSH
27512: LD_INT 1
27514: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27515: LD_VAR 0 1
27519: PUSH
27520: LD_INT 104
27522: EQUAL
27523: PUSH
27524: LD_EXP 9
27528: AND
27529: IFFALSE 27551
// begin dialog_popov := false ;
27531: LD_ADDR_EXP 9
27535: PUSH
27536: LD_INT 0
27538: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27539: LD_EXP 26
27543: PPUSH
27544: LD_STRING DR4
27546: PPUSH
27547: CALL_OW 94
// end ; end ;
27551: PPOPN 1
27553: END
// on BuildingStarted ( b , unit ) do var side , i ;
27554: LD_INT 0
27556: PPUSH
27557: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27558: LD_EXP 41
27562: PUSH
27563: LD_VAR 0 1
27567: PPUSH
27568: CALL_OW 255
27572: ARRAY
27573: IFFALSE 27751
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27575: LD_STRING BuildingStarted [side: 
27577: PUSH
27578: LD_VAR 0 1
27582: PPUSH
27583: CALL_OW 255
27587: STR
27588: PUSH
27589: LD_STRING ; btype: 
27591: STR
27592: PUSH
27593: LD_VAR 0 1
27597: PPUSH
27598: CALL_OW 266
27602: STR
27603: PUSH
27604: LD_STRING ; unit: 
27606: STR
27607: PUSH
27608: LD_VAR 0 2
27612: STR
27613: PUSH
27614: LD_STRING ]
27616: STR
27617: PPUSH
27618: CALL 7806 0 1
// side := GetSide ( b ) ;
27622: LD_ADDR_VAR 0 3
27626: PUSH
27627: LD_VAR 0 1
27631: PPUSH
27632: CALL_OW 255
27636: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27637: LD_VAR 0 3
27641: PPUSH
27642: LD_INT 21
27644: PUSH
27645: LD_INT 3
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PPUSH
27652: CALL 11409 0 2
27656: PUSH
27657: LD_INT 1
27659: EQUAL
27660: IFFALSE 27751
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27662: LD_ADDR_VAR 0 4
27666: PUSH
27667: LD_VAR 0 3
27671: PPUSH
27672: LD_INT 21
27674: PUSH
27675: LD_INT 1
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PPUSH
27682: CALL 11409 0 2
27686: PUSH
27687: LD_VAR 0 3
27691: PPUSH
27692: LD_INT 2
27694: PPUSH
27695: EMPTY
27696: PPUSH
27697: CALL 11492 0 3
27701: DIFF
27702: PUSH
27703: FOR_IN
27704: IFFALSE 27749
// if not HasTask ( i ) then
27706: LD_VAR 0 4
27710: PPUSH
27711: CALL_OW 314
27715: NOT
27716: IFFALSE 27747
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27718: LD_VAR 0 4
27722: PPUSH
27723: LD_VAR 0 1
27727: PPUSH
27728: CALL_OW 250
27732: PPUSH
27733: LD_VAR 0 1
27737: PPUSH
27738: CALL_OW 251
27742: PPUSH
27743: CALL_OW 111
27747: GO 27703
27749: POP
27750: POP
// end ;
27751: PPOPN 4
27753: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27754: LD_EXP 41
27758: PUSH
27759: LD_VAR 0 1
27763: PPUSH
27764: CALL_OW 255
27768: ARRAY
27769: IFFALSE 28138
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27771: LD_STRING BuildingComplete [side: 
27773: PUSH
27774: LD_VAR 0 1
27778: PPUSH
27779: CALL_OW 255
27783: STR
27784: PUSH
27785: LD_STRING ; btype: 
27787: STR
27788: PUSH
27789: LD_VAR 0 1
27793: PPUSH
27794: CALL_OW 266
27798: STR
27799: PUSH
27800: LD_STRING ]
27802: STR
27803: PPUSH
27804: CALL 7806 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27808: LD_ADDR_EXP 48
27812: PUSH
27813: LD_EXP 48
27817: PPUSH
27818: LD_VAR 0 1
27822: PPUSH
27823: CALL_OW 255
27827: PPUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 266
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 250
27847: PUSH
27848: LD_VAR 0 1
27852: PPUSH
27853: CALL_OW 251
27857: PUSH
27858: LD_VAR 0 1
27862: PPUSH
27863: CALL_OW 254
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: LIST
27872: PPUSH
27873: CALL 42216 0 4
27877: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27878: LD_VAR 0 1
27882: PPUSH
27883: CALL_OW 266
27887: PUSH
27888: LD_INT 6
27890: EQUAL
27891: IFFALSE 27925
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27893: LD_ADDR_EXP 42
27897: PUSH
27898: LD_EXP 42
27902: PPUSH
27903: LD_VAR 0 1
27907: PPUSH
27908: CALL_OW 255
27912: PPUSH
27913: LD_VAR 0 1
27917: PPUSH
27918: EMPTY
27919: PPUSH
27920: CALL 42125 0 4
27924: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27925: LD_VAR 0 1
27929: PPUSH
27930: CALL_OW 266
27934: PUSH
27935: LD_INT 0
27937: EQUAL
27938: IFFALSE 28048
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27940: LD_ADDR_EXP 50
27944: PUSH
27945: LD_EXP 50
27949: PPUSH
27950: LD_VAR 0 1
27954: PPUSH
27955: CALL_OW 255
27959: PPUSH
27960: LD_INT 0
27962: PPUSH
27963: EMPTY
27964: PPUSH
27965: CALL 42125 0 4
27969: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27970: LD_VAR 0 1
27974: PPUSH
27975: CALL_OW 274
27979: PPUSH
27980: LD_INT 1
27982: PPUSH
27983: LD_EXP 74
27987: PUSH
27988: LD_INT 1
27990: ARRAY
27991: PPUSH
27992: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
27996: LD_VAR 0 1
28000: PPUSH
28001: CALL_OW 274
28005: PPUSH
28006: LD_INT 2
28008: PPUSH
28009: LD_EXP 74
28013: PUSH
28014: LD_INT 2
28016: ARRAY
28017: PPUSH
28018: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28022: LD_VAR 0 1
28026: PPUSH
28027: CALL_OW 274
28031: PPUSH
28032: LD_INT 3
28034: PPUSH
28035: LD_EXP 74
28039: PUSH
28040: LD_INT 3
28042: ARRAY
28043: PPUSH
28044: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28048: LD_VAR 0 1
28052: PPUSH
28053: CALL_OW 266
28057: PUSH
28058: LD_INT 2
28060: EQUAL
28061: IFFALSE 28093
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28063: LD_ADDR_EXP 50
28067: PUSH
28068: LD_EXP 50
28072: PPUSH
28073: LD_VAR 0 1
28077: PPUSH
28078: CALL_OW 255
28082: PPUSH
28083: LD_INT 2
28085: PPUSH
28086: EMPTY
28087: PPUSH
28088: CALL 42125 0 4
28092: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28093: LD_VAR 0 1
28097: PPUSH
28098: CALL_OW 266
28102: PUSH
28103: LD_INT 4
28105: EQUAL
28106: IFFALSE 28138
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28108: LD_ADDR_EXP 50
28112: PUSH
28113: LD_EXP 50
28117: PPUSH
28118: LD_VAR 0 1
28122: PPUSH
28123: CALL_OW 255
28127: PPUSH
28128: LD_INT 4
28130: PPUSH
28131: EMPTY
28132: PPUSH
28133: CALL 42125 0 4
28137: ST_TO_ADDR
// end ;
28138: PPOPN 1
28140: END
// on ResearchComplete ( tech , lab ) do var i ;
28141: LD_INT 0
28143: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28144: LD_EXP 41
28148: PUSH
28149: LD_VAR 0 2
28153: PPUSH
28154: CALL_OW 255
28158: ARRAY
28159: IFFALSE 28443
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28161: LD_STRING ResearchComplete [side: 
28163: PUSH
28164: LD_VAR 0 2
28168: PPUSH
28169: CALL_OW 255
28173: PPUSH
28174: CALL_OW 255
28178: STR
28179: PUSH
28180: LD_STRING ; tech:
28182: STR
28183: PUSH
28184: LD_VAR 0 1
28188: STR
28189: PUSH
28190: LD_STRING ]
28192: STR
28193: PPUSH
28194: CALL 7806 0 1
// for i = 1 to MREG_ToRes do
28198: LD_ADDR_VAR 0 3
28202: PUSH
28203: DOUBLE
28204: LD_INT 1
28206: DEC
28207: ST_TO_ADDR
28208: LD_EXP 52
28212: PUSH
28213: FOR_TO
28214: IFFALSE 28301
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28216: LD_EXP 52
28220: PUSH
28221: LD_VAR 0 3
28225: ARRAY
28226: PUSH
28227: LD_INT 1
28229: ARRAY
28230: PUSH
28231: LD_VAR 0 2
28235: PPUSH
28236: CALL_OW 255
28240: EQUAL
28241: PUSH
28242: LD_EXP 52
28246: PUSH
28247: LD_VAR 0 3
28251: ARRAY
28252: PUSH
28253: LD_INT 2
28255: ARRAY
28256: PUSH
28257: LD_VAR 0 1
28261: EQUAL
28262: AND
28263: IFFALSE 28299
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28265: LD_ADDR_EXP 52
28269: PUSH
28270: LD_EXP 52
28274: PPUSH
28275: LD_VAR 0 2
28279: PPUSH
28280: CALL_OW 255
28284: PPUSH
28285: LD_VAR 0 1
28289: PPUSH
28290: EMPTY
28291: PPUSH
28292: CALL 42216 0 4
28296: ST_TO_ADDR
// break ;
28297: GO 28301
// end ;
28299: GO 28213
28301: POP
28302: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28303: LD_VAR 0 1
28307: PUSH
28308: LD_INT 2
28310: PUSH
28311: LD_INT 11
28313: PUSH
28314: LD_INT 4
28316: PUSH
28317: LD_INT 3
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: LIST
28324: LIST
28325: IN
28326: IFFALSE 28443
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28328: LD_ADDR_VAR 0 3
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: LD_INT 16
28345: PPUSH
28346: LD_INT 25
28348: PUSH
28349: LD_INT 4
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PPUSH
28356: CALL 12112 0 3
28360: ST_TO_ADDR
// if i then
28361: LD_VAR 0 3
28365: IFFALSE 28383
// SetTag ( i [ 1 ] , 0 ) ;
28367: LD_VAR 0 3
28371: PUSH
28372: LD_INT 1
28374: ARRAY
28375: PPUSH
28376: LD_INT 0
28378: PPUSH
28379: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: LD_VAR 0 2
28392: PPUSH
28393: CALL_OW 255
28397: PPUSH
28398: LD_INT 171
28400: PPUSH
28401: EMPTY
28402: PPUSH
28403: CALL 12112 0 3
28407: ST_TO_ADDR
// if i then
28408: LD_VAR 0 3
28412: IFFALSE 28443
// begin SetTag ( i [ 1 ] , 0 ) ;
28414: LD_VAR 0 3
28418: PUSH
28419: LD_INT 1
28421: ARRAY
28422: PPUSH
28423: LD_INT 0
28425: PPUSH
28426: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28430: LD_VAR 0 3
28434: PUSH
28435: LD_INT 1
28437: ARRAY
28438: PPUSH
28439: CALL_OW 122
// end ; end ; end ;
28443: PPOPN 3
28445: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28446: LD_INT 0
28448: PPUSH
28449: PPUSH
28450: PPUSH
28451: PPUSH
28452: PPUSH
28453: PPUSH
28454: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28455: LD_EXP 41
28459: PUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: ARRAY
28470: IFFALSE 29197
// begin side := GetSide ( veh ) ;
28472: LD_ADDR_VAR 0 4
28476: PUSH
28477: LD_VAR 0 1
28481: PPUSH
28482: CALL_OW 255
28486: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28487: LD_ADDR_VAR 0 6
28491: PUSH
28492: LD_VAR 0 1
28496: PPUSH
28497: CALL_OW 265
28501: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28502: LD_ADDR_VAR 0 7
28506: PUSH
28507: LD_VAR 0 1
28511: PPUSH
28512: CALL_OW 262
28516: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28517: LD_ADDR_VAR 0 8
28521: PUSH
28522: LD_VAR 0 1
28526: PPUSH
28527: CALL_OW 263
28531: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28532: LD_ADDR_VAR 0 9
28536: PUSH
28537: LD_VAR 0 1
28541: PPUSH
28542: CALL_OW 264
28546: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28547: LD_STRING VehicleConstructed [side: 
28549: PUSH
28550: LD_VAR 0 4
28554: STR
28555: PUSH
28556: LD_STRING ; id:
28558: STR
28559: PUSH
28560: LD_VAR 0 1
28564: STR
28565: PUSH
28566: LD_STRING ; components: [
28568: STR
28569: PUSH
28570: LD_VAR 0 6
28574: STR
28575: PUSH
28576: LD_STRING , 
28578: STR
28579: PUSH
28580: LD_VAR 0 7
28584: STR
28585: PUSH
28586: LD_STRING , 
28588: STR
28589: PUSH
28590: LD_VAR 0 8
28594: STR
28595: PUSH
28596: LD_STRING , 
28598: STR
28599: PUSH
28600: LD_VAR 0 9
28604: STR
28605: PUSH
28606: LD_STRING ]]
28608: STR
28609: PPUSH
28610: CALL 7806 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28614: LD_VAR 0 1
28618: PPUSH
28619: CALL_OW 264
28623: PUSH
28624: LD_INT 13
28626: PUSH
28627: LD_INT 12
28629: PUSH
28630: LD_INT 14
28632: PUSH
28633: LD_INT 51
28635: PUSH
28636: LD_INT 53
28638: PUSH
28639: LD_INT 52
28641: PUSH
28642: LD_INT 32
28644: PUSH
28645: EMPTY
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: IN
28654: NOT
28655: IFFALSE 28697
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28657: LD_ADDR_EXP 61
28661: PUSH
28662: LD_EXP 61
28666: PPUSH
28667: LD_VAR 0 4
28671: PPUSH
28672: LD_EXP 61
28676: PUSH
28677: LD_VAR 0 4
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: PLUS
28686: PPUSH
28687: LD_VAR 0 1
28691: PPUSH
28692: CALL 30843 0 4
28696: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28697: LD_VAR 0 1
28701: PPUSH
28702: CALL_OW 264
28706: PUSH
28707: LD_INT 31
28709: EQUAL
28710: IFFALSE 28729
// SetTag ( GetDriver ( veh ) , 9 ) ;
28712: LD_VAR 0 1
28716: PPUSH
28717: CALL 31537 0 1
28721: PPUSH
28722: LD_INT 9
28724: PPUSH
28725: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28729: LD_VAR 0 1
28733: PPUSH
28734: CALL_OW 264
28738: PUSH
28739: LD_INT 14
28741: PUSH
28742: LD_INT 53
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: IN
28749: IFFALSE 28786
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28751: LD_ADDR_EXP 44
28755: PUSH
28756: LD_EXP 44
28760: PPUSH
28761: LD_VAR 0 1
28765: PPUSH
28766: CALL_OW 255
28770: PPUSH
28771: LD_INT 2
28773: PPUSH
28774: LD_VAR 0 1
28778: PPUSH
28779: CALL 30843 0 4
28783: ST_TO_ADDR
// exit ;
28784: GO 29197
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28786: LD_VAR 0 1
28790: PPUSH
28791: CALL_OW 265
28795: PUSH
28796: LD_EXP 68
28800: PUSH
28801: LD_VAR 0 4
28805: ARRAY
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: IN
28811: PUSH
28812: LD_VAR 0 1
28816: PPUSH
28817: CALL_OW 262
28821: PUSH
28822: LD_EXP 68
28826: PUSH
28827: LD_VAR 0 4
28831: ARRAY
28832: PUSH
28833: LD_INT 1
28835: ARRAY
28836: IN
28837: AND
28838: PUSH
28839: LD_VAR 0 1
28843: PPUSH
28844: CALL_OW 263
28848: PUSH
28849: LD_EXP 68
28853: PUSH
28854: LD_VAR 0 4
28858: ARRAY
28859: PUSH
28860: LD_INT 1
28862: ARRAY
28863: IN
28864: AND
28865: PUSH
28866: LD_VAR 0 1
28870: PPUSH
28871: CALL_OW 264
28875: PUSH
28876: LD_EXP 68
28880: PUSH
28881: LD_VAR 0 4
28885: ARRAY
28886: PUSH
28887: LD_INT 1
28889: ARRAY
28890: IN
28891: AND
28892: IFFALSE 28936
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28894: LD_ADDR_EXP 69
28898: PUSH
28899: LD_EXP 69
28903: PPUSH
28904: LD_VAR 0 4
28908: PPUSH
28909: LD_EXP 69
28913: PUSH
28914: LD_VAR 0 4
28918: ARRAY
28919: PUSH
28920: LD_INT 1
28922: PLUS
28923: PPUSH
28924: LD_VAR 0 1
28928: PPUSH
28929: CALL 30843 0 4
28933: ST_TO_ADDR
// exit ;
28934: GO 29197
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28936: LD_VAR 0 6
28940: PUSH
28941: LD_EXP 71
28945: PUSH
28946: LD_VAR 0 4
28950: ARRAY
28951: PUSH
28952: LD_INT 1
28954: ARRAY
28955: EQUAL
28956: PUSH
28957: LD_VAR 0 7
28961: PUSH
28962: LD_EXP 71
28966: PUSH
28967: LD_VAR 0 4
28971: ARRAY
28972: PUSH
28973: LD_INT 2
28975: ARRAY
28976: EQUAL
28977: AND
28978: PUSH
28979: LD_VAR 0 8
28983: PUSH
28984: LD_EXP 71
28988: PUSH
28989: LD_VAR 0 4
28993: ARRAY
28994: PUSH
28995: LD_INT 3
28997: ARRAY
28998: EQUAL
28999: AND
29000: PUSH
29001: LD_VAR 0 9
29005: PUSH
29006: LD_EXP 71
29010: PUSH
29011: LD_VAR 0 4
29015: ARRAY
29016: PUSH
29017: LD_INT 4
29019: ARRAY
29020: EQUAL
29021: AND
29022: IFFALSE 29178
// begin tmp := MREG_ToAttack [ side ] ;
29024: LD_ADDR_VAR 0 5
29028: PUSH
29029: LD_EXP 71
29033: PUSH
29034: LD_VAR 0 4
29038: ARRAY
29039: ST_TO_ADDR
// for i = 1 to 4 do
29040: LD_ADDR_VAR 0 3
29044: PUSH
29045: DOUBLE
29046: LD_INT 1
29048: DEC
29049: ST_TO_ADDR
29050: LD_INT 4
29052: PUSH
29053: FOR_TO
29054: IFFALSE 29076
// tmp := Delete ( tmp , 1 ) ;
29056: LD_ADDR_VAR 0 5
29060: PUSH
29061: LD_VAR 0 5
29065: PPUSH
29066: LD_INT 1
29068: PPUSH
29069: CALL_OW 3
29073: ST_TO_ADDR
29074: GO 29053
29076: POP
29077: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29078: LD_ADDR_EXP 71
29082: PUSH
29083: LD_EXP 71
29087: PPUSH
29088: LD_VAR 0 4
29092: PPUSH
29093: LD_VAR 0 5
29097: PPUSH
29098: CALL_OW 1
29102: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29103: LD_ADDR_EXP 73
29107: PUSH
29108: LD_EXP 73
29112: PPUSH
29113: LD_VAR 0 4
29117: PPUSH
29118: LD_EXP 73
29122: PUSH
29123: LD_VAR 0 4
29127: ARRAY
29128: PUSH
29129: LD_INT 1
29131: PLUS
29132: PPUSH
29133: LD_VAR 0 1
29137: PPUSH
29138: CALL 30843 0 4
29142: ST_TO_ADDR
// if tmp = 0 then
29143: LD_VAR 0 5
29147: PUSH
29148: LD_INT 0
29150: EQUAL
29151: IFFALSE 29176
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29153: LD_ADDR_EXP 71
29157: PUSH
29158: LD_EXP 71
29162: PPUSH
29163: LD_VAR 0 4
29167: PPUSH
29168: LD_INT 0
29170: PPUSH
29171: CALL_OW 1
29175: ST_TO_ADDR
// exit ;
29176: GO 29197
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29178: LD_VAR 0 1
29182: PPUSH
29183: CALL_OW 255
29187: PPUSH
29188: LD_VAR 0 1
29192: PPUSH
29193: CALL 25570 0 2
// end ;
29197: PPOPN 9
29199: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29200: LD_EXP 41
29204: PUSH
29205: LD_VAR 0 2
29209: PPUSH
29210: CALL_OW 255
29214: ARRAY
29215: IFFALSE 29447
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29217: LD_STRING ApemanTamed [side: 
29219: PUSH
29220: LD_VAR 0 2
29224: PPUSH
29225: CALL_OW 255
29229: STR
29230: PUSH
29231: LD_STRING ; sci: 
29233: STR
29234: PUSH
29235: LD_VAR 0 2
29239: STR
29240: PUSH
29241: LD_STRING ; ape: 
29243: STR
29244: PUSH
29245: LD_VAR 0 1
29249: STR
29250: PUSH
29251: LD_STRING ]
29253: STR
29254: PPUSH
29255: CALL 7806 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29259: LD_INT 11
29261: PPUSH
29262: LD_VAR 0 2
29266: PPUSH
29267: CALL_OW 255
29271: PPUSH
29272: CALL_OW 321
29276: PUSH
29277: LD_INT 2
29279: EQUAL
29280: NOT
29281: PUSH
29282: LD_INT 2
29284: PPUSH
29285: LD_VAR 0 2
29289: PPUSH
29290: CALL_OW 255
29294: PPUSH
29295: CALL_OW 321
29299: PUSH
29300: LD_INT 2
29302: EQUAL
29303: NOT
29304: OR
29305: PUSH
29306: LD_VAR 0 2
29310: PPUSH
29311: CALL_OW 255
29315: PPUSH
29316: LD_INT 171
29318: PPUSH
29319: EMPTY
29320: PPUSH
29321: CALL 12112 0 3
29325: PUSH
29326: LD_INT 0
29328: EQUAL
29329: AND
29330: IFFALSE 29344
// begin SetTag ( ape , 171 ) ;
29332: LD_VAR 0 1
29336: PPUSH
29337: LD_INT 171
29339: PPUSH
29340: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29344: LD_VAR 0 2
29348: PPUSH
29349: CALL_OW 255
29353: PPUSH
29354: LD_INT 30
29356: PUSH
29357: LD_INT 1
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PPUSH
29364: CALL 11409 0 2
29368: IFFALSE 29447
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29370: LD_VAR 0 1
29374: PPUSH
29375: LD_VAR 0 2
29379: PPUSH
29380: CALL_OW 255
29384: PPUSH
29385: LD_INT 30
29387: PUSH
29388: LD_INT 1
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PPUSH
29395: CALL 11409 0 2
29399: PUSH
29400: LD_INT 1
29402: ARRAY
29403: PPUSH
29404: CALL_OW 250
29408: PPUSH
29409: LD_VAR 0 2
29413: PPUSH
29414: CALL_OW 255
29418: PPUSH
29419: LD_INT 30
29421: PUSH
29422: LD_INT 1
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: PPUSH
29429: CALL 11409 0 2
29433: PUSH
29434: LD_INT 1
29436: ARRAY
29437: PPUSH
29438: CALL_OW 251
29442: PPUSH
29443: CALL_OW 111
// end ;
29447: PPOPN 2
29449: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29450: LD_EXP 41
29454: PUSH
29455: LD_VAR 0 1
29459: PPUSH
29460: CALL_OW 255
29464: ARRAY
29465: IFFALSE 29743
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29467: LD_VAR 0 2
29471: PUSH
29472: LD_VAR 0 2
29476: PPUSH
29477: CALL_OW 255
29481: PPUSH
29482: CALL 11822 0 1
29486: IN
29487: IFFALSE 29628
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29489: LD_VAR 0 1
29493: PPUSH
29494: CALL_OW 266
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: IN
29509: IFFALSE 29539
// begin Wait ( 0 0$0.3 ) ;
29511: LD_INT 10
29513: PPUSH
29514: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29518: LD_VAR 0 2
29522: PPUSH
29523: LD_INT 16
29525: PPUSH
29526: CALL_OW 336
// ComExitBuilding ( un ) ;
29530: LD_VAR 0 2
29534: PPUSH
29535: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29539: LD_VAR 0 1
29543: PPUSH
29544: CALL_OW 266
29548: PUSH
29549: LD_INT 4
29551: PUSH
29552: LD_INT 5
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: IN
29559: IFFALSE 29628
// begin Wait ( 0 0$0.3 ) ;
29561: LD_INT 10
29563: PPUSH
29564: CALL_OW 67
// if GetTag ( un ) = 0 then
29568: LD_VAR 0 2
29572: PPUSH
29573: CALL_OW 110
29577: PUSH
29578: LD_INT 0
29580: EQUAL
29581: IFFALSE 29597
// SetClass ( un , class_apeman_soldier ) else
29583: LD_VAR 0 2
29587: PPUSH
29588: LD_INT 15
29590: PPUSH
29591: CALL_OW 336
29595: GO 29628
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29597: LD_INT 3
29599: PPUSH
29600: LD_VAR 0 2
29604: PPUSH
29605: CALL_OW 255
29609: PPUSH
29610: CALL_OW 321
29614: IFFALSE 29628
// SetClass ( un , class_apeman_kamikaze ) ;
29616: LD_VAR 0 2
29620: PPUSH
29621: LD_INT 17
29623: PPUSH
29624: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29628: LD_VAR 0 1
29632: PPUSH
29633: CALL_OW 266
29637: PUSH
29638: LD_INT 32
29640: EQUAL
29641: IFFALSE 29743
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29643: LD_ADDR_EXP 70
29647: PUSH
29648: LD_EXP 70
29652: PPUSH
29653: LD_VAR 0 1
29657: PPUSH
29658: CALL_OW 255
29662: PPUSH
29663: LD_EXP 70
29667: PUSH
29668: LD_VAR 0 1
29672: PPUSH
29673: CALL_OW 255
29677: ARRAY
29678: PUSH
29679: LD_INT 1
29681: PLUS
29682: PPUSH
29683: LD_VAR 0 1
29687: PPUSH
29688: CALL 30843 0 4
29692: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29693: LD_ADDR_EXP 70
29697: PUSH
29698: LD_EXP 70
29702: PPUSH
29703: LD_VAR 0 1
29707: PPUSH
29708: CALL_OW 255
29712: PPUSH
29713: LD_EXP 70
29717: PUSH
29718: LD_VAR 0 1
29722: PPUSH
29723: CALL_OW 255
29727: ARRAY
29728: PUSH
29729: LD_INT 1
29731: PLUS
29732: PPUSH
29733: LD_VAR 0 2
29737: PPUSH
29738: CALL 30843 0 4
29742: ST_TO_ADDR
// end ; end ;
29743: PPOPN 2
29745: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29746: LD_VAR 0 1
29750: PUSH
29751: LD_INT 22
29753: PUSH
29754: LD_INT 1
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 21
29763: PUSH
29764: LD_INT 3
29766: PUSH
29767: EMPTY
29768: LIST
29769: LIST
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PPUSH
29775: CALL_OW 69
29779: IN
29780: PUSH
29781: LD_EXP 15
29785: NOT
29786: AND
29787: IFFALSE 29850
// begin alfa_north_triggered := true ;
29789: LD_ADDR_EXP 15
29793: PUSH
29794: LD_INT 1
29796: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29797: LD_EXP 4
29801: PPUSH
29802: LD_STRING DS4
29804: PPUSH
29805: CALL_OW 94
// Wait ( 1 1$25 ) ;
29809: LD_INT 2975
29811: PPUSH
29812: CALL_OW 67
// if not isTest then
29816: LD_EXP 1
29820: NOT
29821: IFFALSE 29850
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29823: LD_INT 20
29825: PPUSH
29826: LD_INT 5
29828: PUSH
29829: LD_INT 6
29831: PUSH
29832: LD_INT 7
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: LIST
29839: PUSH
29840: LD_OWVAR 67
29844: ARRAY
29845: PPUSH
29846: CALL 6964 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29850: LD_VAR 0 1
29854: PUSH
29855: LD_INT 22
29857: PUSH
29858: LD_INT 4
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 21
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PPUSH
29879: CALL_OW 69
29883: IN
29884: PUSH
29885: LD_EXP 16
29889: NOT
29890: AND
29891: IFFALSE 29954
// begin alfa_south_triggered := true ;
29893: LD_ADDR_EXP 16
29897: PUSH
29898: LD_INT 1
29900: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29901: LD_EXP 3
29905: PPUSH
29906: LD_STRING DJ3
29908: PPUSH
29909: CALL_OW 94
// Wait ( 0 0$45 ) ;
29913: LD_INT 1575
29915: PPUSH
29916: CALL_OW 67
// if not isTest then
29920: LD_EXP 1
29924: NOT
29925: IFFALSE 29954
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29927: LD_INT 20
29929: PPUSH
29930: LD_INT 5
29932: PUSH
29933: LD_INT 6
29935: PUSH
29936: LD_INT 7
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: LIST
29943: PUSH
29944: LD_OWVAR 67
29948: ARRAY
29949: PPUSH
29950: CALL 6964 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
29954: LD_VAR 0 1
29958: PPUSH
29959: CALL_OW 266
29963: PUSH
29964: LD_INT 1
29966: EQUAL
29967: PUSH
29968: LD_VAR 0 1
29972: PPUSH
29973: CALL_OW 255
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: LD_INT 4
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: IN
29988: AND
29989: IFFALSE 29998
// RaiseSailEvent ( 104 ) ;
29991: LD_INT 104
29993: PPUSH
29994: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
29998: LD_EXP 41
30002: PUSH
30003: LD_VAR 0 1
30007: PPUSH
30008: CALL_OW 255
30012: ARRAY
30013: IFFALSE 30400
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30015: LD_STRING UnitDestroyed [side 
30017: PUSH
30018: LD_VAR 0 1
30022: PPUSH
30023: CALL_OW 255
30027: STR
30028: PUSH
30029: LD_STRING ; id: 
30031: STR
30032: PUSH
30033: LD_VAR 0 1
30037: STR
30038: PUSH
30039: LD_STRING ; type: 
30041: STR
30042: PUSH
30043: LD_VAR 0 1
30047: PPUSH
30048: CALL_OW 247
30052: STR
30053: PUSH
30054: LD_STRING ]
30056: STR
30057: PPUSH
30058: CALL 7806 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30062: LD_VAR 0 1
30066: PUSH
30067: LD_VAR 0 1
30071: PPUSH
30072: CALL_OW 255
30076: PPUSH
30077: LD_INT 21
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PPUSH
30087: CALL 11409 0 2
30091: IN
30092: IFFALSE 30248
// begin if MCF_HasClass ( un ) then
30094: LD_VAR 0 1
30098: PPUSH
30099: CALL 14115 0 1
30103: IFFALSE 30248
// case MCF_HasClass ( un ) of 1 :
30105: LD_VAR 0 1
30109: PPUSH
30110: CALL 14115 0 1
30114: PUSH
30115: LD_INT 1
30117: DOUBLE
30118: EQUAL
30119: IFTRUE 30123
30121: GO 30148
30123: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30124: LD_VAR 0 1
30128: PPUSH
30129: CALL_OW 255
30133: PPUSH
30134: LD_STRING ToArm
30136: PPUSH
30137: LD_VAR 0 1
30141: PPUSH
30142: CALL 14288 0 3
30146: GO 30248
30148: LD_INT 2
30150: DOUBLE
30151: EQUAL
30152: IFTRUE 30156
30154: GO 30181
30156: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30157: LD_VAR 0 1
30161: PPUSH
30162: CALL_OW 255
30166: PPUSH
30167: LD_STRING ToDep
30169: PPUSH
30170: LD_VAR 0 1
30174: PPUSH
30175: CALL 14288 0 3
30179: GO 30248
30181: LD_INT 3
30183: DOUBLE
30184: EQUAL
30185: IFTRUE 30189
30187: GO 30214
30189: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30190: LD_VAR 0 1
30194: PPUSH
30195: CALL_OW 255
30199: PPUSH
30200: LD_STRING ToFac
30202: PPUSH
30203: LD_VAR 0 1
30207: PPUSH
30208: CALL 14288 0 3
30212: GO 30248
30214: LD_INT 4
30216: DOUBLE
30217: EQUAL
30218: IFTRUE 30222
30220: GO 30247
30222: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 255
30232: PPUSH
30233: LD_STRING ToLab
30235: PPUSH
30236: LD_VAR 0 1
30240: PPUSH
30241: CALL 14288 0 3
30245: GO 30248
30247: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30248: LD_VAR 0 1
30252: PUSH
30253: LD_EXP 69
30257: PUSH
30258: LD_VAR 0 1
30262: PPUSH
30263: CALL_OW 255
30267: ARRAY
30268: IN
30269: IFFALSE 30354
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30271: LD_ADDR_EXP 69
30275: PUSH
30276: LD_EXP 69
30280: PPUSH
30281: LD_VAR 0 1
30285: PPUSH
30286: LD_INT 0
30288: PPUSH
30289: CALL 31002 0 3
30293: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30294: LD_VAR 0 1
30298: PPUSH
30299: CALL_OW 255
30303: PPUSH
30304: LD_VAR 0 1
30308: PPUSH
30309: CALL_OW 265
30313: PUSH
30314: LD_VAR 0 1
30318: PPUSH
30319: CALL_OW 262
30323: PUSH
30324: LD_VAR 0 1
30328: PPUSH
30329: CALL_OW 263
30333: PUSH
30334: LD_VAR 0 1
30338: PPUSH
30339: CALL_OW 264
30343: PUSH
30344: EMPTY
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: PPUSH
30350: CALL 20928 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30354: LD_VAR 0 1
30358: PUSH
30359: LD_EXP 73
30363: PUSH
30364: LD_VAR 0 1
30368: PPUSH
30369: CALL_OW 255
30373: ARRAY
30374: IN
30375: IFFALSE 30400
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30377: LD_ADDR_EXP 73
30381: PUSH
30382: LD_EXP 73
30386: PPUSH
30387: LD_VAR 0 1
30391: PPUSH
30392: LD_INT 0
30394: PPUSH
30395: CALL 31002 0 3
30399: ST_TO_ADDR
// end ; end ;
30400: PPOPN 1
30402: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30403: LD_EXP 41
30407: PUSH
30408: LD_VAR 0 2
30412: PPUSH
30413: CALL_OW 255
30417: ARRAY
30418: IFFALSE 30590
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30420: LD_VAR 0 2
30424: PUSH
30425: LD_EXP 70
30429: PUSH
30430: LD_VAR 0 2
30434: PPUSH
30435: CALL_OW 255
30439: ARRAY
30440: IN
30441: PUSH
30442: LD_VAR 0 1
30446: PPUSH
30447: CALL_OW 266
30451: PUSH
30452: LD_INT 32
30454: PUSH
30455: LD_INT 31
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: IN
30462: AND
30463: IFFALSE 30563
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30465: LD_ADDR_EXP 70
30469: PUSH
30470: LD_EXP 70
30474: PPUSH
30475: LD_VAR 0 1
30479: PPUSH
30480: LD_INT 0
30482: PPUSH
30483: CALL 31002 0 3
30487: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30488: LD_ADDR_EXP 70
30492: PUSH
30493: LD_EXP 70
30497: PPUSH
30498: LD_VAR 0 2
30502: PPUSH
30503: LD_INT 0
30505: PPUSH
30506: CALL 31002 0 3
30510: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30511: LD_EXP 70
30515: PUSH
30516: LD_VAR 0 2
30520: PPUSH
30521: CALL_OW 255
30525: ARRAY
30526: PUSH
30527: LD_STRING 
30529: EQUAL
30530: IFFALSE 30563
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30532: LD_ADDR_EXP 70
30536: PUSH
30537: LD_EXP 70
30541: PPUSH
30542: LD_VAR 0 2
30546: PPUSH
30547: CALL_OW 255
30551: PPUSH
30552: LD_INT 1
30554: PPUSH
30555: LD_INT 0
30557: PPUSH
30558: CALL 30843 0 4
30562: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30563: LD_VAR 0 1
30567: PPUSH
30568: CALL_OW 266
30572: PUSH
30573: LD_INT 36
30575: IN
30576: IFFALSE 30590
// SetTag ( un , 0 ) ;
30578: LD_VAR 0 2
30582: PPUSH
30583: LD_INT 0
30585: PPUSH
30586: CALL_OW 109
// end ;
30590: PPOPN 2
30592: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30593: LD_EXP 41
30597: PUSH
30598: LD_VAR 0 1
30602: PPUSH
30603: CALL_OW 255
30607: ARRAY
30608: IFFALSE 30634
// begin if GetControl ( un ) = control_remote then
30610: LD_VAR 0 1
30614: PPUSH
30615: CALL_OW 263
30619: PUSH
30620: LD_INT 2
30622: EQUAL
30623: IFFALSE 30634
// ComUnlink ( un ) ;
30625: LD_VAR 0 1
30629: PPUSH
30630: CALL_OW 136
// end ;
30634: PPOPN 1
30636: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30637: LD_EXP 41
30641: PUSH
30642: LD_VAR 0 1
30646: PPUSH
30647: CALL_OW 255
30651: ARRAY
30652: IFFALSE 30681
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30654: LD_VAR 0 2
30658: PPUSH
30659: CALL_OW 264
30663: PUSH
30664: LD_INT 31
30666: IN
30667: IFFALSE 30681
// SetTag ( driver , 0 ) ;
30669: LD_VAR 0 1
30673: PPUSH
30674: LD_INT 0
30676: PPUSH
30677: CALL_OW 109
// end ;
30681: PPOPN 4
30683: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30684: LD_INT 0
30686: PPUSH
30687: PPUSH
30688: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30689: LD_ADDR_VAR 0 3
30693: PUSH
30694: LD_VAR 0 1
30698: PPUSH
30699: CALL_OW 269
30703: ST_TO_ADDR
// x := GetX ( building ) ;
30704: LD_ADDR_VAR 0 4
30708: PUSH
30709: LD_VAR 0 1
30713: PPUSH
30714: CALL_OW 250
30718: ST_TO_ADDR
// y := GetY ( building ) ;
30719: LD_ADDR_VAR 0 5
30723: PUSH
30724: LD_VAR 0 1
30728: PPUSH
30729: CALL_OW 251
30733: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30734: LD_ADDR_EXP 45
30738: PUSH
30739: LD_EXP 45
30743: PPUSH
30744: LD_VAR 0 1
30748: PPUSH
30749: CALL_OW 255
30753: PPUSH
30754: LD_VAR 0 3
30758: PPUSH
30759: LD_VAR 0 4
30763: PUSH
30764: LD_VAR 0 5
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PPUSH
30773: CALL 42216 0 4
30777: ST_TO_ADDR
// end ;
30778: PPOPN 5
30780: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30781: LD_VAR 0 1
30785: PUSH
30786: LD_EXP 32
30790: IN
30791: NOT
30792: IFFALSE 30840
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30794: LD_ADDR_EXP 32
30798: PUSH
30799: LD_EXP 32
30803: PPUSH
30804: LD_EXP 32
30808: PUSH
30809: LD_INT 1
30811: PLUS
30812: PPUSH
30813: LD_VAR 0 1
30817: PPUSH
30818: CALL_OW 2
30822: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30823: LD_STRING DestinationUnrechable. [unit: 
30825: PUSH
30826: LD_VAR 0 1
30830: STR
30831: PUSH
30832: LD_STRING ]
30834: STR
30835: PPUSH
30836: CALL 7806 0 1
// end ; end ; end_of_file
30840: PPOPN 1
30842: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30843: LD_INT 0
30845: PPUSH
30846: PPUSH
30847: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30848: LD_ADDR_VAR 0 7
30852: PUSH
30853: LD_VAR 0 1
30857: PUSH
30858: LD_VAR 0 2
30862: ARRAY
30863: PPUSH
30864: LD_VAR 0 3
30868: PPUSH
30869: LD_VAR 0 4
30873: PPUSH
30874: CALL_OW 1
30878: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30879: LD_ADDR_VAR 0 1
30883: PUSH
30884: LD_VAR 0 1
30888: PPUSH
30889: LD_VAR 0 2
30893: PPUSH
30894: LD_VAR 0 7
30898: PPUSH
30899: CALL_OW 1
30903: ST_TO_ADDR
// result := tab ;
30904: LD_ADDR_VAR 0 5
30908: PUSH
30909: LD_VAR 0 1
30913: ST_TO_ADDR
// end ;
30914: LD_VAR 0 5
30918: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
30919: LD_INT 0
30921: PPUSH
30922: PPUSH
30923: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
30924: LD_ADDR_VAR 0 5
30928: PUSH
30929: LD_VAR 0 1
30933: PUSH
30934: LD_VAR 0 2
30938: PUSH
30939: LD_INT 1
30941: ARRAY
30942: ARRAY
30943: PPUSH
30944: LD_VAR 0 2
30948: PUSH
30949: LD_INT 2
30951: ARRAY
30952: PPUSH
30953: CALL_OW 3
30957: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
30958: LD_ADDR_VAR 0 1
30962: PUSH
30963: LD_VAR 0 1
30967: PPUSH
30968: LD_VAR 0 2
30972: PUSH
30973: LD_INT 1
30975: ARRAY
30976: PPUSH
30977: LD_VAR 0 5
30981: PPUSH
30982: CALL_OW 1
30986: ST_TO_ADDR
// result := tab ;
30987: LD_ADDR_VAR 0 3
30991: PUSH
30992: LD_VAR 0 1
30996: ST_TO_ADDR
// end ;
30997: LD_VAR 0 3
31001: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31002: LD_INT 0
31004: PPUSH
31005: PPUSH
31006: PPUSH
31007: PPUSH
// i := 1 ;
31008: LD_ADDR_VAR 0 5
31012: PUSH
31013: LD_INT 1
31015: ST_TO_ADDR
// while ( i <= tab ) do
31016: LD_VAR 0 5
31020: PUSH
31021: LD_VAR 0 1
31025: LESSEQUAL
31026: IFFALSE 31401
// begin if not tab [ i ] then
31028: LD_VAR 0 1
31032: PUSH
31033: LD_VAR 0 5
31037: ARRAY
31038: NOT
31039: IFFALSE 31043
// break ;
31041: GO 31401
// if value in tab then
31043: LD_VAR 0 2
31047: PUSH
31048: LD_VAR 0 1
31052: IN
31053: IFFALSE 31166
// begin if not mode then
31055: LD_VAR 0 3
31059: NOT
31060: IFFALSE 31080
// tab := tab diff value else
31062: LD_ADDR_VAR 0 1
31066: PUSH
31067: LD_VAR 0 1
31071: PUSH
31072: LD_VAR 0 2
31076: DIFF
31077: ST_TO_ADDR
31078: GO 31142
// for j = 1 to tab do
31080: LD_ADDR_VAR 0 6
31084: PUSH
31085: DOUBLE
31086: LD_INT 1
31088: DEC
31089: ST_TO_ADDR
31090: LD_VAR 0 1
31094: PUSH
31095: FOR_TO
31096: IFFALSE 31140
// if tab [ j ] = value then
31098: LD_VAR 0 1
31102: PUSH
31103: LD_VAR 0 6
31107: ARRAY
31108: PUSH
31109: LD_VAR 0 2
31113: EQUAL
31114: IFFALSE 31138
// begin tab := Delete ( tab , j ) ;
31116: LD_ADDR_VAR 0 1
31120: PUSH
31121: LD_VAR 0 1
31125: PPUSH
31126: LD_VAR 0 6
31130: PPUSH
31131: CALL_OW 3
31135: ST_TO_ADDR
// break ;
31136: GO 31140
// end ;
31138: GO 31095
31140: POP
31141: POP
// i := i - 1 ;
31142: LD_ADDR_VAR 0 5
31146: PUSH
31147: LD_VAR 0 5
31151: PUSH
31152: LD_INT 1
31154: MINUS
31155: ST_TO_ADDR
// if mode then
31156: LD_VAR 0 3
31160: IFFALSE 31164
// break ;
31162: GO 31401
// end else
31164: GO 31385
// if tab [ i ] and value in tab [ i ] then
31166: LD_VAR 0 1
31170: PUSH
31171: LD_VAR 0 5
31175: ARRAY
31176: PUSH
31177: LD_VAR 0 2
31181: PUSH
31182: LD_VAR 0 1
31186: PUSH
31187: LD_VAR 0 5
31191: ARRAY
31192: IN
31193: AND
31194: IFFALSE 31385
// begin if not mode then
31196: LD_VAR 0 3
31200: NOT
31201: IFFALSE 31227
// tmp := tab [ i ] diff value else
31203: LD_ADDR_VAR 0 7
31207: PUSH
31208: LD_VAR 0 1
31212: PUSH
31213: LD_VAR 0 5
31217: ARRAY
31218: PUSH
31219: LD_VAR 0 2
31223: DIFF
31224: ST_TO_ADDR
31225: GO 31307
// for j = 1 to tab [ i ] do
31227: LD_ADDR_VAR 0 6
31231: PUSH
31232: DOUBLE
31233: LD_INT 1
31235: DEC
31236: ST_TO_ADDR
31237: LD_VAR 0 1
31241: PUSH
31242: LD_VAR 0 5
31246: ARRAY
31247: PUSH
31248: FOR_TO
31249: IFFALSE 31305
// if value = tab [ i ] [ j ] then
31251: LD_VAR 0 2
31255: PUSH
31256: LD_VAR 0 1
31260: PUSH
31261: LD_VAR 0 5
31265: ARRAY
31266: PUSH
31267: LD_VAR 0 6
31271: ARRAY
31272: EQUAL
31273: IFFALSE 31303
// begin tmp := Delete ( tab [ i ] , j ) ;
31275: LD_ADDR_VAR 0 7
31279: PUSH
31280: LD_VAR 0 1
31284: PUSH
31285: LD_VAR 0 5
31289: ARRAY
31290: PPUSH
31291: LD_VAR 0 6
31295: PPUSH
31296: CALL_OW 3
31300: ST_TO_ADDR
// break ;
31301: GO 31305
// end ;
31303: GO 31248
31305: POP
31306: POP
// if tmp = [ ] then
31307: LD_VAR 0 7
31311: PUSH
31312: EMPTY
31313: EQUAL
31314: IFFALSE 31338
// begin tab := Delete ( tab , i ) ;
31316: LD_ADDR_VAR 0 1
31320: PUSH
31321: LD_VAR 0 1
31325: PPUSH
31326: LD_VAR 0 5
31330: PPUSH
31331: CALL_OW 3
31335: ST_TO_ADDR
// end else
31336: GO 31363
// tab := Replace ( tab , i , tmp ) ;
31338: LD_ADDR_VAR 0 1
31342: PUSH
31343: LD_VAR 0 1
31347: PPUSH
31348: LD_VAR 0 5
31352: PPUSH
31353: LD_VAR 0 7
31357: PPUSH
31358: CALL_OW 1
31362: ST_TO_ADDR
// i := i - 1 ;
31363: LD_ADDR_VAR 0 5
31367: PUSH
31368: LD_VAR 0 5
31372: PUSH
31373: LD_INT 1
31375: MINUS
31376: ST_TO_ADDR
// if mode then
31377: LD_VAR 0 3
31381: IFFALSE 31385
// break ;
31383: GO 31401
// end ; i := i + 1 ;
31385: LD_ADDR_VAR 0 5
31389: PUSH
31390: LD_VAR 0 5
31394: PUSH
31395: LD_INT 1
31397: PLUS
31398: ST_TO_ADDR
// end ;
31399: GO 31016
// result := tab ;
31401: LD_ADDR_VAR 0 4
31405: PUSH
31406: LD_VAR 0 1
31410: ST_TO_ADDR
// end ;
31411: LD_VAR 0 4
31415: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31416: LD_INT 0
31418: PPUSH
31419: PPUSH
// for i = 1 to values do
31420: LD_ADDR_VAR 0 4
31424: PUSH
31425: DOUBLE
31426: LD_INT 1
31428: DEC
31429: ST_TO_ADDR
31430: LD_VAR 0 2
31434: PUSH
31435: FOR_TO
31436: IFFALSE 31469
// tab := Remove ( tab , values [ i ] , false ) ;
31438: LD_ADDR_VAR 0 1
31442: PUSH
31443: LD_VAR 0 1
31447: PPUSH
31448: LD_VAR 0 2
31452: PUSH
31453: LD_VAR 0 4
31457: ARRAY
31458: PPUSH
31459: LD_INT 0
31461: PPUSH
31462: CALL 31002 0 3
31466: ST_TO_ADDR
31467: GO 31435
31469: POP
31470: POP
// result := tab ;
31471: LD_ADDR_VAR 0 3
31475: PUSH
31476: LD_VAR 0 1
31480: ST_TO_ADDR
// end ;
31481: LD_VAR 0 3
31485: RET
// export function IsDriver ( unit ) ; begin
31486: LD_INT 0
31488: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31489: LD_VAR 0 1
31493: PUSH
31494: LD_INT 55
31496: PUSH
31497: EMPTY
31498: LIST
31499: PPUSH
31500: CALL_OW 69
31504: IN
31505: IFFALSE 31524
// result := IsInUnit ( unit ) else
31507: LD_ADDR_VAR 0 2
31511: PUSH
31512: LD_VAR 0 1
31516: PPUSH
31517: CALL_OW 310
31521: ST_TO_ADDR
31522: GO 31532
// result := false ;
31524: LD_ADDR_VAR 0 2
31528: PUSH
31529: LD_INT 0
31531: ST_TO_ADDR
// end ;
31532: LD_VAR 0 2
31536: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31537: LD_INT 0
31539: PPUSH
31540: PPUSH
31541: PPUSH
// if not GetControl ( veh ) = control_manual then
31542: LD_VAR 0 1
31546: PPUSH
31547: CALL_OW 263
31551: PUSH
31552: LD_INT 1
31554: EQUAL
31555: NOT
31556: IFFALSE 31568
// result := false else
31558: LD_ADDR_VAR 0 2
31562: PUSH
31563: LD_INT 0
31565: ST_TO_ADDR
31566: GO 31713
// if veh in FilterAllUnits ( [ f_empty ] ) then
31568: LD_VAR 0 1
31572: PUSH
31573: LD_INT 58
31575: PUSH
31576: EMPTY
31577: LIST
31578: PPUSH
31579: CALL_OW 69
31583: IN
31584: IFFALSE 31596
// result := false else
31586: LD_ADDR_VAR 0 2
31590: PUSH
31591: LD_INT 0
31593: ST_TO_ADDR
31594: GO 31713
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31596: LD_ADDR_VAR 0 4
31600: PUSH
31601: LD_INT 22
31603: PUSH
31604: LD_VAR 0 1
31608: PPUSH
31609: CALL_OW 255
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 55
31620: PUSH
31621: EMPTY
31622: LIST
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PPUSH
31628: CALL_OW 69
31632: ST_TO_ADDR
// if not filter then
31633: LD_VAR 0 4
31637: NOT
31638: IFFALSE 31650
// result := false else
31640: LD_ADDR_VAR 0 2
31644: PUSH
31645: LD_INT 0
31647: ST_TO_ADDR
31648: GO 31713
// for i = 1 to filter do
31650: LD_ADDR_VAR 0 3
31654: PUSH
31655: DOUBLE
31656: LD_INT 1
31658: DEC
31659: ST_TO_ADDR
31660: LD_VAR 0 4
31664: PUSH
31665: FOR_TO
31666: IFFALSE 31711
// if IsDriver ( filter [ i ] ) = veh then
31668: LD_VAR 0 4
31672: PUSH
31673: LD_VAR 0 3
31677: ARRAY
31678: PPUSH
31679: CALL 31486 0 1
31683: PUSH
31684: LD_VAR 0 1
31688: EQUAL
31689: IFFALSE 31709
// begin result := filter [ i ] ;
31691: LD_ADDR_VAR 0 2
31695: PUSH
31696: LD_VAR 0 4
31700: PUSH
31701: LD_VAR 0 3
31705: ARRAY
31706: ST_TO_ADDR
// break ;
31707: GO 31711
// end ;
31709: GO 31665
31711: POP
31712: POP
// end ; end ;
31713: LD_VAR 0 2
31717: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31718: LD_INT 0
31720: PPUSH
31721: PPUSH
// if BuildingStatus ( b ) = bs_build then
31722: LD_VAR 0 2
31726: PPUSH
31727: CALL_OW 461
31731: PUSH
31732: LD_INT 1
31734: EQUAL
31735: IFFALSE 31795
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31737: LD_VAR 0 1
31741: PPUSH
31742: LD_STRING h
31744: PUSH
31745: LD_VAR 0 2
31749: PPUSH
31750: CALL_OW 250
31754: PUSH
31755: LD_VAR 0 2
31759: PPUSH
31760: CALL_OW 251
31764: PUSH
31765: LD_VAR 0 2
31769: PUSH
31770: LD_INT 0
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: LD_INT 0
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: LIST
31783: LIST
31784: LIST
31785: LIST
31786: LIST
31787: PUSH
31788: EMPTY
31789: LIST
31790: PPUSH
31791: CALL_OW 446
// end ;
31795: LD_VAR 0 3
31799: RET
// export function Compare ( val1 , val2 ) ; begin
31800: LD_INT 0
31802: PPUSH
// if val1 = val2 then
31803: LD_VAR 0 1
31807: PUSH
31808: LD_VAR 0 2
31812: EQUAL
31813: IFFALSE 31825
// result := true else
31815: LD_ADDR_VAR 0 3
31819: PUSH
31820: LD_INT 1
31822: ST_TO_ADDR
31823: GO 31833
// result := false ;
31825: LD_ADDR_VAR 0 3
31829: PUSH
31830: LD_INT 0
31832: ST_TO_ADDR
// end ;
31833: LD_VAR 0 3
31837: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31838: LD_INT 0
31840: PPUSH
31841: PPUSH
// result := true ;
31842: LD_ADDR_VAR 0 3
31846: PUSH
31847: LD_INT 1
31849: ST_TO_ADDR
// if array1 = array2 then
31850: LD_VAR 0 1
31854: PUSH
31855: LD_VAR 0 2
31859: EQUAL
31860: IFFALSE 31925
// begin for i = 1 to array1 do
31862: LD_ADDR_VAR 0 4
31866: PUSH
31867: DOUBLE
31868: LD_INT 1
31870: DEC
31871: ST_TO_ADDR
31872: LD_VAR 0 1
31876: PUSH
31877: FOR_TO
31878: IFFALSE 31921
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31880: LD_VAR 0 1
31884: PUSH
31885: LD_VAR 0 4
31889: ARRAY
31890: PPUSH
31891: LD_VAR 0 2
31895: PUSH
31896: LD_VAR 0 4
31900: ARRAY
31901: PPUSH
31902: CALL 31800 0 2
31906: NOT
31907: IFFALSE 31919
// begin result := false ;
31909: LD_ADDR_VAR 0 3
31913: PUSH
31914: LD_INT 0
31916: ST_TO_ADDR
// break ;
31917: GO 31921
// end ;
31919: GO 31877
31921: POP
31922: POP
// end else
31923: GO 31933
// result := false ;
31925: LD_ADDR_VAR 0 3
31929: PUSH
31930: LD_INT 0
31932: ST_TO_ADDR
// end ;
31933: LD_VAR 0 3
31937: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31938: LD_INT 0
31940: PPUSH
31941: PPUSH
// result := false ;
31942: LD_ADDR_VAR 0 3
31946: PUSH
31947: LD_INT 0
31949: ST_TO_ADDR
// for j = 1 to e2 do
31950: LD_ADDR_VAR 0 4
31954: PUSH
31955: DOUBLE
31956: LD_INT 1
31958: DEC
31959: ST_TO_ADDR
31960: LD_VAR 0 2
31964: PUSH
31965: FOR_TO
31966: IFFALSE 32000
// if Compare ( e1 , e2 [ j ] ) then
31968: LD_VAR 0 1
31972: PPUSH
31973: LD_VAR 0 2
31977: PUSH
31978: LD_VAR 0 4
31982: ARRAY
31983: PPUSH
31984: CALL 31800 0 2
31988: IFFALSE 31998
// result := true ;
31990: LD_ADDR_VAR 0 3
31994: PUSH
31995: LD_INT 1
31997: ST_TO_ADDR
31998: GO 31965
32000: POP
32001: POP
// end ;
32002: LD_VAR 0 3
32006: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32007: LD_INT 0
32009: PPUSH
32010: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32011: LD_VAR 0 1
32015: PPUSH
32016: LD_STRING C
32018: PUSH
32019: LD_VAR 0 2
32023: PUSH
32024: LD_VAR 0 3
32028: PUSH
32029: LD_INT 0
32031: PUSH
32032: LD_INT 0
32034: PUSH
32035: LD_INT 0
32037: PUSH
32038: LD_INT 0
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: PUSH
32050: LD_STRING v
32052: PUSH
32053: LD_VAR 0 4
32057: PPUSH
32058: CALL_OW 250
32062: PUSH
32063: LD_VAR 0 4
32067: PPUSH
32068: CALL_OW 251
32072: PUSH
32073: LD_VAR 0 4
32077: PUSH
32078: LD_INT 0
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: PPUSH
32100: CALL_OW 446
// end ;
32104: LD_VAR 0 5
32108: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32109: LD_INT 0
32111: PPUSH
32112: PPUSH
32113: PPUSH
// linked := UnitsLinked ( unit ) ;
32114: LD_ADDR_VAR 0 4
32118: PUSH
32119: LD_VAR 0 1
32123: PPUSH
32124: CALL_OW 432
32128: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32129: LD_ADDR_VAR 0 3
32133: PUSH
32134: LD_VAR 0 1
32138: PPUSH
32139: LD_INT 3
32141: PPUSH
32142: CALL_OW 259
32146: ST_TO_ADDR
// if sk > linked then
32147: LD_VAR 0 3
32151: PUSH
32152: LD_VAR 0 4
32156: GREATER
32157: IFFALSE 32169
// result := true else
32159: LD_ADDR_VAR 0 2
32163: PUSH
32164: LD_INT 1
32166: ST_TO_ADDR
32167: GO 32177
// result := false ;
32169: LD_ADDR_VAR 0 2
32173: PUSH
32174: LD_INT 0
32176: ST_TO_ADDR
// end ;
32177: LD_VAR 0 2
32181: RET
// export function NotTask ( unit ) ; begin
32182: LD_INT 0
32184: PPUSH
// result := true ;
32185: LD_ADDR_VAR 0 2
32189: PUSH
32190: LD_INT 1
32192: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32193: LD_VAR 0 1
32197: PPUSH
32198: CALL_OW 437
32202: PUSH
32203: LD_VAR 0 1
32207: PPUSH
32208: CALL_OW 314
32212: OR
32213: IFFALSE 32223
// result := false ;
32215: LD_ADDR_VAR 0 2
32219: PUSH
32220: LD_INT 0
32222: ST_TO_ADDR
// end ;
32223: LD_VAR 0 2
32227: RET
// export function WantHeal ( sci , unit ) ; begin
32228: LD_INT 0
32230: PPUSH
// if GetTaskList ( sci ) > 0 then
32231: LD_VAR 0 1
32235: PPUSH
32236: CALL_OW 437
32240: PUSH
32241: LD_INT 0
32243: GREATER
32244: IFFALSE 32314
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32246: LD_VAR 0 1
32250: PPUSH
32251: CALL_OW 437
32255: PUSH
32256: LD_INT 1
32258: ARRAY
32259: PUSH
32260: LD_INT 1
32262: ARRAY
32263: PUSH
32264: LD_STRING l
32266: EQUAL
32267: PUSH
32268: LD_VAR 0 1
32272: PPUSH
32273: CALL_OW 437
32277: PUSH
32278: LD_INT 1
32280: ARRAY
32281: PUSH
32282: LD_INT 4
32284: ARRAY
32285: PUSH
32286: LD_VAR 0 2
32290: EQUAL
32291: AND
32292: IFFALSE 32304
// result := true else
32294: LD_ADDR_VAR 0 3
32298: PUSH
32299: LD_INT 1
32301: ST_TO_ADDR
32302: GO 32312
// result := false ;
32304: LD_ADDR_VAR 0 3
32308: PUSH
32309: LD_INT 0
32311: ST_TO_ADDR
// end else
32312: GO 32322
// result := false ;
32314: LD_ADDR_VAR 0 3
32318: PUSH
32319: LD_INT 0
32321: ST_TO_ADDR
// end ;
32322: LD_VAR 0 3
32326: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32327: LD_INT 0
32329: PPUSH
32330: PPUSH
32331: PPUSH
32332: PPUSH
32333: PPUSH
// dist := 99999 ;
32334: LD_ADDR_VAR 0 7
32338: PUSH
32339: LD_INT 99999
32341: ST_TO_ADDR
// un := - 1 ;
32342: LD_ADDR_VAR 0 6
32346: PUSH
32347: LD_INT 1
32349: NEG
32350: ST_TO_ADDR
// if units1 and units2 then
32351: LD_VAR 0 1
32355: PUSH
32356: LD_VAR 0 2
32360: AND
32361: IFFALSE 32449
// for i in units1 do
32363: LD_ADDR_VAR 0 4
32367: PUSH
32368: LD_VAR 0 1
32372: PUSH
32373: FOR_IN
32374: IFFALSE 32447
// for j in units2 do
32376: LD_ADDR_VAR 0 5
32380: PUSH
32381: LD_VAR 0 2
32385: PUSH
32386: FOR_IN
32387: IFFALSE 32443
// if GetDistUnits ( i , j ) < dist then
32389: LD_VAR 0 4
32393: PPUSH
32394: LD_VAR 0 5
32398: PPUSH
32399: CALL_OW 296
32403: PUSH
32404: LD_VAR 0 7
32408: LESS
32409: IFFALSE 32441
// begin un := i ;
32411: LD_ADDR_VAR 0 6
32415: PUSH
32416: LD_VAR 0 4
32420: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32421: LD_ADDR_VAR 0 7
32425: PUSH
32426: LD_VAR 0 4
32430: PPUSH
32431: LD_VAR 0 5
32435: PPUSH
32436: CALL_OW 296
32440: ST_TO_ADDR
// end ;
32441: GO 32386
32443: POP
32444: POP
32445: GO 32373
32447: POP
32448: POP
// result := [ un , dist ] ;
32449: LD_ADDR_VAR 0 3
32453: PUSH
32454: LD_VAR 0 6
32458: PUSH
32459: LD_VAR 0 7
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: ST_TO_ADDR
// end ;
32468: LD_VAR 0 3
32472: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32473: LD_INT 0
32475: PPUSH
32476: PPUSH
32477: PPUSH
32478: PPUSH
32479: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32480: LD_VAR 0 1
32484: NOT
32485: PUSH
32486: LD_VAR 0 1
32490: PPUSH
32491: CALL_OW 256
32495: PUSH
32496: LD_INT 250
32498: LESS
32499: OR
32500: PUSH
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 314
32510: PUSH
32511: LD_VAR 0 1
32515: PPUSH
32516: CALL_OW 261
32520: PUSH
32521: LD_INT 20
32523: GREATER
32524: AND
32525: OR
32526: IFFALSE 32530
// exit ;
32528: GO 32904
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32530: LD_VAR 0 1
32534: PPUSH
32535: CALL_OW 261
32539: PUSH
32540: LD_INT 20
32542: LESS
32543: PUSH
32544: LD_VAR 0 1
32548: PPUSH
32549: CALL_OW 110
32553: PUSH
32554: LD_INT 21
32556: EQUAL
32557: NOT
32558: AND
32559: IFFALSE 32595
// begin ComStop ( bulldozer ) ;
32561: LD_VAR 0 1
32565: PPUSH
32566: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32570: LD_VAR 0 1
32574: PPUSH
32575: LD_INT 21
32577: PPUSH
32578: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32582: LD_VAR 0 1
32586: PPUSH
32587: CALL 26107 0 1
// exit ;
32591: GO 32904
// end else
32593: GO 32622
// if GetFuel ( bulldozer ) > 20 then
32595: LD_VAR 0 1
32599: PPUSH
32600: CALL_OW 261
32604: PUSH
32605: LD_INT 20
32607: GREATER
32608: IFFALSE 32622
// SetTag ( bulldozer , 0 ) ;
32610: LD_VAR 0 1
32614: PPUSH
32615: LD_INT 0
32617: PPUSH
32618: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32622: LD_ADDR_VAR 0 5
32626: PUSH
32627: LD_VAR 0 2
32631: PPUSH
32632: CALL_OW 353
32636: ST_TO_ADDR
// tmp := [ ] ;
32637: LD_ADDR_VAR 0 6
32641: PUSH
32642: EMPTY
32643: ST_TO_ADDR
// for i = 1 to list do
32644: LD_ADDR_VAR 0 4
32648: PUSH
32649: DOUBLE
32650: LD_INT 1
32652: DEC
32653: ST_TO_ADDR
32654: LD_VAR 0 5
32658: PUSH
32659: FOR_TO
32660: IFFALSE 32758
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32662: LD_VAR 0 5
32666: PUSH
32667: LD_VAR 0 4
32671: ARRAY
32672: PUSH
32673: LD_INT 1
32675: ARRAY
32676: PPUSH
32677: LD_VAR 0 5
32681: PUSH
32682: LD_VAR 0 4
32686: ARRAY
32687: PUSH
32688: LD_INT 2
32690: ARRAY
32691: PPUSH
32692: CALL_OW 554
32696: IFFALSE 32756
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32698: LD_ADDR_VAR 0 6
32702: PUSH
32703: LD_VAR 0 6
32707: PPUSH
32708: LD_VAR 0 6
32712: PUSH
32713: LD_INT 1
32715: PLUS
32716: PPUSH
32717: LD_VAR 0 5
32721: PUSH
32722: LD_VAR 0 4
32726: ARRAY
32727: PUSH
32728: LD_INT 1
32730: ARRAY
32731: PUSH
32732: LD_VAR 0 5
32736: PUSH
32737: LD_VAR 0 4
32741: ARRAY
32742: PUSH
32743: LD_INT 2
32745: ARRAY
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PPUSH
32751: CALL_OW 1
32755: ST_TO_ADDR
// end ;
32756: GO 32659
32758: POP
32759: POP
// ComStop ( bulldozer ) ;
32760: LD_VAR 0 1
32764: PPUSH
32765: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32769: LD_ADDR_VAR 0 7
32773: PUSH
32774: LD_VAR 0 1
32778: PPUSH
32779: CALL_OW 250
32783: PUSH
32784: LD_VAR 0 1
32788: PPUSH
32789: CALL_OW 251
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: ST_TO_ADDR
// for i = tmp downto 1 do
32798: LD_ADDR_VAR 0 4
32802: PUSH
32803: DOUBLE
32804: LD_VAR 0 6
32808: INC
32809: ST_TO_ADDR
32810: LD_INT 1
32812: PUSH
32813: FOR_DOWNTO
32814: IFFALSE 32902
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32816: LD_ADDR_VAR 0 7
32820: PUSH
32821: LD_VAR 0 7
32825: PUSH
32826: LD_INT 1
32828: ARRAY
32829: PPUSH
32830: LD_VAR 0 7
32834: PUSH
32835: LD_INT 2
32837: ARRAY
32838: PPUSH
32839: LD_VAR 0 6
32843: PPUSH
32844: CALL 33005 0 3
32848: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32849: LD_VAR 0 1
32853: PPUSH
32854: LD_VAR 0 7
32858: PUSH
32859: LD_INT 1
32861: ARRAY
32862: PPUSH
32863: LD_VAR 0 7
32867: PUSH
32868: LD_INT 2
32870: ARRAY
32871: PPUSH
32872: CALL 32909 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32876: LD_ADDR_VAR 0 6
32880: PUSH
32881: LD_VAR 0 6
32885: PPUSH
32886: LD_VAR 0 7
32890: PUSH
32891: LD_INT 3
32893: ARRAY
32894: PPUSH
32895: CALL_OW 3
32899: ST_TO_ADDR
// end ;
32900: GO 32813
32902: POP
32903: POP
// end ;
32904: LD_VAR 0 3
32908: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32909: LD_INT 0
32911: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32912: LD_VAR 0 2
32916: PPUSH
32917: LD_VAR 0 3
32921: PPUSH
32922: CALL_OW 351
32926: PUSH
32927: LD_VAR 0 2
32931: PPUSH
32932: LD_VAR 0 3
32936: PPUSH
32937: CALL_OW 554
32941: AND
32942: PUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 3
32952: PPUSH
32953: CALL_OW 488
32957: AND
32958: PUSH
32959: LD_VAR 0 2
32963: PPUSH
32964: LD_VAR 0 3
32968: PPUSH
32969: CALL_OW 428
32973: PUSH
32974: LD_INT 1
32976: NEG
32977: EQUAL
32978: AND
32979: IFFALSE 33000
// AddComMoveXY ( bulldozer , x , y ) ;
32981: LD_VAR 0 1
32985: PPUSH
32986: LD_VAR 0 2
32990: PPUSH
32991: LD_VAR 0 3
32995: PPUSH
32996: CALL_OW 171
// end ;
33000: LD_VAR 0 4
33004: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33005: LD_INT 0
33007: PPUSH
33008: PPUSH
33009: PPUSH
33010: PPUSH
33011: PPUSH
33012: PPUSH
33013: PPUSH
// dist := 99999 ;
33014: LD_ADDR_VAR 0 6
33018: PUSH
33019: LD_INT 99999
33021: ST_TO_ADDR
// for i = 1 to list do
33022: LD_ADDR_VAR 0 5
33026: PUSH
33027: DOUBLE
33028: LD_INT 1
33030: DEC
33031: ST_TO_ADDR
33032: LD_VAR 0 3
33036: PUSH
33037: FOR_TO
33038: IFFALSE 33176
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33040: LD_ADDR_VAR 0 7
33044: PUSH
33045: LD_VAR 0 1
33049: PPUSH
33050: LD_VAR 0 2
33054: PPUSH
33055: LD_VAR 0 3
33059: PUSH
33060: LD_VAR 0 5
33064: ARRAY
33065: PUSH
33066: LD_INT 1
33068: ARRAY
33069: PPUSH
33070: LD_VAR 0 3
33074: PUSH
33075: LD_VAR 0 5
33079: ARRAY
33080: PUSH
33081: LD_INT 2
33083: ARRAY
33084: PPUSH
33085: CALL_OW 298
33089: ST_TO_ADDR
// if d = 0 then
33090: LD_VAR 0 7
33094: PUSH
33095: LD_INT 0
33097: EQUAL
33098: IFFALSE 33102
// continue ;
33100: GO 33037
// if d < dist then
33102: LD_VAR 0 7
33106: PUSH
33107: LD_VAR 0 6
33111: LESS
33112: IFFALSE 33174
// begin _x := list [ i ] [ 1 ] ;
33114: LD_ADDR_VAR 0 8
33118: PUSH
33119: LD_VAR 0 3
33123: PUSH
33124: LD_VAR 0 5
33128: ARRAY
33129: PUSH
33130: LD_INT 1
33132: ARRAY
33133: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33134: LD_ADDR_VAR 0 9
33138: PUSH
33139: LD_VAR 0 3
33143: PUSH
33144: LD_VAR 0 5
33148: ARRAY
33149: PUSH
33150: LD_INT 2
33152: ARRAY
33153: ST_TO_ADDR
// _i := i ;
33154: LD_ADDR_VAR 0 10
33158: PUSH
33159: LD_VAR 0 5
33163: ST_TO_ADDR
// dist := d ;
33164: LD_ADDR_VAR 0 6
33168: PUSH
33169: LD_VAR 0 7
33173: ST_TO_ADDR
// end ; end ;
33174: GO 33037
33176: POP
33177: POP
// result := [ _x , _y , _i , dist ] ;
33178: LD_ADDR_VAR 0 4
33182: PUSH
33183: LD_VAR 0 8
33187: PUSH
33188: LD_VAR 0 9
33192: PUSH
33193: LD_VAR 0 10
33197: PUSH
33198: LD_VAR 0 6
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: ST_TO_ADDR
// end ;
33209: LD_VAR 0 4
33213: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33214: LD_INT 0
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
33220: PPUSH
// for i = 1 to list do
33221: LD_ADDR_VAR 0 5
33225: PUSH
33226: DOUBLE
33227: LD_INT 1
33229: DEC
33230: ST_TO_ADDR
33231: LD_VAR 0 1
33235: PUSH
33236: FOR_TO
33237: IFFALSE 33551
// begin for j = list downto 2 do
33239: LD_ADDR_VAR 0 6
33243: PUSH
33244: DOUBLE
33245: LD_VAR 0 1
33249: INC
33250: ST_TO_ADDR
33251: LD_INT 2
33253: PUSH
33254: FOR_DOWNTO
33255: IFFALSE 33547
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: ARRAY
33277: PUSH
33278: LD_INT 1
33280: ARRAY
33281: PPUSH
33282: LD_VAR 0 1
33286: PUSH
33287: LD_VAR 0 6
33291: ARRAY
33292: PUSH
33293: LD_INT 2
33295: ARRAY
33296: PPUSH
33297: CALL_OW 298
33301: PUSH
33302: LD_VAR 0 2
33306: PPUSH
33307: LD_VAR 0 3
33311: PPUSH
33312: LD_VAR 0 1
33316: PUSH
33317: LD_VAR 0 6
33321: PUSH
33322: LD_INT 1
33324: MINUS
33325: ARRAY
33326: PUSH
33327: LD_INT 1
33329: ARRAY
33330: PPUSH
33331: LD_VAR 0 1
33335: PUSH
33336: LD_VAR 0 6
33340: PUSH
33341: LD_INT 1
33343: MINUS
33344: ARRAY
33345: PUSH
33346: LD_INT 2
33348: ARRAY
33349: PPUSH
33350: CALL_OW 298
33354: LESS
33355: IFFALSE 33545
// begin _x := list [ j ] [ 1 ] ;
33357: LD_ADDR_VAR 0 7
33361: PUSH
33362: LD_VAR 0 1
33366: PUSH
33367: LD_VAR 0 6
33371: ARRAY
33372: PUSH
33373: LD_INT 1
33375: ARRAY
33376: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33377: LD_ADDR_VAR 0 8
33381: PUSH
33382: LD_VAR 0 1
33386: PUSH
33387: LD_VAR 0 6
33391: ARRAY
33392: PUSH
33393: LD_INT 2
33395: ARRAY
33396: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33397: LD_ADDR_VAR 0 1
33401: PUSH
33402: LD_VAR 0 1
33406: PPUSH
33407: LD_VAR 0 6
33411: PPUSH
33412: LD_INT 1
33414: PPUSH
33415: LD_VAR 0 1
33419: PUSH
33420: LD_VAR 0 6
33424: PUSH
33425: LD_INT 1
33427: MINUS
33428: ARRAY
33429: PUSH
33430: LD_INT 1
33432: ARRAY
33433: PPUSH
33434: CALL 30843 0 4
33438: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33439: LD_ADDR_VAR 0 1
33443: PUSH
33444: LD_VAR 0 1
33448: PPUSH
33449: LD_VAR 0 6
33453: PPUSH
33454: LD_INT 2
33456: PPUSH
33457: LD_VAR 0 1
33461: PUSH
33462: LD_VAR 0 6
33466: PUSH
33467: LD_INT 1
33469: MINUS
33470: ARRAY
33471: PUSH
33472: LD_INT 2
33474: ARRAY
33475: PPUSH
33476: CALL 30843 0 4
33480: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33481: LD_ADDR_VAR 0 1
33485: PUSH
33486: LD_VAR 0 1
33490: PPUSH
33491: LD_VAR 0 6
33495: PUSH
33496: LD_INT 1
33498: MINUS
33499: PPUSH
33500: LD_INT 1
33502: PPUSH
33503: LD_VAR 0 7
33507: PPUSH
33508: CALL 30843 0 4
33512: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33513: LD_ADDR_VAR 0 1
33517: PUSH
33518: LD_VAR 0 1
33522: PPUSH
33523: LD_VAR 0 6
33527: PUSH
33528: LD_INT 1
33530: MINUS
33531: PPUSH
33532: LD_INT 2
33534: PPUSH
33535: LD_VAR 0 8
33539: PPUSH
33540: CALL 30843 0 4
33544: ST_TO_ADDR
// end ; end ;
33545: GO 33254
33547: POP
33548: POP
// end ;
33549: GO 33236
33551: POP
33552: POP
// result := list ;
33553: LD_ADDR_VAR 0 4
33557: PUSH
33558: LD_VAR 0 1
33562: ST_TO_ADDR
// end ;
33563: LD_VAR 0 4
33567: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33568: LD_INT 0
33570: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33571: LD_ADDR_VAR 0 5
33575: PUSH
33576: LD_VAR 0 1
33580: PPUSH
33581: LD_VAR 0 2
33585: PPUSH
33586: CALL_OW 546
33590: PUSH
33591: LD_INT 2
33593: ARRAY
33594: PUSH
33595: LD_VAR 0 3
33599: PPUSH
33600: LD_VAR 0 4
33604: PPUSH
33605: CALL_OW 546
33609: PUSH
33610: LD_INT 2
33612: ARRAY
33613: MINUS
33614: ST_TO_ADDR
// if result < 0 then
33615: LD_VAR 0 5
33619: PUSH
33620: LD_INT 0
33622: LESS
33623: IFFALSE 33640
// result := result * - 1 ;
33625: LD_ADDR_VAR 0 5
33629: PUSH
33630: LD_VAR 0 5
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: MUL
33639: ST_TO_ADDR
// end ;
33640: LD_VAR 0 5
33644: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33645: LD_INT 0
33647: PPUSH
33648: PPUSH
// area = ListEnvironmentArea ( area ) ;
33649: LD_ADDR_VAR 0 2
33653: PUSH
33654: LD_VAR 0 2
33658: PPUSH
33659: CALL_OW 353
33663: ST_TO_ADDR
// if bulldozer > 0 then
33664: LD_VAR 0 1
33668: PUSH
33669: LD_INT 0
33671: GREATER
33672: IFFALSE 33783
// for i = area downto 1 do
33674: LD_ADDR_VAR 0 4
33678: PUSH
33679: DOUBLE
33680: LD_VAR 0 2
33684: INC
33685: ST_TO_ADDR
33686: LD_INT 1
33688: PUSH
33689: FOR_DOWNTO
33690: IFFALSE 33781
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33692: LD_VAR 0 2
33696: PUSH
33697: LD_VAR 0 4
33701: ARRAY
33702: PUSH
33703: LD_INT 1
33705: ARRAY
33706: PPUSH
33707: LD_VAR 0 2
33711: PUSH
33712: LD_VAR 0 4
33716: ARRAY
33717: PUSH
33718: LD_INT 2
33720: ARRAY
33721: PPUSH
33722: CALL_OW 351
33726: IFFALSE 33779
// if not HasTask ( bulldozer ) then
33728: LD_VAR 0 1
33732: PPUSH
33733: CALL_OW 314
33737: NOT
33738: IFFALSE 33779
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33740: LD_VAR 0 1
33744: PPUSH
33745: LD_VAR 0 2
33749: PUSH
33750: LD_VAR 0 4
33754: ARRAY
33755: PUSH
33756: LD_INT 1
33758: ARRAY
33759: PPUSH
33760: LD_VAR 0 2
33764: PUSH
33765: LD_VAR 0 4
33769: ARRAY
33770: PUSH
33771: LD_INT 2
33773: ARRAY
33774: PPUSH
33775: CALL_OW 171
33779: GO 33689
33781: POP
33782: POP
// end ;
33783: LD_VAR 0 3
33787: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33788: LD_INT 0
33790: PPUSH
33791: PPUSH
33792: PPUSH
33793: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33794: LD_ADDR_VAR 0 6
33798: PUSH
33799: LD_INT 22
33801: PUSH
33802: LD_VAR 0 1
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 21
33813: PUSH
33814: LD_VAR 0 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PPUSH
33827: CALL_OW 69
33831: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33832: LD_ADDR_VAR 0 7
33836: PUSH
33837: LD_VAR 0 3
33841: PPUSH
33842: LD_INT 22
33844: PUSH
33845: LD_VAR 0 1
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 21
33856: PUSH
33857: LD_VAR 0 2
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PPUSH
33870: CALL_OW 70
33874: ST_TO_ADDR
// if tmp and pom then
33875: LD_VAR 0 6
33879: PUSH
33880: LD_VAR 0 7
33884: AND
33885: IFFALSE 33905
// result := tmp diff pom else
33887: LD_ADDR_VAR 0 4
33891: PUSH
33892: LD_VAR 0 6
33896: PUSH
33897: LD_VAR 0 7
33901: DIFF
33902: ST_TO_ADDR
33903: GO 33913
// result := false ;
33905: LD_ADDR_VAR 0 4
33909: PUSH
33910: LD_INT 0
33912: ST_TO_ADDR
// end ;
33913: LD_VAR 0 4
33917: RET
// export function SavePosition ( unit ) ; begin
33918: LD_INT 0
33920: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33921: LD_VAR 0 1
33925: PPUSH
33926: LD_VAR 0 1
33930: PPUSH
33931: CALL_OW 250
33935: PPUSH
33936: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33940: LD_VAR 0 1
33944: PPUSH
33945: LD_VAR 0 1
33949: PPUSH
33950: CALL_OW 251
33954: PPUSH
33955: CALL_OW 232
// end ;
33959: LD_VAR 0 2
33963: RET
// export function GetPosition ( unit ) ; begin
33964: LD_INT 0
33966: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33967: LD_ADDR_VAR 0 2
33971: PUSH
33972: LD_VAR 0 1
33976: PPUSH
33977: CALL_OW 252
33981: PUSH
33982: LD_VAR 0 1
33986: PPUSH
33987: CALL_OW 253
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: ST_TO_ADDR
// end ;
33996: LD_VAR 0 2
34000: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34001: LD_INT 0
34003: PPUSH
// if unit in unreachableList then
34004: LD_VAR 0 1
34008: PUSH
34009: LD_EXP 32
34013: IN
34014: IFFALSE 34032
// unreachableList := unreachableList diff unit ;
34016: LD_ADDR_EXP 32
34020: PUSH
34021: LD_EXP 32
34025: PUSH
34026: LD_VAR 0 1
34030: DIFF
34031: ST_TO_ADDR
// if ValidHex ( x , y ) then
34032: LD_VAR 0 2
34036: PPUSH
34037: LD_VAR 0 3
34041: PPUSH
34042: CALL_OW 488
34046: IFFALSE 34072
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34048: LD_VAR 0 1
34052: PPUSH
34053: LD_VAR 0 2
34057: PPUSH
34058: LD_VAR 0 3
34062: PPUSH
34063: CALL_OW 428
34067: PPUSH
34068: CALL_OW 115
// Wait ( 3 ) ;
34072: LD_INT 3
34074: PPUSH
34075: CALL_OW 67
// if unit in unreachableList then
34079: LD_VAR 0 1
34083: PUSH
34084: LD_EXP 32
34088: IN
34089: IFFALSE 34101
// result := false else
34091: LD_ADDR_VAR 0 4
34095: PUSH
34096: LD_INT 0
34098: ST_TO_ADDR
34099: GO 34109
// result := true ;
34101: LD_ADDR_VAR 0 4
34105: PUSH
34106: LD_INT 1
34108: ST_TO_ADDR
// end ; end_of_file
34109: LD_VAR 0 4
34113: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34114: LD_EXP 33
34118: IFFALSE 34180
34120: GO 34122
34122: DISABLE
34123: LD_INT 0
34125: PPUSH
// begin enable ;
34126: ENABLE
// for i = 1 to mc_crates_list do
34127: LD_ADDR_VAR 0 1
34131: PUSH
34132: DOUBLE
34133: LD_INT 1
34135: DEC
34136: ST_TO_ADDR
34137: LD_EXP 34
34141: PUSH
34142: FOR_TO
34143: IFFALSE 34174
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34145: LD_EXP 34
34149: PUSH
34150: LD_VAR 0 1
34154: ARRAY
34155: PPUSH
34156: LD_INT 5
34158: PPUSH
34159: LD_INT 50
34161: PPUSH
34162: LD_INT 700
34164: PPUSH
34165: LD_INT 20
34167: PPUSH
34168: CALL 24289 0 5
34172: GO 34142
34174: POP
34175: POP
// MC_Game ( ) ;
34176: CALL 34183 0 0
// end ;
34180: PPOPN 1
34182: END
// export function MC_Game ( ) ; var i , side , un ; begin
34183: LD_INT 0
34185: PPUSH
34186: PPUSH
34187: PPUSH
34188: PPUSH
// if not isTest then
34189: LD_EXP 1
34193: NOT
34194: IFFALSE 34214
// MC_Show ( [ #tick , tick ] ) else
34196: LD_STRING #tick
34198: PUSH
34199: LD_OWVAR 1
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PPUSH
34208: CALL 8327 0 1
34212: GO 34223
// MC_Show ( debug_string ) ;
34214: LD_EXP 2
34218: PPUSH
34219: CALL 8327 0 1
// for side = 1 to 8 do
34223: LD_ADDR_VAR 0 3
34227: PUSH
34228: DOUBLE
34229: LD_INT 1
34231: DEC
34232: ST_TO_ADDR
34233: LD_INT 8
34235: PUSH
34236: FOR_TO
34237: IFFALSE 36237
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34239: LD_EXP 41
34243: PUSH
34244: LD_VAR 0 3
34248: ARRAY
34249: PUSH
34250: LD_INT 0
34252: EQUAL
34253: PUSH
34254: LD_VAR 0 3
34258: PPUSH
34259: EMPTY
34260: PPUSH
34261: CALL 11544 0 2
34265: PUSH
34266: LD_INT 0
34268: EQUAL
34269: OR
34270: IFFALSE 34274
// continue ;
34272: GO 34236
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34274: LD_VAR 0 3
34278: PPUSH
34279: LD_VAR 0 3
34283: PPUSH
34284: CALL 24810 0 1
34288: PPUSH
34289: CALL 36244 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34293: LD_EXP 73
34297: PUSH
34298: LD_VAR 0 3
34302: ARRAY
34303: PUSH
34304: LD_INT 1
34306: ARRAY
34307: PUSH
34308: LD_INT 0
34310: GREATER
34311: PUSH
34312: LD_EXP 71
34316: PUSH
34317: LD_VAR 0 3
34321: ARRAY
34322: PUSH
34323: LD_INT 1
34325: ARRAY
34326: PUSH
34327: LD_INT 0
34329: EQUAL
34330: AND
34331: PUSH
34332: LD_VAR 0 3
34336: PPUSH
34337: LD_INT 7
34339: PPUSH
34340: EMPTY
34341: PPUSH
34342: CALL 12112 0 3
34346: NOT
34347: AND
34348: IFFALSE 34419
// begin if side = 1 then
34350: LD_VAR 0 3
34354: PUSH
34355: LD_INT 1
34357: EQUAL
34358: IFFALSE 34367
// RaiseSailEvent ( 101 ) ;
34360: LD_INT 101
34362: PPUSH
34363: CALL_OW 427
// if side = 4 then
34367: LD_VAR 0 3
34371: PUSH
34372: LD_INT 4
34374: EQUAL
34375: IFFALSE 34384
// RaiseSailEvent ( 102 ) ;
34377: LD_INT 102
34379: PPUSH
34380: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34384: LD_ADDR_VAR 0 2
34388: PUSH
34389: LD_EXP 73
34393: PUSH
34394: LD_VAR 0 3
34398: ARRAY
34399: PUSH
34400: FOR_IN
34401: IFFALSE 34417
// SetTag ( i , 7 ) ;
34403: LD_VAR 0 2
34407: PPUSH
34408: LD_INT 7
34410: PPUSH
34411: CALL_OW 109
34415: GO 34400
34417: POP
34418: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34419: LD_VAR 0 3
34423: PPUSH
34424: LD_INT 7
34426: PPUSH
34427: EMPTY
34428: PPUSH
34429: CALL 12112 0 3
34433: IFFALSE 34459
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34435: LD_VAR 0 3
34439: PPUSH
34440: LD_VAR 0 3
34444: PPUSH
34445: LD_INT 7
34447: PPUSH
34448: EMPTY
34449: PPUSH
34450: CALL 12112 0 3
34454: PPUSH
34455: CALL 8254 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34459: LD_VAR 0 3
34463: PPUSH
34464: CALL 17792 0 1
34468: PUSH
34469: LD_VAR 0 3
34473: PPUSH
34474: CALL 11448 0 1
34478: AND
34479: IFFALSE 34490
// MCL_Start ( side ) ;
34481: LD_VAR 0 3
34485: PPUSH
34486: CALL 17749 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34490: LD_ADDR_EXP 37
34494: PUSH
34495: LD_EXP 37
34499: PPUSH
34500: LD_VAR 0 3
34504: PPUSH
34505: LD_VAR 0 3
34509: PPUSH
34510: CALL 19049 0 1
34514: PPUSH
34515: CALL_OW 1
34519: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34520: LD_ADDR_EXP 49
34524: PUSH
34525: LD_EXP 49
34529: PPUSH
34530: LD_VAR 0 3
34534: PPUSH
34535: LD_VAR 0 3
34539: PPUSH
34540: CALL 10862 0 1
34544: PPUSH
34545: CALL_OW 1
34549: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34550: LD_VAR 0 3
34554: PPUSH
34555: LD_INT 21
34557: PUSH
34558: LD_INT 2
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PPUSH
34565: CALL 11409 0 2
34569: IFFALSE 34580
// MCV_CheckStatus ( side ) ;
34571: LD_VAR 0 3
34575: PPUSH
34576: CALL 27019 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34580: LD_VAR 0 3
34584: PPUSH
34585: LD_EXP 55
34589: PPUSH
34590: CALL 43164 0 2
34594: IFFALSE 34679
// begin for i = MREG_ToChangeClass downto 1 do
34596: LD_ADDR_VAR 0 2
34600: PUSH
34601: DOUBLE
34602: LD_EXP 55
34606: INC
34607: ST_TO_ADDR
34608: LD_INT 1
34610: PUSH
34611: FOR_DOWNTO
34612: IFFALSE 34677
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34614: LD_EXP 55
34618: PUSH
34619: LD_VAR 0 2
34623: ARRAY
34624: PUSH
34625: LD_INT 1
34627: ARRAY
34628: PUSH
34629: LD_VAR 0 3
34633: EQUAL
34634: IFFALSE 34675
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34636: LD_VAR 0 3
34640: PPUSH
34641: LD_EXP 55
34645: PUSH
34646: LD_VAR 0 2
34650: ARRAY
34651: PUSH
34652: LD_INT 2
34654: ARRAY
34655: PPUSH
34656: LD_EXP 55
34660: PUSH
34661: LD_VAR 0 2
34665: ARRAY
34666: PUSH
34667: LD_INT 3
34669: ARRAY
34670: PPUSH
34671: CALL 16316 0 3
// end ; end ;
34675: GO 34611
34677: POP
34678: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34679: LD_INT 1
34681: PUSH
34682: LD_EXP 40
34686: PUSH
34687: LD_VAR 0 3
34691: ARRAY
34692: IN
34693: IFFALSE 34704
// begin MCN_TrainApe ( side ) ;
34695: LD_VAR 0 3
34699: PPUSH
34700: CALL 18702 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34704: LD_VAR 0 3
34708: PPUSH
34709: LD_INT 30
34711: PUSH
34712: LD_INT 3
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PPUSH
34719: CALL 11409 0 2
34723: IFFALSE 34897
// begin if MCF_Tag ( side , 10 , [ ] ) then
34725: LD_VAR 0 3
34729: PPUSH
34730: LD_INT 10
34732: PPUSH
34733: EMPTY
34734: PPUSH
34735: CALL 12112 0 3
34739: IFFALSE 34786
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34741: LD_VAR 0 3
34745: PPUSH
34746: LD_INT 10
34748: PPUSH
34749: EMPTY
34750: PPUSH
34751: CALL 12112 0 3
34755: PPUSH
34756: LD_VAR 0 3
34760: PPUSH
34761: LD_INT 30
34763: PUSH
34764: LD_INT 3
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PPUSH
34771: CALL 11409 0 2
34775: PUSH
34776: LD_INT 1
34778: ARRAY
34779: PPUSH
34780: CALL_OW 168
// end else
34784: GO 34897
// if MREG_ToConstruct [ side ] then
34786: LD_EXP 53
34790: PUSH
34791: LD_VAR 0 3
34795: ARRAY
34796: IFFALSE 34897
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34798: LD_VAR 0 3
34802: PPUSH
34803: LD_VAR 0 3
34807: PPUSH
34808: LD_INT 30
34810: PUSH
34811: LD_INT 3
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PPUSH
34818: CALL 11409 0 2
34822: PUSH
34823: LD_INT 1
34825: ARRAY
34826: PPUSH
34827: LD_EXP 53
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 1
34840: ARRAY
34841: PUSH
34842: LD_EXP 53
34846: PUSH
34847: LD_VAR 0 3
34851: ARRAY
34852: PUSH
34853: LD_INT 2
34855: ARRAY
34856: PUSH
34857: LD_EXP 53
34861: PUSH
34862: LD_VAR 0 3
34866: ARRAY
34867: PUSH
34868: LD_INT 3
34870: ARRAY
34871: PUSH
34872: LD_EXP 53
34876: PUSH
34877: LD_VAR 0 3
34881: ARRAY
34882: PUSH
34883: LD_INT 4
34885: ARRAY
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: PPUSH
34893: CALL 25313 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34897: LD_VAR 0 3
34901: PPUSH
34902: LD_INT 30
34904: PUSH
34905: LD_INT 3
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PPUSH
34912: CALL 11409 0 2
34916: PUSH
34917: LD_VAR 0 3
34921: PPUSH
34922: LD_EXP 45
34926: PPUSH
34927: CALL 43164 0 2
34931: AND
34932: PUSH
34933: LD_INT 22
34935: PUSH
34936: LD_VAR 0 3
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 30
34950: PUSH
34951: LD_INT 33
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 30
34960: PUSH
34961: LD_INT 32
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 35
34975: PUSH
34976: LD_INT 0
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: LIST
34987: PPUSH
34988: CALL_OW 69
34992: AND
34993: IFFALSE 35004
// MCV_Turret ( side ) ;
34995: LD_VAR 0 3
34999: PPUSH
35000: CALL 25762 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35004: LD_EXP 44
35008: PUSH
35009: LD_VAR 0 3
35013: ARRAY
35014: PUSH
35015: LD_INT 1
35017: GREATER
35018: PUSH
35019: LD_VAR 0 3
35023: PPUSH
35024: CALL 24810 0 1
35028: PUSH
35029: LD_INT 0
35031: EQUAL
35032: AND
35033: IFFALSE 35195
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35035: LD_EXP 44
35039: PUSH
35040: LD_VAR 0 3
35044: ARRAY
35045: PUSH
35046: LD_INT 1
35048: ARRAY
35049: PPUSH
35050: CALL_OW 353
35054: IFFALSE 35092
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35056: LD_EXP 44
35060: PUSH
35061: LD_VAR 0 3
35065: ARRAY
35066: PUSH
35067: LD_INT 2
35069: ARRAY
35070: PPUSH
35071: LD_EXP 44
35075: PUSH
35076: LD_VAR 0 3
35080: ARRAY
35081: PUSH
35082: LD_INT 1
35084: ARRAY
35085: PPUSH
35086: CALL 32473 0 2
35090: GO 35195
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35092: LD_VAR 0 3
35096: PPUSH
35097: LD_INT 30
35099: PUSH
35100: LD_INT 3
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PPUSH
35107: CALL 11409 0 2
35111: IFFALSE 35195
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35113: LD_VAR 0 3
35117: PPUSH
35118: LD_INT 30
35120: PUSH
35121: LD_INT 3
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PPUSH
35128: CALL 11409 0 2
35132: PUSH
35133: LD_INT 1
35135: ARRAY
35136: PPUSH
35137: CALL_OW 461
35141: PUSH
35142: LD_INT 2
35144: EQUAL
35145: IFFALSE 35195
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35147: LD_EXP 44
35151: PUSH
35152: LD_VAR 0 3
35156: ARRAY
35157: PUSH
35158: LD_INT 2
35160: ARRAY
35161: PPUSH
35162: LD_INT 10
35164: PPUSH
35165: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35169: LD_ADDR_EXP 44
35173: PUSH
35174: LD_EXP 44
35178: PPUSH
35179: LD_VAR 0 3
35183: PPUSH
35184: LD_INT 0
35186: PUSH
35187: EMPTY
35188: LIST
35189: PPUSH
35190: CALL_OW 1
35194: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35195: LD_VAR 0 3
35199: PPUSH
35200: LD_INT 33
35202: PUSH
35203: LD_INT 2
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PPUSH
35210: CALL 11409 0 2
35214: IFFALSE 35254
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35216: LD_VAR 0 3
35220: PPUSH
35221: LD_VAR 0 3
35225: PPUSH
35226: LD_INT 33
35228: PUSH
35229: LD_INT 2
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PPUSH
35236: CALL 11409 0 2
35240: PUSH
35241: LD_INT 1
35243: ARRAY
35244: PPUSH
35245: CALL_OW 248
35249: PPUSH
35250: CALL 26316 0 2
// if MREG_ToRepair [ side ] then
35254: LD_EXP 49
35258: PUSH
35259: LD_VAR 0 3
35263: ARRAY
35264: IFFALSE 35277
// begin MCB_Repair ( side ) ;
35266: LD_VAR 0 3
35270: PPUSH
35271: CALL 11149 0 1
// end else
35275: GO 36190
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35277: LD_VAR 0 3
35281: PPUSH
35282: LD_EXP 51
35286: PPUSH
35287: CALL 43164 0 2
35291: PUSH
35292: LD_VAR 0 3
35296: PPUSH
35297: LD_EXP 42
35301: PPUSH
35302: CALL 43164 0 2
35306: AND
35307: IFFALSE 35515
// begin for i = 1 to MREG_ToUpLab do
35309: LD_ADDR_VAR 0 2
35313: PUSH
35314: DOUBLE
35315: LD_INT 1
35317: DEC
35318: ST_TO_ADDR
35319: LD_EXP 51
35323: PUSH
35324: FOR_TO
35325: IFFALSE 35511
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35327: LD_EXP 51
35331: PUSH
35332: LD_VAR 0 2
35336: ARRAY
35337: PUSH
35338: LD_INT 1
35340: ARRAY
35341: PUSH
35342: LD_VAR 0 3
35346: EQUAL
35347: IFFALSE 35509
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35349: LD_EXP 51
35353: PUSH
35354: LD_VAR 0 2
35358: ARRAY
35359: PUSH
35360: LD_INT 2
35362: ARRAY
35363: PUSH
35364: LD_EXP 51
35368: PUSH
35369: LD_VAR 0 2
35373: ARRAY
35374: PUSH
35375: LD_INT 3
35377: ARRAY
35378: AND
35379: IFFALSE 35507
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35381: LD_VAR 0 3
35385: PPUSH
35386: LD_EXP 51
35390: PUSH
35391: LD_VAR 0 2
35395: ARRAY
35396: PUSH
35397: LD_INT 2
35399: ARRAY
35400: PPUSH
35401: LD_EXP 51
35405: PUSH
35406: LD_VAR 0 2
35410: ARRAY
35411: PUSH
35412: LD_INT 3
35414: ARRAY
35415: PPUSH
35416: CALL 8673 0 3
35420: IFFALSE 35507
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35422: LD_ADDR_EXP 51
35426: PUSH
35427: LD_EXP 51
35431: PPUSH
35432: LD_VAR 0 3
35436: PPUSH
35437: LD_EXP 51
35441: PUSH
35442: LD_VAR 0 2
35446: ARRAY
35447: PUSH
35448: LD_INT 2
35450: ARRAY
35451: PPUSH
35452: LD_EXP 51
35456: PUSH
35457: LD_VAR 0 2
35461: ARRAY
35462: PUSH
35463: LD_INT 3
35465: ARRAY
35466: PPUSH
35467: CALL 42216 0 4
35471: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35472: LD_ADDR_EXP 42
35476: PUSH
35477: LD_EXP 42
35481: PPUSH
35482: LD_VAR 0 3
35486: PPUSH
35487: LD_EXP 42
35491: PUSH
35492: LD_INT 1
35494: ARRAY
35495: PUSH
35496: LD_INT 2
35498: ARRAY
35499: PPUSH
35500: EMPTY
35501: PPUSH
35502: CALL 42216 0 4
35506: ST_TO_ADDR
// end ; break ;
35507: GO 35511
// end ;
35509: GO 35324
35511: POP
35512: POP
// end else
35513: GO 36190
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35515: LD_VAR 0 3
35519: PPUSH
35520: LD_EXP 50
35524: PPUSH
35525: CALL 43164 0 2
35529: IFFALSE 35603
// begin for i = 1 to MREG_ToUpdate do
35531: LD_ADDR_VAR 0 2
35535: PUSH
35536: DOUBLE
35537: LD_INT 1
35539: DEC
35540: ST_TO_ADDR
35541: LD_EXP 50
35545: PUSH
35546: FOR_TO
35547: IFFALSE 35599
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35549: LD_EXP 50
35553: PUSH
35554: LD_VAR 0 2
35558: ARRAY
35559: PUSH
35560: LD_INT 1
35562: ARRAY
35563: PUSH
35564: LD_VAR 0 3
35568: EQUAL
35569: IFFALSE 35597
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35571: LD_VAR 0 3
35575: PPUSH
35576: LD_EXP 50
35580: PUSH
35581: LD_VAR 0 2
35585: ARRAY
35586: PUSH
35587: LD_INT 2
35589: ARRAY
35590: PPUSH
35591: CALL 8509 0 2
// break ;
35595: GO 35599
// end ;
35597: GO 35546
35599: POP
35600: POP
// end else
35601: GO 36190
// if MCF_Get ( side , [ f_constructed ] ) then
35603: LD_VAR 0 3
35607: PPUSH
35608: LD_INT 57
35610: PUSH
35611: EMPTY
35612: LIST
35613: PPUSH
35614: CALL 11409 0 2
35618: IFFALSE 35651
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35620: LD_VAR 0 3
35624: PPUSH
35625: LD_VAR 0 3
35629: PPUSH
35630: LD_INT 57
35632: PUSH
35633: EMPTY
35634: LIST
35635: PPUSH
35636: CALL 11409 0 2
35640: PUSH
35641: LD_INT 1
35643: ARRAY
35644: PPUSH
35645: CALL 10753 0 2
35649: GO 36190
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35651: LD_VAR 0 3
35655: PPUSH
35656: LD_EXP 48
35660: PPUSH
35661: CALL 43164 0 2
35665: PUSH
35666: LD_VAR 0 3
35670: PPUSH
35671: CALL_OW 345
35675: NOT
35676: AND
35677: PUSH
35678: LD_VAR 0 3
35682: PPUSH
35683: CALL 24810 0 1
35687: PUSH
35688: LD_INT 0
35690: EQUAL
35691: AND
35692: IFFALSE 36091
// begin for i = 1 to MREG_ToBuild do
35694: LD_ADDR_VAR 0 2
35698: PUSH
35699: DOUBLE
35700: LD_INT 1
35702: DEC
35703: ST_TO_ADDR
35704: LD_EXP 48
35708: PUSH
35709: FOR_TO
35710: IFFALSE 36087
// if MREG_ToBuild [ i ] [ 1 ] = side then
35712: LD_EXP 48
35716: PUSH
35717: LD_VAR 0 2
35721: ARRAY
35722: PUSH
35723: LD_INT 1
35725: ARRAY
35726: PUSH
35727: LD_VAR 0 3
35731: EQUAL
35732: IFFALSE 36085
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35734: LD_OWVAR 84
35738: PUSH
35739: LD_EXP 48
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 48
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL_OW 351
35781: AND
35782: IFFALSE 35826
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35784: LD_EXP 48
35788: PUSH
35789: LD_VAR 0 2
35793: ARRAY
35794: PUSH
35795: LD_INT 3
35797: ARRAY
35798: PUSH
35799: LD_INT 1
35801: ARRAY
35802: PPUSH
35803: LD_EXP 48
35807: PUSH
35808: LD_VAR 0 2
35812: ARRAY
35813: PUSH
35814: LD_INT 3
35816: ARRAY
35817: PUSH
35818: LD_INT 2
35820: ARRAY
35821: PPUSH
35822: CALL 22557 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35826: LD_EXP 48
35830: PUSH
35831: LD_VAR 0 2
35835: ARRAY
35836: PUSH
35837: LD_INT 2
35839: ARRAY
35840: PUSH
35841: LD_INT 0
35843: EQUAL
35844: IFFALSE 35914
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35846: LD_VAR 0 3
35850: PPUSH
35851: LD_EXP 48
35855: PUSH
35856: LD_VAR 0 2
35860: ARRAY
35861: PUSH
35862: LD_INT 3
35864: ARRAY
35865: PUSH
35866: LD_INT 1
35868: ARRAY
35869: PPUSH
35870: LD_EXP 48
35874: PUSH
35875: LD_VAR 0 2
35879: ARRAY
35880: PUSH
35881: LD_INT 3
35883: ARRAY
35884: PUSH
35885: LD_INT 2
35887: ARRAY
35888: PPUSH
35889: LD_EXP 48
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 3
35902: ARRAY
35903: PUSH
35904: LD_INT 3
35906: ARRAY
35907: PPUSH
35908: CALL 8345 0 4
35912: GO 36083
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35914: LD_EXP 48
35918: PUSH
35919: LD_VAR 0 2
35923: ARRAY
35924: PUSH
35925: LD_INT 2
35927: ARRAY
35928: PUSH
35929: LD_INT 6
35931: EQUAL
35932: IFFALSE 36002
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35934: LD_VAR 0 3
35938: PPUSH
35939: LD_EXP 48
35943: PUSH
35944: LD_VAR 0 2
35948: ARRAY
35949: PUSH
35950: LD_INT 3
35952: ARRAY
35953: PUSH
35954: LD_INT 1
35956: ARRAY
35957: PPUSH
35958: LD_EXP 48
35962: PUSH
35963: LD_VAR 0 2
35967: ARRAY
35968: PUSH
35969: LD_INT 3
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 48
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 3
35994: ARRAY
35995: PPUSH
35996: CALL 8474 0 4
36000: GO 36083
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36002: LD_VAR 0 3
36006: PPUSH
36007: LD_EXP 48
36011: PUSH
36012: LD_VAR 0 2
36016: ARRAY
36017: PUSH
36018: LD_INT 2
36020: ARRAY
36021: PPUSH
36022: LD_EXP 48
36026: PUSH
36027: LD_VAR 0 2
36031: ARRAY
36032: PUSH
36033: LD_INT 3
36035: ARRAY
36036: PUSH
36037: LD_INT 1
36039: ARRAY
36040: PPUSH
36041: LD_EXP 48
36045: PUSH
36046: LD_VAR 0 2
36050: ARRAY
36051: PUSH
36052: LD_INT 3
36054: ARRAY
36055: PUSH
36056: LD_INT 2
36058: ARRAY
36059: PPUSH
36060: LD_EXP 48
36064: PUSH
36065: LD_VAR 0 2
36069: ARRAY
36070: PUSH
36071: LD_INT 3
36073: ARRAY
36074: PUSH
36075: LD_INT 3
36077: ARRAY
36078: PPUSH
36079: CALL 9978 0 5
// break ;
36083: GO 36087
// end ;
36085: GO 35709
36087: POP
36088: POP
// end else
36089: GO 36190
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36091: LD_VAR 0 3
36095: PPUSH
36096: LD_EXP 54
36100: PPUSH
36101: CALL 43164 0 2
36105: PUSH
36106: LD_VAR 0 3
36110: PPUSH
36111: CALL 24810 0 1
36115: PUSH
36116: LD_INT 0
36118: EQUAL
36119: AND
36120: IFFALSE 36190
// begin for i = 1 to MREG_ToDismantle do
36122: LD_ADDR_VAR 0 2
36126: PUSH
36127: DOUBLE
36128: LD_INT 1
36130: DEC
36131: ST_TO_ADDR
36132: LD_EXP 54
36136: PUSH
36137: FOR_TO
36138: IFFALSE 36188
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36140: LD_EXP 54
36144: PUSH
36145: LD_VAR 0 2
36149: ARRAY
36150: PUSH
36151: LD_INT 1
36153: ARRAY
36154: PUSH
36155: LD_VAR 0 3
36159: EQUAL
36160: IFFALSE 36186
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36162: LD_VAR 0 3
36166: PPUSH
36167: LD_EXP 54
36171: PUSH
36172: LD_VAR 0 2
36176: ARRAY
36177: PUSH
36178: LD_INT 2
36180: ARRAY
36181: PPUSH
36182: CALL 10644 0 2
// end ;
36186: GO 36137
36188: POP
36189: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36190: LD_VAR 0 3
36194: PPUSH
36195: LD_INT 30
36197: PUSH
36198: LD_INT 1
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PPUSH
36205: CALL 11409 0 2
36209: PUSH
36210: LD_VAR 0 3
36214: PPUSH
36215: CALL 24810 0 1
36219: PUSH
36220: LD_INT 0
36222: EQUAL
36223: AND
36224: IFFALSE 36235
// MCT_CollectCrates ( side ) ;
36226: LD_VAR 0 3
36230: PPUSH
36231: CALL 23749 0 1
// end ;
36235: GO 34236
36237: POP
36238: POP
// end ;
36239: LD_VAR 0 1
36243: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36244: LD_INT 0
36246: PPUSH
36247: PPUSH
36248: PPUSH
36249: PPUSH
36250: PPUSH
36251: PPUSH
36252: PPUSH
36253: PPUSH
36254: PPUSH
36255: PPUSH
36256: PPUSH
36257: PPUSH
36258: PPUSH
36259: PPUSH
36260: PPUSH
// all := MCF_All ( side , [ ] ) ;
36261: LD_ADDR_VAR 0 17
36265: PUSH
36266: LD_VAR 0 1
36270: PPUSH
36271: EMPTY
36272: PPUSH
36273: CALL 11544 0 2
36277: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36278: LD_ADDR_VAR 0 13
36282: PUSH
36283: LD_VAR 0 1
36287: PPUSH
36288: LD_INT 1
36290: PPUSH
36291: EMPTY
36292: PPUSH
36293: CALL 11492 0 3
36297: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36298: LD_ADDR_VAR 0 14
36302: PUSH
36303: LD_VAR 0 1
36307: PPUSH
36308: LD_INT 2
36310: PPUSH
36311: EMPTY
36312: PPUSH
36313: CALL 11492 0 3
36317: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36318: LD_ADDR_VAR 0 15
36322: PUSH
36323: LD_VAR 0 1
36327: PPUSH
36328: LD_INT 3
36330: PPUSH
36331: EMPTY
36332: PPUSH
36333: CALL 11492 0 3
36337: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36338: LD_ADDR_VAR 0 16
36342: PUSH
36343: LD_VAR 0 1
36347: PPUSH
36348: LD_INT 4
36350: PPUSH
36351: EMPTY
36352: PPUSH
36353: CALL 11492 0 3
36357: ST_TO_ADDR
// if mech then
36358: LD_VAR 0 15
36362: IFFALSE 36379
// mech := MCF_SortListDesc ( mech ) ;
36364: LD_ADDR_VAR 0 15
36368: PUSH
36369: LD_VAR 0 15
36373: PPUSH
36374: CALL 12658 0 1
36378: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36379: LD_EXP 58
36383: PUSH
36384: LD_VAR 0 1
36388: ARRAY
36389: PUSH
36390: LD_STRING 
36392: EQUAL
36393: NOT
36394: IFFALSE 36450
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36396: LD_EXP 58
36400: PUSH
36401: LD_VAR 0 1
36405: ARRAY
36406: PUSH
36407: LD_INT 1
36409: ARRAY
36410: PPUSH
36411: CALL_OW 257
36415: PUSH
36416: LD_INT 1
36418: EQUAL
36419: IFFALSE 36448
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36421: LD_VAR 0 1
36425: PPUSH
36426: LD_STRING ToArm
36428: PPUSH
36429: LD_EXP 58
36433: PUSH
36434: LD_VAR 0 1
36438: ARRAY
36439: PUSH
36440: LD_INT 1
36442: ARRAY
36443: PPUSH
36444: CALL 14288 0 3
// end else
36448: GO 36476
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36450: LD_ADDR_EXP 58
36454: PUSH
36455: LD_EXP 58
36459: PPUSH
36460: LD_VAR 0 1
36464: PPUSH
36465: LD_INT 1
36467: PPUSH
36468: LD_INT 0
36470: PPUSH
36471: CALL 30843 0 4
36475: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36476: LD_EXP 59
36480: PUSH
36481: LD_VAR 0 1
36485: ARRAY
36486: PUSH
36487: LD_STRING 
36489: EQUAL
36490: NOT
36491: IFFALSE 36547
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36493: LD_EXP 59
36497: PUSH
36498: LD_VAR 0 1
36502: ARRAY
36503: PUSH
36504: LD_INT 1
36506: ARRAY
36507: PPUSH
36508: CALL_OW 257
36512: PUSH
36513: LD_INT 2
36515: EQUAL
36516: IFFALSE 36545
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36518: LD_VAR 0 1
36522: PPUSH
36523: LD_STRING ToDep
36525: PPUSH
36526: LD_EXP 59
36530: PUSH
36531: LD_VAR 0 1
36535: ARRAY
36536: PUSH
36537: LD_INT 1
36539: ARRAY
36540: PPUSH
36541: CALL 14288 0 3
// end else
36545: GO 36573
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36547: LD_ADDR_EXP 59
36551: PUSH
36552: LD_EXP 59
36556: PPUSH
36557: LD_VAR 0 1
36561: PPUSH
36562: LD_INT 1
36564: PPUSH
36565: LD_INT 0
36567: PPUSH
36568: CALL 30843 0 4
36572: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36573: LD_EXP 57
36577: PUSH
36578: LD_VAR 0 1
36582: ARRAY
36583: PUSH
36584: LD_STRING 
36586: EQUAL
36587: NOT
36588: IFFALSE 36644
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36590: LD_EXP 57
36594: PUSH
36595: LD_VAR 0 1
36599: ARRAY
36600: PUSH
36601: LD_INT 1
36603: ARRAY
36604: PPUSH
36605: CALL_OW 257
36609: PUSH
36610: LD_INT 3
36612: EQUAL
36613: IFFALSE 36642
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36615: LD_VAR 0 1
36619: PPUSH
36620: LD_STRING ToFac
36622: PPUSH
36623: LD_EXP 57
36627: PUSH
36628: LD_VAR 0 1
36632: ARRAY
36633: PUSH
36634: LD_INT 1
36636: ARRAY
36637: PPUSH
36638: CALL 14288 0 3
// end else
36642: GO 36670
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36644: LD_ADDR_EXP 57
36648: PUSH
36649: LD_EXP 57
36653: PPUSH
36654: LD_VAR 0 1
36658: PPUSH
36659: LD_INT 1
36661: PPUSH
36662: LD_INT 0
36664: PPUSH
36665: CALL 30843 0 4
36669: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36670: LD_EXP 56
36674: PUSH
36675: LD_VAR 0 1
36679: ARRAY
36680: PUSH
36681: LD_STRING 
36683: EQUAL
36684: NOT
36685: IFFALSE 36741
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36687: LD_EXP 56
36691: PUSH
36692: LD_VAR 0 1
36696: ARRAY
36697: PUSH
36698: LD_INT 1
36700: ARRAY
36701: PPUSH
36702: CALL_OW 257
36706: PUSH
36707: LD_INT 4
36709: EQUAL
36710: IFFALSE 36739
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36712: LD_VAR 0 1
36716: PPUSH
36717: LD_STRING ToLab
36719: PPUSH
36720: LD_EXP 56
36724: PUSH
36725: LD_VAR 0 1
36729: ARRAY
36730: PUSH
36731: LD_INT 1
36733: ARRAY
36734: PPUSH
36735: CALL 14288 0 3
// end else
36739: GO 36767
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36741: LD_ADDR_EXP 56
36745: PUSH
36746: LD_EXP 56
36750: PPUSH
36751: LD_VAR 0 1
36755: PPUSH
36756: LD_INT 1
36758: PPUSH
36759: LD_INT 0
36761: PPUSH
36762: CALL 30843 0 4
36766: ST_TO_ADDR
// if mode = 0 then
36767: LD_VAR 0 2
36771: PUSH
36772: LD_INT 0
36774: EQUAL
36775: IFFALSE 38613
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36777: LD_VAR 0 1
36781: PPUSH
36782: LD_INT 30
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PPUSH
36792: CALL 11409 0 2
36796: PUSH
36797: LD_VAR 0 1
36801: PPUSH
36802: LD_INT 21
36804: PUSH
36805: LD_INT 3
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PPUSH
36812: CALL 11409 0 2
36816: PUSH
36817: LD_INT 1
36819: EQUAL
36820: AND
36821: IFFALSE 36886
// begin if all then
36823: LD_VAR 0 17
36827: IFFALSE 36884
// for i in ( all diff eng ) do
36829: LD_ADDR_VAR 0 4
36833: PUSH
36834: LD_VAR 0 17
36838: PUSH
36839: LD_VAR 0 14
36843: DIFF
36844: PUSH
36845: FOR_IN
36846: IFFALSE 36882
// if GetTag ( i ) = 0 then
36848: LD_VAR 0 4
36852: PPUSH
36853: CALL_OW 110
36857: PUSH
36858: LD_INT 0
36860: EQUAL
36861: IFFALSE 36880
// MCH_ChangeClass ( side , i , 2 ) ;
36863: LD_VAR 0 1
36867: PPUSH
36868: LD_VAR 0 4
36872: PPUSH
36873: LD_INT 2
36875: PPUSH
36876: CALL 16316 0 3
36880: GO 36845
36882: POP
36883: POP
// end else
36884: GO 37205
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36886: LD_VAR 0 13
36890: PUSH
36891: LD_EXP 58
36895: PUSH
36896: LD_VAR 0 1
36900: ARRAY
36901: PLUS
36902: PUSH
36903: LD_INT 22
36905: PUSH
36906: LD_VAR 0 1
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 30
36917: PUSH
36918: LD_INT 32
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PPUSH
36929: CALL_OW 69
36933: LESS
36934: IFFALSE 36959
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36936: LD_VAR 0 1
36940: PPUSH
36941: LD_VAR 0 14
36945: PUSH
36946: LD_INT 1
36948: ARRAY
36949: PPUSH
36950: LD_INT 1
36952: PPUSH
36953: CALL 16316 0 3
// end else
36957: GO 37205
// if sci < 6 and MCF_Lab ( side ) then
36959: LD_VAR 0 16
36963: PUSH
36964: LD_INT 6
36966: LESS
36967: PUSH
36968: LD_VAR 0 1
36972: PPUSH
36973: CALL 11448 0 1
36977: AND
36978: IFFALSE 37083
// begin if MREG_ToBunker [ side ] then
36980: LD_EXP 70
36984: PUSH
36985: LD_VAR 0 1
36989: ARRAY
36990: IFFALSE 37016
// tmp := sol diff MREG_ToBunker [ side ] else
36992: LD_ADDR_VAR 0 12
36996: PUSH
36997: LD_VAR 0 13
37001: PUSH
37002: LD_EXP 70
37006: PUSH
37007: LD_VAR 0 1
37011: ARRAY
37012: DIFF
37013: ST_TO_ADDR
37014: GO 37026
// tmp := sol ;
37016: LD_ADDR_VAR 0 12
37020: PUSH
37021: LD_VAR 0 13
37025: ST_TO_ADDR
// if tmp then
37026: LD_VAR 0 12
37030: IFFALSE 37081
// for i in tmp do
37032: LD_ADDR_VAR 0 4
37036: PUSH
37037: LD_VAR 0 12
37041: PUSH
37042: FOR_IN
37043: IFFALSE 37079
// if GetTag ( i ) = 0 then
37045: LD_VAR 0 4
37049: PPUSH
37050: CALL_OW 110
37054: PUSH
37055: LD_INT 0
37057: EQUAL
37058: IFFALSE 37077
// MCH_ChangeClass ( side , i , 4 ) ;
37060: LD_VAR 0 1
37064: PPUSH
37065: LD_VAR 0 4
37069: PPUSH
37070: LD_INT 4
37072: PPUSH
37073: CALL 16316 0 3
37077: GO 37042
37079: POP
37080: POP
// end else
37081: GO 37205
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37083: LD_VAR 0 1
37087: PPUSH
37088: LD_INT 30
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PPUSH
37098: CALL 11409 0 2
37102: IFFALSE 37205
// begin if MREG_ToBunker [ side ] then
37104: LD_EXP 70
37108: PUSH
37109: LD_VAR 0 1
37113: ARRAY
37114: IFFALSE 37140
// tmp := sol diff MREG_ToBunker [ side ] else
37116: LD_ADDR_VAR 0 12
37120: PUSH
37121: LD_VAR 0 13
37125: PUSH
37126: LD_EXP 70
37130: PUSH
37131: LD_VAR 0 1
37135: ARRAY
37136: DIFF
37137: ST_TO_ADDR
37138: GO 37150
// tmp := sol ;
37140: LD_ADDR_VAR 0 12
37144: PUSH
37145: LD_VAR 0 13
37149: ST_TO_ADDR
// if tmp then
37150: LD_VAR 0 12
37154: IFFALSE 37205
// for i in tmp do
37156: LD_ADDR_VAR 0 4
37160: PUSH
37161: LD_VAR 0 12
37165: PUSH
37166: FOR_IN
37167: IFFALSE 37203
// if GetTag ( i ) = 0 then
37169: LD_VAR 0 4
37173: PPUSH
37174: CALL_OW 110
37178: PUSH
37179: LD_INT 0
37181: EQUAL
37182: IFFALSE 37201
// MCH_ChangeClass ( side , i , 2 ) ;
37184: LD_VAR 0 1
37188: PPUSH
37189: LD_VAR 0 4
37193: PPUSH
37194: LD_INT 2
37196: PPUSH
37197: CALL 16316 0 3
37201: GO 37166
37203: POP
37204: POP
// end ; if MCF_Lab ( side ) then
37205: LD_VAR 0 1
37209: PPUSH
37210: CALL 11448 0 1
37214: IFFALSE 37754
// begin if MCL_GetTechList ( side ) then
37216: LD_VAR 0 1
37220: PPUSH
37221: CALL 17792 0 1
37225: IFFALSE 37351
// begin if MREG_ToLab [ side ] then
37227: LD_EXP 56
37231: PUSH
37232: LD_VAR 0 1
37236: ARRAY
37237: IFFALSE 37257
// k := MREG_ToLab [ side ] else
37239: LD_ADDR_VAR 0 8
37243: PUSH
37244: LD_EXP 56
37248: PUSH
37249: LD_VAR 0 1
37253: ARRAY
37254: ST_TO_ADDR
37255: GO 37265
// k := 0 ;
37257: LD_ADDR_VAR 0 8
37261: PUSH
37262: LD_INT 0
37264: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37265: LD_VAR 0 16
37269: PUSH
37270: LD_VAR 0 8
37274: PLUS
37275: PUSH
37276: LD_INT 6
37278: LESSEQUAL
37279: PUSH
37280: LD_VAR 0 17
37284: PUSH
37285: LD_INT 6
37287: GREATER
37288: AND
37289: IFFALSE 37305
// MCH_TrainScientist ( side , 1 ) else
37291: LD_VAR 0 1
37295: PPUSH
37296: LD_INT 1
37298: PPUSH
37299: CALL 15868 0 2
37303: GO 37349
// if all < 6 then
37305: LD_VAR 0 17
37309: PUSH
37310: LD_INT 6
37312: LESS
37313: IFFALSE 37349
// if sci + k < all / 2 then
37315: LD_VAR 0 16
37319: PUSH
37320: LD_VAR 0 8
37324: PLUS
37325: PUSH
37326: LD_VAR 0 17
37330: PUSH
37331: LD_INT 2
37333: DIVREAL
37334: LESS
37335: IFFALSE 37349
// MCH_TrainScientist ( side , 1 ) ;
37337: LD_VAR 0 1
37341: PPUSH
37342: LD_INT 1
37344: PPUSH
37345: CALL 15868 0 2
// end else
37349: GO 37427
// begin if sci > 2 then
37351: LD_VAR 0 16
37355: PUSH
37356: LD_INT 2
37358: GREATER
37359: IFFALSE 37427
// for i = sci downto 2 do
37361: LD_ADDR_VAR 0 4
37365: PUSH
37366: DOUBLE
37367: LD_VAR 0 16
37371: INC
37372: ST_TO_ADDR
37373: LD_INT 2
37375: PUSH
37376: FOR_DOWNTO
37377: IFFALSE 37425
// if GetTag ( sci [ i ] ) = 0 then
37379: LD_VAR 0 16
37383: PUSH
37384: LD_VAR 0 4
37388: ARRAY
37389: PPUSH
37390: CALL_OW 110
37394: PUSH
37395: LD_INT 0
37397: EQUAL
37398: IFFALSE 37423
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37400: LD_VAR 0 1
37404: PPUSH
37405: LD_VAR 0 16
37409: PUSH
37410: LD_VAR 0 4
37414: ARRAY
37415: PPUSH
37416: LD_INT 2
37418: PPUSH
37419: CALL 16316 0 3
37423: GO 37376
37425: POP
37426: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 17792 0 1
37436: PUSH
37437: LD_VAR 0 1
37441: PPUSH
37442: CALL 11448 0 1
37446: AND
37447: PUSH
37448: LD_EXP 37
37452: PUSH
37453: LD_VAR 0 1
37457: ARRAY
37458: NOT
37459: AND
37460: IFFALSE 37754
// begin for j = 1 to MCF_Lab ( side ) do
37462: LD_ADDR_VAR 0 5
37466: PUSH
37467: DOUBLE
37468: LD_INT 1
37470: DEC
37471: ST_TO_ADDR
37472: LD_VAR 0 1
37476: PPUSH
37477: CALL 11448 0 1
37481: PUSH
37482: FOR_TO
37483: IFFALSE 37543
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37485: LD_VAR 0 1
37489: PPUSH
37490: CALL 11448 0 1
37494: PUSH
37495: LD_VAR 0 5
37499: ARRAY
37500: PPUSH
37501: CALL_OW 461
37505: PUSH
37506: LD_INT 3
37508: PUSH
37509: LD_INT 6
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: IN
37516: IFFALSE 37541
// begin b := MCF_Lab ( side ) [ j ] ;
37518: LD_ADDR_VAR 0 11
37522: PUSH
37523: LD_VAR 0 1
37527: PPUSH
37528: CALL 11448 0 1
37532: PUSH
37533: LD_VAR 0 5
37537: ARRAY
37538: ST_TO_ADDR
// break ;
37539: GO 37543
// end ;
37541: GO 37482
37543: POP
37544: POP
// if MCF_Class ( side , 4 , [ ] ) then
37545: LD_VAR 0 1
37549: PPUSH
37550: LD_INT 4
37552: PPUSH
37553: EMPTY
37554: PPUSH
37555: CALL 11492 0 3
37559: IFFALSE 37754
// for j in MCF_Class ( side , 4 , [ ] ) do
37561: LD_ADDR_VAR 0 5
37565: PUSH
37566: LD_VAR 0 1
37570: PPUSH
37571: LD_INT 4
37573: PPUSH
37574: EMPTY
37575: PPUSH
37576: CALL 11492 0 3
37580: PUSH
37581: FOR_IN
37582: IFFALSE 37752
// begin if GetTag ( j ) = 0 then
37584: LD_VAR 0 5
37588: PPUSH
37589: CALL_OW 110
37593: PUSH
37594: LD_INT 0
37596: EQUAL
37597: IFFALSE 37688
// begin if IsInUnit ( j ) and b then
37599: LD_VAR 0 5
37603: PPUSH
37604: CALL_OW 310
37608: PUSH
37609: LD_VAR 0 11
37613: AND
37614: IFFALSE 37662
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37616: LD_VAR 0 5
37620: PPUSH
37621: CALL_OW 310
37625: PPUSH
37626: CALL_OW 461
37630: PUSH
37631: LD_INT 2
37633: EQUAL
37634: PUSH
37635: LD_VAR 0 5
37639: PPUSH
37640: CALL_OW 310
37644: PUSH
37645: LD_VAR 0 11
37649: NONEQUAL
37650: AND
37651: IFFALSE 37662
// ComExitBuilding ( j ) ;
37653: LD_VAR 0 5
37657: PPUSH
37658: CALL_OW 122
// if not IsInUnit ( j ) then
37662: LD_VAR 0 5
37666: PPUSH
37667: CALL_OW 310
37671: NOT
37672: IFFALSE 37688
// ComEnterUnit ( j , b ) ;
37674: LD_VAR 0 5
37678: PPUSH
37679: LD_VAR 0 11
37683: PPUSH
37684: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37688: LD_INT 1
37690: PPUSH
37691: LD_VAR 0 5
37695: PPUSH
37696: CALL_OW 255
37700: PPUSH
37701: CALL_OW 321
37705: PUSH
37706: LD_INT 2
37708: EQUAL
37709: PUSH
37710: LD_VAR 0 5
37714: PPUSH
37715: CALL_OW 255
37719: PPUSH
37720: CALL 24810 0 1
37724: PUSH
37725: LD_INT 0
37727: EQUAL
37728: AND
37729: IFFALSE 37750
// MCN_Tame ( GetSide ( j ) , j ) ;
37731: LD_VAR 0 5
37735: PPUSH
37736: CALL_OW 255
37740: PPUSH
37741: LD_VAR 0 5
37745: PPUSH
37746: CALL 18311 0 2
// end ;
37750: GO 37581
37752: POP
37753: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37754: LD_VAR 0 1
37758: PPUSH
37759: LD_INT 30
37761: PUSH
37762: LD_INT 3
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PPUSH
37769: CALL 11409 0 2
37773: IFFALSE 38032
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37775: LD_ADDR_VAR 0 11
37779: PUSH
37780: LD_VAR 0 1
37784: PPUSH
37785: LD_INT 30
37787: PUSH
37788: LD_INT 3
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PPUSH
37795: CALL 11409 0 2
37799: PUSH
37800: LD_INT 1
37802: ARRAY
37803: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37804: LD_ADDR_VAR 0 12
37808: PUSH
37809: LD_VAR 0 1
37813: PPUSH
37814: LD_INT 0
37816: PPUSH
37817: LD_INT 25
37819: PUSH
37820: LD_INT 3
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PPUSH
37827: CALL 12112 0 3
37831: ST_TO_ADDR
// for i = 1 to tmp do
37832: LD_ADDR_VAR 0 4
37836: PUSH
37837: DOUBLE
37838: LD_INT 1
37840: DEC
37841: ST_TO_ADDR
37842: LD_VAR 0 12
37846: PUSH
37847: FOR_TO
37848: IFFALSE 37908
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37850: LD_VAR 0 12
37854: PUSH
37855: LD_VAR 0 4
37859: ARRAY
37860: PPUSH
37861: CALL_OW 310
37865: NOT
37866: PUSH
37867: LD_VAR 0 12
37871: PUSH
37872: LD_VAR 0 4
37876: ARRAY
37877: PPUSH
37878: CALL_OW 314
37882: NOT
37883: AND
37884: IFFALSE 37906
// ComEnterUnit ( tmp [ i ] , b ) ;
37886: LD_VAR 0 12
37890: PUSH
37891: LD_VAR 0 4
37895: ARRAY
37896: PPUSH
37897: LD_VAR 0 11
37901: PPUSH
37902: CALL_OW 120
37906: GO 37847
37908: POP
37909: POP
// if MREG_ToFac [ side ] then
37910: LD_EXP 57
37914: PUSH
37915: LD_VAR 0 1
37919: ARRAY
37920: IFFALSE 37940
// k := MREG_ToFac [ side ] else
37922: LD_ADDR_VAR 0 8
37926: PUSH
37927: LD_EXP 57
37931: PUSH
37932: LD_VAR 0 1
37936: ARRAY
37937: ST_TO_ADDR
37938: GO 37948
// k := 0 ;
37940: LD_ADDR_VAR 0 8
37944: PUSH
37945: LD_INT 0
37947: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37948: LD_VAR 0 15
37952: PUSH
37953: LD_VAR 0 8
37957: PLUS
37958: PUSH
37959: LD_INT 6
37961: LESSEQUAL
37962: PUSH
37963: LD_VAR 0 17
37967: PUSH
37968: LD_INT 6
37970: GREATER
37971: AND
37972: IFFALSE 37988
// MCH_TrainMechanic ( side , 1 ) else
37974: LD_VAR 0 1
37978: PPUSH
37979: LD_INT 1
37981: PPUSH
37982: CALL 15610 0 2
37986: GO 38032
// if all < 6 then
37988: LD_VAR 0 17
37992: PUSH
37993: LD_INT 6
37995: LESS
37996: IFFALSE 38032
// if mech + k < all / 2 then
37998: LD_VAR 0 15
38002: PUSH
38003: LD_VAR 0 8
38007: PLUS
38008: PUSH
38009: LD_VAR 0 17
38013: PUSH
38014: LD_INT 2
38016: DIVREAL
38017: LESS
38018: IFFALSE 38032
// MCH_TrainMechanic ( side , 1 ) ;
38020: LD_VAR 0 1
38024: PPUSH
38025: LD_INT 1
38027: PPUSH
38028: CALL 15610 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38032: LD_ADDR_VAR 0 10
38036: PUSH
38037: LD_VAR 0 1
38041: PPUSH
38042: LD_INT 30
38044: PUSH
38045: LD_INT 36
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PPUSH
38052: CALL 11409 0 2
38056: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38057: LD_VAR 0 10
38061: PUSH
38062: LD_VAR 0 15
38066: AND
38067: PUSH
38068: LD_VAR 0 1
38072: PPUSH
38073: LD_INT 3
38075: PPUSH
38076: EMPTY
38077: PPUSH
38078: CALL 11492 0 3
38082: AND
38083: IFFALSE 38241
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38085: LD_VAR 0 1
38089: PPUSH
38090: LD_INT 9
38092: PPUSH
38093: EMPTY
38094: PPUSH
38095: CALL 12112 0 3
38099: PUSH
38100: LD_INT 3
38102: LESS
38103: IFFALSE 38241
// begin if mech < 3 then
38105: LD_VAR 0 15
38109: PUSH
38110: LD_INT 3
38112: LESS
38113: IFFALSE 38127
// k := mech else
38115: LD_ADDR_VAR 0 8
38119: PUSH
38120: LD_VAR 0 15
38124: ST_TO_ADDR
38125: GO 38135
// k := 3 ;
38127: LD_ADDR_VAR 0 8
38131: PUSH
38132: LD_INT 3
38134: ST_TO_ADDR
// for j = 1 to k do
38135: LD_ADDR_VAR 0 5
38139: PUSH
38140: DOUBLE
38141: LD_INT 1
38143: DEC
38144: ST_TO_ADDR
38145: LD_VAR 0 8
38149: PUSH
38150: FOR_TO
38151: IFFALSE 38209
// if GetClass ( mech [ j ] ) = 3 then
38153: LD_VAR 0 15
38157: PUSH
38158: LD_VAR 0 5
38162: ARRAY
38163: PPUSH
38164: CALL_OW 257
38168: PUSH
38169: LD_INT 3
38171: EQUAL
38172: IFFALSE 38207
// begin SetTag ( mech [ j ] , 9 ) ;
38174: LD_VAR 0 15
38178: PUSH
38179: LD_VAR 0 5
38183: ARRAY
38184: PPUSH
38185: LD_INT 9
38187: PPUSH
38188: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38192: LD_VAR 0 15
38196: PUSH
38197: LD_VAR 0 5
38201: ARRAY
38202: PPUSH
38203: CALL_OW 122
// end ;
38207: GO 38150
38209: POP
38210: POP
// if mech < 6 + k then
38211: LD_VAR 0 15
38215: PUSH
38216: LD_INT 6
38218: PUSH
38219: LD_VAR 0 8
38223: PLUS
38224: LESS
38225: IFFALSE 38241
// MCH_TrainMechanic ( side , k ) ;
38227: LD_VAR 0 1
38231: PPUSH
38232: LD_VAR 0 8
38236: PPUSH
38237: CALL 15610 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38241: LD_VAR 0 1
38245: PPUSH
38246: LD_INT 9
38248: PPUSH
38249: EMPTY
38250: PPUSH
38251: CALL 12112 0 3
38255: IFFALSE 38346
// for j in MCF_Tag ( side , 9 , [ ] ) do
38257: LD_ADDR_VAR 0 5
38261: PUSH
38262: LD_VAR 0 1
38266: PPUSH
38267: LD_INT 9
38269: PPUSH
38270: EMPTY
38271: PPUSH
38272: CALL 12112 0 3
38276: PUSH
38277: FOR_IN
38278: IFFALSE 38344
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38280: LD_VAR 0 5
38284: PPUSH
38285: CALL_OW 310
38289: NOT
38290: PUSH
38291: LD_VAR 0 5
38295: PPUSH
38296: CALL 31486 0 1
38300: NOT
38301: AND
38302: IFFALSE 38342
// if ct then
38304: LD_VAR 0 10
38308: IFFALSE 38330
// ComEnterUnit ( j , ct [ 1 ] ) else
38310: LD_VAR 0 5
38314: PPUSH
38315: LD_VAR 0 10
38319: PUSH
38320: LD_INT 1
38322: ARRAY
38323: PPUSH
38324: CALL_OW 120
38328: GO 38342
// SetTag ( j , 0 ) ;
38330: LD_VAR 0 5
38334: PPUSH
38335: LD_INT 0
38337: PPUSH
38338: CALL_OW 109
38342: GO 38277
38344: POP
38345: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38346: LD_INT 1
38348: PPUSH
38349: LD_VAR 0 1
38353: PPUSH
38354: CALL_OW 321
38358: PUSH
38359: LD_INT 2
38361: EQUAL
38362: PUSH
38363: LD_EXP 37
38367: PUSH
38368: LD_VAR 0 1
38372: ARRAY
38373: NOT
38374: AND
38375: PUSH
38376: LD_VAR 0 1
38380: PPUSH
38381: LD_INT 4
38383: PPUSH
38384: EMPTY
38385: PPUSH
38386: CALL 11492 0 3
38390: AND
38391: IFFALSE 38439
// for j in MCF_Class ( side , 4 , [ ] ) do
38393: LD_ADDR_VAR 0 5
38397: PUSH
38398: LD_VAR 0 1
38402: PPUSH
38403: LD_INT 4
38405: PPUSH
38406: EMPTY
38407: PPUSH
38408: CALL 11492 0 3
38412: PUSH
38413: FOR_IN
38414: IFFALSE 38437
// MCN_Tame ( GetSide ( j ) , j ) ;
38416: LD_VAR 0 5
38420: PPUSH
38421: CALL_OW 255
38425: PPUSH
38426: LD_VAR 0 5
38430: PPUSH
38431: CALL 18311 0 2
38435: GO 38413
38437: POP
38438: POP
// if MREG_DefVeh [ side ] then
38439: LD_EXP 69
38443: PUSH
38444: LD_VAR 0 1
38448: ARRAY
38449: IFFALSE 38613
// begin for i in MREG_DefVeh [ side ] do
38451: LD_ADDR_VAR 0 4
38455: PUSH
38456: LD_EXP 69
38460: PUSH
38461: LD_VAR 0 1
38465: ARRAY
38466: PUSH
38467: FOR_IN
38468: IFFALSE 38521
// begin SetTag ( i , 0 ) ;
38470: LD_VAR 0 4
38474: PPUSH
38475: LD_INT 0
38477: PPUSH
38478: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38482: LD_VAR 0 4
38486: PPUSH
38487: LD_EXP 66
38491: PUSH
38492: LD_VAR 0 1
38496: ARRAY
38497: PPUSH
38498: CALL_OW 308
38502: NOT
38503: IFFALSE 38519
// MCV_Parking ( side , i ) ;
38505: LD_VAR 0 1
38509: PPUSH
38510: LD_VAR 0 4
38514: PPUSH
38515: CALL 25570 0 2
// end ;
38519: GO 38467
38521: POP
38522: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38523: LD_VAR 0 1
38527: PPUSH
38528: LD_INT 36
38530: PPUSH
38531: EMPTY
38532: PPUSH
38533: CALL 12112 0 3
38537: IFFALSE 38578
// for i in MCF_Tag ( side , 36 , [ ] ) do
38539: LD_ADDR_VAR 0 4
38543: PUSH
38544: LD_VAR 0 1
38548: PPUSH
38549: LD_INT 36
38551: PPUSH
38552: EMPTY
38553: PPUSH
38554: CALL 12112 0 3
38558: PUSH
38559: FOR_IN
38560: IFFALSE 38576
// SetTag ( i , 0 ) ;
38562: LD_VAR 0 4
38566: PPUSH
38567: LD_INT 0
38569: PPUSH
38570: CALL_OW 109
38574: GO 38559
38576: POP
38577: POP
// if MREG_DefMobActive [ side ] then
38578: LD_EXP 72
38582: PUSH
38583: LD_VAR 0 1
38587: ARRAY
38588: IFFALSE 38613
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38590: LD_ADDR_EXP 72
38594: PUSH
38595: LD_EXP 72
38599: PPUSH
38600: LD_VAR 0 1
38604: PPUSH
38605: LD_INT 0
38607: PPUSH
38608: CALL_OW 1
38612: ST_TO_ADDR
// end ; end ; if mode > 0 then
38613: LD_VAR 0 2
38617: PUSH
38618: LD_INT 0
38620: GREATER
38621: IFFALSE 40636
// begin if tick <= 15 15$00 then
38623: LD_OWVAR 1
38627: PUSH
38628: LD_INT 31500
38630: LESSEQUAL
38631: IFFALSE 39055
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38633: LD_VAR 0 13
38637: PUSH
38638: LD_INT 4
38640: GREATER
38641: PUSH
38642: LD_VAR 0 1
38646: PPUSH
38647: CALL 24810 0 1
38651: PUSH
38652: LD_INT 4
38654: LESS
38655: AND
38656: IFFALSE 38767
// for i in sol do
38658: LD_ADDR_VAR 0 4
38662: PUSH
38663: LD_VAR 0 13
38667: PUSH
38668: FOR_IN
38669: IFFALSE 38765
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38671: LD_ADDR_VAR 0 8
38675: PUSH
38676: LD_VAR 0 1
38680: PPUSH
38681: CALL 24810 0 1
38685: PPUSH
38686: LD_VAR 0 4
38690: PPUSH
38691: CALL_OW 74
38695: ST_TO_ADDR
// if IsInUnit ( i ) then
38696: LD_VAR 0 4
38700: PPUSH
38701: CALL_OW 310
38705: IFFALSE 38716
// ComExitBuilding ( i ) ;
38707: LD_VAR 0 4
38711: PPUSH
38712: CALL_OW 122
// if not HasTask ( i ) and k then
38716: LD_VAR 0 4
38720: PPUSH
38721: CALL_OW 314
38725: NOT
38726: PUSH
38727: LD_VAR 0 8
38731: AND
38732: IFFALSE 38763
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38734: LD_VAR 0 4
38738: PPUSH
38739: LD_VAR 0 8
38743: PPUSH
38744: CALL_OW 250
38748: PPUSH
38749: LD_VAR 0 8
38753: PPUSH
38754: CALL_OW 251
38758: PPUSH
38759: CALL_OW 114
// end ;
38763: GO 38668
38765: POP
38766: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38767: LD_VAR 0 1
38771: PPUSH
38772: LD_INT 30
38774: PUSH
38775: LD_INT 5
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PPUSH
38782: CALL 11409 0 2
38786: IFFALSE 39053
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38788: LD_ADDR_VAR 0 11
38792: PUSH
38793: LD_VAR 0 1
38797: PPUSH
38798: LD_INT 30
38800: PUSH
38801: LD_INT 5
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PPUSH
38808: CALL 11409 0 2
38812: PUSH
38813: LD_INT 1
38815: ARRAY
38816: ST_TO_ADDR
// if mech then
38817: LD_VAR 0 15
38821: IFFALSE 38857
// for i in mech do
38823: LD_ADDR_VAR 0 4
38827: PUSH
38828: LD_VAR 0 15
38832: PUSH
38833: FOR_IN
38834: IFFALSE 38855
// MCH_ChangeClass ( side , i , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 4
38845: PPUSH
38846: LD_INT 1
38848: PPUSH
38849: CALL 16316 0 3
38853: GO 38833
38855: POP
38856: POP
// if eng > 1 then
38857: LD_VAR 0 14
38861: PUSH
38862: LD_INT 1
38864: GREATER
38865: IFFALSE 38912
// for i = eng downto 2 do
38867: LD_ADDR_VAR 0 4
38871: PUSH
38872: DOUBLE
38873: LD_VAR 0 14
38877: INC
38878: ST_TO_ADDR
38879: LD_INT 2
38881: PUSH
38882: FOR_DOWNTO
38883: IFFALSE 38910
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38885: LD_VAR 0 1
38889: PPUSH
38890: LD_VAR 0 14
38894: PUSH
38895: LD_VAR 0 4
38899: ARRAY
38900: PPUSH
38901: LD_INT 1
38903: PPUSH
38904: CALL 16316 0 3
38908: GO 38882
38910: POP
38911: POP
// if UnitsInside ( b ) = 6 then
38912: LD_VAR 0 11
38916: PPUSH
38917: CALL_OW 313
38921: PUSH
38922: LD_INT 6
38924: EQUAL
38925: IFFALSE 39053
// begin un := UnitsInside ( b ) [ 1 ] ;
38927: LD_ADDR_VAR 0 9
38931: PUSH
38932: LD_VAR 0 11
38936: PPUSH
38937: CALL_OW 313
38941: PUSH
38942: LD_INT 1
38944: ARRAY
38945: ST_TO_ADDR
// ComExitBuilding ( un ) ;
38946: LD_VAR 0 9
38950: PPUSH
38951: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
38955: LD_VAR 0 1
38959: PPUSH
38960: LD_INT 30
38962: PUSH
38963: LD_INT 5
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PPUSH
38970: CALL 11409 0 2
38974: PUSH
38975: LD_INT 1
38977: GREATER
38978: PUSH
38979: LD_VAR 0 1
38983: PPUSH
38984: CALL 24810 0 1
38988: PUSH
38989: LD_INT 4
38991: GREATEREQUAL
38992: AND
38993: IFFALSE 39053
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
38995: LD_ADDR_VAR 0 8
38999: PUSH
39000: LD_VAR 0 1
39004: PPUSH
39005: LD_INT 30
39007: PUSH
39008: LD_INT 5
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PPUSH
39015: CALL 11409 0 2
39019: PUSH
39020: LD_INT 2
39022: ARRAY
39023: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39024: LD_VAR 0 8
39028: PPUSH
39029: CALL_OW 313
39033: PUSH
39034: LD_INT 6
39036: LESS
39037: IFFALSE 39053
// AddComEnterUnit ( un , k ) ;
39039: LD_VAR 0 9
39043: PPUSH
39044: LD_VAR 0 8
39048: PPUSH
39049: CALL_OW 180
// end ; end ; end ; end else
39053: GO 40636
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39055: LD_VAR 0 1
39059: PPUSH
39060: LD_INT 1
39062: PPUSH
39063: LD_EXP 67
39067: PUSH
39068: LD_VAR 0 1
39072: ARRAY
39073: PUSH
39074: LD_INT 1
39076: ARRAY
39077: PPUSH
39078: CALL 33788 0 3
39082: IFFALSE 39221
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39084: LD_ADDR_VAR 0 12
39088: PUSH
39089: LD_VAR 0 1
39093: PPUSH
39094: LD_INT 21
39096: PUSH
39097: LD_INT 1
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PPUSH
39104: CALL 11409 0 2
39108: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39109: LD_ADDR_VAR 0 11
39113: PUSH
39114: LD_VAR 0 1
39118: PPUSH
39119: LD_INT 30
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PPUSH
39129: CALL 11409 0 2
39133: ST_TO_ADDR
// if b then
39134: LD_VAR 0 11
39138: IFFALSE 39221
// for i in tmp do
39140: LD_ADDR_VAR 0 4
39144: PUSH
39145: LD_VAR 0 12
39149: PUSH
39150: FOR_IN
39151: IFFALSE 39219
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39153: LD_VAR 0 4
39157: PPUSH
39158: LD_EXP 67
39162: PUSH
39163: LD_VAR 0 1
39167: ARRAY
39168: PUSH
39169: LD_INT 1
39171: ARRAY
39172: PPUSH
39173: CALL_OW 308
39177: NOT
39178: IFFALSE 39217
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39180: LD_VAR 0 4
39184: PPUSH
39185: LD_VAR 0 11
39189: PUSH
39190: LD_INT 1
39192: ARRAY
39193: PPUSH
39194: CALL_OW 250
39198: PPUSH
39199: LD_VAR 0 11
39203: PUSH
39204: LD_INT 1
39206: ARRAY
39207: PPUSH
39208: CALL_OW 251
39212: PPUSH
39213: CALL_OW 111
39217: GO 39150
39219: POP
39220: POP
// end ; if MREG_DefVeh [ side ] then
39221: LD_EXP 69
39225: PUSH
39226: LD_VAR 0 1
39230: ARRAY
39231: IFFALSE 39799
// begin tmp := [ ] ;
39233: LD_ADDR_VAR 0 12
39237: PUSH
39238: EMPTY
39239: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39240: LD_EXP 72
39244: PUSH
39245: LD_VAR 0 1
39249: ARRAY
39250: PUSH
39251: LD_INT 0
39253: EQUAL
39254: IFFALSE 39394
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39256: LD_ADDR_VAR 0 8
39260: PUSH
39261: LD_VAR 0 1
39265: PPUSH
39266: LD_INT 0
39268: PPUSH
39269: LD_INT 25
39271: PUSH
39272: LD_INT 3
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PPUSH
39279: CALL 12112 0 3
39283: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39284: LD_VAR 0 8
39288: PUSH
39289: LD_EXP 69
39293: PUSH
39294: LD_VAR 0 1
39298: ARRAY
39299: GREATER
39300: IFFALSE 39361
// begin for i = 1 to MREG_DefVeh [ side ] do
39302: LD_ADDR_VAR 0 4
39306: PUSH
39307: DOUBLE
39308: LD_INT 1
39310: DEC
39311: ST_TO_ADDR
39312: LD_EXP 69
39316: PUSH
39317: LD_VAR 0 1
39321: ARRAY
39322: PUSH
39323: FOR_TO
39324: IFFALSE 39357
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39326: LD_ADDR_VAR 0 12
39330: PUSH
39331: LD_VAR 0 12
39335: PPUSH
39336: LD_INT 1
39338: PPUSH
39339: LD_VAR 0 8
39343: PUSH
39344: LD_VAR 0 4
39348: ARRAY
39349: PPUSH
39350: CALL_OW 2
39354: ST_TO_ADDR
39355: GO 39323
39357: POP
39358: POP
// end else
39359: GO 39371
// tmp := k ;
39361: LD_ADDR_VAR 0 12
39365: PUSH
39366: LD_VAR 0 8
39370: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39371: LD_ADDR_EXP 72
39375: PUSH
39376: LD_EXP 72
39380: PPUSH
39381: LD_VAR 0 1
39385: PPUSH
39386: LD_INT 1
39388: PPUSH
39389: CALL_OW 1
39393: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39394: LD_ADDR_VAR 0 4
39398: PUSH
39399: LD_EXP 69
39403: PUSH
39404: LD_VAR 0 1
39408: ARRAY
39409: PUSH
39410: FOR_IN
39411: IFFALSE 39797
// begin if not GetDriver ( i ) then
39413: LD_VAR 0 4
39417: PPUSH
39418: CALL 31537 0 1
39422: NOT
39423: IFFALSE 39498
// begin if tmp then
39425: LD_VAR 0 12
39429: IFFALSE 39496
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39431: LD_VAR 0 12
39435: PUSH
39436: LD_INT 1
39438: ARRAY
39439: PPUSH
39440: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39444: LD_VAR 0 12
39448: PUSH
39449: LD_INT 1
39451: ARRAY
39452: PPUSH
39453: LD_VAR 0 4
39457: PPUSH
39458: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39462: LD_VAR 0 12
39466: PUSH
39467: LD_INT 1
39469: ARRAY
39470: PPUSH
39471: LD_INT 36
39473: PPUSH
39474: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39478: LD_ADDR_VAR 0 12
39482: PUSH
39483: LD_VAR 0 12
39487: PPUSH
39488: LD_INT 1
39490: PPUSH
39491: CALL_OW 3
39495: ST_TO_ADDR
// end ; end else
39496: GO 39795
// begin if GetTag ( i ) = 0 then
39498: LD_VAR 0 4
39502: PPUSH
39503: CALL_OW 110
39507: PUSH
39508: LD_INT 0
39510: EQUAL
39511: IFFALSE 39527
// SetTag ( i , 31 ) else
39513: LD_VAR 0 4
39517: PPUSH
39518: LD_INT 31
39520: PPUSH
39521: CALL_OW 109
39525: GO 39795
// if GetTag ( i ) = 31 then
39527: LD_VAR 0 4
39531: PPUSH
39532: CALL_OW 110
39536: PUSH
39537: LD_INT 31
39539: EQUAL
39540: IFFALSE 39795
// begin if GetFuel ( i ) < 20 then
39542: LD_VAR 0 4
39546: PPUSH
39547: CALL_OW 261
39551: PUSH
39552: LD_INT 20
39554: LESS
39555: IFFALSE 39580
// begin SetTag ( i , 21 ) ;
39557: LD_VAR 0 4
39561: PPUSH
39562: LD_INT 21
39564: PPUSH
39565: CALL_OW 109
// MCV_Refuel ( i ) ;
39569: LD_VAR 0 4
39573: PPUSH
39574: CALL 26107 0 1
// continue ;
39578: GO 39410
// end ; if GetLives ( i ) < 700 then
39580: LD_VAR 0 4
39584: PPUSH
39585: CALL_OW 256
39589: PUSH
39590: LD_INT 700
39592: LESS
39593: IFFALSE 39705
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39595: LD_VAR 0 4
39599: PPUSH
39600: LD_EXP 60
39604: PUSH
39605: LD_VAR 0 1
39609: ARRAY
39610: PPUSH
39611: CALL_OW 308
39615: NOT
39616: IFFALSE 39640
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39618: LD_VAR 0 4
39622: PPUSH
39623: LD_EXP 60
39627: PUSH
39628: LD_VAR 0 1
39632: ARRAY
39633: PPUSH
39634: CALL_OW 113
39638: GO 39703
// if GetDriver ( i ) then
39640: LD_VAR 0 4
39644: PPUSH
39645: CALL 31537 0 1
39649: IFFALSE 39703
// begin k := GetDriver ( i ) ;
39651: LD_ADDR_VAR 0 8
39655: PUSH
39656: LD_VAR 0 4
39660: PPUSH
39661: CALL 31537 0 1
39665: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39666: LD_VAR 0 8
39670: PPUSH
39671: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39675: LD_VAR 0 8
39679: PPUSH
39680: LD_VAR 0 4
39684: PPUSH
39685: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39689: LD_VAR 0 8
39693: PPUSH
39694: LD_VAR 0 4
39698: PPUSH
39699: CALL_OW 180
// end ; end else
39703: GO 39795
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39705: LD_ADDR_VAR 0 8
39709: PUSH
39710: LD_VAR 0 1
39714: PPUSH
39715: CALL 24810 0 1
39719: PPUSH
39720: LD_VAR 0 4
39724: PPUSH
39725: CALL_OW 74
39729: ST_TO_ADDR
// if k then
39730: LD_VAR 0 8
39734: IFFALSE 39752
// ComAttackUnit ( i , k ) else
39736: LD_VAR 0 4
39740: PPUSH
39741: LD_VAR 0 8
39745: PPUSH
39746: CALL_OW 115
39750: GO 39795
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39752: LD_VAR 0 4
39756: PPUSH
39757: LD_EXP 60
39761: PUSH
39762: LD_VAR 0 1
39766: ARRAY
39767: PPUSH
39768: CALL_OW 308
39772: NOT
39773: IFFALSE 39795
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39775: LD_VAR 0 4
39779: PPUSH
39780: LD_EXP 60
39784: PUSH
39785: LD_VAR 0 1
39789: ARRAY
39790: PPUSH
39791: CALL_OW 113
// end ; end ; end ; end ;
39795: GO 39410
39797: POP
39798: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39799: LD_VAR 0 1
39803: PPUSH
39804: LD_INT 30
39806: PUSH
39807: LD_INT 5
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PPUSH
39814: CALL 11409 0 2
39818: IFFALSE 40636
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39820: LD_ADDR_VAR 0 11
39824: PUSH
39825: LD_VAR 0 1
39829: PPUSH
39830: LD_INT 30
39832: PUSH
39833: LD_INT 5
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PPUSH
39840: CALL 11409 0 2
39844: PUSH
39845: LD_INT 1
39847: ARRAY
39848: ST_TO_ADDR
// if eng > 1 then
39849: LD_VAR 0 14
39853: PUSH
39854: LD_INT 1
39856: GREATER
39857: IFFALSE 39904
// for i = eng downto 2 do
39859: LD_ADDR_VAR 0 4
39863: PUSH
39864: DOUBLE
39865: LD_VAR 0 14
39869: INC
39870: ST_TO_ADDR
39871: LD_INT 2
39873: PUSH
39874: FOR_DOWNTO
39875: IFFALSE 39902
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39877: LD_VAR 0 1
39881: PPUSH
39882: LD_VAR 0 14
39886: PUSH
39887: LD_VAR 0 4
39891: ARRAY
39892: PPUSH
39893: LD_INT 1
39895: PPUSH
39896: CALL 16316 0 3
39900: GO 39874
39902: POP
39903: POP
// if sci > 1 then
39904: LD_VAR 0 16
39908: PUSH
39909: LD_INT 1
39911: GREATER
39912: IFFALSE 39959
// for i = sci downto 2 do
39914: LD_ADDR_VAR 0 4
39918: PUSH
39919: DOUBLE
39920: LD_VAR 0 16
39924: INC
39925: ST_TO_ADDR
39926: LD_INT 2
39928: PUSH
39929: FOR_DOWNTO
39930: IFFALSE 39957
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39932: LD_VAR 0 1
39936: PPUSH
39937: LD_VAR 0 16
39941: PUSH
39942: LD_VAR 0 4
39946: ARRAY
39947: PPUSH
39948: LD_INT 1
39950: PPUSH
39951: CALL 16316 0 3
39955: GO 39929
39957: POP
39958: POP
// if sol then
39959: LD_VAR 0 13
39963: IFFALSE 40636
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39965: LD_VAR 0 13
39969: PUSH
39970: LD_EXP 70
39974: PUSH
39975: LD_VAR 0 1
39979: ARRAY
39980: DIFF
39981: PUSH
39982: LD_INT 22
39984: PUSH
39985: LD_VAR 0 1
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 58
39996: PUSH
39997: EMPTY
39998: LIST
39999: PUSH
40000: LD_INT 2
40002: PUSH
40003: LD_INT 30
40005: PUSH
40006: LD_INT 32
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 30
40015: PUSH
40016: LD_INT 31
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: LIST
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: LIST
40032: PPUSH
40033: CALL_OW 69
40037: PUSH
40038: LD_INT 0
40040: EQUAL
40041: AND
40042: IFFALSE 40636
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40044: LD_ADDR_VAR 0 12
40048: PUSH
40049: LD_VAR 0 13
40053: PUSH
40054: LD_EXP 70
40058: PUSH
40059: LD_VAR 0 1
40063: ARRAY
40064: DIFF
40065: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40066: LD_VAR 0 1
40070: PPUSH
40071: LD_INT 30
40073: PUSH
40074: LD_INT 5
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PPUSH
40081: CALL 11409 0 2
40085: PUSH
40086: LD_INT 1
40088: GREATER
40089: IFFALSE 40120
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40091: LD_ADDR_VAR 0 8
40095: PUSH
40096: LD_VAR 0 1
40100: PPUSH
40101: LD_INT 30
40103: PUSH
40104: LD_INT 5
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PPUSH
40111: CALL 11409 0 2
40115: PUSH
40116: LD_INT 2
40118: ARRAY
40119: ST_TO_ADDR
// for j in tmp do
40120: LD_ADDR_VAR 0 5
40124: PUSH
40125: LD_VAR 0 12
40129: PUSH
40130: FOR_IN
40131: IFFALSE 40634
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40133: LD_VAR 0 5
40137: PUSH
40138: LD_VAR 0 11
40142: PPUSH
40143: CALL_OW 313
40147: IN
40148: PUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 313
40158: PUSH
40159: LD_INT 6
40161: EQUAL
40162: AND
40163: PUSH
40164: LD_VAR 0 8
40168: AND
40169: PUSH
40170: LD_VAR 0 8
40174: PPUSH
40175: CALL_OW 313
40179: PUSH
40180: LD_INT 6
40182: LESS
40183: AND
40184: IFFALSE 40211
// begin ComExitBuilding ( j ) ;
40186: LD_VAR 0 5
40190: PPUSH
40191: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40195: LD_VAR 0 5
40199: PPUSH
40200: LD_VAR 0 8
40204: PPUSH
40205: CALL_OW 180
// continue ;
40209: GO 40130
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 314
40220: NOT
40221: PUSH
40222: LD_VAR 0 5
40226: PPUSH
40227: CALL_OW 110
40231: PUSH
40232: LD_INT 0
40234: EQUAL
40235: AND
40236: PUSH
40237: LD_VAR 0 5
40241: PPUSH
40242: CALL_OW 310
40246: NOT
40247: AND
40248: IFFALSE 40354
// begin if k then
40250: LD_VAR 0 8
40254: IFFALSE 40325
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40256: LD_VAR 0 8
40260: PPUSH
40261: CALL_OW 313
40265: PUSH
40266: LD_VAR 0 11
40270: PPUSH
40271: CALL_OW 313
40275: LESS
40276: IFFALSE 40294
// ComEnterUnit ( j , k ) else
40278: LD_VAR 0 5
40282: PPUSH
40283: LD_VAR 0 8
40287: PPUSH
40288: CALL_OW 120
40292: GO 40323
// if UnitsInside ( b ) < 6 then
40294: LD_VAR 0 11
40298: PPUSH
40299: CALL_OW 313
40303: PUSH
40304: LD_INT 6
40306: LESS
40307: IFFALSE 40323
// ComEnterUnit ( j , b ) ;
40309: LD_VAR 0 5
40313: PPUSH
40314: LD_VAR 0 11
40318: PPUSH
40319: CALL_OW 120
// end else
40323: GO 40354
// if UnitsInside ( b ) < 6 then
40325: LD_VAR 0 11
40329: PPUSH
40330: CALL_OW 313
40334: PUSH
40335: LD_INT 6
40337: LESS
40338: IFFALSE 40354
// ComEnterUnit ( j , b ) ;
40340: LD_VAR 0 5
40344: PPUSH
40345: LD_VAR 0 11
40349: PPUSH
40350: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40354: LD_VAR 0 5
40358: PUSH
40359: LD_VAR 0 1
40363: PPUSH
40364: LD_INT 54
40366: PUSH
40367: EMPTY
40368: LIST
40369: PPUSH
40370: CALL 11409 0 2
40374: IN
40375: PUSH
40376: LD_VAR 0 5
40380: PPUSH
40381: CALL_OW 257
40385: PUSH
40386: LD_INT 1
40388: EQUAL
40389: AND
40390: IFFALSE 40632
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40392: LD_EXP 64
40396: PUSH
40397: LD_VAR 0 1
40401: ARRAY
40402: PUSH
40403: LD_INT 1
40405: ARRAY
40406: PUSH
40407: LD_INT 12
40409: PPUSH
40410: LD_VAR 0 1
40414: PPUSH
40415: CALL_OW 321
40419: PUSH
40420: LD_INT 2
40422: EQUAL
40423: AND
40424: IFFALSE 40472
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40426: LD_VAR 0 1
40430: PPUSH
40431: LD_INT 5
40433: PPUSH
40434: EMPTY
40435: PPUSH
40436: CALL 11492 0 3
40440: PUSH
40441: LD_EXP 64
40445: PUSH
40446: LD_VAR 0 1
40450: ARRAY
40451: PUSH
40452: LD_INT 1
40454: ARRAY
40455: LESS
40456: IFFALSE 40472
// begin SetClass ( j , class_sniper ) ;
40458: LD_VAR 0 5
40462: PPUSH
40463: LD_INT 5
40465: PPUSH
40466: CALL_OW 336
// continue ;
40470: GO 40130
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40472: LD_EXP 64
40476: PUSH
40477: LD_VAR 0 1
40481: ARRAY
40482: PUSH
40483: LD_INT 2
40485: ARRAY
40486: PUSH
40487: LD_INT 41
40489: PPUSH
40490: LD_VAR 0 1
40494: PPUSH
40495: CALL_OW 321
40499: PUSH
40500: LD_INT 2
40502: EQUAL
40503: AND
40504: IFFALSE 40552
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40506: LD_VAR 0 1
40510: PPUSH
40511: LD_INT 8
40513: PPUSH
40514: EMPTY
40515: PPUSH
40516: CALL 11492 0 3
40520: PUSH
40521: LD_EXP 64
40525: PUSH
40526: LD_VAR 0 1
40530: ARRAY
40531: PUSH
40532: LD_INT 2
40534: ARRAY
40535: LESS
40536: IFFALSE 40552
// begin SetClass ( j , class_mortar ) ;
40538: LD_VAR 0 5
40542: PPUSH
40543: LD_INT 8
40545: PPUSH
40546: CALL_OW 336
// continue ;
40550: GO 40130
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40552: LD_EXP 64
40556: PUSH
40557: LD_VAR 0 1
40561: ARRAY
40562: PUSH
40563: LD_INT 3
40565: ARRAY
40566: PUSH
40567: LD_INT 44
40569: PPUSH
40570: LD_VAR 0 1
40574: PPUSH
40575: CALL_OW 321
40579: PUSH
40580: LD_INT 2
40582: EQUAL
40583: AND
40584: IFFALSE 40632
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40586: LD_VAR 0 1
40590: PPUSH
40591: LD_INT 9
40593: PPUSH
40594: EMPTY
40595: PPUSH
40596: CALL 11492 0 3
40600: PUSH
40601: LD_EXP 64
40605: PUSH
40606: LD_VAR 0 1
40610: ARRAY
40611: PUSH
40612: LD_INT 3
40614: ARRAY
40615: LESS
40616: IFFALSE 40632
// begin SetClass ( j , class_bazooker ) ;
40618: LD_VAR 0 5
40622: PPUSH
40623: LD_INT 9
40625: PPUSH
40626: CALL_OW 336
// continue ;
40630: GO 40130
// end ; end ; end ;
40632: GO 40130
40634: POP
40635: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40636: LD_INT 22
40638: PUSH
40639: LD_VAR 0 1
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 58
40650: PUSH
40651: EMPTY
40652: LIST
40653: PUSH
40654: LD_INT 30
40656: PUSH
40657: LD_INT 32
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: LIST
40668: PPUSH
40669: CALL_OW 69
40673: IFFALSE 40823
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40675: LD_ADDR_VAR 0 12
40679: PUSH
40680: LD_INT 22
40682: PUSH
40683: LD_VAR 0 1
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 58
40694: PUSH
40695: EMPTY
40696: LIST
40697: PUSH
40698: LD_INT 30
40700: PUSH
40701: LD_INT 32
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: LIST
40712: PPUSH
40713: CALL_OW 69
40717: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40718: LD_ADDR_VAR 0 8
40722: PUSH
40723: LD_VAR 0 13
40727: PUSH
40728: LD_EXP 70
40732: PUSH
40733: LD_VAR 0 1
40737: ARRAY
40738: DIFF
40739: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40740: LD_VAR 0 12
40744: PUSH
40745: LD_INT 1
40747: ARRAY
40748: PPUSH
40749: CALL_OW 461
40753: PUSH
40754: LD_INT 2
40756: EQUAL
40757: PUSH
40758: LD_VAR 0 12
40762: PUSH
40763: LD_INT 1
40765: ARRAY
40766: PUSH
40767: LD_EXP 70
40771: PUSH
40772: LD_VAR 0 1
40776: ARRAY
40777: IN
40778: NOT
40779: AND
40780: PUSH
40781: LD_VAR 0 8
40785: AND
40786: IFFALSE 40823
// begin ComExitBuilding ( k [ 1 ] ) ;
40788: LD_VAR 0 8
40792: PUSH
40793: LD_INT 1
40795: ARRAY
40796: PPUSH
40797: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40801: LD_VAR 0 8
40805: PUSH
40806: LD_INT 1
40808: ARRAY
40809: PPUSH
40810: LD_VAR 0 12
40814: PUSH
40815: LD_INT 1
40817: ARRAY
40818: PPUSH
40819: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40823: LD_EXP 37
40827: PUSH
40828: LD_VAR 0 1
40832: ARRAY
40833: IFFALSE 40981
// begin if MCF_Class ( side , 4 , [ ] ) then
40835: LD_VAR 0 1
40839: PPUSH
40840: LD_INT 4
40842: PPUSH
40843: EMPTY
40844: PPUSH
40845: CALL 11492 0 3
40849: IFFALSE 40979
// for j in MCF_Class ( side , 4 , [ ] ) do
40851: LD_ADDR_VAR 0 5
40855: PUSH
40856: LD_VAR 0 1
40860: PPUSH
40861: LD_INT 4
40863: PPUSH
40864: EMPTY
40865: PPUSH
40866: CALL 11492 0 3
40870: PUSH
40871: FOR_IN
40872: IFFALSE 40977
// begin if not GetTag ( j ) = 4 then
40874: LD_VAR 0 5
40878: PPUSH
40879: CALL_OW 110
40883: PUSH
40884: LD_INT 4
40886: EQUAL
40887: NOT
40888: IFFALSE 40924
// begin SetTag ( j , 4 ) ;
40890: LD_VAR 0 5
40894: PPUSH
40895: LD_INT 4
40897: PPUSH
40898: CALL_OW 109
// if IsInUnit ( j ) then
40902: LD_VAR 0 5
40906: PPUSH
40907: CALL_OW 310
40911: IFFALSE 40922
// ComExitBuilding ( j ) ;
40913: LD_VAR 0 5
40917: PPUSH
40918: CALL_OW 122
// end else
40922: GO 40975
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40924: LD_VAR 0 5
40928: PPUSH
40929: LD_EXP 37
40933: PUSH
40934: LD_VAR 0 1
40938: ARRAY
40939: PUSH
40940: LD_INT 1
40942: ARRAY
40943: PPUSH
40944: CALL 32228 0 2
40948: NOT
40949: IFFALSE 40975
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40951: LD_VAR 0 5
40955: PPUSH
40956: LD_EXP 37
40960: PUSH
40961: LD_VAR 0 1
40965: ARRAY
40966: PUSH
40967: LD_INT 1
40969: ARRAY
40970: PPUSH
40971: CALL 18979 0 2
// end ;
40975: GO 40871
40977: POP
40978: POP
// end else
40979: GO 41213
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40981: LD_VAR 0 1
40985: PPUSH
40986: LD_INT 4
40988: PPUSH
40989: EMPTY
40990: PPUSH
40991: CALL 11492 0 3
40995: PUSH
40996: LD_VAR 0 1
41000: PPUSH
41001: LD_INT 4
41003: PPUSH
41004: EMPTY
41005: PPUSH
41006: CALL 12112 0 3
41010: AND
41011: IFFALSE 41213
// for j in MCF_Class ( side , 4 , [ ] ) do
41013: LD_ADDR_VAR 0 5
41017: PUSH
41018: LD_VAR 0 1
41022: PPUSH
41023: LD_INT 4
41025: PPUSH
41026: EMPTY
41027: PPUSH
41028: CALL 11492 0 3
41032: PUSH
41033: FOR_IN
41034: IFFALSE 41211
// begin if GetTag ( j ) = 4 then
41036: LD_VAR 0 5
41040: PPUSH
41041: CALL_OW 110
41045: PUSH
41046: LD_INT 4
41048: EQUAL
41049: IFFALSE 41209
// begin SetTag ( j , 0 ) ;
41051: LD_VAR 0 5
41055: PPUSH
41056: LD_INT 0
41058: PPUSH
41059: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41063: LD_VAR 0 1
41067: PPUSH
41068: CALL 11448 0 1
41072: PUSH
41073: LD_VAR 0 1
41077: PPUSH
41078: CALL 17792 0 1
41082: NOT
41083: AND
41084: IFFALSE 41109
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41086: LD_VAR 0 5
41090: PPUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: CALL 11448 0 1
41100: PUSH
41101: LD_INT 1
41103: ARRAY
41104: PPUSH
41105: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41109: LD_VAR 0 1
41113: PPUSH
41114: CALL 11448 0 1
41118: NOT
41119: PUSH
41120: LD_VAR 0 1
41124: PPUSH
41125: LD_INT 30
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PPUSH
41135: CALL 11409 0 2
41139: AND
41140: IFFALSE 41209
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41142: LD_VAR 0 5
41146: PPUSH
41147: LD_VAR 0 1
41151: PPUSH
41152: LD_INT 30
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PPUSH
41162: CALL 11409 0 2
41166: PUSH
41167: LD_INT 1
41169: ARRAY
41170: PPUSH
41171: CALL_OW 250
41175: PPUSH
41176: LD_VAR 0 1
41180: PPUSH
41181: LD_INT 30
41183: PUSH
41184: LD_INT 1
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PPUSH
41191: CALL 11409 0 2
41195: PUSH
41196: LD_INT 1
41198: ARRAY
41199: PPUSH
41200: CALL_OW 251
41204: PPUSH
41205: CALL_OW 111
// end ; end ;
41209: GO 41033
41211: POP
41212: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41213: LD_VAR 0 1
41217: PPUSH
41218: LD_INT 3
41220: PPUSH
41221: EMPTY
41222: PPUSH
41223: CALL 11492 0 3
41227: PUSH
41228: LD_EXP 60
41232: PUSH
41233: LD_VAR 0 1
41237: ARRAY
41238: AND
41239: PUSH
41240: LD_VAR 0 1
41244: PPUSH
41245: LD_INT 6
41247: PPUSH
41248: EMPTY
41249: PPUSH
41250: CALL 12112 0 3
41254: AND
41255: IFFALSE 41786
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41257: LD_ADDR_VAR 0 6
41261: PUSH
41262: LD_EXP 60
41266: PUSH
41267: LD_VAR 0 1
41271: ARRAY
41272: PPUSH
41273: LD_INT 0
41275: PPUSH
41276: CALL_OW 517
41280: PUSH
41281: LD_INT 1
41283: ARRAY
41284: PUSH
41285: LD_INT 1
41287: ARRAY
41288: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41289: LD_ADDR_VAR 0 7
41293: PUSH
41294: LD_EXP 60
41298: PUSH
41299: LD_VAR 0 1
41303: ARRAY
41304: PPUSH
41305: LD_INT 0
41307: PPUSH
41308: CALL_OW 517
41312: PUSH
41313: LD_INT 2
41315: ARRAY
41316: PUSH
41317: LD_INT 1
41319: ARRAY
41320: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41321: LD_VAR 0 1
41325: PPUSH
41326: LD_INT 6
41328: PPUSH
41329: EMPTY
41330: PPUSH
41331: CALL 12112 0 3
41335: IFFALSE 41784
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41337: LD_ADDR_VAR 0 8
41341: PUSH
41342: LD_VAR 0 1
41346: PPUSH
41347: LD_INT 6
41349: PPUSH
41350: EMPTY
41351: PPUSH
41352: CALL 12112 0 3
41356: PUSH
41357: FOR_IN
41358: IFFALSE 41389
// if GetLives ( k ) = 1000 then
41360: LD_VAR 0 8
41364: PPUSH
41365: CALL_OW 256
41369: PUSH
41370: LD_INT 1000
41372: EQUAL
41373: IFFALSE 41387
// SetTag ( k , 0 ) ;
41375: LD_VAR 0 8
41379: PPUSH
41380: LD_INT 0
41382: PPUSH
41383: CALL_OW 109
41387: GO 41357
41389: POP
41390: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41391: LD_VAR 0 1
41395: PPUSH
41396: LD_INT 0
41398: PPUSH
41399: LD_INT 25
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PPUSH
41409: CALL 12112 0 3
41413: IFFALSE 41477
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41415: LD_ADDR_VAR 0 8
41419: PUSH
41420: LD_VAR 0 4
41424: PPUSH
41425: LD_INT 0
41427: PPUSH
41428: LD_INT 25
41430: PUSH
41431: LD_INT 3
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PPUSH
41438: CALL 12112 0 3
41442: PUSH
41443: FOR_IN
41444: IFFALSE 41475
// if GetTag ( k ) = 0 then
41446: LD_VAR 0 8
41450: PPUSH
41451: CALL_OW 110
41455: PUSH
41456: LD_INT 0
41458: EQUAL
41459: IFFALSE 41473
// begin SetTag ( k , 8 ) ;
41461: LD_VAR 0 8
41465: PPUSH
41466: LD_INT 8
41468: PPUSH
41469: CALL_OW 109
// end ;
41473: GO 41443
41475: POP
41476: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41477: LD_VAR 0 1
41481: PPUSH
41482: LD_INT 6
41484: PPUSH
41485: LD_INT 92
41487: PUSH
41488: LD_VAR 0 6
41492: PUSH
41493: LD_VAR 0 7
41497: PUSH
41498: LD_INT 10
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: LIST
41505: LIST
41506: PPUSH
41507: CALL 12112 0 3
41511: IFFALSE 41635
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41513: LD_ADDR_VAR 0 5
41517: PUSH
41518: LD_VAR 0 4
41522: PPUSH
41523: LD_INT 6
41525: PPUSH
41526: LD_INT 92
41528: PUSH
41529: LD_VAR 0 6
41533: PUSH
41534: LD_VAR 0 7
41538: PUSH
41539: LD_INT 10
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: PPUSH
41548: CALL 12112 0 3
41552: PUSH
41553: FOR_IN
41554: IFFALSE 41633
// begin if not HasTask ( j ) and GetDriver ( j ) then
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 314
41565: NOT
41566: PUSH
41567: LD_VAR 0 5
41571: PPUSH
41572: CALL 31537 0 1
41576: AND
41577: IFFALSE 41631
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41579: LD_VAR 0 5
41583: PPUSH
41584: CALL 31537 0 1
41588: PPUSH
41589: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41593: LD_VAR 0 5
41597: PPUSH
41598: CALL 31537 0 1
41602: PPUSH
41603: LD_VAR 0 5
41607: PPUSH
41608: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41612: LD_VAR 0 5
41616: PPUSH
41617: CALL 31537 0 1
41621: PPUSH
41622: LD_VAR 0 5
41626: PPUSH
41627: CALL_OW 180
// end ; end ;
41631: GO 41553
41633: POP
41634: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41635: LD_VAR 0 1
41639: PPUSH
41640: LD_INT 6
41642: PPUSH
41643: LD_INT 92
41645: PUSH
41646: LD_VAR 0 6
41650: PUSH
41651: LD_VAR 0 7
41655: PUSH
41656: LD_INT 10
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: LIST
41663: LIST
41664: PPUSH
41665: CALL 12112 0 3
41669: PUSH
41670: LD_VAR 0 1
41674: PPUSH
41675: LD_INT 8
41677: PPUSH
41678: EMPTY
41679: PPUSH
41680: CALL 12112 0 3
41684: AND
41685: IFFALSE 41784
// for j in MCF_Tag ( side , 8 , [ ] ) do
41687: LD_ADDR_VAR 0 5
41691: PUSH
41692: LD_VAR 0 1
41696: PPUSH
41697: LD_INT 8
41699: PPUSH
41700: EMPTY
41701: PPUSH
41702: CALL 12112 0 3
41706: PUSH
41707: FOR_IN
41708: IFFALSE 41782
// begin if IsInUnit ( j ) then
41710: LD_VAR 0 5
41714: PPUSH
41715: CALL_OW 310
41719: IFFALSE 41732
// ComExitBuilding ( j ) else
41721: LD_VAR 0 5
41725: PPUSH
41726: CALL_OW 122
41730: GO 41780
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41732: LD_VAR 0 5
41736: PPUSH
41737: LD_VAR 0 1
41741: PPUSH
41742: LD_INT 6
41744: PPUSH
41745: LD_INT 92
41747: PUSH
41748: LD_VAR 0 6
41752: PUSH
41753: LD_VAR 0 7
41757: PUSH
41758: LD_INT 10
41760: PUSH
41761: EMPTY
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: PPUSH
41767: CALL 12112 0 3
41771: PUSH
41772: LD_INT 1
41774: ARRAY
41775: PPUSH
41776: CALL_OW 129
// end ;
41780: GO 41707
41782: POP
41783: POP
// end ; end else
41784: GO 41841
// if MCF_Tag ( side , 8 , [ ] ) then
41786: LD_VAR 0 1
41790: PPUSH
41791: LD_INT 8
41793: PPUSH
41794: EMPTY
41795: PPUSH
41796: CALL 12112 0 3
41800: IFFALSE 41841
// for k in MCF_Tag ( side , 8 , [ ] ) do
41802: LD_ADDR_VAR 0 8
41806: PUSH
41807: LD_VAR 0 1
41811: PPUSH
41812: LD_INT 8
41814: PPUSH
41815: EMPTY
41816: PPUSH
41817: CALL 12112 0 3
41821: PUSH
41822: FOR_IN
41823: IFFALSE 41839
// SetTag ( k , 0 ) ;
41825: LD_VAR 0 8
41829: PPUSH
41830: LD_INT 0
41832: PPUSH
41833: CALL_OW 109
41837: GO 41822
41839: POP
41840: POP
// end ; end_of_file
41841: LD_VAR 0 3
41845: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41846: LD_INT 0
41848: PPUSH
// MREG_Game := [ ] ;
41849: LD_ADDR_EXP 35
41853: PUSH
41854: EMPTY
41855: ST_TO_ADDR
// MREG_Crates := [ ] ;
41856: LD_ADDR_EXP 36
41860: PUSH
41861: EMPTY
41862: ST_TO_ADDR
// MREG_Heal := [ ] ;
41863: LD_ADDR_EXP 37
41867: PUSH
41868: EMPTY
41869: ST_TO_ADDR
// MREG_Tame := [ ] ;
41870: LD_ADDR_EXP 39
41874: PUSH
41875: EMPTY
41876: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41877: LD_ADDR_EXP 40
41881: PUSH
41882: EMPTY
41883: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41884: LD_ADDR_EXP 41
41888: PUSH
41889: EMPTY
41890: ST_TO_ADDR
// MREG_LabList := [ ] ;
41891: LD_ADDR_EXP 42
41895: PUSH
41896: EMPTY
41897: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41898: LD_ADDR_EXP 43
41902: PUSH
41903: EMPTY
41904: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41905: LD_ADDR_EXP 44
41909: PUSH
41910: EMPTY
41911: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41912: LD_ADDR_EXP 45
41916: PUSH
41917: EMPTY
41918: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41919: LD_ADDR_EXP 46
41923: PUSH
41924: EMPTY
41925: ST_TO_ADDR
// MREG_Status := [ ] ;
41926: LD_ADDR_EXP 47
41930: PUSH
41931: EMPTY
41932: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41933: LD_ADDR_EXP 48
41937: PUSH
41938: EMPTY
41939: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41940: LD_ADDR_EXP 49
41944: PUSH
41945: EMPTY
41946: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41947: LD_ADDR_EXP 50
41951: PUSH
41952: EMPTY
41953: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41954: LD_ADDR_EXP 51
41958: PUSH
41959: EMPTY
41960: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41961: LD_ADDR_EXP 52
41965: PUSH
41966: EMPTY
41967: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41968: LD_ADDR_EXP 53
41972: PUSH
41973: EMPTY
41974: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41975: LD_ADDR_EXP 54
41979: PUSH
41980: EMPTY
41981: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41982: LD_ADDR_EXP 55
41986: PUSH
41987: EMPTY
41988: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41989: LD_ADDR_EXP 56
41993: PUSH
41994: EMPTY
41995: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41996: LD_ADDR_EXP 57
42000: PUSH
42001: EMPTY
42002: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42003: LD_ADDR_EXP 58
42007: PUSH
42008: EMPTY
42009: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42010: LD_ADDR_EXP 59
42014: PUSH
42015: EMPTY
42016: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42017: LD_ADDR_EXP 63
42021: PUSH
42022: EMPTY
42023: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42024: LD_ADDR_EXP 64
42028: PUSH
42029: EMPTY
42030: ST_TO_ADDR
// MREG_Parking := [ ] ;
42031: LD_ADDR_EXP 60
42035: PUSH
42036: EMPTY
42037: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42038: LD_ADDR_EXP 61
42042: PUSH
42043: EMPTY
42044: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42045: LD_ADDR_EXP 65
42049: PUSH
42050: EMPTY
42051: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42052: LD_ADDR_EXP 66
42056: PUSH
42057: EMPTY
42058: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42059: LD_ADDR_EXP 67
42063: PUSH
42064: EMPTY
42065: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42066: LD_ADDR_EXP 69
42070: PUSH
42071: EMPTY
42072: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42073: LD_ADDR_EXP 70
42077: PUSH
42078: EMPTY
42079: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42080: LD_ADDR_EXP 71
42084: PUSH
42085: EMPTY
42086: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42087: LD_ADDR_EXP 73
42091: PUSH
42092: EMPTY
42093: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42094: LD_ADDR_EXP 72
42098: PUSH
42099: EMPTY
42100: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42101: LD_ADDR_EXP 74
42105: PUSH
42106: LD_INT 300
42108: PUSH
42109: LD_INT 100
42111: PUSH
42112: LD_INT 25
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: LIST
42119: ST_TO_ADDR
// end ;
42120: LD_VAR 0 1
42124: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42125: LD_INT 0
42127: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42128: LD_VAR 0 2
42132: PUSH
42133: LD_VAR 0 3
42137: PUSH
42138: LD_VAR 0 4
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: LIST
42147: PUSH
42148: LD_VAR 0 1
42152: IN
42153: IFFALSE 42167
// result := mreg_list else
42155: LD_ADDR_VAR 0 5
42159: PUSH
42160: LD_VAR 0 1
42164: ST_TO_ADDR
42165: GO 42201
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42167: LD_ADDR_VAR 0 1
42171: PUSH
42172: LD_VAR 0 1
42176: PUSH
42177: LD_VAR 0 2
42181: PUSH
42182: LD_VAR 0 3
42186: PUSH
42187: LD_VAR 0 4
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: LIST
42196: PUSH
42197: EMPTY
42198: LIST
42199: ADD
42200: ST_TO_ADDR
// result := mreg_list ;
42201: LD_ADDR_VAR 0 5
42205: PUSH
42206: LD_VAR 0 1
42210: ST_TO_ADDR
// end ;
42211: LD_VAR 0 5
42215: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42216: LD_INT 0
42218: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42219: LD_VAR 0 2
42223: PUSH
42224: LD_VAR 0 3
42228: PUSH
42229: LD_VAR 0 4
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: LIST
42238: PUSH
42239: LD_VAR 0 1
42243: IN
42244: IFFALSE 42282
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42246: LD_ADDR_VAR 0 5
42250: PUSH
42251: LD_VAR 0 1
42255: PUSH
42256: LD_VAR 0 2
42260: PUSH
42261: LD_VAR 0 3
42265: PUSH
42266: LD_VAR 0 4
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: LIST
42275: PUSH
42276: EMPTY
42277: LIST
42278: DIFF
42279: ST_TO_ADDR
42280: GO 42292
// result := mreg_list ;
42282: LD_ADDR_VAR 0 5
42286: PUSH
42287: LD_VAR 0 1
42291: ST_TO_ADDR
// end ;
42292: LD_VAR 0 5
42296: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42297: LD_INT 0
42299: PPUSH
42300: PPUSH
42301: PPUSH
// for j = 1 to 8 do
42302: LD_ADDR_VAR 0 3
42306: PUSH
42307: DOUBLE
42308: LD_INT 1
42310: DEC
42311: ST_TO_ADDR
42312: LD_INT 8
42314: PUSH
42315: FOR_TO
42316: IFFALSE 43157
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42318: LD_VAR 0 3
42322: PPUSH
42323: LD_INT 51
42325: PUSH
42326: EMPTY
42327: LIST
42328: PPUSH
42329: CALL 11409 0 2
42333: PUSH
42334: LD_OWVAR 2
42338: PUSH
42339: LD_VAR 0 3
42343: EQUAL
42344: NOT
42345: AND
42346: IFFALSE 42364
// MREG_SidesList := MREG_SidesList ^ 1 else
42348: LD_ADDR_EXP 41
42352: PUSH
42353: LD_EXP 41
42357: PUSH
42358: LD_INT 1
42360: ADD
42361: ST_TO_ADDR
42362: GO 42378
// MREG_SidesList := MREG_SidesList ^ 0 ;
42364: LD_ADDR_EXP 41
42368: PUSH
42369: LD_EXP 41
42373: PUSH
42374: LD_INT 0
42376: ADD
42377: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42378: LD_VAR 0 3
42382: PPUSH
42383: LD_INT 2
42385: PUSH
42386: LD_INT 34
42388: PUSH
42389: LD_INT 12
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 34
42398: PUSH
42399: LD_INT 32
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: LD_INT 34
42408: PUSH
42409: LD_INT 51
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: PUSH
42422: EMPTY
42423: LIST
42424: PPUSH
42425: CALL 11710 0 2
42429: IFFALSE 42530
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42431: LD_ADDR_VAR 0 2
42435: PUSH
42436: LD_VAR 0 3
42440: PPUSH
42441: LD_INT 2
42443: PUSH
42444: LD_INT 34
42446: PUSH
42447: LD_INT 12
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 34
42456: PUSH
42457: LD_INT 32
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 34
42466: PUSH
42467: LD_INT 51
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PPUSH
42483: CALL 11710 0 2
42487: PUSH
42488: FOR_IN
42489: IFFALSE 42528
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42491: LD_ADDR_EXP 43
42495: PUSH
42496: LD_EXP 43
42500: PPUSH
42501: LD_VAR 0 3
42505: PPUSH
42506: LD_VAR 0 2
42510: PPUSH
42511: LD_VAR 0 2
42515: PPUSH
42516: CALL_OW 264
42520: PPUSH
42521: CALL 42125 0 4
42525: ST_TO_ADDR
42526: GO 42488
42528: POP
42529: POP
// if MCF_Class ( j , 4 , [ ] ) then
42530: LD_VAR 0 3
42534: PPUSH
42535: LD_INT 4
42537: PPUSH
42538: EMPTY
42539: PPUSH
42540: CALL 11492 0 3
42544: IFFALSE 42577
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42546: LD_ADDR_EXP 56
42550: PUSH
42551: LD_EXP 56
42555: PUSH
42556: LD_VAR 0 3
42560: PPUSH
42561: LD_INT 4
42563: PPUSH
42564: EMPTY
42565: PPUSH
42566: CALL 11492 0 3
42570: PUSH
42571: EMPTY
42572: LIST
42573: ADD
42574: ST_TO_ADDR
42575: GO 42594
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42577: LD_ADDR_EXP 56
42581: PUSH
42582: LD_EXP 56
42586: PUSH
42587: LD_INT 0
42589: PUSH
42590: EMPTY
42591: LIST
42592: ADD
42593: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42594: LD_VAR 0 3
42598: PPUSH
42599: LD_INT 3
42601: PPUSH
42602: EMPTY
42603: PPUSH
42604: CALL 11492 0 3
42608: IFFALSE 42641
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42610: LD_ADDR_EXP 57
42614: PUSH
42615: LD_EXP 57
42619: PUSH
42620: LD_VAR 0 3
42624: PPUSH
42625: LD_INT 3
42627: PPUSH
42628: EMPTY
42629: PPUSH
42630: CALL 11492 0 3
42634: PUSH
42635: EMPTY
42636: LIST
42637: ADD
42638: ST_TO_ADDR
42639: GO 42658
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42641: LD_ADDR_EXP 57
42645: PUSH
42646: LD_EXP 57
42650: PUSH
42651: LD_INT 0
42653: PUSH
42654: EMPTY
42655: LIST
42656: ADD
42657: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42658: LD_VAR 0 3
42662: PPUSH
42663: LD_INT 1
42665: PPUSH
42666: EMPTY
42667: PPUSH
42668: CALL 11492 0 3
42672: IFFALSE 42705
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42674: LD_ADDR_EXP 58
42678: PUSH
42679: LD_EXP 58
42683: PUSH
42684: LD_VAR 0 3
42688: PPUSH
42689: LD_INT 1
42691: PPUSH
42692: EMPTY
42693: PPUSH
42694: CALL 11492 0 3
42698: PUSH
42699: EMPTY
42700: LIST
42701: ADD
42702: ST_TO_ADDR
42703: GO 42722
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42705: LD_ADDR_EXP 58
42709: PUSH
42710: LD_EXP 58
42714: PUSH
42715: LD_INT 0
42717: PUSH
42718: EMPTY
42719: LIST
42720: ADD
42721: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42722: LD_VAR 0 3
42726: PPUSH
42727: LD_INT 2
42729: PPUSH
42730: EMPTY
42731: PPUSH
42732: CALL 11492 0 3
42736: IFFALSE 42769
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42738: LD_ADDR_EXP 59
42742: PUSH
42743: LD_EXP 59
42747: PUSH
42748: LD_VAR 0 3
42752: PPUSH
42753: LD_INT 2
42755: PPUSH
42756: EMPTY
42757: PPUSH
42758: CALL 11492 0 3
42762: PUSH
42763: EMPTY
42764: LIST
42765: ADD
42766: ST_TO_ADDR
42767: GO 42786
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42769: LD_ADDR_EXP 59
42773: PUSH
42774: LD_EXP 59
42778: PUSH
42779: LD_INT 0
42781: PUSH
42782: EMPTY
42783: LIST
42784: ADD
42785: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42786: LD_ADDR_EXP 49
42790: PUSH
42791: LD_EXP 49
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: EMPTY
42800: LIST
42801: ADD
42802: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42803: LD_ADDR_EXP 37
42807: PUSH
42808: LD_EXP 37
42812: PUSH
42813: LD_INT 0
42815: PUSH
42816: EMPTY
42817: LIST
42818: ADD
42819: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42820: LD_ADDR_EXP 39
42824: PUSH
42825: LD_EXP 39
42829: PUSH
42830: LD_INT 0
42832: PUSH
42833: EMPTY
42834: LIST
42835: ADD
42836: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42837: LD_ADDR_EXP 60
42841: PUSH
42842: LD_EXP 60
42846: PUSH
42847: LD_INT 0
42849: PUSH
42850: EMPTY
42851: LIST
42852: ADD
42853: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42854: LD_ADDR_EXP 61
42858: PUSH
42859: LD_EXP 61
42863: PUSH
42864: LD_INT 0
42866: PUSH
42867: EMPTY
42868: LIST
42869: ADD
42870: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42871: LD_ADDR_EXP 53
42875: PUSH
42876: LD_EXP 53
42880: PUSH
42881: LD_INT 0
42883: PUSH
42884: EMPTY
42885: LIST
42886: ADD
42887: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42888: LD_ADDR_EXP 40
42892: PUSH
42893: LD_EXP 40
42897: PUSH
42898: LD_INT 0
42900: PUSH
42901: LD_INT 0
42903: PUSH
42904: LD_INT 0
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: PUSH
42916: EMPTY
42917: LIST
42918: ADD
42919: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42920: LD_ADDR_EXP 62
42924: PUSH
42925: LD_EXP 62
42929: PUSH
42930: LD_INT 0
42932: PUSH
42933: EMPTY
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: EMPTY
42940: LIST
42941: ADD
42942: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42943: LD_ADDR_EXP 63
42947: PUSH
42948: LD_EXP 63
42952: PUSH
42953: LD_INT 0
42955: PUSH
42956: EMPTY
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: ADD
42962: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42963: LD_ADDR_EXP 44
42967: PUSH
42968: LD_EXP 44
42972: PUSH
42973: LD_INT 0
42975: PUSH
42976: EMPTY
42977: LIST
42978: ADD
42979: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42980: LD_ADDR_EXP 65
42984: PUSH
42985: LD_EXP 65
42989: PUSH
42990: LD_INT 0
42992: PUSH
42993: EMPTY
42994: LIST
42995: ADD
42996: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42997: LD_ADDR_EXP 66
43001: PUSH
43002: LD_EXP 66
43006: PUSH
43007: LD_INT 0
43009: PUSH
43010: EMPTY
43011: LIST
43012: ADD
43013: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43014: LD_ADDR_EXP 67
43018: PUSH
43019: LD_EXP 67
43023: PUSH
43024: LD_INT 0
43026: PUSH
43027: EMPTY
43028: LIST
43029: ADD
43030: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43031: LD_ADDR_EXP 68
43035: PUSH
43036: LD_EXP 68
43040: PUSH
43041: LD_INT 0
43043: PUSH
43044: EMPTY
43045: LIST
43046: ADD
43047: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43048: LD_ADDR_EXP 69
43052: PUSH
43053: LD_EXP 69
43057: PUSH
43058: LD_INT 0
43060: PUSH
43061: EMPTY
43062: LIST
43063: ADD
43064: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43065: LD_ADDR_EXP 70
43069: PUSH
43070: LD_EXP 70
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: EMPTY
43079: LIST
43080: ADD
43081: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43082: LD_ADDR_EXP 71
43086: PUSH
43087: LD_EXP 71
43091: PUSH
43092: LD_INT 0
43094: PUSH
43095: EMPTY
43096: LIST
43097: ADD
43098: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43099: LD_ADDR_EXP 73
43103: PUSH
43104: LD_EXP 73
43108: PUSH
43109: LD_INT 0
43111: PUSH
43112: EMPTY
43113: LIST
43114: ADD
43115: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43116: LD_ADDR_EXP 72
43120: PUSH
43121: LD_EXP 72
43125: PUSH
43126: LD_INT 0
43128: ADD
43129: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43130: LD_ADDR_EXP 64
43134: PUSH
43135: LD_EXP 64
43139: PUSH
43140: LD_INT 0
43142: PUSH
43143: LD_INT 0
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: LIST
43153: ADD
43154: ST_TO_ADDR
// end ;
43155: GO 42315
43157: POP
43158: POP
// end ;
43159: LD_VAR 0 1
43163: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43164: LD_INT 0
43166: PPUSH
43167: PPUSH
43168: PPUSH
// m := false ;
43169: LD_ADDR_VAR 0 5
43173: PUSH
43174: LD_INT 0
43176: ST_TO_ADDR
// for i = 1 to mreg do
43177: LD_ADDR_VAR 0 4
43181: PUSH
43182: DOUBLE
43183: LD_INT 1
43185: DEC
43186: ST_TO_ADDR
43187: LD_VAR 0 2
43191: PUSH
43192: FOR_TO
43193: IFFALSE 43229
// if mreg [ i ] [ 1 ] = side then
43195: LD_VAR 0 2
43199: PUSH
43200: LD_VAR 0 4
43204: ARRAY
43205: PUSH
43206: LD_INT 1
43208: ARRAY
43209: PUSH
43210: LD_VAR 0 1
43214: EQUAL
43215: IFFALSE 43227
// begin m := true ;
43217: LD_ADDR_VAR 0 5
43221: PUSH
43222: LD_INT 1
43224: ST_TO_ADDR
// break ;
43225: GO 43229
// end ;
43227: GO 43192
43229: POP
43230: POP
// result := m ;
43231: LD_ADDR_VAR 0 3
43235: PUSH
43236: LD_VAR 0 5
43240: ST_TO_ADDR
// end ;
43241: LD_VAR 0 3
43245: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43246: LD_INT 0
43248: PPUSH
43249: PPUSH
43250: PPUSH
// m := 0 ;
43251: LD_ADDR_VAR 0 5
43255: PUSH
43256: LD_INT 0
43258: ST_TO_ADDR
// for i = 1 to mreg do
43259: LD_ADDR_VAR 0 4
43263: PUSH
43264: DOUBLE
43265: LD_INT 1
43267: DEC
43268: ST_TO_ADDR
43269: LD_VAR 0 2
43273: PUSH
43274: FOR_TO
43275: IFFALSE 43315
// if mreg [ i ] [ 1 ] = side then
43277: LD_VAR 0 2
43281: PUSH
43282: LD_VAR 0 4
43286: ARRAY
43287: PUSH
43288: LD_INT 1
43290: ARRAY
43291: PUSH
43292: LD_VAR 0 1
43296: EQUAL
43297: IFFALSE 43313
// begin m := m + 1 ;
43299: LD_ADDR_VAR 0 5
43303: PUSH
43304: LD_VAR 0 5
43308: PUSH
43309: LD_INT 1
43311: PLUS
43312: ST_TO_ADDR
// end ;
43313: GO 43274
43315: POP
43316: POP
// result := m ;
43317: LD_ADDR_VAR 0 3
43321: PUSH
43322: LD_VAR 0 5
43326: ST_TO_ADDR
// end ;
43327: LD_VAR 0 3
43331: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43332: LD_INT 0
43334: PPUSH
43335: PPUSH
// result := 0 ;
43336: LD_ADDR_VAR 0 3
43340: PUSH
43341: LD_INT 0
43343: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43344: LD_ADDR_VAR 0 4
43348: PUSH
43349: DOUBLE
43350: LD_INT 1
43352: DEC
43353: ST_TO_ADDR
43354: LD_EXP 55
43358: PUSH
43359: FOR_TO
43360: IFFALSE 43422
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43362: LD_EXP 55
43366: PUSH
43367: LD_VAR 0 4
43371: ARRAY
43372: PUSH
43373: LD_INT 1
43375: ARRAY
43376: PUSH
43377: LD_VAR 0 1
43381: EQUAL
43382: PUSH
43383: LD_EXP 55
43387: PUSH
43388: LD_VAR 0 4
43392: ARRAY
43393: PUSH
43394: LD_INT 2
43396: ARRAY
43397: PUSH
43398: LD_VAR 0 2
43402: EQUAL
43403: AND
43404: IFFALSE 43420
// begin result := result + 1 ;
43406: LD_ADDR_VAR 0 3
43410: PUSH
43411: LD_VAR 0 3
43415: PUSH
43416: LD_INT 1
43418: PLUS
43419: ST_TO_ADDR
// end ;
43420: GO 43359
43422: POP
43423: POP
// end ;
43424: LD_VAR 0 3
43428: RET
