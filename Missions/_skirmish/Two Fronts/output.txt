// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7474 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4575 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 32
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4874 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3000 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2627 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3000 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2627 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3000 0 4
// MC_Registry ( ) ;
 213: CALL 41962 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42413 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 33
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21205 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21141 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18134 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21041 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22055 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21282 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21075 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21108 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17913 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21963 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20220 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20795 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20795 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20592 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20256 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20432 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19716 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20330 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20831 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21571 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21141 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18134 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21041 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21282 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21075 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21108 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17913 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21963 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20220 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20795 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20795 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20592 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20256 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20432 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19716 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20330 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20831 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21571 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 11
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 12
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 13
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 14
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 15
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 9
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// end ;
1629: LD_VAR 0 1
1633: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1634: LD_INT 8
1636: PPUSH
1637: CALL_OW 353
1641: PUSH
1642: LD_INT 0
1644: EQUAL
1645: IFFALSE 1680
1647: GO 1649
1649: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1650: LD_INT 1
1652: PPUSH
1653: LD_INT 32
1655: PPUSH
1656: LD_INT 50
1658: PUSH
1659: LD_INT 10
1661: PUSH
1662: LD_INT 4
1664: PUSH
1665: EMPTY
1666: LIST
1667: LIST
1668: LIST
1669: PPUSH
1670: LD_INT 7
1672: PUSH
1673: EMPTY
1674: LIST
1675: PPUSH
1676: CALL 19716 0 4
// end ;
1680: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1681: LD_INT 1
1683: PPUSH
1684: LD_INT 30
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: EMPTY
1691: LIST
1692: LIST
1693: PPUSH
1694: CALL 11421 0 2
1698: IFFALSE 1792
1700: GO 1702
1702: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1703: LD_INT 1
1705: PPUSH
1706: LD_INT 3
1708: PUSH
1709: LD_INT 1
1711: PUSH
1712: LD_INT 2
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 3
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: LD_INT 2
1726: PUSH
1727: LD_INT 5
1729: PUSH
1730: LD_INT 3
1732: PUSH
1733: LD_INT 1
1735: PUSH
1736: LD_INT 2
1738: PUSH
1739: LD_INT 5
1741: PUSH
1742: LD_INT 3
1744: PUSH
1745: LD_INT 1
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 7
1753: PUSH
1754: LD_INT 3
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: LD_INT 2
1762: PUSH
1763: LD_INT 7
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: LIST
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: PPUSH
1788: CALL 21789 0 2
// end ;
1792: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1793: LD_INT 4
1795: PPUSH
1796: LD_INT 30
1798: PUSH
1799: LD_INT 3
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PPUSH
1806: CALL 11421 0 2
1810: IFFALSE 1904
1812: GO 1814
1814: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1815: LD_INT 4
1817: PPUSH
1818: LD_INT 3
1820: PUSH
1821: LD_INT 1
1823: PUSH
1824: LD_INT 2
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 3
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 2
1838: PUSH
1839: LD_INT 5
1841: PUSH
1842: LD_INT 3
1844: PUSH
1845: LD_INT 1
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 5
1853: PUSH
1854: LD_INT 4
1856: PUSH
1857: LD_INT 1
1859: PUSH
1860: LD_INT 2
1862: PUSH
1863: LD_INT 6
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 2
1874: PUSH
1875: LD_INT 6
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PPUSH
1900: CALL 21789 0 2
// end ;
1904: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 30
1910: PUSH
1911: LD_INT 3
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: PPUSH
1918: CALL 11421 0 2
1922: PUSH
1923: LD_EXP 70
1927: PUSH
1928: LD_INT 1
1930: ARRAY
1931: PUSH
1932: LD_INT 1
1934: ARRAY
1935: PUSH
1936: LD_INT 0
1938: EQUAL
1939: AND
1940: IFFALSE 2051
1942: GO 1944
1944: DISABLE
// begin enable ;
1945: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1946: LD_INT 1
1948: PPUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 2
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: LD_INT 3
1963: PUSH
1964: LD_INT 1
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 5
1972: PUSH
1973: LD_INT 3
1975: PUSH
1976: LD_INT 1
1978: PUSH
1979: LD_INT 2
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: LD_INT 3
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 2
1993: PUSH
1994: LD_INT 7
1996: PUSH
1997: LD_INT 3
1999: PUSH
2000: LD_INT 1
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 7
2008: PUSH
2009: LD_INT 4
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 2
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: LIST
2028: LIST
2029: LIST
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 21789 0 2
// end ;
2051: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2052: LD_INT 4
2054: PPUSH
2055: LD_INT 30
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PPUSH
2065: CALL 11421 0 2
2069: PUSH
2070: LD_EXP 70
2074: PUSH
2075: LD_INT 4
2077: ARRAY
2078: PUSH
2079: LD_INT 1
2081: ARRAY
2082: PUSH
2083: LD_INT 0
2085: EQUAL
2086: AND
2087: IFFALSE 2198
2089: GO 2091
2091: DISABLE
// begin enable ;
2092: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2093: LD_INT 4
2095: PPUSH
2096: LD_INT 3
2098: PUSH
2099: LD_INT 1
2101: PUSH
2102: LD_INT 2
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 3
2110: PUSH
2111: LD_INT 1
2113: PUSH
2114: LD_INT 2
2116: PUSH
2117: LD_INT 5
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 1
2125: PUSH
2126: LD_INT 2
2128: PUSH
2129: LD_INT 5
2131: PUSH
2132: LD_INT 4
2134: PUSH
2135: LD_INT 1
2137: PUSH
2138: LD_INT 2
2140: PUSH
2141: LD_INT 6
2143: PUSH
2144: LD_INT 4
2146: PUSH
2147: LD_INT 1
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: LD_INT 6
2155: PUSH
2156: LD_INT 3
2158: PUSH
2159: LD_INT 1
2161: PUSH
2162: LD_INT 2
2164: PUSH
2165: LD_INT 5
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: PPUSH
2194: CALL 21789 0 2
// end ;
2198: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2199: LD_EXP 12
2203: PUSH
2204: LD_INT 22
2206: PUSH
2207: LD_INT 6
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 21
2216: PUSH
2217: LD_INT 2
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 3
2226: PUSH
2227: LD_INT 34
2229: PUSH
2230: LD_INT 51
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: LIST
2245: PPUSH
2246: CALL_OW 69
2250: AND
2251: IFFALSE 2380
2253: GO 2255
2255: DISABLE
2256: LD_INT 0
2258: PPUSH
// begin enable ;
2259: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2260: LD_ADDR_VAR 0 1
2264: PUSH
2265: LD_INT 22
2267: PUSH
2268: LD_INT 6
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: LD_INT 21
2277: PUSH
2278: LD_INT 2
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: PUSH
2285: LD_INT 3
2287: PUSH
2288: LD_INT 34
2290: PUSH
2291: LD_INT 51
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PUSH
2312: FOR_IN
2313: IFFALSE 2378
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2315: LD_VAR 0 1
2319: PPUSH
2320: CALL_OW 314
2324: NOT
2325: PUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: CALL_OW 256
2335: PUSH
2336: LD_INT 250
2338: GREATER
2339: AND
2340: IFFALSE 2376
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2342: LD_VAR 0 1
2346: PPUSH
2347: LD_INT 81
2349: PUSH
2350: LD_INT 6
2352: PUSH
2353: EMPTY
2354: LIST
2355: LIST
2356: PPUSH
2357: CALL_OW 69
2361: PPUSH
2362: LD_VAR 0 1
2366: PPUSH
2367: CALL_OW 74
2371: PPUSH
2372: CALL_OW 115
2376: GO 2312
2378: POP
2379: POP
// end ;
2380: PPOPN 1
2382: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2383: LD_EXP 12
2387: PUSH
2388: LD_INT 22
2390: PUSH
2391: LD_INT 6
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 21
2400: PUSH
2401: LD_INT 2
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 34
2413: PUSH
2414: LD_INT 51
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: LIST
2429: PPUSH
2430: CALL_OW 69
2434: PUSH
2435: LD_INT 0
2437: EQUAL
2438: AND
2439: IFFALSE 2453
2441: GO 2443
2443: DISABLE
// begin enable ;
2444: ENABLE
// pink_attack := false ;
2445: LD_ADDR_EXP 12
2449: PUSH
2450: LD_INT 0
2452: ST_TO_ADDR
// end ;
2453: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2454: LD_EXP 13
2458: PUSH
2459: LD_INT 22
2461: PUSH
2462: LD_INT 8
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PPUSH
2469: CALL_OW 69
2473: AND
2474: IFFALSE 2585
2476: GO 2478
2478: DISABLE
2479: LD_INT 0
2481: PPUSH
// begin enable ;
2482: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2483: LD_ADDR_VAR 0 1
2487: PUSH
2488: LD_INT 22
2490: PUSH
2491: LD_INT 8
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: PUSH
2498: LD_INT 21
2500: PUSH
2501: LD_INT 2
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: PPUSH
2512: CALL_OW 69
2516: PUSH
2517: FOR_IN
2518: IFFALSE 2583
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2520: LD_VAR 0 1
2524: PPUSH
2525: CALL_OW 314
2529: NOT
2530: PUSH
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 256
2540: PUSH
2541: LD_INT 250
2543: GREATER
2544: AND
2545: IFFALSE 2581
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2547: LD_VAR 0 1
2551: PPUSH
2552: LD_INT 81
2554: PUSH
2555: LD_INT 8
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: PPUSH
2562: CALL_OW 69
2566: PPUSH
2567: LD_VAR 0 1
2571: PPUSH
2572: CALL_OW 74
2576: PPUSH
2577: CALL_OW 115
2581: GO 2517
2583: POP
2584: POP
// end ;
2585: PPOPN 1
2587: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2588: LD_EXP 13
2592: PUSH
2593: LD_INT 22
2595: PUSH
2596: LD_INT 8
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: PPUSH
2603: CALL_OW 69
2607: PUSH
2608: LD_INT 0
2610: EQUAL
2611: AND
2612: IFFALSE 2626
2614: GO 2616
2616: DISABLE
// begin enable ;
2617: ENABLE
// alfa_support := false ;
2618: LD_ADDR_EXP 13
2622: PUSH
2623: LD_INT 0
2625: ST_TO_ADDR
// end ; end_of_file
2626: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2627: LD_INT 0
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := side ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_VAR 0 1
2642: ST_TO_ADDR
// uc_nation := nat ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// team := [ ] ;
2653: LD_ADDR_VAR 0 10
2657: PUSH
2658: EMPTY
2659: ST_TO_ADDR
// hc_importance := 100 ;
2660: LD_ADDR_OWVAR 32
2664: PUSH
2665: LD_INT 100
2667: ST_TO_ADDR
// case commander of jakes :
2668: LD_VAR 0 4
2672: PUSH
2673: LD_STRING jakes
2675: DOUBLE
2676: EQUAL
2677: IFTRUE 2681
2679: GO 2758
2681: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2682: LD_INT 1
2684: PPUSH
2685: LD_INT 1
2687: PPUSH
2688: LD_VAR 0 5
2692: PPUSH
2693: CALL_OW 380
// hc_gallery := pkremaster ;
2697: LD_ADDR_OWVAR 33
2701: PUSH
2702: LD_STRING pkremaster
2704: ST_TO_ADDR
// hc_face_number := 12 ;
2705: LD_ADDR_OWVAR 34
2709: PUSH
2710: LD_INT 12
2712: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2713: LD_ADDR_OWVAR 26
2717: PUSH
2718: LD_STRING Jan van Jakes
2720: ST_TO_ADDR
// houten := CreateHuman ;
2721: LD_ADDR_EXP 3
2725: PUSH
2726: CALL_OW 44
2730: ST_TO_ADDR
// LogHuman ( houten ) ;
2731: LD_EXP 3
2735: PPUSH
2736: CALL 7693 0 1
// team := team ^ houten ;
2740: LD_ADDR_VAR 0 10
2744: PUSH
2745: LD_VAR 0 10
2749: PUSH
2750: LD_EXP 3
2754: ADD
2755: ST_TO_ADDR
// end ; sylvia :
2756: GO 2844
2758: LD_STRING sylvia
2760: DOUBLE
2761: EQUAL
2762: IFTRUE 2766
2764: GO 2843
2766: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2767: LD_INT 2
2769: PPUSH
2770: LD_INT 1
2772: PPUSH
2773: LD_VAR 0 5
2777: PPUSH
2778: CALL_OW 380
// hc_gallery := pkremaster ;
2782: LD_ADDR_OWVAR 33
2786: PUSH
2787: LD_STRING pkremaster
2789: ST_TO_ADDR
// hc_face_number := 13 ;
2790: LD_ADDR_OWVAR 34
2794: PUSH
2795: LD_INT 13
2797: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2798: LD_ADDR_OWVAR 26
2802: PUSH
2803: LD_STRING Sylvia Johnson
2805: ST_TO_ADDR
// brown := CreateHuman ;
2806: LD_ADDR_EXP 4
2810: PUSH
2811: CALL_OW 44
2815: ST_TO_ADDR
// LogHuman ( brown ) ;
2816: LD_EXP 4
2820: PPUSH
2821: CALL 7693 0 1
// team := team ^ brown ;
2825: LD_ADDR_VAR 0 10
2829: PUSH
2830: LD_VAR 0 10
2834: PUSH
2835: LD_EXP 4
2839: ADD
2840: ST_TO_ADDR
// end ; end ;
2841: GO 2844
2843: POP
// hc_gallery :=  ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING 
2851: ST_TO_ADDR
// hc_name :=  ;
2852: LD_ADDR_OWVAR 26
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_importance := 0 ;
2860: LD_ADDR_OWVAR 32
2864: PUSH
2865: LD_INT 0
2867: ST_TO_ADDR
// for i = 1 to num do
2868: LD_ADDR_VAR 0 8
2872: PUSH
2873: DOUBLE
2874: LD_INT 1
2876: DEC
2877: ST_TO_ADDR
2878: LD_VAR 0 6
2882: PUSH
2883: FOR_TO
2884: IFFALSE 2948
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2886: LD_INT 0
2888: PPUSH
2889: LD_VAR 0 8
2893: PUSH
2894: LD_INT 4
2896: MOD
2897: PUSH
2898: LD_INT 1
2900: PLUS
2901: PPUSH
2902: LD_VAR 0 5
2906: PPUSH
2907: CALL_OW 380
// un := CreateHuman ;
2911: LD_ADDR_VAR 0 9
2915: PUSH
2916: CALL_OW 44
2920: ST_TO_ADDR
// LogHuman ( un ) ;
2921: LD_VAR 0 9
2925: PPUSH
2926: CALL 7693 0 1
// team := team ^ un ;
2930: LD_ADDR_VAR 0 10
2934: PUSH
2935: LD_VAR 0 10
2939: PUSH
2940: LD_VAR 0 9
2944: ADD
2945: ST_TO_ADDR
// end ;
2946: GO 2883
2948: POP
2949: POP
// for i = 1 to team do
2950: LD_ADDR_VAR 0 8
2954: PUSH
2955: DOUBLE
2956: LD_INT 1
2958: DEC
2959: ST_TO_ADDR
2960: LD_VAR 0 10
2964: PUSH
2965: FOR_TO
2966: IFFALSE 2993
// PlaceUnitArea ( team [ i ] , area , false ) ;
2968: LD_VAR 0 10
2972: PUSH
2973: LD_VAR 0 8
2977: ARRAY
2978: PPUSH
2979: LD_VAR 0 3
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 49
2991: GO 2965
2993: POP
2994: POP
// end ;
2995: LD_VAR 0 7
2999: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3000: LD_INT 0
3002: PPUSH
3003: PPUSH
// for i = 1 to n1 do
3004: LD_ADDR_VAR 0 6
3008: PUSH
3009: DOUBLE
3010: LD_INT 1
3012: DEC
3013: ST_TO_ADDR
3014: LD_VAR 0 1
3018: PUSH
3019: FOR_TO
3020: IFFALSE 3042
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3022: LD_INT 1
3024: PPUSH
3025: LD_INT 1
3027: PPUSH
3028: LD_VAR 0 4
3032: PPUSH
3033: LD_INT 0
3035: PPUSH
3036: CALL_OW 59
3040: GO 3019
3042: POP
3043: POP
// for i = 1 to n2 do
3044: LD_ADDR_VAR 0 6
3048: PUSH
3049: DOUBLE
3050: LD_INT 1
3052: DEC
3053: ST_TO_ADDR
3054: LD_VAR 0 2
3058: PUSH
3059: FOR_TO
3060: IFFALSE 3082
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3062: LD_INT 2
3064: PPUSH
3065: LD_INT 1
3067: PPUSH
3068: LD_VAR 0 4
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 59
3080: GO 3059
3082: POP
3083: POP
// for i = 1 to n3 do
3084: LD_ADDR_VAR 0 6
3088: PUSH
3089: DOUBLE
3090: LD_INT 1
3092: DEC
3093: ST_TO_ADDR
3094: LD_VAR 0 3
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3102: LD_INT 3
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: LD_VAR 0 4
3112: PPUSH
3113: LD_INT 0
3115: PPUSH
3116: CALL_OW 59
3120: GO 3099
3122: POP
3123: POP
// end ; end_of_file
3124: LD_VAR 0 5
3128: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3129: LD_INT 0
3131: PPUSH
3132: PPUSH
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
// uc_side := your_side ;
3137: LD_ADDR_OWVAR 20
3141: PUSH
3142: LD_OWVAR 2
3146: ST_TO_ADDR
// uc_nation := nation_russian ;
3147: LD_ADDR_OWVAR 21
3151: PUSH
3152: LD_INT 3
3154: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3155: LD_ADDR_EXP 18
3159: PUSH
3160: LD_STRING Gladkov
3162: PPUSH
3163: CALL_OW 25
3167: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3168: LD_ADDR_EXP 19
3172: PUSH
3173: LD_STRING Davidov
3175: PPUSH
3176: CALL_OW 25
3180: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3181: LD_ADDR_EXP 20
3185: PUSH
3186: LD_STRING Burlak
3188: PPUSH
3189: CALL_OW 25
3193: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3194: LD_ADDR_EXP 21
3198: PUSH
3199: LD_STRING Stolypin
3201: PPUSH
3202: CALL_OW 25
3206: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3207: LD_ADDR_EXP 16
3211: PUSH
3212: LD_EXP 18
3216: PUSH
3217: LD_EXP 19
3221: PUSH
3222: LD_EXP 20
3226: PUSH
3227: LD_EXP 21
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3238: LD_ADDR_EXP 24
3242: PUSH
3243: LD_EXP 16
3247: PUSH
3248: LD_VAR 0 1
3252: ARRAY
3253: ST_TO_ADDR
// team := [ ] ;
3254: LD_ADDR_VAR 0 6
3258: PUSH
3259: EMPTY
3260: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3261: LD_ADDR_VAR 0 4
3265: PUSH
3266: LD_INT 4
3268: PUSH
3269: LD_INT 3
3271: PUSH
3272: LD_INT 3
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PUSH
3280: LD_OWVAR 67
3284: ARRAY
3285: ST_TO_ADDR
// hc_gallery :=  ;
3286: LD_ADDR_OWVAR 33
3290: PUSH
3291: LD_STRING 
3293: ST_TO_ADDR
// hc_name :=  ;
3294: LD_ADDR_OWVAR 26
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_importance := 0 ;
3302: LD_ADDR_OWVAR 32
3306: PUSH
3307: LD_INT 0
3309: ST_TO_ADDR
// case player_com of gladkov :
3310: LD_EXP 24
3314: PUSH
3315: LD_EXP 18
3319: DOUBLE
3320: EQUAL
3321: IFTRUE 3325
3323: GO 3470
3325: POP
// begin for i = 1 to 10 do
3326: LD_ADDR_VAR 0 3
3330: PUSH
3331: DOUBLE
3332: LD_INT 1
3334: DEC
3335: ST_TO_ADDR
3336: LD_INT 10
3338: PUSH
3339: FOR_TO
3340: IFFALSE 3379
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3342: LD_INT 0
3344: PPUSH
3345: LD_INT 1
3347: PPUSH
3348: LD_VAR 0 4
3352: PUSH
3353: LD_INT 1
3355: PLUS
3356: PPUSH
3357: CALL_OW 380
// team := team ^ CreateHuman ;
3361: LD_ADDR_VAR 0 6
3365: PUSH
3366: LD_VAR 0 6
3370: PUSH
3371: CALL_OW 44
3375: ADD
3376: ST_TO_ADDR
// end ;
3377: GO 3339
3379: POP
3380: POP
// for i = 1 to 15 do
3381: LD_ADDR_VAR 0 3
3385: PUSH
3386: DOUBLE
3387: LD_INT 1
3389: DEC
3390: ST_TO_ADDR
3391: LD_INT 15
3393: PUSH
3394: FOR_TO
3395: IFFALSE 3440
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3397: LD_INT 0
3399: PPUSH
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: MOD
3408: PUSH
3409: LD_INT 2
3411: PLUS
3412: PPUSH
3413: LD_VAR 0 4
3417: PPUSH
3418: CALL_OW 380
// team := team ^ CreateHuman ;
3422: LD_ADDR_VAR 0 6
3426: PUSH
3427: LD_VAR 0 6
3431: PUSH
3432: CALL_OW 44
3436: ADD
3437: ST_TO_ADDR
// end ;
3438: GO 3394
3440: POP
3441: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3442: LD_INT 44
3444: PPUSH
3445: LD_INT 3
3447: PPUSH
3448: LD_INT 1
3450: PPUSH
3451: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3455: LD_INT 34
3457: PPUSH
3458: LD_INT 3
3460: PPUSH
3461: LD_INT 1
3463: PPUSH
3464: CALL_OW 322
// end ; davidov :
3468: GO 4353
3470: LD_EXP 19
3474: DOUBLE
3475: EQUAL
3476: IFTRUE 3480
3478: GO 3755
3480: POP
// begin for i = 1 to 10 do
3481: LD_ADDR_VAR 0 3
3485: PUSH
3486: DOUBLE
3487: LD_INT 1
3489: DEC
3490: ST_TO_ADDR
3491: LD_INT 10
3493: PUSH
3494: FOR_TO
3495: IFFALSE 3534
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3497: LD_INT 0
3499: PPUSH
3500: LD_INT 4
3502: PPUSH
3503: LD_VAR 0 4
3507: PUSH
3508: LD_INT 1
3510: PLUS
3511: PPUSH
3512: CALL_OW 380
// team := team ^ CreateHuman ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: CALL_OW 44
3530: ADD
3531: ST_TO_ADDR
// end ;
3532: GO 3494
3534: POP
3535: POP
// for i = 1 to 15 do
3536: LD_ADDR_VAR 0 3
3540: PUSH
3541: DOUBLE
3542: LD_INT 1
3544: DEC
3545: ST_TO_ADDR
3546: LD_INT 15
3548: PUSH
3549: FOR_TO
3550: IFFALSE 3595
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3552: LD_INT 0
3554: PPUSH
3555: LD_VAR 0 3
3559: PUSH
3560: LD_INT 3
3562: MOD
3563: PUSH
3564: LD_INT 1
3566: PLUS
3567: PPUSH
3568: LD_VAR 0 4
3572: PPUSH
3573: CALL_OW 380
// team := team ^ CreateHuman ;
3577: LD_ADDR_VAR 0 6
3581: PUSH
3582: LD_VAR 0 6
3586: PUSH
3587: CALL_OW 44
3591: ADD
3592: ST_TO_ADDR
// end ;
3593: GO 3549
3595: POP
3596: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3597: LD_INT 34
3599: PPUSH
3600: LD_INT 3
3602: PPUSH
3603: LD_INT 1
3605: PPUSH
3606: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3610: LD_INT 32
3612: PPUSH
3613: LD_INT 3
3615: PPUSH
3616: LD_INT 1
3618: PPUSH
3619: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3623: LD_INT 27
3625: PPUSH
3626: LD_INT 3
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3636: LD_INT 30
3638: PPUSH
3639: LD_INT 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3649: LD_INT 63
3651: PPUSH
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 1
3657: PPUSH
3658: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3662: LD_INT 57
3664: PPUSH
3665: LD_INT 3
3667: PPUSH
3668: LD_INT 1
3670: PPUSH
3671: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3675: LD_INT 58
3677: PPUSH
3678: LD_INT 3
3680: PPUSH
3681: LD_INT 1
3683: PPUSH
3684: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3688: LD_INT 8
3690: PPUSH
3691: LD_INT 3
3693: PPUSH
3694: LD_INT 1
3696: PPUSH
3697: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3701: LD_INT 12
3703: PPUSH
3704: LD_INT 3
3706: PPUSH
3707: LD_INT 1
3709: PPUSH
3710: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3714: LD_INT 14
3716: PPUSH
3717: LD_INT 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3727: LD_INT 24
3729: PPUSH
3730: LD_INT 3
3732: PPUSH
3733: LD_INT 1
3735: PPUSH
3736: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3740: LD_INT 33
3742: PPUSH
3743: LD_INT 3
3745: PPUSH
3746: LD_INT 1
3748: PPUSH
3749: CALL_OW 324
// end ; gorki :
3753: GO 4353
3755: LD_EXP 20
3759: DOUBLE
3760: EQUAL
3761: IFTRUE 3765
3763: GO 4046
3765: POP
// begin for i = 1 to 10 do
3766: LD_ADDR_VAR 0 3
3770: PUSH
3771: DOUBLE
3772: LD_INT 1
3774: DEC
3775: ST_TO_ADDR
3776: LD_INT 10
3778: PUSH
3779: FOR_TO
3780: IFFALSE 3834
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3782: LD_INT 0
3784: PPUSH
3785: LD_INT 3
3787: PPUSH
3788: LD_VAR 0 4
3792: PUSH
3793: LD_INT 1
3795: PLUS
3796: PPUSH
3797: CALL_OW 380
// team := team ^ CreateHuman ;
3801: LD_ADDR_VAR 0 6
3805: PUSH
3806: LD_VAR 0 6
3810: PUSH
3811: CALL_OW 44
3815: ADD
3816: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3817: LD_VAR 0 6
3821: PUSH
3822: LD_VAR 0 6
3826: ARRAY
3827: PPUSH
3828: CALL 7693 0 1
// end ;
3832: GO 3779
3834: POP
3835: POP
// for i = 1 to 15 do
3836: LD_ADDR_VAR 0 3
3840: PUSH
3841: DOUBLE
3842: LD_INT 1
3844: DEC
3845: ST_TO_ADDR
3846: LD_INT 15
3848: PUSH
3849: FOR_TO
3850: IFFALSE 3923
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3852: LD_INT 0
3854: PPUSH
3855: LD_INT 1
3857: PUSH
3858: LD_INT 2
3860: PUSH
3861: LD_INT 4
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: LIST
3868: PUSH
3869: LD_INT 1
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: CALL_OW 12
3879: ARRAY
3880: PPUSH
3881: LD_VAR 0 4
3885: PPUSH
3886: CALL_OW 380
// team := team ^ CreateHuman ;
3890: LD_ADDR_VAR 0 6
3894: PUSH
3895: LD_VAR 0 6
3899: PUSH
3900: CALL_OW 44
3904: ADD
3905: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3906: LD_VAR 0 6
3910: PUSH
3911: LD_VAR 0 6
3915: ARRAY
3916: PPUSH
3917: CALL 7693 0 1
// end ;
3921: GO 3849
3923: POP
3924: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3925: LD_INT 40
3927: PPUSH
3928: LD_INT 3
3930: PPUSH
3931: LD_INT 1
3933: PPUSH
3934: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3938: LD_INT 34
3940: PPUSH
3941: LD_INT 3
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3951: LD_INT 18
3953: PPUSH
3954: LD_INT 3
3956: PPUSH
3957: LD_INT 1
3959: PPUSH
3960: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3964: LD_ADDR_OWVAR 37
3968: PUSH
3969: LD_INT 22
3971: ST_TO_ADDR
// vc_engine := engine_combustion ;
3972: LD_ADDR_OWVAR 39
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// vc_control := control_manual ;
3980: LD_ADDR_OWVAR 38
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3988: LD_ADDR_OWVAR 40
3992: PUSH
3993: LD_INT 45
3995: ST_TO_ADDR
// vc_fuel_battery := 3 ;
3996: LD_ADDR_OWVAR 41
4000: PUSH
4001: LD_INT 3
4003: ST_TO_ADDR
// veh := CreateVehicle ;
4004: LD_ADDR_VAR 0 7
4008: PUSH
4009: CALL_OW 45
4013: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4014: LD_VAR 0 7
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4026: LD_VAR 0 7
4030: PPUSH
4031: LD_INT 107
4033: PPUSH
4034: LD_INT 83
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: CALL_OW 48
// end ; stolypin :
4044: GO 4353
4046: LD_EXP 21
4050: DOUBLE
4051: EQUAL
4052: IFTRUE 4056
4054: GO 4352
4056: POP
// begin for i = 1 to 10 do
4057: LD_ADDR_VAR 0 3
4061: PUSH
4062: DOUBLE
4063: LD_INT 1
4065: DEC
4066: ST_TO_ADDR
4067: LD_INT 10
4069: PUSH
4070: FOR_TO
4071: IFFALSE 4110
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4073: LD_INT 0
4075: PPUSH
4076: LD_INT 2
4078: PPUSH
4079: LD_VAR 0 4
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: PPUSH
4088: CALL_OW 380
// team := team ^ CreateHuman ;
4092: LD_ADDR_VAR 0 6
4096: PUSH
4097: LD_VAR 0 6
4101: PUSH
4102: CALL_OW 44
4106: ADD
4107: ST_TO_ADDR
// end ;
4108: GO 4070
4110: POP
4111: POP
// for i = 1 to 15 do
4112: LD_ADDR_VAR 0 3
4116: PUSH
4117: DOUBLE
4118: LD_INT 1
4120: DEC
4121: ST_TO_ADDR
4122: LD_INT 15
4124: PUSH
4125: FOR_TO
4126: IFFALSE 4184
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4128: LD_INT 0
4130: PPUSH
4131: LD_INT 1
4133: PUSH
4134: LD_INT 3
4136: PUSH
4137: LD_INT 4
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_INT 3
4150: PPUSH
4151: CALL_OW 12
4155: ARRAY
4156: PPUSH
4157: LD_VAR 0 4
4161: PPUSH
4162: CALL_OW 380
// team := team ^ CreateHuman ;
4166: LD_ADDR_VAR 0 6
4170: PUSH
4171: LD_VAR 0 6
4175: PUSH
4176: CALL_OW 44
4180: ADD
4181: ST_TO_ADDR
// end ;
4182: GO 4125
4184: POP
4185: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4186: LD_INT 34
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: LD_INT 1
4194: PPUSH
4195: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4199: LD_ADDR_OWVAR 37
4203: PUSH
4204: LD_INT 22
4206: ST_TO_ADDR
// vc_engine := engine_combustion ;
4207: LD_ADDR_OWVAR 39
4211: PUSH
4212: LD_INT 1
4214: ST_TO_ADDR
// vc_control := control_manual ;
4215: LD_ADDR_OWVAR 38
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4223: LD_ADDR_OWVAR 40
4227: PUSH
4228: LD_INT 51
4230: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4231: LD_ADDR_OWVAR 41
4235: PUSH
4236: LD_INT 30
4238: ST_TO_ADDR
// veh := CreateVehicle ;
4239: LD_ADDR_VAR 0 7
4243: PUSH
4244: CALL_OW 45
4248: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4249: LD_VAR 0 7
4253: PPUSH
4254: LD_INT 1
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4264: LD_VAR 0 7
4268: PPUSH
4269: LD_INT 107
4271: PPUSH
4272: LD_INT 83
4274: PPUSH
4275: LD_INT 0
4277: PPUSH
4278: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4282: LD_ADDR_OWVAR 37
4286: PUSH
4287: LD_INT 22
4289: ST_TO_ADDR
// vc_engine := engine_combustion ;
4290: LD_ADDR_OWVAR 39
4294: PUSH
4295: LD_INT 1
4297: ST_TO_ADDR
// vc_control := control_manual ;
4298: LD_ADDR_OWVAR 38
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_weapon := ru_crane ;
4306: LD_ADDR_OWVAR 40
4310: PUSH
4311: LD_INT 52
4313: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4314: LD_ADDR_OWVAR 41
4318: PUSH
4319: LD_INT 30
4321: ST_TO_ADDR
// veh := CreateVehicle ;
4322: LD_ADDR_VAR 0 7
4326: PUSH
4327: CALL_OW 45
4331: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4332: LD_VAR 0 7
4336: PPUSH
4337: LD_INT 115
4339: PPUSH
4340: LD_INT 96
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: CALL_OW 48
// end ; end ;
4350: GO 4353
4352: POP
// if isTest then
4353: LD_EXP 1
4357: IFFALSE 4371
// tmp := team else
4359: LD_ADDR_VAR 0 5
4363: PUSH
4364: LD_VAR 0 6
4368: ST_TO_ADDR
4369: GO 4435
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_STRING text
4378: PPUSH
4379: LD_INT 12
4381: PPUSH
4382: LD_INT 12
4384: PPUSH
4385: LD_INT -2
4387: PUSH
4388: LD_INT -5
4390: PUSH
4391: LD_INT -3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: LIST
4398: PUSH
4399: LD_VAR 0 6
4403: ADD
4404: PPUSH
4405: LD_INT 1
4407: PUSH
4408: LD_INT 2
4410: PUSH
4411: LD_INT 1
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 3
4420: PUSH
4421: LD_INT 4
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: PPUSH
4430: CALL_OW 42
4434: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4435: LD_EXP 24
4439: PPUSH
4440: LD_INT 9
4442: PPUSH
4443: LD_INT 0
4445: PPUSH
4446: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4450: LD_VAR 0 5
4454: PUSH
4455: LD_INT 1
4457: ARRAY
4458: PPUSH
4459: LD_INT 2
4461: PPUSH
4462: CALL_OW 336
// for i = 1 to tmp do
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: DOUBLE
4472: LD_INT 1
4474: DEC
4475: ST_TO_ADDR
4476: LD_VAR 0 5
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4537
// if i < 4 then
4484: LD_VAR 0 3
4488: PUSH
4489: LD_INT 4
4491: LESS
4492: IFFALSE 4517
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4494: LD_VAR 0 5
4498: PUSH
4499: LD_VAR 0 3
4503: ARRAY
4504: PPUSH
4505: LD_INT 9
4507: PPUSH
4508: LD_INT 0
4510: PPUSH
4511: CALL_OW 49
4515: GO 4535
// SetSide ( tmp [ i ] , 6 ) ;
4517: LD_VAR 0 5
4521: PUSH
4522: LD_VAR 0 3
4526: ARRAY
4527: PPUSH
4528: LD_INT 6
4530: PPUSH
4531: CALL_OW 235
4535: GO 4481
4537: POP
4538: POP
// player_squad := tmp ;
4539: LD_ADDR_EXP 22
4543: PUSH
4544: LD_VAR 0 5
4548: ST_TO_ADDR
// pl_counter := 4 ;
4549: LD_ADDR_EXP 23
4553: PUSH
4554: LD_INT 4
4556: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4557: LD_INT 17
4559: PPUSH
4560: LD_INT 5
4562: PPUSH
4563: LD_INT 1
4565: PPUSH
4566: CALL 18134 0 3
// end ;
4570: LD_VAR 0 2
4574: RET
// export Popov ; export function InitAction ; var commander ; begin
4575: LD_INT 0
4577: PPUSH
4578: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4579: LD_INT 6
4581: PPUSH
4582: LD_INT 3
4584: PPUSH
4585: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4589: LD_INT 1
4591: PPUSH
4592: LD_INT 1
4594: PPUSH
4595: CALL_OW 86
// uc_side := 6 ;
4599: LD_ADDR_OWVAR 20
4603: PUSH
4604: LD_INT 6
4606: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4607: LD_ADDR_EXP 25
4611: PUSH
4612: LD_STRING Popov
4614: PPUSH
4615: CALL_OW 25
4619: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4620: LD_ADDR_OWVAR 67
4624: PUSH
4625: LD_INT 0
4627: PPUSH
4628: CALL_OW 426
4632: ST_TO_ADDR
// if not Difficulty then
4633: LD_OWVAR 67
4637: NOT
4638: IFFALSE 4648
// Difficulty := 2 ;
4640: LD_ADDR_OWVAR 67
4644: PUSH
4645: LD_INT 2
4647: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4648: LD_ADDR_VAR 0 2
4652: PUSH
4653: LD_INT 1
4655: PPUSH
4656: CALL_OW 426
4660: ST_TO_ADDR
// if not commander then
4661: LD_VAR 0 2
4665: NOT
4666: IFFALSE 4676
// commander := 1 ;
4668: LD_ADDR_VAR 0 2
4672: PUSH
4673: LD_INT 1
4675: ST_TO_ADDR
// InitCommanders ( commander ) ;
4676: LD_VAR 0 2
4680: PPUSH
4681: CALL 3129 0 1
// end ;
4685: LD_VAR 0 1
4689: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4690: LD_EXP 23
4694: PUSH
4695: LD_INT 12
4697: LESS
4698: IFFALSE 4871
4700: GO 4702
4702: DISABLE
4703: LD_INT 0
4705: PPUSH
// begin enable ;
4706: ENABLE
// for i = pl_counter to pl_counter + 2 do
4707: LD_ADDR_VAR 0 1
4711: PUSH
4712: DOUBLE
4713: LD_EXP 23
4717: DEC
4718: ST_TO_ADDR
4719: LD_EXP 23
4723: PUSH
4724: LD_INT 2
4726: PLUS
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4775
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4731: LD_EXP 22
4735: PUSH
4736: LD_VAR 0 1
4740: ARRAY
4741: PPUSH
4742: LD_INT 18
4744: PPUSH
4745: LD_INT 0
4747: PPUSH
4748: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4752: LD_EXP 22
4756: PUSH
4757: LD_VAR 0 1
4761: ARRAY
4762: PPUSH
4763: LD_INT 107
4765: PPUSH
4766: LD_INT 88
4768: PPUSH
4769: CALL_OW 111
// end ;
4773: GO 4728
4775: POP
4776: POP
// for i = pl_counter to pl_counter + 2 do
4777: LD_ADDR_VAR 0 1
4781: PUSH
4782: DOUBLE
4783: LD_EXP 23
4787: DEC
4788: ST_TO_ADDR
4789: LD_EXP 23
4793: PUSH
4794: LD_INT 2
4796: PLUS
4797: PUSH
4798: FOR_TO
4799: IFFALSE 4855
// begin repeat wait ( 0 0$01 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4808: LD_EXP 22
4812: PUSH
4813: LD_VAR 0 1
4817: ARRAY
4818: PPUSH
4819: LD_INT 107
4821: PPUSH
4822: LD_INT 88
4824: PPUSH
4825: CALL_OW 297
4829: PUSH
4830: LD_INT 6
4832: LESS
4833: IFFALSE 4801
// SetSide ( player_squad [ i ] , 3 ) ;
4835: LD_EXP 22
4839: PUSH
4840: LD_VAR 0 1
4844: ARRAY
4845: PPUSH
4846: LD_INT 3
4848: PPUSH
4849: CALL_OW 235
// end ;
4853: GO 4798
4855: POP
4856: POP
// pl_counter := pl_counter + 3 ;
4857: LD_ADDR_EXP 23
4861: PUSH
4862: LD_EXP 23
4866: PUSH
4867: LD_INT 3
4869: PLUS
4870: ST_TO_ADDR
// end ;
4871: PPOPN 1
4873: END
// export function Dialog ; begin
4874: LD_INT 0
4876: PPUSH
// if not isTest then
4877: LD_EXP 1
4881: NOT
4882: IFFALSE 4904
// case query ( task ) of 1 :
4884: LD_STRING task
4886: PPUSH
4887: CALL_OW 97
4891: PUSH
4892: LD_INT 1
4894: DOUBLE
4895: EQUAL
4896: IFTRUE 4900
4898: GO 4903
4900: POP
// ; end ;
4901: GO 4904
4903: POP
// InGameOn ;
4904: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4908: LD_INT 107
4910: PPUSH
4911: LD_INT 84
4913: PPUSH
4914: CALL_OW 86
// if isTest then
4918: LD_EXP 1
4922: IFFALSE 4932
// dialogue_skipped := true ;
4924: LD_ADDR_OWVAR 59
4928: PUSH
4929: LD_INT 1
4931: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4932: LD_ADDR_EXP 10
4936: PUSH
4937: LD_EXP 22
4941: PUSH
4942: LD_INT 1
4944: ARRAY
4945: PPUSH
4946: LD_INT 0
4948: PPUSH
4949: LD_INT 96
4951: PPUSH
4952: LD_INT 79
4954: PPUSH
4955: LD_INT 2
4957: PPUSH
4958: CALL_OW 145
4962: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4963: LD_INT 35
4965: PPUSH
4966: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4970: LD_EXP 25
4974: PPUSH
4975: LD_STRING DR1
4977: PPUSH
4978: CALL_OW 94
// Wait ( 0 0$01 ) ;
4982: LD_INT 35
4984: PPUSH
4985: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4989: LD_EXP 25
4993: PPUSH
4994: LD_STRING DR2
4996: PPUSH
4997: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5001: LD_EXP 25
5005: PPUSH
5006: LD_STRING DR3
5008: PPUSH
5009: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5013: LD_INT 35
5015: PPUSH
5016: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5020: LD_INT 3
5022: PPUSH
5023: LD_INT 30
5025: PUSH
5026: LD_INT 0
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL 11421 0 2
5037: PUSH
5038: LD_EXP 1
5042: OR
5043: IFFALSE 5013
// InGameOff ;
5045: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5049: LD_STRING C1
5051: PPUSH
5052: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5056: LD_INT 35
5058: PPUSH
5059: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5063: LD_EXP 10
5067: PPUSH
5068: CALL_OW 461
5072: PUSH
5073: LD_INT 2
5075: EQUAL
5076: IFFALSE 5056
// if not isTest then
5078: LD_EXP 1
5082: NOT
5083: IFFALSE 5105
// case query ( support ) of 1 :
5085: LD_STRING support
5087: PPUSH
5088: CALL_OW 97
5092: PUSH
5093: LD_INT 1
5095: DOUBLE
5096: EQUAL
5097: IFTRUE 5101
5099: GO 5104
5101: POP
// ; end ;
5102: GO 5105
5104: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5105: LD_INT 3
5107: PPUSH
5108: LD_INT 12
5110: PPUSH
5111: LD_INT 2
5113: PPUSH
5114: LD_INT 22
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 30
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PPUSH
5138: CALL_OW 69
5142: PUSH
5143: LD_INT 1
5145: ARRAY
5146: PPUSH
5147: CALL_OW 468
// if player_com = stolypin then
5151: LD_EXP 24
5155: PUSH
5156: LD_EXP 21
5160: EQUAL
5161: IFFALSE 5190
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5163: LD_INT 18
5165: PPUSH
5166: LD_INT 3
5168: PUSH
5169: LD_INT 3
5171: PUSH
5172: LD_INT 2
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PPUSH
5186: CALL 6490 0 2
// end ;
5190: LD_VAR 0 1
5194: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5195: LD_EXP 11
5199: PUSH
5200: LD_OWVAR 1
5204: PUSH
5205: LD_INT 31500
5207: LESS
5208: AND
5209: IFFALSE 5373
// case query ( call1 ) of 1 :
5211: LD_STRING call1
5213: PPUSH
5214: CALL_OW 97
5218: PUSH
5219: LD_INT 1
5221: DOUBLE
5222: EQUAL
5223: IFTRUE 5227
5225: GO 5361
5227: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5228: LD_INT 3
5230: PPUSH
5231: LD_INT 12
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: LD_EXP 10
5241: PPUSH
5242: CALL_OW 468
// call := false ;
5246: LD_ADDR_EXP 11
5250: PUSH
5251: LD_INT 0
5253: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5254: LD_EXP 25
5258: PPUSH
5259: LD_STRING DR6
5261: PPUSH
5262: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5266: LD_INT 6300
5268: PPUSH
5269: LD_INT 8400
5271: PPUSH
5272: CALL_OW 12
5276: PPUSH
5277: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5281: LD_INT 18
5283: PUSH
5284: LD_INT 19
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: LD_INT 1
5293: PPUSH
5294: LD_INT 2
5296: PPUSH
5297: CALL_OW 12
5301: ARRAY
5302: PPUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: PPUSH
5314: CALL 6490 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5318: LD_INT 25200
5320: PPUSH
5321: LD_INT 35700
5323: PPUSH
5324: CALL_OW 12
5328: PPUSH
5329: CALL_OW 67
// call := true ;
5333: LD_ADDR_EXP 11
5337: PUSH
5338: LD_INT 1
5340: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5341: LD_INT 3
5343: PPUSH
5344: LD_INT 12
5346: PPUSH
5347: LD_INT 2
5349: PPUSH
5350: LD_EXP 10
5354: PPUSH
5355: CALL_OW 468
// end ; 2 :
5359: GO 5373
5361: LD_INT 2
5363: DOUBLE
5364: EQUAL
5365: IFTRUE 5369
5367: GO 5372
5369: POP
// ; end ;
5370: GO 5373
5372: POP
// if call and tick >= 15 15$00 then
5373: LD_EXP 11
5377: PUSH
5378: LD_OWVAR 1
5382: PUSH
5383: LD_INT 31500
5385: GREATEREQUAL
5386: AND
5387: IFFALSE 5816
// case query ( call2 ) of 1 :
5389: LD_STRING call2
5391: PPUSH
5392: CALL_OW 97
5396: PUSH
5397: LD_INT 1
5399: DOUBLE
5400: EQUAL
5401: IFTRUE 5405
5403: GO 5641
5405: POP
// begin call := false ;
5406: LD_ADDR_EXP 11
5410: PUSH
5411: LD_INT 0
5413: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5414: LD_INT 1
5416: PPUSH
5417: LD_INT 21
5419: PUSH
5420: LD_INT 3
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: CALL 11421 0 2
5431: PUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11421 0 2
5449: AND
5450: IFFALSE 5498
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5452: LD_INT 18
5454: PUSH
5455: LD_INT 19
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 1
5464: PPUSH
5465: LD_INT 2
5467: PPUSH
5468: CALL_OW 12
5472: ARRAY
5473: PPUSH
5474: LD_INT 5
5476: PUSH
5477: LD_INT 4
5479: PUSH
5480: LD_INT 4
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: LD_OWVAR 67
5492: ARRAY
5493: PPUSH
5494: CALL 6251 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5498: LD_INT 1
5500: PPUSH
5501: LD_INT 21
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL 11421 0 2
5515: PUSH
5516: LD_INT 0
5518: EQUAL
5519: IFFALSE 5548
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5521: LD_INT 19
5523: PPUSH
5524: LD_INT 5
5526: PUSH
5527: LD_INT 4
5529: PUSH
5530: LD_INT 3
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: LD_OWVAR 67
5542: ARRAY
5543: PPUSH
5544: CALL 6251 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5548: LD_INT 4
5550: PPUSH
5551: LD_INT 21
5553: PUSH
5554: LD_INT 3
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PPUSH
5561: CALL 11421 0 2
5565: PUSH
5566: LD_INT 0
5568: EQUAL
5569: IFFALSE 5598
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5571: LD_INT 18
5573: PPUSH
5574: LD_INT 5
5576: PUSH
5577: LD_INT 4
5579: PUSH
5580: LD_INT 4
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: PUSH
5588: LD_OWVAR 67
5592: ARRAY
5593: PPUSH
5594: CALL 6251 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5598: LD_INT 10500
5600: PPUSH
5601: LD_INT 23100
5603: PPUSH
5604: CALL_OW 12
5608: PPUSH
5609: CALL_OW 67
// call := true ;
5613: LD_ADDR_EXP 11
5617: PUSH
5618: LD_INT 1
5620: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 12
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_EXP 10
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5816
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5804
5649: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5650: LD_INT 3
5652: PPUSH
5653: LD_INT 12
5655: PPUSH
5656: LD_INT 1
5658: PPUSH
5659: LD_EXP 10
5663: PPUSH
5664: CALL_OW 468
// call := false ;
5668: LD_ADDR_EXP 11
5672: PUSH
5673: LD_INT 0
5675: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5676: LD_EXP 25
5680: PPUSH
5681: LD_STRING DR6
5683: PPUSH
5684: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5688: LD_INT 6300
5690: PPUSH
5691: LD_INT 8400
5693: PPUSH
5694: CALL_OW 12
5698: PPUSH
5699: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5703: LD_INT 18
5705: PUSH
5706: LD_INT 19
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 1
5715: PPUSH
5716: LD_INT 2
5718: PPUSH
5719: CALL_OW 12
5723: ARRAY
5724: PPUSH
5725: LD_INT 3
5727: PUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: PUSH
5739: LD_OWVAR 67
5743: ARRAY
5744: PUSH
5745: LD_INT 0
5747: PPUSH
5748: LD_INT 1
5750: PPUSH
5751: CALL_OW 12
5755: MINUS
5756: PPUSH
5757: CALL 6490 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5761: LD_INT 35700
5763: PPUSH
5764: LD_INT 44100
5766: PPUSH
5767: CALL_OW 12
5771: PPUSH
5772: CALL_OW 67
// call := true ;
5776: LD_ADDR_EXP 11
5780: PUSH
5781: LD_INT 1
5783: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5784: LD_INT 3
5786: PPUSH
5787: LD_INT 12
5789: PPUSH
5790: LD_INT 2
5792: PPUSH
5793: LD_EXP 10
5797: PPUSH
5798: CALL_OW 468
// end ; 3 :
5802: GO 5816
5804: LD_INT 3
5806: DOUBLE
5807: EQUAL
5808: IFTRUE 5812
5810: GO 5815
5812: POP
// ; end ;
5813: GO 5816
5815: POP
// end ;
5816: PPOPN 4
5818: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5819: LD_INT 22
5821: PUSH
5822: LD_INT 1
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 21
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PPUSH
5843: CALL_OW 69
5847: PUSH
5848: LD_INT 0
5850: EQUAL
5851: PUSH
5852: LD_INT 22
5854: PUSH
5855: LD_INT 4
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 21
5864: PUSH
5865: LD_INT 1
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PPUSH
5876: CALL_OW 69
5880: PUSH
5881: LD_INT 0
5883: EQUAL
5884: AND
5885: IFFALSE 6089
5887: GO 5889
5889: DISABLE
// begin DialogueOn ;
5890: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5894: LD_EXP 25
5898: PPUSH
5899: LD_STRING DR7
5901: PPUSH
5902: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5906: LD_OWVAR 1
5910: PUSH
5911: LD_INT 116550
5913: PUSH
5914: LD_INT 95550
5916: PUSH
5917: LD_INT 89250
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_OWVAR 67
5929: ARRAY
5930: LESS
5931: IFFALSE 5945
// AddMedal ( med1 , 1 ) else
5933: LD_STRING med1
5935: PPUSH
5936: LD_INT 1
5938: PPUSH
5939: CALL_OW 101
5943: GO 5956
// AddMedal ( med1 , - 1 ) ;
5945: LD_STRING med1
5947: PPUSH
5948: LD_INT 1
5950: NEG
5951: PPUSH
5952: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5956: LD_INT 81
5958: PUSH
5959: LD_INT 3
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: LD_INT 21
5968: PUSH
5969: LD_INT 3
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 69
5984: PUSH
5985: LD_INT 0
5987: EQUAL
5988: IFFALSE 6002
// AddMedal ( med3 , 1 ) else
5990: LD_STRING med3
5992: PPUSH
5993: LD_INT 1
5995: PPUSH
5996: CALL_OW 101
6000: GO 6013
// AddMedal ( med3 , - 1 ) ;
6002: LD_STRING med3
6004: PPUSH
6005: LD_INT 1
6007: NEG
6008: PPUSH
6009: CALL_OW 101
// if player_loss = 0 then
6013: LD_EXP 9
6017: PUSH
6018: LD_INT 0
6020: EQUAL
6021: IFFALSE 6035
// AddMedal ( med2 , 1 ) else
6023: LD_STRING med2
6025: PPUSH
6026: LD_INT 1
6028: PPUSH
6029: CALL_OW 101
6033: GO 6078
// if player_loss > 0 and player_loss < 3 then
6035: LD_EXP 9
6039: PUSH
6040: LD_INT 0
6042: GREATER
6043: PUSH
6044: LD_EXP 9
6048: PUSH
6049: LD_INT 3
6051: LESS
6052: AND
6053: IFFALSE 6067
// AddMedal ( med2 , 2 ) else
6055: LD_STRING med2
6057: PPUSH
6058: LD_INT 2
6060: PPUSH
6061: CALL_OW 101
6065: GO 6078
// AddMedal ( med2 , - 1 ) ;
6067: LD_STRING med2
6069: PPUSH
6070: LD_INT 1
6072: NEG
6073: PPUSH
6074: CALL_OW 101
// GiveMedals ( MAIN ) ;
6078: LD_STRING MAIN
6080: PPUSH
6081: CALL_OW 102
// YouWin ;
6085: CALL_OW 103
// end ;
6089: END
// every 0 0$01 trigger IsDead ( player_com ) do
6090: LD_EXP 24
6094: PPUSH
6095: CALL_OW 301
6099: IFFALSE 6166
6101: GO 6103
6103: DISABLE
// begin if IsLive ( Houten ) then
6104: LD_EXP 3
6108: PPUSH
6109: CALL_OW 300
6113: IFFALSE 6129
// SayRadio ( Houten , DJ5 ) else
6115: LD_EXP 3
6119: PPUSH
6120: LD_STRING DJ5
6122: PPUSH
6123: CALL_OW 94
6127: GO 6152
// if IsLive ( Brown ) then
6129: LD_EXP 4
6133: PPUSH
6134: CALL_OW 300
6138: IFFALSE 6152
// SayRadio ( Brown , DS5 ) ;
6140: LD_EXP 4
6144: PPUSH
6145: LD_STRING DS5
6147: PPUSH
6148: CALL_OW 94
// Wait ( 0 0$01 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// YouLost ( dead ) ;
6159: LD_STRING dead
6161: PPUSH
6162: CALL_OW 104
// end ;
6166: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6167: LD_EXP 10
6171: PPUSH
6172: CALL_OW 301
6176: PUSH
6177: LD_EXP 1
6181: NOT
6182: AND
6183: IFFALSE 6250
6185: GO 6187
6187: DISABLE
// begin if IsLive ( Brown ) then
6188: LD_EXP 4
6192: PPUSH
6193: CALL_OW 300
6197: IFFALSE 6213
// SayRadio ( Brown , DS5 ) else
6199: LD_EXP 4
6203: PPUSH
6204: LD_STRING DS5
6206: PPUSH
6207: CALL_OW 94
6211: GO 6236
// if IsLive ( Houten ) then
6213: LD_EXP 3
6217: PPUSH
6218: CALL_OW 300
6222: IFFALSE 6236
// SayRadio ( Houten , DJ5 ) ;
6224: LD_EXP 3
6228: PPUSH
6229: LD_STRING DJ5
6231: PPUSH
6232: CALL_OW 94
// Wait ( 0 0$01 ) ;
6236: LD_INT 35
6238: PPUSH
6239: CALL_OW 67
// YouLost ( depot ) ;
6243: LD_STRING depot
6245: PPUSH
6246: CALL_OW 104
// end ;
6250: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6251: LD_INT 0
6253: PPUSH
6254: PPUSH
6255: PPUSH
// for i = 1 to n do
6256: LD_ADDR_VAR 0 4
6260: PUSH
6261: DOUBLE
6262: LD_INT 1
6264: DEC
6265: ST_TO_ADDR
6266: LD_VAR 0 2
6270: PUSH
6271: FOR_TO
6272: IFFALSE 6475
// begin uc_side := 6 ;
6274: LD_ADDR_OWVAR 20
6278: PUSH
6279: LD_INT 6
6281: ST_TO_ADDR
// uc_nation := 3 ;
6282: LD_ADDR_OWVAR 21
6286: PUSH
6287: LD_INT 3
6289: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6290: LD_ADDR_OWVAR 37
6294: PUSH
6295: LD_INT 23
6297: PUSH
6298: LD_INT 22
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 1
6307: PPUSH
6308: LD_INT 2
6310: PPUSH
6311: CALL_OW 12
6315: ARRAY
6316: ST_TO_ADDR
// vc_control := control_computer ;
6317: LD_ADDR_OWVAR 38
6321: PUSH
6322: LD_INT 3
6324: ST_TO_ADDR
// vc_engine := engine_siberite ;
6325: LD_ADDR_OWVAR 39
6329: PUSH
6330: LD_INT 3
6332: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6333: LD_ADDR_OWVAR 40
6337: PUSH
6338: LD_INT 43
6340: PUSH
6341: LD_INT 44
6343: PUSH
6344: LD_INT 44
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 1
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: CALL_OW 12
6362: ARRAY
6363: ST_TO_ADDR
// un := CreateVehicle ;
6364: LD_ADDR_VAR 0 5
6368: PUSH
6369: CALL_OW 45
6373: ST_TO_ADDR
// case area of east_arr :
6374: LD_VAR 0 1
6378: PUSH
6379: LD_INT 18
6381: DOUBLE
6382: EQUAL
6383: IFTRUE 6387
6385: GO 6422
6387: POP
// begin PlaceUnitArea ( un , area , false ) ;
6388: LD_VAR 0 5
6392: PPUSH
6393: LD_VAR 0 1
6397: PPUSH
6398: LD_INT 0
6400: PPUSH
6401: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6405: LD_VAR 0 5
6409: PPUSH
6410: LD_INT 79
6412: PPUSH
6413: LD_INT 33
6415: PPUSH
6416: CALL_OW 111
// end ; south_arr :
6420: GO 6466
6422: LD_INT 19
6424: DOUBLE
6425: EQUAL
6426: IFTRUE 6430
6428: GO 6465
6430: POP
// begin PlaceUnitArea ( un , area , false ) ;
6431: LD_VAR 0 5
6435: PPUSH
6436: LD_VAR 0 1
6440: PPUSH
6441: LD_INT 0
6443: PPUSH
6444: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6448: LD_VAR 0 5
6452: PPUSH
6453: LD_INT 131
6455: PPUSH
6456: LD_INT 148
6458: PPUSH
6459: CALL_OW 111
// end ; end ;
6463: GO 6466
6465: POP
// Wait ( 0 0$02 ) ;
6466: LD_INT 70
6468: PPUSH
6469: CALL_OW 67
// end ;
6473: GO 6271
6475: POP
6476: POP
// pink_attack := true ;
6477: LD_ADDR_EXP 12
6481: PUSH
6482: LD_INT 1
6484: ST_TO_ADDR
// end ;
6485: LD_VAR 0 3
6489: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6490: LD_INT 0
6492: PPUSH
6493: PPUSH
6494: PPUSH
// for i = 1 to n do
6495: LD_ADDR_VAR 0 4
6499: PUSH
6500: DOUBLE
6501: LD_INT 1
6503: DEC
6504: ST_TO_ADDR
6505: LD_VAR 0 2
6509: PUSH
6510: FOR_TO
6511: IFFALSE 6737
// begin uc_side := 6 ;
6513: LD_ADDR_OWVAR 20
6517: PUSH
6518: LD_INT 6
6520: ST_TO_ADDR
// uc_nation := 3 ;
6521: LD_ADDR_OWVAR 21
6525: PUSH
6526: LD_INT 3
6528: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6529: LD_INT 0
6531: PPUSH
6532: LD_INT 3
6534: PPUSH
6535: LD_INT 4
6537: PPUSH
6538: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6542: LD_ADDR_OWVAR 37
6546: PUSH
6547: LD_INT 22
6549: ST_TO_ADDR
// vc_control := control_manual ;
6550: LD_ADDR_OWVAR 38
6554: PUSH
6555: LD_INT 1
6557: ST_TO_ADDR
// vc_engine := engine_combustion ;
6558: LD_ADDR_OWVAR 39
6562: PUSH
6563: LD_INT 1
6565: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6566: LD_ADDR_OWVAR 40
6570: PUSH
6571: LD_INT 51
6573: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6574: LD_ADDR_OWVAR 41
6578: PUSH
6579: LD_INT 50
6581: ST_TO_ADDR
// un := CreateVehicle ;
6582: LD_ADDR_VAR 0 5
6586: PUSH
6587: CALL_OW 45
6591: ST_TO_ADDR
// case area of east_arr :
6592: LD_VAR 0 1
6596: PUSH
6597: LD_INT 18
6599: DOUBLE
6600: EQUAL
6601: IFTRUE 6605
6603: GO 6620
6605: POP
// SetDir ( un , 4 ) ; south_arr :
6606: LD_VAR 0 5
6610: PPUSH
6611: LD_INT 4
6613: PPUSH
6614: CALL_OW 233
6618: GO 6644
6620: LD_INT 19
6622: DOUBLE
6623: EQUAL
6624: IFTRUE 6628
6626: GO 6643
6628: POP
// SetDir ( un , 5 ) ; end ;
6629: LD_VAR 0 5
6633: PPUSH
6634: LD_INT 5
6636: PPUSH
6637: CALL_OW 233
6641: GO 6644
6643: POP
// PlaceUnitArea ( un , area , false ) ;
6644: LD_VAR 0 5
6648: PPUSH
6649: LD_VAR 0 1
6653: PPUSH
6654: LD_INT 0
6656: PPUSH
6657: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6661: CALL_OW 44
6665: PPUSH
6666: LD_VAR 0 5
6670: PPUSH
6671: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6675: LD_VAR 0 5
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: LD_INT 100
6685: PPUSH
6686: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6690: LD_VAR 0 5
6694: PPUSH
6695: LD_INT 106
6697: PPUSH
6698: LD_INT 88
6700: PPUSH
6701: CALL_OW 111
// AddComUnload ( un ) ;
6705: LD_VAR 0 5
6709: PPUSH
6710: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6714: LD_VAR 0 5
6718: PPUSH
6719: LD_VAR 0 1
6723: PPUSH
6724: CALL_OW 173
// Wait ( 0 0$02 ) ;
6728: LD_INT 70
6730: PPUSH
6731: CALL_OW 67
// end ;
6735: GO 6510
6737: POP
6738: POP
// Wait ( 0 0$05 ) ;
6739: LD_INT 175
6741: PPUSH
6742: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6746: LD_INT 6
6748: PPUSH
6749: LD_INT 34
6751: PUSH
6752: LD_INT 51
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PPUSH
6759: CALL 11421 0 2
6763: IFFALSE 6951
// begin wait ( 0 0$01 ) ;
6765: LD_INT 35
6767: PPUSH
6768: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6772: LD_ADDR_VAR 0 4
6776: PUSH
6777: LD_INT 6
6779: PPUSH
6780: LD_INT 34
6782: PUSH
6783: LD_INT 51
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL 11421 0 2
6794: PUSH
6795: FOR_IN
6796: IFFALSE 6947
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6798: LD_VAR 0 4
6802: PPUSH
6803: LD_INT 9
6805: PPUSH
6806: CALL_OW 308
6810: PUSH
6811: LD_VAR 0 4
6815: PPUSH
6816: CALL 31653 0 1
6820: PPUSH
6821: CALL_OW 258
6825: PUSH
6826: LD_INT 1
6828: EQUAL
6829: AND
6830: PUSH
6831: LD_EXP 8
6835: AND
6836: IFFALSE 6863
// begin Say ( GetDriver ( i ) , Dtran ) ;
6838: LD_VAR 0 4
6842: PPUSH
6843: CALL 31653 0 1
6847: PPUSH
6848: LD_STRING Dtran
6850: PPUSH
6851: CALL_OW 88
// dialog_trans := false ;
6855: LD_ADDR_EXP 8
6859: PUSH
6860: LD_INT 0
6862: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6863: LD_VAR 0 4
6867: PPUSH
6868: CALL_OW 316
6872: IFFALSE 6888
// ComMoveToArea ( i , area ) ;
6874: LD_VAR 0 4
6878: PPUSH
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6888: LD_VAR 0 4
6892: PPUSH
6893: LD_VAR 0 1
6897: PPUSH
6898: CALL_OW 308
6902: PUSH
6903: LD_VAR 0 4
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: CALL_OW 289
6915: PUSH
6916: LD_INT 0
6918: EQUAL
6919: AND
6920: IFFALSE 6945
// begin RemoveUnit ( GetDriver ( i ) ) ;
6922: LD_VAR 0 4
6926: PPUSH
6927: CALL 31653 0 1
6931: PPUSH
6932: CALL_OW 64
// RemoveUnit ( i ) ;
6936: LD_VAR 0 4
6940: PPUSH
6941: CALL_OW 64
// end ; end ;
6945: GO 6795
6947: POP
6948: POP
// end ;
6949: GO 6746
// end ;
6951: LD_VAR 0 3
6955: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
// if isTest then
6962: LD_EXP 1
6966: IFFALSE 6970
// exit ;
6968: GO 7359
// for i = 1 to n do
6970: LD_ADDR_VAR 0 4
6974: PUSH
6975: DOUBLE
6976: LD_INT 1
6978: DEC
6979: ST_TO_ADDR
6980: LD_VAR 0 2
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7218
// begin uc_side := 8 ;
6988: LD_ADDR_OWVAR 20
6992: PUSH
6993: LD_INT 8
6995: ST_TO_ADDR
// uc_nation := 1 ;
6996: LD_ADDR_OWVAR 21
7000: PUSH
7001: LD_INT 1
7003: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7004: LD_ADDR_VAR 0 6
7008: PUSH
7009: LD_INT 3
7011: PUSH
7012: LD_INT 4
7014: PUSH
7015: LD_INT 4
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 1
7025: PPUSH
7026: LD_OWVAR 67
7030: PPUSH
7031: CALL_OW 12
7035: ARRAY
7036: ST_TO_ADDR
// vc_chassis := ch ;
7037: LD_ADDR_OWVAR 37
7041: PUSH
7042: LD_VAR 0 6
7046: ST_TO_ADDR
// vc_control := control_computer ;
7047: LD_ADDR_OWVAR 38
7051: PUSH
7052: LD_INT 3
7054: ST_TO_ADDR
// vc_engine := engine_combustion ;
7055: LD_ADDR_OWVAR 39
7059: PUSH
7060: LD_INT 1
7062: ST_TO_ADDR
// if ch = us_medium_tracked then
7063: LD_VAR 0 6
7067: PUSH
7068: LD_INT 3
7070: EQUAL
7071: IFFALSE 7118
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7073: LD_ADDR_OWVAR 40
7077: PUSH
7078: LD_INT 3
7080: PUSH
7081: LD_INT 4
7083: PUSH
7084: LD_INT 5
7086: PUSH
7087: LD_INT 7
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: PUSH
7096: LD_OWVAR 67
7100: PPUSH
7101: LD_OWVAR 67
7105: PUSH
7106: LD_INT 1
7108: PLUS
7109: PPUSH
7110: CALL_OW 12
7114: ARRAY
7115: ST_TO_ADDR
7116: GO 7159
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7118: LD_ADDR_OWVAR 40
7122: PUSH
7123: LD_INT 5
7125: PUSH
7126: LD_INT 6
7128: PUSH
7129: LD_INT 7
7131: PUSH
7132: LD_INT 7
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PUSH
7149: LD_INT 1
7151: PLUS
7152: PPUSH
7153: CALL_OW 12
7157: ARRAY
7158: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7159: LD_ADDR_OWVAR 41
7163: PUSH
7164: LD_INT 70
7166: ST_TO_ADDR
// un := CreateVehicle ;
7167: LD_ADDR_VAR 0 5
7171: PUSH
7172: CALL_OW 45
7176: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7177: LD_VAR 0 5
7181: PPUSH
7182: LD_VAR 0 1
7186: PPUSH
7187: LD_INT 0
7189: PPUSH
7190: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7194: LD_VAR 0 5
7198: PPUSH
7199: LD_INT 65
7201: PPUSH
7202: LD_INT 9
7204: PPUSH
7205: CALL_OW 111
// Wait ( 0 0$02 ) ;
7209: LD_INT 70
7211: PPUSH
7212: CALL_OW 67
// end ;
7216: GO 6985
7218: POP
7219: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7220: LD_INT 90
7222: PUSH
7223: LD_INT 80
7225: PUSH
7226: LD_INT 70
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: LD_OWVAR 67
7238: ARRAY
7239: PPUSH
7240: CALL_OW 13
7244: IFFALSE 7351
// begin uc_side := 8 ;
7246: LD_ADDR_OWVAR 20
7250: PUSH
7251: LD_INT 8
7253: ST_TO_ADDR
// uc_nation := 1 ;
7254: LD_ADDR_OWVAR 21
7258: PUSH
7259: LD_INT 1
7261: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7262: LD_ADDR_OWVAR 37
7266: PUSH
7267: LD_INT 4
7269: ST_TO_ADDR
// vc_control := control_computer ;
7270: LD_ADDR_OWVAR 38
7274: PUSH
7275: LD_INT 3
7277: ST_TO_ADDR
// vc_engine := engine_combustion ;
7278: LD_ADDR_OWVAR 39
7282: PUSH
7283: LD_INT 1
7285: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7286: LD_ADDR_OWVAR 40
7290: PUSH
7291: LD_INT 14
7293: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7294: LD_ADDR_OWVAR 41
7298: PUSH
7299: LD_INT 70
7301: ST_TO_ADDR
// un := CreateVehicle ;
7302: LD_ADDR_VAR 0 5
7306: PUSH
7307: CALL_OW 45
7311: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7312: LD_VAR 0 5
7316: PPUSH
7317: LD_VAR 0 1
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7329: LD_VAR 0 5
7333: PPUSH
7334: LD_INT 65
7336: PPUSH
7337: LD_INT 9
7339: PPUSH
7340: CALL_OW 111
// Wait ( 0 0$02 ) ;
7344: LD_INT 70
7346: PPUSH
7347: CALL_OW 67
// end ; alfa_support := true ;
7351: LD_ADDR_EXP 13
7355: PUSH
7356: LD_INT 1
7358: ST_TO_ADDR
// end ;
7359: LD_VAR 0 3
7363: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7364: LD_OWVAR 1
7368: PUSH
7369: LD_INT 21000
7371: PUSH
7372: LD_INT 18900
7374: PUSH
7375: LD_INT 16800
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: LIST
7382: PUSH
7383: LD_OWVAR 67
7387: ARRAY
7388: GREATER
7389: IFFALSE 7473
7391: GO 7393
7393: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7394: LD_EXP 25
7398: PPUSH
7399: LD_STRING DR5
7401: PPUSH
7402: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7406: LD_INT 1050
7408: PPUSH
7409: LD_INT 4200
7411: PPUSH
7412: CALL_OW 12
7416: PPUSH
7417: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7421: LD_INT 20
7423: PPUSH
7424: LD_INT 5
7426: PUSH
7427: LD_INT 6
7429: PUSH
7430: LD_INT 7
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PUSH
7438: LD_OWVAR 67
7442: ARRAY
7443: PPUSH
7444: CALL 6956 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7448: LD_INT 8400
7450: PPUSH
7451: LD_INT 12600
7453: PPUSH
7454: CALL_OW 12
7458: PPUSH
7459: CALL_OW 67
// until tick >= 120 120$00 ;
7463: LD_OWVAR 1
7467: PUSH
7468: LD_INT 252000
7470: GREATEREQUAL
7471: IFFALSE 7394
// end ; end_of_file
7473: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7474: LD_INT 0
7476: PPUSH
// enable_addtolog := isTest ;
7477: LD_ADDR_OWVAR 81
7481: PUSH
7482: LD_EXP 1
7486: ST_TO_ADDR
// lines_break_limit := 5 ;
7487: LD_ADDR_EXP 27
7491: PUSH
7492: LD_INT 5
7494: ST_TO_ADDR
// lines_break_type := --- ;
7495: LD_ADDR_EXP 28
7499: PUSH
7500: LD_STRING ---
7502: ST_TO_ADDR
// lines_counter := 0 ;
7503: LD_ADDR_EXP 26
7507: PUSH
7508: LD_INT 0
7510: ST_TO_ADDR
// show_line_index := true ;
7511: LD_ADDR_EXP 29
7515: PUSH
7516: LD_INT 1
7518: ST_TO_ADDR
// tick_log := true ;
7519: LD_ADDR_EXP 30
7523: PUSH
7524: LD_INT 1
7526: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7527: LD_STRING ----------SAND OF SIBERIA LOG----------
7529: PPUSH
7530: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7534: LD_STRING Map Name: 
7536: PUSH
7537: LD_OWVAR 68
7541: STR
7542: PPUSH
7543: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7547: LD_STRING Map Number: 
7549: PUSH
7550: LD_OWVAR 70
7554: STR
7555: PPUSH
7556: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7560: LD_STRING Difficulty: 
7562: PUSH
7563: LD_OWVAR 67
7567: STR
7568: PPUSH
7569: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7573: LD_STRING ---------------------------------------
7575: PPUSH
7576: CALL_OW 561
// end ;
7580: LD_VAR 0 1
7584: RET
// function Log ( text ) ; begin
7585: LD_INT 0
7587: PPUSH
// if show_line_index then
7588: LD_EXP 29
7592: IFFALSE 7604
// result := lines_counter ;
7594: LD_ADDR_VAR 0 2
7598: PUSH
7599: LD_EXP 26
7603: ST_TO_ADDR
// if tick_log then
7604: LD_EXP 30
7608: IFFALSE 7634
// result := result &  T:  & tick &   ;
7610: LD_ADDR_VAR 0 2
7614: PUSH
7615: LD_VAR 0 2
7619: PUSH
7620: LD_STRING  T: 
7622: STR
7623: PUSH
7624: LD_OWVAR 1
7628: STR
7629: PUSH
7630: LD_STRING  
7632: STR
7633: ST_TO_ADDR
// AddToLog ( result & text ) ;
7634: LD_VAR 0 2
7638: PUSH
7639: LD_VAR 0 1
7643: STR
7644: PPUSH
7645: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7649: LD_ADDR_EXP 26
7653: PUSH
7654: LD_EXP 26
7658: PUSH
7659: LD_INT 1
7661: PLUS
7662: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7663: LD_EXP 26
7667: PUSH
7668: LD_EXP 27
7672: MOD
7673: PUSH
7674: LD_INT 0
7676: EQUAL
7677: IFFALSE 7688
// AddToLog ( lines_break_type ) ;
7679: LD_EXP 28
7683: PPUSH
7684: CALL_OW 561
// end ;
7688: LD_VAR 0 2
7692: RET
// export function LogHuman ( id ) ; begin
7693: LD_INT 0
7695: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7696: LD_STRING Human Created. id: 
7698: PUSH
7699: LD_VAR 0 1
7703: STR
7704: PUSH
7705: LD_STRING ; side: 
7707: STR
7708: PUSH
7709: LD_VAR 0 1
7713: PPUSH
7714: CALL_OW 255
7718: STR
7719: PUSH
7720: LD_STRING ; class: 
7722: STR
7723: PUSH
7724: LD_VAR 0 1
7728: PPUSH
7729: CALL_OW 257
7733: STR
7734: PUSH
7735: LD_STRING ; 
7737: STR
7738: PPUSH
7739: CALL 7585 0 1
// end ;
7743: LD_VAR 0 2
7747: RET
// export function LogVeh ( id ) ; begin
7748: LD_INT 0
7750: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7751: LD_STRING Vehicle Created. id: 
7753: PUSH
7754: LD_VAR 0 1
7758: STR
7759: PUSH
7760: LD_STRING ; side: 
7762: STR
7763: PUSH
7764: LD_VAR 0 1
7768: PPUSH
7769: CALL_OW 255
7773: STR
7774: PUSH
7775: LD_STRING ; nation: 
7777: STR
7778: PUSH
7779: LD_VAR 0 1
7783: PPUSH
7784: CALL_OW 248
7788: STR
7789: PUSH
7790: LD_STRING ; weapon: 
7792: STR
7793: PUSH
7794: LD_VAR 0 1
7798: PPUSH
7799: CALL_OW 264
7803: STR
7804: PUSH
7805: LD_STRING ; 
7807: STR
7808: PPUSH
7809: CALL 7585 0 1
// end ;
7813: LD_VAR 0 2
7817: RET
// export function LogEvent ( event ) ; begin
7818: LD_INT 0
7820: PPUSH
// Log ( Event Executed. id:  & event ) ;
7821: LD_STRING Event Executed. id: 
7823: PUSH
7824: LD_VAR 0 1
7828: STR
7829: PPUSH
7830: CALL 7585 0 1
// end ; end_of_file
7834: LD_VAR 0 2
7838: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7839: LD_INT 0
7841: PPUSH
7842: PPUSH
7843: PPUSH
7844: PPUSH
7845: PPUSH
7846: PPUSH
7847: PPUSH
7848: PPUSH
// if unit then
7849: LD_VAR 0 1
7853: IFFALSE 8253
// begin if mode = 0 then
7855: LD_VAR 0 3
7859: PUSH
7860: LD_INT 0
7862: EQUAL
7863: IFFALSE 8011
// begin if coords then
7865: LD_VAR 0 2
7869: IFFALSE 8009
// while ( coords > 1 ) do
7871: LD_VAR 0 2
7875: PUSH
7876: LD_INT 1
7878: GREATER
7879: IFFALSE 8009
// if not HasTask ( unit ) then
7881: LD_VAR 0 1
7885: PPUSH
7886: CALL_OW 314
7890: NOT
7891: IFFALSE 8007
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7893: LD_VAR 0 1
7897: PPUSH
7898: LD_VAR 0 2
7902: PUSH
7903: LD_INT 1
7905: ARRAY
7906: PPUSH
7907: LD_VAR 0 2
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7920: LD_INT 35
7922: PPUSH
7923: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7927: LD_VAR 0 1
7931: PPUSH
7932: CALL_OW 250
7936: PUSH
7937: LD_VAR 0 2
7941: PUSH
7942: LD_INT 1
7944: ARRAY
7945: EQUAL
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 251
7956: PUSH
7957: LD_VAR 0 2
7961: PUSH
7962: LD_INT 2
7964: ARRAY
7965: EQUAL
7966: AND
7967: IFFALSE 7920
// for i = 1 to 2 do
7969: LD_ADDR_VAR 0 5
7973: PUSH
7974: DOUBLE
7975: LD_INT 1
7977: DEC
7978: ST_TO_ADDR
7979: LD_INT 2
7981: PUSH
7982: FOR_TO
7983: IFFALSE 8005
// coords := Delete ( coords , 1 ) ;
7985: LD_ADDR_VAR 0 2
7989: PUSH
7990: LD_VAR 0 2
7994: PPUSH
7995: LD_INT 1
7997: PPUSH
7998: CALL_OW 3
8002: ST_TO_ADDR
8003: GO 7982
8005: POP
8006: POP
// end ;
8007: GO 7871
// end else
8009: GO 8253
// begin if coords then
8011: LD_VAR 0 2
8015: IFFALSE 8253
// begin x := GetX ( unit ) ;
8017: LD_ADDR_VAR 0 6
8021: PUSH
8022: LD_VAR 0 1
8026: PPUSH
8027: CALL_OW 250
8031: ST_TO_ADDR
// y := GetY ( unit ) ;
8032: LD_ADDR_VAR 0 7
8036: PUSH
8037: LD_VAR 0 1
8041: PPUSH
8042: CALL_OW 251
8046: ST_TO_ADDR
// while ( coords > 1 ) do
8047: LD_VAR 0 2
8051: PUSH
8052: LD_INT 1
8054: GREATER
8055: IFFALSE 8253
// begin Wait ( 0 0$0.3 ) ;
8057: LD_INT 10
8059: PPUSH
8060: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8064: LD_VAR 0 1
8068: PPUSH
8069: CALL_OW 255
8073: PPUSH
8074: LD_VAR 0 1
8078: PPUSH
8079: CALL_OW 250
8083: PPUSH
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 251
8093: PPUSH
8094: LD_INT 14
8096: PPUSH
8097: CALL 22591 0 4
8101: IFFALSE 8132
// begin ComMoveXY ( unit , x , y ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_VAR 0 6
8112: PPUSH
8113: LD_VAR 0 7
8117: PPUSH
8118: CALL_OW 111
// result := false ;
8122: LD_ADDR_VAR 0 4
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// end else
8130: GO 8171
// if not HasTask ( unit ) then
8132: LD_VAR 0 1
8136: PPUSH
8137: CALL_OW 314
8141: NOT
8142: IFFALSE 8171
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8144: LD_VAR 0 1
8148: PPUSH
8149: LD_VAR 0 2
8153: PUSH
8154: LD_INT 1
8156: ARRAY
8157: PPUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 2
8165: ARRAY
8166: PPUSH
8167: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8171: LD_VAR 0 1
8175: PPUSH
8176: CALL_OW 250
8180: PUSH
8181: LD_VAR 0 2
8185: PUSH
8186: LD_INT 1
8188: ARRAY
8189: EQUAL
8190: PUSH
8191: LD_VAR 0 1
8195: PPUSH
8196: CALL_OW 251
8200: PUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 2
8208: ARRAY
8209: EQUAL
8210: AND
8211: IFFALSE 8251
// for i = 1 to 2 do
8213: LD_ADDR_VAR 0 5
8217: PUSH
8218: DOUBLE
8219: LD_INT 1
8221: DEC
8222: ST_TO_ADDR
8223: LD_INT 2
8225: PUSH
8226: FOR_TO
8227: IFFALSE 8249
// coords := Delete ( coords , 1 ) ;
8229: LD_ADDR_VAR 0 2
8233: PUSH
8234: LD_VAR 0 2
8238: PPUSH
8239: LD_INT 1
8241: PPUSH
8242: CALL_OW 3
8246: ST_TO_ADDR
8247: GO 8226
8249: POP
8250: POP
// end ;
8251: GO 8047
// end ; end ; end ; result := true ;
8253: LD_ADDR_VAR 0 4
8257: PUSH
8258: LD_INT 1
8260: ST_TO_ADDR
// end ;
8261: LD_VAR 0 4
8265: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8266: LD_INT 0
8268: PPUSH
8269: PPUSH
8270: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8271: LD_ADDR_VAR 0 5
8275: PUSH
8276: LD_INT 81
8278: PUSH
8279: LD_VAR 0 1
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PPUSH
8288: CALL_OW 69
8292: ST_TO_ADDR
// for i in units do
8293: LD_ADDR_VAR 0 4
8297: PUSH
8298: LD_VAR 0 2
8302: PUSH
8303: FOR_IN
8304: IFFALSE 8332
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8306: LD_VAR 0 4
8310: PPUSH
8311: LD_VAR 0 5
8315: PPUSH
8316: LD_VAR 0 4
8320: PPUSH
8321: CALL_OW 74
8325: PPUSH
8326: CALL_OW 115
// end ;
8330: GO 8303
8332: POP
8333: POP
// end ;
8334: LD_VAR 0 3
8338: RET
// export function MC_Show ( string ) ; begin
8339: LD_INT 0
8341: PPUSH
// display_strings := string ;
8342: LD_ADDR_OWVAR 47
8346: PUSH
8347: LD_VAR 0 1
8351: ST_TO_ADDR
// end ; end_of_file
8352: LD_VAR 0 2
8356: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8357: LD_INT 0
8359: PPUSH
8360: PPUSH
8361: PPUSH
8362: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8363: LD_ADDR_VAR 0 8
8367: PUSH
8368: LD_VAR 0 1
8372: PPUSH
8373: LD_INT 2
8375: PPUSH
8376: EMPTY
8377: PPUSH
8378: CALL 11504 0 3
8382: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8383: LD_VAR 0 8
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_VAR 0 3
8397: PPUSH
8398: CALL_OW 428
8402: PUSH
8403: LD_INT 0
8405: EQUAL
8406: AND
8407: IFFALSE 8481
// for i = 1 to plist do
8409: LD_ADDR_VAR 0 6
8413: PUSH
8414: DOUBLE
8415: LD_INT 1
8417: DEC
8418: ST_TO_ADDR
8419: LD_VAR 0 8
8423: PUSH
8424: FOR_TO
8425: IFFALSE 8479
// if NotTask ( plist [ i ] ) then
8427: LD_VAR 0 8
8431: PUSH
8432: LD_VAR 0 6
8436: ARRAY
8437: PPUSH
8438: CALL 32298 0 1
8442: IFFALSE 8477
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8444: LD_VAR 0 8
8448: PUSH
8449: LD_VAR 0 6
8453: ARRAY
8454: PPUSH
8455: LD_INT 0
8457: PPUSH
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_VAR 0 3
8467: PPUSH
8468: LD_VAR 0 4
8472: PPUSH
8473: CALL_OW 145
// end ;
8477: GO 8424
8479: POP
8480: POP
// end ;
8481: LD_VAR 0 5
8485: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8486: LD_INT 0
8488: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8489: LD_VAR 0 1
8493: PPUSH
8494: LD_INT 6
8496: PPUSH
8497: LD_VAR 0 2
8501: PPUSH
8502: LD_VAR 0 3
8506: PPUSH
8507: LD_VAR 0 4
8511: PPUSH
8512: CALL 9990 0 5
// end ;
8516: LD_VAR 0 5
8520: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8521: LD_INT 0
8523: PPUSH
8524: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8525: LD_ADDR_VAR 0 4
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 1
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 2
8544: PUSH
8545: LD_INT 30
8547: PUSH
8548: LD_INT 0
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: PUSH
8555: LD_INT 30
8557: PUSH
8558: LD_INT 1
8560: PUSH
8561: EMPTY
8562: LIST
8563: LIST
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: LIST
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: PUSH
8574: EMPTY
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: CALL_OW 250
8591: PPUSH
8592: LD_VAR 0 2
8596: PPUSH
8597: CALL_OW 251
8601: PPUSH
8602: CALL_OW 73
8606: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8607: LD_VAR 0 4
8611: PPUSH
8612: LD_VAR 0 2
8616: PPUSH
8617: CALL 10279 0 2
8621: IFFALSE 8680
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8623: LD_VAR 0 1
8627: PPUSH
8628: LD_INT 30
8630: PUSH
8631: LD_VAR 0 2
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PPUSH
8640: CALL 11421 0 2
8644: PUSH
8645: LD_INT 1
8647: ARRAY
8648: PPUSH
8649: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8653: LD_ADDR_EXP 49
8657: PUSH
8658: LD_EXP 49
8662: PPUSH
8663: LD_VAR 0 1
8667: PPUSH
8668: LD_VAR 0 2
8672: PPUSH
8673: EMPTY
8674: PPUSH
8675: CALL 42332 0 4
8679: ST_TO_ADDR
// end ; end ;
8680: LD_VAR 0 3
8684: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8685: LD_INT 0
8687: PPUSH
8688: PPUSH
8689: PPUSH
8690: PPUSH
8691: PPUSH
8692: PPUSH
// result := false ;
8693: LD_ADDR_VAR 0 4
8697: PUSH
8698: LD_INT 0
8700: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8701: LD_VAR 0 1
8705: PPUSH
8706: LD_EXP 41
8710: PPUSH
8711: CALL 43280 0 2
8715: IFFALSE 8928
// for i = 1 to MREG_LabList do
8717: LD_ADDR_VAR 0 5
8721: PUSH
8722: DOUBLE
8723: LD_INT 1
8725: DEC
8726: ST_TO_ADDR
8727: LD_EXP 41
8731: PUSH
8732: FOR_TO
8733: IFFALSE 8926
// begin if MREG_LabList [ i ] [ 1 ] = side then
8735: LD_EXP 41
8739: PUSH
8740: LD_VAR 0 5
8744: ARRAY
8745: PUSH
8746: LD_INT 1
8748: ARRAY
8749: PUSH
8750: LD_VAR 0 1
8754: EQUAL
8755: IFFALSE 8924
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8757: LD_ADDR_VAR 0 7
8761: PUSH
8762: LD_EXP 41
8766: PUSH
8767: LD_VAR 0 5
8771: ARRAY
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8777: LD_ADDR_VAR 0 9
8781: PUSH
8782: LD_INT 22
8784: PUSH
8785: LD_VAR 0 1
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: PUSH
8794: LD_INT 2
8796: PUSH
8797: LD_INT 30
8799: PUSH
8800: LD_INT 0
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 30
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: LIST
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PUSH
8826: EMPTY
8827: LIST
8828: PPUSH
8829: CALL_OW 69
8833: PPUSH
8834: LD_VAR 0 7
8838: PPUSH
8839: CALL_OW 250
8843: PPUSH
8844: LD_VAR 0 7
8848: PPUSH
8849: CALL_OW 251
8853: PPUSH
8854: CALL_OW 73
8858: ST_TO_ADDR
// if dep then
8859: LD_VAR 0 9
8863: IFFALSE 8922
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8865: LD_VAR 0 9
8869: PPUSH
8870: LD_VAR 0 2
8874: PPUSH
8875: LD_VAR 0 3
8879: PPUSH
8880: CALL 10395 0 3
8884: IFFALSE 8922
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8886: LD_VAR 0 7
8890: PPUSH
8891: LD_VAR 0 2
8895: PPUSH
8896: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8900: LD_VAR 0 7
8904: PPUSH
8905: LD_VAR 0 3
8909: PPUSH
8910: CALL_OW 207
// result := true ;
8914: LD_ADDR_VAR 0 4
8918: PUSH
8919: LD_INT 1
8921: ST_TO_ADDR
// end ; end ; break ;
8922: GO 8926
// end ; end ;
8924: GO 8732
8926: POP
8927: POP
// end ;
8928: LD_VAR 0 4
8932: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8933: LD_INT 0
8935: PPUSH
8936: PPUSH
8937: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8938: LD_ADDR_VAR 0 7
8942: PUSH
8943: LD_VAR 0 2
8947: PPUSH
8948: LD_VAR 0 3
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: CALL 9120 0 3
8962: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8963: LD_ADDR_EXP 47
8967: PUSH
8968: LD_EXP 47
8972: PPUSH
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 2
8980: PPUSH
8981: LD_VAR 0 2
8985: PUSH
8986: LD_VAR 0 3
8990: PUSH
8991: LD_VAR 0 4
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: PPUSH
9001: CALL 42241 0 4
9005: ST_TO_ADDR
// if ext_list then
9006: LD_VAR 0 5
9010: IFFALSE 9115
// for i = 1 to ext_list do
9012: LD_ADDR_VAR 0 8
9016: PUSH
9017: DOUBLE
9018: LD_INT 1
9020: DEC
9021: ST_TO_ADDR
9022: LD_VAR 0 5
9026: PUSH
9027: FOR_TO
9028: IFFALSE 9113
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9030: LD_ADDR_EXP 47
9034: PUSH
9035: LD_EXP 47
9039: PPUSH
9040: LD_VAR 0 1
9044: PPUSH
9045: LD_VAR 0 5
9049: PUSH
9050: LD_VAR 0 8
9054: ARRAY
9055: PPUSH
9056: LD_VAR 0 7
9060: PUSH
9061: LD_VAR 0 8
9065: ARRAY
9066: PUSH
9067: LD_INT 1
9069: ARRAY
9070: PUSH
9071: LD_VAR 0 7
9075: PUSH
9076: LD_VAR 0 8
9080: ARRAY
9081: PUSH
9082: LD_INT 2
9084: ARRAY
9085: PUSH
9086: LD_VAR 0 7
9090: PUSH
9091: LD_VAR 0 8
9095: ARRAY
9096: PUSH
9097: LD_INT 3
9099: ARRAY
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL 42241 0 4
9110: ST_TO_ADDR
9111: GO 9027
9113: POP
9114: POP
// end ;
9115: LD_VAR 0 6
9119: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9120: LD_INT 0
9122: PPUSH
9123: PPUSH
// list := [ ] ;
9124: LD_ADDR_VAR 0 5
9128: PUSH
9129: EMPTY
9130: ST_TO_ADDR
// case d of 0 :
9131: LD_VAR 0 3
9135: PUSH
9136: LD_INT 0
9138: DOUBLE
9139: EQUAL
9140: IFTRUE 9144
9142: GO 9277
9144: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9145: LD_ADDR_VAR 0 5
9149: PUSH
9150: LD_VAR 0 1
9154: PUSH
9155: LD_INT 4
9157: MINUS
9158: PUSH
9159: LD_VAR 0 2
9163: PUSH
9164: LD_INT 4
9166: MINUS
9167: PUSH
9168: LD_INT 2
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: LIST
9175: PUSH
9176: LD_VAR 0 1
9180: PUSH
9181: LD_INT 3
9183: MINUS
9184: PUSH
9185: LD_VAR 0 2
9189: PUSH
9190: LD_INT 1
9192: PUSH
9193: EMPTY
9194: LIST
9195: LIST
9196: LIST
9197: PUSH
9198: LD_VAR 0 1
9202: PUSH
9203: LD_INT 4
9205: PLUS
9206: PUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 4
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PUSH
9220: LD_VAR 0 1
9224: PUSH
9225: LD_INT 3
9227: PLUS
9228: PUSH
9229: LD_VAR 0 2
9233: PUSH
9234: LD_INT 3
9236: PLUS
9237: PUSH
9238: LD_INT 5
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: LIST
9245: PUSH
9246: LD_VAR 0 1
9250: PUSH
9251: LD_VAR 0 2
9255: PUSH
9256: LD_INT 4
9258: PLUS
9259: PUSH
9260: LD_INT 0
9262: PUSH
9263: EMPTY
9264: LIST
9265: LIST
9266: LIST
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: LIST
9274: ST_TO_ADDR
// end ; 1 :
9275: GO 9975
9277: LD_INT 1
9279: DOUBLE
9280: EQUAL
9281: IFTRUE 9285
9283: GO 9418
9285: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9286: LD_ADDR_VAR 0 5
9290: PUSH
9291: LD_VAR 0 1
9295: PUSH
9296: LD_VAR 0 2
9300: PUSH
9301: LD_INT 4
9303: MINUS
9304: PUSH
9305: LD_INT 3
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_VAR 0 1
9317: PUSH
9318: LD_INT 3
9320: MINUS
9321: PUSH
9322: LD_VAR 0 2
9326: PUSH
9327: LD_INT 3
9329: MINUS
9330: PUSH
9331: LD_INT 2
9333: PUSH
9334: EMPTY
9335: LIST
9336: LIST
9337: LIST
9338: PUSH
9339: LD_VAR 0 1
9343: PUSH
9344: LD_INT 4
9346: MINUS
9347: PUSH
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: LIST
9360: PUSH
9361: LD_VAR 0 1
9365: PUSH
9366: LD_VAR 0 2
9370: PUSH
9371: LD_INT 3
9373: PLUS
9374: PUSH
9375: LD_INT 0
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: LIST
9382: PUSH
9383: LD_VAR 0 1
9387: PUSH
9388: LD_INT 4
9390: PLUS
9391: PUSH
9392: LD_VAR 0 2
9396: PUSH
9397: LD_INT 4
9399: PLUS
9400: PUSH
9401: LD_INT 5
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// end ; 2 :
9416: GO 9975
9418: LD_INT 2
9420: DOUBLE
9421: EQUAL
9422: IFTRUE 9426
9424: GO 9555
9426: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9427: LD_ADDR_VAR 0 5
9431: PUSH
9432: LD_VAR 0 1
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 3
9444: MINUS
9445: PUSH
9446: LD_INT 3
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: LIST
9453: PUSH
9454: LD_VAR 0 1
9458: PUSH
9459: LD_INT 4
9461: PLUS
9462: PUSH
9463: LD_VAR 0 2
9467: PUSH
9468: LD_INT 4
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: LD_VAR 0 1
9502: PUSH
9503: LD_INT 3
9505: MINUS
9506: PUSH
9507: LD_VAR 0 2
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: LIST
9519: PUSH
9520: LD_VAR 0 1
9524: PUSH
9525: LD_INT 4
9527: MINUS
9528: PUSH
9529: LD_VAR 0 2
9533: PUSH
9534: LD_INT 4
9536: MINUS
9537: PUSH
9538: LD_INT 2
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: ST_TO_ADDR
// end ; 3 :
9553: GO 9975
9555: LD_INT 3
9557: DOUBLE
9558: EQUAL
9559: IFTRUE 9563
9561: GO 9696
9563: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 3
9576: PLUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 4
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_INT 4
9598: PLUS
9599: PUSH
9600: LD_VAR 0 2
9604: PUSH
9605: LD_INT 4
9607: PLUS
9608: PUSH
9609: LD_INT 5
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: PUSH
9617: LD_VAR 0 1
9621: PUSH
9622: LD_INT 4
9624: MINUS
9625: PUSH
9626: LD_VAR 0 2
9630: PUSH
9631: LD_INT 1
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: LD_VAR 0 1
9643: PUSH
9644: LD_VAR 0 2
9648: PUSH
9649: LD_INT 4
9651: MINUS
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: LIST
9660: PUSH
9661: LD_VAR 0 1
9665: PUSH
9666: LD_INT 3
9668: MINUS
9669: PUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_INT 3
9677: MINUS
9678: PUSH
9679: LD_INT 2
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: ST_TO_ADDR
// end ; 4 :
9694: GO 9975
9696: LD_INT 4
9698: DOUBLE
9699: EQUAL
9700: IFTRUE 9704
9702: GO 9837
9704: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9705: LD_ADDR_VAR 0 5
9709: PUSH
9710: LD_VAR 0 1
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: LD_INT 4
9722: PLUS
9723: PUSH
9724: LD_INT 0
9726: PUSH
9727: EMPTY
9728: LIST
9729: LIST
9730: LIST
9731: PUSH
9732: LD_VAR 0 1
9736: PUSH
9737: LD_INT 3
9739: PLUS
9740: PUSH
9741: LD_VAR 0 2
9745: PUSH
9746: LD_INT 3
9748: PLUS
9749: PUSH
9750: LD_INT 5
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: LIST
9757: PUSH
9758: LD_VAR 0 1
9762: PUSH
9763: LD_INT 3
9765: PLUS
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: LD_INT 4
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: LIST
9779: PUSH
9780: LD_VAR 0 1
9784: PUSH
9785: LD_VAR 0 2
9789: PUSH
9790: LD_INT 3
9792: MINUS
9793: PUSH
9794: LD_INT 3
9796: PUSH
9797: EMPTY
9798: LIST
9799: LIST
9800: LIST
9801: PUSH
9802: LD_VAR 0 1
9806: PUSH
9807: LD_INT 4
9809: MINUS
9810: PUSH
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 4
9818: MINUS
9819: PUSH
9820: LD_INT 2
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: LIST
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: ST_TO_ADDR
// end ; 5 :
9835: GO 9975
9837: LD_INT 5
9839: DOUBLE
9840: EQUAL
9841: IFTRUE 9845
9843: GO 9974
9845: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9846: LD_ADDR_VAR 0 5
9850: PUSH
9851: LD_VAR 0 1
9855: PUSH
9856: LD_INT 4
9858: MINUS
9859: PUSH
9860: LD_VAR 0 2
9864: PUSH
9865: LD_INT 1
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: LIST
9872: PUSH
9873: LD_VAR 0 1
9877: PUSH
9878: LD_VAR 0 2
9882: PUSH
9883: LD_INT 4
9885: MINUS
9886: PUSH
9887: LD_INT 3
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: LIST
9894: PUSH
9895: LD_VAR 0 1
9899: PUSH
9900: LD_INT 4
9902: PLUS
9903: PUSH
9904: LD_VAR 0 2
9908: PUSH
9909: LD_INT 4
9911: PLUS
9912: PUSH
9913: LD_INT 5
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: LIST
9920: PUSH
9921: LD_VAR 0 1
9925: PUSH
9926: LD_INT 3
9928: PLUS
9929: PUSH
9930: LD_VAR 0 2
9934: PUSH
9935: LD_INT 4
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: LIST
9942: PUSH
9943: LD_VAR 0 1
9947: PUSH
9948: LD_VAR 0 2
9952: PUSH
9953: LD_INT 3
9955: PLUS
9956: PUSH
9957: LD_INT 0
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: ST_TO_ADDR
// end ; end ;
9972: GO 9975
9974: POP
// result := list ;
9975: LD_ADDR_VAR 0 4
9979: PUSH
9980: LD_VAR 0 5
9984: ST_TO_ADDR
// end ;
9985: LD_VAR 0 4
9989: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9990: LD_INT 0
9992: PPUSH
9993: PPUSH
9994: PPUSH
9995: PPUSH
9996: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9997: LD_ADDR_VAR 0 10
10001: PUSH
10002: LD_VAR 0 1
10006: PPUSH
10007: LD_INT 2
10009: PPUSH
10010: EMPTY
10011: PPUSH
10012: CALL 11504 0 3
10016: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10017: LD_ADDR_VAR 0 9
10021: PUSH
10022: LD_INT 22
10024: PUSH
10025: LD_VAR 0 1
10029: PUSH
10030: EMPTY
10031: LIST
10032: LIST
10033: PUSH
10034: LD_INT 2
10036: PUSH
10037: LD_INT 30
10039: PUSH
10040: LD_INT 0
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 30
10049: PUSH
10050: LD_INT 1
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: LIST
10061: PUSH
10062: EMPTY
10063: LIST
10064: LIST
10065: PUSH
10066: EMPTY
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: PPUSH
10074: LD_VAR 0 3
10078: PPUSH
10079: LD_VAR 0 4
10083: PPUSH
10084: CALL_OW 73
10088: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10089: LD_ADDR_VAR 0 8
10093: PUSH
10094: LD_VAR 0 9
10098: PPUSH
10099: LD_VAR 0 2
10103: PPUSH
10104: CALL 10279 0 2
10108: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10109: LD_VAR 0 10
10113: PUSH
10114: LD_VAR 0 8
10118: AND
10119: PUSH
10120: LD_VAR 0 9
10124: PPUSH
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_VAR 0 4
10134: PPUSH
10135: CALL_OW 297
10139: PUSH
10140: LD_INT 26
10142: LESSEQUAL
10143: AND
10144: PUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: LD_VAR 0 4
10154: PPUSH
10155: CALL_OW 428
10159: PUSH
10160: LD_INT 0
10162: EQUAL
10163: AND
10164: IFFALSE 10274
// for i = 1 to plist do
10166: LD_ADDR_VAR 0 7
10170: PUSH
10171: DOUBLE
10172: LD_INT 1
10174: DEC
10175: ST_TO_ADDR
10176: LD_VAR 0 10
10180: PUSH
10181: FOR_TO
10182: IFFALSE 10272
// if IsInUnit ( plist [ i ] ) then
10184: LD_VAR 0 10
10188: PUSH
10189: LD_VAR 0 7
10193: ARRAY
10194: PPUSH
10195: CALL_OW 310
10199: IFFALSE 10218
// ComExitBuilding ( plist [ i ] ) else
10201: LD_VAR 0 10
10205: PUSH
10206: LD_VAR 0 7
10210: ARRAY
10211: PPUSH
10212: CALL_OW 122
10216: GO 10270
// if NotTask ( plist [ i ] ) then
10218: LD_VAR 0 10
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL 32298 0 1
10233: IFFALSE 10270
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10235: LD_VAR 0 10
10239: PUSH
10240: LD_VAR 0 7
10244: ARRAY
10245: PPUSH
10246: LD_VAR 0 2
10250: PPUSH
10251: LD_VAR 0 3
10255: PPUSH
10256: LD_VAR 0 4
10260: PPUSH
10261: LD_VAR 0 5
10265: PPUSH
10266: CALL_OW 145
// end ;
10270: GO 10181
10272: POP
10273: POP
// end ;
10274: LD_VAR 0 6
10278: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10279: LD_INT 0
10281: PPUSH
10282: PPUSH
10283: PPUSH
// pom := GetBase ( bdepot ) ;
10284: LD_ADDR_VAR 0 4
10288: PUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 274
10298: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10299: LD_ADDR_VAR 0 5
10303: PUSH
10304: LD_VAR 0 2
10308: PPUSH
10309: LD_VAR 0 1
10313: PPUSH
10314: CALL_OW 248
10318: PPUSH
10319: CALL_OW 450
10323: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10324: LD_VAR 0 4
10328: PPUSH
10329: LD_INT 1
10331: PPUSH
10332: CALL_OW 275
10336: PUSH
10337: LD_VAR 0 5
10341: PUSH
10342: LD_INT 1
10344: ARRAY
10345: GREATEREQUAL
10346: PUSH
10347: LD_VAR 0 4
10351: PPUSH
10352: LD_INT 3
10354: PPUSH
10355: CALL_OW 275
10359: PUSH
10360: LD_VAR 0 5
10364: PUSH
10365: LD_INT 3
10367: ARRAY
10368: GREATEREQUAL
10369: AND
10370: IFFALSE 10382
// result := true else
10372: LD_ADDR_VAR 0 3
10376: PUSH
10377: LD_INT 1
10379: ST_TO_ADDR
10380: GO 10390
// result := false ;
10382: LD_ADDR_VAR 0 3
10386: PUSH
10387: LD_INT 0
10389: ST_TO_ADDR
// end ;
10390: LD_VAR 0 3
10394: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10395: LD_INT 0
10397: PPUSH
10398: PPUSH
10399: PPUSH
10400: PPUSH
10401: PPUSH
// pom := GetBase ( bdepot ) ;
10402: LD_ADDR_VAR 0 5
10406: PUSH
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 274
10416: ST_TO_ADDR
// cost := [ ] ;
10417: LD_ADDR_VAR 0 8
10421: PUSH
10422: EMPTY
10423: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10424: LD_ADDR_VAR 0 6
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_VAR 0 1
10438: PPUSH
10439: CALL_OW 248
10443: PPUSH
10444: CALL_OW 450
10448: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10449: LD_ADDR_VAR 0 7
10453: PUSH
10454: LD_VAR 0 3
10458: PPUSH
10459: LD_VAR 0 1
10463: PPUSH
10464: CALL_OW 248
10468: PPUSH
10469: CALL_OW 450
10473: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10474: LD_ADDR_VAR 0 8
10478: PUSH
10479: LD_VAR 0 8
10483: PPUSH
10484: LD_INT 1
10486: PPUSH
10487: LD_VAR 0 6
10491: PUSH
10492: LD_INT 1
10494: ARRAY
10495: PUSH
10496: LD_VAR 0 7
10500: PUSH
10501: LD_INT 1
10503: ARRAY
10504: PLUS
10505: PPUSH
10506: CALL_OW 1
10510: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10511: LD_ADDR_VAR 0 8
10515: PUSH
10516: LD_VAR 0 8
10520: PPUSH
10521: LD_INT 2
10523: PPUSH
10524: LD_VAR 0 6
10528: PUSH
10529: LD_INT 2
10531: ARRAY
10532: PUSH
10533: LD_VAR 0 7
10537: PUSH
10538: LD_INT 2
10540: ARRAY
10541: PLUS
10542: PPUSH
10543: CALL_OW 1
10547: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10548: LD_ADDR_VAR 0 8
10552: PUSH
10553: LD_VAR 0 8
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_VAR 0 6
10565: PUSH
10566: LD_INT 3
10568: ARRAY
10569: PUSH
10570: LD_VAR 0 7
10574: PUSH
10575: LD_INT 3
10577: ARRAY
10578: PLUS
10579: PPUSH
10580: CALL_OW 1
10584: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10585: LD_VAR 0 5
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL_OW 275
10597: PUSH
10598: LD_VAR 0 8
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: GREATEREQUAL
10607: PUSH
10608: LD_VAR 0 5
10612: PPUSH
10613: LD_INT 3
10615: PPUSH
10616: CALL_OW 275
10620: PUSH
10621: LD_VAR 0 8
10625: PUSH
10626: LD_INT 3
10628: ARRAY
10629: GREATEREQUAL
10630: AND
10631: IFFALSE 10643
// result := true else
10633: LD_ADDR_VAR 0 4
10637: PUSH
10638: LD_INT 1
10640: ST_TO_ADDR
10641: GO 10651
// result := false ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_INT 0
10650: ST_TO_ADDR
// end ;
10651: LD_VAR 0 4
10655: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10656: LD_INT 0
10658: PPUSH
10659: PPUSH
10660: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10661: LD_ADDR_VAR 0 5
10665: PUSH
10666: LD_VAR 0 1
10670: PPUSH
10671: LD_INT 2
10673: PPUSH
10674: EMPTY
10675: PPUSH
10676: CALL 11504 0 3
10680: ST_TO_ADDR
// if unit and plist then
10681: LD_VAR 0 2
10685: PUSH
10686: LD_VAR 0 5
10690: AND
10691: IFFALSE 10752
// for i = 1 to plist do
10693: LD_ADDR_VAR 0 4
10697: PUSH
10698: DOUBLE
10699: LD_INT 1
10701: DEC
10702: ST_TO_ADDR
10703: LD_VAR 0 5
10707: PUSH
10708: FOR_TO
10709: IFFALSE 10750
// if NotTask ( plist [ i ] ) then
10711: LD_VAR 0 5
10715: PUSH
10716: LD_VAR 0 4
10720: ARRAY
10721: PPUSH
10722: CALL 32298 0 1
10726: IFFALSE 10748
// ComDismantle ( plist [ i ] , unit ) ;
10728: LD_VAR 0 5
10732: PUSH
10733: LD_VAR 0 4
10737: ARRAY
10738: PPUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: CALL_OW 167
10748: GO 10708
10750: POP
10751: POP
// result := true ;
10752: LD_ADDR_VAR 0 3
10756: PUSH
10757: LD_INT 1
10759: ST_TO_ADDR
// end ;
10760: LD_VAR 0 3
10764: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10765: LD_INT 0
10767: PPUSH
10768: PPUSH
10769: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10770: LD_ADDR_VAR 0 5
10774: PUSH
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_INT 2
10782: PPUSH
10783: EMPTY
10784: PPUSH
10785: CALL 11504 0 3
10789: ST_TO_ADDR
// if unit and plist then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_VAR 0 5
10799: AND
10800: IFFALSE 10861
// for i = 1 to plist do
10802: LD_ADDR_VAR 0 4
10806: PUSH
10807: DOUBLE
10808: LD_INT 1
10810: DEC
10811: ST_TO_ADDR
10812: LD_VAR 0 5
10816: PUSH
10817: FOR_TO
10818: IFFALSE 10859
// if NotTask ( plist [ i ] ) then
10820: LD_VAR 0 5
10824: PUSH
10825: LD_VAR 0 4
10829: ARRAY
10830: PPUSH
10831: CALL 32298 0 1
10835: IFFALSE 10857
// ComComplete ( plist [ i ] , unit ) ;
10837: LD_VAR 0 5
10841: PUSH
10842: LD_VAR 0 4
10846: ARRAY
10847: PPUSH
10848: LD_VAR 0 2
10852: PPUSH
10853: CALL 31834 0 2
10857: GO 10817
10859: POP
10860: POP
// result := true ;
10861: LD_ADDR_VAR 0 3
10865: PUSH
10866: LD_INT 1
10868: ST_TO_ADDR
// end ;
10869: LD_VAR 0 3
10873: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10874: LD_INT 0
10876: PPUSH
10877: PPUSH
10878: PPUSH
10879: PPUSH
10880: PPUSH
10881: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10882: LD_ADDR_VAR 0 5
10886: PUSH
10887: LD_INT 22
10889: PUSH
10890: LD_VAR 0 1
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PUSH
10899: LD_INT 21
10901: PUSH
10902: LD_INT 3
10904: PUSH
10905: EMPTY
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 3
10911: PUSH
10912: LD_INT 57
10914: PUSH
10915: EMPTY
10916: LIST
10917: PUSH
10918: EMPTY
10919: LIST
10920: LIST
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 24
10927: PUSH
10928: LD_INT 1000
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: PPUSH
10945: CALL_OW 69
10949: ST_TO_ADDR
// r := [ ] ;
10950: LD_ADDR_VAR 0 6
10954: PUSH
10955: EMPTY
10956: ST_TO_ADDR
// if not tmp then
10957: LD_VAR 0 5
10961: NOT
10962: IFFALSE 10968
// exit else
10964: GO 11156
10966: GO 11136
// begin r := [ tmp [ 1 ] ] ;
10968: LD_ADDR_VAR 0 6
10972: PUSH
10973: LD_VAR 0 5
10977: PUSH
10978: LD_INT 1
10980: ARRAY
10981: PUSH
10982: EMPTY
10983: LIST
10984: ST_TO_ADDR
// for i = 2 to tmp do
10985: LD_ADDR_VAR 0 3
10989: PUSH
10990: DOUBLE
10991: LD_INT 2
10993: DEC
10994: ST_TO_ADDR
10995: LD_VAR 0 5
10999: PUSH
11000: FOR_TO
11001: IFFALSE 11134
// begin m := false ;
11003: LD_ADDR_VAR 0 7
11007: PUSH
11008: LD_INT 0
11010: ST_TO_ADDR
// for j = 1 to r do
11011: LD_ADDR_VAR 0 4
11015: PUSH
11016: DOUBLE
11017: LD_INT 1
11019: DEC
11020: ST_TO_ADDR
11021: LD_VAR 0 6
11025: PUSH
11026: FOR_TO
11027: IFFALSE 11101
// if GetLives ( tmp [ i ] ) < r [ j ] then
11029: LD_VAR 0 5
11033: PUSH
11034: LD_VAR 0 3
11038: ARRAY
11039: PPUSH
11040: CALL_OW 256
11044: PUSH
11045: LD_VAR 0 6
11049: PUSH
11050: LD_VAR 0 4
11054: ARRAY
11055: LESS
11056: IFFALSE 11099
// begin r := Insert ( r , j , tmp [ i ] ) ;
11058: LD_ADDR_VAR 0 6
11062: PUSH
11063: LD_VAR 0 6
11067: PPUSH
11068: LD_VAR 0 4
11072: PPUSH
11073: LD_VAR 0 5
11077: PUSH
11078: LD_VAR 0 3
11082: ARRAY
11083: PPUSH
11084: CALL_OW 2
11088: ST_TO_ADDR
// m := true ;
11089: LD_ADDR_VAR 0 7
11093: PUSH
11094: LD_INT 1
11096: ST_TO_ADDR
// break ;
11097: GO 11101
// end ;
11099: GO 11026
11101: POP
11102: POP
// if not m then
11103: LD_VAR 0 7
11107: NOT
11108: IFFALSE 11132
// r := r ^ tmp [ i ] ;
11110: LD_ADDR_VAR 0 6
11114: PUSH
11115: LD_VAR 0 6
11119: PUSH
11120: LD_VAR 0 5
11124: PUSH
11125: LD_VAR 0 3
11129: ARRAY
11130: ADD
11131: ST_TO_ADDR
// end ;
11132: GO 11000
11134: POP
11135: POP
// end ; if r then
11136: LD_VAR 0 6
11140: IFFALSE 11154
// result := r else
11142: LD_ADDR_VAR 0 2
11146: PUSH
11147: LD_VAR 0 6
11151: ST_TO_ADDR
11152: GO 11156
// exit ;
11154: GO 11156
// end ;
11156: LD_VAR 0 2
11160: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11161: LD_INT 0
11163: PPUSH
11164: PPUSH
11165: PPUSH
11166: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11167: LD_ADDR_VAR 0 5
11171: PUSH
11172: LD_INT 22
11174: PUSH
11175: LD_VAR 0 1
11179: PUSH
11180: EMPTY
11181: LIST
11182: LIST
11183: PUSH
11184: LD_INT 2
11186: PUSH
11187: LD_INT 25
11189: PUSH
11190: LD_INT 2
11192: PUSH
11193: EMPTY
11194: LIST
11195: LIST
11196: PUSH
11197: LD_INT 25
11199: PUSH
11200: LD_INT 16
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: PUSH
11207: LD_INT 34
11209: PUSH
11210: LD_INT 13
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: PUSH
11217: LD_INT 34
11219: PUSH
11220: LD_INT 52
11222: PUSH
11223: EMPTY
11224: LIST
11225: LIST
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 24
11236: PUSH
11237: LD_INT 650
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: LIST
11248: PPUSH
11249: CALL_OW 69
11253: ST_TO_ADDR
// p := 1 ;
11254: LD_ADDR_VAR 0 4
11258: PUSH
11259: LD_INT 1
11261: ST_TO_ADDR
// for i = 1 to repairs do
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: DOUBLE
11268: LD_INT 1
11270: DEC
11271: ST_TO_ADDR
11272: LD_VAR 0 5
11276: PUSH
11277: FOR_TO
11278: IFFALSE 11414
// begin if IsInUnit ( repairs [ i ] ) then
11280: LD_VAR 0 5
11284: PUSH
11285: LD_VAR 0 3
11289: ARRAY
11290: PPUSH
11291: CALL_OW 310
11295: IFFALSE 11314
// ComExitBuilding ( repairs [ i ] ) else
11297: LD_VAR 0 5
11301: PUSH
11302: LD_VAR 0 3
11306: ARRAY
11307: PPUSH
11308: CALL_OW 122
11312: GO 11412
// if not HasTask ( repairs [ i ] ) then
11314: LD_VAR 0 5
11318: PUSH
11319: LD_VAR 0 3
11323: ARRAY
11324: PPUSH
11325: CALL_OW 314
11329: NOT
11330: IFFALSE 11412
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11332: LD_VAR 0 5
11336: PUSH
11337: LD_VAR 0 3
11341: ARRAY
11342: PPUSH
11343: LD_EXP 48
11347: PUSH
11348: LD_VAR 0 1
11352: ARRAY
11353: PUSH
11354: LD_VAR 0 4
11358: ARRAY
11359: PPUSH
11360: CALL_OW 130
// if i mod 3 = 0 then
11364: LD_VAR 0 3
11368: PUSH
11369: LD_INT 3
11371: MOD
11372: PUSH
11373: LD_INT 0
11375: EQUAL
11376: IFFALSE 11392
// p := p + 1 ;
11378: LD_ADDR_VAR 0 4
11382: PUSH
11383: LD_VAR 0 4
11387: PUSH
11388: LD_INT 1
11390: PLUS
11391: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11392: LD_EXP 48
11396: PUSH
11397: LD_VAR 0 1
11401: ARRAY
11402: PUSH
11403: LD_VAR 0 4
11407: LESS
11408: IFFALSE 11412
// break ;
11410: GO 11414
// end ; end ;
11412: GO 11277
11414: POP
11415: POP
// end ; end_of_file
11416: LD_VAR 0 2
11420: RET
// export function MCF_Get ( side , filter ) ; begin
11421: LD_INT 0
11423: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11424: LD_ADDR_VAR 0 3
11428: PUSH
11429: LD_INT 22
11431: PUSH
11432: LD_VAR 0 1
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: PUSH
11441: LD_VAR 0 2
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: ST_TO_ADDR
// end ;
11455: LD_VAR 0 3
11459: RET
// export function MCF_Lab ( side ) ; begin
11460: LD_INT 0
11462: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11463: LD_ADDR_VAR 0 2
11467: PUSH
11468: LD_INT 22
11470: PUSH
11471: LD_VAR 0 1
11475: PUSH
11476: EMPTY
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 30
11482: PUSH
11483: LD_INT 8
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 69
11498: ST_TO_ADDR
// end ;
11499: LD_VAR 0 2
11503: RET
// export function MCF_Class ( side , class , filter ) ; begin
11504: LD_INT 0
11506: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11507: LD_ADDR_VAR 0 4
11511: PUSH
11512: LD_INT 22
11514: PUSH
11515: LD_VAR 0 1
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: LD_INT 25
11526: PUSH
11527: LD_VAR 0 2
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: LD_VAR 0 3
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: LIST
11545: PPUSH
11546: CALL_OW 69
11550: ST_TO_ADDR
// end ;
11551: LD_VAR 0 4
11555: RET
// export function MCF_All ( side , filter ) ; begin
11556: LD_INT 0
11558: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11559: LD_ADDR_VAR 0 3
11563: PUSH
11564: LD_INT 22
11566: PUSH
11567: LD_VAR 0 1
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: LD_INT 2
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PUSH
11589: LD_INT 25
11591: PUSH
11592: LD_INT 2
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: LD_INT 25
11601: PUSH
11602: LD_INT 3
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 25
11611: PUSH
11612: LD_INT 4
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: PUSH
11626: LD_VAR 0 2
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 69
11640: ST_TO_ADDR
// end ;
11641: LD_VAR 0 3
11645: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11646: LD_INT 0
11648: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11649: LD_ADDR_VAR 0 4
11653: PUSH
11654: LD_INT 22
11656: PUSH
11657: LD_VAR 0 1
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: PUSH
11666: LD_INT 92
11668: PUSH
11669: LD_VAR 0 2
11673: PUSH
11674: LD_INT 1
11676: ARRAY
11677: PUSH
11678: LD_VAR 0 2
11682: PUSH
11683: LD_INT 2
11685: ARRAY
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: LD_INT 3
11694: ARRAY
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 21
11744: PUSH
11745: LD_INT 2
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: LD_VAR 0 2
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: LIST
11761: PPUSH
11762: CALL_OW 69
11766: ST_TO_ADDR
// end ;
11767: LD_VAR 0 3
11771: RET
// export function MCF_Cargo ( side ) ; begin
11772: LD_INT 0
11774: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11775: LD_ADDR_VAR 0 2
11779: PUSH
11780: LD_VAR 0 1
11784: PPUSH
11785: LD_INT 2
11787: PUSH
11788: LD_INT 34
11790: PUSH
11791: LD_INT 12
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 34
11800: PUSH
11801: LD_INT 32
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: LD_INT 34
11810: PUSH
11811: LD_INT 51
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: PPUSH
11824: CALL 11722 0 2
11828: ST_TO_ADDR
// end ;
11829: LD_VAR 0 2
11833: RET
// export function MCF_Ape ( side ) ; begin
11834: LD_INT 0
11836: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11837: LD_ADDR_VAR 0 2
11841: PUSH
11842: LD_INT 22
11844: PUSH
11845: LD_VAR 0 1
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: LD_INT 25
11859: PUSH
11860: LD_INT 12
11862: PUSH
11863: EMPTY
11864: LIST
11865: LIST
11866: PUSH
11867: LD_INT 25
11869: PUSH
11870: LD_INT 15
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 25
11879: PUSH
11880: LD_INT 16
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 25
11889: PUSH
11890: LD_INT 17
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: EMPTY
11898: LIST
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PPUSH
11908: CALL_OW 69
11912: ST_TO_ADDR
// end ;
11913: LD_VAR 0 2
11917: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11918: LD_INT 0
11920: PPUSH
11921: PPUSH
11922: PPUSH
11923: PPUSH
// result := [ ] ;
11924: LD_ADDR_VAR 0 3
11928: PUSH
11929: EMPTY
11930: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11931: LD_ADDR_VAR 0 4
11935: PUSH
11936: LD_VAR 0 1
11940: PPUSH
11941: CALL 11834 0 1
11945: ST_TO_ADDR
// case type of 0 , normal :
11946: LD_VAR 0 2
11950: PUSH
11951: LD_INT 0
11953: DOUBLE
11954: EQUAL
11955: IFTRUE 11965
11957: LD_STRING normal
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// cl := class_apeman ; 1 , soldier :
11966: LD_ADDR_VAR 0 5
11970: PUSH
11971: LD_INT 12
11973: ST_TO_ADDR
11974: GO 12052
11976: LD_INT 1
11978: DOUBLE
11979: EQUAL
11980: IFTRUE 11990
11982: LD_STRING soldier
11984: DOUBLE
11985: EQUAL
11986: IFTRUE 11990
11988: GO 12001
11990: POP
// cl := class_apeman_soldier ; 2 , engineer :
11991: LD_ADDR_VAR 0 5
11995: PUSH
11996: LD_INT 15
11998: ST_TO_ADDR
11999: GO 12052
12001: LD_INT 2
12003: DOUBLE
12004: EQUAL
12005: IFTRUE 12015
12007: LD_STRING engineer
12009: DOUBLE
12010: EQUAL
12011: IFTRUE 12015
12013: GO 12026
12015: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12016: LD_ADDR_VAR 0 5
12020: PUSH
12021: LD_INT 16
12023: ST_TO_ADDR
12024: GO 12052
12026: LD_INT 3
12028: DOUBLE
12029: EQUAL
12030: IFTRUE 12040
12032: LD_STRING kamikaze
12034: DOUBLE
12035: EQUAL
12036: IFTRUE 12040
12038: GO 12051
12040: POP
// cl := class_apeman_kamikaze ; end ;
12041: LD_ADDR_VAR 0 5
12045: PUSH
12046: LD_INT 17
12048: ST_TO_ADDR
12049: GO 12052
12051: POP
// for i = 1 to tmp do
12052: LD_ADDR_VAR 0 6
12056: PUSH
12057: DOUBLE
12058: LD_INT 1
12060: DEC
12061: ST_TO_ADDR
12062: LD_VAR 0 4
12066: PUSH
12067: FOR_TO
12068: IFFALSE 12117
// if GetClass ( tmp [ i ] ) = cl then
12070: LD_VAR 0 4
12074: PUSH
12075: LD_VAR 0 6
12079: ARRAY
12080: PPUSH
12081: CALL_OW 257
12085: PUSH
12086: LD_VAR 0 5
12090: EQUAL
12091: IFFALSE 12115
// result := result ^ tmp [ i ] ;
12093: LD_ADDR_VAR 0 3
12097: PUSH
12098: LD_VAR 0 3
12102: PUSH
12103: LD_VAR 0 4
12107: PUSH
12108: LD_VAR 0 6
12112: ARRAY
12113: ADD
12114: ST_TO_ADDR
12115: GO 12067
12117: POP
12118: POP
// end ;
12119: LD_VAR 0 3
12123: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12124: LD_INT 0
12126: PPUSH
12127: PPUSH
12128: PPUSH
12129: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12130: LD_ADDR_VAR 0 5
12134: PUSH
12135: LD_INT 22
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_VAR 0 3
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: PPUSH
12156: CALL_OW 69
12160: ST_TO_ADDR
// r := [ ] ;
12161: LD_ADDR_VAR 0 6
12165: PUSH
12166: EMPTY
12167: ST_TO_ADDR
// if tmp then
12168: LD_VAR 0 5
12172: IFFALSE 12241
// for i = 1 to tmp do
12174: LD_ADDR_VAR 0 7
12178: PUSH
12179: DOUBLE
12180: LD_INT 1
12182: DEC
12183: ST_TO_ADDR
12184: LD_VAR 0 5
12188: PUSH
12189: FOR_TO
12190: IFFALSE 12239
// if GetTag ( tmp [ i ] ) = tag then
12192: LD_VAR 0 5
12196: PUSH
12197: LD_VAR 0 7
12201: ARRAY
12202: PPUSH
12203: CALL_OW 110
12207: PUSH
12208: LD_VAR 0 2
12212: EQUAL
12213: IFFALSE 12237
// r := r ^ tmp [ i ] ;
12215: LD_ADDR_VAR 0 6
12219: PUSH
12220: LD_VAR 0 6
12224: PUSH
12225: LD_VAR 0 5
12229: PUSH
12230: LD_VAR 0 7
12234: ARRAY
12235: ADD
12236: ST_TO_ADDR
12237: GO 12189
12239: POP
12240: POP
// result := r ;
12241: LD_ADDR_VAR 0 4
12245: PUSH
12246: LD_VAR 0 6
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 4
12255: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
// tmp := plist ;
12261: LD_ADDR_VAR 0 5
12265: PUSH
12266: LD_VAR 0 2
12270: ST_TO_ADDR
// if tmp then
12271: LD_VAR 0 5
12275: IFFALSE 12352
// begin for i = 1 to tmp do
12277: LD_ADDR_VAR 0 6
12281: PUSH
12282: DOUBLE
12283: LD_INT 1
12285: DEC
12286: ST_TO_ADDR
12287: LD_VAR 0 5
12291: PUSH
12292: FOR_TO
12293: IFFALSE 12340
// if GetTag ( tmp [ i ] ) <> tag then
12295: LD_VAR 0 5
12299: PUSH
12300: LD_VAR 0 6
12304: ARRAY
12305: PPUSH
12306: CALL_OW 110
12310: PUSH
12311: LD_VAR 0 3
12315: NONEQUAL
12316: IFFALSE 12338
// SetTag ( tmp [ i ] , tag ) ;
12318: LD_VAR 0 5
12322: PUSH
12323: LD_VAR 0 6
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 3
12333: PPUSH
12334: CALL_OW 109
12338: GO 12292
12340: POP
12341: POP
// result := true ;
12342: LD_ADDR_VAR 0 4
12346: PUSH
12347: LD_INT 1
12349: ST_TO_ADDR
// end else
12350: GO 12360
// result := false ;
12352: LD_ADDR_VAR 0 4
12356: PUSH
12357: LD_INT 0
12359: ST_TO_ADDR
// end ;
12360: LD_VAR 0 4
12364: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12365: LD_INT 0
12367: PPUSH
12368: PPUSH
12369: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12370: LD_ADDR_VAR 0 4
12374: PUSH
12375: LD_VAR 0 1
12379: PPUSH
12380: LD_VAR 0 2
12384: PPUSH
12385: EMPTY
12386: PPUSH
12387: CALL 12124 0 3
12391: ST_TO_ADDR
// if tmp then
12392: LD_VAR 0 4
12396: IFFALSE 12448
// begin for i = 1 to tmp do
12398: LD_ADDR_VAR 0 5
12402: PUSH
12403: DOUBLE
12404: LD_INT 1
12406: DEC
12407: ST_TO_ADDR
12408: LD_VAR 0 4
12412: PUSH
12413: FOR_TO
12414: IFFALSE 12436
// SetTag ( tmp [ i ] , 0 ) ;
12416: LD_VAR 0 4
12420: PUSH
12421: LD_VAR 0 5
12425: ARRAY
12426: PPUSH
12427: LD_INT 0
12429: PPUSH
12430: CALL_OW 109
12434: GO 12413
12436: POP
12437: POP
// result := true ;
12438: LD_ADDR_VAR 0 3
12442: PUSH
12443: LD_INT 1
12445: ST_TO_ADDR
// end else
12446: GO 12456
// result := false ;
12448: LD_ADDR_VAR 0 3
12452: PUSH
12453: LD_INT 0
12455: ST_TO_ADDR
// end ;
12456: LD_VAR 0 3
12460: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12461: LD_INT 0
12463: PPUSH
12464: PPUSH
12465: PPUSH
12466: PPUSH
12467: PPUSH
// sort_list := [ ] ;
12468: LD_ADDR_VAR 0 5
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to list do
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_VAR 0 1
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12653
// begin if i = 1 then
12493: LD_VAR 0 3
12497: PUSH
12498: LD_INT 1
12500: EQUAL
12501: IFFALSE 12527
// sort_list := sort_list ^ list [ i ] else
12503: LD_ADDR_VAR 0 5
12507: PUSH
12508: LD_VAR 0 5
12512: PUSH
12513: LD_VAR 0 1
12517: PUSH
12518: LD_VAR 0 3
12522: ARRAY
12523: ADD
12524: ST_TO_ADDR
12525: GO 12651
// begin for j = 1 to sort_list do
12527: LD_ADDR_VAR 0 4
12531: PUSH
12532: DOUBLE
12533: LD_INT 1
12535: DEC
12536: ST_TO_ADDR
12537: LD_VAR 0 5
12541: PUSH
12542: FOR_TO
12543: IFFALSE 12620
// begin add := false ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_INT 0
12552: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12553: LD_VAR 0 1
12557: PUSH
12558: LD_VAR 0 3
12562: ARRAY
12563: PUSH
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 4
12573: ARRAY
12574: LESS
12575: IFFALSE 12618
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12577: LD_ADDR_VAR 0 5
12581: PUSH
12582: LD_VAR 0 5
12586: PPUSH
12587: LD_VAR 0 4
12591: PPUSH
12592: LD_VAR 0 1
12596: PUSH
12597: LD_VAR 0 3
12601: ARRAY
12602: PPUSH
12603: CALL_OW 2
12607: ST_TO_ADDR
// add := true ;
12608: LD_ADDR_VAR 0 6
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// break ;
12616: GO 12620
// end ; end ;
12618: GO 12542
12620: POP
12621: POP
// if not add then
12622: LD_VAR 0 6
12626: NOT
12627: IFFALSE 12651
// sort_list := sort_list ^ list [ i ] ;
12629: LD_ADDR_VAR 0 5
12633: PUSH
12634: LD_VAR 0 5
12638: PUSH
12639: LD_VAR 0 1
12643: PUSH
12644: LD_VAR 0 3
12648: ARRAY
12649: ADD
12650: ST_TO_ADDR
// end ; end ;
12651: GO 12490
12653: POP
12654: POP
// result := sort_list ;
12655: LD_ADDR_VAR 0 2
12659: PUSH
12660: LD_VAR 0 5
12664: ST_TO_ADDR
// end ;
12665: LD_VAR 0 2
12669: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12670: LD_INT 0
12672: PPUSH
12673: PPUSH
12674: PPUSH
12675: PPUSH
12676: PPUSH
// sort_list := [ ] ;
12677: LD_ADDR_VAR 0 5
12681: PUSH
12682: EMPTY
12683: ST_TO_ADDR
// for i = 1 to list do
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: DOUBLE
12690: LD_INT 1
12692: DEC
12693: ST_TO_ADDR
12694: LD_VAR 0 1
12698: PUSH
12699: FOR_TO
12700: IFFALSE 12862
// begin if i = 1 then
12702: LD_VAR 0 3
12706: PUSH
12707: LD_INT 1
12709: EQUAL
12710: IFFALSE 12736
// sort_list := sort_list ^ list [ i ] else
12712: LD_ADDR_VAR 0 5
12716: PUSH
12717: LD_VAR 0 5
12721: PUSH
12722: LD_VAR 0 1
12726: PUSH
12727: LD_VAR 0 3
12731: ARRAY
12732: ADD
12733: ST_TO_ADDR
12734: GO 12860
// begin for j = 1 to sort_list do
12736: LD_ADDR_VAR 0 4
12740: PUSH
12741: DOUBLE
12742: LD_INT 1
12744: DEC
12745: ST_TO_ADDR
12746: LD_VAR 0 5
12750: PUSH
12751: FOR_TO
12752: IFFALSE 12829
// begin add := false ;
12754: LD_ADDR_VAR 0 6
12758: PUSH
12759: LD_INT 0
12761: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12762: LD_VAR 0 1
12766: PUSH
12767: LD_VAR 0 3
12771: ARRAY
12772: PUSH
12773: LD_VAR 0 5
12777: PUSH
12778: LD_VAR 0 4
12782: ARRAY
12783: GREATER
12784: IFFALSE 12827
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12786: LD_ADDR_VAR 0 5
12790: PUSH
12791: LD_VAR 0 5
12795: PPUSH
12796: LD_VAR 0 4
12800: PPUSH
12801: LD_VAR 0 1
12805: PUSH
12806: LD_VAR 0 3
12810: ARRAY
12811: PPUSH
12812: CALL_OW 2
12816: ST_TO_ADDR
// add := true ;
12817: LD_ADDR_VAR 0 6
12821: PUSH
12822: LD_INT 1
12824: ST_TO_ADDR
// break ;
12825: GO 12829
// end ; end ;
12827: GO 12751
12829: POP
12830: POP
// if not add then
12831: LD_VAR 0 6
12835: NOT
12836: IFFALSE 12860
// sort_list := sort_list ^ list [ i ] ;
12838: LD_ADDR_VAR 0 5
12842: PUSH
12843: LD_VAR 0 5
12847: PUSH
12848: LD_VAR 0 1
12852: PUSH
12853: LD_VAR 0 3
12857: ARRAY
12858: ADD
12859: ST_TO_ADDR
// end ; end ;
12860: GO 12699
12862: POP
12863: POP
// result := sort_list ;
12864: LD_ADDR_VAR 0 2
12868: PUSH
12869: LD_VAR 0 5
12873: ST_TO_ADDR
// end ;
12874: LD_VAR 0 2
12878: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12879: LD_INT 0
12881: PPUSH
12882: PPUSH
12883: PPUSH
12884: PPUSH
12885: PPUSH
12886: PPUSH
// tmp := [ ] ;
12887: LD_ADDR_VAR 0 8
12891: PUSH
12892: EMPTY
12893: ST_TO_ADDR
// r := [ ] ;
12894: LD_ADDR_VAR 0 7
12898: PUSH
12899: EMPTY
12900: ST_TO_ADDR
// add := false ;
12901: LD_ADDR_VAR 0 9
12905: PUSH
12906: LD_INT 0
12908: ST_TO_ADDR
// if plist then
12909: LD_VAR 0 2
12913: IFFALSE 12989
// begin for i = 1 to plist do
12915: LD_ADDR_VAR 0 5
12919: PUSH
12920: DOUBLE
12921: LD_INT 1
12923: DEC
12924: ST_TO_ADDR
12925: LD_VAR 0 2
12929: PUSH
12930: FOR_TO
12931: IFFALSE 12985
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12933: LD_ADDR_VAR 0 8
12937: PUSH
12938: LD_VAR 0 8
12942: PUSH
12943: LD_VAR 0 2
12947: PUSH
12948: LD_VAR 0 5
12952: ARRAY
12953: PUSH
12954: LD_VAR 0 2
12958: PUSH
12959: LD_VAR 0 5
12963: ARRAY
12964: PPUSH
12965: LD_VAR 0 3
12969: PPUSH
12970: CALL_OW 259
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: EMPTY
12980: LIST
12981: ADD
12982: ST_TO_ADDR
// end ;
12983: GO 12930
12985: POP
12986: POP
// end else
12987: GO 12997
// result := false ;
12989: LD_ADDR_VAR 0 4
12993: PUSH
12994: LD_INT 0
12996: ST_TO_ADDR
// if tmp then
12997: LD_VAR 0 8
13001: IFFALSE 13175
// begin r := r ^ [ tmp [ 1 ] ] ;
13003: LD_ADDR_VAR 0 7
13007: PUSH
13008: LD_VAR 0 7
13012: PUSH
13013: LD_VAR 0 8
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PUSH
13022: EMPTY
13023: LIST
13024: ADD
13025: ST_TO_ADDR
// for i = 2 to tmp do
13026: LD_ADDR_VAR 0 5
13030: PUSH
13031: DOUBLE
13032: LD_INT 2
13034: DEC
13035: ST_TO_ADDR
13036: LD_VAR 0 8
13040: PUSH
13041: FOR_TO
13042: IFFALSE 13173
// begin for j = 1 to r do
13044: LD_ADDR_VAR 0 6
13048: PUSH
13049: DOUBLE
13050: LD_INT 1
13052: DEC
13053: ST_TO_ADDR
13054: LD_VAR 0 7
13058: PUSH
13059: FOR_TO
13060: IFFALSE 13137
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13062: LD_VAR 0 8
13066: PUSH
13067: LD_VAR 0 5
13071: ARRAY
13072: PUSH
13073: LD_INT 2
13075: ARRAY
13076: PUSH
13077: LD_VAR 0 7
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PUSH
13088: LD_INT 2
13090: ARRAY
13091: LESS
13092: IFFALSE 13135
// begin r := Insert ( r , j , tmp [ i ] ) ;
13094: LD_ADDR_VAR 0 7
13098: PUSH
13099: LD_VAR 0 7
13103: PPUSH
13104: LD_VAR 0 6
13108: PPUSH
13109: LD_VAR 0 8
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PPUSH
13120: CALL_OW 2
13124: ST_TO_ADDR
// add := true ;
13125: LD_ADDR_VAR 0 9
13129: PUSH
13130: LD_INT 1
13132: ST_TO_ADDR
// break ;
13133: GO 13137
// end ; end ;
13135: GO 13059
13137: POP
13138: POP
// if not add then
13139: LD_VAR 0 9
13143: NOT
13144: IFFALSE 13171
// r := r ^ [ tmp [ i ] ] ;
13146: LD_ADDR_VAR 0 7
13150: PUSH
13151: LD_VAR 0 7
13155: PUSH
13156: LD_VAR 0 8
13160: PUSH
13161: LD_VAR 0 5
13165: ARRAY
13166: PUSH
13167: EMPTY
13168: LIST
13169: ADD
13170: ST_TO_ADDR
// end ;
13171: GO 13041
13173: POP
13174: POP
// end ; result := r ;
13175: LD_ADDR_VAR 0 4
13179: PUSH
13180: LD_VAR 0 7
13184: ST_TO_ADDR
// end ;
13185: LD_VAR 0 4
13189: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13190: LD_INT 0
13192: PPUSH
13193: PPUSH
13194: PPUSH
13195: PPUSH
13196: PPUSH
13197: PPUSH
// tmp := [ ] ;
13198: LD_ADDR_VAR 0 8
13202: PUSH
13203: EMPTY
13204: ST_TO_ADDR
// r := [ ] ;
13205: LD_ADDR_VAR 0 7
13209: PUSH
13210: EMPTY
13211: ST_TO_ADDR
// add := false ;
13212: LD_ADDR_VAR 0 9
13216: PUSH
13217: LD_INT 0
13219: ST_TO_ADDR
// if plist then
13220: LD_VAR 0 2
13224: IFFALSE 13300
// begin for i = 1 to plist do
13226: LD_ADDR_VAR 0 5
13230: PUSH
13231: DOUBLE
13232: LD_INT 1
13234: DEC
13235: ST_TO_ADDR
13236: LD_VAR 0 2
13240: PUSH
13241: FOR_TO
13242: IFFALSE 13296
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13244: LD_ADDR_VAR 0 8
13248: PUSH
13249: LD_VAR 0 8
13253: PUSH
13254: LD_VAR 0 2
13258: PUSH
13259: LD_VAR 0 5
13263: ARRAY
13264: PUSH
13265: LD_VAR 0 2
13269: PUSH
13270: LD_VAR 0 5
13274: ARRAY
13275: PPUSH
13276: LD_VAR 0 3
13280: PPUSH
13281: CALL_OW 259
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PUSH
13290: EMPTY
13291: LIST
13292: ADD
13293: ST_TO_ADDR
// end ;
13294: GO 13241
13296: POP
13297: POP
// end else
13298: GO 13308
// result := false ;
13300: LD_ADDR_VAR 0 4
13304: PUSH
13305: LD_INT 0
13307: ST_TO_ADDR
// if tmp then
13308: LD_VAR 0 8
13312: IFFALSE 13486
// begin r := r ^ [ tmp [ 1 ] ] ;
13314: LD_ADDR_VAR 0 7
13318: PUSH
13319: LD_VAR 0 7
13323: PUSH
13324: LD_VAR 0 8
13328: PUSH
13329: LD_INT 1
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// for i = 2 to tmp do
13337: LD_ADDR_VAR 0 5
13341: PUSH
13342: DOUBLE
13343: LD_INT 2
13345: DEC
13346: ST_TO_ADDR
13347: LD_VAR 0 8
13351: PUSH
13352: FOR_TO
13353: IFFALSE 13484
// begin for j = 1 to r do
13355: LD_ADDR_VAR 0 6
13359: PUSH
13360: DOUBLE
13361: LD_INT 1
13363: DEC
13364: ST_TO_ADDR
13365: LD_VAR 0 7
13369: PUSH
13370: FOR_TO
13371: IFFALSE 13448
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13373: LD_VAR 0 8
13377: PUSH
13378: LD_VAR 0 5
13382: ARRAY
13383: PUSH
13384: LD_INT 2
13386: ARRAY
13387: PUSH
13388: LD_VAR 0 7
13392: PUSH
13393: LD_VAR 0 6
13397: ARRAY
13398: PUSH
13399: LD_INT 2
13401: ARRAY
13402: GREATER
13403: IFFALSE 13446
// begin r := Insert ( r , j , tmp [ i ] ) ;
13405: LD_ADDR_VAR 0 7
13409: PUSH
13410: LD_VAR 0 7
13414: PPUSH
13415: LD_VAR 0 6
13419: PPUSH
13420: LD_VAR 0 8
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PPUSH
13431: CALL_OW 2
13435: ST_TO_ADDR
// add := true ;
13436: LD_ADDR_VAR 0 9
13440: PUSH
13441: LD_INT 1
13443: ST_TO_ADDR
// break ;
13444: GO 13448
// end ; end ;
13446: GO 13370
13448: POP
13449: POP
// if not add then
13450: LD_VAR 0 9
13454: NOT
13455: IFFALSE 13482
// r := r ^ [ tmp [ i ] ] ;
13457: LD_ADDR_VAR 0 7
13461: PUSH
13462: LD_VAR 0 7
13466: PUSH
13467: LD_VAR 0 8
13471: PUSH
13472: LD_VAR 0 5
13476: ARRAY
13477: PUSH
13478: EMPTY
13479: LIST
13480: ADD
13481: ST_TO_ADDR
// end ;
13482: GO 13352
13484: POP
13485: POP
// end ; result := r ;
13486: LD_ADDR_VAR 0 4
13490: PUSH
13491: LD_VAR 0 7
13495: ST_TO_ADDR
// end ;
13496: LD_VAR 0 4
13500: RET
// export function MCF_Clear ( side ) ; var i ; begin
13501: LD_INT 0
13503: PPUSH
13504: PPUSH
// for i = 1 to 100 do
13505: LD_ADDR_VAR 0 3
13509: PUSH
13510: DOUBLE
13511: LD_INT 1
13513: DEC
13514: ST_TO_ADDR
13515: LD_INT 100
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13555
// if MCF_Tag ( side , i , [ ] ) then
13521: LD_VAR 0 1
13525: PPUSH
13526: LD_VAR 0 3
13530: PPUSH
13531: EMPTY
13532: PPUSH
13533: CALL 12124 0 3
13537: IFFALSE 13553
// MCF_ClearTag ( side , i ) ;
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_VAR 0 3
13548: PPUSH
13549: CALL 12365 0 2
13553: GO 13518
13555: POP
13556: POP
// result := true ;
13557: LD_ADDR_VAR 0 2
13561: PUSH
13562: LD_INT 1
13564: ST_TO_ADDR
// end ;
13565: LD_VAR 0 2
13569: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13570: LD_INT 0
13572: PPUSH
13573: PPUSH
13574: PPUSH
// for i = 1 to plist do
13575: LD_ADDR_VAR 0 4
13579: PUSH
13580: DOUBLE
13581: LD_INT 1
13583: DEC
13584: ST_TO_ADDR
13585: LD_VAR 0 1
13589: PUSH
13590: FOR_TO
13591: IFFALSE 13640
// if MCF_HasClass ( plist [ i ] ) = n then
13593: LD_VAR 0 1
13597: PUSH
13598: LD_VAR 0 4
13602: ARRAY
13603: PPUSH
13604: CALL 14127 0 1
13608: PUSH
13609: LD_VAR 0 2
13613: EQUAL
13614: IFFALSE 13638
// tmp := tmp ^ plist [ i ] ;
13616: LD_ADDR_VAR 0 5
13620: PUSH
13621: LD_VAR 0 5
13625: PUSH
13626: LD_VAR 0 1
13630: PUSH
13631: LD_VAR 0 4
13635: ARRAY
13636: ADD
13637: ST_TO_ADDR
13638: GO 13590
13640: POP
13641: POP
// result := tmp ;
13642: LD_ADDR_VAR 0 3
13646: PUSH
13647: LD_VAR 0 5
13651: ST_TO_ADDR
// end ;
13652: LD_VAR 0 3
13656: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13657: LD_INT 0
13659: PPUSH
13660: PPUSH
13661: PPUSH
// if mreg = ToArm then
13662: LD_VAR 0 2
13666: PUSH
13667: LD_STRING ToArm
13669: EQUAL
13670: IFFALSE 13775
// begin tmp := MREG_ToArm [ side ] ;
13672: LD_ADDR_VAR 0 6
13676: PUSH
13677: LD_EXP 57
13681: PUSH
13682: LD_VAR 0 1
13686: ARRAY
13687: ST_TO_ADDR
// if tmp = 0 then
13688: LD_VAR 0 6
13692: PUSH
13693: LD_INT 0
13695: EQUAL
13696: IFFALSE 13702
// exit else
13698: GO 14122
13700: GO 13775
// begin for i = MREG_ToArm [ side ] downto n do
13702: LD_ADDR_VAR 0 5
13706: PUSH
13707: DOUBLE
13708: LD_EXP 57
13712: PUSH
13713: LD_VAR 0 1
13717: ARRAY
13718: INC
13719: ST_TO_ADDR
13720: LD_VAR 0 3
13724: PUSH
13725: FOR_DOWNTO
13726: IFFALSE 13748
// tmp := Delete ( tmp , 1 ) ;
13728: LD_ADDR_VAR 0 6
13732: PUSH
13733: LD_VAR 0 6
13737: PPUSH
13738: LD_INT 1
13740: PPUSH
13741: CALL_OW 3
13745: ST_TO_ADDR
13746: GO 13725
13748: POP
13749: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13750: LD_ADDR_EXP 57
13754: PUSH
13755: LD_EXP 57
13759: PPUSH
13760: LD_VAR 0 1
13764: PPUSH
13765: LD_VAR 0 6
13769: PPUSH
13770: CALL_OW 1
13774: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13775: LD_VAR 0 2
13779: PUSH
13780: LD_STRING ToDep
13782: EQUAL
13783: IFFALSE 13888
// begin tmp := MREG_ToDep [ side ] ;
13785: LD_ADDR_VAR 0 6
13789: PUSH
13790: LD_EXP 58
13794: PUSH
13795: LD_VAR 0 1
13799: ARRAY
13800: ST_TO_ADDR
// if tmp = 0 then
13801: LD_VAR 0 6
13805: PUSH
13806: LD_INT 0
13808: EQUAL
13809: IFFALSE 13815
// exit else
13811: GO 14122
13813: GO 13888
// begin for i = MREG_ToDep [ side ] downto n do
13815: LD_ADDR_VAR 0 5
13819: PUSH
13820: DOUBLE
13821: LD_EXP 58
13825: PUSH
13826: LD_VAR 0 1
13830: ARRAY
13831: INC
13832: ST_TO_ADDR
13833: LD_VAR 0 3
13837: PUSH
13838: FOR_DOWNTO
13839: IFFALSE 13861
// tmp := Delete ( tmp , 1 ) ;
13841: LD_ADDR_VAR 0 6
13845: PUSH
13846: LD_VAR 0 6
13850: PPUSH
13851: LD_INT 1
13853: PPUSH
13854: CALL_OW 3
13858: ST_TO_ADDR
13859: GO 13838
13861: POP
13862: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13863: LD_ADDR_EXP 58
13867: PUSH
13868: LD_EXP 58
13872: PPUSH
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_VAR 0 6
13882: PPUSH
13883: CALL_OW 1
13887: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13888: LD_VAR 0 2
13892: PUSH
13893: LD_STRING ToFac
13895: EQUAL
13896: IFFALSE 14001
// begin tmp := MREG_ToFac [ side ] ;
13898: LD_ADDR_VAR 0 6
13902: PUSH
13903: LD_EXP 56
13907: PUSH
13908: LD_VAR 0 1
13912: ARRAY
13913: ST_TO_ADDR
// if tmp = 0 then
13914: LD_VAR 0 6
13918: PUSH
13919: LD_INT 0
13921: EQUAL
13922: IFFALSE 13928
// exit else
13924: GO 14122
13926: GO 14001
// begin for i = MREG_ToFac [ side ] downto n do
13928: LD_ADDR_VAR 0 5
13932: PUSH
13933: DOUBLE
13934: LD_EXP 56
13938: PUSH
13939: LD_VAR 0 1
13943: ARRAY
13944: INC
13945: ST_TO_ADDR
13946: LD_VAR 0 3
13950: PUSH
13951: FOR_DOWNTO
13952: IFFALSE 13974
// tmp := Delete ( tmp , 1 ) ;
13954: LD_ADDR_VAR 0 6
13958: PUSH
13959: LD_VAR 0 6
13963: PPUSH
13964: LD_INT 1
13966: PPUSH
13967: CALL_OW 3
13971: ST_TO_ADDR
13972: GO 13951
13974: POP
13975: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13976: LD_ADDR_EXP 56
13980: PUSH
13981: LD_EXP 56
13985: PPUSH
13986: LD_VAR 0 1
13990: PPUSH
13991: LD_VAR 0 6
13995: PPUSH
13996: CALL_OW 1
14000: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14001: LD_VAR 0 2
14005: PUSH
14006: LD_STRING ToLab
14008: EQUAL
14009: IFFALSE 14114
// begin tmp := MREG_ToLab [ side ] ;
14011: LD_ADDR_VAR 0 6
14015: PUSH
14016: LD_EXP 55
14020: PUSH
14021: LD_VAR 0 1
14025: ARRAY
14026: ST_TO_ADDR
// if tmp = 0 then
14027: LD_VAR 0 6
14031: PUSH
14032: LD_INT 0
14034: EQUAL
14035: IFFALSE 14041
// exit else
14037: GO 14122
14039: GO 14114
// begin for i = MREG_ToLab [ side ] downto n do
14041: LD_ADDR_VAR 0 5
14045: PUSH
14046: DOUBLE
14047: LD_EXP 55
14051: PUSH
14052: LD_VAR 0 1
14056: ARRAY
14057: INC
14058: ST_TO_ADDR
14059: LD_VAR 0 3
14063: PUSH
14064: FOR_DOWNTO
14065: IFFALSE 14087
// tmp := Delete ( tmp , 1 ) ;
14067: LD_ADDR_VAR 0 6
14071: PUSH
14072: LD_VAR 0 6
14076: PPUSH
14077: LD_INT 1
14079: PPUSH
14080: CALL_OW 3
14084: ST_TO_ADDR
14085: GO 14064
14087: POP
14088: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14089: LD_ADDR_EXP 55
14093: PUSH
14094: LD_EXP 55
14098: PPUSH
14099: LD_VAR 0 1
14103: PPUSH
14104: LD_VAR 0 6
14108: PPUSH
14109: CALL_OW 1
14113: ST_TO_ADDR
// end ; end ; result := true ;
14114: LD_ADDR_VAR 0 4
14118: PUSH
14119: LD_INT 1
14121: ST_TO_ADDR
// end ;
14122: LD_VAR 0 4
14126: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14127: LD_INT 0
14129: PPUSH
14130: PPUSH
14131: PPUSH
// side := GetSide ( unit ) ;
14132: LD_ADDR_VAR 0 4
14136: PUSH
14137: LD_VAR 0 1
14141: PPUSH
14142: CALL_OW 255
14146: ST_TO_ADDR
// tmp := 0 ;
14147: LD_ADDR_VAR 0 3
14151: PUSH
14152: LD_INT 0
14154: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14155: LD_VAR 0 1
14159: PUSH
14160: LD_EXP 57
14164: PUSH
14165: LD_VAR 0 4
14169: ARRAY
14170: IN
14171: IFFALSE 14181
// tmp := 1 ;
14173: LD_ADDR_VAR 0 3
14177: PUSH
14178: LD_INT 1
14180: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14181: LD_VAR 0 1
14185: PUSH
14186: LD_EXP 58
14190: PUSH
14191: LD_VAR 0 4
14195: ARRAY
14196: IN
14197: IFFALSE 14207
// tmp := 2 ;
14199: LD_ADDR_VAR 0 3
14203: PUSH
14204: LD_INT 2
14206: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14207: LD_VAR 0 1
14211: PUSH
14212: LD_EXP 56
14216: PUSH
14217: LD_VAR 0 4
14221: ARRAY
14222: IN
14223: IFFALSE 14233
// tmp := 3 ;
14225: LD_ADDR_VAR 0 3
14229: PUSH
14230: LD_INT 3
14232: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14233: LD_VAR 0 1
14237: PUSH
14238: LD_EXP 55
14242: PUSH
14243: LD_VAR 0 4
14247: ARRAY
14248: IN
14249: IFFALSE 14259
// tmp := 4 ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 4
14258: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14259: LD_VAR 0 1
14263: PUSH
14264: LD_EXP 69
14268: PUSH
14269: LD_VAR 0 4
14273: ARRAY
14274: IN
14275: IFFALSE 14285
// tmp := 5 ;
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_INT 5
14284: ST_TO_ADDR
// result := tmp ;
14285: LD_ADDR_VAR 0 2
14289: PUSH
14290: LD_VAR 0 3
14294: ST_TO_ADDR
// end ;
14295: LD_VAR 0 2
14299: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14300: LD_INT 0
14302: PPUSH
14303: PPUSH
// if mreg = ToArm then
14304: LD_VAR 0 2
14308: PUSH
14309: LD_STRING ToArm
14311: EQUAL
14312: IFFALSE 14401
// for i = MREG_ToArm [ side ] downto 1 do
14314: LD_ADDR_VAR 0 5
14318: PUSH
14319: DOUBLE
14320: LD_EXP 57
14324: PUSH
14325: LD_VAR 0 1
14329: ARRAY
14330: INC
14331: ST_TO_ADDR
14332: LD_INT 1
14334: PUSH
14335: FOR_DOWNTO
14336: IFFALSE 14399
// if MREG_ToArm [ side ] [ i ] = unit then
14338: LD_EXP 57
14342: PUSH
14343: LD_VAR 0 1
14347: ARRAY
14348: PUSH
14349: LD_VAR 0 5
14353: ARRAY
14354: PUSH
14355: LD_VAR 0 3
14359: EQUAL
14360: IFFALSE 14397
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14362: LD_ADDR_EXP 57
14366: PUSH
14367: LD_EXP 57
14371: PPUSH
14372: LD_EXP 57
14376: PUSH
14377: LD_VAR 0 1
14381: ARRAY
14382: PUSH
14383: LD_VAR 0 5
14387: ARRAY
14388: PPUSH
14389: LD_INT 1
14391: PPUSH
14392: CALL 31118 0 3
14396: ST_TO_ADDR
// end ;
14397: GO 14335
14399: POP
14400: POP
// if mreg = ToDep then
14401: LD_VAR 0 2
14405: PUSH
14406: LD_STRING ToDep
14408: EQUAL
14409: IFFALSE 14498
// for i = MREG_ToDep [ side ] downto 1 do
14411: LD_ADDR_VAR 0 5
14415: PUSH
14416: DOUBLE
14417: LD_EXP 58
14421: PUSH
14422: LD_VAR 0 1
14426: ARRAY
14427: INC
14428: ST_TO_ADDR
14429: LD_INT 1
14431: PUSH
14432: FOR_DOWNTO
14433: IFFALSE 14496
// if MREG_ToDep [ side ] [ i ] = unit then
14435: LD_EXP 58
14439: PUSH
14440: LD_VAR 0 1
14444: ARRAY
14445: PUSH
14446: LD_VAR 0 5
14450: ARRAY
14451: PUSH
14452: LD_VAR 0 3
14456: EQUAL
14457: IFFALSE 14494
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14459: LD_ADDR_EXP 58
14463: PUSH
14464: LD_EXP 58
14468: PPUSH
14469: LD_EXP 58
14473: PUSH
14474: LD_VAR 0 1
14478: ARRAY
14479: PUSH
14480: LD_VAR 0 5
14484: ARRAY
14485: PPUSH
14486: LD_INT 1
14488: PPUSH
14489: CALL 31118 0 3
14493: ST_TO_ADDR
// end ;
14494: GO 14432
14496: POP
14497: POP
// if mreg = ToFac then
14498: LD_VAR 0 2
14502: PUSH
14503: LD_STRING ToFac
14505: EQUAL
14506: IFFALSE 14595
// for i = MREG_ToFac [ side ] downto 1 do
14508: LD_ADDR_VAR 0 5
14512: PUSH
14513: DOUBLE
14514: LD_EXP 56
14518: PUSH
14519: LD_VAR 0 1
14523: ARRAY
14524: INC
14525: ST_TO_ADDR
14526: LD_INT 1
14528: PUSH
14529: FOR_DOWNTO
14530: IFFALSE 14593
// if MREG_ToFac [ side ] [ i ] = unit then
14532: LD_EXP 56
14536: PUSH
14537: LD_VAR 0 1
14541: ARRAY
14542: PUSH
14543: LD_VAR 0 5
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 3
14553: EQUAL
14554: IFFALSE 14591
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14556: LD_ADDR_EXP 56
14560: PUSH
14561: LD_EXP 56
14565: PPUSH
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: PUSH
14577: LD_VAR 0 5
14581: ARRAY
14582: PPUSH
14583: LD_INT 1
14585: PPUSH
14586: CALL 31118 0 3
14590: ST_TO_ADDR
// end ;
14591: GO 14529
14593: POP
14594: POP
// if mreg = ToLab then
14595: LD_VAR 0 2
14599: PUSH
14600: LD_STRING ToLab
14602: EQUAL
14603: IFFALSE 14692
// for i = MREG_ToLab [ side ] downto 1 do
14605: LD_ADDR_VAR 0 5
14609: PUSH
14610: DOUBLE
14611: LD_EXP 55
14615: PUSH
14616: LD_VAR 0 1
14620: ARRAY
14621: INC
14622: ST_TO_ADDR
14623: LD_INT 1
14625: PUSH
14626: FOR_DOWNTO
14627: IFFALSE 14690
// if MREG_ToLab [ side ] [ i ] = unit then
14629: LD_EXP 55
14633: PUSH
14634: LD_VAR 0 1
14638: ARRAY
14639: PUSH
14640: LD_VAR 0 5
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 3
14650: EQUAL
14651: IFFALSE 14688
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14653: LD_ADDR_EXP 55
14657: PUSH
14658: LD_EXP 55
14662: PPUSH
14663: LD_EXP 55
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: PUSH
14674: LD_VAR 0 5
14678: ARRAY
14679: PPUSH
14680: LD_INT 1
14682: PPUSH
14683: CALL 31118 0 3
14687: ST_TO_ADDR
// end ;
14688: GO 14626
14690: POP
14691: POP
// end ;
14692: LD_VAR 0 4
14696: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14697: LD_INT 0
14699: PPUSH
14700: PPUSH
// result := false ;
14701: LD_ADDR_VAR 0 2
14705: PUSH
14706: LD_INT 0
14708: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14709: LD_ADDR_VAR 0 3
14713: PUSH
14714: DOUBLE
14715: LD_INT 1
14717: DEC
14718: ST_TO_ADDR
14719: LD_EXP 47
14723: PUSH
14724: FOR_TO
14725: IFFALSE 14789
// if MREG_ToBuild [ i ] [ 1 ] = side then
14727: LD_EXP 47
14731: PUSH
14732: LD_VAR 0 3
14736: ARRAY
14737: PUSH
14738: LD_INT 1
14740: ARRAY
14741: PUSH
14742: LD_VAR 0 1
14746: EQUAL
14747: IFFALSE 14787
// begin if MREG_ToBuild [ i ] [ 1 ] then
14749: LD_EXP 47
14753: PUSH
14754: LD_VAR 0 3
14758: ARRAY
14759: PUSH
14760: LD_INT 1
14762: ARRAY
14763: IFFALSE 14787
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14765: LD_ADDR_VAR 0 2
14769: PUSH
14770: LD_EXP 47
14774: PUSH
14775: LD_VAR 0 3
14779: ARRAY
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// break ;
14785: GO 14789
// end ; end ;
14787: GO 14724
14789: POP
14790: POP
// for i = 1 to MREG_ToRepair do
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: DOUBLE
14797: LD_INT 1
14799: DEC
14800: ST_TO_ADDR
14801: LD_EXP 48
14805: PUSH
14806: FOR_TO
14807: IFFALSE 14871
// if MREG_ToRepair [ i ] [ 1 ] = side then
14809: LD_EXP 48
14813: PUSH
14814: LD_VAR 0 3
14818: ARRAY
14819: PUSH
14820: LD_INT 1
14822: ARRAY
14823: PUSH
14824: LD_VAR 0 1
14828: EQUAL
14829: IFFALSE 14869
// begin if MREG_ToRepair [ i ] [ 1 ] then
14831: LD_EXP 48
14835: PUSH
14836: LD_VAR 0 3
14840: ARRAY
14841: PUSH
14842: LD_INT 1
14844: ARRAY
14845: IFFALSE 14869
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14847: LD_ADDR_VAR 0 2
14851: PUSH
14852: LD_EXP 48
14856: PUSH
14857: LD_VAR 0 3
14861: ARRAY
14862: PUSH
14863: LD_INT 1
14865: ARRAY
14866: ST_TO_ADDR
// break ;
14867: GO 14871
// end ; end ;
14869: GO 14806
14871: POP
14872: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14873: LD_VAR 0 1
14877: PPUSH
14878: LD_INT 57
14880: PUSH
14881: EMPTY
14882: LIST
14883: PPUSH
14884: CALL 11421 0 2
14888: IFFALSE 14915
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14890: LD_ADDR_VAR 0 2
14894: PUSH
14895: LD_VAR 0 1
14899: PPUSH
14900: LD_INT 57
14902: PUSH
14903: EMPTY
14904: LIST
14905: PPUSH
14906: CALL 11421 0 2
14910: PUSH
14911: LD_INT 1
14913: ARRAY
14914: ST_TO_ADDR
// end ;
14915: LD_VAR 0 2
14919: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14920: LD_INT 0
14922: PPUSH
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14927: LD_ADDR_VAR 0 6
14931: PUSH
14932: LD_VAR 0 1
14936: PPUSH
14937: LD_INT 21
14939: PUSH
14940: LD_INT 3
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL 11421 0 2
14951: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14952: LD_ADDR_VAR 0 7
14956: PUSH
14957: LD_VAR 0 1
14961: PPUSH
14962: LD_INT 81
14964: PUSH
14965: LD_VAR 0 1
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL 11421 0 2
14978: ST_TO_ADDR
// if not enemy then
14979: LD_VAR 0 7
14983: NOT
14984: IFFALSE 14996
// result := false else
14986: LD_ADDR_VAR 0 3
14990: PUSH
14991: LD_INT 0
14993: ST_TO_ADDR
14994: GO 15050
// begin scan := NearestUnit ( b , enemy ) ;
14996: LD_ADDR_VAR 0 5
15000: PUSH
15001: LD_VAR 0 6
15005: PPUSH
15006: LD_VAR 0 7
15010: PPUSH
15011: CALL 32443 0 2
15015: ST_TO_ADDR
// if scan [ 2 ] < dist then
15016: LD_VAR 0 5
15020: PUSH
15021: LD_INT 2
15023: ARRAY
15024: PUSH
15025: LD_VAR 0 2
15029: LESS
15030: IFFALSE 15042
// result := true else
15032: LD_ADDR_VAR 0 3
15036: PUSH
15037: LD_INT 1
15039: ST_TO_ADDR
15040: GO 15050
// result := false ;
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_INT 0
15049: ST_TO_ADDR
// end ; end ;
15050: LD_VAR 0 3
15054: RET
// export function MCF_Info ( ) ; begin
15055: LD_INT 0
15057: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15058: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15060: PUSH
15061: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15063: ADD
15064: PUSH
15065: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15067: ADD
15068: PUSH
15069: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15071: ADD
15072: PUSH
15073: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15075: ADD
15076: PUSH
15077: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15079: ADD
15080: PUSH
15081: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15083: ADD
15084: PUSH
15085: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15087: ADD
15088: PUSH
15089: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15091: ADD
15092: PUSH
15093: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15095: ADD
15096: PPUSH
15097: CALL 8339 0 1
// end ; end_of_file
15101: LD_VAR 0 1
15105: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15106: LD_INT 0
15108: PPUSH
15109: PPUSH
15110: PPUSH
15111: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15112: LD_ADDR_VAR 0 5
15116: PUSH
15117: LD_VAR 0 1
15121: PPUSH
15122: LD_INT 2
15124: PUSH
15125: LD_INT 25
15127: PUSH
15128: LD_INT 2
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 25
15137: PUSH
15138: LD_INT 3
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 25
15147: PUSH
15148: LD_INT 4
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: PPUSH
15161: CALL 11421 0 2
15165: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15166: LD_ADDR_VAR 0 5
15170: PUSH
15171: LD_VAR 0 5
15175: PPUSH
15176: LD_INT 0
15178: PPUSH
15179: CALL 13570 0 2
15183: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15184: LD_ADDR_VAR 0 6
15188: PUSH
15189: LD_VAR 0 1
15193: PPUSH
15194: LD_VAR 0 5
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL 13190 0 3
15206: ST_TO_ADDR
// if n > sk then
15207: LD_VAR 0 2
15211: PUSH
15212: LD_VAR 0 6
15216: GREATER
15217: IFFALSE 15229
// n := sk ;
15219: LD_ADDR_VAR 0 2
15223: PUSH
15224: LD_VAR 0 6
15228: ST_TO_ADDR
// for i = 1 to n do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 1
15237: DEC
15238: ST_TO_ADDR
15239: LD_VAR 0 2
15243: PUSH
15244: FOR_TO
15245: IFFALSE 15357
// if ( sk [ i ] [ 1 ] ) <> 0 then
15247: LD_VAR 0 6
15251: PUSH
15252: LD_VAR 0 4
15256: ARRAY
15257: PUSH
15258: LD_INT 1
15260: ARRAY
15261: PUSH
15262: LD_INT 0
15264: NONEQUAL
15265: IFFALSE 15355
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15267: LD_ADDR_EXP 54
15271: PUSH
15272: LD_EXP 54
15276: PPUSH
15277: LD_VAR 0 1
15281: PPUSH
15282: LD_VAR 0 6
15286: PUSH
15287: LD_VAR 0 4
15291: ARRAY
15292: PUSH
15293: LD_INT 1
15295: ARRAY
15296: PPUSH
15297: LD_INT 1
15299: PPUSH
15300: CALL 42241 0 4
15304: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15305: LD_ADDR_EXP 57
15309: PUSH
15310: LD_EXP 57
15314: PPUSH
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_EXP 57
15324: PUSH
15325: LD_VAR 0 1
15329: ARRAY
15330: PUSH
15331: LD_INT 1
15333: PLUS
15334: PPUSH
15335: LD_VAR 0 6
15339: PUSH
15340: LD_VAR 0 4
15344: ARRAY
15345: PUSH
15346: LD_INT 1
15348: ARRAY
15349: PPUSH
15350: CALL 30959 0 4
15354: ST_TO_ADDR
// end ;
15355: GO 15244
15357: POP
15358: POP
// end ;
15359: LD_VAR 0 3
15363: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15364: LD_INT 0
15366: PPUSH
15367: PPUSH
15368: PPUSH
15369: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15370: LD_ADDR_VAR 0 5
15374: PUSH
15375: LD_VAR 0 1
15379: PPUSH
15380: LD_INT 2
15382: PUSH
15383: LD_INT 25
15385: PUSH
15386: LD_INT 1
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 25
15395: PUSH
15396: LD_INT 3
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: PUSH
15403: LD_INT 25
15405: PUSH
15406: LD_INT 4
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PPUSH
15419: CALL 11421 0 2
15423: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15424: LD_ADDR_VAR 0 5
15428: PUSH
15429: LD_VAR 0 5
15433: PPUSH
15434: LD_INT 0
15436: PPUSH
15437: CALL 13570 0 2
15441: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15442: LD_ADDR_VAR 0 6
15446: PUSH
15447: LD_VAR 0 1
15451: PPUSH
15452: LD_VAR 0 5
15456: PPUSH
15457: LD_INT 2
15459: PPUSH
15460: CALL 13190 0 3
15464: ST_TO_ADDR
// if n > sk then
15465: LD_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: GREATER
15475: IFFALSE 15487
// n := sk ;
15477: LD_ADDR_VAR 0 2
15481: PUSH
15482: LD_VAR 0 6
15486: ST_TO_ADDR
// for i = 1 to n do
15487: LD_ADDR_VAR 0 4
15491: PUSH
15492: DOUBLE
15493: LD_INT 1
15495: DEC
15496: ST_TO_ADDR
15497: LD_VAR 0 2
15501: PUSH
15502: FOR_TO
15503: IFFALSE 15615
// if ( sk [ i ] [ 1 ] ) <> 0 then
15505: LD_VAR 0 6
15509: PUSH
15510: LD_VAR 0 4
15514: ARRAY
15515: PUSH
15516: LD_INT 1
15518: ARRAY
15519: PUSH
15520: LD_INT 0
15522: NONEQUAL
15523: IFFALSE 15613
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15525: LD_ADDR_EXP 54
15529: PUSH
15530: LD_EXP 54
15534: PPUSH
15535: LD_VAR 0 1
15539: PPUSH
15540: LD_VAR 0 6
15544: PUSH
15545: LD_VAR 0 4
15549: ARRAY
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_INT 2
15557: PPUSH
15558: CALL 42241 0 4
15562: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15563: LD_ADDR_EXP 58
15567: PUSH
15568: LD_EXP 58
15572: PPUSH
15573: LD_VAR 0 1
15577: PPUSH
15578: LD_EXP 58
15582: PUSH
15583: LD_VAR 0 1
15587: ARRAY
15588: PUSH
15589: LD_INT 1
15591: PLUS
15592: PPUSH
15593: LD_VAR 0 6
15597: PUSH
15598: LD_VAR 0 4
15602: ARRAY
15603: PUSH
15604: LD_INT 1
15606: ARRAY
15607: PPUSH
15608: CALL 30959 0 4
15612: ST_TO_ADDR
// end ;
15613: GO 15502
15615: POP
15616: POP
// end ;
15617: LD_VAR 0 3
15621: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15622: LD_INT 0
15624: PPUSH
15625: PPUSH
15626: PPUSH
15627: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15628: LD_ADDR_VAR 0 5
15632: PUSH
15633: LD_VAR 0 1
15637: PPUSH
15638: LD_INT 2
15640: PUSH
15641: LD_INT 25
15643: PUSH
15644: LD_INT 1
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: PUSH
15651: LD_INT 25
15653: PUSH
15654: LD_INT 2
15656: PUSH
15657: EMPTY
15658: LIST
15659: LIST
15660: PUSH
15661: LD_INT 25
15663: PUSH
15664: LD_INT 4
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: PPUSH
15677: CALL 11421 0 2
15681: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15682: LD_ADDR_VAR 0 5
15686: PUSH
15687: LD_VAR 0 5
15691: PPUSH
15692: LD_INT 0
15694: PPUSH
15695: CALL 13570 0 2
15699: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15700: LD_ADDR_VAR 0 6
15704: PUSH
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_VAR 0 5
15714: PPUSH
15715: LD_INT 3
15717: PPUSH
15718: CALL 13190 0 3
15722: ST_TO_ADDR
// if n > sk then
15723: LD_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: GREATER
15733: IFFALSE 15745
// n := sk ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_VAR 0 6
15744: ST_TO_ADDR
// for i = 1 to n do
15745: LD_ADDR_VAR 0 4
15749: PUSH
15750: DOUBLE
15751: LD_INT 1
15753: DEC
15754: ST_TO_ADDR
15755: LD_VAR 0 2
15759: PUSH
15760: FOR_TO
15761: IFFALSE 15873
// if ( sk [ i ] [ 1 ] ) <> 0 then
15763: LD_VAR 0 6
15767: PUSH
15768: LD_VAR 0 4
15772: ARRAY
15773: PUSH
15774: LD_INT 1
15776: ARRAY
15777: PUSH
15778: LD_INT 0
15780: NONEQUAL
15781: IFFALSE 15871
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15783: LD_ADDR_EXP 54
15787: PUSH
15788: LD_EXP 54
15792: PPUSH
15793: LD_VAR 0 1
15797: PPUSH
15798: LD_VAR 0 6
15802: PUSH
15803: LD_VAR 0 4
15807: ARRAY
15808: PUSH
15809: LD_INT 1
15811: ARRAY
15812: PPUSH
15813: LD_INT 3
15815: PPUSH
15816: CALL 42241 0 4
15820: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15821: LD_ADDR_EXP 56
15825: PUSH
15826: LD_EXP 56
15830: PPUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_EXP 56
15840: PUSH
15841: LD_VAR 0 1
15845: ARRAY
15846: PUSH
15847: LD_INT 1
15849: PLUS
15850: PPUSH
15851: LD_VAR 0 6
15855: PUSH
15856: LD_VAR 0 4
15860: ARRAY
15861: PUSH
15862: LD_INT 1
15864: ARRAY
15865: PPUSH
15866: CALL 30959 0 4
15870: ST_TO_ADDR
// end ;
15871: GO 15760
15873: POP
15874: POP
// end ;
15875: LD_VAR 0 3
15879: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15880: LD_INT 0
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15886: LD_ADDR_VAR 0 5
15890: PUSH
15891: LD_VAR 0 1
15895: PPUSH
15896: LD_INT 2
15898: PUSH
15899: LD_INT 25
15901: PUSH
15902: LD_INT 1
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 25
15911: PUSH
15912: LD_INT 2
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: PPUSH
15924: CALL 11421 0 2
15928: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_VAR 0 5
15938: PPUSH
15939: LD_INT 0
15941: PPUSH
15942: CALL 13570 0 2
15946: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15947: LD_ADDR_VAR 0 6
15951: PUSH
15952: LD_VAR 0 1
15956: PPUSH
15957: LD_VAR 0 5
15961: PPUSH
15962: LD_INT 4
15964: PPUSH
15965: CALL 13190 0 3
15969: ST_TO_ADDR
// if n > sk then
15970: LD_VAR 0 2
15974: PUSH
15975: LD_VAR 0 6
15979: GREATER
15980: IFFALSE 15992
// n := sk ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 6
15991: ST_TO_ADDR
// for i = 1 to n do
15992: LD_ADDR_VAR 0 4
15996: PUSH
15997: DOUBLE
15998: LD_INT 1
16000: DEC
16001: ST_TO_ADDR
16002: LD_VAR 0 2
16006: PUSH
16007: FOR_TO
16008: IFFALSE 16120
// if ( sk [ i ] [ 1 ] ) <> 0 then
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 4
16019: ARRAY
16020: PUSH
16021: LD_INT 1
16023: ARRAY
16024: PUSH
16025: LD_INT 0
16027: NONEQUAL
16028: IFFALSE 16118
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16030: LD_ADDR_EXP 54
16034: PUSH
16035: LD_EXP 54
16039: PPUSH
16040: LD_VAR 0 1
16044: PPUSH
16045: LD_VAR 0 6
16049: PUSH
16050: LD_VAR 0 4
16054: ARRAY
16055: PUSH
16056: LD_INT 1
16058: ARRAY
16059: PPUSH
16060: LD_INT 4
16062: PPUSH
16063: CALL 42241 0 4
16067: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16068: LD_ADDR_EXP 55
16072: PUSH
16073: LD_EXP 55
16077: PPUSH
16078: LD_VAR 0 1
16082: PPUSH
16083: LD_EXP 55
16087: PUSH
16088: LD_VAR 0 1
16092: ARRAY
16093: PUSH
16094: LD_INT 1
16096: PLUS
16097: PPUSH
16098: LD_VAR 0 6
16102: PUSH
16103: LD_VAR 0 4
16107: ARRAY
16108: PUSH
16109: LD_INT 1
16111: ARRAY
16112: PPUSH
16113: CALL 30959 0 4
16117: ST_TO_ADDR
// end ;
16118: GO 16007
16120: POP
16121: POP
// end ;
16122: LD_VAR 0 3
16126: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16127: LD_INT 0
16129: PPUSH
16130: PPUSH
16131: PPUSH
16132: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16133: LD_ADDR_VAR 0 6
16137: PUSH
16138: LD_VAR 0 1
16142: PPUSH
16143: LD_INT 2
16145: PUSH
16146: LD_INT 25
16148: PUSH
16149: LD_INT 1
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: PUSH
16156: LD_INT 25
16158: PUSH
16159: LD_INT 2
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: LD_INT 25
16168: PUSH
16169: LD_INT 3
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 25
16178: PUSH
16179: LD_INT 4
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: LIST
16191: LIST
16192: PPUSH
16193: CALL 11421 0 2
16197: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16198: LD_ADDR_VAR 0 6
16202: PUSH
16203: LD_VAR 0 6
16207: PPUSH
16208: LD_INT 0
16210: PPUSH
16211: CALL 13570 0 2
16215: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16216: LD_ADDR_VAR 0 7
16220: PUSH
16221: LD_VAR 0 1
16225: PPUSH
16226: LD_VAR 0 6
16230: PPUSH
16231: LD_INT 1
16233: PPUSH
16234: CALL 13190 0 3
16238: ST_TO_ADDR
// if n > sk then
16239: LD_VAR 0 2
16243: PUSH
16244: LD_VAR 0 7
16248: GREATER
16249: IFFALSE 16261
// n := sk ;
16251: LD_ADDR_VAR 0 2
16255: PUSH
16256: LD_VAR 0 7
16260: ST_TO_ADDR
// for i = 1 to n do
16261: LD_ADDR_VAR 0 5
16265: PUSH
16266: DOUBLE
16267: LD_INT 1
16269: DEC
16270: ST_TO_ADDR
16271: LD_VAR 0 2
16275: PUSH
16276: FOR_TO
16277: IFFALSE 16321
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16279: LD_ADDR_EXP 54
16283: PUSH
16284: LD_EXP 54
16288: PPUSH
16289: LD_VAR 0 1
16293: PPUSH
16294: LD_VAR 0 7
16298: PUSH
16299: LD_VAR 0 5
16303: ARRAY
16304: PUSH
16305: LD_INT 1
16307: ARRAY
16308: PPUSH
16309: LD_VAR 0 3
16313: PPUSH
16314: CALL 42241 0 4
16318: ST_TO_ADDR
// end ;
16319: GO 16276
16321: POP
16322: POP
// end ;
16323: LD_VAR 0 4
16327: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16328: LD_INT 0
16330: PPUSH
16331: PPUSH
16332: PPUSH
// b := false ;
16333: LD_ADDR_VAR 0 6
16337: PUSH
16338: LD_INT 0
16340: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16341: LD_VAR 0 3
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: LD_INT 9
16351: PUSH
16352: LD_INT 5
16354: PUSH
16355: LD_INT 8
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: LIST
16362: LIST
16363: IN
16364: IFFALSE 16452
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16366: LD_VAR 0 1
16370: PPUSH
16371: LD_INT 2
16373: PUSH
16374: LD_INT 30
16376: PUSH
16377: LD_INT 4
16379: PUSH
16380: EMPTY
16381: LIST
16382: LIST
16383: PUSH
16384: LD_INT 30
16386: PUSH
16387: LD_INT 5
16389: PUSH
16390: EMPTY
16391: LIST
16392: LIST
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: LIST
16398: PPUSH
16399: CALL 11421 0 2
16403: IFFALSE 16452
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16405: LD_ADDR_VAR 0 6
16409: PUSH
16410: LD_VAR 0 1
16414: PPUSH
16415: LD_INT 2
16417: PUSH
16418: LD_INT 30
16420: PUSH
16421: LD_INT 4
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: PUSH
16428: LD_INT 30
16430: PUSH
16431: LD_INT 5
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: PUSH
16438: EMPTY
16439: LIST
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL 11421 0 2
16447: PUSH
16448: LD_INT 1
16450: ARRAY
16451: ST_TO_ADDR
// if class = class_engineer then
16452: LD_VAR 0 3
16456: PUSH
16457: LD_INT 2
16459: EQUAL
16460: IFFALSE 16548
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16462: LD_VAR 0 1
16466: PPUSH
16467: LD_INT 2
16469: PUSH
16470: LD_INT 30
16472: PUSH
16473: LD_INT 0
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: PUSH
16480: LD_INT 30
16482: PUSH
16483: LD_INT 1
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: LIST
16494: PPUSH
16495: CALL 11421 0 2
16499: IFFALSE 16548
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16501: LD_ADDR_VAR 0 6
16505: PUSH
16506: LD_VAR 0 1
16510: PPUSH
16511: LD_INT 2
16513: PUSH
16514: LD_INT 30
16516: PUSH
16517: LD_INT 0
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: LD_INT 30
16526: PUSH
16527: LD_INT 1
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: LIST
16538: PPUSH
16539: CALL 11421 0 2
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: ST_TO_ADDR
// if class = class_mechanic then
16548: LD_VAR 0 3
16552: PUSH
16553: LD_INT 3
16555: EQUAL
16556: IFFALSE 16626
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16558: LD_VAR 0 1
16562: PPUSH
16563: LD_INT 30
16565: PUSH
16566: LD_INT 3
16568: PUSH
16569: EMPTY
16570: LIST
16571: LIST
16572: PPUSH
16573: CALL 11421 0 2
16577: IFFALSE 16626
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_VAR 0 1
16588: PPUSH
16589: LD_INT 2
16591: PUSH
16592: LD_INT 30
16594: PUSH
16595: LD_INT 2
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: LD_INT 30
16604: PUSH
16605: LD_INT 3
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PPUSH
16617: CALL 11421 0 2
16621: PUSH
16622: LD_INT 1
16624: ARRAY
16625: ST_TO_ADDR
// if class = class_scientistic then
16626: LD_VAR 0 3
16630: PUSH
16631: LD_INT 4
16633: EQUAL
16634: IFFALSE 16744
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16636: LD_VAR 0 1
16640: PPUSH
16641: LD_INT 2
16643: PUSH
16644: LD_INT 30
16646: PUSH
16647: LD_INT 6
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PUSH
16654: LD_INT 30
16656: PUSH
16657: LD_INT 7
16659: PUSH
16660: EMPTY
16661: LIST
16662: LIST
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 8
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL 11421 0 2
16684: IFFALSE 16744
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16686: LD_ADDR_VAR 0 6
16690: PUSH
16691: LD_VAR 0 1
16695: PPUSH
16696: LD_INT 2
16698: PUSH
16699: LD_INT 30
16701: PUSH
16702: LD_INT 6
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: LD_INT 30
16711: PUSH
16712: LD_INT 7
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PUSH
16719: LD_INT 30
16721: PUSH
16722: LD_INT 8
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PUSH
16729: EMPTY
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: PPUSH
16735: CALL 11421 0 2
16739: PUSH
16740: LD_INT 1
16742: ARRAY
16743: ST_TO_ADDR
// if GetClass ( unit ) = class then
16744: LD_VAR 0 2
16748: PPUSH
16749: CALL_OW 257
16753: PUSH
16754: LD_VAR 0 3
16758: EQUAL
16759: IFFALSE 16793
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16761: LD_ADDR_EXP 54
16765: PUSH
16766: LD_EXP 54
16770: PPUSH
16771: LD_VAR 0 1
16775: PPUSH
16776: LD_VAR 0 2
16780: PPUSH
16781: LD_VAR 0 3
16785: PPUSH
16786: CALL 42332 0 4
16790: ST_TO_ADDR
// end else
16791: GO 16886
// if b then
16793: LD_VAR 0 6
16797: IFFALSE 16878
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16799: LD_VAR 0 2
16803: PPUSH
16804: CALL_OW 310
16808: PUSH
16809: LD_VAR 0 2
16813: PPUSH
16814: CALL_OW 310
16818: PUSH
16819: LD_VAR 0 6
16823: NONEQUAL
16824: AND
16825: IFFALSE 16836
// ComExitBuilding ( unit ) ;
16827: LD_VAR 0 2
16831: PPUSH
16832: CALL_OW 122
// if not IsInUnit ( unit ) then
16836: LD_VAR 0 2
16840: PPUSH
16841: CALL_OW 310
16845: NOT
16846: IFFALSE 16862
// ComEnterUnit ( unit , b ) ;
16848: LD_VAR 0 2
16852: PPUSH
16853: LD_VAR 0 6
16857: PPUSH
16858: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16862: LD_VAR 0 2
16866: PPUSH
16867: LD_VAR 0 3
16871: PPUSH
16872: CALL_OW 183
// end else
16876: GO 16886
// result := false ;
16878: LD_ADDR_VAR 0 4
16882: PUSH
16883: LD_INT 0
16885: ST_TO_ADDR
// end ; end_of_file
16886: LD_VAR 0 4
16890: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16891: LD_INT 0
16893: PPUSH
16894: PPUSH
16895: PPUSH
16896: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16897: LD_ADDR_VAR 0 5
16901: PUSH
16902: LD_INT 35
16904: PUSH
16905: LD_INT 45
16907: PUSH
16908: LD_INT 46
16910: PUSH
16911: LD_INT 47
16913: PUSH
16914: LD_INT 1
16916: PUSH
16917: LD_INT 2
16919: PUSH
16920: LD_INT 48
16922: PUSH
16923: LD_INT 49
16925: PUSH
16926: LD_INT 50
16928: PUSH
16929: LD_INT 20
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: ST_TO_ADDR
// if MCF_Lab ( side ) then
16944: LD_VAR 0 1
16948: PPUSH
16949: CALL 11460 0 1
16953: IFFALSE 17192
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16955: LD_VAR 0 1
16959: PPUSH
16960: CALL 11460 0 1
16964: PUSH
16965: LD_INT 1
16967: ARRAY
16968: PPUSH
16969: CALL_OW 461
16973: PUSH
16974: LD_INT 2
16976: EQUAL
16977: IFFALSE 17116
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL 11460 0 1
16988: PUSH
16989: LD_INT 1
16991: ARRAY
16992: PPUSH
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL 17288 0 2
17002: IFFALSE 17029
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL 11460 0 1
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: LD_VAR 0 2
17022: PPUSH
17023: CALL_OW 124
17027: GO 17116
// if MCF_Lab ( side ) > 1 then
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL 11460 0 1
17038: PUSH
17039: LD_INT 1
17041: GREATER
17042: IFFALSE 17116
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17044: LD_VAR 0 1
17048: PPUSH
17049: CALL 11460 0 1
17053: PUSH
17054: LD_INT 2
17056: ARRAY
17057: PPUSH
17058: CALL_OW 461
17062: PUSH
17063: LD_INT 2
17065: EQUAL
17066: IFFALSE 17116
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17068: LD_VAR 0 1
17072: PPUSH
17073: CALL 11460 0 1
17077: PUSH
17078: LD_INT 2
17080: ARRAY
17081: PPUSH
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL 17288 0 2
17091: IFFALSE 17116
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL 11460 0 1
17102: PUSH
17103: LD_INT 2
17105: ARRAY
17106: PPUSH
17107: LD_VAR 0 2
17111: PPUSH
17112: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17116: LD_VAR 0 2
17120: PUSH
17121: LD_INT 2
17123: PUSH
17124: LD_INT 11
17126: PUSH
17127: LD_INT 4
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: IN
17139: IFFALSE 17192
// begin for lab in MCF_Lab ( side ) do
17141: LD_ADDR_VAR 0 6
17145: PUSH
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL 11460 0 1
17155: PUSH
17156: FOR_IN
17157: IFFALSE 17190
// if BuildingStatus ( lab ) = bs_need_ape then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 461
17168: PUSH
17169: LD_INT 10
17171: EQUAL
17172: IFFALSE 17188
// MCL_ResTame ( side , lab ) ;
17174: LD_VAR 0 1
17178: PPUSH
17179: LD_VAR 0 6
17183: PPUSH
17184: CALL 17413 0 2
17188: GO 17156
17190: POP
17191: POP
// end ; end ; end ;
17192: LD_VAR 0 3
17196: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17197: LD_INT 0
17199: PPUSH
17200: PPUSH
// tmp := [ ] ;
17201: LD_ADDR_VAR 0 3
17205: PUSH
17206: EMPTY
17207: ST_TO_ADDR
// if not lab then
17208: LD_VAR 0 1
17212: NOT
17213: IFFALSE 17225
// result := false else
17215: LD_ADDR_VAR 0 2
17219: PUSH
17220: LD_INT 0
17222: ST_TO_ADDR
17223: GO 17283
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17225: LD_ADDR_VAR 0 3
17229: PUSH
17230: LD_VAR 0 3
17234: PUSH
17235: LD_VAR 0 1
17239: PPUSH
17240: LD_INT 1
17242: PPUSH
17243: CALL_OW 268
17247: ADD
17248: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17249: LD_ADDR_VAR 0 3
17253: PUSH
17254: LD_VAR 0 3
17258: PUSH
17259: LD_VAR 0 1
17263: PPUSH
17264: LD_INT 2
17266: PPUSH
17267: CALL_OW 268
17271: ADD
17272: ST_TO_ADDR
// result := tmp ;
17273: LD_ADDR_VAR 0 2
17277: PUSH
17278: LD_VAR 0 3
17282: ST_TO_ADDR
// end ; end ;
17283: LD_VAR 0 2
17287: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17288: LD_INT 0
17290: PPUSH
17291: PPUSH
17292: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17293: LD_ADDR_VAR 0 5
17297: PUSH
17298: LD_INT 35
17300: PUSH
17301: LD_INT 45
17303: PUSH
17304: LD_INT 46
17306: PUSH
17307: LD_INT 47
17309: PUSH
17310: LD_INT 1
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 48
17318: PUSH
17319: LD_INT 49
17321: PUSH
17322: LD_INT 50
17324: PUSH
17325: LD_INT 20
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: LIST
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: ST_TO_ADDR
// if lab then
17340: LD_VAR 0 1
17344: IFFALSE 17400
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_VAR 0 5
17355: IN
17356: PUSH
17357: LD_VAR 0 2
17361: PPUSH
17362: CALL_OW 481
17366: PUSH
17367: LD_VAR 0 1
17371: PPUSH
17372: CALL 17197 0 1
17376: IN
17377: OR
17378: IFFALSE 17390
// result := true else
17380: LD_ADDR_VAR 0 3
17384: PUSH
17385: LD_INT 1
17387: ST_TO_ADDR
17388: GO 17398
// result := false ;
17390: LD_ADDR_VAR 0 3
17394: PUSH
17395: LD_INT 0
17397: ST_TO_ADDR
// end else
17398: GO 17408
// result := false ;
17400: LD_ADDR_VAR 0 3
17404: PUSH
17405: LD_INT 0
17407: ST_TO_ADDR
// end ;
17408: LD_VAR 0 3
17412: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17413: LD_INT 0
17415: PPUSH
17416: PPUSH
17417: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17418: LD_ADDR_VAR 0 4
17422: PUSH
17423: LD_VAR 0 1
17427: PPUSH
17428: LD_INT 171
17430: PPUSH
17431: EMPTY
17432: PPUSH
17433: CALL 12124 0 3
17437: ST_TO_ADDR
// if not ape then
17438: LD_VAR 0 4
17442: NOT
17443: IFFALSE 17475
// if MCF_Ape ( side ) then
17445: LD_VAR 0 1
17449: PPUSH
17450: CALL 11834 0 1
17454: IFFALSE 17475
// ape := MCF_Ape ( side ) [ 1 ] ;
17456: LD_ADDR_VAR 0 4
17460: PUSH
17461: LD_VAR 0 1
17465: PPUSH
17466: CALL 11834 0 1
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: ST_TO_ADDR
// if ape then
17475: LD_VAR 0 4
17479: IFFALSE 17530
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17481: LD_VAR 0 4
17485: PUSH
17486: LD_INT 1
17488: ARRAY
17489: PPUSH
17490: CALL_OW 310
17494: PUSH
17495: LD_VAR 0 4
17499: PUSH
17500: LD_INT 1
17502: ARRAY
17503: PPUSH
17504: CALL_OW 310
17508: PUSH
17509: LD_VAR 0 2
17513: NONEQUAL
17514: AND
17515: IFFALSE 17530
// ComExitBuilding ( ape [ 1 ] ) ;
17517: LD_VAR 0 4
17521: PUSH
17522: LD_INT 1
17524: ARRAY
17525: PPUSH
17526: CALL_OW 122
// if not lab then
17530: LD_VAR 0 2
17534: NOT
17535: IFFALSE 17541
// exit else
17537: GO 17689
17539: GO 17649
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17541: LD_VAR 0 1
17545: PPUSH
17546: LD_INT 16
17548: PPUSH
17549: LD_INT 25
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: PPUSH
17559: CALL 12124 0 3
17563: PUSH
17564: LD_INT 0
17566: EQUAL
17567: PUSH
17568: LD_VAR 0 2
17572: PPUSH
17573: CALL_OW 313
17577: PUSH
17578: LD_INT 6
17580: EQUAL
17581: AND
17582: IFFALSE 17649
// begin tmp := UnitsInside ( lab ) ;
17584: LD_ADDR_VAR 0 5
17588: PUSH
17589: LD_VAR 0 2
17593: PPUSH
17594: CALL_OW 313
17598: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17599: LD_VAR 0 5
17603: PUSH
17604: LD_VAR 0 5
17608: ARRAY
17609: PPUSH
17610: LD_INT 16
17612: PPUSH
17613: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17617: LD_VAR 0 5
17621: PUSH
17622: LD_VAR 0 5
17626: ARRAY
17627: PPUSH
17628: CALL_OW 310
17632: IFFALSE 17649
// ComExitBuilding ( tmp [ tmp ] ) ;
17634: LD_VAR 0 5
17638: PUSH
17639: LD_VAR 0 5
17643: ARRAY
17644: PPUSH
17645: CALL_OW 122
// end ; if ape then
17649: LD_VAR 0 4
17653: IFFALSE 17689
// if not IsInUnit ( ape [ 1 ] ) then
17655: LD_VAR 0 4
17659: PUSH
17660: LD_INT 1
17662: ARRAY
17663: PPUSH
17664: CALL_OW 310
17668: NOT
17669: IFFALSE 17689
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17671: LD_VAR 0 4
17675: PUSH
17676: LD_INT 1
17678: ARRAY
17679: PPUSH
17680: LD_VAR 0 2
17684: PPUSH
17685: CALL_OW 120
// end ;
17689: LD_VAR 0 3
17693: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17694: LD_INT 0
17696: PPUSH
17697: PPUSH
17698: PPUSH
// result := false ;
17699: LD_ADDR_VAR 0 2
17703: PUSH
17704: LD_INT 0
17706: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 1
17716: PPUSH
17717: CALL 17804 0 1
17721: ST_TO_ADDR
// if techs then
17722: LD_VAR 0 3
17726: IFFALSE 17756
// if techs [ 2 ] then
17728: LD_VAR 0 3
17732: PUSH
17733: LD_INT 2
17735: ARRAY
17736: IFFALSE 17748
// result := true else
17738: LD_ADDR_VAR 0 2
17742: PUSH
17743: LD_INT 1
17745: ST_TO_ADDR
17746: GO 17756
// result := false ;
17748: LD_ADDR_VAR 0 2
17752: PUSH
17753: LD_INT 0
17755: ST_TO_ADDR
// end ;
17756: LD_VAR 0 2
17760: RET
// export function MCL_Start ( side ) ; var i ; begin
17761: LD_INT 0
17763: PPUSH
17764: PPUSH
// if MCL_GetTechList ( side ) then
17765: LD_VAR 0 1
17769: PPUSH
17770: CALL 17804 0 1
17774: IFFALSE 17799
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17776: LD_VAR 0 1
17780: PPUSH
17781: LD_VAR 0 1
17785: PPUSH
17786: CALL 17804 0 1
17790: PUSH
17791: LD_INT 1
17793: ARRAY
17794: PPUSH
17795: CALL 16891 0 2
// end ;
17799: LD_VAR 0 2
17803: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17804: LD_INT 0
17806: PPUSH
17807: PPUSH
17808: PPUSH
// if MREG_ToRes then
17809: LD_EXP 51
17813: IFFALSE 17898
// for i = 1 to MREG_ToRes do
17815: LD_ADDR_VAR 0 3
17819: PUSH
17820: DOUBLE
17821: LD_INT 1
17823: DEC
17824: ST_TO_ADDR
17825: LD_EXP 51
17829: PUSH
17830: FOR_TO
17831: IFFALSE 17896
// if MREG_ToRes [ i ] [ 1 ] = side then
17833: LD_EXP 51
17837: PUSH
17838: LD_VAR 0 3
17842: ARRAY
17843: PUSH
17844: LD_INT 1
17846: ARRAY
17847: PUSH
17848: LD_VAR 0 1
17852: EQUAL
17853: IFFALSE 17894
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17855: LD_ADDR_VAR 0 4
17859: PUSH
17860: LD_VAR 0 4
17864: PPUSH
17865: LD_VAR 0 4
17869: PUSH
17870: LD_INT 1
17872: PLUS
17873: PPUSH
17874: LD_EXP 51
17878: PUSH
17879: LD_VAR 0 3
17883: ARRAY
17884: PUSH
17885: LD_INT 2
17887: ARRAY
17888: PPUSH
17889: CALL_OW 1
17893: ST_TO_ADDR
// end ;
17894: GO 17830
17896: POP
17897: POP
// result := techs ;
17898: LD_ADDR_VAR 0 2
17902: PUSH
17903: LD_VAR 0 4
17907: ST_TO_ADDR
// end ;
17908: LD_VAR 0 2
17912: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17913: LD_INT 0
17915: PPUSH
17916: PPUSH
// for i = 1 to tech_list do
17917: LD_ADDR_VAR 0 4
17921: PUSH
17922: DOUBLE
17923: LD_INT 1
17925: DEC
17926: ST_TO_ADDR
17927: LD_VAR 0 2
17931: PUSH
17932: FOR_TO
17933: IFFALSE 17987
// if not tech_list [ i ] = 20 then
17935: LD_VAR 0 2
17939: PUSH
17940: LD_VAR 0 4
17944: ARRAY
17945: PUSH
17946: LD_INT 20
17948: EQUAL
17949: NOT
17950: IFFALSE 17985
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17952: LD_ADDR_EXP 51
17956: PUSH
17957: LD_EXP 51
17961: PPUSH
17962: LD_VAR 0 1
17966: PPUSH
17967: LD_VAR 0 2
17971: PUSH
17972: LD_VAR 0 4
17976: ARRAY
17977: PPUSH
17978: EMPTY
17979: PPUSH
17980: CALL 42241 0 4
17984: ST_TO_ADDR
17985: GO 17932
17987: POP
17988: POP
// result := true ;
17989: LD_ADDR_VAR 0 3
17993: PUSH
17994: LD_INT 1
17996: ST_TO_ADDR
// end ;
17997: LD_VAR 0 3
18001: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18002: LD_INT 0
18004: PPUSH
18005: PPUSH
// for i = MREG_ToRes downto 1 do
18006: LD_ADDR_VAR 0 3
18010: PUSH
18011: DOUBLE
18012: LD_EXP 51
18016: INC
18017: ST_TO_ADDR
18018: LD_INT 1
18020: PUSH
18021: FOR_DOWNTO
18022: IFFALSE 18068
// if MREG_ToRes [ i ] [ 1 ] = side then
18024: LD_EXP 51
18028: PUSH
18029: LD_VAR 0 3
18033: ARRAY
18034: PUSH
18035: LD_INT 1
18037: ARRAY
18038: PUSH
18039: LD_VAR 0 1
18043: EQUAL
18044: IFFALSE 18066
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18046: LD_ADDR_EXP 51
18050: PUSH
18051: LD_EXP 51
18055: PPUSH
18056: LD_VAR 0 3
18060: PPUSH
18061: CALL_OW 3
18065: ST_TO_ADDR
18066: GO 18021
18068: POP
18069: POP
// result := true ;
18070: LD_ADDR_VAR 0 2
18074: PUSH
18075: LD_INT 1
18077: ST_TO_ADDR
// end ;
18078: LD_VAR 0 2
18082: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18083: LD_INT 0
18085: PPUSH
// result := GetTechProgress ( side , tech ) ;
18086: LD_ADDR_VAR 0 3
18090: PUSH
18091: LD_VAR 0 1
18095: PPUSH
18096: LD_VAR 0 2
18100: PPUSH
18101: CALL_OW 326
18105: ST_TO_ADDR
// end ;
18106: LD_VAR 0 3
18110: RET
// export function MCL_Require ( tech ) ; begin
18111: LD_INT 0
18113: PPUSH
// result := GetTechTechsReq ( tech ) ;
18114: LD_ADDR_VAR 0 2
18118: PUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: CALL_OW 480
18128: ST_TO_ADDR
// end ; end_of_file
18129: LD_VAR 0 2
18133: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18134: LD_INT 0
18136: PPUSH
18137: PPUSH
18138: PPUSH
// uc_side := 0 ;
18139: LD_ADDR_OWVAR 20
18143: PUSH
18144: LD_INT 0
18146: ST_TO_ADDR
// uc_nation := 0 ;
18147: LD_ADDR_OWVAR 21
18151: PUSH
18152: LD_INT 0
18154: ST_TO_ADDR
// for i = 1 to n do
18155: LD_ADDR_VAR 0 5
18159: PUSH
18160: DOUBLE
18161: LD_INT 1
18163: DEC
18164: ST_TO_ADDR
18165: LD_VAR 0 2
18169: PUSH
18170: FOR_TO
18171: IFFALSE 18316
// begin hc_importance := 0 ;
18173: LD_ADDR_OWVAR 32
18177: PUSH
18178: LD_INT 0
18180: ST_TO_ADDR
// hc_gallery :=  ;
18181: LD_ADDR_OWVAR 33
18185: PUSH
18186: LD_STRING 
18188: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18189: LD_ADDR_OWVAR 35
18193: PUSH
18194: LD_VAR 0 3
18198: PUSH
18199: LD_INT 20
18201: MINUS
18202: PPUSH
18203: LD_VAR 0 3
18207: PUSH
18208: LD_INT 20
18210: PLUS
18211: PPUSH
18212: CALL_OW 12
18216: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18217: LD_ADDR_OWVAR 31
18221: PUSH
18222: LD_INT 0
18224: PPUSH
18225: LD_INT 2
18227: PPUSH
18228: CALL_OW 12
18232: PUSH
18233: LD_INT 0
18235: PUSH
18236: LD_INT 0
18238: PUSH
18239: LD_INT 0
18241: PUSH
18242: EMPTY
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18248: LD_ADDR_OWVAR 30
18252: PUSH
18253: LD_INT 0
18255: PUSH
18256: LD_INT 0
18258: PUSH
18259: LD_INT 0
18261: PUSH
18262: LD_INT 0
18264: PUSH
18265: EMPTY
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: ST_TO_ADDR
// hc_name :=  ;
18271: LD_ADDR_OWVAR 26
18275: PUSH
18276: LD_STRING 
18278: ST_TO_ADDR
// hc_class := class_apeman ;
18279: LD_ADDR_OWVAR 28
18283: PUSH
18284: LD_INT 12
18286: ST_TO_ADDR
// ape := CreateHuman ;
18287: LD_ADDR_VAR 0 6
18291: PUSH
18292: CALL_OW 44
18296: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18297: LD_VAR 0 6
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: LD_INT 0
18309: PPUSH
18310: CALL_OW 49
// end ;
18314: GO 18170
18316: POP
18317: POP
// end ;
18318: LD_VAR 0 4
18322: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18323: LD_INT 0
18325: PPUSH
18326: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18327: LD_VAR 0 1
18331: PPUSH
18332: CALL 11834 0 1
18336: PUSH
18337: LD_EXP 38
18341: PUSH
18342: LD_VAR 0 1
18346: ARRAY
18347: GREATEREQUAL
18348: IFFALSE 18525
// begin if GetTag ( unit ) = 17 then
18350: LD_VAR 0 2
18354: PPUSH
18355: CALL_OW 110
18359: PUSH
18360: LD_INT 17
18362: EQUAL
18363: IFFALSE 18523
// begin SetTag ( unit , 0 ) ;
18365: LD_VAR 0 2
18369: PPUSH
18370: LD_INT 0
18372: PPUSH
18373: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18377: LD_VAR 0 1
18381: PPUSH
18382: CALL 11460 0 1
18386: PUSH
18387: LD_VAR 0 1
18391: PPUSH
18392: CALL 17804 0 1
18396: NOT
18397: AND
18398: IFFALSE 18423
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18400: LD_VAR 0 2
18404: PPUSH
18405: LD_VAR 0 1
18409: PPUSH
18410: CALL 11460 0 1
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18423: LD_VAR 0 1
18427: PPUSH
18428: CALL 11460 0 1
18432: NOT
18433: PUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: LD_INT 30
18441: PUSH
18442: LD_INT 1
18444: PUSH
18445: EMPTY
18446: LIST
18447: LIST
18448: PPUSH
18449: CALL 11421 0 2
18453: AND
18454: IFFALSE 18523
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18456: LD_VAR 0 2
18460: PPUSH
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 30
18468: PUSH
18469: LD_INT 1
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: PPUSH
18476: CALL 11421 0 2
18480: PUSH
18481: LD_INT 1
18483: ARRAY
18484: PPUSH
18485: CALL_OW 250
18489: PPUSH
18490: LD_VAR 0 1
18494: PPUSH
18495: LD_INT 30
18497: PUSH
18498: LD_INT 1
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: PPUSH
18505: CALL 11421 0 2
18509: PUSH
18510: LD_INT 1
18512: ARRAY
18513: PPUSH
18514: CALL_OW 251
18518: PPUSH
18519: CALL_OW 111
// end ; end else
18523: GO 18709
// if GetClass ( unit ) <> 4 then
18525: LD_VAR 0 2
18529: PPUSH
18530: CALL_OW 257
18534: PUSH
18535: LD_INT 4
18537: NONEQUAL
18538: IFFALSE 18544
// exit else
18540: GO 18709
18542: GO 18709
// if GetTag ( unit ) = 0 then
18544: LD_VAR 0 2
18548: PPUSH
18549: CALL_OW 110
18553: PUSH
18554: LD_INT 0
18556: EQUAL
18557: IFFALSE 18573
// SetTag ( unit , 17 ) else
18559: LD_VAR 0 2
18563: PPUSH
18564: LD_INT 17
18566: PPUSH
18567: CALL_OW 109
18571: GO 18709
// begin if IsInUnit ( unit ) then
18573: LD_VAR 0 2
18577: PPUSH
18578: CALL_OW 310
18582: IFFALSE 18593
// ComExitBuilding ( unit ) ;
18584: LD_VAR 0 2
18588: PPUSH
18589: CALL_OW 122
// Wait ( 1 ) ;
18593: LD_INT 1
18595: PPUSH
18596: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18600: LD_ADDR_VAR 0 4
18604: PUSH
18605: LD_INT 22
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: LD_INT 25
18617: PUSH
18618: LD_INT 12
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: PUSH
18625: EMPTY
18626: LIST
18627: LIST
18628: PPUSH
18629: CALL_OW 69
18633: PPUSH
18634: LD_VAR 0 2
18638: PPUSH
18639: CALL_OW 74
18643: ST_TO_ADDR
// if not ape then
18644: LD_VAR 0 4
18648: NOT
18649: IFFALSE 18655
// exit else
18651: GO 18709
18653: GO 18664
// ComHold ( ape ) ;
18655: LD_VAR 0 4
18659: PPUSH
18660: CALL_OW 140
// if not HasTask ( unit ) then
18664: LD_VAR 0 2
18668: PPUSH
18669: CALL_OW 314
18673: NOT
18674: IFFALSE 18707
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18676: LD_VAR 0 2
18680: PPUSH
18681: LD_VAR 0 4
18685: PPUSH
18686: CALL_OW 250
18690: PPUSH
18691: LD_VAR 0 4
18695: PPUSH
18696: CALL_OW 251
18700: PPUSH
18701: CALL_OW 131
18705: GO 18709
// exit ;
18707: GO 18709
// end ; end ;
18709: LD_VAR 0 3
18713: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18714: LD_INT 0
18716: PPUSH
18717: PPUSH
18718: PPUSH
18719: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18720: LD_ADDR_VAR 0 4
18724: PUSH
18725: LD_EXP 39
18729: PUSH
18730: LD_VAR 0 1
18734: ARRAY
18735: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18736: LD_ADDR_VAR 0 5
18740: PUSH
18741: LD_VAR 0 1
18745: PPUSH
18746: LD_STRING normal
18748: PPUSH
18749: CALL 11918 0 2
18753: ST_TO_ADDR
// if apes then
18754: LD_VAR 0 5
18758: IFFALSE 18986
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18760: LD_INT 2
18762: PPUSH
18763: LD_VAR 0 1
18767: PPUSH
18768: CALL_OW 321
18772: PUSH
18773: LD_INT 2
18775: EQUAL
18776: PUSH
18777: LD_VAR 0 4
18781: PUSH
18782: LD_INT 2
18784: ARRAY
18785: PUSH
18786: LD_INT 1
18788: EQUAL
18789: AND
18790: PUSH
18791: LD_VAR 0 1
18795: PPUSH
18796: LD_STRING engineer
18798: PPUSH
18799: CALL 11918 0 2
18803: PUSH
18804: LD_INT 3
18806: LESS
18807: AND
18808: PUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: LD_INT 30
18816: PUSH
18817: LD_INT 1
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL 11421 0 2
18828: AND
18829: IFFALSE 18883
// begin for i in apes do
18831: LD_ADDR_VAR 0 3
18835: PUSH
18836: LD_VAR 0 5
18840: PUSH
18841: FOR_IN
18842: IFFALSE 18879
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18844: LD_VAR 0 3
18848: PPUSH
18849: LD_VAR 0 1
18853: PPUSH
18854: LD_INT 30
18856: PUSH
18857: LD_INT 1
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PPUSH
18864: CALL 11421 0 2
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: PPUSH
18873: CALL_OW 120
// end ;
18877: GO 18841
18879: POP
18880: POP
// end else
18881: GO 18986
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18883: LD_INT 11
18885: PPUSH
18886: LD_VAR 0 1
18890: PPUSH
18891: CALL_OW 321
18895: PUSH
18896: LD_INT 2
18898: EQUAL
18899: PUSH
18900: LD_VAR 0 4
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: PUSH
18909: LD_INT 1
18911: EQUAL
18912: AND
18913: PUSH
18914: LD_VAR 0 1
18918: PPUSH
18919: LD_INT 30
18921: PUSH
18922: LD_INT 5
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: PPUSH
18929: CALL 11421 0 2
18933: AND
18934: IFFALSE 18986
// begin for i in apes do
18936: LD_ADDR_VAR 0 3
18940: PUSH
18941: LD_VAR 0 5
18945: PUSH
18946: FOR_IN
18947: IFFALSE 18984
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18949: LD_VAR 0 3
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: LD_INT 30
18961: PUSH
18962: LD_INT 5
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: PPUSH
18969: CALL 11421 0 2
18973: PUSH
18974: LD_INT 1
18976: ARRAY
18977: PPUSH
18978: CALL_OW 120
// end ;
18982: GO 18946
18984: POP
18985: POP
// end ; end ; end ; end_of_file
18986: LD_VAR 0 2
18990: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18991: LD_INT 0
18993: PPUSH
18994: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18995: LD_VAR 0 1
18999: PPUSH
19000: CALL_OW 257
19004: PUSH
19005: LD_INT 4
19007: EQUAL
19008: NOT
19009: PUSH
19010: LD_VAR 0 2
19014: NOT
19015: OR
19016: IFFALSE 19022
// exit else
19018: GO 19056
19020: GO 19056
// if not GetTag ( unit ) = 4 then
19022: LD_VAR 0 1
19026: PPUSH
19027: CALL_OW 110
19031: PUSH
19032: LD_INT 4
19034: EQUAL
19035: NOT
19036: IFFALSE 19042
// exit else
19038: GO 19056
19040: GO 19056
// ComHeal ( unit , target ) ;
19042: LD_VAR 0 1
19046: PPUSH
19047: LD_VAR 0 2
19051: PPUSH
19052: CALL_OW 128
// end ;
19056: LD_VAR 0 3
19060: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
19068: PPUSH
19069: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19070: LD_ADDR_VAR 0 5
19074: PUSH
19075: LD_INT 22
19077: PUSH
19078: LD_VAR 0 1
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PUSH
19087: LD_INT 21
19089: PUSH
19090: LD_INT 1
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: PUSH
19097: LD_INT 3
19099: PUSH
19100: LD_INT 55
19102: PUSH
19103: EMPTY
19104: LIST
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PUSH
19110: LD_INT 3
19112: PUSH
19113: LD_INT 54
19115: PUSH
19116: EMPTY
19117: LIST
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: PUSH
19123: LD_INT 3
19125: PUSH
19126: LD_INT 24
19128: PUSH
19129: LD_INT 1000
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: PUSH
19136: EMPTY
19137: LIST
19138: LIST
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: LIST
19146: PPUSH
19147: CALL_OW 69
19151: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19152: LD_ADDR_VAR 0 8
19156: PUSH
19157: LD_VAR 0 1
19161: PPUSH
19162: LD_INT 30
19164: PUSH
19165: LD_INT 1
19167: PUSH
19168: EMPTY
19169: LIST
19170: LIST
19171: PPUSH
19172: CALL 11421 0 2
19176: ST_TO_ADDR
// r := [ ] ;
19177: LD_ADDR_VAR 0 6
19181: PUSH
19182: EMPTY
19183: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 5
19191: PPUSH
19192: EMPTY
19193: PPUSH
19194: CALL 12124 0 3
19198: IFFALSE 19254
// for j in MCF_Tag ( side , 5 , [ ] ) do
19200: LD_ADDR_VAR 0 4
19204: PUSH
19205: LD_VAR 0 1
19209: PPUSH
19210: LD_INT 5
19212: PPUSH
19213: EMPTY
19214: PPUSH
19215: CALL 12124 0 3
19219: PUSH
19220: FOR_IN
19221: IFFALSE 19252
// if GetLives ( j ) = 1000 then
19223: LD_VAR 0 4
19227: PPUSH
19228: CALL_OW 256
19232: PUSH
19233: LD_INT 1000
19235: EQUAL
19236: IFFALSE 19250
// SetTag ( j , 0 ) ;
19238: LD_VAR 0 4
19242: PPUSH
19243: LD_INT 0
19245: PPUSH
19246: CALL_OW 109
19250: GO 19220
19252: POP
19253: POP
// if tmp then
19254: LD_VAR 0 5
19258: IFFALSE 19587
// begin r := [ tmp [ 1 ] ] ;
19260: LD_ADDR_VAR 0 6
19264: PUSH
19265: LD_VAR 0 5
19269: PUSH
19270: LD_INT 1
19272: ARRAY
19273: PUSH
19274: EMPTY
19275: LIST
19276: ST_TO_ADDR
// for i = 2 to tmp do
19277: LD_ADDR_VAR 0 3
19281: PUSH
19282: DOUBLE
19283: LD_INT 2
19285: DEC
19286: ST_TO_ADDR
19287: LD_VAR 0 5
19291: PUSH
19292: FOR_TO
19293: IFFALSE 19585
// begin m := false ;
19295: LD_ADDR_VAR 0 7
19299: PUSH
19300: LD_INT 0
19302: ST_TO_ADDR
// if d then
19303: LD_VAR 0 8
19307: IFFALSE 19462
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19309: LD_VAR 0 5
19313: PUSH
19314: LD_VAR 0 3
19318: ARRAY
19319: PPUSH
19320: CALL_OW 256
19324: PUSH
19325: LD_INT 650
19327: LESS
19328: PUSH
19329: LD_VAR 0 5
19333: PUSH
19334: LD_VAR 0 3
19338: ARRAY
19339: PPUSH
19340: LD_VAR 0 8
19344: PUSH
19345: LD_INT 1
19347: ARRAY
19348: PPUSH
19349: CALL_OW 250
19353: PPUSH
19354: LD_VAR 0 8
19358: PUSH
19359: LD_INT 1
19361: ARRAY
19362: PPUSH
19363: CALL_OW 251
19367: PPUSH
19368: CALL_OW 297
19372: PUSH
19373: LD_INT 10
19375: GREATER
19376: AND
19377: IFFALSE 19462
// begin if not GetTag ( tmp [ i ] ) = 5 then
19379: LD_VAR 0 5
19383: PUSH
19384: LD_VAR 0 3
19388: ARRAY
19389: PPUSH
19390: CALL_OW 110
19394: PUSH
19395: LD_INT 5
19397: EQUAL
19398: NOT
19399: IFFALSE 19419
// SetTag ( tmp [ i ] , 5 ) ;
19401: LD_VAR 0 5
19405: PUSH
19406: LD_VAR 0 3
19410: ARRAY
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19419: LD_VAR 0 5
19423: PUSH
19424: LD_VAR 0 3
19428: ARRAY
19429: PPUSH
19430: LD_VAR 0 8
19434: PUSH
19435: LD_INT 1
19437: ARRAY
19438: PPUSH
19439: CALL_OW 250
19443: PPUSH
19444: LD_VAR 0 8
19448: PUSH
19449: LD_INT 1
19451: ARRAY
19452: PPUSH
19453: CALL_OW 251
19457: PPUSH
19458: CALL_OW 111
// end ; for j = 1 to r do
19462: LD_ADDR_VAR 0 4
19466: PUSH
19467: DOUBLE
19468: LD_INT 1
19470: DEC
19471: ST_TO_ADDR
19472: LD_VAR 0 6
19476: PUSH
19477: FOR_TO
19478: IFFALSE 19552
// if GetLives ( tmp [ i ] ) < r [ j ] then
19480: LD_VAR 0 5
19484: PUSH
19485: LD_VAR 0 3
19489: ARRAY
19490: PPUSH
19491: CALL_OW 256
19495: PUSH
19496: LD_VAR 0 6
19500: PUSH
19501: LD_VAR 0 4
19505: ARRAY
19506: LESS
19507: IFFALSE 19550
// begin r := Insert ( r , j , tmp [ i ] ) ;
19509: LD_ADDR_VAR 0 6
19513: PUSH
19514: LD_VAR 0 6
19518: PPUSH
19519: LD_VAR 0 4
19523: PPUSH
19524: LD_VAR 0 5
19528: PUSH
19529: LD_VAR 0 3
19533: ARRAY
19534: PPUSH
19535: CALL_OW 2
19539: ST_TO_ADDR
// m := true ;
19540: LD_ADDR_VAR 0 7
19544: PUSH
19545: LD_INT 1
19547: ST_TO_ADDR
// break ;
19548: GO 19552
// end ;
19550: GO 19477
19552: POP
19553: POP
// if not m then
19554: LD_VAR 0 7
19558: NOT
19559: IFFALSE 19583
// r := r ^ tmp [ i ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_VAR 0 6
19570: PUSH
19571: LD_VAR 0 5
19575: PUSH
19576: LD_VAR 0 3
19580: ARRAY
19581: ADD
19582: ST_TO_ADDR
// end ;
19583: GO 19292
19585: POP
19586: POP
// end ; result := r end ; end_of_file
19587: LD_ADDR_VAR 0 2
19591: PUSH
19592: LD_VAR 0 6
19596: ST_TO_ADDR
19597: LD_VAR 0 2
19601: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19602: LD_INT 0
19604: PPUSH
19605: PPUSH
19606: PPUSH
// pom := GetBase ( bdepot ) ;
19607: LD_ADDR_VAR 0 3
19611: PUSH
19612: LD_VAR 0 1
19616: PPUSH
19617: CALL_OW 274
19621: ST_TO_ADDR
// sor := [ ] ;
19622: LD_ADDR_VAR 0 4
19626: PUSH
19627: EMPTY
19628: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19629: LD_ADDR_VAR 0 4
19633: PUSH
19634: LD_VAR 0 4
19638: PUSH
19639: LD_VAR 0 3
19643: PPUSH
19644: LD_INT 1
19646: PPUSH
19647: CALL_OW 275
19651: ADD
19652: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19653: LD_ADDR_VAR 0 4
19657: PUSH
19658: LD_VAR 0 4
19662: PUSH
19663: LD_VAR 0 3
19667: PPUSH
19668: LD_INT 2
19670: PPUSH
19671: CALL_OW 275
19675: ADD
19676: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19677: LD_ADDR_VAR 0 4
19681: PUSH
19682: LD_VAR 0 4
19686: PUSH
19687: LD_VAR 0 3
19691: PPUSH
19692: LD_INT 3
19694: PPUSH
19695: CALL_OW 275
19699: ADD
19700: ST_TO_ADDR
// result := sor ;
19701: LD_ADDR_VAR 0 2
19705: PUSH
19706: LD_VAR 0 4
19710: ST_TO_ADDR
// end ;
19711: LD_VAR 0 2
19715: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19716: LD_INT 0
19718: PPUSH
19719: PPUSH
// while ( coord_list ) do
19720: LD_VAR 0 3
19724: IFFALSE 19898
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19726: LD_ADDR_EXP 47
19730: PUSH
19731: LD_EXP 47
19735: PPUSH
19736: LD_VAR 0 1
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: LD_VAR 0 3
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: LD_VAR 0 3
19759: PUSH
19760: LD_INT 2
19762: ARRAY
19763: PUSH
19764: LD_VAR 0 3
19768: PUSH
19769: LD_INT 3
19771: ARRAY
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL 42241 0 4
19782: ST_TO_ADDR
// if weapon_list then
19783: LD_VAR 0 4
19787: IFFALSE 19858
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19789: LD_ADDR_EXP 44
19793: PUSH
19794: LD_EXP 44
19798: PPUSH
19799: LD_VAR 0 1
19803: PPUSH
19804: LD_VAR 0 4
19808: PUSH
19809: LD_INT 1
19811: ARRAY
19812: PPUSH
19813: LD_VAR 0 3
19817: PUSH
19818: LD_INT 1
19820: ARRAY
19821: PUSH
19822: LD_VAR 0 3
19826: PUSH
19827: LD_INT 2
19829: ARRAY
19830: PUSH
19831: EMPTY
19832: LIST
19833: LIST
19834: PPUSH
19835: CALL 42241 0 4
19839: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19840: LD_ADDR_VAR 0 4
19844: PUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: LD_INT 1
19852: PPUSH
19853: CALL_OW 3
19857: ST_TO_ADDR
// end ; for i = 1 to 3 do
19858: LD_ADDR_VAR 0 6
19862: PUSH
19863: DOUBLE
19864: LD_INT 1
19866: DEC
19867: ST_TO_ADDR
19868: LD_INT 3
19870: PUSH
19871: FOR_TO
19872: IFFALSE 19894
// coord_list := Delete ( coord_list , 1 ) ;
19874: LD_ADDR_VAR 0 3
19878: PUSH
19879: LD_VAR 0 3
19883: PPUSH
19884: LD_INT 1
19886: PPUSH
19887: CALL_OW 3
19891: ST_TO_ADDR
19892: GO 19871
19894: POP
19895: POP
// end ;
19896: GO 19720
// result := true ;
19898: LD_ADDR_VAR 0 5
19902: PUSH
19903: LD_INT 1
19905: ST_TO_ADDR
// end ;
19906: LD_VAR 0 5
19910: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19911: LD_INT 0
19913: PPUSH
19914: PPUSH
// if not weapon_list then
19915: LD_VAR 0 3
19919: NOT
19920: IFFALSE 19924
// exit ;
19922: GO 20039
// while ( coord_list ) do
19924: LD_VAR 0 2
19928: IFFALSE 20039
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19930: LD_ADDR_EXP 44
19934: PUSH
19935: LD_EXP 44
19939: PPUSH
19940: LD_VAR 0 1
19944: PPUSH
19945: LD_VAR 0 3
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PPUSH
19954: LD_VAR 0 2
19958: PUSH
19959: LD_INT 1
19961: ARRAY
19962: PUSH
19963: LD_VAR 0 2
19967: PUSH
19968: LD_INT 2
19970: ARRAY
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: PPUSH
19976: CALL 42241 0 4
19980: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19981: LD_ADDR_VAR 0 3
19985: PUSH
19986: LD_VAR 0 3
19990: PPUSH
19991: LD_INT 1
19993: PPUSH
19994: CALL_OW 3
19998: ST_TO_ADDR
// for i = 1 to 2 do
19999: LD_ADDR_VAR 0 5
20003: PUSH
20004: DOUBLE
20005: LD_INT 1
20007: DEC
20008: ST_TO_ADDR
20009: LD_INT 2
20011: PUSH
20012: FOR_TO
20013: IFFALSE 20035
// coord_list := Delete ( coord_list , 1 ) ;
20015: LD_ADDR_VAR 0 2
20019: PUSH
20020: LD_VAR 0 2
20024: PPUSH
20025: LD_INT 1
20027: PPUSH
20028: CALL_OW 3
20032: ST_TO_ADDR
20033: GO 20012
20035: POP
20036: POP
// end ;
20037: GO 19924
// end ;
20039: LD_VAR 0 4
20043: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20044: LD_INT 0
20046: PPUSH
20047: PPUSH
// while ( coord_list ) do
20048: LD_VAR 0 2
20052: IFFALSE 20207
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20054: LD_VAR 0 2
20058: PUSH
20059: LD_INT 1
20061: ARRAY
20062: PPUSH
20063: LD_VAR 0 2
20067: PUSH
20068: LD_INT 2
20070: ARRAY
20071: PPUSH
20072: CALL_OW 428
20076: IFFALSE 20167
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20078: LD_VAR 0 2
20082: PUSH
20083: LD_INT 1
20085: ARRAY
20086: PPUSH
20087: LD_VAR 0 2
20091: PUSH
20092: LD_INT 2
20094: ARRAY
20095: PPUSH
20096: CALL_OW 428
20100: PPUSH
20101: CALL_OW 266
20105: PUSH
20106: LD_INT 31
20108: PUSH
20109: LD_INT 32
20111: PUSH
20112: LD_INT 33
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: LIST
20119: IN
20120: IFFALSE 20167
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20122: LD_ADDR_EXP 53
20126: PUSH
20127: LD_EXP 53
20131: PPUSH
20132: LD_VAR 0 1
20136: PPUSH
20137: LD_VAR 0 2
20141: PUSH
20142: LD_INT 1
20144: ARRAY
20145: PPUSH
20146: LD_VAR 0 2
20150: PUSH
20151: LD_INT 2
20153: ARRAY
20154: PPUSH
20155: CALL_OW 428
20159: PPUSH
20160: EMPTY
20161: PPUSH
20162: CALL 42241 0 4
20166: ST_TO_ADDR
// for i = 1 to 3 do
20167: LD_ADDR_VAR 0 4
20171: PUSH
20172: DOUBLE
20173: LD_INT 1
20175: DEC
20176: ST_TO_ADDR
20177: LD_INT 3
20179: PUSH
20180: FOR_TO
20181: IFFALSE 20203
// coord_list := Delete ( coord_list , 1 ) ;
20183: LD_ADDR_VAR 0 2
20187: PUSH
20188: LD_VAR 0 2
20192: PPUSH
20193: LD_INT 1
20195: PPUSH
20196: CALL_OW 3
20200: ST_TO_ADDR
20201: GO 20180
20203: POP
20204: POP
// end ;
20205: GO 20048
// result := true ;
20207: LD_ADDR_VAR 0 3
20211: PUSH
20212: LD_INT 1
20214: ST_TO_ADDR
// end ;
20215: LD_VAR 0 3
20219: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20220: LD_INT 0
20222: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20223: LD_ADDR_EXP 47
20227: PUSH
20228: LD_EXP 47
20232: PPUSH
20233: LD_VAR 0 1
20237: PPUSH
20238: LD_INT 0
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: CALL 42241 0 4
20250: ST_TO_ADDR
// end ;
20251: LD_VAR 0 3
20255: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20256: LD_INT 0
20258: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20259: LD_ADDR_EXP 47
20263: PUSH
20264: LD_EXP 47
20268: PPUSH
20269: LD_VAR 0 1
20273: PPUSH
20274: LD_INT 6
20276: PPUSH
20277: LD_VAR 0 2
20281: PPUSH
20282: CALL 42241 0 4
20286: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20287: LD_ADDR_EXP 50
20291: PUSH
20292: LD_EXP 50
20296: PPUSH
20297: LD_VAR 0 1
20301: PPUSH
20302: LD_VAR 0 3
20306: PUSH
20307: LD_INT 1
20309: ARRAY
20310: PPUSH
20311: LD_VAR 0 3
20315: PUSH
20316: LD_INT 2
20318: ARRAY
20319: PPUSH
20320: CALL 42241 0 4
20324: ST_TO_ADDR
// end ;
20325: LD_VAR 0 4
20329: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20330: LD_INT 0
20332: PPUSH
20333: PPUSH
// if ext_list > 5 then
20334: LD_VAR 0 3
20338: PUSH
20339: LD_INT 5
20341: GREATER
20342: IFFALSE 20386
// for i = 6 to ext_list do
20344: LD_ADDR_VAR 0 5
20348: PUSH
20349: DOUBLE
20350: LD_INT 6
20352: DEC
20353: ST_TO_ADDR
20354: LD_VAR 0 3
20358: PUSH
20359: FOR_TO
20360: IFFALSE 20384
// ext_list := Delete ( ext_list , ext_list ) ;
20362: LD_ADDR_VAR 0 3
20366: PUSH
20367: LD_VAR 0 3
20371: PPUSH
20372: LD_VAR 0 3
20376: PPUSH
20377: CALL_OW 3
20381: ST_TO_ADDR
20382: GO 20359
20384: POP
20385: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20386: LD_VAR 0 1
20390: PPUSH
20391: LD_VAR 0 2
20395: PUSH
20396: LD_INT 1
20398: ARRAY
20399: PPUSH
20400: LD_VAR 0 2
20404: PUSH
20405: LD_INT 2
20407: ARRAY
20408: PPUSH
20409: LD_VAR 0 2
20413: PUSH
20414: LD_INT 3
20416: ARRAY
20417: PPUSH
20418: LD_VAR 0 3
20422: PPUSH
20423: CALL 8933 0 5
// end ;
20427: LD_VAR 0 4
20431: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20432: LD_INT 0
20434: PPUSH
20435: PPUSH
20436: PPUSH
// p := 1 ;
20437: LD_ADDR_VAR 0 6
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// if type_list = [ ] then
20445: LD_VAR 0 3
20449: PUSH
20450: EMPTY
20451: EQUAL
20452: IFFALSE 20462
// type_list := b_oil_power ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 26
20461: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20462: LD_ADDR_VAR 0 5
20466: PUSH
20467: DOUBLE
20468: LD_INT 1
20470: DEC
20471: ST_TO_ADDR
20472: LD_VAR 0 2
20476: PUSH
20477: LD_INT 3
20479: DIVREAL
20480: PUSH
20481: FOR_TO
20482: IFFALSE 20585
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20484: LD_ADDR_EXP 47
20488: PUSH
20489: LD_EXP 47
20493: PPUSH
20494: LD_VAR 0 1
20498: PPUSH
20499: LD_VAR 0 3
20503: PUSH
20504: LD_INT 1
20506: PPUSH
20507: LD_VAR 0 3
20511: PPUSH
20512: CALL_OW 12
20516: ARRAY
20517: PPUSH
20518: LD_VAR 0 2
20522: PUSH
20523: LD_VAR 0 6
20527: ARRAY
20528: PUSH
20529: LD_VAR 0 2
20533: PUSH
20534: LD_VAR 0 6
20538: PUSH
20539: LD_INT 1
20541: PLUS
20542: ARRAY
20543: PUSH
20544: LD_VAR 0 2
20548: PUSH
20549: LD_VAR 0 6
20553: PUSH
20554: LD_INT 2
20556: PLUS
20557: ARRAY
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: LIST
20563: PPUSH
20564: CALL 42241 0 4
20568: ST_TO_ADDR
// p := p + 3 ;
20569: LD_ADDR_VAR 0 6
20573: PUSH
20574: LD_VAR 0 6
20578: PUSH
20579: LD_INT 3
20581: PLUS
20582: ST_TO_ADDR
// end ;
20583: GO 20481
20585: POP
20586: POP
// end ;
20587: LD_VAR 0 4
20591: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20592: LD_INT 0
20594: PPUSH
20595: PPUSH
20596: PPUSH
20597: PPUSH
// if not MREG_Deposit [ side ] then
20598: LD_EXP 62
20602: PUSH
20603: LD_VAR 0 1
20607: ARRAY
20608: NOT
20609: IFFALSE 20613
// exit ;
20611: GO 20790
// p := 1 ;
20613: LD_ADDR_VAR 0 4
20617: PUSH
20618: LD_INT 1
20620: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20621: LD_ADDR_VAR 0 3
20625: PUSH
20626: DOUBLE
20627: LD_INT 1
20629: DEC
20630: ST_TO_ADDR
20631: LD_EXP 62
20635: PUSH
20636: LD_VAR 0 1
20640: ARRAY
20641: PUSH
20642: LD_INT 3
20644: DIVREAL
20645: PUSH
20646: FOR_TO
20647: IFFALSE 20788
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20649: LD_EXP 62
20653: PUSH
20654: LD_VAR 0 1
20658: ARRAY
20659: PUSH
20660: LD_VAR 0 4
20664: PUSH
20665: LD_INT 2
20667: PLUS
20668: ARRAY
20669: PUSH
20670: LD_INT 2
20672: EQUAL
20673: IFFALSE 20685
// b := b_oil_mine else
20675: LD_ADDR_VAR 0 5
20679: PUSH
20680: LD_INT 29
20682: ST_TO_ADDR
20683: GO 20693
// b := b_siberite_mine ;
20685: LD_ADDR_VAR 0 5
20689: PUSH
20690: LD_INT 30
20692: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20693: LD_ADDR_EXP 47
20697: PUSH
20698: LD_EXP 47
20702: PPUSH
20703: LD_VAR 0 1
20707: PPUSH
20708: LD_VAR 0 5
20712: PPUSH
20713: LD_EXP 62
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_VAR 0 4
20728: ARRAY
20729: PUSH
20730: LD_EXP 62
20734: PUSH
20735: LD_VAR 0 1
20739: ARRAY
20740: PUSH
20741: LD_VAR 0 4
20745: PUSH
20746: LD_INT 1
20748: PLUS
20749: ARRAY
20750: PUSH
20751: LD_INT 0
20753: PPUSH
20754: LD_INT 5
20756: PPUSH
20757: CALL_OW 12
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: LIST
20766: PPUSH
20767: CALL 42241 0 4
20771: ST_TO_ADDR
// p := p + 3 ;
20772: LD_ADDR_VAR 0 4
20776: PUSH
20777: LD_VAR 0 4
20781: PUSH
20782: LD_INT 3
20784: PLUS
20785: ST_TO_ADDR
// end ;
20786: GO 20646
20788: POP
20789: POP
// end ;
20790: LD_VAR 0 2
20794: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20795: LD_INT 0
20797: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20798: LD_ADDR_EXP 47
20802: PUSH
20803: LD_EXP 47
20807: PPUSH
20808: LD_VAR 0 1
20812: PPUSH
20813: LD_INT 4
20815: PPUSH
20816: LD_VAR 0 2
20820: PPUSH
20821: CALL 42241 0 4
20825: ST_TO_ADDR
// end ;
20826: LD_VAR 0 3
20830: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20831: LD_INT 0
20833: PPUSH
// case nation of 1 , us :
20834: LD_VAR 0 2
20838: PUSH
20839: LD_INT 1
20841: DOUBLE
20842: EQUAL
20843: IFTRUE 20853
20845: LD_STRING us
20847: DOUBLE
20848: EQUAL
20849: IFTRUE 20853
20851: GO 20884
20853: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20854: LD_ADDR_EXP 47
20858: PUSH
20859: LD_EXP 47
20863: PPUSH
20864: LD_VAR 0 1
20868: PPUSH
20869: LD_INT 36
20871: PPUSH
20872: LD_VAR 0 3
20876: PPUSH
20877: CALL 42241 0 4
20881: ST_TO_ADDR
20882: GO 20935
20884: LD_INT 2
20886: DOUBLE
20887: EQUAL
20888: IFTRUE 20898
20890: LD_STRING ar
20892: DOUBLE
20893: EQUAL
20894: IFTRUE 20898
20896: GO 20934
20898: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20899: LD_ADDR_EXP 47
20903: PUSH
20904: LD_VAR 0 1
20908: PPUSH
20909: LD_INT 14
20911: PUSH
20912: LD_INT 2
20914: PUSH
20915: LD_INT 1
20917: PUSH
20918: LD_INT 31
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: LIST
20925: LIST
20926: PPUSH
20927: CALL 20940 0 2
20931: ST_TO_ADDR
20932: GO 20935
20934: POP
// end ;
20935: LD_VAR 0 4
20939: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20940: LD_INT 0
20942: PPUSH
20943: PPUSH
// for i = 1 to list do
20944: LD_ADDR_VAR 0 4
20948: PUSH
20949: DOUBLE
20950: LD_INT 1
20952: DEC
20953: ST_TO_ADDR
20954: LD_VAR 0 2
20958: PUSH
20959: FOR_TO
20960: IFFALSE 21010
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20962: LD_ADDR_EXP 52
20966: PUSH
20967: LD_EXP 52
20971: PPUSH
20972: LD_VAR 0 1
20976: PPUSH
20977: LD_EXP 52
20981: PUSH
20982: LD_VAR 0 1
20986: ARRAY
20987: PUSH
20988: LD_INT 1
20990: PLUS
20991: PPUSH
20992: LD_VAR 0 2
20996: PUSH
20997: LD_VAR 0 4
21001: ARRAY
21002: PPUSH
21003: CALL 30959 0 4
21007: ST_TO_ADDR
21008: GO 20959
21010: POP
21011: POP
// end ;
21012: LD_VAR 0 3
21016: RET
// export function MCS_GetVehicleList ( side ) ; begin
21017: LD_INT 0
21019: PPUSH
// result := MREG_ToConstruct [ side ] ;
21020: LD_ADDR_VAR 0 2
21024: PUSH
21025: LD_EXP 52
21029: PUSH
21030: LD_VAR 0 1
21034: ARRAY
21035: ST_TO_ADDR
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21041: LD_INT 0
21043: PPUSH
21044: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21045: LD_ADDR_EXP 59
21049: PUSH
21050: LD_EXP 59
21054: PPUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: LD_VAR 0 2
21064: PPUSH
21065: CALL_OW 1
21069: ST_TO_ADDR
// end ;
21070: LD_VAR 0 3
21074: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21075: LD_INT 0
21077: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21078: LD_ADDR_EXP 38
21082: PUSH
21083: LD_EXP 38
21087: PPUSH
21088: LD_VAR 0 1
21092: PPUSH
21093: LD_VAR 0 2
21097: PPUSH
21098: CALL_OW 1
21102: ST_TO_ADDR
// end ;
21103: LD_VAR 0 3
21107: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21108: LD_INT 0
21110: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21111: LD_ADDR_EXP 39
21115: PUSH
21116: LD_EXP 39
21120: PPUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: LD_VAR 0 2
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 3
21140: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21141: LD_INT 0
21143: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21144: LD_ADDR_EXP 61
21148: PUSH
21149: LD_EXP 61
21153: PPUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: LD_INT 1
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: CALL 30959 0 4
21171: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21172: LD_ADDR_EXP 61
21176: PUSH
21177: LD_EXP 61
21181: PPUSH
21182: LD_VAR 0 1
21186: PPUSH
21187: LD_INT 2
21189: PPUSH
21190: LD_VAR 0 3
21194: PPUSH
21195: CALL 30959 0 4
21199: ST_TO_ADDR
// end ;
21200: LD_VAR 0 4
21204: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21205: LD_INT 0
21207: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21208: LD_ADDR_EXP 73
21212: PUSH
21213: LD_EXP 73
21217: PPUSH
21218: LD_INT 1
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: CALL_OW 1
21230: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21231: LD_ADDR_EXP 73
21235: PUSH
21236: LD_EXP 73
21240: PPUSH
21241: LD_INT 2
21243: PPUSH
21244: LD_VAR 0 2
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21254: LD_ADDR_EXP 73
21258: PUSH
21259: LD_EXP 73
21263: PPUSH
21264: LD_INT 3
21266: PPUSH
21267: LD_VAR 0 3
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: LD_VAR 0 4
21281: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21282: LD_INT 0
21284: PPUSH
21285: PPUSH
21286: PPUSH
// if not side or not list then
21287: LD_VAR 0 1
21291: NOT
21292: PUSH
21293: LD_VAR 0 2
21297: NOT
21298: OR
21299: IFFALSE 21303
// exit ;
21301: GO 21471
// SetTech ( 20 , side , state_researched ) ;
21303: LD_INT 20
21305: PPUSH
21306: LD_VAR 0 1
21310: PPUSH
21311: LD_INT 2
21313: PPUSH
21314: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21318: LD_ADDR_EXP 62
21322: PUSH
21323: LD_EXP 62
21327: PPUSH
21328: LD_VAR 0 1
21332: PPUSH
21333: LD_VAR 0 2
21337: PPUSH
21338: CALL_OW 2
21342: ST_TO_ADDR
// p := 1 ;
21343: LD_ADDR_VAR 0 5
21347: PUSH
21348: LD_INT 1
21350: ST_TO_ADDR
// for i = 1 to list / 3 do
21351: LD_ADDR_VAR 0 4
21355: PUSH
21356: DOUBLE
21357: LD_INT 1
21359: DEC
21360: ST_TO_ADDR
21361: LD_VAR 0 2
21365: PUSH
21366: LD_INT 3
21368: DIVREAL
21369: PUSH
21370: FOR_TO
21371: IFFALSE 21469
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21373: LD_VAR 0 2
21377: PUSH
21378: LD_VAR 0 5
21382: ARRAY
21383: PPUSH
21384: LD_VAR 0 2
21388: PUSH
21389: LD_VAR 0 5
21393: PUSH
21394: LD_INT 1
21396: PLUS
21397: ARRAY
21398: PPUSH
21399: LD_VAR 0 2
21403: PUSH
21404: LD_VAR 0 5
21408: PUSH
21409: LD_INT 2
21411: PLUS
21412: ARRAY
21413: PPUSH
21414: CALL 22173 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21418: LD_VAR 0 2
21422: PUSH
21423: LD_VAR 0 5
21427: ARRAY
21428: PPUSH
21429: LD_VAR 0 2
21433: PUSH
21434: LD_VAR 0 5
21438: PUSH
21439: LD_INT 1
21441: PLUS
21442: ARRAY
21443: PPUSH
21444: LD_VAR 0 1
21448: PPUSH
21449: CALL_OW 441
// p := p + 3 ;
21453: LD_ADDR_VAR 0 5
21457: PUSH
21458: LD_VAR 0 5
21462: PUSH
21463: LD_INT 3
21465: PLUS
21466: ST_TO_ADDR
// end ;
21467: GO 21370
21469: POP
21470: POP
// end ;
21471: LD_VAR 0 3
21475: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
// if nat = nation_arabian then
21480: LD_VAR 0 2
21484: PUSH
21485: LD_INT 2
21487: EQUAL
21488: IFFALSE 21494
// exit else
21490: GO 21566
21492: GO 21552
// if nat = nation_american then
21494: LD_VAR 0 2
21498: PUSH
21499: LD_INT 1
21501: EQUAL
21502: IFFALSE 21529
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21504: LD_ADDR_VAR 0 4
21508: PUSH
21509: LD_INT 4
21511: PUSH
21512: LD_INT 3
21514: PUSH
21515: LD_INT 1
21517: PUSH
21518: LD_INT 8
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: LIST
21525: LIST
21526: ST_TO_ADDR
21527: GO 21552
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21529: LD_ADDR_VAR 0 4
21533: PUSH
21534: LD_INT 24
21536: PUSH
21537: LD_INT 3
21539: PUSH
21540: LD_INT 1
21542: PUSH
21543: LD_INT 48
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: LIST
21550: LIST
21551: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_VAR 0 4
21561: PPUSH
21562: CALL 20940 0 2
// end ;
21566: LD_VAR 0 3
21570: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21571: LD_INT 0
21573: PPUSH
21574: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21575: LD_ADDR_EXP 64
21579: PUSH
21580: LD_EXP 64
21584: PPUSH
21585: LD_VAR 0 1
21589: PPUSH
21590: LD_INT 1
21592: PPUSH
21593: LD_VAR 0 4
21597: PPUSH
21598: CALL 30959 0 4
21602: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21603: LD_ADDR_EXP 65
21607: PUSH
21608: LD_EXP 65
21612: PPUSH
21613: LD_VAR 0 1
21617: PPUSH
21618: LD_INT 1
21620: PPUSH
21621: LD_VAR 0 2
21625: PPUSH
21626: CALL 30959 0 4
21630: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21631: LD_ADDR_EXP 66
21635: PUSH
21636: LD_EXP 66
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 1
21648: PPUSH
21649: LD_VAR 0 3
21653: PPUSH
21654: CALL 30959 0 4
21658: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21659: LD_ADDR_EXP 67
21663: PUSH
21664: LD_EXP 67
21668: PPUSH
21669: LD_VAR 0 1
21673: PPUSH
21674: LD_INT 1
21676: PPUSH
21677: LD_VAR 0 5
21681: PPUSH
21682: CALL 30959 0 4
21686: ST_TO_ADDR
// while squad do
21687: LD_VAR 0 5
21691: IFFALSE 21784
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21693: LD_VAR 0 1
21697: PPUSH
21698: LD_VAR 0 5
21702: PUSH
21703: LD_INT 1
21705: ARRAY
21706: PUSH
21707: LD_VAR 0 5
21711: PUSH
21712: LD_INT 2
21714: ARRAY
21715: PUSH
21716: LD_VAR 0 5
21720: PUSH
21721: LD_INT 3
21723: ARRAY
21724: PUSH
21725: LD_VAR 0 5
21729: PUSH
21730: LD_INT 4
21732: ARRAY
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: PPUSH
21740: CALL 20940 0 2
// for i = 1 to 4 do
21744: LD_ADDR_VAR 0 7
21748: PUSH
21749: DOUBLE
21750: LD_INT 1
21752: DEC
21753: ST_TO_ADDR
21754: LD_INT 4
21756: PUSH
21757: FOR_TO
21758: IFFALSE 21780
// squad := Delete ( squad , 1 ) ;
21760: LD_ADDR_VAR 0 5
21764: PUSH
21765: LD_VAR 0 5
21769: PPUSH
21770: LD_INT 1
21772: PPUSH
21773: CALL_OW 3
21777: ST_TO_ADDR
21778: GO 21757
21780: POP
21781: POP
// end ;
21782: GO 21687
// end ;
21784: LD_VAR 0 6
21788: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21789: LD_INT 0
21791: PPUSH
21792: PPUSH
// for i = 1 to squad do
21793: LD_ADDR_VAR 0 4
21797: PUSH
21798: DOUBLE
21799: LD_INT 1
21801: DEC
21802: ST_TO_ADDR
21803: LD_VAR 0 2
21807: PUSH
21808: FOR_TO
21809: IFFALSE 21859
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21811: LD_ADDR_EXP 70
21815: PUSH
21816: LD_EXP 70
21820: PPUSH
21821: LD_VAR 0 1
21825: PPUSH
21826: LD_EXP 70
21830: PUSH
21831: LD_VAR 0 1
21835: ARRAY
21836: PUSH
21837: LD_INT 1
21839: PLUS
21840: PPUSH
21841: LD_VAR 0 2
21845: PUSH
21846: LD_VAR 0 4
21850: ARRAY
21851: PPUSH
21852: CALL 30959 0 4
21856: ST_TO_ADDR
21857: GO 21808
21859: POP
21860: POP
// while squad do
21861: LD_VAR 0 2
21865: IFFALSE 21958
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21867: LD_VAR 0 1
21871: PPUSH
21872: LD_VAR 0 2
21876: PUSH
21877: LD_INT 1
21879: ARRAY
21880: PUSH
21881: LD_VAR 0 2
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PUSH
21890: LD_VAR 0 2
21894: PUSH
21895: LD_INT 3
21897: ARRAY
21898: PUSH
21899: LD_VAR 0 2
21903: PUSH
21904: LD_INT 4
21906: ARRAY
21907: PUSH
21908: EMPTY
21909: LIST
21910: LIST
21911: LIST
21912: LIST
21913: PPUSH
21914: CALL 20940 0 2
// for i = 1 to 4 do
21918: LD_ADDR_VAR 0 4
21922: PUSH
21923: DOUBLE
21924: LD_INT 1
21926: DEC
21927: ST_TO_ADDR
21928: LD_INT 4
21930: PUSH
21931: FOR_TO
21932: IFFALSE 21954
// squad := Delete ( squad , 1 ) ;
21934: LD_ADDR_VAR 0 2
21938: PUSH
21939: LD_VAR 0 2
21943: PPUSH
21944: LD_INT 1
21946: PPUSH
21947: CALL_OW 3
21951: ST_TO_ADDR
21952: GO 21931
21954: POP
21955: POP
// end ;
21956: GO 21861
// end ;
21958: LD_VAR 0 3
21962: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21963: LD_INT 0
21965: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21966: LD_ADDR_EXP 63
21970: PUSH
21971: LD_EXP 63
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: LD_INT 1
21983: PPUSH
21984: LD_VAR 0 2
21988: PPUSH
21989: CALL 30959 0 4
21993: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21994: LD_ADDR_EXP 63
21998: PUSH
21999: LD_EXP 63
22003: PPUSH
22004: LD_VAR 0 1
22008: PPUSH
22009: LD_INT 2
22011: PPUSH
22012: LD_VAR 0 3
22016: PPUSH
22017: CALL 30959 0 4
22021: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22022: LD_ADDR_EXP 63
22026: PUSH
22027: LD_EXP 63
22031: PPUSH
22032: LD_VAR 0 1
22036: PPUSH
22037: LD_INT 3
22039: PPUSH
22040: LD_VAR 0 4
22044: PPUSH
22045: CALL 30959 0 4
22049: ST_TO_ADDR
// end ; end_of_file
22050: LD_VAR 0 5
22054: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22055: LD_INT 0
22057: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22058: LD_ADDR_EXP 43
22062: PUSH
22063: LD_EXP 43
22067: PPUSH
22068: LD_VAR 0 1
22072: PPUSH
22073: LD_INT 1
22075: PPUSH
22076: LD_VAR 0 2
22080: PPUSH
22081: CALL 30959 0 4
22085: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22086: LD_VAR 0 1
22090: PPUSH
22091: EMPTY
22092: PPUSH
22093: CALL 11556 0 2
22097: PUSH
22098: LD_INT 1
22100: ARRAY
22101: PPUSH
22102: CALL_OW 248
22106: PUSH
22107: LD_INT 1
22109: EQUAL
22110: IFFALSE 22141
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22112: LD_VAR 0 1
22116: PPUSH
22117: LD_INT 4
22119: PUSH
22120: LD_INT 1
22122: PUSH
22123: LD_INT 1
22125: PUSH
22126: LD_INT 14
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: LIST
22133: LIST
22134: PPUSH
22135: CALL 20940 0 2
22139: GO 22168
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22141: LD_VAR 0 1
22145: PPUSH
22146: LD_INT 24
22148: PUSH
22149: LD_INT 1
22151: PUSH
22152: LD_INT 1
22154: PUSH
22155: LD_INT 53
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: LIST
22162: LIST
22163: PPUSH
22164: CALL 20940 0 2
// end ;
22168: LD_VAR 0 3
22172: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22173: LD_INT 0
22175: PPUSH
// CreateDepositXY ( x , y , t ) ;
22176: LD_VAR 0 1
22180: PPUSH
22181: LD_VAR 0 2
22185: PPUSH
22186: LD_VAR 0 3
22190: PPUSH
22191: CALL_OW 62
// end ;
22195: LD_VAR 0 4
22199: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22200: LD_INT 0
22202: PPUSH
22203: PPUSH
// c := 1 ;
22204: LD_ADDR_VAR 0 5
22208: PUSH
22209: LD_INT 1
22211: ST_TO_ADDR
// case color of red :
22212: LD_VAR 0 3
22216: PUSH
22217: LD_STRING red
22219: DOUBLE
22220: EQUAL
22221: IFTRUE 22225
22223: GO 22236
22225: POP
// c = 1 ; dark-green :
22226: LD_ADDR_VAR 0 5
22230: PUSH
22231: LD_INT 1
22233: ST_TO_ADDR
22234: GO 22522
22236: LD_STRING dark-green
22238: DOUBLE
22239: EQUAL
22240: IFTRUE 22244
22242: GO 22255
22244: POP
// c = 2 ; purple :
22245: LD_ADDR_VAR 0 5
22249: PUSH
22250: LD_INT 2
22252: ST_TO_ADDR
22253: GO 22522
22255: LD_STRING purple
22257: DOUBLE
22258: EQUAL
22259: IFTRUE 22263
22261: GO 22274
22263: POP
// c = 3 ; aqua :
22264: LD_ADDR_VAR 0 5
22268: PUSH
22269: LD_INT 3
22271: ST_TO_ADDR
22272: GO 22522
22274: LD_STRING aqua
22276: DOUBLE
22277: EQUAL
22278: IFTRUE 22282
22280: GO 22293
22282: POP
// c = 4 ; grey :
22283: LD_ADDR_VAR 0 5
22287: PUSH
22288: LD_INT 4
22290: ST_TO_ADDR
22291: GO 22522
22293: LD_STRING grey
22295: DOUBLE
22296: EQUAL
22297: IFTRUE 22301
22299: GO 22312
22301: POP
// c = 5 ; lime :
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: LD_INT 5
22309: ST_TO_ADDR
22310: GO 22522
22312: LD_STRING lime
22314: DOUBLE
22315: EQUAL
22316: IFTRUE 22320
22318: GO 22331
22320: POP
// c = 6 ; tan :
22321: LD_ADDR_VAR 0 5
22325: PUSH
22326: LD_INT 6
22328: ST_TO_ADDR
22329: GO 22522
22331: LD_STRING tan
22333: DOUBLE
22334: EQUAL
22335: IFTRUE 22339
22337: GO 22350
22339: POP
// c = 7 ; pink :
22340: LD_ADDR_VAR 0 5
22344: PUSH
22345: LD_INT 7
22347: ST_TO_ADDR
22348: GO 22522
22350: LD_STRING pink
22352: DOUBLE
22353: EQUAL
22354: IFTRUE 22358
22356: GO 22369
22358: POP
// c = 8 ; green :
22359: LD_ADDR_VAR 0 5
22363: PUSH
22364: LD_INT 8
22366: ST_TO_ADDR
22367: GO 22522
22369: LD_STRING green
22371: DOUBLE
22372: EQUAL
22373: IFTRUE 22377
22375: GO 22388
22377: POP
// c = 9 ; blue :
22378: LD_ADDR_VAR 0 5
22382: PUSH
22383: LD_INT 9
22385: ST_TO_ADDR
22386: GO 22522
22388: LD_STRING blue
22390: DOUBLE
22391: EQUAL
22392: IFTRUE 22396
22394: GO 22407
22396: POP
// c = 10 ; yellow :
22397: LD_ADDR_VAR 0 5
22401: PUSH
22402: LD_INT 10
22404: ST_TO_ADDR
22405: GO 22522
22407: LD_STRING yellow
22409: DOUBLE
22410: EQUAL
22411: IFTRUE 22415
22413: GO 22426
22415: POP
// c = 11 ; brown :
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_INT 11
22423: ST_TO_ADDR
22424: GO 22522
22426: LD_STRING brown
22428: DOUBLE
22429: EQUAL
22430: IFTRUE 22434
22432: GO 22445
22434: POP
// c = 12 ; black :
22435: LD_ADDR_VAR 0 5
22439: PUSH
22440: LD_INT 12
22442: ST_TO_ADDR
22443: GO 22522
22445: LD_STRING black
22447: DOUBLE
22448: EQUAL
22449: IFTRUE 22453
22451: GO 22464
22453: POP
// c = 13 ; aqua2 :
22454: LD_ADDR_VAR 0 5
22458: PUSH
22459: LD_INT 13
22461: ST_TO_ADDR
22462: GO 22522
22464: LD_STRING aqua2
22466: DOUBLE
22467: EQUAL
22468: IFTRUE 22472
22470: GO 22483
22472: POP
// c = 14 ; orange :
22473: LD_ADDR_VAR 0 5
22477: PUSH
22478: LD_INT 14
22480: ST_TO_ADDR
22481: GO 22522
22483: LD_STRING orange
22485: DOUBLE
22486: EQUAL
22487: IFTRUE 22491
22489: GO 22502
22491: POP
// c = 15 ; white :
22492: LD_ADDR_VAR 0 5
22496: PUSH
22497: LD_INT 15
22499: ST_TO_ADDR
22500: GO 22522
22502: LD_STRING white
22504: DOUBLE
22505: EQUAL
22506: IFTRUE 22510
22508: GO 22521
22510: POP
// c = 16 ; end ;
22511: LD_ADDR_VAR 0 5
22515: PUSH
22516: LD_INT 16
22518: ST_TO_ADDR
22519: GO 22522
22521: POP
// if HexInfo ( x , y ) = 0 then
22522: LD_VAR 0 1
22526: PPUSH
22527: LD_VAR 0 2
22531: PPUSH
22532: CALL_OW 428
22536: PUSH
22537: LD_INT 0
22539: EQUAL
22540: IFFALSE 22564
// PlaceEnvironment ( x , y , 58 , c ) ;
22542: LD_VAR 0 1
22546: PPUSH
22547: LD_VAR 0 2
22551: PPUSH
22552: LD_INT 58
22554: PPUSH
22555: LD_VAR 0 5
22559: PPUSH
22560: CALL_OW 349
// end ;
22564: LD_VAR 0 4
22568: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22569: LD_INT 0
22571: PPUSH
// RemoveEnvironment ( x , y ) ;
22572: LD_VAR 0 1
22576: PPUSH
22577: LD_VAR 0 2
22581: PPUSH
22582: CALL_OW 347
// end ;
22586: LD_VAR 0 3
22590: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22591: LD_INT 0
22593: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22594: LD_INT 81
22596: PUSH
22597: LD_VAR 0 1
22601: PUSH
22602: EMPTY
22603: LIST
22604: LIST
22605: PPUSH
22606: CALL_OW 69
22610: PUSH
22611: LD_INT 0
22613: EQUAL
22614: IFFALSE 22626
// result := false else
22616: LD_ADDR_VAR 0 5
22620: PUSH
22621: LD_INT 0
22623: ST_TO_ADDR
22624: GO 22690
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22626: LD_INT 81
22628: PUSH
22629: LD_VAR 0 1
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: PUSH
22638: LD_INT 92
22640: PUSH
22641: LD_VAR 0 2
22645: PUSH
22646: LD_VAR 0 3
22650: PUSH
22651: LD_VAR 0 4
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: PPUSH
22666: CALL_OW 69
22670: IFFALSE 22682
// result := true else
22672: LD_ADDR_VAR 0 5
22676: PUSH
22677: LD_INT 1
22679: ST_TO_ADDR
22680: GO 22690
// result := false ;
22682: LD_ADDR_VAR 0 5
22686: PUSH
22687: LD_INT 0
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 5
22694: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22695: LD_INT 0
22697: PPUSH
22698: PPUSH
22699: PPUSH
22700: PPUSH
22701: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22702: LD_VAR 0 1
22706: PPUSH
22707: LD_INT 81
22709: PUSH
22710: LD_VAR 0 1
22714: PPUSH
22715: CALL_OW 255
22719: PUSH
22720: EMPTY
22721: LIST
22722: LIST
22723: PPUSH
22724: CALL_OW 69
22728: PPUSH
22729: LD_VAR 0 1
22733: PPUSH
22734: CALL_OW 74
22738: PPUSH
22739: CALL_OW 119
// dir := GetDir ( un ) ;
22743: LD_ADDR_VAR 0 4
22747: PUSH
22748: LD_VAR 0 1
22752: PPUSH
22753: CALL_OW 254
22757: ST_TO_ADDR
// dir := dir - 3 ;
22758: LD_ADDR_VAR 0 4
22762: PUSH
22763: LD_VAR 0 4
22767: PUSH
22768: LD_INT 3
22770: MINUS
22771: ST_TO_ADDR
// if dir < 0 then
22772: LD_VAR 0 4
22776: PUSH
22777: LD_INT 0
22779: LESS
22780: IFFALSE 22796
// dir := dir + 6 ;
22782: LD_ADDR_VAR 0 4
22786: PUSH
22787: LD_VAR 0 4
22791: PUSH
22792: LD_INT 6
22794: PLUS
22795: ST_TO_ADDR
// while true do
22796: LD_INT 1
22798: IFFALSE 23295
// begin coord_dist := 3 ;
22800: LD_ADDR_VAR 0 3
22804: PUSH
22805: LD_INT 3
22807: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22808: LD_ADDR_VAR 0 5
22812: PUSH
22813: LD_VAR 0 1
22817: PPUSH
22818: CALL_OW 250
22822: PPUSH
22823: LD_VAR 0 4
22827: PPUSH
22828: LD_VAR 0 3
22832: PPUSH
22833: CALL_OW 272
22837: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22838: LD_ADDR_VAR 0 6
22842: PUSH
22843: LD_VAR 0 1
22847: PPUSH
22848: CALL_OW 251
22852: PPUSH
22853: LD_VAR 0 4
22857: PPUSH
22858: LD_VAR 0 3
22862: PPUSH
22863: CALL_OW 273
22867: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 255
22877: PPUSH
22878: LD_VAR 0 1
22882: PPUSH
22883: CALL_OW 250
22887: PPUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 251
22897: PPUSH
22898: LD_INT 14
22900: PPUSH
22901: CALL 22591 0 4
22905: PUSH
22906: LD_VAR 0 5
22910: PPUSH
22911: LD_VAR 0 6
22915: PPUSH
22916: CALL_OW 351
22920: OR
22921: PUSH
22922: LD_VAR 0 5
22926: PPUSH
22927: LD_VAR 0 6
22931: PPUSH
22932: CALL_OW 488
22936: PUSH
22937: LD_INT 0
22939: EQUAL
22940: OR
22941: PUSH
22942: LD_VAR 0 5
22946: PPUSH
22947: LD_VAR 0 6
22951: PPUSH
22952: CALL_OW 546
22956: PUSH
22957: LD_INT 1
22959: EQUAL
22960: OR
22961: PUSH
22962: LD_VAR 0 5
22966: PPUSH
22967: LD_VAR 0 6
22971: PPUSH
22972: CALL_OW 428
22976: PUSH
22977: LD_INT 0
22979: NONEQUAL
22980: OR
22981: IFFALSE 23209
// begin repeat begin Wait ( 0 0$0.3 ) ;
22983: LD_INT 10
22985: PPUSH
22986: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22990: LD_ADDR_VAR 0 3
22994: PUSH
22995: LD_VAR 0 3
22999: PUSH
23000: LD_INT 1
23002: PLUS
23003: ST_TO_ADDR
// dir := dir + 1 ;
23004: LD_ADDR_VAR 0 4
23008: PUSH
23009: LD_VAR 0 4
23013: PUSH
23014: LD_INT 1
23016: PLUS
23017: ST_TO_ADDR
// if dir > 5 then
23018: LD_VAR 0 4
23022: PUSH
23023: LD_INT 5
23025: GREATER
23026: IFFALSE 23036
// dir = 0 ;
23028: LD_ADDR_VAR 0 4
23032: PUSH
23033: LD_INT 0
23035: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23036: LD_ADDR_VAR 0 5
23040: PUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: CALL_OW 250
23050: PPUSH
23051: LD_VAR 0 4
23055: PPUSH
23056: LD_VAR 0 3
23060: PPUSH
23061: CALL_OW 272
23065: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23066: LD_ADDR_VAR 0 6
23070: PUSH
23071: LD_VAR 0 1
23075: PPUSH
23076: CALL_OW 251
23080: PPUSH
23081: LD_VAR 0 4
23085: PPUSH
23086: LD_VAR 0 3
23090: PPUSH
23091: CALL_OW 273
23095: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23096: LD_VAR 0 1
23100: PPUSH
23101: CALL_OW 255
23105: PPUSH
23106: LD_VAR 0 1
23110: PPUSH
23111: CALL_OW 250
23115: PPUSH
23116: LD_VAR 0 1
23120: PPUSH
23121: CALL_OW 251
23125: PPUSH
23126: LD_INT 14
23128: PPUSH
23129: CALL 22591 0 4
23133: NOT
23134: PUSH
23135: LD_VAR 0 5
23139: PPUSH
23140: LD_VAR 0 6
23144: PPUSH
23145: CALL_OW 351
23149: NOT
23150: AND
23151: PUSH
23152: LD_VAR 0 5
23156: PPUSH
23157: LD_VAR 0 6
23161: PPUSH
23162: CALL_OW 488
23166: AND
23167: PUSH
23168: LD_VAR 0 5
23172: PPUSH
23173: LD_VAR 0 6
23177: PPUSH
23178: CALL_OW 546
23182: PUSH
23183: LD_INT 0
23185: EQUAL
23186: AND
23187: PUSH
23188: LD_VAR 0 5
23192: PPUSH
23193: LD_VAR 0 6
23197: PPUSH
23198: CALL_OW 428
23202: PUSH
23203: LD_INT 0
23205: EQUAL
23206: AND
23207: IFFALSE 22983
// end ; ComMoveXY ( un , x , y ) ;
23209: LD_VAR 0 1
23213: PPUSH
23214: LD_VAR 0 5
23218: PPUSH
23219: LD_VAR 0 6
23223: PPUSH
23224: CALL_OW 111
// Wait ( 0 0$1 ) ;
23228: LD_INT 35
23230: PPUSH
23231: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23235: LD_VAR 0 1
23239: PPUSH
23240: LD_INT 81
23242: PUSH
23243: LD_VAR 0 1
23247: PPUSH
23248: CALL_OW 255
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 69
23261: PPUSH
23262: LD_VAR 0 1
23266: PPUSH
23267: CALL_OW 74
23271: PPUSH
23272: CALL_OW 296
23276: PUSH
23277: LD_INT 14
23279: GREATEREQUAL
23280: IFFALSE 23293
// begin ComStop ( un ) ;
23282: LD_VAR 0 1
23286: PPUSH
23287: CALL_OW 141
// break ;
23291: GO 23295
// end ; end ;
23293: GO 22796
// end ;
23295: LD_VAR 0 2
23299: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23300: LD_INT 0
23302: PPUSH
23303: PPUSH
23304: PPUSH
23305: PPUSH
23306: PPUSH
23307: PPUSH
23308: PPUSH
23309: PPUSH
// x := GetX ( unit ) ;
23310: LD_ADDR_VAR 0 3
23314: PUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: CALL_OW 250
23324: ST_TO_ADDR
// y := GetY ( unit ) ;
23325: LD_ADDR_VAR 0 4
23329: PUSH
23330: LD_VAR 0 1
23334: PPUSH
23335: CALL_OW 251
23339: ST_TO_ADDR
// i := 0 ;
23340: LD_ADDR_VAR 0 8
23344: PUSH
23345: LD_INT 0
23347: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23348: LD_VAR 0 1
23352: PPUSH
23353: LD_INT 81
23355: PUSH
23356: LD_VAR 0 1
23360: PPUSH
23361: CALL_OW 255
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: PPUSH
23370: CALL_OW 69
23374: PPUSH
23375: LD_VAR 0 1
23379: PPUSH
23380: CALL_OW 74
23384: PPUSH
23385: CALL_OW 119
// dir := GetDir ( unit ) ;
23389: LD_ADDR_VAR 0 7
23393: PUSH
23394: LD_VAR 0 1
23398: PPUSH
23399: CALL_OW 254
23403: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23404: LD_ADDR_VAR 0 9
23408: PUSH
23409: LD_INT 0
23411: PPUSH
23412: LD_INT 1
23414: PPUSH
23415: CALL_OW 12
23419: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23420: LD_INT 10
23422: PPUSH
23423: CALL_OW 67
// if mode then
23427: LD_VAR 0 9
23431: IFFALSE 23449
// dir := dir + 1 else
23433: LD_ADDR_VAR 0 7
23437: PUSH
23438: LD_VAR 0 7
23442: PUSH
23443: LD_INT 1
23445: PLUS
23446: ST_TO_ADDR
23447: GO 23463
// dir := dir - 1 ;
23449: LD_ADDR_VAR 0 7
23453: PUSH
23454: LD_VAR 0 7
23458: PUSH
23459: LD_INT 1
23461: MINUS
23462: ST_TO_ADDR
// if ( dir < 0 ) then
23463: LD_VAR 0 7
23467: PUSH
23468: LD_INT 0
23470: LESS
23471: IFFALSE 23481
// dir := 5 ;
23473: LD_ADDR_VAR 0 7
23477: PUSH
23478: LD_INT 5
23480: ST_TO_ADDR
// if ( dir > 5 ) then
23481: LD_VAR 0 7
23485: PUSH
23486: LD_INT 5
23488: GREATER
23489: IFFALSE 23499
// dir := 0 ;
23491: LD_ADDR_VAR 0 7
23495: PUSH
23496: LD_INT 0
23498: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23499: LD_ADDR_VAR 0 5
23503: PUSH
23504: LD_VAR 0 3
23508: PPUSH
23509: LD_VAR 0 7
23513: PPUSH
23514: LD_INT 4
23516: PPUSH
23517: CALL_OW 272
23521: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23522: LD_ADDR_VAR 0 6
23526: PUSH
23527: LD_VAR 0 4
23531: PPUSH
23532: LD_VAR 0 7
23536: PPUSH
23537: LD_INT 4
23539: PPUSH
23540: CALL_OW 273
23544: ST_TO_ADDR
// i := i + 1 ;
23545: LD_ADDR_VAR 0 8
23549: PUSH
23550: LD_VAR 0 8
23554: PUSH
23555: LD_INT 1
23557: PLUS
23558: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 255
23568: PPUSH
23569: LD_VAR 0 5
23573: PPUSH
23574: LD_VAR 0 6
23578: PPUSH
23579: LD_INT 14
23581: PPUSH
23582: CALL 22591 0 4
23586: PUSH
23587: LD_INT 0
23589: EQUAL
23590: PUSH
23591: LD_VAR 0 5
23595: PPUSH
23596: LD_VAR 0 6
23600: PPUSH
23601: CALL_OW 546
23605: PUSH
23606: LD_INT 0
23608: EQUAL
23609: AND
23610: PUSH
23611: LD_VAR 0 5
23615: PPUSH
23616: LD_VAR 0 6
23620: PPUSH
23621: CALL_OW 428
23625: PUSH
23626: LD_INT 0
23628: EQUAL
23629: AND
23630: IFFALSE 23634
// break ;
23632: GO 23644
// end until i > 4 ;
23634: LD_VAR 0 8
23638: PUSH
23639: LD_INT 4
23641: GREATER
23642: IFFALSE 23420
// if x2 and y2 then
23644: LD_VAR 0 5
23648: PUSH
23649: LD_VAR 0 6
23653: AND
23654: IFFALSE 23677
// result := [ x2 , y2 ] else
23656: LD_ADDR_VAR 0 2
23660: PUSH
23661: LD_VAR 0 5
23665: PUSH
23666: LD_VAR 0 6
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: ST_TO_ADDR
23675: GO 23706
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23677: LD_ADDR_VAR 0 2
23681: PUSH
23682: LD_VAR 0 1
23686: PPUSH
23687: CALL_OW 250
23691: PUSH
23692: LD_VAR 0 1
23696: PPUSH
23697: CALL_OW 251
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: ST_TO_ADDR
// end ;
23706: LD_VAR 0 2
23710: RET
// export function MCT_Hex ( x , y ) ; begin
23711: LD_INT 0
23713: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23714: LD_ADDR_VAR 0 3
23718: PUSH
23719: LD_VAR 0 1
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: CALL_OW 546
23733: PUSH
23734: LD_VAR 0 1
23738: PPUSH
23739: LD_VAR 0 2
23743: PPUSH
23744: CALL_OW 428
23748: PUSH
23749: EMPTY
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: ST_TO_ADDR
// end ;
23756: LD_VAR 0 3
23760: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23761: LD_INT 0
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23776: LD_ADDR_VAR 0 10
23780: PUSH
23781: LD_EXP 61
23785: PUSH
23786: LD_VAR 0 1
23790: ARRAY
23791: PUSH
23792: LD_INT 1
23794: ARRAY
23795: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23796: LD_ADDR_VAR 0 11
23800: PUSH
23801: LD_EXP 61
23805: PUSH
23806: LD_VAR 0 1
23810: ARRAY
23811: PUSH
23812: LD_INT 2
23814: ARRAY
23815: ST_TO_ADDR
// collectors := [ ] ;
23816: LD_ADDR_VAR 0 12
23820: PUSH
23821: EMPTY
23822: ST_TO_ADDR
// is_cargo := false ;
23823: LD_ADDR_VAR 0 13
23827: PUSH
23828: LD_INT 0
23830: ST_TO_ADDR
// if isTest then
23831: LD_EXP 1
23835: IFFALSE 23841
// TimerStart ( ) ;
23837: CALL_OW 548
// if MCF_Cargo ( side ) then
23841: LD_VAR 0 1
23845: PPUSH
23846: CALL 11772 0 1
23850: IFFALSE 23877
// begin collectors := MCF_Cargo ( side ) ;
23852: LD_ADDR_VAR 0 12
23856: PUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL 11772 0 1
23866: ST_TO_ADDR
// is_cargo := true ;
23867: LD_ADDR_VAR 0 13
23871: PUSH
23872: LD_INT 1
23874: ST_TO_ADDR
// end else
23875: GO 24026
// begin if MCF_ApeSpec ( side , engineer ) then
23877: LD_VAR 0 1
23881: PPUSH
23882: LD_STRING engineer
23884: PPUSH
23885: CALL 11918 0 2
23889: IFFALSE 23909
// collectors := MCF_ApeSpec ( side , engineer ) ;
23891: LD_ADDR_VAR 0 12
23895: PUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: LD_STRING engineer
23903: PPUSH
23904: CALL 11918 0 2
23908: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23909: LD_VAR 0 1
23913: PPUSH
23914: LD_INT 2
23916: PPUSH
23917: EMPTY
23918: PPUSH
23919: CALL 11504 0 3
23923: IFFALSE 24026
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23925: LD_ADDR_VAR 0 7
23929: PUSH
23930: LD_VAR 0 1
23934: PPUSH
23935: LD_INT 2
23937: PPUSH
23938: EMPTY
23939: PPUSH
23940: CALL 11504 0 3
23944: ST_TO_ADDR
// if z > 5 then
23945: LD_VAR 0 7
23949: PUSH
23950: LD_INT 5
23952: GREATER
23953: IFFALSE 23965
// t1 := 5 else
23955: LD_ADDR_VAR 0 8
23959: PUSH
23960: LD_INT 5
23962: ST_TO_ADDR
23963: GO 23975
// t1 := z ;
23965: LD_ADDR_VAR 0 8
23969: PUSH
23970: LD_VAR 0 7
23974: ST_TO_ADDR
// for t2 = 1 to t1 do
23975: LD_ADDR_VAR 0 9
23979: PUSH
23980: DOUBLE
23981: LD_INT 1
23983: DEC
23984: ST_TO_ADDR
23985: LD_VAR 0 8
23989: PUSH
23990: FOR_TO
23991: IFFALSE 24024
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23993: LD_ADDR_VAR 0 12
23997: PUSH
23998: LD_VAR 0 12
24002: PPUSH
24003: LD_INT 1
24005: PPUSH
24006: LD_VAR 0 7
24010: PUSH
24011: LD_VAR 0 9
24015: ARRAY
24016: PPUSH
24017: CALL_OW 2
24021: ST_TO_ADDR
24022: GO 23990
24024: POP
24025: POP
// end ; end ; if not mode then
24026: LD_VAR 0 10
24030: NOT
24031: IFFALSE 24037
// exit else
24033: GO 24296
24035: GO 24296
// begin if collectors then
24037: LD_VAR 0 12
24041: IFFALSE 24296
// for i in areas do
24043: LD_ADDR_VAR 0 3
24047: PUSH
24048: LD_VAR 0 11
24052: PUSH
24053: FOR_IN
24054: IFFALSE 24294
// if GetListOfCratesInArea ( i ) then
24056: LD_VAR 0 3
24060: PPUSH
24061: CALL_OW 435
24065: IFFALSE 24292
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24067: LD_ADDR_VAR 0 5
24071: PUSH
24072: LD_VAR 0 3
24076: PPUSH
24077: CALL_OW 435
24081: PUSH
24082: LD_INT 1
24084: ARRAY
24085: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24086: LD_ADDR_VAR 0 6
24090: PUSH
24091: LD_VAR 0 3
24095: PPUSH
24096: CALL_OW 435
24100: PUSH
24101: LD_INT 2
24103: ARRAY
24104: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24105: LD_VAR 0 13
24109: PUSH
24110: LD_VAR 0 12
24114: PUSH
24115: LD_INT 1
24117: ARRAY
24118: PPUSH
24119: CALL_OW 110
24123: PUSH
24124: LD_INT 0
24126: EQUAL
24127: AND
24128: IFFALSE 24190
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24130: LD_VAR 0 12
24134: PUSH
24135: LD_INT 1
24137: ARRAY
24138: PPUSH
24139: CALL_OW 314
24143: NOT
24144: PUSH
24145: LD_VAR 0 12
24149: PUSH
24150: LD_INT 1
24152: ARRAY
24153: PPUSH
24154: CALL_OW 110
24158: PUSH
24159: LD_INT 0
24161: EQUAL
24162: AND
24163: IFFALSE 24188
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24165: LD_VAR 0 12
24169: PUSH
24170: LD_INT 1
24172: ARRAY
24173: PPUSH
24174: LD_VAR 0 5
24178: PPUSH
24179: LD_VAR 0 6
24183: PPUSH
24184: CALL_OW 117
// end ; end else
24188: GO 24276
// begin for j = 1 to collectors do
24190: LD_ADDR_VAR 0 4
24194: PUSH
24195: DOUBLE
24196: LD_INT 1
24198: DEC
24199: ST_TO_ADDR
24200: LD_VAR 0 12
24204: PUSH
24205: FOR_TO
24206: IFFALSE 24274
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24208: LD_VAR 0 12
24212: PUSH
24213: LD_VAR 0 4
24217: ARRAY
24218: PPUSH
24219: CALL_OW 314
24223: NOT
24224: PUSH
24225: LD_VAR 0 12
24229: PUSH
24230: LD_VAR 0 4
24234: ARRAY
24235: PPUSH
24236: CALL_OW 110
24240: PUSH
24241: LD_INT 0
24243: EQUAL
24244: AND
24245: IFFALSE 24272
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24247: LD_VAR 0 12
24251: PUSH
24252: LD_VAR 0 4
24256: ARRAY
24257: PPUSH
24258: LD_VAR 0 5
24262: PPUSH
24263: LD_VAR 0 6
24267: PPUSH
24268: CALL 24667 0 3
// end ;
24272: GO 24205
24274: POP
24275: POP
// end ; if isTest then
24276: LD_EXP 1
24280: IFFALSE 24292
// begin debug_time := TimerEnd ( ) ;
24282: LD_ADDR_VAR 0 14
24286: PUSH
24287: CALL_OW 549
24291: ST_TO_ADDR
// end ; end ;
24292: GO 24053
24294: POP
24295: POP
// end ; end ;
24296: LD_VAR 0 2
24300: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24301: LD_INT 0
24303: PPUSH
24304: PPUSH
24305: PPUSH
24306: PPUSH
24307: PPUSH
24308: PPUSH
// if not area then
24309: LD_VAR 0 1
24313: NOT
24314: IFFALSE 24320
// exit else
24316: GO 24582
24318: GO 24582
// if tick mod interval = 0 and Prob ( percent ) then
24320: LD_OWVAR 1
24324: PUSH
24325: LD_VAR 0 4
24329: MOD
24330: PUSH
24331: LD_INT 0
24333: EQUAL
24334: PUSH
24335: LD_VAR 0 3
24339: PPUSH
24340: CALL_OW 13
24344: AND
24345: IFFALSE 24582
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24347: LD_VAR 0 1
24351: PPUSH
24352: CALL_OW 435
24356: PUSH
24357: LD_VAR 0 5
24361: LESS
24362: PUSH
24363: LD_VAR 0 5
24367: PUSH
24368: LD_INT 0
24370: EQUAL
24371: OR
24372: IFFALSE 24582
// begin Randomize ;
24374: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24378: LD_ADDR_VAR 0 7
24382: PUSH
24383: LD_INT 1
24385: PPUSH
24386: LD_VAR 0 2
24390: PPUSH
24391: CALL_OW 12
24395: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24396: LD_ADDR_VAR 0 9
24400: PUSH
24401: LD_VAR 0 1
24405: PPUSH
24406: LD_INT 0
24408: PPUSH
24409: CALL_OW 517
24413: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24414: LD_ADDR_VAR 0 8
24418: PUSH
24419: LD_INT 1
24421: PPUSH
24422: LD_VAR 0 9
24426: PUSH
24427: LD_INT 1
24429: ARRAY
24430: PPUSH
24431: CALL_OW 12
24435: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24436: LD_VAR 0 9
24440: PUSH
24441: LD_INT 1
24443: ARRAY
24444: PUSH
24445: LD_VAR 0 8
24449: ARRAY
24450: PPUSH
24451: LD_VAR 0 9
24455: PUSH
24456: LD_INT 2
24458: ARRAY
24459: PUSH
24460: LD_VAR 0 8
24464: ARRAY
24465: PPUSH
24466: CALL_OW 428
24470: PUSH
24471: LD_INT 0
24473: GREATER
24474: PUSH
24475: LD_VAR 0 9
24479: PUSH
24480: LD_INT 1
24482: ARRAY
24483: PUSH
24484: LD_VAR 0 8
24488: ARRAY
24489: PPUSH
24490: LD_VAR 0 9
24494: PUSH
24495: LD_INT 2
24497: ARRAY
24498: PUSH
24499: LD_VAR 0 8
24503: ARRAY
24504: PPUSH
24505: CALL_OW 284
24509: PUSH
24510: LD_INT 0
24512: GREATER
24513: AND
24514: IFFALSE 24540
// c := Rand ( 1 , tmp [ 1 ] ) ;
24516: LD_ADDR_VAR 0 8
24520: PUSH
24521: LD_INT 1
24523: PPUSH
24524: LD_VAR 0 9
24528: PUSH
24529: LD_INT 1
24531: ARRAY
24532: PPUSH
24533: CALL_OW 12
24537: ST_TO_ADDR
24538: GO 24436
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24540: LD_VAR 0 7
24544: PPUSH
24545: LD_VAR 0 9
24549: PUSH
24550: LD_INT 1
24552: ARRAY
24553: PUSH
24554: LD_VAR 0 8
24558: ARRAY
24559: PPUSH
24560: LD_VAR 0 9
24564: PUSH
24565: LD_INT 2
24567: ARRAY
24568: PUSH
24569: LD_VAR 0 8
24573: ARRAY
24574: PPUSH
24575: LD_INT 1
24577: PPUSH
24578: CALL_OW 54
// end ; end ; end ;
24582: LD_VAR 0 6
24586: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24587: LD_INT 0
24589: PPUSH
24590: PPUSH
// if not MREG_Crates then
24591: LD_EXP 35
24595: NOT
24596: IFFALSE 24600
// exit ;
24598: GO 24662
// for i = MREG_Crates downto 1 do
24600: LD_ADDR_VAR 0 2
24604: PUSH
24605: DOUBLE
24606: LD_EXP 35
24610: INC
24611: ST_TO_ADDR
24612: LD_INT 1
24614: PUSH
24615: FOR_DOWNTO
24616: IFFALSE 24660
// if MREG_Crates [ i ] [ 3 ] = 0 then
24618: LD_EXP 35
24622: PUSH
24623: LD_VAR 0 2
24627: ARRAY
24628: PUSH
24629: LD_INT 3
24631: ARRAY
24632: PUSH
24633: LD_INT 0
24635: EQUAL
24636: IFFALSE 24658
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24638: LD_ADDR_EXP 35
24642: PUSH
24643: LD_EXP 35
24647: PPUSH
24648: LD_VAR 0 2
24652: PPUSH
24653: CALL_OW 3
24657: ST_TO_ADDR
24658: GO 24615
24660: POP
24661: POP
// end ;
24662: LD_VAR 0 1
24666: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24667: LD_INT 0
24669: PPUSH
24670: PPUSH
24671: PPUSH
24672: PPUSH
// if not unit then
24673: LD_VAR 0 1
24677: NOT
24678: IFFALSE 24682
// exit ;
24680: GO 24817
// if HasTask ( unit ) or not CanCarry ( unit ) then
24682: LD_VAR 0 1
24686: PPUSH
24687: CALL_OW 314
24691: PUSH
24692: LD_VAR 0 1
24696: PPUSH
24697: CALL_OW 280
24701: NOT
24702: OR
24703: IFFALSE 24707
// exit ;
24705: GO 24817
// side := GetSide ( unit ) ;
24707: LD_ADDR_VAR 0 6
24711: PUSH
24712: LD_VAR 0 1
24716: PPUSH
24717: CALL_OW 255
24721: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24722: LD_ADDR_VAR 0 7
24726: PUSH
24727: LD_VAR 0 6
24731: PPUSH
24732: LD_INT 30
24734: PUSH
24735: LD_INT 1
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PPUSH
24742: CALL 11421 0 2
24746: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24747: LD_VAR 0 1
24751: PPUSH
24752: CALL_OW 281
24756: PUSH
24757: LD_VAR 0 7
24761: NOT
24762: OR
24763: IFFALSE 24769
// exit else
24765: GO 24817
24767: GO 24817
// if GetResourceAmountXY ( x , y ) then
24769: LD_VAR 0 2
24773: PPUSH
24774: LD_VAR 0 3
24778: PPUSH
24779: CALL_OW 284
24783: IFFALSE 24815
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24785: LD_VAR 0 1
24789: PPUSH
24790: LD_VAR 0 2
24794: PPUSH
24795: LD_VAR 0 3
24799: PPUSH
24800: LD_VAR 0 7
24804: PUSH
24805: LD_INT 1
24807: ARRAY
24808: PPUSH
24809: CALL 32123 0 4
// end else
24813: GO 24817
// exit ;
24815: GO 24817
// end ;
24817: LD_VAR 0 4
24821: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24822: LD_INT 0
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
// result := 0 ;
24829: LD_ADDR_VAR 0 2
24833: PUSH
24834: LD_INT 0
24836: ST_TO_ADDR
// p := 1 ;
24837: LD_ADDR_VAR 0 4
24841: PUSH
24842: LD_INT 1
24844: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24845: LD_ADDR_VAR 0 3
24849: PUSH
24850: DOUBLE
24851: LD_INT 1
24853: DEC
24854: ST_TO_ADDR
24855: LD_EXP 64
24859: PUSH
24860: LD_VAR 0 1
24864: ARRAY
24865: PUSH
24866: LD_INT 1
24868: ARRAY
24869: PUSH
24870: LD_INT 2
24872: DIVREAL
24873: PUSH
24874: FOR_TO
24875: IFFALSE 24999
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24877: LD_ADDR_VAR 0 5
24881: PUSH
24882: LD_INT 81
24884: PUSH
24885: LD_VAR 0 1
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 92
24896: PUSH
24897: LD_EXP 64
24901: PUSH
24902: LD_VAR 0 1
24906: ARRAY
24907: PUSH
24908: LD_INT 1
24910: ARRAY
24911: PUSH
24912: LD_VAR 0 4
24916: ARRAY
24917: PUSH
24918: LD_EXP 64
24922: PUSH
24923: LD_VAR 0 1
24927: ARRAY
24928: PUSH
24929: LD_INT 1
24931: ARRAY
24932: PUSH
24933: LD_VAR 0 4
24937: PUSH
24938: LD_INT 1
24940: PLUS
24941: ARRAY
24942: PUSH
24943: LD_INT 12
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: ST_TO_ADDR
// if tmp then
24961: LD_VAR 0 5
24965: IFFALSE 24983
// result := result ^ tmp ;
24967: LD_ADDR_VAR 0 2
24971: PUSH
24972: LD_VAR 0 2
24976: PUSH
24977: LD_VAR 0 5
24981: ADD
24982: ST_TO_ADDR
// p := p + 2 ;
24983: LD_ADDR_VAR 0 4
24987: PUSH
24988: LD_VAR 0 4
24992: PUSH
24993: LD_INT 2
24995: PLUS
24996: ST_TO_ADDR
// end ;
24997: GO 24874
24999: POP
25000: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25001: LD_EXP 65
25005: PUSH
25006: LD_VAR 0 1
25010: ARRAY
25011: PPUSH
25012: LD_INT 81
25014: PUSH
25015: LD_VAR 0 1
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PPUSH
25024: CALL_OW 70
25028: IFFALSE 25069
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25030: LD_ADDR_VAR 0 2
25034: PUSH
25035: LD_VAR 0 2
25039: PUSH
25040: LD_EXP 65
25044: PUSH
25045: LD_VAR 0 1
25049: ARRAY
25050: PPUSH
25051: LD_INT 81
25053: PUSH
25054: LD_VAR 0 1
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PPUSH
25063: CALL_OW 70
25067: ADD
25068: ST_TO_ADDR
// end ; end_of_file
25069: LD_VAR 0 2
25073: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25074: LD_INT 0
25076: PPUSH
25077: PPUSH
25078: PPUSH
// pom := GetBase ( fac ) ;
25079: LD_ADDR_VAR 0 5
25083: PUSH
25084: LD_VAR 0 1
25088: PPUSH
25089: CALL_OW 274
25093: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25094: LD_ADDR_VAR 0 4
25098: PUSH
25099: LD_VAR 0 2
25103: PUSH
25104: LD_INT 1
25106: ARRAY
25107: PPUSH
25108: LD_VAR 0 2
25112: PUSH
25113: LD_INT 2
25115: ARRAY
25116: PPUSH
25117: LD_VAR 0 2
25121: PUSH
25122: LD_INT 3
25124: ARRAY
25125: PPUSH
25126: LD_VAR 0 2
25130: PUSH
25131: LD_INT 4
25133: ARRAY
25134: PPUSH
25135: CALL_OW 449
25139: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25140: LD_VAR 0 5
25144: PPUSH
25145: LD_INT 1
25147: PPUSH
25148: CALL_OW 275
25152: PUSH
25153: LD_VAR 0 4
25157: PUSH
25158: LD_INT 1
25160: ARRAY
25161: GREATEREQUAL
25162: PUSH
25163: LD_VAR 0 5
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 275
25175: PUSH
25176: LD_VAR 0 4
25180: PUSH
25181: LD_INT 2
25183: ARRAY
25184: GREATEREQUAL
25185: AND
25186: PUSH
25187: LD_VAR 0 5
25191: PPUSH
25192: LD_INT 3
25194: PPUSH
25195: CALL_OW 275
25199: PUSH
25200: LD_VAR 0 4
25204: PUSH
25205: LD_INT 3
25207: ARRAY
25208: GREATEREQUAL
25209: AND
25210: IFFALSE 25222
// result := true else
25212: LD_ADDR_VAR 0 3
25216: PUSH
25217: LD_INT 1
25219: ST_TO_ADDR
25220: GO 25230
// result := false ;
25222: LD_ADDR_VAR 0 3
25226: PUSH
25227: LD_INT 0
25229: ST_TO_ADDR
// end ;
25230: LD_VAR 0 3
25234: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25235: LD_INT 0
25237: PPUSH
25238: PPUSH
25239: PPUSH
// result := false ;
25240: LD_ADDR_VAR 0 3
25244: PUSH
25245: LD_INT 0
25247: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25248: LD_ADDR_VAR 0 4
25252: PUSH
25253: LD_EXP 52
25257: PUSH
25258: LD_VAR 0 1
25262: ARRAY
25263: ST_TO_ADDR
// if tmp then
25264: LD_VAR 0 4
25268: IFFALSE 25320
// for i = 1 to tmp do
25270: LD_ADDR_VAR 0 5
25274: PUSH
25275: DOUBLE
25276: LD_INT 1
25278: DEC
25279: ST_TO_ADDR
25280: LD_VAR 0 4
25284: PUSH
25285: FOR_TO
25286: IFFALSE 25318
// if component = tmp [ i ] then
25288: LD_VAR 0 2
25292: PUSH
25293: LD_VAR 0 4
25297: PUSH
25298: LD_VAR 0 5
25302: ARRAY
25303: EQUAL
25304: IFFALSE 25316
// begin result := true ;
25306: LD_ADDR_VAR 0 3
25310: PUSH
25311: LD_INT 1
25313: ST_TO_ADDR
// break ;
25314: GO 25318
// end ;
25316: GO 25285
25318: POP
25319: POP
// end ;
25320: LD_VAR 0 3
25324: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25325: LD_INT 0
25327: PPUSH
25328: PPUSH
25329: PPUSH
// if fac then
25330: LD_VAR 0 2
25334: IFFALSE 25569
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_VAR 0 3
25345: PPUSH
25346: CALL 25074 0 2
25350: PUSH
25351: LD_VAR 0 2
25355: PPUSH
25356: CALL_OW 461
25360: PUSH
25361: LD_INT 2
25363: EQUAL
25364: AND
25365: PUSH
25366: LD_VAR 0 2
25370: PPUSH
25371: LD_VAR 0 3
25375: PUSH
25376: LD_INT 1
25378: ARRAY
25379: PPUSH
25380: LD_VAR 0 3
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: PPUSH
25389: LD_VAR 0 3
25393: PUSH
25394: LD_INT 3
25396: ARRAY
25397: PPUSH
25398: LD_VAR 0 3
25402: PUSH
25403: LD_INT 4
25405: ARRAY
25406: PPUSH
25407: CALL_OW 448
25411: AND
25412: IFFALSE 25559
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25414: LD_VAR 0 2
25418: PPUSH
25419: LD_VAR 0 3
25423: PUSH
25424: LD_INT 1
25426: ARRAY
25427: PPUSH
25428: LD_VAR 0 3
25432: PUSH
25433: LD_INT 2
25435: ARRAY
25436: PPUSH
25437: LD_VAR 0 3
25441: PUSH
25442: LD_INT 3
25444: ARRAY
25445: PPUSH
25446: LD_VAR 0 3
25450: PUSH
25451: LD_INT 4
25453: ARRAY
25454: PPUSH
25455: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25459: LD_ADDR_VAR 0 6
25463: PUSH
25464: LD_EXP 52
25468: PUSH
25469: LD_VAR 0 1
25473: ARRAY
25474: ST_TO_ADDR
// for i = 4 downto 1 do
25475: LD_ADDR_VAR 0 5
25479: PUSH
25480: DOUBLE
25481: LD_INT 4
25483: INC
25484: ST_TO_ADDR
25485: LD_INT 1
25487: PUSH
25488: FOR_DOWNTO
25489: IFFALSE 25522
// tab := Remove ( tab , list [ i ] , true ) ;
25491: LD_ADDR_VAR 0 6
25495: PUSH
25496: LD_VAR 0 6
25500: PPUSH
25501: LD_VAR 0 3
25505: PUSH
25506: LD_VAR 0 5
25510: ARRAY
25511: PPUSH
25512: LD_INT 1
25514: PPUSH
25515: CALL 31118 0 3
25519: ST_TO_ADDR
25520: GO 25488
25522: POP
25523: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25524: LD_ADDR_EXP 52
25528: PUSH
25529: LD_EXP 52
25533: PPUSH
25534: LD_VAR 0 1
25538: PPUSH
25539: LD_VAR 0 6
25543: PPUSH
25544: CALL_OW 1
25548: ST_TO_ADDR
// result := true ;
25549: LD_ADDR_VAR 0 4
25553: PUSH
25554: LD_INT 1
25556: ST_TO_ADDR
// end else
25557: GO 25567
// result := false ;
25559: LD_ADDR_VAR 0 4
25563: PUSH
25564: LD_INT 0
25566: ST_TO_ADDR
// end else
25567: GO 25577
// result := false ;
25569: LD_ADDR_VAR 0 4
25573: PUSH
25574: LD_INT 0
25576: ST_TO_ADDR
// end ;
25577: LD_VAR 0 4
25581: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
// if not veh then
25586: LD_VAR 0 2
25590: NOT
25591: IFFALSE 25595
// exit ;
25593: GO 25769
// if MREG_Parking [ side ] then
25595: LD_EXP 59
25599: PUSH
25600: LD_VAR 0 1
25604: ARRAY
25605: IFFALSE 25769
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25607: LD_VAR 0 2
25611: PPUSH
25612: LD_EXP 59
25616: PUSH
25617: LD_VAR 0 1
25621: ARRAY
25622: PPUSH
25623: CALL_OW 308
25627: NOT
25628: IFFALSE 25769
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25630: LD_VAR 0 2
25634: PPUSH
25635: LD_EXP 59
25639: PUSH
25640: LD_VAR 0 1
25644: ARRAY
25645: PPUSH
25646: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25650: LD_VAR 0 2
25654: PPUSH
25655: CALL_OW 263
25659: PUSH
25660: LD_INT 1
25662: EQUAL
25663: IFFALSE 25769
// begin i := GetDriver ( veh ) ;
25665: LD_ADDR_VAR 0 4
25669: PUSH
25670: LD_VAR 0 2
25674: PPUSH
25675: CALL 31653 0 1
25679: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25680: LD_INT 35
25682: PPUSH
25683: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25687: LD_VAR 0 2
25691: PPUSH
25692: LD_EXP 59
25696: PUSH
25697: LD_VAR 0 1
25701: ARRAY
25702: PPUSH
25703: CALL_OW 308
25707: PUSH
25708: LD_VAR 0 2
25712: PPUSH
25713: CALL_OW 301
25717: OR
25718: IFFALSE 25680
// ComExitVehicle ( i ) ;
25720: LD_VAR 0 4
25724: PPUSH
25725: CALL_OW 121
// Wait ( 1 ) ;
25729: LD_INT 1
25731: PPUSH
25732: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25736: LD_VAR 0 4
25740: PPUSH
25741: LD_VAR 0 1
25745: PPUSH
25746: LD_INT 30
25748: PUSH
25749: LD_INT 3
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PPUSH
25756: CALL 11421 0 2
25760: PUSH
25761: LD_INT 1
25763: ARRAY
25764: PPUSH
25765: CALL_OW 180
// end ; end ; end ;
25769: LD_VAR 0 3
25773: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25774: LD_INT 0
25776: PPUSH
25777: PPUSH
25778: PPUSH
25779: PPUSH
25780: PPUSH
25781: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 30
25789: PUSH
25790: LD_INT 3
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PPUSH
25797: CALL 11421 0 2
25801: IFFALSE 25985
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25803: LD_VAR 0 1
25807: PPUSH
25808: LD_INT 30
25810: PUSH
25811: LD_INT 3
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PPUSH
25818: CALL 11421 0 2
25822: PUSH
25823: LD_INT 1
25825: ARRAY
25826: PPUSH
25827: CALL_OW 461
25831: PUSH
25832: LD_INT 2
25834: EQUAL
25835: IFFALSE 25985
// begin for i = 1 to MREG_TurretWeapon do
25837: LD_ADDR_VAR 0 3
25841: PUSH
25842: DOUBLE
25843: LD_INT 1
25845: DEC
25846: ST_TO_ADDR
25847: LD_EXP 44
25851: PUSH
25852: FOR_TO
25853: IFFALSE 25983
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25855: LD_EXP 44
25859: PUSH
25860: LD_VAR 0 3
25864: ARRAY
25865: PUSH
25866: LD_INT 1
25868: ARRAY
25869: PUSH
25870: LD_VAR 0 1
25874: EQUAL
25875: IFFALSE 25981
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25877: LD_ADDR_VAR 0 5
25881: PUSH
25882: LD_EXP 44
25886: PUSH
25887: LD_VAR 0 3
25891: ARRAY
25892: PUSH
25893: LD_INT 2
25895: ARRAY
25896: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25897: LD_ADDR_VAR 0 6
25901: PUSH
25902: LD_EXP 44
25906: PUSH
25907: LD_VAR 0 3
25911: ARRAY
25912: PUSH
25913: LD_INT 3
25915: ARRAY
25916: PUSH
25917: LD_INT 1
25919: ARRAY
25920: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25921: LD_ADDR_VAR 0 7
25925: PUSH
25926: LD_EXP 44
25930: PUSH
25931: LD_VAR 0 3
25935: ARRAY
25936: PUSH
25937: LD_INT 3
25939: ARRAY
25940: PUSH
25941: LD_INT 2
25943: ARRAY
25944: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25945: LD_ADDR_VAR 0 4
25949: PUSH
25950: LD_VAR 0 6
25954: PPUSH
25955: LD_VAR 0 7
25959: PPUSH
25960: CALL_OW 428
25964: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25965: LD_VAR 0 4
25969: PPUSH
25970: LD_VAR 0 5
25974: PPUSH
25975: CALL_OW 148
// break ;
25979: GO 25983
// end ;
25981: GO 25852
25983: POP
25984: POP
// end ; end ;
25985: LD_VAR 0 2
25989: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25990: LD_INT 0
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25996: LD_ADDR_VAR 0 4
26000: PUSH
26001: LD_VAR 0 1
26005: PPUSH
26006: LD_INT 32
26008: PUSH
26009: LD_INT 1
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PPUSH
26016: CALL 11421 0 2
26020: ST_TO_ADDR
// if not tmp then
26021: LD_VAR 0 4
26025: NOT
26026: IFFALSE 26032
// exit else
26028: GO 26114
26030: GO 26114
// begin for i = 1 to tmp do
26032: LD_ADDR_VAR 0 3
26036: PUSH
26037: DOUBLE
26038: LD_INT 1
26040: DEC
26041: ST_TO_ADDR
26042: LD_VAR 0 4
26046: PUSH
26047: FOR_TO
26048: IFFALSE 26112
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26050: LD_VAR 0 4
26054: PUSH
26055: LD_VAR 0 3
26059: ARRAY
26060: PPUSH
26061: CALL_OW 261
26065: PUSH
26066: LD_INT 20
26068: LESS
26069: PUSH
26070: LD_VAR 0 4
26074: PUSH
26075: LD_VAR 0 3
26079: ARRAY
26080: PPUSH
26081: CALL_OW 110
26085: PUSH
26086: LD_INT 0
26088: EQUAL
26089: AND
26090: IFFALSE 26110
// begin SetTag ( tmp [ i ] , 21 ) ;
26092: LD_VAR 0 4
26096: PUSH
26097: LD_VAR 0 3
26101: ARRAY
26102: PPUSH
26103: LD_INT 21
26105: PPUSH
26106: CALL_OW 109
// end ;
26110: GO 26047
26112: POP
26113: POP
// end ; end ;
26114: LD_VAR 0 2
26118: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26119: LD_INT 0
26121: PPUSH
26122: PPUSH
26123: PPUSH
26124: PPUSH
26125: PPUSH
// if not unit then
26126: LD_VAR 0 1
26130: NOT
26131: IFFALSE 26135
// exit ;
26133: GO 26323
// side := GetSide ( unit ) ;
26135: LD_ADDR_VAR 0 3
26139: PUSH
26140: LD_VAR 0 1
26144: PPUSH
26145: CALL_OW 255
26149: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26150: LD_ADDR_VAR 0 5
26154: PUSH
26155: LD_VAR 0 3
26159: PPUSH
26160: LD_INT 2
26162: PUSH
26163: LD_INT 30
26165: PUSH
26166: LD_INT 1
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PUSH
26173: LD_INT 30
26175: PUSH
26176: LD_INT 3
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 30
26185: PUSH
26186: LD_INT 29
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: LIST
26197: LIST
26198: PPUSH
26199: CALL 11421 0 2
26203: ST_TO_ADDR
// if not b then
26204: LD_VAR 0 5
26208: NOT
26209: IFFALSE 26213
// exit ;
26211: GO 26323
// if GetTag ( unit ) = 21 then
26213: LD_VAR 0 1
26217: PPUSH
26218: CALL_OW 110
26222: PUSH
26223: LD_INT 21
26225: EQUAL
26226: IFFALSE 26323
// begin c := NearestUnitToUnit ( b , unit ) ;
26228: LD_ADDR_VAR 0 6
26232: PUSH
26233: LD_VAR 0 5
26237: PPUSH
26238: LD_VAR 0 1
26242: PPUSH
26243: CALL_OW 74
26247: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26248: LD_VAR 0 1
26252: PPUSH
26253: LD_VAR 0 6
26257: PPUSH
26258: CALL_OW 250
26262: PPUSH
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 251
26272: PPUSH
26273: CALL_OW 297
26277: PUSH
26278: LD_INT 6
26280: GREATER
26281: IFFALSE 26299
// ComMoveUnit ( unit , c ) else
26283: LD_VAR 0 1
26287: PPUSH
26288: LD_VAR 0 6
26292: PPUSH
26293: CALL_OW 112
26297: GO 26323
// begin SetFuel ( unit , 100 ) ;
26299: LD_VAR 0 1
26303: PPUSH
26304: LD_INT 100
26306: PPUSH
26307: CALL_OW 240
// SetTag ( unit , 0 ) ;
26311: LD_VAR 0 1
26315: PPUSH
26316: LD_INT 0
26318: PPUSH
26319: CALL_OW 109
// end ; end ; end ;
26323: LD_VAR 0 2
26327: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26328: LD_INT 0
26330: PPUSH
26331: PPUSH
26332: PPUSH
26333: PPUSH
26334: PPUSH
26335: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26336: LD_ADDR_VAR 0 7
26340: PUSH
26341: LD_VAR 0 1
26345: PPUSH
26346: LD_INT 33
26348: PUSH
26349: LD_INT 2
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: LD_INT 3
26358: PUSH
26359: LD_INT 61
26361: PUSH
26362: EMPTY
26363: LIST
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PPUSH
26373: CALL 11421 0 2
26377: ST_TO_ADDR
// if not vehs then
26378: LD_VAR 0 7
26382: NOT
26383: IFFALSE 26387
// exit ;
26385: GO 26672
// if nation = 1 then
26387: LD_VAR 0 2
26391: PUSH
26392: LD_INT 1
26394: EQUAL
26395: IFFALSE 26565
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26397: LD_VAR 0 1
26401: PPUSH
26402: LD_INT 30
26404: PUSH
26405: LD_INT 36
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PPUSH
26412: CALL 11421 0 2
26416: NOT
26417: IFFALSE 26423
// exit else
26419: GO 26672
26421: GO 26563
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26423: LD_ADDR_VAR 0 5
26427: PUSH
26428: LD_VAR 0 1
26432: PPUSH
26433: LD_INT 30
26435: PUSH
26436: LD_INT 36
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PPUSH
26443: CALL 11421 0 2
26447: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26448: LD_ADDR_VAR 0 6
26452: PUSH
26453: LD_VAR 0 5
26457: PUSH
26458: LD_INT 1
26460: ARRAY
26461: PPUSH
26462: CALL_OW 313
26466: ST_TO_ADDR
// for i = vehs downto 1 do
26467: LD_ADDR_VAR 0 4
26471: PUSH
26472: DOUBLE
26473: LD_VAR 0 7
26477: INC
26478: ST_TO_ADDR
26479: LD_INT 1
26481: PUSH
26482: FOR_DOWNTO
26483: IFFALSE 26561
// begin if not IsControledBy ( vehs [ i ] ) then
26485: LD_VAR 0 7
26489: PUSH
26490: LD_VAR 0 4
26494: ARRAY
26495: PPUSH
26496: CALL_OW 312
26500: NOT
26501: IFFALSE 26559
// begin tmp := MCV_RemoteDriver ( oper ) ;
26503: LD_ADDR_VAR 0 8
26507: PUSH
26508: LD_VAR 0 6
26512: PPUSH
26513: CALL 26677 0 1
26517: ST_TO_ADDR
// if not tmp then
26518: LD_VAR 0 8
26522: NOT
26523: IFFALSE 26531
// exit else
26525: POP
26526: POP
26527: GO 26672
26529: GO 26559
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26531: LD_VAR 0 7
26535: PUSH
26536: LD_VAR 0 4
26540: ARRAY
26541: PPUSH
26542: LD_VAR 0 8
26546: PUSH
26547: LD_INT 1
26549: ARRAY
26550: PUSH
26551: LD_INT 1
26553: ARRAY
26554: PPUSH
26555: CALL_OW 135
// end ; end ;
26559: GO 26482
26561: POP
26562: POP
// end ; end else
26563: GO 26672
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26565: LD_VAR 0 1
26569: PPUSH
26570: LD_INT 34
26572: PUSH
26573: LD_INT 31
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PPUSH
26580: CALL 11421 0 2
26584: NOT
26585: IFFALSE 26591
// exit else
26587: GO 26672
26589: GO 26672
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26591: LD_ADDR_VAR 0 5
26595: PUSH
26596: LD_VAR 0 1
26600: PPUSH
26601: LD_INT 34
26603: PUSH
26604: LD_INT 31
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PPUSH
26611: CALL 11421 0 2
26615: ST_TO_ADDR
// oper := [ ] ;
26616: LD_ADDR_VAR 0 6
26620: PUSH
26621: EMPTY
26622: ST_TO_ADDR
// for i = 1 to ct do
26623: LD_ADDR_VAR 0 4
26627: PUSH
26628: DOUBLE
26629: LD_INT 1
26631: DEC
26632: ST_TO_ADDR
26633: LD_VAR 0 5
26637: PUSH
26638: FOR_TO
26639: IFFALSE 26670
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26641: LD_ADDR_VAR 0 6
26645: PUSH
26646: LD_VAR 0 6
26650: PUSH
26651: LD_VAR 0 5
26655: PUSH
26656: LD_VAR 0 4
26660: ARRAY
26661: PPUSH
26662: CALL 31653 0 1
26666: ADD
26667: ST_TO_ADDR
26668: GO 26638
26670: POP
26671: POP
// end ; end ; end ;
26672: LD_VAR 0 3
26676: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26677: LD_INT 0
26679: PPUSH
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
// if not drivers then
26685: LD_VAR 0 1
26689: NOT
26690: IFFALSE 26696
// exit else
26692: GO 26976
26694: GO 26976
// begin linked := [ ] ;
26696: LD_ADDR_VAR 0 5
26700: PUSH
26701: EMPTY
26702: ST_TO_ADDR
// for i = 1 to drivers do
26703: LD_ADDR_VAR 0 3
26707: PUSH
26708: DOUBLE
26709: LD_INT 1
26711: DEC
26712: ST_TO_ADDR
26713: LD_VAR 0 1
26717: PUSH
26718: FOR_TO
26719: IFFALSE 26964
// begin if CanControl ( drivers [ i ] ) then
26721: LD_VAR 0 1
26725: PUSH
26726: LD_VAR 0 3
26730: ARRAY
26731: PPUSH
26732: CALL 32225 0 1
26736: IFFALSE 26962
// if i > 1 then
26738: LD_VAR 0 3
26742: PUSH
26743: LD_INT 1
26745: GREATER
26746: IFFALSE 26923
// begin m := false ;
26748: LD_ADDR_VAR 0 6
26752: PUSH
26753: LD_INT 0
26755: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26756: LD_ADDR_VAR 0 7
26760: PUSH
26761: LD_VAR 0 1
26765: PUSH
26766: LD_VAR 0 3
26770: ARRAY
26771: PPUSH
26772: CALL_OW 432
26776: ST_TO_ADDR
// for j = 1 to linked do
26777: LD_ADDR_VAR 0 4
26781: PUSH
26782: DOUBLE
26783: LD_INT 1
26785: DEC
26786: ST_TO_ADDR
26787: LD_VAR 0 5
26791: PUSH
26792: FOR_TO
26793: IFFALSE 26867
// begin if l < linked [ j ] [ 2 ] then
26795: LD_VAR 0 7
26799: PUSH
26800: LD_VAR 0 5
26804: PUSH
26805: LD_VAR 0 4
26809: ARRAY
26810: PUSH
26811: LD_INT 2
26813: ARRAY
26814: LESS
26815: IFFALSE 26865
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26817: LD_ADDR_VAR 0 5
26821: PUSH
26822: LD_VAR 0 5
26826: PPUSH
26827: LD_INT 1
26829: PPUSH
26830: LD_VAR 0 1
26834: PUSH
26835: LD_VAR 0 3
26839: ARRAY
26840: PUSH
26841: LD_VAR 0 7
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PPUSH
26850: CALL_OW 2
26854: ST_TO_ADDR
// m := true ;
26855: LD_ADDR_VAR 0 6
26859: PUSH
26860: LD_INT 1
26862: ST_TO_ADDR
// break ;
26863: GO 26867
// end ; end ;
26865: GO 26792
26867: POP
26868: POP
// if not m then
26869: LD_VAR 0 6
26873: NOT
26874: IFFALSE 26921
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26876: LD_ADDR_VAR 0 5
26880: PUSH
26881: LD_VAR 0 5
26885: PUSH
26886: LD_VAR 0 1
26890: PUSH
26891: LD_VAR 0 3
26895: ARRAY
26896: PUSH
26897: LD_VAR 0 1
26901: PUSH
26902: LD_VAR 0 3
26906: ARRAY
26907: PPUSH
26908: CALL_OW 432
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: EMPTY
26918: LIST
26919: ADD
26920: ST_TO_ADDR
// end else
26921: GO 26962
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26923: LD_ADDR_VAR 0 5
26927: PUSH
26928: LD_VAR 0 1
26932: PUSH
26933: LD_VAR 0 3
26937: ARRAY
26938: PUSH
26939: LD_VAR 0 1
26943: PUSH
26944: LD_VAR 0 3
26948: ARRAY
26949: PPUSH
26950: CALL_OW 432
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: EMPTY
26960: LIST
26961: ST_TO_ADDR
// end ;
26962: GO 26718
26964: POP
26965: POP
// result := linked ;
26966: LD_ADDR_VAR 0 2
26970: PUSH
26971: LD_VAR 0 5
26975: ST_TO_ADDR
// end ; end ;
26976: LD_VAR 0 2
26980: RET
// export function MCV_ToRepair ( unit ) ; begin
26981: LD_INT 0
26983: PPUSH
// if not unit then
26984: LD_VAR 0 1
26988: NOT
26989: IFFALSE 26995
// exit else
26991: GO 27026
26993: GO 27026
// begin SetTag ( unit , 6 ) ;
26995: LD_VAR 0 1
26999: PPUSH
27000: LD_INT 6
27002: PPUSH
27003: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27007: LD_VAR 0 1
27011: PPUSH
27012: CALL_OW 255
27016: PPUSH
27017: LD_VAR 0 1
27021: PPUSH
27022: CALL 25582 0 2
// end ; end ;
27026: LD_VAR 0 2
27030: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27031: LD_INT 0
27033: PPUSH
27034: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27035: LD_VAR 0 1
27039: PPUSH
27040: LD_INT 6
27042: PPUSH
27043: EMPTY
27044: PPUSH
27045: CALL 12124 0 3
27049: IFFALSE 27142
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27051: LD_ADDR_VAR 0 3
27055: PUSH
27056: DOUBLE
27057: LD_VAR 0 1
27061: PPUSH
27062: LD_INT 6
27064: PPUSH
27065: EMPTY
27066: PPUSH
27067: CALL 12124 0 3
27071: INC
27072: ST_TO_ADDR
27073: LD_INT 1
27075: PUSH
27076: FOR_DOWNTO
27077: IFFALSE 27140
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27079: LD_VAR 0 1
27083: PPUSH
27084: LD_INT 6
27086: PPUSH
27087: EMPTY
27088: PPUSH
27089: CALL 12124 0 3
27093: PUSH
27094: LD_VAR 0 3
27098: ARRAY
27099: PPUSH
27100: CALL_OW 256
27104: PUSH
27105: LD_INT 1000
27107: EQUAL
27108: IFFALSE 27138
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27110: LD_VAR 0 1
27114: PPUSH
27115: LD_INT 6
27117: PPUSH
27118: EMPTY
27119: PPUSH
27120: CALL 12124 0 3
27124: PUSH
27125: LD_VAR 0 3
27129: ARRAY
27130: PPUSH
27131: LD_INT 0
27133: PPUSH
27134: CALL_OW 109
27138: GO 27076
27140: POP
27141: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27142: LD_VAR 0 1
27146: PPUSH
27147: LD_INT 10
27149: PPUSH
27150: EMPTY
27151: PPUSH
27152: CALL 12124 0 3
27156: IFFALSE 27273
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27158: LD_ADDR_VAR 0 3
27162: PUSH
27163: DOUBLE
27164: LD_VAR 0 1
27168: PPUSH
27169: LD_INT 10
27171: PPUSH
27172: EMPTY
27173: PPUSH
27174: CALL 12124 0 3
27178: INC
27179: ST_TO_ADDR
27180: LD_INT 1
27182: PUSH
27183: FOR_DOWNTO
27184: IFFALSE 27271
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27186: LD_VAR 0 1
27190: PPUSH
27191: LD_INT 10
27193: PPUSH
27194: EMPTY
27195: PPUSH
27196: CALL 12124 0 3
27200: PUSH
27201: LD_VAR 0 3
27205: ARRAY
27206: PPUSH
27207: CALL_OW 302
27211: NOT
27212: PUSH
27213: LD_VAR 0 1
27217: PPUSH
27218: LD_INT 10
27220: PPUSH
27221: EMPTY
27222: PPUSH
27223: CALL 12124 0 3
27227: PUSH
27228: LD_VAR 0 3
27232: ARRAY
27233: PPUSH
27234: CALL_OW 301
27238: OR
27239: IFFALSE 27269
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27241: LD_VAR 0 1
27245: PPUSH
27246: LD_INT 10
27248: PPUSH
27249: EMPTY
27250: PPUSH
27251: CALL 12124 0 3
27255: PUSH
27256: LD_VAR 0 3
27260: ARRAY
27261: PPUSH
27262: LD_INT 0
27264: PPUSH
27265: CALL_OW 109
27269: GO 27183
27271: POP
27272: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27273: LD_ADDR_VAR 0 3
27277: PUSH
27278: LD_VAR 0 1
27282: PPUSH
27283: EMPTY
27284: PPUSH
27285: CALL 11722 0 2
27289: PUSH
27290: LD_VAR 0 1
27294: PPUSH
27295: LD_INT 7
27297: PPUSH
27298: EMPTY
27299: PPUSH
27300: CALL 12124 0 3
27304: DIFF
27305: PUSH
27306: FOR_IN
27307: IFFALSE 27351
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27309: LD_VAR 0 3
27313: PPUSH
27314: CALL_OW 256
27318: PUSH
27319: LD_INT 650
27321: LESS
27322: PUSH
27323: LD_VAR 0 3
27327: PPUSH
27328: CALL_OW 110
27332: PUSH
27333: LD_INT 6
27335: EQUAL
27336: NOT
27337: AND
27338: IFFALSE 27349
// MCV_ToRepair ( i ) ;
27340: LD_VAR 0 3
27344: PPUSH
27345: CALL 26981 0 1
27349: GO 27306
27351: POP
27352: POP
// end ; end_of_file end_of_file
27353: LD_VAR 0 2
27357: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27358: LD_STRING SAILEvent [
27360: PUSH
27361: LD_VAR 0 1
27365: STR
27366: PUSH
27367: LD_STRING ]
27369: STR
27370: PPUSH
27371: CALL 7818 0 1
// if event = 101 and dialog_north then
27375: LD_VAR 0 1
27379: PUSH
27380: LD_INT 101
27382: EQUAL
27383: PUSH
27384: LD_EXP 5
27388: AND
27389: IFFALSE 27453
// begin dialog_north := false ;
27391: LD_ADDR_EXP 5
27395: PUSH
27396: LD_INT 0
27398: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27399: LD_EXP 4
27403: PPUSH
27404: LD_STRING DS1
27406: PUSH
27407: LD_STRING DS2
27409: PUSH
27410: LD_STRING DS3
27412: PUSH
27413: LD_STRING DS6
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 1
27424: PPUSH
27425: LD_INT 4
27427: PPUSH
27428: CALL_OW 12
27432: ARRAY
27433: PPUSH
27434: CALL_OW 94
// Wait ( 4 4$00 ) ;
27438: LD_INT 8400
27440: PPUSH
27441: CALL_OW 67
// dialog_north := true ;
27445: LD_ADDR_EXP 5
27449: PUSH
27450: LD_INT 1
27452: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27453: LD_VAR 0 1
27457: PUSH
27458: LD_INT 102
27460: EQUAL
27461: PUSH
27462: LD_EXP 6
27466: AND
27467: IFFALSE 27527
// begin dialog_south := false ;
27469: LD_ADDR_EXP 6
27473: PUSH
27474: LD_INT 0
27476: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27477: LD_EXP 3
27481: PPUSH
27482: LD_STRING DJ1
27484: PUSH
27485: LD_STRING DJ4
27487: PUSH
27488: LD_STRING DJ6
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 1
27498: PPUSH
27499: LD_INT 3
27501: PPUSH
27502: CALL_OW 12
27506: ARRAY
27507: PPUSH
27508: CALL_OW 94
// Wait ( 4 4$00 ) ;
27512: LD_INT 8400
27514: PPUSH
27515: CALL_OW 67
// dialog_south := true ;
27519: LD_ADDR_EXP 6
27523: PUSH
27524: LD_INT 1
27526: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27527: LD_VAR 0 1
27531: PUSH
27532: LD_INT 104
27534: EQUAL
27535: PUSH
27536: LD_EXP 7
27540: AND
27541: IFFALSE 27563
// begin dialog_popov := false ;
27543: LD_ADDR_EXP 7
27547: PUSH
27548: LD_INT 0
27550: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27551: LD_EXP 25
27555: PPUSH
27556: LD_STRING DR4
27558: PPUSH
27559: CALL_OW 94
// end ; end ;
27563: PPOPN 1
27565: END
// on BuildingStarted ( b , unit ) do var side , i ;
27566: LD_INT 0
27568: PPUSH
27569: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27570: LD_EXP 40
27574: PUSH
27575: LD_VAR 0 1
27579: PPUSH
27580: CALL_OW 255
27584: ARRAY
27585: IFFALSE 27763
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27587: LD_STRING BuildingStarted [side: 
27589: PUSH
27590: LD_VAR 0 1
27594: PPUSH
27595: CALL_OW 255
27599: STR
27600: PUSH
27601: LD_STRING ; btype: 
27603: STR
27604: PUSH
27605: LD_VAR 0 1
27609: PPUSH
27610: CALL_OW 266
27614: STR
27615: PUSH
27616: LD_STRING ; unit: 
27618: STR
27619: PUSH
27620: LD_VAR 0 2
27624: STR
27625: PUSH
27626: LD_STRING ]
27628: STR
27629: PPUSH
27630: CALL 7818 0 1
// side := GetSide ( b ) ;
27634: LD_ADDR_VAR 0 3
27638: PUSH
27639: LD_VAR 0 1
27643: PPUSH
27644: CALL_OW 255
27648: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27649: LD_VAR 0 3
27653: PPUSH
27654: LD_INT 21
27656: PUSH
27657: LD_INT 3
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PPUSH
27664: CALL 11421 0 2
27668: PUSH
27669: LD_INT 1
27671: EQUAL
27672: IFFALSE 27763
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27674: LD_ADDR_VAR 0 4
27678: PUSH
27679: LD_VAR 0 3
27683: PPUSH
27684: LD_INT 21
27686: PUSH
27687: LD_INT 1
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PPUSH
27694: CALL 11421 0 2
27698: PUSH
27699: LD_VAR 0 3
27703: PPUSH
27704: LD_INT 2
27706: PPUSH
27707: EMPTY
27708: PPUSH
27709: CALL 11504 0 3
27713: DIFF
27714: PUSH
27715: FOR_IN
27716: IFFALSE 27761
// if not HasTask ( i ) then
27718: LD_VAR 0 4
27722: PPUSH
27723: CALL_OW 314
27727: NOT
27728: IFFALSE 27759
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27730: LD_VAR 0 4
27734: PPUSH
27735: LD_VAR 0 1
27739: PPUSH
27740: CALL_OW 250
27744: PPUSH
27745: LD_VAR 0 1
27749: PPUSH
27750: CALL_OW 251
27754: PPUSH
27755: CALL_OW 111
27759: GO 27715
27761: POP
27762: POP
// end ;
27763: PPOPN 4
27765: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27766: LD_EXP 40
27770: PUSH
27771: LD_VAR 0 1
27775: PPUSH
27776: CALL_OW 255
27780: ARRAY
27781: IFFALSE 28150
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27783: LD_STRING BuildingComplete [side: 
27785: PUSH
27786: LD_VAR 0 1
27790: PPUSH
27791: CALL_OW 255
27795: STR
27796: PUSH
27797: LD_STRING ; btype: 
27799: STR
27800: PUSH
27801: LD_VAR 0 1
27805: PPUSH
27806: CALL_OW 266
27810: STR
27811: PUSH
27812: LD_STRING ]
27814: STR
27815: PPUSH
27816: CALL 7818 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27820: LD_ADDR_EXP 47
27824: PUSH
27825: LD_EXP 47
27829: PPUSH
27830: LD_VAR 0 1
27834: PPUSH
27835: CALL_OW 255
27839: PPUSH
27840: LD_VAR 0 1
27844: PPUSH
27845: CALL_OW 266
27849: PPUSH
27850: LD_VAR 0 1
27854: PPUSH
27855: CALL_OW 250
27859: PUSH
27860: LD_VAR 0 1
27864: PPUSH
27865: CALL_OW 251
27869: PUSH
27870: LD_VAR 0 1
27874: PPUSH
27875: CALL_OW 254
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: LIST
27884: PPUSH
27885: CALL 42332 0 4
27889: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27890: LD_VAR 0 1
27894: PPUSH
27895: CALL_OW 266
27899: PUSH
27900: LD_INT 6
27902: EQUAL
27903: IFFALSE 27937
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27905: LD_ADDR_EXP 41
27909: PUSH
27910: LD_EXP 41
27914: PPUSH
27915: LD_VAR 0 1
27919: PPUSH
27920: CALL_OW 255
27924: PPUSH
27925: LD_VAR 0 1
27929: PPUSH
27930: EMPTY
27931: PPUSH
27932: CALL 42241 0 4
27936: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27937: LD_VAR 0 1
27941: PPUSH
27942: CALL_OW 266
27946: PUSH
27947: LD_INT 0
27949: EQUAL
27950: IFFALSE 28060
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27952: LD_ADDR_EXP 49
27956: PUSH
27957: LD_EXP 49
27961: PPUSH
27962: LD_VAR 0 1
27966: PPUSH
27967: CALL_OW 255
27971: PPUSH
27972: LD_INT 0
27974: PPUSH
27975: EMPTY
27976: PPUSH
27977: CALL 42241 0 4
27981: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27982: LD_VAR 0 1
27986: PPUSH
27987: CALL_OW 274
27991: PPUSH
27992: LD_INT 1
27994: PPUSH
27995: LD_EXP 73
27999: PUSH
28000: LD_INT 1
28002: ARRAY
28003: PPUSH
28004: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 274
28017: PPUSH
28018: LD_INT 2
28020: PPUSH
28021: LD_EXP 73
28025: PUSH
28026: LD_INT 2
28028: ARRAY
28029: PPUSH
28030: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28034: LD_VAR 0 1
28038: PPUSH
28039: CALL_OW 274
28043: PPUSH
28044: LD_INT 3
28046: PPUSH
28047: LD_EXP 73
28051: PUSH
28052: LD_INT 3
28054: ARRAY
28055: PPUSH
28056: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28060: LD_VAR 0 1
28064: PPUSH
28065: CALL_OW 266
28069: PUSH
28070: LD_INT 2
28072: EQUAL
28073: IFFALSE 28105
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28075: LD_ADDR_EXP 49
28079: PUSH
28080: LD_EXP 49
28084: PPUSH
28085: LD_VAR 0 1
28089: PPUSH
28090: CALL_OW 255
28094: PPUSH
28095: LD_INT 2
28097: PPUSH
28098: EMPTY
28099: PPUSH
28100: CALL 42241 0 4
28104: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28105: LD_VAR 0 1
28109: PPUSH
28110: CALL_OW 266
28114: PUSH
28115: LD_INT 4
28117: EQUAL
28118: IFFALSE 28150
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28120: LD_ADDR_EXP 49
28124: PUSH
28125: LD_EXP 49
28129: PPUSH
28130: LD_VAR 0 1
28134: PPUSH
28135: CALL_OW 255
28139: PPUSH
28140: LD_INT 4
28142: PPUSH
28143: EMPTY
28144: PPUSH
28145: CALL 42241 0 4
28149: ST_TO_ADDR
// end ;
28150: PPOPN 1
28152: END
// on ResearchComplete ( tech , lab ) do var i ;
28153: LD_INT 0
28155: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28156: LD_EXP 40
28160: PUSH
28161: LD_VAR 0 2
28165: PPUSH
28166: CALL_OW 255
28170: ARRAY
28171: IFFALSE 28455
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28173: LD_STRING ResearchComplete [side: 
28175: PUSH
28176: LD_VAR 0 2
28180: PPUSH
28181: CALL_OW 255
28185: PPUSH
28186: CALL_OW 255
28190: STR
28191: PUSH
28192: LD_STRING ; tech:
28194: STR
28195: PUSH
28196: LD_VAR 0 1
28200: STR
28201: PUSH
28202: LD_STRING ]
28204: STR
28205: PPUSH
28206: CALL 7818 0 1
// for i = 1 to MREG_ToRes do
28210: LD_ADDR_VAR 0 3
28214: PUSH
28215: DOUBLE
28216: LD_INT 1
28218: DEC
28219: ST_TO_ADDR
28220: LD_EXP 51
28224: PUSH
28225: FOR_TO
28226: IFFALSE 28313
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28228: LD_EXP 51
28232: PUSH
28233: LD_VAR 0 3
28237: ARRAY
28238: PUSH
28239: LD_INT 1
28241: ARRAY
28242: PUSH
28243: LD_VAR 0 2
28247: PPUSH
28248: CALL_OW 255
28252: EQUAL
28253: PUSH
28254: LD_EXP 51
28258: PUSH
28259: LD_VAR 0 3
28263: ARRAY
28264: PUSH
28265: LD_INT 2
28267: ARRAY
28268: PUSH
28269: LD_VAR 0 1
28273: EQUAL
28274: AND
28275: IFFALSE 28311
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28277: LD_ADDR_EXP 51
28281: PUSH
28282: LD_EXP 51
28286: PPUSH
28287: LD_VAR 0 2
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_VAR 0 1
28301: PPUSH
28302: EMPTY
28303: PPUSH
28304: CALL 42332 0 4
28308: ST_TO_ADDR
// break ;
28309: GO 28313
// end ;
28311: GO 28225
28313: POP
28314: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28315: LD_VAR 0 1
28319: PUSH
28320: LD_INT 2
28322: PUSH
28323: LD_INT 11
28325: PUSH
28326: LD_INT 4
28328: PUSH
28329: LD_INT 3
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: IN
28338: IFFALSE 28455
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28340: LD_ADDR_VAR 0 3
28344: PUSH
28345: LD_VAR 0 2
28349: PPUSH
28350: CALL_OW 255
28354: PPUSH
28355: LD_INT 16
28357: PPUSH
28358: LD_INT 25
28360: PUSH
28361: LD_INT 4
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PPUSH
28368: CALL 12124 0 3
28372: ST_TO_ADDR
// if i then
28373: LD_VAR 0 3
28377: IFFALSE 28395
// SetTag ( i [ 1 ] , 0 ) ;
28379: LD_VAR 0 3
28383: PUSH
28384: LD_INT 1
28386: ARRAY
28387: PPUSH
28388: LD_INT 0
28390: PPUSH
28391: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28395: LD_ADDR_VAR 0 3
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: PPUSH
28410: LD_INT 171
28412: PPUSH
28413: EMPTY
28414: PPUSH
28415: CALL 12124 0 3
28419: ST_TO_ADDR
// if i then
28420: LD_VAR 0 3
28424: IFFALSE 28455
// begin SetTag ( i [ 1 ] , 0 ) ;
28426: LD_VAR 0 3
28430: PUSH
28431: LD_INT 1
28433: ARRAY
28434: PPUSH
28435: LD_INT 0
28437: PPUSH
28438: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28442: LD_VAR 0 3
28446: PUSH
28447: LD_INT 1
28449: ARRAY
28450: PPUSH
28451: CALL_OW 122
// end ; end ; end ;
28455: PPOPN 3
28457: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28458: LD_INT 0
28460: PPUSH
28461: PPUSH
28462: PPUSH
28463: PPUSH
28464: PPUSH
28465: PPUSH
28466: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28467: LD_EXP 40
28471: PUSH
28472: LD_VAR 0 2
28476: PPUSH
28477: CALL_OW 255
28481: ARRAY
28482: IFFALSE 29209
// begin side := GetSide ( veh ) ;
28484: LD_ADDR_VAR 0 4
28488: PUSH
28489: LD_VAR 0 1
28493: PPUSH
28494: CALL_OW 255
28498: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28499: LD_ADDR_VAR 0 6
28503: PUSH
28504: LD_VAR 0 1
28508: PPUSH
28509: CALL_OW 265
28513: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28514: LD_ADDR_VAR 0 7
28518: PUSH
28519: LD_VAR 0 1
28523: PPUSH
28524: CALL_OW 262
28528: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28529: LD_ADDR_VAR 0 8
28533: PUSH
28534: LD_VAR 0 1
28538: PPUSH
28539: CALL_OW 263
28543: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 1
28553: PPUSH
28554: CALL_OW 264
28558: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28559: LD_STRING VehicleConstructed [side: 
28561: PUSH
28562: LD_VAR 0 4
28566: STR
28567: PUSH
28568: LD_STRING ; id:
28570: STR
28571: PUSH
28572: LD_VAR 0 1
28576: STR
28577: PUSH
28578: LD_STRING ; components: [
28580: STR
28581: PUSH
28582: LD_VAR 0 6
28586: STR
28587: PUSH
28588: LD_STRING , 
28590: STR
28591: PUSH
28592: LD_VAR 0 7
28596: STR
28597: PUSH
28598: LD_STRING , 
28600: STR
28601: PUSH
28602: LD_VAR 0 8
28606: STR
28607: PUSH
28608: LD_STRING , 
28610: STR
28611: PUSH
28612: LD_VAR 0 9
28616: STR
28617: PUSH
28618: LD_STRING ]]
28620: STR
28621: PPUSH
28622: CALL 7818 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28626: LD_VAR 0 1
28630: PPUSH
28631: CALL_OW 264
28635: PUSH
28636: LD_INT 13
28638: PUSH
28639: LD_INT 12
28641: PUSH
28642: LD_INT 14
28644: PUSH
28645: LD_INT 51
28647: PUSH
28648: LD_INT 53
28650: PUSH
28651: LD_INT 52
28653: PUSH
28654: LD_INT 32
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: IN
28666: NOT
28667: IFFALSE 28709
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28669: LD_ADDR_EXP 60
28673: PUSH
28674: LD_EXP 60
28678: PPUSH
28679: LD_VAR 0 4
28683: PPUSH
28684: LD_EXP 60
28688: PUSH
28689: LD_VAR 0 4
28693: ARRAY
28694: PUSH
28695: LD_INT 1
28697: PLUS
28698: PPUSH
28699: LD_VAR 0 1
28703: PPUSH
28704: CALL 30959 0 4
28708: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28709: LD_VAR 0 1
28713: PPUSH
28714: CALL_OW 264
28718: PUSH
28719: LD_INT 31
28721: EQUAL
28722: IFFALSE 28741
// SetTag ( GetDriver ( veh ) , 9 ) ;
28724: LD_VAR 0 1
28728: PPUSH
28729: CALL 31653 0 1
28733: PPUSH
28734: LD_INT 9
28736: PPUSH
28737: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28741: LD_VAR 0 1
28745: PPUSH
28746: CALL_OW 264
28750: PUSH
28751: LD_INT 14
28753: PUSH
28754: LD_INT 53
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: IN
28761: IFFALSE 28798
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28763: LD_ADDR_EXP 43
28767: PUSH
28768: LD_EXP 43
28772: PPUSH
28773: LD_VAR 0 1
28777: PPUSH
28778: CALL_OW 255
28782: PPUSH
28783: LD_INT 2
28785: PPUSH
28786: LD_VAR 0 1
28790: PPUSH
28791: CALL 30959 0 4
28795: ST_TO_ADDR
// exit ;
28796: GO 29209
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28798: LD_VAR 0 1
28802: PPUSH
28803: CALL_OW 265
28807: PUSH
28808: LD_EXP 67
28812: PUSH
28813: LD_VAR 0 4
28817: ARRAY
28818: PUSH
28819: LD_INT 1
28821: ARRAY
28822: IN
28823: PUSH
28824: LD_VAR 0 1
28828: PPUSH
28829: CALL_OW 262
28833: PUSH
28834: LD_EXP 67
28838: PUSH
28839: LD_VAR 0 4
28843: ARRAY
28844: PUSH
28845: LD_INT 1
28847: ARRAY
28848: IN
28849: AND
28850: PUSH
28851: LD_VAR 0 1
28855: PPUSH
28856: CALL_OW 263
28860: PUSH
28861: LD_EXP 67
28865: PUSH
28866: LD_VAR 0 4
28870: ARRAY
28871: PUSH
28872: LD_INT 1
28874: ARRAY
28875: IN
28876: AND
28877: PUSH
28878: LD_VAR 0 1
28882: PPUSH
28883: CALL_OW 264
28887: PUSH
28888: LD_EXP 67
28892: PUSH
28893: LD_VAR 0 4
28897: ARRAY
28898: PUSH
28899: LD_INT 1
28901: ARRAY
28902: IN
28903: AND
28904: IFFALSE 28948
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28906: LD_ADDR_EXP 68
28910: PUSH
28911: LD_EXP 68
28915: PPUSH
28916: LD_VAR 0 4
28920: PPUSH
28921: LD_EXP 68
28925: PUSH
28926: LD_VAR 0 4
28930: ARRAY
28931: PUSH
28932: LD_INT 1
28934: PLUS
28935: PPUSH
28936: LD_VAR 0 1
28940: PPUSH
28941: CALL 30959 0 4
28945: ST_TO_ADDR
// exit ;
28946: GO 29209
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28948: LD_VAR 0 6
28952: PUSH
28953: LD_EXP 70
28957: PUSH
28958: LD_VAR 0 4
28962: ARRAY
28963: PUSH
28964: LD_INT 1
28966: ARRAY
28967: EQUAL
28968: PUSH
28969: LD_VAR 0 7
28973: PUSH
28974: LD_EXP 70
28978: PUSH
28979: LD_VAR 0 4
28983: ARRAY
28984: PUSH
28985: LD_INT 2
28987: ARRAY
28988: EQUAL
28989: AND
28990: PUSH
28991: LD_VAR 0 8
28995: PUSH
28996: LD_EXP 70
29000: PUSH
29001: LD_VAR 0 4
29005: ARRAY
29006: PUSH
29007: LD_INT 3
29009: ARRAY
29010: EQUAL
29011: AND
29012: PUSH
29013: LD_VAR 0 9
29017: PUSH
29018: LD_EXP 70
29022: PUSH
29023: LD_VAR 0 4
29027: ARRAY
29028: PUSH
29029: LD_INT 4
29031: ARRAY
29032: EQUAL
29033: AND
29034: IFFALSE 29190
// begin tmp := MREG_ToAttack [ side ] ;
29036: LD_ADDR_VAR 0 5
29040: PUSH
29041: LD_EXP 70
29045: PUSH
29046: LD_VAR 0 4
29050: ARRAY
29051: ST_TO_ADDR
// for i = 1 to 4 do
29052: LD_ADDR_VAR 0 3
29056: PUSH
29057: DOUBLE
29058: LD_INT 1
29060: DEC
29061: ST_TO_ADDR
29062: LD_INT 4
29064: PUSH
29065: FOR_TO
29066: IFFALSE 29088
// tmp := Delete ( tmp , 1 ) ;
29068: LD_ADDR_VAR 0 5
29072: PUSH
29073: LD_VAR 0 5
29077: PPUSH
29078: LD_INT 1
29080: PPUSH
29081: CALL_OW 3
29085: ST_TO_ADDR
29086: GO 29065
29088: POP
29089: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29090: LD_ADDR_EXP 70
29094: PUSH
29095: LD_EXP 70
29099: PPUSH
29100: LD_VAR 0 4
29104: PPUSH
29105: LD_VAR 0 5
29109: PPUSH
29110: CALL_OW 1
29114: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29115: LD_ADDR_EXP 72
29119: PUSH
29120: LD_EXP 72
29124: PPUSH
29125: LD_VAR 0 4
29129: PPUSH
29130: LD_EXP 72
29134: PUSH
29135: LD_VAR 0 4
29139: ARRAY
29140: PUSH
29141: LD_INT 1
29143: PLUS
29144: PPUSH
29145: LD_VAR 0 1
29149: PPUSH
29150: CALL 30959 0 4
29154: ST_TO_ADDR
// if tmp = 0 then
29155: LD_VAR 0 5
29159: PUSH
29160: LD_INT 0
29162: EQUAL
29163: IFFALSE 29188
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29165: LD_ADDR_EXP 70
29169: PUSH
29170: LD_EXP 70
29174: PPUSH
29175: LD_VAR 0 4
29179: PPUSH
29180: LD_INT 0
29182: PPUSH
29183: CALL_OW 1
29187: ST_TO_ADDR
// exit ;
29188: GO 29209
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29190: LD_VAR 0 1
29194: PPUSH
29195: CALL_OW 255
29199: PPUSH
29200: LD_VAR 0 1
29204: PPUSH
29205: CALL 25582 0 2
// end ;
29209: PPOPN 9
29211: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29212: LD_EXP 40
29216: PUSH
29217: LD_VAR 0 2
29221: PPUSH
29222: CALL_OW 255
29226: ARRAY
29227: IFFALSE 29459
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29229: LD_STRING ApemanTamed [side: 
29231: PUSH
29232: LD_VAR 0 2
29236: PPUSH
29237: CALL_OW 255
29241: STR
29242: PUSH
29243: LD_STRING ; sci: 
29245: STR
29246: PUSH
29247: LD_VAR 0 2
29251: STR
29252: PUSH
29253: LD_STRING ; ape: 
29255: STR
29256: PUSH
29257: LD_VAR 0 1
29261: STR
29262: PUSH
29263: LD_STRING ]
29265: STR
29266: PPUSH
29267: CALL 7818 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29271: LD_INT 11
29273: PPUSH
29274: LD_VAR 0 2
29278: PPUSH
29279: CALL_OW 255
29283: PPUSH
29284: CALL_OW 321
29288: PUSH
29289: LD_INT 2
29291: EQUAL
29292: NOT
29293: PUSH
29294: LD_INT 2
29296: PPUSH
29297: LD_VAR 0 2
29301: PPUSH
29302: CALL_OW 255
29306: PPUSH
29307: CALL_OW 321
29311: PUSH
29312: LD_INT 2
29314: EQUAL
29315: NOT
29316: OR
29317: PUSH
29318: LD_VAR 0 2
29322: PPUSH
29323: CALL_OW 255
29327: PPUSH
29328: LD_INT 171
29330: PPUSH
29331: EMPTY
29332: PPUSH
29333: CALL 12124 0 3
29337: PUSH
29338: LD_INT 0
29340: EQUAL
29341: AND
29342: IFFALSE 29356
// begin SetTag ( ape , 171 ) ;
29344: LD_VAR 0 1
29348: PPUSH
29349: LD_INT 171
29351: PPUSH
29352: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29356: LD_VAR 0 2
29360: PPUSH
29361: CALL_OW 255
29365: PPUSH
29366: LD_INT 30
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PPUSH
29376: CALL 11421 0 2
29380: IFFALSE 29459
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29382: LD_VAR 0 1
29386: PPUSH
29387: LD_VAR 0 2
29391: PPUSH
29392: CALL_OW 255
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL 11421 0 2
29411: PUSH
29412: LD_INT 1
29414: ARRAY
29415: PPUSH
29416: CALL_OW 250
29420: PPUSH
29421: LD_VAR 0 2
29425: PPUSH
29426: CALL_OW 255
29430: PPUSH
29431: LD_INT 30
29433: PUSH
29434: LD_INT 1
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PPUSH
29441: CALL 11421 0 2
29445: PUSH
29446: LD_INT 1
29448: ARRAY
29449: PPUSH
29450: CALL_OW 251
29454: PPUSH
29455: CALL_OW 111
// end ;
29459: PPOPN 2
29461: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29462: LD_EXP 40
29466: PUSH
29467: LD_VAR 0 1
29471: PPUSH
29472: CALL_OW 255
29476: ARRAY
29477: IFFALSE 29755
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29479: LD_VAR 0 2
29483: PUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: CALL 11834 0 1
29498: IN
29499: IFFALSE 29640
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29501: LD_VAR 0 1
29505: PPUSH
29506: CALL_OW 266
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: IN
29521: IFFALSE 29551
// begin Wait ( 0 0$0.3 ) ;
29523: LD_INT 10
29525: PPUSH
29526: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29530: LD_VAR 0 2
29534: PPUSH
29535: LD_INT 16
29537: PPUSH
29538: CALL_OW 336
// ComExitBuilding ( un ) ;
29542: LD_VAR 0 2
29546: PPUSH
29547: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29551: LD_VAR 0 1
29555: PPUSH
29556: CALL_OW 266
29560: PUSH
29561: LD_INT 4
29563: PUSH
29564: LD_INT 5
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: IN
29571: IFFALSE 29640
// begin Wait ( 0 0$0.3 ) ;
29573: LD_INT 10
29575: PPUSH
29576: CALL_OW 67
// if GetTag ( un ) = 0 then
29580: LD_VAR 0 2
29584: PPUSH
29585: CALL_OW 110
29589: PUSH
29590: LD_INT 0
29592: EQUAL
29593: IFFALSE 29609
// SetClass ( un , class_apeman_soldier ) else
29595: LD_VAR 0 2
29599: PPUSH
29600: LD_INT 15
29602: PPUSH
29603: CALL_OW 336
29607: GO 29640
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29609: LD_INT 3
29611: PPUSH
29612: LD_VAR 0 2
29616: PPUSH
29617: CALL_OW 255
29621: PPUSH
29622: CALL_OW 321
29626: IFFALSE 29640
// SetClass ( un , class_apeman_kamikaze ) ;
29628: LD_VAR 0 2
29632: PPUSH
29633: LD_INT 17
29635: PPUSH
29636: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 266
29649: PUSH
29650: LD_INT 32
29652: EQUAL
29653: IFFALSE 29755
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29655: LD_ADDR_EXP 69
29659: PUSH
29660: LD_EXP 69
29664: PPUSH
29665: LD_VAR 0 1
29669: PPUSH
29670: CALL_OW 255
29674: PPUSH
29675: LD_EXP 69
29679: PUSH
29680: LD_VAR 0 1
29684: PPUSH
29685: CALL_OW 255
29689: ARRAY
29690: PUSH
29691: LD_INT 1
29693: PLUS
29694: PPUSH
29695: LD_VAR 0 1
29699: PPUSH
29700: CALL 30959 0 4
29704: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29705: LD_ADDR_EXP 69
29709: PUSH
29710: LD_EXP 69
29714: PPUSH
29715: LD_VAR 0 1
29719: PPUSH
29720: CALL_OW 255
29724: PPUSH
29725: LD_EXP 69
29729: PUSH
29730: LD_VAR 0 1
29734: PPUSH
29735: CALL_OW 255
29739: ARRAY
29740: PUSH
29741: LD_INT 1
29743: PLUS
29744: PPUSH
29745: LD_VAR 0 2
29749: PPUSH
29750: CALL 30959 0 4
29754: ST_TO_ADDR
// end ; end ;
29755: PPOPN 2
29757: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29758: LD_VAR 0 1
29762: PPUSH
29763: CALL 54674 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29767: LD_VAR 0 1
29771: PUSH
29772: LD_INT 22
29774: PUSH
29775: LD_INT 3
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 23
29784: PUSH
29785: LD_INT 3
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 21
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: LIST
29806: PPUSH
29807: CALL_OW 69
29811: IN
29812: IFFALSE 29828
// player_loss := player_loss + 1 ;
29814: LD_ADDR_EXP 9
29818: PUSH
29819: LD_EXP 9
29823: PUSH
29824: LD_INT 1
29826: PLUS
29827: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29828: LD_VAR 0 1
29832: PUSH
29833: LD_INT 22
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 21
29845: PUSH
29846: LD_INT 3
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PPUSH
29857: CALL_OW 69
29861: IN
29862: PUSH
29863: LD_EXP 14
29867: NOT
29868: AND
29869: IFFALSE 29932
// begin alfa_north_triggered := true ;
29871: LD_ADDR_EXP 14
29875: PUSH
29876: LD_INT 1
29878: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29879: LD_EXP 4
29883: PPUSH
29884: LD_STRING DS4
29886: PPUSH
29887: CALL_OW 94
// Wait ( 1 1$25 ) ;
29891: LD_INT 2975
29893: PPUSH
29894: CALL_OW 67
// if not isTest then
29898: LD_EXP 1
29902: NOT
29903: IFFALSE 29932
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29905: LD_INT 20
29907: PPUSH
29908: LD_INT 5
29910: PUSH
29911: LD_INT 6
29913: PUSH
29914: LD_INT 7
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: LIST
29921: PUSH
29922: LD_OWVAR 67
29926: ARRAY
29927: PPUSH
29928: CALL 6956 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29932: LD_VAR 0 1
29936: PUSH
29937: LD_INT 22
29939: PUSH
29940: LD_INT 4
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 21
29949: PUSH
29950: LD_INT 3
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PPUSH
29961: CALL_OW 69
29965: IN
29966: PUSH
29967: LD_EXP 15
29971: NOT
29972: AND
29973: IFFALSE 30036
// begin alfa_south_triggered := true ;
29975: LD_ADDR_EXP 15
29979: PUSH
29980: LD_INT 1
29982: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29983: LD_EXP 3
29987: PPUSH
29988: LD_STRING DJ3
29990: PPUSH
29991: CALL_OW 94
// Wait ( 0 0$45 ) ;
29995: LD_INT 1575
29997: PPUSH
29998: CALL_OW 67
// if not isTest then
30002: LD_EXP 1
30006: NOT
30007: IFFALSE 30036
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30009: LD_INT 20
30011: PPUSH
30012: LD_INT 5
30014: PUSH
30015: LD_INT 6
30017: PUSH
30018: LD_INT 7
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: LIST
30025: PUSH
30026: LD_OWVAR 67
30030: ARRAY
30031: PPUSH
30032: CALL 6956 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30036: LD_VAR 0 1
30040: PPUSH
30041: CALL_OW 266
30045: PUSH
30046: LD_INT 1
30048: EQUAL
30049: PUSH
30050: LD_VAR 0 1
30054: PPUSH
30055: CALL_OW 255
30059: PUSH
30060: LD_INT 1
30062: PUSH
30063: LD_INT 4
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: IN
30070: AND
30071: IFFALSE 30080
// RaiseSailEvent ( 104 ) ;
30073: LD_INT 104
30075: PPUSH
30076: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30080: LD_EXP 40
30084: PUSH
30085: LD_VAR 0 1
30089: PPUSH
30090: CALL_OW 255
30094: ARRAY
30095: IFFALSE 30482
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30097: LD_STRING UnitDestroyed [side 
30099: PUSH
30100: LD_VAR 0 1
30104: PPUSH
30105: CALL_OW 255
30109: STR
30110: PUSH
30111: LD_STRING ; id: 
30113: STR
30114: PUSH
30115: LD_VAR 0 1
30119: STR
30120: PUSH
30121: LD_STRING ; type: 
30123: STR
30124: PUSH
30125: LD_VAR 0 1
30129: PPUSH
30130: CALL_OW 247
30134: STR
30135: PUSH
30136: LD_STRING ]
30138: STR
30139: PPUSH
30140: CALL 7818 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30144: LD_VAR 0 1
30148: PUSH
30149: LD_VAR 0 1
30153: PPUSH
30154: CALL_OW 255
30158: PPUSH
30159: LD_INT 21
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PPUSH
30169: CALL 11421 0 2
30173: IN
30174: IFFALSE 30330
// begin if MCF_HasClass ( un ) then
30176: LD_VAR 0 1
30180: PPUSH
30181: CALL 14127 0 1
30185: IFFALSE 30330
// case MCF_HasClass ( un ) of 1 :
30187: LD_VAR 0 1
30191: PPUSH
30192: CALL 14127 0 1
30196: PUSH
30197: LD_INT 1
30199: DOUBLE
30200: EQUAL
30201: IFTRUE 30205
30203: GO 30230
30205: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30206: LD_VAR 0 1
30210: PPUSH
30211: CALL_OW 255
30215: PPUSH
30216: LD_STRING ToArm
30218: PPUSH
30219: LD_VAR 0 1
30223: PPUSH
30224: CALL 14300 0 3
30228: GO 30330
30230: LD_INT 2
30232: DOUBLE
30233: EQUAL
30234: IFTRUE 30238
30236: GO 30263
30238: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30239: LD_VAR 0 1
30243: PPUSH
30244: CALL_OW 255
30248: PPUSH
30249: LD_STRING ToDep
30251: PPUSH
30252: LD_VAR 0 1
30256: PPUSH
30257: CALL 14300 0 3
30261: GO 30330
30263: LD_INT 3
30265: DOUBLE
30266: EQUAL
30267: IFTRUE 30271
30269: GO 30296
30271: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30272: LD_VAR 0 1
30276: PPUSH
30277: CALL_OW 255
30281: PPUSH
30282: LD_STRING ToFac
30284: PPUSH
30285: LD_VAR 0 1
30289: PPUSH
30290: CALL 14300 0 3
30294: GO 30330
30296: LD_INT 4
30298: DOUBLE
30299: EQUAL
30300: IFTRUE 30304
30302: GO 30329
30304: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30305: LD_VAR 0 1
30309: PPUSH
30310: CALL_OW 255
30314: PPUSH
30315: LD_STRING ToLab
30317: PPUSH
30318: LD_VAR 0 1
30322: PPUSH
30323: CALL 14300 0 3
30327: GO 30330
30329: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30330: LD_VAR 0 1
30334: PUSH
30335: LD_EXP 68
30339: PUSH
30340: LD_VAR 0 1
30344: PPUSH
30345: CALL_OW 255
30349: ARRAY
30350: IN
30351: IFFALSE 30436
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30353: LD_ADDR_EXP 68
30357: PUSH
30358: LD_EXP 68
30362: PPUSH
30363: LD_VAR 0 1
30367: PPUSH
30368: LD_INT 0
30370: PPUSH
30371: CALL 31118 0 3
30375: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30376: LD_VAR 0 1
30380: PPUSH
30381: CALL_OW 255
30385: PPUSH
30386: LD_VAR 0 1
30390: PPUSH
30391: CALL_OW 265
30395: PUSH
30396: LD_VAR 0 1
30400: PPUSH
30401: CALL_OW 262
30405: PUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: CALL_OW 263
30415: PUSH
30416: LD_VAR 0 1
30420: PPUSH
30421: CALL_OW 264
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: PPUSH
30432: CALL 20940 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30436: LD_VAR 0 1
30440: PUSH
30441: LD_EXP 72
30445: PUSH
30446: LD_VAR 0 1
30450: PPUSH
30451: CALL_OW 255
30455: ARRAY
30456: IN
30457: IFFALSE 30482
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30459: LD_ADDR_EXP 72
30463: PUSH
30464: LD_EXP 72
30468: PPUSH
30469: LD_VAR 0 1
30473: PPUSH
30474: LD_INT 0
30476: PPUSH
30477: CALL 31118 0 3
30481: ST_TO_ADDR
// end ; end ;
30482: PPOPN 1
30484: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30485: LD_EXP 40
30489: PUSH
30490: LD_VAR 0 2
30494: PPUSH
30495: CALL_OW 255
30499: ARRAY
30500: IFFALSE 30672
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30502: LD_VAR 0 2
30506: PUSH
30507: LD_EXP 69
30511: PUSH
30512: LD_VAR 0 2
30516: PPUSH
30517: CALL_OW 255
30521: ARRAY
30522: IN
30523: PUSH
30524: LD_VAR 0 1
30528: PPUSH
30529: CALL_OW 266
30533: PUSH
30534: LD_INT 32
30536: PUSH
30537: LD_INT 31
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: IN
30544: AND
30545: IFFALSE 30645
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30547: LD_ADDR_EXP 69
30551: PUSH
30552: LD_EXP 69
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: LD_INT 0
30564: PPUSH
30565: CALL 31118 0 3
30569: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30570: LD_ADDR_EXP 69
30574: PUSH
30575: LD_EXP 69
30579: PPUSH
30580: LD_VAR 0 2
30584: PPUSH
30585: LD_INT 0
30587: PPUSH
30588: CALL 31118 0 3
30592: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30593: LD_EXP 69
30597: PUSH
30598: LD_VAR 0 2
30602: PPUSH
30603: CALL_OW 255
30607: ARRAY
30608: PUSH
30609: LD_STRING 
30611: EQUAL
30612: IFFALSE 30645
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30614: LD_ADDR_EXP 69
30618: PUSH
30619: LD_EXP 69
30623: PPUSH
30624: LD_VAR 0 2
30628: PPUSH
30629: CALL_OW 255
30633: PPUSH
30634: LD_INT 1
30636: PPUSH
30637: LD_INT 0
30639: PPUSH
30640: CALL 30959 0 4
30644: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30645: LD_VAR 0 1
30649: PPUSH
30650: CALL_OW 266
30654: PUSH
30655: LD_INT 36
30657: IN
30658: IFFALSE 30672
// SetTag ( un , 0 ) ;
30660: LD_VAR 0 2
30664: PPUSH
30665: LD_INT 0
30667: PPUSH
30668: CALL_OW 109
// end ;
30672: PPOPN 2
30674: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30675: LD_EXP 40
30679: PUSH
30680: LD_VAR 0 1
30684: PPUSH
30685: CALL_OW 255
30689: ARRAY
30690: IFFALSE 30716
// begin if GetControl ( un ) = control_remote then
30692: LD_VAR 0 1
30696: PPUSH
30697: CALL_OW 263
30701: PUSH
30702: LD_INT 2
30704: EQUAL
30705: IFFALSE 30716
// ComUnlink ( un ) ;
30707: LD_VAR 0 1
30711: PPUSH
30712: CALL_OW 136
// end ;
30716: PPOPN 1
30718: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30719: LD_EXP 40
30723: PUSH
30724: LD_VAR 0 1
30728: PPUSH
30729: CALL_OW 255
30733: ARRAY
30734: IFFALSE 30763
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30736: LD_VAR 0 2
30740: PPUSH
30741: CALL_OW 264
30745: PUSH
30746: LD_INT 31
30748: IN
30749: IFFALSE 30763
// SetTag ( driver , 0 ) ;
30751: LD_VAR 0 1
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL_OW 109
// end ;
30763: PPOPN 4
30765: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30766: LD_INT 0
30768: PPUSH
30769: PPUSH
30770: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30771: LD_ADDR_VAR 0 3
30775: PUSH
30776: LD_VAR 0 1
30780: PPUSH
30781: CALL_OW 269
30785: ST_TO_ADDR
// x := GetX ( building ) ;
30786: LD_ADDR_VAR 0 4
30790: PUSH
30791: LD_VAR 0 1
30795: PPUSH
30796: CALL_OW 250
30800: ST_TO_ADDR
// y := GetY ( building ) ;
30801: LD_ADDR_VAR 0 5
30805: PUSH
30806: LD_VAR 0 1
30810: PPUSH
30811: CALL_OW 251
30815: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30816: LD_ADDR_EXP 44
30820: PUSH
30821: LD_EXP 44
30825: PPUSH
30826: LD_VAR 0 1
30830: PPUSH
30831: CALL_OW 255
30835: PPUSH
30836: LD_VAR 0 3
30840: PPUSH
30841: LD_VAR 0 4
30845: PUSH
30846: LD_VAR 0 5
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PPUSH
30855: CALL 42332 0 4
30859: ST_TO_ADDR
// end ;
30860: PPOPN 5
30862: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30863: LD_VAR 0 1
30867: PUSH
30868: LD_EXP 31
30872: IN
30873: NOT
30874: IFFALSE 30922
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30876: LD_ADDR_EXP 31
30880: PUSH
30881: LD_EXP 31
30885: PPUSH
30886: LD_EXP 31
30890: PUSH
30891: LD_INT 1
30893: PLUS
30894: PPUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 2
30904: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30905: LD_STRING DestinationUnrechable. [unit: 
30907: PUSH
30908: LD_VAR 0 1
30912: STR
30913: PUSH
30914: LD_STRING ]
30916: STR
30917: PPUSH
30918: CALL 7818 0 1
// end ; end ;
30922: PPOPN 1
30924: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
30925: LD_VAR 0 1
30929: PPUSH
30930: LD_VAR 0 2
30934: PPUSH
30935: LD_VAR 0 3
30939: PPUSH
30940: CALL 54772 0 3
// end ;
30944: PPOPN 3
30946: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL 54780 0 1
// end ; end_of_file
30956: PPOPN 1
30958: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30959: LD_INT 0
30961: PPUSH
30962: PPUSH
30963: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30964: LD_ADDR_VAR 0 7
30968: PUSH
30969: LD_VAR 0 1
30973: PUSH
30974: LD_VAR 0 2
30978: ARRAY
30979: PPUSH
30980: LD_VAR 0 3
30984: PPUSH
30985: LD_VAR 0 4
30989: PPUSH
30990: CALL_OW 1
30994: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30995: LD_ADDR_VAR 0 1
30999: PUSH
31000: LD_VAR 0 1
31004: PPUSH
31005: LD_VAR 0 2
31009: PPUSH
31010: LD_VAR 0 7
31014: PPUSH
31015: CALL_OW 1
31019: ST_TO_ADDR
// result := tab ;
31020: LD_ADDR_VAR 0 5
31024: PUSH
31025: LD_VAR 0 1
31029: ST_TO_ADDR
// end ;
31030: LD_VAR 0 5
31034: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31035: LD_INT 0
31037: PPUSH
31038: PPUSH
31039: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31040: LD_ADDR_VAR 0 5
31044: PUSH
31045: LD_VAR 0 1
31049: PUSH
31050: LD_VAR 0 2
31054: PUSH
31055: LD_INT 1
31057: ARRAY
31058: ARRAY
31059: PPUSH
31060: LD_VAR 0 2
31064: PUSH
31065: LD_INT 2
31067: ARRAY
31068: PPUSH
31069: CALL_OW 3
31073: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31074: LD_ADDR_VAR 0 1
31078: PUSH
31079: LD_VAR 0 1
31083: PPUSH
31084: LD_VAR 0 2
31088: PUSH
31089: LD_INT 1
31091: ARRAY
31092: PPUSH
31093: LD_VAR 0 5
31097: PPUSH
31098: CALL_OW 1
31102: ST_TO_ADDR
// result := tab ;
31103: LD_ADDR_VAR 0 3
31107: PUSH
31108: LD_VAR 0 1
31112: ST_TO_ADDR
// end ;
31113: LD_VAR 0 3
31117: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31118: LD_INT 0
31120: PPUSH
31121: PPUSH
31122: PPUSH
31123: PPUSH
// i := 1 ;
31124: LD_ADDR_VAR 0 5
31128: PUSH
31129: LD_INT 1
31131: ST_TO_ADDR
// while ( i <= tab ) do
31132: LD_VAR 0 5
31136: PUSH
31137: LD_VAR 0 1
31141: LESSEQUAL
31142: IFFALSE 31517
// begin if not tab [ i ] then
31144: LD_VAR 0 1
31148: PUSH
31149: LD_VAR 0 5
31153: ARRAY
31154: NOT
31155: IFFALSE 31159
// break ;
31157: GO 31517
// if value in tab then
31159: LD_VAR 0 2
31163: PUSH
31164: LD_VAR 0 1
31168: IN
31169: IFFALSE 31282
// begin if not mode then
31171: LD_VAR 0 3
31175: NOT
31176: IFFALSE 31196
// tab := tab diff value else
31178: LD_ADDR_VAR 0 1
31182: PUSH
31183: LD_VAR 0 1
31187: PUSH
31188: LD_VAR 0 2
31192: DIFF
31193: ST_TO_ADDR
31194: GO 31258
// for j = 1 to tab do
31196: LD_ADDR_VAR 0 6
31200: PUSH
31201: DOUBLE
31202: LD_INT 1
31204: DEC
31205: ST_TO_ADDR
31206: LD_VAR 0 1
31210: PUSH
31211: FOR_TO
31212: IFFALSE 31256
// if tab [ j ] = value then
31214: LD_VAR 0 1
31218: PUSH
31219: LD_VAR 0 6
31223: ARRAY
31224: PUSH
31225: LD_VAR 0 2
31229: EQUAL
31230: IFFALSE 31254
// begin tab := Delete ( tab , j ) ;
31232: LD_ADDR_VAR 0 1
31236: PUSH
31237: LD_VAR 0 1
31241: PPUSH
31242: LD_VAR 0 6
31246: PPUSH
31247: CALL_OW 3
31251: ST_TO_ADDR
// break ;
31252: GO 31256
// end ;
31254: GO 31211
31256: POP
31257: POP
// i := i - 1 ;
31258: LD_ADDR_VAR 0 5
31262: PUSH
31263: LD_VAR 0 5
31267: PUSH
31268: LD_INT 1
31270: MINUS
31271: ST_TO_ADDR
// if mode then
31272: LD_VAR 0 3
31276: IFFALSE 31280
// break ;
31278: GO 31517
// end else
31280: GO 31501
// if tab [ i ] and value in tab [ i ] then
31282: LD_VAR 0 1
31286: PUSH
31287: LD_VAR 0 5
31291: ARRAY
31292: PUSH
31293: LD_VAR 0 2
31297: PUSH
31298: LD_VAR 0 1
31302: PUSH
31303: LD_VAR 0 5
31307: ARRAY
31308: IN
31309: AND
31310: IFFALSE 31501
// begin if not mode then
31312: LD_VAR 0 3
31316: NOT
31317: IFFALSE 31343
// tmp := tab [ i ] diff value else
31319: LD_ADDR_VAR 0 7
31323: PUSH
31324: LD_VAR 0 1
31328: PUSH
31329: LD_VAR 0 5
31333: ARRAY
31334: PUSH
31335: LD_VAR 0 2
31339: DIFF
31340: ST_TO_ADDR
31341: GO 31423
// for j = 1 to tab [ i ] do
31343: LD_ADDR_VAR 0 6
31347: PUSH
31348: DOUBLE
31349: LD_INT 1
31351: DEC
31352: ST_TO_ADDR
31353: LD_VAR 0 1
31357: PUSH
31358: LD_VAR 0 5
31362: ARRAY
31363: PUSH
31364: FOR_TO
31365: IFFALSE 31421
// if value = tab [ i ] [ j ] then
31367: LD_VAR 0 2
31371: PUSH
31372: LD_VAR 0 1
31376: PUSH
31377: LD_VAR 0 5
31381: ARRAY
31382: PUSH
31383: LD_VAR 0 6
31387: ARRAY
31388: EQUAL
31389: IFFALSE 31419
// begin tmp := Delete ( tab [ i ] , j ) ;
31391: LD_ADDR_VAR 0 7
31395: PUSH
31396: LD_VAR 0 1
31400: PUSH
31401: LD_VAR 0 5
31405: ARRAY
31406: PPUSH
31407: LD_VAR 0 6
31411: PPUSH
31412: CALL_OW 3
31416: ST_TO_ADDR
// break ;
31417: GO 31421
// end ;
31419: GO 31364
31421: POP
31422: POP
// if tmp = [ ] then
31423: LD_VAR 0 7
31427: PUSH
31428: EMPTY
31429: EQUAL
31430: IFFALSE 31454
// begin tab := Delete ( tab , i ) ;
31432: LD_ADDR_VAR 0 1
31436: PUSH
31437: LD_VAR 0 1
31441: PPUSH
31442: LD_VAR 0 5
31446: PPUSH
31447: CALL_OW 3
31451: ST_TO_ADDR
// end else
31452: GO 31479
// tab := Replace ( tab , i , tmp ) ;
31454: LD_ADDR_VAR 0 1
31458: PUSH
31459: LD_VAR 0 1
31463: PPUSH
31464: LD_VAR 0 5
31468: PPUSH
31469: LD_VAR 0 7
31473: PPUSH
31474: CALL_OW 1
31478: ST_TO_ADDR
// i := i - 1 ;
31479: LD_ADDR_VAR 0 5
31483: PUSH
31484: LD_VAR 0 5
31488: PUSH
31489: LD_INT 1
31491: MINUS
31492: ST_TO_ADDR
// if mode then
31493: LD_VAR 0 3
31497: IFFALSE 31501
// break ;
31499: GO 31517
// end ; i := i + 1 ;
31501: LD_ADDR_VAR 0 5
31505: PUSH
31506: LD_VAR 0 5
31510: PUSH
31511: LD_INT 1
31513: PLUS
31514: ST_TO_ADDR
// end ;
31515: GO 31132
// result := tab ;
31517: LD_ADDR_VAR 0 4
31521: PUSH
31522: LD_VAR 0 1
31526: ST_TO_ADDR
// end ;
31527: LD_VAR 0 4
31531: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31532: LD_INT 0
31534: PPUSH
31535: PPUSH
// for i = 1 to values do
31536: LD_ADDR_VAR 0 4
31540: PUSH
31541: DOUBLE
31542: LD_INT 1
31544: DEC
31545: ST_TO_ADDR
31546: LD_VAR 0 2
31550: PUSH
31551: FOR_TO
31552: IFFALSE 31585
// tab := Remove ( tab , values [ i ] , false ) ;
31554: LD_ADDR_VAR 0 1
31558: PUSH
31559: LD_VAR 0 1
31563: PPUSH
31564: LD_VAR 0 2
31568: PUSH
31569: LD_VAR 0 4
31573: ARRAY
31574: PPUSH
31575: LD_INT 0
31577: PPUSH
31578: CALL 31118 0 3
31582: ST_TO_ADDR
31583: GO 31551
31585: POP
31586: POP
// result := tab ;
31587: LD_ADDR_VAR 0 3
31591: PUSH
31592: LD_VAR 0 1
31596: ST_TO_ADDR
// end ;
31597: LD_VAR 0 3
31601: RET
// export function IsDriver ( unit ) ; begin
31602: LD_INT 0
31604: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31605: LD_VAR 0 1
31609: PUSH
31610: LD_INT 55
31612: PUSH
31613: EMPTY
31614: LIST
31615: PPUSH
31616: CALL_OW 69
31620: IN
31621: IFFALSE 31640
// result := IsInUnit ( unit ) else
31623: LD_ADDR_VAR 0 2
31627: PUSH
31628: LD_VAR 0 1
31632: PPUSH
31633: CALL_OW 310
31637: ST_TO_ADDR
31638: GO 31648
// result := false ;
31640: LD_ADDR_VAR 0 2
31644: PUSH
31645: LD_INT 0
31647: ST_TO_ADDR
// end ;
31648: LD_VAR 0 2
31652: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31653: LD_INT 0
31655: PPUSH
31656: PPUSH
31657: PPUSH
// if not GetControl ( veh ) = control_manual then
31658: LD_VAR 0 1
31662: PPUSH
31663: CALL_OW 263
31667: PUSH
31668: LD_INT 1
31670: EQUAL
31671: NOT
31672: IFFALSE 31684
// result := false else
31674: LD_ADDR_VAR 0 2
31678: PUSH
31679: LD_INT 0
31681: ST_TO_ADDR
31682: GO 31829
// if veh in FilterAllUnits ( [ f_empty ] ) then
31684: LD_VAR 0 1
31688: PUSH
31689: LD_INT 58
31691: PUSH
31692: EMPTY
31693: LIST
31694: PPUSH
31695: CALL_OW 69
31699: IN
31700: IFFALSE 31712
// result := false else
31702: LD_ADDR_VAR 0 2
31706: PUSH
31707: LD_INT 0
31709: ST_TO_ADDR
31710: GO 31829
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31712: LD_ADDR_VAR 0 4
31716: PUSH
31717: LD_INT 22
31719: PUSH
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 255
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 55
31736: PUSH
31737: EMPTY
31738: LIST
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PPUSH
31744: CALL_OW 69
31748: ST_TO_ADDR
// if not filter then
31749: LD_VAR 0 4
31753: NOT
31754: IFFALSE 31766
// result := false else
31756: LD_ADDR_VAR 0 2
31760: PUSH
31761: LD_INT 0
31763: ST_TO_ADDR
31764: GO 31829
// for i = 1 to filter do
31766: LD_ADDR_VAR 0 3
31770: PUSH
31771: DOUBLE
31772: LD_INT 1
31774: DEC
31775: ST_TO_ADDR
31776: LD_VAR 0 4
31780: PUSH
31781: FOR_TO
31782: IFFALSE 31827
// if IsDriver ( filter [ i ] ) = veh then
31784: LD_VAR 0 4
31788: PUSH
31789: LD_VAR 0 3
31793: ARRAY
31794: PPUSH
31795: CALL 31602 0 1
31799: PUSH
31800: LD_VAR 0 1
31804: EQUAL
31805: IFFALSE 31825
// begin result := filter [ i ] ;
31807: LD_ADDR_VAR 0 2
31811: PUSH
31812: LD_VAR 0 4
31816: PUSH
31817: LD_VAR 0 3
31821: ARRAY
31822: ST_TO_ADDR
// break ;
31823: GO 31827
// end ;
31825: GO 31781
31827: POP
31828: POP
// end ; end ;
31829: LD_VAR 0 2
31833: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31834: LD_INT 0
31836: PPUSH
31837: PPUSH
// if BuildingStatus ( b ) = bs_build then
31838: LD_VAR 0 2
31842: PPUSH
31843: CALL_OW 461
31847: PUSH
31848: LD_INT 1
31850: EQUAL
31851: IFFALSE 31911
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31853: LD_VAR 0 1
31857: PPUSH
31858: LD_STRING h
31860: PUSH
31861: LD_VAR 0 2
31865: PPUSH
31866: CALL_OW 250
31870: PUSH
31871: LD_VAR 0 2
31875: PPUSH
31876: CALL_OW 251
31880: PUSH
31881: LD_VAR 0 2
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: PUSH
31904: EMPTY
31905: LIST
31906: PPUSH
31907: CALL_OW 446
// end ;
31911: LD_VAR 0 3
31915: RET
// export function Compare ( val1 , val2 ) ; begin
31916: LD_INT 0
31918: PPUSH
// if val1 = val2 then
31919: LD_VAR 0 1
31923: PUSH
31924: LD_VAR 0 2
31928: EQUAL
31929: IFFALSE 31941
// result := true else
31931: LD_ADDR_VAR 0 3
31935: PUSH
31936: LD_INT 1
31938: ST_TO_ADDR
31939: GO 31949
// result := false ;
31941: LD_ADDR_VAR 0 3
31945: PUSH
31946: LD_INT 0
31948: ST_TO_ADDR
// end ;
31949: LD_VAR 0 3
31953: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31954: LD_INT 0
31956: PPUSH
31957: PPUSH
// result := true ;
31958: LD_ADDR_VAR 0 3
31962: PUSH
31963: LD_INT 1
31965: ST_TO_ADDR
// if array1 = array2 then
31966: LD_VAR 0 1
31970: PUSH
31971: LD_VAR 0 2
31975: EQUAL
31976: IFFALSE 32041
// begin for i = 1 to array1 do
31978: LD_ADDR_VAR 0 4
31982: PUSH
31983: DOUBLE
31984: LD_INT 1
31986: DEC
31987: ST_TO_ADDR
31988: LD_VAR 0 1
31992: PUSH
31993: FOR_TO
31994: IFFALSE 32037
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31996: LD_VAR 0 1
32000: PUSH
32001: LD_VAR 0 4
32005: ARRAY
32006: PPUSH
32007: LD_VAR 0 2
32011: PUSH
32012: LD_VAR 0 4
32016: ARRAY
32017: PPUSH
32018: CALL 31916 0 2
32022: NOT
32023: IFFALSE 32035
// begin result := false ;
32025: LD_ADDR_VAR 0 3
32029: PUSH
32030: LD_INT 0
32032: ST_TO_ADDR
// break ;
32033: GO 32037
// end ;
32035: GO 31993
32037: POP
32038: POP
// end else
32039: GO 32049
// result := false ;
32041: LD_ADDR_VAR 0 3
32045: PUSH
32046: LD_INT 0
32048: ST_TO_ADDR
// end ;
32049: LD_VAR 0 3
32053: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32054: LD_INT 0
32056: PPUSH
32057: PPUSH
// result := false ;
32058: LD_ADDR_VAR 0 3
32062: PUSH
32063: LD_INT 0
32065: ST_TO_ADDR
// for j = 1 to e2 do
32066: LD_ADDR_VAR 0 4
32070: PUSH
32071: DOUBLE
32072: LD_INT 1
32074: DEC
32075: ST_TO_ADDR
32076: LD_VAR 0 2
32080: PUSH
32081: FOR_TO
32082: IFFALSE 32116
// if Compare ( e1 , e2 [ j ] ) then
32084: LD_VAR 0 1
32088: PPUSH
32089: LD_VAR 0 2
32093: PUSH
32094: LD_VAR 0 4
32098: ARRAY
32099: PPUSH
32100: CALL 31916 0 2
32104: IFFALSE 32114
// result := true ;
32106: LD_ADDR_VAR 0 3
32110: PUSH
32111: LD_INT 1
32113: ST_TO_ADDR
32114: GO 32081
32116: POP
32117: POP
// end ;
32118: LD_VAR 0 3
32122: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32123: LD_INT 0
32125: PPUSH
32126: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32127: LD_VAR 0 1
32131: PPUSH
32132: LD_STRING C
32134: PUSH
32135: LD_VAR 0 2
32139: PUSH
32140: LD_VAR 0 3
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: PUSH
32166: LD_STRING v
32168: PUSH
32169: LD_VAR 0 4
32173: PPUSH
32174: CALL_OW 250
32178: PUSH
32179: LD_VAR 0 4
32183: PPUSH
32184: CALL_OW 251
32188: PUSH
32189: LD_VAR 0 4
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: LD_INT 0
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PPUSH
32216: CALL_OW 446
// end ;
32220: LD_VAR 0 5
32224: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32225: LD_INT 0
32227: PPUSH
32228: PPUSH
32229: PPUSH
// linked := UnitsLinked ( unit ) ;
32230: LD_ADDR_VAR 0 4
32234: PUSH
32235: LD_VAR 0 1
32239: PPUSH
32240: CALL_OW 432
32244: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32245: LD_ADDR_VAR 0 3
32249: PUSH
32250: LD_VAR 0 1
32254: PPUSH
32255: LD_INT 3
32257: PPUSH
32258: CALL_OW 259
32262: ST_TO_ADDR
// if sk > linked then
32263: LD_VAR 0 3
32267: PUSH
32268: LD_VAR 0 4
32272: GREATER
32273: IFFALSE 32285
// result := true else
32275: LD_ADDR_VAR 0 2
32279: PUSH
32280: LD_INT 1
32282: ST_TO_ADDR
32283: GO 32293
// result := false ;
32285: LD_ADDR_VAR 0 2
32289: PUSH
32290: LD_INT 0
32292: ST_TO_ADDR
// end ;
32293: LD_VAR 0 2
32297: RET
// export function NotTask ( unit ) ; begin
32298: LD_INT 0
32300: PPUSH
// result := true ;
32301: LD_ADDR_VAR 0 2
32305: PUSH
32306: LD_INT 1
32308: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32309: LD_VAR 0 1
32313: PPUSH
32314: CALL_OW 437
32318: PUSH
32319: LD_VAR 0 1
32323: PPUSH
32324: CALL_OW 314
32328: OR
32329: IFFALSE 32339
// result := false ;
32331: LD_ADDR_VAR 0 2
32335: PUSH
32336: LD_INT 0
32338: ST_TO_ADDR
// end ;
32339: LD_VAR 0 2
32343: RET
// export function WantHeal ( sci , unit ) ; begin
32344: LD_INT 0
32346: PPUSH
// if GetTaskList ( sci ) > 0 then
32347: LD_VAR 0 1
32351: PPUSH
32352: CALL_OW 437
32356: PUSH
32357: LD_INT 0
32359: GREATER
32360: IFFALSE 32430
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32362: LD_VAR 0 1
32366: PPUSH
32367: CALL_OW 437
32371: PUSH
32372: LD_INT 1
32374: ARRAY
32375: PUSH
32376: LD_INT 1
32378: ARRAY
32379: PUSH
32380: LD_STRING l
32382: EQUAL
32383: PUSH
32384: LD_VAR 0 1
32388: PPUSH
32389: CALL_OW 437
32393: PUSH
32394: LD_INT 1
32396: ARRAY
32397: PUSH
32398: LD_INT 4
32400: ARRAY
32401: PUSH
32402: LD_VAR 0 2
32406: EQUAL
32407: AND
32408: IFFALSE 32420
// result := true else
32410: LD_ADDR_VAR 0 3
32414: PUSH
32415: LD_INT 1
32417: ST_TO_ADDR
32418: GO 32428
// result := false ;
32420: LD_ADDR_VAR 0 3
32424: PUSH
32425: LD_INT 0
32427: ST_TO_ADDR
// end else
32428: GO 32438
// result := false ;
32430: LD_ADDR_VAR 0 3
32434: PUSH
32435: LD_INT 0
32437: ST_TO_ADDR
// end ;
32438: LD_VAR 0 3
32442: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32443: LD_INT 0
32445: PPUSH
32446: PPUSH
32447: PPUSH
32448: PPUSH
32449: PPUSH
// dist := 99999 ;
32450: LD_ADDR_VAR 0 7
32454: PUSH
32455: LD_INT 99999
32457: ST_TO_ADDR
// un := - 1 ;
32458: LD_ADDR_VAR 0 6
32462: PUSH
32463: LD_INT 1
32465: NEG
32466: ST_TO_ADDR
// if units1 and units2 then
32467: LD_VAR 0 1
32471: PUSH
32472: LD_VAR 0 2
32476: AND
32477: IFFALSE 32565
// for i in units1 do
32479: LD_ADDR_VAR 0 4
32483: PUSH
32484: LD_VAR 0 1
32488: PUSH
32489: FOR_IN
32490: IFFALSE 32563
// for j in units2 do
32492: LD_ADDR_VAR 0 5
32496: PUSH
32497: LD_VAR 0 2
32501: PUSH
32502: FOR_IN
32503: IFFALSE 32559
// if GetDistUnits ( i , j ) < dist then
32505: LD_VAR 0 4
32509: PPUSH
32510: LD_VAR 0 5
32514: PPUSH
32515: CALL_OW 296
32519: PUSH
32520: LD_VAR 0 7
32524: LESS
32525: IFFALSE 32557
// begin un := i ;
32527: LD_ADDR_VAR 0 6
32531: PUSH
32532: LD_VAR 0 4
32536: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32537: LD_ADDR_VAR 0 7
32541: PUSH
32542: LD_VAR 0 4
32546: PPUSH
32547: LD_VAR 0 5
32551: PPUSH
32552: CALL_OW 296
32556: ST_TO_ADDR
// end ;
32557: GO 32502
32559: POP
32560: POP
32561: GO 32489
32563: POP
32564: POP
// result := [ un , dist ] ;
32565: LD_ADDR_VAR 0 3
32569: PUSH
32570: LD_VAR 0 6
32574: PUSH
32575: LD_VAR 0 7
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: ST_TO_ADDR
// end ;
32584: LD_VAR 0 3
32588: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32589: LD_INT 0
32591: PPUSH
32592: PPUSH
32593: PPUSH
32594: PPUSH
32595: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32596: LD_VAR 0 1
32600: NOT
32601: PUSH
32602: LD_VAR 0 1
32606: PPUSH
32607: CALL_OW 256
32611: PUSH
32612: LD_INT 250
32614: LESS
32615: OR
32616: PUSH
32617: LD_VAR 0 1
32621: PPUSH
32622: CALL_OW 314
32626: PUSH
32627: LD_VAR 0 1
32631: PPUSH
32632: CALL_OW 261
32636: PUSH
32637: LD_INT 20
32639: GREATER
32640: AND
32641: OR
32642: IFFALSE 32646
// exit ;
32644: GO 33020
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32646: LD_VAR 0 1
32650: PPUSH
32651: CALL_OW 261
32655: PUSH
32656: LD_INT 20
32658: LESS
32659: PUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 110
32669: PUSH
32670: LD_INT 21
32672: EQUAL
32673: NOT
32674: AND
32675: IFFALSE 32711
// begin ComStop ( bulldozer ) ;
32677: LD_VAR 0 1
32681: PPUSH
32682: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32686: LD_VAR 0 1
32690: PPUSH
32691: LD_INT 21
32693: PPUSH
32694: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32698: LD_VAR 0 1
32702: PPUSH
32703: CALL 26119 0 1
// exit ;
32707: GO 33020
// end else
32709: GO 32738
// if GetFuel ( bulldozer ) > 20 then
32711: LD_VAR 0 1
32715: PPUSH
32716: CALL_OW 261
32720: PUSH
32721: LD_INT 20
32723: GREATER
32724: IFFALSE 32738
// SetTag ( bulldozer , 0 ) ;
32726: LD_VAR 0 1
32730: PPUSH
32731: LD_INT 0
32733: PPUSH
32734: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32738: LD_ADDR_VAR 0 5
32742: PUSH
32743: LD_VAR 0 2
32747: PPUSH
32748: CALL_OW 353
32752: ST_TO_ADDR
// tmp := [ ] ;
32753: LD_ADDR_VAR 0 6
32757: PUSH
32758: EMPTY
32759: ST_TO_ADDR
// for i = 1 to list do
32760: LD_ADDR_VAR 0 4
32764: PUSH
32765: DOUBLE
32766: LD_INT 1
32768: DEC
32769: ST_TO_ADDR
32770: LD_VAR 0 5
32774: PUSH
32775: FOR_TO
32776: IFFALSE 32874
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32778: LD_VAR 0 5
32782: PUSH
32783: LD_VAR 0 4
32787: ARRAY
32788: PUSH
32789: LD_INT 1
32791: ARRAY
32792: PPUSH
32793: LD_VAR 0 5
32797: PUSH
32798: LD_VAR 0 4
32802: ARRAY
32803: PUSH
32804: LD_INT 2
32806: ARRAY
32807: PPUSH
32808: CALL_OW 554
32812: IFFALSE 32872
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32814: LD_ADDR_VAR 0 6
32818: PUSH
32819: LD_VAR 0 6
32823: PPUSH
32824: LD_VAR 0 6
32828: PUSH
32829: LD_INT 1
32831: PLUS
32832: PPUSH
32833: LD_VAR 0 5
32837: PUSH
32838: LD_VAR 0 4
32842: ARRAY
32843: PUSH
32844: LD_INT 1
32846: ARRAY
32847: PUSH
32848: LD_VAR 0 5
32852: PUSH
32853: LD_VAR 0 4
32857: ARRAY
32858: PUSH
32859: LD_INT 2
32861: ARRAY
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PPUSH
32867: CALL_OW 1
32871: ST_TO_ADDR
// end ;
32872: GO 32775
32874: POP
32875: POP
// ComStop ( bulldozer ) ;
32876: LD_VAR 0 1
32880: PPUSH
32881: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32885: LD_ADDR_VAR 0 7
32889: PUSH
32890: LD_VAR 0 1
32894: PPUSH
32895: CALL_OW 250
32899: PUSH
32900: LD_VAR 0 1
32904: PPUSH
32905: CALL_OW 251
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: ST_TO_ADDR
// for i = tmp downto 1 do
32914: LD_ADDR_VAR 0 4
32918: PUSH
32919: DOUBLE
32920: LD_VAR 0 6
32924: INC
32925: ST_TO_ADDR
32926: LD_INT 1
32928: PUSH
32929: FOR_DOWNTO
32930: IFFALSE 33018
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32932: LD_ADDR_VAR 0 7
32936: PUSH
32937: LD_VAR 0 7
32941: PUSH
32942: LD_INT 1
32944: ARRAY
32945: PPUSH
32946: LD_VAR 0 7
32950: PUSH
32951: LD_INT 2
32953: ARRAY
32954: PPUSH
32955: LD_VAR 0 6
32959: PPUSH
32960: CALL 33121 0 3
32964: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32965: LD_VAR 0 1
32969: PPUSH
32970: LD_VAR 0 7
32974: PUSH
32975: LD_INT 1
32977: ARRAY
32978: PPUSH
32979: LD_VAR 0 7
32983: PUSH
32984: LD_INT 2
32986: ARRAY
32987: PPUSH
32988: CALL 33025 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32992: LD_ADDR_VAR 0 6
32996: PUSH
32997: LD_VAR 0 6
33001: PPUSH
33002: LD_VAR 0 7
33006: PUSH
33007: LD_INT 3
33009: ARRAY
33010: PPUSH
33011: CALL_OW 3
33015: ST_TO_ADDR
// end ;
33016: GO 32929
33018: POP
33019: POP
// end ;
33020: LD_VAR 0 3
33024: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
33025: LD_INT 0
33027: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
33028: LD_VAR 0 2
33032: PPUSH
33033: LD_VAR 0 3
33037: PPUSH
33038: CALL_OW 351
33042: PUSH
33043: LD_VAR 0 2
33047: PPUSH
33048: LD_VAR 0 3
33052: PPUSH
33053: CALL_OW 554
33057: AND
33058: PUSH
33059: LD_VAR 0 2
33063: PPUSH
33064: LD_VAR 0 3
33068: PPUSH
33069: CALL_OW 488
33073: AND
33074: PUSH
33075: LD_VAR 0 2
33079: PPUSH
33080: LD_VAR 0 3
33084: PPUSH
33085: CALL_OW 428
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: EQUAL
33094: AND
33095: IFFALSE 33116
// AddComMoveXY ( bulldozer , x , y ) ;
33097: LD_VAR 0 1
33101: PPUSH
33102: LD_VAR 0 2
33106: PPUSH
33107: LD_VAR 0 3
33111: PPUSH
33112: CALL_OW 171
// end ;
33116: LD_VAR 0 4
33120: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33121: LD_INT 0
33123: PPUSH
33124: PPUSH
33125: PPUSH
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
// dist := 99999 ;
33130: LD_ADDR_VAR 0 6
33134: PUSH
33135: LD_INT 99999
33137: ST_TO_ADDR
// for i = 1 to list do
33138: LD_ADDR_VAR 0 5
33142: PUSH
33143: DOUBLE
33144: LD_INT 1
33146: DEC
33147: ST_TO_ADDR
33148: LD_VAR 0 3
33152: PUSH
33153: FOR_TO
33154: IFFALSE 33292
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33156: LD_ADDR_VAR 0 7
33160: PUSH
33161: LD_VAR 0 1
33165: PPUSH
33166: LD_VAR 0 2
33170: PPUSH
33171: LD_VAR 0 3
33175: PUSH
33176: LD_VAR 0 5
33180: ARRAY
33181: PUSH
33182: LD_INT 1
33184: ARRAY
33185: PPUSH
33186: LD_VAR 0 3
33190: PUSH
33191: LD_VAR 0 5
33195: ARRAY
33196: PUSH
33197: LD_INT 2
33199: ARRAY
33200: PPUSH
33201: CALL_OW 298
33205: ST_TO_ADDR
// if d = 0 then
33206: LD_VAR 0 7
33210: PUSH
33211: LD_INT 0
33213: EQUAL
33214: IFFALSE 33218
// continue ;
33216: GO 33153
// if d < dist then
33218: LD_VAR 0 7
33222: PUSH
33223: LD_VAR 0 6
33227: LESS
33228: IFFALSE 33290
// begin _x := list [ i ] [ 1 ] ;
33230: LD_ADDR_VAR 0 8
33234: PUSH
33235: LD_VAR 0 3
33239: PUSH
33240: LD_VAR 0 5
33244: ARRAY
33245: PUSH
33246: LD_INT 1
33248: ARRAY
33249: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33250: LD_ADDR_VAR 0 9
33254: PUSH
33255: LD_VAR 0 3
33259: PUSH
33260: LD_VAR 0 5
33264: ARRAY
33265: PUSH
33266: LD_INT 2
33268: ARRAY
33269: ST_TO_ADDR
// _i := i ;
33270: LD_ADDR_VAR 0 10
33274: PUSH
33275: LD_VAR 0 5
33279: ST_TO_ADDR
// dist := d ;
33280: LD_ADDR_VAR 0 6
33284: PUSH
33285: LD_VAR 0 7
33289: ST_TO_ADDR
// end ; end ;
33290: GO 33153
33292: POP
33293: POP
// result := [ _x , _y , _i , dist ] ;
33294: LD_ADDR_VAR 0 4
33298: PUSH
33299: LD_VAR 0 8
33303: PUSH
33304: LD_VAR 0 9
33308: PUSH
33309: LD_VAR 0 10
33313: PUSH
33314: LD_VAR 0 6
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: ST_TO_ADDR
// end ;
33325: LD_VAR 0 4
33329: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33330: LD_INT 0
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
// for i = 1 to list do
33337: LD_ADDR_VAR 0 5
33341: PUSH
33342: DOUBLE
33343: LD_INT 1
33345: DEC
33346: ST_TO_ADDR
33347: LD_VAR 0 1
33351: PUSH
33352: FOR_TO
33353: IFFALSE 33667
// begin for j = list downto 2 do
33355: LD_ADDR_VAR 0 6
33359: PUSH
33360: DOUBLE
33361: LD_VAR 0 1
33365: INC
33366: ST_TO_ADDR
33367: LD_INT 2
33369: PUSH
33370: FOR_DOWNTO
33371: IFFALSE 33663
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33373: LD_VAR 0 2
33377: PPUSH
33378: LD_VAR 0 3
33382: PPUSH
33383: LD_VAR 0 1
33387: PUSH
33388: LD_VAR 0 6
33392: ARRAY
33393: PUSH
33394: LD_INT 1
33396: ARRAY
33397: PPUSH
33398: LD_VAR 0 1
33402: PUSH
33403: LD_VAR 0 6
33407: ARRAY
33408: PUSH
33409: LD_INT 2
33411: ARRAY
33412: PPUSH
33413: CALL_OW 298
33417: PUSH
33418: LD_VAR 0 2
33422: PPUSH
33423: LD_VAR 0 3
33427: PPUSH
33428: LD_VAR 0 1
33432: PUSH
33433: LD_VAR 0 6
33437: PUSH
33438: LD_INT 1
33440: MINUS
33441: ARRAY
33442: PUSH
33443: LD_INT 1
33445: ARRAY
33446: PPUSH
33447: LD_VAR 0 1
33451: PUSH
33452: LD_VAR 0 6
33456: PUSH
33457: LD_INT 1
33459: MINUS
33460: ARRAY
33461: PUSH
33462: LD_INT 2
33464: ARRAY
33465: PPUSH
33466: CALL_OW 298
33470: LESS
33471: IFFALSE 33661
// begin _x := list [ j ] [ 1 ] ;
33473: LD_ADDR_VAR 0 7
33477: PUSH
33478: LD_VAR 0 1
33482: PUSH
33483: LD_VAR 0 6
33487: ARRAY
33488: PUSH
33489: LD_INT 1
33491: ARRAY
33492: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33493: LD_ADDR_VAR 0 8
33497: PUSH
33498: LD_VAR 0 1
33502: PUSH
33503: LD_VAR 0 6
33507: ARRAY
33508: PUSH
33509: LD_INT 2
33511: ARRAY
33512: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33513: LD_ADDR_VAR 0 1
33517: PUSH
33518: LD_VAR 0 1
33522: PPUSH
33523: LD_VAR 0 6
33527: PPUSH
33528: LD_INT 1
33530: PPUSH
33531: LD_VAR 0 1
33535: PUSH
33536: LD_VAR 0 6
33540: PUSH
33541: LD_INT 1
33543: MINUS
33544: ARRAY
33545: PUSH
33546: LD_INT 1
33548: ARRAY
33549: PPUSH
33550: CALL 30959 0 4
33554: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33555: LD_ADDR_VAR 0 1
33559: PUSH
33560: LD_VAR 0 1
33564: PPUSH
33565: LD_VAR 0 6
33569: PPUSH
33570: LD_INT 2
33572: PPUSH
33573: LD_VAR 0 1
33577: PUSH
33578: LD_VAR 0 6
33582: PUSH
33583: LD_INT 1
33585: MINUS
33586: ARRAY
33587: PUSH
33588: LD_INT 2
33590: ARRAY
33591: PPUSH
33592: CALL 30959 0 4
33596: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33597: LD_ADDR_VAR 0 1
33601: PUSH
33602: LD_VAR 0 1
33606: PPUSH
33607: LD_VAR 0 6
33611: PUSH
33612: LD_INT 1
33614: MINUS
33615: PPUSH
33616: LD_INT 1
33618: PPUSH
33619: LD_VAR 0 7
33623: PPUSH
33624: CALL 30959 0 4
33628: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33629: LD_ADDR_VAR 0 1
33633: PUSH
33634: LD_VAR 0 1
33638: PPUSH
33639: LD_VAR 0 6
33643: PUSH
33644: LD_INT 1
33646: MINUS
33647: PPUSH
33648: LD_INT 2
33650: PPUSH
33651: LD_VAR 0 8
33655: PPUSH
33656: CALL 30959 0 4
33660: ST_TO_ADDR
// end ; end ;
33661: GO 33370
33663: POP
33664: POP
// end ;
33665: GO 33352
33667: POP
33668: POP
// result := list ;
33669: LD_ADDR_VAR 0 4
33673: PUSH
33674: LD_VAR 0 1
33678: ST_TO_ADDR
// end ;
33679: LD_VAR 0 4
33683: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33684: LD_INT 0
33686: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33687: LD_ADDR_VAR 0 5
33691: PUSH
33692: LD_VAR 0 1
33696: PPUSH
33697: LD_VAR 0 2
33701: PPUSH
33702: CALL_OW 546
33706: PUSH
33707: LD_INT 2
33709: ARRAY
33710: PUSH
33711: LD_VAR 0 3
33715: PPUSH
33716: LD_VAR 0 4
33720: PPUSH
33721: CALL_OW 546
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: MINUS
33730: ST_TO_ADDR
// if result < 0 then
33731: LD_VAR 0 5
33735: PUSH
33736: LD_INT 0
33738: LESS
33739: IFFALSE 33756
// result := result * - 1 ;
33741: LD_ADDR_VAR 0 5
33745: PUSH
33746: LD_VAR 0 5
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: MUL
33755: ST_TO_ADDR
// end ;
33756: LD_VAR 0 5
33760: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33761: LD_INT 0
33763: PPUSH
33764: PPUSH
// area = ListEnvironmentArea ( area ) ;
33765: LD_ADDR_VAR 0 2
33769: PUSH
33770: LD_VAR 0 2
33774: PPUSH
33775: CALL_OW 353
33779: ST_TO_ADDR
// if bulldozer > 0 then
33780: LD_VAR 0 1
33784: PUSH
33785: LD_INT 0
33787: GREATER
33788: IFFALSE 33899
// for i = area downto 1 do
33790: LD_ADDR_VAR 0 4
33794: PUSH
33795: DOUBLE
33796: LD_VAR 0 2
33800: INC
33801: ST_TO_ADDR
33802: LD_INT 1
33804: PUSH
33805: FOR_DOWNTO
33806: IFFALSE 33897
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33808: LD_VAR 0 2
33812: PUSH
33813: LD_VAR 0 4
33817: ARRAY
33818: PUSH
33819: LD_INT 1
33821: ARRAY
33822: PPUSH
33823: LD_VAR 0 2
33827: PUSH
33828: LD_VAR 0 4
33832: ARRAY
33833: PUSH
33834: LD_INT 2
33836: ARRAY
33837: PPUSH
33838: CALL_OW 351
33842: IFFALSE 33895
// if not HasTask ( bulldozer ) then
33844: LD_VAR 0 1
33848: PPUSH
33849: CALL_OW 314
33853: NOT
33854: IFFALSE 33895
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33856: LD_VAR 0 1
33860: PPUSH
33861: LD_VAR 0 2
33865: PUSH
33866: LD_VAR 0 4
33870: ARRAY
33871: PUSH
33872: LD_INT 1
33874: ARRAY
33875: PPUSH
33876: LD_VAR 0 2
33880: PUSH
33881: LD_VAR 0 4
33885: ARRAY
33886: PUSH
33887: LD_INT 2
33889: ARRAY
33890: PPUSH
33891: CALL_OW 171
33895: GO 33805
33897: POP
33898: POP
// end ;
33899: LD_VAR 0 3
33903: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33904: LD_INT 0
33906: PPUSH
33907: PPUSH
33908: PPUSH
33909: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33910: LD_ADDR_VAR 0 6
33914: PUSH
33915: LD_INT 22
33917: PUSH
33918: LD_VAR 0 1
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 21
33929: PUSH
33930: LD_VAR 0 2
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PPUSH
33943: CALL_OW 69
33947: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33948: LD_ADDR_VAR 0 7
33952: PUSH
33953: LD_VAR 0 3
33957: PPUSH
33958: LD_INT 22
33960: PUSH
33961: LD_VAR 0 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 21
33972: PUSH
33973: LD_VAR 0 2
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PPUSH
33986: CALL_OW 70
33990: ST_TO_ADDR
// if tmp and pom then
33991: LD_VAR 0 6
33995: PUSH
33996: LD_VAR 0 7
34000: AND
34001: IFFALSE 34021
// result := tmp diff pom else
34003: LD_ADDR_VAR 0 4
34007: PUSH
34008: LD_VAR 0 6
34012: PUSH
34013: LD_VAR 0 7
34017: DIFF
34018: ST_TO_ADDR
34019: GO 34029
// result := false ;
34021: LD_ADDR_VAR 0 4
34025: PUSH
34026: LD_INT 0
34028: ST_TO_ADDR
// end ;
34029: LD_VAR 0 4
34033: RET
// export function SavePosition ( unit ) ; begin
34034: LD_INT 0
34036: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
34037: LD_VAR 0 1
34041: PPUSH
34042: LD_VAR 0 1
34046: PPUSH
34047: CALL_OW 250
34051: PPUSH
34052: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
34056: LD_VAR 0 1
34060: PPUSH
34061: LD_VAR 0 1
34065: PPUSH
34066: CALL_OW 251
34070: PPUSH
34071: CALL_OW 232
// end ;
34075: LD_VAR 0 2
34079: RET
// export function GetPosition ( unit ) ; begin
34080: LD_INT 0
34082: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
34083: LD_ADDR_VAR 0 2
34087: PUSH
34088: LD_VAR 0 1
34092: PPUSH
34093: CALL_OW 252
34097: PUSH
34098: LD_VAR 0 1
34102: PPUSH
34103: CALL_OW 253
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: ST_TO_ADDR
// end ;
34112: LD_VAR 0 2
34116: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34117: LD_INT 0
34119: PPUSH
// if unit in unreachableList then
34120: LD_VAR 0 1
34124: PUSH
34125: LD_EXP 31
34129: IN
34130: IFFALSE 34148
// unreachableList := unreachableList diff unit ;
34132: LD_ADDR_EXP 31
34136: PUSH
34137: LD_EXP 31
34141: PUSH
34142: LD_VAR 0 1
34146: DIFF
34147: ST_TO_ADDR
// if ValidHex ( x , y ) then
34148: LD_VAR 0 2
34152: PPUSH
34153: LD_VAR 0 3
34157: PPUSH
34158: CALL_OW 488
34162: IFFALSE 34188
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34164: LD_VAR 0 1
34168: PPUSH
34169: LD_VAR 0 2
34173: PPUSH
34174: LD_VAR 0 3
34178: PPUSH
34179: CALL_OW 428
34183: PPUSH
34184: CALL_OW 115
// Wait ( 3 ) ;
34188: LD_INT 3
34190: PPUSH
34191: CALL_OW 67
// if unit in unreachableList then
34195: LD_VAR 0 1
34199: PUSH
34200: LD_EXP 31
34204: IN
34205: IFFALSE 34217
// result := false else
34207: LD_ADDR_VAR 0 4
34211: PUSH
34212: LD_INT 0
34214: ST_TO_ADDR
34215: GO 34225
// result := true ;
34217: LD_ADDR_VAR 0 4
34221: PUSH
34222: LD_INT 1
34224: ST_TO_ADDR
// end ; end_of_file
34225: LD_VAR 0 4
34229: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34230: LD_EXP 32
34234: IFFALSE 34296
34236: GO 34238
34238: DISABLE
34239: LD_INT 0
34241: PPUSH
// begin enable ;
34242: ENABLE
// for i = 1 to mc_crates_list do
34243: LD_ADDR_VAR 0 1
34247: PUSH
34248: DOUBLE
34249: LD_INT 1
34251: DEC
34252: ST_TO_ADDR
34253: LD_EXP 33
34257: PUSH
34258: FOR_TO
34259: IFFALSE 34290
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34261: LD_EXP 33
34265: PUSH
34266: LD_VAR 0 1
34270: ARRAY
34271: PPUSH
34272: LD_INT 5
34274: PPUSH
34275: LD_INT 50
34277: PPUSH
34278: LD_INT 700
34280: PPUSH
34281: LD_INT 20
34283: PPUSH
34284: CALL 24301 0 5
34288: GO 34258
34290: POP
34291: POP
// MC_Game ( ) ;
34292: CALL 34299 0 0
// end ;
34296: PPOPN 1
34298: END
// export function MC_Game ( ) ; var i , side , un ; begin
34299: LD_INT 0
34301: PPUSH
34302: PPUSH
34303: PPUSH
34304: PPUSH
// if not isTest then
34305: LD_EXP 1
34309: NOT
34310: IFFALSE 34330
// MC_Show ( [ #tick , tick ] ) else
34312: LD_STRING #tick
34314: PUSH
34315: LD_OWVAR 1
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PPUSH
34324: CALL 8339 0 1
34328: GO 34339
// MC_Show ( debug_string ) ;
34330: LD_EXP 2
34334: PPUSH
34335: CALL 8339 0 1
// for side = 1 to 8 do
34339: LD_ADDR_VAR 0 3
34343: PUSH
34344: DOUBLE
34345: LD_INT 1
34347: DEC
34348: ST_TO_ADDR
34349: LD_INT 8
34351: PUSH
34352: FOR_TO
34353: IFFALSE 36353
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34355: LD_EXP 40
34359: PUSH
34360: LD_VAR 0 3
34364: ARRAY
34365: PUSH
34366: LD_INT 0
34368: EQUAL
34369: PUSH
34370: LD_VAR 0 3
34374: PPUSH
34375: EMPTY
34376: PPUSH
34377: CALL 11556 0 2
34381: PUSH
34382: LD_INT 0
34384: EQUAL
34385: OR
34386: IFFALSE 34390
// continue ;
34388: GO 34352
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: CALL 24822 0 1
34404: PPUSH
34405: CALL 36360 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34409: LD_EXP 72
34413: PUSH
34414: LD_VAR 0 3
34418: ARRAY
34419: PUSH
34420: LD_INT 1
34422: ARRAY
34423: PUSH
34424: LD_INT 0
34426: GREATER
34427: PUSH
34428: LD_EXP 70
34432: PUSH
34433: LD_VAR 0 3
34437: ARRAY
34438: PUSH
34439: LD_INT 1
34441: ARRAY
34442: PUSH
34443: LD_INT 0
34445: EQUAL
34446: AND
34447: PUSH
34448: LD_VAR 0 3
34452: PPUSH
34453: LD_INT 7
34455: PPUSH
34456: EMPTY
34457: PPUSH
34458: CALL 12124 0 3
34462: NOT
34463: AND
34464: IFFALSE 34535
// begin if side = 1 then
34466: LD_VAR 0 3
34470: PUSH
34471: LD_INT 1
34473: EQUAL
34474: IFFALSE 34483
// RaiseSailEvent ( 101 ) ;
34476: LD_INT 101
34478: PPUSH
34479: CALL_OW 427
// if side = 4 then
34483: LD_VAR 0 3
34487: PUSH
34488: LD_INT 4
34490: EQUAL
34491: IFFALSE 34500
// RaiseSailEvent ( 102 ) ;
34493: LD_INT 102
34495: PPUSH
34496: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34500: LD_ADDR_VAR 0 2
34504: PUSH
34505: LD_EXP 72
34509: PUSH
34510: LD_VAR 0 3
34514: ARRAY
34515: PUSH
34516: FOR_IN
34517: IFFALSE 34533
// SetTag ( i , 7 ) ;
34519: LD_VAR 0 2
34523: PPUSH
34524: LD_INT 7
34526: PPUSH
34527: CALL_OW 109
34531: GO 34516
34533: POP
34534: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_INT 7
34542: PPUSH
34543: EMPTY
34544: PPUSH
34545: CALL 12124 0 3
34549: IFFALSE 34575
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34551: LD_VAR 0 3
34555: PPUSH
34556: LD_VAR 0 3
34560: PPUSH
34561: LD_INT 7
34563: PPUSH
34564: EMPTY
34565: PPUSH
34566: CALL 12124 0 3
34570: PPUSH
34571: CALL 8266 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34575: LD_VAR 0 3
34579: PPUSH
34580: CALL 17804 0 1
34584: PUSH
34585: LD_VAR 0 3
34589: PPUSH
34590: CALL 11460 0 1
34594: AND
34595: IFFALSE 34606
// MCL_Start ( side ) ;
34597: LD_VAR 0 3
34601: PPUSH
34602: CALL 17761 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34606: LD_ADDR_EXP 36
34610: PUSH
34611: LD_EXP 36
34615: PPUSH
34616: LD_VAR 0 3
34620: PPUSH
34621: LD_VAR 0 3
34625: PPUSH
34626: CALL 19061 0 1
34630: PPUSH
34631: CALL_OW 1
34635: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34636: LD_ADDR_EXP 48
34640: PUSH
34641: LD_EXP 48
34645: PPUSH
34646: LD_VAR 0 3
34650: PPUSH
34651: LD_VAR 0 3
34655: PPUSH
34656: CALL 10874 0 1
34660: PPUSH
34661: CALL_OW 1
34665: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34666: LD_VAR 0 3
34670: PPUSH
34671: LD_INT 21
34673: PUSH
34674: LD_INT 2
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PPUSH
34681: CALL 11421 0 2
34685: IFFALSE 34696
// MCV_CheckStatus ( side ) ;
34687: LD_VAR 0 3
34691: PPUSH
34692: CALL 27031 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_EXP 54
34705: PPUSH
34706: CALL 43280 0 2
34710: IFFALSE 34795
// begin for i = MREG_ToChangeClass downto 1 do
34712: LD_ADDR_VAR 0 2
34716: PUSH
34717: DOUBLE
34718: LD_EXP 54
34722: INC
34723: ST_TO_ADDR
34724: LD_INT 1
34726: PUSH
34727: FOR_DOWNTO
34728: IFFALSE 34793
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34730: LD_EXP 54
34734: PUSH
34735: LD_VAR 0 2
34739: ARRAY
34740: PUSH
34741: LD_INT 1
34743: ARRAY
34744: PUSH
34745: LD_VAR 0 3
34749: EQUAL
34750: IFFALSE 34791
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34752: LD_VAR 0 3
34756: PPUSH
34757: LD_EXP 54
34761: PUSH
34762: LD_VAR 0 2
34766: ARRAY
34767: PUSH
34768: LD_INT 2
34770: ARRAY
34771: PPUSH
34772: LD_EXP 54
34776: PUSH
34777: LD_VAR 0 2
34781: ARRAY
34782: PUSH
34783: LD_INT 3
34785: ARRAY
34786: PPUSH
34787: CALL 16328 0 3
// end ; end ;
34791: GO 34727
34793: POP
34794: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34795: LD_INT 1
34797: PUSH
34798: LD_EXP 39
34802: PUSH
34803: LD_VAR 0 3
34807: ARRAY
34808: IN
34809: IFFALSE 34820
// begin MCN_TrainApe ( side ) ;
34811: LD_VAR 0 3
34815: PPUSH
34816: CALL 18714 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34820: LD_VAR 0 3
34824: PPUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 3
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PPUSH
34835: CALL 11421 0 2
34839: IFFALSE 35013
// begin if MCF_Tag ( side , 10 , [ ] ) then
34841: LD_VAR 0 3
34845: PPUSH
34846: LD_INT 10
34848: PPUSH
34849: EMPTY
34850: PPUSH
34851: CALL 12124 0 3
34855: IFFALSE 34902
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34857: LD_VAR 0 3
34861: PPUSH
34862: LD_INT 10
34864: PPUSH
34865: EMPTY
34866: PPUSH
34867: CALL 12124 0 3
34871: PPUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_INT 30
34879: PUSH
34880: LD_INT 3
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PPUSH
34887: CALL 11421 0 2
34891: PUSH
34892: LD_INT 1
34894: ARRAY
34895: PPUSH
34896: CALL_OW 168
// end else
34900: GO 35013
// if MREG_ToConstruct [ side ] then
34902: LD_EXP 52
34906: PUSH
34907: LD_VAR 0 3
34911: ARRAY
34912: IFFALSE 35013
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34914: LD_VAR 0 3
34918: PPUSH
34919: LD_VAR 0 3
34923: PPUSH
34924: LD_INT 30
34926: PUSH
34927: LD_INT 3
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PPUSH
34934: CALL 11421 0 2
34938: PUSH
34939: LD_INT 1
34941: ARRAY
34942: PPUSH
34943: LD_EXP 52
34947: PUSH
34948: LD_VAR 0 3
34952: ARRAY
34953: PUSH
34954: LD_INT 1
34956: ARRAY
34957: PUSH
34958: LD_EXP 52
34962: PUSH
34963: LD_VAR 0 3
34967: ARRAY
34968: PUSH
34969: LD_INT 2
34971: ARRAY
34972: PUSH
34973: LD_EXP 52
34977: PUSH
34978: LD_VAR 0 3
34982: ARRAY
34983: PUSH
34984: LD_INT 3
34986: ARRAY
34987: PUSH
34988: LD_EXP 52
34992: PUSH
34993: LD_VAR 0 3
34997: ARRAY
34998: PUSH
34999: LD_INT 4
35001: ARRAY
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: PPUSH
35009: CALL 25325 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
35013: LD_VAR 0 3
35017: PPUSH
35018: LD_INT 30
35020: PUSH
35021: LD_INT 3
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PPUSH
35028: CALL 11421 0 2
35032: PUSH
35033: LD_VAR 0 3
35037: PPUSH
35038: LD_EXP 44
35042: PPUSH
35043: CALL 43280 0 2
35047: AND
35048: PUSH
35049: LD_INT 22
35051: PUSH
35052: LD_VAR 0 3
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 2
35063: PUSH
35064: LD_INT 30
35066: PUSH
35067: LD_INT 33
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 30
35076: PUSH
35077: LD_INT 32
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 35
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: LIST
35103: PPUSH
35104: CALL_OW 69
35108: AND
35109: IFFALSE 35120
// MCV_Turret ( side ) ;
35111: LD_VAR 0 3
35115: PPUSH
35116: CALL 25774 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35120: LD_EXP 43
35124: PUSH
35125: LD_VAR 0 3
35129: ARRAY
35130: PUSH
35131: LD_INT 1
35133: GREATER
35134: PUSH
35135: LD_VAR 0 3
35139: PPUSH
35140: CALL 24822 0 1
35144: PUSH
35145: LD_INT 0
35147: EQUAL
35148: AND
35149: IFFALSE 35311
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35151: LD_EXP 43
35155: PUSH
35156: LD_VAR 0 3
35160: ARRAY
35161: PUSH
35162: LD_INT 1
35164: ARRAY
35165: PPUSH
35166: CALL_OW 353
35170: IFFALSE 35208
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35172: LD_EXP 43
35176: PUSH
35177: LD_VAR 0 3
35181: ARRAY
35182: PUSH
35183: LD_INT 2
35185: ARRAY
35186: PPUSH
35187: LD_EXP 43
35191: PUSH
35192: LD_VAR 0 3
35196: ARRAY
35197: PUSH
35198: LD_INT 1
35200: ARRAY
35201: PPUSH
35202: CALL 32589 0 2
35206: GO 35311
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35208: LD_VAR 0 3
35212: PPUSH
35213: LD_INT 30
35215: PUSH
35216: LD_INT 3
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PPUSH
35223: CALL 11421 0 2
35227: IFFALSE 35311
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35229: LD_VAR 0 3
35233: PPUSH
35234: LD_INT 30
35236: PUSH
35237: LD_INT 3
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PPUSH
35244: CALL 11421 0 2
35248: PUSH
35249: LD_INT 1
35251: ARRAY
35252: PPUSH
35253: CALL_OW 461
35257: PUSH
35258: LD_INT 2
35260: EQUAL
35261: IFFALSE 35311
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35263: LD_EXP 43
35267: PUSH
35268: LD_VAR 0 3
35272: ARRAY
35273: PUSH
35274: LD_INT 2
35276: ARRAY
35277: PPUSH
35278: LD_INT 10
35280: PPUSH
35281: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35285: LD_ADDR_EXP 43
35289: PUSH
35290: LD_EXP 43
35294: PPUSH
35295: LD_VAR 0 3
35299: PPUSH
35300: LD_INT 0
35302: PUSH
35303: EMPTY
35304: LIST
35305: PPUSH
35306: CALL_OW 1
35310: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35311: LD_VAR 0 3
35315: PPUSH
35316: LD_INT 33
35318: PUSH
35319: LD_INT 2
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PPUSH
35326: CALL 11421 0 2
35330: IFFALSE 35370
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35332: LD_VAR 0 3
35336: PPUSH
35337: LD_VAR 0 3
35341: PPUSH
35342: LD_INT 33
35344: PUSH
35345: LD_INT 2
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PPUSH
35352: CALL 11421 0 2
35356: PUSH
35357: LD_INT 1
35359: ARRAY
35360: PPUSH
35361: CALL_OW 248
35365: PPUSH
35366: CALL 26328 0 2
// if MREG_ToRepair [ side ] then
35370: LD_EXP 48
35374: PUSH
35375: LD_VAR 0 3
35379: ARRAY
35380: IFFALSE 35393
// begin MCB_Repair ( side ) ;
35382: LD_VAR 0 3
35386: PPUSH
35387: CALL 11161 0 1
// end else
35391: GO 36306
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35393: LD_VAR 0 3
35397: PPUSH
35398: LD_EXP 50
35402: PPUSH
35403: CALL 43280 0 2
35407: PUSH
35408: LD_VAR 0 3
35412: PPUSH
35413: LD_EXP 41
35417: PPUSH
35418: CALL 43280 0 2
35422: AND
35423: IFFALSE 35631
// begin for i = 1 to MREG_ToUpLab do
35425: LD_ADDR_VAR 0 2
35429: PUSH
35430: DOUBLE
35431: LD_INT 1
35433: DEC
35434: ST_TO_ADDR
35435: LD_EXP 50
35439: PUSH
35440: FOR_TO
35441: IFFALSE 35627
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35443: LD_EXP 50
35447: PUSH
35448: LD_VAR 0 2
35452: ARRAY
35453: PUSH
35454: LD_INT 1
35456: ARRAY
35457: PUSH
35458: LD_VAR 0 3
35462: EQUAL
35463: IFFALSE 35625
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35465: LD_EXP 50
35469: PUSH
35470: LD_VAR 0 2
35474: ARRAY
35475: PUSH
35476: LD_INT 2
35478: ARRAY
35479: PUSH
35480: LD_EXP 50
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PUSH
35491: LD_INT 3
35493: ARRAY
35494: AND
35495: IFFALSE 35623
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35497: LD_VAR 0 3
35501: PPUSH
35502: LD_EXP 50
35506: PUSH
35507: LD_VAR 0 2
35511: ARRAY
35512: PUSH
35513: LD_INT 2
35515: ARRAY
35516: PPUSH
35517: LD_EXP 50
35521: PUSH
35522: LD_VAR 0 2
35526: ARRAY
35527: PUSH
35528: LD_INT 3
35530: ARRAY
35531: PPUSH
35532: CALL 8685 0 3
35536: IFFALSE 35623
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35538: LD_ADDR_EXP 50
35542: PUSH
35543: LD_EXP 50
35547: PPUSH
35548: LD_VAR 0 3
35552: PPUSH
35553: LD_EXP 50
35557: PUSH
35558: LD_VAR 0 2
35562: ARRAY
35563: PUSH
35564: LD_INT 2
35566: ARRAY
35567: PPUSH
35568: LD_EXP 50
35572: PUSH
35573: LD_VAR 0 2
35577: ARRAY
35578: PUSH
35579: LD_INT 3
35581: ARRAY
35582: PPUSH
35583: CALL 42332 0 4
35587: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35588: LD_ADDR_EXP 41
35592: PUSH
35593: LD_EXP 41
35597: PPUSH
35598: LD_VAR 0 3
35602: PPUSH
35603: LD_EXP 41
35607: PUSH
35608: LD_INT 1
35610: ARRAY
35611: PUSH
35612: LD_INT 2
35614: ARRAY
35615: PPUSH
35616: EMPTY
35617: PPUSH
35618: CALL 42332 0 4
35622: ST_TO_ADDR
// end ; break ;
35623: GO 35627
// end ;
35625: GO 35440
35627: POP
35628: POP
// end else
35629: GO 36306
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35631: LD_VAR 0 3
35635: PPUSH
35636: LD_EXP 49
35640: PPUSH
35641: CALL 43280 0 2
35645: IFFALSE 35719
// begin for i = 1 to MREG_ToUpdate do
35647: LD_ADDR_VAR 0 2
35651: PUSH
35652: DOUBLE
35653: LD_INT 1
35655: DEC
35656: ST_TO_ADDR
35657: LD_EXP 49
35661: PUSH
35662: FOR_TO
35663: IFFALSE 35715
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35665: LD_EXP 49
35669: PUSH
35670: LD_VAR 0 2
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PUSH
35680: LD_VAR 0 3
35684: EQUAL
35685: IFFALSE 35713
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35687: LD_VAR 0 3
35691: PPUSH
35692: LD_EXP 49
35696: PUSH
35697: LD_VAR 0 2
35701: ARRAY
35702: PUSH
35703: LD_INT 2
35705: ARRAY
35706: PPUSH
35707: CALL 8521 0 2
// break ;
35711: GO 35715
// end ;
35713: GO 35662
35715: POP
35716: POP
// end else
35717: GO 36306
// if MCF_Get ( side , [ f_constructed ] ) then
35719: LD_VAR 0 3
35723: PPUSH
35724: LD_INT 57
35726: PUSH
35727: EMPTY
35728: LIST
35729: PPUSH
35730: CALL 11421 0 2
35734: IFFALSE 35767
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35736: LD_VAR 0 3
35740: PPUSH
35741: LD_VAR 0 3
35745: PPUSH
35746: LD_INT 57
35748: PUSH
35749: EMPTY
35750: LIST
35751: PPUSH
35752: CALL 11421 0 2
35756: PUSH
35757: LD_INT 1
35759: ARRAY
35760: PPUSH
35761: CALL 10765 0 2
35765: GO 36306
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35767: LD_VAR 0 3
35771: PPUSH
35772: LD_EXP 47
35776: PPUSH
35777: CALL 43280 0 2
35781: PUSH
35782: LD_VAR 0 3
35786: PPUSH
35787: CALL_OW 345
35791: NOT
35792: AND
35793: PUSH
35794: LD_VAR 0 3
35798: PPUSH
35799: CALL 24822 0 1
35803: PUSH
35804: LD_INT 0
35806: EQUAL
35807: AND
35808: IFFALSE 36207
// begin for i = 1 to MREG_ToBuild do
35810: LD_ADDR_VAR 0 2
35814: PUSH
35815: DOUBLE
35816: LD_INT 1
35818: DEC
35819: ST_TO_ADDR
35820: LD_EXP 47
35824: PUSH
35825: FOR_TO
35826: IFFALSE 36203
// if MREG_ToBuild [ i ] [ 1 ] = side then
35828: LD_EXP 47
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: PUSH
35839: LD_INT 1
35841: ARRAY
35842: PUSH
35843: LD_VAR 0 3
35847: EQUAL
35848: IFFALSE 36201
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35850: LD_OWVAR 84
35854: PUSH
35855: LD_EXP 47
35859: PUSH
35860: LD_VAR 0 2
35864: ARRAY
35865: PUSH
35866: LD_INT 3
35868: ARRAY
35869: PUSH
35870: LD_INT 1
35872: ARRAY
35873: PPUSH
35874: LD_EXP 47
35878: PUSH
35879: LD_VAR 0 2
35883: ARRAY
35884: PUSH
35885: LD_INT 3
35887: ARRAY
35888: PUSH
35889: LD_INT 2
35891: ARRAY
35892: PPUSH
35893: CALL_OW 351
35897: AND
35898: IFFALSE 35942
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35900: LD_EXP 47
35904: PUSH
35905: LD_VAR 0 2
35909: ARRAY
35910: PUSH
35911: LD_INT 3
35913: ARRAY
35914: PUSH
35915: LD_INT 1
35917: ARRAY
35918: PPUSH
35919: LD_EXP 47
35923: PUSH
35924: LD_VAR 0 2
35928: ARRAY
35929: PUSH
35930: LD_INT 3
35932: ARRAY
35933: PUSH
35934: LD_INT 2
35936: ARRAY
35937: PPUSH
35938: CALL 22569 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35942: LD_EXP 47
35946: PUSH
35947: LD_VAR 0 2
35951: ARRAY
35952: PUSH
35953: LD_INT 2
35955: ARRAY
35956: PUSH
35957: LD_INT 0
35959: EQUAL
35960: IFFALSE 36030
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35962: LD_VAR 0 3
35966: PPUSH
35967: LD_EXP 47
35971: PUSH
35972: LD_VAR 0 2
35976: ARRAY
35977: PUSH
35978: LD_INT 3
35980: ARRAY
35981: PUSH
35982: LD_INT 1
35984: ARRAY
35985: PPUSH
35986: LD_EXP 47
35990: PUSH
35991: LD_VAR 0 2
35995: ARRAY
35996: PUSH
35997: LD_INT 3
35999: ARRAY
36000: PUSH
36001: LD_INT 2
36003: ARRAY
36004: PPUSH
36005: LD_EXP 47
36009: PUSH
36010: LD_VAR 0 2
36014: ARRAY
36015: PUSH
36016: LD_INT 3
36018: ARRAY
36019: PUSH
36020: LD_INT 3
36022: ARRAY
36023: PPUSH
36024: CALL 8357 0 4
36028: GO 36199
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
36030: LD_EXP 47
36034: PUSH
36035: LD_VAR 0 2
36039: ARRAY
36040: PUSH
36041: LD_INT 2
36043: ARRAY
36044: PUSH
36045: LD_INT 6
36047: EQUAL
36048: IFFALSE 36118
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36050: LD_VAR 0 3
36054: PPUSH
36055: LD_EXP 47
36059: PUSH
36060: LD_VAR 0 2
36064: ARRAY
36065: PUSH
36066: LD_INT 3
36068: ARRAY
36069: PUSH
36070: LD_INT 1
36072: ARRAY
36073: PPUSH
36074: LD_EXP 47
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PUSH
36085: LD_INT 3
36087: ARRAY
36088: PUSH
36089: LD_INT 2
36091: ARRAY
36092: PPUSH
36093: LD_EXP 47
36097: PUSH
36098: LD_VAR 0 2
36102: ARRAY
36103: PUSH
36104: LD_INT 3
36106: ARRAY
36107: PUSH
36108: LD_INT 3
36110: ARRAY
36111: PPUSH
36112: CALL 8486 0 4
36116: GO 36199
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36118: LD_VAR 0 3
36122: PPUSH
36123: LD_EXP 47
36127: PUSH
36128: LD_VAR 0 2
36132: ARRAY
36133: PUSH
36134: LD_INT 2
36136: ARRAY
36137: PPUSH
36138: LD_EXP 47
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_INT 3
36151: ARRAY
36152: PUSH
36153: LD_INT 1
36155: ARRAY
36156: PPUSH
36157: LD_EXP 47
36161: PUSH
36162: LD_VAR 0 2
36166: ARRAY
36167: PUSH
36168: LD_INT 3
36170: ARRAY
36171: PUSH
36172: LD_INT 2
36174: ARRAY
36175: PPUSH
36176: LD_EXP 47
36180: PUSH
36181: LD_VAR 0 2
36185: ARRAY
36186: PUSH
36187: LD_INT 3
36189: ARRAY
36190: PUSH
36191: LD_INT 3
36193: ARRAY
36194: PPUSH
36195: CALL 9990 0 5
// break ;
36199: GO 36203
// end ;
36201: GO 35825
36203: POP
36204: POP
// end else
36205: GO 36306
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36207: LD_VAR 0 3
36211: PPUSH
36212: LD_EXP 53
36216: PPUSH
36217: CALL 43280 0 2
36221: PUSH
36222: LD_VAR 0 3
36226: PPUSH
36227: CALL 24822 0 1
36231: PUSH
36232: LD_INT 0
36234: EQUAL
36235: AND
36236: IFFALSE 36306
// begin for i = 1 to MREG_ToDismantle do
36238: LD_ADDR_VAR 0 2
36242: PUSH
36243: DOUBLE
36244: LD_INT 1
36246: DEC
36247: ST_TO_ADDR
36248: LD_EXP 53
36252: PUSH
36253: FOR_TO
36254: IFFALSE 36304
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36256: LD_EXP 53
36260: PUSH
36261: LD_VAR 0 2
36265: ARRAY
36266: PUSH
36267: LD_INT 1
36269: ARRAY
36270: PUSH
36271: LD_VAR 0 3
36275: EQUAL
36276: IFFALSE 36302
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36278: LD_VAR 0 3
36282: PPUSH
36283: LD_EXP 53
36287: PUSH
36288: LD_VAR 0 2
36292: ARRAY
36293: PUSH
36294: LD_INT 2
36296: ARRAY
36297: PPUSH
36298: CALL 10656 0 2
// end ;
36302: GO 36253
36304: POP
36305: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36306: LD_VAR 0 3
36310: PPUSH
36311: LD_INT 30
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PPUSH
36321: CALL 11421 0 2
36325: PUSH
36326: LD_VAR 0 3
36330: PPUSH
36331: CALL 24822 0 1
36335: PUSH
36336: LD_INT 0
36338: EQUAL
36339: AND
36340: IFFALSE 36351
// MCT_CollectCrates ( side ) ;
36342: LD_VAR 0 3
36346: PPUSH
36347: CALL 23761 0 1
// end ;
36351: GO 34352
36353: POP
36354: POP
// end ;
36355: LD_VAR 0 1
36359: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36360: LD_INT 0
36362: PPUSH
36363: PPUSH
36364: PPUSH
36365: PPUSH
36366: PPUSH
36367: PPUSH
36368: PPUSH
36369: PPUSH
36370: PPUSH
36371: PPUSH
36372: PPUSH
36373: PPUSH
36374: PPUSH
36375: PPUSH
36376: PPUSH
// all := MCF_All ( side , [ ] ) ;
36377: LD_ADDR_VAR 0 17
36381: PUSH
36382: LD_VAR 0 1
36386: PPUSH
36387: EMPTY
36388: PPUSH
36389: CALL 11556 0 2
36393: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36394: LD_ADDR_VAR 0 13
36398: PUSH
36399: LD_VAR 0 1
36403: PPUSH
36404: LD_INT 1
36406: PPUSH
36407: EMPTY
36408: PPUSH
36409: CALL 11504 0 3
36413: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36414: LD_ADDR_VAR 0 14
36418: PUSH
36419: LD_VAR 0 1
36423: PPUSH
36424: LD_INT 2
36426: PPUSH
36427: EMPTY
36428: PPUSH
36429: CALL 11504 0 3
36433: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36434: LD_ADDR_VAR 0 15
36438: PUSH
36439: LD_VAR 0 1
36443: PPUSH
36444: LD_INT 3
36446: PPUSH
36447: EMPTY
36448: PPUSH
36449: CALL 11504 0 3
36453: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36454: LD_ADDR_VAR 0 16
36458: PUSH
36459: LD_VAR 0 1
36463: PPUSH
36464: LD_INT 4
36466: PPUSH
36467: EMPTY
36468: PPUSH
36469: CALL 11504 0 3
36473: ST_TO_ADDR
// if mech then
36474: LD_VAR 0 15
36478: IFFALSE 36495
// mech := MCF_SortListDesc ( mech ) ;
36480: LD_ADDR_VAR 0 15
36484: PUSH
36485: LD_VAR 0 15
36489: PPUSH
36490: CALL 12670 0 1
36494: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36495: LD_EXP 57
36499: PUSH
36500: LD_VAR 0 1
36504: ARRAY
36505: PUSH
36506: LD_STRING 
36508: EQUAL
36509: NOT
36510: IFFALSE 36566
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36512: LD_EXP 57
36516: PUSH
36517: LD_VAR 0 1
36521: ARRAY
36522: PUSH
36523: LD_INT 1
36525: ARRAY
36526: PPUSH
36527: CALL_OW 257
36531: PUSH
36532: LD_INT 1
36534: EQUAL
36535: IFFALSE 36564
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36537: LD_VAR 0 1
36541: PPUSH
36542: LD_STRING ToArm
36544: PPUSH
36545: LD_EXP 57
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL 14300 0 3
// end else
36564: GO 36592
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36566: LD_ADDR_EXP 57
36570: PUSH
36571: LD_EXP 57
36575: PPUSH
36576: LD_VAR 0 1
36580: PPUSH
36581: LD_INT 1
36583: PPUSH
36584: LD_INT 0
36586: PPUSH
36587: CALL 30959 0 4
36591: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36592: LD_EXP 58
36596: PUSH
36597: LD_VAR 0 1
36601: ARRAY
36602: PUSH
36603: LD_STRING 
36605: EQUAL
36606: NOT
36607: IFFALSE 36663
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36609: LD_EXP 58
36613: PUSH
36614: LD_VAR 0 1
36618: ARRAY
36619: PUSH
36620: LD_INT 1
36622: ARRAY
36623: PPUSH
36624: CALL_OW 257
36628: PUSH
36629: LD_INT 2
36631: EQUAL
36632: IFFALSE 36661
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36634: LD_VAR 0 1
36638: PPUSH
36639: LD_STRING ToDep
36641: PPUSH
36642: LD_EXP 58
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL 14300 0 3
// end else
36661: GO 36689
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36663: LD_ADDR_EXP 58
36667: PUSH
36668: LD_EXP 58
36672: PPUSH
36673: LD_VAR 0 1
36677: PPUSH
36678: LD_INT 1
36680: PPUSH
36681: LD_INT 0
36683: PPUSH
36684: CALL 30959 0 4
36688: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36689: LD_EXP 56
36693: PUSH
36694: LD_VAR 0 1
36698: ARRAY
36699: PUSH
36700: LD_STRING 
36702: EQUAL
36703: NOT
36704: IFFALSE 36760
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36706: LD_EXP 56
36710: PUSH
36711: LD_VAR 0 1
36715: ARRAY
36716: PUSH
36717: LD_INT 1
36719: ARRAY
36720: PPUSH
36721: CALL_OW 257
36725: PUSH
36726: LD_INT 3
36728: EQUAL
36729: IFFALSE 36758
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36731: LD_VAR 0 1
36735: PPUSH
36736: LD_STRING ToFac
36738: PPUSH
36739: LD_EXP 56
36743: PUSH
36744: LD_VAR 0 1
36748: ARRAY
36749: PUSH
36750: LD_INT 1
36752: ARRAY
36753: PPUSH
36754: CALL 14300 0 3
// end else
36758: GO 36786
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36760: LD_ADDR_EXP 56
36764: PUSH
36765: LD_EXP 56
36769: PPUSH
36770: LD_VAR 0 1
36774: PPUSH
36775: LD_INT 1
36777: PPUSH
36778: LD_INT 0
36780: PPUSH
36781: CALL 30959 0 4
36785: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36786: LD_EXP 55
36790: PUSH
36791: LD_VAR 0 1
36795: ARRAY
36796: PUSH
36797: LD_STRING 
36799: EQUAL
36800: NOT
36801: IFFALSE 36857
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36803: LD_EXP 55
36807: PUSH
36808: LD_VAR 0 1
36812: ARRAY
36813: PUSH
36814: LD_INT 1
36816: ARRAY
36817: PPUSH
36818: CALL_OW 257
36822: PUSH
36823: LD_INT 4
36825: EQUAL
36826: IFFALSE 36855
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36828: LD_VAR 0 1
36832: PPUSH
36833: LD_STRING ToLab
36835: PPUSH
36836: LD_EXP 55
36840: PUSH
36841: LD_VAR 0 1
36845: ARRAY
36846: PUSH
36847: LD_INT 1
36849: ARRAY
36850: PPUSH
36851: CALL 14300 0 3
// end else
36855: GO 36883
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36857: LD_ADDR_EXP 55
36861: PUSH
36862: LD_EXP 55
36866: PPUSH
36867: LD_VAR 0 1
36871: PPUSH
36872: LD_INT 1
36874: PPUSH
36875: LD_INT 0
36877: PPUSH
36878: CALL 30959 0 4
36882: ST_TO_ADDR
// if mode = 0 then
36883: LD_VAR 0 2
36887: PUSH
36888: LD_INT 0
36890: EQUAL
36891: IFFALSE 38729
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36893: LD_VAR 0 1
36897: PPUSH
36898: LD_INT 30
36900: PUSH
36901: LD_INT 1
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PPUSH
36908: CALL 11421 0 2
36912: PUSH
36913: LD_VAR 0 1
36917: PPUSH
36918: LD_INT 21
36920: PUSH
36921: LD_INT 3
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PPUSH
36928: CALL 11421 0 2
36932: PUSH
36933: LD_INT 1
36935: EQUAL
36936: AND
36937: IFFALSE 37002
// begin if all then
36939: LD_VAR 0 17
36943: IFFALSE 37000
// for i in ( all diff eng ) do
36945: LD_ADDR_VAR 0 4
36949: PUSH
36950: LD_VAR 0 17
36954: PUSH
36955: LD_VAR 0 14
36959: DIFF
36960: PUSH
36961: FOR_IN
36962: IFFALSE 36998
// if GetTag ( i ) = 0 then
36964: LD_VAR 0 4
36968: PPUSH
36969: CALL_OW 110
36973: PUSH
36974: LD_INT 0
36976: EQUAL
36977: IFFALSE 36996
// MCH_ChangeClass ( side , i , 2 ) ;
36979: LD_VAR 0 1
36983: PPUSH
36984: LD_VAR 0 4
36988: PPUSH
36989: LD_INT 2
36991: PPUSH
36992: CALL 16328 0 3
36996: GO 36961
36998: POP
36999: POP
// end else
37000: GO 37321
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
37002: LD_VAR 0 13
37006: PUSH
37007: LD_EXP 57
37011: PUSH
37012: LD_VAR 0 1
37016: ARRAY
37017: PLUS
37018: PUSH
37019: LD_INT 22
37021: PUSH
37022: LD_VAR 0 1
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 30
37033: PUSH
37034: LD_INT 32
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PPUSH
37045: CALL_OW 69
37049: LESS
37050: IFFALSE 37075
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
37052: LD_VAR 0 1
37056: PPUSH
37057: LD_VAR 0 14
37061: PUSH
37062: LD_INT 1
37064: ARRAY
37065: PPUSH
37066: LD_INT 1
37068: PPUSH
37069: CALL 16328 0 3
// end else
37073: GO 37321
// if sci < 6 and MCF_Lab ( side ) then
37075: LD_VAR 0 16
37079: PUSH
37080: LD_INT 6
37082: LESS
37083: PUSH
37084: LD_VAR 0 1
37088: PPUSH
37089: CALL 11460 0 1
37093: AND
37094: IFFALSE 37199
// begin if MREG_ToBunker [ side ] then
37096: LD_EXP 69
37100: PUSH
37101: LD_VAR 0 1
37105: ARRAY
37106: IFFALSE 37132
// tmp := sol diff MREG_ToBunker [ side ] else
37108: LD_ADDR_VAR 0 12
37112: PUSH
37113: LD_VAR 0 13
37117: PUSH
37118: LD_EXP 69
37122: PUSH
37123: LD_VAR 0 1
37127: ARRAY
37128: DIFF
37129: ST_TO_ADDR
37130: GO 37142
// tmp := sol ;
37132: LD_ADDR_VAR 0 12
37136: PUSH
37137: LD_VAR 0 13
37141: ST_TO_ADDR
// if tmp then
37142: LD_VAR 0 12
37146: IFFALSE 37197
// for i in tmp do
37148: LD_ADDR_VAR 0 4
37152: PUSH
37153: LD_VAR 0 12
37157: PUSH
37158: FOR_IN
37159: IFFALSE 37195
// if GetTag ( i ) = 0 then
37161: LD_VAR 0 4
37165: PPUSH
37166: CALL_OW 110
37170: PUSH
37171: LD_INT 0
37173: EQUAL
37174: IFFALSE 37193
// MCH_ChangeClass ( side , i , 4 ) ;
37176: LD_VAR 0 1
37180: PPUSH
37181: LD_VAR 0 4
37185: PPUSH
37186: LD_INT 4
37188: PPUSH
37189: CALL 16328 0 3
37193: GO 37158
37195: POP
37196: POP
// end else
37197: GO 37321
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37199: LD_VAR 0 1
37203: PPUSH
37204: LD_INT 30
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PPUSH
37214: CALL 11421 0 2
37218: IFFALSE 37321
// begin if MREG_ToBunker [ side ] then
37220: LD_EXP 69
37224: PUSH
37225: LD_VAR 0 1
37229: ARRAY
37230: IFFALSE 37256
// tmp := sol diff MREG_ToBunker [ side ] else
37232: LD_ADDR_VAR 0 12
37236: PUSH
37237: LD_VAR 0 13
37241: PUSH
37242: LD_EXP 69
37246: PUSH
37247: LD_VAR 0 1
37251: ARRAY
37252: DIFF
37253: ST_TO_ADDR
37254: GO 37266
// tmp := sol ;
37256: LD_ADDR_VAR 0 12
37260: PUSH
37261: LD_VAR 0 13
37265: ST_TO_ADDR
// if tmp then
37266: LD_VAR 0 12
37270: IFFALSE 37321
// for i in tmp do
37272: LD_ADDR_VAR 0 4
37276: PUSH
37277: LD_VAR 0 12
37281: PUSH
37282: FOR_IN
37283: IFFALSE 37319
// if GetTag ( i ) = 0 then
37285: LD_VAR 0 4
37289: PPUSH
37290: CALL_OW 110
37294: PUSH
37295: LD_INT 0
37297: EQUAL
37298: IFFALSE 37317
// MCH_ChangeClass ( side , i , 2 ) ;
37300: LD_VAR 0 1
37304: PPUSH
37305: LD_VAR 0 4
37309: PPUSH
37310: LD_INT 2
37312: PPUSH
37313: CALL 16328 0 3
37317: GO 37282
37319: POP
37320: POP
// end ; if MCF_Lab ( side ) then
37321: LD_VAR 0 1
37325: PPUSH
37326: CALL 11460 0 1
37330: IFFALSE 37870
// begin if MCL_GetTechList ( side ) then
37332: LD_VAR 0 1
37336: PPUSH
37337: CALL 17804 0 1
37341: IFFALSE 37467
// begin if MREG_ToLab [ side ] then
37343: LD_EXP 55
37347: PUSH
37348: LD_VAR 0 1
37352: ARRAY
37353: IFFALSE 37373
// k := MREG_ToLab [ side ] else
37355: LD_ADDR_VAR 0 8
37359: PUSH
37360: LD_EXP 55
37364: PUSH
37365: LD_VAR 0 1
37369: ARRAY
37370: ST_TO_ADDR
37371: GO 37381
// k := 0 ;
37373: LD_ADDR_VAR 0 8
37377: PUSH
37378: LD_INT 0
37380: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37381: LD_VAR 0 16
37385: PUSH
37386: LD_VAR 0 8
37390: PLUS
37391: PUSH
37392: LD_INT 6
37394: LESSEQUAL
37395: PUSH
37396: LD_VAR 0 17
37400: PUSH
37401: LD_INT 6
37403: GREATER
37404: AND
37405: IFFALSE 37421
// MCH_TrainScientist ( side , 1 ) else
37407: LD_VAR 0 1
37411: PPUSH
37412: LD_INT 1
37414: PPUSH
37415: CALL 15880 0 2
37419: GO 37465
// if all < 6 then
37421: LD_VAR 0 17
37425: PUSH
37426: LD_INT 6
37428: LESS
37429: IFFALSE 37465
// if sci + k < all / 2 then
37431: LD_VAR 0 16
37435: PUSH
37436: LD_VAR 0 8
37440: PLUS
37441: PUSH
37442: LD_VAR 0 17
37446: PUSH
37447: LD_INT 2
37449: DIVREAL
37450: LESS
37451: IFFALSE 37465
// MCH_TrainScientist ( side , 1 ) ;
37453: LD_VAR 0 1
37457: PPUSH
37458: LD_INT 1
37460: PPUSH
37461: CALL 15880 0 2
// end else
37465: GO 37543
// begin if sci > 2 then
37467: LD_VAR 0 16
37471: PUSH
37472: LD_INT 2
37474: GREATER
37475: IFFALSE 37543
// for i = sci downto 2 do
37477: LD_ADDR_VAR 0 4
37481: PUSH
37482: DOUBLE
37483: LD_VAR 0 16
37487: INC
37488: ST_TO_ADDR
37489: LD_INT 2
37491: PUSH
37492: FOR_DOWNTO
37493: IFFALSE 37541
// if GetTag ( sci [ i ] ) = 0 then
37495: LD_VAR 0 16
37499: PUSH
37500: LD_VAR 0 4
37504: ARRAY
37505: PPUSH
37506: CALL_OW 110
37510: PUSH
37511: LD_INT 0
37513: EQUAL
37514: IFFALSE 37539
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37516: LD_VAR 0 1
37520: PPUSH
37521: LD_VAR 0 16
37525: PUSH
37526: LD_VAR 0 4
37530: ARRAY
37531: PPUSH
37532: LD_INT 2
37534: PPUSH
37535: CALL 16328 0 3
37539: GO 37492
37541: POP
37542: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37543: LD_VAR 0 1
37547: PPUSH
37548: CALL 17804 0 1
37552: PUSH
37553: LD_VAR 0 1
37557: PPUSH
37558: CALL 11460 0 1
37562: AND
37563: PUSH
37564: LD_EXP 36
37568: PUSH
37569: LD_VAR 0 1
37573: ARRAY
37574: NOT
37575: AND
37576: IFFALSE 37870
// begin for j = 1 to MCF_Lab ( side ) do
37578: LD_ADDR_VAR 0 5
37582: PUSH
37583: DOUBLE
37584: LD_INT 1
37586: DEC
37587: ST_TO_ADDR
37588: LD_VAR 0 1
37592: PPUSH
37593: CALL 11460 0 1
37597: PUSH
37598: FOR_TO
37599: IFFALSE 37659
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37601: LD_VAR 0 1
37605: PPUSH
37606: CALL 11460 0 1
37610: PUSH
37611: LD_VAR 0 5
37615: ARRAY
37616: PPUSH
37617: CALL_OW 461
37621: PUSH
37622: LD_INT 3
37624: PUSH
37625: LD_INT 6
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: IN
37632: IFFALSE 37657
// begin b := MCF_Lab ( side ) [ j ] ;
37634: LD_ADDR_VAR 0 11
37638: PUSH
37639: LD_VAR 0 1
37643: PPUSH
37644: CALL 11460 0 1
37648: PUSH
37649: LD_VAR 0 5
37653: ARRAY
37654: ST_TO_ADDR
// break ;
37655: GO 37659
// end ;
37657: GO 37598
37659: POP
37660: POP
// if MCF_Class ( side , 4 , [ ] ) then
37661: LD_VAR 0 1
37665: PPUSH
37666: LD_INT 4
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL 11504 0 3
37675: IFFALSE 37870
// for j in MCF_Class ( side , 4 , [ ] ) do
37677: LD_ADDR_VAR 0 5
37681: PUSH
37682: LD_VAR 0 1
37686: PPUSH
37687: LD_INT 4
37689: PPUSH
37690: EMPTY
37691: PPUSH
37692: CALL 11504 0 3
37696: PUSH
37697: FOR_IN
37698: IFFALSE 37868
// begin if GetTag ( j ) = 0 then
37700: LD_VAR 0 5
37704: PPUSH
37705: CALL_OW 110
37709: PUSH
37710: LD_INT 0
37712: EQUAL
37713: IFFALSE 37804
// begin if IsInUnit ( j ) and b then
37715: LD_VAR 0 5
37719: PPUSH
37720: CALL_OW 310
37724: PUSH
37725: LD_VAR 0 11
37729: AND
37730: IFFALSE 37778
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37732: LD_VAR 0 5
37736: PPUSH
37737: CALL_OW 310
37741: PPUSH
37742: CALL_OW 461
37746: PUSH
37747: LD_INT 2
37749: EQUAL
37750: PUSH
37751: LD_VAR 0 5
37755: PPUSH
37756: CALL_OW 310
37760: PUSH
37761: LD_VAR 0 11
37765: NONEQUAL
37766: AND
37767: IFFALSE 37778
// ComExitBuilding ( j ) ;
37769: LD_VAR 0 5
37773: PPUSH
37774: CALL_OW 122
// if not IsInUnit ( j ) then
37778: LD_VAR 0 5
37782: PPUSH
37783: CALL_OW 310
37787: NOT
37788: IFFALSE 37804
// ComEnterUnit ( j , b ) ;
37790: LD_VAR 0 5
37794: PPUSH
37795: LD_VAR 0 11
37799: PPUSH
37800: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37804: LD_INT 1
37806: PPUSH
37807: LD_VAR 0 5
37811: PPUSH
37812: CALL_OW 255
37816: PPUSH
37817: CALL_OW 321
37821: PUSH
37822: LD_INT 2
37824: EQUAL
37825: PUSH
37826: LD_VAR 0 5
37830: PPUSH
37831: CALL_OW 255
37835: PPUSH
37836: CALL 24822 0 1
37840: PUSH
37841: LD_INT 0
37843: EQUAL
37844: AND
37845: IFFALSE 37866
// MCN_Tame ( GetSide ( j ) , j ) ;
37847: LD_VAR 0 5
37851: PPUSH
37852: CALL_OW 255
37856: PPUSH
37857: LD_VAR 0 5
37861: PPUSH
37862: CALL 18323 0 2
// end ;
37866: GO 37697
37868: POP
37869: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37870: LD_VAR 0 1
37874: PPUSH
37875: LD_INT 30
37877: PUSH
37878: LD_INT 3
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PPUSH
37885: CALL 11421 0 2
37889: IFFALSE 38148
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37891: LD_ADDR_VAR 0 11
37895: PUSH
37896: LD_VAR 0 1
37900: PPUSH
37901: LD_INT 30
37903: PUSH
37904: LD_INT 3
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PPUSH
37911: CALL 11421 0 2
37915: PUSH
37916: LD_INT 1
37918: ARRAY
37919: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37920: LD_ADDR_VAR 0 12
37924: PUSH
37925: LD_VAR 0 1
37929: PPUSH
37930: LD_INT 0
37932: PPUSH
37933: LD_INT 25
37935: PUSH
37936: LD_INT 3
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PPUSH
37943: CALL 12124 0 3
37947: ST_TO_ADDR
// for i = 1 to tmp do
37948: LD_ADDR_VAR 0 4
37952: PUSH
37953: DOUBLE
37954: LD_INT 1
37956: DEC
37957: ST_TO_ADDR
37958: LD_VAR 0 12
37962: PUSH
37963: FOR_TO
37964: IFFALSE 38024
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37966: LD_VAR 0 12
37970: PUSH
37971: LD_VAR 0 4
37975: ARRAY
37976: PPUSH
37977: CALL_OW 310
37981: NOT
37982: PUSH
37983: LD_VAR 0 12
37987: PUSH
37988: LD_VAR 0 4
37992: ARRAY
37993: PPUSH
37994: CALL_OW 314
37998: NOT
37999: AND
38000: IFFALSE 38022
// ComEnterUnit ( tmp [ i ] , b ) ;
38002: LD_VAR 0 12
38006: PUSH
38007: LD_VAR 0 4
38011: ARRAY
38012: PPUSH
38013: LD_VAR 0 11
38017: PPUSH
38018: CALL_OW 120
38022: GO 37963
38024: POP
38025: POP
// if MREG_ToFac [ side ] then
38026: LD_EXP 56
38030: PUSH
38031: LD_VAR 0 1
38035: ARRAY
38036: IFFALSE 38056
// k := MREG_ToFac [ side ] else
38038: LD_ADDR_VAR 0 8
38042: PUSH
38043: LD_EXP 56
38047: PUSH
38048: LD_VAR 0 1
38052: ARRAY
38053: ST_TO_ADDR
38054: GO 38064
// k := 0 ;
38056: LD_ADDR_VAR 0 8
38060: PUSH
38061: LD_INT 0
38063: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
38064: LD_VAR 0 15
38068: PUSH
38069: LD_VAR 0 8
38073: PLUS
38074: PUSH
38075: LD_INT 6
38077: LESSEQUAL
38078: PUSH
38079: LD_VAR 0 17
38083: PUSH
38084: LD_INT 6
38086: GREATER
38087: AND
38088: IFFALSE 38104
// MCH_TrainMechanic ( side , 1 ) else
38090: LD_VAR 0 1
38094: PPUSH
38095: LD_INT 1
38097: PPUSH
38098: CALL 15622 0 2
38102: GO 38148
// if all < 6 then
38104: LD_VAR 0 17
38108: PUSH
38109: LD_INT 6
38111: LESS
38112: IFFALSE 38148
// if mech + k < all / 2 then
38114: LD_VAR 0 15
38118: PUSH
38119: LD_VAR 0 8
38123: PLUS
38124: PUSH
38125: LD_VAR 0 17
38129: PUSH
38130: LD_INT 2
38132: DIVREAL
38133: LESS
38134: IFFALSE 38148
// MCH_TrainMechanic ( side , 1 ) ;
38136: LD_VAR 0 1
38140: PPUSH
38141: LD_INT 1
38143: PPUSH
38144: CALL 15622 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38148: LD_ADDR_VAR 0 10
38152: PUSH
38153: LD_VAR 0 1
38157: PPUSH
38158: LD_INT 30
38160: PUSH
38161: LD_INT 36
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PPUSH
38168: CALL 11421 0 2
38172: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38173: LD_VAR 0 10
38177: PUSH
38178: LD_VAR 0 15
38182: AND
38183: PUSH
38184: LD_VAR 0 1
38188: PPUSH
38189: LD_INT 3
38191: PPUSH
38192: EMPTY
38193: PPUSH
38194: CALL 11504 0 3
38198: AND
38199: IFFALSE 38357
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38201: LD_VAR 0 1
38205: PPUSH
38206: LD_INT 9
38208: PPUSH
38209: EMPTY
38210: PPUSH
38211: CALL 12124 0 3
38215: PUSH
38216: LD_INT 3
38218: LESS
38219: IFFALSE 38357
// begin if mech < 3 then
38221: LD_VAR 0 15
38225: PUSH
38226: LD_INT 3
38228: LESS
38229: IFFALSE 38243
// k := mech else
38231: LD_ADDR_VAR 0 8
38235: PUSH
38236: LD_VAR 0 15
38240: ST_TO_ADDR
38241: GO 38251
// k := 3 ;
38243: LD_ADDR_VAR 0 8
38247: PUSH
38248: LD_INT 3
38250: ST_TO_ADDR
// for j = 1 to k do
38251: LD_ADDR_VAR 0 5
38255: PUSH
38256: DOUBLE
38257: LD_INT 1
38259: DEC
38260: ST_TO_ADDR
38261: LD_VAR 0 8
38265: PUSH
38266: FOR_TO
38267: IFFALSE 38325
// if GetClass ( mech [ j ] ) = 3 then
38269: LD_VAR 0 15
38273: PUSH
38274: LD_VAR 0 5
38278: ARRAY
38279: PPUSH
38280: CALL_OW 257
38284: PUSH
38285: LD_INT 3
38287: EQUAL
38288: IFFALSE 38323
// begin SetTag ( mech [ j ] , 9 ) ;
38290: LD_VAR 0 15
38294: PUSH
38295: LD_VAR 0 5
38299: ARRAY
38300: PPUSH
38301: LD_INT 9
38303: PPUSH
38304: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38308: LD_VAR 0 15
38312: PUSH
38313: LD_VAR 0 5
38317: ARRAY
38318: PPUSH
38319: CALL_OW 122
// end ;
38323: GO 38266
38325: POP
38326: POP
// if mech < 6 + k then
38327: LD_VAR 0 15
38331: PUSH
38332: LD_INT 6
38334: PUSH
38335: LD_VAR 0 8
38339: PLUS
38340: LESS
38341: IFFALSE 38357
// MCH_TrainMechanic ( side , k ) ;
38343: LD_VAR 0 1
38347: PPUSH
38348: LD_VAR 0 8
38352: PPUSH
38353: CALL 15622 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38357: LD_VAR 0 1
38361: PPUSH
38362: LD_INT 9
38364: PPUSH
38365: EMPTY
38366: PPUSH
38367: CALL 12124 0 3
38371: IFFALSE 38462
// for j in MCF_Tag ( side , 9 , [ ] ) do
38373: LD_ADDR_VAR 0 5
38377: PUSH
38378: LD_VAR 0 1
38382: PPUSH
38383: LD_INT 9
38385: PPUSH
38386: EMPTY
38387: PPUSH
38388: CALL 12124 0 3
38392: PUSH
38393: FOR_IN
38394: IFFALSE 38460
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38396: LD_VAR 0 5
38400: PPUSH
38401: CALL_OW 310
38405: NOT
38406: PUSH
38407: LD_VAR 0 5
38411: PPUSH
38412: CALL 31602 0 1
38416: NOT
38417: AND
38418: IFFALSE 38458
// if ct then
38420: LD_VAR 0 10
38424: IFFALSE 38446
// ComEnterUnit ( j , ct [ 1 ] ) else
38426: LD_VAR 0 5
38430: PPUSH
38431: LD_VAR 0 10
38435: PUSH
38436: LD_INT 1
38438: ARRAY
38439: PPUSH
38440: CALL_OW 120
38444: GO 38458
// SetTag ( j , 0 ) ;
38446: LD_VAR 0 5
38450: PPUSH
38451: LD_INT 0
38453: PPUSH
38454: CALL_OW 109
38458: GO 38393
38460: POP
38461: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38462: LD_INT 1
38464: PPUSH
38465: LD_VAR 0 1
38469: PPUSH
38470: CALL_OW 321
38474: PUSH
38475: LD_INT 2
38477: EQUAL
38478: PUSH
38479: LD_EXP 36
38483: PUSH
38484: LD_VAR 0 1
38488: ARRAY
38489: NOT
38490: AND
38491: PUSH
38492: LD_VAR 0 1
38496: PPUSH
38497: LD_INT 4
38499: PPUSH
38500: EMPTY
38501: PPUSH
38502: CALL 11504 0 3
38506: AND
38507: IFFALSE 38555
// for j in MCF_Class ( side , 4 , [ ] ) do
38509: LD_ADDR_VAR 0 5
38513: PUSH
38514: LD_VAR 0 1
38518: PPUSH
38519: LD_INT 4
38521: PPUSH
38522: EMPTY
38523: PPUSH
38524: CALL 11504 0 3
38528: PUSH
38529: FOR_IN
38530: IFFALSE 38553
// MCN_Tame ( GetSide ( j ) , j ) ;
38532: LD_VAR 0 5
38536: PPUSH
38537: CALL_OW 255
38541: PPUSH
38542: LD_VAR 0 5
38546: PPUSH
38547: CALL 18323 0 2
38551: GO 38529
38553: POP
38554: POP
// if MREG_DefVeh [ side ] then
38555: LD_EXP 68
38559: PUSH
38560: LD_VAR 0 1
38564: ARRAY
38565: IFFALSE 38729
// begin for i in MREG_DefVeh [ side ] do
38567: LD_ADDR_VAR 0 4
38571: PUSH
38572: LD_EXP 68
38576: PUSH
38577: LD_VAR 0 1
38581: ARRAY
38582: PUSH
38583: FOR_IN
38584: IFFALSE 38637
// begin SetTag ( i , 0 ) ;
38586: LD_VAR 0 4
38590: PPUSH
38591: LD_INT 0
38593: PPUSH
38594: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38598: LD_VAR 0 4
38602: PPUSH
38603: LD_EXP 65
38607: PUSH
38608: LD_VAR 0 1
38612: ARRAY
38613: PPUSH
38614: CALL_OW 308
38618: NOT
38619: IFFALSE 38635
// MCV_Parking ( side , i ) ;
38621: LD_VAR 0 1
38625: PPUSH
38626: LD_VAR 0 4
38630: PPUSH
38631: CALL 25582 0 2
// end ;
38635: GO 38583
38637: POP
38638: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38639: LD_VAR 0 1
38643: PPUSH
38644: LD_INT 36
38646: PPUSH
38647: EMPTY
38648: PPUSH
38649: CALL 12124 0 3
38653: IFFALSE 38694
// for i in MCF_Tag ( side , 36 , [ ] ) do
38655: LD_ADDR_VAR 0 4
38659: PUSH
38660: LD_VAR 0 1
38664: PPUSH
38665: LD_INT 36
38667: PPUSH
38668: EMPTY
38669: PPUSH
38670: CALL 12124 0 3
38674: PUSH
38675: FOR_IN
38676: IFFALSE 38692
// SetTag ( i , 0 ) ;
38678: LD_VAR 0 4
38682: PPUSH
38683: LD_INT 0
38685: PPUSH
38686: CALL_OW 109
38690: GO 38675
38692: POP
38693: POP
// if MREG_DefMobActive [ side ] then
38694: LD_EXP 71
38698: PUSH
38699: LD_VAR 0 1
38703: ARRAY
38704: IFFALSE 38729
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38706: LD_ADDR_EXP 71
38710: PUSH
38711: LD_EXP 71
38715: PPUSH
38716: LD_VAR 0 1
38720: PPUSH
38721: LD_INT 0
38723: PPUSH
38724: CALL_OW 1
38728: ST_TO_ADDR
// end ; end ; if mode > 0 then
38729: LD_VAR 0 2
38733: PUSH
38734: LD_INT 0
38736: GREATER
38737: IFFALSE 40752
// begin if tick <= 15 15$00 then
38739: LD_OWVAR 1
38743: PUSH
38744: LD_INT 31500
38746: LESSEQUAL
38747: IFFALSE 39171
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38749: LD_VAR 0 13
38753: PUSH
38754: LD_INT 4
38756: GREATER
38757: PUSH
38758: LD_VAR 0 1
38762: PPUSH
38763: CALL 24822 0 1
38767: PUSH
38768: LD_INT 4
38770: LESS
38771: AND
38772: IFFALSE 38883
// for i in sol do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 13
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38881
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38787: LD_ADDR_VAR 0 8
38791: PUSH
38792: LD_VAR 0 1
38796: PPUSH
38797: CALL 24822 0 1
38801: PPUSH
38802: LD_VAR 0 4
38806: PPUSH
38807: CALL_OW 74
38811: ST_TO_ADDR
// if IsInUnit ( i ) then
38812: LD_VAR 0 4
38816: PPUSH
38817: CALL_OW 310
38821: IFFALSE 38832
// ComExitBuilding ( i ) ;
38823: LD_VAR 0 4
38827: PPUSH
38828: CALL_OW 122
// if not HasTask ( i ) and k then
38832: LD_VAR 0 4
38836: PPUSH
38837: CALL_OW 314
38841: NOT
38842: PUSH
38843: LD_VAR 0 8
38847: AND
38848: IFFALSE 38879
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38850: LD_VAR 0 4
38854: PPUSH
38855: LD_VAR 0 8
38859: PPUSH
38860: CALL_OW 250
38864: PPUSH
38865: LD_VAR 0 8
38869: PPUSH
38870: CALL_OW 251
38874: PPUSH
38875: CALL_OW 114
// end ;
38879: GO 38784
38881: POP
38882: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38883: LD_VAR 0 1
38887: PPUSH
38888: LD_INT 30
38890: PUSH
38891: LD_INT 5
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PPUSH
38898: CALL 11421 0 2
38902: IFFALSE 39169
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38904: LD_ADDR_VAR 0 11
38908: PUSH
38909: LD_VAR 0 1
38913: PPUSH
38914: LD_INT 30
38916: PUSH
38917: LD_INT 5
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PPUSH
38924: CALL 11421 0 2
38928: PUSH
38929: LD_INT 1
38931: ARRAY
38932: ST_TO_ADDR
// if mech then
38933: LD_VAR 0 15
38937: IFFALSE 38973
// for i in mech do
38939: LD_ADDR_VAR 0 4
38943: PUSH
38944: LD_VAR 0 15
38948: PUSH
38949: FOR_IN
38950: IFFALSE 38971
// MCH_ChangeClass ( side , i , 1 ) ;
38952: LD_VAR 0 1
38956: PPUSH
38957: LD_VAR 0 4
38961: PPUSH
38962: LD_INT 1
38964: PPUSH
38965: CALL 16328 0 3
38969: GO 38949
38971: POP
38972: POP
// if eng > 1 then
38973: LD_VAR 0 14
38977: PUSH
38978: LD_INT 1
38980: GREATER
38981: IFFALSE 39028
// for i = eng downto 2 do
38983: LD_ADDR_VAR 0 4
38987: PUSH
38988: DOUBLE
38989: LD_VAR 0 14
38993: INC
38994: ST_TO_ADDR
38995: LD_INT 2
38997: PUSH
38998: FOR_DOWNTO
38999: IFFALSE 39026
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39001: LD_VAR 0 1
39005: PPUSH
39006: LD_VAR 0 14
39010: PUSH
39011: LD_VAR 0 4
39015: ARRAY
39016: PPUSH
39017: LD_INT 1
39019: PPUSH
39020: CALL 16328 0 3
39024: GO 38998
39026: POP
39027: POP
// if UnitsInside ( b ) = 6 then
39028: LD_VAR 0 11
39032: PPUSH
39033: CALL_OW 313
39037: PUSH
39038: LD_INT 6
39040: EQUAL
39041: IFFALSE 39169
// begin un := UnitsInside ( b ) [ 1 ] ;
39043: LD_ADDR_VAR 0 9
39047: PUSH
39048: LD_VAR 0 11
39052: PPUSH
39053: CALL_OW 313
39057: PUSH
39058: LD_INT 1
39060: ARRAY
39061: ST_TO_ADDR
// ComExitBuilding ( un ) ;
39062: LD_VAR 0 9
39066: PPUSH
39067: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
39071: LD_VAR 0 1
39075: PPUSH
39076: LD_INT 30
39078: PUSH
39079: LD_INT 5
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PPUSH
39086: CALL 11421 0 2
39090: PUSH
39091: LD_INT 1
39093: GREATER
39094: PUSH
39095: LD_VAR 0 1
39099: PPUSH
39100: CALL 24822 0 1
39104: PUSH
39105: LD_INT 4
39107: GREATEREQUAL
39108: AND
39109: IFFALSE 39169
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39111: LD_ADDR_VAR 0 8
39115: PUSH
39116: LD_VAR 0 1
39120: PPUSH
39121: LD_INT 30
39123: PUSH
39124: LD_INT 5
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: PPUSH
39131: CALL 11421 0 2
39135: PUSH
39136: LD_INT 2
39138: ARRAY
39139: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39140: LD_VAR 0 8
39144: PPUSH
39145: CALL_OW 313
39149: PUSH
39150: LD_INT 6
39152: LESS
39153: IFFALSE 39169
// AddComEnterUnit ( un , k ) ;
39155: LD_VAR 0 9
39159: PPUSH
39160: LD_VAR 0 8
39164: PPUSH
39165: CALL_OW 180
// end ; end ; end ; end else
39169: GO 40752
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39171: LD_VAR 0 1
39175: PPUSH
39176: LD_INT 1
39178: PPUSH
39179: LD_EXP 66
39183: PUSH
39184: LD_VAR 0 1
39188: ARRAY
39189: PUSH
39190: LD_INT 1
39192: ARRAY
39193: PPUSH
39194: CALL 33904 0 3
39198: IFFALSE 39337
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39200: LD_ADDR_VAR 0 12
39204: PUSH
39205: LD_VAR 0 1
39209: PPUSH
39210: LD_INT 21
39212: PUSH
39213: LD_INT 1
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PPUSH
39220: CALL 11421 0 2
39224: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39225: LD_ADDR_VAR 0 11
39229: PUSH
39230: LD_VAR 0 1
39234: PPUSH
39235: LD_INT 30
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PPUSH
39245: CALL 11421 0 2
39249: ST_TO_ADDR
// if b then
39250: LD_VAR 0 11
39254: IFFALSE 39337
// for i in tmp do
39256: LD_ADDR_VAR 0 4
39260: PUSH
39261: LD_VAR 0 12
39265: PUSH
39266: FOR_IN
39267: IFFALSE 39335
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39269: LD_VAR 0 4
39273: PPUSH
39274: LD_EXP 66
39278: PUSH
39279: LD_VAR 0 1
39283: ARRAY
39284: PUSH
39285: LD_INT 1
39287: ARRAY
39288: PPUSH
39289: CALL_OW 308
39293: NOT
39294: IFFALSE 39333
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39296: LD_VAR 0 4
39300: PPUSH
39301: LD_VAR 0 11
39305: PUSH
39306: LD_INT 1
39308: ARRAY
39309: PPUSH
39310: CALL_OW 250
39314: PPUSH
39315: LD_VAR 0 11
39319: PUSH
39320: LD_INT 1
39322: ARRAY
39323: PPUSH
39324: CALL_OW 251
39328: PPUSH
39329: CALL_OW 111
39333: GO 39266
39335: POP
39336: POP
// end ; if MREG_DefVeh [ side ] then
39337: LD_EXP 68
39341: PUSH
39342: LD_VAR 0 1
39346: ARRAY
39347: IFFALSE 39915
// begin tmp := [ ] ;
39349: LD_ADDR_VAR 0 12
39353: PUSH
39354: EMPTY
39355: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39356: LD_EXP 71
39360: PUSH
39361: LD_VAR 0 1
39365: ARRAY
39366: PUSH
39367: LD_INT 0
39369: EQUAL
39370: IFFALSE 39510
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39372: LD_ADDR_VAR 0 8
39376: PUSH
39377: LD_VAR 0 1
39381: PPUSH
39382: LD_INT 0
39384: PPUSH
39385: LD_INT 25
39387: PUSH
39388: LD_INT 3
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PPUSH
39395: CALL 12124 0 3
39399: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39400: LD_VAR 0 8
39404: PUSH
39405: LD_EXP 68
39409: PUSH
39410: LD_VAR 0 1
39414: ARRAY
39415: GREATER
39416: IFFALSE 39477
// begin for i = 1 to MREG_DefVeh [ side ] do
39418: LD_ADDR_VAR 0 4
39422: PUSH
39423: DOUBLE
39424: LD_INT 1
39426: DEC
39427: ST_TO_ADDR
39428: LD_EXP 68
39432: PUSH
39433: LD_VAR 0 1
39437: ARRAY
39438: PUSH
39439: FOR_TO
39440: IFFALSE 39473
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39442: LD_ADDR_VAR 0 12
39446: PUSH
39447: LD_VAR 0 12
39451: PPUSH
39452: LD_INT 1
39454: PPUSH
39455: LD_VAR 0 8
39459: PUSH
39460: LD_VAR 0 4
39464: ARRAY
39465: PPUSH
39466: CALL_OW 2
39470: ST_TO_ADDR
39471: GO 39439
39473: POP
39474: POP
// end else
39475: GO 39487
// tmp := k ;
39477: LD_ADDR_VAR 0 12
39481: PUSH
39482: LD_VAR 0 8
39486: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39487: LD_ADDR_EXP 71
39491: PUSH
39492: LD_EXP 71
39496: PPUSH
39497: LD_VAR 0 1
39501: PPUSH
39502: LD_INT 1
39504: PPUSH
39505: CALL_OW 1
39509: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39510: LD_ADDR_VAR 0 4
39514: PUSH
39515: LD_EXP 68
39519: PUSH
39520: LD_VAR 0 1
39524: ARRAY
39525: PUSH
39526: FOR_IN
39527: IFFALSE 39913
// begin if not GetDriver ( i ) then
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL 31653 0 1
39538: NOT
39539: IFFALSE 39614
// begin if tmp then
39541: LD_VAR 0 12
39545: IFFALSE 39612
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39547: LD_VAR 0 12
39551: PUSH
39552: LD_INT 1
39554: ARRAY
39555: PPUSH
39556: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39560: LD_VAR 0 12
39564: PUSH
39565: LD_INT 1
39567: ARRAY
39568: PPUSH
39569: LD_VAR 0 4
39573: PPUSH
39574: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39578: LD_VAR 0 12
39582: PUSH
39583: LD_INT 1
39585: ARRAY
39586: PPUSH
39587: LD_INT 36
39589: PPUSH
39590: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39594: LD_ADDR_VAR 0 12
39598: PUSH
39599: LD_VAR 0 12
39603: PPUSH
39604: LD_INT 1
39606: PPUSH
39607: CALL_OW 3
39611: ST_TO_ADDR
// end ; end else
39612: GO 39911
// begin if GetTag ( i ) = 0 then
39614: LD_VAR 0 4
39618: PPUSH
39619: CALL_OW 110
39623: PUSH
39624: LD_INT 0
39626: EQUAL
39627: IFFALSE 39643
// SetTag ( i , 31 ) else
39629: LD_VAR 0 4
39633: PPUSH
39634: LD_INT 31
39636: PPUSH
39637: CALL_OW 109
39641: GO 39911
// if GetTag ( i ) = 31 then
39643: LD_VAR 0 4
39647: PPUSH
39648: CALL_OW 110
39652: PUSH
39653: LD_INT 31
39655: EQUAL
39656: IFFALSE 39911
// begin if GetFuel ( i ) < 20 then
39658: LD_VAR 0 4
39662: PPUSH
39663: CALL_OW 261
39667: PUSH
39668: LD_INT 20
39670: LESS
39671: IFFALSE 39696
// begin SetTag ( i , 21 ) ;
39673: LD_VAR 0 4
39677: PPUSH
39678: LD_INT 21
39680: PPUSH
39681: CALL_OW 109
// MCV_Refuel ( i ) ;
39685: LD_VAR 0 4
39689: PPUSH
39690: CALL 26119 0 1
// continue ;
39694: GO 39526
// end ; if GetLives ( i ) < 700 then
39696: LD_VAR 0 4
39700: PPUSH
39701: CALL_OW 256
39705: PUSH
39706: LD_INT 700
39708: LESS
39709: IFFALSE 39821
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39711: LD_VAR 0 4
39715: PPUSH
39716: LD_EXP 59
39720: PUSH
39721: LD_VAR 0 1
39725: ARRAY
39726: PPUSH
39727: CALL_OW 308
39731: NOT
39732: IFFALSE 39756
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39734: LD_VAR 0 4
39738: PPUSH
39739: LD_EXP 59
39743: PUSH
39744: LD_VAR 0 1
39748: ARRAY
39749: PPUSH
39750: CALL_OW 113
39754: GO 39819
// if GetDriver ( i ) then
39756: LD_VAR 0 4
39760: PPUSH
39761: CALL 31653 0 1
39765: IFFALSE 39819
// begin k := GetDriver ( i ) ;
39767: LD_ADDR_VAR 0 8
39771: PUSH
39772: LD_VAR 0 4
39776: PPUSH
39777: CALL 31653 0 1
39781: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39782: LD_VAR 0 8
39786: PPUSH
39787: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39791: LD_VAR 0 8
39795: PPUSH
39796: LD_VAR 0 4
39800: PPUSH
39801: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39805: LD_VAR 0 8
39809: PPUSH
39810: LD_VAR 0 4
39814: PPUSH
39815: CALL_OW 180
// end ; end else
39819: GO 39911
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39821: LD_ADDR_VAR 0 8
39825: PUSH
39826: LD_VAR 0 1
39830: PPUSH
39831: CALL 24822 0 1
39835: PPUSH
39836: LD_VAR 0 4
39840: PPUSH
39841: CALL_OW 74
39845: ST_TO_ADDR
// if k then
39846: LD_VAR 0 8
39850: IFFALSE 39868
// ComAttackUnit ( i , k ) else
39852: LD_VAR 0 4
39856: PPUSH
39857: LD_VAR 0 8
39861: PPUSH
39862: CALL_OW 115
39866: GO 39911
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39868: LD_VAR 0 4
39872: PPUSH
39873: LD_EXP 59
39877: PUSH
39878: LD_VAR 0 1
39882: ARRAY
39883: PPUSH
39884: CALL_OW 308
39888: NOT
39889: IFFALSE 39911
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39891: LD_VAR 0 4
39895: PPUSH
39896: LD_EXP 59
39900: PUSH
39901: LD_VAR 0 1
39905: ARRAY
39906: PPUSH
39907: CALL_OW 113
// end ; end ; end ; end ;
39911: GO 39526
39913: POP
39914: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39915: LD_VAR 0 1
39919: PPUSH
39920: LD_INT 30
39922: PUSH
39923: LD_INT 5
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL 11421 0 2
39934: IFFALSE 40752
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39936: LD_ADDR_VAR 0 11
39940: PUSH
39941: LD_VAR 0 1
39945: PPUSH
39946: LD_INT 30
39948: PUSH
39949: LD_INT 5
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PPUSH
39956: CALL 11421 0 2
39960: PUSH
39961: LD_INT 1
39963: ARRAY
39964: ST_TO_ADDR
// if eng > 1 then
39965: LD_VAR 0 14
39969: PUSH
39970: LD_INT 1
39972: GREATER
39973: IFFALSE 40020
// for i = eng downto 2 do
39975: LD_ADDR_VAR 0 4
39979: PUSH
39980: DOUBLE
39981: LD_VAR 0 14
39985: INC
39986: ST_TO_ADDR
39987: LD_INT 2
39989: PUSH
39990: FOR_DOWNTO
39991: IFFALSE 40018
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39993: LD_VAR 0 1
39997: PPUSH
39998: LD_VAR 0 14
40002: PUSH
40003: LD_VAR 0 4
40007: ARRAY
40008: PPUSH
40009: LD_INT 1
40011: PPUSH
40012: CALL 16328 0 3
40016: GO 39990
40018: POP
40019: POP
// if sci > 1 then
40020: LD_VAR 0 16
40024: PUSH
40025: LD_INT 1
40027: GREATER
40028: IFFALSE 40075
// for i = sci downto 2 do
40030: LD_ADDR_VAR 0 4
40034: PUSH
40035: DOUBLE
40036: LD_VAR 0 16
40040: INC
40041: ST_TO_ADDR
40042: LD_INT 2
40044: PUSH
40045: FOR_DOWNTO
40046: IFFALSE 40073
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
40048: LD_VAR 0 1
40052: PPUSH
40053: LD_VAR 0 16
40057: PUSH
40058: LD_VAR 0 4
40062: ARRAY
40063: PPUSH
40064: LD_INT 1
40066: PPUSH
40067: CALL 16328 0 3
40071: GO 40045
40073: POP
40074: POP
// if sol then
40075: LD_VAR 0 13
40079: IFFALSE 40752
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
40081: LD_VAR 0 13
40085: PUSH
40086: LD_EXP 69
40090: PUSH
40091: LD_VAR 0 1
40095: ARRAY
40096: DIFF
40097: PUSH
40098: LD_INT 22
40100: PUSH
40101: LD_VAR 0 1
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 58
40112: PUSH
40113: EMPTY
40114: LIST
40115: PUSH
40116: LD_INT 2
40118: PUSH
40119: LD_INT 30
40121: PUSH
40122: LD_INT 32
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 30
40131: PUSH
40132: LD_INT 31
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: LIST
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: LIST
40148: PPUSH
40149: CALL_OW 69
40153: PUSH
40154: LD_INT 0
40156: EQUAL
40157: AND
40158: IFFALSE 40752
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40160: LD_ADDR_VAR 0 12
40164: PUSH
40165: LD_VAR 0 13
40169: PUSH
40170: LD_EXP 69
40174: PUSH
40175: LD_VAR 0 1
40179: ARRAY
40180: DIFF
40181: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40182: LD_VAR 0 1
40186: PPUSH
40187: LD_INT 30
40189: PUSH
40190: LD_INT 5
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PPUSH
40197: CALL 11421 0 2
40201: PUSH
40202: LD_INT 1
40204: GREATER
40205: IFFALSE 40236
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40207: LD_ADDR_VAR 0 8
40211: PUSH
40212: LD_VAR 0 1
40216: PPUSH
40217: LD_INT 30
40219: PUSH
40220: LD_INT 5
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PPUSH
40227: CALL 11421 0 2
40231: PUSH
40232: LD_INT 2
40234: ARRAY
40235: ST_TO_ADDR
// for j in tmp do
40236: LD_ADDR_VAR 0 5
40240: PUSH
40241: LD_VAR 0 12
40245: PUSH
40246: FOR_IN
40247: IFFALSE 40750
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40249: LD_VAR 0 5
40253: PUSH
40254: LD_VAR 0 11
40258: PPUSH
40259: CALL_OW 313
40263: IN
40264: PUSH
40265: LD_VAR 0 11
40269: PPUSH
40270: CALL_OW 313
40274: PUSH
40275: LD_INT 6
40277: EQUAL
40278: AND
40279: PUSH
40280: LD_VAR 0 8
40284: AND
40285: PUSH
40286: LD_VAR 0 8
40290: PPUSH
40291: CALL_OW 313
40295: PUSH
40296: LD_INT 6
40298: LESS
40299: AND
40300: IFFALSE 40327
// begin ComExitBuilding ( j ) ;
40302: LD_VAR 0 5
40306: PPUSH
40307: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40311: LD_VAR 0 5
40315: PPUSH
40316: LD_VAR 0 8
40320: PPUSH
40321: CALL_OW 180
// continue ;
40325: GO 40246
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40327: LD_VAR 0 5
40331: PPUSH
40332: CALL_OW 314
40336: NOT
40337: PUSH
40338: LD_VAR 0 5
40342: PPUSH
40343: CALL_OW 110
40347: PUSH
40348: LD_INT 0
40350: EQUAL
40351: AND
40352: PUSH
40353: LD_VAR 0 5
40357: PPUSH
40358: CALL_OW 310
40362: NOT
40363: AND
40364: IFFALSE 40470
// begin if k then
40366: LD_VAR 0 8
40370: IFFALSE 40441
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40372: LD_VAR 0 8
40376: PPUSH
40377: CALL_OW 313
40381: PUSH
40382: LD_VAR 0 11
40386: PPUSH
40387: CALL_OW 313
40391: LESS
40392: IFFALSE 40410
// ComEnterUnit ( j , k ) else
40394: LD_VAR 0 5
40398: PPUSH
40399: LD_VAR 0 8
40403: PPUSH
40404: CALL_OW 120
40408: GO 40439
// if UnitsInside ( b ) < 6 then
40410: LD_VAR 0 11
40414: PPUSH
40415: CALL_OW 313
40419: PUSH
40420: LD_INT 6
40422: LESS
40423: IFFALSE 40439
// ComEnterUnit ( j , b ) ;
40425: LD_VAR 0 5
40429: PPUSH
40430: LD_VAR 0 11
40434: PPUSH
40435: CALL_OW 120
// end else
40439: GO 40470
// if UnitsInside ( b ) < 6 then
40441: LD_VAR 0 11
40445: PPUSH
40446: CALL_OW 313
40450: PUSH
40451: LD_INT 6
40453: LESS
40454: IFFALSE 40470
// ComEnterUnit ( j , b ) ;
40456: LD_VAR 0 5
40460: PPUSH
40461: LD_VAR 0 11
40465: PPUSH
40466: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40470: LD_VAR 0 5
40474: PUSH
40475: LD_VAR 0 1
40479: PPUSH
40480: LD_INT 54
40482: PUSH
40483: EMPTY
40484: LIST
40485: PPUSH
40486: CALL 11421 0 2
40490: IN
40491: PUSH
40492: LD_VAR 0 5
40496: PPUSH
40497: CALL_OW 257
40501: PUSH
40502: LD_INT 1
40504: EQUAL
40505: AND
40506: IFFALSE 40748
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40508: LD_EXP 63
40512: PUSH
40513: LD_VAR 0 1
40517: ARRAY
40518: PUSH
40519: LD_INT 1
40521: ARRAY
40522: PUSH
40523: LD_INT 12
40525: PPUSH
40526: LD_VAR 0 1
40530: PPUSH
40531: CALL_OW 321
40535: PUSH
40536: LD_INT 2
40538: EQUAL
40539: AND
40540: IFFALSE 40588
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40542: LD_VAR 0 1
40546: PPUSH
40547: LD_INT 5
40549: PPUSH
40550: EMPTY
40551: PPUSH
40552: CALL 11504 0 3
40556: PUSH
40557: LD_EXP 63
40561: PUSH
40562: LD_VAR 0 1
40566: ARRAY
40567: PUSH
40568: LD_INT 1
40570: ARRAY
40571: LESS
40572: IFFALSE 40588
// begin SetClass ( j , class_sniper ) ;
40574: LD_VAR 0 5
40578: PPUSH
40579: LD_INT 5
40581: PPUSH
40582: CALL_OW 336
// continue ;
40586: GO 40246
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40588: LD_EXP 63
40592: PUSH
40593: LD_VAR 0 1
40597: ARRAY
40598: PUSH
40599: LD_INT 2
40601: ARRAY
40602: PUSH
40603: LD_INT 41
40605: PPUSH
40606: LD_VAR 0 1
40610: PPUSH
40611: CALL_OW 321
40615: PUSH
40616: LD_INT 2
40618: EQUAL
40619: AND
40620: IFFALSE 40668
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40622: LD_VAR 0 1
40626: PPUSH
40627: LD_INT 8
40629: PPUSH
40630: EMPTY
40631: PPUSH
40632: CALL 11504 0 3
40636: PUSH
40637: LD_EXP 63
40641: PUSH
40642: LD_VAR 0 1
40646: ARRAY
40647: PUSH
40648: LD_INT 2
40650: ARRAY
40651: LESS
40652: IFFALSE 40668
// begin SetClass ( j , class_mortar ) ;
40654: LD_VAR 0 5
40658: PPUSH
40659: LD_INT 8
40661: PPUSH
40662: CALL_OW 336
// continue ;
40666: GO 40246
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40668: LD_EXP 63
40672: PUSH
40673: LD_VAR 0 1
40677: ARRAY
40678: PUSH
40679: LD_INT 3
40681: ARRAY
40682: PUSH
40683: LD_INT 44
40685: PPUSH
40686: LD_VAR 0 1
40690: PPUSH
40691: CALL_OW 321
40695: PUSH
40696: LD_INT 2
40698: EQUAL
40699: AND
40700: IFFALSE 40748
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40702: LD_VAR 0 1
40706: PPUSH
40707: LD_INT 9
40709: PPUSH
40710: EMPTY
40711: PPUSH
40712: CALL 11504 0 3
40716: PUSH
40717: LD_EXP 63
40721: PUSH
40722: LD_VAR 0 1
40726: ARRAY
40727: PUSH
40728: LD_INT 3
40730: ARRAY
40731: LESS
40732: IFFALSE 40748
// begin SetClass ( j , class_bazooker ) ;
40734: LD_VAR 0 5
40738: PPUSH
40739: LD_INT 9
40741: PPUSH
40742: CALL_OW 336
// continue ;
40746: GO 40246
// end ; end ; end ;
40748: GO 40246
40750: POP
40751: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40752: LD_INT 22
40754: PUSH
40755: LD_VAR 0 1
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 58
40766: PUSH
40767: EMPTY
40768: LIST
40769: PUSH
40770: LD_INT 30
40772: PUSH
40773: LD_INT 32
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: PPUSH
40785: CALL_OW 69
40789: IFFALSE 40939
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40791: LD_ADDR_VAR 0 12
40795: PUSH
40796: LD_INT 22
40798: PUSH
40799: LD_VAR 0 1
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 58
40810: PUSH
40811: EMPTY
40812: LIST
40813: PUSH
40814: LD_INT 30
40816: PUSH
40817: LD_INT 32
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: LIST
40828: PPUSH
40829: CALL_OW 69
40833: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40834: LD_ADDR_VAR 0 8
40838: PUSH
40839: LD_VAR 0 13
40843: PUSH
40844: LD_EXP 69
40848: PUSH
40849: LD_VAR 0 1
40853: ARRAY
40854: DIFF
40855: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40856: LD_VAR 0 12
40860: PUSH
40861: LD_INT 1
40863: ARRAY
40864: PPUSH
40865: CALL_OW 461
40869: PUSH
40870: LD_INT 2
40872: EQUAL
40873: PUSH
40874: LD_VAR 0 12
40878: PUSH
40879: LD_INT 1
40881: ARRAY
40882: PUSH
40883: LD_EXP 69
40887: PUSH
40888: LD_VAR 0 1
40892: ARRAY
40893: IN
40894: NOT
40895: AND
40896: PUSH
40897: LD_VAR 0 8
40901: AND
40902: IFFALSE 40939
// begin ComExitBuilding ( k [ 1 ] ) ;
40904: LD_VAR 0 8
40908: PUSH
40909: LD_INT 1
40911: ARRAY
40912: PPUSH
40913: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40917: LD_VAR 0 8
40921: PUSH
40922: LD_INT 1
40924: ARRAY
40925: PPUSH
40926: LD_VAR 0 12
40930: PUSH
40931: LD_INT 1
40933: ARRAY
40934: PPUSH
40935: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40939: LD_EXP 36
40943: PUSH
40944: LD_VAR 0 1
40948: ARRAY
40949: IFFALSE 41097
// begin if MCF_Class ( side , 4 , [ ] ) then
40951: LD_VAR 0 1
40955: PPUSH
40956: LD_INT 4
40958: PPUSH
40959: EMPTY
40960: PPUSH
40961: CALL 11504 0 3
40965: IFFALSE 41095
// for j in MCF_Class ( side , 4 , [ ] ) do
40967: LD_ADDR_VAR 0 5
40971: PUSH
40972: LD_VAR 0 1
40976: PPUSH
40977: LD_INT 4
40979: PPUSH
40980: EMPTY
40981: PPUSH
40982: CALL 11504 0 3
40986: PUSH
40987: FOR_IN
40988: IFFALSE 41093
// begin if not GetTag ( j ) = 4 then
40990: LD_VAR 0 5
40994: PPUSH
40995: CALL_OW 110
40999: PUSH
41000: LD_INT 4
41002: EQUAL
41003: NOT
41004: IFFALSE 41040
// begin SetTag ( j , 4 ) ;
41006: LD_VAR 0 5
41010: PPUSH
41011: LD_INT 4
41013: PPUSH
41014: CALL_OW 109
// if IsInUnit ( j ) then
41018: LD_VAR 0 5
41022: PPUSH
41023: CALL_OW 310
41027: IFFALSE 41038
// ComExitBuilding ( j ) ;
41029: LD_VAR 0 5
41033: PPUSH
41034: CALL_OW 122
// end else
41038: GO 41091
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
41040: LD_VAR 0 5
41044: PPUSH
41045: LD_EXP 36
41049: PUSH
41050: LD_VAR 0 1
41054: ARRAY
41055: PUSH
41056: LD_INT 1
41058: ARRAY
41059: PPUSH
41060: CALL 32344 0 2
41064: NOT
41065: IFFALSE 41091
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
41067: LD_VAR 0 5
41071: PPUSH
41072: LD_EXP 36
41076: PUSH
41077: LD_VAR 0 1
41081: ARRAY
41082: PUSH
41083: LD_INT 1
41085: ARRAY
41086: PPUSH
41087: CALL 18991 0 2
// end ;
41091: GO 40987
41093: POP
41094: POP
// end else
41095: GO 41329
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
41097: LD_VAR 0 1
41101: PPUSH
41102: LD_INT 4
41104: PPUSH
41105: EMPTY
41106: PPUSH
41107: CALL 11504 0 3
41111: PUSH
41112: LD_VAR 0 1
41116: PPUSH
41117: LD_INT 4
41119: PPUSH
41120: EMPTY
41121: PPUSH
41122: CALL 12124 0 3
41126: AND
41127: IFFALSE 41329
// for j in MCF_Class ( side , 4 , [ ] ) do
41129: LD_ADDR_VAR 0 5
41133: PUSH
41134: LD_VAR 0 1
41138: PPUSH
41139: LD_INT 4
41141: PPUSH
41142: EMPTY
41143: PPUSH
41144: CALL 11504 0 3
41148: PUSH
41149: FOR_IN
41150: IFFALSE 41327
// begin if GetTag ( j ) = 4 then
41152: LD_VAR 0 5
41156: PPUSH
41157: CALL_OW 110
41161: PUSH
41162: LD_INT 4
41164: EQUAL
41165: IFFALSE 41325
// begin SetTag ( j , 0 ) ;
41167: LD_VAR 0 5
41171: PPUSH
41172: LD_INT 0
41174: PPUSH
41175: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41179: LD_VAR 0 1
41183: PPUSH
41184: CALL 11460 0 1
41188: PUSH
41189: LD_VAR 0 1
41193: PPUSH
41194: CALL 17804 0 1
41198: NOT
41199: AND
41200: IFFALSE 41225
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41202: LD_VAR 0 5
41206: PPUSH
41207: LD_VAR 0 1
41211: PPUSH
41212: CALL 11460 0 1
41216: PUSH
41217: LD_INT 1
41219: ARRAY
41220: PPUSH
41221: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41225: LD_VAR 0 1
41229: PPUSH
41230: CALL 11460 0 1
41234: NOT
41235: PUSH
41236: LD_VAR 0 1
41240: PPUSH
41241: LD_INT 30
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PPUSH
41251: CALL 11421 0 2
41255: AND
41256: IFFALSE 41325
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41258: LD_VAR 0 5
41262: PPUSH
41263: LD_VAR 0 1
41267: PPUSH
41268: LD_INT 30
41270: PUSH
41271: LD_INT 1
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PPUSH
41278: CALL 11421 0 2
41282: PUSH
41283: LD_INT 1
41285: ARRAY
41286: PPUSH
41287: CALL_OW 250
41291: PPUSH
41292: LD_VAR 0 1
41296: PPUSH
41297: LD_INT 30
41299: PUSH
41300: LD_INT 1
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL 11421 0 2
41311: PUSH
41312: LD_INT 1
41314: ARRAY
41315: PPUSH
41316: CALL_OW 251
41320: PPUSH
41321: CALL_OW 111
// end ; end ;
41325: GO 41149
41327: POP
41328: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41329: LD_VAR 0 1
41333: PPUSH
41334: LD_INT 3
41336: PPUSH
41337: EMPTY
41338: PPUSH
41339: CALL 11504 0 3
41343: PUSH
41344: LD_EXP 59
41348: PUSH
41349: LD_VAR 0 1
41353: ARRAY
41354: AND
41355: PUSH
41356: LD_VAR 0 1
41360: PPUSH
41361: LD_INT 6
41363: PPUSH
41364: EMPTY
41365: PPUSH
41366: CALL 12124 0 3
41370: AND
41371: IFFALSE 41902
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41373: LD_ADDR_VAR 0 6
41377: PUSH
41378: LD_EXP 59
41382: PUSH
41383: LD_VAR 0 1
41387: ARRAY
41388: PPUSH
41389: LD_INT 0
41391: PPUSH
41392: CALL_OW 517
41396: PUSH
41397: LD_INT 1
41399: ARRAY
41400: PUSH
41401: LD_INT 1
41403: ARRAY
41404: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41405: LD_ADDR_VAR 0 7
41409: PUSH
41410: LD_EXP 59
41414: PUSH
41415: LD_VAR 0 1
41419: ARRAY
41420: PPUSH
41421: LD_INT 0
41423: PPUSH
41424: CALL_OW 517
41428: PUSH
41429: LD_INT 2
41431: ARRAY
41432: PUSH
41433: LD_INT 1
41435: ARRAY
41436: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41437: LD_VAR 0 1
41441: PPUSH
41442: LD_INT 6
41444: PPUSH
41445: EMPTY
41446: PPUSH
41447: CALL 12124 0 3
41451: IFFALSE 41900
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41453: LD_ADDR_VAR 0 8
41457: PUSH
41458: LD_VAR 0 1
41462: PPUSH
41463: LD_INT 6
41465: PPUSH
41466: EMPTY
41467: PPUSH
41468: CALL 12124 0 3
41472: PUSH
41473: FOR_IN
41474: IFFALSE 41505
// if GetLives ( k ) = 1000 then
41476: LD_VAR 0 8
41480: PPUSH
41481: CALL_OW 256
41485: PUSH
41486: LD_INT 1000
41488: EQUAL
41489: IFFALSE 41503
// SetTag ( k , 0 ) ;
41491: LD_VAR 0 8
41495: PPUSH
41496: LD_INT 0
41498: PPUSH
41499: CALL_OW 109
41503: GO 41473
41505: POP
41506: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41507: LD_VAR 0 1
41511: PPUSH
41512: LD_INT 0
41514: PPUSH
41515: LD_INT 25
41517: PUSH
41518: LD_INT 3
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PPUSH
41525: CALL 12124 0 3
41529: IFFALSE 41593
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41531: LD_ADDR_VAR 0 8
41535: PUSH
41536: LD_VAR 0 4
41540: PPUSH
41541: LD_INT 0
41543: PPUSH
41544: LD_INT 25
41546: PUSH
41547: LD_INT 3
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PPUSH
41554: CALL 12124 0 3
41558: PUSH
41559: FOR_IN
41560: IFFALSE 41591
// if GetTag ( k ) = 0 then
41562: LD_VAR 0 8
41566: PPUSH
41567: CALL_OW 110
41571: PUSH
41572: LD_INT 0
41574: EQUAL
41575: IFFALSE 41589
// begin SetTag ( k , 8 ) ;
41577: LD_VAR 0 8
41581: PPUSH
41582: LD_INT 8
41584: PPUSH
41585: CALL_OW 109
// end ;
41589: GO 41559
41591: POP
41592: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41593: LD_VAR 0 1
41597: PPUSH
41598: LD_INT 6
41600: PPUSH
41601: LD_INT 92
41603: PUSH
41604: LD_VAR 0 6
41608: PUSH
41609: LD_VAR 0 7
41613: PUSH
41614: LD_INT 10
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: PPUSH
41623: CALL 12124 0 3
41627: IFFALSE 41751
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41629: LD_ADDR_VAR 0 5
41633: PUSH
41634: LD_VAR 0 4
41638: PPUSH
41639: LD_INT 6
41641: PPUSH
41642: LD_INT 92
41644: PUSH
41645: LD_VAR 0 6
41649: PUSH
41650: LD_VAR 0 7
41654: PUSH
41655: LD_INT 10
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: LIST
41662: LIST
41663: PPUSH
41664: CALL 12124 0 3
41668: PUSH
41669: FOR_IN
41670: IFFALSE 41749
// begin if not HasTask ( j ) and GetDriver ( j ) then
41672: LD_VAR 0 5
41676: PPUSH
41677: CALL_OW 314
41681: NOT
41682: PUSH
41683: LD_VAR 0 5
41687: PPUSH
41688: CALL 31653 0 1
41692: AND
41693: IFFALSE 41747
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41695: LD_VAR 0 5
41699: PPUSH
41700: CALL 31653 0 1
41704: PPUSH
41705: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41709: LD_VAR 0 5
41713: PPUSH
41714: CALL 31653 0 1
41718: PPUSH
41719: LD_VAR 0 5
41723: PPUSH
41724: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41728: LD_VAR 0 5
41732: PPUSH
41733: CALL 31653 0 1
41737: PPUSH
41738: LD_VAR 0 5
41742: PPUSH
41743: CALL_OW 180
// end ; end ;
41747: GO 41669
41749: POP
41750: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41751: LD_VAR 0 1
41755: PPUSH
41756: LD_INT 6
41758: PPUSH
41759: LD_INT 92
41761: PUSH
41762: LD_VAR 0 6
41766: PUSH
41767: LD_VAR 0 7
41771: PUSH
41772: LD_INT 10
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: PPUSH
41781: CALL 12124 0 3
41785: PUSH
41786: LD_VAR 0 1
41790: PPUSH
41791: LD_INT 8
41793: PPUSH
41794: EMPTY
41795: PPUSH
41796: CALL 12124 0 3
41800: AND
41801: IFFALSE 41900
// for j in MCF_Tag ( side , 8 , [ ] ) do
41803: LD_ADDR_VAR 0 5
41807: PUSH
41808: LD_VAR 0 1
41812: PPUSH
41813: LD_INT 8
41815: PPUSH
41816: EMPTY
41817: PPUSH
41818: CALL 12124 0 3
41822: PUSH
41823: FOR_IN
41824: IFFALSE 41898
// begin if IsInUnit ( j ) then
41826: LD_VAR 0 5
41830: PPUSH
41831: CALL_OW 310
41835: IFFALSE 41848
// ComExitBuilding ( j ) else
41837: LD_VAR 0 5
41841: PPUSH
41842: CALL_OW 122
41846: GO 41896
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41848: LD_VAR 0 5
41852: PPUSH
41853: LD_VAR 0 1
41857: PPUSH
41858: LD_INT 6
41860: PPUSH
41861: LD_INT 92
41863: PUSH
41864: LD_VAR 0 6
41868: PUSH
41869: LD_VAR 0 7
41873: PUSH
41874: LD_INT 10
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: LIST
41881: LIST
41882: PPUSH
41883: CALL 12124 0 3
41887: PUSH
41888: LD_INT 1
41890: ARRAY
41891: PPUSH
41892: CALL_OW 129
// end ;
41896: GO 41823
41898: POP
41899: POP
// end ; end else
41900: GO 41957
// if MCF_Tag ( side , 8 , [ ] ) then
41902: LD_VAR 0 1
41906: PPUSH
41907: LD_INT 8
41909: PPUSH
41910: EMPTY
41911: PPUSH
41912: CALL 12124 0 3
41916: IFFALSE 41957
// for k in MCF_Tag ( side , 8 , [ ] ) do
41918: LD_ADDR_VAR 0 8
41922: PUSH
41923: LD_VAR 0 1
41927: PPUSH
41928: LD_INT 8
41930: PPUSH
41931: EMPTY
41932: PPUSH
41933: CALL 12124 0 3
41937: PUSH
41938: FOR_IN
41939: IFFALSE 41955
// SetTag ( k , 0 ) ;
41941: LD_VAR 0 8
41945: PPUSH
41946: LD_INT 0
41948: PPUSH
41949: CALL_OW 109
41953: GO 41938
41955: POP
41956: POP
// end ; end_of_file
41957: LD_VAR 0 3
41961: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41962: LD_INT 0
41964: PPUSH
// MREG_Game := [ ] ;
41965: LD_ADDR_EXP 34
41969: PUSH
41970: EMPTY
41971: ST_TO_ADDR
// MREG_Crates := [ ] ;
41972: LD_ADDR_EXP 35
41976: PUSH
41977: EMPTY
41978: ST_TO_ADDR
// MREG_Heal := [ ] ;
41979: LD_ADDR_EXP 36
41983: PUSH
41984: EMPTY
41985: ST_TO_ADDR
// MREG_Tame := [ ] ;
41986: LD_ADDR_EXP 38
41990: PUSH
41991: EMPTY
41992: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41993: LD_ADDR_EXP 39
41997: PUSH
41998: EMPTY
41999: ST_TO_ADDR
// MREG_SidesList := [ ] ;
42000: LD_ADDR_EXP 40
42004: PUSH
42005: EMPTY
42006: ST_TO_ADDR
// MREG_LabList := [ ] ;
42007: LD_ADDR_EXP 41
42011: PUSH
42012: EMPTY
42013: ST_TO_ADDR
// MREG_Cargo := [ ] ;
42014: LD_ADDR_EXP 42
42018: PUSH
42019: EMPTY
42020: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
42021: LD_ADDR_EXP 43
42025: PUSH
42026: EMPTY
42027: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
42028: LD_ADDR_EXP 44
42032: PUSH
42033: EMPTY
42034: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
42035: LD_ADDR_EXP 45
42039: PUSH
42040: EMPTY
42041: ST_TO_ADDR
// MREG_Status := [ ] ;
42042: LD_ADDR_EXP 46
42046: PUSH
42047: EMPTY
42048: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
42049: LD_ADDR_EXP 47
42053: PUSH
42054: EMPTY
42055: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
42056: LD_ADDR_EXP 48
42060: PUSH
42061: EMPTY
42062: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
42063: LD_ADDR_EXP 49
42067: PUSH
42068: EMPTY
42069: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
42070: LD_ADDR_EXP 50
42074: PUSH
42075: EMPTY
42076: ST_TO_ADDR
// MREG_ToRes := [ ] ;
42077: LD_ADDR_EXP 51
42081: PUSH
42082: EMPTY
42083: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
42084: LD_ADDR_EXP 52
42088: PUSH
42089: EMPTY
42090: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
42091: LD_ADDR_EXP 53
42095: PUSH
42096: EMPTY
42097: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42098: LD_ADDR_EXP 54
42102: PUSH
42103: EMPTY
42104: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42105: LD_ADDR_EXP 55
42109: PUSH
42110: EMPTY
42111: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42112: LD_ADDR_EXP 56
42116: PUSH
42117: EMPTY
42118: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42119: LD_ADDR_EXP 57
42123: PUSH
42124: EMPTY
42125: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42126: LD_ADDR_EXP 58
42130: PUSH
42131: EMPTY
42132: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42133: LD_ADDR_EXP 62
42137: PUSH
42138: EMPTY
42139: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42140: LD_ADDR_EXP 63
42144: PUSH
42145: EMPTY
42146: ST_TO_ADDR
// MREG_Parking := [ ] ;
42147: LD_ADDR_EXP 59
42151: PUSH
42152: EMPTY
42153: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42154: LD_ADDR_EXP 60
42158: PUSH
42159: EMPTY
42160: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42161: LD_ADDR_EXP 64
42165: PUSH
42166: EMPTY
42167: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42168: LD_ADDR_EXP 65
42172: PUSH
42173: EMPTY
42174: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42175: LD_ADDR_EXP 66
42179: PUSH
42180: EMPTY
42181: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42182: LD_ADDR_EXP 68
42186: PUSH
42187: EMPTY
42188: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42189: LD_ADDR_EXP 69
42193: PUSH
42194: EMPTY
42195: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42196: LD_ADDR_EXP 70
42200: PUSH
42201: EMPTY
42202: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42203: LD_ADDR_EXP 72
42207: PUSH
42208: EMPTY
42209: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42210: LD_ADDR_EXP 71
42214: PUSH
42215: EMPTY
42216: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42217: LD_ADDR_EXP 73
42221: PUSH
42222: LD_INT 300
42224: PUSH
42225: LD_INT 100
42227: PUSH
42228: LD_INT 25
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: ST_TO_ADDR
// end ;
42236: LD_VAR 0 1
42240: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42241: LD_INT 0
42243: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42244: LD_VAR 0 2
42248: PUSH
42249: LD_VAR 0 3
42253: PUSH
42254: LD_VAR 0 4
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: LIST
42263: PUSH
42264: LD_VAR 0 1
42268: IN
42269: IFFALSE 42283
// result := mreg_list else
42271: LD_ADDR_VAR 0 5
42275: PUSH
42276: LD_VAR 0 1
42280: ST_TO_ADDR
42281: GO 42317
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42283: LD_ADDR_VAR 0 1
42287: PUSH
42288: LD_VAR 0 1
42292: PUSH
42293: LD_VAR 0 2
42297: PUSH
42298: LD_VAR 0 3
42302: PUSH
42303: LD_VAR 0 4
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: LIST
42312: PUSH
42313: EMPTY
42314: LIST
42315: ADD
42316: ST_TO_ADDR
// result := mreg_list ;
42317: LD_ADDR_VAR 0 5
42321: PUSH
42322: LD_VAR 0 1
42326: ST_TO_ADDR
// end ;
42327: LD_VAR 0 5
42331: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42332: LD_INT 0
42334: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42335: LD_VAR 0 2
42339: PUSH
42340: LD_VAR 0 3
42344: PUSH
42345: LD_VAR 0 4
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: LIST
42354: PUSH
42355: LD_VAR 0 1
42359: IN
42360: IFFALSE 42398
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42362: LD_ADDR_VAR 0 5
42366: PUSH
42367: LD_VAR 0 1
42371: PUSH
42372: LD_VAR 0 2
42376: PUSH
42377: LD_VAR 0 3
42381: PUSH
42382: LD_VAR 0 4
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: LIST
42391: PUSH
42392: EMPTY
42393: LIST
42394: DIFF
42395: ST_TO_ADDR
42396: GO 42408
// result := mreg_list ;
42398: LD_ADDR_VAR 0 5
42402: PUSH
42403: LD_VAR 0 1
42407: ST_TO_ADDR
// end ;
42408: LD_VAR 0 5
42412: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42413: LD_INT 0
42415: PPUSH
42416: PPUSH
42417: PPUSH
// for j = 1 to 8 do
42418: LD_ADDR_VAR 0 3
42422: PUSH
42423: DOUBLE
42424: LD_INT 1
42426: DEC
42427: ST_TO_ADDR
42428: LD_INT 8
42430: PUSH
42431: FOR_TO
42432: IFFALSE 43273
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42434: LD_VAR 0 3
42438: PPUSH
42439: LD_INT 51
42441: PUSH
42442: EMPTY
42443: LIST
42444: PPUSH
42445: CALL 11421 0 2
42449: PUSH
42450: LD_OWVAR 2
42454: PUSH
42455: LD_VAR 0 3
42459: EQUAL
42460: NOT
42461: AND
42462: IFFALSE 42480
// MREG_SidesList := MREG_SidesList ^ 1 else
42464: LD_ADDR_EXP 40
42468: PUSH
42469: LD_EXP 40
42473: PUSH
42474: LD_INT 1
42476: ADD
42477: ST_TO_ADDR
42478: GO 42494
// MREG_SidesList := MREG_SidesList ^ 0 ;
42480: LD_ADDR_EXP 40
42484: PUSH
42485: LD_EXP 40
42489: PUSH
42490: LD_INT 0
42492: ADD
42493: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42494: LD_VAR 0 3
42498: PPUSH
42499: LD_INT 2
42501: PUSH
42502: LD_INT 34
42504: PUSH
42505: LD_INT 12
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 34
42514: PUSH
42515: LD_INT 32
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 34
42524: PUSH
42525: LD_INT 51
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: PUSH
42538: EMPTY
42539: LIST
42540: PPUSH
42541: CALL 11722 0 2
42545: IFFALSE 42646
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42547: LD_ADDR_VAR 0 2
42551: PUSH
42552: LD_VAR 0 3
42556: PPUSH
42557: LD_INT 2
42559: PUSH
42560: LD_INT 34
42562: PUSH
42563: LD_INT 12
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 34
42572: PUSH
42573: LD_INT 32
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 34
42582: PUSH
42583: LD_INT 51
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: LIST
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PPUSH
42599: CALL 11722 0 2
42603: PUSH
42604: FOR_IN
42605: IFFALSE 42644
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42607: LD_ADDR_EXP 42
42611: PUSH
42612: LD_EXP 42
42616: PPUSH
42617: LD_VAR 0 3
42621: PPUSH
42622: LD_VAR 0 2
42626: PPUSH
42627: LD_VAR 0 2
42631: PPUSH
42632: CALL_OW 264
42636: PPUSH
42637: CALL 42241 0 4
42641: ST_TO_ADDR
42642: GO 42604
42644: POP
42645: POP
// if MCF_Class ( j , 4 , [ ] ) then
42646: LD_VAR 0 3
42650: PPUSH
42651: LD_INT 4
42653: PPUSH
42654: EMPTY
42655: PPUSH
42656: CALL 11504 0 3
42660: IFFALSE 42693
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42662: LD_ADDR_EXP 55
42666: PUSH
42667: LD_EXP 55
42671: PUSH
42672: LD_VAR 0 3
42676: PPUSH
42677: LD_INT 4
42679: PPUSH
42680: EMPTY
42681: PPUSH
42682: CALL 11504 0 3
42686: PUSH
42687: EMPTY
42688: LIST
42689: ADD
42690: ST_TO_ADDR
42691: GO 42710
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42693: LD_ADDR_EXP 55
42697: PUSH
42698: LD_EXP 55
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: ADD
42709: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42710: LD_VAR 0 3
42714: PPUSH
42715: LD_INT 3
42717: PPUSH
42718: EMPTY
42719: PPUSH
42720: CALL 11504 0 3
42724: IFFALSE 42757
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42726: LD_ADDR_EXP 56
42730: PUSH
42731: LD_EXP 56
42735: PUSH
42736: LD_VAR 0 3
42740: PPUSH
42741: LD_INT 3
42743: PPUSH
42744: EMPTY
42745: PPUSH
42746: CALL 11504 0 3
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
42755: GO 42774
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42757: LD_ADDR_EXP 56
42761: PUSH
42762: LD_EXP 56
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: LIST
42772: ADD
42773: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42774: LD_VAR 0 3
42778: PPUSH
42779: LD_INT 1
42781: PPUSH
42782: EMPTY
42783: PPUSH
42784: CALL 11504 0 3
42788: IFFALSE 42821
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42790: LD_ADDR_EXP 57
42794: PUSH
42795: LD_EXP 57
42799: PUSH
42800: LD_VAR 0 3
42804: PPUSH
42805: LD_INT 1
42807: PPUSH
42808: EMPTY
42809: PPUSH
42810: CALL 11504 0 3
42814: PUSH
42815: EMPTY
42816: LIST
42817: ADD
42818: ST_TO_ADDR
42819: GO 42838
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42821: LD_ADDR_EXP 57
42825: PUSH
42826: LD_EXP 57
42830: PUSH
42831: LD_INT 0
42833: PUSH
42834: EMPTY
42835: LIST
42836: ADD
42837: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42838: LD_VAR 0 3
42842: PPUSH
42843: LD_INT 2
42845: PPUSH
42846: EMPTY
42847: PPUSH
42848: CALL 11504 0 3
42852: IFFALSE 42885
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42854: LD_ADDR_EXP 58
42858: PUSH
42859: LD_EXP 58
42863: PUSH
42864: LD_VAR 0 3
42868: PPUSH
42869: LD_INT 2
42871: PPUSH
42872: EMPTY
42873: PPUSH
42874: CALL 11504 0 3
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
42883: GO 42902
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42885: LD_ADDR_EXP 58
42889: PUSH
42890: LD_EXP 58
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: ADD
42901: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42902: LD_ADDR_EXP 48
42906: PUSH
42907: LD_EXP 48
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: EMPTY
42916: LIST
42917: ADD
42918: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42919: LD_ADDR_EXP 36
42923: PUSH
42924: LD_EXP 36
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: ADD
42935: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42936: LD_ADDR_EXP 38
42940: PUSH
42941: LD_EXP 38
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: EMPTY
42950: LIST
42951: ADD
42952: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42953: LD_ADDR_EXP 59
42957: PUSH
42958: LD_EXP 59
42962: PUSH
42963: LD_INT 0
42965: PUSH
42966: EMPTY
42967: LIST
42968: ADD
42969: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42970: LD_ADDR_EXP 60
42974: PUSH
42975: LD_EXP 60
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: EMPTY
42984: LIST
42985: ADD
42986: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42987: LD_ADDR_EXP 52
42991: PUSH
42992: LD_EXP 52
42996: PUSH
42997: LD_INT 0
42999: PUSH
43000: EMPTY
43001: LIST
43002: ADD
43003: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
43004: LD_ADDR_EXP 39
43008: PUSH
43009: LD_EXP 39
43013: PUSH
43014: LD_INT 0
43016: PUSH
43017: LD_INT 0
43019: PUSH
43020: LD_INT 0
43022: PUSH
43023: LD_INT 0
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: PUSH
43032: EMPTY
43033: LIST
43034: ADD
43035: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
43036: LD_ADDR_EXP 61
43040: PUSH
43041: LD_EXP 61
43045: PUSH
43046: LD_INT 0
43048: PUSH
43049: EMPTY
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: EMPTY
43056: LIST
43057: ADD
43058: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
43059: LD_ADDR_EXP 62
43063: PUSH
43064: LD_EXP 62
43068: PUSH
43069: LD_INT 0
43071: PUSH
43072: EMPTY
43073: LIST
43074: PUSH
43075: EMPTY
43076: LIST
43077: ADD
43078: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
43079: LD_ADDR_EXP 43
43083: PUSH
43084: LD_EXP 43
43088: PUSH
43089: LD_INT 0
43091: PUSH
43092: EMPTY
43093: LIST
43094: ADD
43095: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
43096: LD_ADDR_EXP 64
43100: PUSH
43101: LD_EXP 64
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: EMPTY
43110: LIST
43111: ADD
43112: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43113: LD_ADDR_EXP 65
43117: PUSH
43118: LD_EXP 65
43122: PUSH
43123: LD_INT 0
43125: PUSH
43126: EMPTY
43127: LIST
43128: ADD
43129: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43130: LD_ADDR_EXP 66
43134: PUSH
43135: LD_EXP 66
43139: PUSH
43140: LD_INT 0
43142: PUSH
43143: EMPTY
43144: LIST
43145: ADD
43146: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43147: LD_ADDR_EXP 67
43151: PUSH
43152: LD_EXP 67
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: EMPTY
43161: LIST
43162: ADD
43163: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43164: LD_ADDR_EXP 68
43168: PUSH
43169: LD_EXP 68
43173: PUSH
43174: LD_INT 0
43176: PUSH
43177: EMPTY
43178: LIST
43179: ADD
43180: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43181: LD_ADDR_EXP 69
43185: PUSH
43186: LD_EXP 69
43190: PUSH
43191: LD_INT 0
43193: PUSH
43194: EMPTY
43195: LIST
43196: ADD
43197: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43198: LD_ADDR_EXP 70
43202: PUSH
43203: LD_EXP 70
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: EMPTY
43212: LIST
43213: ADD
43214: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43215: LD_ADDR_EXP 72
43219: PUSH
43220: LD_EXP 72
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: ADD
43231: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43232: LD_ADDR_EXP 71
43236: PUSH
43237: LD_EXP 71
43241: PUSH
43242: LD_INT 0
43244: ADD
43245: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43246: LD_ADDR_EXP 63
43250: PUSH
43251: LD_EXP 63
43255: PUSH
43256: LD_INT 0
43258: PUSH
43259: LD_INT 0
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: LIST
43269: ADD
43270: ST_TO_ADDR
// end ;
43271: GO 42431
43273: POP
43274: POP
// end ;
43275: LD_VAR 0 1
43279: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43280: LD_INT 0
43282: PPUSH
43283: PPUSH
43284: PPUSH
// m := false ;
43285: LD_ADDR_VAR 0 5
43289: PUSH
43290: LD_INT 0
43292: ST_TO_ADDR
// for i = 1 to mreg do
43293: LD_ADDR_VAR 0 4
43297: PUSH
43298: DOUBLE
43299: LD_INT 1
43301: DEC
43302: ST_TO_ADDR
43303: LD_VAR 0 2
43307: PUSH
43308: FOR_TO
43309: IFFALSE 43345
// if mreg [ i ] [ 1 ] = side then
43311: LD_VAR 0 2
43315: PUSH
43316: LD_VAR 0 4
43320: ARRAY
43321: PUSH
43322: LD_INT 1
43324: ARRAY
43325: PUSH
43326: LD_VAR 0 1
43330: EQUAL
43331: IFFALSE 43343
// begin m := true ;
43333: LD_ADDR_VAR 0 5
43337: PUSH
43338: LD_INT 1
43340: ST_TO_ADDR
// break ;
43341: GO 43345
// end ;
43343: GO 43308
43345: POP
43346: POP
// result := m ;
43347: LD_ADDR_VAR 0 3
43351: PUSH
43352: LD_VAR 0 5
43356: ST_TO_ADDR
// end ;
43357: LD_VAR 0 3
43361: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43362: LD_INT 0
43364: PPUSH
43365: PPUSH
43366: PPUSH
// m := 0 ;
43367: LD_ADDR_VAR 0 5
43371: PUSH
43372: LD_INT 0
43374: ST_TO_ADDR
// for i = 1 to mreg do
43375: LD_ADDR_VAR 0 4
43379: PUSH
43380: DOUBLE
43381: LD_INT 1
43383: DEC
43384: ST_TO_ADDR
43385: LD_VAR 0 2
43389: PUSH
43390: FOR_TO
43391: IFFALSE 43431
// if mreg [ i ] [ 1 ] = side then
43393: LD_VAR 0 2
43397: PUSH
43398: LD_VAR 0 4
43402: ARRAY
43403: PUSH
43404: LD_INT 1
43406: ARRAY
43407: PUSH
43408: LD_VAR 0 1
43412: EQUAL
43413: IFFALSE 43429
// begin m := m + 1 ;
43415: LD_ADDR_VAR 0 5
43419: PUSH
43420: LD_VAR 0 5
43424: PUSH
43425: LD_INT 1
43427: PLUS
43428: ST_TO_ADDR
// end ;
43429: GO 43390
43431: POP
43432: POP
// result := m ;
43433: LD_ADDR_VAR 0 3
43437: PUSH
43438: LD_VAR 0 5
43442: ST_TO_ADDR
// end ;
43443: LD_VAR 0 3
43447: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43448: LD_INT 0
43450: PPUSH
43451: PPUSH
// result := 0 ;
43452: LD_ADDR_VAR 0 3
43456: PUSH
43457: LD_INT 0
43459: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43460: LD_ADDR_VAR 0 4
43464: PUSH
43465: DOUBLE
43466: LD_INT 1
43468: DEC
43469: ST_TO_ADDR
43470: LD_EXP 54
43474: PUSH
43475: FOR_TO
43476: IFFALSE 43538
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43478: LD_EXP 54
43482: PUSH
43483: LD_VAR 0 4
43487: ARRAY
43488: PUSH
43489: LD_INT 1
43491: ARRAY
43492: PUSH
43493: LD_VAR 0 1
43497: EQUAL
43498: PUSH
43499: LD_EXP 54
43503: PUSH
43504: LD_VAR 0 4
43508: ARRAY
43509: PUSH
43510: LD_INT 2
43512: ARRAY
43513: PUSH
43514: LD_VAR 0 2
43518: EQUAL
43519: AND
43520: IFFALSE 43536
// begin result := result + 1 ;
43522: LD_ADDR_VAR 0 3
43526: PUSH
43527: LD_VAR 0 3
43531: PUSH
43532: LD_INT 1
43534: PLUS
43535: ST_TO_ADDR
// end ;
43536: GO 43475
43538: POP
43539: POP
// end ; end_of_file
43540: LD_VAR 0 3
43544: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
43545: GO 43547
43547: DISABLE
// begin ru_radar := 98 ;
43548: LD_ADDR_EXP 74
43552: PUSH
43553: LD_INT 98
43555: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43556: LD_ADDR_EXP 75
43560: PUSH
43561: LD_INT 89
43563: ST_TO_ADDR
// us_hack := 99 ;
43564: LD_ADDR_EXP 76
43568: PUSH
43569: LD_INT 99
43571: ST_TO_ADDR
// us_artillery := 97 ;
43572: LD_ADDR_EXP 77
43576: PUSH
43577: LD_INT 97
43579: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43580: LD_ADDR_EXP 78
43584: PUSH
43585: LD_INT 91
43587: ST_TO_ADDR
// tech_Artillery := 80 ;
43588: LD_ADDR_EXP 79
43592: PUSH
43593: LD_INT 80
43595: ST_TO_ADDR
// tech_RadMat := 81 ;
43596: LD_ADDR_EXP 80
43600: PUSH
43601: LD_INT 81
43603: ST_TO_ADDR
// tech_BasicTools := 82 ;
43604: LD_ADDR_EXP 81
43608: PUSH
43609: LD_INT 82
43611: ST_TO_ADDR
// tech_Cargo := 83 ;
43612: LD_ADDR_EXP 82
43616: PUSH
43617: LD_INT 83
43619: ST_TO_ADDR
// tech_Track := 84 ;
43620: LD_ADDR_EXP 83
43624: PUSH
43625: LD_INT 84
43627: ST_TO_ADDR
// tech_Crane := 85 ;
43628: LD_ADDR_EXP 84
43632: PUSH
43633: LD_INT 85
43635: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43636: LD_ADDR_EXP 85
43640: PUSH
43641: LD_INT 86
43643: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43644: LD_ADDR_EXP 86
43648: PUSH
43649: LD_INT 87
43651: ST_TO_ADDR
// end ; end_of_file end_of_file
43652: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
43653: GO 43655
43655: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
43656: LD_STRING initStreamRollete();
43658: PPUSH
43659: CALL_OW 559
// InitStreamMode ;
43663: CALL 43672 0 0
// DefineStreamItems ( ) ;
43667: CALL 44112 0 0
// end ;
43671: END
// function InitStreamMode ; begin
43672: LD_INT 0
43674: PPUSH
// streamModeActive := false ;
43675: LD_ADDR_EXP 87
43679: PUSH
43680: LD_INT 0
43682: ST_TO_ADDR
// normalCounter := 36 ;
43683: LD_ADDR_EXP 88
43687: PUSH
43688: LD_INT 36
43690: ST_TO_ADDR
// hardcoreCounter := 16 ;
43691: LD_ADDR_EXP 89
43695: PUSH
43696: LD_INT 16
43698: ST_TO_ADDR
// sRocket := false ;
43699: LD_ADDR_EXP 92
43703: PUSH
43704: LD_INT 0
43706: ST_TO_ADDR
// sSpeed := false ;
43707: LD_ADDR_EXP 91
43711: PUSH
43712: LD_INT 0
43714: ST_TO_ADDR
// sEngine := false ;
43715: LD_ADDR_EXP 93
43719: PUSH
43720: LD_INT 0
43722: ST_TO_ADDR
// sSpec := false ;
43723: LD_ADDR_EXP 90
43727: PUSH
43728: LD_INT 0
43730: ST_TO_ADDR
// sLevel := false ;
43731: LD_ADDR_EXP 94
43735: PUSH
43736: LD_INT 0
43738: ST_TO_ADDR
// sArmoury := false ;
43739: LD_ADDR_EXP 95
43743: PUSH
43744: LD_INT 0
43746: ST_TO_ADDR
// sRadar := false ;
43747: LD_ADDR_EXP 96
43751: PUSH
43752: LD_INT 0
43754: ST_TO_ADDR
// sBunker := false ;
43755: LD_ADDR_EXP 97
43759: PUSH
43760: LD_INT 0
43762: ST_TO_ADDR
// sHack := false ;
43763: LD_ADDR_EXP 98
43767: PUSH
43768: LD_INT 0
43770: ST_TO_ADDR
// sFire := false ;
43771: LD_ADDR_EXP 99
43775: PUSH
43776: LD_INT 0
43778: ST_TO_ADDR
// sRefresh := false ;
43779: LD_ADDR_EXP 100
43783: PUSH
43784: LD_INT 0
43786: ST_TO_ADDR
// sExp := false ;
43787: LD_ADDR_EXP 101
43791: PUSH
43792: LD_INT 0
43794: ST_TO_ADDR
// sDepot := false ;
43795: LD_ADDR_EXP 102
43799: PUSH
43800: LD_INT 0
43802: ST_TO_ADDR
// sFlag := false ;
43803: LD_ADDR_EXP 103
43807: PUSH
43808: LD_INT 0
43810: ST_TO_ADDR
// sKamikadze := false ;
43811: LD_ADDR_EXP 111
43815: PUSH
43816: LD_INT 0
43818: ST_TO_ADDR
// sTroll := false ;
43819: LD_ADDR_EXP 112
43823: PUSH
43824: LD_INT 0
43826: ST_TO_ADDR
// sSlow := false ;
43827: LD_ADDR_EXP 113
43831: PUSH
43832: LD_INT 0
43834: ST_TO_ADDR
// sLack := false ;
43835: LD_ADDR_EXP 114
43839: PUSH
43840: LD_INT 0
43842: ST_TO_ADDR
// sTank := false ;
43843: LD_ADDR_EXP 116
43847: PUSH
43848: LD_INT 0
43850: ST_TO_ADDR
// sRemote := false ;
43851: LD_ADDR_EXP 117
43855: PUSH
43856: LD_INT 0
43858: ST_TO_ADDR
// sPowell := false ;
43859: LD_ADDR_EXP 118
43863: PUSH
43864: LD_INT 0
43866: ST_TO_ADDR
// sTeleport := false ;
43867: LD_ADDR_EXP 121
43871: PUSH
43872: LD_INT 0
43874: ST_TO_ADDR
// sOilTower := false ;
43875: LD_ADDR_EXP 123
43879: PUSH
43880: LD_INT 0
43882: ST_TO_ADDR
// sShovel := false ;
43883: LD_ADDR_EXP 124
43887: PUSH
43888: LD_INT 0
43890: ST_TO_ADDR
// sSheik := false ;
43891: LD_ADDR_EXP 125
43895: PUSH
43896: LD_INT 0
43898: ST_TO_ADDR
// sEarthquake := false ;
43899: LD_ADDR_EXP 127
43903: PUSH
43904: LD_INT 0
43906: ST_TO_ADDR
// sAI := false ;
43907: LD_ADDR_EXP 128
43911: PUSH
43912: LD_INT 0
43914: ST_TO_ADDR
// sCargo := false ;
43915: LD_ADDR_EXP 131
43919: PUSH
43920: LD_INT 0
43922: ST_TO_ADDR
// sDLaser := false ;
43923: LD_ADDR_EXP 132
43927: PUSH
43928: LD_INT 0
43930: ST_TO_ADDR
// sExchange := false ;
43931: LD_ADDR_EXP 133
43935: PUSH
43936: LD_INT 0
43938: ST_TO_ADDR
// sFac := false ;
43939: LD_ADDR_EXP 134
43943: PUSH
43944: LD_INT 0
43946: ST_TO_ADDR
// sPower := false ;
43947: LD_ADDR_EXP 135
43951: PUSH
43952: LD_INT 0
43954: ST_TO_ADDR
// sRandom := false ;
43955: LD_ADDR_EXP 136
43959: PUSH
43960: LD_INT 0
43962: ST_TO_ADDR
// sShield := false ;
43963: LD_ADDR_EXP 137
43967: PUSH
43968: LD_INT 0
43970: ST_TO_ADDR
// sTime := false ;
43971: LD_ADDR_EXP 138
43975: PUSH
43976: LD_INT 0
43978: ST_TO_ADDR
// sTools := false ;
43979: LD_ADDR_EXP 139
43983: PUSH
43984: LD_INT 0
43986: ST_TO_ADDR
// sSold := false ;
43987: LD_ADDR_EXP 104
43991: PUSH
43992: LD_INT 0
43994: ST_TO_ADDR
// sDiff := false ;
43995: LD_ADDR_EXP 105
43999: PUSH
44000: LD_INT 0
44002: ST_TO_ADDR
// sFog := false ;
44003: LD_ADDR_EXP 108
44007: PUSH
44008: LD_INT 0
44010: ST_TO_ADDR
// sReset := false ;
44011: LD_ADDR_EXP 109
44015: PUSH
44016: LD_INT 0
44018: ST_TO_ADDR
// sSun := false ;
44019: LD_ADDR_EXP 110
44023: PUSH
44024: LD_INT 0
44026: ST_TO_ADDR
// sTiger := false ;
44027: LD_ADDR_EXP 106
44031: PUSH
44032: LD_INT 0
44034: ST_TO_ADDR
// sBomb := false ;
44035: LD_ADDR_EXP 107
44039: PUSH
44040: LD_INT 0
44042: ST_TO_ADDR
// sWound := false ;
44043: LD_ADDR_EXP 115
44047: PUSH
44048: LD_INT 0
44050: ST_TO_ADDR
// sBetray := false ;
44051: LD_ADDR_EXP 119
44055: PUSH
44056: LD_INT 0
44058: ST_TO_ADDR
// sContamin := false ;
44059: LD_ADDR_EXP 120
44063: PUSH
44064: LD_INT 0
44066: ST_TO_ADDR
// sOil := false ;
44067: LD_ADDR_EXP 122
44071: PUSH
44072: LD_INT 0
44074: ST_TO_ADDR
// sStu := false ;
44075: LD_ADDR_EXP 126
44079: PUSH
44080: LD_INT 0
44082: ST_TO_ADDR
// sBazooka := false ;
44083: LD_ADDR_EXP 129
44087: PUSH
44088: LD_INT 0
44090: ST_TO_ADDR
// sMortar := false ;
44091: LD_ADDR_EXP 130
44095: PUSH
44096: LD_INT 0
44098: ST_TO_ADDR
// sRanger := false ;
44099: LD_ADDR_EXP 140
44103: PUSH
44104: LD_INT 0
44106: ST_TO_ADDR
// end ;
44107: LD_VAR 0 1
44111: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44112: LD_INT 0
44114: PPUSH
44115: PPUSH
44116: PPUSH
44117: PPUSH
44118: PPUSH
// result := [ ] ;
44119: LD_ADDR_VAR 0 1
44123: PUSH
44124: EMPTY
44125: ST_TO_ADDR
// if campaign_id = 1 then
44126: LD_OWVAR 69
44130: PUSH
44131: LD_INT 1
44133: EQUAL
44134: IFFALSE 47072
// begin case mission_number of 1 :
44136: LD_OWVAR 70
44140: PUSH
44141: LD_INT 1
44143: DOUBLE
44144: EQUAL
44145: IFTRUE 44149
44147: GO 44213
44149: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44150: LD_ADDR_VAR 0 1
44154: PUSH
44155: LD_INT 2
44157: PUSH
44158: LD_INT 4
44160: PUSH
44161: LD_INT 11
44163: PUSH
44164: LD_INT 12
44166: PUSH
44167: LD_INT 15
44169: PUSH
44170: LD_INT 16
44172: PUSH
44173: LD_INT 22
44175: PUSH
44176: LD_INT 23
44178: PUSH
44179: LD_INT 26
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 101
44195: PUSH
44196: LD_INT 102
44198: PUSH
44199: LD_INT 106
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: LIST
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: ST_TO_ADDR
44211: GO 47070
44213: LD_INT 2
44215: DOUBLE
44216: EQUAL
44217: IFTRUE 44221
44219: GO 44293
44221: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44222: LD_ADDR_VAR 0 1
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: LD_INT 4
44232: PUSH
44233: LD_INT 11
44235: PUSH
44236: LD_INT 12
44238: PUSH
44239: LD_INT 15
44241: PUSH
44242: LD_INT 16
44244: PUSH
44245: LD_INT 22
44247: PUSH
44248: LD_INT 23
44250: PUSH
44251: LD_INT 26
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 101
44267: PUSH
44268: LD_INT 102
44270: PUSH
44271: LD_INT 105
44273: PUSH
44274: LD_INT 106
44276: PUSH
44277: LD_INT 108
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: ST_TO_ADDR
44291: GO 47070
44293: LD_INT 3
44295: DOUBLE
44296: EQUAL
44297: IFTRUE 44301
44299: GO 44377
44301: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
44302: LD_ADDR_VAR 0 1
44306: PUSH
44307: LD_INT 2
44309: PUSH
44310: LD_INT 4
44312: PUSH
44313: LD_INT 5
44315: PUSH
44316: LD_INT 11
44318: PUSH
44319: LD_INT 12
44321: PUSH
44322: LD_INT 15
44324: PUSH
44325: LD_INT 16
44327: PUSH
44328: LD_INT 22
44330: PUSH
44331: LD_INT 26
44333: PUSH
44334: LD_INT 36
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 101
44351: PUSH
44352: LD_INT 102
44354: PUSH
44355: LD_INT 105
44357: PUSH
44358: LD_INT 106
44360: PUSH
44361: LD_INT 108
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: ST_TO_ADDR
44375: GO 47070
44377: LD_INT 4
44379: DOUBLE
44380: EQUAL
44381: IFTRUE 44385
44383: GO 44469
44385: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
44386: LD_ADDR_VAR 0 1
44390: PUSH
44391: LD_INT 2
44393: PUSH
44394: LD_INT 4
44396: PUSH
44397: LD_INT 5
44399: PUSH
44400: LD_INT 8
44402: PUSH
44403: LD_INT 11
44405: PUSH
44406: LD_INT 12
44408: PUSH
44409: LD_INT 15
44411: PUSH
44412: LD_INT 16
44414: PUSH
44415: LD_INT 22
44417: PUSH
44418: LD_INT 23
44420: PUSH
44421: LD_INT 26
44423: PUSH
44424: LD_INT 36
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 101
44443: PUSH
44444: LD_INT 102
44446: PUSH
44447: LD_INT 105
44449: PUSH
44450: LD_INT 106
44452: PUSH
44453: LD_INT 108
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: ST_TO_ADDR
44467: GO 47070
44469: LD_INT 5
44471: DOUBLE
44472: EQUAL
44473: IFTRUE 44477
44475: GO 44577
44477: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
44478: LD_ADDR_VAR 0 1
44482: PUSH
44483: LD_INT 2
44485: PUSH
44486: LD_INT 4
44488: PUSH
44489: LD_INT 5
44491: PUSH
44492: LD_INT 6
44494: PUSH
44495: LD_INT 8
44497: PUSH
44498: LD_INT 11
44500: PUSH
44501: LD_INT 12
44503: PUSH
44504: LD_INT 15
44506: PUSH
44507: LD_INT 16
44509: PUSH
44510: LD_INT 22
44512: PUSH
44513: LD_INT 23
44515: PUSH
44516: LD_INT 25
44518: PUSH
44519: LD_INT 26
44521: PUSH
44522: LD_INT 36
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 101
44543: PUSH
44544: LD_INT 102
44546: PUSH
44547: LD_INT 105
44549: PUSH
44550: LD_INT 106
44552: PUSH
44553: LD_INT 108
44555: PUSH
44556: LD_INT 109
44558: PUSH
44559: LD_INT 112
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: PUSH
44571: EMPTY
44572: LIST
44573: LIST
44574: ST_TO_ADDR
44575: GO 47070
44577: LD_INT 6
44579: DOUBLE
44580: EQUAL
44581: IFTRUE 44585
44583: GO 44705
44585: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
44586: LD_ADDR_VAR 0 1
44590: PUSH
44591: LD_INT 2
44593: PUSH
44594: LD_INT 4
44596: PUSH
44597: LD_INT 5
44599: PUSH
44600: LD_INT 6
44602: PUSH
44603: LD_INT 8
44605: PUSH
44606: LD_INT 11
44608: PUSH
44609: LD_INT 12
44611: PUSH
44612: LD_INT 15
44614: PUSH
44615: LD_INT 16
44617: PUSH
44618: LD_INT 20
44620: PUSH
44621: LD_INT 21
44623: PUSH
44624: LD_INT 22
44626: PUSH
44627: LD_INT 23
44629: PUSH
44630: LD_INT 25
44632: PUSH
44633: LD_INT 26
44635: PUSH
44636: LD_INT 30
44638: PUSH
44639: LD_INT 31
44641: PUSH
44642: LD_INT 32
44644: PUSH
44645: LD_INT 36
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 101
44671: PUSH
44672: LD_INT 102
44674: PUSH
44675: LD_INT 105
44677: PUSH
44678: LD_INT 106
44680: PUSH
44681: LD_INT 108
44683: PUSH
44684: LD_INT 109
44686: PUSH
44687: LD_INT 112
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: ST_TO_ADDR
44703: GO 47070
44705: LD_INT 7
44707: DOUBLE
44708: EQUAL
44709: IFTRUE 44713
44711: GO 44813
44713: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
44714: LD_ADDR_VAR 0 1
44718: PUSH
44719: LD_INT 2
44721: PUSH
44722: LD_INT 4
44724: PUSH
44725: LD_INT 5
44727: PUSH
44728: LD_INT 7
44730: PUSH
44731: LD_INT 11
44733: PUSH
44734: LD_INT 12
44736: PUSH
44737: LD_INT 15
44739: PUSH
44740: LD_INT 16
44742: PUSH
44743: LD_INT 20
44745: PUSH
44746: LD_INT 21
44748: PUSH
44749: LD_INT 22
44751: PUSH
44752: LD_INT 23
44754: PUSH
44755: LD_INT 25
44757: PUSH
44758: LD_INT 26
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 101
44779: PUSH
44780: LD_INT 102
44782: PUSH
44783: LD_INT 103
44785: PUSH
44786: LD_INT 105
44788: PUSH
44789: LD_INT 106
44791: PUSH
44792: LD_INT 108
44794: PUSH
44795: LD_INT 112
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: ST_TO_ADDR
44811: GO 47070
44813: LD_INT 8
44815: DOUBLE
44816: EQUAL
44817: IFTRUE 44821
44819: GO 44949
44821: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
44822: LD_ADDR_VAR 0 1
44826: PUSH
44827: LD_INT 2
44829: PUSH
44830: LD_INT 4
44832: PUSH
44833: LD_INT 5
44835: PUSH
44836: LD_INT 6
44838: PUSH
44839: LD_INT 7
44841: PUSH
44842: LD_INT 8
44844: PUSH
44845: LD_INT 11
44847: PUSH
44848: LD_INT 12
44850: PUSH
44851: LD_INT 15
44853: PUSH
44854: LD_INT 16
44856: PUSH
44857: LD_INT 20
44859: PUSH
44860: LD_INT 21
44862: PUSH
44863: LD_INT 22
44865: PUSH
44866: LD_INT 23
44868: PUSH
44869: LD_INT 25
44871: PUSH
44872: LD_INT 26
44874: PUSH
44875: LD_INT 30
44877: PUSH
44878: LD_INT 31
44880: PUSH
44881: LD_INT 32
44883: PUSH
44884: LD_INT 36
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 101
44911: PUSH
44912: LD_INT 102
44914: PUSH
44915: LD_INT 103
44917: PUSH
44918: LD_INT 105
44920: PUSH
44921: LD_INT 106
44923: PUSH
44924: LD_INT 108
44926: PUSH
44927: LD_INT 109
44929: PUSH
44930: LD_INT 112
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: ST_TO_ADDR
44947: GO 47070
44949: LD_INT 9
44951: DOUBLE
44952: EQUAL
44953: IFTRUE 44957
44955: GO 45093
44957: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
44958: LD_ADDR_VAR 0 1
44962: PUSH
44963: LD_INT 2
44965: PUSH
44966: LD_INT 4
44968: PUSH
44969: LD_INT 5
44971: PUSH
44972: LD_INT 6
44974: PUSH
44975: LD_INT 7
44977: PUSH
44978: LD_INT 8
44980: PUSH
44981: LD_INT 11
44983: PUSH
44984: LD_INT 12
44986: PUSH
44987: LD_INT 15
44989: PUSH
44990: LD_INT 16
44992: PUSH
44993: LD_INT 20
44995: PUSH
44996: LD_INT 21
44998: PUSH
44999: LD_INT 22
45001: PUSH
45002: LD_INT 23
45004: PUSH
45005: LD_INT 25
45007: PUSH
45008: LD_INT 26
45010: PUSH
45011: LD_INT 28
45013: PUSH
45014: LD_INT 30
45016: PUSH
45017: LD_INT 31
45019: PUSH
45020: LD_INT 32
45022: PUSH
45023: LD_INT 36
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: LIST
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: PUSH
45049: LD_INT 101
45051: PUSH
45052: LD_INT 102
45054: PUSH
45055: LD_INT 103
45057: PUSH
45058: LD_INT 105
45060: PUSH
45061: LD_INT 106
45063: PUSH
45064: LD_INT 108
45066: PUSH
45067: LD_INT 109
45069: PUSH
45070: LD_INT 112
45072: PUSH
45073: LD_INT 114
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: ST_TO_ADDR
45091: GO 47070
45093: LD_INT 10
45095: DOUBLE
45096: EQUAL
45097: IFTRUE 45101
45099: GO 45285
45101: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45102: LD_ADDR_VAR 0 1
45106: PUSH
45107: LD_INT 2
45109: PUSH
45110: LD_INT 4
45112: PUSH
45113: LD_INT 5
45115: PUSH
45116: LD_INT 6
45118: PUSH
45119: LD_INT 7
45121: PUSH
45122: LD_INT 8
45124: PUSH
45125: LD_INT 9
45127: PUSH
45128: LD_INT 10
45130: PUSH
45131: LD_INT 11
45133: PUSH
45134: LD_INT 12
45136: PUSH
45137: LD_INT 13
45139: PUSH
45140: LD_INT 14
45142: PUSH
45143: LD_INT 15
45145: PUSH
45146: LD_INT 16
45148: PUSH
45149: LD_INT 17
45151: PUSH
45152: LD_INT 18
45154: PUSH
45155: LD_INT 19
45157: PUSH
45158: LD_INT 20
45160: PUSH
45161: LD_INT 21
45163: PUSH
45164: LD_INT 22
45166: PUSH
45167: LD_INT 23
45169: PUSH
45170: LD_INT 24
45172: PUSH
45173: LD_INT 25
45175: PUSH
45176: LD_INT 26
45178: PUSH
45179: LD_INT 28
45181: PUSH
45182: LD_INT 30
45184: PUSH
45185: LD_INT 31
45187: PUSH
45188: LD_INT 32
45190: PUSH
45191: LD_INT 36
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: PUSH
45225: LD_INT 101
45227: PUSH
45228: LD_INT 102
45230: PUSH
45231: LD_INT 103
45233: PUSH
45234: LD_INT 104
45236: PUSH
45237: LD_INT 105
45239: PUSH
45240: LD_INT 106
45242: PUSH
45243: LD_INT 107
45245: PUSH
45246: LD_INT 108
45248: PUSH
45249: LD_INT 109
45251: PUSH
45252: LD_INT 110
45254: PUSH
45255: LD_INT 111
45257: PUSH
45258: LD_INT 112
45260: PUSH
45261: LD_INT 114
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: ST_TO_ADDR
45283: GO 47070
45285: LD_INT 11
45287: DOUBLE
45288: EQUAL
45289: IFTRUE 45293
45291: GO 45485
45293: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
45294: LD_ADDR_VAR 0 1
45298: PUSH
45299: LD_INT 2
45301: PUSH
45302: LD_INT 3
45304: PUSH
45305: LD_INT 4
45307: PUSH
45308: LD_INT 5
45310: PUSH
45311: LD_INT 6
45313: PUSH
45314: LD_INT 7
45316: PUSH
45317: LD_INT 8
45319: PUSH
45320: LD_INT 9
45322: PUSH
45323: LD_INT 10
45325: PUSH
45326: LD_INT 11
45328: PUSH
45329: LD_INT 12
45331: PUSH
45332: LD_INT 13
45334: PUSH
45335: LD_INT 14
45337: PUSH
45338: LD_INT 15
45340: PUSH
45341: LD_INT 16
45343: PUSH
45344: LD_INT 17
45346: PUSH
45347: LD_INT 18
45349: PUSH
45350: LD_INT 19
45352: PUSH
45353: LD_INT 20
45355: PUSH
45356: LD_INT 21
45358: PUSH
45359: LD_INT 22
45361: PUSH
45362: LD_INT 23
45364: PUSH
45365: LD_INT 24
45367: PUSH
45368: LD_INT 25
45370: PUSH
45371: LD_INT 26
45373: PUSH
45374: LD_INT 28
45376: PUSH
45377: LD_INT 30
45379: PUSH
45380: LD_INT 31
45382: PUSH
45383: LD_INT 32
45385: PUSH
45386: LD_INT 34
45388: PUSH
45389: LD_INT 36
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: LIST
45415: LIST
45416: LIST
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: PUSH
45425: LD_INT 101
45427: PUSH
45428: LD_INT 102
45430: PUSH
45431: LD_INT 103
45433: PUSH
45434: LD_INT 104
45436: PUSH
45437: LD_INT 105
45439: PUSH
45440: LD_INT 106
45442: PUSH
45443: LD_INT 107
45445: PUSH
45446: LD_INT 108
45448: PUSH
45449: LD_INT 109
45451: PUSH
45452: LD_INT 110
45454: PUSH
45455: LD_INT 111
45457: PUSH
45458: LD_INT 112
45460: PUSH
45461: LD_INT 114
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: ST_TO_ADDR
45483: GO 47070
45485: LD_INT 12
45487: DOUBLE
45488: EQUAL
45489: IFTRUE 45493
45491: GO 45701
45493: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
45494: LD_ADDR_VAR 0 1
45498: PUSH
45499: LD_INT 1
45501: PUSH
45502: LD_INT 2
45504: PUSH
45505: LD_INT 3
45507: PUSH
45508: LD_INT 4
45510: PUSH
45511: LD_INT 5
45513: PUSH
45514: LD_INT 6
45516: PUSH
45517: LD_INT 7
45519: PUSH
45520: LD_INT 8
45522: PUSH
45523: LD_INT 9
45525: PUSH
45526: LD_INT 10
45528: PUSH
45529: LD_INT 11
45531: PUSH
45532: LD_INT 12
45534: PUSH
45535: LD_INT 13
45537: PUSH
45538: LD_INT 14
45540: PUSH
45541: LD_INT 15
45543: PUSH
45544: LD_INT 16
45546: PUSH
45547: LD_INT 17
45549: PUSH
45550: LD_INT 18
45552: PUSH
45553: LD_INT 19
45555: PUSH
45556: LD_INT 20
45558: PUSH
45559: LD_INT 21
45561: PUSH
45562: LD_INT 22
45564: PUSH
45565: LD_INT 23
45567: PUSH
45568: LD_INT 24
45570: PUSH
45571: LD_INT 25
45573: PUSH
45574: LD_INT 26
45576: PUSH
45577: LD_INT 27
45579: PUSH
45580: LD_INT 28
45582: PUSH
45583: LD_INT 30
45585: PUSH
45586: LD_INT 31
45588: PUSH
45589: LD_INT 32
45591: PUSH
45592: LD_INT 33
45594: PUSH
45595: LD_INT 34
45597: PUSH
45598: LD_INT 36
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 101
45639: PUSH
45640: LD_INT 102
45642: PUSH
45643: LD_INT 103
45645: PUSH
45646: LD_INT 104
45648: PUSH
45649: LD_INT 105
45651: PUSH
45652: LD_INT 106
45654: PUSH
45655: LD_INT 107
45657: PUSH
45658: LD_INT 108
45660: PUSH
45661: LD_INT 109
45663: PUSH
45664: LD_INT 110
45666: PUSH
45667: LD_INT 111
45669: PUSH
45670: LD_INT 112
45672: PUSH
45673: LD_INT 113
45675: PUSH
45676: LD_INT 114
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: ST_TO_ADDR
45699: GO 47070
45701: LD_INT 13
45703: DOUBLE
45704: EQUAL
45705: IFTRUE 45709
45707: GO 45905
45709: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
45710: LD_ADDR_VAR 0 1
45714: PUSH
45715: LD_INT 1
45717: PUSH
45718: LD_INT 2
45720: PUSH
45721: LD_INT 3
45723: PUSH
45724: LD_INT 4
45726: PUSH
45727: LD_INT 5
45729: PUSH
45730: LD_INT 8
45732: PUSH
45733: LD_INT 9
45735: PUSH
45736: LD_INT 10
45738: PUSH
45739: LD_INT 11
45741: PUSH
45742: LD_INT 12
45744: PUSH
45745: LD_INT 14
45747: PUSH
45748: LD_INT 15
45750: PUSH
45751: LD_INT 16
45753: PUSH
45754: LD_INT 17
45756: PUSH
45757: LD_INT 18
45759: PUSH
45760: LD_INT 19
45762: PUSH
45763: LD_INT 20
45765: PUSH
45766: LD_INT 21
45768: PUSH
45769: LD_INT 22
45771: PUSH
45772: LD_INT 23
45774: PUSH
45775: LD_INT 24
45777: PUSH
45778: LD_INT 25
45780: PUSH
45781: LD_INT 26
45783: PUSH
45784: LD_INT 27
45786: PUSH
45787: LD_INT 28
45789: PUSH
45790: LD_INT 30
45792: PUSH
45793: LD_INT 31
45795: PUSH
45796: LD_INT 32
45798: PUSH
45799: LD_INT 33
45801: PUSH
45802: LD_INT 34
45804: PUSH
45805: LD_INT 36
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 101
45843: PUSH
45844: LD_INT 102
45846: PUSH
45847: LD_INT 103
45849: PUSH
45850: LD_INT 104
45852: PUSH
45853: LD_INT 105
45855: PUSH
45856: LD_INT 106
45858: PUSH
45859: LD_INT 107
45861: PUSH
45862: LD_INT 108
45864: PUSH
45865: LD_INT 109
45867: PUSH
45868: LD_INT 110
45870: PUSH
45871: LD_INT 111
45873: PUSH
45874: LD_INT 112
45876: PUSH
45877: LD_INT 113
45879: PUSH
45880: LD_INT 114
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: ST_TO_ADDR
45903: GO 47070
45905: LD_INT 14
45907: DOUBLE
45908: EQUAL
45909: IFTRUE 45913
45911: GO 46125
45913: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
45914: LD_ADDR_VAR 0 1
45918: PUSH
45919: LD_INT 1
45921: PUSH
45922: LD_INT 2
45924: PUSH
45925: LD_INT 3
45927: PUSH
45928: LD_INT 4
45930: PUSH
45931: LD_INT 5
45933: PUSH
45934: LD_INT 6
45936: PUSH
45937: LD_INT 7
45939: PUSH
45940: LD_INT 8
45942: PUSH
45943: LD_INT 9
45945: PUSH
45946: LD_INT 10
45948: PUSH
45949: LD_INT 11
45951: PUSH
45952: LD_INT 12
45954: PUSH
45955: LD_INT 13
45957: PUSH
45958: LD_INT 14
45960: PUSH
45961: LD_INT 15
45963: PUSH
45964: LD_INT 16
45966: PUSH
45967: LD_INT 17
45969: PUSH
45970: LD_INT 18
45972: PUSH
45973: LD_INT 19
45975: PUSH
45976: LD_INT 20
45978: PUSH
45979: LD_INT 21
45981: PUSH
45982: LD_INT 22
45984: PUSH
45985: LD_INT 23
45987: PUSH
45988: LD_INT 24
45990: PUSH
45991: LD_INT 25
45993: PUSH
45994: LD_INT 26
45996: PUSH
45997: LD_INT 27
45999: PUSH
46000: LD_INT 28
46002: PUSH
46003: LD_INT 29
46005: PUSH
46006: LD_INT 30
46008: PUSH
46009: LD_INT 31
46011: PUSH
46012: LD_INT 32
46014: PUSH
46015: LD_INT 33
46017: PUSH
46018: LD_INT 34
46020: PUSH
46021: LD_INT 36
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 101
46063: PUSH
46064: LD_INT 102
46066: PUSH
46067: LD_INT 103
46069: PUSH
46070: LD_INT 104
46072: PUSH
46073: LD_INT 105
46075: PUSH
46076: LD_INT 106
46078: PUSH
46079: LD_INT 107
46081: PUSH
46082: LD_INT 108
46084: PUSH
46085: LD_INT 109
46087: PUSH
46088: LD_INT 110
46090: PUSH
46091: LD_INT 111
46093: PUSH
46094: LD_INT 112
46096: PUSH
46097: LD_INT 113
46099: PUSH
46100: LD_INT 114
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: LIST
46110: LIST
46111: LIST
46112: LIST
46113: LIST
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: ST_TO_ADDR
46123: GO 47070
46125: LD_INT 15
46127: DOUBLE
46128: EQUAL
46129: IFTRUE 46133
46131: GO 46345
46133: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46134: LD_ADDR_VAR 0 1
46138: PUSH
46139: LD_INT 1
46141: PUSH
46142: LD_INT 2
46144: PUSH
46145: LD_INT 3
46147: PUSH
46148: LD_INT 4
46150: PUSH
46151: LD_INT 5
46153: PUSH
46154: LD_INT 6
46156: PUSH
46157: LD_INT 7
46159: PUSH
46160: LD_INT 8
46162: PUSH
46163: LD_INT 9
46165: PUSH
46166: LD_INT 10
46168: PUSH
46169: LD_INT 11
46171: PUSH
46172: LD_INT 12
46174: PUSH
46175: LD_INT 13
46177: PUSH
46178: LD_INT 14
46180: PUSH
46181: LD_INT 15
46183: PUSH
46184: LD_INT 16
46186: PUSH
46187: LD_INT 17
46189: PUSH
46190: LD_INT 18
46192: PUSH
46193: LD_INT 19
46195: PUSH
46196: LD_INT 20
46198: PUSH
46199: LD_INT 21
46201: PUSH
46202: LD_INT 22
46204: PUSH
46205: LD_INT 23
46207: PUSH
46208: LD_INT 24
46210: PUSH
46211: LD_INT 25
46213: PUSH
46214: LD_INT 26
46216: PUSH
46217: LD_INT 27
46219: PUSH
46220: LD_INT 28
46222: PUSH
46223: LD_INT 29
46225: PUSH
46226: LD_INT 30
46228: PUSH
46229: LD_INT 31
46231: PUSH
46232: LD_INT 32
46234: PUSH
46235: LD_INT 33
46237: PUSH
46238: LD_INT 34
46240: PUSH
46241: LD_INT 36
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: LIST
46261: LIST
46262: LIST
46263: LIST
46264: LIST
46265: LIST
46266: LIST
46267: LIST
46268: LIST
46269: LIST
46270: LIST
46271: LIST
46272: LIST
46273: LIST
46274: LIST
46275: LIST
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 101
46283: PUSH
46284: LD_INT 102
46286: PUSH
46287: LD_INT 103
46289: PUSH
46290: LD_INT 104
46292: PUSH
46293: LD_INT 105
46295: PUSH
46296: LD_INT 106
46298: PUSH
46299: LD_INT 107
46301: PUSH
46302: LD_INT 108
46304: PUSH
46305: LD_INT 109
46307: PUSH
46308: LD_INT 110
46310: PUSH
46311: LD_INT 111
46313: PUSH
46314: LD_INT 112
46316: PUSH
46317: LD_INT 113
46319: PUSH
46320: LD_INT 114
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: PUSH
46339: EMPTY
46340: LIST
46341: LIST
46342: ST_TO_ADDR
46343: GO 47070
46345: LD_INT 16
46347: DOUBLE
46348: EQUAL
46349: IFTRUE 46353
46351: GO 46477
46353: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
46354: LD_ADDR_VAR 0 1
46358: PUSH
46359: LD_INT 2
46361: PUSH
46362: LD_INT 4
46364: PUSH
46365: LD_INT 5
46367: PUSH
46368: LD_INT 7
46370: PUSH
46371: LD_INT 11
46373: PUSH
46374: LD_INT 12
46376: PUSH
46377: LD_INT 15
46379: PUSH
46380: LD_INT 16
46382: PUSH
46383: LD_INT 20
46385: PUSH
46386: LD_INT 21
46388: PUSH
46389: LD_INT 22
46391: PUSH
46392: LD_INT 23
46394: PUSH
46395: LD_INT 25
46397: PUSH
46398: LD_INT 26
46400: PUSH
46401: LD_INT 30
46403: PUSH
46404: LD_INT 31
46406: PUSH
46407: LD_INT 32
46409: PUSH
46410: LD_INT 33
46412: PUSH
46413: LD_INT 34
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: PUSH
46437: LD_INT 101
46439: PUSH
46440: LD_INT 102
46442: PUSH
46443: LD_INT 103
46445: PUSH
46446: LD_INT 106
46448: PUSH
46449: LD_INT 108
46451: PUSH
46452: LD_INT 112
46454: PUSH
46455: LD_INT 113
46457: PUSH
46458: LD_INT 114
46460: PUSH
46461: EMPTY
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: LIST
46468: LIST
46469: LIST
46470: PUSH
46471: EMPTY
46472: LIST
46473: LIST
46474: ST_TO_ADDR
46475: GO 47070
46477: LD_INT 17
46479: DOUBLE
46480: EQUAL
46481: IFTRUE 46485
46483: GO 46697
46485: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
46486: LD_ADDR_VAR 0 1
46490: PUSH
46491: LD_INT 1
46493: PUSH
46494: LD_INT 2
46496: PUSH
46497: LD_INT 3
46499: PUSH
46500: LD_INT 4
46502: PUSH
46503: LD_INT 5
46505: PUSH
46506: LD_INT 6
46508: PUSH
46509: LD_INT 7
46511: PUSH
46512: LD_INT 8
46514: PUSH
46515: LD_INT 9
46517: PUSH
46518: LD_INT 10
46520: PUSH
46521: LD_INT 11
46523: PUSH
46524: LD_INT 12
46526: PUSH
46527: LD_INT 13
46529: PUSH
46530: LD_INT 14
46532: PUSH
46533: LD_INT 15
46535: PUSH
46536: LD_INT 16
46538: PUSH
46539: LD_INT 17
46541: PUSH
46542: LD_INT 18
46544: PUSH
46545: LD_INT 19
46547: PUSH
46548: LD_INT 20
46550: PUSH
46551: LD_INT 21
46553: PUSH
46554: LD_INT 22
46556: PUSH
46557: LD_INT 23
46559: PUSH
46560: LD_INT 24
46562: PUSH
46563: LD_INT 25
46565: PUSH
46566: LD_INT 26
46568: PUSH
46569: LD_INT 27
46571: PUSH
46572: LD_INT 28
46574: PUSH
46575: LD_INT 29
46577: PUSH
46578: LD_INT 30
46580: PUSH
46581: LD_INT 31
46583: PUSH
46584: LD_INT 32
46586: PUSH
46587: LD_INT 33
46589: PUSH
46590: LD_INT 34
46592: PUSH
46593: LD_INT 36
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 101
46635: PUSH
46636: LD_INT 102
46638: PUSH
46639: LD_INT 103
46641: PUSH
46642: LD_INT 104
46644: PUSH
46645: LD_INT 105
46647: PUSH
46648: LD_INT 106
46650: PUSH
46651: LD_INT 107
46653: PUSH
46654: LD_INT 108
46656: PUSH
46657: LD_INT 109
46659: PUSH
46660: LD_INT 110
46662: PUSH
46663: LD_INT 111
46665: PUSH
46666: LD_INT 112
46668: PUSH
46669: LD_INT 113
46671: PUSH
46672: LD_INT 114
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: ST_TO_ADDR
46695: GO 47070
46697: LD_INT 18
46699: DOUBLE
46700: EQUAL
46701: IFTRUE 46705
46703: GO 46841
46705: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
46706: LD_ADDR_VAR 0 1
46710: PUSH
46711: LD_INT 2
46713: PUSH
46714: LD_INT 4
46716: PUSH
46717: LD_INT 5
46719: PUSH
46720: LD_INT 7
46722: PUSH
46723: LD_INT 11
46725: PUSH
46726: LD_INT 12
46728: PUSH
46729: LD_INT 15
46731: PUSH
46732: LD_INT 16
46734: PUSH
46735: LD_INT 20
46737: PUSH
46738: LD_INT 21
46740: PUSH
46741: LD_INT 22
46743: PUSH
46744: LD_INT 23
46746: PUSH
46747: LD_INT 25
46749: PUSH
46750: LD_INT 26
46752: PUSH
46753: LD_INT 30
46755: PUSH
46756: LD_INT 31
46758: PUSH
46759: LD_INT 32
46761: PUSH
46762: LD_INT 33
46764: PUSH
46765: LD_INT 34
46767: PUSH
46768: LD_INT 35
46770: PUSH
46771: LD_INT 36
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: PUSH
46797: LD_INT 101
46799: PUSH
46800: LD_INT 102
46802: PUSH
46803: LD_INT 103
46805: PUSH
46806: LD_INT 106
46808: PUSH
46809: LD_INT 108
46811: PUSH
46812: LD_INT 112
46814: PUSH
46815: LD_INT 113
46817: PUSH
46818: LD_INT 114
46820: PUSH
46821: LD_INT 115
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: ST_TO_ADDR
46839: GO 47070
46841: LD_INT 19
46843: DOUBLE
46844: EQUAL
46845: IFTRUE 46849
46847: GO 47069
46849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
46850: LD_ADDR_VAR 0 1
46854: PUSH
46855: LD_INT 1
46857: PUSH
46858: LD_INT 2
46860: PUSH
46861: LD_INT 3
46863: PUSH
46864: LD_INT 4
46866: PUSH
46867: LD_INT 5
46869: PUSH
46870: LD_INT 6
46872: PUSH
46873: LD_INT 7
46875: PUSH
46876: LD_INT 8
46878: PUSH
46879: LD_INT 9
46881: PUSH
46882: LD_INT 10
46884: PUSH
46885: LD_INT 11
46887: PUSH
46888: LD_INT 12
46890: PUSH
46891: LD_INT 13
46893: PUSH
46894: LD_INT 14
46896: PUSH
46897: LD_INT 15
46899: PUSH
46900: LD_INT 16
46902: PUSH
46903: LD_INT 17
46905: PUSH
46906: LD_INT 18
46908: PUSH
46909: LD_INT 19
46911: PUSH
46912: LD_INT 20
46914: PUSH
46915: LD_INT 21
46917: PUSH
46918: LD_INT 22
46920: PUSH
46921: LD_INT 23
46923: PUSH
46924: LD_INT 24
46926: PUSH
46927: LD_INT 25
46929: PUSH
46930: LD_INT 26
46932: PUSH
46933: LD_INT 27
46935: PUSH
46936: LD_INT 28
46938: PUSH
46939: LD_INT 29
46941: PUSH
46942: LD_INT 30
46944: PUSH
46945: LD_INT 31
46947: PUSH
46948: LD_INT 32
46950: PUSH
46951: LD_INT 33
46953: PUSH
46954: LD_INT 34
46956: PUSH
46957: LD_INT 35
46959: PUSH
46960: LD_INT 36
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: PUSH
47001: LD_INT 101
47003: PUSH
47004: LD_INT 102
47006: PUSH
47007: LD_INT 103
47009: PUSH
47010: LD_INT 104
47012: PUSH
47013: LD_INT 105
47015: PUSH
47016: LD_INT 106
47018: PUSH
47019: LD_INT 107
47021: PUSH
47022: LD_INT 108
47024: PUSH
47025: LD_INT 109
47027: PUSH
47028: LD_INT 110
47030: PUSH
47031: LD_INT 111
47033: PUSH
47034: LD_INT 112
47036: PUSH
47037: LD_INT 113
47039: PUSH
47040: LD_INT 114
47042: PUSH
47043: LD_INT 115
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: ST_TO_ADDR
47067: GO 47070
47069: POP
// end else
47070: GO 47289
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47072: LD_ADDR_VAR 0 1
47076: PUSH
47077: LD_INT 1
47079: PUSH
47080: LD_INT 2
47082: PUSH
47083: LD_INT 3
47085: PUSH
47086: LD_INT 4
47088: PUSH
47089: LD_INT 5
47091: PUSH
47092: LD_INT 6
47094: PUSH
47095: LD_INT 7
47097: PUSH
47098: LD_INT 8
47100: PUSH
47101: LD_INT 9
47103: PUSH
47104: LD_INT 10
47106: PUSH
47107: LD_INT 11
47109: PUSH
47110: LD_INT 12
47112: PUSH
47113: LD_INT 13
47115: PUSH
47116: LD_INT 14
47118: PUSH
47119: LD_INT 15
47121: PUSH
47122: LD_INT 16
47124: PUSH
47125: LD_INT 17
47127: PUSH
47128: LD_INT 18
47130: PUSH
47131: LD_INT 19
47133: PUSH
47134: LD_INT 20
47136: PUSH
47137: LD_INT 21
47139: PUSH
47140: LD_INT 22
47142: PUSH
47143: LD_INT 23
47145: PUSH
47146: LD_INT 24
47148: PUSH
47149: LD_INT 25
47151: PUSH
47152: LD_INT 26
47154: PUSH
47155: LD_INT 27
47157: PUSH
47158: LD_INT 28
47160: PUSH
47161: LD_INT 29
47163: PUSH
47164: LD_INT 30
47166: PUSH
47167: LD_INT 31
47169: PUSH
47170: LD_INT 32
47172: PUSH
47173: LD_INT 33
47175: PUSH
47176: LD_INT 34
47178: PUSH
47179: LD_INT 35
47181: PUSH
47182: LD_INT 36
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: PUSH
47223: LD_INT 101
47225: PUSH
47226: LD_INT 102
47228: PUSH
47229: LD_INT 103
47231: PUSH
47232: LD_INT 104
47234: PUSH
47235: LD_INT 105
47237: PUSH
47238: LD_INT 106
47240: PUSH
47241: LD_INT 107
47243: PUSH
47244: LD_INT 108
47246: PUSH
47247: LD_INT 109
47249: PUSH
47250: LD_INT 110
47252: PUSH
47253: LD_INT 111
47255: PUSH
47256: LD_INT 112
47258: PUSH
47259: LD_INT 113
47261: PUSH
47262: LD_INT 114
47264: PUSH
47265: LD_INT 115
47267: PUSH
47268: EMPTY
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: ST_TO_ADDR
// if result then
47289: LD_VAR 0 1
47293: IFFALSE 47582
// begin normal :=  ;
47295: LD_ADDR_VAR 0 3
47299: PUSH
47300: LD_STRING 
47302: ST_TO_ADDR
// hardcore :=  ;
47303: LD_ADDR_VAR 0 4
47307: PUSH
47308: LD_STRING 
47310: ST_TO_ADDR
// for i = 1 to normalCounter do
47311: LD_ADDR_VAR 0 5
47315: PUSH
47316: DOUBLE
47317: LD_INT 1
47319: DEC
47320: ST_TO_ADDR
47321: LD_EXP 88
47325: PUSH
47326: FOR_TO
47327: IFFALSE 47428
// begin tmp := 0 ;
47329: LD_ADDR_VAR 0 2
47333: PUSH
47334: LD_STRING 0
47336: ST_TO_ADDR
// if result [ 1 ] then
47337: LD_VAR 0 1
47341: PUSH
47342: LD_INT 1
47344: ARRAY
47345: IFFALSE 47410
// if result [ 1 ] [ 1 ] = i then
47347: LD_VAR 0 1
47351: PUSH
47352: LD_INT 1
47354: ARRAY
47355: PUSH
47356: LD_INT 1
47358: ARRAY
47359: PUSH
47360: LD_VAR 0 5
47364: EQUAL
47365: IFFALSE 47410
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
47367: LD_ADDR_VAR 0 1
47371: PUSH
47372: LD_VAR 0 1
47376: PPUSH
47377: LD_INT 1
47379: PPUSH
47380: LD_VAR 0 1
47384: PUSH
47385: LD_INT 1
47387: ARRAY
47388: PPUSH
47389: LD_INT 1
47391: PPUSH
47392: CALL_OW 3
47396: PPUSH
47397: CALL_OW 1
47401: ST_TO_ADDR
// tmp := 1 ;
47402: LD_ADDR_VAR 0 2
47406: PUSH
47407: LD_STRING 1
47409: ST_TO_ADDR
// end ; normal := normal & tmp ;
47410: LD_ADDR_VAR 0 3
47414: PUSH
47415: LD_VAR 0 3
47419: PUSH
47420: LD_VAR 0 2
47424: STR
47425: ST_TO_ADDR
// end ;
47426: GO 47326
47428: POP
47429: POP
// for i = 1 to hardcoreCounter do
47430: LD_ADDR_VAR 0 5
47434: PUSH
47435: DOUBLE
47436: LD_INT 1
47438: DEC
47439: ST_TO_ADDR
47440: LD_EXP 89
47444: PUSH
47445: FOR_TO
47446: IFFALSE 47551
// begin tmp := 0 ;
47448: LD_ADDR_VAR 0 2
47452: PUSH
47453: LD_STRING 0
47455: ST_TO_ADDR
// if result [ 2 ] then
47456: LD_VAR 0 1
47460: PUSH
47461: LD_INT 2
47463: ARRAY
47464: IFFALSE 47533
// if result [ 2 ] [ 1 ] = 100 + i then
47466: LD_VAR 0 1
47470: PUSH
47471: LD_INT 2
47473: ARRAY
47474: PUSH
47475: LD_INT 1
47477: ARRAY
47478: PUSH
47479: LD_INT 100
47481: PUSH
47482: LD_VAR 0 5
47486: PLUS
47487: EQUAL
47488: IFFALSE 47533
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
47490: LD_ADDR_VAR 0 1
47494: PUSH
47495: LD_VAR 0 1
47499: PPUSH
47500: LD_INT 2
47502: PPUSH
47503: LD_VAR 0 1
47507: PUSH
47508: LD_INT 2
47510: ARRAY
47511: PPUSH
47512: LD_INT 1
47514: PPUSH
47515: CALL_OW 3
47519: PPUSH
47520: CALL_OW 1
47524: ST_TO_ADDR
// tmp := 1 ;
47525: LD_ADDR_VAR 0 2
47529: PUSH
47530: LD_STRING 1
47532: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
47533: LD_ADDR_VAR 0 4
47537: PUSH
47538: LD_VAR 0 4
47542: PUSH
47543: LD_VAR 0 2
47547: STR
47548: ST_TO_ADDR
// end ;
47549: GO 47445
47551: POP
47552: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
47553: LD_STRING getStreamItemsFromMission("
47555: PUSH
47556: LD_VAR 0 3
47560: STR
47561: PUSH
47562: LD_STRING ","
47564: STR
47565: PUSH
47566: LD_VAR 0 4
47570: STR
47571: PUSH
47572: LD_STRING ")
47574: STR
47575: PPUSH
47576: CALL_OW 559
// end else
47580: GO 47589
// ToLua ( getStreamItemsFromMission("","") ) ;
47582: LD_STRING getStreamItemsFromMission("","")
47584: PPUSH
47585: CALL_OW 559
// end ;
47589: LD_VAR 0 1
47593: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
47594: LD_VAR 0 2
47598: PUSH
47599: LD_INT 100
47601: EQUAL
47602: IFFALSE 48551
// begin if not StreamModeActive then
47604: LD_EXP 87
47608: NOT
47609: IFFALSE 47619
// StreamModeActive := true ;
47611: LD_ADDR_EXP 87
47615: PUSH
47616: LD_INT 1
47618: ST_TO_ADDR
// if p3 = 0 then
47619: LD_VAR 0 3
47623: PUSH
47624: LD_INT 0
47626: EQUAL
47627: IFFALSE 47633
// InitStreamMode ;
47629: CALL 43672 0 0
// if p3 = 1 then
47633: LD_VAR 0 3
47637: PUSH
47638: LD_INT 1
47640: EQUAL
47641: IFFALSE 47651
// sRocket := true ;
47643: LD_ADDR_EXP 92
47647: PUSH
47648: LD_INT 1
47650: ST_TO_ADDR
// if p3 = 2 then
47651: LD_VAR 0 3
47655: PUSH
47656: LD_INT 2
47658: EQUAL
47659: IFFALSE 47669
// sSpeed := true ;
47661: LD_ADDR_EXP 91
47665: PUSH
47666: LD_INT 1
47668: ST_TO_ADDR
// if p3 = 3 then
47669: LD_VAR 0 3
47673: PUSH
47674: LD_INT 3
47676: EQUAL
47677: IFFALSE 47687
// sEngine := true ;
47679: LD_ADDR_EXP 93
47683: PUSH
47684: LD_INT 1
47686: ST_TO_ADDR
// if p3 = 4 then
47687: LD_VAR 0 3
47691: PUSH
47692: LD_INT 4
47694: EQUAL
47695: IFFALSE 47705
// sSpec := true ;
47697: LD_ADDR_EXP 90
47701: PUSH
47702: LD_INT 1
47704: ST_TO_ADDR
// if p3 = 5 then
47705: LD_VAR 0 3
47709: PUSH
47710: LD_INT 5
47712: EQUAL
47713: IFFALSE 47723
// sLevel := true ;
47715: LD_ADDR_EXP 94
47719: PUSH
47720: LD_INT 1
47722: ST_TO_ADDR
// if p3 = 6 then
47723: LD_VAR 0 3
47727: PUSH
47728: LD_INT 6
47730: EQUAL
47731: IFFALSE 47741
// sArmoury := true ;
47733: LD_ADDR_EXP 95
47737: PUSH
47738: LD_INT 1
47740: ST_TO_ADDR
// if p3 = 7 then
47741: LD_VAR 0 3
47745: PUSH
47746: LD_INT 7
47748: EQUAL
47749: IFFALSE 47759
// sRadar := true ;
47751: LD_ADDR_EXP 96
47755: PUSH
47756: LD_INT 1
47758: ST_TO_ADDR
// if p3 = 8 then
47759: LD_VAR 0 3
47763: PUSH
47764: LD_INT 8
47766: EQUAL
47767: IFFALSE 47777
// sBunker := true ;
47769: LD_ADDR_EXP 97
47773: PUSH
47774: LD_INT 1
47776: ST_TO_ADDR
// if p3 = 9 then
47777: LD_VAR 0 3
47781: PUSH
47782: LD_INT 9
47784: EQUAL
47785: IFFALSE 47795
// sHack := true ;
47787: LD_ADDR_EXP 98
47791: PUSH
47792: LD_INT 1
47794: ST_TO_ADDR
// if p3 = 10 then
47795: LD_VAR 0 3
47799: PUSH
47800: LD_INT 10
47802: EQUAL
47803: IFFALSE 47813
// sFire := true ;
47805: LD_ADDR_EXP 99
47809: PUSH
47810: LD_INT 1
47812: ST_TO_ADDR
// if p3 = 11 then
47813: LD_VAR 0 3
47817: PUSH
47818: LD_INT 11
47820: EQUAL
47821: IFFALSE 47831
// sRefresh := true ;
47823: LD_ADDR_EXP 100
47827: PUSH
47828: LD_INT 1
47830: ST_TO_ADDR
// if p3 = 12 then
47831: LD_VAR 0 3
47835: PUSH
47836: LD_INT 12
47838: EQUAL
47839: IFFALSE 47849
// sExp := true ;
47841: LD_ADDR_EXP 101
47845: PUSH
47846: LD_INT 1
47848: ST_TO_ADDR
// if p3 = 13 then
47849: LD_VAR 0 3
47853: PUSH
47854: LD_INT 13
47856: EQUAL
47857: IFFALSE 47867
// sDepot := true ;
47859: LD_ADDR_EXP 102
47863: PUSH
47864: LD_INT 1
47866: ST_TO_ADDR
// if p3 = 14 then
47867: LD_VAR 0 3
47871: PUSH
47872: LD_INT 14
47874: EQUAL
47875: IFFALSE 47885
// sFlag := true ;
47877: LD_ADDR_EXP 103
47881: PUSH
47882: LD_INT 1
47884: ST_TO_ADDR
// if p3 = 15 then
47885: LD_VAR 0 3
47889: PUSH
47890: LD_INT 15
47892: EQUAL
47893: IFFALSE 47903
// sKamikadze := true ;
47895: LD_ADDR_EXP 111
47899: PUSH
47900: LD_INT 1
47902: ST_TO_ADDR
// if p3 = 16 then
47903: LD_VAR 0 3
47907: PUSH
47908: LD_INT 16
47910: EQUAL
47911: IFFALSE 47921
// sTroll := true ;
47913: LD_ADDR_EXP 112
47917: PUSH
47918: LD_INT 1
47920: ST_TO_ADDR
// if p3 = 17 then
47921: LD_VAR 0 3
47925: PUSH
47926: LD_INT 17
47928: EQUAL
47929: IFFALSE 47939
// sSlow := true ;
47931: LD_ADDR_EXP 113
47935: PUSH
47936: LD_INT 1
47938: ST_TO_ADDR
// if p3 = 18 then
47939: LD_VAR 0 3
47943: PUSH
47944: LD_INT 18
47946: EQUAL
47947: IFFALSE 47957
// sLack := true ;
47949: LD_ADDR_EXP 114
47953: PUSH
47954: LD_INT 1
47956: ST_TO_ADDR
// if p3 = 19 then
47957: LD_VAR 0 3
47961: PUSH
47962: LD_INT 19
47964: EQUAL
47965: IFFALSE 47975
// sTank := true ;
47967: LD_ADDR_EXP 116
47971: PUSH
47972: LD_INT 1
47974: ST_TO_ADDR
// if p3 = 20 then
47975: LD_VAR 0 3
47979: PUSH
47980: LD_INT 20
47982: EQUAL
47983: IFFALSE 47993
// sRemote := true ;
47985: LD_ADDR_EXP 117
47989: PUSH
47990: LD_INT 1
47992: ST_TO_ADDR
// if p3 = 21 then
47993: LD_VAR 0 3
47997: PUSH
47998: LD_INT 21
48000: EQUAL
48001: IFFALSE 48011
// sPowell := true ;
48003: LD_ADDR_EXP 118
48007: PUSH
48008: LD_INT 1
48010: ST_TO_ADDR
// if p3 = 22 then
48011: LD_VAR 0 3
48015: PUSH
48016: LD_INT 22
48018: EQUAL
48019: IFFALSE 48029
// sTeleport := true ;
48021: LD_ADDR_EXP 121
48025: PUSH
48026: LD_INT 1
48028: ST_TO_ADDR
// if p3 = 23 then
48029: LD_VAR 0 3
48033: PUSH
48034: LD_INT 23
48036: EQUAL
48037: IFFALSE 48047
// sOilTower := true ;
48039: LD_ADDR_EXP 123
48043: PUSH
48044: LD_INT 1
48046: ST_TO_ADDR
// if p3 = 24 then
48047: LD_VAR 0 3
48051: PUSH
48052: LD_INT 24
48054: EQUAL
48055: IFFALSE 48065
// sShovel := true ;
48057: LD_ADDR_EXP 124
48061: PUSH
48062: LD_INT 1
48064: ST_TO_ADDR
// if p3 = 25 then
48065: LD_VAR 0 3
48069: PUSH
48070: LD_INT 25
48072: EQUAL
48073: IFFALSE 48083
// sSheik := true ;
48075: LD_ADDR_EXP 125
48079: PUSH
48080: LD_INT 1
48082: ST_TO_ADDR
// if p3 = 26 then
48083: LD_VAR 0 3
48087: PUSH
48088: LD_INT 26
48090: EQUAL
48091: IFFALSE 48101
// sEarthquake := true ;
48093: LD_ADDR_EXP 127
48097: PUSH
48098: LD_INT 1
48100: ST_TO_ADDR
// if p3 = 27 then
48101: LD_VAR 0 3
48105: PUSH
48106: LD_INT 27
48108: EQUAL
48109: IFFALSE 48119
// sAI := true ;
48111: LD_ADDR_EXP 128
48115: PUSH
48116: LD_INT 1
48118: ST_TO_ADDR
// if p3 = 28 then
48119: LD_VAR 0 3
48123: PUSH
48124: LD_INT 28
48126: EQUAL
48127: IFFALSE 48137
// sCargo := true ;
48129: LD_ADDR_EXP 131
48133: PUSH
48134: LD_INT 1
48136: ST_TO_ADDR
// if p3 = 29 then
48137: LD_VAR 0 3
48141: PUSH
48142: LD_INT 29
48144: EQUAL
48145: IFFALSE 48155
// sDLaser := true ;
48147: LD_ADDR_EXP 132
48151: PUSH
48152: LD_INT 1
48154: ST_TO_ADDR
// if p3 = 30 then
48155: LD_VAR 0 3
48159: PUSH
48160: LD_INT 30
48162: EQUAL
48163: IFFALSE 48173
// sExchange := true ;
48165: LD_ADDR_EXP 133
48169: PUSH
48170: LD_INT 1
48172: ST_TO_ADDR
// if p3 = 31 then
48173: LD_VAR 0 3
48177: PUSH
48178: LD_INT 31
48180: EQUAL
48181: IFFALSE 48191
// sFac := true ;
48183: LD_ADDR_EXP 134
48187: PUSH
48188: LD_INT 1
48190: ST_TO_ADDR
// if p3 = 32 then
48191: LD_VAR 0 3
48195: PUSH
48196: LD_INT 32
48198: EQUAL
48199: IFFALSE 48209
// sPower := true ;
48201: LD_ADDR_EXP 135
48205: PUSH
48206: LD_INT 1
48208: ST_TO_ADDR
// if p3 = 33 then
48209: LD_VAR 0 3
48213: PUSH
48214: LD_INT 33
48216: EQUAL
48217: IFFALSE 48227
// sRandom := true ;
48219: LD_ADDR_EXP 136
48223: PUSH
48224: LD_INT 1
48226: ST_TO_ADDR
// if p3 = 34 then
48227: LD_VAR 0 3
48231: PUSH
48232: LD_INT 34
48234: EQUAL
48235: IFFALSE 48245
// sShield := true ;
48237: LD_ADDR_EXP 137
48241: PUSH
48242: LD_INT 1
48244: ST_TO_ADDR
// if p3 = 35 then
48245: LD_VAR 0 3
48249: PUSH
48250: LD_INT 35
48252: EQUAL
48253: IFFALSE 48263
// sTime := true ;
48255: LD_ADDR_EXP 138
48259: PUSH
48260: LD_INT 1
48262: ST_TO_ADDR
// if p3 = 36 then
48263: LD_VAR 0 3
48267: PUSH
48268: LD_INT 36
48270: EQUAL
48271: IFFALSE 48281
// sTools := true ;
48273: LD_ADDR_EXP 139
48277: PUSH
48278: LD_INT 1
48280: ST_TO_ADDR
// if p3 = 101 then
48281: LD_VAR 0 3
48285: PUSH
48286: LD_INT 101
48288: EQUAL
48289: IFFALSE 48299
// sSold := true ;
48291: LD_ADDR_EXP 104
48295: PUSH
48296: LD_INT 1
48298: ST_TO_ADDR
// if p3 = 102 then
48299: LD_VAR 0 3
48303: PUSH
48304: LD_INT 102
48306: EQUAL
48307: IFFALSE 48317
// sDiff := true ;
48309: LD_ADDR_EXP 105
48313: PUSH
48314: LD_INT 1
48316: ST_TO_ADDR
// if p3 = 103 then
48317: LD_VAR 0 3
48321: PUSH
48322: LD_INT 103
48324: EQUAL
48325: IFFALSE 48335
// sFog := true ;
48327: LD_ADDR_EXP 108
48331: PUSH
48332: LD_INT 1
48334: ST_TO_ADDR
// if p3 = 104 then
48335: LD_VAR 0 3
48339: PUSH
48340: LD_INT 104
48342: EQUAL
48343: IFFALSE 48353
// sReset := true ;
48345: LD_ADDR_EXP 109
48349: PUSH
48350: LD_INT 1
48352: ST_TO_ADDR
// if p3 = 105 then
48353: LD_VAR 0 3
48357: PUSH
48358: LD_INT 105
48360: EQUAL
48361: IFFALSE 48371
// sSun := true ;
48363: LD_ADDR_EXP 110
48367: PUSH
48368: LD_INT 1
48370: ST_TO_ADDR
// if p3 = 106 then
48371: LD_VAR 0 3
48375: PUSH
48376: LD_INT 106
48378: EQUAL
48379: IFFALSE 48389
// sTiger := true ;
48381: LD_ADDR_EXP 106
48385: PUSH
48386: LD_INT 1
48388: ST_TO_ADDR
// if p3 = 107 then
48389: LD_VAR 0 3
48393: PUSH
48394: LD_INT 107
48396: EQUAL
48397: IFFALSE 48407
// sBomb := true ;
48399: LD_ADDR_EXP 107
48403: PUSH
48404: LD_INT 1
48406: ST_TO_ADDR
// if p3 = 108 then
48407: LD_VAR 0 3
48411: PUSH
48412: LD_INT 108
48414: EQUAL
48415: IFFALSE 48425
// sWound := true ;
48417: LD_ADDR_EXP 115
48421: PUSH
48422: LD_INT 1
48424: ST_TO_ADDR
// if p3 = 109 then
48425: LD_VAR 0 3
48429: PUSH
48430: LD_INT 109
48432: EQUAL
48433: IFFALSE 48443
// sBetray := true ;
48435: LD_ADDR_EXP 119
48439: PUSH
48440: LD_INT 1
48442: ST_TO_ADDR
// if p3 = 110 then
48443: LD_VAR 0 3
48447: PUSH
48448: LD_INT 110
48450: EQUAL
48451: IFFALSE 48461
// sContamin := true ;
48453: LD_ADDR_EXP 120
48457: PUSH
48458: LD_INT 1
48460: ST_TO_ADDR
// if p3 = 111 then
48461: LD_VAR 0 3
48465: PUSH
48466: LD_INT 111
48468: EQUAL
48469: IFFALSE 48479
// sOil := true ;
48471: LD_ADDR_EXP 122
48475: PUSH
48476: LD_INT 1
48478: ST_TO_ADDR
// if p3 = 112 then
48479: LD_VAR 0 3
48483: PUSH
48484: LD_INT 112
48486: EQUAL
48487: IFFALSE 48497
// sStu := true ;
48489: LD_ADDR_EXP 126
48493: PUSH
48494: LD_INT 1
48496: ST_TO_ADDR
// if p3 = 113 then
48497: LD_VAR 0 3
48501: PUSH
48502: LD_INT 113
48504: EQUAL
48505: IFFALSE 48515
// sBazooka := true ;
48507: LD_ADDR_EXP 129
48511: PUSH
48512: LD_INT 1
48514: ST_TO_ADDR
// if p3 = 114 then
48515: LD_VAR 0 3
48519: PUSH
48520: LD_INT 114
48522: EQUAL
48523: IFFALSE 48533
// sMortar := true ;
48525: LD_ADDR_EXP 130
48529: PUSH
48530: LD_INT 1
48532: ST_TO_ADDR
// if p3 = 115 then
48533: LD_VAR 0 3
48537: PUSH
48538: LD_INT 115
48540: EQUAL
48541: IFFALSE 48551
// sRanger := true ;
48543: LD_ADDR_EXP 140
48547: PUSH
48548: LD_INT 1
48550: ST_TO_ADDR
// end ; end ;
48551: PPOPN 6
48553: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48554: LD_EXP 87
48558: PUSH
48559: LD_EXP 92
48563: AND
48564: IFFALSE 48688
48566: GO 48568
48568: DISABLE
48569: LD_INT 0
48571: PPUSH
48572: PPUSH
// begin enable ;
48573: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48574: LD_ADDR_VAR 0 2
48578: PUSH
48579: LD_INT 22
48581: PUSH
48582: LD_OWVAR 2
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 2
48593: PUSH
48594: LD_INT 34
48596: PUSH
48597: LD_INT 7
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: PUSH
48604: LD_INT 34
48606: PUSH
48607: LD_INT 45
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: LD_INT 34
48616: PUSH
48617: LD_INT 28
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 34
48626: PUSH
48627: LD_INT 47
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: PPUSH
48645: CALL_OW 69
48649: ST_TO_ADDR
// if not tmp then
48650: LD_VAR 0 2
48654: NOT
48655: IFFALSE 48659
// exit ;
48657: GO 48688
// for i in tmp do
48659: LD_ADDR_VAR 0 1
48663: PUSH
48664: LD_VAR 0 2
48668: PUSH
48669: FOR_IN
48670: IFFALSE 48686
// begin SetLives ( i , 0 ) ;
48672: LD_VAR 0 1
48676: PPUSH
48677: LD_INT 0
48679: PPUSH
48680: CALL_OW 234
// end ;
48684: GO 48669
48686: POP
48687: POP
// end ;
48688: PPOPN 2
48690: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48691: LD_EXP 87
48695: PUSH
48696: LD_EXP 93
48700: AND
48701: IFFALSE 48785
48703: GO 48705
48705: DISABLE
48706: LD_INT 0
48708: PPUSH
48709: PPUSH
// begin enable ;
48710: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48711: LD_ADDR_VAR 0 2
48715: PUSH
48716: LD_INT 22
48718: PUSH
48719: LD_OWVAR 2
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: PUSH
48728: LD_INT 32
48730: PUSH
48731: LD_INT 3
48733: PUSH
48734: EMPTY
48735: LIST
48736: LIST
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PPUSH
48742: CALL_OW 69
48746: ST_TO_ADDR
// if not tmp then
48747: LD_VAR 0 2
48751: NOT
48752: IFFALSE 48756
// exit ;
48754: GO 48785
// for i in tmp do
48756: LD_ADDR_VAR 0 1
48760: PUSH
48761: LD_VAR 0 2
48765: PUSH
48766: FOR_IN
48767: IFFALSE 48783
// begin SetLives ( i , 0 ) ;
48769: LD_VAR 0 1
48773: PPUSH
48774: LD_INT 0
48776: PPUSH
48777: CALL_OW 234
// end ;
48781: GO 48766
48783: POP
48784: POP
// end ;
48785: PPOPN 2
48787: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48788: LD_EXP 87
48792: PUSH
48793: LD_EXP 90
48797: AND
48798: IFFALSE 48891
48800: GO 48802
48802: DISABLE
48803: LD_INT 0
48805: PPUSH
// begin enable ;
48806: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48807: LD_ADDR_VAR 0 1
48811: PUSH
48812: LD_INT 22
48814: PUSH
48815: LD_OWVAR 2
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: PUSH
48824: LD_INT 2
48826: PUSH
48827: LD_INT 25
48829: PUSH
48830: LD_INT 5
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: PUSH
48837: LD_INT 25
48839: PUSH
48840: LD_INT 9
48842: PUSH
48843: EMPTY
48844: LIST
48845: LIST
48846: PUSH
48847: LD_INT 25
48849: PUSH
48850: LD_INT 8
48852: PUSH
48853: EMPTY
48854: LIST
48855: LIST
48856: PUSH
48857: EMPTY
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PPUSH
48867: CALL_OW 69
48871: PUSH
48872: FOR_IN
48873: IFFALSE 48889
// begin SetClass ( i , 1 ) ;
48875: LD_VAR 0 1
48879: PPUSH
48880: LD_INT 1
48882: PPUSH
48883: CALL_OW 336
// end ;
48887: GO 48872
48889: POP
48890: POP
// end ;
48891: PPOPN 1
48893: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48894: LD_EXP 87
48898: PUSH
48899: LD_EXP 91
48903: AND
48904: PUSH
48905: LD_OWVAR 65
48909: PUSH
48910: LD_INT 7
48912: LESS
48913: AND
48914: IFFALSE 48928
48916: GO 48918
48918: DISABLE
// begin enable ;
48919: ENABLE
// game_speed := 7 ;
48920: LD_ADDR_OWVAR 65
48924: PUSH
48925: LD_INT 7
48927: ST_TO_ADDR
// end ;
48928: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48929: LD_EXP 87
48933: PUSH
48934: LD_EXP 94
48938: AND
48939: IFFALSE 49141
48941: GO 48943
48943: DISABLE
48944: LD_INT 0
48946: PPUSH
48947: PPUSH
48948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48949: LD_ADDR_VAR 0 3
48953: PUSH
48954: LD_INT 81
48956: PUSH
48957: LD_OWVAR 2
48961: PUSH
48962: EMPTY
48963: LIST
48964: LIST
48965: PUSH
48966: LD_INT 21
48968: PUSH
48969: LD_INT 1
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PPUSH
48980: CALL_OW 69
48984: ST_TO_ADDR
// if not tmp then
48985: LD_VAR 0 3
48989: NOT
48990: IFFALSE 48994
// exit ;
48992: GO 49141
// if tmp > 5 then
48994: LD_VAR 0 3
48998: PUSH
48999: LD_INT 5
49001: GREATER
49002: IFFALSE 49014
// k := 5 else
49004: LD_ADDR_VAR 0 2
49008: PUSH
49009: LD_INT 5
49011: ST_TO_ADDR
49012: GO 49024
// k := tmp ;
49014: LD_ADDR_VAR 0 2
49018: PUSH
49019: LD_VAR 0 3
49023: ST_TO_ADDR
// for i := 1 to k do
49024: LD_ADDR_VAR 0 1
49028: PUSH
49029: DOUBLE
49030: LD_INT 1
49032: DEC
49033: ST_TO_ADDR
49034: LD_VAR 0 2
49038: PUSH
49039: FOR_TO
49040: IFFALSE 49139
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49042: LD_VAR 0 3
49046: PUSH
49047: LD_VAR 0 1
49051: ARRAY
49052: PPUSH
49053: LD_VAR 0 1
49057: PUSH
49058: LD_INT 4
49060: MOD
49061: PUSH
49062: LD_INT 1
49064: PLUS
49065: PPUSH
49066: CALL_OW 259
49070: PUSH
49071: LD_INT 10
49073: LESS
49074: IFFALSE 49137
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49076: LD_VAR 0 3
49080: PUSH
49081: LD_VAR 0 1
49085: ARRAY
49086: PPUSH
49087: LD_VAR 0 1
49091: PUSH
49092: LD_INT 4
49094: MOD
49095: PUSH
49096: LD_INT 1
49098: PLUS
49099: PPUSH
49100: LD_VAR 0 3
49104: PUSH
49105: LD_VAR 0 1
49109: ARRAY
49110: PPUSH
49111: LD_VAR 0 1
49115: PUSH
49116: LD_INT 4
49118: MOD
49119: PUSH
49120: LD_INT 1
49122: PLUS
49123: PPUSH
49124: CALL_OW 259
49128: PUSH
49129: LD_INT 1
49131: PLUS
49132: PPUSH
49133: CALL_OW 237
49137: GO 49039
49139: POP
49140: POP
// end ;
49141: PPOPN 3
49143: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49144: LD_EXP 87
49148: PUSH
49149: LD_EXP 95
49153: AND
49154: IFFALSE 49174
49156: GO 49158
49158: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49159: LD_INT 4
49161: PPUSH
49162: LD_OWVAR 2
49166: PPUSH
49167: LD_INT 0
49169: PPUSH
49170: CALL_OW 324
49174: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49175: LD_EXP 87
49179: PUSH
49180: LD_EXP 124
49184: AND
49185: IFFALSE 49205
49187: GO 49189
49189: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49190: LD_INT 19
49192: PPUSH
49193: LD_OWVAR 2
49197: PPUSH
49198: LD_INT 0
49200: PPUSH
49201: CALL_OW 324
49205: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49206: LD_EXP 87
49210: PUSH
49211: LD_EXP 96
49215: AND
49216: IFFALSE 49318
49218: GO 49220
49220: DISABLE
49221: LD_INT 0
49223: PPUSH
49224: PPUSH
// begin enable ;
49225: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49226: LD_ADDR_VAR 0 2
49230: PUSH
49231: LD_INT 22
49233: PUSH
49234: LD_OWVAR 2
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: PUSH
49243: LD_INT 2
49245: PUSH
49246: LD_INT 34
49248: PUSH
49249: LD_INT 11
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: PUSH
49256: LD_INT 34
49258: PUSH
49259: LD_INT 30
49261: PUSH
49262: EMPTY
49263: LIST
49264: LIST
49265: PUSH
49266: EMPTY
49267: LIST
49268: LIST
49269: LIST
49270: PUSH
49271: EMPTY
49272: LIST
49273: LIST
49274: PPUSH
49275: CALL_OW 69
49279: ST_TO_ADDR
// if not tmp then
49280: LD_VAR 0 2
49284: NOT
49285: IFFALSE 49289
// exit ;
49287: GO 49318
// for i in tmp do
49289: LD_ADDR_VAR 0 1
49293: PUSH
49294: LD_VAR 0 2
49298: PUSH
49299: FOR_IN
49300: IFFALSE 49316
// begin SetLives ( i , 0 ) ;
49302: LD_VAR 0 1
49306: PPUSH
49307: LD_INT 0
49309: PPUSH
49310: CALL_OW 234
// end ;
49314: GO 49299
49316: POP
49317: POP
// end ;
49318: PPOPN 2
49320: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49321: LD_EXP 87
49325: PUSH
49326: LD_EXP 97
49330: AND
49331: IFFALSE 49351
49333: GO 49335
49335: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49336: LD_INT 32
49338: PPUSH
49339: LD_OWVAR 2
49343: PPUSH
49344: LD_INT 0
49346: PPUSH
49347: CALL_OW 324
49351: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49352: LD_EXP 87
49356: PUSH
49357: LD_EXP 98
49361: AND
49362: IFFALSE 49543
49364: GO 49366
49366: DISABLE
49367: LD_INT 0
49369: PPUSH
49370: PPUSH
49371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49372: LD_ADDR_VAR 0 2
49376: PUSH
49377: LD_INT 22
49379: PUSH
49380: LD_OWVAR 2
49384: PUSH
49385: EMPTY
49386: LIST
49387: LIST
49388: PUSH
49389: LD_INT 33
49391: PUSH
49392: LD_INT 3
49394: PUSH
49395: EMPTY
49396: LIST
49397: LIST
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PPUSH
49403: CALL_OW 69
49407: ST_TO_ADDR
// if not tmp then
49408: LD_VAR 0 2
49412: NOT
49413: IFFALSE 49417
// exit ;
49415: GO 49543
// side := 0 ;
49417: LD_ADDR_VAR 0 3
49421: PUSH
49422: LD_INT 0
49424: ST_TO_ADDR
// for i := 1 to 8 do
49425: LD_ADDR_VAR 0 1
49429: PUSH
49430: DOUBLE
49431: LD_INT 1
49433: DEC
49434: ST_TO_ADDR
49435: LD_INT 8
49437: PUSH
49438: FOR_TO
49439: IFFALSE 49487
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49441: LD_OWVAR 2
49445: PUSH
49446: LD_VAR 0 1
49450: NONEQUAL
49451: PUSH
49452: LD_OWVAR 2
49456: PPUSH
49457: LD_VAR 0 1
49461: PPUSH
49462: CALL_OW 81
49466: PUSH
49467: LD_INT 2
49469: EQUAL
49470: AND
49471: IFFALSE 49485
// begin side := i ;
49473: LD_ADDR_VAR 0 3
49477: PUSH
49478: LD_VAR 0 1
49482: ST_TO_ADDR
// break ;
49483: GO 49487
// end ;
49485: GO 49438
49487: POP
49488: POP
// if not side then
49489: LD_VAR 0 3
49493: NOT
49494: IFFALSE 49498
// exit ;
49496: GO 49543
// for i := 1 to tmp do
49498: LD_ADDR_VAR 0 1
49502: PUSH
49503: DOUBLE
49504: LD_INT 1
49506: DEC
49507: ST_TO_ADDR
49508: LD_VAR 0 2
49512: PUSH
49513: FOR_TO
49514: IFFALSE 49541
// if Prob ( 60 ) then
49516: LD_INT 60
49518: PPUSH
49519: CALL_OW 13
49523: IFFALSE 49539
// SetSide ( i , side ) ;
49525: LD_VAR 0 1
49529: PPUSH
49530: LD_VAR 0 3
49534: PPUSH
49535: CALL_OW 235
49539: GO 49513
49541: POP
49542: POP
// end ;
49543: PPOPN 3
49545: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49546: LD_EXP 87
49550: PUSH
49551: LD_EXP 100
49555: AND
49556: IFFALSE 49675
49558: GO 49560
49560: DISABLE
49561: LD_INT 0
49563: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49564: LD_ADDR_VAR 0 1
49568: PUSH
49569: LD_INT 22
49571: PUSH
49572: LD_OWVAR 2
49576: PUSH
49577: EMPTY
49578: LIST
49579: LIST
49580: PUSH
49581: LD_INT 21
49583: PUSH
49584: LD_INT 1
49586: PUSH
49587: EMPTY
49588: LIST
49589: LIST
49590: PUSH
49591: LD_INT 3
49593: PUSH
49594: LD_INT 23
49596: PUSH
49597: LD_INT 0
49599: PUSH
49600: EMPTY
49601: LIST
49602: LIST
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: LIST
49612: PPUSH
49613: CALL_OW 69
49617: PUSH
49618: FOR_IN
49619: IFFALSE 49673
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49621: LD_VAR 0 1
49625: PPUSH
49626: CALL_OW 257
49630: PUSH
49631: LD_INT 1
49633: PUSH
49634: LD_INT 2
49636: PUSH
49637: LD_INT 3
49639: PUSH
49640: LD_INT 4
49642: PUSH
49643: EMPTY
49644: LIST
49645: LIST
49646: LIST
49647: LIST
49648: IN
49649: IFFALSE 49671
// SetClass ( un , rand ( 1 , 4 ) ) ;
49651: LD_VAR 0 1
49655: PPUSH
49656: LD_INT 1
49658: PPUSH
49659: LD_INT 4
49661: PPUSH
49662: CALL_OW 12
49666: PPUSH
49667: CALL_OW 336
49671: GO 49618
49673: POP
49674: POP
// end ;
49675: PPOPN 1
49677: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49678: LD_EXP 87
49682: PUSH
49683: LD_EXP 99
49687: AND
49688: IFFALSE 49767
49690: GO 49692
49692: DISABLE
49693: LD_INT 0
49695: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49696: LD_ADDR_VAR 0 1
49700: PUSH
49701: LD_INT 22
49703: PUSH
49704: LD_OWVAR 2
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PUSH
49713: LD_INT 21
49715: PUSH
49716: LD_INT 3
49718: PUSH
49719: EMPTY
49720: LIST
49721: LIST
49722: PUSH
49723: EMPTY
49724: LIST
49725: LIST
49726: PPUSH
49727: CALL_OW 69
49731: ST_TO_ADDR
// if not tmp then
49732: LD_VAR 0 1
49736: NOT
49737: IFFALSE 49741
// exit ;
49739: GO 49767
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49741: LD_VAR 0 1
49745: PUSH
49746: LD_INT 1
49748: PPUSH
49749: LD_VAR 0 1
49753: PPUSH
49754: CALL_OW 12
49758: ARRAY
49759: PPUSH
49760: LD_INT 100
49762: PPUSH
49763: CALL_OW 234
// end ;
49767: PPOPN 1
49769: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49770: LD_EXP 87
49774: PUSH
49775: LD_EXP 101
49779: AND
49780: IFFALSE 49878
49782: GO 49784
49784: DISABLE
49785: LD_INT 0
49787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49788: LD_ADDR_VAR 0 1
49792: PUSH
49793: LD_INT 22
49795: PUSH
49796: LD_OWVAR 2
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 21
49807: PUSH
49808: LD_INT 1
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: EMPTY
49816: LIST
49817: LIST
49818: PPUSH
49819: CALL_OW 69
49823: ST_TO_ADDR
// if not tmp then
49824: LD_VAR 0 1
49828: NOT
49829: IFFALSE 49833
// exit ;
49831: GO 49878
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49833: LD_VAR 0 1
49837: PUSH
49838: LD_INT 1
49840: PPUSH
49841: LD_VAR 0 1
49845: PPUSH
49846: CALL_OW 12
49850: ARRAY
49851: PPUSH
49852: LD_INT 1
49854: PPUSH
49855: LD_INT 4
49857: PPUSH
49858: CALL_OW 12
49862: PPUSH
49863: LD_INT 3000
49865: PPUSH
49866: LD_INT 9000
49868: PPUSH
49869: CALL_OW 12
49873: PPUSH
49874: CALL_OW 492
// end ;
49878: PPOPN 1
49880: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49881: LD_EXP 87
49885: PUSH
49886: LD_EXP 102
49890: AND
49891: IFFALSE 49911
49893: GO 49895
49895: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49896: LD_INT 1
49898: PPUSH
49899: LD_OWVAR 2
49903: PPUSH
49904: LD_INT 0
49906: PPUSH
49907: CALL_OW 324
49911: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49912: LD_EXP 87
49916: PUSH
49917: LD_EXP 103
49921: AND
49922: IFFALSE 50005
49924: GO 49926
49926: DISABLE
49927: LD_INT 0
49929: PPUSH
49930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49931: LD_ADDR_VAR 0 2
49935: PUSH
49936: LD_INT 22
49938: PUSH
49939: LD_OWVAR 2
49943: PUSH
49944: EMPTY
49945: LIST
49946: LIST
49947: PUSH
49948: LD_INT 21
49950: PUSH
49951: LD_INT 3
49953: PUSH
49954: EMPTY
49955: LIST
49956: LIST
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: PPUSH
49962: CALL_OW 69
49966: ST_TO_ADDR
// if not tmp then
49967: LD_VAR 0 2
49971: NOT
49972: IFFALSE 49976
// exit ;
49974: GO 50005
// for i in tmp do
49976: LD_ADDR_VAR 0 1
49980: PUSH
49981: LD_VAR 0 2
49985: PUSH
49986: FOR_IN
49987: IFFALSE 50003
// SetBLevel ( i , 10 ) ;
49989: LD_VAR 0 1
49993: PPUSH
49994: LD_INT 10
49996: PPUSH
49997: CALL_OW 241
50001: GO 49986
50003: POP
50004: POP
// end ;
50005: PPOPN 2
50007: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50008: LD_EXP 87
50012: PUSH
50013: LD_EXP 104
50017: AND
50018: IFFALSE 50129
50020: GO 50022
50022: DISABLE
50023: LD_INT 0
50025: PPUSH
50026: PPUSH
50027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50028: LD_ADDR_VAR 0 3
50032: PUSH
50033: LD_INT 22
50035: PUSH
50036: LD_OWVAR 2
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: PUSH
50045: LD_INT 25
50047: PUSH
50048: LD_INT 1
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PPUSH
50059: CALL_OW 69
50063: ST_TO_ADDR
// if not tmp then
50064: LD_VAR 0 3
50068: NOT
50069: IFFALSE 50073
// exit ;
50071: GO 50129
// un := tmp [ rand ( 1 , tmp ) ] ;
50073: LD_ADDR_VAR 0 2
50077: PUSH
50078: LD_VAR 0 3
50082: PUSH
50083: LD_INT 1
50085: PPUSH
50086: LD_VAR 0 3
50090: PPUSH
50091: CALL_OW 12
50095: ARRAY
50096: ST_TO_ADDR
// if Crawls ( un ) then
50097: LD_VAR 0 2
50101: PPUSH
50102: CALL_OW 318
50106: IFFALSE 50117
// ComWalk ( un ) ;
50108: LD_VAR 0 2
50112: PPUSH
50113: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50117: LD_VAR 0 2
50121: PPUSH
50122: LD_INT 5
50124: PPUSH
50125: CALL_OW 336
// end ;
50129: PPOPN 3
50131: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
50132: LD_EXP 87
50136: PUSH
50137: LD_EXP 105
50141: AND
50142: PUSH
50143: LD_OWVAR 67
50147: PUSH
50148: LD_INT 3
50150: LESS
50151: AND
50152: IFFALSE 50171
50154: GO 50156
50156: DISABLE
// Difficulty := Difficulty + 1 ;
50157: LD_ADDR_OWVAR 67
50161: PUSH
50162: LD_OWVAR 67
50166: PUSH
50167: LD_INT 1
50169: PLUS
50170: ST_TO_ADDR
50171: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50172: LD_EXP 87
50176: PUSH
50177: LD_EXP 106
50181: AND
50182: IFFALSE 50285
50184: GO 50186
50186: DISABLE
50187: LD_INT 0
50189: PPUSH
// begin for i := 1 to 5 do
50190: LD_ADDR_VAR 0 1
50194: PUSH
50195: DOUBLE
50196: LD_INT 1
50198: DEC
50199: ST_TO_ADDR
50200: LD_INT 5
50202: PUSH
50203: FOR_TO
50204: IFFALSE 50283
// begin uc_nation := nation_nature ;
50206: LD_ADDR_OWVAR 21
50210: PUSH
50211: LD_INT 0
50213: ST_TO_ADDR
// uc_side := 0 ;
50214: LD_ADDR_OWVAR 20
50218: PUSH
50219: LD_INT 0
50221: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50222: LD_ADDR_OWVAR 29
50226: PUSH
50227: LD_INT 12
50229: PUSH
50230: LD_INT 12
50232: PUSH
50233: EMPTY
50234: LIST
50235: LIST
50236: ST_TO_ADDR
// hc_agressivity := 20 ;
50237: LD_ADDR_OWVAR 35
50241: PUSH
50242: LD_INT 20
50244: ST_TO_ADDR
// hc_class := class_tiger ;
50245: LD_ADDR_OWVAR 28
50249: PUSH
50250: LD_INT 14
50252: ST_TO_ADDR
// hc_gallery :=  ;
50253: LD_ADDR_OWVAR 33
50257: PUSH
50258: LD_STRING 
50260: ST_TO_ADDR
// hc_name :=  ;
50261: LD_ADDR_OWVAR 26
50265: PUSH
50266: LD_STRING 
50268: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50269: CALL_OW 44
50273: PPUSH
50274: LD_INT 0
50276: PPUSH
50277: CALL_OW 51
// end ;
50281: GO 50203
50283: POP
50284: POP
// end ;
50285: PPOPN 1
50287: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50288: LD_EXP 87
50292: PUSH
50293: LD_EXP 107
50297: AND
50298: IFFALSE 50307
50300: GO 50302
50302: DISABLE
// StreamSibBomb ;
50303: CALL 50308 0 0
50307: END
// export function StreamSibBomb ; var i , x , y ; begin
50308: LD_INT 0
50310: PPUSH
50311: PPUSH
50312: PPUSH
50313: PPUSH
// result := false ;
50314: LD_ADDR_VAR 0 1
50318: PUSH
50319: LD_INT 0
50321: ST_TO_ADDR
// for i := 1 to 16 do
50322: LD_ADDR_VAR 0 2
50326: PUSH
50327: DOUBLE
50328: LD_INT 1
50330: DEC
50331: ST_TO_ADDR
50332: LD_INT 16
50334: PUSH
50335: FOR_TO
50336: IFFALSE 50535
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50338: LD_ADDR_VAR 0 3
50342: PUSH
50343: LD_INT 10
50345: PUSH
50346: LD_INT 20
50348: PUSH
50349: LD_INT 30
50351: PUSH
50352: LD_INT 40
50354: PUSH
50355: LD_INT 50
50357: PUSH
50358: LD_INT 60
50360: PUSH
50361: LD_INT 70
50363: PUSH
50364: LD_INT 80
50366: PUSH
50367: LD_INT 90
50369: PUSH
50370: LD_INT 100
50372: PUSH
50373: LD_INT 110
50375: PUSH
50376: LD_INT 120
50378: PUSH
50379: LD_INT 130
50381: PUSH
50382: LD_INT 140
50384: PUSH
50385: LD_INT 150
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: PUSH
50405: LD_INT 1
50407: PPUSH
50408: LD_INT 15
50410: PPUSH
50411: CALL_OW 12
50415: ARRAY
50416: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50417: LD_ADDR_VAR 0 4
50421: PUSH
50422: LD_INT 10
50424: PUSH
50425: LD_INT 20
50427: PUSH
50428: LD_INT 30
50430: PUSH
50431: LD_INT 40
50433: PUSH
50434: LD_INT 50
50436: PUSH
50437: LD_INT 60
50439: PUSH
50440: LD_INT 70
50442: PUSH
50443: LD_INT 80
50445: PUSH
50446: LD_INT 90
50448: PUSH
50449: LD_INT 100
50451: PUSH
50452: LD_INT 110
50454: PUSH
50455: LD_INT 120
50457: PUSH
50458: LD_INT 130
50460: PUSH
50461: LD_INT 140
50463: PUSH
50464: LD_INT 150
50466: PUSH
50467: EMPTY
50468: LIST
50469: LIST
50470: LIST
50471: LIST
50472: LIST
50473: LIST
50474: LIST
50475: LIST
50476: LIST
50477: LIST
50478: LIST
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: PUSH
50484: LD_INT 1
50486: PPUSH
50487: LD_INT 15
50489: PPUSH
50490: CALL_OW 12
50494: ARRAY
50495: ST_TO_ADDR
// if ValidHex ( x , y ) then
50496: LD_VAR 0 3
50500: PPUSH
50501: LD_VAR 0 4
50505: PPUSH
50506: CALL_OW 488
50510: IFFALSE 50533
// begin result := [ x , y ] ;
50512: LD_ADDR_VAR 0 1
50516: PUSH
50517: LD_VAR 0 3
50521: PUSH
50522: LD_VAR 0 4
50526: PUSH
50527: EMPTY
50528: LIST
50529: LIST
50530: ST_TO_ADDR
// break ;
50531: GO 50535
// end ; end ;
50533: GO 50335
50535: POP
50536: POP
// if result then
50537: LD_VAR 0 1
50541: IFFALSE 50601
// begin ToLua ( playSibBomb() ) ;
50543: LD_STRING playSibBomb()
50545: PPUSH
50546: CALL_OW 559
// wait ( 0 0$14 ) ;
50550: LD_INT 490
50552: PPUSH
50553: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50557: LD_VAR 0 1
50561: PUSH
50562: LD_INT 1
50564: ARRAY
50565: PPUSH
50566: LD_VAR 0 1
50570: PUSH
50571: LD_INT 2
50573: ARRAY
50574: PPUSH
50575: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50579: LD_VAR 0 1
50583: PUSH
50584: LD_INT 1
50586: ARRAY
50587: PPUSH
50588: LD_VAR 0 1
50592: PUSH
50593: LD_INT 2
50595: ARRAY
50596: PPUSH
50597: CALL_OW 429
// end ; end ;
50601: LD_VAR 0 1
50605: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50606: LD_EXP 87
50610: PUSH
50611: LD_EXP 109
50615: AND
50616: IFFALSE 50628
50618: GO 50620
50620: DISABLE
// YouLost (  ) ;
50621: LD_STRING 
50623: PPUSH
50624: CALL_OW 104
50628: END
// every 0 0$1 trigger StreamModeActive and sFog do
50629: LD_EXP 87
50633: PUSH
50634: LD_EXP 108
50638: AND
50639: IFFALSE 50653
50641: GO 50643
50643: DISABLE
// FogOff ( your_side ) ;
50644: LD_OWVAR 2
50648: PPUSH
50649: CALL_OW 344
50653: END
// every 0 0$1 trigger StreamModeActive and sSun do
50654: LD_EXP 87
50658: PUSH
50659: LD_EXP 110
50663: AND
50664: IFFALSE 50692
50666: GO 50668
50668: DISABLE
// begin solar_recharge_percent := 0 ;
50669: LD_ADDR_OWVAR 79
50673: PUSH
50674: LD_INT 0
50676: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50677: LD_INT 10500
50679: PPUSH
50680: CALL_OW 67
// solar_recharge_percent := 100 ;
50684: LD_ADDR_OWVAR 79
50688: PUSH
50689: LD_INT 100
50691: ST_TO_ADDR
// end ;
50692: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50693: LD_EXP 87
50697: PUSH
50698: LD_EXP 111
50702: AND
50703: IFFALSE 50942
50705: GO 50707
50707: DISABLE
50708: LD_INT 0
50710: PPUSH
50711: PPUSH
50712: PPUSH
// begin tmp := [ ] ;
50713: LD_ADDR_VAR 0 3
50717: PUSH
50718: EMPTY
50719: ST_TO_ADDR
// for i := 1 to 6 do
50720: LD_ADDR_VAR 0 1
50724: PUSH
50725: DOUBLE
50726: LD_INT 1
50728: DEC
50729: ST_TO_ADDR
50730: LD_INT 6
50732: PUSH
50733: FOR_TO
50734: IFFALSE 50839
// begin uc_nation := nation_nature ;
50736: LD_ADDR_OWVAR 21
50740: PUSH
50741: LD_INT 0
50743: ST_TO_ADDR
// uc_side := 0 ;
50744: LD_ADDR_OWVAR 20
50748: PUSH
50749: LD_INT 0
50751: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50752: LD_ADDR_OWVAR 29
50756: PUSH
50757: LD_INT 12
50759: PUSH
50760: LD_INT 12
50762: PUSH
50763: EMPTY
50764: LIST
50765: LIST
50766: ST_TO_ADDR
// hc_agressivity := 20 ;
50767: LD_ADDR_OWVAR 35
50771: PUSH
50772: LD_INT 20
50774: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50775: LD_ADDR_OWVAR 28
50779: PUSH
50780: LD_INT 17
50782: ST_TO_ADDR
// hc_gallery :=  ;
50783: LD_ADDR_OWVAR 33
50787: PUSH
50788: LD_STRING 
50790: ST_TO_ADDR
// hc_name :=  ;
50791: LD_ADDR_OWVAR 26
50795: PUSH
50796: LD_STRING 
50798: ST_TO_ADDR
// un := CreateHuman ;
50799: LD_ADDR_VAR 0 2
50803: PUSH
50804: CALL_OW 44
50808: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50809: LD_VAR 0 2
50813: PPUSH
50814: LD_INT 1
50816: PPUSH
50817: CALL_OW 51
// tmp := tmp ^ un ;
50821: LD_ADDR_VAR 0 3
50825: PUSH
50826: LD_VAR 0 3
50830: PUSH
50831: LD_VAR 0 2
50835: ADD
50836: ST_TO_ADDR
// end ;
50837: GO 50733
50839: POP
50840: POP
// repeat wait ( 0 0$1 ) ;
50841: LD_INT 35
50843: PPUSH
50844: CALL_OW 67
// for un in tmp do
50848: LD_ADDR_VAR 0 2
50852: PUSH
50853: LD_VAR 0 3
50857: PUSH
50858: FOR_IN
50859: IFFALSE 50933
// begin if IsDead ( un ) then
50861: LD_VAR 0 2
50865: PPUSH
50866: CALL_OW 301
50870: IFFALSE 50890
// begin tmp := tmp diff un ;
50872: LD_ADDR_VAR 0 3
50876: PUSH
50877: LD_VAR 0 3
50881: PUSH
50882: LD_VAR 0 2
50886: DIFF
50887: ST_TO_ADDR
// continue ;
50888: GO 50858
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50890: LD_VAR 0 2
50894: PPUSH
50895: LD_INT 3
50897: PUSH
50898: LD_INT 22
50900: PUSH
50901: LD_INT 0
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: PUSH
50908: EMPTY
50909: LIST
50910: LIST
50911: PPUSH
50912: CALL_OW 69
50916: PPUSH
50917: LD_VAR 0 2
50921: PPUSH
50922: CALL_OW 74
50926: PPUSH
50927: CALL_OW 115
// end ;
50931: GO 50858
50933: POP
50934: POP
// until not tmp ;
50935: LD_VAR 0 3
50939: NOT
50940: IFFALSE 50841
// end ;
50942: PPOPN 3
50944: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50945: LD_EXP 87
50949: PUSH
50950: LD_EXP 112
50954: AND
50955: IFFALSE 51009
50957: GO 50959
50959: DISABLE
// begin ToLua ( displayTroll(); ) ;
50960: LD_STRING displayTroll();
50962: PPUSH
50963: CALL_OW 559
// wait ( 3 3$00 ) ;
50967: LD_INT 6300
50969: PPUSH
50970: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50974: LD_STRING hideTroll();
50976: PPUSH
50977: CALL_OW 559
// wait ( 1 1$00 ) ;
50981: LD_INT 2100
50983: PPUSH
50984: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50988: LD_STRING displayTroll();
50990: PPUSH
50991: CALL_OW 559
// wait ( 1 1$00 ) ;
50995: LD_INT 2100
50997: PPUSH
50998: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51002: LD_STRING hideTroll();
51004: PPUSH
51005: CALL_OW 559
// end ;
51009: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51010: LD_EXP 87
51014: PUSH
51015: LD_EXP 113
51019: AND
51020: IFFALSE 51083
51022: GO 51024
51024: DISABLE
51025: LD_INT 0
51027: PPUSH
// begin p := 0 ;
51028: LD_ADDR_VAR 0 1
51032: PUSH
51033: LD_INT 0
51035: ST_TO_ADDR
// repeat game_speed := 1 ;
51036: LD_ADDR_OWVAR 65
51040: PUSH
51041: LD_INT 1
51043: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51044: LD_INT 35
51046: PPUSH
51047: CALL_OW 67
// p := p + 1 ;
51051: LD_ADDR_VAR 0 1
51055: PUSH
51056: LD_VAR 0 1
51060: PUSH
51061: LD_INT 1
51063: PLUS
51064: ST_TO_ADDR
// until p >= 60 ;
51065: LD_VAR 0 1
51069: PUSH
51070: LD_INT 60
51072: GREATEREQUAL
51073: IFFALSE 51036
// game_speed := 4 ;
51075: LD_ADDR_OWVAR 65
51079: PUSH
51080: LD_INT 4
51082: ST_TO_ADDR
// end ;
51083: PPOPN 1
51085: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51086: LD_EXP 87
51090: PUSH
51091: LD_EXP 114
51095: AND
51096: IFFALSE 51242
51098: GO 51100
51100: DISABLE
51101: LD_INT 0
51103: PPUSH
51104: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51105: LD_ADDR_VAR 0 1
51109: PUSH
51110: LD_INT 22
51112: PUSH
51113: LD_OWVAR 2
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 2
51124: PUSH
51125: LD_INT 30
51127: PUSH
51128: LD_INT 0
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PUSH
51135: LD_INT 30
51137: PUSH
51138: LD_INT 1
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: LIST
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: PPUSH
51154: CALL_OW 69
51158: ST_TO_ADDR
// if not depot then
51159: LD_VAR 0 1
51163: NOT
51164: IFFALSE 51168
// exit ;
51166: GO 51242
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51168: LD_ADDR_VAR 0 2
51172: PUSH
51173: LD_VAR 0 1
51177: PUSH
51178: LD_INT 1
51180: PPUSH
51181: LD_VAR 0 1
51185: PPUSH
51186: CALL_OW 12
51190: ARRAY
51191: PPUSH
51192: CALL_OW 274
51196: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51197: LD_VAR 0 2
51201: PPUSH
51202: LD_INT 1
51204: PPUSH
51205: LD_INT 0
51207: PPUSH
51208: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51212: LD_VAR 0 2
51216: PPUSH
51217: LD_INT 2
51219: PPUSH
51220: LD_INT 0
51222: PPUSH
51223: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51227: LD_VAR 0 2
51231: PPUSH
51232: LD_INT 3
51234: PPUSH
51235: LD_INT 0
51237: PPUSH
51238: CALL_OW 277
// end ;
51242: PPOPN 2
51244: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51245: LD_EXP 87
51249: PUSH
51250: LD_EXP 115
51254: AND
51255: IFFALSE 51352
51257: GO 51259
51259: DISABLE
51260: LD_INT 0
51262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51263: LD_ADDR_VAR 0 1
51267: PUSH
51268: LD_INT 22
51270: PUSH
51271: LD_OWVAR 2
51275: PUSH
51276: EMPTY
51277: LIST
51278: LIST
51279: PUSH
51280: LD_INT 21
51282: PUSH
51283: LD_INT 1
51285: PUSH
51286: EMPTY
51287: LIST
51288: LIST
51289: PUSH
51290: LD_INT 3
51292: PUSH
51293: LD_INT 23
51295: PUSH
51296: LD_INT 0
51298: PUSH
51299: EMPTY
51300: LIST
51301: LIST
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: PUSH
51307: EMPTY
51308: LIST
51309: LIST
51310: LIST
51311: PPUSH
51312: CALL_OW 69
51316: ST_TO_ADDR
// if not tmp then
51317: LD_VAR 0 1
51321: NOT
51322: IFFALSE 51326
// exit ;
51324: GO 51352
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51326: LD_VAR 0 1
51330: PUSH
51331: LD_INT 1
51333: PPUSH
51334: LD_VAR 0 1
51338: PPUSH
51339: CALL_OW 12
51343: ARRAY
51344: PPUSH
51345: LD_INT 200
51347: PPUSH
51348: CALL_OW 234
// end ;
51352: PPOPN 1
51354: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51355: LD_EXP 87
51359: PUSH
51360: LD_EXP 116
51364: AND
51365: IFFALSE 51444
51367: GO 51369
51369: DISABLE
51370: LD_INT 0
51372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51373: LD_ADDR_VAR 0 1
51377: PUSH
51378: LD_INT 22
51380: PUSH
51381: LD_OWVAR 2
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 21
51392: PUSH
51393: LD_INT 2
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: EMPTY
51401: LIST
51402: LIST
51403: PPUSH
51404: CALL_OW 69
51408: ST_TO_ADDR
// if not tmp then
51409: LD_VAR 0 1
51413: NOT
51414: IFFALSE 51418
// exit ;
51416: GO 51444
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51418: LD_VAR 0 1
51422: PUSH
51423: LD_INT 1
51425: PPUSH
51426: LD_VAR 0 1
51430: PPUSH
51431: CALL_OW 12
51435: ARRAY
51436: PPUSH
51437: LD_INT 60
51439: PPUSH
51440: CALL_OW 234
// end ;
51444: PPOPN 1
51446: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51447: LD_EXP 87
51451: PUSH
51452: LD_EXP 117
51456: AND
51457: IFFALSE 51556
51459: GO 51461
51461: DISABLE
51462: LD_INT 0
51464: PPUSH
51465: PPUSH
// begin enable ;
51466: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51467: LD_ADDR_VAR 0 1
51471: PUSH
51472: LD_INT 22
51474: PUSH
51475: LD_OWVAR 2
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: PUSH
51484: LD_INT 61
51486: PUSH
51487: EMPTY
51488: LIST
51489: PUSH
51490: LD_INT 33
51492: PUSH
51493: LD_INT 2
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: PUSH
51500: EMPTY
51501: LIST
51502: LIST
51503: LIST
51504: PPUSH
51505: CALL_OW 69
51509: ST_TO_ADDR
// if not tmp then
51510: LD_VAR 0 1
51514: NOT
51515: IFFALSE 51519
// exit ;
51517: GO 51556
// for i in tmp do
51519: LD_ADDR_VAR 0 2
51523: PUSH
51524: LD_VAR 0 1
51528: PUSH
51529: FOR_IN
51530: IFFALSE 51554
// if IsControledBy ( i ) then
51532: LD_VAR 0 2
51536: PPUSH
51537: CALL_OW 312
51541: IFFALSE 51552
// ComUnlink ( i ) ;
51543: LD_VAR 0 2
51547: PPUSH
51548: CALL_OW 136
51552: GO 51529
51554: POP
51555: POP
// end ;
51556: PPOPN 2
51558: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51559: LD_EXP 87
51563: PUSH
51564: LD_EXP 118
51568: AND
51569: IFFALSE 51709
51571: GO 51573
51573: DISABLE
51574: LD_INT 0
51576: PPUSH
51577: PPUSH
// begin ToLua ( displayPowell(); ) ;
51578: LD_STRING displayPowell();
51580: PPUSH
51581: CALL_OW 559
// uc_side := 0 ;
51585: LD_ADDR_OWVAR 20
51589: PUSH
51590: LD_INT 0
51592: ST_TO_ADDR
// uc_nation := 2 ;
51593: LD_ADDR_OWVAR 21
51597: PUSH
51598: LD_INT 2
51600: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51601: LD_ADDR_OWVAR 37
51605: PUSH
51606: LD_INT 14
51608: ST_TO_ADDR
// vc_engine := engine_siberite ;
51609: LD_ADDR_OWVAR 39
51613: PUSH
51614: LD_INT 3
51616: ST_TO_ADDR
// vc_control := control_apeman ;
51617: LD_ADDR_OWVAR 38
51621: PUSH
51622: LD_INT 5
51624: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51625: LD_ADDR_OWVAR 40
51629: PUSH
51630: LD_INT 29
51632: ST_TO_ADDR
// un := CreateVehicle ;
51633: LD_ADDR_VAR 0 2
51637: PUSH
51638: CALL_OW 45
51642: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51643: LD_VAR 0 2
51647: PPUSH
51648: LD_INT 1
51650: PPUSH
51651: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51655: LD_INT 35
51657: PPUSH
51658: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51662: LD_VAR 0 2
51666: PPUSH
51667: LD_INT 22
51669: PUSH
51670: LD_OWVAR 2
51674: PUSH
51675: EMPTY
51676: LIST
51677: LIST
51678: PPUSH
51679: CALL_OW 69
51683: PPUSH
51684: LD_VAR 0 2
51688: PPUSH
51689: CALL_OW 74
51693: PPUSH
51694: CALL_OW 115
// until IsDead ( un ) ;
51698: LD_VAR 0 2
51702: PPUSH
51703: CALL_OW 301
51707: IFFALSE 51655
// end ;
51709: PPOPN 2
51711: END
// every 0 0$1 trigger StreamModeActive and sStu do
51712: LD_EXP 87
51716: PUSH
51717: LD_EXP 126
51721: AND
51722: IFFALSE 51738
51724: GO 51726
51726: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51727: LD_STRING displayStucuk();
51729: PPUSH
51730: CALL_OW 559
// ResetFog ;
51734: CALL_OW 335
// end ;
51738: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51739: LD_EXP 87
51743: PUSH
51744: LD_EXP 119
51748: AND
51749: IFFALSE 51890
51751: GO 51753
51753: DISABLE
51754: LD_INT 0
51756: PPUSH
51757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51758: LD_ADDR_VAR 0 2
51762: PUSH
51763: LD_INT 22
51765: PUSH
51766: LD_OWVAR 2
51770: PUSH
51771: EMPTY
51772: LIST
51773: LIST
51774: PUSH
51775: LD_INT 21
51777: PUSH
51778: LD_INT 1
51780: PUSH
51781: EMPTY
51782: LIST
51783: LIST
51784: PUSH
51785: EMPTY
51786: LIST
51787: LIST
51788: PPUSH
51789: CALL_OW 69
51793: ST_TO_ADDR
// if not tmp then
51794: LD_VAR 0 2
51798: NOT
51799: IFFALSE 51803
// exit ;
51801: GO 51890
// un := tmp [ rand ( 1 , tmp ) ] ;
51803: LD_ADDR_VAR 0 1
51807: PUSH
51808: LD_VAR 0 2
51812: PUSH
51813: LD_INT 1
51815: PPUSH
51816: LD_VAR 0 2
51820: PPUSH
51821: CALL_OW 12
51825: ARRAY
51826: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51827: LD_VAR 0 1
51831: PPUSH
51832: LD_INT 0
51834: PPUSH
51835: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51839: LD_VAR 0 1
51843: PPUSH
51844: LD_OWVAR 3
51848: PUSH
51849: LD_VAR 0 1
51853: DIFF
51854: PPUSH
51855: LD_VAR 0 1
51859: PPUSH
51860: CALL_OW 74
51864: PPUSH
51865: CALL_OW 115
// wait ( 0 0$20 ) ;
51869: LD_INT 700
51871: PPUSH
51872: CALL_OW 67
// SetSide ( un , your_side ) ;
51876: LD_VAR 0 1
51880: PPUSH
51881: LD_OWVAR 2
51885: PPUSH
51886: CALL_OW 235
// end ;
51890: PPOPN 2
51892: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51893: LD_EXP 87
51897: PUSH
51898: LD_EXP 120
51902: AND
51903: IFFALSE 52009
51905: GO 51907
51907: DISABLE
51908: LD_INT 0
51910: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51911: LD_ADDR_VAR 0 1
51915: PUSH
51916: LD_INT 22
51918: PUSH
51919: LD_OWVAR 2
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: PUSH
51928: LD_INT 2
51930: PUSH
51931: LD_INT 30
51933: PUSH
51934: LD_INT 0
51936: PUSH
51937: EMPTY
51938: LIST
51939: LIST
51940: PUSH
51941: LD_INT 30
51943: PUSH
51944: LD_INT 1
51946: PUSH
51947: EMPTY
51948: LIST
51949: LIST
51950: PUSH
51951: EMPTY
51952: LIST
51953: LIST
51954: LIST
51955: PUSH
51956: EMPTY
51957: LIST
51958: LIST
51959: PPUSH
51960: CALL_OW 69
51964: ST_TO_ADDR
// if not depot then
51965: LD_VAR 0 1
51969: NOT
51970: IFFALSE 51974
// exit ;
51972: GO 52009
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51974: LD_VAR 0 1
51978: PUSH
51979: LD_INT 1
51981: ARRAY
51982: PPUSH
51983: CALL_OW 250
51987: PPUSH
51988: LD_VAR 0 1
51992: PUSH
51993: LD_INT 1
51995: ARRAY
51996: PPUSH
51997: CALL_OW 251
52001: PPUSH
52002: LD_INT 70
52004: PPUSH
52005: CALL_OW 495
// end ;
52009: PPOPN 1
52011: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52012: LD_EXP 87
52016: PUSH
52017: LD_EXP 121
52021: AND
52022: IFFALSE 52233
52024: GO 52026
52026: DISABLE
52027: LD_INT 0
52029: PPUSH
52030: PPUSH
52031: PPUSH
52032: PPUSH
52033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52034: LD_ADDR_VAR 0 5
52038: PUSH
52039: LD_INT 22
52041: PUSH
52042: LD_OWVAR 2
52046: PUSH
52047: EMPTY
52048: LIST
52049: LIST
52050: PUSH
52051: LD_INT 21
52053: PUSH
52054: LD_INT 1
52056: PUSH
52057: EMPTY
52058: LIST
52059: LIST
52060: PUSH
52061: EMPTY
52062: LIST
52063: LIST
52064: PPUSH
52065: CALL_OW 69
52069: ST_TO_ADDR
// if not tmp then
52070: LD_VAR 0 5
52074: NOT
52075: IFFALSE 52079
// exit ;
52077: GO 52233
// for i in tmp do
52079: LD_ADDR_VAR 0 1
52083: PUSH
52084: LD_VAR 0 5
52088: PUSH
52089: FOR_IN
52090: IFFALSE 52231
// begin d := rand ( 0 , 5 ) ;
52092: LD_ADDR_VAR 0 4
52096: PUSH
52097: LD_INT 0
52099: PPUSH
52100: LD_INT 5
52102: PPUSH
52103: CALL_OW 12
52107: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52108: LD_ADDR_VAR 0 2
52112: PUSH
52113: LD_VAR 0 1
52117: PPUSH
52118: CALL_OW 250
52122: PPUSH
52123: LD_VAR 0 4
52127: PPUSH
52128: LD_INT 3
52130: PPUSH
52131: LD_INT 12
52133: PPUSH
52134: CALL_OW 12
52138: PPUSH
52139: CALL_OW 272
52143: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52144: LD_ADDR_VAR 0 3
52148: PUSH
52149: LD_VAR 0 1
52153: PPUSH
52154: CALL_OW 251
52158: PPUSH
52159: LD_VAR 0 4
52163: PPUSH
52164: LD_INT 3
52166: PPUSH
52167: LD_INT 12
52169: PPUSH
52170: CALL_OW 12
52174: PPUSH
52175: CALL_OW 273
52179: ST_TO_ADDR
// if ValidHex ( x , y ) then
52180: LD_VAR 0 2
52184: PPUSH
52185: LD_VAR 0 3
52189: PPUSH
52190: CALL_OW 488
52194: IFFALSE 52229
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52196: LD_VAR 0 1
52200: PPUSH
52201: LD_VAR 0 2
52205: PPUSH
52206: LD_VAR 0 3
52210: PPUSH
52211: LD_INT 3
52213: PPUSH
52214: LD_INT 6
52216: PPUSH
52217: CALL_OW 12
52221: PPUSH
52222: LD_INT 1
52224: PPUSH
52225: CALL_OW 483
// end ;
52229: GO 52089
52231: POP
52232: POP
// end ;
52233: PPOPN 5
52235: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52236: LD_EXP 87
52240: PUSH
52241: LD_EXP 122
52245: AND
52246: IFFALSE 52340
52248: GO 52250
52250: DISABLE
52251: LD_INT 0
52253: PPUSH
52254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52255: LD_ADDR_VAR 0 2
52259: PUSH
52260: LD_INT 22
52262: PUSH
52263: LD_OWVAR 2
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: PUSH
52272: LD_INT 32
52274: PUSH
52275: LD_INT 1
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: PUSH
52282: LD_INT 21
52284: PUSH
52285: LD_INT 2
52287: PUSH
52288: EMPTY
52289: LIST
52290: LIST
52291: PUSH
52292: EMPTY
52293: LIST
52294: LIST
52295: LIST
52296: PPUSH
52297: CALL_OW 69
52301: ST_TO_ADDR
// if not tmp then
52302: LD_VAR 0 2
52306: NOT
52307: IFFALSE 52311
// exit ;
52309: GO 52340
// for i in tmp do
52311: LD_ADDR_VAR 0 1
52315: PUSH
52316: LD_VAR 0 2
52320: PUSH
52321: FOR_IN
52322: IFFALSE 52338
// SetFuel ( i , 0 ) ;
52324: LD_VAR 0 1
52328: PPUSH
52329: LD_INT 0
52331: PPUSH
52332: CALL_OW 240
52336: GO 52321
52338: POP
52339: POP
// end ;
52340: PPOPN 2
52342: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52343: LD_EXP 87
52347: PUSH
52348: LD_EXP 123
52352: AND
52353: IFFALSE 52419
52355: GO 52357
52357: DISABLE
52358: LD_INT 0
52360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52361: LD_ADDR_VAR 0 1
52365: PUSH
52366: LD_INT 22
52368: PUSH
52369: LD_OWVAR 2
52373: PUSH
52374: EMPTY
52375: LIST
52376: LIST
52377: PUSH
52378: LD_INT 30
52380: PUSH
52381: LD_INT 29
52383: PUSH
52384: EMPTY
52385: LIST
52386: LIST
52387: PUSH
52388: EMPTY
52389: LIST
52390: LIST
52391: PPUSH
52392: CALL_OW 69
52396: ST_TO_ADDR
// if not tmp then
52397: LD_VAR 0 1
52401: NOT
52402: IFFALSE 52406
// exit ;
52404: GO 52419
// DestroyUnit ( tmp [ 1 ] ) ;
52406: LD_VAR 0 1
52410: PUSH
52411: LD_INT 1
52413: ARRAY
52414: PPUSH
52415: CALL_OW 65
// end ;
52419: PPOPN 1
52421: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52422: LD_EXP 87
52426: PUSH
52427: LD_EXP 125
52431: AND
52432: IFFALSE 52561
52434: GO 52436
52436: DISABLE
52437: LD_INT 0
52439: PPUSH
// begin uc_side := 0 ;
52440: LD_ADDR_OWVAR 20
52444: PUSH
52445: LD_INT 0
52447: ST_TO_ADDR
// uc_nation := nation_arabian ;
52448: LD_ADDR_OWVAR 21
52452: PUSH
52453: LD_INT 2
52455: ST_TO_ADDR
// hc_gallery :=  ;
52456: LD_ADDR_OWVAR 33
52460: PUSH
52461: LD_STRING 
52463: ST_TO_ADDR
// hc_name :=  ;
52464: LD_ADDR_OWVAR 26
52468: PUSH
52469: LD_STRING 
52471: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52472: LD_INT 1
52474: PPUSH
52475: LD_INT 11
52477: PPUSH
52478: LD_INT 10
52480: PPUSH
52481: CALL_OW 380
// un := CreateHuman ;
52485: LD_ADDR_VAR 0 1
52489: PUSH
52490: CALL_OW 44
52494: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52495: LD_VAR 0 1
52499: PPUSH
52500: LD_INT 1
52502: PPUSH
52503: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52507: LD_INT 35
52509: PPUSH
52510: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52514: LD_VAR 0 1
52518: PPUSH
52519: LD_INT 22
52521: PUSH
52522: LD_OWVAR 2
52526: PUSH
52527: EMPTY
52528: LIST
52529: LIST
52530: PPUSH
52531: CALL_OW 69
52535: PPUSH
52536: LD_VAR 0 1
52540: PPUSH
52541: CALL_OW 74
52545: PPUSH
52546: CALL_OW 115
// until IsDead ( un ) ;
52550: LD_VAR 0 1
52554: PPUSH
52555: CALL_OW 301
52559: IFFALSE 52507
// end ;
52561: PPOPN 1
52563: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52564: LD_EXP 87
52568: PUSH
52569: LD_EXP 127
52573: AND
52574: IFFALSE 52586
52576: GO 52578
52578: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52579: LD_STRING earthquake(getX(game), 0, 32)
52581: PPUSH
52582: CALL_OW 559
52586: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52587: LD_EXP 87
52591: PUSH
52592: LD_EXP 128
52596: AND
52597: IFFALSE 52688
52599: GO 52601
52601: DISABLE
52602: LD_INT 0
52604: PPUSH
// begin enable ;
52605: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52606: LD_ADDR_VAR 0 1
52610: PUSH
52611: LD_INT 22
52613: PUSH
52614: LD_OWVAR 2
52618: PUSH
52619: EMPTY
52620: LIST
52621: LIST
52622: PUSH
52623: LD_INT 21
52625: PUSH
52626: LD_INT 2
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PUSH
52633: LD_INT 33
52635: PUSH
52636: LD_INT 3
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: PUSH
52643: EMPTY
52644: LIST
52645: LIST
52646: LIST
52647: PPUSH
52648: CALL_OW 69
52652: ST_TO_ADDR
// if not tmp then
52653: LD_VAR 0 1
52657: NOT
52658: IFFALSE 52662
// exit ;
52660: GO 52688
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52662: LD_VAR 0 1
52666: PUSH
52667: LD_INT 1
52669: PPUSH
52670: LD_VAR 0 1
52674: PPUSH
52675: CALL_OW 12
52679: ARRAY
52680: PPUSH
52681: LD_INT 1
52683: PPUSH
52684: CALL_OW 234
// end ;
52688: PPOPN 1
52690: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52691: LD_EXP 87
52695: PUSH
52696: LD_EXP 129
52700: AND
52701: IFFALSE 52842
52703: GO 52705
52705: DISABLE
52706: LD_INT 0
52708: PPUSH
52709: PPUSH
52710: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52711: LD_ADDR_VAR 0 3
52715: PUSH
52716: LD_INT 22
52718: PUSH
52719: LD_OWVAR 2
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PUSH
52728: LD_INT 25
52730: PUSH
52731: LD_INT 1
52733: PUSH
52734: EMPTY
52735: LIST
52736: LIST
52737: PUSH
52738: EMPTY
52739: LIST
52740: LIST
52741: PPUSH
52742: CALL_OW 69
52746: ST_TO_ADDR
// if not tmp then
52747: LD_VAR 0 3
52751: NOT
52752: IFFALSE 52756
// exit ;
52754: GO 52842
// un := tmp [ rand ( 1 , tmp ) ] ;
52756: LD_ADDR_VAR 0 2
52760: PUSH
52761: LD_VAR 0 3
52765: PUSH
52766: LD_INT 1
52768: PPUSH
52769: LD_VAR 0 3
52773: PPUSH
52774: CALL_OW 12
52778: ARRAY
52779: ST_TO_ADDR
// if Crawls ( un ) then
52780: LD_VAR 0 2
52784: PPUSH
52785: CALL_OW 318
52789: IFFALSE 52800
// ComWalk ( un ) ;
52791: LD_VAR 0 2
52795: PPUSH
52796: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52800: LD_VAR 0 2
52804: PPUSH
52805: LD_INT 9
52807: PPUSH
52808: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52812: LD_INT 28
52814: PPUSH
52815: LD_OWVAR 2
52819: PPUSH
52820: LD_INT 2
52822: PPUSH
52823: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52827: LD_INT 29
52829: PPUSH
52830: LD_OWVAR 2
52834: PPUSH
52835: LD_INT 2
52837: PPUSH
52838: CALL_OW 322
// end ;
52842: PPOPN 3
52844: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52845: LD_EXP 87
52849: PUSH
52850: LD_EXP 130
52854: AND
52855: IFFALSE 52966
52857: GO 52859
52859: DISABLE
52860: LD_INT 0
52862: PPUSH
52863: PPUSH
52864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52865: LD_ADDR_VAR 0 3
52869: PUSH
52870: LD_INT 22
52872: PUSH
52873: LD_OWVAR 2
52877: PUSH
52878: EMPTY
52879: LIST
52880: LIST
52881: PUSH
52882: LD_INT 25
52884: PUSH
52885: LD_INT 1
52887: PUSH
52888: EMPTY
52889: LIST
52890: LIST
52891: PUSH
52892: EMPTY
52893: LIST
52894: LIST
52895: PPUSH
52896: CALL_OW 69
52900: ST_TO_ADDR
// if not tmp then
52901: LD_VAR 0 3
52905: NOT
52906: IFFALSE 52910
// exit ;
52908: GO 52966
// un := tmp [ rand ( 1 , tmp ) ] ;
52910: LD_ADDR_VAR 0 2
52914: PUSH
52915: LD_VAR 0 3
52919: PUSH
52920: LD_INT 1
52922: PPUSH
52923: LD_VAR 0 3
52927: PPUSH
52928: CALL_OW 12
52932: ARRAY
52933: ST_TO_ADDR
// if Crawls ( un ) then
52934: LD_VAR 0 2
52938: PPUSH
52939: CALL_OW 318
52943: IFFALSE 52954
// ComWalk ( un ) ;
52945: LD_VAR 0 2
52949: PPUSH
52950: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52954: LD_VAR 0 2
52958: PPUSH
52959: LD_INT 8
52961: PPUSH
52962: CALL_OW 336
// end ;
52966: PPOPN 3
52968: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52969: LD_EXP 87
52973: PUSH
52974: LD_EXP 131
52978: AND
52979: IFFALSE 53123
52981: GO 52983
52983: DISABLE
52984: LD_INT 0
52986: PPUSH
52987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52988: LD_ADDR_VAR 0 2
52992: PUSH
52993: LD_INT 22
52995: PUSH
52996: LD_OWVAR 2
53000: PUSH
53001: EMPTY
53002: LIST
53003: LIST
53004: PUSH
53005: LD_INT 21
53007: PUSH
53008: LD_INT 2
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: PUSH
53015: LD_INT 2
53017: PUSH
53018: LD_INT 34
53020: PUSH
53021: LD_INT 12
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: PUSH
53028: LD_INT 34
53030: PUSH
53031: LD_INT 51
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: PUSH
53038: LD_INT 34
53040: PUSH
53041: LD_INT 32
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: PUSH
53048: EMPTY
53049: LIST
53050: LIST
53051: LIST
53052: LIST
53053: PUSH
53054: EMPTY
53055: LIST
53056: LIST
53057: LIST
53058: PPUSH
53059: CALL_OW 69
53063: ST_TO_ADDR
// if not tmp then
53064: LD_VAR 0 2
53068: NOT
53069: IFFALSE 53073
// exit ;
53071: GO 53123
// for i in tmp do
53073: LD_ADDR_VAR 0 1
53077: PUSH
53078: LD_VAR 0 2
53082: PUSH
53083: FOR_IN
53084: IFFALSE 53121
// if GetCargo ( i , mat_artifact ) = 0 then
53086: LD_VAR 0 1
53090: PPUSH
53091: LD_INT 4
53093: PPUSH
53094: CALL_OW 289
53098: PUSH
53099: LD_INT 0
53101: EQUAL
53102: IFFALSE 53119
// SetCargo ( i , mat_siberit , 100 ) ;
53104: LD_VAR 0 1
53108: PPUSH
53109: LD_INT 3
53111: PPUSH
53112: LD_INT 100
53114: PPUSH
53115: CALL_OW 290
53119: GO 53083
53121: POP
53122: POP
// end ;
53123: PPOPN 2
53125: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53126: LD_EXP 87
53130: PUSH
53131: LD_EXP 132
53135: AND
53136: IFFALSE 53289
53138: GO 53140
53140: DISABLE
53141: LD_INT 0
53143: PPUSH
53144: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53145: LD_ADDR_VAR 0 2
53149: PUSH
53150: LD_INT 22
53152: PUSH
53153: LD_OWVAR 2
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: PPUSH
53162: CALL_OW 69
53166: ST_TO_ADDR
// if not tmp then
53167: LD_VAR 0 2
53171: NOT
53172: IFFALSE 53176
// exit ;
53174: GO 53289
// for i := 1 to 2 do
53176: LD_ADDR_VAR 0 1
53180: PUSH
53181: DOUBLE
53182: LD_INT 1
53184: DEC
53185: ST_TO_ADDR
53186: LD_INT 2
53188: PUSH
53189: FOR_TO
53190: IFFALSE 53287
// begin uc_side := your_side ;
53192: LD_ADDR_OWVAR 20
53196: PUSH
53197: LD_OWVAR 2
53201: ST_TO_ADDR
// uc_nation := nation_american ;
53202: LD_ADDR_OWVAR 21
53206: PUSH
53207: LD_INT 1
53209: ST_TO_ADDR
// vc_chassis := us_morphling ;
53210: LD_ADDR_OWVAR 37
53214: PUSH
53215: LD_INT 5
53217: ST_TO_ADDR
// vc_engine := engine_siberite ;
53218: LD_ADDR_OWVAR 39
53222: PUSH
53223: LD_INT 3
53225: ST_TO_ADDR
// vc_control := control_computer ;
53226: LD_ADDR_OWVAR 38
53230: PUSH
53231: LD_INT 3
53233: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53234: LD_ADDR_OWVAR 40
53238: PUSH
53239: LD_INT 10
53241: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
53242: CALL_OW 45
53246: PPUSH
53247: LD_VAR 0 2
53251: PUSH
53252: LD_INT 1
53254: ARRAY
53255: PPUSH
53256: CALL_OW 250
53260: PPUSH
53261: LD_VAR 0 2
53265: PUSH
53266: LD_INT 1
53268: ARRAY
53269: PPUSH
53270: CALL_OW 251
53274: PPUSH
53275: LD_INT 12
53277: PPUSH
53278: LD_INT 1
53280: PPUSH
53281: CALL_OW 50
// end ;
53285: GO 53189
53287: POP
53288: POP
// end ;
53289: PPOPN 2
53291: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53292: LD_EXP 87
53296: PUSH
53297: LD_EXP 133
53301: AND
53302: IFFALSE 53524
53304: GO 53306
53306: DISABLE
53307: LD_INT 0
53309: PPUSH
53310: PPUSH
53311: PPUSH
53312: PPUSH
53313: PPUSH
53314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53315: LD_ADDR_VAR 0 6
53319: PUSH
53320: LD_INT 22
53322: PUSH
53323: LD_OWVAR 2
53327: PUSH
53328: EMPTY
53329: LIST
53330: LIST
53331: PUSH
53332: LD_INT 21
53334: PUSH
53335: LD_INT 1
53337: PUSH
53338: EMPTY
53339: LIST
53340: LIST
53341: PUSH
53342: LD_INT 3
53344: PUSH
53345: LD_INT 23
53347: PUSH
53348: LD_INT 0
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: PUSH
53355: EMPTY
53356: LIST
53357: LIST
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: LIST
53363: PPUSH
53364: CALL_OW 69
53368: ST_TO_ADDR
// if not tmp then
53369: LD_VAR 0 6
53373: NOT
53374: IFFALSE 53378
// exit ;
53376: GO 53524
// s1 := rand ( 1 , 4 ) ;
53378: LD_ADDR_VAR 0 2
53382: PUSH
53383: LD_INT 1
53385: PPUSH
53386: LD_INT 4
53388: PPUSH
53389: CALL_OW 12
53393: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53394: LD_ADDR_VAR 0 4
53398: PUSH
53399: LD_VAR 0 6
53403: PUSH
53404: LD_INT 1
53406: ARRAY
53407: PPUSH
53408: LD_VAR 0 2
53412: PPUSH
53413: CALL_OW 259
53417: ST_TO_ADDR
// if s1 = 1 then
53418: LD_VAR 0 2
53422: PUSH
53423: LD_INT 1
53425: EQUAL
53426: IFFALSE 53446
// s2 := rand ( 2 , 4 ) else
53428: LD_ADDR_VAR 0 3
53432: PUSH
53433: LD_INT 2
53435: PPUSH
53436: LD_INT 4
53438: PPUSH
53439: CALL_OW 12
53443: ST_TO_ADDR
53444: GO 53454
// s2 := 1 ;
53446: LD_ADDR_VAR 0 3
53450: PUSH
53451: LD_INT 1
53453: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53454: LD_ADDR_VAR 0 5
53458: PUSH
53459: LD_VAR 0 6
53463: PUSH
53464: LD_INT 1
53466: ARRAY
53467: PPUSH
53468: LD_VAR 0 3
53472: PPUSH
53473: CALL_OW 259
53477: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53478: LD_VAR 0 6
53482: PUSH
53483: LD_INT 1
53485: ARRAY
53486: PPUSH
53487: LD_VAR 0 2
53491: PPUSH
53492: LD_VAR 0 5
53496: PPUSH
53497: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53501: LD_VAR 0 6
53505: PUSH
53506: LD_INT 1
53508: ARRAY
53509: PPUSH
53510: LD_VAR 0 3
53514: PPUSH
53515: LD_VAR 0 4
53519: PPUSH
53520: CALL_OW 237
// end ;
53524: PPOPN 6
53526: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53527: LD_EXP 87
53531: PUSH
53532: LD_EXP 134
53536: AND
53537: IFFALSE 53616
53539: GO 53541
53541: DISABLE
53542: LD_INT 0
53544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53545: LD_ADDR_VAR 0 1
53549: PUSH
53550: LD_INT 22
53552: PUSH
53553: LD_OWVAR 2
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: PUSH
53562: LD_INT 30
53564: PUSH
53565: LD_INT 3
53567: PUSH
53568: EMPTY
53569: LIST
53570: LIST
53571: PUSH
53572: EMPTY
53573: LIST
53574: LIST
53575: PPUSH
53576: CALL_OW 69
53580: ST_TO_ADDR
// if not tmp then
53581: LD_VAR 0 1
53585: NOT
53586: IFFALSE 53590
// exit ;
53588: GO 53616
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53590: LD_VAR 0 1
53594: PUSH
53595: LD_INT 1
53597: PPUSH
53598: LD_VAR 0 1
53602: PPUSH
53603: CALL_OW 12
53607: ARRAY
53608: PPUSH
53609: LD_INT 1
53611: PPUSH
53612: CALL_OW 234
// end ;
53616: PPOPN 1
53618: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53619: LD_EXP 87
53623: PUSH
53624: LD_EXP 135
53628: AND
53629: IFFALSE 53741
53631: GO 53633
53633: DISABLE
53634: LD_INT 0
53636: PPUSH
53637: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53638: LD_ADDR_VAR 0 2
53642: PUSH
53643: LD_INT 22
53645: PUSH
53646: LD_OWVAR 2
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: PUSH
53655: LD_INT 2
53657: PUSH
53658: LD_INT 30
53660: PUSH
53661: LD_INT 27
53663: PUSH
53664: EMPTY
53665: LIST
53666: LIST
53667: PUSH
53668: LD_INT 30
53670: PUSH
53671: LD_INT 26
53673: PUSH
53674: EMPTY
53675: LIST
53676: LIST
53677: PUSH
53678: LD_INT 30
53680: PUSH
53681: LD_INT 28
53683: PUSH
53684: EMPTY
53685: LIST
53686: LIST
53687: PUSH
53688: EMPTY
53689: LIST
53690: LIST
53691: LIST
53692: LIST
53693: PUSH
53694: EMPTY
53695: LIST
53696: LIST
53697: PPUSH
53698: CALL_OW 69
53702: ST_TO_ADDR
// if not tmp then
53703: LD_VAR 0 2
53707: NOT
53708: IFFALSE 53712
// exit ;
53710: GO 53741
// for i in tmp do
53712: LD_ADDR_VAR 0 1
53716: PUSH
53717: LD_VAR 0 2
53721: PUSH
53722: FOR_IN
53723: IFFALSE 53739
// SetLives ( i , 1 ) ;
53725: LD_VAR 0 1
53729: PPUSH
53730: LD_INT 1
53732: PPUSH
53733: CALL_OW 234
53737: GO 53722
53739: POP
53740: POP
// end ;
53741: PPOPN 2
53743: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53744: LD_EXP 87
53748: PUSH
53749: LD_EXP 136
53753: AND
53754: IFFALSE 54028
53756: GO 53758
53758: DISABLE
53759: LD_INT 0
53761: PPUSH
53762: PPUSH
53763: PPUSH
// begin i := rand ( 1 , 7 ) ;
53764: LD_ADDR_VAR 0 1
53768: PUSH
53769: LD_INT 1
53771: PPUSH
53772: LD_INT 7
53774: PPUSH
53775: CALL_OW 12
53779: ST_TO_ADDR
// case i of 1 :
53780: LD_VAR 0 1
53784: PUSH
53785: LD_INT 1
53787: DOUBLE
53788: EQUAL
53789: IFTRUE 53793
53791: GO 53803
53793: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53794: LD_STRING earthquake(getX(game), 0, 32)
53796: PPUSH
53797: CALL_OW 559
53801: GO 54028
53803: LD_INT 2
53805: DOUBLE
53806: EQUAL
53807: IFTRUE 53811
53809: GO 53825
53811: POP
// begin ToLua ( displayStucuk(); ) ;
53812: LD_STRING displayStucuk();
53814: PPUSH
53815: CALL_OW 559
// ResetFog ;
53819: CALL_OW 335
// end ; 3 :
53823: GO 54028
53825: LD_INT 3
53827: DOUBLE
53828: EQUAL
53829: IFTRUE 53833
53831: GO 53937
53833: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53834: LD_ADDR_VAR 0 2
53838: PUSH
53839: LD_INT 22
53841: PUSH
53842: LD_OWVAR 2
53846: PUSH
53847: EMPTY
53848: LIST
53849: LIST
53850: PUSH
53851: LD_INT 25
53853: PUSH
53854: LD_INT 1
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: PUSH
53861: EMPTY
53862: LIST
53863: LIST
53864: PPUSH
53865: CALL_OW 69
53869: ST_TO_ADDR
// if not tmp then
53870: LD_VAR 0 2
53874: NOT
53875: IFFALSE 53879
// exit ;
53877: GO 54028
// un := tmp [ rand ( 1 , tmp ) ] ;
53879: LD_ADDR_VAR 0 3
53883: PUSH
53884: LD_VAR 0 2
53888: PUSH
53889: LD_INT 1
53891: PPUSH
53892: LD_VAR 0 2
53896: PPUSH
53897: CALL_OW 12
53901: ARRAY
53902: ST_TO_ADDR
// if Crawls ( un ) then
53903: LD_VAR 0 3
53907: PPUSH
53908: CALL_OW 318
53912: IFFALSE 53923
// ComWalk ( un ) ;
53914: LD_VAR 0 3
53918: PPUSH
53919: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53923: LD_VAR 0 3
53927: PPUSH
53928: LD_INT 8
53930: PPUSH
53931: CALL_OW 336
// end ; 4 :
53935: GO 54028
53937: LD_INT 4
53939: DOUBLE
53940: EQUAL
53941: IFTRUE 53945
53943: GO 54006
53945: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53946: LD_ADDR_VAR 0 2
53950: PUSH
53951: LD_INT 22
53953: PUSH
53954: LD_OWVAR 2
53958: PUSH
53959: EMPTY
53960: LIST
53961: LIST
53962: PUSH
53963: LD_INT 30
53965: PUSH
53966: LD_INT 29
53968: PUSH
53969: EMPTY
53970: LIST
53971: LIST
53972: PUSH
53973: EMPTY
53974: LIST
53975: LIST
53976: PPUSH
53977: CALL_OW 69
53981: ST_TO_ADDR
// if not tmp then
53982: LD_VAR 0 2
53986: NOT
53987: IFFALSE 53991
// exit ;
53989: GO 54028
// DestroyUnit ( tmp [ 1 ] ) ;
53991: LD_VAR 0 2
53995: PUSH
53996: LD_INT 1
53998: ARRAY
53999: PPUSH
54000: CALL_OW 65
// end ; 5 .. 7 :
54004: GO 54028
54006: LD_INT 5
54008: DOUBLE
54009: GREATEREQUAL
54010: IFFALSE 54018
54012: LD_INT 7
54014: DOUBLE
54015: LESSEQUAL
54016: IFTRUE 54020
54018: GO 54027
54020: POP
// StreamSibBomb ; end ;
54021: CALL 50308 0 0
54025: GO 54028
54027: POP
// end ;
54028: PPOPN 3
54030: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54031: LD_EXP 87
54035: PUSH
54036: LD_EXP 137
54040: AND
54041: IFFALSE 54197
54043: GO 54045
54045: DISABLE
54046: LD_INT 0
54048: PPUSH
54049: PPUSH
54050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54051: LD_ADDR_VAR 0 2
54055: PUSH
54056: LD_INT 81
54058: PUSH
54059: LD_OWVAR 2
54063: PUSH
54064: EMPTY
54065: LIST
54066: LIST
54067: PUSH
54068: LD_INT 2
54070: PUSH
54071: LD_INT 21
54073: PUSH
54074: LD_INT 1
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: PUSH
54081: LD_INT 21
54083: PUSH
54084: LD_INT 2
54086: PUSH
54087: EMPTY
54088: LIST
54089: LIST
54090: PUSH
54091: EMPTY
54092: LIST
54093: LIST
54094: LIST
54095: PUSH
54096: EMPTY
54097: LIST
54098: LIST
54099: PPUSH
54100: CALL_OW 69
54104: ST_TO_ADDR
// if not tmp then
54105: LD_VAR 0 2
54109: NOT
54110: IFFALSE 54114
// exit ;
54112: GO 54197
// p := 0 ;
54114: LD_ADDR_VAR 0 3
54118: PUSH
54119: LD_INT 0
54121: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54122: LD_INT 35
54124: PPUSH
54125: CALL_OW 67
// p := p + 1 ;
54129: LD_ADDR_VAR 0 3
54133: PUSH
54134: LD_VAR 0 3
54138: PUSH
54139: LD_INT 1
54141: PLUS
54142: ST_TO_ADDR
// for i in tmp do
54143: LD_ADDR_VAR 0 1
54147: PUSH
54148: LD_VAR 0 2
54152: PUSH
54153: FOR_IN
54154: IFFALSE 54185
// if GetLives ( i ) < 1000 then
54156: LD_VAR 0 1
54160: PPUSH
54161: CALL_OW 256
54165: PUSH
54166: LD_INT 1000
54168: LESS
54169: IFFALSE 54183
// SetLives ( i , 1000 ) ;
54171: LD_VAR 0 1
54175: PPUSH
54176: LD_INT 1000
54178: PPUSH
54179: CALL_OW 234
54183: GO 54153
54185: POP
54186: POP
// until p > 20 ;
54187: LD_VAR 0 3
54191: PUSH
54192: LD_INT 20
54194: GREATER
54195: IFFALSE 54122
// end ;
54197: PPOPN 3
54199: END
// every 0 0$1 trigger StreamModeActive and sTime do
54200: LD_EXP 87
54204: PUSH
54205: LD_EXP 138
54209: AND
54210: IFFALSE 54245
54212: GO 54214
54214: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54215: LD_INT 28
54217: PPUSH
54218: LD_OWVAR 2
54222: PPUSH
54223: LD_INT 2
54225: PPUSH
54226: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54230: LD_INT 30
54232: PPUSH
54233: LD_OWVAR 2
54237: PPUSH
54238: LD_INT 2
54240: PPUSH
54241: CALL_OW 322
// end ;
54245: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54246: LD_EXP 87
54250: PUSH
54251: LD_EXP 139
54255: AND
54256: IFFALSE 54377
54258: GO 54260
54260: DISABLE
54261: LD_INT 0
54263: PPUSH
54264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54265: LD_ADDR_VAR 0 2
54269: PUSH
54270: LD_INT 22
54272: PUSH
54273: LD_OWVAR 2
54277: PUSH
54278: EMPTY
54279: LIST
54280: LIST
54281: PUSH
54282: LD_INT 21
54284: PUSH
54285: LD_INT 1
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: PUSH
54292: LD_INT 3
54294: PUSH
54295: LD_INT 23
54297: PUSH
54298: LD_INT 0
54300: PUSH
54301: EMPTY
54302: LIST
54303: LIST
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: PPUSH
54314: CALL_OW 69
54318: ST_TO_ADDR
// if not tmp then
54319: LD_VAR 0 2
54323: NOT
54324: IFFALSE 54328
// exit ;
54326: GO 54377
// for i in tmp do
54328: LD_ADDR_VAR 0 1
54332: PUSH
54333: LD_VAR 0 2
54337: PUSH
54338: FOR_IN
54339: IFFALSE 54375
// begin if Crawls ( i ) then
54341: LD_VAR 0 1
54345: PPUSH
54346: CALL_OW 318
54350: IFFALSE 54361
// ComWalk ( i ) ;
54352: LD_VAR 0 1
54356: PPUSH
54357: CALL_OW 138
// SetClass ( i , 2 ) ;
54361: LD_VAR 0 1
54365: PPUSH
54366: LD_INT 2
54368: PPUSH
54369: CALL_OW 336
// end ;
54373: GO 54338
54375: POP
54376: POP
// end ;
54377: PPOPN 2
54379: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54380: LD_EXP 87
54384: PUSH
54385: LD_EXP 140
54389: AND
54390: IFFALSE 54671
54392: GO 54394
54394: DISABLE
54395: LD_INT 0
54397: PPUSH
54398: PPUSH
54399: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54400: LD_OWVAR 2
54404: PPUSH
54405: LD_INT 9
54407: PPUSH
54408: LD_INT 1
54410: PPUSH
54411: LD_INT 1
54413: PPUSH
54414: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54418: LD_INT 9
54420: PPUSH
54421: LD_OWVAR 2
54425: PPUSH
54426: CALL_OW 343
// uc_side := 9 ;
54430: LD_ADDR_OWVAR 20
54434: PUSH
54435: LD_INT 9
54437: ST_TO_ADDR
// uc_nation := 2 ;
54438: LD_ADDR_OWVAR 21
54442: PUSH
54443: LD_INT 2
54445: ST_TO_ADDR
// hc_name := Dark Warrior ;
54446: LD_ADDR_OWVAR 26
54450: PUSH
54451: LD_STRING Dark Warrior
54453: ST_TO_ADDR
// hc_gallery :=  ;
54454: LD_ADDR_OWVAR 33
54458: PUSH
54459: LD_STRING 
54461: ST_TO_ADDR
// hc_noskilllimit := true ;
54462: LD_ADDR_OWVAR 76
54466: PUSH
54467: LD_INT 1
54469: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54470: LD_ADDR_OWVAR 31
54474: PUSH
54475: LD_INT 30
54477: PUSH
54478: LD_INT 30
54480: PUSH
54481: LD_INT 30
54483: PUSH
54484: LD_INT 30
54486: PUSH
54487: EMPTY
54488: LIST
54489: LIST
54490: LIST
54491: LIST
54492: ST_TO_ADDR
// un := CreateHuman ;
54493: LD_ADDR_VAR 0 3
54497: PUSH
54498: CALL_OW 44
54502: ST_TO_ADDR
// hc_noskilllimit := false ;
54503: LD_ADDR_OWVAR 76
54507: PUSH
54508: LD_INT 0
54510: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54511: LD_VAR 0 3
54515: PPUSH
54516: LD_INT 1
54518: PPUSH
54519: CALL_OW 51
// p := 0 ;
54523: LD_ADDR_VAR 0 2
54527: PUSH
54528: LD_INT 0
54530: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54531: LD_INT 35
54533: PPUSH
54534: CALL_OW 67
// p := p + 1 ;
54538: LD_ADDR_VAR 0 2
54542: PUSH
54543: LD_VAR 0 2
54547: PUSH
54548: LD_INT 1
54550: PLUS
54551: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54552: LD_VAR 0 3
54556: PPUSH
54557: CALL_OW 256
54561: PUSH
54562: LD_INT 1000
54564: LESS
54565: IFFALSE 54579
// SetLives ( un , 1000 ) ;
54567: LD_VAR 0 3
54571: PPUSH
54572: LD_INT 1000
54574: PPUSH
54575: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54579: LD_VAR 0 3
54583: PPUSH
54584: LD_INT 81
54586: PUSH
54587: LD_OWVAR 2
54591: PUSH
54592: EMPTY
54593: LIST
54594: LIST
54595: PUSH
54596: LD_INT 91
54598: PUSH
54599: LD_VAR 0 3
54603: PUSH
54604: LD_INT 30
54606: PUSH
54607: EMPTY
54608: LIST
54609: LIST
54610: LIST
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: PPUSH
54616: CALL_OW 69
54620: PPUSH
54621: LD_VAR 0 3
54625: PPUSH
54626: CALL_OW 74
54630: PPUSH
54631: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54635: LD_VAR 0 2
54639: PUSH
54640: LD_INT 60
54642: GREATER
54643: PUSH
54644: LD_VAR 0 3
54648: PPUSH
54649: CALL_OW 301
54653: OR
54654: IFFALSE 54531
// if un then
54656: LD_VAR 0 3
54660: IFFALSE 54671
// RemoveUnit ( un ) ;
54662: LD_VAR 0 3
54666: PPUSH
54667: CALL_OW 64
// end ; end_of_file
54671: PPOPN 3
54673: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
54674: LD_INT 0
54676: PPUSH
54677: PPUSH
54678: PPUSH
54679: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
54680: LD_VAR 0 1
54684: PPUSH
54685: CALL_OW 264
54689: PUSH
54690: LD_EXP 78
54694: EQUAL
54695: IFFALSE 54767
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
54697: LD_INT 68
54699: PPUSH
54700: LD_VAR 0 1
54704: PPUSH
54705: CALL_OW 255
54709: PPUSH
54710: CALL_OW 321
54714: PUSH
54715: LD_INT 2
54717: EQUAL
54718: IFFALSE 54730
// eff := 70 else
54720: LD_ADDR_VAR 0 4
54724: PUSH
54725: LD_INT 70
54727: ST_TO_ADDR
54728: GO 54738
// eff := 30 ;
54730: LD_ADDR_VAR 0 4
54734: PUSH
54735: LD_INT 30
54737: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
54738: LD_VAR 0 1
54742: PPUSH
54743: CALL_OW 250
54747: PPUSH
54748: LD_VAR 0 1
54752: PPUSH
54753: CALL_OW 251
54757: PPUSH
54758: LD_VAR 0 4
54762: PPUSH
54763: CALL_OW 495
// end ; end ;
54767: LD_VAR 0 2
54771: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
54772: LD_INT 0
54774: PPUSH
// end ;
54775: LD_VAR 0 4
54779: RET
// export function SOS_Command ( cmd ) ; begin
54780: LD_INT 0
54782: PPUSH
// end ;
54783: LD_VAR 0 2
54787: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
54788: LD_VAR 0 1
54792: PUSH
54793: LD_INT 255
54795: EQUAL
54796: PUSH
54797: LD_VAR 0 2
54801: PPUSH
54802: CALL_OW 264
54806: PUSH
54807: LD_INT 14
54809: PUSH
54810: LD_INT 53
54812: PUSH
54813: EMPTY
54814: LIST
54815: LIST
54816: IN
54817: AND
54818: PUSH
54819: LD_VAR 0 4
54823: PPUSH
54824: LD_VAR 0 5
54828: PPUSH
54829: CALL_OW 488
54833: AND
54834: IFFALSE 54858
// CutTreeXYR ( unit , x , y , 12 ) ;
54836: LD_VAR 0 2
54840: PPUSH
54841: LD_VAR 0 4
54845: PPUSH
54846: LD_VAR 0 5
54850: PPUSH
54851: LD_INT 12
54853: PPUSH
54854: CALL 54861 0 4
// end ;
54858: PPOPN 5
54860: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
54861: LD_INT 0
54863: PPUSH
54864: PPUSH
54865: PPUSH
54866: PPUSH
54867: PPUSH
54868: PPUSH
54869: PPUSH
54870: PPUSH
54871: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
54872: LD_VAR 0 1
54876: NOT
54877: PUSH
54878: LD_VAR 0 2
54882: PPUSH
54883: LD_VAR 0 3
54887: PPUSH
54888: CALL_OW 488
54892: NOT
54893: OR
54894: PUSH
54895: LD_VAR 0 4
54899: NOT
54900: OR
54901: IFFALSE 54905
// exit ;
54903: GO 55245
// list := [ ] ;
54905: LD_ADDR_VAR 0 13
54909: PUSH
54910: EMPTY
54911: ST_TO_ADDR
// if x - r < 0 then
54912: LD_VAR 0 2
54916: PUSH
54917: LD_VAR 0 4
54921: MINUS
54922: PUSH
54923: LD_INT 0
54925: LESS
54926: IFFALSE 54938
// min_x := 0 else
54928: LD_ADDR_VAR 0 7
54932: PUSH
54933: LD_INT 0
54935: ST_TO_ADDR
54936: GO 54954
// min_x := x - r ;
54938: LD_ADDR_VAR 0 7
54942: PUSH
54943: LD_VAR 0 2
54947: PUSH
54948: LD_VAR 0 4
54952: MINUS
54953: ST_TO_ADDR
// if y - r < 0 then
54954: LD_VAR 0 3
54958: PUSH
54959: LD_VAR 0 4
54963: MINUS
54964: PUSH
54965: LD_INT 0
54967: LESS
54968: IFFALSE 54980
// min_y := 0 else
54970: LD_ADDR_VAR 0 8
54974: PUSH
54975: LD_INT 0
54977: ST_TO_ADDR
54978: GO 54996
// min_y := y - r ;
54980: LD_ADDR_VAR 0 8
54984: PUSH
54985: LD_VAR 0 3
54989: PUSH
54990: LD_VAR 0 4
54994: MINUS
54995: ST_TO_ADDR
// max_x := x + r ;
54996: LD_ADDR_VAR 0 9
55000: PUSH
55001: LD_VAR 0 2
55005: PUSH
55006: LD_VAR 0 4
55010: PLUS
55011: ST_TO_ADDR
// max_y := y + r ;
55012: LD_ADDR_VAR 0 10
55016: PUSH
55017: LD_VAR 0 3
55021: PUSH
55022: LD_VAR 0 4
55026: PLUS
55027: ST_TO_ADDR
// for _x = min_x to max_x do
55028: LD_ADDR_VAR 0 11
55032: PUSH
55033: DOUBLE
55034: LD_VAR 0 7
55038: DEC
55039: ST_TO_ADDR
55040: LD_VAR 0 9
55044: PUSH
55045: FOR_TO
55046: IFFALSE 55163
// for _y = min_y to max_y do
55048: LD_ADDR_VAR 0 12
55052: PUSH
55053: DOUBLE
55054: LD_VAR 0 8
55058: DEC
55059: ST_TO_ADDR
55060: LD_VAR 0 10
55064: PUSH
55065: FOR_TO
55066: IFFALSE 55159
// begin if not ValidHex ( _x , _y ) then
55068: LD_VAR 0 11
55072: PPUSH
55073: LD_VAR 0 12
55077: PPUSH
55078: CALL_OW 488
55082: NOT
55083: IFFALSE 55087
// continue ;
55085: GO 55065
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
55087: LD_VAR 0 11
55091: PPUSH
55092: LD_VAR 0 12
55096: PPUSH
55097: CALL_OW 351
55101: PUSH
55102: LD_VAR 0 11
55106: PPUSH
55107: LD_VAR 0 12
55111: PPUSH
55112: CALL_OW 554
55116: AND
55117: IFFALSE 55157
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
55119: LD_ADDR_VAR 0 13
55123: PUSH
55124: LD_VAR 0 13
55128: PPUSH
55129: LD_VAR 0 13
55133: PUSH
55134: LD_INT 1
55136: PLUS
55137: PPUSH
55138: LD_VAR 0 11
55142: PUSH
55143: LD_VAR 0 12
55147: PUSH
55148: EMPTY
55149: LIST
55150: LIST
55151: PPUSH
55152: CALL_OW 2
55156: ST_TO_ADDR
// end ;
55157: GO 55065
55159: POP
55160: POP
55161: GO 55045
55163: POP
55164: POP
// if not list then
55165: LD_VAR 0 13
55169: NOT
55170: IFFALSE 55174
// exit ;
55172: GO 55245
// for i in list do
55174: LD_ADDR_VAR 0 6
55178: PUSH
55179: LD_VAR 0 13
55183: PUSH
55184: FOR_IN
55185: IFFALSE 55243
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
55187: LD_VAR 0 1
55191: PPUSH
55192: LD_STRING M
55194: PUSH
55195: LD_VAR 0 6
55199: PUSH
55200: LD_INT 1
55202: ARRAY
55203: PUSH
55204: LD_VAR 0 6
55208: PUSH
55209: LD_INT 2
55211: ARRAY
55212: PUSH
55213: LD_INT 0
55215: PUSH
55216: LD_INT 0
55218: PUSH
55219: LD_INT 0
55221: PUSH
55222: LD_INT 0
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: LIST
55229: LIST
55230: LIST
55231: LIST
55232: LIST
55233: PUSH
55234: EMPTY
55235: LIST
55236: PPUSH
55237: CALL_OW 447
55241: GO 55184
55243: POP
55244: POP
// end ;
55245: LD_VAR 0 5
55249: RET
