// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7640 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4617 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4916 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41603 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42054 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21371 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21307 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18300 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21207 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22221 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21448 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21241 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21274 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18079 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22129 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20386 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20961 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20961 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20758 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20422 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20598 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19882 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20496 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20997 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21737 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21307 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18300 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21207 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21448 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21241 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21274 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18079 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22129 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20386 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20961 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20961 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20758 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20422 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20598 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19882 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20496 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20997 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21737 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19882 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11587 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21955 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11587 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21955 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11587 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21955 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11587 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21955 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7859 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7859 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7859 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7859 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7859 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4477
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 10
4389: PUSH
4390: LD_INT 9
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: LD_OWVAR 67
4405: ARRAY
4406: PPUSH
4407: LD_INT 10
4409: PUSH
4410: LD_INT 9
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: LD_INT -2
4429: PUSH
4430: LD_INT -5
4432: PUSH
4433: LD_INT -3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: LD_VAR 0 6
4445: ADD
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 2
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 3
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 42
4476: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4477: LD_EXP 25
4481: PPUSH
4482: LD_INT 9
4484: PPUSH
4485: LD_INT 0
4487: PPUSH
4488: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: PPUSH
4501: LD_INT 2
4503: PPUSH
4504: CALL_OW 336
// for i = 1 to tmp do
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: DOUBLE
4514: LD_INT 1
4516: DEC
4517: ST_TO_ADDR
4518: LD_VAR 0 5
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4579
// if i < 4 then
4526: LD_VAR 0 3
4530: PUSH
4531: LD_INT 4
4533: LESS
4534: IFFALSE 4559
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4536: LD_VAR 0 5
4540: PUSH
4541: LD_VAR 0 3
4545: ARRAY
4546: PPUSH
4547: LD_INT 9
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 49
4557: GO 4577
// SetSide ( tmp [ i ] , 6 ) ;
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: ARRAY
4569: PPUSH
4570: LD_INT 6
4572: PPUSH
4573: CALL_OW 235
4577: GO 4523
4579: POP
4580: POP
// player_squad := tmp ;
4581: LD_ADDR_EXP 23
4585: PUSH
4586: LD_VAR 0 5
4590: ST_TO_ADDR
// pl_counter := 4 ;
4591: LD_ADDR_EXP 24
4595: PUSH
4596: LD_INT 4
4598: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4599: LD_INT 17
4601: PPUSH
4602: LD_INT 5
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL 18300 0 3
// end ;
4612: LD_VAR 0 2
4616: RET
// export Popov ; export function InitAction ; var commander ; begin
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4621: LD_INT 6
4623: PPUSH
4624: LD_INT 3
4626: PPUSH
4627: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: CALL_OW 86
// uc_side := 6 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 6
4648: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4649: LD_ADDR_EXP 26
4653: PUSH
4654: LD_STRING Popov
4656: PPUSH
4657: CALL_OW 25
4661: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4662: LD_ADDR_OWVAR 67
4666: PUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 426
4674: ST_TO_ADDR
// if not Difficulty then
4675: LD_OWVAR 67
4679: NOT
4680: IFFALSE 4690
// Difficulty := 2 ;
4682: LD_ADDR_OWVAR 67
4686: PUSH
4687: LD_INT 2
4689: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: LD_INT 1
4697: PPUSH
4698: CALL_OW 426
4702: ST_TO_ADDR
// if not commander then
4703: LD_VAR 0 2
4707: NOT
4708: IFFALSE 4718
// commander := 1 ;
4710: LD_ADDR_VAR 0 2
4714: PUSH
4715: LD_INT 1
4717: ST_TO_ADDR
// InitCommanders ( commander ) ;
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL 3137 0 1
// end ;
4727: LD_VAR 0 1
4731: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4732: LD_EXP 24
4736: PUSH
4737: LD_INT 12
4739: LESS
4740: IFFALSE 4913
4742: GO 4744
4744: DISABLE
4745: LD_INT 0
4747: PPUSH
// begin enable ;
4748: ENABLE
// for i = pl_counter to pl_counter + 2 do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_EXP 24
4759: DEC
4760: ST_TO_ADDR
4761: LD_EXP 24
4765: PUSH
4766: LD_INT 2
4768: PLUS
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4817
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4773: LD_EXP 23
4777: PUSH
4778: LD_VAR 0 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 18
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4794: LD_EXP 23
4798: PUSH
4799: LD_VAR 0 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 107
4807: PPUSH
4808: LD_INT 88
4810: PPUSH
4811: CALL_OW 111
// end ;
4815: GO 4770
4817: POP
4818: POP
// for i = pl_counter to pl_counter + 2 do
4819: LD_ADDR_VAR 0 1
4823: PUSH
4824: DOUBLE
4825: LD_EXP 24
4829: DEC
4830: ST_TO_ADDR
4831: LD_EXP 24
4835: PUSH
4836: LD_INT 2
4838: PLUS
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4897
// begin repeat wait ( 0 0$01 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4850: LD_EXP 23
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 107
4863: PPUSH
4864: LD_INT 88
4866: PPUSH
4867: CALL_OW 297
4871: PUSH
4872: LD_INT 6
4874: LESS
4875: IFFALSE 4843
// SetSide ( player_squad [ i ] , 3 ) ;
4877: LD_EXP 23
4881: PUSH
4882: LD_VAR 0 1
4886: ARRAY
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: CALL_OW 235
// end ;
4895: GO 4840
4897: POP
4898: POP
// pl_counter := pl_counter + 3 ;
4899: LD_ADDR_EXP 24
4903: PUSH
4904: LD_EXP 24
4908: PUSH
4909: LD_INT 3
4911: PLUS
4912: ST_TO_ADDR
// end ;
4913: PPOPN 1
4915: END
// export function Dialog ; begin
4916: LD_INT 0
4918: PPUSH
// if not isTest then
4919: LD_EXP 1
4923: NOT
4924: IFFALSE 4946
// case query ( task ) of 1 :
4926: LD_STRING task
4928: PPUSH
4929: CALL_OW 97
4933: PUSH
4934: LD_INT 1
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// InGameOn ;
4946: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4950: LD_INT 107
4952: PPUSH
4953: LD_INT 84
4955: PPUSH
4956: CALL_OW 86
// if isTest then
4960: LD_EXP 1
4964: IFFALSE 4974
// dialogue_skipped := true ;
4966: LD_ADDR_OWVAR 59
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4974: LD_ADDR_EXP 11
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_INT 1
4986: ARRAY
4987: PPUSH
4988: LD_INT 0
4990: PPUSH
4991: LD_INT 96
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 2
4999: PPUSH
5000: CALL_OW 145
5004: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5012: LD_EXP 26
5016: PPUSH
5017: LD_STRING DR1
5019: PPUSH
5020: CALL_OW 94
// Wait ( 0 0$01 ) ;
5024: LD_INT 35
5026: PPUSH
5027: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5031: LD_EXP 26
5035: PPUSH
5036: LD_STRING DR2
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5043: LD_EXP 26
5047: PPUSH
5048: LD_STRING DR3
5050: PPUSH
5051: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5062: LD_INT 3
5064: PPUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL 11587 0 2
5079: PUSH
5080: LD_EXP 1
5084: OR
5085: IFFALSE 5055
// InGameOff ;
5087: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5091: LD_STRING C1
5093: PPUSH
5094: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5105: LD_EXP 11
5109: PPUSH
5110: CALL_OW 461
5114: PUSH
5115: LD_INT 2
5117: EQUAL
5118: IFFALSE 5098
// if not isTest then
5120: LD_EXP 1
5124: NOT
5125: IFFALSE 5147
// case query ( support ) of 1 :
5127: LD_STRING support
5129: PPUSH
5130: CALL_OW 97
5134: PUSH
5135: LD_INT 1
5137: DOUBLE
5138: EQUAL
5139: IFTRUE 5143
5141: GO 5146
5143: POP
// ; end ;
5144: GO 5147
5146: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5147: LD_INT 3
5149: PPUSH
5150: LD_INT 12
5152: PPUSH
5153: LD_INT 2
5155: PPUSH
5156: LD_INT 22
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 0
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 69
5184: PUSH
5185: LD_INT 1
5187: ARRAY
5188: PPUSH
5189: CALL_OW 468
// if player_com = stolypin then
5193: LD_EXP 25
5197: PUSH
5198: LD_EXP 22
5202: EQUAL
5203: IFFALSE 5232
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5205: LD_INT 18
5207: PPUSH
5208: LD_INT 3
5210: PUSH
5211: LD_INT 3
5213: PUSH
5214: LD_INT 2
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: ARRAY
5227: PPUSH
5228: CALL 6656 0 2
// end ;
5232: LD_VAR 0 1
5236: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5237: LD_EXP 12
5241: PUSH
5242: LD_OWVAR 1
5246: PUSH
5247: LD_INT 31500
5249: LESS
5250: AND
5251: IFFALSE 5423
// case query ( call1 ) of 1 :
5253: LD_STRING call1
5255: PPUSH
5256: CALL_OW 97
5260: PUSH
5261: LD_INT 1
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5411
5269: POP
// begin callUsed := true ;
5270: LD_ADDR_EXP 3
5274: PUSH
5275: LD_INT 1
5277: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5278: LD_INT 3
5280: PPUSH
5281: LD_INT 12
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_EXP 11
5291: PPUSH
5292: CALL_OW 468
// call := false ;
5296: LD_ADDR_EXP 12
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5304: LD_EXP 26
5308: PPUSH
5309: LD_STRING DR6
5311: PPUSH
5312: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5316: LD_INT 6300
5318: PPUSH
5319: LD_INT 8400
5321: PPUSH
5322: CALL_OW 12
5326: PPUSH
5327: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5331: LD_INT 18
5333: PUSH
5334: LD_INT 19
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_INT 2
5346: PPUSH
5347: CALL_OW 12
5351: ARRAY
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 2
5358: PPUSH
5359: CALL_OW 12
5363: PPUSH
5364: CALL 6656 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5368: LD_INT 25200
5370: PPUSH
5371: LD_INT 35700
5373: PPUSH
5374: CALL_OW 12
5378: PPUSH
5379: CALL_OW 67
// call := true ;
5383: LD_ADDR_EXP 12
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 12
5396: PPUSH
5397: LD_INT 2
5399: PPUSH
5400: LD_EXP 11
5404: PPUSH
5405: CALL_OW 468
// end ; 2 :
5409: GO 5423
5411: LD_INT 2
5413: DOUBLE
5414: EQUAL
5415: IFTRUE 5419
5417: GO 5422
5419: POP
// ; end ;
5420: GO 5423
5422: POP
// if call and tick >= 15 15$00 then
5423: LD_EXP 12
5427: PUSH
5428: LD_OWVAR 1
5432: PUSH
5433: LD_INT 31500
5435: GREATEREQUAL
5436: AND
5437: IFFALSE 5882
// case query ( call2 ) of 1 :
5439: LD_STRING call2
5441: PPUSH
5442: CALL_OW 97
5446: PUSH
5447: LD_INT 1
5449: DOUBLE
5450: EQUAL
5451: IFTRUE 5455
5453: GO 5699
5455: POP
// begin callUsed := true ;
5456: LD_ADDR_EXP 3
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// call := false ;
5464: LD_ADDR_EXP 12
5468: PUSH
5469: LD_INT 0
5471: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5472: LD_INT 1
5474: PPUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL 11587 0 2
5489: PUSH
5490: LD_INT 4
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11587 0 2
5507: AND
5508: IFFALSE 5556
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PUSH
5513: LD_INT 19
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 2
5525: PPUSH
5526: CALL_OW 12
5530: ARRAY
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6417 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11587 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5579: LD_INT 19
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 3
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6417 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5606: LD_INT 4
5608: PPUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL 11587 0 2
5623: PUSH
5624: LD_INT 0
5626: EQUAL
5627: IFFALSE 5656
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5629: LD_INT 18
5631: PPUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 4
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: PUSH
5646: LD_OWVAR 67
5650: ARRAY
5651: PPUSH
5652: CALL 6417 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5656: LD_INT 10500
5658: PPUSH
5659: LD_INT 23100
5661: PPUSH
5662: CALL_OW 12
5666: PPUSH
5667: CALL_OW 67
// call := true ;
5671: LD_ADDR_EXP 12
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5679: LD_INT 3
5681: PPUSH
5682: LD_INT 12
5684: PPUSH
5685: LD_INT 2
5687: PPUSH
5688: LD_EXP 11
5692: PPUSH
5693: CALL_OW 468
// end ; 2 :
5697: GO 5882
5699: LD_INT 2
5701: DOUBLE
5702: EQUAL
5703: IFTRUE 5707
5705: GO 5870
5707: POP
// begin callUsed := true ;
5708: LD_ADDR_EXP 3
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5716: LD_INT 3
5718: PPUSH
5719: LD_INT 12
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: LD_EXP 11
5729: PPUSH
5730: CALL_OW 468
// call := false ;
5734: LD_ADDR_EXP 12
5738: PUSH
5739: LD_INT 0
5741: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5742: LD_EXP 26
5746: PPUSH
5747: LD_STRING DR6
5749: PPUSH
5750: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5754: LD_INT 6300
5756: PPUSH
5757: LD_INT 8400
5759: PPUSH
5760: CALL_OW 12
5764: PPUSH
5765: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5769: LD_INT 18
5771: PUSH
5772: LD_INT 19
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PUSH
5779: LD_INT 1
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: CALL_OW 12
5789: ARRAY
5790: PPUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_OWVAR 67
5809: ARRAY
5810: PUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 12
5821: MINUS
5822: PPUSH
5823: CALL 6656 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5827: LD_INT 35700
5829: PPUSH
5830: LD_INT 44100
5832: PPUSH
5833: CALL_OW 12
5837: PPUSH
5838: CALL_OW 67
// call := true ;
5842: LD_ADDR_EXP 12
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5850: LD_INT 3
5852: PPUSH
5853: LD_INT 12
5855: PPUSH
5856: LD_INT 2
5858: PPUSH
5859: LD_EXP 11
5863: PPUSH
5864: CALL_OW 468
// end ; 3 :
5868: GO 5882
5870: LD_INT 3
5872: DOUBLE
5873: EQUAL
5874: IFTRUE 5878
5876: GO 5881
5878: POP
// ; end ;
5879: GO 5882
5881: POP
// end ;
5882: PPOPN 4
5884: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5885: LD_INT 22
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 69
5913: PUSH
5914: LD_INT 0
5916: EQUAL
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 21
5930: PUSH
5931: LD_INT 1
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 69
5946: PUSH
5947: LD_INT 0
5949: EQUAL
5950: AND
5951: IFFALSE 6255
5953: GO 5955
5955: DISABLE
// begin DialogueOn ;
5956: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5960: LD_EXP 26
5964: PPUSH
5965: LD_STRING DR7
5967: PPUSH
5968: CALL_OW 94
// case player_com of Gorki :
5972: LD_EXP 25
5976: PUSH
5977: LD_EXP 21
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 5997
5987: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5988: LD_STRING ACH_GORKI
5990: PPUSH
5991: CALL_OW 543
5995: GO 6058
5997: LD_EXP 22
6001: DOUBLE
6002: EQUAL
6003: IFTRUE 6007
6005: GO 6017
6007: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
6008: LD_STRING ACH_STOLYP
6010: PPUSH
6011: CALL_OW 543
6015: GO 6058
6017: LD_EXP 20
6021: DOUBLE
6022: EQUAL
6023: IFTRUE 6027
6025: GO 6037
6027: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
6028: LD_STRING ACH_DAVIDOV
6030: PPUSH
6031: CALL_OW 543
6035: GO 6058
6037: LD_EXP 19
6041: DOUBLE
6042: EQUAL
6043: IFTRUE 6047
6045: GO 6057
6047: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6048: LD_STRING ACH_GLADKOV
6050: PPUSH
6051: CALL_OW 543
6055: GO 6058
6057: POP
// if not callUsed then
6058: LD_EXP 3
6062: NOT
6063: IFFALSE 6072
// SetAchievement ( ACH_NOSUPP ) ;
6065: LD_STRING ACH_NOSUPP
6067: PPUSH
6068: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6072: LD_OWVAR 1
6076: PUSH
6077: LD_INT 116550
6079: PUSH
6080: LD_INT 95550
6082: PUSH
6083: LD_INT 89250
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: LESS
6097: IFFALSE 6111
// AddMedal ( med1 , 1 ) else
6099: LD_STRING med1
6101: PPUSH
6102: LD_INT 1
6104: PPUSH
6105: CALL_OW 101
6109: GO 6122
// AddMedal ( med1 , - 1 ) ;
6111: LD_STRING med1
6113: PPUSH
6114: LD_INT 1
6116: NEG
6117: PPUSH
6118: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6122: LD_INT 81
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 21
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: LD_INT 0
6153: EQUAL
6154: IFFALSE 6168
// AddMedal ( med3 , 1 ) else
6156: LD_STRING med3
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 101
6166: GO 6179
// AddMedal ( med3 , - 1 ) ;
6168: LD_STRING med3
6170: PPUSH
6171: LD_INT 1
6173: NEG
6174: PPUSH
6175: CALL_OW 101
// if player_loss = 0 then
6179: LD_EXP 10
6183: PUSH
6184: LD_INT 0
6186: EQUAL
6187: IFFALSE 6201
// AddMedal ( med2 , 1 ) else
6189: LD_STRING med2
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 101
6199: GO 6244
// if player_loss > 0 and player_loss < 3 then
6201: LD_EXP 10
6205: PUSH
6206: LD_INT 0
6208: GREATER
6209: PUSH
6210: LD_EXP 10
6214: PUSH
6215: LD_INT 3
6217: LESS
6218: AND
6219: IFFALSE 6233
// AddMedal ( med2 , 2 ) else
6221: LD_STRING med2
6223: PPUSH
6224: LD_INT 2
6226: PPUSH
6227: CALL_OW 101
6231: GO 6244
// AddMedal ( med2 , - 1 ) ;
6233: LD_STRING med2
6235: PPUSH
6236: LD_INT 1
6238: NEG
6239: PPUSH
6240: CALL_OW 101
// GiveMedals ( MAIN ) ;
6244: LD_STRING MAIN
6246: PPUSH
6247: CALL_OW 102
// YouWin ;
6251: CALL_OW 103
// end ;
6255: END
// every 0 0$01 trigger IsDead ( player_com ) do
6256: LD_EXP 25
6260: PPUSH
6261: CALL_OW 301
6265: IFFALSE 6332
6267: GO 6269
6269: DISABLE
// begin if IsLive ( Houten ) then
6270: LD_EXP 4
6274: PPUSH
6275: CALL_OW 300
6279: IFFALSE 6295
// SayRadio ( Houten , DJ5 ) else
6281: LD_EXP 4
6285: PPUSH
6286: LD_STRING DJ5
6288: PPUSH
6289: CALL_OW 94
6293: GO 6318
// if IsLive ( Brown ) then
6295: LD_EXP 5
6299: PPUSH
6300: CALL_OW 300
6304: IFFALSE 6318
// SayRadio ( Brown , DS5 ) ;
6306: LD_EXP 5
6310: PPUSH
6311: LD_STRING DS5
6313: PPUSH
6314: CALL_OW 94
// Wait ( 0 0$01 ) ;
6318: LD_INT 35
6320: PPUSH
6321: CALL_OW 67
// YouLost ( dead ) ;
6325: LD_STRING dead
6327: PPUSH
6328: CALL_OW 104
// end ;
6332: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6333: LD_EXP 11
6337: PPUSH
6338: CALL_OW 301
6342: PUSH
6343: LD_EXP 1
6347: NOT
6348: AND
6349: IFFALSE 6416
6351: GO 6353
6353: DISABLE
// begin if IsLive ( Brown ) then
6354: LD_EXP 5
6358: PPUSH
6359: CALL_OW 300
6363: IFFALSE 6379
// SayRadio ( Brown , DS5 ) else
6365: LD_EXP 5
6369: PPUSH
6370: LD_STRING DS5
6372: PPUSH
6373: CALL_OW 94
6377: GO 6402
// if IsLive ( Houten ) then
6379: LD_EXP 4
6383: PPUSH
6384: CALL_OW 300
6388: IFFALSE 6402
// SayRadio ( Houten , DJ5 ) ;
6390: LD_EXP 4
6394: PPUSH
6395: LD_STRING DJ5
6397: PPUSH
6398: CALL_OW 94
// Wait ( 0 0$01 ) ;
6402: LD_INT 35
6404: PPUSH
6405: CALL_OW 67
// YouLost ( depot ) ;
6409: LD_STRING depot
6411: PPUSH
6412: CALL_OW 104
// end ;
6416: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
6421: PPUSH
// for i = 1 to n do
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6641
// begin uc_side := 6 ;
6440: LD_ADDR_OWVAR 20
6444: PUSH
6445: LD_INT 6
6447: ST_TO_ADDR
// uc_nation := 3 ;
6448: LD_ADDR_OWVAR 21
6452: PUSH
6453: LD_INT 3
6455: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6456: LD_ADDR_OWVAR 37
6460: PUSH
6461: LD_INT 23
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 1
6473: PPUSH
6474: LD_INT 2
6476: PPUSH
6477: CALL_OW 12
6481: ARRAY
6482: ST_TO_ADDR
// vc_control := control_computer ;
6483: LD_ADDR_OWVAR 38
6487: PUSH
6488: LD_INT 3
6490: ST_TO_ADDR
// vc_engine := engine_siberite ;
6491: LD_ADDR_OWVAR 39
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6499: LD_ADDR_OWVAR 40
6503: PUSH
6504: LD_INT 43
6506: PUSH
6507: LD_INT 44
6509: PUSH
6510: LD_INT 44
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 1
6520: PPUSH
6521: LD_INT 3
6523: PPUSH
6524: CALL_OW 12
6528: ARRAY
6529: ST_TO_ADDR
// un := CreateVehicle ;
6530: LD_ADDR_VAR 0 5
6534: PUSH
6535: CALL_OW 45
6539: ST_TO_ADDR
// case area of east_arr :
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 18
6547: DOUBLE
6548: EQUAL
6549: IFTRUE 6553
6551: GO 6588
6553: POP
// begin PlaceUnitArea ( un , area , false ) ;
6554: LD_VAR 0 5
6558: PPUSH
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 0
6566: PPUSH
6567: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_INT 79
6578: PPUSH
6579: LD_INT 33
6581: PPUSH
6582: CALL_OW 111
// end ; south_arr :
6586: GO 6632
6588: LD_INT 19
6590: DOUBLE
6591: EQUAL
6592: IFTRUE 6596
6594: GO 6631
6596: POP
// begin PlaceUnitArea ( un , area , false ) ;
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 1
6606: PPUSH
6607: LD_INT 0
6609: PPUSH
6610: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 131
6621: PPUSH
6622: LD_INT 148
6624: PPUSH
6625: CALL_OW 111
// end ; end ;
6629: GO 6632
6631: POP
// Wait ( 0 0$02 ) ;
6632: LD_INT 70
6634: PPUSH
6635: CALL_OW 67
// end ;
6639: GO 6437
6641: POP
6642: POP
// pink_attack := true ;
6643: LD_ADDR_EXP 13
6647: PUSH
6648: LD_INT 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 3
6655: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// for i = 1 to n do
6661: LD_ADDR_VAR 0 4
6665: PUSH
6666: DOUBLE
6667: LD_INT 1
6669: DEC
6670: ST_TO_ADDR
6671: LD_VAR 0 2
6675: PUSH
6676: FOR_TO
6677: IFFALSE 6903
// begin uc_side := 6 ;
6679: LD_ADDR_OWVAR 20
6683: PUSH
6684: LD_INT 6
6686: ST_TO_ADDR
// uc_nation := 3 ;
6687: LD_ADDR_OWVAR 21
6691: PUSH
6692: LD_INT 3
6694: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6695: LD_INT 0
6697: PPUSH
6698: LD_INT 3
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6708: LD_ADDR_OWVAR 37
6712: PUSH
6713: LD_INT 22
6715: ST_TO_ADDR
// vc_control := control_manual ;
6716: LD_ADDR_OWVAR 38
6720: PUSH
6721: LD_INT 1
6723: ST_TO_ADDR
// vc_engine := engine_combustion ;
6724: LD_ADDR_OWVAR 39
6728: PUSH
6729: LD_INT 1
6731: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6732: LD_ADDR_OWVAR 40
6736: PUSH
6737: LD_INT 51
6739: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6740: LD_ADDR_OWVAR 41
6744: PUSH
6745: LD_INT 50
6747: ST_TO_ADDR
// un := CreateVehicle ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: CALL_OW 45
6757: ST_TO_ADDR
// case area of east_arr :
6758: LD_VAR 0 1
6762: PUSH
6763: LD_INT 18
6765: DOUBLE
6766: EQUAL
6767: IFTRUE 6771
6769: GO 6786
6771: POP
// SetDir ( un , 4 ) ; south_arr :
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 4
6779: PPUSH
6780: CALL_OW 233
6784: GO 6810
6786: LD_INT 19
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6809
6794: POP
// SetDir ( un , 5 ) ; end ;
6795: LD_VAR 0 5
6799: PPUSH
6800: LD_INT 5
6802: PPUSH
6803: CALL_OW 233
6807: GO 6810
6809: POP
// PlaceUnitArea ( un , area , false ) ;
6810: LD_VAR 0 5
6814: PPUSH
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6827: CALL_OW 44
6831: PPUSH
6832: LD_VAR 0 5
6836: PPUSH
6837: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6841: LD_VAR 0 5
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 100
6851: PPUSH
6852: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 106
6863: PPUSH
6864: LD_INT 88
6866: PPUSH
6867: CALL_OW 111
// AddComUnload ( un ) ;
6871: LD_VAR 0 5
6875: PPUSH
6876: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 173
// Wait ( 0 0$02 ) ;
6894: LD_INT 70
6896: PPUSH
6897: CALL_OW 67
// end ;
6901: GO 6676
6903: POP
6904: POP
// Wait ( 0 0$05 ) ;
6905: LD_INT 175
6907: PPUSH
6908: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6912: LD_INT 6
6914: PPUSH
6915: LD_INT 34
6917: PUSH
6918: LD_INT 51
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL 11587 0 2
6929: IFFALSE 7117
// begin wait ( 0 0$01 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6938: LD_ADDR_VAR 0 4
6942: PUSH
6943: LD_INT 6
6945: PPUSH
6946: LD_INT 34
6948: PUSH
6949: LD_INT 51
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL 11587 0 2
6960: PUSH
6961: FOR_IN
6962: IFFALSE 7113
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6964: LD_VAR 0 4
6968: PPUSH
6969: LD_INT 9
6971: PPUSH
6972: CALL_OW 308
6976: PUSH
6977: LD_VAR 0 4
6981: PPUSH
6982: CALL 31695 0 1
6986: PPUSH
6987: CALL_OW 258
6991: PUSH
6992: LD_INT 1
6994: EQUAL
6995: AND
6996: PUSH
6997: LD_EXP 9
7001: AND
7002: IFFALSE 7029
// begin Say ( GetDriver ( i ) , Dtran ) ;
7004: LD_VAR 0 4
7008: PPUSH
7009: CALL 31695 0 1
7013: PPUSH
7014: LD_STRING Dtran
7016: PPUSH
7017: CALL_OW 88
// dialog_trans := false ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// end ; if IsIdle ( i ) then
7029: LD_VAR 0 4
7033: PPUSH
7034: CALL_OW 316
7038: IFFALSE 7054
// ComMoveToArea ( i , area ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: LD_VAR 0 1
7049: PPUSH
7050: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7054: LD_VAR 0 4
7058: PPUSH
7059: LD_VAR 0 1
7063: PPUSH
7064: CALL_OW 308
7068: PUSH
7069: LD_VAR 0 4
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL_OW 289
7081: PUSH
7082: LD_INT 0
7084: EQUAL
7085: AND
7086: IFFALSE 7111
// begin RemoveUnit ( GetDriver ( i ) ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL 31695 0 1
7097: PPUSH
7098: CALL_OW 64
// RemoveUnit ( i ) ;
7102: LD_VAR 0 4
7106: PPUSH
7107: CALL_OW 64
// end ; end ;
7111: GO 6961
7113: POP
7114: POP
// end ;
7115: GO 6912
// end ;
7117: LD_VAR 0 3
7121: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7122: LD_INT 0
7124: PPUSH
7125: PPUSH
7126: PPUSH
7127: PPUSH
// if isTest then
7128: LD_EXP 1
7132: IFFALSE 7136
// exit ;
7134: GO 7525
// for i = 1 to n do
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7384
// begin uc_side := 8 ;
7154: LD_ADDR_OWVAR 20
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// uc_nation := 1 ;
7162: LD_ADDR_OWVAR 21
7166: PUSH
7167: LD_INT 1
7169: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7170: LD_ADDR_VAR 0 6
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 1
7191: PPUSH
7192: LD_OWVAR 67
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// vc_chassis := ch ;
7203: LD_ADDR_OWVAR 37
7207: PUSH
7208: LD_VAR 0 6
7212: ST_TO_ADDR
// vc_control := control_computer ;
7213: LD_ADDR_OWVAR 38
7217: PUSH
7218: LD_INT 3
7220: ST_TO_ADDR
// vc_engine := engine_combustion ;
7221: LD_ADDR_OWVAR 39
7225: PUSH
7226: LD_INT 1
7228: ST_TO_ADDR
// if ch = us_medium_tracked then
7229: LD_VAR 0 6
7233: PUSH
7234: LD_INT 3
7236: EQUAL
7237: IFFALSE 7284
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7239: LD_ADDR_OWVAR 40
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 4
7249: PUSH
7250: LD_INT 5
7252: PUSH
7253: LD_INT 7
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: PPUSH
7267: LD_OWVAR 67
7271: PUSH
7272: LD_INT 1
7274: PLUS
7275: PPUSH
7276: CALL_OW 12
7280: ARRAY
7281: ST_TO_ADDR
7282: GO 7325
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7284: LD_ADDR_OWVAR 40
7288: PUSH
7289: LD_INT 5
7291: PUSH
7292: LD_INT 6
7294: PUSH
7295: LD_INT 7
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_OWVAR 67
7314: PUSH
7315: LD_INT 1
7317: PLUS
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7325: LD_ADDR_OWVAR 41
7329: PUSH
7330: LD_INT 70
7332: ST_TO_ADDR
// un := CreateVehicle ;
7333: LD_ADDR_VAR 0 5
7337: PUSH
7338: CALL_OW 45
7342: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7343: LD_VAR 0 5
7347: PPUSH
7348: LD_VAR 0 1
7352: PPUSH
7353: LD_INT 0
7355: PPUSH
7356: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7360: LD_VAR 0 5
7364: PPUSH
7365: LD_INT 65
7367: PPUSH
7368: LD_INT 9
7370: PPUSH
7371: CALL_OW 111
// Wait ( 0 0$02 ) ;
7375: LD_INT 70
7377: PPUSH
7378: CALL_OW 67
// end ;
7382: GO 7151
7384: POP
7385: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7386: LD_INT 90
7388: PUSH
7389: LD_INT 80
7391: PUSH
7392: LD_INT 70
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_OWVAR 67
7404: ARRAY
7405: PPUSH
7406: CALL_OW 13
7410: IFFALSE 7517
// begin uc_side := 8 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 8
7419: ST_TO_ADDR
// uc_nation := 1 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 1
7427: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7428: LD_ADDR_OWVAR 37
7432: PUSH
7433: LD_INT 4
7435: ST_TO_ADDR
// vc_control := control_computer ;
7436: LD_ADDR_OWVAR 38
7440: PUSH
7441: LD_INT 3
7443: ST_TO_ADDR
// vc_engine := engine_combustion ;
7444: LD_ADDR_OWVAR 39
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7452: LD_ADDR_OWVAR 40
7456: PUSH
7457: LD_INT 14
7459: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7460: LD_ADDR_OWVAR 41
7464: PUSH
7465: LD_INT 70
7467: ST_TO_ADDR
// un := CreateVehicle ;
7468: LD_ADDR_VAR 0 5
7472: PUSH
7473: CALL_OW 45
7477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7478: LD_VAR 0 5
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7495: LD_VAR 0 5
7499: PPUSH
7500: LD_INT 65
7502: PPUSH
7503: LD_INT 9
7505: PPUSH
7506: CALL_OW 111
// Wait ( 0 0$02 ) ;
7510: LD_INT 70
7512: PPUSH
7513: CALL_OW 67
// end ; alfa_support := true ;
7517: LD_ADDR_EXP 14
7521: PUSH
7522: LD_INT 1
7524: ST_TO_ADDR
// end ;
7525: LD_VAR 0 3
7529: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7530: LD_OWVAR 1
7534: PUSH
7535: LD_INT 21000
7537: PUSH
7538: LD_INT 18900
7540: PUSH
7541: LD_INT 16800
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: LD_OWVAR 67
7553: ARRAY
7554: GREATER
7555: IFFALSE 7639
7557: GO 7559
7559: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7560: LD_EXP 26
7564: PPUSH
7565: LD_STRING DR5
7567: PPUSH
7568: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7572: LD_INT 1050
7574: PPUSH
7575: LD_INT 4200
7577: PPUSH
7578: CALL_OW 12
7582: PPUSH
7583: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7587: LD_INT 20
7589: PPUSH
7590: LD_INT 5
7592: PUSH
7593: LD_INT 6
7595: PUSH
7596: LD_INT 8
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_OWVAR 67
7608: ARRAY
7609: PPUSH
7610: CALL 7122 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7614: LD_INT 8400
7616: PPUSH
7617: LD_INT 12600
7619: PPUSH
7620: CALL_OW 12
7624: PPUSH
7625: CALL_OW 67
// until tick >= 120 120$00 ;
7629: LD_OWVAR 1
7633: PUSH
7634: LD_INT 252000
7636: GREATEREQUAL
7637: IFFALSE 7560
// end ; end_of_file
7639: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7640: LD_INT 0
7642: PPUSH
// enable_addtolog := isTest ;
7643: LD_ADDR_OWVAR 81
7647: PUSH
7648: LD_EXP 1
7652: ST_TO_ADDR
// lines_break_limit := 5 ;
7653: LD_ADDR_EXP 28
7657: PUSH
7658: LD_INT 5
7660: ST_TO_ADDR
// lines_break_type := --- ;
7661: LD_ADDR_EXP 29
7665: PUSH
7666: LD_STRING ---
7668: ST_TO_ADDR
// lines_counter := 0 ;
7669: LD_ADDR_EXP 27
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// show_line_index := true ;
7677: LD_ADDR_EXP 30
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// tick_log := true ;
7685: LD_ADDR_EXP 31
7689: PUSH
7690: LD_INT 1
7692: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7693: LD_STRING ----------SAND OF SIBERIA LOG----------
7695: PPUSH
7696: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7700: LD_STRING Map Name: 
7702: PUSH
7703: LD_OWVAR 68
7707: STR
7708: PPUSH
7709: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7713: LD_STRING Map Number: 
7715: PUSH
7716: LD_OWVAR 70
7720: STR
7721: PPUSH
7722: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7726: LD_STRING Difficulty: 
7728: PUSH
7729: LD_OWVAR 67
7733: STR
7734: PPUSH
7735: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7739: LD_STRING ---------------------------------------
7741: PPUSH
7742: CALL_OW 561
// end ;
7746: LD_VAR 0 1
7750: RET
// function Log ( text ) ; begin
7751: LD_INT 0
7753: PPUSH
// if show_line_index then
7754: LD_EXP 30
7758: IFFALSE 7770
// result := lines_counter ;
7760: LD_ADDR_VAR 0 2
7764: PUSH
7765: LD_EXP 27
7769: ST_TO_ADDR
// if tick_log then
7770: LD_EXP 31
7774: IFFALSE 7800
// result := result &  T:  & tick &   ;
7776: LD_ADDR_VAR 0 2
7780: PUSH
7781: LD_VAR 0 2
7785: PUSH
7786: LD_STRING  T: 
7788: STR
7789: PUSH
7790: LD_OWVAR 1
7794: STR
7795: PUSH
7796: LD_STRING  
7798: STR
7799: ST_TO_ADDR
// AddToLog ( result & text ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_VAR 0 1
7809: STR
7810: PPUSH
7811: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7815: LD_ADDR_EXP 27
7819: PUSH
7820: LD_EXP 27
7824: PUSH
7825: LD_INT 1
7827: PLUS
7828: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7829: LD_EXP 27
7833: PUSH
7834: LD_EXP 28
7838: MOD
7839: PUSH
7840: LD_INT 0
7842: EQUAL
7843: IFFALSE 7854
// AddToLog ( lines_break_type ) ;
7845: LD_EXP 29
7849: PPUSH
7850: CALL_OW 561
// end ;
7854: LD_VAR 0 2
7858: RET
// export function LogHuman ( id ) ; begin
7859: LD_INT 0
7861: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7862: LD_STRING Human Created. id: 
7864: PUSH
7865: LD_VAR 0 1
7869: STR
7870: PUSH
7871: LD_STRING ; side: 
7873: STR
7874: PUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 255
7884: STR
7885: PUSH
7886: LD_STRING ; class: 
7888: STR
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 257
7899: STR
7900: PUSH
7901: LD_STRING ; 
7903: STR
7904: PPUSH
7905: CALL 7751 0 1
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogVeh ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7917: LD_STRING Vehicle Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; nation: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 248
7954: STR
7955: PUSH
7956: LD_STRING ; weapon: 
7958: STR
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 264
7969: STR
7970: PUSH
7971: LD_STRING ; 
7973: STR
7974: PPUSH
7975: CALL 7751 0 1
// end ;
7979: LD_VAR 0 2
7983: RET
// export function LogEvent ( event ) ; begin
7984: LD_INT 0
7986: PPUSH
// Log ( Event Executed. id:  & event ) ;
7987: LD_STRING Event Executed. id: 
7989: PUSH
7990: LD_VAR 0 1
7994: STR
7995: PPUSH
7996: CALL 7751 0 1
// end ; end_of_file
8000: LD_VAR 0 2
8004: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8005: LD_INT 0
8007: PPUSH
8008: PPUSH
8009: PPUSH
8010: PPUSH
8011: PPUSH
8012: PPUSH
8013: PPUSH
8014: PPUSH
// if unit then
8015: LD_VAR 0 1
8019: IFFALSE 8419
// begin if mode = 0 then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_INT 0
8028: EQUAL
8029: IFFALSE 8177
// begin if coords then
8031: LD_VAR 0 2
8035: IFFALSE 8175
// while ( coords > 1 ) do
8037: LD_VAR 0 2
8041: PUSH
8042: LD_INT 1
8044: GREATER
8045: IFFALSE 8175
// if not HasTask ( unit ) then
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 314
8056: NOT
8057: IFFALSE 8173
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8059: LD_VAR 0 1
8063: PPUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 1
8071: ARRAY
8072: PPUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: PPUSH
8082: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8086: LD_INT 35
8088: PPUSH
8089: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 250
8102: PUSH
8103: LD_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ARRAY
8111: EQUAL
8112: PUSH
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 251
8122: PUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 2
8130: ARRAY
8131: EQUAL
8132: AND
8133: IFFALSE 8086
// for i = 1 to 2 do
8135: LD_ADDR_VAR 0 5
8139: PUSH
8140: DOUBLE
8141: LD_INT 1
8143: DEC
8144: ST_TO_ADDR
8145: LD_INT 2
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8171
// coords := Delete ( coords , 1 ) ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: LD_INT 1
8163: PPUSH
8164: CALL_OW 3
8168: ST_TO_ADDR
8169: GO 8148
8171: POP
8172: POP
// end ;
8173: GO 8037
// end else
8175: GO 8419
// begin if coords then
8177: LD_VAR 0 2
8181: IFFALSE 8419
// begin x := GetX ( unit ) ;
8183: LD_ADDR_VAR 0 6
8187: PUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 250
8197: ST_TO_ADDR
// y := GetY ( unit ) ;
8198: LD_ADDR_VAR 0 7
8202: PUSH
8203: LD_VAR 0 1
8207: PPUSH
8208: CALL_OW 251
8212: ST_TO_ADDR
// while ( coords > 1 ) do
8213: LD_VAR 0 2
8217: PUSH
8218: LD_INT 1
8220: GREATER
8221: IFFALSE 8419
// begin Wait ( 0 0$0.3 ) ;
8223: LD_INT 10
8225: PPUSH
8226: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 255
8239: PPUSH
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 250
8249: PPUSH
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 251
8259: PPUSH
8260: LD_INT 14
8262: PPUSH
8263: CALL 22757 0 4
8267: IFFALSE 8298
// begin ComMoveXY ( unit , x , y ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 7
8283: PPUSH
8284: CALL_OW 111
// result := false ;
8288: LD_ADDR_VAR 0 4
8292: PUSH
8293: LD_INT 0
8295: ST_TO_ADDR
// end else
8296: GO 8337
// if not HasTask ( unit ) then
8298: LD_VAR 0 1
8302: PPUSH
8303: CALL_OW 314
8307: NOT
8308: IFFALSE 8337
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8310: LD_VAR 0 1
8314: PPUSH
8315: LD_VAR 0 2
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 2
8331: ARRAY
8332: PPUSH
8333: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8337: LD_VAR 0 1
8341: PPUSH
8342: CALL_OW 250
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: EQUAL
8356: PUSH
8357: LD_VAR 0 1
8361: PPUSH
8362: CALL_OW 251
8366: PUSH
8367: LD_VAR 0 2
8371: PUSH
8372: LD_INT 2
8374: ARRAY
8375: EQUAL
8376: AND
8377: IFFALSE 8417
// for i = 1 to 2 do
8379: LD_ADDR_VAR 0 5
8383: PUSH
8384: DOUBLE
8385: LD_INT 1
8387: DEC
8388: ST_TO_ADDR
8389: LD_INT 2
8391: PUSH
8392: FOR_TO
8393: IFFALSE 8415
// coords := Delete ( coords , 1 ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 2
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
8413: GO 8392
8415: POP
8416: POP
// end ;
8417: GO 8213
// end ; end ; end ; result := true ;
8419: LD_ADDR_VAR 0 4
8423: PUSH
8424: LD_INT 1
8426: ST_TO_ADDR
// end ;
8427: LD_VAR 0 4
8431: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8437: LD_ADDR_VAR 0 5
8441: PUSH
8442: LD_INT 81
8444: PUSH
8445: LD_VAR 0 1
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// for i in units do
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_VAR 0 2
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8498
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8472: LD_VAR 0 4
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL_OW 74
8491: PPUSH
8492: CALL_OW 115
// end ;
8496: GO 8469
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 3
8504: RET
// export function MC_Show ( string ) ; begin
8505: LD_INT 0
8507: PPUSH
// display_strings := string ;
8508: LD_ADDR_OWVAR 47
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// end ; end_of_file
8518: LD_VAR 0 2
8522: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
8527: PPUSH
8528: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8529: LD_ADDR_VAR 0 8
8533: PUSH
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 2
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL 11670 0 3
8548: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8549: LD_VAR 0 8
8553: PUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: LD_VAR 0 3
8563: PPUSH
8564: CALL_OW 428
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: AND
8573: IFFALSE 8647
// for i = 1 to plist do
8575: LD_ADDR_VAR 0 6
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 8
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8645
// if NotTask ( plist [ i ] ) then
8593: LD_VAR 0 8
8597: PUSH
8598: LD_VAR 0 6
8602: ARRAY
8603: PPUSH
8604: CALL 32158 0 1
8608: IFFALSE 8643
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8610: LD_VAR 0 8
8614: PUSH
8615: LD_VAR 0 6
8619: ARRAY
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: LD_VAR 0 2
8628: PPUSH
8629: LD_VAR 0 3
8633: PPUSH
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 145
// end ;
8643: GO 8590
8645: POP
8646: POP
// end ;
8647: LD_VAR 0 5
8651: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8652: LD_INT 0
8654: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 6
8662: PPUSH
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_VAR 0 4
8677: PPUSH
8678: CALL 10156 0 5
// end ;
8682: LD_VAR 0 5
8686: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8691: LD_ADDR_VAR 0 4
8695: PUSH
8696: LD_INT 22
8698: PUSH
8699: LD_VAR 0 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 30
8713: PUSH
8714: LD_INT 0
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 30
8723: PUSH
8724: LD_INT 1
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: EMPTY
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 250
8757: PPUSH
8758: LD_VAR 0 2
8762: PPUSH
8763: CALL_OW 251
8767: PPUSH
8768: CALL_OW 73
8772: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8773: LD_VAR 0 4
8777: PPUSH
8778: LD_VAR 0 2
8782: PPUSH
8783: CALL 10445 0 2
8787: IFFALSE 8846
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8789: LD_VAR 0 1
8793: PPUSH
8794: LD_INT 30
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PPUSH
8806: CALL 11587 0 2
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8819: LD_ADDR_EXP 50
8823: PUSH
8824: LD_EXP 50
8828: PPUSH
8829: LD_VAR 0 1
8833: PPUSH
8834: LD_VAR 0 2
8838: PPUSH
8839: EMPTY
8840: PPUSH
8841: CALL 41973 0 4
8845: ST_TO_ADDR
// end ; end ;
8846: LD_VAR 0 3
8850: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8851: LD_INT 0
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// result := false ;
8859: LD_ADDR_VAR 0 4
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8867: LD_VAR 0 1
8871: PPUSH
8872: LD_EXP 42
8876: PPUSH
8877: CALL 42921 0 2
8881: IFFALSE 9094
// for i = 1 to MREG_LabList do
8883: LD_ADDR_VAR 0 5
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_EXP 42
8897: PUSH
8898: FOR_TO
8899: IFFALSE 9092
// begin if MREG_LabList [ i ] [ 1 ] = side then
8901: LD_EXP 42
8905: PUSH
8906: LD_VAR 0 5
8910: ARRAY
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PUSH
8916: LD_VAR 0 1
8920: EQUAL
8921: IFFALSE 9090
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8923: LD_ADDR_VAR 0 7
8927: PUSH
8928: LD_EXP 42
8932: PUSH
8933: LD_VAR 0 5
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8943: LD_ADDR_VAR 0 9
8947: PUSH
8948: LD_INT 22
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 0
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 30
8975: PUSH
8976: LD_INT 1
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: EMPTY
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: CALL_OW 250
9009: PPUSH
9010: LD_VAR 0 7
9014: PPUSH
9015: CALL_OW 251
9019: PPUSH
9020: CALL_OW 73
9024: ST_TO_ADDR
// if dep then
9025: LD_VAR 0 9
9029: IFFALSE 9088
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9031: LD_VAR 0 9
9035: PPUSH
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 3
9045: PPUSH
9046: CALL 10561 0 3
9050: IFFALSE 9088
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9052: LD_VAR 0 7
9056: PPUSH
9057: LD_VAR 0 2
9061: PPUSH
9062: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9066: LD_VAR 0 7
9070: PPUSH
9071: LD_VAR 0 3
9075: PPUSH
9076: CALL_OW 207
// result := true ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 1
9087: ST_TO_ADDR
// end ; end ; break ;
9088: GO 9092
// end ; end ;
9090: GO 8898
9092: POP
9093: POP
// end ;
9094: LD_VAR 0 4
9098: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9104: LD_ADDR_VAR 0 7
9108: PUSH
9109: LD_VAR 0 2
9113: PPUSH
9114: LD_VAR 0 3
9118: PPUSH
9119: LD_VAR 0 4
9123: PPUSH
9124: CALL 9286 0 3
9128: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9129: LD_ADDR_EXP 48
9133: PUSH
9134: LD_EXP 48
9138: PPUSH
9139: LD_VAR 0 1
9143: PPUSH
9144: LD_INT 2
9146: PPUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_VAR 0 3
9156: PUSH
9157: LD_VAR 0 4
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL 41882 0 4
9171: ST_TO_ADDR
// if ext_list then
9172: LD_VAR 0 5
9176: IFFALSE 9281
// for i = 1 to ext_list do
9178: LD_ADDR_VAR 0 8
9182: PUSH
9183: DOUBLE
9184: LD_INT 1
9186: DEC
9187: ST_TO_ADDR
9188: LD_VAR 0 5
9192: PUSH
9193: FOR_TO
9194: IFFALSE 9279
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9196: LD_ADDR_EXP 48
9200: PUSH
9201: LD_EXP 48
9205: PPUSH
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 8
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PUSH
9237: LD_VAR 0 7
9241: PUSH
9242: LD_VAR 0 8
9246: ARRAY
9247: PUSH
9248: LD_INT 2
9250: ARRAY
9251: PUSH
9252: LD_VAR 0 7
9256: PUSH
9257: LD_VAR 0 8
9261: ARRAY
9262: PUSH
9263: LD_INT 3
9265: ARRAY
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: PPUSH
9272: CALL 41882 0 4
9276: ST_TO_ADDR
9277: GO 9193
9279: POP
9280: POP
// end ;
9281: LD_VAR 0 6
9285: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
// list := [ ] ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: EMPTY
9296: ST_TO_ADDR
// case d of 0 :
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 0
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9443
9310: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9311: LD_ADDR_VAR 0 5
9315: PUSH
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 4
9323: MINUS
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 4
9332: MINUS
9333: PUSH
9334: LD_INT 2
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: LD_VAR 0 1
9346: PUSH
9347: LD_INT 3
9349: MINUS
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: LD_INT 1
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 4
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_VAR 0 1
9390: PUSH
9391: LD_INT 3
9393: PLUS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 3
9402: PLUS
9403: PUSH
9404: LD_INT 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_VAR 0 2
9421: PUSH
9422: LD_INT 4
9424: PLUS
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: ST_TO_ADDR
// end ; 1 :
9441: GO 10141
9443: LD_INT 1
9445: DOUBLE
9446: EQUAL
9447: IFTRUE 9451
9449: GO 9584
9451: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9452: LD_ADDR_VAR 0 5
9456: PUSH
9457: LD_VAR 0 1
9461: PUSH
9462: LD_VAR 0 2
9466: PUSH
9467: LD_INT 4
9469: MINUS
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: PUSH
9479: LD_VAR 0 1
9483: PUSH
9484: LD_INT 3
9486: MINUS
9487: PUSH
9488: LD_VAR 0 2
9492: PUSH
9493: LD_INT 3
9495: MINUS
9496: PUSH
9497: LD_INT 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: PUSH
9505: LD_VAR 0 1
9509: PUSH
9510: LD_INT 4
9512: MINUS
9513: PUSH
9514: LD_VAR 0 2
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: LD_INT 3
9539: PLUS
9540: PUSH
9541: LD_INT 0
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: LD_VAR 0 1
9553: PUSH
9554: LD_INT 4
9556: PLUS
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 4
9565: PLUS
9566: PUSH
9567: LD_INT 5
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: ST_TO_ADDR
// end ; 2 :
9582: GO 10141
9584: LD_INT 2
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9721
9592: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9593: LD_ADDR_VAR 0 5
9597: PUSH
9598: LD_VAR 0 1
9602: PUSH
9603: LD_VAR 0 2
9607: PUSH
9608: LD_INT 3
9610: MINUS
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: PLUS
9628: PUSH
9629: LD_VAR 0 2
9633: PUSH
9634: LD_INT 4
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 2
9651: PUSH
9652: LD_INT 4
9654: PLUS
9655: PUSH
9656: LD_INT 0
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 3
9671: MINUS
9672: PUSH
9673: LD_VAR 0 2
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: LD_INT 4
9693: MINUS
9694: PUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 4
9702: MINUS
9703: PUSH
9704: LD_INT 2
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: ST_TO_ADDR
// end ; 3 :
9719: GO 10141
9721: LD_INT 3
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9862
9729: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_VAR 0 1
9739: PUSH
9740: LD_INT 3
9742: PLUS
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 4
9764: PLUS
9765: PUSH
9766: LD_VAR 0 2
9770: PUSH
9771: LD_INT 4
9773: PLUS
9774: PUSH
9775: LD_INT 5
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_VAR 0 1
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_VAR 0 2
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: LD_INT 4
9817: MINUS
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: LIST
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_INT 3
9834: MINUS
9835: PUSH
9836: LD_VAR 0 2
9840: PUSH
9841: LD_INT 3
9843: MINUS
9844: PUSH
9845: LD_INT 2
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: ST_TO_ADDR
// end ; 4 :
9860: GO 10141
9862: LD_INT 4
9864: DOUBLE
9865: EQUAL
9866: IFTRUE 9870
9868: GO 10003
9870: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9871: LD_ADDR_VAR 0 5
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 4
9888: PLUS
9889: PUSH
9890: LD_INT 0
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_VAR 0 1
9902: PUSH
9903: LD_INT 3
9905: PLUS
9906: PUSH
9907: LD_VAR 0 2
9911: PUSH
9912: LD_INT 3
9914: PLUS
9915: PUSH
9916: LD_INT 5
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: PUSH
9924: LD_VAR 0 1
9928: PUSH
9929: LD_INT 3
9931: PLUS
9932: PUSH
9933: LD_VAR 0 2
9937: PUSH
9938: LD_INT 4
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: PUSH
9946: LD_VAR 0 1
9950: PUSH
9951: LD_VAR 0 2
9955: PUSH
9956: LD_INT 3
9958: MINUS
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: PUSH
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 4
9975: MINUS
9976: PUSH
9977: LD_VAR 0 2
9981: PUSH
9982: LD_INT 4
9984: MINUS
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: ST_TO_ADDR
// end ; 5 :
10001: GO 10141
10003: LD_INT 5
10005: DOUBLE
10006: EQUAL
10007: IFTRUE 10011
10009: GO 10140
10011: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10012: LD_ADDR_VAR 0 5
10016: PUSH
10017: LD_VAR 0 1
10021: PUSH
10022: LD_INT 4
10024: MINUS
10025: PUSH
10026: LD_VAR 0 2
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: LD_INT 4
10051: MINUS
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: PUSH
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 4
10068: PLUS
10069: PUSH
10070: LD_VAR 0 2
10074: PUSH
10075: LD_INT 4
10077: PLUS
10078: PUSH
10079: LD_INT 5
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: LD_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PLUS
10095: PUSH
10096: LD_VAR 0 2
10100: PUSH
10101: LD_INT 4
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_VAR 0 2
10118: PUSH
10119: LD_INT 3
10121: PLUS
10122: PUSH
10123: LD_INT 0
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: ST_TO_ADDR
// end ; end ;
10138: GO 10141
10140: POP
// result := list ;
10141: LD_ADDR_VAR 0 4
10145: PUSH
10146: LD_VAR 0 5
10150: ST_TO_ADDR
// end ;
10151: LD_VAR 0 4
10155: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10156: LD_INT 0
10158: PPUSH
10159: PPUSH
10160: PPUSH
10161: PPUSH
10162: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10163: LD_ADDR_VAR 0 10
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: EMPTY
10177: PPUSH
10178: CALL 11670 0 3
10182: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_VAR 0 1
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 30
10205: PUSH
10206: LD_INT 0
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_VAR 0 3
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL_OW 73
10254: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10255: LD_ADDR_VAR 0 8
10259: PUSH
10260: LD_VAR 0 9
10264: PPUSH
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL 10445 0 2
10274: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10275: LD_VAR 0 10
10279: PUSH
10280: LD_VAR 0 8
10284: AND
10285: PUSH
10286: LD_VAR 0 9
10290: PPUSH
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_VAR 0 4
10300: PPUSH
10301: CALL_OW 297
10305: PUSH
10306: LD_INT 26
10308: LESSEQUAL
10309: AND
10310: PUSH
10311: LD_VAR 0 3
10315: PPUSH
10316: LD_VAR 0 4
10320: PPUSH
10321: CALL_OW 428
10325: PUSH
10326: LD_INT 0
10328: EQUAL
10329: AND
10330: IFFALSE 10440
// for i = 1 to plist do
10332: LD_ADDR_VAR 0 7
10336: PUSH
10337: DOUBLE
10338: LD_INT 1
10340: DEC
10341: ST_TO_ADDR
10342: LD_VAR 0 10
10346: PUSH
10347: FOR_TO
10348: IFFALSE 10438
// if IsInUnit ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL_OW 310
10365: IFFALSE 10384
// ComExitBuilding ( plist [ i ] ) else
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: CALL_OW 122
10382: GO 10436
// if NotTask ( plist [ i ] ) then
10384: LD_VAR 0 10
10388: PUSH
10389: LD_VAR 0 7
10393: ARRAY
10394: PPUSH
10395: CALL 32158 0 1
10399: IFFALSE 10436
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10401: LD_VAR 0 10
10405: PUSH
10406: LD_VAR 0 7
10410: ARRAY
10411: PPUSH
10412: LD_VAR 0 2
10416: PPUSH
10417: LD_VAR 0 3
10421: PPUSH
10422: LD_VAR 0 4
10426: PPUSH
10427: LD_VAR 0 5
10431: PPUSH
10432: CALL_OW 145
// end ;
10436: GO 10347
10438: POP
10439: POP
// end ;
10440: LD_VAR 0 6
10444: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10445: LD_INT 0
10447: PPUSH
10448: PPUSH
10449: PPUSH
// pom := GetBase ( bdepot ) ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 274
10464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10465: LD_ADDR_VAR 0 5
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 248
10484: PPUSH
10485: CALL_OW 450
10489: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10490: LD_VAR 0 4
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 275
10502: PUSH
10503: LD_VAR 0 5
10507: PUSH
10508: LD_INT 1
10510: ARRAY
10511: GREATEREQUAL
10512: PUSH
10513: LD_VAR 0 4
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: CALL_OW 275
10525: PUSH
10526: LD_VAR 0 5
10530: PUSH
10531: LD_INT 3
10533: ARRAY
10534: GREATEREQUAL
10535: AND
10536: IFFALSE 10548
// result := true else
10538: LD_ADDR_VAR 0 3
10542: PUSH
10543: LD_INT 1
10545: ST_TO_ADDR
10546: GO 10556
// result := false ;
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: LD_INT 0
10555: ST_TO_ADDR
// end ;
10556: LD_VAR 0 3
10560: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10561: LD_INT 0
10563: PPUSH
10564: PPUSH
10565: PPUSH
10566: PPUSH
10567: PPUSH
// pom := GetBase ( bdepot ) ;
10568: LD_ADDR_VAR 0 5
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 274
10582: ST_TO_ADDR
// cost := [ ] ;
10583: LD_ADDR_VAR 0 8
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_VAR 0 1
10604: PPUSH
10605: CALL_OW 248
10609: PPUSH
10610: CALL_OW 450
10614: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10615: LD_ADDR_VAR 0 7
10619: PUSH
10620: LD_VAR 0 3
10624: PPUSH
10625: LD_VAR 0 1
10629: PPUSH
10630: CALL_OW 248
10634: PPUSH
10635: CALL_OW 450
10639: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10640: LD_ADDR_VAR 0 8
10644: PUSH
10645: LD_VAR 0 8
10649: PPUSH
10650: LD_INT 1
10652: PPUSH
10653: LD_VAR 0 6
10657: PUSH
10658: LD_INT 1
10660: ARRAY
10661: PUSH
10662: LD_VAR 0 7
10666: PUSH
10667: LD_INT 1
10669: ARRAY
10670: PLUS
10671: PPUSH
10672: CALL_OW 1
10676: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10677: LD_ADDR_VAR 0 8
10681: PUSH
10682: LD_VAR 0 8
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_VAR 0 6
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: PUSH
10699: LD_VAR 0 7
10703: PUSH
10704: LD_INT 2
10706: ARRAY
10707: PLUS
10708: PPUSH
10709: CALL_OW 1
10713: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10714: LD_ADDR_VAR 0 8
10718: PUSH
10719: LD_VAR 0 8
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_VAR 0 6
10731: PUSH
10732: LD_INT 3
10734: ARRAY
10735: PUSH
10736: LD_VAR 0 7
10740: PUSH
10741: LD_INT 3
10743: ARRAY
10744: PLUS
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 275
10763: PUSH
10764: LD_VAR 0 8
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: GREATEREQUAL
10773: PUSH
10774: LD_VAR 0 5
10778: PPUSH
10779: LD_INT 3
10781: PPUSH
10782: CALL_OW 275
10786: PUSH
10787: LD_VAR 0 8
10791: PUSH
10792: LD_INT 3
10794: ARRAY
10795: GREATEREQUAL
10796: AND
10797: IFFALSE 10809
// result := true else
10799: LD_ADDR_VAR 0 4
10803: PUSH
10804: LD_INT 1
10806: ST_TO_ADDR
10807: GO 10817
// result := false ;
10809: LD_ADDR_VAR 0 4
10813: PUSH
10814: LD_INT 0
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 4
10821: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
10826: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10827: LD_ADDR_VAR 0 5
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_INT 2
10839: PPUSH
10840: EMPTY
10841: PPUSH
10842: CALL 11670 0 3
10846: ST_TO_ADDR
// if unit and plist then
10847: LD_VAR 0 2
10851: PUSH
10852: LD_VAR 0 5
10856: AND
10857: IFFALSE 10918
// for i = 1 to plist do
10859: LD_ADDR_VAR 0 4
10863: PUSH
10864: DOUBLE
10865: LD_INT 1
10867: DEC
10868: ST_TO_ADDR
10869: LD_VAR 0 5
10873: PUSH
10874: FOR_TO
10875: IFFALSE 10916
// if NotTask ( plist [ i ] ) then
10877: LD_VAR 0 5
10881: PUSH
10882: LD_VAR 0 4
10886: ARRAY
10887: PPUSH
10888: CALL 32158 0 1
10892: IFFALSE 10914
// ComDismantle ( plist [ i ] , unit ) ;
10894: LD_VAR 0 5
10898: PUSH
10899: LD_VAR 0 4
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 2
10909: PPUSH
10910: CALL_OW 167
10914: GO 10874
10916: POP
10917: POP
// result := true ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// end ;
10926: LD_VAR 0 3
10930: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10931: LD_INT 0
10933: PPUSH
10934: PPUSH
10935: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10936: LD_ADDR_VAR 0 5
10940: PUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL 11670 0 3
10955: ST_TO_ADDR
// if unit and plist then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_VAR 0 5
10965: AND
10966: IFFALSE 11027
// for i = 1 to plist do
10968: LD_ADDR_VAR 0 4
10972: PUSH
10973: DOUBLE
10974: LD_INT 1
10976: DEC
10977: ST_TO_ADDR
10978: LD_VAR 0 5
10982: PUSH
10983: FOR_TO
10984: IFFALSE 11025
// if NotTask ( plist [ i ] ) then
10986: LD_VAR 0 5
10990: PUSH
10991: LD_VAR 0 4
10995: ARRAY
10996: PPUSH
10997: CALL 32158 0 1
11001: IFFALSE 11023
// ComComplete ( plist [ i ] , unit ) ;
11003: LD_VAR 0 5
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: CALL 68283 0 2
11023: GO 10983
11025: POP
11026: POP
// result := true ;
11027: LD_ADDR_VAR 0 3
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// end ;
11035: LD_VAR 0 3
11039: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11040: LD_INT 0
11042: PPUSH
11043: PPUSH
11044: PPUSH
11045: PPUSH
11046: PPUSH
11047: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 21
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 3
11077: PUSH
11078: LD_INT 57
11080: PUSH
11081: EMPTY
11082: LIST
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: LD_INT 24
11093: PUSH
11094: LD_INT 1000
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: ST_TO_ADDR
// r := [ ] ;
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: EMPTY
11122: ST_TO_ADDR
// if not tmp then
11123: LD_VAR 0 5
11127: NOT
11128: IFFALSE 11134
// exit else
11130: GO 11322
11132: GO 11302
// begin r := [ tmp [ 1 ] ] ;
11134: LD_ADDR_VAR 0 6
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 1
11146: ARRAY
11147: PUSH
11148: EMPTY
11149: LIST
11150: ST_TO_ADDR
// for i = 2 to tmp do
11151: LD_ADDR_VAR 0 3
11155: PUSH
11156: DOUBLE
11157: LD_INT 2
11159: DEC
11160: ST_TO_ADDR
11161: LD_VAR 0 5
11165: PUSH
11166: FOR_TO
11167: IFFALSE 11300
// begin m := false ;
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// for j = 1 to r do
11177: LD_ADDR_VAR 0 4
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 6
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11267
// if GetLives ( tmp [ i ] ) < r [ j ] then
11195: LD_VAR 0 5
11199: PUSH
11200: LD_VAR 0 3
11204: ARRAY
11205: PPUSH
11206: CALL_OW 256
11210: PUSH
11211: LD_VAR 0 6
11215: PUSH
11216: LD_VAR 0 4
11220: ARRAY
11221: LESS
11222: IFFALSE 11265
// begin r := Insert ( r , j , tmp [ i ] ) ;
11224: LD_ADDR_VAR 0 6
11228: PUSH
11229: LD_VAR 0 6
11233: PPUSH
11234: LD_VAR 0 4
11238: PPUSH
11239: LD_VAR 0 5
11243: PUSH
11244: LD_VAR 0 3
11248: ARRAY
11249: PPUSH
11250: CALL_OW 2
11254: ST_TO_ADDR
// m := true ;
11255: LD_ADDR_VAR 0 7
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// break ;
11263: GO 11267
// end ;
11265: GO 11192
11267: POP
11268: POP
// if not m then
11269: LD_VAR 0 7
11273: NOT
11274: IFFALSE 11298
// r := r ^ tmp [ i ] ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_VAR 0 6
11285: PUSH
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: ADD
11297: ST_TO_ADDR
// end ;
11298: GO 11166
11300: POP
11301: POP
// end ; if r then
11302: LD_VAR 0 6
11306: IFFALSE 11320
// result := r else
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_VAR 0 6
11317: ST_TO_ADDR
11318: GO 11322
// exit ;
11320: GO 11322
// end ;
11322: LD_VAR 0 2
11326: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11327: LD_INT 0
11329: PPUSH
11330: PPUSH
11331: PPUSH
11332: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 16
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 13
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 34
11385: PUSH
11386: LD_INT 52
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 24
11402: PUSH
11403: LD_INT 650
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// p := 1 ;
11420: LD_ADDR_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: ST_TO_ADDR
// for i = 1 to repairs do
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: DOUBLE
11434: LD_INT 1
11436: DEC
11437: ST_TO_ADDR
11438: LD_VAR 0 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11580
// begin if IsInUnit ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 310
11461: IFFALSE 11480
// ComExitBuilding ( repairs [ i ] ) else
11463: LD_VAR 0 5
11467: PUSH
11468: LD_VAR 0 3
11472: ARRAY
11473: PPUSH
11474: CALL_OW 122
11478: GO 11578
// if not HasTask ( repairs [ i ] ) then
11480: LD_VAR 0 5
11484: PUSH
11485: LD_VAR 0 3
11489: ARRAY
11490: PPUSH
11491: CALL_OW 314
11495: NOT
11496: IFFALSE 11578
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11498: LD_VAR 0 5
11502: PUSH
11503: LD_VAR 0 3
11507: ARRAY
11508: PPUSH
11509: LD_EXP 49
11513: PUSH
11514: LD_VAR 0 1
11518: ARRAY
11519: PUSH
11520: LD_VAR 0 4
11524: ARRAY
11525: PPUSH
11526: CALL_OW 130
// if i mod 3 = 0 then
11530: LD_VAR 0 3
11534: PUSH
11535: LD_INT 3
11537: MOD
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11558
// p := p + 1 ;
11544: LD_ADDR_VAR 0 4
11548: PUSH
11549: LD_VAR 0 4
11553: PUSH
11554: LD_INT 1
11556: PLUS
11557: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11558: LD_EXP 49
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: PUSH
11569: LD_VAR 0 4
11573: LESS
11574: IFFALSE 11578
// break ;
11576: GO 11580
// end ; end ;
11578: GO 11443
11580: POP
11581: POP
// end ; end_of_file
11582: LD_VAR 0 2
11586: RET
// export function MCF_Get ( side , filter ) ; begin
11587: LD_INT 0
11589: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// end ;
11621: LD_VAR 0 3
11625: RET
// export function MCF_Lab ( side ) ; begin
11626: LD_INT 0
11628: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11629: LD_ADDR_VAR 0 2
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_VAR 0 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 30
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: ST_TO_ADDR
// end ;
11665: LD_VAR 0 2
11669: RET
// export function MCF_Class ( side , class , filter ) ; begin
11670: LD_INT 0
11672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11673: LD_ADDR_VAR 0 4
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_VAR 0 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_All ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 25
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 25
11767: PUSH
11768: LD_INT 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// end ;
11807: LD_VAR 0 3
11811: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11812: LD_INT 0
11814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11815: LD_ADDR_VAR 0 4
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 92
11834: PUSH
11835: LD_VAR 0 2
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PUSH
11844: LD_VAR 0 2
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PUSH
11853: LD_VAR 0 2
11857: PUSH
11858: LD_INT 3
11860: ARRAY
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// end ;
11883: LD_VAR 0 4
11887: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11888: LD_INT 0
11890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_VAR 0 1
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 21
11910: PUSH
11911: LD_INT 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_VAR 0 2
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PPUSH
11928: CALL_OW 69
11932: ST_TO_ADDR
// end ;
11933: LD_VAR 0 3
11937: RET
// export function MCF_Cargo ( side ) ; begin
11938: LD_INT 0
11940: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11941: LD_ADDR_VAR 0 2
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 12
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 51
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL 11888 0 2
11994: ST_TO_ADDR
// end ;
11995: LD_VAR 0 2
11999: RET
// export function MCF_Ape ( side ) ; begin
12000: LD_INT 0
12002: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12003: LD_ADDR_VAR 0 2
12007: PUSH
12008: LD_INT 22
12010: PUSH
12011: LD_VAR 0 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 2
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 12
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 15
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 16
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 25
12055: PUSH
12056: LD_INT 17
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: ST_TO_ADDR
// end ;
12079: LD_VAR 0 2
12083: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12084: LD_INT 0
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 3
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12097: LD_ADDR_VAR 0 4
12101: PUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL 12000 0 1
12111: ST_TO_ADDR
// case type of 0 , normal :
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12131
12123: LD_STRING normal
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12142
12131: POP
// cl := class_apeman ; 1 , soldier :
12132: LD_ADDR_VAR 0 5
12136: PUSH
12137: LD_INT 12
12139: ST_TO_ADDR
12140: GO 12218
12142: LD_INT 1
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12156
12148: LD_STRING soldier
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12156
12154: GO 12167
12156: POP
// cl := class_apeman_soldier ; 2 , engineer :
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 15
12164: ST_TO_ADDR
12165: GO 12218
12167: LD_INT 2
12169: DOUBLE
12170: EQUAL
12171: IFTRUE 12181
12173: LD_STRING engineer
12175: DOUBLE
12176: EQUAL
12177: IFTRUE 12181
12179: GO 12192
12181: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12182: LD_ADDR_VAR 0 5
12186: PUSH
12187: LD_INT 16
12189: ST_TO_ADDR
12190: GO 12218
12192: LD_INT 3
12194: DOUBLE
12195: EQUAL
12196: IFTRUE 12206
12198: LD_STRING kamikaze
12200: DOUBLE
12201: EQUAL
12202: IFTRUE 12206
12204: GO 12217
12206: POP
// cl := class_apeman_kamikaze ; end ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_INT 17
12214: ST_TO_ADDR
12215: GO 12218
12217: POP
// for i = 1 to tmp do
12218: LD_ADDR_VAR 0 6
12222: PUSH
12223: DOUBLE
12224: LD_INT 1
12226: DEC
12227: ST_TO_ADDR
12228: LD_VAR 0 4
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12283
// if GetClass ( tmp [ i ] ) = cl then
12236: LD_VAR 0 4
12240: PUSH
12241: LD_VAR 0 6
12245: ARRAY
12246: PPUSH
12247: CALL_OW 257
12251: PUSH
12252: LD_VAR 0 5
12256: EQUAL
12257: IFFALSE 12281
// result := result ^ tmp [ i ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_VAR 0 4
12273: PUSH
12274: LD_VAR 0 6
12278: ARRAY
12279: ADD
12280: ST_TO_ADDR
12281: GO 12233
12283: POP
12284: POP
// end ;
12285: LD_VAR 0 3
12289: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_VAR 0 3
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 69
12326: ST_TO_ADDR
// r := [ ] ;
12327: LD_ADDR_VAR 0 6
12331: PUSH
12332: EMPTY
12333: ST_TO_ADDR
// if tmp then
12334: LD_VAR 0 5
12338: IFFALSE 12407
// for i = 1 to tmp do
12340: LD_ADDR_VAR 0 7
12344: PUSH
12345: DOUBLE
12346: LD_INT 1
12348: DEC
12349: ST_TO_ADDR
12350: LD_VAR 0 5
12354: PUSH
12355: FOR_TO
12356: IFFALSE 12405
// if GetTag ( tmp [ i ] ) = tag then
12358: LD_VAR 0 5
12362: PUSH
12363: LD_VAR 0 7
12367: ARRAY
12368: PPUSH
12369: CALL_OW 110
12373: PUSH
12374: LD_VAR 0 2
12378: EQUAL
12379: IFFALSE 12403
// r := r ^ tmp [ i ] ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_VAR 0 6
12390: PUSH
12391: LD_VAR 0 5
12395: PUSH
12396: LD_VAR 0 7
12400: ARRAY
12401: ADD
12402: ST_TO_ADDR
12403: GO 12355
12405: POP
12406: POP
// result := r ;
12407: LD_ADDR_VAR 0 4
12411: PUSH
12412: LD_VAR 0 6
12416: ST_TO_ADDR
// end ;
12417: LD_VAR 0 4
12421: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12422: LD_INT 0
12424: PPUSH
12425: PPUSH
12426: PPUSH
// tmp := plist ;
12427: LD_ADDR_VAR 0 5
12431: PUSH
12432: LD_VAR 0 2
12436: ST_TO_ADDR
// if tmp then
12437: LD_VAR 0 5
12441: IFFALSE 12518
// begin for i = 1 to tmp do
12443: LD_ADDR_VAR 0 6
12447: PUSH
12448: DOUBLE
12449: LD_INT 1
12451: DEC
12452: ST_TO_ADDR
12453: LD_VAR 0 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12506
// if GetTag ( tmp [ i ] ) <> tag then
12461: LD_VAR 0 5
12465: PUSH
12466: LD_VAR 0 6
12470: ARRAY
12471: PPUSH
12472: CALL_OW 110
12476: PUSH
12477: LD_VAR 0 3
12481: NONEQUAL
12482: IFFALSE 12504
// SetTag ( tmp [ i ] , tag ) ;
12484: LD_VAR 0 5
12488: PUSH
12489: LD_VAR 0 6
12493: ARRAY
12494: PPUSH
12495: LD_VAR 0 3
12499: PPUSH
12500: CALL_OW 109
12504: GO 12458
12506: POP
12507: POP
// result := true ;
12508: LD_ADDR_VAR 0 4
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// end else
12516: GO 12526
// result := false ;
12518: LD_ADDR_VAR 0 4
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// end ;
12526: LD_VAR 0 4
12530: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: EMPTY
12552: PPUSH
12553: CALL 12290 0 3
12557: ST_TO_ADDR
// if tmp then
12558: LD_VAR 0 4
12562: IFFALSE 12614
// begin for i = 1 to tmp do
12564: LD_ADDR_VAR 0 5
12568: PUSH
12569: DOUBLE
12570: LD_INT 1
12572: DEC
12573: ST_TO_ADDR
12574: LD_VAR 0 4
12578: PUSH
12579: FOR_TO
12580: IFFALSE 12602
// SetTag ( tmp [ i ] , 0 ) ;
12582: LD_VAR 0 4
12586: PUSH
12587: LD_VAR 0 5
12591: ARRAY
12592: PPUSH
12593: LD_INT 0
12595: PPUSH
12596: CALL_OW 109
12600: GO 12579
12602: POP
12603: POP
// result := true ;
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// end else
12612: GO 12622
// result := false ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 3
12626: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
12631: PPUSH
12632: PPUSH
12633: PPUSH
// sort_list := [ ] ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: EMPTY
12640: ST_TO_ADDR
// for i = 1 to list do
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: DOUBLE
12647: LD_INT 1
12649: DEC
12650: ST_TO_ADDR
12651: LD_VAR 0 1
12655: PUSH
12656: FOR_TO
12657: IFFALSE 12819
// begin if i = 1 then
12659: LD_VAR 0 3
12663: PUSH
12664: LD_INT 1
12666: EQUAL
12667: IFFALSE 12693
// sort_list := sort_list ^ list [ i ] else
12669: LD_ADDR_VAR 0 5
12673: PUSH
12674: LD_VAR 0 5
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: LD_VAR 0 3
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
12691: GO 12817
// begin for j = 1 to sort_list do
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: DOUBLE
12699: LD_INT 1
12701: DEC
12702: ST_TO_ADDR
12703: LD_VAR 0 5
12707: PUSH
12708: FOR_TO
12709: IFFALSE 12786
// begin add := false ;
12711: LD_ADDR_VAR 0 6
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12719: LD_VAR 0 1
12723: PUSH
12724: LD_VAR 0 3
12728: ARRAY
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: LD_VAR 0 4
12739: ARRAY
12740: LESS
12741: IFFALSE 12784
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12743: LD_ADDR_VAR 0 5
12747: PUSH
12748: LD_VAR 0 5
12752: PPUSH
12753: LD_VAR 0 4
12757: PPUSH
12758: LD_VAR 0 1
12762: PUSH
12763: LD_VAR 0 3
12767: ARRAY
12768: PPUSH
12769: CALL_OW 2
12773: ST_TO_ADDR
// add := true ;
12774: LD_ADDR_VAR 0 6
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// break ;
12782: GO 12786
// end ; end ;
12784: GO 12708
12786: POP
12787: POP
// if not add then
12788: LD_VAR 0 6
12792: NOT
12793: IFFALSE 12817
// sort_list := sort_list ^ list [ i ] ;
12795: LD_ADDR_VAR 0 5
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 1
12809: PUSH
12810: LD_VAR 0 3
12814: ARRAY
12815: ADD
12816: ST_TO_ADDR
// end ; end ;
12817: GO 12656
12819: POP
12820: POP
// result := sort_list ;
12821: LD_ADDR_VAR 0 2
12825: PUSH
12826: LD_VAR 0 5
12830: ST_TO_ADDR
// end ;
12831: LD_VAR 0 2
12835: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
// sort_list := [ ] ;
12843: LD_ADDR_VAR 0 5
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i = 1 to list do
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_VAR 0 1
12864: PUSH
12865: FOR_TO
12866: IFFALSE 13028
// begin if i = 1 then
12868: LD_VAR 0 3
12872: PUSH
12873: LD_INT 1
12875: EQUAL
12876: IFFALSE 12902
// sort_list := sort_list ^ list [ i ] else
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_VAR 0 5
12887: PUSH
12888: LD_VAR 0 1
12892: PUSH
12893: LD_VAR 0 3
12897: ARRAY
12898: ADD
12899: ST_TO_ADDR
12900: GO 13026
// begin for j = 1 to sort_list do
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: DOUBLE
12908: LD_INT 1
12910: DEC
12911: ST_TO_ADDR
12912: LD_VAR 0 5
12916: PUSH
12917: FOR_TO
12918: IFFALSE 12995
// begin add := false ;
12920: LD_ADDR_VAR 0 6
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 5
12943: PUSH
12944: LD_VAR 0 4
12948: ARRAY
12949: GREATER
12950: IFFALSE 12993
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12952: LD_ADDR_VAR 0 5
12956: PUSH
12957: LD_VAR 0 5
12961: PPUSH
12962: LD_VAR 0 4
12966: PPUSH
12967: LD_VAR 0 1
12971: PUSH
12972: LD_VAR 0 3
12976: ARRAY
12977: PPUSH
12978: CALL_OW 2
12982: ST_TO_ADDR
// add := true ;
12983: LD_ADDR_VAR 0 6
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// break ;
12991: GO 12995
// end ; end ;
12993: GO 12917
12995: POP
12996: POP
// if not add then
12997: LD_VAR 0 6
13001: NOT
13002: IFFALSE 13026
// sort_list := sort_list ^ list [ i ] ;
13004: LD_ADDR_VAR 0 5
13008: PUSH
13009: LD_VAR 0 5
13013: PUSH
13014: LD_VAR 0 1
13018: PUSH
13019: LD_VAR 0 3
13023: ARRAY
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12865
13028: POP
13029: POP
// result := sort_list ;
13030: LD_ADDR_VAR 0 2
13034: PUSH
13035: LD_VAR 0 5
13039: ST_TO_ADDR
// end ;
13040: LD_VAR 0 2
13044: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13045: LD_INT 0
13047: PPUSH
13048: PPUSH
13049: PPUSH
13050: PPUSH
13051: PPUSH
13052: PPUSH
// tmp := [ ] ;
13053: LD_ADDR_VAR 0 8
13057: PUSH
13058: EMPTY
13059: ST_TO_ADDR
// r := [ ] ;
13060: LD_ADDR_VAR 0 7
13064: PUSH
13065: EMPTY
13066: ST_TO_ADDR
// add := false ;
13067: LD_ADDR_VAR 0 9
13071: PUSH
13072: LD_INT 0
13074: ST_TO_ADDR
// if plist then
13075: LD_VAR 0 2
13079: IFFALSE 13155
// begin for i = 1 to plist do
13081: LD_ADDR_VAR 0 5
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13151
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13099: LD_ADDR_VAR 0 8
13103: PUSH
13104: LD_VAR 0 8
13108: PUSH
13109: LD_VAR 0 2
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PUSH
13120: LD_VAR 0 2
13124: PUSH
13125: LD_VAR 0 5
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 3
13135: PPUSH
13136: CALL_OW 259
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: ADD
13148: ST_TO_ADDR
// end ;
13149: GO 13096
13151: POP
13152: POP
// end else
13153: GO 13163
// result := false ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 0
13162: ST_TO_ADDR
// if tmp then
13163: LD_VAR 0 8
13167: IFFALSE 13341
// begin r := r ^ [ tmp [ 1 ] ] ;
13169: LD_ADDR_VAR 0 7
13173: PUSH
13174: LD_VAR 0 7
13178: PUSH
13179: LD_VAR 0 8
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: EMPTY
13189: LIST
13190: ADD
13191: ST_TO_ADDR
// for i = 2 to tmp do
13192: LD_ADDR_VAR 0 5
13196: PUSH
13197: DOUBLE
13198: LD_INT 2
13200: DEC
13201: ST_TO_ADDR
13202: LD_VAR 0 8
13206: PUSH
13207: FOR_TO
13208: IFFALSE 13339
// begin for j = 1 to r do
13210: LD_ADDR_VAR 0 6
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_VAR 0 7
13224: PUSH
13225: FOR_TO
13226: IFFALSE 13303
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13228: LD_VAR 0 8
13232: PUSH
13233: LD_VAR 0 5
13237: ARRAY
13238: PUSH
13239: LD_INT 2
13241: ARRAY
13242: PUSH
13243: LD_VAR 0 7
13247: PUSH
13248: LD_VAR 0 6
13252: ARRAY
13253: PUSH
13254: LD_INT 2
13256: ARRAY
13257: LESS
13258: IFFALSE 13301
// begin r := Insert ( r , j , tmp [ i ] ) ;
13260: LD_ADDR_VAR 0 7
13264: PUSH
13265: LD_VAR 0 7
13269: PPUSH
13270: LD_VAR 0 6
13274: PPUSH
13275: LD_VAR 0 8
13279: PUSH
13280: LD_VAR 0 5
13284: ARRAY
13285: PPUSH
13286: CALL_OW 2
13290: ST_TO_ADDR
// add := true ;
13291: LD_ADDR_VAR 0 9
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// break ;
13299: GO 13303
// end ; end ;
13301: GO 13225
13303: POP
13304: POP
// if not add then
13305: LD_VAR 0 9
13309: NOT
13310: IFFALSE 13337
// r := r ^ [ tmp [ i ] ] ;
13312: LD_ADDR_VAR 0 7
13316: PUSH
13317: LD_VAR 0 7
13321: PUSH
13322: LD_VAR 0 8
13326: PUSH
13327: LD_VAR 0 5
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// end ;
13337: GO 13207
13339: POP
13340: POP
// end ; result := r ;
13341: LD_ADDR_VAR 0 4
13345: PUSH
13346: LD_VAR 0 7
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 4
13355: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
// tmp := [ ] ;
13364: LD_ADDR_VAR 0 8
13368: PUSH
13369: EMPTY
13370: ST_TO_ADDR
// r := [ ] ;
13371: LD_ADDR_VAR 0 7
13375: PUSH
13376: EMPTY
13377: ST_TO_ADDR
// add := false ;
13378: LD_ADDR_VAR 0 9
13382: PUSH
13383: LD_INT 0
13385: ST_TO_ADDR
// if plist then
13386: LD_VAR 0 2
13390: IFFALSE 13466
// begin for i = 1 to plist do
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: DOUBLE
13398: LD_INT 1
13400: DEC
13401: ST_TO_ADDR
13402: LD_VAR 0 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13462
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13410: LD_ADDR_VAR 0 8
13414: PUSH
13415: LD_VAR 0 8
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: LD_VAR 0 5
13440: ARRAY
13441: PPUSH
13442: LD_VAR 0 3
13446: PPUSH
13447: CALL_OW 259
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: ADD
13459: ST_TO_ADDR
// end ;
13460: GO 13407
13462: POP
13463: POP
// end else
13464: GO 13474
// result := false ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// if tmp then
13474: LD_VAR 0 8
13478: IFFALSE 13652
// begin r := r ^ [ tmp [ 1 ] ] ;
13480: LD_ADDR_VAR 0 7
13484: PUSH
13485: LD_VAR 0 7
13489: PUSH
13490: LD_VAR 0 8
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: PUSH
13499: EMPTY
13500: LIST
13501: ADD
13502: ST_TO_ADDR
// for i = 2 to tmp do
13503: LD_ADDR_VAR 0 5
13507: PUSH
13508: DOUBLE
13509: LD_INT 2
13511: DEC
13512: ST_TO_ADDR
13513: LD_VAR 0 8
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13650
// begin for j = 1 to r do
13521: LD_ADDR_VAR 0 6
13525: PUSH
13526: DOUBLE
13527: LD_INT 1
13529: DEC
13530: ST_TO_ADDR
13531: LD_VAR 0 7
13535: PUSH
13536: FOR_TO
13537: IFFALSE 13614
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13539: LD_VAR 0 8
13543: PUSH
13544: LD_VAR 0 5
13548: ARRAY
13549: PUSH
13550: LD_INT 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 7
13558: PUSH
13559: LD_VAR 0 6
13563: ARRAY
13564: PUSH
13565: LD_INT 2
13567: ARRAY
13568: GREATER
13569: IFFALSE 13612
// begin r := Insert ( r , j , tmp [ i ] ) ;
13571: LD_ADDR_VAR 0 7
13575: PUSH
13576: LD_VAR 0 7
13580: PPUSH
13581: LD_VAR 0 6
13585: PPUSH
13586: LD_VAR 0 8
13590: PUSH
13591: LD_VAR 0 5
13595: ARRAY
13596: PPUSH
13597: CALL_OW 2
13601: ST_TO_ADDR
// add := true ;
13602: LD_ADDR_VAR 0 9
13606: PUSH
13607: LD_INT 1
13609: ST_TO_ADDR
// break ;
13610: GO 13614
// end ; end ;
13612: GO 13536
13614: POP
13615: POP
// if not add then
13616: LD_VAR 0 9
13620: NOT
13621: IFFALSE 13648
// r := r ^ [ tmp [ i ] ] ;
13623: LD_ADDR_VAR 0 7
13627: PUSH
13628: LD_VAR 0 7
13632: PUSH
13633: LD_VAR 0 8
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: EMPTY
13645: LIST
13646: ADD
13647: ST_TO_ADDR
// end ;
13648: GO 13518
13650: POP
13651: POP
// end ; result := r ;
13652: LD_ADDR_VAR 0 4
13656: PUSH
13657: LD_VAR 0 7
13661: ST_TO_ADDR
// end ;
13662: LD_VAR 0 4
13666: RET
// export function MCF_Clear ( side ) ; var i ; begin
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
// for i = 1 to 100 do
13671: LD_ADDR_VAR 0 3
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 100
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13721
// if MCF_Tag ( side , i , [ ] ) then
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 3
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL 12290 0 3
13703: IFFALSE 13719
// MCF_ClearTag ( side , i ) ;
13705: LD_VAR 0 1
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: CALL 12531 0 2
13719: GO 13684
13721: POP
13722: POP
// result := true ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_INT 1
13730: ST_TO_ADDR
// end ;
13731: LD_VAR 0 2
13735: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// for i = 1 to plist do
13741: LD_ADDR_VAR 0 4
13745: PUSH
13746: DOUBLE
13747: LD_INT 1
13749: DEC
13750: ST_TO_ADDR
13751: LD_VAR 0 1
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13806
// if MCF_HasClass ( plist [ i ] ) = n then
13759: LD_VAR 0 1
13763: PUSH
13764: LD_VAR 0 4
13768: ARRAY
13769: PPUSH
13770: CALL 14293 0 1
13774: PUSH
13775: LD_VAR 0 2
13779: EQUAL
13780: IFFALSE 13804
// tmp := tmp ^ plist [ i ] ;
13782: LD_ADDR_VAR 0 5
13786: PUSH
13787: LD_VAR 0 5
13791: PUSH
13792: LD_VAR 0 1
13796: PUSH
13797: LD_VAR 0 4
13801: ARRAY
13802: ADD
13803: ST_TO_ADDR
13804: GO 13756
13806: POP
13807: POP
// result := tmp ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_VAR 0 5
13817: ST_TO_ADDR
// end ;
13818: LD_VAR 0 3
13822: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13823: LD_INT 0
13825: PPUSH
13826: PPUSH
13827: PPUSH
// if mreg = ToArm then
13828: LD_VAR 0 2
13832: PUSH
13833: LD_STRING ToArm
13835: EQUAL
13836: IFFALSE 13941
// begin tmp := MREG_ToArm [ side ] ;
13838: LD_ADDR_VAR 0 6
13842: PUSH
13843: LD_EXP 58
13847: PUSH
13848: LD_VAR 0 1
13852: ARRAY
13853: ST_TO_ADDR
// if tmp = 0 then
13854: LD_VAR 0 6
13858: PUSH
13859: LD_INT 0
13861: EQUAL
13862: IFFALSE 13868
// exit else
13864: GO 14288
13866: GO 13941
// begin for i = MREG_ToArm [ side ] downto n do
13868: LD_ADDR_VAR 0 5
13872: PUSH
13873: DOUBLE
13874: LD_EXP 58
13878: PUSH
13879: LD_VAR 0 1
13883: ARRAY
13884: INC
13885: ST_TO_ADDR
13886: LD_VAR 0 3
13890: PUSH
13891: FOR_DOWNTO
13892: IFFALSE 13914
// tmp := Delete ( tmp , 1 ) ;
13894: LD_ADDR_VAR 0 6
13898: PUSH
13899: LD_VAR 0 6
13903: PPUSH
13904: LD_INT 1
13906: PPUSH
13907: CALL_OW 3
13911: ST_TO_ADDR
13912: GO 13891
13914: POP
13915: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13916: LD_ADDR_EXP 58
13920: PUSH
13921: LD_EXP 58
13925: PPUSH
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: CALL_OW 1
13940: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13941: LD_VAR 0 2
13945: PUSH
13946: LD_STRING ToDep
13948: EQUAL
13949: IFFALSE 14054
// begin tmp := MREG_ToDep [ side ] ;
13951: LD_ADDR_VAR 0 6
13955: PUSH
13956: LD_EXP 59
13960: PUSH
13961: LD_VAR 0 1
13965: ARRAY
13966: ST_TO_ADDR
// if tmp = 0 then
13967: LD_VAR 0 6
13971: PUSH
13972: LD_INT 0
13974: EQUAL
13975: IFFALSE 13981
// exit else
13977: GO 14288
13979: GO 14054
// begin for i = MREG_ToDep [ side ] downto n do
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: DOUBLE
13987: LD_EXP 59
13991: PUSH
13992: LD_VAR 0 1
13996: ARRAY
13997: INC
13998: ST_TO_ADDR
13999: LD_VAR 0 3
14003: PUSH
14004: FOR_DOWNTO
14005: IFFALSE 14027
// tmp := Delete ( tmp , 1 ) ;
14007: LD_ADDR_VAR 0 6
14011: PUSH
14012: LD_VAR 0 6
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL_OW 3
14024: ST_TO_ADDR
14025: GO 14004
14027: POP
14028: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14029: LD_ADDR_EXP 59
14033: PUSH
14034: LD_EXP 59
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: CALL_OW 1
14053: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14054: LD_VAR 0 2
14058: PUSH
14059: LD_STRING ToFac
14061: EQUAL
14062: IFFALSE 14167
// begin tmp := MREG_ToFac [ side ] ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_EXP 57
14073: PUSH
14074: LD_VAR 0 1
14078: ARRAY
14079: ST_TO_ADDR
// if tmp = 0 then
14080: LD_VAR 0 6
14084: PUSH
14085: LD_INT 0
14087: EQUAL
14088: IFFALSE 14094
// exit else
14090: GO 14288
14092: GO 14167
// begin for i = MREG_ToFac [ side ] downto n do
14094: LD_ADDR_VAR 0 5
14098: PUSH
14099: DOUBLE
14100: LD_EXP 57
14104: PUSH
14105: LD_VAR 0 1
14109: ARRAY
14110: INC
14111: ST_TO_ADDR
14112: LD_VAR 0 3
14116: PUSH
14117: FOR_DOWNTO
14118: IFFALSE 14140
// tmp := Delete ( tmp , 1 ) ;
14120: LD_ADDR_VAR 0 6
14124: PUSH
14125: LD_VAR 0 6
14129: PPUSH
14130: LD_INT 1
14132: PPUSH
14133: CALL_OW 3
14137: ST_TO_ADDR
14138: GO 14117
14140: POP
14141: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14142: LD_ADDR_EXP 57
14146: PUSH
14147: LD_EXP 57
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 6
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14167: LD_VAR 0 2
14171: PUSH
14172: LD_STRING ToLab
14174: EQUAL
14175: IFFALSE 14280
// begin tmp := MREG_ToLab [ side ] ;
14177: LD_ADDR_VAR 0 6
14181: PUSH
14182: LD_EXP 56
14186: PUSH
14187: LD_VAR 0 1
14191: ARRAY
14192: ST_TO_ADDR
// if tmp = 0 then
14193: LD_VAR 0 6
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: IFFALSE 14207
// exit else
14203: GO 14288
14205: GO 14280
// begin for i = MREG_ToLab [ side ] downto n do
14207: LD_ADDR_VAR 0 5
14211: PUSH
14212: DOUBLE
14213: LD_EXP 56
14217: PUSH
14218: LD_VAR 0 1
14222: ARRAY
14223: INC
14224: ST_TO_ADDR
14225: LD_VAR 0 3
14229: PUSH
14230: FOR_DOWNTO
14231: IFFALSE 14253
// tmp := Delete ( tmp , 1 ) ;
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 6
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: CALL_OW 3
14250: ST_TO_ADDR
14251: GO 14230
14253: POP
14254: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_EXP 56
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_VAR 0 6
14274: PPUSH
14275: CALL_OW 1
14279: ST_TO_ADDR
// end ; end ; result := true ;
14280: LD_ADDR_VAR 0 4
14284: PUSH
14285: LD_INT 1
14287: ST_TO_ADDR
// end ;
14288: LD_VAR 0 4
14292: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14293: LD_INT 0
14295: PPUSH
14296: PPUSH
14297: PPUSH
// side := GetSide ( unit ) ;
14298: LD_ADDR_VAR 0 4
14302: PUSH
14303: LD_VAR 0 1
14307: PPUSH
14308: CALL_OW 255
14312: ST_TO_ADDR
// tmp := 0 ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 4
14335: ARRAY
14336: IN
14337: IFFALSE 14347
// tmp := 1 ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 1
14346: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14347: LD_VAR 0 1
14351: PUSH
14352: LD_EXP 59
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: IN
14363: IFFALSE 14373
// tmp := 2 ;
14365: LD_ADDR_VAR 0 3
14369: PUSH
14370: LD_INT 2
14372: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14373: LD_VAR 0 1
14377: PUSH
14378: LD_EXP 57
14382: PUSH
14383: LD_VAR 0 4
14387: ARRAY
14388: IN
14389: IFFALSE 14399
// tmp := 3 ;
14391: LD_ADDR_VAR 0 3
14395: PUSH
14396: LD_INT 3
14398: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 56
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: IN
14415: IFFALSE 14425
// tmp := 4 ;
14417: LD_ADDR_VAR 0 3
14421: PUSH
14422: LD_INT 4
14424: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14425: LD_VAR 0 1
14429: PUSH
14430: LD_EXP 70
14434: PUSH
14435: LD_VAR 0 4
14439: ARRAY
14440: IN
14441: IFFALSE 14451
// tmp := 5 ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 5
14450: ST_TO_ADDR
// result := tmp ;
14451: LD_ADDR_VAR 0 2
14455: PUSH
14456: LD_VAR 0 3
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
// if mreg = ToArm then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToArm
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToArm [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 58
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToArm [ side ] [ i ] = unit then
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 58
14532: PUSH
14533: LD_EXP 58
14537: PPUSH
14538: LD_EXP 58
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31211 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToDep then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToDep
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToDep [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 59
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToDep [ side ] [ i ] = unit then
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 59
14629: PUSH
14630: LD_EXP 59
14634: PPUSH
14635: LD_EXP 59
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31211 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// if mreg = ToFac then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_STRING ToFac
14671: EQUAL
14672: IFFALSE 14761
// for i = MREG_ToFac [ side ] downto 1 do
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: DOUBLE
14680: LD_EXP 57
14684: PUSH
14685: LD_VAR 0 1
14689: ARRAY
14690: INC
14691: ST_TO_ADDR
14692: LD_INT 1
14694: PUSH
14695: FOR_DOWNTO
14696: IFFALSE 14759
// if MREG_ToFac [ side ] [ i ] = unit then
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PUSH
14715: LD_VAR 0 3
14719: EQUAL
14720: IFFALSE 14757
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14722: LD_ADDR_EXP 57
14726: PUSH
14727: LD_EXP 57
14731: PPUSH
14732: LD_EXP 57
14736: PUSH
14737: LD_VAR 0 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 5
14747: ARRAY
14748: PPUSH
14749: LD_INT 1
14751: PPUSH
14752: CALL 31211 0 3
14756: ST_TO_ADDR
// end ;
14757: GO 14695
14759: POP
14760: POP
// if mreg = ToLab then
14761: LD_VAR 0 2
14765: PUSH
14766: LD_STRING ToLab
14768: EQUAL
14769: IFFALSE 14858
// for i = MREG_ToLab [ side ] downto 1 do
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: DOUBLE
14777: LD_EXP 56
14781: PUSH
14782: LD_VAR 0 1
14786: ARRAY
14787: INC
14788: ST_TO_ADDR
14789: LD_INT 1
14791: PUSH
14792: FOR_DOWNTO
14793: IFFALSE 14856
// if MREG_ToLab [ side ] [ i ] = unit then
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 3
14816: EQUAL
14817: IFFALSE 14854
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14819: LD_ADDR_EXP 56
14823: PUSH
14824: LD_EXP 56
14828: PPUSH
14829: LD_EXP 56
14833: PUSH
14834: LD_VAR 0 1
14838: ARRAY
14839: PUSH
14840: LD_VAR 0 5
14844: ARRAY
14845: PPUSH
14846: LD_INT 1
14848: PPUSH
14849: CALL 31211 0 3
14853: ST_TO_ADDR
// end ;
14854: GO 14792
14856: POP
14857: POP
// end ;
14858: LD_VAR 0 4
14862: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14863: LD_INT 0
14865: PPUSH
14866: PPUSH
// result := false ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_INT 0
14874: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_EXP 48
14889: PUSH
14890: FOR_TO
14891: IFFALSE 14955
// if MREG_ToBuild [ i ] [ 1 ] = side then
14893: LD_EXP 48
14897: PUSH
14898: LD_VAR 0 3
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 1
14912: EQUAL
14913: IFFALSE 14953
// begin if MREG_ToBuild [ i ] [ 1 ] then
14915: LD_EXP 48
14919: PUSH
14920: LD_VAR 0 3
14924: ARRAY
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: IFFALSE 14953
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_EXP 48
14940: PUSH
14941: LD_VAR 0 3
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: ST_TO_ADDR
// break ;
14951: GO 14955
// end ; end ;
14953: GO 14890
14955: POP
14956: POP
// for i = 1 to MREG_ToRepair do
14957: LD_ADDR_VAR 0 3
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 49
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15037
// if MREG_ToRepair [ i ] [ 1 ] = side then
14975: LD_EXP 49
14979: PUSH
14980: LD_VAR 0 3
14984: ARRAY
14985: PUSH
14986: LD_INT 1
14988: ARRAY
14989: PUSH
14990: LD_VAR 0 1
14994: EQUAL
14995: IFFALSE 15035
// begin if MREG_ToRepair [ i ] [ 1 ] then
14997: LD_EXP 49
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: IFFALSE 15035
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15013: LD_ADDR_VAR 0 2
15017: PUSH
15018: LD_EXP 49
15022: PUSH
15023: LD_VAR 0 3
15027: ARRAY
15028: PUSH
15029: LD_INT 1
15031: ARRAY
15032: ST_TO_ADDR
// break ;
15033: GO 15037
// end ; end ;
15035: GO 14972
15037: POP
15038: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 57
15046: PUSH
15047: EMPTY
15048: LIST
15049: PPUSH
15050: CALL 11587 0 2
15054: IFFALSE 15081
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15056: LD_ADDR_VAR 0 2
15060: PUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 57
15068: PUSH
15069: EMPTY
15070: LIST
15071: PPUSH
15072: CALL 11587 0 2
15076: PUSH
15077: LD_INT 1
15079: ARRAY
15080: ST_TO_ADDR
// end ;
15081: LD_VAR 0 2
15085: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15093: LD_ADDR_VAR 0 6
15097: PUSH
15098: LD_VAR 0 1
15102: PPUSH
15103: LD_INT 21
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PPUSH
15113: CALL 11587 0 2
15117: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15118: LD_ADDR_VAR 0 7
15122: PUSH
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_INT 81
15130: PUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 11587 0 2
15144: ST_TO_ADDR
// if not enemy then
15145: LD_VAR 0 7
15149: NOT
15150: IFFALSE 15162
// result := false else
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 0
15159: ST_TO_ADDR
15160: GO 15216
// begin scan := NearestUnit ( b , enemy ) ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 6
15171: PPUSH
15172: LD_VAR 0 7
15176: PPUSH
15177: CALL 32204 0 2
15181: ST_TO_ADDR
// if scan [ 2 ] < dist then
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 2
15189: ARRAY
15190: PUSH
15191: LD_VAR 0 2
15195: LESS
15196: IFFALSE 15208
// result := true else
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
15206: GO 15216
// result := false ;
15208: LD_ADDR_VAR 0 3
15212: PUSH
15213: LD_INT 0
15215: ST_TO_ADDR
// end ; end ;
15216: LD_VAR 0 3
15220: RET
// export function MCF_Info ( ) ; begin
15221: LD_INT 0
15223: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15224: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15226: PUSH
15227: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15229: ADD
15230: PUSH
15231: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15233: ADD
15234: PUSH
15235: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15237: ADD
15238: PUSH
15239: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15241: ADD
15242: PUSH
15243: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15245: ADD
15246: PUSH
15247: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15249: ADD
15250: PUSH
15251: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15253: ADD
15254: PUSH
15255: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15257: ADD
15258: PUSH
15259: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15261: ADD
15262: PPUSH
15263: CALL 8505 0 1
// end ; end_of_file
15267: LD_VAR 0 1
15271: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15272: LD_INT 0
15274: PPUSH
15275: PPUSH
15276: PPUSH
15277: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15278: LD_ADDR_VAR 0 5
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 25
15293: PUSH
15294: LD_INT 2
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PUSH
15301: LD_INT 25
15303: PUSH
15304: LD_INT 3
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 25
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL 11587 0 2
15331: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_VAR 0 5
15341: PPUSH
15342: LD_INT 0
15344: PPUSH
15345: CALL 13736 0 2
15349: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15350: LD_ADDR_VAR 0 6
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 5
15364: PPUSH
15365: LD_INT 1
15367: PPUSH
15368: CALL 13356 0 3
15372: ST_TO_ADDR
// if n > sk then
15373: LD_VAR 0 2
15377: PUSH
15378: LD_VAR 0 6
15382: GREATER
15383: IFFALSE 15395
// n := sk ;
15385: LD_ADDR_VAR 0 2
15389: PUSH
15390: LD_VAR 0 6
15394: ST_TO_ADDR
// for i = 1 to n do
15395: LD_ADDR_VAR 0 4
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_TO
15411: IFFALSE 15523
// if ( sk [ i ] [ 1 ] ) <> 0 then
15413: LD_VAR 0 6
15417: PUSH
15418: LD_VAR 0 4
15422: ARRAY
15423: PUSH
15424: LD_INT 1
15426: ARRAY
15427: PUSH
15428: LD_INT 0
15430: NONEQUAL
15431: IFFALSE 15521
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15433: LD_ADDR_EXP 55
15437: PUSH
15438: LD_EXP 55
15442: PPUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 6
15452: PUSH
15453: LD_VAR 0 4
15457: ARRAY
15458: PUSH
15459: LD_INT 1
15461: ARRAY
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: CALL 41882 0 4
15470: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_EXP 58
15480: PPUSH
15481: LD_VAR 0 1
15485: PPUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PUSH
15497: LD_INT 1
15499: PLUS
15500: PPUSH
15501: LD_VAR 0 6
15505: PUSH
15506: LD_VAR 0 4
15510: ARRAY
15511: PUSH
15512: LD_INT 1
15514: ARRAY
15515: PPUSH
15516: CALL 31052 0 4
15520: ST_TO_ADDR
// end ;
15521: GO 15410
15523: POP
15524: POP
// end ;
15525: LD_VAR 0 3
15529: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15530: LD_INT 0
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: LD_INT 2
15548: PUSH
15549: LD_INT 25
15551: PUSH
15552: LD_INT 1
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: LD_INT 25
15561: PUSH
15562: LD_INT 3
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 25
15571: PUSH
15572: LD_INT 4
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: PPUSH
15585: CALL 11587 0 2
15589: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15590: LD_ADDR_VAR 0 5
15594: PUSH
15595: LD_VAR 0 5
15599: PPUSH
15600: LD_INT 0
15602: PPUSH
15603: CALL 13736 0 2
15607: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_VAR 0 5
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL 13356 0 3
15630: ST_TO_ADDR
// if n > sk then
15631: LD_VAR 0 2
15635: PUSH
15636: LD_VAR 0 6
15640: GREATER
15641: IFFALSE 15653
// n := sk ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_VAR 0 6
15652: ST_TO_ADDR
// for i = 1 to n do
15653: LD_ADDR_VAR 0 4
15657: PUSH
15658: DOUBLE
15659: LD_INT 1
15661: DEC
15662: ST_TO_ADDR
15663: LD_VAR 0 2
15667: PUSH
15668: FOR_TO
15669: IFFALSE 15781
// if ( sk [ i ] [ 1 ] ) <> 0 then
15671: LD_VAR 0 6
15675: PUSH
15676: LD_VAR 0 4
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_INT 0
15688: NONEQUAL
15689: IFFALSE 15779
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15691: LD_ADDR_EXP 55
15695: PUSH
15696: LD_EXP 55
15700: PPUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PUSH
15711: LD_VAR 0 4
15715: ARRAY
15716: PUSH
15717: LD_INT 1
15719: ARRAY
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL 41882 0 4
15728: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15729: LD_ADDR_EXP 59
15733: PUSH
15734: LD_EXP 59
15738: PPUSH
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_EXP 59
15748: PUSH
15749: LD_VAR 0 1
15753: ARRAY
15754: PUSH
15755: LD_INT 1
15757: PLUS
15758: PPUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 4
15768: ARRAY
15769: PUSH
15770: LD_INT 1
15772: ARRAY
15773: PPUSH
15774: CALL 31052 0 4
15778: ST_TO_ADDR
// end ;
15779: GO 15668
15781: POP
15782: POP
// end ;
15783: LD_VAR 0 3
15787: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15788: LD_INT 0
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15794: LD_ADDR_VAR 0 5
15798: PUSH
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 2
15806: PUSH
15807: LD_INT 25
15809: PUSH
15810: LD_INT 1
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 25
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 25
15829: PUSH
15830: LD_INT 4
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11587 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13736 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 3
15883: PPUSH
15884: CALL 13356 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL 41882 0 4
15986: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 57
15991: PUSH
15992: LD_EXP 57
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 57
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 31052 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL 11587 0 2
16094: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: LD_VAR 0 5
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL 13736 0 2
16112: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16113: LD_ADDR_VAR 0 6
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 5
16127: PPUSH
16128: LD_INT 4
16130: PPUSH
16131: CALL 13356 0 3
16135: ST_TO_ADDR
// if n > sk then
16136: LD_VAR 0 2
16140: PUSH
16141: LD_VAR 0 6
16145: GREATER
16146: IFFALSE 16158
// n := sk ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_VAR 0 6
16157: ST_TO_ADDR
// for i = 1 to n do
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: DOUBLE
16164: LD_INT 1
16166: DEC
16167: ST_TO_ADDR
16168: LD_VAR 0 2
16172: PUSH
16173: FOR_TO
16174: IFFALSE 16286
// if ( sk [ i ] [ 1 ] ) <> 0 then
16176: LD_VAR 0 6
16180: PUSH
16181: LD_VAR 0 4
16185: ARRAY
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PUSH
16191: LD_INT 0
16193: NONEQUAL
16194: IFFALSE 16284
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16196: LD_ADDR_EXP 55
16200: PUSH
16201: LD_EXP 55
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 6
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: LD_INT 4
16228: PPUSH
16229: CALL 41882 0 4
16233: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16234: LD_ADDR_EXP 56
16238: PUSH
16239: LD_EXP 56
16243: PPUSH
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_EXP 56
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PUSH
16260: LD_INT 1
16262: PLUS
16263: PPUSH
16264: LD_VAR 0 6
16268: PUSH
16269: LD_VAR 0 4
16273: ARRAY
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL 31052 0 4
16283: ST_TO_ADDR
// end ;
16284: GO 16173
16286: POP
16287: POP
// end ;
16288: LD_VAR 0 3
16292: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16293: LD_INT 0
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_INT 2
16311: PUSH
16312: LD_INT 25
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 25
16324: PUSH
16325: LD_INT 2
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 25
16334: PUSH
16335: LD_INT 3
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PUSH
16342: LD_INT 25
16344: PUSH
16345: LD_INT 4
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL 11587 0 2
16363: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16364: LD_ADDR_VAR 0 6
16368: PUSH
16369: LD_VAR 0 6
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL 13736 0 2
16381: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16382: LD_ADDR_VAR 0 7
16386: PUSH
16387: LD_VAR 0 1
16391: PPUSH
16392: LD_VAR 0 6
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: CALL 13356 0 3
16404: ST_TO_ADDR
// if n > sk then
16405: LD_VAR 0 2
16409: PUSH
16410: LD_VAR 0 7
16414: GREATER
16415: IFFALSE 16427
// n := sk ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 7
16426: ST_TO_ADDR
// for i = 1 to n do
16427: LD_ADDR_VAR 0 5
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16445: LD_ADDR_EXP 55
16449: PUSH
16450: LD_EXP 55
16454: PPUSH
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PUSH
16465: LD_VAR 0 5
16469: ARRAY
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: CALL 41882 0 4
16484: ST_TO_ADDR
// end ;
16485: GO 16442
16487: POP
16488: POP
// end ;
16489: LD_VAR 0 4
16493: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// b := false ;
16499: LD_ADDR_VAR 0 6
16503: PUSH
16504: LD_INT 0
16506: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 9
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 8
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: IN
16530: IFFALSE 16618
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 30
16542: PUSH
16543: LD_INT 4
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL 11587 0 2
16569: IFFALSE 16618
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16571: LD_ADDR_VAR 0 6
16575: PUSH
16576: LD_VAR 0 1
16580: PPUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 30
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 5
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL 11587 0 2
16613: PUSH
16614: LD_INT 1
16616: ARRAY
16617: ST_TO_ADDR
// if class = class_engineer then
16618: LD_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: EQUAL
16626: IFFALSE 16714
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16628: LD_VAR 0 1
16632: PPUSH
16633: LD_INT 2
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 0
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PPUSH
16661: CALL 11587 0 2
16665: IFFALSE 16714
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16667: LD_ADDR_VAR 0 6
16671: PUSH
16672: LD_VAR 0 1
16676: PPUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 30
16682: PUSH
16683: LD_INT 0
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 30
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11587 0 2
16709: PUSH
16710: LD_INT 1
16712: ARRAY
16713: ST_TO_ADDR
// if class = class_mechanic then
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 3
16721: EQUAL
16722: IFFALSE 16792
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16724: LD_VAR 0 1
16728: PPUSH
16729: LD_INT 30
16731: PUSH
16732: LD_INT 3
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL 11587 0 2
16743: IFFALSE 16792
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16745: LD_ADDR_VAR 0 6
16749: PUSH
16750: LD_VAR 0 1
16754: PPUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 30
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 30
16770: PUSH
16771: LD_INT 3
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL 11587 0 2
16787: PUSH
16788: LD_INT 1
16790: ARRAY
16791: ST_TO_ADDR
// if class = class_scientistic then
16792: LD_VAR 0 3
16796: PUSH
16797: LD_INT 4
16799: EQUAL
16800: IFFALSE 16910
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16802: LD_VAR 0 1
16806: PPUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 30
16812: PUSH
16813: LD_INT 6
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 30
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 30
16832: PUSH
16833: LD_INT 8
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL 11587 0 2
16850: IFFALSE 16910
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16852: LD_ADDR_VAR 0 6
16856: PUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: LD_INT 2
16864: PUSH
16865: LD_INT 30
16867: PUSH
16868: LD_INT 6
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 30
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 30
16887: PUSH
16888: LD_INT 8
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PPUSH
16901: CALL 11587 0 2
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: ST_TO_ADDR
// if GetClass ( unit ) = class then
16910: LD_VAR 0 2
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_VAR 0 3
16924: EQUAL
16925: IFFALSE 16959
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16927: LD_ADDR_EXP 55
16931: PUSH
16932: LD_EXP 55
16936: PPUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: LD_VAR 0 3
16951: PPUSH
16952: CALL 41973 0 4
16956: ST_TO_ADDR
// end else
16957: GO 17052
// if b then
16959: LD_VAR 0 6
16963: IFFALSE 17044
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 310
16974: PUSH
16975: LD_VAR 0 2
16979: PPUSH
16980: CALL_OW 310
16984: PUSH
16985: LD_VAR 0 6
16989: NONEQUAL
16990: AND
16991: IFFALSE 17002
// ComExitBuilding ( unit ) ;
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL_OW 122
// if not IsInUnit ( unit ) then
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 310
17011: NOT
17012: IFFALSE 17028
// ComEnterUnit ( unit , b ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17028: LD_VAR 0 2
17032: PPUSH
17033: LD_VAR 0 3
17037: PPUSH
17038: CALL_OW 183
// end else
17042: GO 17052
// result := false ;
17044: LD_ADDR_VAR 0 4
17048: PUSH
17049: LD_INT 0
17051: ST_TO_ADDR
// end ; end_of_file
17052: LD_VAR 0 4
17056: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
17062: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17063: LD_ADDR_VAR 0 5
17067: PUSH
17068: LD_INT 35
17070: PUSH
17071: LD_INT 45
17073: PUSH
17074: LD_INT 46
17076: PUSH
17077: LD_INT 47
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 48
17088: PUSH
17089: LD_INT 49
17091: PUSH
17092: LD_INT 50
17094: PUSH
17095: LD_INT 20
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
// if MCF_Lab ( side ) then
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 11626 0 1
17119: IFFALSE 17358
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL 11626 0 1
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: CALL_OW 461
17139: PUSH
17140: LD_INT 2
17142: EQUAL
17143: IFFALSE 17282
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL 11626 0 1
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL 17454 0 2
17168: IFFALSE 17195
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL 11626 0 1
17179: PUSH
17180: LD_INT 1
17182: ARRAY
17183: PPUSH
17184: LD_VAR 0 2
17188: PPUSH
17189: CALL_OW 124
17193: GO 17282
// if MCF_Lab ( side ) > 1 then
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL 11626 0 1
17204: PUSH
17205: LD_INT 1
17207: GREATER
17208: IFFALSE 17282
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17210: LD_VAR 0 1
17214: PPUSH
17215: CALL 11626 0 1
17219: PUSH
17220: LD_INT 2
17222: ARRAY
17223: PPUSH
17224: CALL_OW 461
17228: PUSH
17229: LD_INT 2
17231: EQUAL
17232: IFFALSE 17282
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11626 0 1
17243: PUSH
17244: LD_INT 2
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL 17454 0 2
17257: IFFALSE 17282
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11626 0 1
17268: PUSH
17269: LD_INT 2
17271: ARRAY
17272: PPUSH
17273: LD_VAR 0 2
17277: PPUSH
17278: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17282: LD_VAR 0 2
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: LD_INT 11
17292: PUSH
17293: LD_INT 4
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: IN
17305: IFFALSE 17358
// begin for lab in MCF_Lab ( side ) do
17307: LD_ADDR_VAR 0 6
17311: PUSH
17312: LD_VAR 0 1
17316: PPUSH
17317: CALL 11626 0 1
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17356
// if BuildingStatus ( lab ) = bs_need_ape then
17325: LD_VAR 0 6
17329: PPUSH
17330: CALL_OW 461
17334: PUSH
17335: LD_INT 10
17337: EQUAL
17338: IFFALSE 17354
// MCL_ResTame ( side , lab ) ;
17340: LD_VAR 0 1
17344: PPUSH
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL 17579 0 2
17354: GO 17322
17356: POP
17357: POP
// end ; end ; end ;
17358: LD_VAR 0 3
17362: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
// tmp := [ ] ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: EMPTY
17373: ST_TO_ADDR
// if not lab then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17391
// result := false else
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: LD_INT 0
17388: ST_TO_ADDR
17389: GO 17449
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: CALL_OW 268
17413: ADD
17414: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 3
17424: PUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: LD_INT 2
17432: PPUSH
17433: CALL_OW 268
17437: ADD
17438: ST_TO_ADDR
// result := tmp ;
17439: LD_ADDR_VAR 0 2
17443: PUSH
17444: LD_VAR 0 3
17448: ST_TO_ADDR
// end ; end ;
17449: LD_VAR 0 2
17453: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 35
17466: PUSH
17467: LD_INT 45
17469: PUSH
17470: LD_INT 46
17472: PUSH
17473: LD_INT 47
17475: PUSH
17476: LD_INT 1
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: LD_INT 48
17484: PUSH
17485: LD_INT 49
17487: PUSH
17488: LD_INT 50
17490: PUSH
17491: LD_INT 20
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: ST_TO_ADDR
// if lab then
17506: LD_VAR 0 1
17510: IFFALSE 17566
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17512: LD_VAR 0 2
17516: PUSH
17517: LD_VAR 0 5
17521: IN
17522: PUSH
17523: LD_VAR 0 2
17527: PPUSH
17528: CALL_OW 481
17532: PUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: CALL 17363 0 1
17542: IN
17543: OR
17544: IFFALSE 17556
// result := true else
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
17554: GO 17564
// result := false ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_INT 0
17563: ST_TO_ADDR
// end else
17564: GO 17574
// result := false ;
17566: LD_ADDR_VAR 0 3
17570: PUSH
17571: LD_INT 0
17573: ST_TO_ADDR
// end ;
17574: LD_VAR 0 3
17578: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17579: LD_INT 0
17581: PPUSH
17582: PPUSH
17583: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 171
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL 12290 0 3
17603: ST_TO_ADDR
// if not ape then
17604: LD_VAR 0 4
17608: NOT
17609: IFFALSE 17641
// if MCF_Ape ( side ) then
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL 12000 0 1
17620: IFFALSE 17641
// ape := MCF_Ape ( side ) [ 1 ] ;
17622: LD_ADDR_VAR 0 4
17626: PUSH
17627: LD_VAR 0 1
17631: PPUSH
17632: CALL 12000 0 1
17636: PUSH
17637: LD_INT 1
17639: ARRAY
17640: ST_TO_ADDR
// if ape then
17641: LD_VAR 0 4
17645: IFFALSE 17696
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17647: LD_VAR 0 4
17651: PUSH
17652: LD_INT 1
17654: ARRAY
17655: PPUSH
17656: CALL_OW 310
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: LD_INT 1
17668: ARRAY
17669: PPUSH
17670: CALL_OW 310
17674: PUSH
17675: LD_VAR 0 2
17679: NONEQUAL
17680: AND
17681: IFFALSE 17696
// ComExitBuilding ( ape [ 1 ] ) ;
17683: LD_VAR 0 4
17687: PUSH
17688: LD_INT 1
17690: ARRAY
17691: PPUSH
17692: CALL_OW 122
// if not lab then
17696: LD_VAR 0 2
17700: NOT
17701: IFFALSE 17707
// exit else
17703: GO 17855
17705: GO 17815
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 16
17714: PPUSH
17715: LD_INT 25
17717: PUSH
17718: LD_INT 4
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL 12290 0 3
17729: PUSH
17730: LD_INT 0
17732: EQUAL
17733: PUSH
17734: LD_VAR 0 2
17738: PPUSH
17739: CALL_OW 313
17743: PUSH
17744: LD_INT 6
17746: EQUAL
17747: AND
17748: IFFALSE 17815
// begin tmp := UnitsInside ( lab ) ;
17750: LD_ADDR_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: CALL_OW 313
17764: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 5
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 5
17792: ARRAY
17793: PPUSH
17794: CALL_OW 310
17798: IFFALSE 17815
// ComExitBuilding ( tmp [ tmp ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 5
17809: ARRAY
17810: PPUSH
17811: CALL_OW 122
// end ; if ape then
17815: LD_VAR 0 4
17819: IFFALSE 17855
// if not IsInUnit ( ape [ 1 ] ) then
17821: LD_VAR 0 4
17825: PUSH
17826: LD_INT 1
17828: ARRAY
17829: PPUSH
17830: CALL_OW 310
17834: NOT
17835: IFFALSE 17855
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PPUSH
17846: LD_VAR 0 2
17850: PPUSH
17851: CALL_OW 120
// end ;
17855: LD_VAR 0 3
17859: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17860: LD_INT 0
17862: PPUSH
17863: PPUSH
17864: PPUSH
// result := false ;
17865: LD_ADDR_VAR 0 2
17869: PUSH
17870: LD_INT 0
17872: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 1
17882: PPUSH
17883: CALL 17970 0 1
17887: ST_TO_ADDR
// if techs then
17888: LD_VAR 0 3
17892: IFFALSE 17922
// if techs [ 2 ] then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 2
17901: ARRAY
17902: IFFALSE 17914
// result := true else
17904: LD_ADDR_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: ST_TO_ADDR
17912: GO 17922
// result := false ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// end ;
17922: LD_VAR 0 2
17926: RET
// export function MCL_Start ( side ) ; var i ; begin
17927: LD_INT 0
17929: PPUSH
17930: PPUSH
// if MCL_GetTechList ( side ) then
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 17970 0 1
17940: IFFALSE 17965
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 17970 0 1
17956: PUSH
17957: LD_INT 1
17959: ARRAY
17960: PPUSH
17961: CALL 17057 0 2
// end ;
17965: LD_VAR 0 2
17969: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17970: LD_INT 0
17972: PPUSH
17973: PPUSH
17974: PPUSH
// if MREG_ToRes then
17975: LD_EXP 52
17979: IFFALSE 18064
// for i = 1 to MREG_ToRes do
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: DOUBLE
17987: LD_INT 1
17989: DEC
17990: ST_TO_ADDR
17991: LD_EXP 52
17995: PUSH
17996: FOR_TO
17997: IFFALSE 18062
// if MREG_ToRes [ i ] [ 1 ] = side then
17999: LD_EXP 52
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 1
18012: ARRAY
18013: PUSH
18014: LD_VAR 0 1
18018: EQUAL
18019: IFFALSE 18060
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18021: LD_ADDR_VAR 0 4
18025: PUSH
18026: LD_VAR 0 4
18030: PPUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: PLUS
18039: PPUSH
18040: LD_EXP 52
18044: PUSH
18045: LD_VAR 0 3
18049: ARRAY
18050: PUSH
18051: LD_INT 2
18053: ARRAY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// end ;
18060: GO 17996
18062: POP
18063: POP
// result := techs ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_VAR 0 4
18073: ST_TO_ADDR
// end ;
18074: LD_VAR 0 2
18078: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18079: LD_INT 0
18081: PPUSH
18082: PPUSH
// for i = 1 to tech_list do
18083: LD_ADDR_VAR 0 4
18087: PUSH
18088: DOUBLE
18089: LD_INT 1
18091: DEC
18092: ST_TO_ADDR
18093: LD_VAR 0 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18153
// if not tech_list [ i ] = 20 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_VAR 0 4
18110: ARRAY
18111: PUSH
18112: LD_INT 20
18114: EQUAL
18115: NOT
18116: IFFALSE 18151
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18118: LD_ADDR_EXP 52
18122: PUSH
18123: LD_EXP 52
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: ARRAY
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL 41882 0 4
18150: ST_TO_ADDR
18151: GO 18098
18153: POP
18154: POP
// result := true ;
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
// for i = MREG_ToRes downto 1 do
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: DOUBLE
18178: LD_EXP 52
18182: INC
18183: ST_TO_ADDR
18184: LD_INT 1
18186: PUSH
18187: FOR_DOWNTO
18188: IFFALSE 18234
// if MREG_ToRes [ i ] [ 1 ] = side then
18190: LD_EXP 52
18194: PUSH
18195: LD_VAR 0 3
18199: ARRAY
18200: PUSH
18201: LD_INT 1
18203: ARRAY
18204: PUSH
18205: LD_VAR 0 1
18209: EQUAL
18210: IFFALSE 18232
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18212: LD_ADDR_EXP 52
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: LD_VAR 0 3
18226: PPUSH
18227: CALL_OW 3
18231: ST_TO_ADDR
18232: GO 18187
18234: POP
18235: POP
// result := true ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 1
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18249: LD_INT 0
18251: PPUSH
// result := GetTechProgress ( side , tech ) ;
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: CALL_OW 326
18271: ST_TO_ADDR
// end ;
18272: LD_VAR 0 3
18276: RET
// export function MCL_Require ( tech ) ; begin
18277: LD_INT 0
18279: PPUSH
// result := GetTechTechsReq ( tech ) ;
18280: LD_ADDR_VAR 0 2
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 480
18294: ST_TO_ADDR
// end ; end_of_file
18295: LD_VAR 0 2
18299: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18300: LD_INT 0
18302: PPUSH
18303: PPUSH
18304: PPUSH
// uc_side := 0 ;
18305: LD_ADDR_OWVAR 20
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// uc_nation := 0 ;
18313: LD_ADDR_OWVAR 21
18317: PUSH
18318: LD_INT 0
18320: ST_TO_ADDR
// for i = 1 to n do
18321: LD_ADDR_VAR 0 5
18325: PUSH
18326: DOUBLE
18327: LD_INT 1
18329: DEC
18330: ST_TO_ADDR
18331: LD_VAR 0 2
18335: PUSH
18336: FOR_TO
18337: IFFALSE 18482
// begin hc_importance := 0 ;
18339: LD_ADDR_OWVAR 32
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// hc_gallery :=  ;
18347: LD_ADDR_OWVAR 33
18351: PUSH
18352: LD_STRING 
18354: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18355: LD_ADDR_OWVAR 35
18359: PUSH
18360: LD_VAR 0 3
18364: PUSH
18365: LD_INT 20
18367: MINUS
18368: PPUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_INT 20
18376: PLUS
18377: PPUSH
18378: CALL_OW 12
18382: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18383: LD_ADDR_OWVAR 31
18387: PUSH
18388: LD_INT 0
18390: PPUSH
18391: LD_INT 2
18393: PPUSH
18394: CALL_OW 12
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: LD_INT 0
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18414: LD_ADDR_OWVAR 30
18418: PUSH
18419: LD_INT 0
18421: PUSH
18422: LD_INT 0
18424: PUSH
18425: LD_INT 0
18427: PUSH
18428: LD_INT 0
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_class := class_apeman ;
18445: LD_ADDR_OWVAR 28
18449: PUSH
18450: LD_INT 12
18452: ST_TO_ADDR
// ape := CreateHuman ;
18453: LD_ADDR_VAR 0 6
18457: PUSH
18458: CALL_OW 44
18462: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18463: LD_VAR 0 6
18467: PPUSH
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 0
18475: PPUSH
18476: CALL_OW 49
// end ;
18480: GO 18336
18482: POP
18483: POP
// end ;
18484: LD_VAR 0 4
18488: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18489: LD_INT 0
18491: PPUSH
18492: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL 12000 0 1
18502: PUSH
18503: LD_EXP 39
18507: PUSH
18508: LD_VAR 0 1
18512: ARRAY
18513: GREATEREQUAL
18514: IFFALSE 18691
// begin if GetTag ( unit ) = 17 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 17
18528: EQUAL
18529: IFFALSE 18689
// begin SetTag ( unit , 0 ) ;
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 0
18538: PPUSH
18539: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18543: LD_VAR 0 1
18547: PPUSH
18548: CALL 11626 0 1
18552: PUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL 17970 0 1
18562: NOT
18563: AND
18564: IFFALSE 18589
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18566: LD_VAR 0 2
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: CALL 11626 0 1
18580: PUSH
18581: LD_INT 1
18583: ARRAY
18584: PPUSH
18585: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18589: LD_VAR 0 1
18593: PPUSH
18594: CALL 11626 0 1
18598: NOT
18599: PUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL 11587 0 2
18619: AND
18620: IFFALSE 18689
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18622: LD_VAR 0 2
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: LD_INT 30
18634: PUSH
18635: LD_INT 1
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PPUSH
18642: CALL 11587 0 2
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 250
18655: PPUSH
18656: LD_VAR 0 1
18660: PPUSH
18661: LD_INT 30
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL 11587 0 2
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: PPUSH
18680: CALL_OW 251
18684: PPUSH
18685: CALL_OW 111
// end ; end else
18689: GO 18875
// if GetClass ( unit ) <> 4 then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 257
18700: PUSH
18701: LD_INT 4
18703: NONEQUAL
18704: IFFALSE 18710
// exit else
18706: GO 18875
18708: GO 18875
// if GetTag ( unit ) = 0 then
18710: LD_VAR 0 2
18714: PPUSH
18715: CALL_OW 110
18719: PUSH
18720: LD_INT 0
18722: EQUAL
18723: IFFALSE 18739
// SetTag ( unit , 17 ) else
18725: LD_VAR 0 2
18729: PPUSH
18730: LD_INT 17
18732: PPUSH
18733: CALL_OW 109
18737: GO 18875
// begin if IsInUnit ( unit ) then
18739: LD_VAR 0 2
18743: PPUSH
18744: CALL_OW 310
18748: IFFALSE 18759
// ComExitBuilding ( unit ) ;
18750: LD_VAR 0 2
18754: PPUSH
18755: CALL_OW 122
// Wait ( 1 ) ;
18759: LD_INT 1
18761: PPUSH
18762: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: LD_INT 22
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 12
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: PPUSH
18800: LD_VAR 0 2
18804: PPUSH
18805: CALL_OW 74
18809: ST_TO_ADDR
// if not ape then
18810: LD_VAR 0 4
18814: NOT
18815: IFFALSE 18821
// exit else
18817: GO 18875
18819: GO 18830
// ComHold ( ape ) ;
18821: LD_VAR 0 4
18825: PPUSH
18826: CALL_OW 140
// if not HasTask ( unit ) then
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 314
18839: NOT
18840: IFFALSE 18873
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18842: LD_VAR 0 2
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: CALL_OW 250
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: CALL_OW 251
18866: PPUSH
18867: CALL_OW 131
18871: GO 18875
// exit ;
18873: GO 18875
// end ; end ;
18875: LD_VAR 0 3
18879: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18880: LD_INT 0
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_EXP 40
18895: PUSH
18896: LD_VAR 0 1
18900: ARRAY
18901: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18902: LD_ADDR_VAR 0 5
18906: PUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_STRING normal
18914: PPUSH
18915: CALL 12084 0 2
18919: ST_TO_ADDR
// if apes then
18920: LD_VAR 0 5
18924: IFFALSE 19152
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18926: LD_INT 2
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: CALL_OW 321
18938: PUSH
18939: LD_INT 2
18941: EQUAL
18942: PUSH
18943: LD_VAR 0 4
18947: PUSH
18948: LD_INT 2
18950: ARRAY
18951: PUSH
18952: LD_INT 1
18954: EQUAL
18955: AND
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_STRING engineer
18964: PPUSH
18965: CALL 12084 0 2
18969: PUSH
18970: LD_INT 3
18972: LESS
18973: AND
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 30
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PPUSH
18990: CALL 11587 0 2
18994: AND
18995: IFFALSE 19049
// begin for i in apes do
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 5
19006: PUSH
19007: FOR_IN
19008: IFFALSE 19045
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_VAR 0 1
19019: PPUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL 11587 0 2
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: PPUSH
19039: CALL_OW 120
// end ;
19043: GO 19007
19045: POP
19046: POP
// end else
19047: GO 19152
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19049: LD_INT 11
19051: PPUSH
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 321
19061: PUSH
19062: LD_INT 2
19064: EQUAL
19065: PUSH
19066: LD_VAR 0 4
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PUSH
19075: LD_INT 1
19077: EQUAL
19078: AND
19079: PUSH
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 30
19087: PUSH
19088: LD_INT 5
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PPUSH
19095: CALL 11587 0 2
19099: AND
19100: IFFALSE 19152
// begin for i in apes do
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19150
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19115: LD_VAR 0 3
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 30
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL 11587 0 2
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PPUSH
19144: CALL_OW 120
// end ;
19148: GO 19112
19150: POP
19151: POP
// end ; end ; end ; end_of_file
19152: LD_VAR 0 2
19156: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 257
19170: PUSH
19171: LD_INT 4
19173: EQUAL
19174: NOT
19175: PUSH
19176: LD_VAR 0 2
19180: NOT
19181: OR
19182: IFFALSE 19188
// exit else
19184: GO 19222
19186: GO 19222
// if not GetTag ( unit ) = 4 then
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 110
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: NOT
19202: IFFALSE 19208
// exit else
19204: GO 19222
19206: GO 19222
// ComHeal ( unit , target ) ;
19208: LD_VAR 0 1
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: CALL_OW 128
// end ;
19222: LD_VAR 0 3
19226: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19227: LD_INT 0
19229: PPUSH
19230: PPUSH
19231: PPUSH
19232: PPUSH
19233: PPUSH
19234: PPUSH
19235: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19236: LD_ADDR_VAR 0 5
19240: PUSH
19241: LD_INT 22
19243: PUSH
19244: LD_VAR 0 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 55
19268: PUSH
19269: EMPTY
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 3
19278: PUSH
19279: LD_INT 54
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: LD_INT 1000
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19318: LD_ADDR_VAR 0 8
19322: PUSH
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_INT 30
19330: PUSH
19331: LD_INT 1
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL 11587 0 2
19342: ST_TO_ADDR
// r := [ ] ;
19343: LD_ADDR_VAR 0 6
19347: PUSH
19348: EMPTY
19349: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 5
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL 12290 0 3
19364: IFFALSE 19420
// for j in MCF_Tag ( side , 5 , [ ] ) do
19366: LD_ADDR_VAR 0 4
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: EMPTY
19380: PPUSH
19381: CALL 12290 0 3
19385: PUSH
19386: FOR_IN
19387: IFFALSE 19418
// if GetLives ( j ) = 1000 then
19389: LD_VAR 0 4
19393: PPUSH
19394: CALL_OW 256
19398: PUSH
19399: LD_INT 1000
19401: EQUAL
19402: IFFALSE 19416
// SetTag ( j , 0 ) ;
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 109
19416: GO 19386
19418: POP
19419: POP
// if tmp then
19420: LD_VAR 0 5
19424: IFFALSE 19753
// begin r := [ tmp [ 1 ] ] ;
19426: LD_ADDR_VAR 0 6
19430: PUSH
19431: LD_VAR 0 5
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: PUSH
19440: EMPTY
19441: LIST
19442: ST_TO_ADDR
// for i = 2 to tmp do
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: DOUBLE
19449: LD_INT 2
19451: DEC
19452: ST_TO_ADDR
19453: LD_VAR 0 5
19457: PUSH
19458: FOR_TO
19459: IFFALSE 19751
// begin m := false ;
19461: LD_ADDR_VAR 0 7
19465: PUSH
19466: LD_INT 0
19468: ST_TO_ADDR
// if d then
19469: LD_VAR 0 8
19473: IFFALSE 19628
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19475: LD_VAR 0 5
19479: PUSH
19480: LD_VAR 0 3
19484: ARRAY
19485: PPUSH
19486: CALL_OW 256
19490: PUSH
19491: LD_INT 650
19493: LESS
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_VAR 0 3
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 8
19510: PUSH
19511: LD_INT 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 250
19519: PPUSH
19520: LD_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: CALL_OW 251
19533: PPUSH
19534: CALL_OW 297
19538: PUSH
19539: LD_INT 10
19541: GREATER
19542: AND
19543: IFFALSE 19628
// begin if not GetTag ( tmp [ i ] ) = 5 then
19545: LD_VAR 0 5
19549: PUSH
19550: LD_VAR 0 3
19554: ARRAY
19555: PPUSH
19556: CALL_OW 110
19560: PUSH
19561: LD_INT 5
19563: EQUAL
19564: NOT
19565: IFFALSE 19585
// SetTag ( tmp [ i ] , 5 ) ;
19567: LD_VAR 0 5
19571: PUSH
19572: LD_VAR 0 3
19576: ARRAY
19577: PPUSH
19578: LD_INT 5
19580: PPUSH
19581: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19585: LD_VAR 0 5
19589: PUSH
19590: LD_VAR 0 3
19594: ARRAY
19595: PPUSH
19596: LD_VAR 0 8
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PPUSH
19605: CALL_OW 250
19609: PPUSH
19610: LD_VAR 0 8
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: PPUSH
19619: CALL_OW 251
19623: PPUSH
19624: CALL_OW 111
// end ; for j = 1 to r do
19628: LD_ADDR_VAR 0 4
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19718
// if GetLives ( tmp [ i ] ) < r [ j ] then
19646: LD_VAR 0 5
19650: PUSH
19651: LD_VAR 0 3
19655: ARRAY
19656: PPUSH
19657: CALL_OW 256
19661: PUSH
19662: LD_VAR 0 6
19666: PUSH
19667: LD_VAR 0 4
19671: ARRAY
19672: LESS
19673: IFFALSE 19716
// begin r := Insert ( r , j , tmp [ i ] ) ;
19675: LD_ADDR_VAR 0 6
19679: PUSH
19680: LD_VAR 0 6
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PUSH
19695: LD_VAR 0 3
19699: ARRAY
19700: PPUSH
19701: CALL_OW 2
19705: ST_TO_ADDR
// m := true ;
19706: LD_ADDR_VAR 0 7
19710: PUSH
19711: LD_INT 1
19713: ST_TO_ADDR
// break ;
19714: GO 19718
// end ;
19716: GO 19643
19718: POP
19719: POP
// if not m then
19720: LD_VAR 0 7
19724: NOT
19725: IFFALSE 19749
// r := r ^ tmp [ i ] ;
19727: LD_ADDR_VAR 0 6
19731: PUSH
19732: LD_VAR 0 6
19736: PUSH
19737: LD_VAR 0 5
19741: PUSH
19742: LD_VAR 0 3
19746: ARRAY
19747: ADD
19748: ST_TO_ADDR
// end ;
19749: GO 19458
19751: POP
19752: POP
// end ; result := r end ; end_of_file
19753: LD_ADDR_VAR 0 2
19757: PUSH
19758: LD_VAR 0 6
19762: ST_TO_ADDR
19763: LD_VAR 0 2
19767: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19768: LD_INT 0
19770: PPUSH
19771: PPUSH
19772: PPUSH
// pom := GetBase ( bdepot ) ;
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: CALL_OW 274
19787: ST_TO_ADDR
// sor := [ ] ;
19788: LD_ADDR_VAR 0 4
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_VAR 0 4
19804: PUSH
19805: LD_VAR 0 3
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 275
19817: ADD
19818: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19819: LD_ADDR_VAR 0 4
19823: PUSH
19824: LD_VAR 0 4
19828: PUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 275
19841: ADD
19842: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19843: LD_ADDR_VAR 0 4
19847: PUSH
19848: LD_VAR 0 4
19852: PUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: LD_INT 3
19860: PPUSH
19861: CALL_OW 275
19865: ADD
19866: ST_TO_ADDR
// result := sor ;
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 4
19876: ST_TO_ADDR
// end ;
19877: LD_VAR 0 2
19881: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19882: LD_INT 0
19884: PPUSH
19885: PPUSH
// while ( coord_list ) do
19886: LD_VAR 0 3
19890: IFFALSE 20064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19892: LD_ADDR_EXP 48
19896: PUSH
19897: LD_EXP 48
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PUSH
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: PUSH
19930: LD_VAR 0 3
19934: PUSH
19935: LD_INT 3
19937: ARRAY
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: PPUSH
19944: CALL 41882 0 4
19948: ST_TO_ADDR
// if weapon_list then
19949: LD_VAR 0 4
19953: IFFALSE 20024
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19955: LD_ADDR_EXP 45
19959: PUSH
19960: LD_EXP 45
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: LD_VAR 0 4
19974: PUSH
19975: LD_INT 1
19977: ARRAY
19978: PPUSH
19979: LD_VAR 0 3
19983: PUSH
19984: LD_INT 1
19986: ARRAY
19987: PUSH
19988: LD_VAR 0 3
19992: PUSH
19993: LD_INT 2
19995: ARRAY
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PPUSH
20001: CALL 41882 0 4
20005: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 4
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
// end ; for i = 1 to 3 do
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: DOUBLE
20030: LD_INT 1
20032: DEC
20033: ST_TO_ADDR
20034: LD_INT 3
20036: PUSH
20037: FOR_TO
20038: IFFALSE 20060
// coord_list := Delete ( coord_list , 1 ) ;
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_VAR 0 3
20049: PPUSH
20050: LD_INT 1
20052: PPUSH
20053: CALL_OW 3
20057: ST_TO_ADDR
20058: GO 20037
20060: POP
20061: POP
// end ;
20062: GO 19886
// result := true ;
20064: LD_ADDR_VAR 0 5
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// end ;
20072: LD_VAR 0 5
20076: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20077: LD_INT 0
20079: PPUSH
20080: PPUSH
// if not weapon_list then
20081: LD_VAR 0 3
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20205
// while ( coord_list ) do
20090: LD_VAR 0 2
20094: IFFALSE 20205
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20096: LD_ADDR_EXP 45
20100: PUSH
20101: LD_EXP 45
20105: PPUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: LD_VAR 0 2
20124: PUSH
20125: LD_INT 1
20127: ARRAY
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_INT 2
20136: ARRAY
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL 41882 0 4
20146: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_VAR 0 3
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
// for i = 1 to 2 do
20165: LD_ADDR_VAR 0 5
20169: PUSH
20170: DOUBLE
20171: LD_INT 1
20173: DEC
20174: ST_TO_ADDR
20175: LD_INT 2
20177: PUSH
20178: FOR_TO
20179: IFFALSE 20201
// coord_list := Delete ( coord_list , 1 ) ;
20181: LD_ADDR_VAR 0 2
20185: PUSH
20186: LD_VAR 0 2
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 3
20198: ST_TO_ADDR
20199: GO 20178
20201: POP
20202: POP
// end ;
20203: GO 20090
// end ;
20205: LD_VAR 0 4
20209: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20210: LD_INT 0
20212: PPUSH
20213: PPUSH
// while ( coord_list ) do
20214: LD_VAR 0 2
20218: IFFALSE 20373
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20220: LD_VAR 0 2
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_INT 2
20236: ARRAY
20237: PPUSH
20238: CALL_OW 428
20242: IFFALSE 20333
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20244: LD_VAR 0 2
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_VAR 0 2
20257: PUSH
20258: LD_INT 2
20260: ARRAY
20261: PPUSH
20262: CALL_OW 428
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 31
20274: PUSH
20275: LD_INT 32
20277: PUSH
20278: LD_INT 33
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: IN
20286: IFFALSE 20333
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20288: LD_ADDR_EXP 54
20292: PUSH
20293: LD_EXP 54
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: LD_VAR 0 2
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 2
20316: PUSH
20317: LD_INT 2
20319: ARRAY
20320: PPUSH
20321: CALL_OW 428
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL 41882 0 4
20332: ST_TO_ADDR
// for i = 1 to 3 do
20333: LD_ADDR_VAR 0 4
20337: PUSH
20338: DOUBLE
20339: LD_INT 1
20341: DEC
20342: ST_TO_ADDR
20343: LD_INT 3
20345: PUSH
20346: FOR_TO
20347: IFFALSE 20369
// coord_list := Delete ( coord_list , 1 ) ;
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: CALL_OW 3
20366: ST_TO_ADDR
20367: GO 20346
20369: POP
20370: POP
// end ;
20371: GO 20214
// result := true ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// end ;
20381: LD_VAR 0 3
20385: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20386: LD_INT 0
20388: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20389: LD_ADDR_EXP 48
20393: PUSH
20394: LD_EXP 48
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: LD_INT 0
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: CALL 41882 0 4
20416: ST_TO_ADDR
// end ;
20417: LD_VAR 0 3
20421: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20422: LD_INT 0
20424: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20425: LD_ADDR_EXP 48
20429: PUSH
20430: LD_EXP 48
20434: PPUSH
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 6
20442: PPUSH
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL 41882 0 4
20452: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20453: LD_ADDR_EXP 51
20457: PUSH
20458: LD_EXP 51
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 1
20475: ARRAY
20476: PPUSH
20477: LD_VAR 0 3
20481: PUSH
20482: LD_INT 2
20484: ARRAY
20485: PPUSH
20486: CALL 41882 0 4
20490: ST_TO_ADDR
// end ;
20491: LD_VAR 0 4
20495: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20496: LD_INT 0
20498: PPUSH
20499: PPUSH
// if ext_list > 5 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 5
20507: GREATER
20508: IFFALSE 20552
// for i = 6 to ext_list do
20510: LD_ADDR_VAR 0 5
20514: PUSH
20515: DOUBLE
20516: LD_INT 6
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 3
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20550
// ext_list := Delete ( ext_list , ext_list ) ;
20528: LD_ADDR_VAR 0 3
20532: PUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: CALL_OW 3
20547: ST_TO_ADDR
20548: GO 20525
20550: POP
20551: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20552: LD_VAR 0 1
20556: PPUSH
20557: LD_VAR 0 2
20561: PUSH
20562: LD_INT 1
20564: ARRAY
20565: PPUSH
20566: LD_VAR 0 2
20570: PUSH
20571: LD_INT 2
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 3
20588: PPUSH
20589: CALL 9099 0 5
// end ;
20593: LD_VAR 0 4
20597: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
// p := 1 ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_INT 1
20610: ST_TO_ADDR
// if type_list = [ ] then
20611: LD_VAR 0 3
20615: PUSH
20616: EMPTY
20617: EQUAL
20618: IFFALSE 20628
// type_list := b_oil_power ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_INT 26
20627: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20628: LD_ADDR_VAR 0 5
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 2
20642: PUSH
20643: LD_INT 3
20645: DIVREAL
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20751
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20650: LD_ADDR_EXP 48
20654: PUSH
20655: LD_EXP 48
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 3
20669: PUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_VAR 0 3
20677: PPUSH
20678: CALL_OW 12
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 6
20693: ARRAY
20694: PUSH
20695: LD_VAR 0 2
20699: PUSH
20700: LD_VAR 0 6
20704: PUSH
20705: LD_INT 1
20707: PLUS
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 2
20722: PLUS
20723: ARRAY
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL 41882 0 4
20734: ST_TO_ADDR
// p := p + 3 ;
20735: LD_ADDR_VAR 0 6
20739: PUSH
20740: LD_VAR 0 6
20744: PUSH
20745: LD_INT 3
20747: PLUS
20748: ST_TO_ADDR
// end ;
20749: GO 20647
20751: POP
20752: POP
// end ;
20753: LD_VAR 0 4
20757: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not MREG_Deposit [ side ] then
20764: LD_EXP 63
20768: PUSH
20769: LD_VAR 0 1
20773: ARRAY
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20956
// p := 1 ;
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: DOUBLE
20793: LD_INT 1
20795: DEC
20796: ST_TO_ADDR
20797: LD_EXP 63
20801: PUSH
20802: LD_VAR 0 1
20806: ARRAY
20807: PUSH
20808: LD_INT 3
20810: DIVREAL
20811: PUSH
20812: FOR_TO
20813: IFFALSE 20954
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20815: LD_EXP 63
20819: PUSH
20820: LD_VAR 0 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 4
20830: PUSH
20831: LD_INT 2
20833: PLUS
20834: ARRAY
20835: PUSH
20836: LD_INT 2
20838: EQUAL
20839: IFFALSE 20851
// b := b_oil_mine else
20841: LD_ADDR_VAR 0 5
20845: PUSH
20846: LD_INT 29
20848: ST_TO_ADDR
20849: GO 20859
// b := b_siberite_mine ;
20851: LD_ADDR_VAR 0 5
20855: PUSH
20856: LD_INT 30
20858: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20859: LD_ADDR_EXP 48
20863: PUSH
20864: LD_EXP 48
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 5
20878: PPUSH
20879: LD_EXP 63
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: ARRAY
20895: PUSH
20896: LD_EXP 63
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: ARRAY
20916: PUSH
20917: LD_INT 0
20919: PPUSH
20920: LD_INT 5
20922: PPUSH
20923: CALL_OW 12
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: LIST
20932: PPUSH
20933: CALL 41882 0 4
20937: ST_TO_ADDR
// p := p + 3 ;
20938: LD_ADDR_VAR 0 4
20942: PUSH
20943: LD_VAR 0 4
20947: PUSH
20948: LD_INT 3
20950: PLUS
20951: ST_TO_ADDR
// end ;
20952: GO 20812
20954: POP
20955: POP
// end ;
20956: LD_VAR 0 2
20960: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20961: LD_INT 0
20963: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20964: LD_ADDR_EXP 48
20968: PUSH
20969: LD_EXP 48
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: CALL 41882 0 4
20991: ST_TO_ADDR
// end ;
20992: LD_VAR 0 3
20996: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20997: LD_INT 0
20999: PPUSH
// case nation of 1 , us :
21000: LD_VAR 0 2
21004: PUSH
21005: LD_INT 1
21007: DOUBLE
21008: EQUAL
21009: IFTRUE 21019
21011: LD_STRING us
21013: DOUBLE
21014: EQUAL
21015: IFTRUE 21019
21017: GO 21050
21019: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21020: LD_ADDR_EXP 48
21024: PUSH
21025: LD_EXP 48
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_INT 36
21037: PPUSH
21038: LD_VAR 0 3
21042: PPUSH
21043: CALL 41882 0 4
21047: ST_TO_ADDR
21048: GO 21101
21050: LD_INT 2
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21064
21056: LD_STRING ar
21058: DOUBLE
21059: EQUAL
21060: IFTRUE 21064
21062: GO 21100
21064: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21065: LD_ADDR_EXP 48
21069: PUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: LD_INT 14
21077: PUSH
21078: LD_INT 2
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: LD_INT 31
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: PPUSH
21093: CALL 21106 0 2
21097: ST_TO_ADDR
21098: GO 21101
21100: POP
// end ;
21101: LD_VAR 0 4
21105: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21106: LD_INT 0
21108: PPUSH
21109: PPUSH
// for i = 1 to list do
21110: LD_ADDR_VAR 0 4
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 2
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21176
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21128: LD_ADDR_EXP 53
21132: PUSH
21133: LD_EXP 53
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_EXP 53
21147: PUSH
21148: LD_VAR 0 1
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: PLUS
21157: PPUSH
21158: LD_VAR 0 2
21162: PUSH
21163: LD_VAR 0 4
21167: ARRAY
21168: PPUSH
21169: CALL 31052 0 4
21173: ST_TO_ADDR
21174: GO 21125
21176: POP
21177: POP
// end ;
21178: LD_VAR 0 3
21182: RET
// export function MCS_GetVehicleList ( side ) ; begin
21183: LD_INT 0
21185: PPUSH
// result := MREG_ToConstruct [ side ] ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_EXP 53
21195: PUSH
21196: LD_VAR 0 1
21200: ARRAY
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 2
21206: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21207: LD_INT 0
21209: PPUSH
21210: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21211: LD_ADDR_EXP 60
21215: PUSH
21216: LD_EXP 60
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 2
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 3
21240: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21241: LD_INT 0
21243: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21244: LD_ADDR_EXP 39
21248: PUSH
21249: LD_EXP 39
21253: PPUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_VAR 0 2
21263: PPUSH
21264: CALL_OW 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 3
21273: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21274: LD_INT 0
21276: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21277: LD_ADDR_EXP 40
21281: PUSH
21282: LD_EXP 40
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 3
21306: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21307: LD_INT 0
21309: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21310: LD_ADDR_EXP 62
21314: PUSH
21315: LD_EXP 62
21319: PPUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: LD_INT 1
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: CALL 31052 0 4
21337: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21338: LD_ADDR_EXP 62
21342: PUSH
21343: LD_EXP 62
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: LD_VAR 0 3
21360: PPUSH
21361: CALL 31052 0 4
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 4
21370: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21374: LD_ADDR_EXP 74
21378: PUSH
21379: LD_EXP 74
21383: PPUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21397: LD_ADDR_EXP 74
21401: PUSH
21402: LD_EXP 74
21406: PPUSH
21407: LD_INT 2
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21420: LD_ADDR_EXP 74
21424: PUSH
21425: LD_EXP 74
21429: PPUSH
21430: LD_INT 3
21432: PPUSH
21433: LD_VAR 0 3
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 4
21447: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
// if not side or not list then
21453: LD_VAR 0 1
21457: NOT
21458: PUSH
21459: LD_VAR 0 2
21463: NOT
21464: OR
21465: IFFALSE 21469
// exit ;
21467: GO 21637
// SetTech ( 20 , side , state_researched ) ;
21469: LD_INT 20
21471: PPUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21484: LD_ADDR_EXP 63
21488: PUSH
21489: LD_EXP 63
21493: PPUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_VAR 0 2
21503: PPUSH
21504: CALL_OW 2
21508: ST_TO_ADDR
// p := 1 ;
21509: LD_ADDR_VAR 0 5
21513: PUSH
21514: LD_INT 1
21516: ST_TO_ADDR
// for i = 1 to list / 3 do
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: DOUBLE
21523: LD_INT 1
21525: DEC
21526: ST_TO_ADDR
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 3
21534: DIVREAL
21535: PUSH
21536: FOR_TO
21537: IFFALSE 21635
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_VAR 0 5
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: LD_INT 1
21562: PLUS
21563: ARRAY
21564: PPUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_VAR 0 5
21574: PUSH
21575: LD_INT 2
21577: PLUS
21578: ARRAY
21579: PPUSH
21580: CALL 22339 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21584: LD_VAR 0 2
21588: PUSH
21589: LD_VAR 0 5
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_VAR 0 5
21604: PUSH
21605: LD_INT 1
21607: PLUS
21608: ARRAY
21609: PPUSH
21610: LD_VAR 0 1
21614: PPUSH
21615: CALL_OW 441
// p := p + 3 ;
21619: LD_ADDR_VAR 0 5
21623: PUSH
21624: LD_VAR 0 5
21628: PUSH
21629: LD_INT 3
21631: PLUS
21632: ST_TO_ADDR
// end ;
21633: GO 21536
21635: POP
21636: POP
// end ;
21637: LD_VAR 0 3
21641: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
// if nat = nation_arabian then
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 2
21653: EQUAL
21654: IFFALSE 21660
// exit else
21656: GO 21732
21658: GO 21718
// if nat = nation_american then
21660: LD_VAR 0 2
21664: PUSH
21665: LD_INT 1
21667: EQUAL
21668: IFFALSE 21695
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_INT 4
21677: PUSH
21678: LD_INT 3
21680: PUSH
21681: LD_INT 1
21683: PUSH
21684: LD_INT 8
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: ST_TO_ADDR
21693: GO 21718
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: LD_INT 24
21702: PUSH
21703: LD_INT 3
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: LD_INT 48
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21718: LD_VAR 0 1
21722: PPUSH
21723: LD_VAR 0 4
21727: PPUSH
21728: CALL 21106 0 2
// end ;
21732: LD_VAR 0 3
21736: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21741: LD_ADDR_EXP 65
21745: PUSH
21746: LD_EXP 65
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: LD_VAR 0 4
21763: PPUSH
21764: CALL 31052 0 4
21768: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21769: LD_ADDR_EXP 66
21773: PUSH
21774: LD_EXP 66
21778: PPUSH
21779: LD_VAR 0 1
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_VAR 0 2
21791: PPUSH
21792: CALL 31052 0 4
21796: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21797: LD_ADDR_EXP 67
21801: PUSH
21802: LD_EXP 67
21806: PPUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_INT 1
21814: PPUSH
21815: LD_VAR 0 3
21819: PPUSH
21820: CALL 31052 0 4
21824: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21825: LD_ADDR_EXP 68
21829: PUSH
21830: LD_EXP 68
21834: PPUSH
21835: LD_VAR 0 1
21839: PPUSH
21840: LD_INT 1
21842: PPUSH
21843: LD_VAR 0 5
21847: PPUSH
21848: CALL 31052 0 4
21852: ST_TO_ADDR
// while squad do
21853: LD_VAR 0 5
21857: IFFALSE 21950
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_VAR 0 5
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 2
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 3
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: LD_INT 4
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL 21106 0 2
// for i = 1 to 4 do
21910: LD_ADDR_VAR 0 7
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_INT 4
21922: PUSH
21923: FOR_TO
21924: IFFALSE 21946
// squad := Delete ( squad , 1 ) ;
21926: LD_ADDR_VAR 0 5
21930: PUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: LD_INT 1
21938: PPUSH
21939: CALL_OW 3
21943: ST_TO_ADDR
21944: GO 21923
21946: POP
21947: POP
// end ;
21948: GO 21853
// end ;
21950: LD_VAR 0 6
21954: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21955: LD_INT 0
21957: PPUSH
21958: PPUSH
// for i = 1 to squad do
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: DOUBLE
21965: LD_INT 1
21967: DEC
21968: ST_TO_ADDR
21969: LD_VAR 0 2
21973: PUSH
21974: FOR_TO
21975: IFFALSE 22025
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21977: LD_ADDR_EXP 71
21981: PUSH
21982: LD_EXP 71
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_EXP 71
21996: PUSH
21997: LD_VAR 0 1
22001: ARRAY
22002: PUSH
22003: LD_INT 1
22005: PLUS
22006: PPUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 4
22016: ARRAY
22017: PPUSH
22018: CALL 31052 0 4
22022: ST_TO_ADDR
22023: GO 21974
22025: POP
22026: POP
// while squad do
22027: LD_VAR 0 2
22031: IFFALSE 22124
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PUSH
22047: LD_VAR 0 2
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PUSH
22056: LD_VAR 0 2
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 4
22072: ARRAY
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: PPUSH
22080: CALL 21106 0 2
// for i = 1 to 4 do
22084: LD_ADDR_VAR 0 4
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_INT 4
22096: PUSH
22097: FOR_TO
22098: IFFALSE 22120
// squad := Delete ( squad , 1 ) ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 2
22109: PPUSH
22110: LD_INT 1
22112: PPUSH
22113: CALL_OW 3
22117: ST_TO_ADDR
22118: GO 22097
22120: POP
22121: POP
// end ;
22122: GO 22027
// end ;
22124: LD_VAR 0 3
22128: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22129: LD_INT 0
22131: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22132: LD_ADDR_EXP 64
22136: PUSH
22137: LD_EXP 64
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: CALL 31052 0 4
22159: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22160: LD_ADDR_EXP 64
22164: PUSH
22165: LD_EXP 64
22169: PPUSH
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: LD_VAR 0 3
22182: PPUSH
22183: CALL 31052 0 4
22187: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22188: LD_ADDR_EXP 64
22192: PUSH
22193: LD_EXP 64
22197: PPUSH
22198: LD_VAR 0 1
22202: PPUSH
22203: LD_INT 3
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL 31052 0 4
22215: ST_TO_ADDR
// end ; end_of_file
22216: LD_VAR 0 5
22220: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22221: LD_INT 0
22223: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22224: LD_ADDR_EXP 44
22228: PUSH
22229: LD_EXP 44
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 1
22241: PPUSH
22242: LD_VAR 0 2
22246: PPUSH
22247: CALL 31052 0 4
22251: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22252: LD_VAR 0 1
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL 11722 0 2
22263: PUSH
22264: LD_INT 1
22266: ARRAY
22267: PPUSH
22268: CALL_OW 248
22272: PUSH
22273: LD_INT 1
22275: EQUAL
22276: IFFALSE 22307
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: LD_INT 1
22291: PUSH
22292: LD_INT 14
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: PPUSH
22301: CALL 21106 0 2
22305: GO 22334
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22307: LD_VAR 0 1
22311: PPUSH
22312: LD_INT 24
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 1
22320: PUSH
22321: LD_INT 53
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL 21106 0 2
// end ;
22334: LD_VAR 0 3
22338: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22339: LD_INT 0
22341: PPUSH
// CreateDepositXY ( x , y , t ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 2
22351: PPUSH
22352: LD_VAR 0 3
22356: PPUSH
22357: CALL_OW 62
// end ;
22361: LD_VAR 0 4
22365: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22366: LD_INT 0
22368: PPUSH
22369: PPUSH
// c := 1 ;
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 1
22377: ST_TO_ADDR
// case color of red :
22378: LD_VAR 0 3
22382: PUSH
22383: LD_STRING red
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 1 ; dark-green :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
22400: GO 22688
22402: LD_STRING dark-green
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 2 ; purple :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 2
22418: ST_TO_ADDR
22419: GO 22688
22421: LD_STRING purple
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 3 ; aqua :
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 3
22437: ST_TO_ADDR
22438: GO 22688
22440: LD_STRING aqua
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22459
22448: POP
// c = 4 ; grey :
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_INT 4
22456: ST_TO_ADDR
22457: GO 22688
22459: LD_STRING grey
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22478
22467: POP
// c = 5 ; lime :
22468: LD_ADDR_VAR 0 5
22472: PUSH
22473: LD_INT 5
22475: ST_TO_ADDR
22476: GO 22688
22478: LD_STRING lime
22480: DOUBLE
22481: EQUAL
22482: IFTRUE 22486
22484: GO 22497
22486: POP
// c = 6 ; tan :
22487: LD_ADDR_VAR 0 5
22491: PUSH
22492: LD_INT 6
22494: ST_TO_ADDR
22495: GO 22688
22497: LD_STRING tan
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22516
22505: POP
// c = 7 ; pink :
22506: LD_ADDR_VAR 0 5
22510: PUSH
22511: LD_INT 7
22513: ST_TO_ADDR
22514: GO 22688
22516: LD_STRING pink
22518: DOUBLE
22519: EQUAL
22520: IFTRUE 22524
22522: GO 22535
22524: POP
// c = 8 ; green :
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_INT 8
22532: ST_TO_ADDR
22533: GO 22688
22535: LD_STRING green
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22554
22543: POP
// c = 9 ; blue :
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_INT 9
22551: ST_TO_ADDR
22552: GO 22688
22554: LD_STRING blue
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22573
22562: POP
// c = 10 ; yellow :
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_INT 10
22570: ST_TO_ADDR
22571: GO 22688
22573: LD_STRING yellow
22575: DOUBLE
22576: EQUAL
22577: IFTRUE 22581
22579: GO 22592
22581: POP
// c = 11 ; brown :
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_INT 11
22589: ST_TO_ADDR
22590: GO 22688
22592: LD_STRING brown
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22600
22598: GO 22611
22600: POP
// c = 12 ; black :
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 12
22608: ST_TO_ADDR
22609: GO 22688
22611: LD_STRING black
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22630
22619: POP
// c = 13 ; aqua2 :
22620: LD_ADDR_VAR 0 5
22624: PUSH
22625: LD_INT 13
22627: ST_TO_ADDR
22628: GO 22688
22630: LD_STRING aqua2
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22649
22638: POP
// c = 14 ; orange :
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_INT 14
22646: ST_TO_ADDR
22647: GO 22688
22649: LD_STRING orange
22651: DOUBLE
22652: EQUAL
22653: IFTRUE 22657
22655: GO 22668
22657: POP
// c = 15 ; white :
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_INT 15
22665: ST_TO_ADDR
22666: GO 22688
22668: LD_STRING white
22670: DOUBLE
22671: EQUAL
22672: IFTRUE 22676
22674: GO 22687
22676: POP
// c = 16 ; end ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_INT 16
22684: ST_TO_ADDR
22685: GO 22688
22687: POP
// if HexInfo ( x , y ) = 0 then
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_VAR 0 2
22697: PPUSH
22698: CALL_OW 428
22702: PUSH
22703: LD_INT 0
22705: EQUAL
22706: IFFALSE 22730
// PlaceEnvironment ( x , y , 58 , c ) ;
22708: LD_VAR 0 1
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: LD_INT 58
22720: PPUSH
22721: LD_VAR 0 5
22725: PPUSH
22726: CALL_OW 349
// end ;
22730: LD_VAR 0 4
22734: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22735: LD_INT 0
22737: PPUSH
// RemoveEnvironment ( x , y ) ;
22738: LD_VAR 0 1
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: CALL_OW 347
// end ;
22752: LD_VAR 0 3
22756: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22757: LD_INT 0
22759: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22760: LD_ADDR_VAR 0 5
22764: PUSH
22765: LD_INT 81
22767: PUSH
22768: LD_VAR 0 1
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 92
22779: PUSH
22780: LD_VAR 0 2
22784: PUSH
22785: LD_VAR 0 3
22789: PUSH
22790: LD_VAR 0 4
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 69
22809: ST_TO_ADDR
// end ;
22810: LD_VAR 0 5
22814: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22815: LD_INT 0
22817: PPUSH
22818: PPUSH
22819: PPUSH
22820: PPUSH
22821: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22822: LD_VAR 0 1
22826: PPUSH
22827: LD_INT 81
22829: PUSH
22830: LD_VAR 0 1
22834: PPUSH
22835: CALL_OW 255
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PPUSH
22844: CALL_OW 69
22848: PPUSH
22849: LD_VAR 0 1
22853: PPUSH
22854: CALL_OW 74
22858: PPUSH
22859: CALL_OW 119
// dir := GetDir ( un ) ;
22863: LD_ADDR_VAR 0 4
22867: PUSH
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 254
22877: ST_TO_ADDR
// dir := dir - 3 ;
22878: LD_ADDR_VAR 0 4
22882: PUSH
22883: LD_VAR 0 4
22887: PUSH
22888: LD_INT 3
22890: MINUS
22891: ST_TO_ADDR
// if dir < 0 then
22892: LD_VAR 0 4
22896: PUSH
22897: LD_INT 0
22899: LESS
22900: IFFALSE 22916
// dir := dir + 6 ;
22902: LD_ADDR_VAR 0 4
22906: PUSH
22907: LD_VAR 0 4
22911: PUSH
22912: LD_INT 6
22914: PLUS
22915: ST_TO_ADDR
// while true do
22916: LD_INT 1
22918: IFFALSE 23415
// begin coord_dist := 3 ;
22920: LD_ADDR_VAR 0 3
22924: PUSH
22925: LD_INT 3
22927: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22928: LD_ADDR_VAR 0 5
22932: PUSH
22933: LD_VAR 0 1
22937: PPUSH
22938: CALL_OW 250
22942: PPUSH
22943: LD_VAR 0 4
22947: PPUSH
22948: LD_VAR 0 3
22952: PPUSH
22953: CALL_OW 272
22957: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22958: LD_ADDR_VAR 0 6
22962: PUSH
22963: LD_VAR 0 1
22967: PPUSH
22968: CALL_OW 251
22972: PPUSH
22973: LD_VAR 0 4
22977: PPUSH
22978: LD_VAR 0 3
22982: PPUSH
22983: CALL_OW 273
22987: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22988: LD_VAR 0 1
22992: PPUSH
22993: CALL_OW 255
22997: PPUSH
22998: LD_VAR 0 1
23002: PPUSH
23003: CALL_OW 250
23007: PPUSH
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 251
23017: PPUSH
23018: LD_INT 14
23020: PPUSH
23021: CALL 22757 0 4
23025: PUSH
23026: LD_VAR 0 5
23030: PPUSH
23031: LD_VAR 0 6
23035: PPUSH
23036: CALL_OW 351
23040: OR
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 6
23051: PPUSH
23052: CALL_OW 488
23056: PUSH
23057: LD_INT 0
23059: EQUAL
23060: OR
23061: PUSH
23062: LD_VAR 0 5
23066: PPUSH
23067: LD_VAR 0 6
23071: PPUSH
23072: CALL_OW 546
23076: PUSH
23077: LD_INT 1
23079: EQUAL
23080: OR
23081: PUSH
23082: LD_VAR 0 5
23086: PPUSH
23087: LD_VAR 0 6
23091: PPUSH
23092: CALL_OW 428
23096: PUSH
23097: LD_INT 0
23099: NONEQUAL
23100: OR
23101: IFFALSE 23329
// begin repeat begin Wait ( 0 0$0.3 ) ;
23103: LD_INT 10
23105: PPUSH
23106: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23110: LD_ADDR_VAR 0 3
23114: PUSH
23115: LD_VAR 0 3
23119: PUSH
23120: LD_INT 1
23122: PLUS
23123: ST_TO_ADDR
// dir := dir + 1 ;
23124: LD_ADDR_VAR 0 4
23128: PUSH
23129: LD_VAR 0 4
23133: PUSH
23134: LD_INT 1
23136: PLUS
23137: ST_TO_ADDR
// if dir > 5 then
23138: LD_VAR 0 4
23142: PUSH
23143: LD_INT 5
23145: GREATER
23146: IFFALSE 23156
// dir = 0 ;
23148: LD_ADDR_VAR 0 4
23152: PUSH
23153: LD_INT 0
23155: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23156: LD_ADDR_VAR 0 5
23160: PUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: CALL_OW 250
23170: PPUSH
23171: LD_VAR 0 4
23175: PPUSH
23176: LD_VAR 0 3
23180: PPUSH
23181: CALL_OW 272
23185: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23186: LD_ADDR_VAR 0 6
23190: PUSH
23191: LD_VAR 0 1
23195: PPUSH
23196: CALL_OW 251
23200: PPUSH
23201: LD_VAR 0 4
23205: PPUSH
23206: LD_VAR 0 3
23210: PPUSH
23211: CALL_OW 273
23215: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23216: LD_VAR 0 1
23220: PPUSH
23221: CALL_OW 255
23225: PPUSH
23226: LD_VAR 0 1
23230: PPUSH
23231: CALL_OW 250
23235: PPUSH
23236: LD_VAR 0 1
23240: PPUSH
23241: CALL_OW 251
23245: PPUSH
23246: LD_INT 14
23248: PPUSH
23249: CALL 22757 0 4
23253: NOT
23254: PUSH
23255: LD_VAR 0 5
23259: PPUSH
23260: LD_VAR 0 6
23264: PPUSH
23265: CALL_OW 351
23269: NOT
23270: AND
23271: PUSH
23272: LD_VAR 0 5
23276: PPUSH
23277: LD_VAR 0 6
23281: PPUSH
23282: CALL_OW 488
23286: AND
23287: PUSH
23288: LD_VAR 0 5
23292: PPUSH
23293: LD_VAR 0 6
23297: PPUSH
23298: CALL_OW 546
23302: PUSH
23303: LD_INT 0
23305: EQUAL
23306: AND
23307: PUSH
23308: LD_VAR 0 5
23312: PPUSH
23313: LD_VAR 0 6
23317: PPUSH
23318: CALL_OW 428
23322: PUSH
23323: LD_INT 0
23325: EQUAL
23326: AND
23327: IFFALSE 23103
// end ; ComMoveXY ( un , x , y ) ;
23329: LD_VAR 0 1
23333: PPUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 111
// Wait ( 0 0$1 ) ;
23348: LD_INT 35
23350: PPUSH
23351: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23355: LD_VAR 0 1
23359: PPUSH
23360: LD_INT 81
23362: PUSH
23363: LD_VAR 0 1
23367: PPUSH
23368: CALL_OW 255
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PPUSH
23377: CALL_OW 69
23381: PPUSH
23382: LD_VAR 0 1
23386: PPUSH
23387: CALL_OW 74
23391: PPUSH
23392: CALL_OW 296
23396: PUSH
23397: LD_INT 14
23399: GREATEREQUAL
23400: IFFALSE 23413
// begin ComStop ( un ) ;
23402: LD_VAR 0 1
23406: PPUSH
23407: CALL_OW 141
// break ;
23411: GO 23415
// end ; end ;
23413: GO 22916
// end ;
23415: LD_VAR 0 2
23419: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23420: LD_INT 0
23422: PPUSH
23423: PPUSH
23424: PPUSH
23425: PPUSH
23426: PPUSH
23427: PPUSH
23428: PPUSH
23429: PPUSH
// x := GetX ( unit ) ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_VAR 0 1
23439: PPUSH
23440: CALL_OW 250
23444: ST_TO_ADDR
// y := GetY ( unit ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: CALL_OW 251
23459: ST_TO_ADDR
// i := 0 ;
23460: LD_ADDR_VAR 0 8
23464: PUSH
23465: LD_INT 0
23467: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23468: LD_VAR 0 1
23472: PPUSH
23473: LD_INT 81
23475: PUSH
23476: LD_VAR 0 1
23480: PPUSH
23481: CALL_OW 255
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PPUSH
23490: CALL_OW 69
23494: PPUSH
23495: LD_VAR 0 1
23499: PPUSH
23500: CALL_OW 74
23504: PPUSH
23505: CALL_OW 119
// dir := GetDir ( unit ) ;
23509: LD_ADDR_VAR 0 7
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 254
23523: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23524: LD_ADDR_VAR 0 9
23528: PUSH
23529: LD_INT 0
23531: PPUSH
23532: LD_INT 1
23534: PPUSH
23535: CALL_OW 12
23539: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23540: LD_INT 10
23542: PPUSH
23543: CALL_OW 67
// if mode then
23547: LD_VAR 0 9
23551: IFFALSE 23569
// dir := dir + 1 else
23553: LD_ADDR_VAR 0 7
23557: PUSH
23558: LD_VAR 0 7
23562: PUSH
23563: LD_INT 1
23565: PLUS
23566: ST_TO_ADDR
23567: GO 23583
// dir := dir - 1 ;
23569: LD_ADDR_VAR 0 7
23573: PUSH
23574: LD_VAR 0 7
23578: PUSH
23579: LD_INT 1
23581: MINUS
23582: ST_TO_ADDR
// if ( dir < 0 ) then
23583: LD_VAR 0 7
23587: PUSH
23588: LD_INT 0
23590: LESS
23591: IFFALSE 23601
// dir := 5 ;
23593: LD_ADDR_VAR 0 7
23597: PUSH
23598: LD_INT 5
23600: ST_TO_ADDR
// if ( dir > 5 ) then
23601: LD_VAR 0 7
23605: PUSH
23606: LD_INT 5
23608: GREATER
23609: IFFALSE 23619
// dir := 0 ;
23611: LD_ADDR_VAR 0 7
23615: PUSH
23616: LD_INT 0
23618: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23619: LD_ADDR_VAR 0 5
23623: PUSH
23624: LD_VAR 0 3
23628: PPUSH
23629: LD_VAR 0 7
23633: PPUSH
23634: LD_INT 4
23636: PPUSH
23637: CALL_OW 272
23641: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23642: LD_ADDR_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: PPUSH
23652: LD_VAR 0 7
23656: PPUSH
23657: LD_INT 4
23659: PPUSH
23660: CALL_OW 273
23664: ST_TO_ADDR
// i := i + 1 ;
23665: LD_ADDR_VAR 0 8
23669: PUSH
23670: LD_VAR 0 8
23674: PUSH
23675: LD_INT 1
23677: PLUS
23678: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23679: LD_VAR 0 1
23683: PPUSH
23684: CALL_OW 255
23688: PPUSH
23689: LD_VAR 0 5
23693: PPUSH
23694: LD_VAR 0 6
23698: PPUSH
23699: LD_INT 14
23701: PPUSH
23702: CALL 22757 0 4
23706: PUSH
23707: LD_INT 0
23709: EQUAL
23710: PUSH
23711: LD_VAR 0 5
23715: PPUSH
23716: LD_VAR 0 6
23720: PPUSH
23721: CALL_OW 546
23725: PUSH
23726: LD_INT 0
23728: EQUAL
23729: AND
23730: PUSH
23731: LD_VAR 0 5
23735: PPUSH
23736: LD_VAR 0 6
23740: PPUSH
23741: CALL_OW 428
23745: PUSH
23746: LD_INT 0
23748: EQUAL
23749: AND
23750: IFFALSE 23754
// break ;
23752: GO 23764
// end until i > 4 ;
23754: LD_VAR 0 8
23758: PUSH
23759: LD_INT 4
23761: GREATER
23762: IFFALSE 23540
// if x2 and y2 then
23764: LD_VAR 0 5
23768: PUSH
23769: LD_VAR 0 6
23773: AND
23774: IFFALSE 23797
// result := [ x2 , y2 ] else
23776: LD_ADDR_VAR 0 2
23780: PUSH
23781: LD_VAR 0 5
23785: PUSH
23786: LD_VAR 0 6
23790: PUSH
23791: EMPTY
23792: LIST
23793: LIST
23794: ST_TO_ADDR
23795: GO 23826
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23797: LD_ADDR_VAR 0 2
23801: PUSH
23802: LD_VAR 0 1
23806: PPUSH
23807: CALL_OW 250
23811: PUSH
23812: LD_VAR 0 1
23816: PPUSH
23817: CALL_OW 251
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: ST_TO_ADDR
// end ;
23826: LD_VAR 0 2
23830: RET
// export function MCT_Hex ( x , y ) ; begin
23831: LD_INT 0
23833: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: LD_VAR 0 2
23848: PPUSH
23849: CALL_OW 546
23853: PUSH
23854: LD_VAR 0 1
23858: PPUSH
23859: LD_VAR 0 2
23863: PPUSH
23864: CALL_OW 428
23868: PUSH
23869: EMPTY
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: ST_TO_ADDR
// end ;
23876: LD_VAR 0 3
23880: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23881: LD_INT 0
23883: PPUSH
23884: PPUSH
23885: PPUSH
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
23892: PPUSH
23893: PPUSH
23894: PPUSH
23895: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23896: LD_ADDR_VAR 0 10
23900: PUSH
23901: LD_EXP 62
23905: PUSH
23906: LD_VAR 0 1
23910: ARRAY
23911: PUSH
23912: LD_INT 1
23914: ARRAY
23915: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23916: LD_ADDR_VAR 0 11
23920: PUSH
23921: LD_EXP 62
23925: PUSH
23926: LD_VAR 0 1
23930: ARRAY
23931: PUSH
23932: LD_INT 2
23934: ARRAY
23935: ST_TO_ADDR
// collectors := [ ] ;
23936: LD_ADDR_VAR 0 12
23940: PUSH
23941: EMPTY
23942: ST_TO_ADDR
// is_cargo := false ;
23943: LD_ADDR_VAR 0 13
23947: PUSH
23948: LD_INT 0
23950: ST_TO_ADDR
// if isTest then
23951: LD_EXP 1
23955: IFFALSE 23961
// TimerStart ( ) ;
23957: CALL_OW 548
// if MCF_Cargo ( side ) then
23961: LD_VAR 0 1
23965: PPUSH
23966: CALL 11938 0 1
23970: IFFALSE 23997
// begin collectors := MCF_Cargo ( side ) ;
23972: LD_ADDR_VAR 0 12
23976: PUSH
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL 11938 0 1
23986: ST_TO_ADDR
// is_cargo := true ;
23987: LD_ADDR_VAR 0 13
23991: PUSH
23992: LD_INT 1
23994: ST_TO_ADDR
// end else
23995: GO 24146
// begin if MCF_ApeSpec ( side , engineer ) then
23997: LD_VAR 0 1
24001: PPUSH
24002: LD_STRING engineer
24004: PPUSH
24005: CALL 12084 0 2
24009: IFFALSE 24029
// collectors := MCF_ApeSpec ( side , engineer ) ;
24011: LD_ADDR_VAR 0 12
24015: PUSH
24016: LD_VAR 0 1
24020: PPUSH
24021: LD_STRING engineer
24023: PPUSH
24024: CALL 12084 0 2
24028: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24029: LD_VAR 0 1
24033: PPUSH
24034: LD_INT 2
24036: PPUSH
24037: EMPTY
24038: PPUSH
24039: CALL 11670 0 3
24043: IFFALSE 24146
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24045: LD_ADDR_VAR 0 7
24049: PUSH
24050: LD_VAR 0 1
24054: PPUSH
24055: LD_INT 2
24057: PPUSH
24058: EMPTY
24059: PPUSH
24060: CALL 11670 0 3
24064: ST_TO_ADDR
// if z > 5 then
24065: LD_VAR 0 7
24069: PUSH
24070: LD_INT 5
24072: GREATER
24073: IFFALSE 24085
// t1 := 5 else
24075: LD_ADDR_VAR 0 8
24079: PUSH
24080: LD_INT 5
24082: ST_TO_ADDR
24083: GO 24095
// t1 := z ;
24085: LD_ADDR_VAR 0 8
24089: PUSH
24090: LD_VAR 0 7
24094: ST_TO_ADDR
// for t2 = 1 to t1 do
24095: LD_ADDR_VAR 0 9
24099: PUSH
24100: DOUBLE
24101: LD_INT 1
24103: DEC
24104: ST_TO_ADDR
24105: LD_VAR 0 8
24109: PUSH
24110: FOR_TO
24111: IFFALSE 24144
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24113: LD_ADDR_VAR 0 12
24117: PUSH
24118: LD_VAR 0 12
24122: PPUSH
24123: LD_INT 1
24125: PPUSH
24126: LD_VAR 0 7
24130: PUSH
24131: LD_VAR 0 9
24135: ARRAY
24136: PPUSH
24137: CALL_OW 2
24141: ST_TO_ADDR
24142: GO 24110
24144: POP
24145: POP
// end ; end ; if not mode then
24146: LD_VAR 0 10
24150: NOT
24151: IFFALSE 24157
// exit else
24153: GO 24416
24155: GO 24416
// begin if collectors then
24157: LD_VAR 0 12
24161: IFFALSE 24416
// for i in areas do
24163: LD_ADDR_VAR 0 3
24167: PUSH
24168: LD_VAR 0 11
24172: PUSH
24173: FOR_IN
24174: IFFALSE 24414
// if GetListOfCratesInArea ( i ) then
24176: LD_VAR 0 3
24180: PPUSH
24181: CALL_OW 435
24185: IFFALSE 24412
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24187: LD_ADDR_VAR 0 5
24191: PUSH
24192: LD_VAR 0 3
24196: PPUSH
24197: CALL_OW 435
24201: PUSH
24202: LD_INT 1
24204: ARRAY
24205: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24206: LD_ADDR_VAR 0 6
24210: PUSH
24211: LD_VAR 0 3
24215: PPUSH
24216: CALL_OW 435
24220: PUSH
24221: LD_INT 2
24223: ARRAY
24224: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24225: LD_VAR 0 13
24229: PUSH
24230: LD_VAR 0 12
24234: PUSH
24235: LD_INT 1
24237: ARRAY
24238: PPUSH
24239: CALL_OW 110
24243: PUSH
24244: LD_INT 0
24246: EQUAL
24247: AND
24248: IFFALSE 24310
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24250: LD_VAR 0 12
24254: PUSH
24255: LD_INT 1
24257: ARRAY
24258: PPUSH
24259: CALL_OW 314
24263: NOT
24264: PUSH
24265: LD_VAR 0 12
24269: PUSH
24270: LD_INT 1
24272: ARRAY
24273: PPUSH
24274: CALL_OW 110
24278: PUSH
24279: LD_INT 0
24281: EQUAL
24282: AND
24283: IFFALSE 24308
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24285: LD_VAR 0 12
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 5
24298: PPUSH
24299: LD_VAR 0 6
24303: PPUSH
24304: CALL_OW 117
// end ; end else
24308: GO 24396
// begin for j = 1 to collectors do
24310: LD_ADDR_VAR 0 4
24314: PUSH
24315: DOUBLE
24316: LD_INT 1
24318: DEC
24319: ST_TO_ADDR
24320: LD_VAR 0 12
24324: PUSH
24325: FOR_TO
24326: IFFALSE 24394
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24328: LD_VAR 0 12
24332: PUSH
24333: LD_VAR 0 4
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_VAR 0 4
24354: ARRAY
24355: PPUSH
24356: CALL_OW 110
24360: PUSH
24361: LD_INT 0
24363: EQUAL
24364: AND
24365: IFFALSE 24392
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24367: LD_VAR 0 12
24371: PUSH
24372: LD_VAR 0 4
24376: ARRAY
24377: PPUSH
24378: LD_VAR 0 5
24382: PPUSH
24383: LD_VAR 0 6
24387: PPUSH
24388: CALL 24787 0 3
// end ;
24392: GO 24325
24394: POP
24395: POP
// end ; if isTest then
24396: LD_EXP 1
24400: IFFALSE 24412
// begin debug_time := TimerEnd ( ) ;
24402: LD_ADDR_VAR 0 14
24406: PUSH
24407: CALL_OW 549
24411: ST_TO_ADDR
// end ; end ;
24412: GO 24173
24414: POP
24415: POP
// end ; end ;
24416: LD_VAR 0 2
24420: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24421: LD_INT 0
24423: PPUSH
24424: PPUSH
24425: PPUSH
24426: PPUSH
24427: PPUSH
24428: PPUSH
// if not area then
24429: LD_VAR 0 1
24433: NOT
24434: IFFALSE 24440
// exit else
24436: GO 24702
24438: GO 24702
// if tick mod interval = 0 and Prob ( percent ) then
24440: LD_OWVAR 1
24444: PUSH
24445: LD_VAR 0 4
24449: MOD
24450: PUSH
24451: LD_INT 0
24453: EQUAL
24454: PUSH
24455: LD_VAR 0 3
24459: PPUSH
24460: CALL_OW 13
24464: AND
24465: IFFALSE 24702
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24467: LD_VAR 0 1
24471: PPUSH
24472: CALL_OW 435
24476: PUSH
24477: LD_VAR 0 5
24481: LESS
24482: PUSH
24483: LD_VAR 0 5
24487: PUSH
24488: LD_INT 0
24490: EQUAL
24491: OR
24492: IFFALSE 24702
// begin Randomize ;
24494: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24498: LD_ADDR_VAR 0 7
24502: PUSH
24503: LD_INT 1
24505: PPUSH
24506: LD_VAR 0 2
24510: PPUSH
24511: CALL_OW 12
24515: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24516: LD_ADDR_VAR 0 9
24520: PUSH
24521: LD_VAR 0 1
24525: PPUSH
24526: LD_INT 0
24528: PPUSH
24529: CALL_OW 517
24533: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24534: LD_ADDR_VAR 0 8
24538: PUSH
24539: LD_INT 1
24541: PPUSH
24542: LD_VAR 0 9
24546: PUSH
24547: LD_INT 1
24549: ARRAY
24550: PPUSH
24551: CALL_OW 12
24555: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24556: LD_VAR 0 9
24560: PUSH
24561: LD_INT 1
24563: ARRAY
24564: PUSH
24565: LD_VAR 0 8
24569: ARRAY
24570: PPUSH
24571: LD_VAR 0 9
24575: PUSH
24576: LD_INT 2
24578: ARRAY
24579: PUSH
24580: LD_VAR 0 8
24584: ARRAY
24585: PPUSH
24586: CALL_OW 428
24590: PUSH
24591: LD_INT 0
24593: GREATER
24594: PUSH
24595: LD_VAR 0 9
24599: PUSH
24600: LD_INT 1
24602: ARRAY
24603: PUSH
24604: LD_VAR 0 8
24608: ARRAY
24609: PPUSH
24610: LD_VAR 0 9
24614: PUSH
24615: LD_INT 2
24617: ARRAY
24618: PUSH
24619: LD_VAR 0 8
24623: ARRAY
24624: PPUSH
24625: CALL_OW 284
24629: PUSH
24630: LD_INT 0
24632: GREATER
24633: AND
24634: IFFALSE 24660
// c := Rand ( 1 , tmp [ 1 ] ) ;
24636: LD_ADDR_VAR 0 8
24640: PUSH
24641: LD_INT 1
24643: PPUSH
24644: LD_VAR 0 9
24648: PUSH
24649: LD_INT 1
24651: ARRAY
24652: PPUSH
24653: CALL_OW 12
24657: ST_TO_ADDR
24658: GO 24556
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24660: LD_VAR 0 7
24664: PPUSH
24665: LD_VAR 0 9
24669: PUSH
24670: LD_INT 1
24672: ARRAY
24673: PUSH
24674: LD_VAR 0 8
24678: ARRAY
24679: PPUSH
24680: LD_VAR 0 9
24684: PUSH
24685: LD_INT 2
24687: ARRAY
24688: PUSH
24689: LD_VAR 0 8
24693: ARRAY
24694: PPUSH
24695: LD_INT 1
24697: PPUSH
24698: CALL_OW 54
// end ; end ; end ;
24702: LD_VAR 0 6
24706: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24707: LD_INT 0
24709: PPUSH
24710: PPUSH
// if not MREG_Crates then
24711: LD_EXP 36
24715: NOT
24716: IFFALSE 24720
// exit ;
24718: GO 24782
// for i = MREG_Crates downto 1 do
24720: LD_ADDR_VAR 0 2
24724: PUSH
24725: DOUBLE
24726: LD_EXP 36
24730: INC
24731: ST_TO_ADDR
24732: LD_INT 1
24734: PUSH
24735: FOR_DOWNTO
24736: IFFALSE 24780
// if MREG_Crates [ i ] [ 3 ] = 0 then
24738: LD_EXP 36
24742: PUSH
24743: LD_VAR 0 2
24747: ARRAY
24748: PUSH
24749: LD_INT 3
24751: ARRAY
24752: PUSH
24753: LD_INT 0
24755: EQUAL
24756: IFFALSE 24778
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24758: LD_ADDR_EXP 36
24762: PUSH
24763: LD_EXP 36
24767: PPUSH
24768: LD_VAR 0 2
24772: PPUSH
24773: CALL_OW 3
24777: ST_TO_ADDR
24778: GO 24735
24780: POP
24781: POP
// end ;
24782: LD_VAR 0 1
24786: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
24791: PPUSH
24792: PPUSH
// if not unit then
24793: LD_VAR 0 1
24797: NOT
24798: IFFALSE 24802
// exit ;
24800: GO 24937
// if HasTask ( unit ) or not CanCarry ( unit ) then
24802: LD_VAR 0 1
24806: PPUSH
24807: CALL_OW 314
24811: PUSH
24812: LD_VAR 0 1
24816: PPUSH
24817: CALL_OW 280
24821: NOT
24822: OR
24823: IFFALSE 24827
// exit ;
24825: GO 24937
// side := GetSide ( unit ) ;
24827: LD_ADDR_VAR 0 6
24831: PUSH
24832: LD_VAR 0 1
24836: PPUSH
24837: CALL_OW 255
24841: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24842: LD_ADDR_VAR 0 7
24846: PUSH
24847: LD_VAR 0 6
24851: PPUSH
24852: LD_INT 30
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PPUSH
24862: CALL 11587 0 2
24866: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24867: LD_VAR 0 1
24871: PPUSH
24872: CALL_OW 281
24876: PUSH
24877: LD_VAR 0 7
24881: NOT
24882: OR
24883: IFFALSE 24889
// exit else
24885: GO 24937
24887: GO 24937
// if GetResourceAmountXY ( x , y ) then
24889: LD_VAR 0 2
24893: PPUSH
24894: LD_VAR 0 3
24898: PPUSH
24899: CALL_OW 284
24903: IFFALSE 24935
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24905: LD_VAR 0 1
24909: PPUSH
24910: LD_VAR 0 2
24914: PPUSH
24915: LD_VAR 0 3
24919: PPUSH
24920: LD_VAR 0 7
24924: PUSH
24925: LD_INT 1
24927: ARRAY
24928: PPUSH
24929: CALL 31983 0 4
// end else
24933: GO 24937
// exit ;
24935: GO 24937
// end ;
24937: LD_VAR 0 4
24941: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24942: LD_INT 0
24944: PPUSH
24945: PPUSH
24946: PPUSH
24947: PPUSH
24948: PPUSH
// result := [ ] ;
24949: LD_ADDR_VAR 0 2
24953: PUSH
24954: EMPTY
24955: ST_TO_ADDR
// p := 1 ;
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: LD_INT 1
24963: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24964: LD_ADDR_VAR 0 3
24968: PUSH
24969: DOUBLE
24970: LD_INT 1
24972: DEC
24973: ST_TO_ADDR
24974: LD_EXP 65
24978: PUSH
24979: LD_VAR 0 1
24983: ARRAY
24984: PUSH
24985: LD_INT 1
24987: ARRAY
24988: PUSH
24989: LD_INT 2
24991: DIVREAL
24992: PUSH
24993: FOR_TO
24994: IFFALSE 25118
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24996: LD_ADDR_VAR 0 5
25000: PUSH
25001: LD_INT 81
25003: PUSH
25004: LD_VAR 0 1
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 92
25015: PUSH
25016: LD_EXP 65
25020: PUSH
25021: LD_VAR 0 1
25025: ARRAY
25026: PUSH
25027: LD_INT 1
25029: ARRAY
25030: PUSH
25031: LD_VAR 0 4
25035: ARRAY
25036: PUSH
25037: LD_EXP 65
25041: PUSH
25042: LD_VAR 0 1
25046: ARRAY
25047: PUSH
25048: LD_INT 1
25050: ARRAY
25051: PUSH
25052: LD_VAR 0 4
25056: PUSH
25057: LD_INT 1
25059: PLUS
25060: ARRAY
25061: PUSH
25062: LD_INT 12
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: LIST
25069: LIST
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PPUSH
25075: CALL_OW 69
25079: ST_TO_ADDR
// if tmp then
25080: LD_VAR 0 5
25084: IFFALSE 25102
// result := result union tmp ;
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_VAR 0 2
25095: PUSH
25096: LD_VAR 0 5
25100: UNION
25101: ST_TO_ADDR
// p := p + 2 ;
25102: LD_ADDR_VAR 0 4
25106: PUSH
25107: LD_VAR 0 4
25111: PUSH
25112: LD_INT 2
25114: PLUS
25115: ST_TO_ADDR
// end ;
25116: GO 24993
25118: POP
25119: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25120: LD_EXP 66
25124: PUSH
25125: LD_VAR 0 1
25129: ARRAY
25130: PPUSH
25131: LD_INT 81
25133: PUSH
25134: LD_VAR 0 1
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PPUSH
25143: CALL_OW 70
25147: IFFALSE 25188
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25149: LD_ADDR_VAR 0 2
25153: PUSH
25154: LD_VAR 0 2
25158: PUSH
25159: LD_EXP 66
25163: PUSH
25164: LD_VAR 0 1
25168: ARRAY
25169: PPUSH
25170: LD_INT 81
25172: PUSH
25173: LD_VAR 0 1
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PPUSH
25182: CALL_OW 70
25186: UNION
25187: ST_TO_ADDR
// end ; end_of_file
25188: LD_VAR 0 2
25192: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25193: LD_INT 0
25195: PPUSH
25196: PPUSH
25197: PPUSH
// pom := GetBase ( fac ) ;
25198: LD_ADDR_VAR 0 5
25202: PUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 274
25212: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25213: LD_ADDR_VAR 0 4
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_INT 1
25225: ARRAY
25226: PPUSH
25227: LD_VAR 0 2
25231: PUSH
25232: LD_INT 2
25234: ARRAY
25235: PPUSH
25236: LD_VAR 0 2
25240: PUSH
25241: LD_INT 3
25243: ARRAY
25244: PPUSH
25245: LD_VAR 0 2
25249: PUSH
25250: LD_INT 4
25252: ARRAY
25253: PPUSH
25254: CALL_OW 449
25258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25259: LD_ADDR_VAR 0 3
25263: PUSH
25264: LD_VAR 0 5
25268: PPUSH
25269: LD_INT 1
25271: PPUSH
25272: CALL_OW 275
25276: PUSH
25277: LD_VAR 0 4
25281: PUSH
25282: LD_INT 1
25284: ARRAY
25285: GREATEREQUAL
25286: PUSH
25287: LD_VAR 0 5
25291: PPUSH
25292: LD_INT 2
25294: PPUSH
25295: CALL_OW 275
25299: PUSH
25300: LD_VAR 0 4
25304: PUSH
25305: LD_INT 2
25307: ARRAY
25308: GREATEREQUAL
25309: AND
25310: PUSH
25311: LD_VAR 0 5
25315: PPUSH
25316: LD_INT 3
25318: PPUSH
25319: CALL_OW 275
25323: PUSH
25324: LD_VAR 0 4
25328: PUSH
25329: LD_INT 3
25331: ARRAY
25332: GREATEREQUAL
25333: AND
25334: ST_TO_ADDR
// end ;
25335: LD_VAR 0 3
25339: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25340: LD_INT 0
25342: PPUSH
25343: PPUSH
25344: PPUSH
// result := false ;
25345: LD_ADDR_VAR 0 3
25349: PUSH
25350: LD_INT 0
25352: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25353: LD_ADDR_VAR 0 4
25357: PUSH
25358: LD_EXP 53
25362: PUSH
25363: LD_VAR 0 1
25367: ARRAY
25368: ST_TO_ADDR
// if tmp then
25369: LD_VAR 0 4
25373: IFFALSE 25427
// for i = 1 to tmp do
25375: LD_ADDR_VAR 0 5
25379: PUSH
25380: DOUBLE
25381: LD_INT 1
25383: DEC
25384: ST_TO_ADDR
25385: LD_VAR 0 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25425
// if component = tmp [ i ] then
25393: LD_VAR 0 2
25397: PUSH
25398: LD_VAR 0 4
25402: PUSH
25403: LD_VAR 0 5
25407: ARRAY
25408: EQUAL
25409: IFFALSE 25423
// begin result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// exit ;
25419: POP
25420: POP
25421: GO 25427
// end ;
25423: GO 25390
25425: POP
25426: POP
// end ;
25427: LD_VAR 0 3
25431: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25432: LD_INT 0
25434: PPUSH
25435: PPUSH
25436: PPUSH
// result := false ;
25437: LD_ADDR_VAR 0 4
25441: PUSH
25442: LD_INT 0
25444: ST_TO_ADDR
// if fac then
25445: LD_VAR 0 2
25449: IFFALSE 25672
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25451: LD_VAR 0 2
25455: PPUSH
25456: LD_VAR 0 3
25460: PPUSH
25461: CALL 25193 0 2
25465: PUSH
25466: LD_VAR 0 2
25470: PPUSH
25471: CALL_OW 461
25475: PUSH
25476: LD_INT 2
25478: EQUAL
25479: AND
25480: PUSH
25481: LD_VAR 0 2
25485: PPUSH
25486: LD_VAR 0 3
25490: PUSH
25491: LD_INT 1
25493: ARRAY
25494: PPUSH
25495: LD_VAR 0 3
25499: PUSH
25500: LD_INT 2
25502: ARRAY
25503: PPUSH
25504: LD_VAR 0 3
25508: PUSH
25509: LD_INT 3
25511: ARRAY
25512: PPUSH
25513: LD_VAR 0 3
25517: PUSH
25518: LD_INT 4
25520: ARRAY
25521: PPUSH
25522: CALL_OW 448
25526: AND
25527: IFFALSE 25672
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25529: LD_VAR 0 2
25533: PPUSH
25534: LD_VAR 0 3
25538: PUSH
25539: LD_INT 1
25541: ARRAY
25542: PPUSH
25543: LD_VAR 0 3
25547: PUSH
25548: LD_INT 2
25550: ARRAY
25551: PPUSH
25552: LD_VAR 0 3
25556: PUSH
25557: LD_INT 3
25559: ARRAY
25560: PPUSH
25561: LD_VAR 0 3
25565: PUSH
25566: LD_INT 4
25568: ARRAY
25569: PPUSH
25570: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25574: LD_ADDR_VAR 0 6
25578: PUSH
25579: LD_EXP 53
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: ST_TO_ADDR
// for i = 4 downto 1 do
25590: LD_ADDR_VAR 0 5
25594: PUSH
25595: DOUBLE
25596: LD_INT 4
25598: INC
25599: ST_TO_ADDR
25600: LD_INT 1
25602: PUSH
25603: FOR_DOWNTO
25604: IFFALSE 25637
// tab := Remove ( tab , list [ i ] , true ) ;
25606: LD_ADDR_VAR 0 6
25610: PUSH
25611: LD_VAR 0 6
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_VAR 0 5
25625: ARRAY
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL 31211 0 3
25634: ST_TO_ADDR
25635: GO 25603
25637: POP
25638: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25639: LD_ADDR_EXP 53
25643: PUSH
25644: LD_EXP 53
25648: PPUSH
25649: LD_VAR 0 1
25653: PPUSH
25654: LD_VAR 0 6
25658: PPUSH
25659: CALL_OW 1
25663: ST_TO_ADDR
// result := true ;
25664: LD_ADDR_VAR 0 4
25668: PUSH
25669: LD_INT 1
25671: ST_TO_ADDR
// end ; end ; end ;
25672: LD_VAR 0 4
25676: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25677: LD_INT 0
25679: PPUSH
25680: PPUSH
// if not veh then
25681: LD_VAR 0 2
25685: NOT
25686: IFFALSE 25690
// exit ;
25688: GO 25864
// if MREG_Parking [ side ] then
25690: LD_EXP 60
25694: PUSH
25695: LD_VAR 0 1
25699: ARRAY
25700: IFFALSE 25864
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25702: LD_VAR 0 2
25706: PPUSH
25707: LD_EXP 60
25711: PUSH
25712: LD_VAR 0 1
25716: ARRAY
25717: PPUSH
25718: CALL_OW 308
25722: NOT
25723: IFFALSE 25864
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25725: LD_VAR 0 2
25729: PPUSH
25730: LD_EXP 60
25734: PUSH
25735: LD_VAR 0 1
25739: ARRAY
25740: PPUSH
25741: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25745: LD_VAR 0 2
25749: PPUSH
25750: CALL_OW 263
25754: PUSH
25755: LD_INT 1
25757: EQUAL
25758: IFFALSE 25864
// begin i := GetDriver ( veh ) ;
25760: LD_ADDR_VAR 0 4
25764: PUSH
25765: LD_VAR 0 2
25769: PPUSH
25770: CALL 31695 0 1
25774: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25775: LD_INT 35
25777: PPUSH
25778: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 60
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: PUSH
25803: LD_VAR 0 2
25807: PPUSH
25808: CALL_OW 301
25812: OR
25813: IFFALSE 25775
// ComExitVehicle ( i ) ;
25815: LD_VAR 0 4
25819: PPUSH
25820: CALL_OW 121
// Wait ( 1 ) ;
25824: LD_INT 1
25826: PPUSH
25827: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25831: LD_VAR 0 4
25835: PPUSH
25836: LD_VAR 0 1
25840: PPUSH
25841: LD_INT 30
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PPUSH
25851: CALL 11587 0 2
25855: PUSH
25856: LD_INT 1
25858: ARRAY
25859: PPUSH
25860: CALL_OW 180
// end ; end ; end ;
25864: LD_VAR 0 3
25868: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25869: LD_INT 0
25871: PPUSH
25872: PPUSH
25873: PPUSH
25874: PPUSH
25875: PPUSH
25876: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25877: LD_VAR 0 1
25881: PPUSH
25882: LD_INT 30
25884: PUSH
25885: LD_INT 3
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PPUSH
25892: CALL 11587 0 2
25896: IFFALSE 26080
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25898: LD_VAR 0 1
25902: PPUSH
25903: LD_INT 30
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL 11587 0 2
25917: PUSH
25918: LD_INT 1
25920: ARRAY
25921: PPUSH
25922: CALL_OW 461
25926: PUSH
25927: LD_INT 2
25929: EQUAL
25930: IFFALSE 26080
// begin for i = 1 to MREG_TurretWeapon do
25932: LD_ADDR_VAR 0 3
25936: PUSH
25937: DOUBLE
25938: LD_INT 1
25940: DEC
25941: ST_TO_ADDR
25942: LD_EXP 45
25946: PUSH
25947: FOR_TO
25948: IFFALSE 26078
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25950: LD_EXP 45
25954: PUSH
25955: LD_VAR 0 3
25959: ARRAY
25960: PUSH
25961: LD_INT 1
25963: ARRAY
25964: PUSH
25965: LD_VAR 0 1
25969: EQUAL
25970: IFFALSE 26076
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25972: LD_ADDR_VAR 0 5
25976: PUSH
25977: LD_EXP 45
25981: PUSH
25982: LD_VAR 0 3
25986: ARRAY
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25992: LD_ADDR_VAR 0 6
25996: PUSH
25997: LD_EXP 45
26001: PUSH
26002: LD_VAR 0 3
26006: ARRAY
26007: PUSH
26008: LD_INT 3
26010: ARRAY
26011: PUSH
26012: LD_INT 1
26014: ARRAY
26015: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26016: LD_ADDR_VAR 0 7
26020: PUSH
26021: LD_EXP 45
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: LD_INT 3
26034: ARRAY
26035: PUSH
26036: LD_INT 2
26038: ARRAY
26039: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26040: LD_ADDR_VAR 0 4
26044: PUSH
26045: LD_VAR 0 6
26049: PPUSH
26050: LD_VAR 0 7
26054: PPUSH
26055: CALL_OW 428
26059: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26060: LD_VAR 0 4
26064: PPUSH
26065: LD_VAR 0 5
26069: PPUSH
26070: CALL_OW 148
// break ;
26074: GO 26078
// end ;
26076: GO 25947
26078: POP
26079: POP
// end ; end ;
26080: LD_VAR 0 2
26084: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26085: LD_INT 0
26087: PPUSH
26088: PPUSH
26089: PPUSH
26090: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26091: LD_ADDR_VAR 0 4
26095: PUSH
26096: LD_VAR 0 1
26100: PPUSH
26101: LD_INT 32
26103: PUSH
26104: LD_INT 1
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: PPUSH
26111: CALL 11587 0 2
26115: ST_TO_ADDR
// if not tmp then
26116: LD_VAR 0 4
26120: NOT
26121: IFFALSE 26127
// exit else
26123: GO 26209
26125: GO 26209
// begin for i = 1 to tmp do
26127: LD_ADDR_VAR 0 3
26131: PUSH
26132: DOUBLE
26133: LD_INT 1
26135: DEC
26136: ST_TO_ADDR
26137: LD_VAR 0 4
26141: PUSH
26142: FOR_TO
26143: IFFALSE 26207
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26145: LD_VAR 0 4
26149: PUSH
26150: LD_VAR 0 3
26154: ARRAY
26155: PPUSH
26156: CALL_OW 261
26160: PUSH
26161: LD_INT 20
26163: LESS
26164: PUSH
26165: LD_VAR 0 4
26169: PUSH
26170: LD_VAR 0 3
26174: ARRAY
26175: PPUSH
26176: CALL_OW 110
26180: PUSH
26181: LD_INT 0
26183: EQUAL
26184: AND
26185: IFFALSE 26205
// begin SetTag ( tmp [ i ] , 21 ) ;
26187: LD_VAR 0 4
26191: PUSH
26192: LD_VAR 0 3
26196: ARRAY
26197: PPUSH
26198: LD_INT 21
26200: PPUSH
26201: CALL_OW 109
// end ;
26205: GO 26142
26207: POP
26208: POP
// end ; end ;
26209: LD_VAR 0 2
26213: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26214: LD_INT 0
26216: PPUSH
26217: PPUSH
26218: PPUSH
26219: PPUSH
26220: PPUSH
// if not unit then
26221: LD_VAR 0 1
26225: NOT
26226: IFFALSE 26230
// exit ;
26228: GO 26418
// side := GetSide ( unit ) ;
26230: LD_ADDR_VAR 0 3
26234: PUSH
26235: LD_VAR 0 1
26239: PPUSH
26240: CALL_OW 255
26244: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26245: LD_ADDR_VAR 0 5
26249: PUSH
26250: LD_VAR 0 3
26254: PPUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 3
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 30
26280: PUSH
26281: LD_INT 29
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: PPUSH
26294: CALL 11587 0 2
26298: ST_TO_ADDR
// if not b then
26299: LD_VAR 0 5
26303: NOT
26304: IFFALSE 26308
// exit ;
26306: GO 26418
// if GetTag ( unit ) = 21 then
26308: LD_VAR 0 1
26312: PPUSH
26313: CALL_OW 110
26317: PUSH
26318: LD_INT 21
26320: EQUAL
26321: IFFALSE 26418
// begin c := NearestUnitToUnit ( b , unit ) ;
26323: LD_ADDR_VAR 0 6
26327: PUSH
26328: LD_VAR 0 5
26332: PPUSH
26333: LD_VAR 0 1
26337: PPUSH
26338: CALL_OW 74
26342: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26343: LD_VAR 0 1
26347: PPUSH
26348: LD_VAR 0 6
26352: PPUSH
26353: CALL_OW 250
26357: PPUSH
26358: LD_VAR 0 6
26362: PPUSH
26363: CALL_OW 251
26367: PPUSH
26368: CALL_OW 297
26372: PUSH
26373: LD_INT 6
26375: GREATER
26376: IFFALSE 26394
// ComMoveUnit ( unit , c ) else
26378: LD_VAR 0 1
26382: PPUSH
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 112
26392: GO 26418
// begin SetFuel ( unit , 100 ) ;
26394: LD_VAR 0 1
26398: PPUSH
26399: LD_INT 100
26401: PPUSH
26402: CALL_OW 240
// SetTag ( unit , 0 ) ;
26406: LD_VAR 0 1
26410: PPUSH
26411: LD_INT 0
26413: PPUSH
26414: CALL_OW 109
// end ; end ; end ;
26418: LD_VAR 0 2
26422: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26423: LD_INT 0
26425: PPUSH
26426: PPUSH
26427: PPUSH
26428: PPUSH
26429: PPUSH
26430: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26431: LD_ADDR_VAR 0 7
26435: PUSH
26436: LD_VAR 0 1
26440: PPUSH
26441: LD_INT 33
26443: PUSH
26444: LD_INT 2
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 61
26456: PUSH
26457: EMPTY
26458: LIST
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PPUSH
26468: CALL 11587 0 2
26472: ST_TO_ADDR
// if not vehs then
26473: LD_VAR 0 7
26477: NOT
26478: IFFALSE 26482
// exit ;
26480: GO 26767
// if nation = 1 then
26482: LD_VAR 0 2
26486: PUSH
26487: LD_INT 1
26489: EQUAL
26490: IFFALSE 26660
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26492: LD_VAR 0 1
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 36
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL 11587 0 2
26511: NOT
26512: IFFALSE 26518
// exit else
26514: GO 26767
26516: GO 26658
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26518: LD_ADDR_VAR 0 5
26522: PUSH
26523: LD_VAR 0 1
26527: PPUSH
26528: LD_INT 30
26530: PUSH
26531: LD_INT 36
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PPUSH
26538: CALL 11587 0 2
26542: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26543: LD_ADDR_VAR 0 6
26547: PUSH
26548: LD_VAR 0 5
26552: PUSH
26553: LD_INT 1
26555: ARRAY
26556: PPUSH
26557: CALL_OW 313
26561: ST_TO_ADDR
// for i = vehs downto 1 do
26562: LD_ADDR_VAR 0 4
26566: PUSH
26567: DOUBLE
26568: LD_VAR 0 7
26572: INC
26573: ST_TO_ADDR
26574: LD_INT 1
26576: PUSH
26577: FOR_DOWNTO
26578: IFFALSE 26656
// begin if not IsControledBy ( vehs [ i ] ) then
26580: LD_VAR 0 7
26584: PUSH
26585: LD_VAR 0 4
26589: ARRAY
26590: PPUSH
26591: CALL_OW 312
26595: NOT
26596: IFFALSE 26654
// begin tmp := MCV_RemoteDriver ( oper ) ;
26598: LD_ADDR_VAR 0 8
26602: PUSH
26603: LD_VAR 0 6
26607: PPUSH
26608: CALL 26772 0 1
26612: ST_TO_ADDR
// if not tmp then
26613: LD_VAR 0 8
26617: NOT
26618: IFFALSE 26626
// exit else
26620: POP
26621: POP
26622: GO 26767
26624: GO 26654
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26626: LD_VAR 0 7
26630: PUSH
26631: LD_VAR 0 4
26635: ARRAY
26636: PPUSH
26637: LD_VAR 0 8
26641: PUSH
26642: LD_INT 1
26644: ARRAY
26645: PUSH
26646: LD_INT 1
26648: ARRAY
26649: PPUSH
26650: CALL_OW 135
// end ; end ;
26654: GO 26577
26656: POP
26657: POP
// end ; end else
26658: GO 26767
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26660: LD_VAR 0 1
26664: PPUSH
26665: LD_INT 34
26667: PUSH
26668: LD_INT 31
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PPUSH
26675: CALL 11587 0 2
26679: NOT
26680: IFFALSE 26686
// exit else
26682: GO 26767
26684: GO 26767
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26686: LD_ADDR_VAR 0 5
26690: PUSH
26691: LD_VAR 0 1
26695: PPUSH
26696: LD_INT 34
26698: PUSH
26699: LD_INT 31
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL 11587 0 2
26710: ST_TO_ADDR
// oper := [ ] ;
26711: LD_ADDR_VAR 0 6
26715: PUSH
26716: EMPTY
26717: ST_TO_ADDR
// for i = 1 to ct do
26718: LD_ADDR_VAR 0 4
26722: PUSH
26723: DOUBLE
26724: LD_INT 1
26726: DEC
26727: ST_TO_ADDR
26728: LD_VAR 0 5
26732: PUSH
26733: FOR_TO
26734: IFFALSE 26765
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26736: LD_ADDR_VAR 0 6
26740: PUSH
26741: LD_VAR 0 6
26745: PUSH
26746: LD_VAR 0 5
26750: PUSH
26751: LD_VAR 0 4
26755: ARRAY
26756: PPUSH
26757: CALL 31695 0 1
26761: ADD
26762: ST_TO_ADDR
26763: GO 26733
26765: POP
26766: POP
// end ; end ; end ;
26767: LD_VAR 0 3
26771: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26772: LD_INT 0
26774: PPUSH
26775: PPUSH
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
// if not drivers then
26780: LD_VAR 0 1
26784: NOT
26785: IFFALSE 26791
// exit else
26787: GO 27071
26789: GO 27071
// begin linked := [ ] ;
26791: LD_ADDR_VAR 0 5
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to drivers do
26798: LD_ADDR_VAR 0 3
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 1
26812: PUSH
26813: FOR_TO
26814: IFFALSE 27059
// begin if CanControl ( drivers [ i ] ) then
26816: LD_VAR 0 1
26820: PUSH
26821: LD_VAR 0 3
26825: ARRAY
26826: PPUSH
26827: CALL 32085 0 1
26831: IFFALSE 27057
// if i > 1 then
26833: LD_VAR 0 3
26837: PUSH
26838: LD_INT 1
26840: GREATER
26841: IFFALSE 27018
// begin m := false ;
26843: LD_ADDR_VAR 0 6
26847: PUSH
26848: LD_INT 0
26850: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26851: LD_ADDR_VAR 0 7
26855: PUSH
26856: LD_VAR 0 1
26860: PUSH
26861: LD_VAR 0 3
26865: ARRAY
26866: PPUSH
26867: CALL_OW 432
26871: ST_TO_ADDR
// for j = 1 to linked do
26872: LD_ADDR_VAR 0 4
26876: PUSH
26877: DOUBLE
26878: LD_INT 1
26880: DEC
26881: ST_TO_ADDR
26882: LD_VAR 0 5
26886: PUSH
26887: FOR_TO
26888: IFFALSE 26962
// begin if l < linked [ j ] [ 2 ] then
26890: LD_VAR 0 7
26894: PUSH
26895: LD_VAR 0 5
26899: PUSH
26900: LD_VAR 0 4
26904: ARRAY
26905: PUSH
26906: LD_INT 2
26908: ARRAY
26909: LESS
26910: IFFALSE 26960
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26912: LD_ADDR_VAR 0 5
26916: PUSH
26917: LD_VAR 0 5
26921: PPUSH
26922: LD_INT 1
26924: PPUSH
26925: LD_VAR 0 1
26929: PUSH
26930: LD_VAR 0 3
26934: ARRAY
26935: PUSH
26936: LD_VAR 0 7
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PPUSH
26945: CALL_OW 2
26949: ST_TO_ADDR
// m := true ;
26950: LD_ADDR_VAR 0 6
26954: PUSH
26955: LD_INT 1
26957: ST_TO_ADDR
// break ;
26958: GO 26962
// end ; end ;
26960: GO 26887
26962: POP
26963: POP
// if not m then
26964: LD_VAR 0 6
26968: NOT
26969: IFFALSE 27016
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26971: LD_ADDR_VAR 0 5
26975: PUSH
26976: LD_VAR 0 5
26980: PUSH
26981: LD_VAR 0 1
26985: PUSH
26986: LD_VAR 0 3
26990: ARRAY
26991: PUSH
26992: LD_VAR 0 1
26996: PUSH
26997: LD_VAR 0 3
27001: ARRAY
27002: PPUSH
27003: CALL_OW 432
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: EMPTY
27013: LIST
27014: ADD
27015: ST_TO_ADDR
// end else
27016: GO 27057
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27018: LD_ADDR_VAR 0 5
27022: PUSH
27023: LD_VAR 0 1
27027: PUSH
27028: LD_VAR 0 3
27032: ARRAY
27033: PUSH
27034: LD_VAR 0 1
27038: PUSH
27039: LD_VAR 0 3
27043: ARRAY
27044: PPUSH
27045: CALL_OW 432
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: ST_TO_ADDR
// end ;
27057: GO 26813
27059: POP
27060: POP
// result := linked ;
27061: LD_ADDR_VAR 0 2
27065: PUSH
27066: LD_VAR 0 5
27070: ST_TO_ADDR
// end ; end ;
27071: LD_VAR 0 2
27075: RET
// export function MCV_ToRepair ( unit ) ; begin
27076: LD_INT 0
27078: PPUSH
// if not unit then
27079: LD_VAR 0 1
27083: NOT
27084: IFFALSE 27088
// exit ;
27086: GO 27119
// SetTag ( unit , 6 ) ;
27088: LD_VAR 0 1
27092: PPUSH
27093: LD_INT 6
27095: PPUSH
27096: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27100: LD_VAR 0 1
27104: PPUSH
27105: CALL_OW 255
27109: PPUSH
27110: LD_VAR 0 1
27114: PPUSH
27115: CALL 25677 0 2
// end ;
27119: LD_VAR 0 2
27123: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27124: LD_INT 0
27126: PPUSH
27127: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27128: LD_VAR 0 1
27132: PPUSH
27133: LD_INT 6
27135: PPUSH
27136: EMPTY
27137: PPUSH
27138: CALL 12290 0 3
27142: IFFALSE 27235
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27144: LD_ADDR_VAR 0 3
27148: PUSH
27149: DOUBLE
27150: LD_VAR 0 1
27154: PPUSH
27155: LD_INT 6
27157: PPUSH
27158: EMPTY
27159: PPUSH
27160: CALL 12290 0 3
27164: INC
27165: ST_TO_ADDR
27166: LD_INT 1
27168: PUSH
27169: FOR_DOWNTO
27170: IFFALSE 27233
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27172: LD_VAR 0 1
27176: PPUSH
27177: LD_INT 6
27179: PPUSH
27180: EMPTY
27181: PPUSH
27182: CALL 12290 0 3
27186: PUSH
27187: LD_VAR 0 3
27191: ARRAY
27192: PPUSH
27193: CALL_OW 256
27197: PUSH
27198: LD_INT 1000
27200: EQUAL
27201: IFFALSE 27231
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27203: LD_VAR 0 1
27207: PPUSH
27208: LD_INT 6
27210: PPUSH
27211: EMPTY
27212: PPUSH
27213: CALL 12290 0 3
27217: PUSH
27218: LD_VAR 0 3
27222: ARRAY
27223: PPUSH
27224: LD_INT 0
27226: PPUSH
27227: CALL_OW 109
27231: GO 27169
27233: POP
27234: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27235: LD_VAR 0 1
27239: PPUSH
27240: LD_INT 10
27242: PPUSH
27243: EMPTY
27244: PPUSH
27245: CALL 12290 0 3
27249: IFFALSE 27366
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27251: LD_ADDR_VAR 0 3
27255: PUSH
27256: DOUBLE
27257: LD_VAR 0 1
27261: PPUSH
27262: LD_INT 10
27264: PPUSH
27265: EMPTY
27266: PPUSH
27267: CALL 12290 0 3
27271: INC
27272: ST_TO_ADDR
27273: LD_INT 1
27275: PUSH
27276: FOR_DOWNTO
27277: IFFALSE 27364
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27279: LD_VAR 0 1
27283: PPUSH
27284: LD_INT 10
27286: PPUSH
27287: EMPTY
27288: PPUSH
27289: CALL 12290 0 3
27293: PUSH
27294: LD_VAR 0 3
27298: ARRAY
27299: PPUSH
27300: CALL_OW 302
27304: NOT
27305: PUSH
27306: LD_VAR 0 1
27310: PPUSH
27311: LD_INT 10
27313: PPUSH
27314: EMPTY
27315: PPUSH
27316: CALL 12290 0 3
27320: PUSH
27321: LD_VAR 0 3
27325: ARRAY
27326: PPUSH
27327: CALL_OW 301
27331: OR
27332: IFFALSE 27362
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27334: LD_VAR 0 1
27338: PPUSH
27339: LD_INT 10
27341: PPUSH
27342: EMPTY
27343: PPUSH
27344: CALL 12290 0 3
27348: PUSH
27349: LD_VAR 0 3
27353: ARRAY
27354: PPUSH
27355: LD_INT 0
27357: PPUSH
27358: CALL_OW 109
27362: GO 27276
27364: POP
27365: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27366: LD_ADDR_VAR 0 3
27370: PUSH
27371: LD_VAR 0 1
27375: PPUSH
27376: EMPTY
27377: PPUSH
27378: CALL 11888 0 2
27382: PUSH
27383: LD_VAR 0 1
27387: PPUSH
27388: LD_INT 7
27390: PPUSH
27391: EMPTY
27392: PPUSH
27393: CALL 12290 0 3
27397: DIFF
27398: PUSH
27399: FOR_IN
27400: IFFALSE 27444
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27402: LD_VAR 0 3
27406: PPUSH
27407: CALL_OW 256
27411: PUSH
27412: LD_INT 650
27414: LESS
27415: PUSH
27416: LD_VAR 0 3
27420: PPUSH
27421: CALL_OW 110
27425: PUSH
27426: LD_INT 6
27428: EQUAL
27429: NOT
27430: AND
27431: IFFALSE 27442
// MCV_ToRepair ( i ) ;
27433: LD_VAR 0 3
27437: PPUSH
27438: CALL 27076 0 1
27442: GO 27399
27444: POP
27445: POP
// end ; end_of_file end_of_file
27446: LD_VAR 0 2
27450: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27451: LD_STRING SAILEvent [
27453: PUSH
27454: LD_VAR 0 1
27458: STR
27459: PUSH
27460: LD_STRING ]
27462: STR
27463: PPUSH
27464: CALL 7984 0 1
// if event = 101 and dialog_north then
27468: LD_VAR 0 1
27472: PUSH
27473: LD_INT 101
27475: EQUAL
27476: PUSH
27477: LD_EXP 6
27481: AND
27482: IFFALSE 27546
// begin dialog_north := false ;
27484: LD_ADDR_EXP 6
27488: PUSH
27489: LD_INT 0
27491: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27492: LD_EXP 5
27496: PPUSH
27497: LD_STRING DS1
27499: PUSH
27500: LD_STRING DS2
27502: PUSH
27503: LD_STRING DS3
27505: PUSH
27506: LD_STRING DS6
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 1
27517: PPUSH
27518: LD_INT 4
27520: PPUSH
27521: CALL_OW 12
27525: ARRAY
27526: PPUSH
27527: CALL_OW 94
// Wait ( 4 4$00 ) ;
27531: LD_INT 8400
27533: PPUSH
27534: CALL_OW 67
// dialog_north := true ;
27538: LD_ADDR_EXP 6
27542: PUSH
27543: LD_INT 1
27545: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27546: LD_VAR 0 1
27550: PUSH
27551: LD_INT 102
27553: EQUAL
27554: PUSH
27555: LD_EXP 7
27559: AND
27560: IFFALSE 27620
// begin dialog_south := false ;
27562: LD_ADDR_EXP 7
27566: PUSH
27567: LD_INT 0
27569: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27570: LD_EXP 4
27574: PPUSH
27575: LD_STRING DJ1
27577: PUSH
27578: LD_STRING DJ4
27580: PUSH
27581: LD_STRING DJ6
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PPUSH
27592: LD_INT 3
27594: PPUSH
27595: CALL_OW 12
27599: ARRAY
27600: PPUSH
27601: CALL_OW 94
// Wait ( 4 4$00 ) ;
27605: LD_INT 8400
27607: PPUSH
27608: CALL_OW 67
// dialog_south := true ;
27612: LD_ADDR_EXP 7
27616: PUSH
27617: LD_INT 1
27619: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27620: LD_VAR 0 1
27624: PUSH
27625: LD_INT 104
27627: EQUAL
27628: PUSH
27629: LD_EXP 8
27633: AND
27634: IFFALSE 27656
// begin dialog_popov := false ;
27636: LD_ADDR_EXP 8
27640: PUSH
27641: LD_INT 0
27643: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27644: LD_EXP 26
27648: PPUSH
27649: LD_STRING DR4
27651: PPUSH
27652: CALL_OW 94
// end ; end ;
27656: PPOPN 1
27658: END
// on BuildingStarted ( b , unit ) do var side , i ;
27659: LD_INT 0
27661: PPUSH
27662: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27663: LD_EXP 41
27667: PUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 255
27677: ARRAY
27678: IFFALSE 27856
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27680: LD_STRING BuildingStarted [side: 
27682: PUSH
27683: LD_VAR 0 1
27687: PPUSH
27688: CALL_OW 255
27692: STR
27693: PUSH
27694: LD_STRING ; btype: 
27696: STR
27697: PUSH
27698: LD_VAR 0 1
27702: PPUSH
27703: CALL_OW 266
27707: STR
27708: PUSH
27709: LD_STRING ; unit: 
27711: STR
27712: PUSH
27713: LD_VAR 0 2
27717: STR
27718: PUSH
27719: LD_STRING ]
27721: STR
27722: PPUSH
27723: CALL 7984 0 1
// side := GetSide ( b ) ;
27727: LD_ADDR_VAR 0 3
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27742: LD_VAR 0 3
27746: PPUSH
27747: LD_INT 21
27749: PUSH
27750: LD_INT 3
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PPUSH
27757: CALL 11587 0 2
27761: PUSH
27762: LD_INT 1
27764: EQUAL
27765: IFFALSE 27856
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27767: LD_ADDR_VAR 0 4
27771: PUSH
27772: LD_VAR 0 3
27776: PPUSH
27777: LD_INT 21
27779: PUSH
27780: LD_INT 1
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL 11587 0 2
27791: PUSH
27792: LD_VAR 0 3
27796: PPUSH
27797: LD_INT 2
27799: PPUSH
27800: EMPTY
27801: PPUSH
27802: CALL 11670 0 3
27806: DIFF
27807: PUSH
27808: FOR_IN
27809: IFFALSE 27854
// if not HasTask ( i ) then
27811: LD_VAR 0 4
27815: PPUSH
27816: CALL_OW 314
27820: NOT
27821: IFFALSE 27852
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27823: LD_VAR 0 4
27827: PPUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 250
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 251
27847: PPUSH
27848: CALL_OW 111
27852: GO 27808
27854: POP
27855: POP
// end ;
27856: PPOPN 4
27858: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27859: LD_EXP 41
27863: PUSH
27864: LD_VAR 0 1
27868: PPUSH
27869: CALL_OW 255
27873: ARRAY
27874: IFFALSE 28243
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27876: LD_STRING BuildingComplete [side: 
27878: PUSH
27879: LD_VAR 0 1
27883: PPUSH
27884: CALL_OW 255
27888: STR
27889: PUSH
27890: LD_STRING ; btype: 
27892: STR
27893: PUSH
27894: LD_VAR 0 1
27898: PPUSH
27899: CALL_OW 266
27903: STR
27904: PUSH
27905: LD_STRING ]
27907: STR
27908: PPUSH
27909: CALL 7984 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27913: LD_ADDR_EXP 48
27917: PUSH
27918: LD_EXP 48
27922: PPUSH
27923: LD_VAR 0 1
27927: PPUSH
27928: CALL_OW 255
27932: PPUSH
27933: LD_VAR 0 1
27937: PPUSH
27938: CALL_OW 266
27942: PPUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 250
27952: PUSH
27953: LD_VAR 0 1
27957: PPUSH
27958: CALL_OW 251
27962: PUSH
27963: LD_VAR 0 1
27967: PPUSH
27968: CALL_OW 254
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: PPUSH
27978: CALL 41973 0 4
27982: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27983: LD_VAR 0 1
27987: PPUSH
27988: CALL_OW 266
27992: PUSH
27993: LD_INT 6
27995: EQUAL
27996: IFFALSE 28030
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27998: LD_ADDR_EXP 42
28002: PUSH
28003: LD_EXP 42
28007: PPUSH
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 255
28017: PPUSH
28018: LD_VAR 0 1
28022: PPUSH
28023: EMPTY
28024: PPUSH
28025: CALL 41882 0 4
28029: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 266
28039: PUSH
28040: LD_INT 0
28042: EQUAL
28043: IFFALSE 28153
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28045: LD_ADDR_EXP 50
28049: PUSH
28050: LD_EXP 50
28054: PPUSH
28055: LD_VAR 0 1
28059: PPUSH
28060: CALL_OW 255
28064: PPUSH
28065: LD_INT 0
28067: PPUSH
28068: EMPTY
28069: PPUSH
28070: CALL 41882 0 4
28074: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28075: LD_VAR 0 1
28079: PPUSH
28080: CALL_OW 274
28084: PPUSH
28085: LD_INT 1
28087: PPUSH
28088: LD_EXP 74
28092: PUSH
28093: LD_INT 1
28095: ARRAY
28096: PPUSH
28097: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28101: LD_VAR 0 1
28105: PPUSH
28106: CALL_OW 274
28110: PPUSH
28111: LD_INT 2
28113: PPUSH
28114: LD_EXP 74
28118: PUSH
28119: LD_INT 2
28121: ARRAY
28122: PPUSH
28123: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28127: LD_VAR 0 1
28131: PPUSH
28132: CALL_OW 274
28136: PPUSH
28137: LD_INT 3
28139: PPUSH
28140: LD_EXP 74
28144: PUSH
28145: LD_INT 3
28147: ARRAY
28148: PPUSH
28149: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28153: LD_VAR 0 1
28157: PPUSH
28158: CALL_OW 266
28162: PUSH
28163: LD_INT 2
28165: EQUAL
28166: IFFALSE 28198
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28168: LD_ADDR_EXP 50
28172: PUSH
28173: LD_EXP 50
28177: PPUSH
28178: LD_VAR 0 1
28182: PPUSH
28183: CALL_OW 255
28187: PPUSH
28188: LD_INT 2
28190: PPUSH
28191: EMPTY
28192: PPUSH
28193: CALL 41882 0 4
28197: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28198: LD_VAR 0 1
28202: PPUSH
28203: CALL_OW 266
28207: PUSH
28208: LD_INT 4
28210: EQUAL
28211: IFFALSE 28243
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28213: LD_ADDR_EXP 50
28217: PUSH
28218: LD_EXP 50
28222: PPUSH
28223: LD_VAR 0 1
28227: PPUSH
28228: CALL_OW 255
28232: PPUSH
28233: LD_INT 4
28235: PPUSH
28236: EMPTY
28237: PPUSH
28238: CALL 41882 0 4
28242: ST_TO_ADDR
// end ;
28243: PPOPN 1
28245: END
// on ResearchComplete ( tech , lab ) do var i ;
28246: LD_INT 0
28248: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28249: LD_EXP 41
28253: PUSH
28254: LD_VAR 0 2
28258: PPUSH
28259: CALL_OW 255
28263: ARRAY
28264: IFFALSE 28548
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28266: LD_STRING ResearchComplete [side: 
28268: PUSH
28269: LD_VAR 0 2
28273: PPUSH
28274: CALL_OW 255
28278: PPUSH
28279: CALL_OW 255
28283: STR
28284: PUSH
28285: LD_STRING ; tech:
28287: STR
28288: PUSH
28289: LD_VAR 0 1
28293: STR
28294: PUSH
28295: LD_STRING ]
28297: STR
28298: PPUSH
28299: CALL 7984 0 1
// for i = 1 to MREG_ToRes do
28303: LD_ADDR_VAR 0 3
28307: PUSH
28308: DOUBLE
28309: LD_INT 1
28311: DEC
28312: ST_TO_ADDR
28313: LD_EXP 52
28317: PUSH
28318: FOR_TO
28319: IFFALSE 28406
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28321: LD_EXP 52
28325: PUSH
28326: LD_VAR 0 3
28330: ARRAY
28331: PUSH
28332: LD_INT 1
28334: ARRAY
28335: PUSH
28336: LD_VAR 0 2
28340: PPUSH
28341: CALL_OW 255
28345: EQUAL
28346: PUSH
28347: LD_EXP 52
28351: PUSH
28352: LD_VAR 0 3
28356: ARRAY
28357: PUSH
28358: LD_INT 2
28360: ARRAY
28361: PUSH
28362: LD_VAR 0 1
28366: EQUAL
28367: AND
28368: IFFALSE 28404
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28370: LD_ADDR_EXP 52
28374: PUSH
28375: LD_EXP 52
28379: PPUSH
28380: LD_VAR 0 2
28384: PPUSH
28385: CALL_OW 255
28389: PPUSH
28390: LD_VAR 0 1
28394: PPUSH
28395: EMPTY
28396: PPUSH
28397: CALL 41973 0 4
28401: ST_TO_ADDR
// break ;
28402: GO 28406
// end ;
28404: GO 28318
28406: POP
28407: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28408: LD_VAR 0 1
28412: PUSH
28413: LD_INT 2
28415: PUSH
28416: LD_INT 11
28418: PUSH
28419: LD_INT 4
28421: PUSH
28422: LD_INT 3
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: IN
28431: IFFALSE 28548
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28433: LD_ADDR_VAR 0 3
28437: PUSH
28438: LD_VAR 0 2
28442: PPUSH
28443: CALL_OW 255
28447: PPUSH
28448: LD_INT 16
28450: PPUSH
28451: LD_INT 25
28453: PUSH
28454: LD_INT 4
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PPUSH
28461: CALL 12290 0 3
28465: ST_TO_ADDR
// if i then
28466: LD_VAR 0 3
28470: IFFALSE 28488
// SetTag ( i [ 1 ] , 0 ) ;
28472: LD_VAR 0 3
28476: PUSH
28477: LD_INT 1
28479: ARRAY
28480: PPUSH
28481: LD_INT 0
28483: PPUSH
28484: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28488: LD_ADDR_VAR 0 3
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: CALL_OW 255
28502: PPUSH
28503: LD_INT 171
28505: PPUSH
28506: EMPTY
28507: PPUSH
28508: CALL 12290 0 3
28512: ST_TO_ADDR
// if i then
28513: LD_VAR 0 3
28517: IFFALSE 28548
// begin SetTag ( i [ 1 ] , 0 ) ;
28519: LD_VAR 0 3
28523: PUSH
28524: LD_INT 1
28526: ARRAY
28527: PPUSH
28528: LD_INT 0
28530: PPUSH
28531: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28535: LD_VAR 0 3
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: PPUSH
28544: CALL_OW 122
// end ; end ; end ;
28548: PPOPN 3
28550: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28551: LD_INT 0
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28560: LD_EXP 41
28564: PUSH
28565: LD_VAR 0 2
28569: PPUSH
28570: CALL_OW 255
28574: ARRAY
28575: IFFALSE 29302
// begin side := GetSide ( veh ) ;
28577: LD_ADDR_VAR 0 4
28581: PUSH
28582: LD_VAR 0 1
28586: PPUSH
28587: CALL_OW 255
28591: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28592: LD_ADDR_VAR 0 6
28596: PUSH
28597: LD_VAR 0 1
28601: PPUSH
28602: CALL_OW 265
28606: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28607: LD_ADDR_VAR 0 7
28611: PUSH
28612: LD_VAR 0 1
28616: PPUSH
28617: CALL_OW 262
28621: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28622: LD_ADDR_VAR 0 8
28626: PUSH
28627: LD_VAR 0 1
28631: PPUSH
28632: CALL_OW 263
28636: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28637: LD_ADDR_VAR 0 9
28641: PUSH
28642: LD_VAR 0 1
28646: PPUSH
28647: CALL_OW 264
28651: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28652: LD_STRING VehicleConstructed [side: 
28654: PUSH
28655: LD_VAR 0 4
28659: STR
28660: PUSH
28661: LD_STRING ; id:
28663: STR
28664: PUSH
28665: LD_VAR 0 1
28669: STR
28670: PUSH
28671: LD_STRING ; components: [
28673: STR
28674: PUSH
28675: LD_VAR 0 6
28679: STR
28680: PUSH
28681: LD_STRING , 
28683: STR
28684: PUSH
28685: LD_VAR 0 7
28689: STR
28690: PUSH
28691: LD_STRING , 
28693: STR
28694: PUSH
28695: LD_VAR 0 8
28699: STR
28700: PUSH
28701: LD_STRING , 
28703: STR
28704: PUSH
28705: LD_VAR 0 9
28709: STR
28710: PUSH
28711: LD_STRING ]]
28713: STR
28714: PPUSH
28715: CALL 7984 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28719: LD_VAR 0 1
28723: PPUSH
28724: CALL_OW 264
28728: PUSH
28729: LD_INT 13
28731: PUSH
28732: LD_INT 12
28734: PUSH
28735: LD_INT 14
28737: PUSH
28738: LD_INT 51
28740: PUSH
28741: LD_INT 53
28743: PUSH
28744: LD_INT 52
28746: PUSH
28747: LD_INT 32
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: IN
28759: NOT
28760: IFFALSE 28802
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28762: LD_ADDR_EXP 61
28766: PUSH
28767: LD_EXP 61
28771: PPUSH
28772: LD_VAR 0 4
28776: PPUSH
28777: LD_EXP 61
28781: PUSH
28782: LD_VAR 0 4
28786: ARRAY
28787: PUSH
28788: LD_INT 1
28790: PLUS
28791: PPUSH
28792: LD_VAR 0 1
28796: PPUSH
28797: CALL 31052 0 4
28801: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28802: LD_VAR 0 1
28806: PPUSH
28807: CALL_OW 264
28811: PUSH
28812: LD_INT 31
28814: EQUAL
28815: IFFALSE 28834
// SetTag ( GetDriver ( veh ) , 9 ) ;
28817: LD_VAR 0 1
28821: PPUSH
28822: CALL 31695 0 1
28826: PPUSH
28827: LD_INT 9
28829: PPUSH
28830: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28834: LD_VAR 0 1
28838: PPUSH
28839: CALL_OW 264
28843: PUSH
28844: LD_INT 14
28846: PUSH
28847: LD_INT 53
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: IN
28854: IFFALSE 28891
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28856: LD_ADDR_EXP 44
28860: PUSH
28861: LD_EXP 44
28865: PPUSH
28866: LD_VAR 0 1
28870: PPUSH
28871: CALL_OW 255
28875: PPUSH
28876: LD_INT 2
28878: PPUSH
28879: LD_VAR 0 1
28883: PPUSH
28884: CALL 31052 0 4
28888: ST_TO_ADDR
// exit ;
28889: GO 29302
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28891: LD_VAR 0 1
28895: PPUSH
28896: CALL_OW 265
28900: PUSH
28901: LD_EXP 68
28905: PUSH
28906: LD_VAR 0 4
28910: ARRAY
28911: PUSH
28912: LD_INT 1
28914: ARRAY
28915: IN
28916: PUSH
28917: LD_VAR 0 1
28921: PPUSH
28922: CALL_OW 262
28926: PUSH
28927: LD_EXP 68
28931: PUSH
28932: LD_VAR 0 4
28936: ARRAY
28937: PUSH
28938: LD_INT 1
28940: ARRAY
28941: IN
28942: AND
28943: PUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 263
28953: PUSH
28954: LD_EXP 68
28958: PUSH
28959: LD_VAR 0 4
28963: ARRAY
28964: PUSH
28965: LD_INT 1
28967: ARRAY
28968: IN
28969: AND
28970: PUSH
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 264
28980: PUSH
28981: LD_EXP 68
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: AND
28997: IFFALSE 29041
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28999: LD_ADDR_EXP 69
29003: PUSH
29004: LD_EXP 69
29008: PPUSH
29009: LD_VAR 0 4
29013: PPUSH
29014: LD_EXP 69
29018: PUSH
29019: LD_VAR 0 4
29023: ARRAY
29024: PUSH
29025: LD_INT 1
29027: PLUS
29028: PPUSH
29029: LD_VAR 0 1
29033: PPUSH
29034: CALL 31052 0 4
29038: ST_TO_ADDR
// exit ;
29039: GO 29302
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29041: LD_VAR 0 6
29045: PUSH
29046: LD_EXP 71
29050: PUSH
29051: LD_VAR 0 4
29055: ARRAY
29056: PUSH
29057: LD_INT 1
29059: ARRAY
29060: EQUAL
29061: PUSH
29062: LD_VAR 0 7
29066: PUSH
29067: LD_EXP 71
29071: PUSH
29072: LD_VAR 0 4
29076: ARRAY
29077: PUSH
29078: LD_INT 2
29080: ARRAY
29081: EQUAL
29082: AND
29083: PUSH
29084: LD_VAR 0 8
29088: PUSH
29089: LD_EXP 71
29093: PUSH
29094: LD_VAR 0 4
29098: ARRAY
29099: PUSH
29100: LD_INT 3
29102: ARRAY
29103: EQUAL
29104: AND
29105: PUSH
29106: LD_VAR 0 9
29110: PUSH
29111: LD_EXP 71
29115: PUSH
29116: LD_VAR 0 4
29120: ARRAY
29121: PUSH
29122: LD_INT 4
29124: ARRAY
29125: EQUAL
29126: AND
29127: IFFALSE 29283
// begin tmp := MREG_ToAttack [ side ] ;
29129: LD_ADDR_VAR 0 5
29133: PUSH
29134: LD_EXP 71
29138: PUSH
29139: LD_VAR 0 4
29143: ARRAY
29144: ST_TO_ADDR
// for i = 1 to 4 do
29145: LD_ADDR_VAR 0 3
29149: PUSH
29150: DOUBLE
29151: LD_INT 1
29153: DEC
29154: ST_TO_ADDR
29155: LD_INT 4
29157: PUSH
29158: FOR_TO
29159: IFFALSE 29181
// tmp := Delete ( tmp , 1 ) ;
29161: LD_ADDR_VAR 0 5
29165: PUSH
29166: LD_VAR 0 5
29170: PPUSH
29171: LD_INT 1
29173: PPUSH
29174: CALL_OW 3
29178: ST_TO_ADDR
29179: GO 29158
29181: POP
29182: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29183: LD_ADDR_EXP 71
29187: PUSH
29188: LD_EXP 71
29192: PPUSH
29193: LD_VAR 0 4
29197: PPUSH
29198: LD_VAR 0 5
29202: PPUSH
29203: CALL_OW 1
29207: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29208: LD_ADDR_EXP 73
29212: PUSH
29213: LD_EXP 73
29217: PPUSH
29218: LD_VAR 0 4
29222: PPUSH
29223: LD_EXP 73
29227: PUSH
29228: LD_VAR 0 4
29232: ARRAY
29233: PUSH
29234: LD_INT 1
29236: PLUS
29237: PPUSH
29238: LD_VAR 0 1
29242: PPUSH
29243: CALL 31052 0 4
29247: ST_TO_ADDR
// if tmp = 0 then
29248: LD_VAR 0 5
29252: PUSH
29253: LD_INT 0
29255: EQUAL
29256: IFFALSE 29281
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29258: LD_ADDR_EXP 71
29262: PUSH
29263: LD_EXP 71
29267: PPUSH
29268: LD_VAR 0 4
29272: PPUSH
29273: LD_INT 0
29275: PPUSH
29276: CALL_OW 1
29280: ST_TO_ADDR
// exit ;
29281: GO 29302
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 255
29292: PPUSH
29293: LD_VAR 0 1
29297: PPUSH
29298: CALL 25677 0 2
// end ;
29302: PPOPN 9
29304: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29305: LD_EXP 41
29309: PUSH
29310: LD_VAR 0 2
29314: PPUSH
29315: CALL_OW 255
29319: ARRAY
29320: IFFALSE 29552
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29322: LD_STRING ApemanTamed [side: 
29324: PUSH
29325: LD_VAR 0 2
29329: PPUSH
29330: CALL_OW 255
29334: STR
29335: PUSH
29336: LD_STRING ; sci: 
29338: STR
29339: PUSH
29340: LD_VAR 0 2
29344: STR
29345: PUSH
29346: LD_STRING ; ape: 
29348: STR
29349: PUSH
29350: LD_VAR 0 1
29354: STR
29355: PUSH
29356: LD_STRING ]
29358: STR
29359: PPUSH
29360: CALL 7984 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29364: LD_INT 11
29366: PPUSH
29367: LD_VAR 0 2
29371: PPUSH
29372: CALL_OW 255
29376: PPUSH
29377: CALL_OW 321
29381: PUSH
29382: LD_INT 2
29384: EQUAL
29385: NOT
29386: PUSH
29387: LD_INT 2
29389: PPUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: PPUSH
29400: CALL_OW 321
29404: PUSH
29405: LD_INT 2
29407: EQUAL
29408: NOT
29409: OR
29410: PUSH
29411: LD_VAR 0 2
29415: PPUSH
29416: CALL_OW 255
29420: PPUSH
29421: LD_INT 171
29423: PPUSH
29424: EMPTY
29425: PPUSH
29426: CALL 12290 0 3
29430: PUSH
29431: LD_INT 0
29433: EQUAL
29434: AND
29435: IFFALSE 29449
// begin SetTag ( ape , 171 ) ;
29437: LD_VAR 0 1
29441: PPUSH
29442: LD_INT 171
29444: PPUSH
29445: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29449: LD_VAR 0 2
29453: PPUSH
29454: CALL_OW 255
29458: PPUSH
29459: LD_INT 30
29461: PUSH
29462: LD_INT 1
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PPUSH
29469: CALL 11587 0 2
29473: IFFALSE 29552
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29475: LD_VAR 0 1
29479: PPUSH
29480: LD_VAR 0 2
29484: PPUSH
29485: CALL_OW 255
29489: PPUSH
29490: LD_INT 30
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PPUSH
29500: CALL 11587 0 2
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: CALL_OW 250
29513: PPUSH
29514: LD_VAR 0 2
29518: PPUSH
29519: CALL_OW 255
29523: PPUSH
29524: LD_INT 30
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PPUSH
29534: CALL 11587 0 2
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PPUSH
29543: CALL_OW 251
29547: PPUSH
29548: CALL_OW 111
// end ;
29552: PPOPN 2
29554: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29555: LD_EXP 41
29559: PUSH
29560: LD_VAR 0 1
29564: PPUSH
29565: CALL_OW 255
29569: ARRAY
29570: IFFALSE 29848
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 2
29581: PPUSH
29582: CALL_OW 255
29586: PPUSH
29587: CALL 12000 0 1
29591: IN
29592: IFFALSE 29733
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29594: LD_VAR 0 1
29598: PPUSH
29599: CALL_OW 266
29603: PUSH
29604: LD_INT 0
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: IN
29614: IFFALSE 29644
// begin Wait ( 0 0$0.3 ) ;
29616: LD_INT 10
29618: PPUSH
29619: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29623: LD_VAR 0 2
29627: PPUSH
29628: LD_INT 16
29630: PPUSH
29631: CALL_OW 336
// ComExitBuilding ( un ) ;
29635: LD_VAR 0 2
29639: PPUSH
29640: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29644: LD_VAR 0 1
29648: PPUSH
29649: CALL_OW 266
29653: PUSH
29654: LD_INT 4
29656: PUSH
29657: LD_INT 5
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: IN
29664: IFFALSE 29733
// begin Wait ( 0 0$0.3 ) ;
29666: LD_INT 10
29668: PPUSH
29669: CALL_OW 67
// if GetTag ( un ) = 0 then
29673: LD_VAR 0 2
29677: PPUSH
29678: CALL_OW 110
29682: PUSH
29683: LD_INT 0
29685: EQUAL
29686: IFFALSE 29702
// SetClass ( un , class_apeman_soldier ) else
29688: LD_VAR 0 2
29692: PPUSH
29693: LD_INT 15
29695: PPUSH
29696: CALL_OW 336
29700: GO 29733
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29702: LD_INT 3
29704: PPUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: CALL_OW 255
29714: PPUSH
29715: CALL_OW 321
29719: IFFALSE 29733
// SetClass ( un , class_apeman_kamikaze ) ;
29721: LD_VAR 0 2
29725: PPUSH
29726: LD_INT 17
29728: PPUSH
29729: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29733: LD_VAR 0 1
29737: PPUSH
29738: CALL_OW 266
29742: PUSH
29743: LD_INT 32
29745: EQUAL
29746: IFFALSE 29848
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29748: LD_ADDR_EXP 70
29752: PUSH
29753: LD_EXP 70
29757: PPUSH
29758: LD_VAR 0 1
29762: PPUSH
29763: CALL_OW 255
29767: PPUSH
29768: LD_EXP 70
29772: PUSH
29773: LD_VAR 0 1
29777: PPUSH
29778: CALL_OW 255
29782: ARRAY
29783: PUSH
29784: LD_INT 1
29786: PLUS
29787: PPUSH
29788: LD_VAR 0 1
29792: PPUSH
29793: CALL 31052 0 4
29797: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29798: LD_ADDR_EXP 70
29802: PUSH
29803: LD_EXP 70
29807: PPUSH
29808: LD_VAR 0 1
29812: PPUSH
29813: CALL_OW 255
29817: PPUSH
29818: LD_EXP 70
29822: PUSH
29823: LD_VAR 0 1
29827: PPUSH
29828: CALL_OW 255
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: PLUS
29837: PPUSH
29838: LD_VAR 0 2
29842: PPUSH
29843: CALL 31052 0 4
29847: ST_TO_ADDR
// end ; end ;
29848: PPOPN 2
29850: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL 56497 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29860: LD_VAR 0 1
29864: PUSH
29865: LD_INT 22
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 23
29877: PUSH
29878: LD_INT 3
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 21
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: LIST
29899: PPUSH
29900: CALL_OW 69
29904: IN
29905: IFFALSE 29921
// player_loss := player_loss + 1 ;
29907: LD_ADDR_EXP 10
29911: PUSH
29912: LD_EXP 10
29916: PUSH
29917: LD_INT 1
29919: PLUS
29920: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29921: LD_VAR 0 1
29925: PUSH
29926: LD_INT 22
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 21
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PPUSH
29950: CALL_OW 69
29954: IN
29955: PUSH
29956: LD_EXP 15
29960: NOT
29961: AND
29962: IFFALSE 30025
// begin alfa_north_triggered := true ;
29964: LD_ADDR_EXP 15
29968: PUSH
29969: LD_INT 1
29971: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29972: LD_EXP 5
29976: PPUSH
29977: LD_STRING DS4
29979: PPUSH
29980: CALL_OW 94
// Wait ( 1 1$25 ) ;
29984: LD_INT 2975
29986: PPUSH
29987: CALL_OW 67
// if not isTest then
29991: LD_EXP 1
29995: NOT
29996: IFFALSE 30025
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29998: LD_INT 20
30000: PPUSH
30001: LD_INT 5
30003: PUSH
30004: LD_INT 6
30006: PUSH
30007: LD_INT 7
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: PUSH
30015: LD_OWVAR 67
30019: ARRAY
30020: PPUSH
30021: CALL 7122 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30025: LD_VAR 0 1
30029: PUSH
30030: LD_INT 22
30032: PUSH
30033: LD_INT 4
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 21
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PPUSH
30054: CALL_OW 69
30058: IN
30059: PUSH
30060: LD_EXP 16
30064: NOT
30065: AND
30066: IFFALSE 30129
// begin alfa_south_triggered := true ;
30068: LD_ADDR_EXP 16
30072: PUSH
30073: LD_INT 1
30075: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30076: LD_EXP 4
30080: PPUSH
30081: LD_STRING DJ3
30083: PPUSH
30084: CALL_OW 94
// Wait ( 0 0$45 ) ;
30088: LD_INT 1575
30090: PPUSH
30091: CALL_OW 67
// if not isTest then
30095: LD_EXP 1
30099: NOT
30100: IFFALSE 30129
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30102: LD_INT 20
30104: PPUSH
30105: LD_INT 5
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: LD_INT 7
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: LIST
30118: PUSH
30119: LD_OWVAR 67
30123: ARRAY
30124: PPUSH
30125: CALL 7122 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30129: LD_VAR 0 1
30133: PPUSH
30134: CALL_OW 266
30138: PUSH
30139: LD_INT 1
30141: EQUAL
30142: PUSH
30143: LD_VAR 0 1
30147: PPUSH
30148: CALL_OW 255
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: LD_INT 4
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: IN
30163: AND
30164: IFFALSE 30173
// RaiseSailEvent ( 104 ) ;
30166: LD_INT 104
30168: PPUSH
30169: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30173: LD_EXP 41
30177: PUSH
30178: LD_VAR 0 1
30182: PPUSH
30183: CALL_OW 255
30187: ARRAY
30188: IFFALSE 30575
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30190: LD_STRING UnitDestroyed [side 
30192: PUSH
30193: LD_VAR 0 1
30197: PPUSH
30198: CALL_OW 255
30202: STR
30203: PUSH
30204: LD_STRING ; id: 
30206: STR
30207: PUSH
30208: LD_VAR 0 1
30212: STR
30213: PUSH
30214: LD_STRING ; type: 
30216: STR
30217: PUSH
30218: LD_VAR 0 1
30222: PPUSH
30223: CALL_OW 247
30227: STR
30228: PUSH
30229: LD_STRING ]
30231: STR
30232: PPUSH
30233: CALL 7984 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30237: LD_VAR 0 1
30241: PUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: CALL_OW 255
30251: PPUSH
30252: LD_INT 21
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PPUSH
30262: CALL 11587 0 2
30266: IN
30267: IFFALSE 30423
// begin if MCF_HasClass ( un ) then
30269: LD_VAR 0 1
30273: PPUSH
30274: CALL 14293 0 1
30278: IFFALSE 30423
// case MCF_HasClass ( un ) of 1 :
30280: LD_VAR 0 1
30284: PPUSH
30285: CALL 14293 0 1
30289: PUSH
30290: LD_INT 1
30292: DOUBLE
30293: EQUAL
30294: IFTRUE 30298
30296: GO 30323
30298: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30299: LD_VAR 0 1
30303: PPUSH
30304: CALL_OW 255
30308: PPUSH
30309: LD_STRING ToArm
30311: PPUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL 14466 0 3
30321: GO 30423
30323: LD_INT 2
30325: DOUBLE
30326: EQUAL
30327: IFTRUE 30331
30329: GO 30356
30331: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30332: LD_VAR 0 1
30336: PPUSH
30337: CALL_OW 255
30341: PPUSH
30342: LD_STRING ToDep
30344: PPUSH
30345: LD_VAR 0 1
30349: PPUSH
30350: CALL 14466 0 3
30354: GO 30423
30356: LD_INT 3
30358: DOUBLE
30359: EQUAL
30360: IFTRUE 30364
30362: GO 30389
30364: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30365: LD_VAR 0 1
30369: PPUSH
30370: CALL_OW 255
30374: PPUSH
30375: LD_STRING ToFac
30377: PPUSH
30378: LD_VAR 0 1
30382: PPUSH
30383: CALL 14466 0 3
30387: GO 30423
30389: LD_INT 4
30391: DOUBLE
30392: EQUAL
30393: IFTRUE 30397
30395: GO 30422
30397: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30398: LD_VAR 0 1
30402: PPUSH
30403: CALL_OW 255
30407: PPUSH
30408: LD_STRING ToLab
30410: PPUSH
30411: LD_VAR 0 1
30415: PPUSH
30416: CALL 14466 0 3
30420: GO 30423
30422: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30423: LD_VAR 0 1
30427: PUSH
30428: LD_EXP 69
30432: PUSH
30433: LD_VAR 0 1
30437: PPUSH
30438: CALL_OW 255
30442: ARRAY
30443: IN
30444: IFFALSE 30529
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30446: LD_ADDR_EXP 69
30450: PUSH
30451: LD_EXP 69
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: LD_INT 0
30463: PPUSH
30464: CALL 31211 0 3
30468: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30469: LD_VAR 0 1
30473: PPUSH
30474: CALL_OW 255
30478: PPUSH
30479: LD_VAR 0 1
30483: PPUSH
30484: CALL_OW 265
30488: PUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL_OW 262
30498: PUSH
30499: LD_VAR 0 1
30503: PPUSH
30504: CALL_OW 263
30508: PUSH
30509: LD_VAR 0 1
30513: PPUSH
30514: CALL_OW 264
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: PPUSH
30525: CALL 21106 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30529: LD_VAR 0 1
30533: PUSH
30534: LD_EXP 73
30538: PUSH
30539: LD_VAR 0 1
30543: PPUSH
30544: CALL_OW 255
30548: ARRAY
30549: IN
30550: IFFALSE 30575
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30552: LD_ADDR_EXP 73
30556: PUSH
30557: LD_EXP 73
30561: PPUSH
30562: LD_VAR 0 1
30566: PPUSH
30567: LD_INT 0
30569: PPUSH
30570: CALL 31211 0 3
30574: ST_TO_ADDR
// end ; end ;
30575: PPOPN 1
30577: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30578: LD_EXP 41
30582: PUSH
30583: LD_VAR 0 2
30587: PPUSH
30588: CALL_OW 255
30592: ARRAY
30593: IFFALSE 30765
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30595: LD_VAR 0 2
30599: PUSH
30600: LD_EXP 70
30604: PUSH
30605: LD_VAR 0 2
30609: PPUSH
30610: CALL_OW 255
30614: ARRAY
30615: IN
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 266
30626: PUSH
30627: LD_INT 32
30629: PUSH
30630: LD_INT 31
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: IN
30637: AND
30638: IFFALSE 30738
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30640: LD_ADDR_EXP 70
30644: PUSH
30645: LD_EXP 70
30649: PPUSH
30650: LD_VAR 0 1
30654: PPUSH
30655: LD_INT 0
30657: PPUSH
30658: CALL 31211 0 3
30662: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30663: LD_ADDR_EXP 70
30667: PUSH
30668: LD_EXP 70
30672: PPUSH
30673: LD_VAR 0 2
30677: PPUSH
30678: LD_INT 0
30680: PPUSH
30681: CALL 31211 0 3
30685: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30686: LD_EXP 70
30690: PUSH
30691: LD_VAR 0 2
30695: PPUSH
30696: CALL_OW 255
30700: ARRAY
30701: PUSH
30702: LD_STRING 
30704: EQUAL
30705: IFFALSE 30738
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30707: LD_ADDR_EXP 70
30711: PUSH
30712: LD_EXP 70
30716: PPUSH
30717: LD_VAR 0 2
30721: PPUSH
30722: CALL_OW 255
30726: PPUSH
30727: LD_INT 1
30729: PPUSH
30730: LD_INT 0
30732: PPUSH
30733: CALL 31052 0 4
30737: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30738: LD_VAR 0 1
30742: PPUSH
30743: CALL_OW 266
30747: PUSH
30748: LD_INT 36
30750: IN
30751: IFFALSE 30765
// SetTag ( un , 0 ) ;
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL_OW 109
// end ;
30765: PPOPN 2
30767: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30768: LD_EXP 41
30772: PUSH
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 255
30782: ARRAY
30783: IFFALSE 30809
// begin if GetControl ( un ) = control_remote then
30785: LD_VAR 0 1
30789: PPUSH
30790: CALL_OW 263
30794: PUSH
30795: LD_INT 2
30797: EQUAL
30798: IFFALSE 30809
// ComUnlink ( un ) ;
30800: LD_VAR 0 1
30804: PPUSH
30805: CALL_OW 136
// end ;
30809: PPOPN 1
30811: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30812: LD_EXP 41
30816: PUSH
30817: LD_VAR 0 1
30821: PPUSH
30822: CALL_OW 255
30826: ARRAY
30827: IFFALSE 30856
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30829: LD_VAR 0 2
30833: PPUSH
30834: CALL_OW 264
30838: PUSH
30839: LD_INT 31
30841: IN
30842: IFFALSE 30856
// SetTag ( driver , 0 ) ;
30844: LD_VAR 0 1
30848: PPUSH
30849: LD_INT 0
30851: PPUSH
30852: CALL_OW 109
// end ;
30856: PPOPN 4
30858: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30859: LD_INT 0
30861: PPUSH
30862: PPUSH
30863: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30864: LD_ADDR_VAR 0 3
30868: PUSH
30869: LD_VAR 0 1
30873: PPUSH
30874: CALL_OW 269
30878: ST_TO_ADDR
// x := GetX ( building ) ;
30879: LD_ADDR_VAR 0 4
30883: PUSH
30884: LD_VAR 0 1
30888: PPUSH
30889: CALL_OW 250
30893: ST_TO_ADDR
// y := GetY ( building ) ;
30894: LD_ADDR_VAR 0 5
30898: PUSH
30899: LD_VAR 0 1
30903: PPUSH
30904: CALL_OW 251
30908: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30909: LD_ADDR_EXP 45
30913: PUSH
30914: LD_EXP 45
30918: PPUSH
30919: LD_VAR 0 1
30923: PPUSH
30924: CALL_OW 255
30928: PPUSH
30929: LD_VAR 0 3
30933: PPUSH
30934: LD_VAR 0 4
30938: PUSH
30939: LD_VAR 0 5
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PPUSH
30948: CALL 41973 0 4
30952: ST_TO_ADDR
// end ;
30953: PPOPN 5
30955: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30956: LD_VAR 0 1
30960: PUSH
30961: LD_EXP 32
30965: IN
30966: NOT
30967: IFFALSE 31015
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30969: LD_ADDR_EXP 32
30973: PUSH
30974: LD_EXP 32
30978: PPUSH
30979: LD_EXP 32
30983: PUSH
30984: LD_INT 1
30986: PLUS
30987: PPUSH
30988: LD_VAR 0 1
30992: PPUSH
30993: CALL_OW 2
30997: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30998: LD_STRING DestinationUnrechable. [unit: 
31000: PUSH
31001: LD_VAR 0 1
31005: STR
31006: PUSH
31007: LD_STRING ]
31009: STR
31010: PPUSH
31011: CALL 7984 0 1
// end ; end ;
31015: PPOPN 1
31017: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31018: LD_VAR 0 1
31022: PPUSH
31023: LD_VAR 0 2
31027: PPUSH
31028: LD_VAR 0 3
31032: PPUSH
31033: CALL 56595 0 3
// end ;
31037: PPOPN 3
31039: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31040: LD_VAR 0 1
31044: PPUSH
31045: CALL 56603 0 1
// end ; end_of_file
31049: PPOPN 1
31051: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31052: LD_INT 0
31054: PPUSH
31055: PPUSH
31056: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31057: LD_ADDR_VAR 0 7
31061: PUSH
31062: LD_VAR 0 1
31066: PUSH
31067: LD_VAR 0 2
31071: ARRAY
31072: PPUSH
31073: LD_VAR 0 3
31077: PPUSH
31078: LD_VAR 0 4
31082: PPUSH
31083: CALL_OW 1
31087: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31088: LD_ADDR_VAR 0 1
31092: PUSH
31093: LD_VAR 0 1
31097: PPUSH
31098: LD_VAR 0 2
31102: PPUSH
31103: LD_VAR 0 7
31107: PPUSH
31108: CALL_OW 1
31112: ST_TO_ADDR
// result := tab ;
31113: LD_ADDR_VAR 0 5
31117: PUSH
31118: LD_VAR 0 1
31122: ST_TO_ADDR
// end ;
31123: LD_VAR 0 5
31127: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31128: LD_INT 0
31130: PPUSH
31131: PPUSH
31132: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31133: LD_ADDR_VAR 0 5
31137: PUSH
31138: LD_VAR 0 1
31142: PUSH
31143: LD_VAR 0 2
31147: PUSH
31148: LD_INT 1
31150: ARRAY
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 2
31157: PUSH
31158: LD_INT 2
31160: ARRAY
31161: PPUSH
31162: CALL_OW 3
31166: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31167: LD_ADDR_VAR 0 1
31171: PUSH
31172: LD_VAR 0 1
31176: PPUSH
31177: LD_VAR 0 2
31181: PUSH
31182: LD_INT 1
31184: ARRAY
31185: PPUSH
31186: LD_VAR 0 5
31190: PPUSH
31191: CALL_OW 1
31195: ST_TO_ADDR
// result := tab ;
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: LD_VAR 0 1
31205: ST_TO_ADDR
// end ;
31206: LD_VAR 0 3
31210: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31211: LD_INT 0
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
// i := 1 ;
31217: LD_ADDR_VAR 0 5
31221: PUSH
31222: LD_INT 1
31224: ST_TO_ADDR
// while ( i <= tab ) do
31225: LD_VAR 0 5
31229: PUSH
31230: LD_VAR 0 1
31234: LESSEQUAL
31235: IFFALSE 31610
// begin if not tab [ i ] then
31237: LD_VAR 0 1
31241: PUSH
31242: LD_VAR 0 5
31246: ARRAY
31247: NOT
31248: IFFALSE 31252
// break ;
31250: GO 31610
// if value in tab then
31252: LD_VAR 0 2
31256: PUSH
31257: LD_VAR 0 1
31261: IN
31262: IFFALSE 31375
// begin if not mode then
31264: LD_VAR 0 3
31268: NOT
31269: IFFALSE 31289
// tab := tab diff value else
31271: LD_ADDR_VAR 0 1
31275: PUSH
31276: LD_VAR 0 1
31280: PUSH
31281: LD_VAR 0 2
31285: DIFF
31286: ST_TO_ADDR
31287: GO 31351
// for j = 1 to tab do
31289: LD_ADDR_VAR 0 6
31293: PUSH
31294: DOUBLE
31295: LD_INT 1
31297: DEC
31298: ST_TO_ADDR
31299: LD_VAR 0 1
31303: PUSH
31304: FOR_TO
31305: IFFALSE 31349
// if tab [ j ] = value then
31307: LD_VAR 0 1
31311: PUSH
31312: LD_VAR 0 6
31316: ARRAY
31317: PUSH
31318: LD_VAR 0 2
31322: EQUAL
31323: IFFALSE 31347
// begin tab := Delete ( tab , j ) ;
31325: LD_ADDR_VAR 0 1
31329: PUSH
31330: LD_VAR 0 1
31334: PPUSH
31335: LD_VAR 0 6
31339: PPUSH
31340: CALL_OW 3
31344: ST_TO_ADDR
// break ;
31345: GO 31349
// end ;
31347: GO 31304
31349: POP
31350: POP
// i := i - 1 ;
31351: LD_ADDR_VAR 0 5
31355: PUSH
31356: LD_VAR 0 5
31360: PUSH
31361: LD_INT 1
31363: MINUS
31364: ST_TO_ADDR
// if mode then
31365: LD_VAR 0 3
31369: IFFALSE 31373
// break ;
31371: GO 31610
// end else
31373: GO 31594
// if tab [ i ] and value in tab [ i ] then
31375: LD_VAR 0 1
31379: PUSH
31380: LD_VAR 0 5
31384: ARRAY
31385: PUSH
31386: LD_VAR 0 2
31390: PUSH
31391: LD_VAR 0 1
31395: PUSH
31396: LD_VAR 0 5
31400: ARRAY
31401: IN
31402: AND
31403: IFFALSE 31594
// begin if not mode then
31405: LD_VAR 0 3
31409: NOT
31410: IFFALSE 31436
// tmp := tab [ i ] diff value else
31412: LD_ADDR_VAR 0 7
31416: PUSH
31417: LD_VAR 0 1
31421: PUSH
31422: LD_VAR 0 5
31426: ARRAY
31427: PUSH
31428: LD_VAR 0 2
31432: DIFF
31433: ST_TO_ADDR
31434: GO 31516
// for j = 1 to tab [ i ] do
31436: LD_ADDR_VAR 0 6
31440: PUSH
31441: DOUBLE
31442: LD_INT 1
31444: DEC
31445: ST_TO_ADDR
31446: LD_VAR 0 1
31450: PUSH
31451: LD_VAR 0 5
31455: ARRAY
31456: PUSH
31457: FOR_TO
31458: IFFALSE 31514
// if value = tab [ i ] [ j ] then
31460: LD_VAR 0 2
31464: PUSH
31465: LD_VAR 0 1
31469: PUSH
31470: LD_VAR 0 5
31474: ARRAY
31475: PUSH
31476: LD_VAR 0 6
31480: ARRAY
31481: EQUAL
31482: IFFALSE 31512
// begin tmp := Delete ( tab [ i ] , j ) ;
31484: LD_ADDR_VAR 0 7
31488: PUSH
31489: LD_VAR 0 1
31493: PUSH
31494: LD_VAR 0 5
31498: ARRAY
31499: PPUSH
31500: LD_VAR 0 6
31504: PPUSH
31505: CALL_OW 3
31509: ST_TO_ADDR
// break ;
31510: GO 31514
// end ;
31512: GO 31457
31514: POP
31515: POP
// if tmp = [ ] then
31516: LD_VAR 0 7
31520: PUSH
31521: EMPTY
31522: EQUAL
31523: IFFALSE 31547
// begin tab := Delete ( tab , i ) ;
31525: LD_ADDR_VAR 0 1
31529: PUSH
31530: LD_VAR 0 1
31534: PPUSH
31535: LD_VAR 0 5
31539: PPUSH
31540: CALL_OW 3
31544: ST_TO_ADDR
// end else
31545: GO 31572
// tab := Replace ( tab , i , tmp ) ;
31547: LD_ADDR_VAR 0 1
31551: PUSH
31552: LD_VAR 0 1
31556: PPUSH
31557: LD_VAR 0 5
31561: PPUSH
31562: LD_VAR 0 7
31566: PPUSH
31567: CALL_OW 1
31571: ST_TO_ADDR
// i := i - 1 ;
31572: LD_ADDR_VAR 0 5
31576: PUSH
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 1
31584: MINUS
31585: ST_TO_ADDR
// if mode then
31586: LD_VAR 0 3
31590: IFFALSE 31594
// break ;
31592: GO 31610
// end ; i := i + 1 ;
31594: LD_ADDR_VAR 0 5
31598: PUSH
31599: LD_VAR 0 5
31603: PUSH
31604: LD_INT 1
31606: PLUS
31607: ST_TO_ADDR
// end ;
31608: GO 31225
// result := tab ;
31610: LD_ADDR_VAR 0 4
31614: PUSH
31615: LD_VAR 0 1
31619: ST_TO_ADDR
// end ;
31620: LD_VAR 0 4
31624: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31625: LD_INT 0
31627: PPUSH
31628: PPUSH
// for i = 1 to values do
31629: LD_ADDR_VAR 0 4
31633: PUSH
31634: DOUBLE
31635: LD_INT 1
31637: DEC
31638: ST_TO_ADDR
31639: LD_VAR 0 2
31643: PUSH
31644: FOR_TO
31645: IFFALSE 31678
// tab := Remove ( tab , values [ i ] , false ) ;
31647: LD_ADDR_VAR 0 1
31651: PUSH
31652: LD_VAR 0 1
31656: PPUSH
31657: LD_VAR 0 2
31661: PUSH
31662: LD_VAR 0 4
31666: ARRAY
31667: PPUSH
31668: LD_INT 0
31670: PPUSH
31671: CALL 31211 0 3
31675: ST_TO_ADDR
31676: GO 31644
31678: POP
31679: POP
// result := tab ;
31680: LD_ADDR_VAR 0 3
31684: PUSH
31685: LD_VAR 0 1
31689: ST_TO_ADDR
// end ;
31690: LD_VAR 0 3
31694: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31695: LD_INT 0
31697: PPUSH
31698: PPUSH
31699: PPUSH
// if not GetControl ( veh ) = control_manual then
31700: LD_VAR 0 1
31704: PPUSH
31705: CALL_OW 263
31709: PUSH
31710: LD_INT 1
31712: EQUAL
31713: NOT
31714: IFFALSE 31726
// result := false else
31716: LD_ADDR_VAR 0 2
31720: PUSH
31721: LD_INT 0
31723: ST_TO_ADDR
31724: GO 31871
// if veh in FilterAllUnits ( [ f_empty ] ) then
31726: LD_VAR 0 1
31730: PUSH
31731: LD_INT 58
31733: PUSH
31734: EMPTY
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: IN
31742: IFFALSE 31754
// result := false else
31744: LD_ADDR_VAR 0 2
31748: PUSH
31749: LD_INT 0
31751: ST_TO_ADDR
31752: GO 31871
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31754: LD_ADDR_VAR 0 4
31758: PUSH
31759: LD_INT 22
31761: PUSH
31762: LD_VAR 0 1
31766: PPUSH
31767: CALL_OW 255
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 55
31778: PUSH
31779: EMPTY
31780: LIST
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PPUSH
31786: CALL_OW 69
31790: ST_TO_ADDR
// if not filter then
31791: LD_VAR 0 4
31795: NOT
31796: IFFALSE 31808
// result := false else
31798: LD_ADDR_VAR 0 2
31802: PUSH
31803: LD_INT 0
31805: ST_TO_ADDR
31806: GO 31871
// for i = 1 to filter do
31808: LD_ADDR_VAR 0 3
31812: PUSH
31813: DOUBLE
31814: LD_INT 1
31816: DEC
31817: ST_TO_ADDR
31818: LD_VAR 0 4
31822: PUSH
31823: FOR_TO
31824: IFFALSE 31869
// if IsDriver ( filter [ i ] ) = veh then
31826: LD_VAR 0 4
31830: PUSH
31831: LD_VAR 0 3
31835: ARRAY
31836: PPUSH
31837: CALL 94081 0 1
31841: PUSH
31842: LD_VAR 0 1
31846: EQUAL
31847: IFFALSE 31867
// begin result := filter [ i ] ;
31849: LD_ADDR_VAR 0 2
31853: PUSH
31854: LD_VAR 0 4
31858: PUSH
31859: LD_VAR 0 3
31863: ARRAY
31864: ST_TO_ADDR
// break ;
31865: GO 31869
// end ;
31867: GO 31823
31869: POP
31870: POP
// end ; end ;
31871: LD_VAR 0 2
31875: RET
// export function Compare ( val1 , val2 ) ; begin
31876: LD_INT 0
31878: PPUSH
// if val1 = val2 then
31879: LD_VAR 0 1
31883: PUSH
31884: LD_VAR 0 2
31888: EQUAL
31889: IFFALSE 31901
// result := true else
31891: LD_ADDR_VAR 0 3
31895: PUSH
31896: LD_INT 1
31898: ST_TO_ADDR
31899: GO 31909
// result := false ;
31901: LD_ADDR_VAR 0 3
31905: PUSH
31906: LD_INT 0
31908: ST_TO_ADDR
// end ;
31909: LD_VAR 0 3
31913: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31914: LD_INT 0
31916: PPUSH
31917: PPUSH
// result := false ;
31918: LD_ADDR_VAR 0 3
31922: PUSH
31923: LD_INT 0
31925: ST_TO_ADDR
// for j = 1 to e2 do
31926: LD_ADDR_VAR 0 4
31930: PUSH
31931: DOUBLE
31932: LD_INT 1
31934: DEC
31935: ST_TO_ADDR
31936: LD_VAR 0 2
31940: PUSH
31941: FOR_TO
31942: IFFALSE 31976
// if Compare ( e1 , e2 [ j ] ) then
31944: LD_VAR 0 1
31948: PPUSH
31949: LD_VAR 0 2
31953: PUSH
31954: LD_VAR 0 4
31958: ARRAY
31959: PPUSH
31960: CALL 31876 0 2
31964: IFFALSE 31974
// result := true ;
31966: LD_ADDR_VAR 0 3
31970: PUSH
31971: LD_INT 1
31973: ST_TO_ADDR
31974: GO 31941
31976: POP
31977: POP
// end ;
31978: LD_VAR 0 3
31982: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
31983: LD_INT 0
31985: PPUSH
31986: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
31987: LD_VAR 0 1
31991: PPUSH
31992: LD_STRING C
31994: PUSH
31995: LD_VAR 0 2
31999: PUSH
32000: LD_VAR 0 3
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: LD_INT 0
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: PUSH
32026: LD_STRING v
32028: PUSH
32029: LD_VAR 0 4
32033: PPUSH
32034: CALL_OW 250
32038: PUSH
32039: LD_VAR 0 4
32043: PPUSH
32044: CALL_OW 251
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PPUSH
32076: CALL_OW 446
// end ;
32080: LD_VAR 0 5
32084: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32085: LD_INT 0
32087: PPUSH
32088: PPUSH
32089: PPUSH
// linked := UnitsLinked ( unit ) ;
32090: LD_ADDR_VAR 0 4
32094: PUSH
32095: LD_VAR 0 1
32099: PPUSH
32100: CALL_OW 432
32104: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32105: LD_ADDR_VAR 0 3
32109: PUSH
32110: LD_VAR 0 1
32114: PPUSH
32115: LD_INT 3
32117: PPUSH
32118: CALL_OW 259
32122: ST_TO_ADDR
// if sk > linked then
32123: LD_VAR 0 3
32127: PUSH
32128: LD_VAR 0 4
32132: GREATER
32133: IFFALSE 32145
// result := true else
32135: LD_ADDR_VAR 0 2
32139: PUSH
32140: LD_INT 1
32142: ST_TO_ADDR
32143: GO 32153
// result := false ;
32145: LD_ADDR_VAR 0 2
32149: PUSH
32150: LD_INT 0
32152: ST_TO_ADDR
// end ;
32153: LD_VAR 0 2
32157: RET
// export function NotTask ( unit ) ; begin
32158: LD_INT 0
32160: PPUSH
// result := true ;
32161: LD_ADDR_VAR 0 2
32165: PUSH
32166: LD_INT 1
32168: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32169: LD_VAR 0 1
32173: PPUSH
32174: CALL_OW 437
32178: PUSH
32179: LD_VAR 0 1
32183: PPUSH
32184: CALL_OW 314
32188: OR
32189: IFFALSE 32199
// result := false ;
32191: LD_ADDR_VAR 0 2
32195: PUSH
32196: LD_INT 0
32198: ST_TO_ADDR
// end ;
32199: LD_VAR 0 2
32203: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
32209: PPUSH
32210: PPUSH
// dist := 99999 ;
32211: LD_ADDR_VAR 0 7
32215: PUSH
32216: LD_INT 99999
32218: ST_TO_ADDR
// un := - 1 ;
32219: LD_ADDR_VAR 0 6
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: ST_TO_ADDR
// if units1 and units2 then
32228: LD_VAR 0 1
32232: PUSH
32233: LD_VAR 0 2
32237: AND
32238: IFFALSE 32326
// for i in units1 do
32240: LD_ADDR_VAR 0 4
32244: PUSH
32245: LD_VAR 0 1
32249: PUSH
32250: FOR_IN
32251: IFFALSE 32324
// for j in units2 do
32253: LD_ADDR_VAR 0 5
32257: PUSH
32258: LD_VAR 0 2
32262: PUSH
32263: FOR_IN
32264: IFFALSE 32320
// if GetDistUnits ( i , j ) < dist then
32266: LD_VAR 0 4
32270: PPUSH
32271: LD_VAR 0 5
32275: PPUSH
32276: CALL_OW 296
32280: PUSH
32281: LD_VAR 0 7
32285: LESS
32286: IFFALSE 32318
// begin un := i ;
32288: LD_ADDR_VAR 0 6
32292: PUSH
32293: LD_VAR 0 4
32297: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32298: LD_ADDR_VAR 0 7
32302: PUSH
32303: LD_VAR 0 4
32307: PPUSH
32308: LD_VAR 0 5
32312: PPUSH
32313: CALL_OW 296
32317: ST_TO_ADDR
// end ;
32318: GO 32263
32320: POP
32321: POP
32322: GO 32250
32324: POP
32325: POP
// result := [ un , dist ] ;
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_VAR 0 6
32335: PUSH
32336: LD_VAR 0 7
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// end ;
32345: LD_VAR 0 3
32349: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32350: LD_INT 0
32352: PPUSH
32353: PPUSH
32354: PPUSH
32355: PPUSH
32356: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32357: LD_VAR 0 1
32361: NOT
32362: PUSH
32363: LD_VAR 0 1
32367: PPUSH
32368: CALL_OW 256
32372: PUSH
32373: LD_INT 250
32375: LESS
32376: OR
32377: PUSH
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 314
32387: PUSH
32388: LD_VAR 0 1
32392: PPUSH
32393: CALL_OW 261
32397: PUSH
32398: LD_INT 20
32400: GREATER
32401: AND
32402: OR
32403: IFFALSE 32407
// exit ;
32405: GO 32781
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32407: LD_VAR 0 1
32411: PPUSH
32412: CALL_OW 261
32416: PUSH
32417: LD_INT 20
32419: LESS
32420: PUSH
32421: LD_VAR 0 1
32425: PPUSH
32426: CALL_OW 110
32430: PUSH
32431: LD_INT 21
32433: EQUAL
32434: NOT
32435: AND
32436: IFFALSE 32472
// begin ComStop ( bulldozer ) ;
32438: LD_VAR 0 1
32442: PPUSH
32443: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32447: LD_VAR 0 1
32451: PPUSH
32452: LD_INT 21
32454: PPUSH
32455: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32459: LD_VAR 0 1
32463: PPUSH
32464: CALL 26214 0 1
// exit ;
32468: GO 32781
// end else
32470: GO 32499
// if GetFuel ( bulldozer ) > 20 then
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 261
32481: PUSH
32482: LD_INT 20
32484: GREATER
32485: IFFALSE 32499
// SetTag ( bulldozer , 0 ) ;
32487: LD_VAR 0 1
32491: PPUSH
32492: LD_INT 0
32494: PPUSH
32495: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32499: LD_ADDR_VAR 0 5
32503: PUSH
32504: LD_VAR 0 2
32508: PPUSH
32509: CALL_OW 353
32513: ST_TO_ADDR
// tmp := [ ] ;
32514: LD_ADDR_VAR 0 6
32518: PUSH
32519: EMPTY
32520: ST_TO_ADDR
// for i = 1 to list do
32521: LD_ADDR_VAR 0 4
32525: PUSH
32526: DOUBLE
32527: LD_INT 1
32529: DEC
32530: ST_TO_ADDR
32531: LD_VAR 0 5
32535: PUSH
32536: FOR_TO
32537: IFFALSE 32635
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32539: LD_VAR 0 5
32543: PUSH
32544: LD_VAR 0 4
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: ARRAY
32553: PPUSH
32554: LD_VAR 0 5
32558: PUSH
32559: LD_VAR 0 4
32563: ARRAY
32564: PUSH
32565: LD_INT 2
32567: ARRAY
32568: PPUSH
32569: CALL_OW 554
32573: IFFALSE 32633
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32575: LD_ADDR_VAR 0 6
32579: PUSH
32580: LD_VAR 0 6
32584: PPUSH
32585: LD_VAR 0 6
32589: PUSH
32590: LD_INT 1
32592: PLUS
32593: PPUSH
32594: LD_VAR 0 5
32598: PUSH
32599: LD_VAR 0 4
32603: ARRAY
32604: PUSH
32605: LD_INT 1
32607: ARRAY
32608: PUSH
32609: LD_VAR 0 5
32613: PUSH
32614: LD_VAR 0 4
32618: ARRAY
32619: PUSH
32620: LD_INT 2
32622: ARRAY
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PPUSH
32628: CALL_OW 1
32632: ST_TO_ADDR
// end ;
32633: GO 32536
32635: POP
32636: POP
// ComStop ( bulldozer ) ;
32637: LD_VAR 0 1
32641: PPUSH
32642: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32646: LD_ADDR_VAR 0 7
32650: PUSH
32651: LD_VAR 0 1
32655: PPUSH
32656: CALL_OW 250
32660: PUSH
32661: LD_VAR 0 1
32665: PPUSH
32666: CALL_OW 251
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: ST_TO_ADDR
// for i = tmp downto 1 do
32675: LD_ADDR_VAR 0 4
32679: PUSH
32680: DOUBLE
32681: LD_VAR 0 6
32685: INC
32686: ST_TO_ADDR
32687: LD_INT 1
32689: PUSH
32690: FOR_DOWNTO
32691: IFFALSE 32779
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32693: LD_ADDR_VAR 0 7
32697: PUSH
32698: LD_VAR 0 7
32702: PUSH
32703: LD_INT 1
32705: ARRAY
32706: PPUSH
32707: LD_VAR 0 7
32711: PUSH
32712: LD_INT 2
32714: ARRAY
32715: PPUSH
32716: LD_VAR 0 6
32720: PPUSH
32721: CALL 32882 0 3
32725: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32726: LD_VAR 0 1
32730: PPUSH
32731: LD_VAR 0 7
32735: PUSH
32736: LD_INT 1
32738: ARRAY
32739: PPUSH
32740: LD_VAR 0 7
32744: PUSH
32745: LD_INT 2
32747: ARRAY
32748: PPUSH
32749: CALL 32786 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32753: LD_ADDR_VAR 0 6
32757: PUSH
32758: LD_VAR 0 6
32762: PPUSH
32763: LD_VAR 0 7
32767: PUSH
32768: LD_INT 3
32770: ARRAY
32771: PPUSH
32772: CALL_OW 3
32776: ST_TO_ADDR
// end ;
32777: GO 32690
32779: POP
32780: POP
// end ;
32781: LD_VAR 0 3
32785: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32786: LD_INT 0
32788: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32789: LD_VAR 0 2
32793: PPUSH
32794: LD_VAR 0 3
32798: PPUSH
32799: CALL_OW 351
32803: PUSH
32804: LD_VAR 0 2
32808: PPUSH
32809: LD_VAR 0 3
32813: PPUSH
32814: CALL_OW 554
32818: AND
32819: PUSH
32820: LD_VAR 0 2
32824: PPUSH
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL_OW 488
32834: AND
32835: PUSH
32836: LD_VAR 0 2
32840: PPUSH
32841: LD_VAR 0 3
32845: PPUSH
32846: CALL_OW 428
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: EQUAL
32855: AND
32856: IFFALSE 32877
// AddComMoveXY ( bulldozer , x , y ) ;
32858: LD_VAR 0 1
32862: PPUSH
32863: LD_VAR 0 2
32867: PPUSH
32868: LD_VAR 0 3
32872: PPUSH
32873: CALL_OW 171
// end ;
32877: LD_VAR 0 4
32881: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32882: LD_INT 0
32884: PPUSH
32885: PPUSH
32886: PPUSH
32887: PPUSH
32888: PPUSH
32889: PPUSH
32890: PPUSH
// dist := 99999 ;
32891: LD_ADDR_VAR 0 6
32895: PUSH
32896: LD_INT 99999
32898: ST_TO_ADDR
// for i = 1 to list do
32899: LD_ADDR_VAR 0 5
32903: PUSH
32904: DOUBLE
32905: LD_INT 1
32907: DEC
32908: ST_TO_ADDR
32909: LD_VAR 0 3
32913: PUSH
32914: FOR_TO
32915: IFFALSE 33053
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32917: LD_ADDR_VAR 0 7
32921: PUSH
32922: LD_VAR 0 1
32926: PPUSH
32927: LD_VAR 0 2
32931: PPUSH
32932: LD_VAR 0 3
32936: PUSH
32937: LD_VAR 0 5
32941: ARRAY
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: LD_VAR 0 3
32951: PUSH
32952: LD_VAR 0 5
32956: ARRAY
32957: PUSH
32958: LD_INT 2
32960: ARRAY
32961: PPUSH
32962: CALL_OW 298
32966: ST_TO_ADDR
// if d = 0 then
32967: LD_VAR 0 7
32971: PUSH
32972: LD_INT 0
32974: EQUAL
32975: IFFALSE 32979
// continue ;
32977: GO 32914
// if d < dist then
32979: LD_VAR 0 7
32983: PUSH
32984: LD_VAR 0 6
32988: LESS
32989: IFFALSE 33051
// begin _x := list [ i ] [ 1 ] ;
32991: LD_ADDR_VAR 0 8
32995: PUSH
32996: LD_VAR 0 3
33000: PUSH
33001: LD_VAR 0 5
33005: ARRAY
33006: PUSH
33007: LD_INT 1
33009: ARRAY
33010: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33011: LD_ADDR_VAR 0 9
33015: PUSH
33016: LD_VAR 0 3
33020: PUSH
33021: LD_VAR 0 5
33025: ARRAY
33026: PUSH
33027: LD_INT 2
33029: ARRAY
33030: ST_TO_ADDR
// _i := i ;
33031: LD_ADDR_VAR 0 10
33035: PUSH
33036: LD_VAR 0 5
33040: ST_TO_ADDR
// dist := d ;
33041: LD_ADDR_VAR 0 6
33045: PUSH
33046: LD_VAR 0 7
33050: ST_TO_ADDR
// end ; end ;
33051: GO 32914
33053: POP
33054: POP
// result := [ _x , _y , _i , dist ] ;
33055: LD_ADDR_VAR 0 4
33059: PUSH
33060: LD_VAR 0 8
33064: PUSH
33065: LD_VAR 0 9
33069: PUSH
33070: LD_VAR 0 10
33074: PUSH
33075: LD_VAR 0 6
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// end ;
33086: LD_VAR 0 4
33090: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33091: LD_INT 0
33093: PPUSH
33094: PPUSH
33095: PPUSH
33096: PPUSH
33097: PPUSH
// for i = 1 to list do
33098: LD_ADDR_VAR 0 5
33102: PUSH
33103: DOUBLE
33104: LD_INT 1
33106: DEC
33107: ST_TO_ADDR
33108: LD_VAR 0 1
33112: PUSH
33113: FOR_TO
33114: IFFALSE 33428
// begin for j = list downto 2 do
33116: LD_ADDR_VAR 0 6
33120: PUSH
33121: DOUBLE
33122: LD_VAR 0 1
33126: INC
33127: ST_TO_ADDR
33128: LD_INT 2
33130: PUSH
33131: FOR_DOWNTO
33132: IFFALSE 33424
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33134: LD_VAR 0 2
33138: PPUSH
33139: LD_VAR 0 3
33143: PPUSH
33144: LD_VAR 0 1
33148: PUSH
33149: LD_VAR 0 6
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: ARRAY
33158: PPUSH
33159: LD_VAR 0 1
33163: PUSH
33164: LD_VAR 0 6
33168: ARRAY
33169: PUSH
33170: LD_INT 2
33172: ARRAY
33173: PPUSH
33174: CALL_OW 298
33178: PUSH
33179: LD_VAR 0 2
33183: PPUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: LD_VAR 0 1
33193: PUSH
33194: LD_VAR 0 6
33198: PUSH
33199: LD_INT 1
33201: MINUS
33202: ARRAY
33203: PUSH
33204: LD_INT 1
33206: ARRAY
33207: PPUSH
33208: LD_VAR 0 1
33212: PUSH
33213: LD_VAR 0 6
33217: PUSH
33218: LD_INT 1
33220: MINUS
33221: ARRAY
33222: PUSH
33223: LD_INT 2
33225: ARRAY
33226: PPUSH
33227: CALL_OW 298
33231: LESS
33232: IFFALSE 33422
// begin _x := list [ j ] [ 1 ] ;
33234: LD_ADDR_VAR 0 7
33238: PUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 1
33252: ARRAY
33253: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33254: LD_ADDR_VAR 0 8
33258: PUSH
33259: LD_VAR 0 1
33263: PUSH
33264: LD_VAR 0 6
33268: ARRAY
33269: PUSH
33270: LD_INT 2
33272: ARRAY
33273: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33274: LD_ADDR_VAR 0 1
33278: PUSH
33279: LD_VAR 0 1
33283: PPUSH
33284: LD_VAR 0 6
33288: PPUSH
33289: LD_INT 1
33291: PPUSH
33292: LD_VAR 0 1
33296: PUSH
33297: LD_VAR 0 6
33301: PUSH
33302: LD_INT 1
33304: MINUS
33305: ARRAY
33306: PUSH
33307: LD_INT 1
33309: ARRAY
33310: PPUSH
33311: CALL 31052 0 4
33315: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33316: LD_ADDR_VAR 0 1
33320: PUSH
33321: LD_VAR 0 1
33325: PPUSH
33326: LD_VAR 0 6
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: LD_VAR 0 1
33338: PUSH
33339: LD_VAR 0 6
33343: PUSH
33344: LD_INT 1
33346: MINUS
33347: ARRAY
33348: PUSH
33349: LD_INT 2
33351: ARRAY
33352: PPUSH
33353: CALL 31052 0 4
33357: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_VAR 0 1
33367: PPUSH
33368: LD_VAR 0 6
33372: PUSH
33373: LD_INT 1
33375: MINUS
33376: PPUSH
33377: LD_INT 1
33379: PPUSH
33380: LD_VAR 0 7
33384: PPUSH
33385: CALL 31052 0 4
33389: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33390: LD_ADDR_VAR 0 1
33394: PUSH
33395: LD_VAR 0 1
33399: PPUSH
33400: LD_VAR 0 6
33404: PUSH
33405: LD_INT 1
33407: MINUS
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 8
33416: PPUSH
33417: CALL 31052 0 4
33421: ST_TO_ADDR
// end ; end ;
33422: GO 33131
33424: POP
33425: POP
// end ;
33426: GO 33113
33428: POP
33429: POP
// result := list ;
33430: LD_ADDR_VAR 0 4
33434: PUSH
33435: LD_VAR 0 1
33439: ST_TO_ADDR
// end ;
33440: LD_VAR 0 4
33444: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33445: LD_INT 0
33447: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33448: LD_ADDR_VAR 0 5
33452: PUSH
33453: LD_VAR 0 1
33457: PPUSH
33458: LD_VAR 0 2
33462: PPUSH
33463: CALL_OW 546
33467: PUSH
33468: LD_INT 2
33470: ARRAY
33471: PUSH
33472: LD_VAR 0 3
33476: PPUSH
33477: LD_VAR 0 4
33481: PPUSH
33482: CALL_OW 546
33486: PUSH
33487: LD_INT 2
33489: ARRAY
33490: MINUS
33491: ST_TO_ADDR
// if result < 0 then
33492: LD_VAR 0 5
33496: PUSH
33497: LD_INT 0
33499: LESS
33500: IFFALSE 33517
// result := result * - 1 ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_VAR 0 5
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: MUL
33516: ST_TO_ADDR
// end ;
33517: LD_VAR 0 5
33521: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33522: LD_INT 0
33524: PPUSH
33525: PPUSH
// area = ListEnvironmentArea ( area ) ;
33526: LD_ADDR_VAR 0 2
33530: PUSH
33531: LD_VAR 0 2
33535: PPUSH
33536: CALL_OW 353
33540: ST_TO_ADDR
// if bulldozer > 0 then
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 0
33548: GREATER
33549: IFFALSE 33660
// for i = area downto 1 do
33551: LD_ADDR_VAR 0 4
33555: PUSH
33556: DOUBLE
33557: LD_VAR 0 2
33561: INC
33562: ST_TO_ADDR
33563: LD_INT 1
33565: PUSH
33566: FOR_DOWNTO
33567: IFFALSE 33658
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33569: LD_VAR 0 2
33573: PUSH
33574: LD_VAR 0 4
33578: ARRAY
33579: PUSH
33580: LD_INT 1
33582: ARRAY
33583: PPUSH
33584: LD_VAR 0 2
33588: PUSH
33589: LD_VAR 0 4
33593: ARRAY
33594: PUSH
33595: LD_INT 2
33597: ARRAY
33598: PPUSH
33599: CALL_OW 351
33603: IFFALSE 33656
// if not HasTask ( bulldozer ) then
33605: LD_VAR 0 1
33609: PPUSH
33610: CALL_OW 314
33614: NOT
33615: IFFALSE 33656
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33617: LD_VAR 0 1
33621: PPUSH
33622: LD_VAR 0 2
33626: PUSH
33627: LD_VAR 0 4
33631: ARRAY
33632: PUSH
33633: LD_INT 1
33635: ARRAY
33636: PPUSH
33637: LD_VAR 0 2
33641: PUSH
33642: LD_VAR 0 4
33646: ARRAY
33647: PUSH
33648: LD_INT 2
33650: ARRAY
33651: PPUSH
33652: CALL_OW 171
33656: GO 33566
33658: POP
33659: POP
// end ;
33660: LD_VAR 0 3
33664: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33665: LD_INT 0
33667: PPUSH
33668: PPUSH
33669: PPUSH
33670: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33671: LD_ADDR_VAR 0 6
33675: PUSH
33676: LD_INT 22
33678: PUSH
33679: LD_VAR 0 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 21
33690: PUSH
33691: LD_VAR 0 2
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PPUSH
33704: CALL_OW 69
33708: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33709: LD_ADDR_VAR 0 7
33713: PUSH
33714: LD_VAR 0 3
33718: PPUSH
33719: LD_INT 22
33721: PUSH
33722: LD_VAR 0 1
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 21
33733: PUSH
33734: LD_VAR 0 2
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PPUSH
33747: CALL_OW 70
33751: ST_TO_ADDR
// if tmp and pom then
33752: LD_VAR 0 6
33756: PUSH
33757: LD_VAR 0 7
33761: AND
33762: IFFALSE 33782
// result := tmp diff pom else
33764: LD_ADDR_VAR 0 4
33768: PUSH
33769: LD_VAR 0 6
33773: PUSH
33774: LD_VAR 0 7
33778: DIFF
33779: ST_TO_ADDR
33780: GO 33790
// result := false ;
33782: LD_ADDR_VAR 0 4
33786: PUSH
33787: LD_INT 0
33789: ST_TO_ADDR
// end ;
33790: LD_VAR 0 4
33794: RET
// export function SavePosition ( unit ) ; begin
33795: LD_INT 0
33797: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33798: LD_VAR 0 1
33802: PPUSH
33803: LD_VAR 0 1
33807: PPUSH
33808: CALL_OW 250
33812: PPUSH
33813: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33817: LD_VAR 0 1
33821: PPUSH
33822: LD_VAR 0 1
33826: PPUSH
33827: CALL_OW 251
33831: PPUSH
33832: CALL_OW 232
// end ;
33836: LD_VAR 0 2
33840: RET
// export function GetPosition ( unit ) ; begin
33841: LD_INT 0
33843: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33844: LD_ADDR_VAR 0 2
33848: PUSH
33849: LD_VAR 0 1
33853: PPUSH
33854: CALL_OW 252
33858: PUSH
33859: LD_VAR 0 1
33863: PPUSH
33864: CALL_OW 253
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: ST_TO_ADDR
// end ;
33873: LD_VAR 0 2
33877: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33878: LD_INT 0
33880: PPUSH
// if unit in unreachableList then
33881: LD_VAR 0 1
33885: PUSH
33886: LD_EXP 32
33890: IN
33891: IFFALSE 33909
// unreachableList := unreachableList diff unit ;
33893: LD_ADDR_EXP 32
33897: PUSH
33898: LD_EXP 32
33902: PUSH
33903: LD_VAR 0 1
33907: DIFF
33908: ST_TO_ADDR
// if ValidHex ( x , y ) then
33909: LD_VAR 0 2
33913: PPUSH
33914: LD_VAR 0 3
33918: PPUSH
33919: CALL_OW 488
33923: IFFALSE 33949
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33925: LD_VAR 0 1
33929: PPUSH
33930: LD_VAR 0 2
33934: PPUSH
33935: LD_VAR 0 3
33939: PPUSH
33940: CALL_OW 428
33944: PPUSH
33945: CALL_OW 115
// Wait ( 3 ) ;
33949: LD_INT 3
33951: PPUSH
33952: CALL_OW 67
// if unit in unreachableList then
33956: LD_VAR 0 1
33960: PUSH
33961: LD_EXP 32
33965: IN
33966: IFFALSE 33978
// result := false else
33968: LD_ADDR_VAR 0 4
33972: PUSH
33973: LD_INT 0
33975: ST_TO_ADDR
33976: GO 33986
// result := true ;
33978: LD_ADDR_VAR 0 4
33982: PUSH
33983: LD_INT 1
33985: ST_TO_ADDR
// end ; end_of_file
33986: LD_VAR 0 4
33990: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
33991: LD_EXP 33
33995: IFFALSE 34057
33997: GO 33999
33999: DISABLE
34000: LD_INT 0
34002: PPUSH
// begin enable ;
34003: ENABLE
// for i = 1 to mc_crates_list do
34004: LD_ADDR_VAR 0 1
34008: PUSH
34009: DOUBLE
34010: LD_INT 1
34012: DEC
34013: ST_TO_ADDR
34014: LD_EXP 34
34018: PUSH
34019: FOR_TO
34020: IFFALSE 34051
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34022: LD_EXP 34
34026: PUSH
34027: LD_VAR 0 1
34031: ARRAY
34032: PPUSH
34033: LD_INT 5
34035: PPUSH
34036: LD_INT 50
34038: PPUSH
34039: LD_INT 700
34041: PPUSH
34042: LD_INT 20
34044: PPUSH
34045: CALL 24421 0 5
34049: GO 34019
34051: POP
34052: POP
// MC_Game ( ) ;
34053: CALL 34060 0 0
// end ;
34057: PPOPN 1
34059: END
// export function MC_Game ( ) ; var i , side , un ; begin
34060: LD_INT 0
34062: PPUSH
34063: PPUSH
34064: PPUSH
34065: PPUSH
// if not isTest then
34066: LD_EXP 1
34070: NOT
34071: IFFALSE 34091
// MC_Show ( [ #tick , tick ] ) else
34073: LD_STRING #tick
34075: PUSH
34076: LD_OWVAR 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PPUSH
34085: CALL 8505 0 1
34089: GO 34100
// MC_Show ( debug_string ) ;
34091: LD_EXP 2
34095: PPUSH
34096: CALL 8505 0 1
// for side = 1 to 8 do
34100: LD_ADDR_VAR 0 3
34104: PUSH
34105: DOUBLE
34106: LD_INT 1
34108: DEC
34109: ST_TO_ADDR
34110: LD_INT 8
34112: PUSH
34113: FOR_TO
34114: IFFALSE 36114
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34116: LD_EXP 41
34120: PUSH
34121: LD_VAR 0 3
34125: ARRAY
34126: PUSH
34127: LD_INT 0
34129: EQUAL
34130: PUSH
34131: LD_VAR 0 3
34135: PPUSH
34136: EMPTY
34137: PPUSH
34138: CALL 11722 0 2
34142: PUSH
34143: LD_INT 0
34145: EQUAL
34146: OR
34147: IFFALSE 34151
// continue ;
34149: GO 34113
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34151: LD_VAR 0 3
34155: PPUSH
34156: LD_VAR 0 3
34160: PPUSH
34161: CALL 24942 0 1
34165: PPUSH
34166: CALL 36121 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34170: LD_EXP 73
34174: PUSH
34175: LD_VAR 0 3
34179: ARRAY
34180: PUSH
34181: LD_INT 1
34183: ARRAY
34184: PUSH
34185: LD_INT 0
34187: GREATER
34188: PUSH
34189: LD_EXP 71
34193: PUSH
34194: LD_VAR 0 3
34198: ARRAY
34199: PUSH
34200: LD_INT 1
34202: ARRAY
34203: PUSH
34204: LD_INT 0
34206: EQUAL
34207: AND
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: LD_INT 7
34216: PPUSH
34217: EMPTY
34218: PPUSH
34219: CALL 12290 0 3
34223: NOT
34224: AND
34225: IFFALSE 34296
// begin if side = 1 then
34227: LD_VAR 0 3
34231: PUSH
34232: LD_INT 1
34234: EQUAL
34235: IFFALSE 34244
// RaiseSailEvent ( 101 ) ;
34237: LD_INT 101
34239: PPUSH
34240: CALL_OW 427
// if side = 4 then
34244: LD_VAR 0 3
34248: PUSH
34249: LD_INT 4
34251: EQUAL
34252: IFFALSE 34261
// RaiseSailEvent ( 102 ) ;
34254: LD_INT 102
34256: PPUSH
34257: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34261: LD_ADDR_VAR 0 2
34265: PUSH
34266: LD_EXP 73
34270: PUSH
34271: LD_VAR 0 3
34275: ARRAY
34276: PUSH
34277: FOR_IN
34278: IFFALSE 34294
// SetTag ( i , 7 ) ;
34280: LD_VAR 0 2
34284: PPUSH
34285: LD_INT 7
34287: PPUSH
34288: CALL_OW 109
34292: GO 34277
34294: POP
34295: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34296: LD_VAR 0 3
34300: PPUSH
34301: LD_INT 7
34303: PPUSH
34304: EMPTY
34305: PPUSH
34306: CALL 12290 0 3
34310: IFFALSE 34336
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34312: LD_VAR 0 3
34316: PPUSH
34317: LD_VAR 0 3
34321: PPUSH
34322: LD_INT 7
34324: PPUSH
34325: EMPTY
34326: PPUSH
34327: CALL 12290 0 3
34331: PPUSH
34332: CALL 8432 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34336: LD_VAR 0 3
34340: PPUSH
34341: CALL 17970 0 1
34345: PUSH
34346: LD_VAR 0 3
34350: PPUSH
34351: CALL 11626 0 1
34355: AND
34356: IFFALSE 34367
// MCL_Start ( side ) ;
34358: LD_VAR 0 3
34362: PPUSH
34363: CALL 17927 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34367: LD_ADDR_EXP 37
34371: PUSH
34372: LD_EXP 37
34376: PPUSH
34377: LD_VAR 0 3
34381: PPUSH
34382: LD_VAR 0 3
34386: PPUSH
34387: CALL 19227 0 1
34391: PPUSH
34392: CALL_OW 1
34396: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34397: LD_ADDR_EXP 49
34401: PUSH
34402: LD_EXP 49
34406: PPUSH
34407: LD_VAR 0 3
34411: PPUSH
34412: LD_VAR 0 3
34416: PPUSH
34417: CALL 11040 0 1
34421: PPUSH
34422: CALL_OW 1
34426: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34427: LD_VAR 0 3
34431: PPUSH
34432: LD_INT 21
34434: PUSH
34435: LD_INT 2
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PPUSH
34442: CALL 11587 0 2
34446: IFFALSE 34457
// MCV_CheckStatus ( side ) ;
34448: LD_VAR 0 3
34452: PPUSH
34453: CALL 27124 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_EXP 55
34466: PPUSH
34467: CALL 42921 0 2
34471: IFFALSE 34556
// begin for i = MREG_ToChangeClass downto 1 do
34473: LD_ADDR_VAR 0 2
34477: PUSH
34478: DOUBLE
34479: LD_EXP 55
34483: INC
34484: ST_TO_ADDR
34485: LD_INT 1
34487: PUSH
34488: FOR_DOWNTO
34489: IFFALSE 34554
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34491: LD_EXP 55
34495: PUSH
34496: LD_VAR 0 2
34500: ARRAY
34501: PUSH
34502: LD_INT 1
34504: ARRAY
34505: PUSH
34506: LD_VAR 0 3
34510: EQUAL
34511: IFFALSE 34552
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34513: LD_VAR 0 3
34517: PPUSH
34518: LD_EXP 55
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: PUSH
34529: LD_INT 2
34531: ARRAY
34532: PPUSH
34533: LD_EXP 55
34537: PUSH
34538: LD_VAR 0 2
34542: ARRAY
34543: PUSH
34544: LD_INT 3
34546: ARRAY
34547: PPUSH
34548: CALL 16494 0 3
// end ; end ;
34552: GO 34488
34554: POP
34555: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34556: LD_INT 1
34558: PUSH
34559: LD_EXP 40
34563: PUSH
34564: LD_VAR 0 3
34568: ARRAY
34569: IN
34570: IFFALSE 34581
// begin MCN_TrainApe ( side ) ;
34572: LD_VAR 0 3
34576: PPUSH
34577: CALL 18880 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34581: LD_VAR 0 3
34585: PPUSH
34586: LD_INT 30
34588: PUSH
34589: LD_INT 3
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PPUSH
34596: CALL 11587 0 2
34600: IFFALSE 34774
// begin if MCF_Tag ( side , 10 , [ ] ) then
34602: LD_VAR 0 3
34606: PPUSH
34607: LD_INT 10
34609: PPUSH
34610: EMPTY
34611: PPUSH
34612: CALL 12290 0 3
34616: IFFALSE 34663
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34618: LD_VAR 0 3
34622: PPUSH
34623: LD_INT 10
34625: PPUSH
34626: EMPTY
34627: PPUSH
34628: CALL 12290 0 3
34632: PPUSH
34633: LD_VAR 0 3
34637: PPUSH
34638: LD_INT 30
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PPUSH
34648: CALL 11587 0 2
34652: PUSH
34653: LD_INT 1
34655: ARRAY
34656: PPUSH
34657: CALL_OW 168
// end else
34661: GO 34774
// if MREG_ToConstruct [ side ] then
34663: LD_EXP 53
34667: PUSH
34668: LD_VAR 0 3
34672: ARRAY
34673: IFFALSE 34774
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 30
34687: PUSH
34688: LD_INT 3
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PPUSH
34695: CALL 11587 0 2
34699: PUSH
34700: LD_INT 1
34702: ARRAY
34703: PPUSH
34704: LD_EXP 53
34708: PUSH
34709: LD_VAR 0 3
34713: ARRAY
34714: PUSH
34715: LD_INT 1
34717: ARRAY
34718: PUSH
34719: LD_EXP 53
34723: PUSH
34724: LD_VAR 0 3
34728: ARRAY
34729: PUSH
34730: LD_INT 2
34732: ARRAY
34733: PUSH
34734: LD_EXP 53
34738: PUSH
34739: LD_VAR 0 3
34743: ARRAY
34744: PUSH
34745: LD_INT 3
34747: ARRAY
34748: PUSH
34749: LD_EXP 53
34753: PUSH
34754: LD_VAR 0 3
34758: ARRAY
34759: PUSH
34760: LD_INT 4
34762: ARRAY
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: PPUSH
34770: CALL 25432 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11587 0 2
34793: PUSH
34794: LD_VAR 0 3
34798: PPUSH
34799: LD_EXP 45
34803: PPUSH
34804: CALL 42921 0 2
34808: AND
34809: PUSH
34810: LD_INT 22
34812: PUSH
34813: LD_VAR 0 3
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: PUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 33
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 30
34837: PUSH
34838: LD_INT 32
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 35
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: LIST
34864: PPUSH
34865: CALL_OW 69
34869: AND
34870: IFFALSE 34881
// MCV_Turret ( side ) ;
34872: LD_VAR 0 3
34876: PPUSH
34877: CALL 25869 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34881: LD_EXP 44
34885: PUSH
34886: LD_VAR 0 3
34890: ARRAY
34891: PUSH
34892: LD_INT 1
34894: GREATER
34895: PUSH
34896: LD_VAR 0 3
34900: PPUSH
34901: CALL 24942 0 1
34905: PUSH
34906: LD_INT 0
34908: EQUAL
34909: AND
34910: IFFALSE 35072
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34912: LD_EXP 44
34916: PUSH
34917: LD_VAR 0 3
34921: ARRAY
34922: PUSH
34923: LD_INT 1
34925: ARRAY
34926: PPUSH
34927: CALL_OW 353
34931: IFFALSE 34969
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
34933: LD_EXP 44
34937: PUSH
34938: LD_VAR 0 3
34942: ARRAY
34943: PUSH
34944: LD_INT 2
34946: ARRAY
34947: PPUSH
34948: LD_EXP 44
34952: PUSH
34953: LD_VAR 0 3
34957: ARRAY
34958: PUSH
34959: LD_INT 1
34961: ARRAY
34962: PPUSH
34963: CALL 32350 0 2
34967: GO 35072
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
34969: LD_VAR 0 3
34973: PPUSH
34974: LD_INT 30
34976: PUSH
34977: LD_INT 3
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PPUSH
34984: CALL 11587 0 2
34988: IFFALSE 35072
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
34990: LD_VAR 0 3
34994: PPUSH
34995: LD_INT 30
34997: PUSH
34998: LD_INT 3
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PPUSH
35005: CALL 11587 0 2
35009: PUSH
35010: LD_INT 1
35012: ARRAY
35013: PPUSH
35014: CALL_OW 461
35018: PUSH
35019: LD_INT 2
35021: EQUAL
35022: IFFALSE 35072
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35024: LD_EXP 44
35028: PUSH
35029: LD_VAR 0 3
35033: ARRAY
35034: PUSH
35035: LD_INT 2
35037: ARRAY
35038: PPUSH
35039: LD_INT 10
35041: PPUSH
35042: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35046: LD_ADDR_EXP 44
35050: PUSH
35051: LD_EXP 44
35055: PPUSH
35056: LD_VAR 0 3
35060: PPUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: PPUSH
35067: CALL_OW 1
35071: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35072: LD_VAR 0 3
35076: PPUSH
35077: LD_INT 33
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PPUSH
35087: CALL 11587 0 2
35091: IFFALSE 35131
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35093: LD_VAR 0 3
35097: PPUSH
35098: LD_VAR 0 3
35102: PPUSH
35103: LD_INT 33
35105: PUSH
35106: LD_INT 2
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PPUSH
35113: CALL 11587 0 2
35117: PUSH
35118: LD_INT 1
35120: ARRAY
35121: PPUSH
35122: CALL_OW 248
35126: PPUSH
35127: CALL 26423 0 2
// if MREG_ToRepair [ side ] then
35131: LD_EXP 49
35135: PUSH
35136: LD_VAR 0 3
35140: ARRAY
35141: IFFALSE 35154
// begin MCB_Repair ( side ) ;
35143: LD_VAR 0 3
35147: PPUSH
35148: CALL 11327 0 1
// end else
35152: GO 36067
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35154: LD_VAR 0 3
35158: PPUSH
35159: LD_EXP 51
35163: PPUSH
35164: CALL 42921 0 2
35168: PUSH
35169: LD_VAR 0 3
35173: PPUSH
35174: LD_EXP 42
35178: PPUSH
35179: CALL 42921 0 2
35183: AND
35184: IFFALSE 35392
// begin for i = 1 to MREG_ToUpLab do
35186: LD_ADDR_VAR 0 2
35190: PUSH
35191: DOUBLE
35192: LD_INT 1
35194: DEC
35195: ST_TO_ADDR
35196: LD_EXP 51
35200: PUSH
35201: FOR_TO
35202: IFFALSE 35388
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35204: LD_EXP 51
35208: PUSH
35209: LD_VAR 0 2
35213: ARRAY
35214: PUSH
35215: LD_INT 1
35217: ARRAY
35218: PUSH
35219: LD_VAR 0 3
35223: EQUAL
35224: IFFALSE 35386
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35226: LD_EXP 51
35230: PUSH
35231: LD_VAR 0 2
35235: ARRAY
35236: PUSH
35237: LD_INT 2
35239: ARRAY
35240: PUSH
35241: LD_EXP 51
35245: PUSH
35246: LD_VAR 0 2
35250: ARRAY
35251: PUSH
35252: LD_INT 3
35254: ARRAY
35255: AND
35256: IFFALSE 35384
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35258: LD_VAR 0 3
35262: PPUSH
35263: LD_EXP 51
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PUSH
35274: LD_INT 2
35276: ARRAY
35277: PPUSH
35278: LD_EXP 51
35282: PUSH
35283: LD_VAR 0 2
35287: ARRAY
35288: PUSH
35289: LD_INT 3
35291: ARRAY
35292: PPUSH
35293: CALL 8851 0 3
35297: IFFALSE 35384
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35299: LD_ADDR_EXP 51
35303: PUSH
35304: LD_EXP 51
35308: PPUSH
35309: LD_VAR 0 3
35313: PPUSH
35314: LD_EXP 51
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PUSH
35325: LD_INT 2
35327: ARRAY
35328: PPUSH
35329: LD_EXP 51
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_INT 3
35342: ARRAY
35343: PPUSH
35344: CALL 41973 0 4
35348: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35349: LD_ADDR_EXP 42
35353: PUSH
35354: LD_EXP 42
35358: PPUSH
35359: LD_VAR 0 3
35363: PPUSH
35364: LD_EXP 42
35368: PUSH
35369: LD_INT 1
35371: ARRAY
35372: PUSH
35373: LD_INT 2
35375: ARRAY
35376: PPUSH
35377: EMPTY
35378: PPUSH
35379: CALL 41973 0 4
35383: ST_TO_ADDR
// end ; break ;
35384: GO 35388
// end ;
35386: GO 35201
35388: POP
35389: POP
// end else
35390: GO 36067
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35392: LD_VAR 0 3
35396: PPUSH
35397: LD_EXP 50
35401: PPUSH
35402: CALL 42921 0 2
35406: IFFALSE 35480
// begin for i = 1 to MREG_ToUpdate do
35408: LD_ADDR_VAR 0 2
35412: PUSH
35413: DOUBLE
35414: LD_INT 1
35416: DEC
35417: ST_TO_ADDR
35418: LD_EXP 50
35422: PUSH
35423: FOR_TO
35424: IFFALSE 35476
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35426: LD_EXP 50
35430: PUSH
35431: LD_VAR 0 2
35435: ARRAY
35436: PUSH
35437: LD_INT 1
35439: ARRAY
35440: PUSH
35441: LD_VAR 0 3
35445: EQUAL
35446: IFFALSE 35474
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35448: LD_VAR 0 3
35452: PPUSH
35453: LD_EXP 50
35457: PUSH
35458: LD_VAR 0 2
35462: ARRAY
35463: PUSH
35464: LD_INT 2
35466: ARRAY
35467: PPUSH
35468: CALL 8687 0 2
// break ;
35472: GO 35476
// end ;
35474: GO 35423
35476: POP
35477: POP
// end else
35478: GO 36067
// if MCF_Get ( side , [ f_constructed ] ) then
35480: LD_VAR 0 3
35484: PPUSH
35485: LD_INT 57
35487: PUSH
35488: EMPTY
35489: LIST
35490: PPUSH
35491: CALL 11587 0 2
35495: IFFALSE 35528
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35497: LD_VAR 0 3
35501: PPUSH
35502: LD_VAR 0 3
35506: PPUSH
35507: LD_INT 57
35509: PUSH
35510: EMPTY
35511: LIST
35512: PPUSH
35513: CALL 11587 0 2
35517: PUSH
35518: LD_INT 1
35520: ARRAY
35521: PPUSH
35522: CALL 10931 0 2
35526: GO 36067
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PPUSH
35538: CALL 42921 0 2
35542: PUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 345
35552: NOT
35553: AND
35554: PUSH
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL 24942 0 1
35564: PUSH
35565: LD_INT 0
35567: EQUAL
35568: AND
35569: IFFALSE 35968
// begin for i = 1 to MREG_ToBuild do
35571: LD_ADDR_VAR 0 2
35575: PUSH
35576: DOUBLE
35577: LD_INT 1
35579: DEC
35580: ST_TO_ADDR
35581: LD_EXP 48
35585: PUSH
35586: FOR_TO
35587: IFFALSE 35964
// if MREG_ToBuild [ i ] [ 1 ] = side then
35589: LD_EXP 48
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: PUSH
35600: LD_INT 1
35602: ARRAY
35603: PUSH
35604: LD_VAR 0 3
35608: EQUAL
35609: IFFALSE 35962
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35611: LD_OWVAR 84
35615: PUSH
35616: LD_EXP 48
35620: PUSH
35621: LD_VAR 0 2
35625: ARRAY
35626: PUSH
35627: LD_INT 3
35629: ARRAY
35630: PUSH
35631: LD_INT 1
35633: ARRAY
35634: PPUSH
35635: LD_EXP 48
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 3
35648: ARRAY
35649: PUSH
35650: LD_INT 2
35652: ARRAY
35653: PPUSH
35654: CALL_OW 351
35658: AND
35659: IFFALSE 35703
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35661: LD_EXP 48
35665: PUSH
35666: LD_VAR 0 2
35670: ARRAY
35671: PUSH
35672: LD_INT 3
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PPUSH
35680: LD_EXP 48
35684: PUSH
35685: LD_VAR 0 2
35689: ARRAY
35690: PUSH
35691: LD_INT 3
35693: ARRAY
35694: PUSH
35695: LD_INT 2
35697: ARRAY
35698: PPUSH
35699: CALL 22735 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35703: LD_EXP 48
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_INT 2
35716: ARRAY
35717: PUSH
35718: LD_INT 0
35720: EQUAL
35721: IFFALSE 35791
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35723: LD_VAR 0 3
35727: PPUSH
35728: LD_EXP 48
35732: PUSH
35733: LD_VAR 0 2
35737: ARRAY
35738: PUSH
35739: LD_INT 3
35741: ARRAY
35742: PUSH
35743: LD_INT 1
35745: ARRAY
35746: PPUSH
35747: LD_EXP 48
35751: PUSH
35752: LD_VAR 0 2
35756: ARRAY
35757: PUSH
35758: LD_INT 3
35760: ARRAY
35761: PUSH
35762: LD_INT 2
35764: ARRAY
35765: PPUSH
35766: LD_EXP 48
35770: PUSH
35771: LD_VAR 0 2
35775: ARRAY
35776: PUSH
35777: LD_INT 3
35779: ARRAY
35780: PUSH
35781: LD_INT 3
35783: ARRAY
35784: PPUSH
35785: CALL 8523 0 4
35789: GO 35960
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35791: LD_EXP 48
35795: PUSH
35796: LD_VAR 0 2
35800: ARRAY
35801: PUSH
35802: LD_INT 2
35804: ARRAY
35805: PUSH
35806: LD_INT 6
35808: EQUAL
35809: IFFALSE 35879
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35811: LD_VAR 0 3
35815: PPUSH
35816: LD_EXP 48
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: PUSH
35827: LD_INT 3
35829: ARRAY
35830: PUSH
35831: LD_INT 1
35833: ARRAY
35834: PPUSH
35835: LD_EXP 48
35839: PUSH
35840: LD_VAR 0 2
35844: ARRAY
35845: PUSH
35846: LD_INT 3
35848: ARRAY
35849: PUSH
35850: LD_INT 2
35852: ARRAY
35853: PPUSH
35854: LD_EXP 48
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PUSH
35865: LD_INT 3
35867: ARRAY
35868: PUSH
35869: LD_INT 3
35871: ARRAY
35872: PPUSH
35873: CALL 8652 0 4
35877: GO 35960
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35879: LD_VAR 0 3
35883: PPUSH
35884: LD_EXP 48
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: PUSH
35895: LD_INT 2
35897: ARRAY
35898: PPUSH
35899: LD_EXP 48
35903: PUSH
35904: LD_VAR 0 2
35908: ARRAY
35909: PUSH
35910: LD_INT 3
35912: ARRAY
35913: PUSH
35914: LD_INT 1
35916: ARRAY
35917: PPUSH
35918: LD_EXP 48
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: PUSH
35929: LD_INT 3
35931: ARRAY
35932: PUSH
35933: LD_INT 2
35935: ARRAY
35936: PPUSH
35937: LD_EXP 48
35941: PUSH
35942: LD_VAR 0 2
35946: ARRAY
35947: PUSH
35948: LD_INT 3
35950: ARRAY
35951: PUSH
35952: LD_INT 3
35954: ARRAY
35955: PPUSH
35956: CALL 10156 0 5
// break ;
35960: GO 35964
// end ;
35962: GO 35586
35964: POP
35965: POP
// end else
35966: GO 36067
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
35968: LD_VAR 0 3
35972: PPUSH
35973: LD_EXP 54
35977: PPUSH
35978: CALL 42921 0 2
35982: PUSH
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL 24942 0 1
35992: PUSH
35993: LD_INT 0
35995: EQUAL
35996: AND
35997: IFFALSE 36067
// begin for i = 1 to MREG_ToDismantle do
35999: LD_ADDR_VAR 0 2
36003: PUSH
36004: DOUBLE
36005: LD_INT 1
36007: DEC
36008: ST_TO_ADDR
36009: LD_EXP 54
36013: PUSH
36014: FOR_TO
36015: IFFALSE 36065
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36017: LD_EXP 54
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 1
36030: ARRAY
36031: PUSH
36032: LD_VAR 0 3
36036: EQUAL
36037: IFFALSE 36063
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36039: LD_VAR 0 3
36043: PPUSH
36044: LD_EXP 54
36048: PUSH
36049: LD_VAR 0 2
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: CALL 10822 0 2
// end ;
36063: GO 36014
36065: POP
36066: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36067: LD_VAR 0 3
36071: PPUSH
36072: LD_INT 30
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PPUSH
36082: CALL 11587 0 2
36086: PUSH
36087: LD_VAR 0 3
36091: PPUSH
36092: CALL 24942 0 1
36096: PUSH
36097: LD_INT 0
36099: EQUAL
36100: AND
36101: IFFALSE 36112
// MCT_CollectCrates ( side ) ;
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL 23881 0 1
// end ;
36112: GO 34113
36114: POP
36115: POP
// end ;
36116: LD_VAR 0 1
36120: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36121: LD_INT 0
36123: PPUSH
36124: PPUSH
36125: PPUSH
36126: PPUSH
36127: PPUSH
36128: PPUSH
36129: PPUSH
36130: PPUSH
36131: PPUSH
36132: PPUSH
36133: PPUSH
36134: PPUSH
36135: PPUSH
36136: PPUSH
36137: PPUSH
// all := MCF_All ( side , [ ] ) ;
36138: LD_ADDR_VAR 0 17
36142: PUSH
36143: LD_VAR 0 1
36147: PPUSH
36148: EMPTY
36149: PPUSH
36150: CALL 11722 0 2
36154: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36155: LD_ADDR_VAR 0 13
36159: PUSH
36160: LD_VAR 0 1
36164: PPUSH
36165: LD_INT 1
36167: PPUSH
36168: EMPTY
36169: PPUSH
36170: CALL 11670 0 3
36174: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36175: LD_ADDR_VAR 0 14
36179: PUSH
36180: LD_VAR 0 1
36184: PPUSH
36185: LD_INT 2
36187: PPUSH
36188: EMPTY
36189: PPUSH
36190: CALL 11670 0 3
36194: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36195: LD_ADDR_VAR 0 15
36199: PUSH
36200: LD_VAR 0 1
36204: PPUSH
36205: LD_INT 3
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL 11670 0 3
36214: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36215: LD_ADDR_VAR 0 16
36219: PUSH
36220: LD_VAR 0 1
36224: PPUSH
36225: LD_INT 4
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11670 0 3
36234: ST_TO_ADDR
// if mech then
36235: LD_VAR 0 15
36239: IFFALSE 36256
// mech := MCF_SortListDesc ( mech ) ;
36241: LD_ADDR_VAR 0 15
36245: PUSH
36246: LD_VAR 0 15
36250: PPUSH
36251: CALL 12836 0 1
36255: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36256: LD_EXP 58
36260: PUSH
36261: LD_VAR 0 1
36265: ARRAY
36266: PUSH
36267: LD_STRING 
36269: EQUAL
36270: NOT
36271: IFFALSE 36327
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36273: LD_EXP 58
36277: PUSH
36278: LD_VAR 0 1
36282: ARRAY
36283: PUSH
36284: LD_INT 1
36286: ARRAY
36287: PPUSH
36288: CALL_OW 257
36292: PUSH
36293: LD_INT 1
36295: EQUAL
36296: IFFALSE 36325
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_STRING ToArm
36305: PPUSH
36306: LD_EXP 58
36310: PUSH
36311: LD_VAR 0 1
36315: ARRAY
36316: PUSH
36317: LD_INT 1
36319: ARRAY
36320: PPUSH
36321: CALL 14466 0 3
// end else
36325: GO 36353
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36327: LD_ADDR_EXP 58
36331: PUSH
36332: LD_EXP 58
36336: PPUSH
36337: LD_VAR 0 1
36341: PPUSH
36342: LD_INT 1
36344: PPUSH
36345: LD_INT 0
36347: PPUSH
36348: CALL 31052 0 4
36352: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36353: LD_EXP 59
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_STRING 
36366: EQUAL
36367: NOT
36368: IFFALSE 36424
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36370: LD_EXP 59
36374: PUSH
36375: LD_VAR 0 1
36379: ARRAY
36380: PUSH
36381: LD_INT 1
36383: ARRAY
36384: PPUSH
36385: CALL_OW 257
36389: PUSH
36390: LD_INT 2
36392: EQUAL
36393: IFFALSE 36422
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_STRING ToDep
36402: PPUSH
36403: LD_EXP 59
36407: PUSH
36408: LD_VAR 0 1
36412: ARRAY
36413: PUSH
36414: LD_INT 1
36416: ARRAY
36417: PPUSH
36418: CALL 14466 0 3
// end else
36422: GO 36450
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36424: LD_ADDR_EXP 59
36428: PUSH
36429: LD_EXP 59
36433: PPUSH
36434: LD_VAR 0 1
36438: PPUSH
36439: LD_INT 1
36441: PPUSH
36442: LD_INT 0
36444: PPUSH
36445: CALL 31052 0 4
36449: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_STRING 
36463: EQUAL
36464: NOT
36465: IFFALSE 36521
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36467: LD_EXP 57
36471: PUSH
36472: LD_VAR 0 1
36476: ARRAY
36477: PUSH
36478: LD_INT 1
36480: ARRAY
36481: PPUSH
36482: CALL_OW 257
36486: PUSH
36487: LD_INT 3
36489: EQUAL
36490: IFFALSE 36519
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36492: LD_VAR 0 1
36496: PPUSH
36497: LD_STRING ToFac
36499: PPUSH
36500: LD_EXP 57
36504: PUSH
36505: LD_VAR 0 1
36509: ARRAY
36510: PUSH
36511: LD_INT 1
36513: ARRAY
36514: PPUSH
36515: CALL 14466 0 3
// end else
36519: GO 36547
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36521: LD_ADDR_EXP 57
36525: PUSH
36526: LD_EXP 57
36530: PPUSH
36531: LD_VAR 0 1
36535: PPUSH
36536: LD_INT 1
36538: PPUSH
36539: LD_INT 0
36541: PPUSH
36542: CALL 31052 0 4
36546: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36547: LD_EXP 56
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_STRING 
36560: EQUAL
36561: NOT
36562: IFFALSE 36618
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36564: LD_EXP 56
36568: PUSH
36569: LD_VAR 0 1
36573: ARRAY
36574: PUSH
36575: LD_INT 1
36577: ARRAY
36578: PPUSH
36579: CALL_OW 257
36583: PUSH
36584: LD_INT 4
36586: EQUAL
36587: IFFALSE 36616
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36589: LD_VAR 0 1
36593: PPUSH
36594: LD_STRING ToLab
36596: PPUSH
36597: LD_EXP 56
36601: PUSH
36602: LD_VAR 0 1
36606: ARRAY
36607: PUSH
36608: LD_INT 1
36610: ARRAY
36611: PPUSH
36612: CALL 14466 0 3
// end else
36616: GO 36644
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36618: LD_ADDR_EXP 56
36622: PUSH
36623: LD_EXP 56
36627: PPUSH
36628: LD_VAR 0 1
36632: PPUSH
36633: LD_INT 1
36635: PPUSH
36636: LD_INT 0
36638: PPUSH
36639: CALL 31052 0 4
36643: ST_TO_ADDR
// if mode = 0 then
36644: LD_VAR 0 2
36648: PUSH
36649: LD_INT 0
36651: EQUAL
36652: IFFALSE 38490
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36654: LD_VAR 0 1
36658: PPUSH
36659: LD_INT 30
36661: PUSH
36662: LD_INT 1
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PPUSH
36669: CALL 11587 0 2
36673: PUSH
36674: LD_VAR 0 1
36678: PPUSH
36679: LD_INT 21
36681: PUSH
36682: LD_INT 3
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PPUSH
36689: CALL 11587 0 2
36693: PUSH
36694: LD_INT 1
36696: EQUAL
36697: AND
36698: IFFALSE 36763
// begin if all then
36700: LD_VAR 0 17
36704: IFFALSE 36761
// for i in ( all diff eng ) do
36706: LD_ADDR_VAR 0 4
36710: PUSH
36711: LD_VAR 0 17
36715: PUSH
36716: LD_VAR 0 14
36720: DIFF
36721: PUSH
36722: FOR_IN
36723: IFFALSE 36759
// if GetTag ( i ) = 0 then
36725: LD_VAR 0 4
36729: PPUSH
36730: CALL_OW 110
36734: PUSH
36735: LD_INT 0
36737: EQUAL
36738: IFFALSE 36757
// MCH_ChangeClass ( side , i , 2 ) ;
36740: LD_VAR 0 1
36744: PPUSH
36745: LD_VAR 0 4
36749: PPUSH
36750: LD_INT 2
36752: PPUSH
36753: CALL 16494 0 3
36757: GO 36722
36759: POP
36760: POP
// end else
36761: GO 37082
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36763: LD_VAR 0 13
36767: PUSH
36768: LD_EXP 58
36772: PUSH
36773: LD_VAR 0 1
36777: ARRAY
36778: PLUS
36779: PUSH
36780: LD_INT 22
36782: PUSH
36783: LD_VAR 0 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 30
36794: PUSH
36795: LD_INT 32
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PPUSH
36806: CALL_OW 69
36810: LESS
36811: IFFALSE 36836
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36813: LD_VAR 0 1
36817: PPUSH
36818: LD_VAR 0 14
36822: PUSH
36823: LD_INT 1
36825: ARRAY
36826: PPUSH
36827: LD_INT 1
36829: PPUSH
36830: CALL 16494 0 3
// end else
36834: GO 37082
// if sci < 6 and MCF_Lab ( side ) then
36836: LD_VAR 0 16
36840: PUSH
36841: LD_INT 6
36843: LESS
36844: PUSH
36845: LD_VAR 0 1
36849: PPUSH
36850: CALL 11626 0 1
36854: AND
36855: IFFALSE 36960
// begin if MREG_ToBunker [ side ] then
36857: LD_EXP 70
36861: PUSH
36862: LD_VAR 0 1
36866: ARRAY
36867: IFFALSE 36893
// tmp := sol diff MREG_ToBunker [ side ] else
36869: LD_ADDR_VAR 0 12
36873: PUSH
36874: LD_VAR 0 13
36878: PUSH
36879: LD_EXP 70
36883: PUSH
36884: LD_VAR 0 1
36888: ARRAY
36889: DIFF
36890: ST_TO_ADDR
36891: GO 36903
// tmp := sol ;
36893: LD_ADDR_VAR 0 12
36897: PUSH
36898: LD_VAR 0 13
36902: ST_TO_ADDR
// if tmp then
36903: LD_VAR 0 12
36907: IFFALSE 36958
// for i in tmp do
36909: LD_ADDR_VAR 0 4
36913: PUSH
36914: LD_VAR 0 12
36918: PUSH
36919: FOR_IN
36920: IFFALSE 36956
// if GetTag ( i ) = 0 then
36922: LD_VAR 0 4
36926: PPUSH
36927: CALL_OW 110
36931: PUSH
36932: LD_INT 0
36934: EQUAL
36935: IFFALSE 36954
// MCH_ChangeClass ( side , i , 4 ) ;
36937: LD_VAR 0 1
36941: PPUSH
36942: LD_VAR 0 4
36946: PPUSH
36947: LD_INT 4
36949: PPUSH
36950: CALL 16494 0 3
36954: GO 36919
36956: POP
36957: POP
// end else
36958: GO 37082
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
36960: LD_VAR 0 1
36964: PPUSH
36965: LD_INT 30
36967: PUSH
36968: LD_INT 1
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL 11587 0 2
36979: IFFALSE 37082
// begin if MREG_ToBunker [ side ] then
36981: LD_EXP 70
36985: PUSH
36986: LD_VAR 0 1
36990: ARRAY
36991: IFFALSE 37017
// tmp := sol diff MREG_ToBunker [ side ] else
36993: LD_ADDR_VAR 0 12
36997: PUSH
36998: LD_VAR 0 13
37002: PUSH
37003: LD_EXP 70
37007: PUSH
37008: LD_VAR 0 1
37012: ARRAY
37013: DIFF
37014: ST_TO_ADDR
37015: GO 37027
// tmp := sol ;
37017: LD_ADDR_VAR 0 12
37021: PUSH
37022: LD_VAR 0 13
37026: ST_TO_ADDR
// if tmp then
37027: LD_VAR 0 12
37031: IFFALSE 37082
// for i in tmp do
37033: LD_ADDR_VAR 0 4
37037: PUSH
37038: LD_VAR 0 12
37042: PUSH
37043: FOR_IN
37044: IFFALSE 37080
// if GetTag ( i ) = 0 then
37046: LD_VAR 0 4
37050: PPUSH
37051: CALL_OW 110
37055: PUSH
37056: LD_INT 0
37058: EQUAL
37059: IFFALSE 37078
// MCH_ChangeClass ( side , i , 2 ) ;
37061: LD_VAR 0 1
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: LD_INT 2
37073: PPUSH
37074: CALL 16494 0 3
37078: GO 37043
37080: POP
37081: POP
// end ; if MCF_Lab ( side ) then
37082: LD_VAR 0 1
37086: PPUSH
37087: CALL 11626 0 1
37091: IFFALSE 37631
// begin if MCL_GetTechList ( side ) then
37093: LD_VAR 0 1
37097: PPUSH
37098: CALL 17970 0 1
37102: IFFALSE 37228
// begin if MREG_ToLab [ side ] then
37104: LD_EXP 56
37108: PUSH
37109: LD_VAR 0 1
37113: ARRAY
37114: IFFALSE 37134
// k := MREG_ToLab [ side ] else
37116: LD_ADDR_VAR 0 8
37120: PUSH
37121: LD_EXP 56
37125: PUSH
37126: LD_VAR 0 1
37130: ARRAY
37131: ST_TO_ADDR
37132: GO 37142
// k := 0 ;
37134: LD_ADDR_VAR 0 8
37138: PUSH
37139: LD_INT 0
37141: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37142: LD_VAR 0 16
37146: PUSH
37147: LD_VAR 0 8
37151: PLUS
37152: PUSH
37153: LD_INT 6
37155: LESSEQUAL
37156: PUSH
37157: LD_VAR 0 17
37161: PUSH
37162: LD_INT 6
37164: GREATER
37165: AND
37166: IFFALSE 37182
// MCH_TrainScientist ( side , 1 ) else
37168: LD_VAR 0 1
37172: PPUSH
37173: LD_INT 1
37175: PPUSH
37176: CALL 16046 0 2
37180: GO 37226
// if all < 6 then
37182: LD_VAR 0 17
37186: PUSH
37187: LD_INT 6
37189: LESS
37190: IFFALSE 37226
// if sci + k < all / 2 then
37192: LD_VAR 0 16
37196: PUSH
37197: LD_VAR 0 8
37201: PLUS
37202: PUSH
37203: LD_VAR 0 17
37207: PUSH
37208: LD_INT 2
37210: DIVREAL
37211: LESS
37212: IFFALSE 37226
// MCH_TrainScientist ( side , 1 ) ;
37214: LD_VAR 0 1
37218: PPUSH
37219: LD_INT 1
37221: PPUSH
37222: CALL 16046 0 2
// end else
37226: GO 37304
// begin if sci > 2 then
37228: LD_VAR 0 16
37232: PUSH
37233: LD_INT 2
37235: GREATER
37236: IFFALSE 37304
// for i = sci downto 2 do
37238: LD_ADDR_VAR 0 4
37242: PUSH
37243: DOUBLE
37244: LD_VAR 0 16
37248: INC
37249: ST_TO_ADDR
37250: LD_INT 2
37252: PUSH
37253: FOR_DOWNTO
37254: IFFALSE 37302
// if GetTag ( sci [ i ] ) = 0 then
37256: LD_VAR 0 16
37260: PUSH
37261: LD_VAR 0 4
37265: ARRAY
37266: PPUSH
37267: CALL_OW 110
37271: PUSH
37272: LD_INT 0
37274: EQUAL
37275: IFFALSE 37300
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37277: LD_VAR 0 1
37281: PPUSH
37282: LD_VAR 0 16
37286: PUSH
37287: LD_VAR 0 4
37291: ARRAY
37292: PPUSH
37293: LD_INT 2
37295: PPUSH
37296: CALL 16494 0 3
37300: GO 37253
37302: POP
37303: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37304: LD_VAR 0 1
37308: PPUSH
37309: CALL 17970 0 1
37313: PUSH
37314: LD_VAR 0 1
37318: PPUSH
37319: CALL 11626 0 1
37323: AND
37324: PUSH
37325: LD_EXP 37
37329: PUSH
37330: LD_VAR 0 1
37334: ARRAY
37335: NOT
37336: AND
37337: IFFALSE 37631
// begin for j = 1 to MCF_Lab ( side ) do
37339: LD_ADDR_VAR 0 5
37343: PUSH
37344: DOUBLE
37345: LD_INT 1
37347: DEC
37348: ST_TO_ADDR
37349: LD_VAR 0 1
37353: PPUSH
37354: CALL 11626 0 1
37358: PUSH
37359: FOR_TO
37360: IFFALSE 37420
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37362: LD_VAR 0 1
37366: PPUSH
37367: CALL 11626 0 1
37371: PUSH
37372: LD_VAR 0 5
37376: ARRAY
37377: PPUSH
37378: CALL_OW 461
37382: PUSH
37383: LD_INT 3
37385: PUSH
37386: LD_INT 6
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: IN
37393: IFFALSE 37418
// begin b := MCF_Lab ( side ) [ j ] ;
37395: LD_ADDR_VAR 0 11
37399: PUSH
37400: LD_VAR 0 1
37404: PPUSH
37405: CALL 11626 0 1
37409: PUSH
37410: LD_VAR 0 5
37414: ARRAY
37415: ST_TO_ADDR
// break ;
37416: GO 37420
// end ;
37418: GO 37359
37420: POP
37421: POP
// if MCF_Class ( side , 4 , [ ] ) then
37422: LD_VAR 0 1
37426: PPUSH
37427: LD_INT 4
37429: PPUSH
37430: EMPTY
37431: PPUSH
37432: CALL 11670 0 3
37436: IFFALSE 37631
// for j in MCF_Class ( side , 4 , [ ] ) do
37438: LD_ADDR_VAR 0 5
37442: PUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: LD_INT 4
37450: PPUSH
37451: EMPTY
37452: PPUSH
37453: CALL 11670 0 3
37457: PUSH
37458: FOR_IN
37459: IFFALSE 37629
// begin if GetTag ( j ) = 0 then
37461: LD_VAR 0 5
37465: PPUSH
37466: CALL_OW 110
37470: PUSH
37471: LD_INT 0
37473: EQUAL
37474: IFFALSE 37565
// begin if IsInUnit ( j ) and b then
37476: LD_VAR 0 5
37480: PPUSH
37481: CALL_OW 310
37485: PUSH
37486: LD_VAR 0 11
37490: AND
37491: IFFALSE 37539
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37493: LD_VAR 0 5
37497: PPUSH
37498: CALL_OW 310
37502: PPUSH
37503: CALL_OW 461
37507: PUSH
37508: LD_INT 2
37510: EQUAL
37511: PUSH
37512: LD_VAR 0 5
37516: PPUSH
37517: CALL_OW 310
37521: PUSH
37522: LD_VAR 0 11
37526: NONEQUAL
37527: AND
37528: IFFALSE 37539
// ComExitBuilding ( j ) ;
37530: LD_VAR 0 5
37534: PPUSH
37535: CALL_OW 122
// if not IsInUnit ( j ) then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 310
37548: NOT
37549: IFFALSE 37565
// ComEnterUnit ( j , b ) ;
37551: LD_VAR 0 5
37555: PPUSH
37556: LD_VAR 0 11
37560: PPUSH
37561: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37565: LD_INT 1
37567: PPUSH
37568: LD_VAR 0 5
37572: PPUSH
37573: CALL_OW 255
37577: PPUSH
37578: CALL_OW 321
37582: PUSH
37583: LD_INT 2
37585: EQUAL
37586: PUSH
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 255
37596: PPUSH
37597: CALL 24942 0 1
37601: PUSH
37602: LD_INT 0
37604: EQUAL
37605: AND
37606: IFFALSE 37627
// MCN_Tame ( GetSide ( j ) , j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 255
37617: PPUSH
37618: LD_VAR 0 5
37622: PPUSH
37623: CALL 18489 0 2
// end ;
37627: GO 37458
37629: POP
37630: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37631: LD_VAR 0 1
37635: PPUSH
37636: LD_INT 30
37638: PUSH
37639: LD_INT 3
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PPUSH
37646: CALL 11587 0 2
37650: IFFALSE 37909
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37652: LD_ADDR_VAR 0 11
37656: PUSH
37657: LD_VAR 0 1
37661: PPUSH
37662: LD_INT 30
37664: PUSH
37665: LD_INT 3
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PPUSH
37672: CALL 11587 0 2
37676: PUSH
37677: LD_INT 1
37679: ARRAY
37680: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37681: LD_ADDR_VAR 0 12
37685: PUSH
37686: LD_VAR 0 1
37690: PPUSH
37691: LD_INT 0
37693: PPUSH
37694: LD_INT 25
37696: PUSH
37697: LD_INT 3
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PPUSH
37704: CALL 12290 0 3
37708: ST_TO_ADDR
// for i = 1 to tmp do
37709: LD_ADDR_VAR 0 4
37713: PUSH
37714: DOUBLE
37715: LD_INT 1
37717: DEC
37718: ST_TO_ADDR
37719: LD_VAR 0 12
37723: PUSH
37724: FOR_TO
37725: IFFALSE 37785
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37727: LD_VAR 0 12
37731: PUSH
37732: LD_VAR 0 4
37736: ARRAY
37737: PPUSH
37738: CALL_OW 310
37742: NOT
37743: PUSH
37744: LD_VAR 0 12
37748: PUSH
37749: LD_VAR 0 4
37753: ARRAY
37754: PPUSH
37755: CALL_OW 314
37759: NOT
37760: AND
37761: IFFALSE 37783
// ComEnterUnit ( tmp [ i ] , b ) ;
37763: LD_VAR 0 12
37767: PUSH
37768: LD_VAR 0 4
37772: ARRAY
37773: PPUSH
37774: LD_VAR 0 11
37778: PPUSH
37779: CALL_OW 120
37783: GO 37724
37785: POP
37786: POP
// if MREG_ToFac [ side ] then
37787: LD_EXP 57
37791: PUSH
37792: LD_VAR 0 1
37796: ARRAY
37797: IFFALSE 37817
// k := MREG_ToFac [ side ] else
37799: LD_ADDR_VAR 0 8
37803: PUSH
37804: LD_EXP 57
37808: PUSH
37809: LD_VAR 0 1
37813: ARRAY
37814: ST_TO_ADDR
37815: GO 37825
// k := 0 ;
37817: LD_ADDR_VAR 0 8
37821: PUSH
37822: LD_INT 0
37824: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37825: LD_VAR 0 15
37829: PUSH
37830: LD_VAR 0 8
37834: PLUS
37835: PUSH
37836: LD_INT 6
37838: LESSEQUAL
37839: PUSH
37840: LD_VAR 0 17
37844: PUSH
37845: LD_INT 6
37847: GREATER
37848: AND
37849: IFFALSE 37865
// MCH_TrainMechanic ( side , 1 ) else
37851: LD_VAR 0 1
37855: PPUSH
37856: LD_INT 1
37858: PPUSH
37859: CALL 15788 0 2
37863: GO 37909
// if all < 6 then
37865: LD_VAR 0 17
37869: PUSH
37870: LD_INT 6
37872: LESS
37873: IFFALSE 37909
// if mech + k < all / 2 then
37875: LD_VAR 0 15
37879: PUSH
37880: LD_VAR 0 8
37884: PLUS
37885: PUSH
37886: LD_VAR 0 17
37890: PUSH
37891: LD_INT 2
37893: DIVREAL
37894: LESS
37895: IFFALSE 37909
// MCH_TrainMechanic ( side , 1 ) ;
37897: LD_VAR 0 1
37901: PPUSH
37902: LD_INT 1
37904: PPUSH
37905: CALL 15788 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37909: LD_ADDR_VAR 0 10
37913: PUSH
37914: LD_VAR 0 1
37918: PPUSH
37919: LD_INT 30
37921: PUSH
37922: LD_INT 36
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PPUSH
37929: CALL 11587 0 2
37933: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
37934: LD_VAR 0 10
37938: PUSH
37939: LD_VAR 0 15
37943: AND
37944: PUSH
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 3
37952: PPUSH
37953: EMPTY
37954: PPUSH
37955: CALL 11670 0 3
37959: AND
37960: IFFALSE 38118
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
37962: LD_VAR 0 1
37966: PPUSH
37967: LD_INT 9
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL 12290 0 3
37976: PUSH
37977: LD_INT 3
37979: LESS
37980: IFFALSE 38118
// begin if mech < 3 then
37982: LD_VAR 0 15
37986: PUSH
37987: LD_INT 3
37989: LESS
37990: IFFALSE 38004
// k := mech else
37992: LD_ADDR_VAR 0 8
37996: PUSH
37997: LD_VAR 0 15
38001: ST_TO_ADDR
38002: GO 38012
// k := 3 ;
38004: LD_ADDR_VAR 0 8
38008: PUSH
38009: LD_INT 3
38011: ST_TO_ADDR
// for j = 1 to k do
38012: LD_ADDR_VAR 0 5
38016: PUSH
38017: DOUBLE
38018: LD_INT 1
38020: DEC
38021: ST_TO_ADDR
38022: LD_VAR 0 8
38026: PUSH
38027: FOR_TO
38028: IFFALSE 38086
// if GetClass ( mech [ j ] ) = 3 then
38030: LD_VAR 0 15
38034: PUSH
38035: LD_VAR 0 5
38039: ARRAY
38040: PPUSH
38041: CALL_OW 257
38045: PUSH
38046: LD_INT 3
38048: EQUAL
38049: IFFALSE 38084
// begin SetTag ( mech [ j ] , 9 ) ;
38051: LD_VAR 0 15
38055: PUSH
38056: LD_VAR 0 5
38060: ARRAY
38061: PPUSH
38062: LD_INT 9
38064: PPUSH
38065: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38069: LD_VAR 0 15
38073: PUSH
38074: LD_VAR 0 5
38078: ARRAY
38079: PPUSH
38080: CALL_OW 122
// end ;
38084: GO 38027
38086: POP
38087: POP
// if mech < 6 + k then
38088: LD_VAR 0 15
38092: PUSH
38093: LD_INT 6
38095: PUSH
38096: LD_VAR 0 8
38100: PLUS
38101: LESS
38102: IFFALSE 38118
// MCH_TrainMechanic ( side , k ) ;
38104: LD_VAR 0 1
38108: PPUSH
38109: LD_VAR 0 8
38113: PPUSH
38114: CALL 15788 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38118: LD_VAR 0 1
38122: PPUSH
38123: LD_INT 9
38125: PPUSH
38126: EMPTY
38127: PPUSH
38128: CALL 12290 0 3
38132: IFFALSE 38223
// for j in MCF_Tag ( side , 9 , [ ] ) do
38134: LD_ADDR_VAR 0 5
38138: PUSH
38139: LD_VAR 0 1
38143: PPUSH
38144: LD_INT 9
38146: PPUSH
38147: EMPTY
38148: PPUSH
38149: CALL 12290 0 3
38153: PUSH
38154: FOR_IN
38155: IFFALSE 38221
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38157: LD_VAR 0 5
38161: PPUSH
38162: CALL_OW 310
38166: NOT
38167: PUSH
38168: LD_VAR 0 5
38172: PPUSH
38173: CALL 94081 0 1
38177: NOT
38178: AND
38179: IFFALSE 38219
// if ct then
38181: LD_VAR 0 10
38185: IFFALSE 38207
// ComEnterUnit ( j , ct [ 1 ] ) else
38187: LD_VAR 0 5
38191: PPUSH
38192: LD_VAR 0 10
38196: PUSH
38197: LD_INT 1
38199: ARRAY
38200: PPUSH
38201: CALL_OW 120
38205: GO 38219
// SetTag ( j , 0 ) ;
38207: LD_VAR 0 5
38211: PPUSH
38212: LD_INT 0
38214: PPUSH
38215: CALL_OW 109
38219: GO 38154
38221: POP
38222: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38223: LD_INT 1
38225: PPUSH
38226: LD_VAR 0 1
38230: PPUSH
38231: CALL_OW 321
38235: PUSH
38236: LD_INT 2
38238: EQUAL
38239: PUSH
38240: LD_EXP 37
38244: PUSH
38245: LD_VAR 0 1
38249: ARRAY
38250: NOT
38251: AND
38252: PUSH
38253: LD_VAR 0 1
38257: PPUSH
38258: LD_INT 4
38260: PPUSH
38261: EMPTY
38262: PPUSH
38263: CALL 11670 0 3
38267: AND
38268: IFFALSE 38316
// for j in MCF_Class ( side , 4 , [ ] ) do
38270: LD_ADDR_VAR 0 5
38274: PUSH
38275: LD_VAR 0 1
38279: PPUSH
38280: LD_INT 4
38282: PPUSH
38283: EMPTY
38284: PPUSH
38285: CALL 11670 0 3
38289: PUSH
38290: FOR_IN
38291: IFFALSE 38314
// MCN_Tame ( GetSide ( j ) , j ) ;
38293: LD_VAR 0 5
38297: PPUSH
38298: CALL_OW 255
38302: PPUSH
38303: LD_VAR 0 5
38307: PPUSH
38308: CALL 18489 0 2
38312: GO 38290
38314: POP
38315: POP
// if MREG_DefVeh [ side ] then
38316: LD_EXP 69
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: IFFALSE 38490
// begin for i in MREG_DefVeh [ side ] do
38328: LD_ADDR_VAR 0 4
38332: PUSH
38333: LD_EXP 69
38337: PUSH
38338: LD_VAR 0 1
38342: ARRAY
38343: PUSH
38344: FOR_IN
38345: IFFALSE 38398
// begin SetTag ( i , 0 ) ;
38347: LD_VAR 0 4
38351: PPUSH
38352: LD_INT 0
38354: PPUSH
38355: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38359: LD_VAR 0 4
38363: PPUSH
38364: LD_EXP 66
38368: PUSH
38369: LD_VAR 0 1
38373: ARRAY
38374: PPUSH
38375: CALL_OW 308
38379: NOT
38380: IFFALSE 38396
// MCV_Parking ( side , i ) ;
38382: LD_VAR 0 1
38386: PPUSH
38387: LD_VAR 0 4
38391: PPUSH
38392: CALL 25677 0 2
// end ;
38396: GO 38344
38398: POP
38399: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38400: LD_VAR 0 1
38404: PPUSH
38405: LD_INT 36
38407: PPUSH
38408: EMPTY
38409: PPUSH
38410: CALL 12290 0 3
38414: IFFALSE 38455
// for i in MCF_Tag ( side , 36 , [ ] ) do
38416: LD_ADDR_VAR 0 4
38420: PUSH
38421: LD_VAR 0 1
38425: PPUSH
38426: LD_INT 36
38428: PPUSH
38429: EMPTY
38430: PPUSH
38431: CALL 12290 0 3
38435: PUSH
38436: FOR_IN
38437: IFFALSE 38453
// SetTag ( i , 0 ) ;
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_INT 0
38446: PPUSH
38447: CALL_OW 109
38451: GO 38436
38453: POP
38454: POP
// if MREG_DefMobActive [ side ] then
38455: LD_EXP 72
38459: PUSH
38460: LD_VAR 0 1
38464: ARRAY
38465: IFFALSE 38490
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38467: LD_ADDR_EXP 72
38471: PUSH
38472: LD_EXP 72
38476: PPUSH
38477: LD_VAR 0 1
38481: PPUSH
38482: LD_INT 0
38484: PPUSH
38485: CALL_OW 1
38489: ST_TO_ADDR
// end ; end ; if mode > 0 then
38490: LD_VAR 0 2
38494: PUSH
38495: LD_INT 0
38497: GREATER
38498: IFFALSE 40393
// begin if tick <= 15 15$00 then
38500: LD_OWVAR 1
38504: PUSH
38505: LD_INT 31500
38507: LESSEQUAL
38508: IFFALSE 38812
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38510: LD_VAR 0 13
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: CALL 24942 0 1
38524: PUSH
38525: LD_INT 4
38527: LESS
38528: AND
38529: IFFALSE 38640
// begin for i in sol do
38531: LD_ADDR_VAR 0 4
38535: PUSH
38536: LD_VAR 0 13
38540: PUSH
38541: FOR_IN
38542: IFFALSE 38638
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38544: LD_ADDR_VAR 0 8
38548: PUSH
38549: LD_VAR 0 1
38553: PPUSH
38554: CALL 24942 0 1
38558: PPUSH
38559: LD_VAR 0 4
38563: PPUSH
38564: CALL_OW 74
38568: ST_TO_ADDR
// if IsInUnit ( i ) then
38569: LD_VAR 0 4
38573: PPUSH
38574: CALL_OW 310
38578: IFFALSE 38589
// ComExitBuilding ( i ) ;
38580: LD_VAR 0 4
38584: PPUSH
38585: CALL_OW 122
// if not HasTask ( i ) and k then
38589: LD_VAR 0 4
38593: PPUSH
38594: CALL_OW 314
38598: NOT
38599: PUSH
38600: LD_VAR 0 8
38604: AND
38605: IFFALSE 38636
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38607: LD_VAR 0 4
38611: PPUSH
38612: LD_VAR 0 8
38616: PPUSH
38617: CALL_OW 250
38621: PPUSH
38622: LD_VAR 0 8
38626: PPUSH
38627: CALL_OW 251
38631: PPUSH
38632: CALL_OW 174
// end ;
38636: GO 38541
38638: POP
38639: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38640: LD_VAR 0 1
38644: PPUSH
38645: LD_INT 30
38647: PUSH
38648: LD_INT 5
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PPUSH
38655: CALL 11587 0 2
38659: IFFALSE 38810
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38661: LD_ADDR_VAR 0 11
38665: PUSH
38666: LD_VAR 0 1
38670: PPUSH
38671: LD_INT 30
38673: PUSH
38674: LD_INT 5
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PPUSH
38681: CALL 11587 0 2
38685: PUSH
38686: LD_INT 1
38688: ARRAY
38689: ST_TO_ADDR
// if mech then
38690: LD_VAR 0 15
38694: IFFALSE 38730
// for i in mech do
38696: LD_ADDR_VAR 0 4
38700: PUSH
38701: LD_VAR 0 15
38705: PUSH
38706: FOR_IN
38707: IFFALSE 38728
// MCH_ChangeClass ( side , i , 1 ) ;
38709: LD_VAR 0 1
38713: PPUSH
38714: LD_VAR 0 4
38718: PPUSH
38719: LD_INT 1
38721: PPUSH
38722: CALL 16494 0 3
38726: GO 38706
38728: POP
38729: POP
// if eng > 1 then
38730: LD_VAR 0 14
38734: PUSH
38735: LD_INT 1
38737: GREATER
38738: IFFALSE 38785
// for i = eng downto 2 do
38740: LD_ADDR_VAR 0 4
38744: PUSH
38745: DOUBLE
38746: LD_VAR 0 14
38750: INC
38751: ST_TO_ADDR
38752: LD_INT 2
38754: PUSH
38755: FOR_DOWNTO
38756: IFFALSE 38783
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38758: LD_VAR 0 1
38762: PPUSH
38763: LD_VAR 0 14
38767: PUSH
38768: LD_VAR 0 4
38772: ARRAY
38773: PPUSH
38774: LD_INT 1
38776: PPUSH
38777: CALL 16494 0 3
38781: GO 38755
38783: POP
38784: POP
// if UnitsInside ( b ) then
38785: LD_VAR 0 11
38789: PPUSH
38790: CALL_OW 313
38794: IFFALSE 38810
// ComExitBuilding ( UnitsInside ( b ) ) ;
38796: LD_VAR 0 11
38800: PPUSH
38801: CALL_OW 313
38805: PPUSH
38806: CALL_OW 122
// end ; end else
38810: GO 40393
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38812: LD_VAR 0 1
38816: PPUSH
38817: LD_INT 1
38819: PPUSH
38820: LD_EXP 67
38824: PUSH
38825: LD_VAR 0 1
38829: ARRAY
38830: PUSH
38831: LD_INT 1
38833: ARRAY
38834: PPUSH
38835: CALL 33665 0 3
38839: IFFALSE 38978
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38841: LD_ADDR_VAR 0 12
38845: PUSH
38846: LD_VAR 0 1
38850: PPUSH
38851: LD_INT 21
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PPUSH
38861: CALL 11587 0 2
38865: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38866: LD_ADDR_VAR 0 11
38870: PUSH
38871: LD_VAR 0 1
38875: PPUSH
38876: LD_INT 30
38878: PUSH
38879: LD_INT 1
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PPUSH
38886: CALL 11587 0 2
38890: ST_TO_ADDR
// if b then
38891: LD_VAR 0 11
38895: IFFALSE 38978
// for i in tmp do
38897: LD_ADDR_VAR 0 4
38901: PUSH
38902: LD_VAR 0 12
38906: PUSH
38907: FOR_IN
38908: IFFALSE 38976
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38910: LD_VAR 0 4
38914: PPUSH
38915: LD_EXP 67
38919: PUSH
38920: LD_VAR 0 1
38924: ARRAY
38925: PUSH
38926: LD_INT 1
38928: ARRAY
38929: PPUSH
38930: CALL_OW 308
38934: NOT
38935: IFFALSE 38974
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
38937: LD_VAR 0 4
38941: PPUSH
38942: LD_VAR 0 11
38946: PUSH
38947: LD_INT 1
38949: ARRAY
38950: PPUSH
38951: CALL_OW 250
38955: PPUSH
38956: LD_VAR 0 11
38960: PUSH
38961: LD_INT 1
38963: ARRAY
38964: PPUSH
38965: CALL_OW 251
38969: PPUSH
38970: CALL_OW 111
38974: GO 38907
38976: POP
38977: POP
// end ; if MREG_DefVeh [ side ] then
38978: LD_EXP 69
38982: PUSH
38983: LD_VAR 0 1
38987: ARRAY
38988: IFFALSE 39556
// begin tmp := [ ] ;
38990: LD_ADDR_VAR 0 12
38994: PUSH
38995: EMPTY
38996: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
38997: LD_EXP 72
39001: PUSH
39002: LD_VAR 0 1
39006: ARRAY
39007: PUSH
39008: LD_INT 0
39010: EQUAL
39011: IFFALSE 39151
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_VAR 0 1
39022: PPUSH
39023: LD_INT 0
39025: PPUSH
39026: LD_INT 25
39028: PUSH
39029: LD_INT 3
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PPUSH
39036: CALL 12290 0 3
39040: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39041: LD_VAR 0 8
39045: PUSH
39046: LD_EXP 69
39050: PUSH
39051: LD_VAR 0 1
39055: ARRAY
39056: GREATER
39057: IFFALSE 39118
// begin for i = 1 to MREG_DefVeh [ side ] do
39059: LD_ADDR_VAR 0 4
39063: PUSH
39064: DOUBLE
39065: LD_INT 1
39067: DEC
39068: ST_TO_ADDR
39069: LD_EXP 69
39073: PUSH
39074: LD_VAR 0 1
39078: ARRAY
39079: PUSH
39080: FOR_TO
39081: IFFALSE 39114
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39083: LD_ADDR_VAR 0 12
39087: PUSH
39088: LD_VAR 0 12
39092: PPUSH
39093: LD_INT 1
39095: PPUSH
39096: LD_VAR 0 8
39100: PUSH
39101: LD_VAR 0 4
39105: ARRAY
39106: PPUSH
39107: CALL_OW 2
39111: ST_TO_ADDR
39112: GO 39080
39114: POP
39115: POP
// end else
39116: GO 39128
// tmp := k ;
39118: LD_ADDR_VAR 0 12
39122: PUSH
39123: LD_VAR 0 8
39127: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39128: LD_ADDR_EXP 72
39132: PUSH
39133: LD_EXP 72
39137: PPUSH
39138: LD_VAR 0 1
39142: PPUSH
39143: LD_INT 1
39145: PPUSH
39146: CALL_OW 1
39150: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39151: LD_ADDR_VAR 0 4
39155: PUSH
39156: LD_EXP 69
39160: PUSH
39161: LD_VAR 0 1
39165: ARRAY
39166: PUSH
39167: FOR_IN
39168: IFFALSE 39554
// begin if not GetDriver ( i ) then
39170: LD_VAR 0 4
39174: PPUSH
39175: CALL 31695 0 1
39179: NOT
39180: IFFALSE 39255
// begin if tmp then
39182: LD_VAR 0 12
39186: IFFALSE 39253
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39188: LD_VAR 0 12
39192: PUSH
39193: LD_INT 1
39195: ARRAY
39196: PPUSH
39197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39201: LD_VAR 0 12
39205: PUSH
39206: LD_INT 1
39208: ARRAY
39209: PPUSH
39210: LD_VAR 0 4
39214: PPUSH
39215: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39219: LD_VAR 0 12
39223: PUSH
39224: LD_INT 1
39226: ARRAY
39227: PPUSH
39228: LD_INT 36
39230: PPUSH
39231: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39235: LD_ADDR_VAR 0 12
39239: PUSH
39240: LD_VAR 0 12
39244: PPUSH
39245: LD_INT 1
39247: PPUSH
39248: CALL_OW 3
39252: ST_TO_ADDR
// end ; end else
39253: GO 39552
// begin if GetTag ( i ) = 0 then
39255: LD_VAR 0 4
39259: PPUSH
39260: CALL_OW 110
39264: PUSH
39265: LD_INT 0
39267: EQUAL
39268: IFFALSE 39284
// SetTag ( i , 31 ) else
39270: LD_VAR 0 4
39274: PPUSH
39275: LD_INT 31
39277: PPUSH
39278: CALL_OW 109
39282: GO 39552
// if GetTag ( i ) = 31 then
39284: LD_VAR 0 4
39288: PPUSH
39289: CALL_OW 110
39293: PUSH
39294: LD_INT 31
39296: EQUAL
39297: IFFALSE 39552
// begin if GetFuel ( i ) < 20 then
39299: LD_VAR 0 4
39303: PPUSH
39304: CALL_OW 261
39308: PUSH
39309: LD_INT 20
39311: LESS
39312: IFFALSE 39337
// begin SetTag ( i , 21 ) ;
39314: LD_VAR 0 4
39318: PPUSH
39319: LD_INT 21
39321: PPUSH
39322: CALL_OW 109
// MCV_Refuel ( i ) ;
39326: LD_VAR 0 4
39330: PPUSH
39331: CALL 26214 0 1
// continue ;
39335: GO 39167
// end ; if GetLives ( i ) < 700 then
39337: LD_VAR 0 4
39341: PPUSH
39342: CALL_OW 256
39346: PUSH
39347: LD_INT 700
39349: LESS
39350: IFFALSE 39462
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39352: LD_VAR 0 4
39356: PPUSH
39357: LD_EXP 60
39361: PUSH
39362: LD_VAR 0 1
39366: ARRAY
39367: PPUSH
39368: CALL_OW 308
39372: NOT
39373: IFFALSE 39397
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39375: LD_VAR 0 4
39379: PPUSH
39380: LD_EXP 60
39384: PUSH
39385: LD_VAR 0 1
39389: ARRAY
39390: PPUSH
39391: CALL_OW 113
39395: GO 39460
// if GetDriver ( i ) then
39397: LD_VAR 0 4
39401: PPUSH
39402: CALL 31695 0 1
39406: IFFALSE 39460
// begin k := GetDriver ( i ) ;
39408: LD_ADDR_VAR 0 8
39412: PUSH
39413: LD_VAR 0 4
39417: PPUSH
39418: CALL 31695 0 1
39422: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39423: LD_VAR 0 8
39427: PPUSH
39428: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39432: LD_VAR 0 8
39436: PPUSH
39437: LD_VAR 0 4
39441: PPUSH
39442: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39446: LD_VAR 0 8
39450: PPUSH
39451: LD_VAR 0 4
39455: PPUSH
39456: CALL_OW 180
// end ; end else
39460: GO 39552
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39462: LD_ADDR_VAR 0 8
39466: PUSH
39467: LD_VAR 0 1
39471: PPUSH
39472: CALL 24942 0 1
39476: PPUSH
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL_OW 74
39486: ST_TO_ADDR
// if k then
39487: LD_VAR 0 8
39491: IFFALSE 39509
// ComAttackUnit ( i , k ) else
39493: LD_VAR 0 4
39497: PPUSH
39498: LD_VAR 0 8
39502: PPUSH
39503: CALL_OW 115
39507: GO 39552
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39509: LD_VAR 0 4
39513: PPUSH
39514: LD_EXP 60
39518: PUSH
39519: LD_VAR 0 1
39523: ARRAY
39524: PPUSH
39525: CALL_OW 308
39529: NOT
39530: IFFALSE 39552
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39532: LD_VAR 0 4
39536: PPUSH
39537: LD_EXP 60
39541: PUSH
39542: LD_VAR 0 1
39546: ARRAY
39547: PPUSH
39548: CALL_OW 113
// end ; end ; end ; end ;
39552: GO 39167
39554: POP
39555: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39556: LD_VAR 0 1
39560: PPUSH
39561: LD_INT 30
39563: PUSH
39564: LD_INT 5
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PPUSH
39571: CALL 11587 0 2
39575: IFFALSE 40393
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39577: LD_ADDR_VAR 0 11
39581: PUSH
39582: LD_VAR 0 1
39586: PPUSH
39587: LD_INT 30
39589: PUSH
39590: LD_INT 5
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PPUSH
39597: CALL 11587 0 2
39601: PUSH
39602: LD_INT 1
39604: ARRAY
39605: ST_TO_ADDR
// if eng > 1 then
39606: LD_VAR 0 14
39610: PUSH
39611: LD_INT 1
39613: GREATER
39614: IFFALSE 39661
// for i = eng downto 2 do
39616: LD_ADDR_VAR 0 4
39620: PUSH
39621: DOUBLE
39622: LD_VAR 0 14
39626: INC
39627: ST_TO_ADDR
39628: LD_INT 2
39630: PUSH
39631: FOR_DOWNTO
39632: IFFALSE 39659
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_VAR 0 14
39643: PUSH
39644: LD_VAR 0 4
39648: ARRAY
39649: PPUSH
39650: LD_INT 1
39652: PPUSH
39653: CALL 16494 0 3
39657: GO 39631
39659: POP
39660: POP
// if sci > 1 then
39661: LD_VAR 0 16
39665: PUSH
39666: LD_INT 1
39668: GREATER
39669: IFFALSE 39716
// for i = sci downto 2 do
39671: LD_ADDR_VAR 0 4
39675: PUSH
39676: DOUBLE
39677: LD_VAR 0 16
39681: INC
39682: ST_TO_ADDR
39683: LD_INT 2
39685: PUSH
39686: FOR_DOWNTO
39687: IFFALSE 39714
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39689: LD_VAR 0 1
39693: PPUSH
39694: LD_VAR 0 16
39698: PUSH
39699: LD_VAR 0 4
39703: ARRAY
39704: PPUSH
39705: LD_INT 1
39707: PPUSH
39708: CALL 16494 0 3
39712: GO 39686
39714: POP
39715: POP
// if sol then
39716: LD_VAR 0 13
39720: IFFALSE 40393
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39722: LD_VAR 0 13
39726: PUSH
39727: LD_EXP 70
39731: PUSH
39732: LD_VAR 0 1
39736: ARRAY
39737: DIFF
39738: PUSH
39739: LD_INT 22
39741: PUSH
39742: LD_VAR 0 1
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 58
39753: PUSH
39754: EMPTY
39755: LIST
39756: PUSH
39757: LD_INT 2
39759: PUSH
39760: LD_INT 30
39762: PUSH
39763: LD_INT 32
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 30
39772: PUSH
39773: LD_INT 31
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL_OW 69
39794: PUSH
39795: LD_INT 0
39797: EQUAL
39798: AND
39799: IFFALSE 40393
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39801: LD_ADDR_VAR 0 12
39805: PUSH
39806: LD_VAR 0 13
39810: PUSH
39811: LD_EXP 70
39815: PUSH
39816: LD_VAR 0 1
39820: ARRAY
39821: DIFF
39822: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39823: LD_VAR 0 1
39827: PPUSH
39828: LD_INT 30
39830: PUSH
39831: LD_INT 5
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PPUSH
39838: CALL 11587 0 2
39842: PUSH
39843: LD_INT 1
39845: GREATER
39846: IFFALSE 39877
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39848: LD_ADDR_VAR 0 8
39852: PUSH
39853: LD_VAR 0 1
39857: PPUSH
39858: LD_INT 30
39860: PUSH
39861: LD_INT 5
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL 11587 0 2
39872: PUSH
39873: LD_INT 2
39875: ARRAY
39876: ST_TO_ADDR
// for j in tmp do
39877: LD_ADDR_VAR 0 5
39881: PUSH
39882: LD_VAR 0 12
39886: PUSH
39887: FOR_IN
39888: IFFALSE 40391
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39890: LD_VAR 0 5
39894: PUSH
39895: LD_VAR 0 11
39899: PPUSH
39900: CALL_OW 313
39904: IN
39905: PUSH
39906: LD_VAR 0 11
39910: PPUSH
39911: CALL_OW 313
39915: PUSH
39916: LD_INT 6
39918: EQUAL
39919: AND
39920: PUSH
39921: LD_VAR 0 8
39925: AND
39926: PUSH
39927: LD_VAR 0 8
39931: PPUSH
39932: CALL_OW 313
39936: PUSH
39937: LD_INT 6
39939: LESS
39940: AND
39941: IFFALSE 39968
// begin ComExitBuilding ( j ) ;
39943: LD_VAR 0 5
39947: PPUSH
39948: CALL_OW 122
// AddComEnterunit ( j , k ) ;
39952: LD_VAR 0 5
39956: PPUSH
39957: LD_VAR 0 8
39961: PPUSH
39962: CALL_OW 180
// continue ;
39966: GO 39887
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
39968: LD_VAR 0 5
39972: PPUSH
39973: CALL_OW 314
39977: NOT
39978: PUSH
39979: LD_VAR 0 5
39983: PPUSH
39984: CALL_OW 110
39988: PUSH
39989: LD_INT 0
39991: EQUAL
39992: AND
39993: PUSH
39994: LD_VAR 0 5
39998: PPUSH
39999: CALL_OW 310
40003: NOT
40004: AND
40005: IFFALSE 40111
// begin if k then
40007: LD_VAR 0 8
40011: IFFALSE 40082
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40013: LD_VAR 0 8
40017: PPUSH
40018: CALL_OW 313
40022: PUSH
40023: LD_VAR 0 11
40027: PPUSH
40028: CALL_OW 313
40032: LESS
40033: IFFALSE 40051
// ComEnterUnit ( j , k ) else
40035: LD_VAR 0 5
40039: PPUSH
40040: LD_VAR 0 8
40044: PPUSH
40045: CALL_OW 120
40049: GO 40080
// if UnitsInside ( b ) < 6 then
40051: LD_VAR 0 11
40055: PPUSH
40056: CALL_OW 313
40060: PUSH
40061: LD_INT 6
40063: LESS
40064: IFFALSE 40080
// ComEnterUnit ( j , b ) ;
40066: LD_VAR 0 5
40070: PPUSH
40071: LD_VAR 0 11
40075: PPUSH
40076: CALL_OW 120
// end else
40080: GO 40111
// if UnitsInside ( b ) < 6 then
40082: LD_VAR 0 11
40086: PPUSH
40087: CALL_OW 313
40091: PUSH
40092: LD_INT 6
40094: LESS
40095: IFFALSE 40111
// ComEnterUnit ( j , b ) ;
40097: LD_VAR 0 5
40101: PPUSH
40102: LD_VAR 0 11
40106: PPUSH
40107: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40111: LD_VAR 0 5
40115: PUSH
40116: LD_VAR 0 1
40120: PPUSH
40121: LD_INT 54
40123: PUSH
40124: EMPTY
40125: LIST
40126: PPUSH
40127: CALL 11587 0 2
40131: IN
40132: PUSH
40133: LD_VAR 0 5
40137: PPUSH
40138: CALL_OW 257
40142: PUSH
40143: LD_INT 1
40145: EQUAL
40146: AND
40147: IFFALSE 40389
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40149: LD_EXP 64
40153: PUSH
40154: LD_VAR 0 1
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: PUSH
40164: LD_INT 12
40166: PPUSH
40167: LD_VAR 0 1
40171: PPUSH
40172: CALL_OW 321
40176: PUSH
40177: LD_INT 2
40179: EQUAL
40180: AND
40181: IFFALSE 40229
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40183: LD_VAR 0 1
40187: PPUSH
40188: LD_INT 5
40190: PPUSH
40191: EMPTY
40192: PPUSH
40193: CALL 11670 0 3
40197: PUSH
40198: LD_EXP 64
40202: PUSH
40203: LD_VAR 0 1
40207: ARRAY
40208: PUSH
40209: LD_INT 1
40211: ARRAY
40212: LESS
40213: IFFALSE 40229
// begin SetClass ( j , class_sniper ) ;
40215: LD_VAR 0 5
40219: PPUSH
40220: LD_INT 5
40222: PPUSH
40223: CALL_OW 336
// continue ;
40227: GO 39887
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40229: LD_EXP 64
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 2
40242: ARRAY
40243: PUSH
40244: LD_INT 41
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 8
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11670 0 3
40277: PUSH
40278: LD_EXP 64
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 2
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_mortar ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 8
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39887
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40309: LD_EXP 64
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 3
40322: ARRAY
40323: PUSH
40324: LD_INT 44
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 9
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11670 0 3
40357: PUSH
40358: LD_EXP 64
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 3
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_bazooker ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 9
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39887
// end ; end ; end ;
40389: GO 39887
40391: POP
40392: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40393: LD_INT 22
40395: PUSH
40396: LD_VAR 0 1
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 58
40407: PUSH
40408: EMPTY
40409: LIST
40410: PUSH
40411: LD_INT 30
40413: PUSH
40414: LD_INT 32
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: PPUSH
40426: CALL_OW 69
40430: IFFALSE 40580
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40432: LD_ADDR_VAR 0 12
40436: PUSH
40437: LD_INT 22
40439: PUSH
40440: LD_VAR 0 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 58
40451: PUSH
40452: EMPTY
40453: LIST
40454: PUSH
40455: LD_INT 30
40457: PUSH
40458: LD_INT 32
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: LIST
40469: PPUSH
40470: CALL_OW 69
40474: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40475: LD_ADDR_VAR 0 8
40479: PUSH
40480: LD_VAR 0 13
40484: PUSH
40485: LD_EXP 70
40489: PUSH
40490: LD_VAR 0 1
40494: ARRAY
40495: DIFF
40496: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40497: LD_VAR 0 12
40501: PUSH
40502: LD_INT 1
40504: ARRAY
40505: PPUSH
40506: CALL_OW 461
40510: PUSH
40511: LD_INT 2
40513: EQUAL
40514: PUSH
40515: LD_VAR 0 12
40519: PUSH
40520: LD_INT 1
40522: ARRAY
40523: PUSH
40524: LD_EXP 70
40528: PUSH
40529: LD_VAR 0 1
40533: ARRAY
40534: IN
40535: NOT
40536: AND
40537: PUSH
40538: LD_VAR 0 8
40542: AND
40543: IFFALSE 40580
// begin ComExitBuilding ( k [ 1 ] ) ;
40545: LD_VAR 0 8
40549: PUSH
40550: LD_INT 1
40552: ARRAY
40553: PPUSH
40554: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40558: LD_VAR 0 8
40562: PUSH
40563: LD_INT 1
40565: ARRAY
40566: PPUSH
40567: LD_VAR 0 12
40571: PUSH
40572: LD_INT 1
40574: ARRAY
40575: PPUSH
40576: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40580: LD_EXP 37
40584: PUSH
40585: LD_VAR 0 1
40589: ARRAY
40590: IFFALSE 40738
// begin if MCF_Class ( side , 4 , [ ] ) then
40592: LD_VAR 0 1
40596: PPUSH
40597: LD_INT 4
40599: PPUSH
40600: EMPTY
40601: PPUSH
40602: CALL 11670 0 3
40606: IFFALSE 40736
// for j in MCF_Class ( side , 4 , [ ] ) do
40608: LD_ADDR_VAR 0 5
40612: PUSH
40613: LD_VAR 0 1
40617: PPUSH
40618: LD_INT 4
40620: PPUSH
40621: EMPTY
40622: PPUSH
40623: CALL 11670 0 3
40627: PUSH
40628: FOR_IN
40629: IFFALSE 40734
// begin if not GetTag ( j ) = 4 then
40631: LD_VAR 0 5
40635: PPUSH
40636: CALL_OW 110
40640: PUSH
40641: LD_INT 4
40643: EQUAL
40644: NOT
40645: IFFALSE 40681
// begin SetTag ( j , 4 ) ;
40647: LD_VAR 0 5
40651: PPUSH
40652: LD_INT 4
40654: PPUSH
40655: CALL_OW 109
// if IsInUnit ( j ) then
40659: LD_VAR 0 5
40663: PPUSH
40664: CALL_OW 310
40668: IFFALSE 40679
// ComExitBuilding ( j ) ;
40670: LD_VAR 0 5
40674: PPUSH
40675: CALL_OW 122
// end else
40679: GO 40732
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40681: LD_VAR 0 5
40685: PPUSH
40686: LD_EXP 37
40690: PUSH
40691: LD_VAR 0 1
40695: ARRAY
40696: PUSH
40697: LD_INT 1
40699: ARRAY
40700: PPUSH
40701: CALL 93705 0 2
40705: NOT
40706: IFFALSE 40732
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40708: LD_VAR 0 5
40712: PPUSH
40713: LD_EXP 37
40717: PUSH
40718: LD_VAR 0 1
40722: ARRAY
40723: PUSH
40724: LD_INT 1
40726: ARRAY
40727: PPUSH
40728: CALL 19157 0 2
// end ;
40732: GO 40628
40734: POP
40735: POP
// end else
40736: GO 40970
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40738: LD_VAR 0 1
40742: PPUSH
40743: LD_INT 4
40745: PPUSH
40746: EMPTY
40747: PPUSH
40748: CALL 11670 0 3
40752: PUSH
40753: LD_VAR 0 1
40757: PPUSH
40758: LD_INT 4
40760: PPUSH
40761: EMPTY
40762: PPUSH
40763: CALL 12290 0 3
40767: AND
40768: IFFALSE 40970
// for j in MCF_Class ( side , 4 , [ ] ) do
40770: LD_ADDR_VAR 0 5
40774: PUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 4
40782: PPUSH
40783: EMPTY
40784: PPUSH
40785: CALL 11670 0 3
40789: PUSH
40790: FOR_IN
40791: IFFALSE 40968
// begin if GetTag ( j ) = 4 then
40793: LD_VAR 0 5
40797: PPUSH
40798: CALL_OW 110
40802: PUSH
40803: LD_INT 4
40805: EQUAL
40806: IFFALSE 40966
// begin SetTag ( j , 0 ) ;
40808: LD_VAR 0 5
40812: PPUSH
40813: LD_INT 0
40815: PPUSH
40816: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40820: LD_VAR 0 1
40824: PPUSH
40825: CALL 11626 0 1
40829: PUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: CALL 17970 0 1
40839: NOT
40840: AND
40841: IFFALSE 40866
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40843: LD_VAR 0 5
40847: PPUSH
40848: LD_VAR 0 1
40852: PPUSH
40853: CALL 11626 0 1
40857: PUSH
40858: LD_INT 1
40860: ARRAY
40861: PPUSH
40862: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40866: LD_VAR 0 1
40870: PPUSH
40871: CALL 11626 0 1
40875: NOT
40876: PUSH
40877: LD_VAR 0 1
40881: PPUSH
40882: LD_INT 30
40884: PUSH
40885: LD_INT 1
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PPUSH
40892: CALL 11587 0 2
40896: AND
40897: IFFALSE 40966
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40899: LD_VAR 0 5
40903: PPUSH
40904: LD_VAR 0 1
40908: PPUSH
40909: LD_INT 30
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PPUSH
40919: CALL 11587 0 2
40923: PUSH
40924: LD_INT 1
40926: ARRAY
40927: PPUSH
40928: CALL_OW 250
40932: PPUSH
40933: LD_VAR 0 1
40937: PPUSH
40938: LD_INT 30
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PPUSH
40948: CALL 11587 0 2
40952: PUSH
40953: LD_INT 1
40955: ARRAY
40956: PPUSH
40957: CALL_OW 251
40961: PPUSH
40962: CALL_OW 111
// end ; end ;
40966: GO 40790
40968: POP
40969: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
40970: LD_VAR 0 1
40974: PPUSH
40975: LD_INT 3
40977: PPUSH
40978: EMPTY
40979: PPUSH
40980: CALL 11670 0 3
40984: PUSH
40985: LD_EXP 60
40989: PUSH
40990: LD_VAR 0 1
40994: ARRAY
40995: AND
40996: PUSH
40997: LD_VAR 0 1
41001: PPUSH
41002: LD_INT 6
41004: PPUSH
41005: EMPTY
41006: PPUSH
41007: CALL 12290 0 3
41011: AND
41012: IFFALSE 41543
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41014: LD_ADDR_VAR 0 6
41018: PUSH
41019: LD_EXP 60
41023: PUSH
41024: LD_VAR 0 1
41028: ARRAY
41029: PPUSH
41030: LD_INT 0
41032: PPUSH
41033: CALL_OW 517
41037: PUSH
41038: LD_INT 1
41040: ARRAY
41041: PUSH
41042: LD_INT 1
41044: ARRAY
41045: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41046: LD_ADDR_VAR 0 7
41050: PUSH
41051: LD_EXP 60
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PPUSH
41062: LD_INT 0
41064: PPUSH
41065: CALL_OW 517
41069: PUSH
41070: LD_INT 2
41072: ARRAY
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41078: LD_VAR 0 1
41082: PPUSH
41083: LD_INT 6
41085: PPUSH
41086: EMPTY
41087: PPUSH
41088: CALL 12290 0 3
41092: IFFALSE 41541
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41094: LD_ADDR_VAR 0 8
41098: PUSH
41099: LD_VAR 0 1
41103: PPUSH
41104: LD_INT 6
41106: PPUSH
41107: EMPTY
41108: PPUSH
41109: CALL 12290 0 3
41113: PUSH
41114: FOR_IN
41115: IFFALSE 41146
// if GetLives ( k ) = 1000 then
41117: LD_VAR 0 8
41121: PPUSH
41122: CALL_OW 256
41126: PUSH
41127: LD_INT 1000
41129: EQUAL
41130: IFFALSE 41144
// SetTag ( k , 0 ) ;
41132: LD_VAR 0 8
41136: PPUSH
41137: LD_INT 0
41139: PPUSH
41140: CALL_OW 109
41144: GO 41114
41146: POP
41147: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41148: LD_VAR 0 1
41152: PPUSH
41153: LD_INT 0
41155: PPUSH
41156: LD_INT 25
41158: PUSH
41159: LD_INT 3
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PPUSH
41166: CALL 12290 0 3
41170: IFFALSE 41234
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 4
41181: PPUSH
41182: LD_INT 0
41184: PPUSH
41185: LD_INT 25
41187: PUSH
41188: LD_INT 3
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PPUSH
41195: CALL 12290 0 3
41199: PUSH
41200: FOR_IN
41201: IFFALSE 41232
// if GetTag ( k ) = 0 then
41203: LD_VAR 0 8
41207: PPUSH
41208: CALL_OW 110
41212: PUSH
41213: LD_INT 0
41215: EQUAL
41216: IFFALSE 41230
// begin SetTag ( k , 8 ) ;
41218: LD_VAR 0 8
41222: PPUSH
41223: LD_INT 8
41225: PPUSH
41226: CALL_OW 109
// end ;
41230: GO 41200
41232: POP
41233: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41234: LD_VAR 0 1
41238: PPUSH
41239: LD_INT 6
41241: PPUSH
41242: LD_INT 92
41244: PUSH
41245: LD_VAR 0 6
41249: PUSH
41250: LD_VAR 0 7
41254: PUSH
41255: LD_INT 10
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: PPUSH
41264: CALL 12290 0 3
41268: IFFALSE 41392
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41270: LD_ADDR_VAR 0 5
41274: PUSH
41275: LD_VAR 0 4
41279: PPUSH
41280: LD_INT 6
41282: PPUSH
41283: LD_INT 92
41285: PUSH
41286: LD_VAR 0 6
41290: PUSH
41291: LD_VAR 0 7
41295: PUSH
41296: LD_INT 10
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: PPUSH
41305: CALL 12290 0 3
41309: PUSH
41310: FOR_IN
41311: IFFALSE 41390
// begin if not HasTask ( j ) and GetDriver ( j ) then
41313: LD_VAR 0 5
41317: PPUSH
41318: CALL_OW 314
41322: NOT
41323: PUSH
41324: LD_VAR 0 5
41328: PPUSH
41329: CALL 31695 0 1
41333: AND
41334: IFFALSE 41388
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41336: LD_VAR 0 5
41340: PPUSH
41341: CALL 31695 0 1
41345: PPUSH
41346: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41350: LD_VAR 0 5
41354: PPUSH
41355: CALL 31695 0 1
41359: PPUSH
41360: LD_VAR 0 5
41364: PPUSH
41365: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41369: LD_VAR 0 5
41373: PPUSH
41374: CALL 31695 0 1
41378: PPUSH
41379: LD_VAR 0 5
41383: PPUSH
41384: CALL_OW 180
// end ; end ;
41388: GO 41310
41390: POP
41391: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41392: LD_VAR 0 1
41396: PPUSH
41397: LD_INT 6
41399: PPUSH
41400: LD_INT 92
41402: PUSH
41403: LD_VAR 0 6
41407: PUSH
41408: LD_VAR 0 7
41412: PUSH
41413: LD_INT 10
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL 12290 0 3
41426: PUSH
41427: LD_VAR 0 1
41431: PPUSH
41432: LD_INT 8
41434: PPUSH
41435: EMPTY
41436: PPUSH
41437: CALL 12290 0 3
41441: AND
41442: IFFALSE 41541
// for j in MCF_Tag ( side , 8 , [ ] ) do
41444: LD_ADDR_VAR 0 5
41448: PUSH
41449: LD_VAR 0 1
41453: PPUSH
41454: LD_INT 8
41456: PPUSH
41457: EMPTY
41458: PPUSH
41459: CALL 12290 0 3
41463: PUSH
41464: FOR_IN
41465: IFFALSE 41539
// begin if IsInUnit ( j ) then
41467: LD_VAR 0 5
41471: PPUSH
41472: CALL_OW 310
41476: IFFALSE 41489
// ComExitBuilding ( j ) else
41478: LD_VAR 0 5
41482: PPUSH
41483: CALL_OW 122
41487: GO 41537
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41489: LD_VAR 0 5
41493: PPUSH
41494: LD_VAR 0 1
41498: PPUSH
41499: LD_INT 6
41501: PPUSH
41502: LD_INT 92
41504: PUSH
41505: LD_VAR 0 6
41509: PUSH
41510: LD_VAR 0 7
41514: PUSH
41515: LD_INT 10
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: PPUSH
41524: CALL 12290 0 3
41528: PUSH
41529: LD_INT 1
41531: ARRAY
41532: PPUSH
41533: CALL_OW 129
// end ;
41537: GO 41464
41539: POP
41540: POP
// end ; end else
41541: GO 41598
// if MCF_Tag ( side , 8 , [ ] ) then
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12290 0 3
41557: IFFALSE 41598
// for k in MCF_Tag ( side , 8 , [ ] ) do
41559: LD_ADDR_VAR 0 8
41563: PUSH
41564: LD_VAR 0 1
41568: PPUSH
41569: LD_INT 8
41571: PPUSH
41572: EMPTY
41573: PPUSH
41574: CALL 12290 0 3
41578: PUSH
41579: FOR_IN
41580: IFFALSE 41596
// SetTag ( k , 0 ) ;
41582: LD_VAR 0 8
41586: PPUSH
41587: LD_INT 0
41589: PPUSH
41590: CALL_OW 109
41594: GO 41579
41596: POP
41597: POP
// end ; end_of_file
41598: LD_VAR 0 3
41602: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41603: LD_INT 0
41605: PPUSH
// MREG_Game := [ ] ;
41606: LD_ADDR_EXP 35
41610: PUSH
41611: EMPTY
41612: ST_TO_ADDR
// MREG_Crates := [ ] ;
41613: LD_ADDR_EXP 36
41617: PUSH
41618: EMPTY
41619: ST_TO_ADDR
// MREG_Heal := [ ] ;
41620: LD_ADDR_EXP 37
41624: PUSH
41625: EMPTY
41626: ST_TO_ADDR
// MREG_Tame := [ ] ;
41627: LD_ADDR_EXP 39
41631: PUSH
41632: EMPTY
41633: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41634: LD_ADDR_EXP 40
41638: PUSH
41639: EMPTY
41640: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41641: LD_ADDR_EXP 41
41645: PUSH
41646: EMPTY
41647: ST_TO_ADDR
// MREG_LabList := [ ] ;
41648: LD_ADDR_EXP 42
41652: PUSH
41653: EMPTY
41654: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41655: LD_ADDR_EXP 43
41659: PUSH
41660: EMPTY
41661: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41662: LD_ADDR_EXP 44
41666: PUSH
41667: EMPTY
41668: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41669: LD_ADDR_EXP 45
41673: PUSH
41674: EMPTY
41675: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41676: LD_ADDR_EXP 46
41680: PUSH
41681: EMPTY
41682: ST_TO_ADDR
// MREG_Status := [ ] ;
41683: LD_ADDR_EXP 47
41687: PUSH
41688: EMPTY
41689: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41690: LD_ADDR_EXP 48
41694: PUSH
41695: EMPTY
41696: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41697: LD_ADDR_EXP 49
41701: PUSH
41702: EMPTY
41703: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41704: LD_ADDR_EXP 50
41708: PUSH
41709: EMPTY
41710: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41711: LD_ADDR_EXP 51
41715: PUSH
41716: EMPTY
41717: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41718: LD_ADDR_EXP 52
41722: PUSH
41723: EMPTY
41724: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41725: LD_ADDR_EXP 53
41729: PUSH
41730: EMPTY
41731: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41732: LD_ADDR_EXP 54
41736: PUSH
41737: EMPTY
41738: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41739: LD_ADDR_EXP 55
41743: PUSH
41744: EMPTY
41745: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41746: LD_ADDR_EXP 56
41750: PUSH
41751: EMPTY
41752: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41753: LD_ADDR_EXP 57
41757: PUSH
41758: EMPTY
41759: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41760: LD_ADDR_EXP 58
41764: PUSH
41765: EMPTY
41766: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41767: LD_ADDR_EXP 59
41771: PUSH
41772: EMPTY
41773: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41774: LD_ADDR_EXP 63
41778: PUSH
41779: EMPTY
41780: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41781: LD_ADDR_EXP 64
41785: PUSH
41786: EMPTY
41787: ST_TO_ADDR
// MREG_Parking := [ ] ;
41788: LD_ADDR_EXP 60
41792: PUSH
41793: EMPTY
41794: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41795: LD_ADDR_EXP 61
41799: PUSH
41800: EMPTY
41801: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41802: LD_ADDR_EXP 65
41806: PUSH
41807: EMPTY
41808: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41809: LD_ADDR_EXP 66
41813: PUSH
41814: EMPTY
41815: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41816: LD_ADDR_EXP 67
41820: PUSH
41821: EMPTY
41822: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41823: LD_ADDR_EXP 69
41827: PUSH
41828: EMPTY
41829: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41830: LD_ADDR_EXP 70
41834: PUSH
41835: EMPTY
41836: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41837: LD_ADDR_EXP 71
41841: PUSH
41842: EMPTY
41843: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41844: LD_ADDR_EXP 73
41848: PUSH
41849: EMPTY
41850: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41851: LD_ADDR_EXP 72
41855: PUSH
41856: EMPTY
41857: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41858: LD_ADDR_EXP 74
41862: PUSH
41863: LD_INT 300
41865: PUSH
41866: LD_INT 100
41868: PUSH
41869: LD_INT 25
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: LIST
41876: ST_TO_ADDR
// end ;
41877: LD_VAR 0 1
41881: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41882: LD_INT 0
41884: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41885: LD_VAR 0 2
41889: PUSH
41890: LD_VAR 0 3
41894: PUSH
41895: LD_VAR 0 4
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: PUSH
41905: LD_VAR 0 1
41909: IN
41910: IFFALSE 41924
// result := mreg_list else
41912: LD_ADDR_VAR 0 5
41916: PUSH
41917: LD_VAR 0 1
41921: ST_TO_ADDR
41922: GO 41958
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
41924: LD_ADDR_VAR 0 1
41928: PUSH
41929: LD_VAR 0 1
41933: PUSH
41934: LD_VAR 0 2
41938: PUSH
41939: LD_VAR 0 3
41943: PUSH
41944: LD_VAR 0 4
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: LIST
41953: PUSH
41954: EMPTY
41955: LIST
41956: ADD
41957: ST_TO_ADDR
// result := mreg_list ;
41958: LD_ADDR_VAR 0 5
41962: PUSH
41963: LD_VAR 0 1
41967: ST_TO_ADDR
// end ;
41968: LD_VAR 0 5
41972: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
41973: LD_INT 0
41975: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41976: LD_VAR 0 2
41980: PUSH
41981: LD_VAR 0 3
41985: PUSH
41986: LD_VAR 0 4
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: LIST
41995: PUSH
41996: LD_VAR 0 1
42000: IN
42001: IFFALSE 42039
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42003: LD_ADDR_VAR 0 5
42007: PUSH
42008: LD_VAR 0 1
42012: PUSH
42013: LD_VAR 0 2
42017: PUSH
42018: LD_VAR 0 3
42022: PUSH
42023: LD_VAR 0 4
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: PUSH
42033: EMPTY
42034: LIST
42035: DIFF
42036: ST_TO_ADDR
42037: GO 42049
// result := mreg_list ;
42039: LD_ADDR_VAR 0 5
42043: PUSH
42044: LD_VAR 0 1
42048: ST_TO_ADDR
// end ;
42049: LD_VAR 0 5
42053: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42054: LD_INT 0
42056: PPUSH
42057: PPUSH
42058: PPUSH
// for j = 1 to 8 do
42059: LD_ADDR_VAR 0 3
42063: PUSH
42064: DOUBLE
42065: LD_INT 1
42067: DEC
42068: ST_TO_ADDR
42069: LD_INT 8
42071: PUSH
42072: FOR_TO
42073: IFFALSE 42914
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42075: LD_VAR 0 3
42079: PPUSH
42080: LD_INT 51
42082: PUSH
42083: EMPTY
42084: LIST
42085: PPUSH
42086: CALL 11587 0 2
42090: PUSH
42091: LD_OWVAR 2
42095: PUSH
42096: LD_VAR 0 3
42100: EQUAL
42101: NOT
42102: AND
42103: IFFALSE 42121
// MREG_SidesList := MREG_SidesList ^ 1 else
42105: LD_ADDR_EXP 41
42109: PUSH
42110: LD_EXP 41
42114: PUSH
42115: LD_INT 1
42117: ADD
42118: ST_TO_ADDR
42119: GO 42135
// MREG_SidesList := MREG_SidesList ^ 0 ;
42121: LD_ADDR_EXP 41
42125: PUSH
42126: LD_EXP 41
42130: PUSH
42131: LD_INT 0
42133: ADD
42134: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42135: LD_VAR 0 3
42139: PPUSH
42140: LD_INT 2
42142: PUSH
42143: LD_INT 34
42145: PUSH
42146: LD_INT 12
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 34
42155: PUSH
42156: LD_INT 32
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 34
42165: PUSH
42166: LD_INT 51
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: PUSH
42179: EMPTY
42180: LIST
42181: PPUSH
42182: CALL 11888 0 2
42186: IFFALSE 42287
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42188: LD_ADDR_VAR 0 2
42192: PUSH
42193: LD_VAR 0 3
42197: PPUSH
42198: LD_INT 2
42200: PUSH
42201: LD_INT 34
42203: PUSH
42204: LD_INT 12
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 34
42213: PUSH
42214: LD_INT 32
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 51
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PPUSH
42240: CALL 11888 0 2
42244: PUSH
42245: FOR_IN
42246: IFFALSE 42285
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42248: LD_ADDR_EXP 43
42252: PUSH
42253: LD_EXP 43
42257: PPUSH
42258: LD_VAR 0 3
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: LD_VAR 0 2
42272: PPUSH
42273: CALL_OW 264
42277: PPUSH
42278: CALL 41882 0 4
42282: ST_TO_ADDR
42283: GO 42245
42285: POP
42286: POP
// if MCF_Class ( j , 4 , [ ] ) then
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 4
42294: PPUSH
42295: EMPTY
42296: PPUSH
42297: CALL 11670 0 3
42301: IFFALSE 42334
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42303: LD_ADDR_EXP 56
42307: PUSH
42308: LD_EXP 56
42312: PUSH
42313: LD_VAR 0 3
42317: PPUSH
42318: LD_INT 4
42320: PPUSH
42321: EMPTY
42322: PPUSH
42323: CALL 11670 0 3
42327: PUSH
42328: EMPTY
42329: LIST
42330: ADD
42331: ST_TO_ADDR
42332: GO 42351
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42334: LD_ADDR_EXP 56
42338: PUSH
42339: LD_EXP 56
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: ADD
42350: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42351: LD_VAR 0 3
42355: PPUSH
42356: LD_INT 3
42358: PPUSH
42359: EMPTY
42360: PPUSH
42361: CALL 11670 0 3
42365: IFFALSE 42398
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42367: LD_ADDR_EXP 57
42371: PUSH
42372: LD_EXP 57
42376: PUSH
42377: LD_VAR 0 3
42381: PPUSH
42382: LD_INT 3
42384: PPUSH
42385: EMPTY
42386: PPUSH
42387: CALL 11670 0 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: ADD
42395: ST_TO_ADDR
42396: GO 42415
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42398: LD_ADDR_EXP 57
42402: PUSH
42403: LD_EXP 57
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: EMPTY
42412: LIST
42413: ADD
42414: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42415: LD_VAR 0 3
42419: PPUSH
42420: LD_INT 1
42422: PPUSH
42423: EMPTY
42424: PPUSH
42425: CALL 11670 0 3
42429: IFFALSE 42462
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42431: LD_ADDR_EXP 58
42435: PUSH
42436: LD_EXP 58
42440: PUSH
42441: LD_VAR 0 3
42445: PPUSH
42446: LD_INT 1
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL 11670 0 3
42455: PUSH
42456: EMPTY
42457: LIST
42458: ADD
42459: ST_TO_ADDR
42460: GO 42479
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42462: LD_ADDR_EXP 58
42466: PUSH
42467: LD_EXP 58
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: ADD
42478: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42479: LD_VAR 0 3
42483: PPUSH
42484: LD_INT 2
42486: PPUSH
42487: EMPTY
42488: PPUSH
42489: CALL 11670 0 3
42493: IFFALSE 42526
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42495: LD_ADDR_EXP 59
42499: PUSH
42500: LD_EXP 59
42504: PUSH
42505: LD_VAR 0 3
42509: PPUSH
42510: LD_INT 2
42512: PPUSH
42513: EMPTY
42514: PPUSH
42515: CALL 11670 0 3
42519: PUSH
42520: EMPTY
42521: LIST
42522: ADD
42523: ST_TO_ADDR
42524: GO 42543
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42526: LD_ADDR_EXP 59
42530: PUSH
42531: LD_EXP 59
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: ADD
42542: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42543: LD_ADDR_EXP 49
42547: PUSH
42548: LD_EXP 49
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: EMPTY
42557: LIST
42558: ADD
42559: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42560: LD_ADDR_EXP 37
42564: PUSH
42565: LD_EXP 37
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: EMPTY
42574: LIST
42575: ADD
42576: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42577: LD_ADDR_EXP 39
42581: PUSH
42582: LD_EXP 39
42586: PUSH
42587: LD_INT 0
42589: PUSH
42590: EMPTY
42591: LIST
42592: ADD
42593: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42594: LD_ADDR_EXP 60
42598: PUSH
42599: LD_EXP 60
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: EMPTY
42608: LIST
42609: ADD
42610: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42611: LD_ADDR_EXP 61
42615: PUSH
42616: LD_EXP 61
42620: PUSH
42621: LD_INT 0
42623: PUSH
42624: EMPTY
42625: LIST
42626: ADD
42627: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42628: LD_ADDR_EXP 53
42632: PUSH
42633: LD_EXP 53
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: ADD
42644: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42645: LD_ADDR_EXP 40
42649: PUSH
42650: LD_EXP 40
42654: PUSH
42655: LD_INT 0
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: PUSH
42673: EMPTY
42674: LIST
42675: ADD
42676: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42677: LD_ADDR_EXP 62
42681: PUSH
42682: LD_EXP 62
42686: PUSH
42687: LD_INT 0
42689: PUSH
42690: EMPTY
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: EMPTY
42697: LIST
42698: ADD
42699: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42700: LD_ADDR_EXP 63
42704: PUSH
42705: LD_EXP 63
42709: PUSH
42710: LD_INT 0
42712: PUSH
42713: EMPTY
42714: LIST
42715: PUSH
42716: EMPTY
42717: LIST
42718: ADD
42719: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42720: LD_ADDR_EXP 44
42724: PUSH
42725: LD_EXP 44
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: ADD
42736: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42737: LD_ADDR_EXP 65
42741: PUSH
42742: LD_EXP 65
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: EMPTY
42751: LIST
42752: ADD
42753: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42754: LD_ADDR_EXP 66
42758: PUSH
42759: LD_EXP 66
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42771: LD_ADDR_EXP 67
42775: PUSH
42776: LD_EXP 67
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: LIST
42786: ADD
42787: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42788: LD_ADDR_EXP 68
42792: PUSH
42793: LD_EXP 68
42797: PUSH
42798: LD_INT 0
42800: PUSH
42801: EMPTY
42802: LIST
42803: ADD
42804: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42805: LD_ADDR_EXP 69
42809: PUSH
42810: LD_EXP 69
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: EMPTY
42819: LIST
42820: ADD
42821: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42822: LD_ADDR_EXP 70
42826: PUSH
42827: LD_EXP 70
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: EMPTY
42836: LIST
42837: ADD
42838: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42839: LD_ADDR_EXP 71
42843: PUSH
42844: LD_EXP 71
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: ADD
42855: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42856: LD_ADDR_EXP 73
42860: PUSH
42861: LD_EXP 73
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: EMPTY
42870: LIST
42871: ADD
42872: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42873: LD_ADDR_EXP 72
42877: PUSH
42878: LD_EXP 72
42882: PUSH
42883: LD_INT 0
42885: ADD
42886: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42887: LD_ADDR_EXP 64
42891: PUSH
42892: LD_EXP 64
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: LIST
42910: ADD
42911: ST_TO_ADDR
// end ;
42912: GO 42072
42914: POP
42915: POP
// end ;
42916: LD_VAR 0 1
42920: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42921: LD_INT 0
42923: PPUSH
42924: PPUSH
42925: PPUSH
// m := false ;
42926: LD_ADDR_VAR 0 5
42930: PUSH
42931: LD_INT 0
42933: ST_TO_ADDR
// for i = 1 to mreg do
42934: LD_ADDR_VAR 0 4
42938: PUSH
42939: DOUBLE
42940: LD_INT 1
42942: DEC
42943: ST_TO_ADDR
42944: LD_VAR 0 2
42948: PUSH
42949: FOR_TO
42950: IFFALSE 42986
// if mreg [ i ] [ 1 ] = side then
42952: LD_VAR 0 2
42956: PUSH
42957: LD_VAR 0 4
42961: ARRAY
42962: PUSH
42963: LD_INT 1
42965: ARRAY
42966: PUSH
42967: LD_VAR 0 1
42971: EQUAL
42972: IFFALSE 42984
// begin m := true ;
42974: LD_ADDR_VAR 0 5
42978: PUSH
42979: LD_INT 1
42981: ST_TO_ADDR
// break ;
42982: GO 42986
// end ;
42984: GO 42949
42986: POP
42987: POP
// result := m ;
42988: LD_ADDR_VAR 0 3
42992: PUSH
42993: LD_VAR 0 5
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43003: LD_INT 0
43005: PPUSH
43006: PPUSH
43007: PPUSH
// m := 0 ;
43008: LD_ADDR_VAR 0 5
43012: PUSH
43013: LD_INT 0
43015: ST_TO_ADDR
// for i = 1 to mreg do
43016: LD_ADDR_VAR 0 4
43020: PUSH
43021: DOUBLE
43022: LD_INT 1
43024: DEC
43025: ST_TO_ADDR
43026: LD_VAR 0 2
43030: PUSH
43031: FOR_TO
43032: IFFALSE 43072
// if mreg [ i ] [ 1 ] = side then
43034: LD_VAR 0 2
43038: PUSH
43039: LD_VAR 0 4
43043: ARRAY
43044: PUSH
43045: LD_INT 1
43047: ARRAY
43048: PUSH
43049: LD_VAR 0 1
43053: EQUAL
43054: IFFALSE 43070
// begin m := m + 1 ;
43056: LD_ADDR_VAR 0 5
43060: PUSH
43061: LD_VAR 0 5
43065: PUSH
43066: LD_INT 1
43068: PLUS
43069: ST_TO_ADDR
// end ;
43070: GO 43031
43072: POP
43073: POP
// result := m ;
43074: LD_ADDR_VAR 0 3
43078: PUSH
43079: LD_VAR 0 5
43083: ST_TO_ADDR
// end ;
43084: LD_VAR 0 3
43088: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43089: LD_INT 0
43091: PPUSH
43092: PPUSH
// result := 0 ;
43093: LD_ADDR_VAR 0 3
43097: PUSH
43098: LD_INT 0
43100: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43101: LD_ADDR_VAR 0 4
43105: PUSH
43106: DOUBLE
43107: LD_INT 1
43109: DEC
43110: ST_TO_ADDR
43111: LD_EXP 55
43115: PUSH
43116: FOR_TO
43117: IFFALSE 43179
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43119: LD_EXP 55
43123: PUSH
43124: LD_VAR 0 4
43128: ARRAY
43129: PUSH
43130: LD_INT 1
43132: ARRAY
43133: PUSH
43134: LD_VAR 0 1
43138: EQUAL
43139: PUSH
43140: LD_EXP 55
43144: PUSH
43145: LD_VAR 0 4
43149: ARRAY
43150: PUSH
43151: LD_INT 2
43153: ARRAY
43154: PUSH
43155: LD_VAR 0 2
43159: EQUAL
43160: AND
43161: IFFALSE 43177
// begin result := result + 1 ;
43163: LD_ADDR_VAR 0 3
43167: PUSH
43168: LD_VAR 0 3
43172: PUSH
43173: LD_INT 1
43175: PLUS
43176: ST_TO_ADDR
// end ;
43177: GO 43116
43179: POP
43180: POP
// end ; end_of_file
43181: LD_VAR 0 3
43185: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
43186: LD_INT 0
43188: PPUSH
// ar_miner := 81 ;
43189: LD_ADDR_EXP 82
43193: PUSH
43194: LD_INT 81
43196: ST_TO_ADDR
// ar_crane := 88 ;
43197: LD_ADDR_EXP 81
43201: PUSH
43202: LD_INT 88
43204: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43205: LD_ADDR_EXP 76
43209: PUSH
43210: LD_INT 89
43212: ST_TO_ADDR
// us_hack := 99 ;
43213: LD_ADDR_EXP 77
43217: PUSH
43218: LD_INT 99
43220: ST_TO_ADDR
// us_artillery := 97 ;
43221: LD_ADDR_EXP 78
43225: PUSH
43226: LD_INT 97
43228: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43229: LD_ADDR_EXP 79
43233: PUSH
43234: LD_INT 91
43236: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
43237: LD_ADDR_EXP 80
43241: PUSH
43242: LD_INT 92
43244: ST_TO_ADDR
// ru_radar := 98 ;
43245: LD_ADDR_EXP 75
43249: PUSH
43250: LD_INT 98
43252: ST_TO_ADDR
// tech_Artillery := 80 ;
43253: LD_ADDR_EXP 83
43257: PUSH
43258: LD_INT 80
43260: ST_TO_ADDR
// tech_RadMat := 81 ;
43261: LD_ADDR_EXP 84
43265: PUSH
43266: LD_INT 81
43268: ST_TO_ADDR
// tech_BasicTools := 82 ;
43269: LD_ADDR_EXP 85
43273: PUSH
43274: LD_INT 82
43276: ST_TO_ADDR
// tech_Cargo := 83 ;
43277: LD_ADDR_EXP 86
43281: PUSH
43282: LD_INT 83
43284: ST_TO_ADDR
// tech_Track := 84 ;
43285: LD_ADDR_EXP 87
43289: PUSH
43290: LD_INT 84
43292: ST_TO_ADDR
// tech_Crane := 85 ;
43293: LD_ADDR_EXP 88
43297: PUSH
43298: LD_INT 85
43300: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43301: LD_ADDR_EXP 89
43305: PUSH
43306: LD_INT 86
43308: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43309: LD_ADDR_EXP 90
43313: PUSH
43314: LD_INT 87
43316: ST_TO_ADDR
// end ;
43317: LD_VAR 0 1
43321: RET
// every 1 do
43322: GO 43324
43324: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43325: CALL 43186 0 0
43329: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
43330: LD_VAR 0 2
43334: PUSH
43335: LD_INT 100
43337: EQUAL
43338: IFFALSE 44287
// begin if not StreamModeActive then
43340: LD_EXP 91
43344: NOT
43345: IFFALSE 43355
// StreamModeActive := true ;
43347: LD_ADDR_EXP 91
43351: PUSH
43352: LD_INT 1
43354: ST_TO_ADDR
// if p3 = 0 then
43355: LD_VAR 0 3
43359: PUSH
43360: LD_INT 0
43362: EQUAL
43363: IFFALSE 43369
// InitStreamMode ;
43365: CALL 44445 0 0
// if p3 = 1 then
43369: LD_VAR 0 3
43373: PUSH
43374: LD_INT 1
43376: EQUAL
43377: IFFALSE 43387
// sRocket := true ;
43379: LD_ADDR_EXP 96
43383: PUSH
43384: LD_INT 1
43386: ST_TO_ADDR
// if p3 = 2 then
43387: LD_VAR 0 3
43391: PUSH
43392: LD_INT 2
43394: EQUAL
43395: IFFALSE 43405
// sSpeed := true ;
43397: LD_ADDR_EXP 95
43401: PUSH
43402: LD_INT 1
43404: ST_TO_ADDR
// if p3 = 3 then
43405: LD_VAR 0 3
43409: PUSH
43410: LD_INT 3
43412: EQUAL
43413: IFFALSE 43423
// sEngine := true ;
43415: LD_ADDR_EXP 97
43419: PUSH
43420: LD_INT 1
43422: ST_TO_ADDR
// if p3 = 4 then
43423: LD_VAR 0 3
43427: PUSH
43428: LD_INT 4
43430: EQUAL
43431: IFFALSE 43441
// sSpec := true ;
43433: LD_ADDR_EXP 94
43437: PUSH
43438: LD_INT 1
43440: ST_TO_ADDR
// if p3 = 5 then
43441: LD_VAR 0 3
43445: PUSH
43446: LD_INT 5
43448: EQUAL
43449: IFFALSE 43459
// sLevel := true ;
43451: LD_ADDR_EXP 98
43455: PUSH
43456: LD_INT 1
43458: ST_TO_ADDR
// if p3 = 6 then
43459: LD_VAR 0 3
43463: PUSH
43464: LD_INT 6
43466: EQUAL
43467: IFFALSE 43477
// sArmoury := true ;
43469: LD_ADDR_EXP 99
43473: PUSH
43474: LD_INT 1
43476: ST_TO_ADDR
// if p3 = 7 then
43477: LD_VAR 0 3
43481: PUSH
43482: LD_INT 7
43484: EQUAL
43485: IFFALSE 43495
// sRadar := true ;
43487: LD_ADDR_EXP 100
43491: PUSH
43492: LD_INT 1
43494: ST_TO_ADDR
// if p3 = 8 then
43495: LD_VAR 0 3
43499: PUSH
43500: LD_INT 8
43502: EQUAL
43503: IFFALSE 43513
// sBunker := true ;
43505: LD_ADDR_EXP 101
43509: PUSH
43510: LD_INT 1
43512: ST_TO_ADDR
// if p3 = 9 then
43513: LD_VAR 0 3
43517: PUSH
43518: LD_INT 9
43520: EQUAL
43521: IFFALSE 43531
// sHack := true ;
43523: LD_ADDR_EXP 102
43527: PUSH
43528: LD_INT 1
43530: ST_TO_ADDR
// if p3 = 10 then
43531: LD_VAR 0 3
43535: PUSH
43536: LD_INT 10
43538: EQUAL
43539: IFFALSE 43549
// sFire := true ;
43541: LD_ADDR_EXP 103
43545: PUSH
43546: LD_INT 1
43548: ST_TO_ADDR
// if p3 = 11 then
43549: LD_VAR 0 3
43553: PUSH
43554: LD_INT 11
43556: EQUAL
43557: IFFALSE 43567
// sRefresh := true ;
43559: LD_ADDR_EXP 104
43563: PUSH
43564: LD_INT 1
43566: ST_TO_ADDR
// if p3 = 12 then
43567: LD_VAR 0 3
43571: PUSH
43572: LD_INT 12
43574: EQUAL
43575: IFFALSE 43585
// sExp := true ;
43577: LD_ADDR_EXP 105
43581: PUSH
43582: LD_INT 1
43584: ST_TO_ADDR
// if p3 = 13 then
43585: LD_VAR 0 3
43589: PUSH
43590: LD_INT 13
43592: EQUAL
43593: IFFALSE 43603
// sDepot := true ;
43595: LD_ADDR_EXP 106
43599: PUSH
43600: LD_INT 1
43602: ST_TO_ADDR
// if p3 = 14 then
43603: LD_VAR 0 3
43607: PUSH
43608: LD_INT 14
43610: EQUAL
43611: IFFALSE 43621
// sFlag := true ;
43613: LD_ADDR_EXP 107
43617: PUSH
43618: LD_INT 1
43620: ST_TO_ADDR
// if p3 = 15 then
43621: LD_VAR 0 3
43625: PUSH
43626: LD_INT 15
43628: EQUAL
43629: IFFALSE 43639
// sKamikadze := true ;
43631: LD_ADDR_EXP 115
43635: PUSH
43636: LD_INT 1
43638: ST_TO_ADDR
// if p3 = 16 then
43639: LD_VAR 0 3
43643: PUSH
43644: LD_INT 16
43646: EQUAL
43647: IFFALSE 43657
// sTroll := true ;
43649: LD_ADDR_EXP 116
43653: PUSH
43654: LD_INT 1
43656: ST_TO_ADDR
// if p3 = 17 then
43657: LD_VAR 0 3
43661: PUSH
43662: LD_INT 17
43664: EQUAL
43665: IFFALSE 43675
// sSlow := true ;
43667: LD_ADDR_EXP 117
43671: PUSH
43672: LD_INT 1
43674: ST_TO_ADDR
// if p3 = 18 then
43675: LD_VAR 0 3
43679: PUSH
43680: LD_INT 18
43682: EQUAL
43683: IFFALSE 43693
// sLack := true ;
43685: LD_ADDR_EXP 118
43689: PUSH
43690: LD_INT 1
43692: ST_TO_ADDR
// if p3 = 19 then
43693: LD_VAR 0 3
43697: PUSH
43698: LD_INT 19
43700: EQUAL
43701: IFFALSE 43711
// sTank := true ;
43703: LD_ADDR_EXP 120
43707: PUSH
43708: LD_INT 1
43710: ST_TO_ADDR
// if p3 = 20 then
43711: LD_VAR 0 3
43715: PUSH
43716: LD_INT 20
43718: EQUAL
43719: IFFALSE 43729
// sRemote := true ;
43721: LD_ADDR_EXP 121
43725: PUSH
43726: LD_INT 1
43728: ST_TO_ADDR
// if p3 = 21 then
43729: LD_VAR 0 3
43733: PUSH
43734: LD_INT 21
43736: EQUAL
43737: IFFALSE 43747
// sPowell := true ;
43739: LD_ADDR_EXP 122
43743: PUSH
43744: LD_INT 1
43746: ST_TO_ADDR
// if p3 = 22 then
43747: LD_VAR 0 3
43751: PUSH
43752: LD_INT 22
43754: EQUAL
43755: IFFALSE 43765
// sTeleport := true ;
43757: LD_ADDR_EXP 125
43761: PUSH
43762: LD_INT 1
43764: ST_TO_ADDR
// if p3 = 23 then
43765: LD_VAR 0 3
43769: PUSH
43770: LD_INT 23
43772: EQUAL
43773: IFFALSE 43783
// sOilTower := true ;
43775: LD_ADDR_EXP 127
43779: PUSH
43780: LD_INT 1
43782: ST_TO_ADDR
// if p3 = 24 then
43783: LD_VAR 0 3
43787: PUSH
43788: LD_INT 24
43790: EQUAL
43791: IFFALSE 43801
// sShovel := true ;
43793: LD_ADDR_EXP 128
43797: PUSH
43798: LD_INT 1
43800: ST_TO_ADDR
// if p3 = 25 then
43801: LD_VAR 0 3
43805: PUSH
43806: LD_INT 25
43808: EQUAL
43809: IFFALSE 43819
// sSheik := true ;
43811: LD_ADDR_EXP 129
43815: PUSH
43816: LD_INT 1
43818: ST_TO_ADDR
// if p3 = 26 then
43819: LD_VAR 0 3
43823: PUSH
43824: LD_INT 26
43826: EQUAL
43827: IFFALSE 43837
// sEarthquake := true ;
43829: LD_ADDR_EXP 131
43833: PUSH
43834: LD_INT 1
43836: ST_TO_ADDR
// if p3 = 27 then
43837: LD_VAR 0 3
43841: PUSH
43842: LD_INT 27
43844: EQUAL
43845: IFFALSE 43855
// sAI := true ;
43847: LD_ADDR_EXP 132
43851: PUSH
43852: LD_INT 1
43854: ST_TO_ADDR
// if p3 = 28 then
43855: LD_VAR 0 3
43859: PUSH
43860: LD_INT 28
43862: EQUAL
43863: IFFALSE 43873
// sCargo := true ;
43865: LD_ADDR_EXP 135
43869: PUSH
43870: LD_INT 1
43872: ST_TO_ADDR
// if p3 = 29 then
43873: LD_VAR 0 3
43877: PUSH
43878: LD_INT 29
43880: EQUAL
43881: IFFALSE 43891
// sDLaser := true ;
43883: LD_ADDR_EXP 136
43887: PUSH
43888: LD_INT 1
43890: ST_TO_ADDR
// if p3 = 30 then
43891: LD_VAR 0 3
43895: PUSH
43896: LD_INT 30
43898: EQUAL
43899: IFFALSE 43909
// sExchange := true ;
43901: LD_ADDR_EXP 137
43905: PUSH
43906: LD_INT 1
43908: ST_TO_ADDR
// if p3 = 31 then
43909: LD_VAR 0 3
43913: PUSH
43914: LD_INT 31
43916: EQUAL
43917: IFFALSE 43927
// sFac := true ;
43919: LD_ADDR_EXP 138
43923: PUSH
43924: LD_INT 1
43926: ST_TO_ADDR
// if p3 = 32 then
43927: LD_VAR 0 3
43931: PUSH
43932: LD_INT 32
43934: EQUAL
43935: IFFALSE 43945
// sPower := true ;
43937: LD_ADDR_EXP 139
43941: PUSH
43942: LD_INT 1
43944: ST_TO_ADDR
// if p3 = 33 then
43945: LD_VAR 0 3
43949: PUSH
43950: LD_INT 33
43952: EQUAL
43953: IFFALSE 43963
// sRandom := true ;
43955: LD_ADDR_EXP 140
43959: PUSH
43960: LD_INT 1
43962: ST_TO_ADDR
// if p3 = 34 then
43963: LD_VAR 0 3
43967: PUSH
43968: LD_INT 34
43970: EQUAL
43971: IFFALSE 43981
// sShield := true ;
43973: LD_ADDR_EXP 141
43977: PUSH
43978: LD_INT 1
43980: ST_TO_ADDR
// if p3 = 35 then
43981: LD_VAR 0 3
43985: PUSH
43986: LD_INT 35
43988: EQUAL
43989: IFFALSE 43999
// sTime := true ;
43991: LD_ADDR_EXP 142
43995: PUSH
43996: LD_INT 1
43998: ST_TO_ADDR
// if p3 = 36 then
43999: LD_VAR 0 3
44003: PUSH
44004: LD_INT 36
44006: EQUAL
44007: IFFALSE 44017
// sTools := true ;
44009: LD_ADDR_EXP 143
44013: PUSH
44014: LD_INT 1
44016: ST_TO_ADDR
// if p3 = 101 then
44017: LD_VAR 0 3
44021: PUSH
44022: LD_INT 101
44024: EQUAL
44025: IFFALSE 44035
// sSold := true ;
44027: LD_ADDR_EXP 108
44031: PUSH
44032: LD_INT 1
44034: ST_TO_ADDR
// if p3 = 102 then
44035: LD_VAR 0 3
44039: PUSH
44040: LD_INT 102
44042: EQUAL
44043: IFFALSE 44053
// sDiff := true ;
44045: LD_ADDR_EXP 109
44049: PUSH
44050: LD_INT 1
44052: ST_TO_ADDR
// if p3 = 103 then
44053: LD_VAR 0 3
44057: PUSH
44058: LD_INT 103
44060: EQUAL
44061: IFFALSE 44071
// sFog := true ;
44063: LD_ADDR_EXP 112
44067: PUSH
44068: LD_INT 1
44070: ST_TO_ADDR
// if p3 = 104 then
44071: LD_VAR 0 3
44075: PUSH
44076: LD_INT 104
44078: EQUAL
44079: IFFALSE 44089
// sReset := true ;
44081: LD_ADDR_EXP 113
44085: PUSH
44086: LD_INT 1
44088: ST_TO_ADDR
// if p3 = 105 then
44089: LD_VAR 0 3
44093: PUSH
44094: LD_INT 105
44096: EQUAL
44097: IFFALSE 44107
// sSun := true ;
44099: LD_ADDR_EXP 114
44103: PUSH
44104: LD_INT 1
44106: ST_TO_ADDR
// if p3 = 106 then
44107: LD_VAR 0 3
44111: PUSH
44112: LD_INT 106
44114: EQUAL
44115: IFFALSE 44125
// sTiger := true ;
44117: LD_ADDR_EXP 110
44121: PUSH
44122: LD_INT 1
44124: ST_TO_ADDR
// if p3 = 107 then
44125: LD_VAR 0 3
44129: PUSH
44130: LD_INT 107
44132: EQUAL
44133: IFFALSE 44143
// sBomb := true ;
44135: LD_ADDR_EXP 111
44139: PUSH
44140: LD_INT 1
44142: ST_TO_ADDR
// if p3 = 108 then
44143: LD_VAR 0 3
44147: PUSH
44148: LD_INT 108
44150: EQUAL
44151: IFFALSE 44161
// sWound := true ;
44153: LD_ADDR_EXP 119
44157: PUSH
44158: LD_INT 1
44160: ST_TO_ADDR
// if p3 = 109 then
44161: LD_VAR 0 3
44165: PUSH
44166: LD_INT 109
44168: EQUAL
44169: IFFALSE 44179
// sBetray := true ;
44171: LD_ADDR_EXP 123
44175: PUSH
44176: LD_INT 1
44178: ST_TO_ADDR
// if p3 = 110 then
44179: LD_VAR 0 3
44183: PUSH
44184: LD_INT 110
44186: EQUAL
44187: IFFALSE 44197
// sContamin := true ;
44189: LD_ADDR_EXP 124
44193: PUSH
44194: LD_INT 1
44196: ST_TO_ADDR
// if p3 = 111 then
44197: LD_VAR 0 3
44201: PUSH
44202: LD_INT 111
44204: EQUAL
44205: IFFALSE 44215
// sOil := true ;
44207: LD_ADDR_EXP 126
44211: PUSH
44212: LD_INT 1
44214: ST_TO_ADDR
// if p3 = 112 then
44215: LD_VAR 0 3
44219: PUSH
44220: LD_INT 112
44222: EQUAL
44223: IFFALSE 44233
// sStu := true ;
44225: LD_ADDR_EXP 130
44229: PUSH
44230: LD_INT 1
44232: ST_TO_ADDR
// if p3 = 113 then
44233: LD_VAR 0 3
44237: PUSH
44238: LD_INT 113
44240: EQUAL
44241: IFFALSE 44251
// sBazooka := true ;
44243: LD_ADDR_EXP 133
44247: PUSH
44248: LD_INT 1
44250: ST_TO_ADDR
// if p3 = 114 then
44251: LD_VAR 0 3
44255: PUSH
44256: LD_INT 114
44258: EQUAL
44259: IFFALSE 44269
// sMortar := true ;
44261: LD_ADDR_EXP 134
44265: PUSH
44266: LD_INT 1
44268: ST_TO_ADDR
// if p3 = 115 then
44269: LD_VAR 0 3
44273: PUSH
44274: LD_INT 115
44276: EQUAL
44277: IFFALSE 44287
// sRanger := true ;
44279: LD_ADDR_EXP 144
44283: PUSH
44284: LD_INT 1
44286: ST_TO_ADDR
// end ; if p2 = 101 then
44287: LD_VAR 0 2
44291: PUSH
44292: LD_INT 101
44294: EQUAL
44295: IFFALSE 44423
// begin case p3 of 1 :
44297: LD_VAR 0 3
44301: PUSH
44302: LD_INT 1
44304: DOUBLE
44305: EQUAL
44306: IFTRUE 44310
44308: GO 44317
44310: POP
// hHackUnlimitedResources ; 2 :
44311: CALL 55458 0 0
44315: GO 44423
44317: LD_INT 2
44319: DOUBLE
44320: EQUAL
44321: IFTRUE 44325
44323: GO 44332
44325: POP
// hHackSetLevel10 ; 3 :
44326: CALL 55591 0 0
44330: GO 44423
44332: LD_INT 3
44334: DOUBLE
44335: EQUAL
44336: IFTRUE 44340
44338: GO 44347
44340: POP
// hHackSetLevel10YourUnits ; 4 :
44341: CALL 55676 0 0
44345: GO 44423
44347: LD_INT 4
44349: DOUBLE
44350: EQUAL
44351: IFTRUE 44355
44353: GO 44362
44355: POP
// hHackInvincible ; 5 :
44356: CALL 56124 0 0
44360: GO 44423
44362: LD_INT 5
44364: DOUBLE
44365: EQUAL
44366: IFTRUE 44370
44368: GO 44377
44370: POP
// hHackInvisible ; 6 :
44371: CALL 56235 0 0
44375: GO 44423
44377: LD_INT 6
44379: DOUBLE
44380: EQUAL
44381: IFTRUE 44385
44383: GO 44392
44385: POP
// hHackChangeYourSide ; 7 :
44386: CALL 56292 0 0
44390: GO 44423
44392: LD_INT 7
44394: DOUBLE
44395: EQUAL
44396: IFTRUE 44400
44398: GO 44407
44400: POP
// hHackChangeUnitSide ; 8 :
44401: CALL 56334 0 0
44405: GO 44423
44407: LD_INT 8
44409: DOUBLE
44410: EQUAL
44411: IFTRUE 44415
44413: GO 44422
44415: POP
// hHackFog ; end ;
44416: CALL 56435 0 0
44420: GO 44423
44422: POP
// end ; end ;
44423: PPOPN 6
44425: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44426: GO 44428
44428: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44429: LD_STRING initStreamRollete();
44431: PPUSH
44432: CALL_OW 559
// InitStreamMode ;
44436: CALL 44445 0 0
// DefineStreamItems ( ) ;
44440: CALL 44885 0 0
// end ;
44444: END
// function InitStreamMode ; begin
44445: LD_INT 0
44447: PPUSH
// streamModeActive := false ;
44448: LD_ADDR_EXP 91
44452: PUSH
44453: LD_INT 0
44455: ST_TO_ADDR
// normalCounter := 36 ;
44456: LD_ADDR_EXP 92
44460: PUSH
44461: LD_INT 36
44463: ST_TO_ADDR
// hardcoreCounter := 16 ;
44464: LD_ADDR_EXP 93
44468: PUSH
44469: LD_INT 16
44471: ST_TO_ADDR
// sRocket := false ;
44472: LD_ADDR_EXP 96
44476: PUSH
44477: LD_INT 0
44479: ST_TO_ADDR
// sSpeed := false ;
44480: LD_ADDR_EXP 95
44484: PUSH
44485: LD_INT 0
44487: ST_TO_ADDR
// sEngine := false ;
44488: LD_ADDR_EXP 97
44492: PUSH
44493: LD_INT 0
44495: ST_TO_ADDR
// sSpec := false ;
44496: LD_ADDR_EXP 94
44500: PUSH
44501: LD_INT 0
44503: ST_TO_ADDR
// sLevel := false ;
44504: LD_ADDR_EXP 98
44508: PUSH
44509: LD_INT 0
44511: ST_TO_ADDR
// sArmoury := false ;
44512: LD_ADDR_EXP 99
44516: PUSH
44517: LD_INT 0
44519: ST_TO_ADDR
// sRadar := false ;
44520: LD_ADDR_EXP 100
44524: PUSH
44525: LD_INT 0
44527: ST_TO_ADDR
// sBunker := false ;
44528: LD_ADDR_EXP 101
44532: PUSH
44533: LD_INT 0
44535: ST_TO_ADDR
// sHack := false ;
44536: LD_ADDR_EXP 102
44540: PUSH
44541: LD_INT 0
44543: ST_TO_ADDR
// sFire := false ;
44544: LD_ADDR_EXP 103
44548: PUSH
44549: LD_INT 0
44551: ST_TO_ADDR
// sRefresh := false ;
44552: LD_ADDR_EXP 104
44556: PUSH
44557: LD_INT 0
44559: ST_TO_ADDR
// sExp := false ;
44560: LD_ADDR_EXP 105
44564: PUSH
44565: LD_INT 0
44567: ST_TO_ADDR
// sDepot := false ;
44568: LD_ADDR_EXP 106
44572: PUSH
44573: LD_INT 0
44575: ST_TO_ADDR
// sFlag := false ;
44576: LD_ADDR_EXP 107
44580: PUSH
44581: LD_INT 0
44583: ST_TO_ADDR
// sKamikadze := false ;
44584: LD_ADDR_EXP 115
44588: PUSH
44589: LD_INT 0
44591: ST_TO_ADDR
// sTroll := false ;
44592: LD_ADDR_EXP 116
44596: PUSH
44597: LD_INT 0
44599: ST_TO_ADDR
// sSlow := false ;
44600: LD_ADDR_EXP 117
44604: PUSH
44605: LD_INT 0
44607: ST_TO_ADDR
// sLack := false ;
44608: LD_ADDR_EXP 118
44612: PUSH
44613: LD_INT 0
44615: ST_TO_ADDR
// sTank := false ;
44616: LD_ADDR_EXP 120
44620: PUSH
44621: LD_INT 0
44623: ST_TO_ADDR
// sRemote := false ;
44624: LD_ADDR_EXP 121
44628: PUSH
44629: LD_INT 0
44631: ST_TO_ADDR
// sPowell := false ;
44632: LD_ADDR_EXP 122
44636: PUSH
44637: LD_INT 0
44639: ST_TO_ADDR
// sTeleport := false ;
44640: LD_ADDR_EXP 125
44644: PUSH
44645: LD_INT 0
44647: ST_TO_ADDR
// sOilTower := false ;
44648: LD_ADDR_EXP 127
44652: PUSH
44653: LD_INT 0
44655: ST_TO_ADDR
// sShovel := false ;
44656: LD_ADDR_EXP 128
44660: PUSH
44661: LD_INT 0
44663: ST_TO_ADDR
// sSheik := false ;
44664: LD_ADDR_EXP 129
44668: PUSH
44669: LD_INT 0
44671: ST_TO_ADDR
// sEarthquake := false ;
44672: LD_ADDR_EXP 131
44676: PUSH
44677: LD_INT 0
44679: ST_TO_ADDR
// sAI := false ;
44680: LD_ADDR_EXP 132
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sCargo := false ;
44688: LD_ADDR_EXP 135
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sDLaser := false ;
44696: LD_ADDR_EXP 136
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sExchange := false ;
44704: LD_ADDR_EXP 137
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sFac := false ;
44712: LD_ADDR_EXP 138
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sPower := false ;
44720: LD_ADDR_EXP 139
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sRandom := false ;
44728: LD_ADDR_EXP 140
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sShield := false ;
44736: LD_ADDR_EXP 141
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sTime := false ;
44744: LD_ADDR_EXP 142
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sTools := false ;
44752: LD_ADDR_EXP 143
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sSold := false ;
44760: LD_ADDR_EXP 108
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sDiff := false ;
44768: LD_ADDR_EXP 109
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sFog := false ;
44776: LD_ADDR_EXP 112
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sReset := false ;
44784: LD_ADDR_EXP 113
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sSun := false ;
44792: LD_ADDR_EXP 114
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sTiger := false ;
44800: LD_ADDR_EXP 110
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sBomb := false ;
44808: LD_ADDR_EXP 111
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sWound := false ;
44816: LD_ADDR_EXP 119
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sBetray := false ;
44824: LD_ADDR_EXP 123
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sContamin := false ;
44832: LD_ADDR_EXP 124
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sOil := false ;
44840: LD_ADDR_EXP 126
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sStu := false ;
44848: LD_ADDR_EXP 130
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sBazooka := false ;
44856: LD_ADDR_EXP 133
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sMortar := false ;
44864: LD_ADDR_EXP 134
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// sRanger := false ;
44872: LD_ADDR_EXP 144
44876: PUSH
44877: LD_INT 0
44879: ST_TO_ADDR
// end ;
44880: LD_VAR 0 1
44884: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44885: LD_INT 0
44887: PPUSH
44888: PPUSH
44889: PPUSH
44890: PPUSH
44891: PPUSH
// result := [ ] ;
44892: LD_ADDR_VAR 0 1
44896: PUSH
44897: EMPTY
44898: ST_TO_ADDR
// if campaign_id = 1 then
44899: LD_OWVAR 69
44903: PUSH
44904: LD_INT 1
44906: EQUAL
44907: IFFALSE 47845
// begin case mission_number of 1 :
44909: LD_OWVAR 70
44913: PUSH
44914: LD_INT 1
44916: DOUBLE
44917: EQUAL
44918: IFTRUE 44922
44920: GO 44986
44922: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44923: LD_ADDR_VAR 0 1
44927: PUSH
44928: LD_INT 2
44930: PUSH
44931: LD_INT 4
44933: PUSH
44934: LD_INT 11
44936: PUSH
44937: LD_INT 12
44939: PUSH
44940: LD_INT 15
44942: PUSH
44943: LD_INT 16
44945: PUSH
44946: LD_INT 22
44948: PUSH
44949: LD_INT 23
44951: PUSH
44952: LD_INT 26
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 101
44968: PUSH
44969: LD_INT 102
44971: PUSH
44972: LD_INT 106
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: LIST
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: ST_TO_ADDR
44984: GO 47843
44986: LD_INT 2
44988: DOUBLE
44989: EQUAL
44990: IFTRUE 44994
44992: GO 45066
44994: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44995: LD_ADDR_VAR 0 1
44999: PUSH
45000: LD_INT 2
45002: PUSH
45003: LD_INT 4
45005: PUSH
45006: LD_INT 11
45008: PUSH
45009: LD_INT 12
45011: PUSH
45012: LD_INT 15
45014: PUSH
45015: LD_INT 16
45017: PUSH
45018: LD_INT 22
45020: PUSH
45021: LD_INT 23
45023: PUSH
45024: LD_INT 26
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 101
45040: PUSH
45041: LD_INT 102
45043: PUSH
45044: LD_INT 105
45046: PUSH
45047: LD_INT 106
45049: PUSH
45050: LD_INT 108
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: ST_TO_ADDR
45064: GO 47843
45066: LD_INT 3
45068: DOUBLE
45069: EQUAL
45070: IFTRUE 45074
45072: GO 45150
45074: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45075: LD_ADDR_VAR 0 1
45079: PUSH
45080: LD_INT 2
45082: PUSH
45083: LD_INT 4
45085: PUSH
45086: LD_INT 5
45088: PUSH
45089: LD_INT 11
45091: PUSH
45092: LD_INT 12
45094: PUSH
45095: LD_INT 15
45097: PUSH
45098: LD_INT 16
45100: PUSH
45101: LD_INT 22
45103: PUSH
45104: LD_INT 26
45106: PUSH
45107: LD_INT 36
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 101
45124: PUSH
45125: LD_INT 102
45127: PUSH
45128: LD_INT 105
45130: PUSH
45131: LD_INT 106
45133: PUSH
45134: LD_INT 108
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: ST_TO_ADDR
45148: GO 47843
45150: LD_INT 4
45152: DOUBLE
45153: EQUAL
45154: IFTRUE 45158
45156: GO 45242
45158: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45159: LD_ADDR_VAR 0 1
45163: PUSH
45164: LD_INT 2
45166: PUSH
45167: LD_INT 4
45169: PUSH
45170: LD_INT 5
45172: PUSH
45173: LD_INT 8
45175: PUSH
45176: LD_INT 11
45178: PUSH
45179: LD_INT 12
45181: PUSH
45182: LD_INT 15
45184: PUSH
45185: LD_INT 16
45187: PUSH
45188: LD_INT 22
45190: PUSH
45191: LD_INT 23
45193: PUSH
45194: LD_INT 26
45196: PUSH
45197: LD_INT 36
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 101
45216: PUSH
45217: LD_INT 102
45219: PUSH
45220: LD_INT 105
45222: PUSH
45223: LD_INT 106
45225: PUSH
45226: LD_INT 108
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: LIST
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: ST_TO_ADDR
45240: GO 47843
45242: LD_INT 5
45244: DOUBLE
45245: EQUAL
45246: IFTRUE 45250
45248: GO 45350
45250: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45251: LD_ADDR_VAR 0 1
45255: PUSH
45256: LD_INT 2
45258: PUSH
45259: LD_INT 4
45261: PUSH
45262: LD_INT 5
45264: PUSH
45265: LD_INT 6
45267: PUSH
45268: LD_INT 8
45270: PUSH
45271: LD_INT 11
45273: PUSH
45274: LD_INT 12
45276: PUSH
45277: LD_INT 15
45279: PUSH
45280: LD_INT 16
45282: PUSH
45283: LD_INT 22
45285: PUSH
45286: LD_INT 23
45288: PUSH
45289: LD_INT 25
45291: PUSH
45292: LD_INT 26
45294: PUSH
45295: LD_INT 36
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 101
45316: PUSH
45317: LD_INT 102
45319: PUSH
45320: LD_INT 105
45322: PUSH
45323: LD_INT 106
45325: PUSH
45326: LD_INT 108
45328: PUSH
45329: LD_INT 109
45331: PUSH
45332: LD_INT 112
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: ST_TO_ADDR
45348: GO 47843
45350: LD_INT 6
45352: DOUBLE
45353: EQUAL
45354: IFTRUE 45358
45356: GO 45478
45358: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45359: LD_ADDR_VAR 0 1
45363: PUSH
45364: LD_INT 2
45366: PUSH
45367: LD_INT 4
45369: PUSH
45370: LD_INT 5
45372: PUSH
45373: LD_INT 6
45375: PUSH
45376: LD_INT 8
45378: PUSH
45379: LD_INT 11
45381: PUSH
45382: LD_INT 12
45384: PUSH
45385: LD_INT 15
45387: PUSH
45388: LD_INT 16
45390: PUSH
45391: LD_INT 20
45393: PUSH
45394: LD_INT 21
45396: PUSH
45397: LD_INT 22
45399: PUSH
45400: LD_INT 23
45402: PUSH
45403: LD_INT 25
45405: PUSH
45406: LD_INT 26
45408: PUSH
45409: LD_INT 30
45411: PUSH
45412: LD_INT 31
45414: PUSH
45415: LD_INT 32
45417: PUSH
45418: LD_INT 36
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 101
45444: PUSH
45445: LD_INT 102
45447: PUSH
45448: LD_INT 105
45450: PUSH
45451: LD_INT 106
45453: PUSH
45454: LD_INT 108
45456: PUSH
45457: LD_INT 109
45459: PUSH
45460: LD_INT 112
45462: PUSH
45463: EMPTY
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: ST_TO_ADDR
45476: GO 47843
45478: LD_INT 7
45480: DOUBLE
45481: EQUAL
45482: IFTRUE 45486
45484: GO 45586
45486: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45487: LD_ADDR_VAR 0 1
45491: PUSH
45492: LD_INT 2
45494: PUSH
45495: LD_INT 4
45497: PUSH
45498: LD_INT 5
45500: PUSH
45501: LD_INT 7
45503: PUSH
45504: LD_INT 11
45506: PUSH
45507: LD_INT 12
45509: PUSH
45510: LD_INT 15
45512: PUSH
45513: LD_INT 16
45515: PUSH
45516: LD_INT 20
45518: PUSH
45519: LD_INT 21
45521: PUSH
45522: LD_INT 22
45524: PUSH
45525: LD_INT 23
45527: PUSH
45528: LD_INT 25
45530: PUSH
45531: LD_INT 26
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 101
45552: PUSH
45553: LD_INT 102
45555: PUSH
45556: LD_INT 103
45558: PUSH
45559: LD_INT 105
45561: PUSH
45562: LD_INT 106
45564: PUSH
45565: LD_INT 108
45567: PUSH
45568: LD_INT 112
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: ST_TO_ADDR
45584: GO 47843
45586: LD_INT 8
45588: DOUBLE
45589: EQUAL
45590: IFTRUE 45594
45592: GO 45722
45594: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45595: LD_ADDR_VAR 0 1
45599: PUSH
45600: LD_INT 2
45602: PUSH
45603: LD_INT 4
45605: PUSH
45606: LD_INT 5
45608: PUSH
45609: LD_INT 6
45611: PUSH
45612: LD_INT 7
45614: PUSH
45615: LD_INT 8
45617: PUSH
45618: LD_INT 11
45620: PUSH
45621: LD_INT 12
45623: PUSH
45624: LD_INT 15
45626: PUSH
45627: LD_INT 16
45629: PUSH
45630: LD_INT 20
45632: PUSH
45633: LD_INT 21
45635: PUSH
45636: LD_INT 22
45638: PUSH
45639: LD_INT 23
45641: PUSH
45642: LD_INT 25
45644: PUSH
45645: LD_INT 26
45647: PUSH
45648: LD_INT 30
45650: PUSH
45651: LD_INT 31
45653: PUSH
45654: LD_INT 32
45656: PUSH
45657: LD_INT 36
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: PUSH
45682: LD_INT 101
45684: PUSH
45685: LD_INT 102
45687: PUSH
45688: LD_INT 103
45690: PUSH
45691: LD_INT 105
45693: PUSH
45694: LD_INT 106
45696: PUSH
45697: LD_INT 108
45699: PUSH
45700: LD_INT 109
45702: PUSH
45703: LD_INT 112
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: ST_TO_ADDR
45720: GO 47843
45722: LD_INT 9
45724: DOUBLE
45725: EQUAL
45726: IFTRUE 45730
45728: GO 45866
45730: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45731: LD_ADDR_VAR 0 1
45735: PUSH
45736: LD_INT 2
45738: PUSH
45739: LD_INT 4
45741: PUSH
45742: LD_INT 5
45744: PUSH
45745: LD_INT 6
45747: PUSH
45748: LD_INT 7
45750: PUSH
45751: LD_INT 8
45753: PUSH
45754: LD_INT 11
45756: PUSH
45757: LD_INT 12
45759: PUSH
45760: LD_INT 15
45762: PUSH
45763: LD_INT 16
45765: PUSH
45766: LD_INT 20
45768: PUSH
45769: LD_INT 21
45771: PUSH
45772: LD_INT 22
45774: PUSH
45775: LD_INT 23
45777: PUSH
45778: LD_INT 25
45780: PUSH
45781: LD_INT 26
45783: PUSH
45784: LD_INT 28
45786: PUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 31
45792: PUSH
45793: LD_INT 32
45795: PUSH
45796: LD_INT 36
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 101
45824: PUSH
45825: LD_INT 102
45827: PUSH
45828: LD_INT 103
45830: PUSH
45831: LD_INT 105
45833: PUSH
45834: LD_INT 106
45836: PUSH
45837: LD_INT 108
45839: PUSH
45840: LD_INT 109
45842: PUSH
45843: LD_INT 112
45845: PUSH
45846: LD_INT 114
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: ST_TO_ADDR
45864: GO 47843
45866: LD_INT 10
45868: DOUBLE
45869: EQUAL
45870: IFTRUE 45874
45872: GO 46058
45874: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45875: LD_ADDR_VAR 0 1
45879: PUSH
45880: LD_INT 2
45882: PUSH
45883: LD_INT 4
45885: PUSH
45886: LD_INT 5
45888: PUSH
45889: LD_INT 6
45891: PUSH
45892: LD_INT 7
45894: PUSH
45895: LD_INT 8
45897: PUSH
45898: LD_INT 9
45900: PUSH
45901: LD_INT 10
45903: PUSH
45904: LD_INT 11
45906: PUSH
45907: LD_INT 12
45909: PUSH
45910: LD_INT 13
45912: PUSH
45913: LD_INT 14
45915: PUSH
45916: LD_INT 15
45918: PUSH
45919: LD_INT 16
45921: PUSH
45922: LD_INT 17
45924: PUSH
45925: LD_INT 18
45927: PUSH
45928: LD_INT 19
45930: PUSH
45931: LD_INT 20
45933: PUSH
45934: LD_INT 21
45936: PUSH
45937: LD_INT 22
45939: PUSH
45940: LD_INT 23
45942: PUSH
45943: LD_INT 24
45945: PUSH
45946: LD_INT 25
45948: PUSH
45949: LD_INT 26
45951: PUSH
45952: LD_INT 28
45954: PUSH
45955: LD_INT 30
45957: PUSH
45958: LD_INT 31
45960: PUSH
45961: LD_INT 32
45963: PUSH
45964: LD_INT 36
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 101
46000: PUSH
46001: LD_INT 102
46003: PUSH
46004: LD_INT 103
46006: PUSH
46007: LD_INT 104
46009: PUSH
46010: LD_INT 105
46012: PUSH
46013: LD_INT 106
46015: PUSH
46016: LD_INT 107
46018: PUSH
46019: LD_INT 108
46021: PUSH
46022: LD_INT 109
46024: PUSH
46025: LD_INT 110
46027: PUSH
46028: LD_INT 111
46030: PUSH
46031: LD_INT 112
46033: PUSH
46034: LD_INT 114
46036: PUSH
46037: EMPTY
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: ST_TO_ADDR
46056: GO 47843
46058: LD_INT 11
46060: DOUBLE
46061: EQUAL
46062: IFTRUE 46066
46064: GO 46258
46066: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46067: LD_ADDR_VAR 0 1
46071: PUSH
46072: LD_INT 2
46074: PUSH
46075: LD_INT 3
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: LD_INT 5
46083: PUSH
46084: LD_INT 6
46086: PUSH
46087: LD_INT 7
46089: PUSH
46090: LD_INT 8
46092: PUSH
46093: LD_INT 9
46095: PUSH
46096: LD_INT 10
46098: PUSH
46099: LD_INT 11
46101: PUSH
46102: LD_INT 12
46104: PUSH
46105: LD_INT 13
46107: PUSH
46108: LD_INT 14
46110: PUSH
46111: LD_INT 15
46113: PUSH
46114: LD_INT 16
46116: PUSH
46117: LD_INT 17
46119: PUSH
46120: LD_INT 18
46122: PUSH
46123: LD_INT 19
46125: PUSH
46126: LD_INT 20
46128: PUSH
46129: LD_INT 21
46131: PUSH
46132: LD_INT 22
46134: PUSH
46135: LD_INT 23
46137: PUSH
46138: LD_INT 24
46140: PUSH
46141: LD_INT 25
46143: PUSH
46144: LD_INT 26
46146: PUSH
46147: LD_INT 28
46149: PUSH
46150: LD_INT 30
46152: PUSH
46153: LD_INT 31
46155: PUSH
46156: LD_INT 32
46158: PUSH
46159: LD_INT 34
46161: PUSH
46162: LD_INT 36
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 101
46200: PUSH
46201: LD_INT 102
46203: PUSH
46204: LD_INT 103
46206: PUSH
46207: LD_INT 104
46209: PUSH
46210: LD_INT 105
46212: PUSH
46213: LD_INT 106
46215: PUSH
46216: LD_INT 107
46218: PUSH
46219: LD_INT 108
46221: PUSH
46222: LD_INT 109
46224: PUSH
46225: LD_INT 110
46227: PUSH
46228: LD_INT 111
46230: PUSH
46231: LD_INT 112
46233: PUSH
46234: LD_INT 114
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: ST_TO_ADDR
46256: GO 47843
46258: LD_INT 12
46260: DOUBLE
46261: EQUAL
46262: IFTRUE 46266
46264: GO 46474
46266: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46267: LD_ADDR_VAR 0 1
46271: PUSH
46272: LD_INT 1
46274: PUSH
46275: LD_INT 2
46277: PUSH
46278: LD_INT 3
46280: PUSH
46281: LD_INT 4
46283: PUSH
46284: LD_INT 5
46286: PUSH
46287: LD_INT 6
46289: PUSH
46290: LD_INT 7
46292: PUSH
46293: LD_INT 8
46295: PUSH
46296: LD_INT 9
46298: PUSH
46299: LD_INT 10
46301: PUSH
46302: LD_INT 11
46304: PUSH
46305: LD_INT 12
46307: PUSH
46308: LD_INT 13
46310: PUSH
46311: LD_INT 14
46313: PUSH
46314: LD_INT 15
46316: PUSH
46317: LD_INT 16
46319: PUSH
46320: LD_INT 17
46322: PUSH
46323: LD_INT 18
46325: PUSH
46326: LD_INT 19
46328: PUSH
46329: LD_INT 20
46331: PUSH
46332: LD_INT 21
46334: PUSH
46335: LD_INT 22
46337: PUSH
46338: LD_INT 23
46340: PUSH
46341: LD_INT 24
46343: PUSH
46344: LD_INT 25
46346: PUSH
46347: LD_INT 26
46349: PUSH
46350: LD_INT 27
46352: PUSH
46353: LD_INT 28
46355: PUSH
46356: LD_INT 30
46358: PUSH
46359: LD_INT 31
46361: PUSH
46362: LD_INT 32
46364: PUSH
46365: LD_INT 33
46367: PUSH
46368: LD_INT 34
46370: PUSH
46371: LD_INT 36
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: PUSH
46410: LD_INT 101
46412: PUSH
46413: LD_INT 102
46415: PUSH
46416: LD_INT 103
46418: PUSH
46419: LD_INT 104
46421: PUSH
46422: LD_INT 105
46424: PUSH
46425: LD_INT 106
46427: PUSH
46428: LD_INT 107
46430: PUSH
46431: LD_INT 108
46433: PUSH
46434: LD_INT 109
46436: PUSH
46437: LD_INT 110
46439: PUSH
46440: LD_INT 111
46442: PUSH
46443: LD_INT 112
46445: PUSH
46446: LD_INT 113
46448: PUSH
46449: LD_INT 114
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: ST_TO_ADDR
46472: GO 47843
46474: LD_INT 13
46476: DOUBLE
46477: EQUAL
46478: IFTRUE 46482
46480: GO 46678
46482: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46483: LD_ADDR_VAR 0 1
46487: PUSH
46488: LD_INT 1
46490: PUSH
46491: LD_INT 2
46493: PUSH
46494: LD_INT 3
46496: PUSH
46497: LD_INT 4
46499: PUSH
46500: LD_INT 5
46502: PUSH
46503: LD_INT 8
46505: PUSH
46506: LD_INT 9
46508: PUSH
46509: LD_INT 10
46511: PUSH
46512: LD_INT 11
46514: PUSH
46515: LD_INT 12
46517: PUSH
46518: LD_INT 14
46520: PUSH
46521: LD_INT 15
46523: PUSH
46524: LD_INT 16
46526: PUSH
46527: LD_INT 17
46529: PUSH
46530: LD_INT 18
46532: PUSH
46533: LD_INT 19
46535: PUSH
46536: LD_INT 20
46538: PUSH
46539: LD_INT 21
46541: PUSH
46542: LD_INT 22
46544: PUSH
46545: LD_INT 23
46547: PUSH
46548: LD_INT 24
46550: PUSH
46551: LD_INT 25
46553: PUSH
46554: LD_INT 26
46556: PUSH
46557: LD_INT 27
46559: PUSH
46560: LD_INT 28
46562: PUSH
46563: LD_INT 30
46565: PUSH
46566: LD_INT 31
46568: PUSH
46569: LD_INT 32
46571: PUSH
46572: LD_INT 33
46574: PUSH
46575: LD_INT 34
46577: PUSH
46578: LD_INT 36
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: PUSH
46614: LD_INT 101
46616: PUSH
46617: LD_INT 102
46619: PUSH
46620: LD_INT 103
46622: PUSH
46623: LD_INT 104
46625: PUSH
46626: LD_INT 105
46628: PUSH
46629: LD_INT 106
46631: PUSH
46632: LD_INT 107
46634: PUSH
46635: LD_INT 108
46637: PUSH
46638: LD_INT 109
46640: PUSH
46641: LD_INT 110
46643: PUSH
46644: LD_INT 111
46646: PUSH
46647: LD_INT 112
46649: PUSH
46650: LD_INT 113
46652: PUSH
46653: LD_INT 114
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: ST_TO_ADDR
46676: GO 47843
46678: LD_INT 14
46680: DOUBLE
46681: EQUAL
46682: IFTRUE 46686
46684: GO 46898
46686: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46687: LD_ADDR_VAR 0 1
46691: PUSH
46692: LD_INT 1
46694: PUSH
46695: LD_INT 2
46697: PUSH
46698: LD_INT 3
46700: PUSH
46701: LD_INT 4
46703: PUSH
46704: LD_INT 5
46706: PUSH
46707: LD_INT 6
46709: PUSH
46710: LD_INT 7
46712: PUSH
46713: LD_INT 8
46715: PUSH
46716: LD_INT 9
46718: PUSH
46719: LD_INT 10
46721: PUSH
46722: LD_INT 11
46724: PUSH
46725: LD_INT 12
46727: PUSH
46728: LD_INT 13
46730: PUSH
46731: LD_INT 14
46733: PUSH
46734: LD_INT 15
46736: PUSH
46737: LD_INT 16
46739: PUSH
46740: LD_INT 17
46742: PUSH
46743: LD_INT 18
46745: PUSH
46746: LD_INT 19
46748: PUSH
46749: LD_INT 20
46751: PUSH
46752: LD_INT 21
46754: PUSH
46755: LD_INT 22
46757: PUSH
46758: LD_INT 23
46760: PUSH
46761: LD_INT 24
46763: PUSH
46764: LD_INT 25
46766: PUSH
46767: LD_INT 26
46769: PUSH
46770: LD_INT 27
46772: PUSH
46773: LD_INT 28
46775: PUSH
46776: LD_INT 29
46778: PUSH
46779: LD_INT 30
46781: PUSH
46782: LD_INT 31
46784: PUSH
46785: LD_INT 32
46787: PUSH
46788: LD_INT 33
46790: PUSH
46791: LD_INT 34
46793: PUSH
46794: LD_INT 36
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 101
46836: PUSH
46837: LD_INT 102
46839: PUSH
46840: LD_INT 103
46842: PUSH
46843: LD_INT 104
46845: PUSH
46846: LD_INT 105
46848: PUSH
46849: LD_INT 106
46851: PUSH
46852: LD_INT 107
46854: PUSH
46855: LD_INT 108
46857: PUSH
46858: LD_INT 109
46860: PUSH
46861: LD_INT 110
46863: PUSH
46864: LD_INT 111
46866: PUSH
46867: LD_INT 112
46869: PUSH
46870: LD_INT 113
46872: PUSH
46873: LD_INT 114
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: ST_TO_ADDR
46896: GO 47843
46898: LD_INT 15
46900: DOUBLE
46901: EQUAL
46902: IFTRUE 46906
46904: GO 47118
46906: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46907: LD_ADDR_VAR 0 1
46911: PUSH
46912: LD_INT 1
46914: PUSH
46915: LD_INT 2
46917: PUSH
46918: LD_INT 3
46920: PUSH
46921: LD_INT 4
46923: PUSH
46924: LD_INT 5
46926: PUSH
46927: LD_INT 6
46929: PUSH
46930: LD_INT 7
46932: PUSH
46933: LD_INT 8
46935: PUSH
46936: LD_INT 9
46938: PUSH
46939: LD_INT 10
46941: PUSH
46942: LD_INT 11
46944: PUSH
46945: LD_INT 12
46947: PUSH
46948: LD_INT 13
46950: PUSH
46951: LD_INT 14
46953: PUSH
46954: LD_INT 15
46956: PUSH
46957: LD_INT 16
46959: PUSH
46960: LD_INT 17
46962: PUSH
46963: LD_INT 18
46965: PUSH
46966: LD_INT 19
46968: PUSH
46969: LD_INT 20
46971: PUSH
46972: LD_INT 21
46974: PUSH
46975: LD_INT 22
46977: PUSH
46978: LD_INT 23
46980: PUSH
46981: LD_INT 24
46983: PUSH
46984: LD_INT 25
46986: PUSH
46987: LD_INT 26
46989: PUSH
46990: LD_INT 27
46992: PUSH
46993: LD_INT 28
46995: PUSH
46996: LD_INT 29
46998: PUSH
46999: LD_INT 30
47001: PUSH
47002: LD_INT 31
47004: PUSH
47005: LD_INT 32
47007: PUSH
47008: LD_INT 33
47010: PUSH
47011: LD_INT 34
47013: PUSH
47014: LD_INT 36
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 101
47056: PUSH
47057: LD_INT 102
47059: PUSH
47060: LD_INT 103
47062: PUSH
47063: LD_INT 104
47065: PUSH
47066: LD_INT 105
47068: PUSH
47069: LD_INT 106
47071: PUSH
47072: LD_INT 107
47074: PUSH
47075: LD_INT 108
47077: PUSH
47078: LD_INT 109
47080: PUSH
47081: LD_INT 110
47083: PUSH
47084: LD_INT 111
47086: PUSH
47087: LD_INT 112
47089: PUSH
47090: LD_INT 113
47092: PUSH
47093: LD_INT 114
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: ST_TO_ADDR
47116: GO 47843
47118: LD_INT 16
47120: DOUBLE
47121: EQUAL
47122: IFTRUE 47126
47124: GO 47250
47126: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47127: LD_ADDR_VAR 0 1
47131: PUSH
47132: LD_INT 2
47134: PUSH
47135: LD_INT 4
47137: PUSH
47138: LD_INT 5
47140: PUSH
47141: LD_INT 7
47143: PUSH
47144: LD_INT 11
47146: PUSH
47147: LD_INT 12
47149: PUSH
47150: LD_INT 15
47152: PUSH
47153: LD_INT 16
47155: PUSH
47156: LD_INT 20
47158: PUSH
47159: LD_INT 21
47161: PUSH
47162: LD_INT 22
47164: PUSH
47165: LD_INT 23
47167: PUSH
47168: LD_INT 25
47170: PUSH
47171: LD_INT 26
47173: PUSH
47174: LD_INT 30
47176: PUSH
47177: LD_INT 31
47179: PUSH
47180: LD_INT 32
47182: PUSH
47183: LD_INT 33
47185: PUSH
47186: LD_INT 34
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: PUSH
47210: LD_INT 101
47212: PUSH
47213: LD_INT 102
47215: PUSH
47216: LD_INT 103
47218: PUSH
47219: LD_INT 106
47221: PUSH
47222: LD_INT 108
47224: PUSH
47225: LD_INT 112
47227: PUSH
47228: LD_INT 113
47230: PUSH
47231: LD_INT 114
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: LIST
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: ST_TO_ADDR
47248: GO 47843
47250: LD_INT 17
47252: DOUBLE
47253: EQUAL
47254: IFTRUE 47258
47256: GO 47470
47258: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47259: LD_ADDR_VAR 0 1
47263: PUSH
47264: LD_INT 1
47266: PUSH
47267: LD_INT 2
47269: PUSH
47270: LD_INT 3
47272: PUSH
47273: LD_INT 4
47275: PUSH
47276: LD_INT 5
47278: PUSH
47279: LD_INT 6
47281: PUSH
47282: LD_INT 7
47284: PUSH
47285: LD_INT 8
47287: PUSH
47288: LD_INT 9
47290: PUSH
47291: LD_INT 10
47293: PUSH
47294: LD_INT 11
47296: PUSH
47297: LD_INT 12
47299: PUSH
47300: LD_INT 13
47302: PUSH
47303: LD_INT 14
47305: PUSH
47306: LD_INT 15
47308: PUSH
47309: LD_INT 16
47311: PUSH
47312: LD_INT 17
47314: PUSH
47315: LD_INT 18
47317: PUSH
47318: LD_INT 19
47320: PUSH
47321: LD_INT 20
47323: PUSH
47324: LD_INT 21
47326: PUSH
47327: LD_INT 22
47329: PUSH
47330: LD_INT 23
47332: PUSH
47333: LD_INT 24
47335: PUSH
47336: LD_INT 25
47338: PUSH
47339: LD_INT 26
47341: PUSH
47342: LD_INT 27
47344: PUSH
47345: LD_INT 28
47347: PUSH
47348: LD_INT 29
47350: PUSH
47351: LD_INT 30
47353: PUSH
47354: LD_INT 31
47356: PUSH
47357: LD_INT 32
47359: PUSH
47360: LD_INT 33
47362: PUSH
47363: LD_INT 34
47365: PUSH
47366: LD_INT 36
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: PUSH
47406: LD_INT 101
47408: PUSH
47409: LD_INT 102
47411: PUSH
47412: LD_INT 103
47414: PUSH
47415: LD_INT 104
47417: PUSH
47418: LD_INT 105
47420: PUSH
47421: LD_INT 106
47423: PUSH
47424: LD_INT 107
47426: PUSH
47427: LD_INT 108
47429: PUSH
47430: LD_INT 109
47432: PUSH
47433: LD_INT 110
47435: PUSH
47436: LD_INT 111
47438: PUSH
47439: LD_INT 112
47441: PUSH
47442: LD_INT 113
47444: PUSH
47445: LD_INT 114
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: ST_TO_ADDR
47468: GO 47843
47470: LD_INT 18
47472: DOUBLE
47473: EQUAL
47474: IFTRUE 47478
47476: GO 47614
47478: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47479: LD_ADDR_VAR 0 1
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: LD_INT 4
47489: PUSH
47490: LD_INT 5
47492: PUSH
47493: LD_INT 7
47495: PUSH
47496: LD_INT 11
47498: PUSH
47499: LD_INT 12
47501: PUSH
47502: LD_INT 15
47504: PUSH
47505: LD_INT 16
47507: PUSH
47508: LD_INT 20
47510: PUSH
47511: LD_INT 21
47513: PUSH
47514: LD_INT 22
47516: PUSH
47517: LD_INT 23
47519: PUSH
47520: LD_INT 25
47522: PUSH
47523: LD_INT 26
47525: PUSH
47526: LD_INT 30
47528: PUSH
47529: LD_INT 31
47531: PUSH
47532: LD_INT 32
47534: PUSH
47535: LD_INT 33
47537: PUSH
47538: LD_INT 34
47540: PUSH
47541: LD_INT 35
47543: PUSH
47544: LD_INT 36
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 101
47572: PUSH
47573: LD_INT 102
47575: PUSH
47576: LD_INT 103
47578: PUSH
47579: LD_INT 106
47581: PUSH
47582: LD_INT 108
47584: PUSH
47585: LD_INT 112
47587: PUSH
47588: LD_INT 113
47590: PUSH
47591: LD_INT 114
47593: PUSH
47594: LD_INT 115
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: ST_TO_ADDR
47612: GO 47843
47614: LD_INT 19
47616: DOUBLE
47617: EQUAL
47618: IFTRUE 47622
47620: GO 47842
47622: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47623: LD_ADDR_VAR 0 1
47627: PUSH
47628: LD_INT 1
47630: PUSH
47631: LD_INT 2
47633: PUSH
47634: LD_INT 3
47636: PUSH
47637: LD_INT 4
47639: PUSH
47640: LD_INT 5
47642: PUSH
47643: LD_INT 6
47645: PUSH
47646: LD_INT 7
47648: PUSH
47649: LD_INT 8
47651: PUSH
47652: LD_INT 9
47654: PUSH
47655: LD_INT 10
47657: PUSH
47658: LD_INT 11
47660: PUSH
47661: LD_INT 12
47663: PUSH
47664: LD_INT 13
47666: PUSH
47667: LD_INT 14
47669: PUSH
47670: LD_INT 15
47672: PUSH
47673: LD_INT 16
47675: PUSH
47676: LD_INT 17
47678: PUSH
47679: LD_INT 18
47681: PUSH
47682: LD_INT 19
47684: PUSH
47685: LD_INT 20
47687: PUSH
47688: LD_INT 21
47690: PUSH
47691: LD_INT 22
47693: PUSH
47694: LD_INT 23
47696: PUSH
47697: LD_INT 24
47699: PUSH
47700: LD_INT 25
47702: PUSH
47703: LD_INT 26
47705: PUSH
47706: LD_INT 27
47708: PUSH
47709: LD_INT 28
47711: PUSH
47712: LD_INT 29
47714: PUSH
47715: LD_INT 30
47717: PUSH
47718: LD_INT 31
47720: PUSH
47721: LD_INT 32
47723: PUSH
47724: LD_INT 33
47726: PUSH
47727: LD_INT 34
47729: PUSH
47730: LD_INT 35
47732: PUSH
47733: LD_INT 36
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 101
47776: PUSH
47777: LD_INT 102
47779: PUSH
47780: LD_INT 103
47782: PUSH
47783: LD_INT 104
47785: PUSH
47786: LD_INT 105
47788: PUSH
47789: LD_INT 106
47791: PUSH
47792: LD_INT 107
47794: PUSH
47795: LD_INT 108
47797: PUSH
47798: LD_INT 109
47800: PUSH
47801: LD_INT 110
47803: PUSH
47804: LD_INT 111
47806: PUSH
47807: LD_INT 112
47809: PUSH
47810: LD_INT 113
47812: PUSH
47813: LD_INT 114
47815: PUSH
47816: LD_INT 115
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: ST_TO_ADDR
47840: GO 47843
47842: POP
// end else
47843: GO 48062
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47845: LD_ADDR_VAR 0 1
47849: PUSH
47850: LD_INT 1
47852: PUSH
47853: LD_INT 2
47855: PUSH
47856: LD_INT 3
47858: PUSH
47859: LD_INT 4
47861: PUSH
47862: LD_INT 5
47864: PUSH
47865: LD_INT 6
47867: PUSH
47868: LD_INT 7
47870: PUSH
47871: LD_INT 8
47873: PUSH
47874: LD_INT 9
47876: PUSH
47877: LD_INT 10
47879: PUSH
47880: LD_INT 11
47882: PUSH
47883: LD_INT 12
47885: PUSH
47886: LD_INT 13
47888: PUSH
47889: LD_INT 14
47891: PUSH
47892: LD_INT 15
47894: PUSH
47895: LD_INT 16
47897: PUSH
47898: LD_INT 17
47900: PUSH
47901: LD_INT 18
47903: PUSH
47904: LD_INT 19
47906: PUSH
47907: LD_INT 20
47909: PUSH
47910: LD_INT 21
47912: PUSH
47913: LD_INT 22
47915: PUSH
47916: LD_INT 23
47918: PUSH
47919: LD_INT 24
47921: PUSH
47922: LD_INT 25
47924: PUSH
47925: LD_INT 26
47927: PUSH
47928: LD_INT 27
47930: PUSH
47931: LD_INT 28
47933: PUSH
47934: LD_INT 29
47936: PUSH
47937: LD_INT 30
47939: PUSH
47940: LD_INT 31
47942: PUSH
47943: LD_INT 32
47945: PUSH
47946: LD_INT 33
47948: PUSH
47949: LD_INT 34
47951: PUSH
47952: LD_INT 35
47954: PUSH
47955: LD_INT 36
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: PUSH
47996: LD_INT 101
47998: PUSH
47999: LD_INT 102
48001: PUSH
48002: LD_INT 103
48004: PUSH
48005: LD_INT 104
48007: PUSH
48008: LD_INT 105
48010: PUSH
48011: LD_INT 106
48013: PUSH
48014: LD_INT 107
48016: PUSH
48017: LD_INT 108
48019: PUSH
48020: LD_INT 109
48022: PUSH
48023: LD_INT 110
48025: PUSH
48026: LD_INT 111
48028: PUSH
48029: LD_INT 112
48031: PUSH
48032: LD_INT 113
48034: PUSH
48035: LD_INT 114
48037: PUSH
48038: LD_INT 115
48040: PUSH
48041: EMPTY
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: ST_TO_ADDR
// if result then
48062: LD_VAR 0 1
48066: IFFALSE 48355
// begin normal :=  ;
48068: LD_ADDR_VAR 0 3
48072: PUSH
48073: LD_STRING 
48075: ST_TO_ADDR
// hardcore :=  ;
48076: LD_ADDR_VAR 0 4
48080: PUSH
48081: LD_STRING 
48083: ST_TO_ADDR
// for i = 1 to normalCounter do
48084: LD_ADDR_VAR 0 5
48088: PUSH
48089: DOUBLE
48090: LD_INT 1
48092: DEC
48093: ST_TO_ADDR
48094: LD_EXP 92
48098: PUSH
48099: FOR_TO
48100: IFFALSE 48201
// begin tmp := 0 ;
48102: LD_ADDR_VAR 0 2
48106: PUSH
48107: LD_STRING 0
48109: ST_TO_ADDR
// if result [ 1 ] then
48110: LD_VAR 0 1
48114: PUSH
48115: LD_INT 1
48117: ARRAY
48118: IFFALSE 48183
// if result [ 1 ] [ 1 ] = i then
48120: LD_VAR 0 1
48124: PUSH
48125: LD_INT 1
48127: ARRAY
48128: PUSH
48129: LD_INT 1
48131: ARRAY
48132: PUSH
48133: LD_VAR 0 5
48137: EQUAL
48138: IFFALSE 48183
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48140: LD_ADDR_VAR 0 1
48144: PUSH
48145: LD_VAR 0 1
48149: PPUSH
48150: LD_INT 1
48152: PPUSH
48153: LD_VAR 0 1
48157: PUSH
48158: LD_INT 1
48160: ARRAY
48161: PPUSH
48162: LD_INT 1
48164: PPUSH
48165: CALL_OW 3
48169: PPUSH
48170: CALL_OW 1
48174: ST_TO_ADDR
// tmp := 1 ;
48175: LD_ADDR_VAR 0 2
48179: PUSH
48180: LD_STRING 1
48182: ST_TO_ADDR
// end ; normal := normal & tmp ;
48183: LD_ADDR_VAR 0 3
48187: PUSH
48188: LD_VAR 0 3
48192: PUSH
48193: LD_VAR 0 2
48197: STR
48198: ST_TO_ADDR
// end ;
48199: GO 48099
48201: POP
48202: POP
// for i = 1 to hardcoreCounter do
48203: LD_ADDR_VAR 0 5
48207: PUSH
48208: DOUBLE
48209: LD_INT 1
48211: DEC
48212: ST_TO_ADDR
48213: LD_EXP 93
48217: PUSH
48218: FOR_TO
48219: IFFALSE 48324
// begin tmp := 0 ;
48221: LD_ADDR_VAR 0 2
48225: PUSH
48226: LD_STRING 0
48228: ST_TO_ADDR
// if result [ 2 ] then
48229: LD_VAR 0 1
48233: PUSH
48234: LD_INT 2
48236: ARRAY
48237: IFFALSE 48306
// if result [ 2 ] [ 1 ] = 100 + i then
48239: LD_VAR 0 1
48243: PUSH
48244: LD_INT 2
48246: ARRAY
48247: PUSH
48248: LD_INT 1
48250: ARRAY
48251: PUSH
48252: LD_INT 100
48254: PUSH
48255: LD_VAR 0 5
48259: PLUS
48260: EQUAL
48261: IFFALSE 48306
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48263: LD_ADDR_VAR 0 1
48267: PUSH
48268: LD_VAR 0 1
48272: PPUSH
48273: LD_INT 2
48275: PPUSH
48276: LD_VAR 0 1
48280: PUSH
48281: LD_INT 2
48283: ARRAY
48284: PPUSH
48285: LD_INT 1
48287: PPUSH
48288: CALL_OW 3
48292: PPUSH
48293: CALL_OW 1
48297: ST_TO_ADDR
// tmp := 1 ;
48298: LD_ADDR_VAR 0 2
48302: PUSH
48303: LD_STRING 1
48305: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48306: LD_ADDR_VAR 0 4
48310: PUSH
48311: LD_VAR 0 4
48315: PUSH
48316: LD_VAR 0 2
48320: STR
48321: ST_TO_ADDR
// end ;
48322: GO 48218
48324: POP
48325: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48326: LD_STRING getStreamItemsFromMission("
48328: PUSH
48329: LD_VAR 0 3
48333: STR
48334: PUSH
48335: LD_STRING ","
48337: STR
48338: PUSH
48339: LD_VAR 0 4
48343: STR
48344: PUSH
48345: LD_STRING ")
48347: STR
48348: PPUSH
48349: CALL_OW 559
// end else
48353: GO 48362
// ToLua ( getStreamItemsFromMission("","") ) ;
48355: LD_STRING getStreamItemsFromMission("","")
48357: PPUSH
48358: CALL_OW 559
// end ;
48362: LD_VAR 0 1
48366: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48367: LD_EXP 91
48371: PUSH
48372: LD_EXP 96
48376: AND
48377: IFFALSE 48501
48379: GO 48381
48381: DISABLE
48382: LD_INT 0
48384: PPUSH
48385: PPUSH
// begin enable ;
48386: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48387: LD_ADDR_VAR 0 2
48391: PUSH
48392: LD_INT 22
48394: PUSH
48395: LD_OWVAR 2
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: LD_INT 2
48406: PUSH
48407: LD_INT 34
48409: PUSH
48410: LD_INT 7
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: PUSH
48417: LD_INT 34
48419: PUSH
48420: LD_INT 45
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: PUSH
48427: LD_INT 34
48429: PUSH
48430: LD_INT 28
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: PUSH
48437: LD_INT 34
48439: PUSH
48440: LD_INT 47
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PPUSH
48458: CALL_OW 69
48462: ST_TO_ADDR
// if not tmp then
48463: LD_VAR 0 2
48467: NOT
48468: IFFALSE 48472
// exit ;
48470: GO 48501
// for i in tmp do
48472: LD_ADDR_VAR 0 1
48476: PUSH
48477: LD_VAR 0 2
48481: PUSH
48482: FOR_IN
48483: IFFALSE 48499
// begin SetLives ( i , 0 ) ;
48485: LD_VAR 0 1
48489: PPUSH
48490: LD_INT 0
48492: PPUSH
48493: CALL_OW 234
// end ;
48497: GO 48482
48499: POP
48500: POP
// end ;
48501: PPOPN 2
48503: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48504: LD_EXP 91
48508: PUSH
48509: LD_EXP 97
48513: AND
48514: IFFALSE 48598
48516: GO 48518
48518: DISABLE
48519: LD_INT 0
48521: PPUSH
48522: PPUSH
// begin enable ;
48523: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48524: LD_ADDR_VAR 0 2
48528: PUSH
48529: LD_INT 22
48531: PUSH
48532: LD_OWVAR 2
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 32
48543: PUSH
48544: LD_INT 3
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PPUSH
48555: CALL_OW 69
48559: ST_TO_ADDR
// if not tmp then
48560: LD_VAR 0 2
48564: NOT
48565: IFFALSE 48569
// exit ;
48567: GO 48598
// for i in tmp do
48569: LD_ADDR_VAR 0 1
48573: PUSH
48574: LD_VAR 0 2
48578: PUSH
48579: FOR_IN
48580: IFFALSE 48596
// begin SetLives ( i , 0 ) ;
48582: LD_VAR 0 1
48586: PPUSH
48587: LD_INT 0
48589: PPUSH
48590: CALL_OW 234
// end ;
48594: GO 48579
48596: POP
48597: POP
// end ;
48598: PPOPN 2
48600: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48601: LD_EXP 91
48605: PUSH
48606: LD_EXP 94
48610: AND
48611: IFFALSE 48704
48613: GO 48615
48615: DISABLE
48616: LD_INT 0
48618: PPUSH
// begin enable ;
48619: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48620: LD_ADDR_VAR 0 1
48624: PUSH
48625: LD_INT 22
48627: PUSH
48628: LD_OWVAR 2
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: PUSH
48637: LD_INT 2
48639: PUSH
48640: LD_INT 25
48642: PUSH
48643: LD_INT 5
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: LD_INT 25
48652: PUSH
48653: LD_INT 9
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 25
48662: PUSH
48663: LD_INT 8
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: PUSH
48676: EMPTY
48677: LIST
48678: LIST
48679: PPUSH
48680: CALL_OW 69
48684: PUSH
48685: FOR_IN
48686: IFFALSE 48702
// begin SetClass ( i , 1 ) ;
48688: LD_VAR 0 1
48692: PPUSH
48693: LD_INT 1
48695: PPUSH
48696: CALL_OW 336
// end ;
48700: GO 48685
48702: POP
48703: POP
// end ;
48704: PPOPN 1
48706: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48707: LD_EXP 91
48711: PUSH
48712: LD_EXP 95
48716: AND
48717: PUSH
48718: LD_OWVAR 65
48722: PUSH
48723: LD_INT 7
48725: LESS
48726: AND
48727: IFFALSE 48741
48729: GO 48731
48731: DISABLE
// begin enable ;
48732: ENABLE
// game_speed := 7 ;
48733: LD_ADDR_OWVAR 65
48737: PUSH
48738: LD_INT 7
48740: ST_TO_ADDR
// end ;
48741: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48742: LD_EXP 91
48746: PUSH
48747: LD_EXP 98
48751: AND
48752: IFFALSE 48954
48754: GO 48756
48756: DISABLE
48757: LD_INT 0
48759: PPUSH
48760: PPUSH
48761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48762: LD_ADDR_VAR 0 3
48766: PUSH
48767: LD_INT 81
48769: PUSH
48770: LD_OWVAR 2
48774: PUSH
48775: EMPTY
48776: LIST
48777: LIST
48778: PUSH
48779: LD_INT 21
48781: PUSH
48782: LD_INT 1
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PPUSH
48793: CALL_OW 69
48797: ST_TO_ADDR
// if not tmp then
48798: LD_VAR 0 3
48802: NOT
48803: IFFALSE 48807
// exit ;
48805: GO 48954
// if tmp > 5 then
48807: LD_VAR 0 3
48811: PUSH
48812: LD_INT 5
48814: GREATER
48815: IFFALSE 48827
// k := 5 else
48817: LD_ADDR_VAR 0 2
48821: PUSH
48822: LD_INT 5
48824: ST_TO_ADDR
48825: GO 48837
// k := tmp ;
48827: LD_ADDR_VAR 0 2
48831: PUSH
48832: LD_VAR 0 3
48836: ST_TO_ADDR
// for i := 1 to k do
48837: LD_ADDR_VAR 0 1
48841: PUSH
48842: DOUBLE
48843: LD_INT 1
48845: DEC
48846: ST_TO_ADDR
48847: LD_VAR 0 2
48851: PUSH
48852: FOR_TO
48853: IFFALSE 48952
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48855: LD_VAR 0 3
48859: PUSH
48860: LD_VAR 0 1
48864: ARRAY
48865: PPUSH
48866: LD_VAR 0 1
48870: PUSH
48871: LD_INT 4
48873: MOD
48874: PUSH
48875: LD_INT 1
48877: PLUS
48878: PPUSH
48879: CALL_OW 259
48883: PUSH
48884: LD_INT 10
48886: LESS
48887: IFFALSE 48950
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48889: LD_VAR 0 3
48893: PUSH
48894: LD_VAR 0 1
48898: ARRAY
48899: PPUSH
48900: LD_VAR 0 1
48904: PUSH
48905: LD_INT 4
48907: MOD
48908: PUSH
48909: LD_INT 1
48911: PLUS
48912: PPUSH
48913: LD_VAR 0 3
48917: PUSH
48918: LD_VAR 0 1
48922: ARRAY
48923: PPUSH
48924: LD_VAR 0 1
48928: PUSH
48929: LD_INT 4
48931: MOD
48932: PUSH
48933: LD_INT 1
48935: PLUS
48936: PPUSH
48937: CALL_OW 259
48941: PUSH
48942: LD_INT 1
48944: PLUS
48945: PPUSH
48946: CALL_OW 237
48950: GO 48852
48952: POP
48953: POP
// end ;
48954: PPOPN 3
48956: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
48957: LD_EXP 91
48961: PUSH
48962: LD_EXP 99
48966: AND
48967: IFFALSE 48987
48969: GO 48971
48971: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
48972: LD_INT 4
48974: PPUSH
48975: LD_OWVAR 2
48979: PPUSH
48980: LD_INT 0
48982: PPUSH
48983: CALL_OW 324
48987: END
// every 0 0$1 trigger StreamModeActive and sShovel do
48988: LD_EXP 91
48992: PUSH
48993: LD_EXP 128
48997: AND
48998: IFFALSE 49018
49000: GO 49002
49002: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49003: LD_INT 19
49005: PPUSH
49006: LD_OWVAR 2
49010: PPUSH
49011: LD_INT 0
49013: PPUSH
49014: CALL_OW 324
49018: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49019: LD_EXP 91
49023: PUSH
49024: LD_EXP 100
49028: AND
49029: IFFALSE 49131
49031: GO 49033
49033: DISABLE
49034: LD_INT 0
49036: PPUSH
49037: PPUSH
// begin enable ;
49038: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49039: LD_ADDR_VAR 0 2
49043: PUSH
49044: LD_INT 22
49046: PUSH
49047: LD_OWVAR 2
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 2
49058: PUSH
49059: LD_INT 34
49061: PUSH
49062: LD_INT 11
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 34
49071: PUSH
49072: LD_INT 30
49074: PUSH
49075: EMPTY
49076: LIST
49077: LIST
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: LIST
49083: PUSH
49084: EMPTY
49085: LIST
49086: LIST
49087: PPUSH
49088: CALL_OW 69
49092: ST_TO_ADDR
// if not tmp then
49093: LD_VAR 0 2
49097: NOT
49098: IFFALSE 49102
// exit ;
49100: GO 49131
// for i in tmp do
49102: LD_ADDR_VAR 0 1
49106: PUSH
49107: LD_VAR 0 2
49111: PUSH
49112: FOR_IN
49113: IFFALSE 49129
// begin SetLives ( i , 0 ) ;
49115: LD_VAR 0 1
49119: PPUSH
49120: LD_INT 0
49122: PPUSH
49123: CALL_OW 234
// end ;
49127: GO 49112
49129: POP
49130: POP
// end ;
49131: PPOPN 2
49133: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49134: LD_EXP 91
49138: PUSH
49139: LD_EXP 101
49143: AND
49144: IFFALSE 49164
49146: GO 49148
49148: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49149: LD_INT 32
49151: PPUSH
49152: LD_OWVAR 2
49156: PPUSH
49157: LD_INT 0
49159: PPUSH
49160: CALL_OW 324
49164: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49165: LD_EXP 91
49169: PUSH
49170: LD_EXP 102
49174: AND
49175: IFFALSE 49356
49177: GO 49179
49179: DISABLE
49180: LD_INT 0
49182: PPUSH
49183: PPUSH
49184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49185: LD_ADDR_VAR 0 2
49189: PUSH
49190: LD_INT 22
49192: PUSH
49193: LD_OWVAR 2
49197: PUSH
49198: EMPTY
49199: LIST
49200: LIST
49201: PUSH
49202: LD_INT 33
49204: PUSH
49205: LD_INT 3
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PPUSH
49216: CALL_OW 69
49220: ST_TO_ADDR
// if not tmp then
49221: LD_VAR 0 2
49225: NOT
49226: IFFALSE 49230
// exit ;
49228: GO 49356
// side := 0 ;
49230: LD_ADDR_VAR 0 3
49234: PUSH
49235: LD_INT 0
49237: ST_TO_ADDR
// for i := 1 to 8 do
49238: LD_ADDR_VAR 0 1
49242: PUSH
49243: DOUBLE
49244: LD_INT 1
49246: DEC
49247: ST_TO_ADDR
49248: LD_INT 8
49250: PUSH
49251: FOR_TO
49252: IFFALSE 49300
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49254: LD_OWVAR 2
49258: PUSH
49259: LD_VAR 0 1
49263: NONEQUAL
49264: PUSH
49265: LD_OWVAR 2
49269: PPUSH
49270: LD_VAR 0 1
49274: PPUSH
49275: CALL_OW 81
49279: PUSH
49280: LD_INT 2
49282: EQUAL
49283: AND
49284: IFFALSE 49298
// begin side := i ;
49286: LD_ADDR_VAR 0 3
49290: PUSH
49291: LD_VAR 0 1
49295: ST_TO_ADDR
// break ;
49296: GO 49300
// end ;
49298: GO 49251
49300: POP
49301: POP
// if not side then
49302: LD_VAR 0 3
49306: NOT
49307: IFFALSE 49311
// exit ;
49309: GO 49356
// for i := 1 to tmp do
49311: LD_ADDR_VAR 0 1
49315: PUSH
49316: DOUBLE
49317: LD_INT 1
49319: DEC
49320: ST_TO_ADDR
49321: LD_VAR 0 2
49325: PUSH
49326: FOR_TO
49327: IFFALSE 49354
// if Prob ( 60 ) then
49329: LD_INT 60
49331: PPUSH
49332: CALL_OW 13
49336: IFFALSE 49352
// SetSide ( i , side ) ;
49338: LD_VAR 0 1
49342: PPUSH
49343: LD_VAR 0 3
49347: PPUSH
49348: CALL_OW 235
49352: GO 49326
49354: POP
49355: POP
// end ;
49356: PPOPN 3
49358: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49359: LD_EXP 91
49363: PUSH
49364: LD_EXP 104
49368: AND
49369: IFFALSE 49488
49371: GO 49373
49373: DISABLE
49374: LD_INT 0
49376: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49377: LD_ADDR_VAR 0 1
49381: PUSH
49382: LD_INT 22
49384: PUSH
49385: LD_OWVAR 2
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 21
49396: PUSH
49397: LD_INT 1
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: PUSH
49404: LD_INT 3
49406: PUSH
49407: LD_INT 23
49409: PUSH
49410: LD_INT 0
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: LIST
49425: PPUSH
49426: CALL_OW 69
49430: PUSH
49431: FOR_IN
49432: IFFALSE 49486
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49434: LD_VAR 0 1
49438: PPUSH
49439: CALL_OW 257
49443: PUSH
49444: LD_INT 1
49446: PUSH
49447: LD_INT 2
49449: PUSH
49450: LD_INT 3
49452: PUSH
49453: LD_INT 4
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: IN
49462: IFFALSE 49484
// SetClass ( un , rand ( 1 , 4 ) ) ;
49464: LD_VAR 0 1
49468: PPUSH
49469: LD_INT 1
49471: PPUSH
49472: LD_INT 4
49474: PPUSH
49475: CALL_OW 12
49479: PPUSH
49480: CALL_OW 336
49484: GO 49431
49486: POP
49487: POP
// end ;
49488: PPOPN 1
49490: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49491: LD_EXP 91
49495: PUSH
49496: LD_EXP 103
49500: AND
49501: IFFALSE 49580
49503: GO 49505
49505: DISABLE
49506: LD_INT 0
49508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49509: LD_ADDR_VAR 0 1
49513: PUSH
49514: LD_INT 22
49516: PUSH
49517: LD_OWVAR 2
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 21
49528: PUSH
49529: LD_INT 3
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PPUSH
49540: CALL_OW 69
49544: ST_TO_ADDR
// if not tmp then
49545: LD_VAR 0 1
49549: NOT
49550: IFFALSE 49554
// exit ;
49552: GO 49580
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49554: LD_VAR 0 1
49558: PUSH
49559: LD_INT 1
49561: PPUSH
49562: LD_VAR 0 1
49566: PPUSH
49567: CALL_OW 12
49571: ARRAY
49572: PPUSH
49573: LD_INT 100
49575: PPUSH
49576: CALL_OW 234
// end ;
49580: PPOPN 1
49582: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49583: LD_EXP 91
49587: PUSH
49588: LD_EXP 105
49592: AND
49593: IFFALSE 49691
49595: GO 49597
49597: DISABLE
49598: LD_INT 0
49600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49601: LD_ADDR_VAR 0 1
49605: PUSH
49606: LD_INT 22
49608: PUSH
49609: LD_OWVAR 2
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: PUSH
49618: LD_INT 21
49620: PUSH
49621: LD_INT 1
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: EMPTY
49629: LIST
49630: LIST
49631: PPUSH
49632: CALL_OW 69
49636: ST_TO_ADDR
// if not tmp then
49637: LD_VAR 0 1
49641: NOT
49642: IFFALSE 49646
// exit ;
49644: GO 49691
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49646: LD_VAR 0 1
49650: PUSH
49651: LD_INT 1
49653: PPUSH
49654: LD_VAR 0 1
49658: PPUSH
49659: CALL_OW 12
49663: ARRAY
49664: PPUSH
49665: LD_INT 1
49667: PPUSH
49668: LD_INT 4
49670: PPUSH
49671: CALL_OW 12
49675: PPUSH
49676: LD_INT 3000
49678: PPUSH
49679: LD_INT 9000
49681: PPUSH
49682: CALL_OW 12
49686: PPUSH
49687: CALL_OW 492
// end ;
49691: PPOPN 1
49693: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49694: LD_EXP 91
49698: PUSH
49699: LD_EXP 106
49703: AND
49704: IFFALSE 49724
49706: GO 49708
49708: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49709: LD_INT 1
49711: PPUSH
49712: LD_OWVAR 2
49716: PPUSH
49717: LD_INT 0
49719: PPUSH
49720: CALL_OW 324
49724: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49725: LD_EXP 91
49729: PUSH
49730: LD_EXP 107
49734: AND
49735: IFFALSE 49818
49737: GO 49739
49739: DISABLE
49740: LD_INT 0
49742: PPUSH
49743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49744: LD_ADDR_VAR 0 2
49748: PUSH
49749: LD_INT 22
49751: PUSH
49752: LD_OWVAR 2
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 21
49763: PUSH
49764: LD_INT 3
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PPUSH
49775: CALL_OW 69
49779: ST_TO_ADDR
// if not tmp then
49780: LD_VAR 0 2
49784: NOT
49785: IFFALSE 49789
// exit ;
49787: GO 49818
// for i in tmp do
49789: LD_ADDR_VAR 0 1
49793: PUSH
49794: LD_VAR 0 2
49798: PUSH
49799: FOR_IN
49800: IFFALSE 49816
// SetBLevel ( i , 10 ) ;
49802: LD_VAR 0 1
49806: PPUSH
49807: LD_INT 10
49809: PPUSH
49810: CALL_OW 241
49814: GO 49799
49816: POP
49817: POP
// end ;
49818: PPOPN 2
49820: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49821: LD_EXP 91
49825: PUSH
49826: LD_EXP 108
49830: AND
49831: IFFALSE 49942
49833: GO 49835
49835: DISABLE
49836: LD_INT 0
49838: PPUSH
49839: PPUSH
49840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49841: LD_ADDR_VAR 0 3
49845: PUSH
49846: LD_INT 22
49848: PUSH
49849: LD_OWVAR 2
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PUSH
49858: LD_INT 25
49860: PUSH
49861: LD_INT 1
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PPUSH
49872: CALL_OW 69
49876: ST_TO_ADDR
// if not tmp then
49877: LD_VAR 0 3
49881: NOT
49882: IFFALSE 49886
// exit ;
49884: GO 49942
// un := tmp [ rand ( 1 , tmp ) ] ;
49886: LD_ADDR_VAR 0 2
49890: PUSH
49891: LD_VAR 0 3
49895: PUSH
49896: LD_INT 1
49898: PPUSH
49899: LD_VAR 0 3
49903: PPUSH
49904: CALL_OW 12
49908: ARRAY
49909: ST_TO_ADDR
// if Crawls ( un ) then
49910: LD_VAR 0 2
49914: PPUSH
49915: CALL_OW 318
49919: IFFALSE 49930
// ComWalk ( un ) ;
49921: LD_VAR 0 2
49925: PPUSH
49926: CALL_OW 138
// SetClass ( un , class_sniper ) ;
49930: LD_VAR 0 2
49934: PPUSH
49935: LD_INT 5
49937: PPUSH
49938: CALL_OW 336
// end ;
49942: PPOPN 3
49944: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
49945: LD_EXP 91
49949: PUSH
49950: LD_EXP 109
49954: AND
49955: PUSH
49956: LD_OWVAR 67
49960: PUSH
49961: LD_INT 3
49963: LESS
49964: AND
49965: IFFALSE 49984
49967: GO 49969
49969: DISABLE
// Difficulty := Difficulty + 1 ;
49970: LD_ADDR_OWVAR 67
49974: PUSH
49975: LD_OWVAR 67
49979: PUSH
49980: LD_INT 1
49982: PLUS
49983: ST_TO_ADDR
49984: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
49985: LD_EXP 91
49989: PUSH
49990: LD_EXP 110
49994: AND
49995: IFFALSE 50098
49997: GO 49999
49999: DISABLE
50000: LD_INT 0
50002: PPUSH
// begin for i := 1 to 5 do
50003: LD_ADDR_VAR 0 1
50007: PUSH
50008: DOUBLE
50009: LD_INT 1
50011: DEC
50012: ST_TO_ADDR
50013: LD_INT 5
50015: PUSH
50016: FOR_TO
50017: IFFALSE 50096
// begin uc_nation := nation_nature ;
50019: LD_ADDR_OWVAR 21
50023: PUSH
50024: LD_INT 0
50026: ST_TO_ADDR
// uc_side := 0 ;
50027: LD_ADDR_OWVAR 20
50031: PUSH
50032: LD_INT 0
50034: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50035: LD_ADDR_OWVAR 29
50039: PUSH
50040: LD_INT 12
50042: PUSH
50043: LD_INT 12
50045: PUSH
50046: EMPTY
50047: LIST
50048: LIST
50049: ST_TO_ADDR
// hc_agressivity := 20 ;
50050: LD_ADDR_OWVAR 35
50054: PUSH
50055: LD_INT 20
50057: ST_TO_ADDR
// hc_class := class_tiger ;
50058: LD_ADDR_OWVAR 28
50062: PUSH
50063: LD_INT 14
50065: ST_TO_ADDR
// hc_gallery :=  ;
50066: LD_ADDR_OWVAR 33
50070: PUSH
50071: LD_STRING 
50073: ST_TO_ADDR
// hc_name :=  ;
50074: LD_ADDR_OWVAR 26
50078: PUSH
50079: LD_STRING 
50081: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50082: CALL_OW 44
50086: PPUSH
50087: LD_INT 0
50089: PPUSH
50090: CALL_OW 51
// end ;
50094: GO 50016
50096: POP
50097: POP
// end ;
50098: PPOPN 1
50100: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50101: LD_EXP 91
50105: PUSH
50106: LD_EXP 111
50110: AND
50111: IFFALSE 50120
50113: GO 50115
50115: DISABLE
// StreamSibBomb ;
50116: CALL 50121 0 0
50120: END
// export function StreamSibBomb ; var i , x , y ; begin
50121: LD_INT 0
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
// result := false ;
50127: LD_ADDR_VAR 0 1
50131: PUSH
50132: LD_INT 0
50134: ST_TO_ADDR
// for i := 1 to 16 do
50135: LD_ADDR_VAR 0 2
50139: PUSH
50140: DOUBLE
50141: LD_INT 1
50143: DEC
50144: ST_TO_ADDR
50145: LD_INT 16
50147: PUSH
50148: FOR_TO
50149: IFFALSE 50348
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50151: LD_ADDR_VAR 0 3
50155: PUSH
50156: LD_INT 10
50158: PUSH
50159: LD_INT 20
50161: PUSH
50162: LD_INT 30
50164: PUSH
50165: LD_INT 40
50167: PUSH
50168: LD_INT 50
50170: PUSH
50171: LD_INT 60
50173: PUSH
50174: LD_INT 70
50176: PUSH
50177: LD_INT 80
50179: PUSH
50180: LD_INT 90
50182: PUSH
50183: LD_INT 100
50185: PUSH
50186: LD_INT 110
50188: PUSH
50189: LD_INT 120
50191: PUSH
50192: LD_INT 130
50194: PUSH
50195: LD_INT 140
50197: PUSH
50198: LD_INT 150
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: LIST
50211: LIST
50212: LIST
50213: LIST
50214: LIST
50215: LIST
50216: LIST
50217: PUSH
50218: LD_INT 1
50220: PPUSH
50221: LD_INT 15
50223: PPUSH
50224: CALL_OW 12
50228: ARRAY
50229: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50230: LD_ADDR_VAR 0 4
50234: PUSH
50235: LD_INT 10
50237: PUSH
50238: LD_INT 20
50240: PUSH
50241: LD_INT 30
50243: PUSH
50244: LD_INT 40
50246: PUSH
50247: LD_INT 50
50249: PUSH
50250: LD_INT 60
50252: PUSH
50253: LD_INT 70
50255: PUSH
50256: LD_INT 80
50258: PUSH
50259: LD_INT 90
50261: PUSH
50262: LD_INT 100
50264: PUSH
50265: LD_INT 110
50267: PUSH
50268: LD_INT 120
50270: PUSH
50271: LD_INT 130
50273: PUSH
50274: LD_INT 140
50276: PUSH
50277: LD_INT 150
50279: PUSH
50280: EMPTY
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: PUSH
50297: LD_INT 1
50299: PPUSH
50300: LD_INT 15
50302: PPUSH
50303: CALL_OW 12
50307: ARRAY
50308: ST_TO_ADDR
// if ValidHex ( x , y ) then
50309: LD_VAR 0 3
50313: PPUSH
50314: LD_VAR 0 4
50318: PPUSH
50319: CALL_OW 488
50323: IFFALSE 50346
// begin result := [ x , y ] ;
50325: LD_ADDR_VAR 0 1
50329: PUSH
50330: LD_VAR 0 3
50334: PUSH
50335: LD_VAR 0 4
50339: PUSH
50340: EMPTY
50341: LIST
50342: LIST
50343: ST_TO_ADDR
// break ;
50344: GO 50348
// end ; end ;
50346: GO 50148
50348: POP
50349: POP
// if result then
50350: LD_VAR 0 1
50354: IFFALSE 50414
// begin ToLua ( playSibBomb() ) ;
50356: LD_STRING playSibBomb()
50358: PPUSH
50359: CALL_OW 559
// wait ( 0 0$14 ) ;
50363: LD_INT 490
50365: PPUSH
50366: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50370: LD_VAR 0 1
50374: PUSH
50375: LD_INT 1
50377: ARRAY
50378: PPUSH
50379: LD_VAR 0 1
50383: PUSH
50384: LD_INT 2
50386: ARRAY
50387: PPUSH
50388: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50392: LD_VAR 0 1
50396: PUSH
50397: LD_INT 1
50399: ARRAY
50400: PPUSH
50401: LD_VAR 0 1
50405: PUSH
50406: LD_INT 2
50408: ARRAY
50409: PPUSH
50410: CALL_OW 429
// end ; end ;
50414: LD_VAR 0 1
50418: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50419: LD_EXP 91
50423: PUSH
50424: LD_EXP 113
50428: AND
50429: IFFALSE 50441
50431: GO 50433
50433: DISABLE
// YouLost (  ) ;
50434: LD_STRING 
50436: PPUSH
50437: CALL_OW 104
50441: END
// every 0 0$1 trigger StreamModeActive and sFog do
50442: LD_EXP 91
50446: PUSH
50447: LD_EXP 112
50451: AND
50452: IFFALSE 50466
50454: GO 50456
50456: DISABLE
// FogOff ( your_side ) ;
50457: LD_OWVAR 2
50461: PPUSH
50462: CALL_OW 344
50466: END
// every 0 0$1 trigger StreamModeActive and sSun do
50467: LD_EXP 91
50471: PUSH
50472: LD_EXP 114
50476: AND
50477: IFFALSE 50505
50479: GO 50481
50481: DISABLE
// begin solar_recharge_percent := 0 ;
50482: LD_ADDR_OWVAR 79
50486: PUSH
50487: LD_INT 0
50489: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50490: LD_INT 10500
50492: PPUSH
50493: CALL_OW 67
// solar_recharge_percent := 100 ;
50497: LD_ADDR_OWVAR 79
50501: PUSH
50502: LD_INT 100
50504: ST_TO_ADDR
// end ;
50505: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50506: LD_EXP 91
50510: PUSH
50511: LD_EXP 115
50515: AND
50516: IFFALSE 50755
50518: GO 50520
50520: DISABLE
50521: LD_INT 0
50523: PPUSH
50524: PPUSH
50525: PPUSH
// begin tmp := [ ] ;
50526: LD_ADDR_VAR 0 3
50530: PUSH
50531: EMPTY
50532: ST_TO_ADDR
// for i := 1 to 6 do
50533: LD_ADDR_VAR 0 1
50537: PUSH
50538: DOUBLE
50539: LD_INT 1
50541: DEC
50542: ST_TO_ADDR
50543: LD_INT 6
50545: PUSH
50546: FOR_TO
50547: IFFALSE 50652
// begin uc_nation := nation_nature ;
50549: LD_ADDR_OWVAR 21
50553: PUSH
50554: LD_INT 0
50556: ST_TO_ADDR
// uc_side := 0 ;
50557: LD_ADDR_OWVAR 20
50561: PUSH
50562: LD_INT 0
50564: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50565: LD_ADDR_OWVAR 29
50569: PUSH
50570: LD_INT 12
50572: PUSH
50573: LD_INT 12
50575: PUSH
50576: EMPTY
50577: LIST
50578: LIST
50579: ST_TO_ADDR
// hc_agressivity := 20 ;
50580: LD_ADDR_OWVAR 35
50584: PUSH
50585: LD_INT 20
50587: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50588: LD_ADDR_OWVAR 28
50592: PUSH
50593: LD_INT 17
50595: ST_TO_ADDR
// hc_gallery :=  ;
50596: LD_ADDR_OWVAR 33
50600: PUSH
50601: LD_STRING 
50603: ST_TO_ADDR
// hc_name :=  ;
50604: LD_ADDR_OWVAR 26
50608: PUSH
50609: LD_STRING 
50611: ST_TO_ADDR
// un := CreateHuman ;
50612: LD_ADDR_VAR 0 2
50616: PUSH
50617: CALL_OW 44
50621: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50622: LD_VAR 0 2
50626: PPUSH
50627: LD_INT 1
50629: PPUSH
50630: CALL_OW 51
// tmp := tmp ^ un ;
50634: LD_ADDR_VAR 0 3
50638: PUSH
50639: LD_VAR 0 3
50643: PUSH
50644: LD_VAR 0 2
50648: ADD
50649: ST_TO_ADDR
// end ;
50650: GO 50546
50652: POP
50653: POP
// repeat wait ( 0 0$1 ) ;
50654: LD_INT 35
50656: PPUSH
50657: CALL_OW 67
// for un in tmp do
50661: LD_ADDR_VAR 0 2
50665: PUSH
50666: LD_VAR 0 3
50670: PUSH
50671: FOR_IN
50672: IFFALSE 50746
// begin if IsDead ( un ) then
50674: LD_VAR 0 2
50678: PPUSH
50679: CALL_OW 301
50683: IFFALSE 50703
// begin tmp := tmp diff un ;
50685: LD_ADDR_VAR 0 3
50689: PUSH
50690: LD_VAR 0 3
50694: PUSH
50695: LD_VAR 0 2
50699: DIFF
50700: ST_TO_ADDR
// continue ;
50701: GO 50671
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50703: LD_VAR 0 2
50707: PPUSH
50708: LD_INT 3
50710: PUSH
50711: LD_INT 22
50713: PUSH
50714: LD_INT 0
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: EMPTY
50722: LIST
50723: LIST
50724: PPUSH
50725: CALL_OW 69
50729: PPUSH
50730: LD_VAR 0 2
50734: PPUSH
50735: CALL_OW 74
50739: PPUSH
50740: CALL_OW 115
// end ;
50744: GO 50671
50746: POP
50747: POP
// until not tmp ;
50748: LD_VAR 0 3
50752: NOT
50753: IFFALSE 50654
// end ;
50755: PPOPN 3
50757: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50758: LD_EXP 91
50762: PUSH
50763: LD_EXP 116
50767: AND
50768: IFFALSE 50822
50770: GO 50772
50772: DISABLE
// begin ToLua ( displayTroll(); ) ;
50773: LD_STRING displayTroll();
50775: PPUSH
50776: CALL_OW 559
// wait ( 3 3$00 ) ;
50780: LD_INT 6300
50782: PPUSH
50783: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50787: LD_STRING hideTroll();
50789: PPUSH
50790: CALL_OW 559
// wait ( 1 1$00 ) ;
50794: LD_INT 2100
50796: PPUSH
50797: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50801: LD_STRING displayTroll();
50803: PPUSH
50804: CALL_OW 559
// wait ( 1 1$00 ) ;
50808: LD_INT 2100
50810: PPUSH
50811: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50815: LD_STRING hideTroll();
50817: PPUSH
50818: CALL_OW 559
// end ;
50822: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50823: LD_EXP 91
50827: PUSH
50828: LD_EXP 117
50832: AND
50833: IFFALSE 50896
50835: GO 50837
50837: DISABLE
50838: LD_INT 0
50840: PPUSH
// begin p := 0 ;
50841: LD_ADDR_VAR 0 1
50845: PUSH
50846: LD_INT 0
50848: ST_TO_ADDR
// repeat game_speed := 1 ;
50849: LD_ADDR_OWVAR 65
50853: PUSH
50854: LD_INT 1
50856: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50857: LD_INT 35
50859: PPUSH
50860: CALL_OW 67
// p := p + 1 ;
50864: LD_ADDR_VAR 0 1
50868: PUSH
50869: LD_VAR 0 1
50873: PUSH
50874: LD_INT 1
50876: PLUS
50877: ST_TO_ADDR
// until p >= 60 ;
50878: LD_VAR 0 1
50882: PUSH
50883: LD_INT 60
50885: GREATEREQUAL
50886: IFFALSE 50849
// game_speed := 4 ;
50888: LD_ADDR_OWVAR 65
50892: PUSH
50893: LD_INT 4
50895: ST_TO_ADDR
// end ;
50896: PPOPN 1
50898: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
50899: LD_EXP 91
50903: PUSH
50904: LD_EXP 118
50908: AND
50909: IFFALSE 51055
50911: GO 50913
50913: DISABLE
50914: LD_INT 0
50916: PPUSH
50917: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
50918: LD_ADDR_VAR 0 1
50922: PUSH
50923: LD_INT 22
50925: PUSH
50926: LD_OWVAR 2
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PUSH
50935: LD_INT 2
50937: PUSH
50938: LD_INT 30
50940: PUSH
50941: LD_INT 0
50943: PUSH
50944: EMPTY
50945: LIST
50946: LIST
50947: PUSH
50948: LD_INT 30
50950: PUSH
50951: LD_INT 1
50953: PUSH
50954: EMPTY
50955: LIST
50956: LIST
50957: PUSH
50958: EMPTY
50959: LIST
50960: LIST
50961: LIST
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PPUSH
50967: CALL_OW 69
50971: ST_TO_ADDR
// if not depot then
50972: LD_VAR 0 1
50976: NOT
50977: IFFALSE 50981
// exit ;
50979: GO 51055
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
50981: LD_ADDR_VAR 0 2
50985: PUSH
50986: LD_VAR 0 1
50990: PUSH
50991: LD_INT 1
50993: PPUSH
50994: LD_VAR 0 1
50998: PPUSH
50999: CALL_OW 12
51003: ARRAY
51004: PPUSH
51005: CALL_OW 274
51009: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51010: LD_VAR 0 2
51014: PPUSH
51015: LD_INT 1
51017: PPUSH
51018: LD_INT 0
51020: PPUSH
51021: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51025: LD_VAR 0 2
51029: PPUSH
51030: LD_INT 2
51032: PPUSH
51033: LD_INT 0
51035: PPUSH
51036: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51040: LD_VAR 0 2
51044: PPUSH
51045: LD_INT 3
51047: PPUSH
51048: LD_INT 0
51050: PPUSH
51051: CALL_OW 277
// end ;
51055: PPOPN 2
51057: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51058: LD_EXP 91
51062: PUSH
51063: LD_EXP 119
51067: AND
51068: IFFALSE 51165
51070: GO 51072
51072: DISABLE
51073: LD_INT 0
51075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51076: LD_ADDR_VAR 0 1
51080: PUSH
51081: LD_INT 22
51083: PUSH
51084: LD_OWVAR 2
51088: PUSH
51089: EMPTY
51090: LIST
51091: LIST
51092: PUSH
51093: LD_INT 21
51095: PUSH
51096: LD_INT 1
51098: PUSH
51099: EMPTY
51100: LIST
51101: LIST
51102: PUSH
51103: LD_INT 3
51105: PUSH
51106: LD_INT 23
51108: PUSH
51109: LD_INT 0
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: LIST
51124: PPUSH
51125: CALL_OW 69
51129: ST_TO_ADDR
// if not tmp then
51130: LD_VAR 0 1
51134: NOT
51135: IFFALSE 51139
// exit ;
51137: GO 51165
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51139: LD_VAR 0 1
51143: PUSH
51144: LD_INT 1
51146: PPUSH
51147: LD_VAR 0 1
51151: PPUSH
51152: CALL_OW 12
51156: ARRAY
51157: PPUSH
51158: LD_INT 200
51160: PPUSH
51161: CALL_OW 234
// end ;
51165: PPOPN 1
51167: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51168: LD_EXP 91
51172: PUSH
51173: LD_EXP 120
51177: AND
51178: IFFALSE 51257
51180: GO 51182
51182: DISABLE
51183: LD_INT 0
51185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51186: LD_ADDR_VAR 0 1
51190: PUSH
51191: LD_INT 22
51193: PUSH
51194: LD_OWVAR 2
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: PUSH
51203: LD_INT 21
51205: PUSH
51206: LD_INT 2
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PUSH
51213: EMPTY
51214: LIST
51215: LIST
51216: PPUSH
51217: CALL_OW 69
51221: ST_TO_ADDR
// if not tmp then
51222: LD_VAR 0 1
51226: NOT
51227: IFFALSE 51231
// exit ;
51229: GO 51257
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51231: LD_VAR 0 1
51235: PUSH
51236: LD_INT 1
51238: PPUSH
51239: LD_VAR 0 1
51243: PPUSH
51244: CALL_OW 12
51248: ARRAY
51249: PPUSH
51250: LD_INT 60
51252: PPUSH
51253: CALL_OW 234
// end ;
51257: PPOPN 1
51259: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51260: LD_EXP 91
51264: PUSH
51265: LD_EXP 121
51269: AND
51270: IFFALSE 51369
51272: GO 51274
51274: DISABLE
51275: LD_INT 0
51277: PPUSH
51278: PPUSH
// begin enable ;
51279: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51280: LD_ADDR_VAR 0 1
51284: PUSH
51285: LD_INT 22
51287: PUSH
51288: LD_OWVAR 2
51292: PUSH
51293: EMPTY
51294: LIST
51295: LIST
51296: PUSH
51297: LD_INT 61
51299: PUSH
51300: EMPTY
51301: LIST
51302: PUSH
51303: LD_INT 33
51305: PUSH
51306: LD_INT 2
51308: PUSH
51309: EMPTY
51310: LIST
51311: LIST
51312: PUSH
51313: EMPTY
51314: LIST
51315: LIST
51316: LIST
51317: PPUSH
51318: CALL_OW 69
51322: ST_TO_ADDR
// if not tmp then
51323: LD_VAR 0 1
51327: NOT
51328: IFFALSE 51332
// exit ;
51330: GO 51369
// for i in tmp do
51332: LD_ADDR_VAR 0 2
51336: PUSH
51337: LD_VAR 0 1
51341: PUSH
51342: FOR_IN
51343: IFFALSE 51367
// if IsControledBy ( i ) then
51345: LD_VAR 0 2
51349: PPUSH
51350: CALL_OW 312
51354: IFFALSE 51365
// ComUnlink ( i ) ;
51356: LD_VAR 0 2
51360: PPUSH
51361: CALL_OW 136
51365: GO 51342
51367: POP
51368: POP
// end ;
51369: PPOPN 2
51371: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51372: LD_EXP 91
51376: PUSH
51377: LD_EXP 122
51381: AND
51382: IFFALSE 51522
51384: GO 51386
51386: DISABLE
51387: LD_INT 0
51389: PPUSH
51390: PPUSH
// begin ToLua ( displayPowell(); ) ;
51391: LD_STRING displayPowell();
51393: PPUSH
51394: CALL_OW 559
// uc_side := 0 ;
51398: LD_ADDR_OWVAR 20
51402: PUSH
51403: LD_INT 0
51405: ST_TO_ADDR
// uc_nation := 2 ;
51406: LD_ADDR_OWVAR 21
51410: PUSH
51411: LD_INT 2
51413: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51414: LD_ADDR_OWVAR 37
51418: PUSH
51419: LD_INT 14
51421: ST_TO_ADDR
// vc_engine := engine_siberite ;
51422: LD_ADDR_OWVAR 39
51426: PUSH
51427: LD_INT 3
51429: ST_TO_ADDR
// vc_control := control_apeman ;
51430: LD_ADDR_OWVAR 38
51434: PUSH
51435: LD_INT 5
51437: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51438: LD_ADDR_OWVAR 40
51442: PUSH
51443: LD_INT 29
51445: ST_TO_ADDR
// un := CreateVehicle ;
51446: LD_ADDR_VAR 0 2
51450: PUSH
51451: CALL_OW 45
51455: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51456: LD_VAR 0 2
51460: PPUSH
51461: LD_INT 1
51463: PPUSH
51464: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51468: LD_INT 35
51470: PPUSH
51471: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51475: LD_VAR 0 2
51479: PPUSH
51480: LD_INT 22
51482: PUSH
51483: LD_OWVAR 2
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PPUSH
51492: CALL_OW 69
51496: PPUSH
51497: LD_VAR 0 2
51501: PPUSH
51502: CALL_OW 74
51506: PPUSH
51507: CALL_OW 115
// until IsDead ( un ) ;
51511: LD_VAR 0 2
51515: PPUSH
51516: CALL_OW 301
51520: IFFALSE 51468
// end ;
51522: PPOPN 2
51524: END
// every 0 0$1 trigger StreamModeActive and sStu do
51525: LD_EXP 91
51529: PUSH
51530: LD_EXP 130
51534: AND
51535: IFFALSE 51551
51537: GO 51539
51539: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51540: LD_STRING displayStucuk();
51542: PPUSH
51543: CALL_OW 559
// ResetFog ;
51547: CALL_OW 335
// end ;
51551: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51552: LD_EXP 91
51556: PUSH
51557: LD_EXP 123
51561: AND
51562: IFFALSE 51703
51564: GO 51566
51566: DISABLE
51567: LD_INT 0
51569: PPUSH
51570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51571: LD_ADDR_VAR 0 2
51575: PUSH
51576: LD_INT 22
51578: PUSH
51579: LD_OWVAR 2
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PUSH
51588: LD_INT 21
51590: PUSH
51591: LD_INT 1
51593: PUSH
51594: EMPTY
51595: LIST
51596: LIST
51597: PUSH
51598: EMPTY
51599: LIST
51600: LIST
51601: PPUSH
51602: CALL_OW 69
51606: ST_TO_ADDR
// if not tmp then
51607: LD_VAR 0 2
51611: NOT
51612: IFFALSE 51616
// exit ;
51614: GO 51703
// un := tmp [ rand ( 1 , tmp ) ] ;
51616: LD_ADDR_VAR 0 1
51620: PUSH
51621: LD_VAR 0 2
51625: PUSH
51626: LD_INT 1
51628: PPUSH
51629: LD_VAR 0 2
51633: PPUSH
51634: CALL_OW 12
51638: ARRAY
51639: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51640: LD_VAR 0 1
51644: PPUSH
51645: LD_INT 0
51647: PPUSH
51648: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51652: LD_VAR 0 1
51656: PPUSH
51657: LD_OWVAR 3
51661: PUSH
51662: LD_VAR 0 1
51666: DIFF
51667: PPUSH
51668: LD_VAR 0 1
51672: PPUSH
51673: CALL_OW 74
51677: PPUSH
51678: CALL_OW 115
// wait ( 0 0$20 ) ;
51682: LD_INT 700
51684: PPUSH
51685: CALL_OW 67
// SetSide ( un , your_side ) ;
51689: LD_VAR 0 1
51693: PPUSH
51694: LD_OWVAR 2
51698: PPUSH
51699: CALL_OW 235
// end ;
51703: PPOPN 2
51705: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51706: LD_EXP 91
51710: PUSH
51711: LD_EXP 124
51715: AND
51716: IFFALSE 51822
51718: GO 51720
51720: DISABLE
51721: LD_INT 0
51723: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51724: LD_ADDR_VAR 0 1
51728: PUSH
51729: LD_INT 22
51731: PUSH
51732: LD_OWVAR 2
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: PUSH
51741: LD_INT 2
51743: PUSH
51744: LD_INT 30
51746: PUSH
51747: LD_INT 0
51749: PUSH
51750: EMPTY
51751: LIST
51752: LIST
51753: PUSH
51754: LD_INT 30
51756: PUSH
51757: LD_INT 1
51759: PUSH
51760: EMPTY
51761: LIST
51762: LIST
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: LIST
51768: PUSH
51769: EMPTY
51770: LIST
51771: LIST
51772: PPUSH
51773: CALL_OW 69
51777: ST_TO_ADDR
// if not depot then
51778: LD_VAR 0 1
51782: NOT
51783: IFFALSE 51787
// exit ;
51785: GO 51822
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51787: LD_VAR 0 1
51791: PUSH
51792: LD_INT 1
51794: ARRAY
51795: PPUSH
51796: CALL_OW 250
51800: PPUSH
51801: LD_VAR 0 1
51805: PUSH
51806: LD_INT 1
51808: ARRAY
51809: PPUSH
51810: CALL_OW 251
51814: PPUSH
51815: LD_INT 70
51817: PPUSH
51818: CALL_OW 495
// end ;
51822: PPOPN 1
51824: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51825: LD_EXP 91
51829: PUSH
51830: LD_EXP 125
51834: AND
51835: IFFALSE 52046
51837: GO 51839
51839: DISABLE
51840: LD_INT 0
51842: PPUSH
51843: PPUSH
51844: PPUSH
51845: PPUSH
51846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51847: LD_ADDR_VAR 0 5
51851: PUSH
51852: LD_INT 22
51854: PUSH
51855: LD_OWVAR 2
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: LD_INT 21
51866: PUSH
51867: LD_INT 1
51869: PUSH
51870: EMPTY
51871: LIST
51872: LIST
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PPUSH
51878: CALL_OW 69
51882: ST_TO_ADDR
// if not tmp then
51883: LD_VAR 0 5
51887: NOT
51888: IFFALSE 51892
// exit ;
51890: GO 52046
// for i in tmp do
51892: LD_ADDR_VAR 0 1
51896: PUSH
51897: LD_VAR 0 5
51901: PUSH
51902: FOR_IN
51903: IFFALSE 52044
// begin d := rand ( 0 , 5 ) ;
51905: LD_ADDR_VAR 0 4
51909: PUSH
51910: LD_INT 0
51912: PPUSH
51913: LD_INT 5
51915: PPUSH
51916: CALL_OW 12
51920: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
51921: LD_ADDR_VAR 0 2
51925: PUSH
51926: LD_VAR 0 1
51930: PPUSH
51931: CALL_OW 250
51935: PPUSH
51936: LD_VAR 0 4
51940: PPUSH
51941: LD_INT 3
51943: PPUSH
51944: LD_INT 12
51946: PPUSH
51947: CALL_OW 12
51951: PPUSH
51952: CALL_OW 272
51956: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
51957: LD_ADDR_VAR 0 3
51961: PUSH
51962: LD_VAR 0 1
51966: PPUSH
51967: CALL_OW 251
51971: PPUSH
51972: LD_VAR 0 4
51976: PPUSH
51977: LD_INT 3
51979: PPUSH
51980: LD_INT 12
51982: PPUSH
51983: CALL_OW 12
51987: PPUSH
51988: CALL_OW 273
51992: ST_TO_ADDR
// if ValidHex ( x , y ) then
51993: LD_VAR 0 2
51997: PPUSH
51998: LD_VAR 0 3
52002: PPUSH
52003: CALL_OW 488
52007: IFFALSE 52042
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52009: LD_VAR 0 1
52013: PPUSH
52014: LD_VAR 0 2
52018: PPUSH
52019: LD_VAR 0 3
52023: PPUSH
52024: LD_INT 3
52026: PPUSH
52027: LD_INT 6
52029: PPUSH
52030: CALL_OW 12
52034: PPUSH
52035: LD_INT 1
52037: PPUSH
52038: CALL_OW 483
// end ;
52042: GO 51902
52044: POP
52045: POP
// end ;
52046: PPOPN 5
52048: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52049: LD_EXP 91
52053: PUSH
52054: LD_EXP 126
52058: AND
52059: IFFALSE 52153
52061: GO 52063
52063: DISABLE
52064: LD_INT 0
52066: PPUSH
52067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52068: LD_ADDR_VAR 0 2
52072: PUSH
52073: LD_INT 22
52075: PUSH
52076: LD_OWVAR 2
52080: PUSH
52081: EMPTY
52082: LIST
52083: LIST
52084: PUSH
52085: LD_INT 32
52087: PUSH
52088: LD_INT 1
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PUSH
52095: LD_INT 21
52097: PUSH
52098: LD_INT 2
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: LIST
52109: PPUSH
52110: CALL_OW 69
52114: ST_TO_ADDR
// if not tmp then
52115: LD_VAR 0 2
52119: NOT
52120: IFFALSE 52124
// exit ;
52122: GO 52153
// for i in tmp do
52124: LD_ADDR_VAR 0 1
52128: PUSH
52129: LD_VAR 0 2
52133: PUSH
52134: FOR_IN
52135: IFFALSE 52151
// SetFuel ( i , 0 ) ;
52137: LD_VAR 0 1
52141: PPUSH
52142: LD_INT 0
52144: PPUSH
52145: CALL_OW 240
52149: GO 52134
52151: POP
52152: POP
// end ;
52153: PPOPN 2
52155: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52156: LD_EXP 91
52160: PUSH
52161: LD_EXP 127
52165: AND
52166: IFFALSE 52232
52168: GO 52170
52170: DISABLE
52171: LD_INT 0
52173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52174: LD_ADDR_VAR 0 1
52178: PUSH
52179: LD_INT 22
52181: PUSH
52182: LD_OWVAR 2
52186: PUSH
52187: EMPTY
52188: LIST
52189: LIST
52190: PUSH
52191: LD_INT 30
52193: PUSH
52194: LD_INT 29
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: PUSH
52201: EMPTY
52202: LIST
52203: LIST
52204: PPUSH
52205: CALL_OW 69
52209: ST_TO_ADDR
// if not tmp then
52210: LD_VAR 0 1
52214: NOT
52215: IFFALSE 52219
// exit ;
52217: GO 52232
// DestroyUnit ( tmp [ 1 ] ) ;
52219: LD_VAR 0 1
52223: PUSH
52224: LD_INT 1
52226: ARRAY
52227: PPUSH
52228: CALL_OW 65
// end ;
52232: PPOPN 1
52234: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52235: LD_EXP 91
52239: PUSH
52240: LD_EXP 129
52244: AND
52245: IFFALSE 52374
52247: GO 52249
52249: DISABLE
52250: LD_INT 0
52252: PPUSH
// begin uc_side := 0 ;
52253: LD_ADDR_OWVAR 20
52257: PUSH
52258: LD_INT 0
52260: ST_TO_ADDR
// uc_nation := nation_arabian ;
52261: LD_ADDR_OWVAR 21
52265: PUSH
52266: LD_INT 2
52268: ST_TO_ADDR
// hc_gallery :=  ;
52269: LD_ADDR_OWVAR 33
52273: PUSH
52274: LD_STRING 
52276: ST_TO_ADDR
// hc_name :=  ;
52277: LD_ADDR_OWVAR 26
52281: PUSH
52282: LD_STRING 
52284: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52285: LD_INT 1
52287: PPUSH
52288: LD_INT 11
52290: PPUSH
52291: LD_INT 10
52293: PPUSH
52294: CALL_OW 380
// un := CreateHuman ;
52298: LD_ADDR_VAR 0 1
52302: PUSH
52303: CALL_OW 44
52307: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52308: LD_VAR 0 1
52312: PPUSH
52313: LD_INT 1
52315: PPUSH
52316: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52320: LD_INT 35
52322: PPUSH
52323: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52327: LD_VAR 0 1
52331: PPUSH
52332: LD_INT 22
52334: PUSH
52335: LD_OWVAR 2
52339: PUSH
52340: EMPTY
52341: LIST
52342: LIST
52343: PPUSH
52344: CALL_OW 69
52348: PPUSH
52349: LD_VAR 0 1
52353: PPUSH
52354: CALL_OW 74
52358: PPUSH
52359: CALL_OW 115
// until IsDead ( un ) ;
52363: LD_VAR 0 1
52367: PPUSH
52368: CALL_OW 301
52372: IFFALSE 52320
// end ;
52374: PPOPN 1
52376: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52377: LD_EXP 91
52381: PUSH
52382: LD_EXP 131
52386: AND
52387: IFFALSE 52399
52389: GO 52391
52391: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52392: LD_STRING earthquake(getX(game), 0, 32)
52394: PPUSH
52395: CALL_OW 559
52399: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52400: LD_EXP 91
52404: PUSH
52405: LD_EXP 132
52409: AND
52410: IFFALSE 52501
52412: GO 52414
52414: DISABLE
52415: LD_INT 0
52417: PPUSH
// begin enable ;
52418: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52419: LD_ADDR_VAR 0 1
52423: PUSH
52424: LD_INT 22
52426: PUSH
52427: LD_OWVAR 2
52431: PUSH
52432: EMPTY
52433: LIST
52434: LIST
52435: PUSH
52436: LD_INT 21
52438: PUSH
52439: LD_INT 2
52441: PUSH
52442: EMPTY
52443: LIST
52444: LIST
52445: PUSH
52446: LD_INT 33
52448: PUSH
52449: LD_INT 3
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: PUSH
52456: EMPTY
52457: LIST
52458: LIST
52459: LIST
52460: PPUSH
52461: CALL_OW 69
52465: ST_TO_ADDR
// if not tmp then
52466: LD_VAR 0 1
52470: NOT
52471: IFFALSE 52475
// exit ;
52473: GO 52501
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52475: LD_VAR 0 1
52479: PUSH
52480: LD_INT 1
52482: PPUSH
52483: LD_VAR 0 1
52487: PPUSH
52488: CALL_OW 12
52492: ARRAY
52493: PPUSH
52494: LD_INT 1
52496: PPUSH
52497: CALL_OW 234
// end ;
52501: PPOPN 1
52503: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52504: LD_EXP 91
52508: PUSH
52509: LD_EXP 133
52513: AND
52514: IFFALSE 52655
52516: GO 52518
52518: DISABLE
52519: LD_INT 0
52521: PPUSH
52522: PPUSH
52523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52524: LD_ADDR_VAR 0 3
52528: PUSH
52529: LD_INT 22
52531: PUSH
52532: LD_OWVAR 2
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: PUSH
52541: LD_INT 25
52543: PUSH
52544: LD_INT 1
52546: PUSH
52547: EMPTY
52548: LIST
52549: LIST
52550: PUSH
52551: EMPTY
52552: LIST
52553: LIST
52554: PPUSH
52555: CALL_OW 69
52559: ST_TO_ADDR
// if not tmp then
52560: LD_VAR 0 3
52564: NOT
52565: IFFALSE 52569
// exit ;
52567: GO 52655
// un := tmp [ rand ( 1 , tmp ) ] ;
52569: LD_ADDR_VAR 0 2
52573: PUSH
52574: LD_VAR 0 3
52578: PUSH
52579: LD_INT 1
52581: PPUSH
52582: LD_VAR 0 3
52586: PPUSH
52587: CALL_OW 12
52591: ARRAY
52592: ST_TO_ADDR
// if Crawls ( un ) then
52593: LD_VAR 0 2
52597: PPUSH
52598: CALL_OW 318
52602: IFFALSE 52613
// ComWalk ( un ) ;
52604: LD_VAR 0 2
52608: PPUSH
52609: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52613: LD_VAR 0 2
52617: PPUSH
52618: LD_INT 9
52620: PPUSH
52621: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52625: LD_INT 28
52627: PPUSH
52628: LD_OWVAR 2
52632: PPUSH
52633: LD_INT 2
52635: PPUSH
52636: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52640: LD_INT 29
52642: PPUSH
52643: LD_OWVAR 2
52647: PPUSH
52648: LD_INT 2
52650: PPUSH
52651: CALL_OW 322
// end ;
52655: PPOPN 3
52657: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52658: LD_EXP 91
52662: PUSH
52663: LD_EXP 134
52667: AND
52668: IFFALSE 52779
52670: GO 52672
52672: DISABLE
52673: LD_INT 0
52675: PPUSH
52676: PPUSH
52677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52678: LD_ADDR_VAR 0 3
52682: PUSH
52683: LD_INT 22
52685: PUSH
52686: LD_OWVAR 2
52690: PUSH
52691: EMPTY
52692: LIST
52693: LIST
52694: PUSH
52695: LD_INT 25
52697: PUSH
52698: LD_INT 1
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PPUSH
52709: CALL_OW 69
52713: ST_TO_ADDR
// if not tmp then
52714: LD_VAR 0 3
52718: NOT
52719: IFFALSE 52723
// exit ;
52721: GO 52779
// un := tmp [ rand ( 1 , tmp ) ] ;
52723: LD_ADDR_VAR 0 2
52727: PUSH
52728: LD_VAR 0 3
52732: PUSH
52733: LD_INT 1
52735: PPUSH
52736: LD_VAR 0 3
52740: PPUSH
52741: CALL_OW 12
52745: ARRAY
52746: ST_TO_ADDR
// if Crawls ( un ) then
52747: LD_VAR 0 2
52751: PPUSH
52752: CALL_OW 318
52756: IFFALSE 52767
// ComWalk ( un ) ;
52758: LD_VAR 0 2
52762: PPUSH
52763: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52767: LD_VAR 0 2
52771: PPUSH
52772: LD_INT 8
52774: PPUSH
52775: CALL_OW 336
// end ;
52779: PPOPN 3
52781: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52782: LD_EXP 91
52786: PUSH
52787: LD_EXP 135
52791: AND
52792: IFFALSE 52936
52794: GO 52796
52796: DISABLE
52797: LD_INT 0
52799: PPUSH
52800: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52801: LD_ADDR_VAR 0 2
52805: PUSH
52806: LD_INT 22
52808: PUSH
52809: LD_OWVAR 2
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: PUSH
52818: LD_INT 21
52820: PUSH
52821: LD_INT 2
52823: PUSH
52824: EMPTY
52825: LIST
52826: LIST
52827: PUSH
52828: LD_INT 2
52830: PUSH
52831: LD_INT 34
52833: PUSH
52834: LD_INT 12
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: PUSH
52841: LD_INT 34
52843: PUSH
52844: LD_INT 51
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PUSH
52851: LD_INT 34
52853: PUSH
52854: LD_INT 32
52856: PUSH
52857: EMPTY
52858: LIST
52859: LIST
52860: PUSH
52861: EMPTY
52862: LIST
52863: LIST
52864: LIST
52865: LIST
52866: PUSH
52867: EMPTY
52868: LIST
52869: LIST
52870: LIST
52871: PPUSH
52872: CALL_OW 69
52876: ST_TO_ADDR
// if not tmp then
52877: LD_VAR 0 2
52881: NOT
52882: IFFALSE 52886
// exit ;
52884: GO 52936
// for i in tmp do
52886: LD_ADDR_VAR 0 1
52890: PUSH
52891: LD_VAR 0 2
52895: PUSH
52896: FOR_IN
52897: IFFALSE 52934
// if GetCargo ( i , mat_artifact ) = 0 then
52899: LD_VAR 0 1
52903: PPUSH
52904: LD_INT 4
52906: PPUSH
52907: CALL_OW 289
52911: PUSH
52912: LD_INT 0
52914: EQUAL
52915: IFFALSE 52932
// SetCargo ( i , mat_siberit , 100 ) ;
52917: LD_VAR 0 1
52921: PPUSH
52922: LD_INT 3
52924: PPUSH
52925: LD_INT 100
52927: PPUSH
52928: CALL_OW 290
52932: GO 52896
52934: POP
52935: POP
// end ;
52936: PPOPN 2
52938: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
52939: LD_EXP 91
52943: PUSH
52944: LD_EXP 136
52948: AND
52949: IFFALSE 53132
52951: GO 52953
52953: DISABLE
52954: LD_INT 0
52956: PPUSH
52957: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
52958: LD_ADDR_VAR 0 2
52962: PUSH
52963: LD_INT 22
52965: PUSH
52966: LD_OWVAR 2
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: PPUSH
52975: CALL_OW 69
52979: ST_TO_ADDR
// if not tmp then
52980: LD_VAR 0 2
52984: NOT
52985: IFFALSE 52989
// exit ;
52987: GO 53132
// for i := 1 to 2 do
52989: LD_ADDR_VAR 0 1
52993: PUSH
52994: DOUBLE
52995: LD_INT 1
52997: DEC
52998: ST_TO_ADDR
52999: LD_INT 2
53001: PUSH
53002: FOR_TO
53003: IFFALSE 53130
// begin uc_side := your_side ;
53005: LD_ADDR_OWVAR 20
53009: PUSH
53010: LD_OWVAR 2
53014: ST_TO_ADDR
// uc_nation := nation_american ;
53015: LD_ADDR_OWVAR 21
53019: PUSH
53020: LD_INT 1
53022: ST_TO_ADDR
// vc_chassis := us_morphling ;
53023: LD_ADDR_OWVAR 37
53027: PUSH
53028: LD_INT 5
53030: ST_TO_ADDR
// vc_engine := engine_siberite ;
53031: LD_ADDR_OWVAR 39
53035: PUSH
53036: LD_INT 3
53038: ST_TO_ADDR
// vc_control := control_computer ;
53039: LD_ADDR_OWVAR 38
53043: PUSH
53044: LD_INT 3
53046: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53047: LD_ADDR_OWVAR 40
53051: PUSH
53052: LD_INT 10
53054: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53055: LD_VAR 0 2
53059: PUSH
53060: LD_INT 1
53062: ARRAY
53063: PPUSH
53064: CALL_OW 310
53068: NOT
53069: IFFALSE 53116
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53071: CALL_OW 45
53075: PPUSH
53076: LD_VAR 0 2
53080: PUSH
53081: LD_INT 1
53083: ARRAY
53084: PPUSH
53085: CALL_OW 250
53089: PPUSH
53090: LD_VAR 0 2
53094: PUSH
53095: LD_INT 1
53097: ARRAY
53098: PPUSH
53099: CALL_OW 251
53103: PPUSH
53104: LD_INT 12
53106: PPUSH
53107: LD_INT 1
53109: PPUSH
53110: CALL_OW 50
53114: GO 53128
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53116: CALL_OW 45
53120: PPUSH
53121: LD_INT 1
53123: PPUSH
53124: CALL_OW 51
// end ;
53128: GO 53002
53130: POP
53131: POP
// end ;
53132: PPOPN 2
53134: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53135: LD_EXP 91
53139: PUSH
53140: LD_EXP 137
53144: AND
53145: IFFALSE 53367
53147: GO 53149
53149: DISABLE
53150: LD_INT 0
53152: PPUSH
53153: PPUSH
53154: PPUSH
53155: PPUSH
53156: PPUSH
53157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53158: LD_ADDR_VAR 0 6
53162: PUSH
53163: LD_INT 22
53165: PUSH
53166: LD_OWVAR 2
53170: PUSH
53171: EMPTY
53172: LIST
53173: LIST
53174: PUSH
53175: LD_INT 21
53177: PUSH
53178: LD_INT 1
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: PUSH
53185: LD_INT 3
53187: PUSH
53188: LD_INT 23
53190: PUSH
53191: LD_INT 0
53193: PUSH
53194: EMPTY
53195: LIST
53196: LIST
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: EMPTY
53203: LIST
53204: LIST
53205: LIST
53206: PPUSH
53207: CALL_OW 69
53211: ST_TO_ADDR
// if not tmp then
53212: LD_VAR 0 6
53216: NOT
53217: IFFALSE 53221
// exit ;
53219: GO 53367
// s1 := rand ( 1 , 4 ) ;
53221: LD_ADDR_VAR 0 2
53225: PUSH
53226: LD_INT 1
53228: PPUSH
53229: LD_INT 4
53231: PPUSH
53232: CALL_OW 12
53236: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53237: LD_ADDR_VAR 0 4
53241: PUSH
53242: LD_VAR 0 6
53246: PUSH
53247: LD_INT 1
53249: ARRAY
53250: PPUSH
53251: LD_VAR 0 2
53255: PPUSH
53256: CALL_OW 259
53260: ST_TO_ADDR
// if s1 = 1 then
53261: LD_VAR 0 2
53265: PUSH
53266: LD_INT 1
53268: EQUAL
53269: IFFALSE 53289
// s2 := rand ( 2 , 4 ) else
53271: LD_ADDR_VAR 0 3
53275: PUSH
53276: LD_INT 2
53278: PPUSH
53279: LD_INT 4
53281: PPUSH
53282: CALL_OW 12
53286: ST_TO_ADDR
53287: GO 53297
// s2 := 1 ;
53289: LD_ADDR_VAR 0 3
53293: PUSH
53294: LD_INT 1
53296: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53297: LD_ADDR_VAR 0 5
53301: PUSH
53302: LD_VAR 0 6
53306: PUSH
53307: LD_INT 1
53309: ARRAY
53310: PPUSH
53311: LD_VAR 0 3
53315: PPUSH
53316: CALL_OW 259
53320: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53321: LD_VAR 0 6
53325: PUSH
53326: LD_INT 1
53328: ARRAY
53329: PPUSH
53330: LD_VAR 0 2
53334: PPUSH
53335: LD_VAR 0 5
53339: PPUSH
53340: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53344: LD_VAR 0 6
53348: PUSH
53349: LD_INT 1
53351: ARRAY
53352: PPUSH
53353: LD_VAR 0 3
53357: PPUSH
53358: LD_VAR 0 4
53362: PPUSH
53363: CALL_OW 237
// end ;
53367: PPOPN 6
53369: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53370: LD_EXP 91
53374: PUSH
53375: LD_EXP 138
53379: AND
53380: IFFALSE 53459
53382: GO 53384
53384: DISABLE
53385: LD_INT 0
53387: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53388: LD_ADDR_VAR 0 1
53392: PUSH
53393: LD_INT 22
53395: PUSH
53396: LD_OWVAR 2
53400: PUSH
53401: EMPTY
53402: LIST
53403: LIST
53404: PUSH
53405: LD_INT 30
53407: PUSH
53408: LD_INT 3
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PUSH
53415: EMPTY
53416: LIST
53417: LIST
53418: PPUSH
53419: CALL_OW 69
53423: ST_TO_ADDR
// if not tmp then
53424: LD_VAR 0 1
53428: NOT
53429: IFFALSE 53433
// exit ;
53431: GO 53459
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53433: LD_VAR 0 1
53437: PUSH
53438: LD_INT 1
53440: PPUSH
53441: LD_VAR 0 1
53445: PPUSH
53446: CALL_OW 12
53450: ARRAY
53451: PPUSH
53452: LD_INT 1
53454: PPUSH
53455: CALL_OW 234
// end ;
53459: PPOPN 1
53461: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53462: LD_EXP 91
53466: PUSH
53467: LD_EXP 139
53471: AND
53472: IFFALSE 53584
53474: GO 53476
53476: DISABLE
53477: LD_INT 0
53479: PPUSH
53480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53481: LD_ADDR_VAR 0 2
53485: PUSH
53486: LD_INT 22
53488: PUSH
53489: LD_OWVAR 2
53493: PUSH
53494: EMPTY
53495: LIST
53496: LIST
53497: PUSH
53498: LD_INT 2
53500: PUSH
53501: LD_INT 30
53503: PUSH
53504: LD_INT 27
53506: PUSH
53507: EMPTY
53508: LIST
53509: LIST
53510: PUSH
53511: LD_INT 30
53513: PUSH
53514: LD_INT 26
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: PUSH
53521: LD_INT 30
53523: PUSH
53524: LD_INT 28
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: LIST
53535: LIST
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PPUSH
53541: CALL_OW 69
53545: ST_TO_ADDR
// if not tmp then
53546: LD_VAR 0 2
53550: NOT
53551: IFFALSE 53555
// exit ;
53553: GO 53584
// for i in tmp do
53555: LD_ADDR_VAR 0 1
53559: PUSH
53560: LD_VAR 0 2
53564: PUSH
53565: FOR_IN
53566: IFFALSE 53582
// SetLives ( i , 1 ) ;
53568: LD_VAR 0 1
53572: PPUSH
53573: LD_INT 1
53575: PPUSH
53576: CALL_OW 234
53580: GO 53565
53582: POP
53583: POP
// end ;
53584: PPOPN 2
53586: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53587: LD_EXP 91
53591: PUSH
53592: LD_EXP 140
53596: AND
53597: IFFALSE 53871
53599: GO 53601
53601: DISABLE
53602: LD_INT 0
53604: PPUSH
53605: PPUSH
53606: PPUSH
// begin i := rand ( 1 , 7 ) ;
53607: LD_ADDR_VAR 0 1
53611: PUSH
53612: LD_INT 1
53614: PPUSH
53615: LD_INT 7
53617: PPUSH
53618: CALL_OW 12
53622: ST_TO_ADDR
// case i of 1 :
53623: LD_VAR 0 1
53627: PUSH
53628: LD_INT 1
53630: DOUBLE
53631: EQUAL
53632: IFTRUE 53636
53634: GO 53646
53636: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53637: LD_STRING earthquake(getX(game), 0, 32)
53639: PPUSH
53640: CALL_OW 559
53644: GO 53871
53646: LD_INT 2
53648: DOUBLE
53649: EQUAL
53650: IFTRUE 53654
53652: GO 53668
53654: POP
// begin ToLua ( displayStucuk(); ) ;
53655: LD_STRING displayStucuk();
53657: PPUSH
53658: CALL_OW 559
// ResetFog ;
53662: CALL_OW 335
// end ; 3 :
53666: GO 53871
53668: LD_INT 3
53670: DOUBLE
53671: EQUAL
53672: IFTRUE 53676
53674: GO 53780
53676: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53677: LD_ADDR_VAR 0 2
53681: PUSH
53682: LD_INT 22
53684: PUSH
53685: LD_OWVAR 2
53689: PUSH
53690: EMPTY
53691: LIST
53692: LIST
53693: PUSH
53694: LD_INT 25
53696: PUSH
53697: LD_INT 1
53699: PUSH
53700: EMPTY
53701: LIST
53702: LIST
53703: PUSH
53704: EMPTY
53705: LIST
53706: LIST
53707: PPUSH
53708: CALL_OW 69
53712: ST_TO_ADDR
// if not tmp then
53713: LD_VAR 0 2
53717: NOT
53718: IFFALSE 53722
// exit ;
53720: GO 53871
// un := tmp [ rand ( 1 , tmp ) ] ;
53722: LD_ADDR_VAR 0 3
53726: PUSH
53727: LD_VAR 0 2
53731: PUSH
53732: LD_INT 1
53734: PPUSH
53735: LD_VAR 0 2
53739: PPUSH
53740: CALL_OW 12
53744: ARRAY
53745: ST_TO_ADDR
// if Crawls ( un ) then
53746: LD_VAR 0 3
53750: PPUSH
53751: CALL_OW 318
53755: IFFALSE 53766
// ComWalk ( un ) ;
53757: LD_VAR 0 3
53761: PPUSH
53762: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53766: LD_VAR 0 3
53770: PPUSH
53771: LD_INT 8
53773: PPUSH
53774: CALL_OW 336
// end ; 4 :
53778: GO 53871
53780: LD_INT 4
53782: DOUBLE
53783: EQUAL
53784: IFTRUE 53788
53786: GO 53849
53788: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53789: LD_ADDR_VAR 0 2
53793: PUSH
53794: LD_INT 22
53796: PUSH
53797: LD_OWVAR 2
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: PUSH
53806: LD_INT 30
53808: PUSH
53809: LD_INT 29
53811: PUSH
53812: EMPTY
53813: LIST
53814: LIST
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: PPUSH
53820: CALL_OW 69
53824: ST_TO_ADDR
// if not tmp then
53825: LD_VAR 0 2
53829: NOT
53830: IFFALSE 53834
// exit ;
53832: GO 53871
// DestroyUnit ( tmp [ 1 ] ) ;
53834: LD_VAR 0 2
53838: PUSH
53839: LD_INT 1
53841: ARRAY
53842: PPUSH
53843: CALL_OW 65
// end ; 5 .. 7 :
53847: GO 53871
53849: LD_INT 5
53851: DOUBLE
53852: GREATEREQUAL
53853: IFFALSE 53861
53855: LD_INT 7
53857: DOUBLE
53858: LESSEQUAL
53859: IFTRUE 53863
53861: GO 53870
53863: POP
// StreamSibBomb ; end ;
53864: CALL 50121 0 0
53868: GO 53871
53870: POP
// end ;
53871: PPOPN 3
53873: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53874: LD_EXP 91
53878: PUSH
53879: LD_EXP 141
53883: AND
53884: IFFALSE 54040
53886: GO 53888
53888: DISABLE
53889: LD_INT 0
53891: PPUSH
53892: PPUSH
53893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
53894: LD_ADDR_VAR 0 2
53898: PUSH
53899: LD_INT 81
53901: PUSH
53902: LD_OWVAR 2
53906: PUSH
53907: EMPTY
53908: LIST
53909: LIST
53910: PUSH
53911: LD_INT 2
53913: PUSH
53914: LD_INT 21
53916: PUSH
53917: LD_INT 1
53919: PUSH
53920: EMPTY
53921: LIST
53922: LIST
53923: PUSH
53924: LD_INT 21
53926: PUSH
53927: LD_INT 2
53929: PUSH
53930: EMPTY
53931: LIST
53932: LIST
53933: PUSH
53934: EMPTY
53935: LIST
53936: LIST
53937: LIST
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PPUSH
53943: CALL_OW 69
53947: ST_TO_ADDR
// if not tmp then
53948: LD_VAR 0 2
53952: NOT
53953: IFFALSE 53957
// exit ;
53955: GO 54040
// p := 0 ;
53957: LD_ADDR_VAR 0 3
53961: PUSH
53962: LD_INT 0
53964: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53965: LD_INT 35
53967: PPUSH
53968: CALL_OW 67
// p := p + 1 ;
53972: LD_ADDR_VAR 0 3
53976: PUSH
53977: LD_VAR 0 3
53981: PUSH
53982: LD_INT 1
53984: PLUS
53985: ST_TO_ADDR
// for i in tmp do
53986: LD_ADDR_VAR 0 1
53990: PUSH
53991: LD_VAR 0 2
53995: PUSH
53996: FOR_IN
53997: IFFALSE 54028
// if GetLives ( i ) < 1000 then
53999: LD_VAR 0 1
54003: PPUSH
54004: CALL_OW 256
54008: PUSH
54009: LD_INT 1000
54011: LESS
54012: IFFALSE 54026
// SetLives ( i , 1000 ) ;
54014: LD_VAR 0 1
54018: PPUSH
54019: LD_INT 1000
54021: PPUSH
54022: CALL_OW 234
54026: GO 53996
54028: POP
54029: POP
// until p > 20 ;
54030: LD_VAR 0 3
54034: PUSH
54035: LD_INT 20
54037: GREATER
54038: IFFALSE 53965
// end ;
54040: PPOPN 3
54042: END
// every 0 0$1 trigger StreamModeActive and sTime do
54043: LD_EXP 91
54047: PUSH
54048: LD_EXP 142
54052: AND
54053: IFFALSE 54088
54055: GO 54057
54057: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54058: LD_INT 28
54060: PPUSH
54061: LD_OWVAR 2
54065: PPUSH
54066: LD_INT 2
54068: PPUSH
54069: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54073: LD_INT 30
54075: PPUSH
54076: LD_OWVAR 2
54080: PPUSH
54081: LD_INT 2
54083: PPUSH
54084: CALL_OW 322
// end ;
54088: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54089: LD_EXP 91
54093: PUSH
54094: LD_EXP 143
54098: AND
54099: IFFALSE 54220
54101: GO 54103
54103: DISABLE
54104: LD_INT 0
54106: PPUSH
54107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54108: LD_ADDR_VAR 0 2
54112: PUSH
54113: LD_INT 22
54115: PUSH
54116: LD_OWVAR 2
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: PUSH
54125: LD_INT 21
54127: PUSH
54128: LD_INT 1
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PUSH
54135: LD_INT 3
54137: PUSH
54138: LD_INT 23
54140: PUSH
54141: LD_INT 0
54143: PUSH
54144: EMPTY
54145: LIST
54146: LIST
54147: PUSH
54148: EMPTY
54149: LIST
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: PPUSH
54157: CALL_OW 69
54161: ST_TO_ADDR
// if not tmp then
54162: LD_VAR 0 2
54166: NOT
54167: IFFALSE 54171
// exit ;
54169: GO 54220
// for i in tmp do
54171: LD_ADDR_VAR 0 1
54175: PUSH
54176: LD_VAR 0 2
54180: PUSH
54181: FOR_IN
54182: IFFALSE 54218
// begin if Crawls ( i ) then
54184: LD_VAR 0 1
54188: PPUSH
54189: CALL_OW 318
54193: IFFALSE 54204
// ComWalk ( i ) ;
54195: LD_VAR 0 1
54199: PPUSH
54200: CALL_OW 138
// SetClass ( i , 2 ) ;
54204: LD_VAR 0 1
54208: PPUSH
54209: LD_INT 2
54211: PPUSH
54212: CALL_OW 336
// end ;
54216: GO 54181
54218: POP
54219: POP
// end ;
54220: PPOPN 2
54222: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54223: LD_EXP 91
54227: PUSH
54228: LD_EXP 144
54232: AND
54233: IFFALSE 54514
54235: GO 54237
54237: DISABLE
54238: LD_INT 0
54240: PPUSH
54241: PPUSH
54242: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54243: LD_OWVAR 2
54247: PPUSH
54248: LD_INT 9
54250: PPUSH
54251: LD_INT 1
54253: PPUSH
54254: LD_INT 1
54256: PPUSH
54257: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54261: LD_INT 9
54263: PPUSH
54264: LD_OWVAR 2
54268: PPUSH
54269: CALL_OW 343
// uc_side := 9 ;
54273: LD_ADDR_OWVAR 20
54277: PUSH
54278: LD_INT 9
54280: ST_TO_ADDR
// uc_nation := 2 ;
54281: LD_ADDR_OWVAR 21
54285: PUSH
54286: LD_INT 2
54288: ST_TO_ADDR
// hc_name := Dark Warrior ;
54289: LD_ADDR_OWVAR 26
54293: PUSH
54294: LD_STRING Dark Warrior
54296: ST_TO_ADDR
// hc_gallery :=  ;
54297: LD_ADDR_OWVAR 33
54301: PUSH
54302: LD_STRING 
54304: ST_TO_ADDR
// hc_noskilllimit := true ;
54305: LD_ADDR_OWVAR 76
54309: PUSH
54310: LD_INT 1
54312: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54313: LD_ADDR_OWVAR 31
54317: PUSH
54318: LD_INT 30
54320: PUSH
54321: LD_INT 30
54323: PUSH
54324: LD_INT 30
54326: PUSH
54327: LD_INT 30
54329: PUSH
54330: EMPTY
54331: LIST
54332: LIST
54333: LIST
54334: LIST
54335: ST_TO_ADDR
// un := CreateHuman ;
54336: LD_ADDR_VAR 0 3
54340: PUSH
54341: CALL_OW 44
54345: ST_TO_ADDR
// hc_noskilllimit := false ;
54346: LD_ADDR_OWVAR 76
54350: PUSH
54351: LD_INT 0
54353: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54354: LD_VAR 0 3
54358: PPUSH
54359: LD_INT 1
54361: PPUSH
54362: CALL_OW 51
// p := 0 ;
54366: LD_ADDR_VAR 0 2
54370: PUSH
54371: LD_INT 0
54373: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54374: LD_INT 35
54376: PPUSH
54377: CALL_OW 67
// p := p + 1 ;
54381: LD_ADDR_VAR 0 2
54385: PUSH
54386: LD_VAR 0 2
54390: PUSH
54391: LD_INT 1
54393: PLUS
54394: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54395: LD_VAR 0 3
54399: PPUSH
54400: CALL_OW 256
54404: PUSH
54405: LD_INT 1000
54407: LESS
54408: IFFALSE 54422
// SetLives ( un , 1000 ) ;
54410: LD_VAR 0 3
54414: PPUSH
54415: LD_INT 1000
54417: PPUSH
54418: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54422: LD_VAR 0 3
54426: PPUSH
54427: LD_INT 81
54429: PUSH
54430: LD_OWVAR 2
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: PUSH
54439: LD_INT 91
54441: PUSH
54442: LD_VAR 0 3
54446: PUSH
54447: LD_INT 30
54449: PUSH
54450: EMPTY
54451: LIST
54452: LIST
54453: LIST
54454: PUSH
54455: EMPTY
54456: LIST
54457: LIST
54458: PPUSH
54459: CALL_OW 69
54463: PPUSH
54464: LD_VAR 0 3
54468: PPUSH
54469: CALL_OW 74
54473: PPUSH
54474: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 60
54485: GREATER
54486: PUSH
54487: LD_VAR 0 3
54491: PPUSH
54492: CALL_OW 301
54496: OR
54497: IFFALSE 54374
// if un then
54499: LD_VAR 0 3
54503: IFFALSE 54514
// RemoveUnit ( un ) ;
54505: LD_VAR 0 3
54509: PPUSH
54510: CALL_OW 64
// end ;
54514: PPOPN 3
54516: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
54517: LD_INT 0
54519: PPUSH
// case cmd of 301 :
54520: LD_VAR 0 1
54524: PUSH
54525: LD_INT 301
54527: DOUBLE
54528: EQUAL
54529: IFTRUE 54533
54531: GO 54565
54533: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
54534: LD_VAR 0 6
54538: PPUSH
54539: LD_VAR 0 7
54543: PPUSH
54544: LD_VAR 0 8
54548: PPUSH
54549: LD_VAR 0 4
54553: PPUSH
54554: LD_VAR 0 5
54558: PPUSH
54559: CALL 55766 0 5
54563: GO 54686
54565: LD_INT 302
54567: DOUBLE
54568: EQUAL
54569: IFTRUE 54573
54571: GO 54610
54573: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
54574: LD_VAR 0 6
54578: PPUSH
54579: LD_VAR 0 7
54583: PPUSH
54584: LD_VAR 0 8
54588: PPUSH
54589: LD_VAR 0 9
54593: PPUSH
54594: LD_VAR 0 4
54598: PPUSH
54599: LD_VAR 0 5
54603: PPUSH
54604: CALL 55857 0 6
54608: GO 54686
54610: LD_INT 303
54612: DOUBLE
54613: EQUAL
54614: IFTRUE 54618
54616: GO 54655
54618: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
54619: LD_VAR 0 6
54623: PPUSH
54624: LD_VAR 0 7
54628: PPUSH
54629: LD_VAR 0 8
54633: PPUSH
54634: LD_VAR 0 9
54638: PPUSH
54639: LD_VAR 0 4
54643: PPUSH
54644: LD_VAR 0 5
54648: PPUSH
54649: CALL 54691 0 6
54653: GO 54686
54655: LD_INT 304
54657: DOUBLE
54658: EQUAL
54659: IFTRUE 54663
54661: GO 54685
54663: POP
// hHackTeleport ( unit , x , y ) ; end ;
54664: LD_VAR 0 2
54668: PPUSH
54669: LD_VAR 0 4
54673: PPUSH
54674: LD_VAR 0 5
54678: PPUSH
54679: CALL 56450 0 3
54683: GO 54686
54685: POP
// end ;
54686: LD_VAR 0 12
54690: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
54691: LD_INT 0
54693: PPUSH
54694: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
54695: LD_VAR 0 1
54699: PUSH
54700: LD_INT 1
54702: LESS
54703: PUSH
54704: LD_VAR 0 1
54708: PUSH
54709: LD_INT 3
54711: GREATER
54712: OR
54713: PUSH
54714: LD_VAR 0 5
54718: PPUSH
54719: LD_VAR 0 6
54723: PPUSH
54724: CALL_OW 428
54728: OR
54729: IFFALSE 54733
// exit ;
54731: GO 55453
// uc_side := your_side ;
54733: LD_ADDR_OWVAR 20
54737: PUSH
54738: LD_OWVAR 2
54742: ST_TO_ADDR
// uc_nation := nation ;
54743: LD_ADDR_OWVAR 21
54747: PUSH
54748: LD_VAR 0 1
54752: ST_TO_ADDR
// bc_level = 1 ;
54753: LD_ADDR_OWVAR 43
54757: PUSH
54758: LD_INT 1
54760: ST_TO_ADDR
// case btype of 1 :
54761: LD_VAR 0 2
54765: PUSH
54766: LD_INT 1
54768: DOUBLE
54769: EQUAL
54770: IFTRUE 54774
54772: GO 54785
54774: POP
// bc_type := b_depot ; 2 :
54775: LD_ADDR_OWVAR 42
54779: PUSH
54780: LD_INT 0
54782: ST_TO_ADDR
54783: GO 55397
54785: LD_INT 2
54787: DOUBLE
54788: EQUAL
54789: IFTRUE 54793
54791: GO 54804
54793: POP
// bc_type := b_warehouse ; 3 :
54794: LD_ADDR_OWVAR 42
54798: PUSH
54799: LD_INT 1
54801: ST_TO_ADDR
54802: GO 55397
54804: LD_INT 3
54806: DOUBLE
54807: EQUAL
54808: IFTRUE 54812
54810: GO 54823
54812: POP
// bc_type := b_lab ; 4 .. 9 :
54813: LD_ADDR_OWVAR 42
54817: PUSH
54818: LD_INT 6
54820: ST_TO_ADDR
54821: GO 55397
54823: LD_INT 4
54825: DOUBLE
54826: GREATEREQUAL
54827: IFFALSE 54835
54829: LD_INT 9
54831: DOUBLE
54832: LESSEQUAL
54833: IFTRUE 54837
54835: GO 54889
54837: POP
// begin bc_type := b_lab_half ;
54838: LD_ADDR_OWVAR 42
54842: PUSH
54843: LD_INT 7
54845: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
54846: LD_ADDR_OWVAR 44
54850: PUSH
54851: LD_INT 10
54853: PUSH
54854: LD_INT 11
54856: PUSH
54857: LD_INT 12
54859: PUSH
54860: LD_INT 15
54862: PUSH
54863: LD_INT 14
54865: PUSH
54866: LD_INT 13
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: LIST
54873: LIST
54874: LIST
54875: LIST
54876: PUSH
54877: LD_VAR 0 2
54881: PUSH
54882: LD_INT 3
54884: MINUS
54885: ARRAY
54886: ST_TO_ADDR
// end ; 10 .. 13 :
54887: GO 55397
54889: LD_INT 10
54891: DOUBLE
54892: GREATEREQUAL
54893: IFFALSE 54901
54895: LD_INT 13
54897: DOUBLE
54898: LESSEQUAL
54899: IFTRUE 54903
54901: GO 54980
54903: POP
// begin bc_type := b_lab_full ;
54904: LD_ADDR_OWVAR 42
54908: PUSH
54909: LD_INT 8
54911: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
54912: LD_ADDR_OWVAR 44
54916: PUSH
54917: LD_INT 10
54919: PUSH
54920: LD_INT 12
54922: PUSH
54923: LD_INT 14
54925: PUSH
54926: LD_INT 13
54928: PUSH
54929: EMPTY
54930: LIST
54931: LIST
54932: LIST
54933: LIST
54934: PUSH
54935: LD_VAR 0 2
54939: PUSH
54940: LD_INT 9
54942: MINUS
54943: ARRAY
54944: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
54945: LD_ADDR_OWVAR 45
54949: PUSH
54950: LD_INT 11
54952: PUSH
54953: LD_INT 15
54955: PUSH
54956: LD_INT 12
54958: PUSH
54959: LD_INT 15
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: LIST
54966: LIST
54967: PUSH
54968: LD_VAR 0 2
54972: PUSH
54973: LD_INT 9
54975: MINUS
54976: ARRAY
54977: ST_TO_ADDR
// end ; 14 :
54978: GO 55397
54980: LD_INT 14
54982: DOUBLE
54983: EQUAL
54984: IFTRUE 54988
54986: GO 54999
54988: POP
// bc_type := b_workshop ; 15 :
54989: LD_ADDR_OWVAR 42
54993: PUSH
54994: LD_INT 2
54996: ST_TO_ADDR
54997: GO 55397
54999: LD_INT 15
55001: DOUBLE
55002: EQUAL
55003: IFTRUE 55007
55005: GO 55018
55007: POP
// bc_type := b_factory ; 16 :
55008: LD_ADDR_OWVAR 42
55012: PUSH
55013: LD_INT 3
55015: ST_TO_ADDR
55016: GO 55397
55018: LD_INT 16
55020: DOUBLE
55021: EQUAL
55022: IFTRUE 55026
55024: GO 55037
55026: POP
// bc_type := b_ext_gun ; 17 :
55027: LD_ADDR_OWVAR 42
55031: PUSH
55032: LD_INT 17
55034: ST_TO_ADDR
55035: GO 55397
55037: LD_INT 17
55039: DOUBLE
55040: EQUAL
55041: IFTRUE 55045
55043: GO 55073
55045: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55046: LD_ADDR_OWVAR 42
55050: PUSH
55051: LD_INT 19
55053: PUSH
55054: LD_INT 23
55056: PUSH
55057: LD_INT 19
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: LIST
55064: PUSH
55065: LD_VAR 0 1
55069: ARRAY
55070: ST_TO_ADDR
55071: GO 55397
55073: LD_INT 18
55075: DOUBLE
55076: EQUAL
55077: IFTRUE 55081
55079: GO 55092
55081: POP
// bc_type := b_ext_radar ; 19 :
55082: LD_ADDR_OWVAR 42
55086: PUSH
55087: LD_INT 20
55089: ST_TO_ADDR
55090: GO 55397
55092: LD_INT 19
55094: DOUBLE
55095: EQUAL
55096: IFTRUE 55100
55098: GO 55111
55100: POP
// bc_type := b_ext_radio ; 20 :
55101: LD_ADDR_OWVAR 42
55105: PUSH
55106: LD_INT 22
55108: ST_TO_ADDR
55109: GO 55397
55111: LD_INT 20
55113: DOUBLE
55114: EQUAL
55115: IFTRUE 55119
55117: GO 55130
55119: POP
// bc_type := b_ext_siberium ; 21 :
55120: LD_ADDR_OWVAR 42
55124: PUSH
55125: LD_INT 21
55127: ST_TO_ADDR
55128: GO 55397
55130: LD_INT 21
55132: DOUBLE
55133: EQUAL
55134: IFTRUE 55138
55136: GO 55149
55138: POP
// bc_type := b_ext_computer ; 22 :
55139: LD_ADDR_OWVAR 42
55143: PUSH
55144: LD_INT 24
55146: ST_TO_ADDR
55147: GO 55397
55149: LD_INT 22
55151: DOUBLE
55152: EQUAL
55153: IFTRUE 55157
55155: GO 55168
55157: POP
// bc_type := b_ext_track ; 23 :
55158: LD_ADDR_OWVAR 42
55162: PUSH
55163: LD_INT 16
55165: ST_TO_ADDR
55166: GO 55397
55168: LD_INT 23
55170: DOUBLE
55171: EQUAL
55172: IFTRUE 55176
55174: GO 55187
55176: POP
// bc_type := b_ext_laser ; 24 :
55177: LD_ADDR_OWVAR 42
55181: PUSH
55182: LD_INT 25
55184: ST_TO_ADDR
55185: GO 55397
55187: LD_INT 24
55189: DOUBLE
55190: EQUAL
55191: IFTRUE 55195
55193: GO 55206
55195: POP
// bc_type := b_control_tower ; 25 :
55196: LD_ADDR_OWVAR 42
55200: PUSH
55201: LD_INT 36
55203: ST_TO_ADDR
55204: GO 55397
55206: LD_INT 25
55208: DOUBLE
55209: EQUAL
55210: IFTRUE 55214
55212: GO 55225
55214: POP
// bc_type := b_breastwork ; 26 :
55215: LD_ADDR_OWVAR 42
55219: PUSH
55220: LD_INT 31
55222: ST_TO_ADDR
55223: GO 55397
55225: LD_INT 26
55227: DOUBLE
55228: EQUAL
55229: IFTRUE 55233
55231: GO 55244
55233: POP
// bc_type := b_bunker ; 27 :
55234: LD_ADDR_OWVAR 42
55238: PUSH
55239: LD_INT 32
55241: ST_TO_ADDR
55242: GO 55397
55244: LD_INT 27
55246: DOUBLE
55247: EQUAL
55248: IFTRUE 55252
55250: GO 55263
55252: POP
// bc_type := b_turret ; 28 :
55253: LD_ADDR_OWVAR 42
55257: PUSH
55258: LD_INT 33
55260: ST_TO_ADDR
55261: GO 55397
55263: LD_INT 28
55265: DOUBLE
55266: EQUAL
55267: IFTRUE 55271
55269: GO 55282
55271: POP
// bc_type := b_armoury ; 29 :
55272: LD_ADDR_OWVAR 42
55276: PUSH
55277: LD_INT 4
55279: ST_TO_ADDR
55280: GO 55397
55282: LD_INT 29
55284: DOUBLE
55285: EQUAL
55286: IFTRUE 55290
55288: GO 55301
55290: POP
// bc_type := b_barracks ; 30 :
55291: LD_ADDR_OWVAR 42
55295: PUSH
55296: LD_INT 5
55298: ST_TO_ADDR
55299: GO 55397
55301: LD_INT 30
55303: DOUBLE
55304: EQUAL
55305: IFTRUE 55309
55307: GO 55320
55309: POP
// bc_type := b_solar_power ; 31 :
55310: LD_ADDR_OWVAR 42
55314: PUSH
55315: LD_INT 27
55317: ST_TO_ADDR
55318: GO 55397
55320: LD_INT 31
55322: DOUBLE
55323: EQUAL
55324: IFTRUE 55328
55326: GO 55339
55328: POP
// bc_type := b_oil_power ; 32 :
55329: LD_ADDR_OWVAR 42
55333: PUSH
55334: LD_INT 26
55336: ST_TO_ADDR
55337: GO 55397
55339: LD_INT 32
55341: DOUBLE
55342: EQUAL
55343: IFTRUE 55347
55345: GO 55358
55347: POP
// bc_type := b_siberite_power ; 33 :
55348: LD_ADDR_OWVAR 42
55352: PUSH
55353: LD_INT 28
55355: ST_TO_ADDR
55356: GO 55397
55358: LD_INT 33
55360: DOUBLE
55361: EQUAL
55362: IFTRUE 55366
55364: GO 55377
55366: POP
// bc_type := b_oil_mine ; 34 :
55367: LD_ADDR_OWVAR 42
55371: PUSH
55372: LD_INT 29
55374: ST_TO_ADDR
55375: GO 55397
55377: LD_INT 34
55379: DOUBLE
55380: EQUAL
55381: IFTRUE 55385
55383: GO 55396
55385: POP
// bc_type := b_siberite_mine ; end ;
55386: LD_ADDR_OWVAR 42
55390: PUSH
55391: LD_INT 30
55393: ST_TO_ADDR
55394: GO 55397
55396: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
55397: LD_ADDR_VAR 0 8
55401: PUSH
55402: LD_VAR 0 5
55406: PPUSH
55407: LD_VAR 0 6
55411: PPUSH
55412: LD_VAR 0 3
55416: PPUSH
55417: CALL_OW 47
55421: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
55422: LD_OWVAR 42
55426: PUSH
55427: LD_INT 32
55429: PUSH
55430: LD_INT 33
55432: PUSH
55433: EMPTY
55434: LIST
55435: LIST
55436: IN
55437: IFFALSE 55453
// PlaceWeaponTurret ( b , weapon ) ;
55439: LD_VAR 0 8
55443: PPUSH
55444: LD_VAR 0 4
55448: PPUSH
55449: CALL_OW 431
// end ;
55453: LD_VAR 0 7
55457: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
55458: LD_INT 0
55460: PPUSH
55461: PPUSH
55462: PPUSH
55463: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
55464: LD_ADDR_VAR 0 4
55468: PUSH
55469: LD_INT 22
55471: PUSH
55472: LD_OWVAR 2
55476: PUSH
55477: EMPTY
55478: LIST
55479: LIST
55480: PUSH
55481: LD_INT 2
55483: PUSH
55484: LD_INT 30
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PUSH
55494: LD_INT 30
55496: PUSH
55497: LD_INT 1
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: PPUSH
55513: CALL_OW 69
55517: ST_TO_ADDR
// if not tmp then
55518: LD_VAR 0 4
55522: NOT
55523: IFFALSE 55527
// exit ;
55525: GO 55586
// for i in tmp do
55527: LD_ADDR_VAR 0 2
55531: PUSH
55532: LD_VAR 0 4
55536: PUSH
55537: FOR_IN
55538: IFFALSE 55584
// for j = 1 to 3 do
55540: LD_ADDR_VAR 0 3
55544: PUSH
55545: DOUBLE
55546: LD_INT 1
55548: DEC
55549: ST_TO_ADDR
55550: LD_INT 3
55552: PUSH
55553: FOR_TO
55554: IFFALSE 55580
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
55556: LD_VAR 0 2
55560: PPUSH
55561: CALL_OW 274
55565: PPUSH
55566: LD_VAR 0 3
55570: PPUSH
55571: LD_INT 99999
55573: PPUSH
55574: CALL_OW 277
55578: GO 55553
55580: POP
55581: POP
55582: GO 55537
55584: POP
55585: POP
// end ;
55586: LD_VAR 0 1
55590: RET
// export function hHackSetLevel10 ; var i , j ; begin
55591: LD_INT 0
55593: PPUSH
55594: PPUSH
55595: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55596: LD_ADDR_VAR 0 2
55600: PUSH
55601: LD_INT 21
55603: PUSH
55604: LD_INT 1
55606: PUSH
55607: EMPTY
55608: LIST
55609: LIST
55610: PPUSH
55611: CALL_OW 69
55615: PUSH
55616: FOR_IN
55617: IFFALSE 55669
// if IsSelected ( i ) then
55619: LD_VAR 0 2
55623: PPUSH
55624: CALL_OW 306
55628: IFFALSE 55667
// begin for j := 1 to 4 do
55630: LD_ADDR_VAR 0 3
55634: PUSH
55635: DOUBLE
55636: LD_INT 1
55638: DEC
55639: ST_TO_ADDR
55640: LD_INT 4
55642: PUSH
55643: FOR_TO
55644: IFFALSE 55665
// SetSkill ( i , j , 10 ) ;
55646: LD_VAR 0 2
55650: PPUSH
55651: LD_VAR 0 3
55655: PPUSH
55656: LD_INT 10
55658: PPUSH
55659: CALL_OW 237
55663: GO 55643
55665: POP
55666: POP
// end ;
55667: GO 55616
55669: POP
55670: POP
// end ;
55671: LD_VAR 0 1
55675: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
55676: LD_INT 0
55678: PPUSH
55679: PPUSH
55680: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55681: LD_ADDR_VAR 0 2
55685: PUSH
55686: LD_INT 22
55688: PUSH
55689: LD_OWVAR 2
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: PUSH
55698: LD_INT 21
55700: PUSH
55701: LD_INT 1
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: PPUSH
55712: CALL_OW 69
55716: PUSH
55717: FOR_IN
55718: IFFALSE 55759
// begin for j := 1 to 4 do
55720: LD_ADDR_VAR 0 3
55724: PUSH
55725: DOUBLE
55726: LD_INT 1
55728: DEC
55729: ST_TO_ADDR
55730: LD_INT 4
55732: PUSH
55733: FOR_TO
55734: IFFALSE 55755
// SetSkill ( i , j , 10 ) ;
55736: LD_VAR 0 2
55740: PPUSH
55741: LD_VAR 0 3
55745: PPUSH
55746: LD_INT 10
55748: PPUSH
55749: CALL_OW 237
55753: GO 55733
55755: POP
55756: POP
// end ;
55757: GO 55717
55759: POP
55760: POP
// end ;
55761: LD_VAR 0 1
55765: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
55766: LD_INT 0
55768: PPUSH
// uc_side := your_side ;
55769: LD_ADDR_OWVAR 20
55773: PUSH
55774: LD_OWVAR 2
55778: ST_TO_ADDR
// uc_nation := nation ;
55779: LD_ADDR_OWVAR 21
55783: PUSH
55784: LD_VAR 0 1
55788: ST_TO_ADDR
// InitHc ;
55789: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55793: LD_INT 0
55795: PPUSH
55796: LD_VAR 0 2
55800: PPUSH
55801: LD_VAR 0 3
55805: PPUSH
55806: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
55810: LD_VAR 0 4
55814: PPUSH
55815: LD_VAR 0 5
55819: PPUSH
55820: CALL_OW 428
55824: PUSH
55825: LD_INT 0
55827: EQUAL
55828: IFFALSE 55852
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
55830: CALL_OW 44
55834: PPUSH
55835: LD_VAR 0 4
55839: PPUSH
55840: LD_VAR 0 5
55844: PPUSH
55845: LD_INT 1
55847: PPUSH
55848: CALL_OW 48
// end ;
55852: LD_VAR 0 6
55856: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
55857: LD_INT 0
55859: PPUSH
55860: PPUSH
// uc_side := your_side ;
55861: LD_ADDR_OWVAR 20
55865: PUSH
55866: LD_OWVAR 2
55870: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
55871: LD_VAR 0 1
55875: PUSH
55876: LD_INT 1
55878: PUSH
55879: LD_INT 2
55881: PUSH
55882: LD_INT 3
55884: PUSH
55885: LD_INT 4
55887: PUSH
55888: LD_INT 5
55890: PUSH
55891: EMPTY
55892: LIST
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: IN
55898: IFFALSE 55910
// uc_nation := nation_american else
55900: LD_ADDR_OWVAR 21
55904: PUSH
55905: LD_INT 1
55907: ST_TO_ADDR
55908: GO 55953
// if chassis in [ 11 , 12 , 13 , 14 ] then
55910: LD_VAR 0 1
55914: PUSH
55915: LD_INT 11
55917: PUSH
55918: LD_INT 12
55920: PUSH
55921: LD_INT 13
55923: PUSH
55924: LD_INT 14
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: IN
55933: IFFALSE 55945
// uc_nation := nation_arabian else
55935: LD_ADDR_OWVAR 21
55939: PUSH
55940: LD_INT 2
55942: ST_TO_ADDR
55943: GO 55953
// uc_nation := nation_russian ;
55945: LD_ADDR_OWVAR 21
55949: PUSH
55950: LD_INT 3
55952: ST_TO_ADDR
// vc_chassis := chassis ;
55953: LD_ADDR_OWVAR 37
55957: PUSH
55958: LD_VAR 0 1
55962: ST_TO_ADDR
// vc_engine := engine ;
55963: LD_ADDR_OWVAR 39
55967: PUSH
55968: LD_VAR 0 2
55972: ST_TO_ADDR
// vc_control := control ;
55973: LD_ADDR_OWVAR 38
55977: PUSH
55978: LD_VAR 0 3
55982: ST_TO_ADDR
// vc_weapon := weapon ;
55983: LD_ADDR_OWVAR 40
55987: PUSH
55988: LD_VAR 0 4
55992: ST_TO_ADDR
// un := CreateVehicle ;
55993: LD_ADDR_VAR 0 8
55997: PUSH
55998: CALL_OW 45
56002: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
56003: LD_VAR 0 8
56007: PPUSH
56008: LD_INT 0
56010: PPUSH
56011: LD_INT 5
56013: PPUSH
56014: CALL_OW 12
56018: PPUSH
56019: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56023: LD_VAR 0 8
56027: PPUSH
56028: LD_VAR 0 5
56032: PPUSH
56033: LD_VAR 0 6
56037: PPUSH
56038: LD_INT 1
56040: PPUSH
56041: CALL_OW 48
// end ;
56045: LD_VAR 0 7
56049: RET
// export hInvincible ; every 1 do
56050: GO 56052
56052: DISABLE
// hInvincible := [ ] ;
56053: LD_ADDR_EXP 145
56057: PUSH
56058: EMPTY
56059: ST_TO_ADDR
56060: END
// every 10 do var i ;
56061: GO 56063
56063: DISABLE
56064: LD_INT 0
56066: PPUSH
// begin enable ;
56067: ENABLE
// if not hInvincible then
56068: LD_EXP 145
56072: NOT
56073: IFFALSE 56077
// exit ;
56075: GO 56121
// for i in hInvincible do
56077: LD_ADDR_VAR 0 1
56081: PUSH
56082: LD_EXP 145
56086: PUSH
56087: FOR_IN
56088: IFFALSE 56119
// if GetLives ( i ) < 1000 then
56090: LD_VAR 0 1
56094: PPUSH
56095: CALL_OW 256
56099: PUSH
56100: LD_INT 1000
56102: LESS
56103: IFFALSE 56117
// SetLives ( i , 1000 ) ;
56105: LD_VAR 0 1
56109: PPUSH
56110: LD_INT 1000
56112: PPUSH
56113: CALL_OW 234
56117: GO 56087
56119: POP
56120: POP
// end ;
56121: PPOPN 1
56123: END
// export function hHackInvincible ; var i ; begin
56124: LD_INT 0
56126: PPUSH
56127: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56128: LD_ADDR_VAR 0 2
56132: PUSH
56133: LD_INT 2
56135: PUSH
56136: LD_INT 21
56138: PUSH
56139: LD_INT 1
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: PUSH
56146: LD_INT 21
56148: PUSH
56149: LD_INT 2
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: PUSH
56156: EMPTY
56157: LIST
56158: LIST
56159: LIST
56160: PPUSH
56161: CALL_OW 69
56165: PUSH
56166: FOR_IN
56167: IFFALSE 56228
// if IsSelected ( i ) then
56169: LD_VAR 0 2
56173: PPUSH
56174: CALL_OW 306
56178: IFFALSE 56226
// begin if i in hInvincible then
56180: LD_VAR 0 2
56184: PUSH
56185: LD_EXP 145
56189: IN
56190: IFFALSE 56210
// hInvincible := hInvincible diff i else
56192: LD_ADDR_EXP 145
56196: PUSH
56197: LD_EXP 145
56201: PUSH
56202: LD_VAR 0 2
56206: DIFF
56207: ST_TO_ADDR
56208: GO 56226
// hInvincible := hInvincible union i ;
56210: LD_ADDR_EXP 145
56214: PUSH
56215: LD_EXP 145
56219: PUSH
56220: LD_VAR 0 2
56224: UNION
56225: ST_TO_ADDR
// end ;
56226: GO 56166
56228: POP
56229: POP
// end ;
56230: LD_VAR 0 1
56234: RET
// export function hHackInvisible ; var i , j ; begin
56235: LD_INT 0
56237: PPUSH
56238: PPUSH
56239: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56240: LD_ADDR_VAR 0 2
56244: PUSH
56245: LD_INT 21
56247: PUSH
56248: LD_INT 1
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: PPUSH
56255: CALL_OW 69
56259: PUSH
56260: FOR_IN
56261: IFFALSE 56285
// if IsSelected ( i ) then
56263: LD_VAR 0 2
56267: PPUSH
56268: CALL_OW 306
56272: IFFALSE 56283
// ComForceInvisible ( i ) ;
56274: LD_VAR 0 2
56278: PPUSH
56279: CALL_OW 496
56283: GO 56260
56285: POP
56286: POP
// end ;
56287: LD_VAR 0 1
56291: RET
// export function hHackChangeYourSide ; begin
56292: LD_INT 0
56294: PPUSH
// if your_side = 8 then
56295: LD_OWVAR 2
56299: PUSH
56300: LD_INT 8
56302: EQUAL
56303: IFFALSE 56315
// your_side := 0 else
56305: LD_ADDR_OWVAR 2
56309: PUSH
56310: LD_INT 0
56312: ST_TO_ADDR
56313: GO 56329
// your_side := your_side + 1 ;
56315: LD_ADDR_OWVAR 2
56319: PUSH
56320: LD_OWVAR 2
56324: PUSH
56325: LD_INT 1
56327: PLUS
56328: ST_TO_ADDR
// end ;
56329: LD_VAR 0 1
56333: RET
// export function hHackChangeUnitSide ; var i , j ; begin
56334: LD_INT 0
56336: PPUSH
56337: PPUSH
56338: PPUSH
// for i in all_units do
56339: LD_ADDR_VAR 0 2
56343: PUSH
56344: LD_OWVAR 3
56348: PUSH
56349: FOR_IN
56350: IFFALSE 56428
// if IsSelected ( i ) then
56352: LD_VAR 0 2
56356: PPUSH
56357: CALL_OW 306
56361: IFFALSE 56426
// begin j := GetSide ( i ) ;
56363: LD_ADDR_VAR 0 3
56367: PUSH
56368: LD_VAR 0 2
56372: PPUSH
56373: CALL_OW 255
56377: ST_TO_ADDR
// if j = 8 then
56378: LD_VAR 0 3
56382: PUSH
56383: LD_INT 8
56385: EQUAL
56386: IFFALSE 56398
// j := 0 else
56388: LD_ADDR_VAR 0 3
56392: PUSH
56393: LD_INT 0
56395: ST_TO_ADDR
56396: GO 56412
// j := j + 1 ;
56398: LD_ADDR_VAR 0 3
56402: PUSH
56403: LD_VAR 0 3
56407: PUSH
56408: LD_INT 1
56410: PLUS
56411: ST_TO_ADDR
// SetSide ( i , j ) ;
56412: LD_VAR 0 2
56416: PPUSH
56417: LD_VAR 0 3
56421: PPUSH
56422: CALL_OW 235
// end ;
56426: GO 56349
56428: POP
56429: POP
// end ;
56430: LD_VAR 0 1
56434: RET
// export function hHackFog ; begin
56435: LD_INT 0
56437: PPUSH
// FogOff ( true ) ;
56438: LD_INT 1
56440: PPUSH
56441: CALL_OW 344
// end ;
56445: LD_VAR 0 1
56449: RET
// export function hHackTeleport ( unit , x , y ) ; begin
56450: LD_INT 0
56452: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
56453: LD_VAR 0 1
56457: PPUSH
56458: LD_VAR 0 2
56462: PPUSH
56463: LD_VAR 0 3
56467: PPUSH
56468: LD_INT 1
56470: PPUSH
56471: LD_INT 1
56473: PPUSH
56474: CALL_OW 483
// CenterOnXY ( x , y ) ;
56478: LD_VAR 0 2
56482: PPUSH
56483: LD_VAR 0 3
56487: PPUSH
56488: CALL_OW 84
// end ; end_of_file
56492: LD_VAR 0 4
56496: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56497: LD_INT 0
56499: PPUSH
56500: PPUSH
56501: PPUSH
56502: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56503: LD_VAR 0 1
56507: PPUSH
56508: CALL_OW 264
56512: PUSH
56513: LD_EXP 79
56517: EQUAL
56518: IFFALSE 56590
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56520: LD_INT 68
56522: PPUSH
56523: LD_VAR 0 1
56527: PPUSH
56528: CALL_OW 255
56532: PPUSH
56533: CALL_OW 321
56537: PUSH
56538: LD_INT 2
56540: EQUAL
56541: IFFALSE 56553
// eff := 70 else
56543: LD_ADDR_VAR 0 4
56547: PUSH
56548: LD_INT 70
56550: ST_TO_ADDR
56551: GO 56561
// eff := 30 ;
56553: LD_ADDR_VAR 0 4
56557: PUSH
56558: LD_INT 30
56560: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56561: LD_VAR 0 1
56565: PPUSH
56566: CALL_OW 250
56570: PPUSH
56571: LD_VAR 0 1
56575: PPUSH
56576: CALL_OW 251
56580: PPUSH
56581: LD_VAR 0 4
56585: PPUSH
56586: CALL_OW 495
// end ; end ;
56590: LD_VAR 0 2
56594: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56595: LD_INT 0
56597: PPUSH
// end ;
56598: LD_VAR 0 4
56602: RET
// export function SOS_Command ( cmd ) ; begin
56603: LD_INT 0
56605: PPUSH
// end ;
56606: LD_VAR 0 2
56610: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56611: LD_INT 0
56613: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56614: LD_VAR 0 1
56618: PUSH
56619: LD_INT 250
56621: EQUAL
56622: PUSH
56623: LD_VAR 0 2
56627: PPUSH
56628: CALL_OW 264
56632: PUSH
56633: LD_EXP 82
56637: EQUAL
56638: AND
56639: IFFALSE 56660
// MinerPlaceMine ( unit , x , y ) ;
56641: LD_VAR 0 2
56645: PPUSH
56646: LD_VAR 0 4
56650: PPUSH
56651: LD_VAR 0 5
56655: PPUSH
56656: CALL 59001 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56660: LD_VAR 0 1
56664: PUSH
56665: LD_INT 251
56667: EQUAL
56668: PUSH
56669: LD_VAR 0 2
56673: PPUSH
56674: CALL_OW 264
56678: PUSH
56679: LD_EXP 82
56683: EQUAL
56684: AND
56685: IFFALSE 56706
// MinerDetonateMine ( unit , x , y ) ;
56687: LD_VAR 0 2
56691: PPUSH
56692: LD_VAR 0 4
56696: PPUSH
56697: LD_VAR 0 5
56701: PPUSH
56702: CALL 59278 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
56706: LD_VAR 0 1
56710: PUSH
56711: LD_INT 252
56713: EQUAL
56714: PUSH
56715: LD_VAR 0 2
56719: PPUSH
56720: CALL_OW 264
56724: PUSH
56725: LD_EXP 82
56729: EQUAL
56730: AND
56731: IFFALSE 56752
// MinerCreateMinefield ( unit , x , y ) ;
56733: LD_VAR 0 2
56737: PPUSH
56738: LD_VAR 0 4
56742: PPUSH
56743: LD_VAR 0 5
56747: PPUSH
56748: CALL 59695 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
56752: LD_VAR 0 1
56756: PUSH
56757: LD_INT 253
56759: EQUAL
56760: PUSH
56761: LD_VAR 0 2
56765: PPUSH
56766: CALL_OW 257
56770: PUSH
56771: LD_INT 5
56773: EQUAL
56774: AND
56775: IFFALSE 56796
// ComBinocular ( unit , x , y ) ;
56777: LD_VAR 0 2
56781: PPUSH
56782: LD_VAR 0 4
56786: PPUSH
56787: LD_VAR 0 5
56791: PPUSH
56792: CALL 60066 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56796: LD_VAR 0 1
56800: PUSH
56801: LD_INT 254
56803: EQUAL
56804: PUSH
56805: LD_VAR 0 2
56809: PPUSH
56810: CALL_OW 264
56814: PUSH
56815: LD_EXP 77
56819: EQUAL
56820: AND
56821: PUSH
56822: LD_VAR 0 3
56826: PPUSH
56827: CALL_OW 263
56831: PUSH
56832: LD_INT 3
56834: EQUAL
56835: AND
56836: IFFALSE 56852
// HackDestroyVehicle ( unit , selectedUnit ) ;
56838: LD_VAR 0 2
56842: PPUSH
56843: LD_VAR 0 3
56847: PPUSH
56848: CALL 58361 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56852: LD_VAR 0 1
56856: PUSH
56857: LD_INT 255
56859: EQUAL
56860: PUSH
56861: LD_VAR 0 2
56865: PPUSH
56866: CALL_OW 264
56870: PUSH
56871: LD_INT 14
56873: PUSH
56874: LD_INT 53
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: IN
56881: AND
56882: PUSH
56883: LD_VAR 0 4
56887: PPUSH
56888: LD_VAR 0 5
56892: PPUSH
56893: CALL_OW 488
56897: AND
56898: IFFALSE 56922
// CutTreeXYR ( unit , x , y , 12 ) ;
56900: LD_VAR 0 2
56904: PPUSH
56905: LD_VAR 0 4
56909: PPUSH
56910: LD_VAR 0 5
56914: PPUSH
56915: LD_INT 12
56917: PPUSH
56918: CALL 56927 0 4
// end ;
56922: LD_VAR 0 6
56926: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56927: LD_INT 0
56929: PPUSH
56930: PPUSH
56931: PPUSH
56932: PPUSH
56933: PPUSH
56934: PPUSH
56935: PPUSH
56936: PPUSH
56937: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56938: LD_VAR 0 1
56942: NOT
56943: PUSH
56944: LD_VAR 0 2
56948: PPUSH
56949: LD_VAR 0 3
56953: PPUSH
56954: CALL_OW 488
56958: NOT
56959: OR
56960: PUSH
56961: LD_VAR 0 4
56965: NOT
56966: OR
56967: IFFALSE 56971
// exit ;
56969: GO 57311
// list := [ ] ;
56971: LD_ADDR_VAR 0 13
56975: PUSH
56976: EMPTY
56977: ST_TO_ADDR
// if x - r < 0 then
56978: LD_VAR 0 2
56982: PUSH
56983: LD_VAR 0 4
56987: MINUS
56988: PUSH
56989: LD_INT 0
56991: LESS
56992: IFFALSE 57004
// min_x := 0 else
56994: LD_ADDR_VAR 0 7
56998: PUSH
56999: LD_INT 0
57001: ST_TO_ADDR
57002: GO 57020
// min_x := x - r ;
57004: LD_ADDR_VAR 0 7
57008: PUSH
57009: LD_VAR 0 2
57013: PUSH
57014: LD_VAR 0 4
57018: MINUS
57019: ST_TO_ADDR
// if y - r < 0 then
57020: LD_VAR 0 3
57024: PUSH
57025: LD_VAR 0 4
57029: MINUS
57030: PUSH
57031: LD_INT 0
57033: LESS
57034: IFFALSE 57046
// min_y := 0 else
57036: LD_ADDR_VAR 0 8
57040: PUSH
57041: LD_INT 0
57043: ST_TO_ADDR
57044: GO 57062
// min_y := y - r ;
57046: LD_ADDR_VAR 0 8
57050: PUSH
57051: LD_VAR 0 3
57055: PUSH
57056: LD_VAR 0 4
57060: MINUS
57061: ST_TO_ADDR
// max_x := x + r ;
57062: LD_ADDR_VAR 0 9
57066: PUSH
57067: LD_VAR 0 2
57071: PUSH
57072: LD_VAR 0 4
57076: PLUS
57077: ST_TO_ADDR
// max_y := y + r ;
57078: LD_ADDR_VAR 0 10
57082: PUSH
57083: LD_VAR 0 3
57087: PUSH
57088: LD_VAR 0 4
57092: PLUS
57093: ST_TO_ADDR
// for _x = min_x to max_x do
57094: LD_ADDR_VAR 0 11
57098: PUSH
57099: DOUBLE
57100: LD_VAR 0 7
57104: DEC
57105: ST_TO_ADDR
57106: LD_VAR 0 9
57110: PUSH
57111: FOR_TO
57112: IFFALSE 57229
// for _y = min_y to max_y do
57114: LD_ADDR_VAR 0 12
57118: PUSH
57119: DOUBLE
57120: LD_VAR 0 8
57124: DEC
57125: ST_TO_ADDR
57126: LD_VAR 0 10
57130: PUSH
57131: FOR_TO
57132: IFFALSE 57225
// begin if not ValidHex ( _x , _y ) then
57134: LD_VAR 0 11
57138: PPUSH
57139: LD_VAR 0 12
57143: PPUSH
57144: CALL_OW 488
57148: NOT
57149: IFFALSE 57153
// continue ;
57151: GO 57131
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57153: LD_VAR 0 11
57157: PPUSH
57158: LD_VAR 0 12
57162: PPUSH
57163: CALL_OW 351
57167: PUSH
57168: LD_VAR 0 11
57172: PPUSH
57173: LD_VAR 0 12
57177: PPUSH
57178: CALL_OW 554
57182: AND
57183: IFFALSE 57223
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57185: LD_ADDR_VAR 0 13
57189: PUSH
57190: LD_VAR 0 13
57194: PPUSH
57195: LD_VAR 0 13
57199: PUSH
57200: LD_INT 1
57202: PLUS
57203: PPUSH
57204: LD_VAR 0 11
57208: PUSH
57209: LD_VAR 0 12
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: PPUSH
57218: CALL_OW 2
57222: ST_TO_ADDR
// end ;
57223: GO 57131
57225: POP
57226: POP
57227: GO 57111
57229: POP
57230: POP
// if not list then
57231: LD_VAR 0 13
57235: NOT
57236: IFFALSE 57240
// exit ;
57238: GO 57311
// for i in list do
57240: LD_ADDR_VAR 0 6
57244: PUSH
57245: LD_VAR 0 13
57249: PUSH
57250: FOR_IN
57251: IFFALSE 57309
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57253: LD_VAR 0 1
57257: PPUSH
57258: LD_STRING M
57260: PUSH
57261: LD_VAR 0 6
57265: PUSH
57266: LD_INT 1
57268: ARRAY
57269: PUSH
57270: LD_VAR 0 6
57274: PUSH
57275: LD_INT 2
57277: ARRAY
57278: PUSH
57279: LD_INT 0
57281: PUSH
57282: LD_INT 0
57284: PUSH
57285: LD_INT 0
57287: PUSH
57288: LD_INT 0
57290: PUSH
57291: EMPTY
57292: LIST
57293: LIST
57294: LIST
57295: LIST
57296: LIST
57297: LIST
57298: LIST
57299: PUSH
57300: EMPTY
57301: LIST
57302: PPUSH
57303: CALL_OW 447
57307: GO 57250
57309: POP
57310: POP
// end ;
57311: LD_VAR 0 5
57315: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57316: LD_EXP 146
57320: NOT
57321: IFFALSE 57371
57323: GO 57325
57325: DISABLE
// begin initHack := true ;
57326: LD_ADDR_EXP 146
57330: PUSH
57331: LD_INT 1
57333: ST_TO_ADDR
// hackTanks := [ ] ;
57334: LD_ADDR_EXP 147
57338: PUSH
57339: EMPTY
57340: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57341: LD_ADDR_EXP 148
57345: PUSH
57346: EMPTY
57347: ST_TO_ADDR
// hackLimit := 3 ;
57348: LD_ADDR_EXP 149
57352: PUSH
57353: LD_INT 3
57355: ST_TO_ADDR
// hackDist := 12 ;
57356: LD_ADDR_EXP 150
57360: PUSH
57361: LD_INT 12
57363: ST_TO_ADDR
// hackCounter := [ ] ;
57364: LD_ADDR_EXP 151
57368: PUSH
57369: EMPTY
57370: ST_TO_ADDR
// end ;
57371: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57372: LD_EXP 146
57376: PUSH
57377: LD_INT 34
57379: PUSH
57380: LD_EXP 77
57384: PUSH
57385: EMPTY
57386: LIST
57387: LIST
57388: PPUSH
57389: CALL_OW 69
57393: AND
57394: IFFALSE 57649
57396: GO 57398
57398: DISABLE
57399: LD_INT 0
57401: PPUSH
57402: PPUSH
// begin enable ;
57403: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57404: LD_ADDR_VAR 0 1
57408: PUSH
57409: LD_INT 34
57411: PUSH
57412: LD_EXP 77
57416: PUSH
57417: EMPTY
57418: LIST
57419: LIST
57420: PPUSH
57421: CALL_OW 69
57425: PUSH
57426: FOR_IN
57427: IFFALSE 57647
// begin if not i in hackTanks then
57429: LD_VAR 0 1
57433: PUSH
57434: LD_EXP 147
57438: IN
57439: NOT
57440: IFFALSE 57523
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57442: LD_ADDR_EXP 147
57446: PUSH
57447: LD_EXP 147
57451: PPUSH
57452: LD_EXP 147
57456: PUSH
57457: LD_INT 1
57459: PLUS
57460: PPUSH
57461: LD_VAR 0 1
57465: PPUSH
57466: CALL_OW 1
57470: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57471: LD_ADDR_EXP 148
57475: PUSH
57476: LD_EXP 148
57480: PPUSH
57481: LD_EXP 148
57485: PUSH
57486: LD_INT 1
57488: PLUS
57489: PPUSH
57490: EMPTY
57491: PPUSH
57492: CALL_OW 1
57496: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57497: LD_ADDR_EXP 151
57501: PUSH
57502: LD_EXP 151
57506: PPUSH
57507: LD_EXP 151
57511: PUSH
57512: LD_INT 1
57514: PLUS
57515: PPUSH
57516: EMPTY
57517: PPUSH
57518: CALL_OW 1
57522: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57523: LD_VAR 0 1
57527: PPUSH
57528: CALL_OW 302
57532: NOT
57533: IFFALSE 57546
// begin HackUnlinkAll ( i ) ;
57535: LD_VAR 0 1
57539: PPUSH
57540: CALL 57652 0 1
// continue ;
57544: GO 57426
// end ; HackCheckCapturedStatus ( i ) ;
57546: LD_VAR 0 1
57550: PPUSH
57551: CALL 58095 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57555: LD_ADDR_VAR 0 2
57559: PUSH
57560: LD_INT 81
57562: PUSH
57563: LD_VAR 0 1
57567: PPUSH
57568: CALL_OW 255
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: PUSH
57577: LD_INT 33
57579: PUSH
57580: LD_INT 3
57582: PUSH
57583: EMPTY
57584: LIST
57585: LIST
57586: PUSH
57587: LD_INT 91
57589: PUSH
57590: LD_VAR 0 1
57594: PUSH
57595: LD_EXP 150
57599: PUSH
57600: EMPTY
57601: LIST
57602: LIST
57603: LIST
57604: PUSH
57605: LD_INT 50
57607: PUSH
57608: EMPTY
57609: LIST
57610: PUSH
57611: EMPTY
57612: LIST
57613: LIST
57614: LIST
57615: LIST
57616: PPUSH
57617: CALL_OW 69
57621: ST_TO_ADDR
// if not tmp then
57622: LD_VAR 0 2
57626: NOT
57627: IFFALSE 57631
// continue ;
57629: GO 57426
// HackLink ( i , tmp ) ;
57631: LD_VAR 0 1
57635: PPUSH
57636: LD_VAR 0 2
57640: PPUSH
57641: CALL 57788 0 2
// end ;
57645: GO 57426
57647: POP
57648: POP
// end ;
57649: PPOPN 2
57651: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57652: LD_INT 0
57654: PPUSH
57655: PPUSH
57656: PPUSH
// if not hack in hackTanks then
57657: LD_VAR 0 1
57661: PUSH
57662: LD_EXP 147
57666: IN
57667: NOT
57668: IFFALSE 57672
// exit ;
57670: GO 57783
// index := GetElementIndex ( hackTanks , hack ) ;
57672: LD_ADDR_VAR 0 4
57676: PUSH
57677: LD_EXP 147
57681: PPUSH
57682: LD_VAR 0 1
57686: PPUSH
57687: CALL 65217 0 2
57691: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57692: LD_EXP 148
57696: PUSH
57697: LD_VAR 0 4
57701: ARRAY
57702: IFFALSE 57783
// begin for i in hackTanksCaptured [ index ] do
57704: LD_ADDR_VAR 0 3
57708: PUSH
57709: LD_EXP 148
57713: PUSH
57714: LD_VAR 0 4
57718: ARRAY
57719: PUSH
57720: FOR_IN
57721: IFFALSE 57747
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57723: LD_VAR 0 3
57727: PUSH
57728: LD_INT 1
57730: ARRAY
57731: PPUSH
57732: LD_VAR 0 3
57736: PUSH
57737: LD_INT 2
57739: ARRAY
57740: PPUSH
57741: CALL_OW 235
57745: GO 57720
57747: POP
57748: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57749: LD_ADDR_EXP 148
57753: PUSH
57754: LD_EXP 148
57758: PPUSH
57759: LD_VAR 0 4
57763: PPUSH
57764: EMPTY
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57771: LD_VAR 0 1
57775: PPUSH
57776: LD_INT 0
57778: PPUSH
57779: CALL_OW 505
// end ; end ;
57783: LD_VAR 0 2
57787: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57788: LD_INT 0
57790: PPUSH
57791: PPUSH
57792: PPUSH
// if not hack in hackTanks or not vehicles then
57793: LD_VAR 0 1
57797: PUSH
57798: LD_EXP 147
57802: IN
57803: NOT
57804: PUSH
57805: LD_VAR 0 2
57809: NOT
57810: OR
57811: IFFALSE 57815
// exit ;
57813: GO 58090
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57815: LD_ADDR_VAR 0 2
57819: PUSH
57820: LD_VAR 0 1
57824: PPUSH
57825: LD_VAR 0 2
57829: PPUSH
57830: LD_INT 1
57832: PPUSH
57833: LD_INT 1
57835: PPUSH
57836: CALL 65867 0 4
57840: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57841: LD_ADDR_VAR 0 5
57845: PUSH
57846: LD_EXP 147
57850: PPUSH
57851: LD_VAR 0 1
57855: PPUSH
57856: CALL 65217 0 2
57860: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57861: LD_EXP 148
57865: PUSH
57866: LD_VAR 0 5
57870: ARRAY
57871: PUSH
57872: LD_EXP 149
57876: LESS
57877: IFFALSE 58066
// begin for i := 1 to vehicles do
57879: LD_ADDR_VAR 0 4
57883: PUSH
57884: DOUBLE
57885: LD_INT 1
57887: DEC
57888: ST_TO_ADDR
57889: LD_VAR 0 2
57893: PUSH
57894: FOR_TO
57895: IFFALSE 58064
// begin if hackTanksCaptured [ index ] = hackLimit then
57897: LD_EXP 148
57901: PUSH
57902: LD_VAR 0 5
57906: ARRAY
57907: PUSH
57908: LD_EXP 149
57912: EQUAL
57913: IFFALSE 57917
// break ;
57915: GO 58064
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57917: LD_ADDR_EXP 151
57921: PUSH
57922: LD_EXP 151
57926: PPUSH
57927: LD_VAR 0 5
57931: PPUSH
57932: LD_EXP 151
57936: PUSH
57937: LD_VAR 0 5
57941: ARRAY
57942: PUSH
57943: LD_INT 1
57945: PLUS
57946: PPUSH
57947: CALL_OW 1
57951: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57952: LD_ADDR_EXP 148
57956: PUSH
57957: LD_EXP 148
57961: PPUSH
57962: LD_VAR 0 5
57966: PUSH
57967: LD_EXP 148
57971: PUSH
57972: LD_VAR 0 5
57976: ARRAY
57977: PUSH
57978: LD_INT 1
57980: PLUS
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: PPUSH
57986: LD_VAR 0 2
57990: PUSH
57991: LD_VAR 0 4
57995: ARRAY
57996: PUSH
57997: LD_VAR 0 2
58001: PUSH
58002: LD_VAR 0 4
58006: ARRAY
58007: PPUSH
58008: CALL_OW 255
58012: PUSH
58013: EMPTY
58014: LIST
58015: LIST
58016: PPUSH
58017: CALL 65432 0 3
58021: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58022: LD_VAR 0 2
58026: PUSH
58027: LD_VAR 0 4
58031: ARRAY
58032: PPUSH
58033: LD_VAR 0 1
58037: PPUSH
58038: CALL_OW 255
58042: PPUSH
58043: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58047: LD_VAR 0 2
58051: PUSH
58052: LD_VAR 0 4
58056: ARRAY
58057: PPUSH
58058: CALL_OW 141
// end ;
58062: GO 57894
58064: POP
58065: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58066: LD_VAR 0 1
58070: PPUSH
58071: LD_EXP 148
58075: PUSH
58076: LD_VAR 0 5
58080: ARRAY
58081: PUSH
58082: LD_INT 0
58084: PLUS
58085: PPUSH
58086: CALL_OW 505
// end ;
58090: LD_VAR 0 3
58094: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58095: LD_INT 0
58097: PPUSH
58098: PPUSH
58099: PPUSH
58100: PPUSH
// if not hack in hackTanks then
58101: LD_VAR 0 1
58105: PUSH
58106: LD_EXP 147
58110: IN
58111: NOT
58112: IFFALSE 58116
// exit ;
58114: GO 58356
// index := GetElementIndex ( hackTanks , hack ) ;
58116: LD_ADDR_VAR 0 4
58120: PUSH
58121: LD_EXP 147
58125: PPUSH
58126: LD_VAR 0 1
58130: PPUSH
58131: CALL 65217 0 2
58135: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58136: LD_ADDR_VAR 0 3
58140: PUSH
58141: DOUBLE
58142: LD_EXP 148
58146: PUSH
58147: LD_VAR 0 4
58151: ARRAY
58152: INC
58153: ST_TO_ADDR
58154: LD_INT 1
58156: PUSH
58157: FOR_DOWNTO
58158: IFFALSE 58330
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58160: LD_ADDR_VAR 0 5
58164: PUSH
58165: LD_EXP 148
58169: PUSH
58170: LD_VAR 0 4
58174: ARRAY
58175: PUSH
58176: LD_VAR 0 3
58180: ARRAY
58181: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58182: LD_VAR 0 5
58186: PUSH
58187: LD_INT 1
58189: ARRAY
58190: PPUSH
58191: CALL_OW 302
58195: NOT
58196: PUSH
58197: LD_VAR 0 5
58201: PUSH
58202: LD_INT 1
58204: ARRAY
58205: PPUSH
58206: CALL_OW 255
58210: PUSH
58211: LD_VAR 0 1
58215: PPUSH
58216: CALL_OW 255
58220: NONEQUAL
58221: OR
58222: IFFALSE 58328
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58224: LD_VAR 0 5
58228: PUSH
58229: LD_INT 1
58231: ARRAY
58232: PPUSH
58233: CALL_OW 305
58237: PUSH
58238: LD_VAR 0 5
58242: PUSH
58243: LD_INT 1
58245: ARRAY
58246: PPUSH
58247: CALL_OW 255
58251: PUSH
58252: LD_VAR 0 1
58256: PPUSH
58257: CALL_OW 255
58261: EQUAL
58262: AND
58263: IFFALSE 58287
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58265: LD_VAR 0 5
58269: PUSH
58270: LD_INT 1
58272: ARRAY
58273: PPUSH
58274: LD_VAR 0 5
58278: PUSH
58279: LD_INT 2
58281: ARRAY
58282: PPUSH
58283: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58287: LD_ADDR_EXP 148
58291: PUSH
58292: LD_EXP 148
58296: PPUSH
58297: LD_VAR 0 4
58301: PPUSH
58302: LD_EXP 148
58306: PUSH
58307: LD_VAR 0 4
58311: ARRAY
58312: PPUSH
58313: LD_VAR 0 3
58317: PPUSH
58318: CALL_OW 3
58322: PPUSH
58323: CALL_OW 1
58327: ST_TO_ADDR
// end ; end ;
58328: GO 58157
58330: POP
58331: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58332: LD_VAR 0 1
58336: PPUSH
58337: LD_EXP 148
58341: PUSH
58342: LD_VAR 0 4
58346: ARRAY
58347: PUSH
58348: LD_INT 0
58350: PLUS
58351: PPUSH
58352: CALL_OW 505
// end ;
58356: LD_VAR 0 2
58360: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58361: LD_INT 0
58363: PPUSH
58364: PPUSH
58365: PPUSH
58366: PPUSH
// if not hack in hackTanks then
58367: LD_VAR 0 1
58371: PUSH
58372: LD_EXP 147
58376: IN
58377: NOT
58378: IFFALSE 58382
// exit ;
58380: GO 58467
// index := GetElementIndex ( hackTanks , hack ) ;
58382: LD_ADDR_VAR 0 5
58386: PUSH
58387: LD_EXP 147
58391: PPUSH
58392: LD_VAR 0 1
58396: PPUSH
58397: CALL 65217 0 2
58401: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58402: LD_ADDR_VAR 0 4
58406: PUSH
58407: DOUBLE
58408: LD_INT 1
58410: DEC
58411: ST_TO_ADDR
58412: LD_EXP 148
58416: PUSH
58417: LD_VAR 0 5
58421: ARRAY
58422: PUSH
58423: FOR_TO
58424: IFFALSE 58465
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58426: LD_EXP 148
58430: PUSH
58431: LD_VAR 0 5
58435: ARRAY
58436: PUSH
58437: LD_VAR 0 4
58441: ARRAY
58442: PUSH
58443: LD_INT 1
58445: ARRAY
58446: PUSH
58447: LD_VAR 0 2
58451: EQUAL
58452: IFFALSE 58463
// KillUnit ( vehicle ) ;
58454: LD_VAR 0 2
58458: PPUSH
58459: CALL_OW 66
58463: GO 58423
58465: POP
58466: POP
// end ;
58467: LD_VAR 0 3
58471: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58472: LD_EXP 152
58476: NOT
58477: IFFALSE 58512
58479: GO 58481
58481: DISABLE
// begin initMiner := true ;
58482: LD_ADDR_EXP 152
58486: PUSH
58487: LD_INT 1
58489: ST_TO_ADDR
// minersList := [ ] ;
58490: LD_ADDR_EXP 153
58494: PUSH
58495: EMPTY
58496: ST_TO_ADDR
// minerMinesList := [ ] ;
58497: LD_ADDR_EXP 154
58501: PUSH
58502: EMPTY
58503: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58504: LD_ADDR_EXP 155
58508: PUSH
58509: LD_INT 5
58511: ST_TO_ADDR
// end ;
58512: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58513: LD_EXP 152
58517: PUSH
58518: LD_INT 34
58520: PUSH
58521: LD_EXP 82
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: PPUSH
58530: CALL_OW 69
58534: AND
58535: IFFALSE 58998
58537: GO 58539
58539: DISABLE
58540: LD_INT 0
58542: PPUSH
58543: PPUSH
58544: PPUSH
58545: PPUSH
// begin enable ;
58546: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58547: LD_ADDR_VAR 0 1
58551: PUSH
58552: LD_INT 34
58554: PUSH
58555: LD_EXP 82
58559: PUSH
58560: EMPTY
58561: LIST
58562: LIST
58563: PPUSH
58564: CALL_OW 69
58568: PUSH
58569: FOR_IN
58570: IFFALSE 58642
// begin if not i in minersList then
58572: LD_VAR 0 1
58576: PUSH
58577: LD_EXP 153
58581: IN
58582: NOT
58583: IFFALSE 58640
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58585: LD_ADDR_EXP 153
58589: PUSH
58590: LD_EXP 153
58594: PPUSH
58595: LD_EXP 153
58599: PUSH
58600: LD_INT 1
58602: PLUS
58603: PPUSH
58604: LD_VAR 0 1
58608: PPUSH
58609: CALL_OW 1
58613: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58614: LD_ADDR_EXP 154
58618: PUSH
58619: LD_EXP 154
58623: PPUSH
58624: LD_EXP 154
58628: PUSH
58629: LD_INT 1
58631: PLUS
58632: PPUSH
58633: EMPTY
58634: PPUSH
58635: CALL_OW 1
58639: ST_TO_ADDR
// end end ;
58640: GO 58569
58642: POP
58643: POP
// for i := minerMinesList downto 1 do
58644: LD_ADDR_VAR 0 1
58648: PUSH
58649: DOUBLE
58650: LD_EXP 154
58654: INC
58655: ST_TO_ADDR
58656: LD_INT 1
58658: PUSH
58659: FOR_DOWNTO
58660: IFFALSE 58996
// begin if IsLive ( minersList [ i ] ) then
58662: LD_EXP 153
58666: PUSH
58667: LD_VAR 0 1
58671: ARRAY
58672: PPUSH
58673: CALL_OW 300
58677: IFFALSE 58705
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
58679: LD_EXP 153
58683: PUSH
58684: LD_VAR 0 1
58688: ARRAY
58689: PPUSH
58690: LD_EXP 154
58694: PUSH
58695: LD_VAR 0 1
58699: ARRAY
58700: PPUSH
58701: CALL_OW 505
// if not minerMinesList [ i ] then
58705: LD_EXP 154
58709: PUSH
58710: LD_VAR 0 1
58714: ARRAY
58715: NOT
58716: IFFALSE 58720
// continue ;
58718: GO 58659
// for j := minerMinesList [ i ] downto 1 do
58720: LD_ADDR_VAR 0 2
58724: PUSH
58725: DOUBLE
58726: LD_EXP 154
58730: PUSH
58731: LD_VAR 0 1
58735: ARRAY
58736: INC
58737: ST_TO_ADDR
58738: LD_INT 1
58740: PUSH
58741: FOR_DOWNTO
58742: IFFALSE 58992
// begin side := GetSide ( minersList [ i ] ) ;
58744: LD_ADDR_VAR 0 3
58748: PUSH
58749: LD_EXP 153
58753: PUSH
58754: LD_VAR 0 1
58758: ARRAY
58759: PPUSH
58760: CALL_OW 255
58764: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
58765: LD_ADDR_VAR 0 4
58769: PUSH
58770: LD_EXP 154
58774: PUSH
58775: LD_VAR 0 1
58779: ARRAY
58780: PUSH
58781: LD_VAR 0 2
58785: ARRAY
58786: PUSH
58787: LD_INT 1
58789: ARRAY
58790: PPUSH
58791: LD_EXP 154
58795: PUSH
58796: LD_VAR 0 1
58800: ARRAY
58801: PUSH
58802: LD_VAR 0 2
58806: ARRAY
58807: PUSH
58808: LD_INT 2
58810: ARRAY
58811: PPUSH
58812: CALL_OW 428
58816: ST_TO_ADDR
// if not tmp then
58817: LD_VAR 0 4
58821: NOT
58822: IFFALSE 58826
// continue ;
58824: GO 58741
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
58826: LD_VAR 0 4
58830: PUSH
58831: LD_INT 81
58833: PUSH
58834: LD_VAR 0 3
58838: PUSH
58839: EMPTY
58840: LIST
58841: LIST
58842: PPUSH
58843: CALL_OW 69
58847: IN
58848: PUSH
58849: LD_EXP 154
58853: PUSH
58854: LD_VAR 0 1
58858: ARRAY
58859: PUSH
58860: LD_VAR 0 2
58864: ARRAY
58865: PUSH
58866: LD_INT 1
58868: ARRAY
58869: PPUSH
58870: LD_EXP 154
58874: PUSH
58875: LD_VAR 0 1
58879: ARRAY
58880: PUSH
58881: LD_VAR 0 2
58885: ARRAY
58886: PUSH
58887: LD_INT 2
58889: ARRAY
58890: PPUSH
58891: CALL_OW 458
58895: AND
58896: IFFALSE 58990
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
58898: LD_EXP 154
58902: PUSH
58903: LD_VAR 0 1
58907: ARRAY
58908: PUSH
58909: LD_VAR 0 2
58913: ARRAY
58914: PUSH
58915: LD_INT 1
58917: ARRAY
58918: PPUSH
58919: LD_EXP 154
58923: PUSH
58924: LD_VAR 0 1
58928: ARRAY
58929: PUSH
58930: LD_VAR 0 2
58934: ARRAY
58935: PUSH
58936: LD_INT 2
58938: ARRAY
58939: PPUSH
58940: LD_VAR 0 3
58944: PPUSH
58945: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
58949: LD_ADDR_EXP 154
58953: PUSH
58954: LD_EXP 154
58958: PPUSH
58959: LD_VAR 0 1
58963: PPUSH
58964: LD_EXP 154
58968: PUSH
58969: LD_VAR 0 1
58973: ARRAY
58974: PPUSH
58975: LD_VAR 0 2
58979: PPUSH
58980: CALL_OW 3
58984: PPUSH
58985: CALL_OW 1
58989: ST_TO_ADDR
// end ; end ;
58990: GO 58741
58992: POP
58993: POP
// end ;
58994: GO 58659
58996: POP
58997: POP
// end ;
58998: PPOPN 4
59000: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59001: LD_INT 0
59003: PPUSH
59004: PPUSH
// result := false ;
59005: LD_ADDR_VAR 0 4
59009: PUSH
59010: LD_INT 0
59012: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59013: LD_VAR 0 1
59017: PPUSH
59018: CALL_OW 264
59022: PUSH
59023: LD_EXP 82
59027: EQUAL
59028: NOT
59029: IFFALSE 59033
// exit ;
59031: GO 59273
// index := GetElementIndex ( minersList , unit ) ;
59033: LD_ADDR_VAR 0 5
59037: PUSH
59038: LD_EXP 153
59042: PPUSH
59043: LD_VAR 0 1
59047: PPUSH
59048: CALL 65217 0 2
59052: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59053: LD_EXP 154
59057: PUSH
59058: LD_VAR 0 5
59062: ARRAY
59063: PUSH
59064: LD_EXP 155
59068: GREATEREQUAL
59069: IFFALSE 59073
// exit ;
59071: GO 59273
// ComMoveXY ( unit , x , y ) ;
59073: LD_VAR 0 1
59077: PPUSH
59078: LD_VAR 0 2
59082: PPUSH
59083: LD_VAR 0 3
59087: PPUSH
59088: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59092: LD_INT 35
59094: PPUSH
59095: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59099: LD_VAR 0 1
59103: PPUSH
59104: LD_VAR 0 2
59108: PPUSH
59109: LD_VAR 0 3
59113: PPUSH
59114: CALL 95281 0 3
59118: NOT
59119: PUSH
59120: LD_VAR 0 1
59124: PPUSH
59125: CALL_OW 314
59129: AND
59130: IFFALSE 59134
// exit ;
59132: GO 59273
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59134: LD_VAR 0 2
59138: PPUSH
59139: LD_VAR 0 3
59143: PPUSH
59144: CALL_OW 428
59148: PUSH
59149: LD_VAR 0 1
59153: EQUAL
59154: PUSH
59155: LD_VAR 0 1
59159: PPUSH
59160: CALL_OW 314
59164: NOT
59165: AND
59166: IFFALSE 59092
// PlaySoundXY ( x , y , PlantMine ) ;
59168: LD_VAR 0 2
59172: PPUSH
59173: LD_VAR 0 3
59177: PPUSH
59178: LD_STRING PlantMine
59180: PPUSH
59181: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59185: LD_VAR 0 2
59189: PPUSH
59190: LD_VAR 0 3
59194: PPUSH
59195: LD_VAR 0 1
59199: PPUSH
59200: CALL_OW 255
59204: PPUSH
59205: LD_INT 0
59207: PPUSH
59208: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59212: LD_ADDR_EXP 154
59216: PUSH
59217: LD_EXP 154
59221: PPUSH
59222: LD_VAR 0 5
59226: PUSH
59227: LD_EXP 154
59231: PUSH
59232: LD_VAR 0 5
59236: ARRAY
59237: PUSH
59238: LD_INT 1
59240: PLUS
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PPUSH
59246: LD_VAR 0 2
59250: PUSH
59251: LD_VAR 0 3
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: PPUSH
59260: CALL 65432 0 3
59264: ST_TO_ADDR
// result := true ;
59265: LD_ADDR_VAR 0 4
59269: PUSH
59270: LD_INT 1
59272: ST_TO_ADDR
// end ;
59273: LD_VAR 0 4
59277: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59278: LD_INT 0
59280: PPUSH
59281: PPUSH
59282: PPUSH
// if not unit in minersList then
59283: LD_VAR 0 1
59287: PUSH
59288: LD_EXP 153
59292: IN
59293: NOT
59294: IFFALSE 59298
// exit ;
59296: GO 59690
// index := GetElementIndex ( minersList , unit ) ;
59298: LD_ADDR_VAR 0 6
59302: PUSH
59303: LD_EXP 153
59307: PPUSH
59308: LD_VAR 0 1
59312: PPUSH
59313: CALL 65217 0 2
59317: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59318: LD_ADDR_VAR 0 5
59322: PUSH
59323: DOUBLE
59324: LD_EXP 154
59328: PUSH
59329: LD_VAR 0 6
59333: ARRAY
59334: INC
59335: ST_TO_ADDR
59336: LD_INT 1
59338: PUSH
59339: FOR_DOWNTO
59340: IFFALSE 59501
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59342: LD_EXP 154
59346: PUSH
59347: LD_VAR 0 6
59351: ARRAY
59352: PUSH
59353: LD_VAR 0 5
59357: ARRAY
59358: PUSH
59359: LD_INT 1
59361: ARRAY
59362: PUSH
59363: LD_VAR 0 2
59367: EQUAL
59368: PUSH
59369: LD_EXP 154
59373: PUSH
59374: LD_VAR 0 6
59378: ARRAY
59379: PUSH
59380: LD_VAR 0 5
59384: ARRAY
59385: PUSH
59386: LD_INT 2
59388: ARRAY
59389: PUSH
59390: LD_VAR 0 3
59394: EQUAL
59395: AND
59396: IFFALSE 59499
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59398: LD_EXP 154
59402: PUSH
59403: LD_VAR 0 6
59407: ARRAY
59408: PUSH
59409: LD_VAR 0 5
59413: ARRAY
59414: PUSH
59415: LD_INT 1
59417: ARRAY
59418: PPUSH
59419: LD_EXP 154
59423: PUSH
59424: LD_VAR 0 6
59428: ARRAY
59429: PUSH
59430: LD_VAR 0 5
59434: ARRAY
59435: PUSH
59436: LD_INT 2
59438: ARRAY
59439: PPUSH
59440: LD_VAR 0 1
59444: PPUSH
59445: CALL_OW 255
59449: PPUSH
59450: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59454: LD_ADDR_EXP 154
59458: PUSH
59459: LD_EXP 154
59463: PPUSH
59464: LD_VAR 0 6
59468: PPUSH
59469: LD_EXP 154
59473: PUSH
59474: LD_VAR 0 6
59478: ARRAY
59479: PPUSH
59480: LD_VAR 0 5
59484: PPUSH
59485: CALL_OW 3
59489: PPUSH
59490: CALL_OW 1
59494: ST_TO_ADDR
// exit ;
59495: POP
59496: POP
59497: GO 59690
// end ; end ;
59499: GO 59339
59501: POP
59502: POP
// for i := minerMinesList [ index ] downto 1 do
59503: LD_ADDR_VAR 0 5
59507: PUSH
59508: DOUBLE
59509: LD_EXP 154
59513: PUSH
59514: LD_VAR 0 6
59518: ARRAY
59519: INC
59520: ST_TO_ADDR
59521: LD_INT 1
59523: PUSH
59524: FOR_DOWNTO
59525: IFFALSE 59688
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59527: LD_EXP 154
59531: PUSH
59532: LD_VAR 0 6
59536: ARRAY
59537: PUSH
59538: LD_VAR 0 5
59542: ARRAY
59543: PUSH
59544: LD_INT 1
59546: ARRAY
59547: PPUSH
59548: LD_EXP 154
59552: PUSH
59553: LD_VAR 0 6
59557: ARRAY
59558: PUSH
59559: LD_VAR 0 5
59563: ARRAY
59564: PUSH
59565: LD_INT 2
59567: ARRAY
59568: PPUSH
59569: LD_VAR 0 2
59573: PPUSH
59574: LD_VAR 0 3
59578: PPUSH
59579: CALL_OW 298
59583: PUSH
59584: LD_INT 6
59586: LESS
59587: IFFALSE 59686
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59589: LD_EXP 154
59593: PUSH
59594: LD_VAR 0 6
59598: ARRAY
59599: PUSH
59600: LD_VAR 0 5
59604: ARRAY
59605: PUSH
59606: LD_INT 1
59608: ARRAY
59609: PPUSH
59610: LD_EXP 154
59614: PUSH
59615: LD_VAR 0 6
59619: ARRAY
59620: PUSH
59621: LD_VAR 0 5
59625: ARRAY
59626: PUSH
59627: LD_INT 2
59629: ARRAY
59630: PPUSH
59631: LD_VAR 0 1
59635: PPUSH
59636: CALL_OW 255
59640: PPUSH
59641: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59645: LD_ADDR_EXP 154
59649: PUSH
59650: LD_EXP 154
59654: PPUSH
59655: LD_VAR 0 6
59659: PPUSH
59660: LD_EXP 154
59664: PUSH
59665: LD_VAR 0 6
59669: ARRAY
59670: PPUSH
59671: LD_VAR 0 5
59675: PPUSH
59676: CALL_OW 3
59680: PPUSH
59681: CALL_OW 1
59685: ST_TO_ADDR
// end ; end ;
59686: GO 59524
59688: POP
59689: POP
// end ;
59690: LD_VAR 0 4
59694: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
59695: LD_INT 0
59697: PPUSH
59698: PPUSH
59699: PPUSH
59700: PPUSH
59701: PPUSH
59702: PPUSH
59703: PPUSH
59704: PPUSH
59705: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
59706: LD_VAR 0 1
59710: PPUSH
59711: CALL_OW 264
59715: PUSH
59716: LD_EXP 82
59720: EQUAL
59721: NOT
59722: PUSH
59723: LD_VAR 0 1
59727: PUSH
59728: LD_EXP 153
59732: IN
59733: NOT
59734: OR
59735: IFFALSE 59739
// exit ;
59737: GO 60061
// index := GetElementIndex ( minersList , unit ) ;
59739: LD_ADDR_VAR 0 6
59743: PUSH
59744: LD_EXP 153
59748: PPUSH
59749: LD_VAR 0 1
59753: PPUSH
59754: CALL 65217 0 2
59758: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
59759: LD_ADDR_VAR 0 8
59763: PUSH
59764: LD_EXP 155
59768: PUSH
59769: LD_EXP 154
59773: PUSH
59774: LD_VAR 0 6
59778: ARRAY
59779: MINUS
59780: ST_TO_ADDR
// if not minesFreeAmount then
59781: LD_VAR 0 8
59785: NOT
59786: IFFALSE 59790
// exit ;
59788: GO 60061
// tmp := [ ] ;
59790: LD_ADDR_VAR 0 7
59794: PUSH
59795: EMPTY
59796: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
59797: LD_ADDR_VAR 0 5
59801: PUSH
59802: DOUBLE
59803: LD_INT 1
59805: DEC
59806: ST_TO_ADDR
59807: LD_VAR 0 8
59811: PUSH
59812: FOR_TO
59813: IFFALSE 60008
// begin _d := rand ( 0 , 5 ) ;
59815: LD_ADDR_VAR 0 11
59819: PUSH
59820: LD_INT 0
59822: PPUSH
59823: LD_INT 5
59825: PPUSH
59826: CALL_OW 12
59830: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
59831: LD_ADDR_VAR 0 12
59835: PUSH
59836: LD_INT 2
59838: PPUSH
59839: LD_INT 6
59841: PPUSH
59842: CALL_OW 12
59846: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
59847: LD_ADDR_VAR 0 9
59851: PUSH
59852: LD_VAR 0 2
59856: PPUSH
59857: LD_VAR 0 11
59861: PPUSH
59862: LD_VAR 0 12
59866: PPUSH
59867: CALL_OW 272
59871: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
59872: LD_ADDR_VAR 0 10
59876: PUSH
59877: LD_VAR 0 3
59881: PPUSH
59882: LD_VAR 0 11
59886: PPUSH
59887: LD_VAR 0 12
59891: PPUSH
59892: CALL_OW 273
59896: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
59897: LD_VAR 0 9
59901: PPUSH
59902: LD_VAR 0 10
59906: PPUSH
59907: CALL_OW 488
59911: PUSH
59912: LD_VAR 0 9
59916: PUSH
59917: LD_VAR 0 10
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: PUSH
59926: LD_VAR 0 7
59930: IN
59931: NOT
59932: AND
59933: PUSH
59934: LD_VAR 0 9
59938: PPUSH
59939: LD_VAR 0 10
59943: PPUSH
59944: CALL_OW 458
59948: NOT
59949: AND
59950: IFFALSE 59992
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
59952: LD_ADDR_VAR 0 7
59956: PUSH
59957: LD_VAR 0 7
59961: PPUSH
59962: LD_VAR 0 7
59966: PUSH
59967: LD_INT 1
59969: PLUS
59970: PPUSH
59971: LD_VAR 0 9
59975: PUSH
59976: LD_VAR 0 10
59980: PUSH
59981: EMPTY
59982: LIST
59983: LIST
59984: PPUSH
59985: CALL_OW 1
59989: ST_TO_ADDR
59990: GO 60006
// i := i - 1 ;
59992: LD_ADDR_VAR 0 5
59996: PUSH
59997: LD_VAR 0 5
60001: PUSH
60002: LD_INT 1
60004: MINUS
60005: ST_TO_ADDR
// end ;
60006: GO 59812
60008: POP
60009: POP
// for i in tmp do
60010: LD_ADDR_VAR 0 5
60014: PUSH
60015: LD_VAR 0 7
60019: PUSH
60020: FOR_IN
60021: IFFALSE 60059
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60023: LD_VAR 0 1
60027: PPUSH
60028: LD_VAR 0 5
60032: PUSH
60033: LD_INT 1
60035: ARRAY
60036: PPUSH
60037: LD_VAR 0 5
60041: PUSH
60042: LD_INT 2
60044: ARRAY
60045: PPUSH
60046: CALL 59001 0 3
60050: NOT
60051: IFFALSE 60057
// exit ;
60053: POP
60054: POP
60055: GO 60061
60057: GO 60020
60059: POP
60060: POP
// end ;
60061: LD_VAR 0 4
60065: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60066: LD_INT 0
60068: PPUSH
60069: PPUSH
60070: PPUSH
60071: PPUSH
60072: PPUSH
60073: PPUSH
60074: PPUSH
// if not GetClass ( unit ) = class_sniper then
60075: LD_VAR 0 1
60079: PPUSH
60080: CALL_OW 257
60084: PUSH
60085: LD_INT 5
60087: EQUAL
60088: NOT
60089: IFFALSE 60093
// exit ;
60091: GO 60481
// dist := 8 ;
60093: LD_ADDR_VAR 0 5
60097: PUSH
60098: LD_INT 8
60100: ST_TO_ADDR
// viewRange := 12 ;
60101: LD_ADDR_VAR 0 7
60105: PUSH
60106: LD_INT 12
60108: ST_TO_ADDR
// side := GetSide ( unit ) ;
60109: LD_ADDR_VAR 0 6
60113: PUSH
60114: LD_VAR 0 1
60118: PPUSH
60119: CALL_OW 255
60123: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60124: LD_INT 61
60126: PPUSH
60127: LD_VAR 0 6
60131: PPUSH
60132: CALL_OW 321
60136: PUSH
60137: LD_INT 2
60139: EQUAL
60140: IFFALSE 60150
// viewRange := 16 ;
60142: LD_ADDR_VAR 0 7
60146: PUSH
60147: LD_INT 16
60149: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60150: LD_VAR 0 1
60154: PPUSH
60155: LD_VAR 0 2
60159: PPUSH
60160: LD_VAR 0 3
60164: PPUSH
60165: CALL_OW 297
60169: PUSH
60170: LD_VAR 0 5
60174: GREATER
60175: IFFALSE 60254
// begin ComMoveXY ( unit , x , y ) ;
60177: LD_VAR 0 1
60181: PPUSH
60182: LD_VAR 0 2
60186: PPUSH
60187: LD_VAR 0 3
60191: PPUSH
60192: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60196: LD_INT 35
60198: PPUSH
60199: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60203: LD_VAR 0 1
60207: PPUSH
60208: LD_VAR 0 2
60212: PPUSH
60213: LD_VAR 0 3
60217: PPUSH
60218: CALL 95281 0 3
60222: NOT
60223: IFFALSE 60227
// exit ;
60225: GO 60481
// until GetDistUnitXY ( unit , x , y ) < dist ;
60227: LD_VAR 0 1
60231: PPUSH
60232: LD_VAR 0 2
60236: PPUSH
60237: LD_VAR 0 3
60241: PPUSH
60242: CALL_OW 297
60246: PUSH
60247: LD_VAR 0 5
60251: LESS
60252: IFFALSE 60196
// end ; ComTurnXY ( unit , x , y ) ;
60254: LD_VAR 0 1
60258: PPUSH
60259: LD_VAR 0 2
60263: PPUSH
60264: LD_VAR 0 3
60268: PPUSH
60269: CALL_OW 118
// wait ( 5 ) ;
60273: LD_INT 5
60275: PPUSH
60276: CALL_OW 67
// _d := GetDir ( unit ) ;
60280: LD_ADDR_VAR 0 10
60284: PUSH
60285: LD_VAR 0 1
60289: PPUSH
60290: CALL_OW 254
60294: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60295: LD_ADDR_VAR 0 8
60299: PUSH
60300: LD_VAR 0 1
60304: PPUSH
60305: CALL_OW 250
60309: PPUSH
60310: LD_VAR 0 10
60314: PPUSH
60315: LD_VAR 0 5
60319: PPUSH
60320: CALL_OW 272
60324: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60325: LD_ADDR_VAR 0 9
60329: PUSH
60330: LD_VAR 0 1
60334: PPUSH
60335: CALL_OW 251
60339: PPUSH
60340: LD_VAR 0 10
60344: PPUSH
60345: LD_VAR 0 5
60349: PPUSH
60350: CALL_OW 273
60354: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60355: LD_VAR 0 8
60359: PPUSH
60360: LD_VAR 0 9
60364: PPUSH
60365: CALL_OW 488
60369: NOT
60370: IFFALSE 60374
// exit ;
60372: GO 60481
// ComAnimCustom ( unit , 1 ) ;
60374: LD_VAR 0 1
60378: PPUSH
60379: LD_INT 1
60381: PPUSH
60382: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60386: LD_VAR 0 8
60390: PPUSH
60391: LD_VAR 0 9
60395: PPUSH
60396: LD_VAR 0 6
60400: PPUSH
60401: LD_VAR 0 7
60405: PPUSH
60406: CALL_OW 330
// repeat wait ( 1 ) ;
60410: LD_INT 1
60412: PPUSH
60413: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60417: LD_VAR 0 1
60421: PPUSH
60422: CALL_OW 316
60426: PUSH
60427: LD_VAR 0 1
60431: PPUSH
60432: CALL_OW 314
60436: OR
60437: PUSH
60438: LD_VAR 0 1
60442: PPUSH
60443: CALL_OW 302
60447: NOT
60448: OR
60449: PUSH
60450: LD_VAR 0 1
60454: PPUSH
60455: CALL_OW 301
60459: OR
60460: IFFALSE 60410
// RemoveSeeing ( _x , _y , side ) ;
60462: LD_VAR 0 8
60466: PPUSH
60467: LD_VAR 0 9
60471: PPUSH
60472: LD_VAR 0 6
60476: PPUSH
60477: CALL_OW 331
// end ; end_of_file
60481: LD_VAR 0 4
60485: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
60486: LD_INT 0
60488: PPUSH
60489: PPUSH
// if exist_mode then
60490: LD_VAR 0 2
60494: IFFALSE 60519
// unit := CreateCharacter ( prefix & ident ) else
60496: LD_ADDR_VAR 0 5
60500: PUSH
60501: LD_VAR 0 3
60505: PUSH
60506: LD_VAR 0 1
60510: STR
60511: PPUSH
60512: CALL_OW 34
60516: ST_TO_ADDR
60517: GO 60534
// unit := NewCharacter ( ident ) ;
60519: LD_ADDR_VAR 0 5
60523: PUSH
60524: LD_VAR 0 1
60528: PPUSH
60529: CALL_OW 25
60533: ST_TO_ADDR
// result := unit ;
60534: LD_ADDR_VAR 0 4
60538: PUSH
60539: LD_VAR 0 5
60543: ST_TO_ADDR
// end ;
60544: LD_VAR 0 4
60548: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
60549: LD_INT 0
60551: PPUSH
60552: PPUSH
// if not side or not nation then
60553: LD_VAR 0 1
60557: NOT
60558: PUSH
60559: LD_VAR 0 2
60563: NOT
60564: OR
60565: IFFALSE 60569
// exit ;
60567: GO 61333
// case nation of nation_american :
60569: LD_VAR 0 2
60573: PUSH
60574: LD_INT 1
60576: DOUBLE
60577: EQUAL
60578: IFTRUE 60582
60580: GO 60796
60582: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
60583: LD_ADDR_VAR 0 4
60587: PUSH
60588: LD_INT 35
60590: PUSH
60591: LD_INT 45
60593: PUSH
60594: LD_INT 46
60596: PUSH
60597: LD_INT 47
60599: PUSH
60600: LD_INT 82
60602: PUSH
60603: LD_INT 83
60605: PUSH
60606: LD_INT 84
60608: PUSH
60609: LD_INT 85
60611: PUSH
60612: LD_INT 86
60614: PUSH
60615: LD_INT 1
60617: PUSH
60618: LD_INT 2
60620: PUSH
60621: LD_INT 6
60623: PUSH
60624: LD_INT 15
60626: PUSH
60627: LD_INT 16
60629: PUSH
60630: LD_INT 7
60632: PUSH
60633: LD_INT 12
60635: PUSH
60636: LD_INT 13
60638: PUSH
60639: LD_INT 10
60641: PUSH
60642: LD_INT 14
60644: PUSH
60645: LD_INT 20
60647: PUSH
60648: LD_INT 21
60650: PUSH
60651: LD_INT 22
60653: PUSH
60654: LD_INT 25
60656: PUSH
60657: LD_INT 32
60659: PUSH
60660: LD_INT 27
60662: PUSH
60663: LD_INT 36
60665: PUSH
60666: LD_INT 69
60668: PUSH
60669: LD_INT 39
60671: PUSH
60672: LD_INT 34
60674: PUSH
60675: LD_INT 40
60677: PUSH
60678: LD_INT 48
60680: PUSH
60681: LD_INT 49
60683: PUSH
60684: LD_INT 50
60686: PUSH
60687: LD_INT 51
60689: PUSH
60690: LD_INT 52
60692: PUSH
60693: LD_INT 53
60695: PUSH
60696: LD_INT 54
60698: PUSH
60699: LD_INT 55
60701: PUSH
60702: LD_INT 56
60704: PUSH
60705: LD_INT 57
60707: PUSH
60708: LD_INT 58
60710: PUSH
60711: LD_INT 59
60713: PUSH
60714: LD_INT 60
60716: PUSH
60717: LD_INT 61
60719: PUSH
60720: LD_INT 62
60722: PUSH
60723: LD_INT 80
60725: PUSH
60726: LD_INT 82
60728: PUSH
60729: LD_INT 83
60731: PUSH
60732: LD_INT 84
60734: PUSH
60735: LD_INT 85
60737: PUSH
60738: LD_INT 86
60740: PUSH
60741: EMPTY
60742: LIST
60743: LIST
60744: LIST
60745: LIST
60746: LIST
60747: LIST
60748: LIST
60749: LIST
60750: LIST
60751: LIST
60752: LIST
60753: LIST
60754: LIST
60755: LIST
60756: LIST
60757: LIST
60758: LIST
60759: LIST
60760: LIST
60761: LIST
60762: LIST
60763: LIST
60764: LIST
60765: LIST
60766: LIST
60767: LIST
60768: LIST
60769: LIST
60770: LIST
60771: LIST
60772: LIST
60773: LIST
60774: LIST
60775: LIST
60776: LIST
60777: LIST
60778: LIST
60779: LIST
60780: LIST
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: LIST
60786: LIST
60787: LIST
60788: LIST
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: ST_TO_ADDR
60794: GO 61257
60796: LD_INT 2
60798: DOUBLE
60799: EQUAL
60800: IFTRUE 60804
60802: GO 61026
60804: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
60805: LD_ADDR_VAR 0 4
60809: PUSH
60810: LD_INT 35
60812: PUSH
60813: LD_INT 45
60815: PUSH
60816: LD_INT 46
60818: PUSH
60819: LD_INT 47
60821: PUSH
60822: LD_INT 82
60824: PUSH
60825: LD_INT 83
60827: PUSH
60828: LD_INT 84
60830: PUSH
60831: LD_INT 85
60833: PUSH
60834: LD_INT 87
60836: PUSH
60837: LD_INT 70
60839: PUSH
60840: LD_INT 1
60842: PUSH
60843: LD_INT 11
60845: PUSH
60846: LD_INT 3
60848: PUSH
60849: LD_INT 4
60851: PUSH
60852: LD_INT 5
60854: PUSH
60855: LD_INT 6
60857: PUSH
60858: LD_INT 15
60860: PUSH
60861: LD_INT 18
60863: PUSH
60864: LD_INT 7
60866: PUSH
60867: LD_INT 17
60869: PUSH
60870: LD_INT 8
60872: PUSH
60873: LD_INT 20
60875: PUSH
60876: LD_INT 21
60878: PUSH
60879: LD_INT 22
60881: PUSH
60882: LD_INT 72
60884: PUSH
60885: LD_INT 26
60887: PUSH
60888: LD_INT 69
60890: PUSH
60891: LD_INT 39
60893: PUSH
60894: LD_INT 40
60896: PUSH
60897: LD_INT 41
60899: PUSH
60900: LD_INT 42
60902: PUSH
60903: LD_INT 43
60905: PUSH
60906: LD_INT 48
60908: PUSH
60909: LD_INT 49
60911: PUSH
60912: LD_INT 50
60914: PUSH
60915: LD_INT 51
60917: PUSH
60918: LD_INT 52
60920: PUSH
60921: LD_INT 53
60923: PUSH
60924: LD_INT 54
60926: PUSH
60927: LD_INT 55
60929: PUSH
60930: LD_INT 56
60932: PUSH
60933: LD_INT 60
60935: PUSH
60936: LD_INT 61
60938: PUSH
60939: LD_INT 62
60941: PUSH
60942: LD_INT 66
60944: PUSH
60945: LD_INT 67
60947: PUSH
60948: LD_INT 68
60950: PUSH
60951: LD_INT 81
60953: PUSH
60954: LD_INT 82
60956: PUSH
60957: LD_INT 83
60959: PUSH
60960: LD_INT 84
60962: PUSH
60963: LD_INT 85
60965: PUSH
60966: LD_INT 87
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: LIST
60973: LIST
60974: LIST
60975: LIST
60976: LIST
60977: LIST
60978: LIST
60979: LIST
60980: LIST
60981: LIST
60982: LIST
60983: LIST
60984: LIST
60985: LIST
60986: LIST
60987: LIST
60988: LIST
60989: LIST
60990: LIST
60991: LIST
60992: LIST
60993: LIST
60994: LIST
60995: LIST
60996: LIST
60997: LIST
60998: LIST
60999: LIST
61000: LIST
61001: LIST
61002: LIST
61003: LIST
61004: LIST
61005: LIST
61006: LIST
61007: LIST
61008: LIST
61009: LIST
61010: LIST
61011: LIST
61012: LIST
61013: LIST
61014: LIST
61015: LIST
61016: LIST
61017: LIST
61018: LIST
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: ST_TO_ADDR
61024: GO 61257
61026: LD_INT 3
61028: DOUBLE
61029: EQUAL
61030: IFTRUE 61034
61032: GO 61256
61034: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61035: LD_ADDR_VAR 0 4
61039: PUSH
61040: LD_INT 46
61042: PUSH
61043: LD_INT 47
61045: PUSH
61046: LD_INT 1
61048: PUSH
61049: LD_INT 2
61051: PUSH
61052: LD_INT 82
61054: PUSH
61055: LD_INT 83
61057: PUSH
61058: LD_INT 84
61060: PUSH
61061: LD_INT 85
61063: PUSH
61064: LD_INT 86
61066: PUSH
61067: LD_INT 11
61069: PUSH
61070: LD_INT 9
61072: PUSH
61073: LD_INT 20
61075: PUSH
61076: LD_INT 19
61078: PUSH
61079: LD_INT 21
61081: PUSH
61082: LD_INT 24
61084: PUSH
61085: LD_INT 22
61087: PUSH
61088: LD_INT 25
61090: PUSH
61091: LD_INT 28
61093: PUSH
61094: LD_INT 29
61096: PUSH
61097: LD_INT 30
61099: PUSH
61100: LD_INT 31
61102: PUSH
61103: LD_INT 37
61105: PUSH
61106: LD_INT 38
61108: PUSH
61109: LD_INT 32
61111: PUSH
61112: LD_INT 27
61114: PUSH
61115: LD_INT 33
61117: PUSH
61118: LD_INT 69
61120: PUSH
61121: LD_INT 39
61123: PUSH
61124: LD_INT 34
61126: PUSH
61127: LD_INT 40
61129: PUSH
61130: LD_INT 71
61132: PUSH
61133: LD_INT 23
61135: PUSH
61136: LD_INT 44
61138: PUSH
61139: LD_INT 48
61141: PUSH
61142: LD_INT 49
61144: PUSH
61145: LD_INT 50
61147: PUSH
61148: LD_INT 51
61150: PUSH
61151: LD_INT 52
61153: PUSH
61154: LD_INT 53
61156: PUSH
61157: LD_INT 54
61159: PUSH
61160: LD_INT 55
61162: PUSH
61163: LD_INT 56
61165: PUSH
61166: LD_INT 57
61168: PUSH
61169: LD_INT 58
61171: PUSH
61172: LD_INT 59
61174: PUSH
61175: LD_INT 63
61177: PUSH
61178: LD_INT 64
61180: PUSH
61181: LD_INT 65
61183: PUSH
61184: LD_INT 82
61186: PUSH
61187: LD_INT 83
61189: PUSH
61190: LD_INT 84
61192: PUSH
61193: LD_INT 85
61195: PUSH
61196: LD_INT 86
61198: PUSH
61199: EMPTY
61200: LIST
61201: LIST
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: LIST
61214: LIST
61215: LIST
61216: LIST
61217: LIST
61218: LIST
61219: LIST
61220: LIST
61221: LIST
61222: LIST
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: ST_TO_ADDR
61254: GO 61257
61256: POP
// if state > - 1 and state < 3 then
61257: LD_VAR 0 3
61261: PUSH
61262: LD_INT 1
61264: NEG
61265: GREATER
61266: PUSH
61267: LD_VAR 0 3
61271: PUSH
61272: LD_INT 3
61274: LESS
61275: AND
61276: IFFALSE 61333
// for i in result do
61278: LD_ADDR_VAR 0 5
61282: PUSH
61283: LD_VAR 0 4
61287: PUSH
61288: FOR_IN
61289: IFFALSE 61331
// if GetTech ( i , side ) <> state then
61291: LD_VAR 0 5
61295: PPUSH
61296: LD_VAR 0 1
61300: PPUSH
61301: CALL_OW 321
61305: PUSH
61306: LD_VAR 0 3
61310: NONEQUAL
61311: IFFALSE 61329
// result := result diff i ;
61313: LD_ADDR_VAR 0 4
61317: PUSH
61318: LD_VAR 0 4
61322: PUSH
61323: LD_VAR 0 5
61327: DIFF
61328: ST_TO_ADDR
61329: GO 61288
61331: POP
61332: POP
// end ;
61333: LD_VAR 0 4
61337: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
61338: LD_INT 0
61340: PPUSH
61341: PPUSH
61342: PPUSH
// result := true ;
61343: LD_ADDR_VAR 0 3
61347: PUSH
61348: LD_INT 1
61350: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
61351: LD_ADDR_VAR 0 5
61355: PUSH
61356: LD_VAR 0 2
61360: PPUSH
61361: CALL_OW 480
61365: ST_TO_ADDR
// if not tmp then
61366: LD_VAR 0 5
61370: NOT
61371: IFFALSE 61375
// exit ;
61373: GO 61424
// for i in tmp do
61375: LD_ADDR_VAR 0 4
61379: PUSH
61380: LD_VAR 0 5
61384: PUSH
61385: FOR_IN
61386: IFFALSE 61422
// if GetTech ( i , side ) <> state_researched then
61388: LD_VAR 0 4
61392: PPUSH
61393: LD_VAR 0 1
61397: PPUSH
61398: CALL_OW 321
61402: PUSH
61403: LD_INT 2
61405: NONEQUAL
61406: IFFALSE 61420
// begin result := false ;
61408: LD_ADDR_VAR 0 3
61412: PUSH
61413: LD_INT 0
61415: ST_TO_ADDR
// exit ;
61416: POP
61417: POP
61418: GO 61424
// end ;
61420: GO 61385
61422: POP
61423: POP
// end ;
61424: LD_VAR 0 3
61428: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
61429: LD_INT 0
61431: PPUSH
61432: PPUSH
61433: PPUSH
61434: PPUSH
61435: PPUSH
61436: PPUSH
61437: PPUSH
61438: PPUSH
61439: PPUSH
61440: PPUSH
61441: PPUSH
61442: PPUSH
61443: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
61444: LD_VAR 0 1
61448: NOT
61449: PUSH
61450: LD_VAR 0 1
61454: PPUSH
61455: CALL_OW 257
61459: PUSH
61460: LD_INT 9
61462: NONEQUAL
61463: OR
61464: IFFALSE 61468
// exit ;
61466: GO 62041
// side := GetSide ( unit ) ;
61468: LD_ADDR_VAR 0 9
61472: PUSH
61473: LD_VAR 0 1
61477: PPUSH
61478: CALL_OW 255
61482: ST_TO_ADDR
// tech_space := tech_spacanom ;
61483: LD_ADDR_VAR 0 12
61487: PUSH
61488: LD_INT 29
61490: ST_TO_ADDR
// tech_time := tech_taurad ;
61491: LD_ADDR_VAR 0 13
61495: PUSH
61496: LD_INT 28
61498: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
61499: LD_ADDR_VAR 0 11
61503: PUSH
61504: LD_VAR 0 1
61508: PPUSH
61509: CALL_OW 310
61513: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
61514: LD_VAR 0 11
61518: PPUSH
61519: CALL_OW 247
61523: PUSH
61524: LD_INT 2
61526: EQUAL
61527: IFFALSE 61531
// exit ;
61529: GO 62041
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61531: LD_ADDR_VAR 0 8
61535: PUSH
61536: LD_INT 81
61538: PUSH
61539: LD_VAR 0 9
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PUSH
61548: LD_INT 3
61550: PUSH
61551: LD_INT 21
61553: PUSH
61554: LD_INT 3
61556: PUSH
61557: EMPTY
61558: LIST
61559: LIST
61560: PUSH
61561: EMPTY
61562: LIST
61563: LIST
61564: PUSH
61565: EMPTY
61566: LIST
61567: LIST
61568: PPUSH
61569: CALL_OW 69
61573: ST_TO_ADDR
// if not tmp then
61574: LD_VAR 0 8
61578: NOT
61579: IFFALSE 61583
// exit ;
61581: GO 62041
// if in_unit then
61583: LD_VAR 0 11
61587: IFFALSE 61611
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
61589: LD_ADDR_VAR 0 10
61593: PUSH
61594: LD_VAR 0 8
61598: PPUSH
61599: LD_VAR 0 11
61603: PPUSH
61604: CALL_OW 74
61608: ST_TO_ADDR
61609: GO 61631
// enemy := NearestUnitToUnit ( tmp , unit ) ;
61611: LD_ADDR_VAR 0 10
61615: PUSH
61616: LD_VAR 0 8
61620: PPUSH
61621: LD_VAR 0 1
61625: PPUSH
61626: CALL_OW 74
61630: ST_TO_ADDR
// if not enemy then
61631: LD_VAR 0 10
61635: NOT
61636: IFFALSE 61640
// exit ;
61638: GO 62041
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
61640: LD_VAR 0 11
61644: PUSH
61645: LD_VAR 0 11
61649: PPUSH
61650: LD_VAR 0 10
61654: PPUSH
61655: CALL_OW 296
61659: PUSH
61660: LD_INT 13
61662: GREATER
61663: AND
61664: PUSH
61665: LD_VAR 0 1
61669: PPUSH
61670: LD_VAR 0 10
61674: PPUSH
61675: CALL_OW 296
61679: PUSH
61680: LD_INT 12
61682: GREATER
61683: OR
61684: IFFALSE 61688
// exit ;
61686: GO 62041
// missile := [ 1 ] ;
61688: LD_ADDR_VAR 0 14
61692: PUSH
61693: LD_INT 1
61695: PUSH
61696: EMPTY
61697: LIST
61698: ST_TO_ADDR
// if Researched ( side , tech_space ) then
61699: LD_VAR 0 9
61703: PPUSH
61704: LD_VAR 0 12
61708: PPUSH
61709: CALL_OW 325
61713: IFFALSE 61742
// missile := Insert ( missile , missile + 1 , 2 ) ;
61715: LD_ADDR_VAR 0 14
61719: PUSH
61720: LD_VAR 0 14
61724: PPUSH
61725: LD_VAR 0 14
61729: PUSH
61730: LD_INT 1
61732: PLUS
61733: PPUSH
61734: LD_INT 2
61736: PPUSH
61737: CALL_OW 2
61741: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
61742: LD_VAR 0 9
61746: PPUSH
61747: LD_VAR 0 13
61751: PPUSH
61752: CALL_OW 325
61756: PUSH
61757: LD_VAR 0 10
61761: PPUSH
61762: CALL_OW 255
61766: PPUSH
61767: LD_VAR 0 13
61771: PPUSH
61772: CALL_OW 325
61776: NOT
61777: AND
61778: IFFALSE 61807
// missile := Insert ( missile , missile + 1 , 3 ) ;
61780: LD_ADDR_VAR 0 14
61784: PUSH
61785: LD_VAR 0 14
61789: PPUSH
61790: LD_VAR 0 14
61794: PUSH
61795: LD_INT 1
61797: PLUS
61798: PPUSH
61799: LD_INT 3
61801: PPUSH
61802: CALL_OW 2
61806: ST_TO_ADDR
// if missile < 2 then
61807: LD_VAR 0 14
61811: PUSH
61812: LD_INT 2
61814: LESS
61815: IFFALSE 61819
// exit ;
61817: GO 62041
// x := GetX ( enemy ) ;
61819: LD_ADDR_VAR 0 4
61823: PUSH
61824: LD_VAR 0 10
61828: PPUSH
61829: CALL_OW 250
61833: ST_TO_ADDR
// y := GetY ( enemy ) ;
61834: LD_ADDR_VAR 0 5
61838: PUSH
61839: LD_VAR 0 10
61843: PPUSH
61844: CALL_OW 251
61848: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
61849: LD_ADDR_VAR 0 6
61853: PUSH
61854: LD_VAR 0 4
61858: PUSH
61859: LD_INT 1
61861: NEG
61862: PPUSH
61863: LD_INT 1
61865: PPUSH
61866: CALL_OW 12
61870: PLUS
61871: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
61872: LD_ADDR_VAR 0 7
61876: PUSH
61877: LD_VAR 0 5
61881: PUSH
61882: LD_INT 1
61884: NEG
61885: PPUSH
61886: LD_INT 1
61888: PPUSH
61889: CALL_OW 12
61893: PLUS
61894: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
61895: LD_VAR 0 6
61899: PPUSH
61900: LD_VAR 0 7
61904: PPUSH
61905: CALL_OW 488
61909: NOT
61910: IFFALSE 61932
// begin _x := x ;
61912: LD_ADDR_VAR 0 6
61916: PUSH
61917: LD_VAR 0 4
61921: ST_TO_ADDR
// _y := y ;
61922: LD_ADDR_VAR 0 7
61926: PUSH
61927: LD_VAR 0 5
61931: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
61932: LD_ADDR_VAR 0 3
61936: PUSH
61937: LD_INT 1
61939: PPUSH
61940: LD_VAR 0 14
61944: PPUSH
61945: CALL_OW 12
61949: ST_TO_ADDR
// case i of 1 :
61950: LD_VAR 0 3
61954: PUSH
61955: LD_INT 1
61957: DOUBLE
61958: EQUAL
61959: IFTRUE 61963
61961: GO 61980
61963: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
61964: LD_VAR 0 1
61968: PPUSH
61969: LD_VAR 0 10
61973: PPUSH
61974: CALL_OW 115
61978: GO 62041
61980: LD_INT 2
61982: DOUBLE
61983: EQUAL
61984: IFTRUE 61988
61986: GO 62010
61988: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
61989: LD_VAR 0 1
61993: PPUSH
61994: LD_VAR 0 6
61998: PPUSH
61999: LD_VAR 0 7
62003: PPUSH
62004: CALL_OW 153
62008: GO 62041
62010: LD_INT 3
62012: DOUBLE
62013: EQUAL
62014: IFTRUE 62018
62016: GO 62040
62018: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62019: LD_VAR 0 1
62023: PPUSH
62024: LD_VAR 0 6
62028: PPUSH
62029: LD_VAR 0 7
62033: PPUSH
62034: CALL_OW 154
62038: GO 62041
62040: POP
// end ;
62041: LD_VAR 0 2
62045: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62046: LD_INT 0
62048: PPUSH
62049: PPUSH
62050: PPUSH
62051: PPUSH
62052: PPUSH
62053: PPUSH
// if not unit or not building then
62054: LD_VAR 0 1
62058: NOT
62059: PUSH
62060: LD_VAR 0 2
62064: NOT
62065: OR
62066: IFFALSE 62070
// exit ;
62068: GO 62228
// x := GetX ( building ) ;
62070: LD_ADDR_VAR 0 5
62074: PUSH
62075: LD_VAR 0 2
62079: PPUSH
62080: CALL_OW 250
62084: ST_TO_ADDR
// y := GetY ( building ) ;
62085: LD_ADDR_VAR 0 6
62089: PUSH
62090: LD_VAR 0 2
62094: PPUSH
62095: CALL_OW 251
62099: ST_TO_ADDR
// for i = 0 to 5 do
62100: LD_ADDR_VAR 0 4
62104: PUSH
62105: DOUBLE
62106: LD_INT 0
62108: DEC
62109: ST_TO_ADDR
62110: LD_INT 5
62112: PUSH
62113: FOR_TO
62114: IFFALSE 62226
// begin _x := ShiftX ( x , i , 3 ) ;
62116: LD_ADDR_VAR 0 7
62120: PUSH
62121: LD_VAR 0 5
62125: PPUSH
62126: LD_VAR 0 4
62130: PPUSH
62131: LD_INT 3
62133: PPUSH
62134: CALL_OW 272
62138: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62139: LD_ADDR_VAR 0 8
62143: PUSH
62144: LD_VAR 0 6
62148: PPUSH
62149: LD_VAR 0 4
62153: PPUSH
62154: LD_INT 3
62156: PPUSH
62157: CALL_OW 273
62161: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62162: LD_VAR 0 7
62166: PPUSH
62167: LD_VAR 0 8
62171: PPUSH
62172: CALL_OW 488
62176: NOT
62177: IFFALSE 62181
// continue ;
62179: GO 62113
// if HexInfo ( _x , _y ) = 0 then
62181: LD_VAR 0 7
62185: PPUSH
62186: LD_VAR 0 8
62190: PPUSH
62191: CALL_OW 428
62195: PUSH
62196: LD_INT 0
62198: EQUAL
62199: IFFALSE 62224
// begin ComMoveXY ( unit , _x , _y ) ;
62201: LD_VAR 0 1
62205: PPUSH
62206: LD_VAR 0 7
62210: PPUSH
62211: LD_VAR 0 8
62215: PPUSH
62216: CALL_OW 111
// exit ;
62220: POP
62221: POP
62222: GO 62228
// end ; end ;
62224: GO 62113
62226: POP
62227: POP
// end ;
62228: LD_VAR 0 3
62232: RET
// export function ScanBase ( side , base_area ) ; begin
62233: LD_INT 0
62235: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62236: LD_ADDR_VAR 0 3
62240: PUSH
62241: LD_VAR 0 2
62245: PPUSH
62246: LD_INT 81
62248: PUSH
62249: LD_VAR 0 1
62253: PUSH
62254: EMPTY
62255: LIST
62256: LIST
62257: PPUSH
62258: CALL_OW 70
62262: ST_TO_ADDR
// end ;
62263: LD_VAR 0 3
62267: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
62268: LD_INT 0
62270: PPUSH
62271: PPUSH
62272: PPUSH
62273: PPUSH
// result := false ;
62274: LD_ADDR_VAR 0 2
62278: PUSH
62279: LD_INT 0
62281: ST_TO_ADDR
// side := GetSide ( unit ) ;
62282: LD_ADDR_VAR 0 3
62286: PUSH
62287: LD_VAR 0 1
62291: PPUSH
62292: CALL_OW 255
62296: ST_TO_ADDR
// nat := GetNation ( unit ) ;
62297: LD_ADDR_VAR 0 4
62301: PUSH
62302: LD_VAR 0 1
62306: PPUSH
62307: CALL_OW 248
62311: ST_TO_ADDR
// case nat of 1 :
62312: LD_VAR 0 4
62316: PUSH
62317: LD_INT 1
62319: DOUBLE
62320: EQUAL
62321: IFTRUE 62325
62323: GO 62336
62325: POP
// tech := tech_lassight ; 2 :
62326: LD_ADDR_VAR 0 5
62330: PUSH
62331: LD_INT 12
62333: ST_TO_ADDR
62334: GO 62375
62336: LD_INT 2
62338: DOUBLE
62339: EQUAL
62340: IFTRUE 62344
62342: GO 62355
62344: POP
// tech := tech_mortar ; 3 :
62345: LD_ADDR_VAR 0 5
62349: PUSH
62350: LD_INT 41
62352: ST_TO_ADDR
62353: GO 62375
62355: LD_INT 3
62357: DOUBLE
62358: EQUAL
62359: IFTRUE 62363
62361: GO 62374
62363: POP
// tech := tech_bazooka ; end ;
62364: LD_ADDR_VAR 0 5
62368: PUSH
62369: LD_INT 44
62371: ST_TO_ADDR
62372: GO 62375
62374: POP
// if Researched ( side , tech ) then
62375: LD_VAR 0 3
62379: PPUSH
62380: LD_VAR 0 5
62384: PPUSH
62385: CALL_OW 325
62389: IFFALSE 62416
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
62391: LD_ADDR_VAR 0 2
62395: PUSH
62396: LD_INT 5
62398: PUSH
62399: LD_INT 8
62401: PUSH
62402: LD_INT 9
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: LIST
62409: PUSH
62410: LD_VAR 0 4
62414: ARRAY
62415: ST_TO_ADDR
// end ;
62416: LD_VAR 0 2
62420: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
62421: LD_INT 0
62423: PPUSH
62424: PPUSH
62425: PPUSH
// if not mines then
62426: LD_VAR 0 2
62430: NOT
62431: IFFALSE 62435
// exit ;
62433: GO 62579
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62435: LD_ADDR_VAR 0 5
62439: PUSH
62440: LD_INT 81
62442: PUSH
62443: LD_VAR 0 1
62447: PUSH
62448: EMPTY
62449: LIST
62450: LIST
62451: PUSH
62452: LD_INT 3
62454: PUSH
62455: LD_INT 21
62457: PUSH
62458: LD_INT 3
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: PUSH
62465: EMPTY
62466: LIST
62467: LIST
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: PPUSH
62473: CALL_OW 69
62477: ST_TO_ADDR
// for i in mines do
62478: LD_ADDR_VAR 0 4
62482: PUSH
62483: LD_VAR 0 2
62487: PUSH
62488: FOR_IN
62489: IFFALSE 62577
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
62491: LD_VAR 0 4
62495: PUSH
62496: LD_INT 1
62498: ARRAY
62499: PPUSH
62500: LD_VAR 0 4
62504: PUSH
62505: LD_INT 2
62507: ARRAY
62508: PPUSH
62509: CALL_OW 458
62513: NOT
62514: IFFALSE 62518
// continue ;
62516: GO 62488
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
62518: LD_VAR 0 4
62522: PUSH
62523: LD_INT 1
62525: ARRAY
62526: PPUSH
62527: LD_VAR 0 4
62531: PUSH
62532: LD_INT 2
62534: ARRAY
62535: PPUSH
62536: CALL_OW 428
62540: PUSH
62541: LD_VAR 0 5
62545: IN
62546: IFFALSE 62575
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
62548: LD_VAR 0 4
62552: PUSH
62553: LD_INT 1
62555: ARRAY
62556: PPUSH
62557: LD_VAR 0 4
62561: PUSH
62562: LD_INT 2
62564: ARRAY
62565: PPUSH
62566: LD_VAR 0 1
62570: PPUSH
62571: CALL_OW 456
// end ;
62575: GO 62488
62577: POP
62578: POP
// end ;
62579: LD_VAR 0 3
62583: RET
// export function Count ( array ) ; var i ; begin
62584: LD_INT 0
62586: PPUSH
62587: PPUSH
// result := 0 ;
62588: LD_ADDR_VAR 0 2
62592: PUSH
62593: LD_INT 0
62595: ST_TO_ADDR
// for i in array do
62596: LD_ADDR_VAR 0 3
62600: PUSH
62601: LD_VAR 0 1
62605: PUSH
62606: FOR_IN
62607: IFFALSE 62631
// if i then
62609: LD_VAR 0 3
62613: IFFALSE 62629
// result := result + 1 ;
62615: LD_ADDR_VAR 0 2
62619: PUSH
62620: LD_VAR 0 2
62624: PUSH
62625: LD_INT 1
62627: PLUS
62628: ST_TO_ADDR
62629: GO 62606
62631: POP
62632: POP
// end ;
62633: LD_VAR 0 2
62637: RET
// export function IsEmpty ( building ) ; begin
62638: LD_INT 0
62640: PPUSH
// if not building then
62641: LD_VAR 0 1
62645: NOT
62646: IFFALSE 62650
// exit ;
62648: GO 62693
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
62650: LD_ADDR_VAR 0 2
62654: PUSH
62655: LD_VAR 0 1
62659: PUSH
62660: LD_INT 22
62662: PUSH
62663: LD_VAR 0 1
62667: PPUSH
62668: CALL_OW 255
62672: PUSH
62673: EMPTY
62674: LIST
62675: LIST
62676: PUSH
62677: LD_INT 58
62679: PUSH
62680: EMPTY
62681: LIST
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: PPUSH
62687: CALL_OW 69
62691: IN
62692: ST_TO_ADDR
// end ;
62693: LD_VAR 0 2
62697: RET
// export function IsNotFull ( building ) ; begin
62698: LD_INT 0
62700: PPUSH
// if not building then
62701: LD_VAR 0 1
62705: NOT
62706: IFFALSE 62710
// exit ;
62708: GO 62729
// result := UnitsInside ( building ) < 6 ;
62710: LD_ADDR_VAR 0 2
62714: PUSH
62715: LD_VAR 0 1
62719: PPUSH
62720: CALL_OW 313
62724: PUSH
62725: LD_INT 6
62727: LESS
62728: ST_TO_ADDR
// end ;
62729: LD_VAR 0 2
62733: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
62734: LD_INT 0
62736: PPUSH
62737: PPUSH
62738: PPUSH
62739: PPUSH
// tmp := [ ] ;
62740: LD_ADDR_VAR 0 3
62744: PUSH
62745: EMPTY
62746: ST_TO_ADDR
// list := [ ] ;
62747: LD_ADDR_VAR 0 5
62751: PUSH
62752: EMPTY
62753: ST_TO_ADDR
// for i = 16 to 25 do
62754: LD_ADDR_VAR 0 4
62758: PUSH
62759: DOUBLE
62760: LD_INT 16
62762: DEC
62763: ST_TO_ADDR
62764: LD_INT 25
62766: PUSH
62767: FOR_TO
62768: IFFALSE 62841
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
62770: LD_ADDR_VAR 0 3
62774: PUSH
62775: LD_VAR 0 3
62779: PUSH
62780: LD_INT 22
62782: PUSH
62783: LD_VAR 0 1
62787: PPUSH
62788: CALL_OW 255
62792: PUSH
62793: EMPTY
62794: LIST
62795: LIST
62796: PUSH
62797: LD_INT 91
62799: PUSH
62800: LD_VAR 0 1
62804: PUSH
62805: LD_INT 6
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: LIST
62812: PUSH
62813: LD_INT 30
62815: PUSH
62816: LD_VAR 0 4
62820: PUSH
62821: EMPTY
62822: LIST
62823: LIST
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: LIST
62829: PUSH
62830: EMPTY
62831: LIST
62832: PPUSH
62833: CALL_OW 69
62837: ADD
62838: ST_TO_ADDR
62839: GO 62767
62841: POP
62842: POP
// for i = 1 to tmp do
62843: LD_ADDR_VAR 0 4
62847: PUSH
62848: DOUBLE
62849: LD_INT 1
62851: DEC
62852: ST_TO_ADDR
62853: LD_VAR 0 3
62857: PUSH
62858: FOR_TO
62859: IFFALSE 62947
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
62861: LD_ADDR_VAR 0 5
62865: PUSH
62866: LD_VAR 0 5
62870: PUSH
62871: LD_VAR 0 3
62875: PUSH
62876: LD_VAR 0 4
62880: ARRAY
62881: PPUSH
62882: CALL_OW 266
62886: PUSH
62887: LD_VAR 0 3
62891: PUSH
62892: LD_VAR 0 4
62896: ARRAY
62897: PPUSH
62898: CALL_OW 250
62902: PUSH
62903: LD_VAR 0 3
62907: PUSH
62908: LD_VAR 0 4
62912: ARRAY
62913: PPUSH
62914: CALL_OW 251
62918: PUSH
62919: LD_VAR 0 3
62923: PUSH
62924: LD_VAR 0 4
62928: ARRAY
62929: PPUSH
62930: CALL_OW 254
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: PUSH
62941: EMPTY
62942: LIST
62943: ADD
62944: ST_TO_ADDR
62945: GO 62858
62947: POP
62948: POP
// result := list ;
62949: LD_ADDR_VAR 0 2
62953: PUSH
62954: LD_VAR 0 5
62958: ST_TO_ADDR
// end ;
62959: LD_VAR 0 2
62963: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
62964: LD_INT 0
62966: PPUSH
62967: PPUSH
62968: PPUSH
62969: PPUSH
62970: PPUSH
62971: PPUSH
62972: PPUSH
// if not factory then
62973: LD_VAR 0 1
62977: NOT
62978: IFFALSE 62982
// exit ;
62980: GO 63575
// if control = control_apeman then
62982: LD_VAR 0 4
62986: PUSH
62987: LD_INT 5
62989: EQUAL
62990: IFFALSE 63099
// begin tmp := UnitsInside ( factory ) ;
62992: LD_ADDR_VAR 0 8
62996: PUSH
62997: LD_VAR 0 1
63001: PPUSH
63002: CALL_OW 313
63006: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63007: LD_VAR 0 8
63011: PPUSH
63012: LD_INT 25
63014: PUSH
63015: LD_INT 12
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: PPUSH
63022: CALL_OW 72
63026: NOT
63027: IFFALSE 63037
// control := control_manual ;
63029: LD_ADDR_VAR 0 4
63033: PUSH
63034: LD_INT 1
63036: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63037: LD_ADDR_VAR 0 8
63041: PUSH
63042: LD_VAR 0 1
63046: PPUSH
63047: CALL 62734 0 1
63051: ST_TO_ADDR
// if tmp then
63052: LD_VAR 0 8
63056: IFFALSE 63099
// begin for i in tmp do
63058: LD_ADDR_VAR 0 7
63062: PUSH
63063: LD_VAR 0 8
63067: PUSH
63068: FOR_IN
63069: IFFALSE 63097
// if i [ 1 ] = b_ext_radio then
63071: LD_VAR 0 7
63075: PUSH
63076: LD_INT 1
63078: ARRAY
63079: PUSH
63080: LD_INT 22
63082: EQUAL
63083: IFFALSE 63095
// begin control := control_remote ;
63085: LD_ADDR_VAR 0 4
63089: PUSH
63090: LD_INT 2
63092: ST_TO_ADDR
// break ;
63093: GO 63097
// end ;
63095: GO 63068
63097: POP
63098: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63099: LD_VAR 0 1
63103: PPUSH
63104: LD_VAR 0 2
63108: PPUSH
63109: LD_VAR 0 3
63113: PPUSH
63114: LD_VAR 0 4
63118: PPUSH
63119: LD_VAR 0 5
63123: PPUSH
63124: CALL_OW 448
63128: IFFALSE 63163
// begin result := [ chassis , engine , control , weapon ] ;
63130: LD_ADDR_VAR 0 6
63134: PUSH
63135: LD_VAR 0 2
63139: PUSH
63140: LD_VAR 0 3
63144: PUSH
63145: LD_VAR 0 4
63149: PUSH
63150: LD_VAR 0 5
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: ST_TO_ADDR
// exit ;
63161: GO 63575
// end ; _chassis := AvailableChassisList ( factory ) ;
63163: LD_ADDR_VAR 0 9
63167: PUSH
63168: LD_VAR 0 1
63172: PPUSH
63173: CALL_OW 475
63177: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63178: LD_ADDR_VAR 0 11
63182: PUSH
63183: LD_VAR 0 1
63187: PPUSH
63188: CALL_OW 476
63192: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63193: LD_ADDR_VAR 0 12
63197: PUSH
63198: LD_VAR 0 1
63202: PPUSH
63203: CALL_OW 477
63207: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63208: LD_ADDR_VAR 0 10
63212: PUSH
63213: LD_VAR 0 1
63217: PPUSH
63218: CALL_OW 478
63222: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63223: LD_VAR 0 9
63227: NOT
63228: PUSH
63229: LD_VAR 0 11
63233: NOT
63234: OR
63235: PUSH
63236: LD_VAR 0 12
63240: NOT
63241: OR
63242: PUSH
63243: LD_VAR 0 10
63247: NOT
63248: OR
63249: IFFALSE 63284
// begin result := [ chassis , engine , control , weapon ] ;
63251: LD_ADDR_VAR 0 6
63255: PUSH
63256: LD_VAR 0 2
63260: PUSH
63261: LD_VAR 0 3
63265: PUSH
63266: LD_VAR 0 4
63270: PUSH
63271: LD_VAR 0 5
63275: PUSH
63276: EMPTY
63277: LIST
63278: LIST
63279: LIST
63280: LIST
63281: ST_TO_ADDR
// exit ;
63282: GO 63575
// end ; if not chassis in _chassis then
63284: LD_VAR 0 2
63288: PUSH
63289: LD_VAR 0 9
63293: IN
63294: NOT
63295: IFFALSE 63321
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
63297: LD_ADDR_VAR 0 2
63301: PUSH
63302: LD_VAR 0 9
63306: PUSH
63307: LD_INT 1
63309: PPUSH
63310: LD_VAR 0 9
63314: PPUSH
63315: CALL_OW 12
63319: ARRAY
63320: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
63321: LD_VAR 0 2
63325: PPUSH
63326: LD_VAR 0 3
63330: PPUSH
63331: CALL 63580 0 2
63335: NOT
63336: IFFALSE 63395
// repeat engine := _engine [ 1 ] ;
63338: LD_ADDR_VAR 0 3
63342: PUSH
63343: LD_VAR 0 11
63347: PUSH
63348: LD_INT 1
63350: ARRAY
63351: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
63352: LD_ADDR_VAR 0 11
63356: PUSH
63357: LD_VAR 0 11
63361: PPUSH
63362: LD_INT 1
63364: PPUSH
63365: CALL_OW 3
63369: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
63370: LD_VAR 0 2
63374: PPUSH
63375: LD_VAR 0 3
63379: PPUSH
63380: CALL 63580 0 2
63384: PUSH
63385: LD_VAR 0 11
63389: PUSH
63390: EMPTY
63391: EQUAL
63392: OR
63393: IFFALSE 63338
// if not control in _control then
63395: LD_VAR 0 4
63399: PUSH
63400: LD_VAR 0 12
63404: IN
63405: NOT
63406: IFFALSE 63432
// control := _control [ rand ( 1 , _control ) ] ;
63408: LD_ADDR_VAR 0 4
63412: PUSH
63413: LD_VAR 0 12
63417: PUSH
63418: LD_INT 1
63420: PPUSH
63421: LD_VAR 0 12
63425: PPUSH
63426: CALL_OW 12
63430: ARRAY
63431: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
63432: LD_VAR 0 2
63436: PPUSH
63437: LD_VAR 0 5
63441: PPUSH
63442: CALL 63800 0 2
63446: NOT
63447: IFFALSE 63506
// repeat weapon := _weapon [ 1 ] ;
63449: LD_ADDR_VAR 0 5
63453: PUSH
63454: LD_VAR 0 10
63458: PUSH
63459: LD_INT 1
63461: ARRAY
63462: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
63463: LD_ADDR_VAR 0 10
63467: PUSH
63468: LD_VAR 0 10
63472: PPUSH
63473: LD_INT 1
63475: PPUSH
63476: CALL_OW 3
63480: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
63481: LD_VAR 0 2
63485: PPUSH
63486: LD_VAR 0 5
63490: PPUSH
63491: CALL 63800 0 2
63495: PUSH
63496: LD_VAR 0 10
63500: PUSH
63501: EMPTY
63502: EQUAL
63503: OR
63504: IFFALSE 63449
// result := [ ] ;
63506: LD_ADDR_VAR 0 6
63510: PUSH
63511: EMPTY
63512: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63513: LD_VAR 0 1
63517: PPUSH
63518: LD_VAR 0 2
63522: PPUSH
63523: LD_VAR 0 3
63527: PPUSH
63528: LD_VAR 0 4
63532: PPUSH
63533: LD_VAR 0 5
63537: PPUSH
63538: CALL_OW 448
63542: IFFALSE 63575
// result := [ chassis , engine , control , weapon ] ;
63544: LD_ADDR_VAR 0 6
63548: PUSH
63549: LD_VAR 0 2
63553: PUSH
63554: LD_VAR 0 3
63558: PUSH
63559: LD_VAR 0 4
63563: PUSH
63564: LD_VAR 0 5
63568: PUSH
63569: EMPTY
63570: LIST
63571: LIST
63572: LIST
63573: LIST
63574: ST_TO_ADDR
// end ;
63575: LD_VAR 0 6
63579: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
63580: LD_INT 0
63582: PPUSH
// if not chassis or not engine then
63583: LD_VAR 0 1
63587: NOT
63588: PUSH
63589: LD_VAR 0 2
63593: NOT
63594: OR
63595: IFFALSE 63599
// exit ;
63597: GO 63795
// case engine of engine_solar :
63599: LD_VAR 0 2
63603: PUSH
63604: LD_INT 2
63606: DOUBLE
63607: EQUAL
63608: IFTRUE 63612
63610: GO 63650
63612: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
63613: LD_ADDR_VAR 0 3
63617: PUSH
63618: LD_INT 11
63620: PUSH
63621: LD_INT 12
63623: PUSH
63624: LD_INT 13
63626: PUSH
63627: LD_INT 14
63629: PUSH
63630: LD_INT 1
63632: PUSH
63633: LD_INT 2
63635: PUSH
63636: LD_INT 3
63638: PUSH
63639: EMPTY
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: ST_TO_ADDR
63648: GO 63779
63650: LD_INT 1
63652: DOUBLE
63653: EQUAL
63654: IFTRUE 63658
63656: GO 63720
63658: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
63659: LD_ADDR_VAR 0 3
63663: PUSH
63664: LD_INT 11
63666: PUSH
63667: LD_INT 12
63669: PUSH
63670: LD_INT 13
63672: PUSH
63673: LD_INT 14
63675: PUSH
63676: LD_INT 1
63678: PUSH
63679: LD_INT 2
63681: PUSH
63682: LD_INT 3
63684: PUSH
63685: LD_INT 4
63687: PUSH
63688: LD_INT 5
63690: PUSH
63691: LD_INT 21
63693: PUSH
63694: LD_INT 23
63696: PUSH
63697: LD_INT 22
63699: PUSH
63700: LD_INT 24
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: LIST
63707: LIST
63708: LIST
63709: LIST
63710: LIST
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: LIST
63716: LIST
63717: ST_TO_ADDR
63718: GO 63779
63720: LD_INT 3
63722: DOUBLE
63723: EQUAL
63724: IFTRUE 63728
63726: GO 63778
63728: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
63729: LD_ADDR_VAR 0 3
63733: PUSH
63734: LD_INT 13
63736: PUSH
63737: LD_INT 14
63739: PUSH
63740: LD_INT 2
63742: PUSH
63743: LD_INT 3
63745: PUSH
63746: LD_INT 4
63748: PUSH
63749: LD_INT 5
63751: PUSH
63752: LD_INT 21
63754: PUSH
63755: LD_INT 22
63757: PUSH
63758: LD_INT 23
63760: PUSH
63761: LD_INT 24
63763: PUSH
63764: EMPTY
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: LIST
63775: ST_TO_ADDR
63776: GO 63779
63778: POP
// result := ( chassis in result ) ;
63779: LD_ADDR_VAR 0 3
63783: PUSH
63784: LD_VAR 0 1
63788: PUSH
63789: LD_VAR 0 3
63793: IN
63794: ST_TO_ADDR
// end ;
63795: LD_VAR 0 3
63799: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
63800: LD_INT 0
63802: PPUSH
// if not chassis or not weapon then
63803: LD_VAR 0 1
63807: NOT
63808: PUSH
63809: LD_VAR 0 2
63813: NOT
63814: OR
63815: IFFALSE 63819
// exit ;
63817: GO 64845
// case weapon of us_machine_gun :
63819: LD_VAR 0 2
63823: PUSH
63824: LD_INT 2
63826: DOUBLE
63827: EQUAL
63828: IFTRUE 63832
63830: GO 63862
63832: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
63833: LD_ADDR_VAR 0 3
63837: PUSH
63838: LD_INT 1
63840: PUSH
63841: LD_INT 2
63843: PUSH
63844: LD_INT 3
63846: PUSH
63847: LD_INT 4
63849: PUSH
63850: LD_INT 5
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: ST_TO_ADDR
63860: GO 64829
63862: LD_INT 3
63864: DOUBLE
63865: EQUAL
63866: IFTRUE 63870
63868: GO 63900
63870: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
63871: LD_ADDR_VAR 0 3
63875: PUSH
63876: LD_INT 1
63878: PUSH
63879: LD_INT 2
63881: PUSH
63882: LD_INT 3
63884: PUSH
63885: LD_INT 4
63887: PUSH
63888: LD_INT 5
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: ST_TO_ADDR
63898: GO 64829
63900: LD_INT 11
63902: DOUBLE
63903: EQUAL
63904: IFTRUE 63908
63906: GO 63938
63908: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
63909: LD_ADDR_VAR 0 3
63913: PUSH
63914: LD_INT 1
63916: PUSH
63917: LD_INT 2
63919: PUSH
63920: LD_INT 3
63922: PUSH
63923: LD_INT 4
63925: PUSH
63926: LD_INT 5
63928: PUSH
63929: EMPTY
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: ST_TO_ADDR
63936: GO 64829
63938: LD_INT 4
63940: DOUBLE
63941: EQUAL
63942: IFTRUE 63946
63944: GO 63972
63946: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
63947: LD_ADDR_VAR 0 3
63951: PUSH
63952: LD_INT 2
63954: PUSH
63955: LD_INT 3
63957: PUSH
63958: LD_INT 4
63960: PUSH
63961: LD_INT 5
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: ST_TO_ADDR
63970: GO 64829
63972: LD_INT 5
63974: DOUBLE
63975: EQUAL
63976: IFTRUE 63980
63978: GO 64006
63980: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
63981: LD_ADDR_VAR 0 3
63985: PUSH
63986: LD_INT 2
63988: PUSH
63989: LD_INT 3
63991: PUSH
63992: LD_INT 4
63994: PUSH
63995: LD_INT 5
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: ST_TO_ADDR
64004: GO 64829
64006: LD_INT 9
64008: DOUBLE
64009: EQUAL
64010: IFTRUE 64014
64012: GO 64040
64014: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64015: LD_ADDR_VAR 0 3
64019: PUSH
64020: LD_INT 2
64022: PUSH
64023: LD_INT 3
64025: PUSH
64026: LD_INT 4
64028: PUSH
64029: LD_INT 5
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: LIST
64036: LIST
64037: ST_TO_ADDR
64038: GO 64829
64040: LD_INT 7
64042: DOUBLE
64043: EQUAL
64044: IFTRUE 64048
64046: GO 64074
64048: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64049: LD_ADDR_VAR 0 3
64053: PUSH
64054: LD_INT 2
64056: PUSH
64057: LD_INT 3
64059: PUSH
64060: LD_INT 4
64062: PUSH
64063: LD_INT 5
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: ST_TO_ADDR
64072: GO 64829
64074: LD_INT 12
64076: DOUBLE
64077: EQUAL
64078: IFTRUE 64082
64080: GO 64108
64082: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64083: LD_ADDR_VAR 0 3
64087: PUSH
64088: LD_INT 2
64090: PUSH
64091: LD_INT 3
64093: PUSH
64094: LD_INT 4
64096: PUSH
64097: LD_INT 5
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: ST_TO_ADDR
64106: GO 64829
64108: LD_INT 13
64110: DOUBLE
64111: EQUAL
64112: IFTRUE 64116
64114: GO 64142
64116: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64117: LD_ADDR_VAR 0 3
64121: PUSH
64122: LD_INT 2
64124: PUSH
64125: LD_INT 3
64127: PUSH
64128: LD_INT 4
64130: PUSH
64131: LD_INT 5
64133: PUSH
64134: EMPTY
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: ST_TO_ADDR
64140: GO 64829
64142: LD_INT 14
64144: DOUBLE
64145: EQUAL
64146: IFTRUE 64150
64148: GO 64168
64150: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64151: LD_ADDR_VAR 0 3
64155: PUSH
64156: LD_INT 4
64158: PUSH
64159: LD_INT 5
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: ST_TO_ADDR
64166: GO 64829
64168: LD_INT 6
64170: DOUBLE
64171: EQUAL
64172: IFTRUE 64176
64174: GO 64194
64176: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64177: LD_ADDR_VAR 0 3
64181: PUSH
64182: LD_INT 4
64184: PUSH
64185: LD_INT 5
64187: PUSH
64188: EMPTY
64189: LIST
64190: LIST
64191: ST_TO_ADDR
64192: GO 64829
64194: LD_INT 10
64196: DOUBLE
64197: EQUAL
64198: IFTRUE 64202
64200: GO 64220
64202: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64203: LD_ADDR_VAR 0 3
64207: PUSH
64208: LD_INT 4
64210: PUSH
64211: LD_INT 5
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: ST_TO_ADDR
64218: GO 64829
64220: LD_INT 22
64222: DOUBLE
64223: EQUAL
64224: IFTRUE 64228
64226: GO 64254
64228: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64229: LD_ADDR_VAR 0 3
64233: PUSH
64234: LD_INT 11
64236: PUSH
64237: LD_INT 12
64239: PUSH
64240: LD_INT 13
64242: PUSH
64243: LD_INT 14
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: ST_TO_ADDR
64252: GO 64829
64254: LD_INT 23
64256: DOUBLE
64257: EQUAL
64258: IFTRUE 64262
64260: GO 64288
64262: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
64263: LD_ADDR_VAR 0 3
64267: PUSH
64268: LD_INT 11
64270: PUSH
64271: LD_INT 12
64273: PUSH
64274: LD_INT 13
64276: PUSH
64277: LD_INT 14
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: ST_TO_ADDR
64286: GO 64829
64288: LD_INT 24
64290: DOUBLE
64291: EQUAL
64292: IFTRUE 64296
64294: GO 64322
64296: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
64297: LD_ADDR_VAR 0 3
64301: PUSH
64302: LD_INT 11
64304: PUSH
64305: LD_INT 12
64307: PUSH
64308: LD_INT 13
64310: PUSH
64311: LD_INT 14
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: ST_TO_ADDR
64320: GO 64829
64322: LD_INT 30
64324: DOUBLE
64325: EQUAL
64326: IFTRUE 64330
64328: GO 64356
64330: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
64331: LD_ADDR_VAR 0 3
64335: PUSH
64336: LD_INT 11
64338: PUSH
64339: LD_INT 12
64341: PUSH
64342: LD_INT 13
64344: PUSH
64345: LD_INT 14
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: LIST
64352: LIST
64353: ST_TO_ADDR
64354: GO 64829
64356: LD_INT 25
64358: DOUBLE
64359: EQUAL
64360: IFTRUE 64364
64362: GO 64382
64364: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
64365: LD_ADDR_VAR 0 3
64369: PUSH
64370: LD_INT 13
64372: PUSH
64373: LD_INT 14
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: ST_TO_ADDR
64380: GO 64829
64382: LD_INT 27
64384: DOUBLE
64385: EQUAL
64386: IFTRUE 64390
64388: GO 64408
64390: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
64391: LD_ADDR_VAR 0 3
64395: PUSH
64396: LD_INT 13
64398: PUSH
64399: LD_INT 14
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: ST_TO_ADDR
64406: GO 64829
64408: LD_INT 28
64410: DOUBLE
64411: EQUAL
64412: IFTRUE 64416
64414: GO 64434
64416: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
64417: LD_ADDR_VAR 0 3
64421: PUSH
64422: LD_INT 13
64424: PUSH
64425: LD_INT 14
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: ST_TO_ADDR
64432: GO 64829
64434: LD_INT 29
64436: DOUBLE
64437: EQUAL
64438: IFTRUE 64442
64440: GO 64460
64442: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
64443: LD_ADDR_VAR 0 3
64447: PUSH
64448: LD_INT 13
64450: PUSH
64451: LD_INT 14
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: ST_TO_ADDR
64458: GO 64829
64460: LD_INT 31
64462: DOUBLE
64463: EQUAL
64464: IFTRUE 64468
64466: GO 64486
64468: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
64469: LD_ADDR_VAR 0 3
64473: PUSH
64474: LD_INT 13
64476: PUSH
64477: LD_INT 14
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: ST_TO_ADDR
64484: GO 64829
64486: LD_INT 26
64488: DOUBLE
64489: EQUAL
64490: IFTRUE 64494
64492: GO 64512
64494: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
64495: LD_ADDR_VAR 0 3
64499: PUSH
64500: LD_INT 13
64502: PUSH
64503: LD_INT 14
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: ST_TO_ADDR
64510: GO 64829
64512: LD_INT 42
64514: DOUBLE
64515: EQUAL
64516: IFTRUE 64520
64518: GO 64546
64520: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
64521: LD_ADDR_VAR 0 3
64525: PUSH
64526: LD_INT 21
64528: PUSH
64529: LD_INT 22
64531: PUSH
64532: LD_INT 23
64534: PUSH
64535: LD_INT 24
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: ST_TO_ADDR
64544: GO 64829
64546: LD_INT 43
64548: DOUBLE
64549: EQUAL
64550: IFTRUE 64554
64552: GO 64580
64554: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
64555: LD_ADDR_VAR 0 3
64559: PUSH
64560: LD_INT 21
64562: PUSH
64563: LD_INT 22
64565: PUSH
64566: LD_INT 23
64568: PUSH
64569: LD_INT 24
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: LIST
64576: LIST
64577: ST_TO_ADDR
64578: GO 64829
64580: LD_INT 44
64582: DOUBLE
64583: EQUAL
64584: IFTRUE 64588
64586: GO 64614
64588: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
64589: LD_ADDR_VAR 0 3
64593: PUSH
64594: LD_INT 21
64596: PUSH
64597: LD_INT 22
64599: PUSH
64600: LD_INT 23
64602: PUSH
64603: LD_INT 24
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: ST_TO_ADDR
64612: GO 64829
64614: LD_INT 45
64616: DOUBLE
64617: EQUAL
64618: IFTRUE 64622
64620: GO 64648
64622: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
64623: LD_ADDR_VAR 0 3
64627: PUSH
64628: LD_INT 21
64630: PUSH
64631: LD_INT 22
64633: PUSH
64634: LD_INT 23
64636: PUSH
64637: LD_INT 24
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: LIST
64644: LIST
64645: ST_TO_ADDR
64646: GO 64829
64648: LD_INT 49
64650: DOUBLE
64651: EQUAL
64652: IFTRUE 64656
64654: GO 64682
64656: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
64657: LD_ADDR_VAR 0 3
64661: PUSH
64662: LD_INT 21
64664: PUSH
64665: LD_INT 22
64667: PUSH
64668: LD_INT 23
64670: PUSH
64671: LD_INT 24
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: ST_TO_ADDR
64680: GO 64829
64682: LD_INT 51
64684: DOUBLE
64685: EQUAL
64686: IFTRUE 64690
64688: GO 64716
64690: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
64691: LD_ADDR_VAR 0 3
64695: PUSH
64696: LD_INT 21
64698: PUSH
64699: LD_INT 22
64701: PUSH
64702: LD_INT 23
64704: PUSH
64705: LD_INT 24
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: ST_TO_ADDR
64714: GO 64829
64716: LD_INT 52
64718: DOUBLE
64719: EQUAL
64720: IFTRUE 64724
64722: GO 64750
64724: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
64725: LD_ADDR_VAR 0 3
64729: PUSH
64730: LD_INT 21
64732: PUSH
64733: LD_INT 22
64735: PUSH
64736: LD_INT 23
64738: PUSH
64739: LD_INT 24
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: LIST
64746: LIST
64747: ST_TO_ADDR
64748: GO 64829
64750: LD_INT 53
64752: DOUBLE
64753: EQUAL
64754: IFTRUE 64758
64756: GO 64776
64758: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
64759: LD_ADDR_VAR 0 3
64763: PUSH
64764: LD_INT 23
64766: PUSH
64767: LD_INT 24
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: ST_TO_ADDR
64774: GO 64829
64776: LD_INT 46
64778: DOUBLE
64779: EQUAL
64780: IFTRUE 64784
64782: GO 64802
64784: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
64785: LD_ADDR_VAR 0 3
64789: PUSH
64790: LD_INT 23
64792: PUSH
64793: LD_INT 24
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: ST_TO_ADDR
64800: GO 64829
64802: LD_INT 47
64804: DOUBLE
64805: EQUAL
64806: IFTRUE 64810
64808: GO 64828
64810: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64811: LD_ADDR_VAR 0 3
64815: PUSH
64816: LD_INT 23
64818: PUSH
64819: LD_INT 24
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: ST_TO_ADDR
64826: GO 64829
64828: POP
// result := ( chassis in result ) ;
64829: LD_ADDR_VAR 0 3
64833: PUSH
64834: LD_VAR 0 1
64838: PUSH
64839: LD_VAR 0 3
64843: IN
64844: ST_TO_ADDR
// end ;
64845: LD_VAR 0 3
64849: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
64850: LD_INT 0
64852: PPUSH
64853: PPUSH
64854: PPUSH
64855: PPUSH
64856: PPUSH
64857: PPUSH
64858: PPUSH
// result := array ;
64859: LD_ADDR_VAR 0 5
64863: PUSH
64864: LD_VAR 0 1
64868: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
64869: LD_VAR 0 1
64873: NOT
64874: PUSH
64875: LD_VAR 0 2
64879: NOT
64880: OR
64881: PUSH
64882: LD_VAR 0 3
64886: NOT
64887: OR
64888: PUSH
64889: LD_VAR 0 2
64893: PUSH
64894: LD_VAR 0 1
64898: GREATER
64899: OR
64900: PUSH
64901: LD_VAR 0 3
64905: PUSH
64906: LD_VAR 0 1
64910: GREATER
64911: OR
64912: IFFALSE 64916
// exit ;
64914: GO 65212
// if direction then
64916: LD_VAR 0 4
64920: IFFALSE 64984
// begin d := 1 ;
64922: LD_ADDR_VAR 0 9
64926: PUSH
64927: LD_INT 1
64929: ST_TO_ADDR
// if i_from > i_to then
64930: LD_VAR 0 2
64934: PUSH
64935: LD_VAR 0 3
64939: GREATER
64940: IFFALSE 64966
// length := ( array - i_from ) + i_to else
64942: LD_ADDR_VAR 0 11
64946: PUSH
64947: LD_VAR 0 1
64951: PUSH
64952: LD_VAR 0 2
64956: MINUS
64957: PUSH
64958: LD_VAR 0 3
64962: PLUS
64963: ST_TO_ADDR
64964: GO 64982
// length := i_to - i_from ;
64966: LD_ADDR_VAR 0 11
64970: PUSH
64971: LD_VAR 0 3
64975: PUSH
64976: LD_VAR 0 2
64980: MINUS
64981: ST_TO_ADDR
// end else
64982: GO 65045
// begin d := - 1 ;
64984: LD_ADDR_VAR 0 9
64988: PUSH
64989: LD_INT 1
64991: NEG
64992: ST_TO_ADDR
// if i_from > i_to then
64993: LD_VAR 0 2
64997: PUSH
64998: LD_VAR 0 3
65002: GREATER
65003: IFFALSE 65023
// length := i_from - i_to else
65005: LD_ADDR_VAR 0 11
65009: PUSH
65010: LD_VAR 0 2
65014: PUSH
65015: LD_VAR 0 3
65019: MINUS
65020: ST_TO_ADDR
65021: GO 65045
// length := ( array - i_to ) + i_from ;
65023: LD_ADDR_VAR 0 11
65027: PUSH
65028: LD_VAR 0 1
65032: PUSH
65033: LD_VAR 0 3
65037: MINUS
65038: PUSH
65039: LD_VAR 0 2
65043: PLUS
65044: ST_TO_ADDR
// end ; if not length then
65045: LD_VAR 0 11
65049: NOT
65050: IFFALSE 65054
// exit ;
65052: GO 65212
// tmp := array ;
65054: LD_ADDR_VAR 0 10
65058: PUSH
65059: LD_VAR 0 1
65063: ST_TO_ADDR
// for i = 1 to length do
65064: LD_ADDR_VAR 0 6
65068: PUSH
65069: DOUBLE
65070: LD_INT 1
65072: DEC
65073: ST_TO_ADDR
65074: LD_VAR 0 11
65078: PUSH
65079: FOR_TO
65080: IFFALSE 65200
// begin for j = 1 to array do
65082: LD_ADDR_VAR 0 7
65086: PUSH
65087: DOUBLE
65088: LD_INT 1
65090: DEC
65091: ST_TO_ADDR
65092: LD_VAR 0 1
65096: PUSH
65097: FOR_TO
65098: IFFALSE 65186
// begin k := j + d ;
65100: LD_ADDR_VAR 0 8
65104: PUSH
65105: LD_VAR 0 7
65109: PUSH
65110: LD_VAR 0 9
65114: PLUS
65115: ST_TO_ADDR
// if k > array then
65116: LD_VAR 0 8
65120: PUSH
65121: LD_VAR 0 1
65125: GREATER
65126: IFFALSE 65136
// k := 1 ;
65128: LD_ADDR_VAR 0 8
65132: PUSH
65133: LD_INT 1
65135: ST_TO_ADDR
// if not k then
65136: LD_VAR 0 8
65140: NOT
65141: IFFALSE 65153
// k := array ;
65143: LD_ADDR_VAR 0 8
65147: PUSH
65148: LD_VAR 0 1
65152: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65153: LD_ADDR_VAR 0 10
65157: PUSH
65158: LD_VAR 0 10
65162: PPUSH
65163: LD_VAR 0 8
65167: PPUSH
65168: LD_VAR 0 1
65172: PUSH
65173: LD_VAR 0 7
65177: ARRAY
65178: PPUSH
65179: CALL_OW 1
65183: ST_TO_ADDR
// end ;
65184: GO 65097
65186: POP
65187: POP
// array := tmp ;
65188: LD_ADDR_VAR 0 1
65192: PUSH
65193: LD_VAR 0 10
65197: ST_TO_ADDR
// end ;
65198: GO 65079
65200: POP
65201: POP
// result := array ;
65202: LD_ADDR_VAR 0 5
65206: PUSH
65207: LD_VAR 0 1
65211: ST_TO_ADDR
// end ;
65212: LD_VAR 0 5
65216: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65217: LD_INT 0
65219: PPUSH
65220: PPUSH
// result := 0 ;
65221: LD_ADDR_VAR 0 3
65225: PUSH
65226: LD_INT 0
65228: ST_TO_ADDR
// if not array or not value in array then
65229: LD_VAR 0 1
65233: NOT
65234: PUSH
65235: LD_VAR 0 2
65239: PUSH
65240: LD_VAR 0 1
65244: IN
65245: NOT
65246: OR
65247: IFFALSE 65251
// exit ;
65249: GO 65305
// for i = 1 to array do
65251: LD_ADDR_VAR 0 4
65255: PUSH
65256: DOUBLE
65257: LD_INT 1
65259: DEC
65260: ST_TO_ADDR
65261: LD_VAR 0 1
65265: PUSH
65266: FOR_TO
65267: IFFALSE 65303
// if value = array [ i ] then
65269: LD_VAR 0 2
65273: PUSH
65274: LD_VAR 0 1
65278: PUSH
65279: LD_VAR 0 4
65283: ARRAY
65284: EQUAL
65285: IFFALSE 65301
// begin result := i ;
65287: LD_ADDR_VAR 0 3
65291: PUSH
65292: LD_VAR 0 4
65296: ST_TO_ADDR
// exit ;
65297: POP
65298: POP
65299: GO 65305
// end ;
65301: GO 65266
65303: POP
65304: POP
// end ;
65305: LD_VAR 0 3
65309: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
65310: LD_INT 0
65312: PPUSH
// vc_chassis := chassis ;
65313: LD_ADDR_OWVAR 37
65317: PUSH
65318: LD_VAR 0 1
65322: ST_TO_ADDR
// vc_engine := engine ;
65323: LD_ADDR_OWVAR 39
65327: PUSH
65328: LD_VAR 0 2
65332: ST_TO_ADDR
// vc_control := control ;
65333: LD_ADDR_OWVAR 38
65337: PUSH
65338: LD_VAR 0 3
65342: ST_TO_ADDR
// vc_weapon := weapon ;
65343: LD_ADDR_OWVAR 40
65347: PUSH
65348: LD_VAR 0 4
65352: ST_TO_ADDR
// vc_fuel_battery := fuel ;
65353: LD_ADDR_OWVAR 41
65357: PUSH
65358: LD_VAR 0 5
65362: ST_TO_ADDR
// end ;
65363: LD_VAR 0 6
65367: RET
// export function WantPlant ( unit ) ; var task ; begin
65368: LD_INT 0
65370: PPUSH
65371: PPUSH
// result := false ;
65372: LD_ADDR_VAR 0 2
65376: PUSH
65377: LD_INT 0
65379: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
65380: LD_ADDR_VAR 0 3
65384: PUSH
65385: LD_VAR 0 1
65389: PPUSH
65390: CALL_OW 437
65394: ST_TO_ADDR
// if task then
65395: LD_VAR 0 3
65399: IFFALSE 65427
// if task [ 1 ] [ 1 ] = p then
65401: LD_VAR 0 3
65405: PUSH
65406: LD_INT 1
65408: ARRAY
65409: PUSH
65410: LD_INT 1
65412: ARRAY
65413: PUSH
65414: LD_STRING p
65416: EQUAL
65417: IFFALSE 65427
// result := true ;
65419: LD_ADDR_VAR 0 2
65423: PUSH
65424: LD_INT 1
65426: ST_TO_ADDR
// end ;
65427: LD_VAR 0 2
65431: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
65432: LD_INT 0
65434: PPUSH
65435: PPUSH
65436: PPUSH
65437: PPUSH
// if pos < 1 then
65438: LD_VAR 0 2
65442: PUSH
65443: LD_INT 1
65445: LESS
65446: IFFALSE 65450
// exit ;
65448: GO 65753
// if pos = 1 then
65450: LD_VAR 0 2
65454: PUSH
65455: LD_INT 1
65457: EQUAL
65458: IFFALSE 65491
// result := Replace ( arr , pos [ 1 ] , value ) else
65460: LD_ADDR_VAR 0 4
65464: PUSH
65465: LD_VAR 0 1
65469: PPUSH
65470: LD_VAR 0 2
65474: PUSH
65475: LD_INT 1
65477: ARRAY
65478: PPUSH
65479: LD_VAR 0 3
65483: PPUSH
65484: CALL_OW 1
65488: ST_TO_ADDR
65489: GO 65753
// begin tmp := arr ;
65491: LD_ADDR_VAR 0 6
65495: PUSH
65496: LD_VAR 0 1
65500: ST_TO_ADDR
// s_arr := [ tmp ] ;
65501: LD_ADDR_VAR 0 7
65505: PUSH
65506: LD_VAR 0 6
65510: PUSH
65511: EMPTY
65512: LIST
65513: ST_TO_ADDR
// for i = 1 to pos - 1 do
65514: LD_ADDR_VAR 0 5
65518: PUSH
65519: DOUBLE
65520: LD_INT 1
65522: DEC
65523: ST_TO_ADDR
65524: LD_VAR 0 2
65528: PUSH
65529: LD_INT 1
65531: MINUS
65532: PUSH
65533: FOR_TO
65534: IFFALSE 65579
// begin tmp := tmp [ pos [ i ] ] ;
65536: LD_ADDR_VAR 0 6
65540: PUSH
65541: LD_VAR 0 6
65545: PUSH
65546: LD_VAR 0 2
65550: PUSH
65551: LD_VAR 0 5
65555: ARRAY
65556: ARRAY
65557: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
65558: LD_ADDR_VAR 0 7
65562: PUSH
65563: LD_VAR 0 7
65567: PUSH
65568: LD_VAR 0 6
65572: PUSH
65573: EMPTY
65574: LIST
65575: ADD
65576: ST_TO_ADDR
// end ;
65577: GO 65533
65579: POP
65580: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
65581: LD_ADDR_VAR 0 6
65585: PUSH
65586: LD_VAR 0 6
65590: PPUSH
65591: LD_VAR 0 2
65595: PUSH
65596: LD_VAR 0 2
65600: ARRAY
65601: PPUSH
65602: LD_VAR 0 3
65606: PPUSH
65607: CALL_OW 1
65611: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
65612: LD_ADDR_VAR 0 7
65616: PUSH
65617: LD_VAR 0 7
65621: PPUSH
65622: LD_VAR 0 7
65626: PPUSH
65627: LD_VAR 0 6
65631: PPUSH
65632: CALL_OW 1
65636: ST_TO_ADDR
// for i = s_arr downto 2 do
65637: LD_ADDR_VAR 0 5
65641: PUSH
65642: DOUBLE
65643: LD_VAR 0 7
65647: INC
65648: ST_TO_ADDR
65649: LD_INT 2
65651: PUSH
65652: FOR_DOWNTO
65653: IFFALSE 65737
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
65655: LD_ADDR_VAR 0 6
65659: PUSH
65660: LD_VAR 0 7
65664: PUSH
65665: LD_VAR 0 5
65669: PUSH
65670: LD_INT 1
65672: MINUS
65673: ARRAY
65674: PPUSH
65675: LD_VAR 0 2
65679: PUSH
65680: LD_VAR 0 5
65684: PUSH
65685: LD_INT 1
65687: MINUS
65688: ARRAY
65689: PPUSH
65690: LD_VAR 0 7
65694: PUSH
65695: LD_VAR 0 5
65699: ARRAY
65700: PPUSH
65701: CALL_OW 1
65705: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
65706: LD_ADDR_VAR 0 7
65710: PUSH
65711: LD_VAR 0 7
65715: PPUSH
65716: LD_VAR 0 5
65720: PUSH
65721: LD_INT 1
65723: MINUS
65724: PPUSH
65725: LD_VAR 0 6
65729: PPUSH
65730: CALL_OW 1
65734: ST_TO_ADDR
// end ;
65735: GO 65652
65737: POP
65738: POP
// result := s_arr [ 1 ] ;
65739: LD_ADDR_VAR 0 4
65743: PUSH
65744: LD_VAR 0 7
65748: PUSH
65749: LD_INT 1
65751: ARRAY
65752: ST_TO_ADDR
// end ; end ;
65753: LD_VAR 0 4
65757: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
65758: LD_INT 0
65760: PPUSH
65761: PPUSH
// if not list then
65762: LD_VAR 0 1
65766: NOT
65767: IFFALSE 65771
// exit ;
65769: GO 65862
// i := list [ pos1 ] ;
65771: LD_ADDR_VAR 0 5
65775: PUSH
65776: LD_VAR 0 1
65780: PUSH
65781: LD_VAR 0 2
65785: ARRAY
65786: ST_TO_ADDR
// if not i then
65787: LD_VAR 0 5
65791: NOT
65792: IFFALSE 65796
// exit ;
65794: GO 65862
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
65796: LD_ADDR_VAR 0 1
65800: PUSH
65801: LD_VAR 0 1
65805: PPUSH
65806: LD_VAR 0 2
65810: PPUSH
65811: LD_VAR 0 1
65815: PUSH
65816: LD_VAR 0 3
65820: ARRAY
65821: PPUSH
65822: CALL_OW 1
65826: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
65827: LD_ADDR_VAR 0 1
65831: PUSH
65832: LD_VAR 0 1
65836: PPUSH
65837: LD_VAR 0 3
65841: PPUSH
65842: LD_VAR 0 5
65846: PPUSH
65847: CALL_OW 1
65851: ST_TO_ADDR
// result := list ;
65852: LD_ADDR_VAR 0 4
65856: PUSH
65857: LD_VAR 0 1
65861: ST_TO_ADDR
// end ;
65862: LD_VAR 0 4
65866: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
65867: LD_INT 0
65869: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
65870: LD_ADDR_VAR 0 5
65874: PUSH
65875: LD_VAR 0 1
65879: PPUSH
65880: CALL_OW 250
65884: PPUSH
65885: LD_VAR 0 1
65889: PPUSH
65890: CALL_OW 251
65894: PPUSH
65895: LD_VAR 0 2
65899: PPUSH
65900: LD_VAR 0 3
65904: PPUSH
65905: LD_VAR 0 4
65909: PPUSH
65910: CALL 65920 0 5
65914: ST_TO_ADDR
// end ;
65915: LD_VAR 0 5
65919: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
65920: LD_INT 0
65922: PPUSH
65923: PPUSH
65924: PPUSH
65925: PPUSH
// if not list then
65926: LD_VAR 0 3
65930: NOT
65931: IFFALSE 65935
// exit ;
65933: GO 66323
// result := [ ] ;
65935: LD_ADDR_VAR 0 6
65939: PUSH
65940: EMPTY
65941: ST_TO_ADDR
// for i in list do
65942: LD_ADDR_VAR 0 7
65946: PUSH
65947: LD_VAR 0 3
65951: PUSH
65952: FOR_IN
65953: IFFALSE 66155
// begin tmp := GetDistUnitXY ( i , x , y ) ;
65955: LD_ADDR_VAR 0 9
65959: PUSH
65960: LD_VAR 0 7
65964: PPUSH
65965: LD_VAR 0 1
65969: PPUSH
65970: LD_VAR 0 2
65974: PPUSH
65975: CALL_OW 297
65979: ST_TO_ADDR
// if not result then
65980: LD_VAR 0 6
65984: NOT
65985: IFFALSE 66011
// result := [ [ i , tmp ] ] else
65987: LD_ADDR_VAR 0 6
65991: PUSH
65992: LD_VAR 0 7
65996: PUSH
65997: LD_VAR 0 9
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: EMPTY
66007: LIST
66008: ST_TO_ADDR
66009: GO 66153
// begin if result [ result ] [ 2 ] < tmp then
66011: LD_VAR 0 6
66015: PUSH
66016: LD_VAR 0 6
66020: ARRAY
66021: PUSH
66022: LD_INT 2
66024: ARRAY
66025: PUSH
66026: LD_VAR 0 9
66030: LESS
66031: IFFALSE 66073
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66033: LD_ADDR_VAR 0 6
66037: PUSH
66038: LD_VAR 0 6
66042: PPUSH
66043: LD_VAR 0 6
66047: PUSH
66048: LD_INT 1
66050: PLUS
66051: PPUSH
66052: LD_VAR 0 7
66056: PUSH
66057: LD_VAR 0 9
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PPUSH
66066: CALL_OW 2
66070: ST_TO_ADDR
66071: GO 66153
// for j = 1 to result do
66073: LD_ADDR_VAR 0 8
66077: PUSH
66078: DOUBLE
66079: LD_INT 1
66081: DEC
66082: ST_TO_ADDR
66083: LD_VAR 0 6
66087: PUSH
66088: FOR_TO
66089: IFFALSE 66151
// begin if tmp < result [ j ] [ 2 ] then
66091: LD_VAR 0 9
66095: PUSH
66096: LD_VAR 0 6
66100: PUSH
66101: LD_VAR 0 8
66105: ARRAY
66106: PUSH
66107: LD_INT 2
66109: ARRAY
66110: LESS
66111: IFFALSE 66149
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66113: LD_ADDR_VAR 0 6
66117: PUSH
66118: LD_VAR 0 6
66122: PPUSH
66123: LD_VAR 0 8
66127: PPUSH
66128: LD_VAR 0 7
66132: PUSH
66133: LD_VAR 0 9
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PPUSH
66142: CALL_OW 2
66146: ST_TO_ADDR
// break ;
66147: GO 66151
// end ; end ;
66149: GO 66088
66151: POP
66152: POP
// end ; end ;
66153: GO 65952
66155: POP
66156: POP
// if result and not asc then
66157: LD_VAR 0 6
66161: PUSH
66162: LD_VAR 0 4
66166: NOT
66167: AND
66168: IFFALSE 66243
// begin tmp := result ;
66170: LD_ADDR_VAR 0 9
66174: PUSH
66175: LD_VAR 0 6
66179: ST_TO_ADDR
// for i = tmp downto 1 do
66180: LD_ADDR_VAR 0 7
66184: PUSH
66185: DOUBLE
66186: LD_VAR 0 9
66190: INC
66191: ST_TO_ADDR
66192: LD_INT 1
66194: PUSH
66195: FOR_DOWNTO
66196: IFFALSE 66241
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66198: LD_ADDR_VAR 0 6
66202: PUSH
66203: LD_VAR 0 6
66207: PPUSH
66208: LD_VAR 0 9
66212: PUSH
66213: LD_VAR 0 7
66217: MINUS
66218: PUSH
66219: LD_INT 1
66221: PLUS
66222: PPUSH
66223: LD_VAR 0 9
66227: PUSH
66228: LD_VAR 0 7
66232: ARRAY
66233: PPUSH
66234: CALL_OW 1
66238: ST_TO_ADDR
66239: GO 66195
66241: POP
66242: POP
// end ; tmp := [ ] ;
66243: LD_ADDR_VAR 0 9
66247: PUSH
66248: EMPTY
66249: ST_TO_ADDR
// if mode then
66250: LD_VAR 0 5
66254: IFFALSE 66323
// begin for i = 1 to result do
66256: LD_ADDR_VAR 0 7
66260: PUSH
66261: DOUBLE
66262: LD_INT 1
66264: DEC
66265: ST_TO_ADDR
66266: LD_VAR 0 6
66270: PUSH
66271: FOR_TO
66272: IFFALSE 66311
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
66274: LD_ADDR_VAR 0 9
66278: PUSH
66279: LD_VAR 0 9
66283: PPUSH
66284: LD_VAR 0 7
66288: PPUSH
66289: LD_VAR 0 6
66293: PUSH
66294: LD_VAR 0 7
66298: ARRAY
66299: PUSH
66300: LD_INT 1
66302: ARRAY
66303: PPUSH
66304: CALL_OW 1
66308: ST_TO_ADDR
66309: GO 66271
66311: POP
66312: POP
// result := tmp ;
66313: LD_ADDR_VAR 0 6
66317: PUSH
66318: LD_VAR 0 9
66322: ST_TO_ADDR
// end ; end ;
66323: LD_VAR 0 6
66327: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
66328: LD_INT 0
66330: PPUSH
66331: PPUSH
66332: PPUSH
66333: PPUSH
66334: PPUSH
66335: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
66336: LD_ADDR_VAR 0 5
66340: PUSH
66341: LD_INT 0
66343: PUSH
66344: LD_INT 0
66346: PUSH
66347: LD_INT 0
66349: PUSH
66350: EMPTY
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: ST_TO_ADDR
// if not x or not y then
66358: LD_VAR 0 2
66362: NOT
66363: PUSH
66364: LD_VAR 0 3
66368: NOT
66369: OR
66370: IFFALSE 66374
// exit ;
66372: GO 68020
// if not range then
66374: LD_VAR 0 4
66378: NOT
66379: IFFALSE 66389
// range := 10 ;
66381: LD_ADDR_VAR 0 4
66385: PUSH
66386: LD_INT 10
66388: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66389: LD_ADDR_VAR 0 8
66393: PUSH
66394: LD_INT 81
66396: PUSH
66397: LD_VAR 0 1
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: PUSH
66406: LD_INT 92
66408: PUSH
66409: LD_VAR 0 2
66413: PUSH
66414: LD_VAR 0 3
66418: PUSH
66419: LD_VAR 0 4
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 3
66432: PUSH
66433: LD_INT 21
66435: PUSH
66436: LD_INT 3
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: LIST
66451: PPUSH
66452: CALL_OW 69
66456: ST_TO_ADDR
// if not tmp then
66457: LD_VAR 0 8
66461: NOT
66462: IFFALSE 66466
// exit ;
66464: GO 68020
// for i in tmp do
66466: LD_ADDR_VAR 0 6
66470: PUSH
66471: LD_VAR 0 8
66475: PUSH
66476: FOR_IN
66477: IFFALSE 67995
// begin points := [ 0 , 0 , 0 ] ;
66479: LD_ADDR_VAR 0 9
66483: PUSH
66484: LD_INT 0
66486: PUSH
66487: LD_INT 0
66489: PUSH
66490: LD_INT 0
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: LIST
66497: ST_TO_ADDR
// bpoints := 1 ;
66498: LD_ADDR_VAR 0 10
66502: PUSH
66503: LD_INT 1
66505: ST_TO_ADDR
// case GetType ( i ) of unit_human :
66506: LD_VAR 0 6
66510: PPUSH
66511: CALL_OW 247
66515: PUSH
66516: LD_INT 1
66518: DOUBLE
66519: EQUAL
66520: IFTRUE 66524
66522: GO 67102
66524: POP
// begin if GetClass ( i ) = 1 then
66525: LD_VAR 0 6
66529: PPUSH
66530: CALL_OW 257
66534: PUSH
66535: LD_INT 1
66537: EQUAL
66538: IFFALSE 66559
// points := [ 10 , 5 , 3 ] ;
66540: LD_ADDR_VAR 0 9
66544: PUSH
66545: LD_INT 10
66547: PUSH
66548: LD_INT 5
66550: PUSH
66551: LD_INT 3
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: LIST
66558: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
66559: LD_VAR 0 6
66563: PPUSH
66564: CALL_OW 257
66568: PUSH
66569: LD_INT 2
66571: PUSH
66572: LD_INT 3
66574: PUSH
66575: LD_INT 4
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: LIST
66582: IN
66583: IFFALSE 66604
// points := [ 3 , 2 , 1 ] ;
66585: LD_ADDR_VAR 0 9
66589: PUSH
66590: LD_INT 3
66592: PUSH
66593: LD_INT 2
66595: PUSH
66596: LD_INT 1
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: LIST
66603: ST_TO_ADDR
// if GetClass ( i ) = 5 then
66604: LD_VAR 0 6
66608: PPUSH
66609: CALL_OW 257
66613: PUSH
66614: LD_INT 5
66616: EQUAL
66617: IFFALSE 66638
// points := [ 130 , 5 , 2 ] ;
66619: LD_ADDR_VAR 0 9
66623: PUSH
66624: LD_INT 130
66626: PUSH
66627: LD_INT 5
66629: PUSH
66630: LD_INT 2
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: LIST
66637: ST_TO_ADDR
// if GetClass ( i ) = 8 then
66638: LD_VAR 0 6
66642: PPUSH
66643: CALL_OW 257
66647: PUSH
66648: LD_INT 8
66650: EQUAL
66651: IFFALSE 66672
// points := [ 35 , 35 , 30 ] ;
66653: LD_ADDR_VAR 0 9
66657: PUSH
66658: LD_INT 35
66660: PUSH
66661: LD_INT 35
66663: PUSH
66664: LD_INT 30
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: LIST
66671: ST_TO_ADDR
// if GetClass ( i ) = 9 then
66672: LD_VAR 0 6
66676: PPUSH
66677: CALL_OW 257
66681: PUSH
66682: LD_INT 9
66684: EQUAL
66685: IFFALSE 66706
// points := [ 20 , 55 , 40 ] ;
66687: LD_ADDR_VAR 0 9
66691: PUSH
66692: LD_INT 20
66694: PUSH
66695: LD_INT 55
66697: PUSH
66698: LD_INT 40
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: LIST
66705: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
66706: LD_VAR 0 6
66710: PPUSH
66711: CALL_OW 257
66715: PUSH
66716: LD_INT 12
66718: PUSH
66719: LD_INT 16
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: IN
66726: IFFALSE 66747
// points := [ 5 , 3 , 2 ] ;
66728: LD_ADDR_VAR 0 9
66732: PUSH
66733: LD_INT 5
66735: PUSH
66736: LD_INT 3
66738: PUSH
66739: LD_INT 2
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: LIST
66746: ST_TO_ADDR
// if GetClass ( i ) = 17 then
66747: LD_VAR 0 6
66751: PPUSH
66752: CALL_OW 257
66756: PUSH
66757: LD_INT 17
66759: EQUAL
66760: IFFALSE 66781
// points := [ 100 , 50 , 75 ] ;
66762: LD_ADDR_VAR 0 9
66766: PUSH
66767: LD_INT 100
66769: PUSH
66770: LD_INT 50
66772: PUSH
66773: LD_INT 75
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: LIST
66780: ST_TO_ADDR
// if GetClass ( i ) = 15 then
66781: LD_VAR 0 6
66785: PPUSH
66786: CALL_OW 257
66790: PUSH
66791: LD_INT 15
66793: EQUAL
66794: IFFALSE 66815
// points := [ 10 , 5 , 3 ] ;
66796: LD_ADDR_VAR 0 9
66800: PUSH
66801: LD_INT 10
66803: PUSH
66804: LD_INT 5
66806: PUSH
66807: LD_INT 3
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: LIST
66814: ST_TO_ADDR
// if GetClass ( i ) = 14 then
66815: LD_VAR 0 6
66819: PPUSH
66820: CALL_OW 257
66824: PUSH
66825: LD_INT 14
66827: EQUAL
66828: IFFALSE 66849
// points := [ 10 , 0 , 0 ] ;
66830: LD_ADDR_VAR 0 9
66834: PUSH
66835: LD_INT 10
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: LD_INT 0
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: LIST
66848: ST_TO_ADDR
// if GetClass ( i ) = 11 then
66849: LD_VAR 0 6
66853: PPUSH
66854: CALL_OW 257
66858: PUSH
66859: LD_INT 11
66861: EQUAL
66862: IFFALSE 66883
// points := [ 30 , 10 , 5 ] ;
66864: LD_ADDR_VAR 0 9
66868: PUSH
66869: LD_INT 30
66871: PUSH
66872: LD_INT 10
66874: PUSH
66875: LD_INT 5
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: LIST
66882: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
66883: LD_VAR 0 1
66887: PPUSH
66888: LD_INT 5
66890: PPUSH
66891: CALL_OW 321
66895: PUSH
66896: LD_INT 2
66898: EQUAL
66899: IFFALSE 66916
// bpoints := bpoints * 1.8 ;
66901: LD_ADDR_VAR 0 10
66905: PUSH
66906: LD_VAR 0 10
66910: PUSH
66911: LD_REAL  1.80000000000000E+0000
66914: MUL
66915: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
66916: LD_VAR 0 6
66920: PPUSH
66921: CALL_OW 257
66925: PUSH
66926: LD_INT 1
66928: PUSH
66929: LD_INT 2
66931: PUSH
66932: LD_INT 3
66934: PUSH
66935: LD_INT 4
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: IN
66944: PUSH
66945: LD_VAR 0 1
66949: PPUSH
66950: LD_INT 51
66952: PPUSH
66953: CALL_OW 321
66957: PUSH
66958: LD_INT 2
66960: EQUAL
66961: AND
66962: IFFALSE 66979
// bpoints := bpoints * 1.2 ;
66964: LD_ADDR_VAR 0 10
66968: PUSH
66969: LD_VAR 0 10
66973: PUSH
66974: LD_REAL  1.20000000000000E+0000
66977: MUL
66978: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
66979: LD_VAR 0 6
66983: PPUSH
66984: CALL_OW 257
66988: PUSH
66989: LD_INT 5
66991: PUSH
66992: LD_INT 7
66994: PUSH
66995: LD_INT 9
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: LIST
67002: IN
67003: PUSH
67004: LD_VAR 0 1
67008: PPUSH
67009: LD_INT 52
67011: PPUSH
67012: CALL_OW 321
67016: PUSH
67017: LD_INT 2
67019: EQUAL
67020: AND
67021: IFFALSE 67038
// bpoints := bpoints * 1.5 ;
67023: LD_ADDR_VAR 0 10
67027: PUSH
67028: LD_VAR 0 10
67032: PUSH
67033: LD_REAL  1.50000000000000E+0000
67036: MUL
67037: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67038: LD_VAR 0 1
67042: PPUSH
67043: LD_INT 66
67045: PPUSH
67046: CALL_OW 321
67050: PUSH
67051: LD_INT 2
67053: EQUAL
67054: IFFALSE 67071
// bpoints := bpoints * 1.1 ;
67056: LD_ADDR_VAR 0 10
67060: PUSH
67061: LD_VAR 0 10
67065: PUSH
67066: LD_REAL  1.10000000000000E+0000
67069: MUL
67070: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67071: LD_ADDR_VAR 0 10
67075: PUSH
67076: LD_VAR 0 10
67080: PUSH
67081: LD_VAR 0 6
67085: PPUSH
67086: LD_INT 1
67088: PPUSH
67089: CALL_OW 259
67093: PUSH
67094: LD_REAL  1.15000000000000E+0000
67097: MUL
67098: MUL
67099: ST_TO_ADDR
// end ; unit_vehicle :
67100: GO 67924
67102: LD_INT 2
67104: DOUBLE
67105: EQUAL
67106: IFTRUE 67110
67108: GO 67912
67110: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67111: LD_VAR 0 6
67115: PPUSH
67116: CALL_OW 264
67120: PUSH
67121: LD_INT 2
67123: PUSH
67124: LD_INT 42
67126: PUSH
67127: LD_INT 24
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: LIST
67134: IN
67135: IFFALSE 67156
// points := [ 25 , 5 , 3 ] ;
67137: LD_ADDR_VAR 0 9
67141: PUSH
67142: LD_INT 25
67144: PUSH
67145: LD_INT 5
67147: PUSH
67148: LD_INT 3
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: LIST
67155: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67156: LD_VAR 0 6
67160: PPUSH
67161: CALL_OW 264
67165: PUSH
67166: LD_INT 4
67168: PUSH
67169: LD_INT 43
67171: PUSH
67172: LD_INT 25
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: LIST
67179: IN
67180: IFFALSE 67201
// points := [ 40 , 15 , 5 ] ;
67182: LD_ADDR_VAR 0 9
67186: PUSH
67187: LD_INT 40
67189: PUSH
67190: LD_INT 15
67192: PUSH
67193: LD_INT 5
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: LIST
67200: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67201: LD_VAR 0 6
67205: PPUSH
67206: CALL_OW 264
67210: PUSH
67211: LD_INT 3
67213: PUSH
67214: LD_INT 23
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: IN
67221: IFFALSE 67242
// points := [ 7 , 25 , 8 ] ;
67223: LD_ADDR_VAR 0 9
67227: PUSH
67228: LD_INT 7
67230: PUSH
67231: LD_INT 25
67233: PUSH
67234: LD_INT 8
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: LIST
67241: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
67242: LD_VAR 0 6
67246: PPUSH
67247: CALL_OW 264
67251: PUSH
67252: LD_INT 5
67254: PUSH
67255: LD_INT 27
67257: PUSH
67258: LD_INT 44
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: LIST
67265: IN
67266: IFFALSE 67287
// points := [ 14 , 50 , 16 ] ;
67268: LD_ADDR_VAR 0 9
67272: PUSH
67273: LD_INT 14
67275: PUSH
67276: LD_INT 50
67278: PUSH
67279: LD_INT 16
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: LIST
67286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
67287: LD_VAR 0 6
67291: PPUSH
67292: CALL_OW 264
67296: PUSH
67297: LD_INT 6
67299: PUSH
67300: LD_INT 46
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: IN
67307: IFFALSE 67328
// points := [ 32 , 120 , 70 ] ;
67309: LD_ADDR_VAR 0 9
67313: PUSH
67314: LD_INT 32
67316: PUSH
67317: LD_INT 120
67319: PUSH
67320: LD_INT 70
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: LIST
67327: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
67328: LD_VAR 0 6
67332: PPUSH
67333: CALL_OW 264
67337: PUSH
67338: LD_INT 7
67340: PUSH
67341: LD_INT 28
67343: PUSH
67344: LD_INT 45
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: LIST
67351: IN
67352: IFFALSE 67373
// points := [ 35 , 20 , 45 ] ;
67354: LD_ADDR_VAR 0 9
67358: PUSH
67359: LD_INT 35
67361: PUSH
67362: LD_INT 20
67364: PUSH
67365: LD_INT 45
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: LIST
67372: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
67373: LD_VAR 0 6
67377: PPUSH
67378: CALL_OW 264
67382: PUSH
67383: LD_INT 47
67385: PUSH
67386: EMPTY
67387: LIST
67388: IN
67389: IFFALSE 67410
// points := [ 67 , 45 , 75 ] ;
67391: LD_ADDR_VAR 0 9
67395: PUSH
67396: LD_INT 67
67398: PUSH
67399: LD_INT 45
67401: PUSH
67402: LD_INT 75
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: LIST
67409: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
67410: LD_VAR 0 6
67414: PPUSH
67415: CALL_OW 264
67419: PUSH
67420: LD_INT 26
67422: PUSH
67423: EMPTY
67424: LIST
67425: IN
67426: IFFALSE 67447
// points := [ 120 , 30 , 80 ] ;
67428: LD_ADDR_VAR 0 9
67432: PUSH
67433: LD_INT 120
67435: PUSH
67436: LD_INT 30
67438: PUSH
67439: LD_INT 80
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: LIST
67446: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
67447: LD_VAR 0 6
67451: PPUSH
67452: CALL_OW 264
67456: PUSH
67457: LD_INT 22
67459: PUSH
67460: EMPTY
67461: LIST
67462: IN
67463: IFFALSE 67484
// points := [ 40 , 1 , 1 ] ;
67465: LD_ADDR_VAR 0 9
67469: PUSH
67470: LD_INT 40
67472: PUSH
67473: LD_INT 1
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: LIST
67483: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
67484: LD_VAR 0 6
67488: PPUSH
67489: CALL_OW 264
67493: PUSH
67494: LD_INT 29
67496: PUSH
67497: EMPTY
67498: LIST
67499: IN
67500: IFFALSE 67521
// points := [ 70 , 200 , 400 ] ;
67502: LD_ADDR_VAR 0 9
67506: PUSH
67507: LD_INT 70
67509: PUSH
67510: LD_INT 200
67512: PUSH
67513: LD_INT 400
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: LIST
67520: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
67521: LD_VAR 0 6
67525: PPUSH
67526: CALL_OW 264
67530: PUSH
67531: LD_INT 14
67533: PUSH
67534: LD_INT 53
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: IN
67541: IFFALSE 67562
// points := [ 40 , 10 , 20 ] ;
67543: LD_ADDR_VAR 0 9
67547: PUSH
67548: LD_INT 40
67550: PUSH
67551: LD_INT 10
67553: PUSH
67554: LD_INT 20
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: LIST
67561: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
67562: LD_VAR 0 6
67566: PPUSH
67567: CALL_OW 264
67571: PUSH
67572: LD_INT 9
67574: PUSH
67575: EMPTY
67576: LIST
67577: IN
67578: IFFALSE 67599
// points := [ 5 , 70 , 20 ] ;
67580: LD_ADDR_VAR 0 9
67584: PUSH
67585: LD_INT 5
67587: PUSH
67588: LD_INT 70
67590: PUSH
67591: LD_INT 20
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: LIST
67598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
67599: LD_VAR 0 6
67603: PPUSH
67604: CALL_OW 264
67608: PUSH
67609: LD_INT 10
67611: PUSH
67612: EMPTY
67613: LIST
67614: IN
67615: IFFALSE 67636
// points := [ 35 , 110 , 70 ] ;
67617: LD_ADDR_VAR 0 9
67621: PUSH
67622: LD_INT 35
67624: PUSH
67625: LD_INT 110
67627: PUSH
67628: LD_INT 70
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: LIST
67635: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
67636: LD_VAR 0 6
67640: PPUSH
67641: CALL_OW 265
67645: PUSH
67646: LD_INT 25
67648: EQUAL
67649: IFFALSE 67670
// points := [ 80 , 65 , 100 ] ;
67651: LD_ADDR_VAR 0 9
67655: PUSH
67656: LD_INT 80
67658: PUSH
67659: LD_INT 65
67661: PUSH
67662: LD_INT 100
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: LIST
67669: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
67670: LD_VAR 0 6
67674: PPUSH
67675: CALL_OW 263
67679: PUSH
67680: LD_INT 1
67682: EQUAL
67683: IFFALSE 67718
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
67685: LD_ADDR_VAR 0 10
67689: PUSH
67690: LD_VAR 0 10
67694: PUSH
67695: LD_VAR 0 6
67699: PPUSH
67700: CALL_OW 311
67704: PPUSH
67705: LD_INT 3
67707: PPUSH
67708: CALL_OW 259
67712: PUSH
67713: LD_INT 4
67715: MUL
67716: MUL
67717: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
67718: LD_VAR 0 6
67722: PPUSH
67723: CALL_OW 263
67727: PUSH
67728: LD_INT 2
67730: EQUAL
67731: IFFALSE 67782
// begin j := IsControledBy ( i ) ;
67733: LD_ADDR_VAR 0 7
67737: PUSH
67738: LD_VAR 0 6
67742: PPUSH
67743: CALL_OW 312
67747: ST_TO_ADDR
// if j then
67748: LD_VAR 0 7
67752: IFFALSE 67782
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
67754: LD_ADDR_VAR 0 10
67758: PUSH
67759: LD_VAR 0 10
67763: PUSH
67764: LD_VAR 0 7
67768: PPUSH
67769: LD_INT 3
67771: PPUSH
67772: CALL_OW 259
67776: PUSH
67777: LD_INT 3
67779: MUL
67780: MUL
67781: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
67782: LD_VAR 0 6
67786: PPUSH
67787: CALL_OW 264
67791: PUSH
67792: LD_INT 5
67794: PUSH
67795: LD_INT 6
67797: PUSH
67798: LD_INT 46
67800: PUSH
67801: LD_INT 44
67803: PUSH
67804: LD_INT 47
67806: PUSH
67807: LD_INT 45
67809: PUSH
67810: LD_INT 28
67812: PUSH
67813: LD_INT 7
67815: PUSH
67816: LD_INT 27
67818: PUSH
67819: LD_INT 29
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: IN
67834: PUSH
67835: LD_VAR 0 1
67839: PPUSH
67840: LD_INT 52
67842: PPUSH
67843: CALL_OW 321
67847: PUSH
67848: LD_INT 2
67850: EQUAL
67851: AND
67852: IFFALSE 67869
// bpoints := bpoints * 1.2 ;
67854: LD_ADDR_VAR 0 10
67858: PUSH
67859: LD_VAR 0 10
67863: PUSH
67864: LD_REAL  1.20000000000000E+0000
67867: MUL
67868: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
67869: LD_VAR 0 6
67873: PPUSH
67874: CALL_OW 264
67878: PUSH
67879: LD_INT 6
67881: PUSH
67882: LD_INT 46
67884: PUSH
67885: LD_INT 47
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: LIST
67892: IN
67893: IFFALSE 67910
// bpoints := bpoints * 1.2 ;
67895: LD_ADDR_VAR 0 10
67899: PUSH
67900: LD_VAR 0 10
67904: PUSH
67905: LD_REAL  1.20000000000000E+0000
67908: MUL
67909: ST_TO_ADDR
// end ; unit_building :
67910: GO 67924
67912: LD_INT 3
67914: DOUBLE
67915: EQUAL
67916: IFTRUE 67920
67918: GO 67923
67920: POP
// ; end ;
67921: GO 67924
67923: POP
// for j = 1 to 3 do
67924: LD_ADDR_VAR 0 7
67928: PUSH
67929: DOUBLE
67930: LD_INT 1
67932: DEC
67933: ST_TO_ADDR
67934: LD_INT 3
67936: PUSH
67937: FOR_TO
67938: IFFALSE 67991
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
67940: LD_ADDR_VAR 0 5
67944: PUSH
67945: LD_VAR 0 5
67949: PPUSH
67950: LD_VAR 0 7
67954: PPUSH
67955: LD_VAR 0 5
67959: PUSH
67960: LD_VAR 0 7
67964: ARRAY
67965: PUSH
67966: LD_VAR 0 9
67970: PUSH
67971: LD_VAR 0 7
67975: ARRAY
67976: PUSH
67977: LD_VAR 0 10
67981: MUL
67982: PLUS
67983: PPUSH
67984: CALL_OW 1
67988: ST_TO_ADDR
67989: GO 67937
67991: POP
67992: POP
// end ;
67993: GO 66476
67995: POP
67996: POP
// result := Replace ( result , 4 , tmp ) ;
67997: LD_ADDR_VAR 0 5
68001: PUSH
68002: LD_VAR 0 5
68006: PPUSH
68007: LD_INT 4
68009: PPUSH
68010: LD_VAR 0 8
68014: PPUSH
68015: CALL_OW 1
68019: ST_TO_ADDR
// end ;
68020: LD_VAR 0 5
68024: RET
// export function DangerAtRange ( unit , range ) ; begin
68025: LD_INT 0
68027: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68028: LD_ADDR_VAR 0 3
68032: PUSH
68033: LD_VAR 0 1
68037: PPUSH
68038: CALL_OW 255
68042: PPUSH
68043: LD_VAR 0 1
68047: PPUSH
68048: CALL_OW 250
68052: PPUSH
68053: LD_VAR 0 1
68057: PPUSH
68058: CALL_OW 251
68062: PPUSH
68063: LD_VAR 0 2
68067: PPUSH
68068: CALL 66328 0 4
68072: ST_TO_ADDR
// end ;
68073: LD_VAR 0 3
68077: RET
// export function DangerInArea ( side , area ) ; begin
68078: LD_INT 0
68080: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68081: LD_ADDR_VAR 0 3
68085: PUSH
68086: LD_VAR 0 2
68090: PPUSH
68091: LD_INT 81
68093: PUSH
68094: LD_VAR 0 1
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PPUSH
68103: CALL_OW 70
68107: ST_TO_ADDR
// end ;
68108: LD_VAR 0 3
68112: RET
// export function IsExtension ( b ) ; begin
68113: LD_INT 0
68115: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68116: LD_ADDR_VAR 0 2
68120: PUSH
68121: LD_VAR 0 1
68125: PUSH
68126: LD_INT 23
68128: PUSH
68129: LD_INT 20
68131: PUSH
68132: LD_INT 22
68134: PUSH
68135: LD_INT 17
68137: PUSH
68138: LD_INT 24
68140: PUSH
68141: LD_INT 21
68143: PUSH
68144: LD_INT 19
68146: PUSH
68147: LD_INT 16
68149: PUSH
68150: LD_INT 25
68152: PUSH
68153: LD_INT 18
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: IN
68168: ST_TO_ADDR
// end ;
68169: LD_VAR 0 2
68173: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
68174: LD_INT 0
68176: PPUSH
68177: PPUSH
68178: PPUSH
// result := [ ] ;
68179: LD_ADDR_VAR 0 3
68183: PUSH
68184: EMPTY
68185: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68186: LD_ADDR_VAR 0 4
68190: PUSH
68191: LD_VAR 0 2
68195: PPUSH
68196: LD_INT 21
68198: PUSH
68199: LD_INT 3
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PPUSH
68206: CALL_OW 70
68210: ST_TO_ADDR
// if not tmp then
68211: LD_VAR 0 4
68215: NOT
68216: IFFALSE 68220
// exit ;
68218: GO 68278
// for i in tmp do
68220: LD_ADDR_VAR 0 5
68224: PUSH
68225: LD_VAR 0 4
68229: PUSH
68230: FOR_IN
68231: IFFALSE 68266
// if GetBase ( i ) <> base then
68233: LD_VAR 0 5
68237: PPUSH
68238: CALL_OW 274
68242: PUSH
68243: LD_VAR 0 1
68247: NONEQUAL
68248: IFFALSE 68264
// ComLinkToBase ( base , i ) ;
68250: LD_VAR 0 1
68254: PPUSH
68255: LD_VAR 0 5
68259: PPUSH
68260: CALL_OW 169
68264: GO 68230
68266: POP
68267: POP
// result := tmp ;
68268: LD_ADDR_VAR 0 3
68272: PUSH
68273: LD_VAR 0 4
68277: ST_TO_ADDR
// end ;
68278: LD_VAR 0 3
68282: RET
// export function ComComplete ( unit , b ) ; var i ; begin
68283: LD_INT 0
68285: PPUSH
68286: PPUSH
// if BuildingStatus ( b ) = bs_build then
68287: LD_VAR 0 2
68291: PPUSH
68292: CALL_OW 461
68296: PUSH
68297: LD_INT 1
68299: EQUAL
68300: IFFALSE 68360
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
68302: LD_VAR 0 1
68306: PPUSH
68307: LD_STRING h
68309: PUSH
68310: LD_VAR 0 2
68314: PPUSH
68315: CALL_OW 250
68319: PUSH
68320: LD_VAR 0 2
68324: PPUSH
68325: CALL_OW 251
68329: PUSH
68330: LD_VAR 0 2
68334: PUSH
68335: LD_INT 0
68337: PUSH
68338: LD_INT 0
68340: PUSH
68341: LD_INT 0
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: PUSH
68353: EMPTY
68354: LIST
68355: PPUSH
68356: CALL_OW 446
// end ;
68360: LD_VAR 0 3
68364: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
68365: LD_INT 0
68367: PPUSH
68368: PPUSH
68369: PPUSH
68370: PPUSH
68371: PPUSH
68372: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
68373: LD_VAR 0 1
68377: NOT
68378: PUSH
68379: LD_VAR 0 1
68383: PPUSH
68384: CALL_OW 263
68388: PUSH
68389: LD_INT 2
68391: EQUAL
68392: NOT
68393: OR
68394: IFFALSE 68398
// exit ;
68396: GO 68714
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
68398: LD_ADDR_VAR 0 6
68402: PUSH
68403: LD_INT 22
68405: PUSH
68406: LD_VAR 0 1
68410: PPUSH
68411: CALL_OW 255
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 2
68422: PUSH
68423: LD_INT 30
68425: PUSH
68426: LD_INT 36
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 34
68435: PUSH
68436: LD_INT 31
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: LIST
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PPUSH
68452: CALL_OW 69
68456: ST_TO_ADDR
// if not tmp then
68457: LD_VAR 0 6
68461: NOT
68462: IFFALSE 68466
// exit ;
68464: GO 68714
// result := [ ] ;
68466: LD_ADDR_VAR 0 2
68470: PUSH
68471: EMPTY
68472: ST_TO_ADDR
// for i in tmp do
68473: LD_ADDR_VAR 0 3
68477: PUSH
68478: LD_VAR 0 6
68482: PUSH
68483: FOR_IN
68484: IFFALSE 68555
// begin t := UnitsInside ( i ) ;
68486: LD_ADDR_VAR 0 4
68490: PUSH
68491: LD_VAR 0 3
68495: PPUSH
68496: CALL_OW 313
68500: ST_TO_ADDR
// if t then
68501: LD_VAR 0 4
68505: IFFALSE 68553
// for j in t do
68507: LD_ADDR_VAR 0 7
68511: PUSH
68512: LD_VAR 0 4
68516: PUSH
68517: FOR_IN
68518: IFFALSE 68551
// result := Insert ( result , result + 1 , j ) ;
68520: LD_ADDR_VAR 0 2
68524: PUSH
68525: LD_VAR 0 2
68529: PPUSH
68530: LD_VAR 0 2
68534: PUSH
68535: LD_INT 1
68537: PLUS
68538: PPUSH
68539: LD_VAR 0 7
68543: PPUSH
68544: CALL_OW 2
68548: ST_TO_ADDR
68549: GO 68517
68551: POP
68552: POP
// end ;
68553: GO 68483
68555: POP
68556: POP
// if not result then
68557: LD_VAR 0 2
68561: NOT
68562: IFFALSE 68566
// exit ;
68564: GO 68714
// mech := result [ 1 ] ;
68566: LD_ADDR_VAR 0 5
68570: PUSH
68571: LD_VAR 0 2
68575: PUSH
68576: LD_INT 1
68578: ARRAY
68579: ST_TO_ADDR
// if result > 1 then
68580: LD_VAR 0 2
68584: PUSH
68585: LD_INT 1
68587: GREATER
68588: IFFALSE 68700
// for i = 2 to result do
68590: LD_ADDR_VAR 0 3
68594: PUSH
68595: DOUBLE
68596: LD_INT 2
68598: DEC
68599: ST_TO_ADDR
68600: LD_VAR 0 2
68604: PUSH
68605: FOR_TO
68606: IFFALSE 68698
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
68608: LD_ADDR_VAR 0 4
68612: PUSH
68613: LD_VAR 0 2
68617: PUSH
68618: LD_VAR 0 3
68622: ARRAY
68623: PPUSH
68624: LD_INT 3
68626: PPUSH
68627: CALL_OW 259
68631: PUSH
68632: LD_VAR 0 2
68636: PUSH
68637: LD_VAR 0 3
68641: ARRAY
68642: PPUSH
68643: CALL_OW 432
68647: MINUS
68648: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
68649: LD_VAR 0 4
68653: PUSH
68654: LD_VAR 0 5
68658: PPUSH
68659: LD_INT 3
68661: PPUSH
68662: CALL_OW 259
68666: PUSH
68667: LD_VAR 0 5
68671: PPUSH
68672: CALL_OW 432
68676: MINUS
68677: GREATEREQUAL
68678: IFFALSE 68696
// mech := result [ i ] ;
68680: LD_ADDR_VAR 0 5
68684: PUSH
68685: LD_VAR 0 2
68689: PUSH
68690: LD_VAR 0 3
68694: ARRAY
68695: ST_TO_ADDR
// end ;
68696: GO 68605
68698: POP
68699: POP
// ComLinkTo ( vehicle , mech ) ;
68700: LD_VAR 0 1
68704: PPUSH
68705: LD_VAR 0 5
68709: PPUSH
68710: CALL_OW 135
// end ;
68714: LD_VAR 0 2
68718: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
68719: LD_INT 0
68721: PPUSH
68722: PPUSH
68723: PPUSH
68724: PPUSH
68725: PPUSH
68726: PPUSH
68727: PPUSH
68728: PPUSH
68729: PPUSH
68730: PPUSH
68731: PPUSH
68732: PPUSH
68733: PPUSH
// result := [ ] ;
68734: LD_ADDR_VAR 0 7
68738: PUSH
68739: EMPTY
68740: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
68741: LD_VAR 0 1
68745: PPUSH
68746: CALL_OW 266
68750: PUSH
68751: LD_INT 0
68753: PUSH
68754: LD_INT 1
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: IN
68761: NOT
68762: IFFALSE 68766
// exit ;
68764: GO 70397
// if name then
68766: LD_VAR 0 3
68770: IFFALSE 68786
// SetBName ( base_dep , name ) ;
68772: LD_VAR 0 1
68776: PPUSH
68777: LD_VAR 0 3
68781: PPUSH
68782: CALL_OW 500
// base := GetBase ( base_dep ) ;
68786: LD_ADDR_VAR 0 15
68790: PUSH
68791: LD_VAR 0 1
68795: PPUSH
68796: CALL_OW 274
68800: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
68801: LD_ADDR_VAR 0 16
68805: PUSH
68806: LD_VAR 0 1
68810: PPUSH
68811: CALL_OW 255
68815: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
68816: LD_ADDR_VAR 0 17
68820: PUSH
68821: LD_VAR 0 1
68825: PPUSH
68826: CALL_OW 248
68830: ST_TO_ADDR
// if sources then
68831: LD_VAR 0 5
68835: IFFALSE 68882
// for i = 1 to 3 do
68837: LD_ADDR_VAR 0 8
68841: PUSH
68842: DOUBLE
68843: LD_INT 1
68845: DEC
68846: ST_TO_ADDR
68847: LD_INT 3
68849: PUSH
68850: FOR_TO
68851: IFFALSE 68880
// AddResourceType ( base , i , sources [ i ] ) ;
68853: LD_VAR 0 15
68857: PPUSH
68858: LD_VAR 0 8
68862: PPUSH
68863: LD_VAR 0 5
68867: PUSH
68868: LD_VAR 0 8
68872: ARRAY
68873: PPUSH
68874: CALL_OW 276
68878: GO 68850
68880: POP
68881: POP
// buildings := GetBaseBuildings ( base , area ) ;
68882: LD_ADDR_VAR 0 18
68886: PUSH
68887: LD_VAR 0 15
68891: PPUSH
68892: LD_VAR 0 2
68896: PPUSH
68897: CALL 68174 0 2
68901: ST_TO_ADDR
// InitHc ;
68902: CALL_OW 19
// InitUc ;
68906: CALL_OW 18
// uc_side := side ;
68910: LD_ADDR_OWVAR 20
68914: PUSH
68915: LD_VAR 0 16
68919: ST_TO_ADDR
// uc_nation := nation ;
68920: LD_ADDR_OWVAR 21
68924: PUSH
68925: LD_VAR 0 17
68929: ST_TO_ADDR
// if buildings then
68930: LD_VAR 0 18
68934: IFFALSE 70256
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
68936: LD_ADDR_VAR 0 19
68940: PUSH
68941: LD_VAR 0 18
68945: PPUSH
68946: LD_INT 2
68948: PUSH
68949: LD_INT 30
68951: PUSH
68952: LD_INT 29
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: PUSH
68959: LD_INT 30
68961: PUSH
68962: LD_INT 30
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: LIST
68973: PPUSH
68974: CALL_OW 72
68978: ST_TO_ADDR
// if tmp then
68979: LD_VAR 0 19
68983: IFFALSE 69031
// for i in tmp do
68985: LD_ADDR_VAR 0 8
68989: PUSH
68990: LD_VAR 0 19
68994: PUSH
68995: FOR_IN
68996: IFFALSE 69029
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
68998: LD_VAR 0 8
69002: PPUSH
69003: CALL_OW 250
69007: PPUSH
69008: LD_VAR 0 8
69012: PPUSH
69013: CALL_OW 251
69017: PPUSH
69018: LD_VAR 0 16
69022: PPUSH
69023: CALL_OW 441
69027: GO 68995
69029: POP
69030: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69031: LD_VAR 0 18
69035: PPUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 30
69041: PUSH
69042: LD_INT 32
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 30
69051: PUSH
69052: LD_INT 33
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: LIST
69063: PPUSH
69064: CALL_OW 72
69068: IFFALSE 69156
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69070: LD_ADDR_VAR 0 8
69074: PUSH
69075: LD_VAR 0 18
69079: PPUSH
69080: LD_INT 2
69082: PUSH
69083: LD_INT 30
69085: PUSH
69086: LD_INT 32
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 30
69095: PUSH
69096: LD_INT 33
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: LIST
69107: PPUSH
69108: CALL_OW 72
69112: PUSH
69113: FOR_IN
69114: IFFALSE 69154
// begin if not GetBWeapon ( i ) then
69116: LD_VAR 0 8
69120: PPUSH
69121: CALL_OW 269
69125: NOT
69126: IFFALSE 69152
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69128: LD_VAR 0 8
69132: PPUSH
69133: LD_VAR 0 8
69137: PPUSH
69138: LD_VAR 0 2
69142: PPUSH
69143: CALL 70402 0 2
69147: PPUSH
69148: CALL_OW 431
// end ;
69152: GO 69113
69154: POP
69155: POP
// end ; for i = 1 to personel do
69156: LD_ADDR_VAR 0 8
69160: PUSH
69161: DOUBLE
69162: LD_INT 1
69164: DEC
69165: ST_TO_ADDR
69166: LD_VAR 0 6
69170: PUSH
69171: FOR_TO
69172: IFFALSE 70236
// begin if i > 4 then
69174: LD_VAR 0 8
69178: PUSH
69179: LD_INT 4
69181: GREATER
69182: IFFALSE 69186
// break ;
69184: GO 70236
// case i of 1 :
69186: LD_VAR 0 8
69190: PUSH
69191: LD_INT 1
69193: DOUBLE
69194: EQUAL
69195: IFTRUE 69199
69197: GO 69279
69199: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
69200: LD_ADDR_VAR 0 12
69204: PUSH
69205: LD_VAR 0 18
69209: PPUSH
69210: LD_INT 22
69212: PUSH
69213: LD_VAR 0 16
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 58
69224: PUSH
69225: EMPTY
69226: LIST
69227: PUSH
69228: LD_INT 2
69230: PUSH
69231: LD_INT 30
69233: PUSH
69234: LD_INT 32
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 30
69243: PUSH
69244: LD_INT 4
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 30
69253: PUSH
69254: LD_INT 5
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: LIST
69271: PPUSH
69272: CALL_OW 72
69276: ST_TO_ADDR
69277: GO 69501
69279: LD_INT 2
69281: DOUBLE
69282: EQUAL
69283: IFTRUE 69287
69285: GO 69349
69287: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
69288: LD_ADDR_VAR 0 12
69292: PUSH
69293: LD_VAR 0 18
69297: PPUSH
69298: LD_INT 22
69300: PUSH
69301: LD_VAR 0 16
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 2
69312: PUSH
69313: LD_INT 30
69315: PUSH
69316: LD_INT 0
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 30
69325: PUSH
69326: LD_INT 1
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: LIST
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PPUSH
69342: CALL_OW 72
69346: ST_TO_ADDR
69347: GO 69501
69349: LD_INT 3
69351: DOUBLE
69352: EQUAL
69353: IFTRUE 69357
69355: GO 69419
69357: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
69358: LD_ADDR_VAR 0 12
69362: PUSH
69363: LD_VAR 0 18
69367: PPUSH
69368: LD_INT 22
69370: PUSH
69371: LD_VAR 0 16
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 2
69382: PUSH
69383: LD_INT 30
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 30
69395: PUSH
69396: LD_INT 3
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: LIST
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PPUSH
69412: CALL_OW 72
69416: ST_TO_ADDR
69417: GO 69501
69419: LD_INT 4
69421: DOUBLE
69422: EQUAL
69423: IFTRUE 69427
69425: GO 69500
69427: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
69428: LD_ADDR_VAR 0 12
69432: PUSH
69433: LD_VAR 0 18
69437: PPUSH
69438: LD_INT 22
69440: PUSH
69441: LD_VAR 0 16
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 2
69452: PUSH
69453: LD_INT 30
69455: PUSH
69456: LD_INT 6
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 30
69465: PUSH
69466: LD_INT 7
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 30
69475: PUSH
69476: LD_INT 8
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PPUSH
69493: CALL_OW 72
69497: ST_TO_ADDR
69498: GO 69501
69500: POP
// if i = 1 then
69501: LD_VAR 0 8
69505: PUSH
69506: LD_INT 1
69508: EQUAL
69509: IFFALSE 69620
// begin tmp := [ ] ;
69511: LD_ADDR_VAR 0 19
69515: PUSH
69516: EMPTY
69517: ST_TO_ADDR
// for j in f do
69518: LD_ADDR_VAR 0 9
69522: PUSH
69523: LD_VAR 0 12
69527: PUSH
69528: FOR_IN
69529: IFFALSE 69602
// if GetBType ( j ) = b_bunker then
69531: LD_VAR 0 9
69535: PPUSH
69536: CALL_OW 266
69540: PUSH
69541: LD_INT 32
69543: EQUAL
69544: IFFALSE 69571
// tmp := Insert ( tmp , 1 , j ) else
69546: LD_ADDR_VAR 0 19
69550: PUSH
69551: LD_VAR 0 19
69555: PPUSH
69556: LD_INT 1
69558: PPUSH
69559: LD_VAR 0 9
69563: PPUSH
69564: CALL_OW 2
69568: ST_TO_ADDR
69569: GO 69600
// tmp := Insert ( tmp , tmp + 1 , j ) ;
69571: LD_ADDR_VAR 0 19
69575: PUSH
69576: LD_VAR 0 19
69580: PPUSH
69581: LD_VAR 0 19
69585: PUSH
69586: LD_INT 1
69588: PLUS
69589: PPUSH
69590: LD_VAR 0 9
69594: PPUSH
69595: CALL_OW 2
69599: ST_TO_ADDR
69600: GO 69528
69602: POP
69603: POP
// if tmp then
69604: LD_VAR 0 19
69608: IFFALSE 69620
// f := tmp ;
69610: LD_ADDR_VAR 0 12
69614: PUSH
69615: LD_VAR 0 19
69619: ST_TO_ADDR
// end ; x := personel [ i ] ;
69620: LD_ADDR_VAR 0 13
69624: PUSH
69625: LD_VAR 0 6
69629: PUSH
69630: LD_VAR 0 8
69634: ARRAY
69635: ST_TO_ADDR
// if x = - 1 then
69636: LD_VAR 0 13
69640: PUSH
69641: LD_INT 1
69643: NEG
69644: EQUAL
69645: IFFALSE 69854
// begin for j in f do
69647: LD_ADDR_VAR 0 9
69651: PUSH
69652: LD_VAR 0 12
69656: PUSH
69657: FOR_IN
69658: IFFALSE 69850
// repeat InitHc ;
69660: CALL_OW 19
// if GetBType ( j ) = b_barracks then
69664: LD_VAR 0 9
69668: PPUSH
69669: CALL_OW 266
69673: PUSH
69674: LD_INT 5
69676: EQUAL
69677: IFFALSE 69747
// begin if UnitsInside ( j ) < 3 then
69679: LD_VAR 0 9
69683: PPUSH
69684: CALL_OW 313
69688: PUSH
69689: LD_INT 3
69691: LESS
69692: IFFALSE 69728
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
69694: LD_INT 0
69696: PPUSH
69697: LD_INT 5
69699: PUSH
69700: LD_INT 8
69702: PUSH
69703: LD_INT 9
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: LIST
69710: PUSH
69711: LD_VAR 0 17
69715: ARRAY
69716: PPUSH
69717: LD_VAR 0 4
69721: PPUSH
69722: CALL_OW 380
69726: GO 69745
// PrepareHuman ( false , i , skill ) ;
69728: LD_INT 0
69730: PPUSH
69731: LD_VAR 0 8
69735: PPUSH
69736: LD_VAR 0 4
69740: PPUSH
69741: CALL_OW 380
// end else
69745: GO 69764
// PrepareHuman ( false , i , skill ) ;
69747: LD_INT 0
69749: PPUSH
69750: LD_VAR 0 8
69754: PPUSH
69755: LD_VAR 0 4
69759: PPUSH
69760: CALL_OW 380
// un := CreateHuman ;
69764: LD_ADDR_VAR 0 14
69768: PUSH
69769: CALL_OW 44
69773: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69774: LD_ADDR_VAR 0 7
69778: PUSH
69779: LD_VAR 0 7
69783: PPUSH
69784: LD_INT 1
69786: PPUSH
69787: LD_VAR 0 14
69791: PPUSH
69792: CALL_OW 2
69796: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
69797: LD_VAR 0 14
69801: PPUSH
69802: LD_VAR 0 9
69806: PPUSH
69807: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
69811: LD_VAR 0 9
69815: PPUSH
69816: CALL_OW 313
69820: PUSH
69821: LD_INT 6
69823: EQUAL
69824: PUSH
69825: LD_VAR 0 9
69829: PPUSH
69830: CALL_OW 266
69834: PUSH
69835: LD_INT 32
69837: PUSH
69838: LD_INT 31
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: IN
69845: OR
69846: IFFALSE 69660
69848: GO 69657
69850: POP
69851: POP
// end else
69852: GO 70234
// for j = 1 to x do
69854: LD_ADDR_VAR 0 9
69858: PUSH
69859: DOUBLE
69860: LD_INT 1
69862: DEC
69863: ST_TO_ADDR
69864: LD_VAR 0 13
69868: PUSH
69869: FOR_TO
69870: IFFALSE 70232
// begin InitHc ;
69872: CALL_OW 19
// if not f then
69876: LD_VAR 0 12
69880: NOT
69881: IFFALSE 69970
// begin PrepareHuman ( false , i , skill ) ;
69883: LD_INT 0
69885: PPUSH
69886: LD_VAR 0 8
69890: PPUSH
69891: LD_VAR 0 4
69895: PPUSH
69896: CALL_OW 380
// un := CreateHuman ;
69900: LD_ADDR_VAR 0 14
69904: PUSH
69905: CALL_OW 44
69909: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69910: LD_ADDR_VAR 0 7
69914: PUSH
69915: LD_VAR 0 7
69919: PPUSH
69920: LD_INT 1
69922: PPUSH
69923: LD_VAR 0 14
69927: PPUSH
69928: CALL_OW 2
69932: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
69933: LD_VAR 0 14
69937: PPUSH
69938: LD_VAR 0 1
69942: PPUSH
69943: CALL_OW 250
69947: PPUSH
69948: LD_VAR 0 1
69952: PPUSH
69953: CALL_OW 251
69957: PPUSH
69958: LD_INT 10
69960: PPUSH
69961: LD_INT 0
69963: PPUSH
69964: CALL_OW 50
// continue ;
69968: GO 69869
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
69970: LD_VAR 0 12
69974: PUSH
69975: LD_INT 1
69977: ARRAY
69978: PPUSH
69979: CALL_OW 313
69983: PUSH
69984: LD_VAR 0 12
69988: PUSH
69989: LD_INT 1
69991: ARRAY
69992: PPUSH
69993: CALL_OW 266
69997: PUSH
69998: LD_INT 32
70000: PUSH
70001: LD_INT 31
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: IN
70008: AND
70009: PUSH
70010: LD_VAR 0 12
70014: PUSH
70015: LD_INT 1
70017: ARRAY
70018: PPUSH
70019: CALL_OW 313
70023: PUSH
70024: LD_INT 6
70026: EQUAL
70027: OR
70028: IFFALSE 70048
// f := Delete ( f , 1 ) ;
70030: LD_ADDR_VAR 0 12
70034: PUSH
70035: LD_VAR 0 12
70039: PPUSH
70040: LD_INT 1
70042: PPUSH
70043: CALL_OW 3
70047: ST_TO_ADDR
// if not f then
70048: LD_VAR 0 12
70052: NOT
70053: IFFALSE 70071
// begin x := x + 2 ;
70055: LD_ADDR_VAR 0 13
70059: PUSH
70060: LD_VAR 0 13
70064: PUSH
70065: LD_INT 2
70067: PLUS
70068: ST_TO_ADDR
// continue ;
70069: GO 69869
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70071: LD_VAR 0 12
70075: PUSH
70076: LD_INT 1
70078: ARRAY
70079: PPUSH
70080: CALL_OW 266
70084: PUSH
70085: LD_INT 5
70087: EQUAL
70088: IFFALSE 70162
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70090: LD_VAR 0 12
70094: PUSH
70095: LD_INT 1
70097: ARRAY
70098: PPUSH
70099: CALL_OW 313
70103: PUSH
70104: LD_INT 3
70106: LESS
70107: IFFALSE 70143
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70109: LD_INT 0
70111: PPUSH
70112: LD_INT 5
70114: PUSH
70115: LD_INT 8
70117: PUSH
70118: LD_INT 9
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: LIST
70125: PUSH
70126: LD_VAR 0 17
70130: ARRAY
70131: PPUSH
70132: LD_VAR 0 4
70136: PPUSH
70137: CALL_OW 380
70141: GO 70160
// PrepareHuman ( false , i , skill ) ;
70143: LD_INT 0
70145: PPUSH
70146: LD_VAR 0 8
70150: PPUSH
70151: LD_VAR 0 4
70155: PPUSH
70156: CALL_OW 380
// end else
70160: GO 70179
// PrepareHuman ( false , i , skill ) ;
70162: LD_INT 0
70164: PPUSH
70165: LD_VAR 0 8
70169: PPUSH
70170: LD_VAR 0 4
70174: PPUSH
70175: CALL_OW 380
// un := CreateHuman ;
70179: LD_ADDR_VAR 0 14
70183: PUSH
70184: CALL_OW 44
70188: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70189: LD_ADDR_VAR 0 7
70193: PUSH
70194: LD_VAR 0 7
70198: PPUSH
70199: LD_INT 1
70201: PPUSH
70202: LD_VAR 0 14
70206: PPUSH
70207: CALL_OW 2
70211: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
70212: LD_VAR 0 14
70216: PPUSH
70217: LD_VAR 0 12
70221: PUSH
70222: LD_INT 1
70224: ARRAY
70225: PPUSH
70226: CALL_OW 52
// end ;
70230: GO 69869
70232: POP
70233: POP
// end ;
70234: GO 69171
70236: POP
70237: POP
// result := result ^ buildings ;
70238: LD_ADDR_VAR 0 7
70242: PUSH
70243: LD_VAR 0 7
70247: PUSH
70248: LD_VAR 0 18
70252: ADD
70253: ST_TO_ADDR
// end else
70254: GO 70397
// begin for i = 1 to personel do
70256: LD_ADDR_VAR 0 8
70260: PUSH
70261: DOUBLE
70262: LD_INT 1
70264: DEC
70265: ST_TO_ADDR
70266: LD_VAR 0 6
70270: PUSH
70271: FOR_TO
70272: IFFALSE 70395
// begin if i > 4 then
70274: LD_VAR 0 8
70278: PUSH
70279: LD_INT 4
70281: GREATER
70282: IFFALSE 70286
// break ;
70284: GO 70395
// x := personel [ i ] ;
70286: LD_ADDR_VAR 0 13
70290: PUSH
70291: LD_VAR 0 6
70295: PUSH
70296: LD_VAR 0 8
70300: ARRAY
70301: ST_TO_ADDR
// if x = - 1 then
70302: LD_VAR 0 13
70306: PUSH
70307: LD_INT 1
70309: NEG
70310: EQUAL
70311: IFFALSE 70315
// continue ;
70313: GO 70271
// PrepareHuman ( false , i , skill ) ;
70315: LD_INT 0
70317: PPUSH
70318: LD_VAR 0 8
70322: PPUSH
70323: LD_VAR 0 4
70327: PPUSH
70328: CALL_OW 380
// un := CreateHuman ;
70332: LD_ADDR_VAR 0 14
70336: PUSH
70337: CALL_OW 44
70341: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70342: LD_VAR 0 14
70346: PPUSH
70347: LD_VAR 0 1
70351: PPUSH
70352: CALL_OW 250
70356: PPUSH
70357: LD_VAR 0 1
70361: PPUSH
70362: CALL_OW 251
70366: PPUSH
70367: LD_INT 10
70369: PPUSH
70370: LD_INT 0
70372: PPUSH
70373: CALL_OW 50
// result := result ^ un ;
70377: LD_ADDR_VAR 0 7
70381: PUSH
70382: LD_VAR 0 7
70386: PUSH
70387: LD_VAR 0 14
70391: ADD
70392: ST_TO_ADDR
// end ;
70393: GO 70271
70395: POP
70396: POP
// end ; end ;
70397: LD_VAR 0 7
70401: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
70402: LD_INT 0
70404: PPUSH
70405: PPUSH
70406: PPUSH
70407: PPUSH
70408: PPUSH
70409: PPUSH
70410: PPUSH
70411: PPUSH
70412: PPUSH
70413: PPUSH
70414: PPUSH
70415: PPUSH
70416: PPUSH
70417: PPUSH
70418: PPUSH
70419: PPUSH
// result := false ;
70420: LD_ADDR_VAR 0 3
70424: PUSH
70425: LD_INT 0
70427: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
70428: LD_VAR 0 1
70432: NOT
70433: PUSH
70434: LD_VAR 0 1
70438: PPUSH
70439: CALL_OW 266
70443: PUSH
70444: LD_INT 32
70446: PUSH
70447: LD_INT 33
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: IN
70454: NOT
70455: OR
70456: IFFALSE 70460
// exit ;
70458: GO 71596
// nat := GetNation ( tower ) ;
70460: LD_ADDR_VAR 0 12
70464: PUSH
70465: LD_VAR 0 1
70469: PPUSH
70470: CALL_OW 248
70474: ST_TO_ADDR
// side := GetSide ( tower ) ;
70475: LD_ADDR_VAR 0 16
70479: PUSH
70480: LD_VAR 0 1
70484: PPUSH
70485: CALL_OW 255
70489: ST_TO_ADDR
// x := GetX ( tower ) ;
70490: LD_ADDR_VAR 0 10
70494: PUSH
70495: LD_VAR 0 1
70499: PPUSH
70500: CALL_OW 250
70504: ST_TO_ADDR
// y := GetY ( tower ) ;
70505: LD_ADDR_VAR 0 11
70509: PUSH
70510: LD_VAR 0 1
70514: PPUSH
70515: CALL_OW 251
70519: ST_TO_ADDR
// if not x or not y then
70520: LD_VAR 0 10
70524: NOT
70525: PUSH
70526: LD_VAR 0 11
70530: NOT
70531: OR
70532: IFFALSE 70536
// exit ;
70534: GO 71596
// weapon := 0 ;
70536: LD_ADDR_VAR 0 18
70540: PUSH
70541: LD_INT 0
70543: ST_TO_ADDR
// fac_list := [ ] ;
70544: LD_ADDR_VAR 0 17
70548: PUSH
70549: EMPTY
70550: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
70551: LD_ADDR_VAR 0 6
70555: PUSH
70556: LD_VAR 0 1
70560: PPUSH
70561: CALL_OW 274
70565: PPUSH
70566: LD_VAR 0 2
70570: PPUSH
70571: CALL 68174 0 2
70575: PPUSH
70576: LD_INT 30
70578: PUSH
70579: LD_INT 3
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PPUSH
70586: CALL_OW 72
70590: ST_TO_ADDR
// if not factories then
70591: LD_VAR 0 6
70595: NOT
70596: IFFALSE 70600
// exit ;
70598: GO 71596
// for i in factories do
70600: LD_ADDR_VAR 0 8
70604: PUSH
70605: LD_VAR 0 6
70609: PUSH
70610: FOR_IN
70611: IFFALSE 70636
// fac_list := fac_list union AvailableWeaponList ( i ) ;
70613: LD_ADDR_VAR 0 17
70617: PUSH
70618: LD_VAR 0 17
70622: PUSH
70623: LD_VAR 0 8
70627: PPUSH
70628: CALL_OW 478
70632: UNION
70633: ST_TO_ADDR
70634: GO 70610
70636: POP
70637: POP
// if not fac_list then
70638: LD_VAR 0 17
70642: NOT
70643: IFFALSE 70647
// exit ;
70645: GO 71596
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
70647: LD_ADDR_VAR 0 5
70651: PUSH
70652: LD_INT 4
70654: PUSH
70655: LD_INT 5
70657: PUSH
70658: LD_INT 9
70660: PUSH
70661: LD_INT 10
70663: PUSH
70664: LD_INT 6
70666: PUSH
70667: LD_INT 7
70669: PUSH
70670: LD_INT 11
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 27
70684: PUSH
70685: LD_INT 28
70687: PUSH
70688: LD_INT 26
70690: PUSH
70691: LD_INT 30
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 43
70702: PUSH
70703: LD_INT 44
70705: PUSH
70706: LD_INT 46
70708: PUSH
70709: LD_INT 45
70711: PUSH
70712: LD_INT 47
70714: PUSH
70715: LD_INT 49
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: LIST
70730: PUSH
70731: LD_VAR 0 12
70735: ARRAY
70736: ST_TO_ADDR
// for i in list do
70737: LD_ADDR_VAR 0 8
70741: PUSH
70742: LD_VAR 0 5
70746: PUSH
70747: FOR_IN
70748: IFFALSE 70781
// if not i in fac_list then
70750: LD_VAR 0 8
70754: PUSH
70755: LD_VAR 0 17
70759: IN
70760: NOT
70761: IFFALSE 70779
// list := list diff i ;
70763: LD_ADDR_VAR 0 5
70767: PUSH
70768: LD_VAR 0 5
70772: PUSH
70773: LD_VAR 0 8
70777: DIFF
70778: ST_TO_ADDR
70779: GO 70747
70781: POP
70782: POP
// if not list then
70783: LD_VAR 0 5
70787: NOT
70788: IFFALSE 70792
// exit ;
70790: GO 71596
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
70792: LD_VAR 0 12
70796: PUSH
70797: LD_INT 3
70799: EQUAL
70800: PUSH
70801: LD_INT 49
70803: PUSH
70804: LD_VAR 0 5
70808: IN
70809: AND
70810: PUSH
70811: LD_INT 31
70813: PPUSH
70814: LD_VAR 0 16
70818: PPUSH
70819: CALL_OW 321
70823: PUSH
70824: LD_INT 2
70826: EQUAL
70827: AND
70828: IFFALSE 70888
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
70830: LD_INT 22
70832: PUSH
70833: LD_VAR 0 16
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 35
70844: PUSH
70845: LD_INT 49
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 91
70854: PUSH
70855: LD_VAR 0 1
70859: PUSH
70860: LD_INT 10
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: LIST
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: LIST
70872: PPUSH
70873: CALL_OW 69
70877: NOT
70878: IFFALSE 70888
// weapon := ru_time_lapser ;
70880: LD_ADDR_VAR 0 18
70884: PUSH
70885: LD_INT 49
70887: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
70888: LD_VAR 0 12
70892: PUSH
70893: LD_INT 1
70895: PUSH
70896: LD_INT 2
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: IN
70903: PUSH
70904: LD_INT 11
70906: PUSH
70907: LD_VAR 0 5
70911: IN
70912: PUSH
70913: LD_INT 30
70915: PUSH
70916: LD_VAR 0 5
70920: IN
70921: OR
70922: AND
70923: PUSH
70924: LD_INT 6
70926: PPUSH
70927: LD_VAR 0 16
70931: PPUSH
70932: CALL_OW 321
70936: PUSH
70937: LD_INT 2
70939: EQUAL
70940: AND
70941: IFFALSE 71106
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
70943: LD_INT 22
70945: PUSH
70946: LD_VAR 0 16
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 2
70957: PUSH
70958: LD_INT 35
70960: PUSH
70961: LD_INT 11
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 35
70970: PUSH
70971: LD_INT 30
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 91
70985: PUSH
70986: LD_VAR 0 1
70990: PUSH
70991: LD_INT 18
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: LIST
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: LIST
71003: PPUSH
71004: CALL_OW 69
71008: NOT
71009: PUSH
71010: LD_INT 22
71012: PUSH
71013: LD_VAR 0 16
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 2
71024: PUSH
71025: LD_INT 30
71027: PUSH
71028: LD_INT 32
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: LD_INT 30
71037: PUSH
71038: LD_INT 33
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 91
71052: PUSH
71053: LD_VAR 0 1
71057: PUSH
71058: LD_INT 12
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: LIST
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: LIST
71070: PUSH
71071: EMPTY
71072: LIST
71073: PPUSH
71074: CALL_OW 69
71078: PUSH
71079: LD_INT 2
71081: GREATER
71082: AND
71083: IFFALSE 71106
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71085: LD_ADDR_VAR 0 18
71089: PUSH
71090: LD_INT 11
71092: PUSH
71093: LD_INT 30
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_VAR 0 12
71104: ARRAY
71105: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71106: LD_VAR 0 18
71110: NOT
71111: PUSH
71112: LD_INT 40
71114: PPUSH
71115: LD_VAR 0 16
71119: PPUSH
71120: CALL_OW 321
71124: PUSH
71125: LD_INT 2
71127: EQUAL
71128: AND
71129: PUSH
71130: LD_INT 7
71132: PUSH
71133: LD_VAR 0 5
71137: IN
71138: PUSH
71139: LD_INT 28
71141: PUSH
71142: LD_VAR 0 5
71146: IN
71147: OR
71148: PUSH
71149: LD_INT 45
71151: PUSH
71152: LD_VAR 0 5
71156: IN
71157: OR
71158: AND
71159: IFFALSE 71413
// begin hex := GetHexInfo ( x , y ) ;
71161: LD_ADDR_VAR 0 4
71165: PUSH
71166: LD_VAR 0 10
71170: PPUSH
71171: LD_VAR 0 11
71175: PPUSH
71176: CALL_OW 546
71180: ST_TO_ADDR
// if hex [ 1 ] then
71181: LD_VAR 0 4
71185: PUSH
71186: LD_INT 1
71188: ARRAY
71189: IFFALSE 71193
// exit ;
71191: GO 71596
// height := hex [ 2 ] ;
71193: LD_ADDR_VAR 0 15
71197: PUSH
71198: LD_VAR 0 4
71202: PUSH
71203: LD_INT 2
71205: ARRAY
71206: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71207: LD_ADDR_VAR 0 14
71211: PUSH
71212: LD_INT 0
71214: PUSH
71215: LD_INT 2
71217: PUSH
71218: LD_INT 3
71220: PUSH
71221: LD_INT 5
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: ST_TO_ADDR
// for i in tmp do
71230: LD_ADDR_VAR 0 8
71234: PUSH
71235: LD_VAR 0 14
71239: PUSH
71240: FOR_IN
71241: IFFALSE 71411
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
71243: LD_ADDR_VAR 0 9
71247: PUSH
71248: LD_VAR 0 10
71252: PPUSH
71253: LD_VAR 0 8
71257: PPUSH
71258: LD_INT 5
71260: PPUSH
71261: CALL_OW 272
71265: PUSH
71266: LD_VAR 0 11
71270: PPUSH
71271: LD_VAR 0 8
71275: PPUSH
71276: LD_INT 5
71278: PPUSH
71279: CALL_OW 273
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
71288: LD_VAR 0 9
71292: PUSH
71293: LD_INT 1
71295: ARRAY
71296: PPUSH
71297: LD_VAR 0 9
71301: PUSH
71302: LD_INT 2
71304: ARRAY
71305: PPUSH
71306: CALL_OW 488
71310: IFFALSE 71409
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
71312: LD_ADDR_VAR 0 4
71316: PUSH
71317: LD_VAR 0 9
71321: PUSH
71322: LD_INT 1
71324: ARRAY
71325: PPUSH
71326: LD_VAR 0 9
71330: PUSH
71331: LD_INT 2
71333: ARRAY
71334: PPUSH
71335: CALL_OW 546
71339: ST_TO_ADDR
// if hex [ 1 ] then
71340: LD_VAR 0 4
71344: PUSH
71345: LD_INT 1
71347: ARRAY
71348: IFFALSE 71352
// continue ;
71350: GO 71240
// h := hex [ 2 ] ;
71352: LD_ADDR_VAR 0 13
71356: PUSH
71357: LD_VAR 0 4
71361: PUSH
71362: LD_INT 2
71364: ARRAY
71365: ST_TO_ADDR
// if h + 7 < height then
71366: LD_VAR 0 13
71370: PUSH
71371: LD_INT 7
71373: PLUS
71374: PUSH
71375: LD_VAR 0 15
71379: LESS
71380: IFFALSE 71409
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
71382: LD_ADDR_VAR 0 18
71386: PUSH
71387: LD_INT 7
71389: PUSH
71390: LD_INT 28
71392: PUSH
71393: LD_INT 45
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: LIST
71400: PUSH
71401: LD_VAR 0 12
71405: ARRAY
71406: ST_TO_ADDR
// break ;
71407: GO 71411
// end ; end ; end ;
71409: GO 71240
71411: POP
71412: POP
// end ; if not weapon then
71413: LD_VAR 0 18
71417: NOT
71418: IFFALSE 71478
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
71420: LD_ADDR_VAR 0 5
71424: PUSH
71425: LD_VAR 0 5
71429: PUSH
71430: LD_INT 11
71432: PUSH
71433: LD_INT 30
71435: PUSH
71436: LD_INT 49
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: LIST
71443: DIFF
71444: ST_TO_ADDR
// if not list then
71445: LD_VAR 0 5
71449: NOT
71450: IFFALSE 71454
// exit ;
71452: GO 71596
// weapon := list [ rand ( 1 , list ) ] ;
71454: LD_ADDR_VAR 0 18
71458: PUSH
71459: LD_VAR 0 5
71463: PUSH
71464: LD_INT 1
71466: PPUSH
71467: LD_VAR 0 5
71471: PPUSH
71472: CALL_OW 12
71476: ARRAY
71477: ST_TO_ADDR
// end ; if weapon then
71478: LD_VAR 0 18
71482: IFFALSE 71596
// begin tmp := CostOfWeapon ( weapon ) ;
71484: LD_ADDR_VAR 0 14
71488: PUSH
71489: LD_VAR 0 18
71493: PPUSH
71494: CALL_OW 451
71498: ST_TO_ADDR
// j := GetBase ( tower ) ;
71499: LD_ADDR_VAR 0 9
71503: PUSH
71504: LD_VAR 0 1
71508: PPUSH
71509: CALL_OW 274
71513: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
71514: LD_VAR 0 9
71518: PPUSH
71519: LD_INT 1
71521: PPUSH
71522: CALL_OW 275
71526: PUSH
71527: LD_VAR 0 14
71531: PUSH
71532: LD_INT 1
71534: ARRAY
71535: GREATEREQUAL
71536: PUSH
71537: LD_VAR 0 9
71541: PPUSH
71542: LD_INT 2
71544: PPUSH
71545: CALL_OW 275
71549: PUSH
71550: LD_VAR 0 14
71554: PUSH
71555: LD_INT 2
71557: ARRAY
71558: GREATEREQUAL
71559: AND
71560: PUSH
71561: LD_VAR 0 9
71565: PPUSH
71566: LD_INT 3
71568: PPUSH
71569: CALL_OW 275
71573: PUSH
71574: LD_VAR 0 14
71578: PUSH
71579: LD_INT 3
71581: ARRAY
71582: GREATEREQUAL
71583: AND
71584: IFFALSE 71596
// result := weapon ;
71586: LD_ADDR_VAR 0 3
71590: PUSH
71591: LD_VAR 0 18
71595: ST_TO_ADDR
// end ; end ;
71596: LD_VAR 0 3
71600: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
71601: LD_INT 0
71603: PPUSH
71604: PPUSH
// result := true ;
71605: LD_ADDR_VAR 0 3
71609: PUSH
71610: LD_INT 1
71612: ST_TO_ADDR
// if array1 = array2 then
71613: LD_VAR 0 1
71617: PUSH
71618: LD_VAR 0 2
71622: EQUAL
71623: IFFALSE 71683
// begin for i = 1 to array1 do
71625: LD_ADDR_VAR 0 4
71629: PUSH
71630: DOUBLE
71631: LD_INT 1
71633: DEC
71634: ST_TO_ADDR
71635: LD_VAR 0 1
71639: PUSH
71640: FOR_TO
71641: IFFALSE 71679
// if array1 [ i ] <> array2 [ i ] then
71643: LD_VAR 0 1
71647: PUSH
71648: LD_VAR 0 4
71652: ARRAY
71653: PUSH
71654: LD_VAR 0 2
71658: PUSH
71659: LD_VAR 0 4
71663: ARRAY
71664: NONEQUAL
71665: IFFALSE 71677
// begin result := false ;
71667: LD_ADDR_VAR 0 3
71671: PUSH
71672: LD_INT 0
71674: ST_TO_ADDR
// break ;
71675: GO 71679
// end ;
71677: GO 71640
71679: POP
71680: POP
// end else
71681: GO 71691
// result := false ;
71683: LD_ADDR_VAR 0 3
71687: PUSH
71688: LD_INT 0
71690: ST_TO_ADDR
// end ;
71691: LD_VAR 0 3
71695: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
71696: LD_INT 0
71698: PPUSH
71699: PPUSH
71700: PPUSH
// pom := GetBase ( fac ) ;
71701: LD_ADDR_VAR 0 5
71705: PUSH
71706: LD_VAR 0 1
71710: PPUSH
71711: CALL_OW 274
71715: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
71716: LD_ADDR_VAR 0 4
71720: PUSH
71721: LD_VAR 0 2
71725: PUSH
71726: LD_INT 1
71728: ARRAY
71729: PPUSH
71730: LD_VAR 0 2
71734: PUSH
71735: LD_INT 2
71737: ARRAY
71738: PPUSH
71739: LD_VAR 0 2
71743: PUSH
71744: LD_INT 3
71746: ARRAY
71747: PPUSH
71748: LD_VAR 0 2
71752: PUSH
71753: LD_INT 4
71755: ARRAY
71756: PPUSH
71757: CALL_OW 449
71761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
71762: LD_ADDR_VAR 0 3
71766: PUSH
71767: LD_VAR 0 5
71771: PPUSH
71772: LD_INT 1
71774: PPUSH
71775: CALL_OW 275
71779: PUSH
71780: LD_VAR 0 4
71784: PUSH
71785: LD_INT 1
71787: ARRAY
71788: GREATEREQUAL
71789: PUSH
71790: LD_VAR 0 5
71794: PPUSH
71795: LD_INT 2
71797: PPUSH
71798: CALL_OW 275
71802: PUSH
71803: LD_VAR 0 4
71807: PUSH
71808: LD_INT 2
71810: ARRAY
71811: GREATEREQUAL
71812: AND
71813: PUSH
71814: LD_VAR 0 5
71818: PPUSH
71819: LD_INT 3
71821: PPUSH
71822: CALL_OW 275
71826: PUSH
71827: LD_VAR 0 4
71831: PUSH
71832: LD_INT 3
71834: ARRAY
71835: GREATEREQUAL
71836: AND
71837: ST_TO_ADDR
// end ;
71838: LD_VAR 0 3
71842: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
71843: LD_INT 0
71845: PPUSH
71846: PPUSH
71847: PPUSH
71848: PPUSH
// pom := GetBase ( building ) ;
71849: LD_ADDR_VAR 0 3
71853: PUSH
71854: LD_VAR 0 1
71858: PPUSH
71859: CALL_OW 274
71863: ST_TO_ADDR
// if not pom then
71864: LD_VAR 0 3
71868: NOT
71869: IFFALSE 71873
// exit ;
71871: GO 72043
// btype := GetBType ( building ) ;
71873: LD_ADDR_VAR 0 5
71877: PUSH
71878: LD_VAR 0 1
71882: PPUSH
71883: CALL_OW 266
71887: ST_TO_ADDR
// if btype = b_armoury then
71888: LD_VAR 0 5
71892: PUSH
71893: LD_INT 4
71895: EQUAL
71896: IFFALSE 71906
// btype := b_barracks ;
71898: LD_ADDR_VAR 0 5
71902: PUSH
71903: LD_INT 5
71905: ST_TO_ADDR
// if btype = b_depot then
71906: LD_VAR 0 5
71910: PUSH
71911: LD_INT 0
71913: EQUAL
71914: IFFALSE 71924
// btype := b_warehouse ;
71916: LD_ADDR_VAR 0 5
71920: PUSH
71921: LD_INT 1
71923: ST_TO_ADDR
// if btype = b_workshop then
71924: LD_VAR 0 5
71928: PUSH
71929: LD_INT 2
71931: EQUAL
71932: IFFALSE 71942
// btype := b_factory ;
71934: LD_ADDR_VAR 0 5
71938: PUSH
71939: LD_INT 3
71941: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
71942: LD_ADDR_VAR 0 4
71946: PUSH
71947: LD_VAR 0 5
71951: PPUSH
71952: LD_VAR 0 1
71956: PPUSH
71957: CALL_OW 248
71961: PPUSH
71962: CALL_OW 450
71966: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
71967: LD_ADDR_VAR 0 2
71971: PUSH
71972: LD_VAR 0 3
71976: PPUSH
71977: LD_INT 1
71979: PPUSH
71980: CALL_OW 275
71984: PUSH
71985: LD_VAR 0 4
71989: PUSH
71990: LD_INT 1
71992: ARRAY
71993: GREATEREQUAL
71994: PUSH
71995: LD_VAR 0 3
71999: PPUSH
72000: LD_INT 2
72002: PPUSH
72003: CALL_OW 275
72007: PUSH
72008: LD_VAR 0 4
72012: PUSH
72013: LD_INT 2
72015: ARRAY
72016: GREATEREQUAL
72017: AND
72018: PUSH
72019: LD_VAR 0 3
72023: PPUSH
72024: LD_INT 3
72026: PPUSH
72027: CALL_OW 275
72031: PUSH
72032: LD_VAR 0 4
72036: PUSH
72037: LD_INT 3
72039: ARRAY
72040: GREATEREQUAL
72041: AND
72042: ST_TO_ADDR
// end ;
72043: LD_VAR 0 2
72047: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72048: LD_INT 0
72050: PPUSH
72051: PPUSH
72052: PPUSH
// pom := GetBase ( building ) ;
72053: LD_ADDR_VAR 0 4
72057: PUSH
72058: LD_VAR 0 1
72062: PPUSH
72063: CALL_OW 274
72067: ST_TO_ADDR
// if not pom then
72068: LD_VAR 0 4
72072: NOT
72073: IFFALSE 72077
// exit ;
72075: GO 72178
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72077: LD_ADDR_VAR 0 5
72081: PUSH
72082: LD_VAR 0 2
72086: PPUSH
72087: LD_VAR 0 1
72091: PPUSH
72092: CALL_OW 248
72096: PPUSH
72097: CALL_OW 450
72101: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72102: LD_ADDR_VAR 0 3
72106: PUSH
72107: LD_VAR 0 4
72111: PPUSH
72112: LD_INT 1
72114: PPUSH
72115: CALL_OW 275
72119: PUSH
72120: LD_VAR 0 5
72124: PUSH
72125: LD_INT 1
72127: ARRAY
72128: GREATEREQUAL
72129: PUSH
72130: LD_VAR 0 4
72134: PPUSH
72135: LD_INT 2
72137: PPUSH
72138: CALL_OW 275
72142: PUSH
72143: LD_VAR 0 5
72147: PUSH
72148: LD_INT 2
72150: ARRAY
72151: GREATEREQUAL
72152: AND
72153: PUSH
72154: LD_VAR 0 4
72158: PPUSH
72159: LD_INT 3
72161: PPUSH
72162: CALL_OW 275
72166: PUSH
72167: LD_VAR 0 5
72171: PUSH
72172: LD_INT 3
72174: ARRAY
72175: GREATEREQUAL
72176: AND
72177: ST_TO_ADDR
// end ;
72178: LD_VAR 0 3
72182: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
72183: LD_INT 0
72185: PPUSH
72186: PPUSH
72187: PPUSH
72188: PPUSH
72189: PPUSH
72190: PPUSH
72191: PPUSH
72192: PPUSH
72193: PPUSH
72194: PPUSH
// result := false ;
72195: LD_ADDR_VAR 0 6
72199: PUSH
72200: LD_INT 0
72202: ST_TO_ADDR
// if not base or not btype or not x or not y then
72203: LD_VAR 0 1
72207: NOT
72208: PUSH
72209: LD_VAR 0 2
72213: NOT
72214: OR
72215: PUSH
72216: LD_VAR 0 3
72220: NOT
72221: OR
72222: PUSH
72223: LD_VAR 0 4
72227: NOT
72228: OR
72229: IFFALSE 72233
// exit ;
72231: GO 72842
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
72233: LD_ADDR_VAR 0 12
72237: PUSH
72238: LD_VAR 0 2
72242: PPUSH
72243: LD_VAR 0 3
72247: PPUSH
72248: LD_VAR 0 4
72252: PPUSH
72253: LD_VAR 0 5
72257: PPUSH
72258: LD_VAR 0 1
72262: PUSH
72263: LD_INT 1
72265: ARRAY
72266: PPUSH
72267: CALL_OW 248
72271: PPUSH
72272: LD_INT 0
72274: PPUSH
72275: CALL 73679 0 6
72279: ST_TO_ADDR
// if not hexes then
72280: LD_VAR 0 12
72284: NOT
72285: IFFALSE 72289
// exit ;
72287: GO 72842
// for i = 1 to hexes do
72289: LD_ADDR_VAR 0 7
72293: PUSH
72294: DOUBLE
72295: LD_INT 1
72297: DEC
72298: ST_TO_ADDR
72299: LD_VAR 0 12
72303: PUSH
72304: FOR_TO
72305: IFFALSE 72840
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
72307: LD_ADDR_VAR 0 11
72311: PUSH
72312: LD_VAR 0 12
72316: PUSH
72317: LD_VAR 0 7
72321: ARRAY
72322: PUSH
72323: LD_INT 1
72325: ARRAY
72326: PPUSH
72327: LD_VAR 0 12
72331: PUSH
72332: LD_VAR 0 7
72336: ARRAY
72337: PUSH
72338: LD_INT 2
72340: ARRAY
72341: PPUSH
72342: CALL_OW 428
72346: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
72347: LD_VAR 0 12
72351: PUSH
72352: LD_VAR 0 7
72356: ARRAY
72357: PUSH
72358: LD_INT 1
72360: ARRAY
72361: PPUSH
72362: LD_VAR 0 12
72366: PUSH
72367: LD_VAR 0 7
72371: ARRAY
72372: PUSH
72373: LD_INT 2
72375: ARRAY
72376: PPUSH
72377: CALL_OW 351
72381: PUSH
72382: LD_VAR 0 12
72386: PUSH
72387: LD_VAR 0 7
72391: ARRAY
72392: PUSH
72393: LD_INT 1
72395: ARRAY
72396: PPUSH
72397: LD_VAR 0 12
72401: PUSH
72402: LD_VAR 0 7
72406: ARRAY
72407: PUSH
72408: LD_INT 2
72410: ARRAY
72411: PPUSH
72412: CALL_OW 488
72416: NOT
72417: OR
72418: PUSH
72419: LD_VAR 0 11
72423: PPUSH
72424: CALL_OW 247
72428: PUSH
72429: LD_INT 3
72431: EQUAL
72432: OR
72433: IFFALSE 72439
// exit ;
72435: POP
72436: POP
72437: GO 72842
// if not tmp or not tmp in base then
72439: LD_VAR 0 11
72443: NOT
72444: PUSH
72445: LD_VAR 0 11
72449: PUSH
72450: LD_VAR 0 1
72454: IN
72455: NOT
72456: OR
72457: IFFALSE 72461
// continue ;
72459: GO 72304
// result := true ;
72461: LD_ADDR_VAR 0 6
72465: PUSH
72466: LD_INT 1
72468: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72469: LD_ADDR_VAR 0 15
72473: PUSH
72474: LD_VAR 0 1
72478: PPUSH
72479: LD_INT 22
72481: PUSH
72482: LD_VAR 0 11
72486: PPUSH
72487: CALL_OW 255
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 2
72498: PUSH
72499: LD_INT 30
72501: PUSH
72502: LD_INT 0
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 30
72511: PUSH
72512: LD_INT 1
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: LIST
72523: PUSH
72524: EMPTY
72525: LIST
72526: LIST
72527: PPUSH
72528: CALL_OW 72
72532: ST_TO_ADDR
// if dep then
72533: LD_VAR 0 15
72537: IFFALSE 72673
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
72539: LD_ADDR_VAR 0 14
72543: PUSH
72544: LD_VAR 0 15
72548: PUSH
72549: LD_INT 1
72551: ARRAY
72552: PPUSH
72553: CALL_OW 250
72557: PPUSH
72558: LD_VAR 0 15
72562: PUSH
72563: LD_INT 1
72565: ARRAY
72566: PPUSH
72567: CALL_OW 254
72571: PPUSH
72572: LD_INT 5
72574: PPUSH
72575: CALL_OW 272
72579: PUSH
72580: LD_VAR 0 15
72584: PUSH
72585: LD_INT 1
72587: ARRAY
72588: PPUSH
72589: CALL_OW 251
72593: PPUSH
72594: LD_VAR 0 15
72598: PUSH
72599: LD_INT 1
72601: ARRAY
72602: PPUSH
72603: CALL_OW 254
72607: PPUSH
72608: LD_INT 5
72610: PPUSH
72611: CALL_OW 273
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
72620: LD_VAR 0 14
72624: PUSH
72625: LD_INT 1
72627: ARRAY
72628: PPUSH
72629: LD_VAR 0 14
72633: PUSH
72634: LD_INT 2
72636: ARRAY
72637: PPUSH
72638: CALL_OW 488
72642: IFFALSE 72673
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
72644: LD_VAR 0 11
72648: PPUSH
72649: LD_VAR 0 14
72653: PUSH
72654: LD_INT 1
72656: ARRAY
72657: PPUSH
72658: LD_VAR 0 14
72662: PUSH
72663: LD_INT 2
72665: ARRAY
72666: PPUSH
72667: CALL_OW 111
// continue ;
72671: GO 72304
// end ; end ; r := GetDir ( tmp ) ;
72673: LD_ADDR_VAR 0 13
72677: PUSH
72678: LD_VAR 0 11
72682: PPUSH
72683: CALL_OW 254
72687: ST_TO_ADDR
// if r = 5 then
72688: LD_VAR 0 13
72692: PUSH
72693: LD_INT 5
72695: EQUAL
72696: IFFALSE 72706
// r := 0 ;
72698: LD_ADDR_VAR 0 13
72702: PUSH
72703: LD_INT 0
72705: ST_TO_ADDR
// for j = r to 5 do
72706: LD_ADDR_VAR 0 8
72710: PUSH
72711: DOUBLE
72712: LD_VAR 0 13
72716: DEC
72717: ST_TO_ADDR
72718: LD_INT 5
72720: PUSH
72721: FOR_TO
72722: IFFALSE 72836
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
72724: LD_ADDR_VAR 0 9
72728: PUSH
72729: LD_VAR 0 11
72733: PPUSH
72734: CALL_OW 250
72738: PPUSH
72739: LD_VAR 0 8
72743: PPUSH
72744: LD_INT 2
72746: PPUSH
72747: CALL_OW 272
72751: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
72752: LD_ADDR_VAR 0 10
72756: PUSH
72757: LD_VAR 0 11
72761: PPUSH
72762: CALL_OW 251
72766: PPUSH
72767: LD_VAR 0 8
72771: PPUSH
72772: LD_INT 2
72774: PPUSH
72775: CALL_OW 273
72779: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
72780: LD_VAR 0 9
72784: PPUSH
72785: LD_VAR 0 10
72789: PPUSH
72790: CALL_OW 488
72794: PUSH
72795: LD_VAR 0 9
72799: PPUSH
72800: LD_VAR 0 10
72804: PPUSH
72805: CALL_OW 428
72809: NOT
72810: AND
72811: IFFALSE 72834
// begin ComMoveXY ( tmp , _x , _y ) ;
72813: LD_VAR 0 11
72817: PPUSH
72818: LD_VAR 0 9
72822: PPUSH
72823: LD_VAR 0 10
72827: PPUSH
72828: CALL_OW 111
// break ;
72832: GO 72836
// end ; end ;
72834: GO 72721
72836: POP
72837: POP
// end ;
72838: GO 72304
72840: POP
72841: POP
// end ;
72842: LD_VAR 0 6
72846: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
72847: LD_INT 0
72849: PPUSH
72850: PPUSH
72851: PPUSH
72852: PPUSH
72853: PPUSH
72854: PPUSH
72855: PPUSH
72856: PPUSH
72857: PPUSH
72858: PPUSH
// result := false ;
72859: LD_ADDR_VAR 0 6
72863: PUSH
72864: LD_INT 0
72866: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
72867: LD_VAR 0 1
72871: NOT
72872: PUSH
72873: LD_VAR 0 1
72877: PPUSH
72878: CALL_OW 266
72882: PUSH
72883: LD_INT 0
72885: PUSH
72886: LD_INT 1
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: IN
72893: NOT
72894: OR
72895: PUSH
72896: LD_VAR 0 2
72900: NOT
72901: OR
72902: PUSH
72903: LD_VAR 0 5
72907: PUSH
72908: LD_INT 0
72910: PUSH
72911: LD_INT 1
72913: PUSH
72914: LD_INT 2
72916: PUSH
72917: LD_INT 3
72919: PUSH
72920: LD_INT 4
72922: PUSH
72923: LD_INT 5
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: IN
72934: NOT
72935: OR
72936: PUSH
72937: LD_VAR 0 3
72941: PPUSH
72942: LD_VAR 0 4
72946: PPUSH
72947: CALL_OW 488
72951: NOT
72952: OR
72953: IFFALSE 72957
// exit ;
72955: GO 73674
// pom := GetBase ( depot ) ;
72957: LD_ADDR_VAR 0 10
72961: PUSH
72962: LD_VAR 0 1
72966: PPUSH
72967: CALL_OW 274
72971: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
72972: LD_ADDR_VAR 0 11
72976: PUSH
72977: LD_VAR 0 2
72981: PPUSH
72982: LD_VAR 0 1
72986: PPUSH
72987: CALL_OW 248
72991: PPUSH
72992: CALL_OW 450
72996: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
72997: LD_VAR 0 10
73001: PPUSH
73002: LD_INT 1
73004: PPUSH
73005: CALL_OW 275
73009: PUSH
73010: LD_VAR 0 11
73014: PUSH
73015: LD_INT 1
73017: ARRAY
73018: GREATEREQUAL
73019: PUSH
73020: LD_VAR 0 10
73024: PPUSH
73025: LD_INT 2
73027: PPUSH
73028: CALL_OW 275
73032: PUSH
73033: LD_VAR 0 11
73037: PUSH
73038: LD_INT 2
73040: ARRAY
73041: GREATEREQUAL
73042: AND
73043: PUSH
73044: LD_VAR 0 10
73048: PPUSH
73049: LD_INT 3
73051: PPUSH
73052: CALL_OW 275
73056: PUSH
73057: LD_VAR 0 11
73061: PUSH
73062: LD_INT 3
73064: ARRAY
73065: GREATEREQUAL
73066: AND
73067: NOT
73068: IFFALSE 73072
// exit ;
73070: GO 73674
// if GetBType ( depot ) = b_depot then
73072: LD_VAR 0 1
73076: PPUSH
73077: CALL_OW 266
73081: PUSH
73082: LD_INT 0
73084: EQUAL
73085: IFFALSE 73097
// dist := 28 else
73087: LD_ADDR_VAR 0 14
73091: PUSH
73092: LD_INT 28
73094: ST_TO_ADDR
73095: GO 73105
// dist := 36 ;
73097: LD_ADDR_VAR 0 14
73101: PUSH
73102: LD_INT 36
73104: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
73105: LD_VAR 0 1
73109: PPUSH
73110: LD_VAR 0 3
73114: PPUSH
73115: LD_VAR 0 4
73119: PPUSH
73120: CALL_OW 297
73124: PUSH
73125: LD_VAR 0 14
73129: GREATER
73130: IFFALSE 73134
// exit ;
73132: GO 73674
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
73134: LD_ADDR_VAR 0 12
73138: PUSH
73139: LD_VAR 0 2
73143: PPUSH
73144: LD_VAR 0 3
73148: PPUSH
73149: LD_VAR 0 4
73153: PPUSH
73154: LD_VAR 0 5
73158: PPUSH
73159: LD_VAR 0 1
73163: PPUSH
73164: CALL_OW 248
73168: PPUSH
73169: LD_INT 0
73171: PPUSH
73172: CALL 73679 0 6
73176: ST_TO_ADDR
// if not hexes then
73177: LD_VAR 0 12
73181: NOT
73182: IFFALSE 73186
// exit ;
73184: GO 73674
// hex := GetHexInfo ( x , y ) ;
73186: LD_ADDR_VAR 0 15
73190: PUSH
73191: LD_VAR 0 3
73195: PPUSH
73196: LD_VAR 0 4
73200: PPUSH
73201: CALL_OW 546
73205: ST_TO_ADDR
// if hex [ 1 ] then
73206: LD_VAR 0 15
73210: PUSH
73211: LD_INT 1
73213: ARRAY
73214: IFFALSE 73218
// exit ;
73216: GO 73674
// height := hex [ 2 ] ;
73218: LD_ADDR_VAR 0 13
73222: PUSH
73223: LD_VAR 0 15
73227: PUSH
73228: LD_INT 2
73230: ARRAY
73231: ST_TO_ADDR
// for i = 1 to hexes do
73232: LD_ADDR_VAR 0 7
73236: PUSH
73237: DOUBLE
73238: LD_INT 1
73240: DEC
73241: ST_TO_ADDR
73242: LD_VAR 0 12
73246: PUSH
73247: FOR_TO
73248: IFFALSE 73578
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
73250: LD_VAR 0 12
73254: PUSH
73255: LD_VAR 0 7
73259: ARRAY
73260: PUSH
73261: LD_INT 1
73263: ARRAY
73264: PPUSH
73265: LD_VAR 0 12
73269: PUSH
73270: LD_VAR 0 7
73274: ARRAY
73275: PUSH
73276: LD_INT 2
73278: ARRAY
73279: PPUSH
73280: CALL_OW 488
73284: NOT
73285: PUSH
73286: LD_VAR 0 12
73290: PUSH
73291: LD_VAR 0 7
73295: ARRAY
73296: PUSH
73297: LD_INT 1
73299: ARRAY
73300: PPUSH
73301: LD_VAR 0 12
73305: PUSH
73306: LD_VAR 0 7
73310: ARRAY
73311: PUSH
73312: LD_INT 2
73314: ARRAY
73315: PPUSH
73316: CALL_OW 428
73320: PUSH
73321: LD_INT 0
73323: GREATER
73324: OR
73325: PUSH
73326: LD_VAR 0 12
73330: PUSH
73331: LD_VAR 0 7
73335: ARRAY
73336: PUSH
73337: LD_INT 1
73339: ARRAY
73340: PPUSH
73341: LD_VAR 0 12
73345: PUSH
73346: LD_VAR 0 7
73350: ARRAY
73351: PUSH
73352: LD_INT 2
73354: ARRAY
73355: PPUSH
73356: CALL_OW 351
73360: OR
73361: IFFALSE 73367
// exit ;
73363: POP
73364: POP
73365: GO 73674
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
73367: LD_ADDR_VAR 0 8
73371: PUSH
73372: LD_VAR 0 12
73376: PUSH
73377: LD_VAR 0 7
73381: ARRAY
73382: PUSH
73383: LD_INT 1
73385: ARRAY
73386: PPUSH
73387: LD_VAR 0 12
73391: PUSH
73392: LD_VAR 0 7
73396: ARRAY
73397: PUSH
73398: LD_INT 2
73400: ARRAY
73401: PPUSH
73402: CALL_OW 546
73406: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
73407: LD_VAR 0 8
73411: PUSH
73412: LD_INT 1
73414: ARRAY
73415: PUSH
73416: LD_VAR 0 8
73420: PUSH
73421: LD_INT 2
73423: ARRAY
73424: PUSH
73425: LD_VAR 0 13
73429: PUSH
73430: LD_INT 2
73432: PLUS
73433: GREATER
73434: OR
73435: PUSH
73436: LD_VAR 0 8
73440: PUSH
73441: LD_INT 2
73443: ARRAY
73444: PUSH
73445: LD_VAR 0 13
73449: PUSH
73450: LD_INT 2
73452: MINUS
73453: LESS
73454: OR
73455: PUSH
73456: LD_VAR 0 8
73460: PUSH
73461: LD_INT 3
73463: ARRAY
73464: PUSH
73465: LD_INT 0
73467: PUSH
73468: LD_INT 8
73470: PUSH
73471: LD_INT 9
73473: PUSH
73474: LD_INT 10
73476: PUSH
73477: LD_INT 11
73479: PUSH
73480: LD_INT 12
73482: PUSH
73483: LD_INT 13
73485: PUSH
73486: LD_INT 16
73488: PUSH
73489: LD_INT 17
73491: PUSH
73492: LD_INT 18
73494: PUSH
73495: LD_INT 19
73497: PUSH
73498: LD_INT 20
73500: PUSH
73501: LD_INT 21
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: IN
73519: NOT
73520: OR
73521: PUSH
73522: LD_VAR 0 8
73526: PUSH
73527: LD_INT 5
73529: ARRAY
73530: NOT
73531: OR
73532: PUSH
73533: LD_VAR 0 8
73537: PUSH
73538: LD_INT 6
73540: ARRAY
73541: PUSH
73542: LD_INT 1
73544: PUSH
73545: LD_INT 2
73547: PUSH
73548: LD_INT 7
73550: PUSH
73551: LD_INT 9
73553: PUSH
73554: LD_INT 10
73556: PUSH
73557: LD_INT 11
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: IN
73568: NOT
73569: OR
73570: IFFALSE 73576
// exit ;
73572: POP
73573: POP
73574: GO 73674
// end ;
73576: GO 73247
73578: POP
73579: POP
// side := GetSide ( depot ) ;
73580: LD_ADDR_VAR 0 9
73584: PUSH
73585: LD_VAR 0 1
73589: PPUSH
73590: CALL_OW 255
73594: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73595: LD_VAR 0 9
73599: PPUSH
73600: LD_VAR 0 3
73604: PPUSH
73605: LD_VAR 0 4
73609: PPUSH
73610: LD_INT 20
73612: PPUSH
73613: CALL 66328 0 4
73617: PUSH
73618: LD_INT 4
73620: ARRAY
73621: IFFALSE 73625
// exit ;
73623: GO 73674
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
73625: LD_VAR 0 2
73629: PUSH
73630: LD_INT 29
73632: PUSH
73633: LD_INT 30
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: IN
73640: PUSH
73641: LD_VAR 0 3
73645: PPUSH
73646: LD_VAR 0 4
73650: PPUSH
73651: LD_VAR 0 9
73655: PPUSH
73656: CALL_OW 440
73660: NOT
73661: AND
73662: IFFALSE 73666
// exit ;
73664: GO 73674
// result := true ;
73666: LD_ADDR_VAR 0 6
73670: PUSH
73671: LD_INT 1
73673: ST_TO_ADDR
// end ;
73674: LD_VAR 0 6
73678: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
73679: LD_INT 0
73681: PPUSH
73682: PPUSH
73683: PPUSH
73684: PPUSH
73685: PPUSH
73686: PPUSH
73687: PPUSH
73688: PPUSH
73689: PPUSH
73690: PPUSH
73691: PPUSH
73692: PPUSH
73693: PPUSH
73694: PPUSH
73695: PPUSH
73696: PPUSH
73697: PPUSH
73698: PPUSH
73699: PPUSH
73700: PPUSH
73701: PPUSH
73702: PPUSH
73703: PPUSH
73704: PPUSH
73705: PPUSH
73706: PPUSH
73707: PPUSH
73708: PPUSH
73709: PPUSH
73710: PPUSH
73711: PPUSH
73712: PPUSH
73713: PPUSH
73714: PPUSH
73715: PPUSH
73716: PPUSH
73717: PPUSH
73718: PPUSH
73719: PPUSH
73720: PPUSH
73721: PPUSH
73722: PPUSH
73723: PPUSH
73724: PPUSH
73725: PPUSH
73726: PPUSH
73727: PPUSH
73728: PPUSH
73729: PPUSH
73730: PPUSH
73731: PPUSH
73732: PPUSH
73733: PPUSH
73734: PPUSH
73735: PPUSH
73736: PPUSH
73737: PPUSH
73738: PPUSH
// result = [ ] ;
73739: LD_ADDR_VAR 0 7
73743: PUSH
73744: EMPTY
73745: ST_TO_ADDR
// temp_list = [ ] ;
73746: LD_ADDR_VAR 0 9
73750: PUSH
73751: EMPTY
73752: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
73753: LD_VAR 0 4
73757: PUSH
73758: LD_INT 0
73760: PUSH
73761: LD_INT 1
73763: PUSH
73764: LD_INT 2
73766: PUSH
73767: LD_INT 3
73769: PUSH
73770: LD_INT 4
73772: PUSH
73773: LD_INT 5
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: LIST
73783: IN
73784: NOT
73785: PUSH
73786: LD_VAR 0 1
73790: PUSH
73791: LD_INT 0
73793: PUSH
73794: LD_INT 1
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: IN
73801: PUSH
73802: LD_VAR 0 5
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: LD_INT 3
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: LIST
73820: IN
73821: NOT
73822: AND
73823: OR
73824: IFFALSE 73828
// exit ;
73826: GO 92219
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
73828: LD_VAR 0 1
73832: PUSH
73833: LD_INT 6
73835: PUSH
73836: LD_INT 7
73838: PUSH
73839: LD_INT 8
73841: PUSH
73842: LD_INT 13
73844: PUSH
73845: LD_INT 12
73847: PUSH
73848: LD_INT 15
73850: PUSH
73851: LD_INT 11
73853: PUSH
73854: LD_INT 14
73856: PUSH
73857: LD_INT 10
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: IN
73871: IFFALSE 73881
// btype = b_lab ;
73873: LD_ADDR_VAR 0 1
73877: PUSH
73878: LD_INT 6
73880: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
73881: LD_VAR 0 6
73885: PUSH
73886: LD_INT 0
73888: PUSH
73889: LD_INT 1
73891: PUSH
73892: LD_INT 2
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: LIST
73899: IN
73900: NOT
73901: PUSH
73902: LD_VAR 0 1
73906: PUSH
73907: LD_INT 0
73909: PUSH
73910: LD_INT 1
73912: PUSH
73913: LD_INT 2
73915: PUSH
73916: LD_INT 3
73918: PUSH
73919: LD_INT 6
73921: PUSH
73922: LD_INT 36
73924: PUSH
73925: LD_INT 4
73927: PUSH
73928: LD_INT 5
73930: PUSH
73931: LD_INT 31
73933: PUSH
73934: LD_INT 32
73936: PUSH
73937: LD_INT 33
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: LIST
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: IN
73953: NOT
73954: PUSH
73955: LD_VAR 0 6
73959: PUSH
73960: LD_INT 1
73962: EQUAL
73963: AND
73964: OR
73965: PUSH
73966: LD_VAR 0 1
73970: PUSH
73971: LD_INT 2
73973: PUSH
73974: LD_INT 3
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: IN
73981: NOT
73982: PUSH
73983: LD_VAR 0 6
73987: PUSH
73988: LD_INT 2
73990: EQUAL
73991: AND
73992: OR
73993: IFFALSE 74003
// mode = 0 ;
73995: LD_ADDR_VAR 0 6
73999: PUSH
74000: LD_INT 0
74002: ST_TO_ADDR
// case mode of 0 :
74003: LD_VAR 0 6
74007: PUSH
74008: LD_INT 0
74010: DOUBLE
74011: EQUAL
74012: IFTRUE 74016
74014: GO 85469
74016: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74017: LD_ADDR_VAR 0 11
74021: PUSH
74022: LD_INT 0
74024: PUSH
74025: LD_INT 0
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: LD_INT 1
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 1
74045: PUSH
74046: LD_INT 0
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 1
74055: PUSH
74056: LD_INT 1
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 0
74065: PUSH
74066: LD_INT 1
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 1
74075: NEG
74076: PUSH
74077: LD_INT 0
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: NEG
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: NEG
74099: PUSH
74100: LD_INT 2
74102: NEG
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 0
74110: PUSH
74111: LD_INT 2
74113: NEG
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 1
74121: PUSH
74122: LD_INT 1
74124: NEG
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: PUSH
74133: LD_INT 2
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: LD_INT 2
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 1
74152: NEG
74153: PUSH
74154: LD_INT 1
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 1
74163: PUSH
74164: LD_INT 3
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 0
74173: PUSH
74174: LD_INT 3
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 1
74183: NEG
74184: PUSH
74185: LD_INT 2
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74210: LD_ADDR_VAR 0 12
74214: PUSH
74215: LD_INT 0
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: LD_INT 1
74230: NEG
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 1
74238: PUSH
74239: LD_INT 0
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 1
74248: PUSH
74249: LD_INT 1
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: LD_INT 1
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 1
74268: NEG
74269: PUSH
74270: LD_INT 0
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: LD_INT 1
74279: NEG
74280: PUSH
74281: LD_INT 1
74283: NEG
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: PUSH
74289: LD_INT 1
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 2
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 2
74312: PUSH
74313: LD_INT 1
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 1
74322: NEG
74323: PUSH
74324: LD_INT 1
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: NEG
74334: PUSH
74335: LD_INT 0
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: LD_INT 2
74344: NEG
74345: PUSH
74346: LD_INT 1
74348: NEG
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 2
74356: NEG
74357: PUSH
74358: LD_INT 1
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 3
74367: NEG
74368: PUSH
74369: LD_INT 0
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 3
74378: NEG
74379: PUSH
74380: LD_INT 1
74382: NEG
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74406: LD_ADDR_VAR 0 13
74410: PUSH
74411: LD_INT 0
74413: PUSH
74414: LD_INT 0
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 0
74423: PUSH
74424: LD_INT 1
74426: NEG
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: LD_INT 1
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PUSH
74442: LD_INT 1
74444: PUSH
74445: LD_INT 1
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PUSH
74452: LD_INT 0
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: PUSH
74462: LD_INT 1
74464: NEG
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 1
74475: NEG
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: LD_INT 2
74491: NEG
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: LD_INT 2
74499: PUSH
74500: LD_INT 1
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 2
74509: PUSH
74510: LD_INT 2
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 1
74519: PUSH
74520: LD_INT 2
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 2
74529: NEG
74530: PUSH
74531: LD_INT 1
74533: NEG
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 2
74541: NEG
74542: PUSH
74543: LD_INT 2
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 2
74553: NEG
74554: PUSH
74555: LD_INT 3
74557: NEG
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 3
74565: NEG
74566: PUSH
74567: LD_INT 2
74569: NEG
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: LD_INT 3
74577: NEG
74578: PUSH
74579: LD_INT 3
74581: NEG
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74605: LD_ADDR_VAR 0 14
74609: PUSH
74610: LD_INT 0
74612: PUSH
74613: LD_INT 0
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 0
74622: PUSH
74623: LD_INT 1
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: LD_INT 0
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 1
74643: PUSH
74644: LD_INT 1
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 0
74653: PUSH
74654: LD_INT 1
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: LD_INT 0
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 1
74674: NEG
74675: PUSH
74676: LD_INT 1
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: NEG
74687: PUSH
74688: LD_INT 2
74690: NEG
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 0
74698: PUSH
74699: LD_INT 2
74701: NEG
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 1
74709: PUSH
74710: LD_INT 1
74712: NEG
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: PUSH
74718: LD_INT 1
74720: PUSH
74721: LD_INT 2
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: LD_INT 0
74730: PUSH
74731: LD_INT 2
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 1
74740: NEG
74741: PUSH
74742: LD_INT 1
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 1
74751: NEG
74752: PUSH
74753: LD_INT 3
74755: NEG
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 0
74763: PUSH
74764: LD_INT 3
74766: NEG
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: LD_INT 2
74777: NEG
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74801: LD_ADDR_VAR 0 15
74805: PUSH
74806: LD_INT 0
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: LD_INT 1
74821: NEG
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: LD_INT 1
74829: PUSH
74830: LD_INT 0
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 1
74839: PUSH
74840: LD_INT 1
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 0
74849: PUSH
74850: LD_INT 1
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: LD_INT 0
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 1
74870: NEG
74871: PUSH
74872: LD_INT 1
74874: NEG
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: PUSH
74880: LD_INT 1
74882: PUSH
74883: LD_INT 1
74885: NEG
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PUSH
74891: LD_INT 2
74893: PUSH
74894: LD_INT 0
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 2
74903: PUSH
74904: LD_INT 1
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: LD_INT 1
74913: NEG
74914: PUSH
74915: LD_INT 1
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: LD_INT 2
74924: NEG
74925: PUSH
74926: LD_INT 0
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 2
74935: NEG
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 2
74947: PUSH
74948: LD_INT 1
74950: NEG
74951: PUSH
74952: EMPTY
74953: LIST
74954: LIST
74955: PUSH
74956: LD_INT 3
74958: PUSH
74959: LD_INT 0
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 3
74968: PUSH
74969: LD_INT 1
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: LIST
74985: LIST
74986: LIST
74987: LIST
74988: LIST
74989: LIST
74990: LIST
74991: LIST
74992: LIST
74993: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74994: LD_ADDR_VAR 0 16
74998: PUSH
74999: LD_INT 0
75001: PUSH
75002: LD_INT 0
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 0
75011: PUSH
75012: LD_INT 1
75014: NEG
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 1
75022: PUSH
75023: LD_INT 0
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: LD_INT 1
75032: PUSH
75033: LD_INT 1
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: LD_INT 1
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 1
75052: NEG
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 1
75063: NEG
75064: PUSH
75065: LD_INT 1
75067: NEG
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 1
75075: NEG
75076: PUSH
75077: LD_INT 2
75079: NEG
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 2
75087: PUSH
75088: LD_INT 1
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 2
75097: PUSH
75098: LD_INT 2
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 1
75107: PUSH
75108: LD_INT 2
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 2
75117: NEG
75118: PUSH
75119: LD_INT 1
75121: NEG
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 2
75129: NEG
75130: PUSH
75131: LD_INT 2
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 3
75141: PUSH
75142: LD_INT 2
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 3
75151: PUSH
75152: LD_INT 3
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 2
75161: PUSH
75162: LD_INT 3
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: LIST
75183: LIST
75184: LIST
75185: LIST
75186: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75187: LD_ADDR_VAR 0 17
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: LD_INT 0
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 0
75204: PUSH
75205: LD_INT 1
75207: NEG
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 1
75215: PUSH
75216: LD_INT 0
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: PUSH
75226: LD_INT 1
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: LD_INT 1
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 1
75245: NEG
75246: PUSH
75247: LD_INT 0
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 1
75256: NEG
75257: PUSH
75258: LD_INT 1
75260: NEG
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 1
75268: NEG
75269: PUSH
75270: LD_INT 2
75272: NEG
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: LD_INT 2
75283: NEG
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 1
75291: PUSH
75292: LD_INT 1
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 2
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 2
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 2
75322: PUSH
75323: LD_INT 2
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 1
75332: PUSH
75333: LD_INT 2
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 0
75342: PUSH
75343: LD_INT 2
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: LD_INT 1
75352: NEG
75353: PUSH
75354: LD_INT 1
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 2
75363: NEG
75364: PUSH
75365: LD_INT 0
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 2
75374: NEG
75375: PUSH
75376: LD_INT 1
75378: NEG
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 2
75386: NEG
75387: PUSH
75388: LD_INT 2
75390: NEG
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: LIST
75416: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75417: LD_ADDR_VAR 0 18
75421: PUSH
75422: LD_INT 0
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: LD_INT 1
75437: NEG
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: LD_INT 0
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 1
75455: PUSH
75456: LD_INT 1
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 0
75465: PUSH
75466: LD_INT 1
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: LD_INT 0
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: LD_INT 1
75490: NEG
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 1
75498: NEG
75499: PUSH
75500: LD_INT 2
75502: NEG
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PUSH
75508: LD_INT 0
75510: PUSH
75511: LD_INT 2
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 1
75521: PUSH
75522: LD_INT 1
75524: NEG
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 2
75532: PUSH
75533: LD_INT 0
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 2
75542: PUSH
75543: LD_INT 1
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 2
75552: PUSH
75553: LD_INT 2
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 1
75562: PUSH
75563: LD_INT 2
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 0
75572: PUSH
75573: LD_INT 2
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 1
75582: NEG
75583: PUSH
75584: LD_INT 1
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 2
75593: NEG
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 2
75604: NEG
75605: PUSH
75606: LD_INT 1
75608: NEG
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 2
75616: NEG
75617: PUSH
75618: LD_INT 2
75620: NEG
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: LIST
75630: LIST
75631: LIST
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: LIST
75645: LIST
75646: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75647: LD_ADDR_VAR 0 19
75651: PUSH
75652: LD_INT 0
75654: PUSH
75655: LD_INT 0
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PUSH
75662: LD_INT 0
75664: PUSH
75665: LD_INT 1
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 1
75675: PUSH
75676: LD_INT 0
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 1
75685: PUSH
75686: LD_INT 1
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 0
75695: PUSH
75696: LD_INT 1
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 1
75705: NEG
75706: PUSH
75707: LD_INT 0
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: LD_INT 1
75728: NEG
75729: PUSH
75730: LD_INT 2
75732: NEG
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 0
75740: PUSH
75741: LD_INT 2
75743: NEG
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 1
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 2
75762: PUSH
75763: LD_INT 0
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 2
75772: PUSH
75773: LD_INT 1
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 2
75782: PUSH
75783: LD_INT 2
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 1
75792: PUSH
75793: LD_INT 2
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: LD_INT 0
75802: PUSH
75803: LD_INT 2
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 1
75812: NEG
75813: PUSH
75814: LD_INT 1
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 2
75823: NEG
75824: PUSH
75825: LD_INT 0
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 2
75834: NEG
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 2
75846: NEG
75847: PUSH
75848: LD_INT 2
75850: NEG
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: LIST
75860: LIST
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75877: LD_ADDR_VAR 0 20
75881: PUSH
75882: LD_INT 0
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 0
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: LD_INT 0
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: LD_INT 1
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 0
75925: PUSH
75926: LD_INT 1
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 1
75935: NEG
75936: PUSH
75937: LD_INT 0
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 1
75946: NEG
75947: PUSH
75948: LD_INT 1
75950: NEG
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: NEG
75959: PUSH
75960: LD_INT 2
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 0
75970: PUSH
75971: LD_INT 2
75973: NEG
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 1
75981: PUSH
75982: LD_INT 1
75984: NEG
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 2
75992: PUSH
75993: LD_INT 0
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 2
76002: PUSH
76003: LD_INT 1
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 2
76012: PUSH
76013: LD_INT 2
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: LD_INT 1
76022: PUSH
76023: LD_INT 2
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 1
76042: NEG
76043: PUSH
76044: LD_INT 1
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: LD_INT 2
76053: NEG
76054: PUSH
76055: LD_INT 0
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PUSH
76062: LD_INT 2
76064: NEG
76065: PUSH
76066: LD_INT 1
76068: NEG
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 2
76076: NEG
76077: PUSH
76078: LD_INT 2
76080: NEG
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: LIST
76104: LIST
76105: LIST
76106: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76107: LD_ADDR_VAR 0 21
76111: PUSH
76112: LD_INT 0
76114: PUSH
76115: LD_INT 0
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 0
76124: PUSH
76125: LD_INT 1
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 0
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: LD_INT 1
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 0
76155: PUSH
76156: LD_INT 1
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 1
76165: NEG
76166: PUSH
76167: LD_INT 0
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 1
76176: NEG
76177: PUSH
76178: LD_INT 1
76180: NEG
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 1
76188: NEG
76189: PUSH
76190: LD_INT 2
76192: NEG
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: PUSH
76198: LD_INT 0
76200: PUSH
76201: LD_INT 2
76203: NEG
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 1
76211: PUSH
76212: LD_INT 1
76214: NEG
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: LD_INT 2
76222: PUSH
76223: LD_INT 0
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 2
76232: PUSH
76233: LD_INT 1
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 2
76242: PUSH
76243: LD_INT 2
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 1
76252: PUSH
76253: LD_INT 2
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 0
76262: PUSH
76263: LD_INT 2
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 1
76272: NEG
76273: PUSH
76274: LD_INT 1
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: PUSH
76281: LD_INT 2
76283: NEG
76284: PUSH
76285: LD_INT 0
76287: PUSH
76288: EMPTY
76289: LIST
76290: LIST
76291: PUSH
76292: LD_INT 2
76294: NEG
76295: PUSH
76296: LD_INT 1
76298: NEG
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 2
76306: NEG
76307: PUSH
76308: LD_INT 2
76310: NEG
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: LIST
76320: LIST
76321: LIST
76322: LIST
76323: LIST
76324: LIST
76325: LIST
76326: LIST
76327: LIST
76328: LIST
76329: LIST
76330: LIST
76331: LIST
76332: LIST
76333: LIST
76334: LIST
76335: LIST
76336: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76337: LD_ADDR_VAR 0 22
76341: PUSH
76342: LD_INT 0
76344: PUSH
76345: LD_INT 0
76347: PUSH
76348: EMPTY
76349: LIST
76350: LIST
76351: PUSH
76352: LD_INT 0
76354: PUSH
76355: LD_INT 1
76357: NEG
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 1
76365: PUSH
76366: LD_INT 0
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 1
76375: PUSH
76376: LD_INT 1
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 0
76385: PUSH
76386: LD_INT 1
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 1
76395: NEG
76396: PUSH
76397: LD_INT 0
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 1
76406: NEG
76407: PUSH
76408: LD_INT 1
76410: NEG
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 1
76418: NEG
76419: PUSH
76420: LD_INT 2
76422: NEG
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 0
76430: PUSH
76431: LD_INT 2
76433: NEG
76434: PUSH
76435: EMPTY
76436: LIST
76437: LIST
76438: PUSH
76439: LD_INT 1
76441: PUSH
76442: LD_INT 1
76444: NEG
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 2
76452: PUSH
76453: LD_INT 0
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 2
76462: PUSH
76463: LD_INT 1
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 2
76472: PUSH
76473: LD_INT 2
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PUSH
76480: LD_INT 1
76482: PUSH
76483: LD_INT 2
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 0
76492: PUSH
76493: LD_INT 2
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: LD_INT 1
76502: NEG
76503: PUSH
76504: LD_INT 1
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: LD_INT 2
76513: NEG
76514: PUSH
76515: LD_INT 0
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 2
76524: NEG
76525: PUSH
76526: LD_INT 1
76528: NEG
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 2
76536: NEG
76537: PUSH
76538: LD_INT 2
76540: NEG
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: LIST
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76567: LD_ADDR_VAR 0 23
76571: PUSH
76572: LD_INT 0
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 0
76584: PUSH
76585: LD_INT 1
76587: NEG
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 1
76595: PUSH
76596: LD_INT 0
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: LD_INT 1
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 0
76615: PUSH
76616: LD_INT 1
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: LD_INT 1
76625: NEG
76626: PUSH
76627: LD_INT 0
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 1
76636: NEG
76637: PUSH
76638: LD_INT 1
76640: NEG
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 1
76648: NEG
76649: PUSH
76650: LD_INT 2
76652: NEG
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 0
76660: PUSH
76661: LD_INT 2
76663: NEG
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: LD_INT 1
76671: PUSH
76672: LD_INT 1
76674: NEG
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: LD_INT 2
76682: PUSH
76683: LD_INT 0
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: LD_INT 1
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 2
76702: PUSH
76703: LD_INT 2
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 1
76712: PUSH
76713: LD_INT 2
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: LD_INT 2
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 1
76732: NEG
76733: PUSH
76734: LD_INT 1
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 2
76743: NEG
76744: PUSH
76745: LD_INT 0
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 2
76754: NEG
76755: PUSH
76756: LD_INT 1
76758: NEG
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 2
76766: NEG
76767: PUSH
76768: LD_INT 2
76770: NEG
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 2
76778: NEG
76779: PUSH
76780: LD_INT 3
76782: NEG
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 1
76790: NEG
76791: PUSH
76792: LD_INT 3
76794: NEG
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 1
76802: PUSH
76803: LD_INT 2
76805: NEG
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 2
76813: PUSH
76814: LD_INT 1
76816: NEG
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: LIST
76826: LIST
76827: LIST
76828: LIST
76829: LIST
76830: LIST
76831: LIST
76832: LIST
76833: LIST
76834: LIST
76835: LIST
76836: LIST
76837: LIST
76838: LIST
76839: LIST
76840: LIST
76841: LIST
76842: LIST
76843: LIST
76844: LIST
76845: LIST
76846: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
76847: LD_ADDR_VAR 0 24
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: LD_INT 0
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 0
76864: PUSH
76865: LD_INT 1
76867: NEG
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 1
76875: PUSH
76876: LD_INT 0
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 1
76885: PUSH
76886: LD_INT 1
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 0
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 1
76905: NEG
76906: PUSH
76907: LD_INT 0
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 1
76916: NEG
76917: PUSH
76918: LD_INT 1
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 1
76928: NEG
76929: PUSH
76930: LD_INT 2
76932: NEG
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 0
76940: PUSH
76941: LD_INT 2
76943: NEG
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 1
76951: PUSH
76952: LD_INT 1
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 2
76962: PUSH
76963: LD_INT 0
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 2
76972: PUSH
76973: LD_INT 1
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 2
76982: PUSH
76983: LD_INT 2
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 1
76992: PUSH
76993: LD_INT 2
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: LD_INT 2
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: PUSH
77010: LD_INT 1
77012: NEG
77013: PUSH
77014: LD_INT 1
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 2
77023: NEG
77024: PUSH
77025: LD_INT 0
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: LD_INT 2
77034: NEG
77035: PUSH
77036: LD_INT 1
77038: NEG
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 2
77046: NEG
77047: PUSH
77048: LD_INT 2
77050: NEG
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 1
77058: PUSH
77059: LD_INT 2
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 2
77069: PUSH
77070: LD_INT 1
77072: NEG
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 3
77080: PUSH
77081: LD_INT 1
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 3
77090: PUSH
77091: LD_INT 2
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: LIST
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: LIST
77120: LIST
77121: LIST
77122: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
77123: LD_ADDR_VAR 0 25
77127: PUSH
77128: LD_INT 0
77130: PUSH
77131: LD_INT 0
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 0
77140: PUSH
77141: LD_INT 1
77143: NEG
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 1
77151: PUSH
77152: LD_INT 0
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 1
77161: PUSH
77162: LD_INT 1
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 0
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 1
77181: NEG
77182: PUSH
77183: LD_INT 0
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 1
77192: NEG
77193: PUSH
77194: LD_INT 1
77196: NEG
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 1
77204: NEG
77205: PUSH
77206: LD_INT 2
77208: NEG
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 0
77216: PUSH
77217: LD_INT 2
77219: NEG
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 1
77227: PUSH
77228: LD_INT 1
77230: NEG
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 2
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 2
77248: PUSH
77249: LD_INT 1
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 2
77258: PUSH
77259: LD_INT 2
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 1
77268: PUSH
77269: LD_INT 2
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 0
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 1
77288: NEG
77289: PUSH
77290: LD_INT 1
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 2
77299: NEG
77300: PUSH
77301: LD_INT 0
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 2
77310: NEG
77311: PUSH
77312: LD_INT 1
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 2
77322: NEG
77323: PUSH
77324: LD_INT 2
77326: NEG
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 3
77334: PUSH
77335: LD_INT 1
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 3
77344: PUSH
77345: LD_INT 2
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 2
77354: PUSH
77355: LD_INT 3
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: LD_INT 1
77364: PUSH
77365: LD_INT 3
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: LIST
77381: LIST
77382: LIST
77383: LIST
77384: LIST
77385: LIST
77386: LIST
77387: LIST
77388: LIST
77389: LIST
77390: LIST
77391: LIST
77392: LIST
77393: LIST
77394: LIST
77395: LIST
77396: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77397: LD_ADDR_VAR 0 26
77401: PUSH
77402: LD_INT 0
77404: PUSH
77405: LD_INT 0
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 0
77414: PUSH
77415: LD_INT 1
77417: NEG
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 1
77425: PUSH
77426: LD_INT 0
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 1
77435: PUSH
77436: LD_INT 1
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 0
77445: PUSH
77446: LD_INT 1
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: LD_INT 1
77455: NEG
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: LD_INT 1
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 1
77478: NEG
77479: PUSH
77480: LD_INT 2
77482: NEG
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: LD_INT 2
77493: NEG
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 1
77501: PUSH
77502: LD_INT 1
77504: NEG
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 2
77512: PUSH
77513: LD_INT 0
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: LD_INT 2
77522: PUSH
77523: LD_INT 1
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 2
77532: PUSH
77533: LD_INT 2
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 1
77542: PUSH
77543: LD_INT 2
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: LD_INT 0
77552: PUSH
77553: LD_INT 2
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: PUSH
77560: LD_INT 1
77562: NEG
77563: PUSH
77564: LD_INT 1
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 2
77573: NEG
77574: PUSH
77575: LD_INT 0
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 2
77584: NEG
77585: PUSH
77586: LD_INT 1
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 2
77596: NEG
77597: PUSH
77598: LD_INT 2
77600: NEG
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 2
77608: PUSH
77609: LD_INT 3
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: PUSH
77616: LD_INT 1
77618: PUSH
77619: LD_INT 3
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 1
77628: NEG
77629: PUSH
77630: LD_INT 2
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 2
77639: NEG
77640: PUSH
77641: LD_INT 1
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77673: LD_ADDR_VAR 0 27
77677: PUSH
77678: LD_INT 0
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 0
77690: PUSH
77691: LD_INT 1
77693: NEG
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 1
77701: PUSH
77702: LD_INT 0
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 1
77711: PUSH
77712: LD_INT 1
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: LD_INT 1
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: LD_INT 1
77731: NEG
77732: PUSH
77733: LD_INT 0
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: LD_INT 1
77742: NEG
77743: PUSH
77744: LD_INT 1
77746: NEG
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PUSH
77752: LD_INT 1
77754: NEG
77755: PUSH
77756: LD_INT 2
77758: NEG
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: LD_INT 2
77769: NEG
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 1
77777: PUSH
77778: LD_INT 1
77780: NEG
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 2
77788: PUSH
77789: LD_INT 0
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 2
77798: PUSH
77799: LD_INT 1
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 2
77808: PUSH
77809: LD_INT 2
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: LD_INT 1
77818: PUSH
77819: LD_INT 2
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 0
77828: PUSH
77829: LD_INT 2
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 1
77838: NEG
77839: PUSH
77840: LD_INT 1
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 2
77849: NEG
77850: PUSH
77851: LD_INT 0
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 2
77860: NEG
77861: PUSH
77862: LD_INT 1
77864: NEG
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 2
77872: NEG
77873: PUSH
77874: LD_INT 2
77876: NEG
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 1
77884: NEG
77885: PUSH
77886: LD_INT 2
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 2
77895: NEG
77896: PUSH
77897: LD_INT 1
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 3
77906: NEG
77907: PUSH
77908: LD_INT 1
77910: NEG
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 3
77918: NEG
77919: PUSH
77920: LD_INT 2
77922: NEG
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: LIST
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: LIST
77942: LIST
77943: LIST
77944: LIST
77945: LIST
77946: LIST
77947: LIST
77948: LIST
77949: LIST
77950: LIST
77951: LIST
77952: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77953: LD_ADDR_VAR 0 28
77957: PUSH
77958: LD_INT 0
77960: PUSH
77961: LD_INT 0
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 0
77970: PUSH
77971: LD_INT 1
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 1
77981: PUSH
77982: LD_INT 0
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 1
77991: PUSH
77992: LD_INT 1
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: PUSH
77999: LD_INT 0
78001: PUSH
78002: LD_INT 1
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 1
78011: NEG
78012: PUSH
78013: LD_INT 0
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 1
78022: NEG
78023: PUSH
78024: LD_INT 1
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 1
78034: NEG
78035: PUSH
78036: LD_INT 2
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: LD_INT 2
78049: NEG
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 1
78057: PUSH
78058: LD_INT 1
78060: NEG
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 2
78068: PUSH
78069: LD_INT 0
78071: PUSH
78072: EMPTY
78073: LIST
78074: LIST
78075: PUSH
78076: LD_INT 2
78078: PUSH
78079: LD_INT 1
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 2
78088: PUSH
78089: LD_INT 2
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 1
78098: PUSH
78099: LD_INT 2
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 0
78108: PUSH
78109: LD_INT 2
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: PUSH
78116: LD_INT 1
78118: NEG
78119: PUSH
78120: LD_INT 1
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 2
78129: NEG
78130: PUSH
78131: LD_INT 0
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 2
78140: NEG
78141: PUSH
78142: LD_INT 1
78144: NEG
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 2
78152: NEG
78153: PUSH
78154: LD_INT 2
78156: NEG
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 2
78164: NEG
78165: PUSH
78166: LD_INT 3
78168: NEG
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 1
78176: NEG
78177: PUSH
78178: LD_INT 3
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 3
78188: NEG
78189: PUSH
78190: LD_INT 1
78192: NEG
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: LD_INT 3
78200: NEG
78201: PUSH
78202: LD_INT 2
78204: NEG
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
78235: LD_ADDR_VAR 0 29
78239: PUSH
78240: LD_INT 0
78242: PUSH
78243: LD_INT 0
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 0
78252: PUSH
78253: LD_INT 1
78255: NEG
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 1
78263: PUSH
78264: LD_INT 0
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 1
78273: PUSH
78274: LD_INT 1
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 0
78283: PUSH
78284: LD_INT 1
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 1
78293: NEG
78294: PUSH
78295: LD_INT 0
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 1
78304: NEG
78305: PUSH
78306: LD_INT 1
78308: NEG
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: LD_INT 1
78316: NEG
78317: PUSH
78318: LD_INT 2
78320: NEG
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_INT 0
78328: PUSH
78329: LD_INT 2
78331: NEG
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 1
78339: PUSH
78340: LD_INT 1
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 2
78350: PUSH
78351: LD_INT 0
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 2
78360: PUSH
78361: LD_INT 1
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 1
78370: PUSH
78371: LD_INT 2
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 0
78380: PUSH
78381: LD_INT 2
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 1
78390: NEG
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 2
78401: NEG
78402: PUSH
78403: LD_INT 1
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 2
78413: NEG
78414: PUSH
78415: LD_INT 2
78417: NEG
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 2
78425: NEG
78426: PUSH
78427: LD_INT 3
78429: NEG
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 2
78437: PUSH
78438: LD_INT 1
78440: NEG
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 3
78448: PUSH
78449: LD_INT 1
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 1
78458: PUSH
78459: LD_INT 3
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: LD_INT 2
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 3
78479: NEG
78480: PUSH
78481: LD_INT 2
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: LIST
78493: LIST
78494: LIST
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: LIST
78502: LIST
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: LIST
78509: LIST
78510: LIST
78511: LIST
78512: LIST
78513: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78514: LD_ADDR_VAR 0 30
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: LD_INT 0
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 0
78531: PUSH
78532: LD_INT 1
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 1
78542: PUSH
78543: LD_INT 0
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 1
78552: PUSH
78553: LD_INT 1
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: PUSH
78560: LD_INT 0
78562: PUSH
78563: LD_INT 1
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: LD_INT 1
78572: NEG
78573: PUSH
78574: LD_INT 0
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 1
78583: NEG
78584: PUSH
78585: LD_INT 1
78587: NEG
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 1
78595: NEG
78596: PUSH
78597: LD_INT 2
78599: NEG
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: LD_INT 2
78610: NEG
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 1
78618: PUSH
78619: LD_INT 1
78621: NEG
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 2
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 2
78639: PUSH
78640: LD_INT 1
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 2
78649: PUSH
78650: LD_INT 2
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 1
78659: PUSH
78660: LD_INT 2
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 1
78669: NEG
78670: PUSH
78671: LD_INT 1
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 2
78680: NEG
78681: PUSH
78682: LD_INT 0
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 2
78691: NEG
78692: PUSH
78693: LD_INT 1
78695: NEG
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 1
78703: NEG
78704: PUSH
78705: LD_INT 3
78707: NEG
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 1
78715: PUSH
78716: LD_INT 2
78718: NEG
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 3
78726: PUSH
78727: LD_INT 2
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 2
78736: PUSH
78737: LD_INT 3
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: LD_INT 1
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 3
78757: NEG
78758: PUSH
78759: LD_INT 1
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
78792: LD_ADDR_VAR 0 31
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: LD_INT 0
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PUSH
78807: LD_INT 0
78809: PUSH
78810: LD_INT 1
78812: NEG
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 1
78820: PUSH
78821: LD_INT 0
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 1
78830: PUSH
78831: LD_INT 1
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 0
78840: PUSH
78841: LD_INT 1
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: NEG
78851: PUSH
78852: LD_INT 0
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 1
78861: NEG
78862: PUSH
78863: LD_INT 1
78865: NEG
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 1
78873: NEG
78874: PUSH
78875: LD_INT 2
78877: NEG
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 1
78885: PUSH
78886: LD_INT 1
78888: NEG
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: LD_INT 2
78896: PUSH
78897: LD_INT 0
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 2
78906: PUSH
78907: LD_INT 1
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 2
78916: PUSH
78917: LD_INT 2
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 1
78926: PUSH
78927: LD_INT 2
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 0
78936: PUSH
78937: LD_INT 2
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 1
78946: NEG
78947: PUSH
78948: LD_INT 1
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 2
78957: NEG
78958: PUSH
78959: LD_INT 1
78961: NEG
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 2
78969: NEG
78970: PUSH
78971: LD_INT 2
78973: NEG
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 2
78981: NEG
78982: PUSH
78983: LD_INT 3
78985: NEG
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 2
78993: PUSH
78994: LD_INT 1
78996: NEG
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 3
79004: PUSH
79005: LD_INT 1
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 1
79014: PUSH
79015: LD_INT 3
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 1
79024: NEG
79025: PUSH
79026: LD_INT 2
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 3
79035: NEG
79036: PUSH
79037: LD_INT 2
79039: NEG
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: LIST
79049: LIST
79050: LIST
79051: LIST
79052: LIST
79053: LIST
79054: LIST
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79070: LD_ADDR_VAR 0 32
79074: PUSH
79075: LD_INT 0
79077: PUSH
79078: LD_INT 0
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 1
79098: PUSH
79099: LD_INT 0
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 1
79108: PUSH
79109: LD_INT 1
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 0
79118: PUSH
79119: LD_INT 1
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 1
79128: NEG
79129: PUSH
79130: LD_INT 0
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 1
79151: NEG
79152: PUSH
79153: LD_INT 2
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 0
79163: PUSH
79164: LD_INT 2
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 1
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 2
79185: PUSH
79186: LD_INT 1
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 2
79195: PUSH
79196: LD_INT 2
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 1
79205: PUSH
79206: LD_INT 2
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 0
79215: PUSH
79216: LD_INT 2
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 1
79225: NEG
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 2
79236: NEG
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 2
79247: NEG
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 1
79259: NEG
79260: PUSH
79261: LD_INT 3
79263: NEG
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 1
79271: PUSH
79272: LD_INT 2
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 3
79282: PUSH
79283: LD_INT 2
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 2
79292: PUSH
79293: LD_INT 3
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 2
79302: NEG
79303: PUSH
79304: LD_INT 1
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 3
79313: NEG
79314: PUSH
79315: LD_INT 1
79317: NEG
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79348: LD_ADDR_VAR 0 33
79352: PUSH
79353: LD_INT 0
79355: PUSH
79356: LD_INT 0
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 0
79365: PUSH
79366: LD_INT 1
79368: NEG
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 1
79376: PUSH
79377: LD_INT 0
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 1
79386: PUSH
79387: LD_INT 1
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 0
79396: PUSH
79397: LD_INT 1
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 1
79406: NEG
79407: PUSH
79408: LD_INT 0
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 1
79417: NEG
79418: PUSH
79419: LD_INT 1
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 1
79429: NEG
79430: PUSH
79431: LD_INT 2
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 1
79441: PUSH
79442: LD_INT 1
79444: NEG
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 2
79452: PUSH
79453: LD_INT 0
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 2
79462: PUSH
79463: LD_INT 1
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 1
79472: PUSH
79473: LD_INT 2
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 0
79482: PUSH
79483: LD_INT 2
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: NEG
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 2
79503: NEG
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 2
79514: NEG
79515: PUSH
79516: LD_INT 1
79518: NEG
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 2
79526: NEG
79527: PUSH
79528: LD_INT 2
79530: NEG
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 2
79538: NEG
79539: PUSH
79540: LD_INT 3
79542: NEG
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: LD_INT 1
79553: NEG
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 3
79561: PUSH
79562: LD_INT 1
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 1
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 1
79581: NEG
79582: PUSH
79583: LD_INT 2
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 3
79592: NEG
79593: PUSH
79594: LD_INT 2
79596: NEG
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79627: LD_ADDR_VAR 0 34
79631: PUSH
79632: LD_INT 0
79634: PUSH
79635: LD_INT 0
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 1
79647: NEG
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 1
79655: PUSH
79656: LD_INT 0
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 1
79665: PUSH
79666: LD_INT 1
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 0
79675: PUSH
79676: LD_INT 1
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 1
79685: NEG
79686: PUSH
79687: LD_INT 0
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 1
79696: NEG
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 1
79708: NEG
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 0
79720: PUSH
79721: LD_INT 2
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: LD_INT 1
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 2
79742: PUSH
79743: LD_INT 1
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 2
79752: PUSH
79753: LD_INT 2
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: LD_INT 2
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 1
79772: NEG
79773: PUSH
79774: LD_INT 1
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 2
79783: NEG
79784: PUSH
79785: LD_INT 0
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 2
79794: NEG
79795: PUSH
79796: LD_INT 1
79798: NEG
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: LD_INT 2
79806: NEG
79807: PUSH
79808: LD_INT 2
79810: NEG
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 1
79818: NEG
79819: PUSH
79820: LD_INT 3
79822: NEG
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 1
79830: PUSH
79831: LD_INT 2
79833: NEG
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 3
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 3
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 2
79861: NEG
79862: PUSH
79863: LD_INT 1
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 3
79872: NEG
79873: PUSH
79874: LD_INT 1
79876: NEG
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
79907: LD_ADDR_VAR 0 35
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: LD_INT 0
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 0
79924: PUSH
79925: LD_INT 1
79927: NEG
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 1
79935: PUSH
79936: LD_INT 0
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 1
79945: PUSH
79946: LD_INT 1
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: LD_INT 0
79955: PUSH
79956: LD_INT 1
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 1
79965: NEG
79966: PUSH
79967: LD_INT 0
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 1
79976: NEG
79977: PUSH
79978: LD_INT 1
79980: NEG
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 2
79988: PUSH
79989: LD_INT 1
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 2
79998: NEG
79999: PUSH
80000: LD_INT 1
80002: NEG
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80019: LD_ADDR_VAR 0 36
80023: PUSH
80024: LD_INT 0
80026: PUSH
80027: LD_INT 0
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 0
80036: PUSH
80037: LD_INT 1
80039: NEG
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 1
80047: PUSH
80048: LD_INT 0
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 1
80057: PUSH
80058: LD_INT 1
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 0
80067: PUSH
80068: LD_INT 1
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 1
80077: NEG
80078: PUSH
80079: LD_INT 0
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 1
80088: NEG
80089: PUSH
80090: LD_INT 1
80092: NEG
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 1
80100: NEG
80101: PUSH
80102: LD_INT 2
80104: NEG
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 1
80112: PUSH
80113: LD_INT 2
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80131: LD_ADDR_VAR 0 37
80135: PUSH
80136: LD_INT 0
80138: PUSH
80139: LD_INT 0
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 0
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 1
80159: PUSH
80160: LD_INT 0
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 1
80169: PUSH
80170: LD_INT 1
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 0
80179: PUSH
80180: LD_INT 1
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 1
80200: NEG
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: LD_INT 1
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: NEG
80224: PUSH
80225: LD_INT 1
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80243: LD_ADDR_VAR 0 38
80247: PUSH
80248: LD_INT 0
80250: PUSH
80251: LD_INT 0
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 0
80260: PUSH
80261: LD_INT 1
80263: NEG
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 1
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 1
80281: PUSH
80282: LD_INT 1
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 0
80291: PUSH
80292: LD_INT 1
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 1
80301: NEG
80302: PUSH
80303: LD_INT 0
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 1
80312: NEG
80313: PUSH
80314: LD_INT 1
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 2
80324: PUSH
80325: LD_INT 1
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 2
80334: NEG
80335: PUSH
80336: LD_INT 1
80338: NEG
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80355: LD_ADDR_VAR 0 39
80359: PUSH
80360: LD_INT 0
80362: PUSH
80363: LD_INT 0
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: LD_INT 1
80375: NEG
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 1
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: LD_INT 1
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 0
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 1
80413: NEG
80414: PUSH
80415: LD_INT 0
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 1
80424: NEG
80425: PUSH
80426: LD_INT 1
80428: NEG
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 1
80436: NEG
80437: PUSH
80438: LD_INT 2
80440: NEG
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 1
80448: PUSH
80449: LD_INT 2
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80467: LD_ADDR_VAR 0 40
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: LD_INT 0
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 0
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: LD_INT 0
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 1
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 0
80515: PUSH
80516: LD_INT 1
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: NEG
80526: PUSH
80527: LD_INT 0
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 1
80536: NEG
80537: PUSH
80538: LD_INT 1
80540: NEG
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: PUSH
80549: LD_INT 1
80551: NEG
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 1
80559: NEG
80560: PUSH
80561: LD_INT 1
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80579: LD_ADDR_VAR 0 41
80583: PUSH
80584: LD_INT 0
80586: PUSH
80587: LD_INT 0
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 0
80596: PUSH
80597: LD_INT 1
80599: NEG
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 1
80607: PUSH
80608: LD_INT 0
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: LD_INT 1
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 0
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: LD_INT 1
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: NEG
80661: PUSH
80662: LD_INT 2
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 2
80683: PUSH
80684: LD_INT 0
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 2
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 2
80703: PUSH
80704: LD_INT 2
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 1
80713: PUSH
80714: LD_INT 2
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 1
80723: NEG
80724: PUSH
80725: LD_INT 1
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 2
80734: NEG
80735: PUSH
80736: LD_INT 0
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 2
80745: NEG
80746: PUSH
80747: LD_INT 1
80749: NEG
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 2
80757: NEG
80758: PUSH
80759: LD_INT 2
80761: NEG
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 2
80769: NEG
80770: PUSH
80771: LD_INT 3
80773: NEG
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: LD_INT 2
80781: PUSH
80782: LD_INT 1
80784: NEG
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 3
80792: PUSH
80793: LD_INT 0
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 3
80802: PUSH
80803: LD_INT 1
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 3
80812: PUSH
80813: LD_INT 2
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 3
80822: PUSH
80823: LD_INT 3
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 2
80832: PUSH
80833: LD_INT 3
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 2
80842: NEG
80843: PUSH
80844: LD_INT 1
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 3
80853: NEG
80854: PUSH
80855: LD_INT 0
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 3
80864: NEG
80865: PUSH
80866: LD_INT 1
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 3
80876: NEG
80877: PUSH
80878: LD_INT 2
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 3
80888: NEG
80889: PUSH
80890: LD_INT 3
80892: NEG
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80929: LD_ADDR_VAR 0 42
80933: PUSH
80934: LD_INT 0
80936: PUSH
80937: LD_INT 0
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 0
80946: PUSH
80947: LD_INT 1
80949: NEG
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 1
80957: PUSH
80958: LD_INT 0
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 1
80967: PUSH
80968: LD_INT 1
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 0
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 1
80987: NEG
80988: PUSH
80989: LD_INT 0
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: LD_INT 1
81002: NEG
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 1
81010: NEG
81011: PUSH
81012: LD_INT 2
81014: NEG
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 0
81022: PUSH
81023: LD_INT 2
81025: NEG
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 1
81033: PUSH
81034: LD_INT 1
81036: NEG
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 2
81044: PUSH
81045: LD_INT 1
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 2
81054: PUSH
81055: LD_INT 2
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: LD_INT 2
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 0
81074: PUSH
81075: LD_INT 2
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 1
81084: NEG
81085: PUSH
81086: LD_INT 1
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 2
81095: NEG
81096: PUSH
81097: LD_INT 1
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 2
81107: NEG
81108: PUSH
81109: LD_INT 2
81111: NEG
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 2
81119: NEG
81120: PUSH
81121: LD_INT 3
81123: NEG
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 1
81131: NEG
81132: PUSH
81133: LD_INT 3
81135: NEG
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 0
81143: PUSH
81144: LD_INT 3
81146: NEG
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 1
81154: PUSH
81155: LD_INT 2
81157: NEG
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: LD_INT 3
81165: PUSH
81166: LD_INT 2
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 3
81175: PUSH
81176: LD_INT 3
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 2
81185: PUSH
81186: LD_INT 3
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 1
81195: PUSH
81196: LD_INT 3
81198: PUSH
81199: EMPTY
81200: LIST
81201: LIST
81202: PUSH
81203: LD_INT 0
81205: PUSH
81206: LD_INT 3
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 1
81215: NEG
81216: PUSH
81217: LD_INT 2
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 3
81226: NEG
81227: PUSH
81228: LD_INT 2
81230: NEG
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 3
81238: NEG
81239: PUSH
81240: LD_INT 3
81242: NEG
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81279: LD_ADDR_VAR 0 43
81283: PUSH
81284: LD_INT 0
81286: PUSH
81287: LD_INT 0
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: LD_INT 1
81299: NEG
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 1
81307: PUSH
81308: LD_INT 0
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 1
81317: PUSH
81318: LD_INT 1
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 0
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 1
81348: NEG
81349: PUSH
81350: LD_INT 1
81352: NEG
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 1
81360: NEG
81361: PUSH
81362: LD_INT 2
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 0
81372: PUSH
81373: LD_INT 2
81375: NEG
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 1
81383: PUSH
81384: LD_INT 1
81386: NEG
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PUSH
81392: LD_INT 2
81394: PUSH
81395: LD_INT 0
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 2
81404: PUSH
81405: LD_INT 1
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 1
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 0
81424: PUSH
81425: LD_INT 2
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 1
81434: NEG
81435: PUSH
81436: LD_INT 1
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 2
81445: NEG
81446: PUSH
81447: LD_INT 0
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 2
81456: NEG
81457: PUSH
81458: LD_INT 1
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 1
81468: NEG
81469: PUSH
81470: LD_INT 3
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 0
81480: PUSH
81481: LD_INT 3
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: PUSH
81492: LD_INT 2
81494: NEG
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 2
81502: PUSH
81503: LD_INT 1
81505: NEG
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 3
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 3
81523: PUSH
81524: LD_INT 1
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: LD_INT 3
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: LD_INT 0
81543: PUSH
81544: LD_INT 3
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 1
81553: NEG
81554: PUSH
81555: LD_INT 2
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 2
81564: NEG
81565: PUSH
81566: LD_INT 1
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 3
81575: NEG
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 3
81586: NEG
81587: PUSH
81588: LD_INT 1
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81627: LD_ADDR_VAR 0 44
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: LD_INT 0
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 0
81644: PUSH
81645: LD_INT 1
81647: NEG
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 1
81655: PUSH
81656: LD_INT 0
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 1
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 0
81675: PUSH
81676: LD_INT 1
81678: PUSH
81679: EMPTY
81680: LIST
81681: LIST
81682: PUSH
81683: LD_INT 1
81685: NEG
81686: PUSH
81687: LD_INT 0
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 1
81696: NEG
81697: PUSH
81698: LD_INT 1
81700: NEG
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 1
81708: NEG
81709: PUSH
81710: LD_INT 2
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 1
81720: PUSH
81721: LD_INT 1
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 2
81731: PUSH
81732: LD_INT 0
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 2
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 2
81751: PUSH
81752: LD_INT 2
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 1
81761: PUSH
81762: LD_INT 2
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 1
81771: NEG
81772: PUSH
81773: LD_INT 1
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 2
81782: NEG
81783: PUSH
81784: LD_INT 0
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 2
81793: NEG
81794: PUSH
81795: LD_INT 1
81797: NEG
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 2
81805: NEG
81806: PUSH
81807: LD_INT 2
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 2
81817: NEG
81818: PUSH
81819: LD_INT 3
81821: NEG
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 2
81829: PUSH
81830: LD_INT 1
81832: NEG
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 3
81840: PUSH
81841: LD_INT 0
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 3
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 3
81860: PUSH
81861: LD_INT 2
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 3
81870: PUSH
81871: LD_INT 3
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 2
81880: PUSH
81881: LD_INT 3
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 2
81890: NEG
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 3
81901: NEG
81902: PUSH
81903: LD_INT 0
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 3
81912: NEG
81913: PUSH
81914: LD_INT 1
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 3
81924: NEG
81925: PUSH
81926: LD_INT 2
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 3
81936: NEG
81937: PUSH
81938: LD_INT 3
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81977: LD_ADDR_VAR 0 45
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: LD_INT 0
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 0
81994: PUSH
81995: LD_INT 1
81997: NEG
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 1
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: PUSH
82016: LD_INT 1
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 0
82025: PUSH
82026: LD_INT 1
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 1
82035: NEG
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 1
82046: NEG
82047: PUSH
82048: LD_INT 1
82050: NEG
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 1
82058: NEG
82059: PUSH
82060: LD_INT 2
82062: NEG
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 0
82070: PUSH
82071: LD_INT 2
82073: NEG
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 1
82081: PUSH
82082: LD_INT 1
82084: NEG
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 2
82092: PUSH
82093: LD_INT 1
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 2
82102: PUSH
82103: LD_INT 2
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 1
82112: PUSH
82113: LD_INT 2
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: LD_INT 2
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 1
82132: NEG
82133: PUSH
82134: LD_INT 1
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 2
82143: NEG
82144: PUSH
82145: LD_INT 1
82147: NEG
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 2
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: NEG
82168: PUSH
82169: LD_INT 3
82171: NEG
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 1
82179: NEG
82180: PUSH
82181: LD_INT 3
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 0
82191: PUSH
82192: LD_INT 3
82194: NEG
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 1
82202: PUSH
82203: LD_INT 2
82205: NEG
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PUSH
82211: LD_INT 3
82213: PUSH
82214: LD_INT 2
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 3
82223: PUSH
82224: LD_INT 3
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 2
82233: PUSH
82234: LD_INT 3
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 1
82243: PUSH
82244: LD_INT 3
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 0
82253: PUSH
82254: LD_INT 3
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 1
82263: NEG
82264: PUSH
82265: LD_INT 2
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 3
82274: NEG
82275: PUSH
82276: LD_INT 2
82278: NEG
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 3
82286: NEG
82287: PUSH
82288: LD_INT 3
82290: NEG
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82327: LD_ADDR_VAR 0 46
82331: PUSH
82332: LD_INT 0
82334: PUSH
82335: LD_INT 0
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 0
82344: PUSH
82345: LD_INT 1
82347: NEG
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 1
82355: PUSH
82356: LD_INT 0
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 1
82365: PUSH
82366: LD_INT 1
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 0
82375: PUSH
82376: LD_INT 1
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 1
82385: NEG
82386: PUSH
82387: LD_INT 0
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 1
82396: NEG
82397: PUSH
82398: LD_INT 1
82400: NEG
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 1
82408: NEG
82409: PUSH
82410: LD_INT 2
82412: NEG
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 0
82420: PUSH
82421: LD_INT 2
82423: NEG
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 1
82431: PUSH
82432: LD_INT 1
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 2
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 2
82452: PUSH
82453: LD_INT 1
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 1
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 0
82472: PUSH
82473: LD_INT 2
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: LD_INT 1
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 2
82493: NEG
82494: PUSH
82495: LD_INT 0
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 2
82504: NEG
82505: PUSH
82506: LD_INT 1
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: LD_INT 3
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 0
82528: PUSH
82529: LD_INT 3
82531: NEG
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 1
82539: PUSH
82540: LD_INT 2
82542: NEG
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 2
82550: PUSH
82551: LD_INT 1
82553: NEG
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 3
82561: PUSH
82562: LD_INT 0
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 3
82571: PUSH
82572: LD_INT 1
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 1
82581: PUSH
82582: LD_INT 3
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 0
82591: PUSH
82592: LD_INT 3
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 1
82601: NEG
82602: PUSH
82603: LD_INT 2
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 2
82612: NEG
82613: PUSH
82614: LD_INT 1
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 3
82623: NEG
82624: PUSH
82625: LD_INT 0
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 3
82634: NEG
82635: PUSH
82636: LD_INT 1
82638: NEG
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82675: LD_ADDR_VAR 0 47
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: LD_INT 0
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 0
82692: PUSH
82693: LD_INT 1
82695: NEG
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 1
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 1
82713: PUSH
82714: LD_INT 1
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 0
82723: PUSH
82724: LD_INT 1
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 1
82733: NEG
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: LD_INT 1
82748: NEG
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PUSH
82754: LD_INT 1
82756: NEG
82757: PUSH
82758: LD_INT 2
82760: NEG
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 0
82768: PUSH
82769: LD_INT 2
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 1
82779: PUSH
82780: LD_INT 1
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 2
82790: NEG
82791: PUSH
82792: LD_INT 1
82794: NEG
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 2
82802: NEG
82803: PUSH
82804: LD_INT 2
82806: NEG
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
82826: LD_ADDR_VAR 0 48
82830: PUSH
82831: LD_INT 0
82833: PUSH
82834: LD_INT 0
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 0
82843: PUSH
82844: LD_INT 1
82846: NEG
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 1
82854: PUSH
82855: LD_INT 0
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: LD_INT 1
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 0
82874: PUSH
82875: LD_INT 1
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: LD_INT 0
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 1
82895: NEG
82896: PUSH
82897: LD_INT 1
82899: NEG
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 1
82907: NEG
82908: PUSH
82909: LD_INT 2
82911: NEG
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 2
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 2
82951: PUSH
82952: LD_INT 1
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: LIST
82963: LIST
82964: LIST
82965: LIST
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: LIST
82972: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
82973: LD_ADDR_VAR 0 49
82977: PUSH
82978: LD_INT 0
82980: PUSH
82981: LD_INT 0
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 0
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 1
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: LD_INT 1
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 0
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: LD_INT 0
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 1
83042: NEG
83043: PUSH
83044: LD_INT 1
83046: NEG
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 1
83054: PUSH
83055: LD_INT 1
83057: NEG
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 2
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 2
83075: PUSH
83076: LD_INT 1
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 2
83085: PUSH
83086: LD_INT 2
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 1
83095: PUSH
83096: LD_INT 2
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83117: LD_ADDR_VAR 0 50
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: LD_INT 0
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 0
83134: PUSH
83135: LD_INT 1
83137: NEG
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 1
83145: PUSH
83146: LD_INT 0
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: LD_INT 1
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 0
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 1
83175: NEG
83176: PUSH
83177: LD_INT 0
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 1
83186: NEG
83187: PUSH
83188: LD_INT 1
83190: NEG
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: LD_INT 1
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 2
83208: PUSH
83209: LD_INT 2
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PUSH
83216: LD_INT 1
83218: PUSH
83219: LD_INT 2
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 0
83228: PUSH
83229: LD_INT 2
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 1
83238: NEG
83239: PUSH
83240: LD_INT 1
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83261: LD_ADDR_VAR 0 51
83265: PUSH
83266: LD_INT 0
83268: PUSH
83269: LD_INT 0
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 0
83278: PUSH
83279: LD_INT 1
83281: NEG
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 1
83289: PUSH
83290: LD_INT 0
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 1
83299: PUSH
83300: LD_INT 1
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 0
83309: PUSH
83310: LD_INT 1
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 1
83319: NEG
83320: PUSH
83321: LD_INT 0
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 1
83330: NEG
83331: PUSH
83332: LD_INT 1
83334: NEG
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 1
83342: PUSH
83343: LD_INT 2
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 0
83352: PUSH
83353: LD_INT 2
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 1
83362: NEG
83363: PUSH
83364: LD_INT 1
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 2
83373: NEG
83374: PUSH
83375: LD_INT 0
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 2
83384: NEG
83385: PUSH
83386: LD_INT 1
83388: NEG
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83408: LD_ADDR_VAR 0 52
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: LD_INT 0
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 0
83425: PUSH
83426: LD_INT 1
83428: NEG
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 1
83436: PUSH
83437: LD_INT 0
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: LD_INT 1
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 0
83456: PUSH
83457: LD_INT 1
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 1
83466: NEG
83467: PUSH
83468: LD_INT 0
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 1
83477: NEG
83478: PUSH
83479: LD_INT 1
83481: NEG
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 1
83489: NEG
83490: PUSH
83491: LD_INT 2
83493: NEG
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 1
83501: NEG
83502: PUSH
83503: LD_INT 1
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 2
83512: NEG
83513: PUSH
83514: LD_INT 0
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 2
83523: NEG
83524: PUSH
83525: LD_INT 1
83527: NEG
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PUSH
83533: LD_INT 2
83535: NEG
83536: PUSH
83537: LD_INT 2
83539: NEG
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83559: LD_ADDR_VAR 0 53
83563: PUSH
83564: LD_INT 0
83566: PUSH
83567: LD_INT 0
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 0
83576: PUSH
83577: LD_INT 1
83579: NEG
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: LD_INT 0
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 1
83597: PUSH
83598: LD_INT 1
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: LD_INT 1
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: LD_INT 0
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: NEG
83629: PUSH
83630: LD_INT 1
83632: NEG
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: LD_INT 2
83644: NEG
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: LD_INT 2
83655: NEG
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 1
83663: PUSH
83664: LD_INT 1
83666: NEG
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: LD_INT 2
83674: PUSH
83675: LD_INT 0
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: PUSH
83682: LD_INT 2
83684: PUSH
83685: LD_INT 1
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 2
83694: PUSH
83695: LD_INT 2
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 1
83704: PUSH
83705: LD_INT 2
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 0
83714: PUSH
83715: LD_INT 2
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 1
83724: NEG
83725: PUSH
83726: LD_INT 1
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 2
83735: NEG
83736: PUSH
83737: LD_INT 0
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: LD_INT 2
83746: NEG
83747: PUSH
83748: LD_INT 1
83750: NEG
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 2
83758: NEG
83759: PUSH
83760: LD_INT 2
83762: NEG
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83789: LD_ADDR_VAR 0 54
83793: PUSH
83794: LD_INT 0
83796: PUSH
83797: LD_INT 0
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 0
83806: PUSH
83807: LD_INT 1
83809: NEG
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 1
83817: PUSH
83818: LD_INT 0
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: LD_INT 1
83827: PUSH
83828: LD_INT 1
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 0
83837: PUSH
83838: LD_INT 1
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 1
83847: NEG
83848: PUSH
83849: LD_INT 0
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 1
83858: NEG
83859: PUSH
83860: LD_INT 1
83862: NEG
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: LD_INT 2
83874: NEG
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: LD_INT 2
83885: NEG
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 1
83893: PUSH
83894: LD_INT 1
83896: NEG
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 2
83904: PUSH
83905: LD_INT 0
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 2
83914: PUSH
83915: LD_INT 1
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 2
83924: PUSH
83925: LD_INT 2
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: LD_INT 1
83934: PUSH
83935: LD_INT 2
83937: PUSH
83938: EMPTY
83939: LIST
83940: LIST
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: LD_INT 2
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: PUSH
83952: LD_INT 1
83954: NEG
83955: PUSH
83956: LD_INT 1
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 2
83965: NEG
83966: PUSH
83967: LD_INT 0
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 2
83976: NEG
83977: PUSH
83978: LD_INT 1
83980: NEG
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: LD_INT 2
83992: NEG
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84019: LD_ADDR_VAR 0 55
84023: PUSH
84024: LD_INT 0
84026: PUSH
84027: LD_INT 0
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: LD_INT 1
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 0
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 1
84057: PUSH
84058: LD_INT 1
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 0
84067: PUSH
84068: LD_INT 1
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 1
84077: NEG
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: NEG
84089: PUSH
84090: LD_INT 1
84092: NEG
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: LD_INT 1
84100: NEG
84101: PUSH
84102: LD_INT 2
84104: NEG
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: LD_INT 2
84115: NEG
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 1
84123: PUSH
84124: LD_INT 1
84126: NEG
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 2
84134: PUSH
84135: LD_INT 0
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 2
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 2
84154: PUSH
84155: LD_INT 2
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 1
84164: PUSH
84165: LD_INT 2
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: LD_INT 0
84174: PUSH
84175: LD_INT 2
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 1
84184: NEG
84185: PUSH
84186: LD_INT 1
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 2
84195: NEG
84196: PUSH
84197: LD_INT 0
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 2
84206: NEG
84207: PUSH
84208: LD_INT 1
84210: NEG
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 2
84218: NEG
84219: PUSH
84220: LD_INT 2
84222: NEG
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84249: LD_ADDR_VAR 0 56
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: LD_INT 0
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 1
84277: PUSH
84278: LD_INT 0
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 1
84287: PUSH
84288: LD_INT 1
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 0
84297: PUSH
84298: LD_INT 1
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 1
84307: NEG
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: NEG
84331: PUSH
84332: LD_INT 2
84334: NEG
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: LD_INT 2
84345: NEG
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: PUSH
84354: LD_INT 1
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 2
84364: PUSH
84365: LD_INT 0
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 2
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 2
84384: PUSH
84385: LD_INT 2
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: PUSH
84395: LD_INT 2
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 0
84404: PUSH
84405: LD_INT 2
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: LD_INT 1
84414: NEG
84415: PUSH
84416: LD_INT 1
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: LD_INT 2
84425: NEG
84426: PUSH
84427: LD_INT 0
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 2
84436: NEG
84437: PUSH
84438: LD_INT 1
84440: NEG
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 2
84448: NEG
84449: PUSH
84450: LD_INT 2
84452: NEG
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84479: LD_ADDR_VAR 0 57
84483: PUSH
84484: LD_INT 0
84486: PUSH
84487: LD_INT 0
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: LD_INT 1
84499: NEG
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 1
84507: PUSH
84508: LD_INT 0
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 1
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 1
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: NEG
84538: PUSH
84539: LD_INT 0
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: NEG
84549: PUSH
84550: LD_INT 1
84552: NEG
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 1
84560: NEG
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: PUSH
84570: LD_INT 0
84572: PUSH
84573: LD_INT 2
84575: NEG
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 1
84583: PUSH
84584: LD_INT 1
84586: NEG
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 2
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 2
84604: PUSH
84605: LD_INT 1
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 2
84614: PUSH
84615: LD_INT 2
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: PUSH
84622: LD_INT 1
84624: PUSH
84625: LD_INT 2
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: LD_INT 2
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: PUSH
84642: LD_INT 1
84644: NEG
84645: PUSH
84646: LD_INT 1
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 2
84655: NEG
84656: PUSH
84657: LD_INT 0
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 2
84666: NEG
84667: PUSH
84668: LD_INT 1
84670: NEG
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 2
84678: NEG
84679: PUSH
84680: LD_INT 2
84682: NEG
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84709: LD_ADDR_VAR 0 58
84713: PUSH
84714: LD_INT 0
84716: PUSH
84717: LD_INT 0
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 0
84726: PUSH
84727: LD_INT 1
84729: NEG
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PUSH
84735: LD_INT 1
84737: PUSH
84738: LD_INT 0
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 1
84747: PUSH
84748: LD_INT 1
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 0
84757: PUSH
84758: LD_INT 1
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 1
84767: NEG
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 1
84778: NEG
84779: PUSH
84780: LD_INT 1
84782: NEG
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 1
84790: NEG
84791: PUSH
84792: LD_INT 2
84794: NEG
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 0
84802: PUSH
84803: LD_INT 2
84805: NEG
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 1
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 2
84824: PUSH
84825: LD_INT 0
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PUSH
84832: LD_INT 2
84834: PUSH
84835: LD_INT 1
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 2
84844: PUSH
84845: LD_INT 2
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 1
84854: PUSH
84855: LD_INT 2
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: PUSH
84862: LD_INT 0
84864: PUSH
84865: LD_INT 2
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 1
84874: NEG
84875: PUSH
84876: LD_INT 1
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 2
84885: NEG
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 2
84896: NEG
84897: PUSH
84898: LD_INT 1
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 2
84908: NEG
84909: PUSH
84910: LD_INT 2
84912: NEG
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
84939: LD_ADDR_VAR 0 59
84943: PUSH
84944: LD_INT 0
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 1
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: NEG
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85027: LD_ADDR_VAR 0 60
85031: PUSH
85032: LD_INT 0
85034: PUSH
85035: LD_INT 0
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: PUSH
85042: LD_INT 0
85044: PUSH
85045: LD_INT 1
85047: NEG
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 1
85055: PUSH
85056: LD_INT 0
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PUSH
85063: LD_INT 1
85065: PUSH
85066: LD_INT 1
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: LD_INT 1
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: LD_INT 0
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: NEG
85097: PUSH
85098: LD_INT 1
85100: NEG
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85115: LD_ADDR_VAR 0 61
85119: PUSH
85120: LD_INT 0
85122: PUSH
85123: LD_INT 0
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 1
85143: PUSH
85144: LD_INT 0
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: LD_INT 1
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 0
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: LD_INT 0
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 1
85184: NEG
85185: PUSH
85186: LD_INT 1
85188: NEG
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85203: LD_ADDR_VAR 0 62
85207: PUSH
85208: LD_INT 0
85210: PUSH
85211: LD_INT 0
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: LD_INT 1
85223: NEG
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 1
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 1
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 0
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 1
85261: NEG
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: LD_INT 1
85272: NEG
85273: PUSH
85274: LD_INT 1
85276: NEG
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85291: LD_ADDR_VAR 0 63
85295: PUSH
85296: LD_INT 0
85298: PUSH
85299: LD_INT 0
85301: PUSH
85302: EMPTY
85303: LIST
85304: LIST
85305: PUSH
85306: LD_INT 0
85308: PUSH
85309: LD_INT 1
85311: NEG
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: PUSH
85317: LD_INT 1
85319: PUSH
85320: LD_INT 0
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 1
85329: PUSH
85330: LD_INT 1
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PUSH
85337: LD_INT 0
85339: PUSH
85340: LD_INT 1
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: PUSH
85347: LD_INT 1
85349: NEG
85350: PUSH
85351: LD_INT 0
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 1
85360: NEG
85361: PUSH
85362: LD_INT 1
85364: NEG
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85379: LD_ADDR_VAR 0 64
85383: PUSH
85384: LD_INT 0
85386: PUSH
85387: LD_INT 0
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: LD_INT 1
85399: NEG
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 1
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: PUSH
85415: LD_INT 1
85417: PUSH
85418: LD_INT 1
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: PUSH
85425: LD_INT 0
85427: PUSH
85428: LD_INT 1
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: LD_INT 0
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 1
85448: NEG
85449: PUSH
85450: LD_INT 1
85452: NEG
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: ST_TO_ADDR
// end ; 1 :
85467: GO 91364
85469: LD_INT 1
85471: DOUBLE
85472: EQUAL
85473: IFTRUE 85477
85475: GO 88100
85477: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85478: LD_ADDR_VAR 0 11
85482: PUSH
85483: LD_INT 1
85485: NEG
85486: PUSH
85487: LD_INT 3
85489: NEG
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 0
85497: PUSH
85498: LD_INT 3
85500: NEG
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 1
85508: PUSH
85509: LD_INT 2
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: LIST
85521: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85522: LD_ADDR_VAR 0 12
85526: PUSH
85527: LD_INT 2
85529: PUSH
85530: LD_INT 1
85532: NEG
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 3
85540: PUSH
85541: LD_INT 0
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 3
85550: PUSH
85551: LD_INT 1
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: LIST
85562: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85563: LD_ADDR_VAR 0 13
85567: PUSH
85568: LD_INT 3
85570: PUSH
85571: LD_INT 2
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 3
85580: PUSH
85581: LD_INT 3
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PUSH
85588: LD_INT 2
85590: PUSH
85591: LD_INT 3
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: LIST
85602: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85603: LD_ADDR_VAR 0 14
85607: PUSH
85608: LD_INT 1
85610: PUSH
85611: LD_INT 3
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: LD_INT 3
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 1
85630: NEG
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: LIST
85643: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85644: LD_ADDR_VAR 0 15
85648: PUSH
85649: LD_INT 2
85651: NEG
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 3
85662: NEG
85663: PUSH
85664: LD_INT 0
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 3
85673: NEG
85674: PUSH
85675: LD_INT 1
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: LIST
85687: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85688: LD_ADDR_VAR 0 16
85692: PUSH
85693: LD_INT 2
85695: NEG
85696: PUSH
85697: LD_INT 3
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 3
85707: NEG
85708: PUSH
85709: LD_INT 2
85711: NEG
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 3
85719: NEG
85720: PUSH
85721: LD_INT 3
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: LIST
85733: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85734: LD_ADDR_VAR 0 17
85738: PUSH
85739: LD_INT 1
85741: NEG
85742: PUSH
85743: LD_INT 3
85745: NEG
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 0
85753: PUSH
85754: LD_INT 3
85756: NEG
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 1
85764: PUSH
85765: LD_INT 2
85767: NEG
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: LIST
85777: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85778: LD_ADDR_VAR 0 18
85782: PUSH
85783: LD_INT 2
85785: PUSH
85786: LD_INT 1
85788: NEG
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: PUSH
85794: LD_INT 3
85796: PUSH
85797: LD_INT 0
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 3
85806: PUSH
85807: LD_INT 1
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: LIST
85818: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85819: LD_ADDR_VAR 0 19
85823: PUSH
85824: LD_INT 3
85826: PUSH
85827: LD_INT 2
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 3
85836: PUSH
85837: LD_INT 3
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 2
85846: PUSH
85847: LD_INT 3
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: LIST
85858: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85859: LD_ADDR_VAR 0 20
85863: PUSH
85864: LD_INT 1
85866: PUSH
85867: LD_INT 3
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: LD_INT 0
85876: PUSH
85877: LD_INT 3
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: PUSH
85888: LD_INT 2
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: LIST
85899: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85900: LD_ADDR_VAR 0 21
85904: PUSH
85905: LD_INT 2
85907: NEG
85908: PUSH
85909: LD_INT 1
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: LD_INT 3
85918: NEG
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 3
85929: NEG
85930: PUSH
85931: LD_INT 1
85933: NEG
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: LIST
85943: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85944: LD_ADDR_VAR 0 22
85948: PUSH
85949: LD_INT 2
85951: NEG
85952: PUSH
85953: LD_INT 3
85955: NEG
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 3
85963: NEG
85964: PUSH
85965: LD_INT 2
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: LD_INT 3
85975: NEG
85976: PUSH
85977: LD_INT 3
85979: NEG
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: LIST
85989: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
85990: LD_ADDR_VAR 0 23
85994: PUSH
85995: LD_INT 0
85997: PUSH
85998: LD_INT 3
86000: NEG
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 1
86008: NEG
86009: PUSH
86010: LD_INT 4
86012: NEG
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 1
86020: PUSH
86021: LD_INT 3
86023: NEG
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: LIST
86033: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
86034: LD_ADDR_VAR 0 24
86038: PUSH
86039: LD_INT 3
86041: PUSH
86042: LD_INT 0
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 3
86051: PUSH
86052: LD_INT 1
86054: NEG
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 4
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: LIST
86074: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
86075: LD_ADDR_VAR 0 25
86079: PUSH
86080: LD_INT 3
86082: PUSH
86083: LD_INT 3
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 4
86092: PUSH
86093: LD_INT 3
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 3
86102: PUSH
86103: LD_INT 4
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: LIST
86114: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
86115: LD_ADDR_VAR 0 26
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: LD_INT 3
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: LD_INT 4
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 1
86142: NEG
86143: PUSH
86144: LD_INT 3
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: LIST
86155: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
86156: LD_ADDR_VAR 0 27
86160: PUSH
86161: LD_INT 3
86163: NEG
86164: PUSH
86165: LD_INT 0
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 3
86174: NEG
86175: PUSH
86176: LD_INT 1
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: LD_INT 4
86185: NEG
86186: PUSH
86187: LD_INT 1
86189: NEG
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: LIST
86199: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
86200: LD_ADDR_VAR 0 28
86204: PUSH
86205: LD_INT 3
86207: NEG
86208: PUSH
86209: LD_INT 3
86211: NEG
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 3
86219: NEG
86220: PUSH
86221: LD_INT 4
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 4
86231: NEG
86232: PUSH
86233: LD_INT 3
86235: NEG
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: LIST
86245: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
86246: LD_ADDR_VAR 0 29
86250: PUSH
86251: LD_INT 1
86253: NEG
86254: PUSH
86255: LD_INT 3
86257: NEG
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 0
86265: PUSH
86266: LD_INT 3
86268: NEG
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 1
86276: PUSH
86277: LD_INT 2
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 1
86287: NEG
86288: PUSH
86289: LD_INT 4
86291: NEG
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 0
86299: PUSH
86300: LD_INT 4
86302: NEG
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 1
86310: PUSH
86311: LD_INT 3
86313: NEG
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 1
86321: NEG
86322: PUSH
86323: LD_INT 5
86325: NEG
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 0
86333: PUSH
86334: LD_INT 5
86336: NEG
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 1
86344: PUSH
86345: LD_INT 4
86347: NEG
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 1
86355: NEG
86356: PUSH
86357: LD_INT 6
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 0
86367: PUSH
86368: LD_INT 6
86370: NEG
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 1
86378: PUSH
86379: LD_INT 5
86381: NEG
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
86401: LD_ADDR_VAR 0 30
86405: PUSH
86406: LD_INT 2
86408: PUSH
86409: LD_INT 1
86411: NEG
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 3
86419: PUSH
86420: LD_INT 0
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PUSH
86427: LD_INT 3
86429: PUSH
86430: LD_INT 1
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: LD_INT 3
86439: PUSH
86440: LD_INT 1
86442: NEG
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 4
86450: PUSH
86451: LD_INT 0
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 4
86460: PUSH
86461: LD_INT 1
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 4
86470: PUSH
86471: LD_INT 1
86473: NEG
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 5
86481: PUSH
86482: LD_INT 0
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 5
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 5
86501: PUSH
86502: LD_INT 1
86504: NEG
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 6
86512: PUSH
86513: LD_INT 0
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 6
86522: PUSH
86523: LD_INT 1
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: EMPTY
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
86544: LD_ADDR_VAR 0 31
86548: PUSH
86549: LD_INT 3
86551: PUSH
86552: LD_INT 2
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 3
86561: PUSH
86562: LD_INT 3
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 2
86571: PUSH
86572: LD_INT 3
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 4
86581: PUSH
86582: LD_INT 3
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 4
86591: PUSH
86592: LD_INT 4
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 3
86601: PUSH
86602: LD_INT 4
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 5
86611: PUSH
86612: LD_INT 4
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: LD_INT 5
86621: PUSH
86622: LD_INT 5
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 4
86631: PUSH
86632: LD_INT 5
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 6
86641: PUSH
86642: LD_INT 5
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 6
86651: PUSH
86652: LD_INT 6
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 5
86661: PUSH
86662: LD_INT 6
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
86683: LD_ADDR_VAR 0 32
86687: PUSH
86688: LD_INT 1
86690: PUSH
86691: LD_INT 3
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 0
86700: PUSH
86701: LD_INT 3
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: LD_INT 2
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 1
86721: PUSH
86722: LD_INT 4
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 0
86731: PUSH
86732: LD_INT 4
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PUSH
86739: LD_INT 1
86741: NEG
86742: PUSH
86743: LD_INT 3
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: PUSH
86750: LD_INT 1
86752: PUSH
86753: LD_INT 5
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: PUSH
86760: LD_INT 0
86762: PUSH
86763: LD_INT 5
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: PUSH
86770: LD_INT 1
86772: NEG
86773: PUSH
86774: LD_INT 4
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: LD_INT 6
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 0
86793: PUSH
86794: LD_INT 6
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 1
86803: NEG
86804: PUSH
86805: LD_INT 5
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: LIST
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
86826: LD_ADDR_VAR 0 33
86830: PUSH
86831: LD_INT 2
86833: NEG
86834: PUSH
86835: LD_INT 1
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: PUSH
86842: LD_INT 3
86844: NEG
86845: PUSH
86846: LD_INT 0
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PUSH
86853: LD_INT 3
86855: NEG
86856: PUSH
86857: LD_INT 1
86859: NEG
86860: PUSH
86861: EMPTY
86862: LIST
86863: LIST
86864: PUSH
86865: LD_INT 3
86867: NEG
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 4
86878: NEG
86879: PUSH
86880: LD_INT 0
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PUSH
86887: LD_INT 4
86889: NEG
86890: PUSH
86891: LD_INT 1
86893: NEG
86894: PUSH
86895: EMPTY
86896: LIST
86897: LIST
86898: PUSH
86899: LD_INT 4
86901: NEG
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 5
86912: NEG
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 5
86923: NEG
86924: PUSH
86925: LD_INT 1
86927: NEG
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 5
86935: NEG
86936: PUSH
86937: LD_INT 1
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 6
86946: NEG
86947: PUSH
86948: LD_INT 0
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 6
86957: NEG
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
86981: LD_ADDR_VAR 0 34
86985: PUSH
86986: LD_INT 2
86988: NEG
86989: PUSH
86990: LD_INT 3
86992: NEG
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 3
87000: NEG
87001: PUSH
87002: LD_INT 2
87004: NEG
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: LD_INT 3
87012: NEG
87013: PUSH
87014: LD_INT 3
87016: NEG
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 3
87024: NEG
87025: PUSH
87026: LD_INT 4
87028: NEG
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 4
87036: NEG
87037: PUSH
87038: LD_INT 3
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 4
87048: NEG
87049: PUSH
87050: LD_INT 4
87052: NEG
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 4
87060: NEG
87061: PUSH
87062: LD_INT 5
87064: NEG
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 5
87072: NEG
87073: PUSH
87074: LD_INT 4
87076: NEG
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 5
87084: NEG
87085: PUSH
87086: LD_INT 5
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 5
87096: NEG
87097: PUSH
87098: LD_INT 6
87100: NEG
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: LD_INT 6
87108: NEG
87109: PUSH
87110: LD_INT 5
87112: NEG
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: PUSH
87118: LD_INT 6
87120: NEG
87121: PUSH
87122: LD_INT 6
87124: NEG
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: EMPTY
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
87144: LD_ADDR_VAR 0 41
87148: PUSH
87149: LD_INT 0
87151: PUSH
87152: LD_INT 2
87154: NEG
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 1
87162: NEG
87163: PUSH
87164: LD_INT 3
87166: NEG
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 1
87174: PUSH
87175: LD_INT 2
87177: NEG
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: LIST
87187: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
87188: LD_ADDR_VAR 0 42
87192: PUSH
87193: LD_INT 2
87195: PUSH
87196: LD_INT 0
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 2
87205: PUSH
87206: LD_INT 1
87208: NEG
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 3
87216: PUSH
87217: LD_INT 1
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: LIST
87228: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
87229: LD_ADDR_VAR 0 43
87233: PUSH
87234: LD_INT 2
87236: PUSH
87237: LD_INT 2
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 3
87246: PUSH
87247: LD_INT 2
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 2
87256: PUSH
87257: LD_INT 3
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: LIST
87268: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
87269: LD_ADDR_VAR 0 44
87273: PUSH
87274: LD_INT 0
87276: PUSH
87277: LD_INT 2
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 1
87286: PUSH
87287: LD_INT 3
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 1
87296: NEG
87297: PUSH
87298: LD_INT 2
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: LIST
87309: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87310: LD_ADDR_VAR 0 45
87314: PUSH
87315: LD_INT 2
87317: NEG
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 2
87328: NEG
87329: PUSH
87330: LD_INT 1
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 3
87339: NEG
87340: PUSH
87341: LD_INT 1
87343: NEG
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: LIST
87353: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
87354: LD_ADDR_VAR 0 46
87358: PUSH
87359: LD_INT 2
87361: NEG
87362: PUSH
87363: LD_INT 2
87365: NEG
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 2
87373: NEG
87374: PUSH
87375: LD_INT 3
87377: NEG
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 3
87385: NEG
87386: PUSH
87387: LD_INT 2
87389: NEG
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: LIST
87399: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
87400: LD_ADDR_VAR 0 47
87404: PUSH
87405: LD_INT 2
87407: NEG
87408: PUSH
87409: LD_INT 3
87411: NEG
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: LD_INT 3
87423: NEG
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87433: LD_ADDR_VAR 0 48
87437: PUSH
87438: LD_INT 1
87440: PUSH
87441: LD_INT 2
87443: NEG
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 2
87451: PUSH
87452: LD_INT 1
87454: NEG
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
87464: LD_ADDR_VAR 0 49
87468: PUSH
87469: LD_INT 3
87471: PUSH
87472: LD_INT 1
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 3
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
87493: LD_ADDR_VAR 0 50
87497: PUSH
87498: LD_INT 2
87500: PUSH
87501: LD_INT 3
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 1
87510: PUSH
87511: LD_INT 3
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87522: LD_ADDR_VAR 0 51
87526: PUSH
87527: LD_INT 1
87529: NEG
87530: PUSH
87531: LD_INT 2
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 2
87540: NEG
87541: PUSH
87542: LD_INT 1
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87553: LD_ADDR_VAR 0 52
87557: PUSH
87558: LD_INT 3
87560: NEG
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 3
87572: NEG
87573: PUSH
87574: LD_INT 2
87576: NEG
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
87586: LD_ADDR_VAR 0 53
87590: PUSH
87591: LD_INT 1
87593: NEG
87594: PUSH
87595: LD_INT 3
87597: NEG
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 0
87605: PUSH
87606: LD_INT 3
87608: NEG
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PUSH
87614: LD_INT 1
87616: PUSH
87617: LD_INT 2
87619: NEG
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: LIST
87629: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87630: LD_ADDR_VAR 0 54
87634: PUSH
87635: LD_INT 2
87637: PUSH
87638: LD_INT 1
87640: NEG
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 3
87648: PUSH
87649: LD_INT 0
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 3
87658: PUSH
87659: LD_INT 1
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: LIST
87670: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
87671: LD_ADDR_VAR 0 55
87675: PUSH
87676: LD_INT 3
87678: PUSH
87679: LD_INT 2
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 3
87688: PUSH
87689: LD_INT 3
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 2
87698: PUSH
87699: LD_INT 3
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: LIST
87710: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
87711: LD_ADDR_VAR 0 56
87715: PUSH
87716: LD_INT 1
87718: PUSH
87719: LD_INT 3
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 0
87728: PUSH
87729: LD_INT 3
87731: PUSH
87732: EMPTY
87733: LIST
87734: LIST
87735: PUSH
87736: LD_INT 1
87738: NEG
87739: PUSH
87740: LD_INT 2
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: LIST
87751: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87752: LD_ADDR_VAR 0 57
87756: PUSH
87757: LD_INT 2
87759: NEG
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 3
87770: NEG
87771: PUSH
87772: LD_INT 0
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 3
87781: NEG
87782: PUSH
87783: LD_INT 1
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: LIST
87795: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87796: LD_ADDR_VAR 0 58
87800: PUSH
87801: LD_INT 2
87803: NEG
87804: PUSH
87805: LD_INT 3
87807: NEG
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 3
87815: NEG
87816: PUSH
87817: LD_INT 2
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 3
87827: NEG
87828: PUSH
87829: LD_INT 3
87831: NEG
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: LIST
87841: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
87842: LD_ADDR_VAR 0 59
87846: PUSH
87847: LD_INT 1
87849: NEG
87850: PUSH
87851: LD_INT 2
87853: NEG
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: LD_INT 2
87864: NEG
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PUSH
87870: LD_INT 1
87872: PUSH
87873: LD_INT 1
87875: NEG
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: LIST
87885: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87886: LD_ADDR_VAR 0 60
87890: PUSH
87891: LD_INT 1
87893: PUSH
87894: LD_INT 1
87896: NEG
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 2
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 2
87914: PUSH
87915: LD_INT 1
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: LIST
87926: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87927: LD_ADDR_VAR 0 61
87931: PUSH
87932: LD_INT 2
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 2
87944: PUSH
87945: LD_INT 2
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 1
87954: PUSH
87955: LD_INT 2
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: LIST
87966: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87967: LD_ADDR_VAR 0 62
87971: PUSH
87972: LD_INT 1
87974: PUSH
87975: LD_INT 2
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: LD_INT 2
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 1
87994: NEG
87995: PUSH
87996: LD_INT 1
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: LIST
88007: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88008: LD_ADDR_VAR 0 63
88012: PUSH
88013: LD_INT 1
88015: NEG
88016: PUSH
88017: LD_INT 1
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 2
88026: NEG
88027: PUSH
88028: LD_INT 0
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 2
88037: NEG
88038: PUSH
88039: LD_INT 1
88041: NEG
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: LIST
88051: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88052: LD_ADDR_VAR 0 64
88056: PUSH
88057: LD_INT 1
88059: NEG
88060: PUSH
88061: LD_INT 2
88063: NEG
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 2
88071: NEG
88072: PUSH
88073: LD_INT 1
88075: NEG
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 2
88083: NEG
88084: PUSH
88085: LD_INT 2
88087: NEG
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: LIST
88097: ST_TO_ADDR
// end ; 2 :
88098: GO 91364
88100: LD_INT 2
88102: DOUBLE
88103: EQUAL
88104: IFTRUE 88108
88106: GO 91363
88108: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
88109: LD_ADDR_VAR 0 29
88113: PUSH
88114: LD_INT 4
88116: PUSH
88117: LD_INT 0
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 4
88126: PUSH
88127: LD_INT 1
88129: NEG
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 5
88137: PUSH
88138: LD_INT 0
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 5
88147: PUSH
88148: LD_INT 1
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PUSH
88155: LD_INT 4
88157: PUSH
88158: LD_INT 1
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: PUSH
88165: LD_INT 3
88167: PUSH
88168: LD_INT 0
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 3
88177: PUSH
88178: LD_INT 1
88180: NEG
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 3
88188: PUSH
88189: LD_INT 2
88191: NEG
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: LD_INT 5
88199: PUSH
88200: LD_INT 2
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 3
88209: PUSH
88210: LD_INT 3
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 3
88219: PUSH
88220: LD_INT 2
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 4
88229: PUSH
88230: LD_INT 3
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 4
88239: PUSH
88240: LD_INT 4
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 3
88249: PUSH
88250: LD_INT 4
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 2
88259: PUSH
88260: LD_INT 3
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 2
88269: PUSH
88270: LD_INT 2
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 4
88279: PUSH
88280: LD_INT 2
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 2
88289: PUSH
88290: LD_INT 4
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: LD_INT 0
88299: PUSH
88300: LD_INT 4
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 0
88309: PUSH
88310: LD_INT 3
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 1
88319: PUSH
88320: LD_INT 4
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 1
88329: PUSH
88330: LD_INT 5
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 0
88339: PUSH
88340: LD_INT 5
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 1
88349: NEG
88350: PUSH
88351: LD_INT 4
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 1
88360: NEG
88361: PUSH
88362: LD_INT 3
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: PUSH
88369: LD_INT 2
88371: PUSH
88372: LD_INT 5
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 2
88381: NEG
88382: PUSH
88383: LD_INT 3
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 3
88392: NEG
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 3
88403: NEG
88404: PUSH
88405: LD_INT 1
88407: NEG
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: PUSH
88413: LD_INT 2
88415: NEG
88416: PUSH
88417: LD_INT 0
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PUSH
88424: LD_INT 2
88426: NEG
88427: PUSH
88428: LD_INT 1
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 3
88437: NEG
88438: PUSH
88439: LD_INT 1
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 4
88448: NEG
88449: PUSH
88450: LD_INT 0
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 4
88459: NEG
88460: PUSH
88461: LD_INT 1
88463: NEG
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: LD_INT 4
88471: NEG
88472: PUSH
88473: LD_INT 2
88475: NEG
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 2
88483: NEG
88484: PUSH
88485: LD_INT 2
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 4
88494: NEG
88495: PUSH
88496: LD_INT 4
88498: NEG
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 4
88506: NEG
88507: PUSH
88508: LD_INT 5
88510: NEG
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 3
88518: NEG
88519: PUSH
88520: LD_INT 4
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 3
88530: NEG
88531: PUSH
88532: LD_INT 3
88534: NEG
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 4
88542: NEG
88543: PUSH
88544: LD_INT 3
88546: NEG
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 5
88554: NEG
88555: PUSH
88556: LD_INT 4
88558: NEG
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 5
88566: NEG
88567: PUSH
88568: LD_INT 5
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 3
88578: NEG
88579: PUSH
88580: LD_INT 5
88582: NEG
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 5
88590: NEG
88591: PUSH
88592: LD_INT 3
88594: NEG
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
88647: LD_ADDR_VAR 0 30
88651: PUSH
88652: LD_INT 4
88654: PUSH
88655: LD_INT 4
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: LD_INT 4
88664: PUSH
88665: LD_INT 3
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 5
88674: PUSH
88675: LD_INT 4
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: PUSH
88682: LD_INT 5
88684: PUSH
88685: LD_INT 5
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 4
88694: PUSH
88695: LD_INT 5
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: PUSH
88702: LD_INT 3
88704: PUSH
88705: LD_INT 4
88707: PUSH
88708: EMPTY
88709: LIST
88710: LIST
88711: PUSH
88712: LD_INT 3
88714: PUSH
88715: LD_INT 3
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 5
88724: PUSH
88725: LD_INT 3
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 3
88734: PUSH
88735: LD_INT 5
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 3
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 0
88754: PUSH
88755: LD_INT 2
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 1
88764: PUSH
88765: LD_INT 3
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 1
88774: PUSH
88775: LD_INT 4
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 0
88784: PUSH
88785: LD_INT 4
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 1
88794: NEG
88795: PUSH
88796: LD_INT 3
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 1
88805: NEG
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 2
88816: PUSH
88817: LD_INT 4
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 2
88826: NEG
88827: PUSH
88828: LD_INT 2
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 4
88837: NEG
88838: PUSH
88839: LD_INT 0
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: LD_INT 4
88848: NEG
88849: PUSH
88850: LD_INT 1
88852: NEG
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 3
88860: NEG
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 3
88871: NEG
88872: PUSH
88873: LD_INT 1
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 4
88882: NEG
88883: PUSH
88884: LD_INT 1
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 5
88893: NEG
88894: PUSH
88895: LD_INT 0
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: LD_INT 5
88904: NEG
88905: PUSH
88906: LD_INT 1
88908: NEG
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 5
88916: NEG
88917: PUSH
88918: LD_INT 2
88920: NEG
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 3
88928: NEG
88929: PUSH
88930: LD_INT 2
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: PUSH
88937: LD_INT 3
88939: NEG
88940: PUSH
88941: LD_INT 3
88943: NEG
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 3
88951: NEG
88952: PUSH
88953: LD_INT 4
88955: NEG
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 2
88963: NEG
88964: PUSH
88965: LD_INT 3
88967: NEG
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 2
88975: NEG
88976: PUSH
88977: LD_INT 2
88979: NEG
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 3
88987: NEG
88988: PUSH
88989: LD_INT 2
88991: NEG
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 4
88999: NEG
89000: PUSH
89001: LD_INT 3
89003: NEG
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 4
89011: NEG
89012: PUSH
89013: LD_INT 4
89015: NEG
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 2
89023: NEG
89024: PUSH
89025: LD_INT 4
89027: NEG
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: PUSH
89033: LD_INT 4
89035: NEG
89036: PUSH
89037: LD_INT 2
89039: NEG
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: PUSH
89045: LD_INT 0
89047: PUSH
89048: LD_INT 4
89050: NEG
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: LD_INT 5
89061: NEG
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 1
89069: PUSH
89070: LD_INT 4
89072: NEG
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 1
89080: PUSH
89081: LD_INT 3
89083: NEG
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 0
89091: PUSH
89092: LD_INT 3
89094: NEG
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 1
89102: NEG
89103: PUSH
89104: LD_INT 4
89106: NEG
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 1
89114: NEG
89115: PUSH
89116: LD_INT 5
89118: NEG
89119: PUSH
89120: EMPTY
89121: LIST
89122: LIST
89123: PUSH
89124: LD_INT 2
89126: PUSH
89127: LD_INT 3
89129: NEG
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 2
89137: NEG
89138: PUSH
89139: LD_INT 5
89141: NEG
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
89194: LD_ADDR_VAR 0 31
89198: PUSH
89199: LD_INT 0
89201: PUSH
89202: LD_INT 4
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: PUSH
89209: LD_INT 0
89211: PUSH
89212: LD_INT 3
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 1
89221: PUSH
89222: LD_INT 4
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 1
89231: PUSH
89232: LD_INT 5
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 0
89241: PUSH
89242: LD_INT 5
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: PUSH
89249: LD_INT 1
89251: NEG
89252: PUSH
89253: LD_INT 4
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 1
89262: NEG
89263: PUSH
89264: LD_INT 3
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 2
89273: PUSH
89274: LD_INT 5
89276: PUSH
89277: EMPTY
89278: LIST
89279: LIST
89280: PUSH
89281: LD_INT 2
89283: NEG
89284: PUSH
89285: LD_INT 3
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 3
89294: NEG
89295: PUSH
89296: LD_INT 0
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 3
89305: NEG
89306: PUSH
89307: LD_INT 1
89309: NEG
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PUSH
89315: LD_INT 2
89317: NEG
89318: PUSH
89319: LD_INT 0
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: LD_INT 1
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 3
89339: NEG
89340: PUSH
89341: LD_INT 1
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 4
89350: NEG
89351: PUSH
89352: LD_INT 0
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 4
89361: NEG
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 4
89373: NEG
89374: PUSH
89375: LD_INT 2
89377: NEG
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 2
89385: NEG
89386: PUSH
89387: LD_INT 2
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 4
89396: NEG
89397: PUSH
89398: LD_INT 4
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 4
89408: NEG
89409: PUSH
89410: LD_INT 5
89412: NEG
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 3
89420: NEG
89421: PUSH
89422: LD_INT 4
89424: NEG
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 3
89432: NEG
89433: PUSH
89434: LD_INT 3
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 4
89444: NEG
89445: PUSH
89446: LD_INT 3
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 5
89456: NEG
89457: PUSH
89458: LD_INT 4
89460: NEG
89461: PUSH
89462: EMPTY
89463: LIST
89464: LIST
89465: PUSH
89466: LD_INT 5
89468: NEG
89469: PUSH
89470: LD_INT 5
89472: NEG
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 3
89480: NEG
89481: PUSH
89482: LD_INT 5
89484: NEG
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 5
89492: NEG
89493: PUSH
89494: LD_INT 3
89496: NEG
89497: PUSH
89498: EMPTY
89499: LIST
89500: LIST
89501: PUSH
89502: LD_INT 0
89504: PUSH
89505: LD_INT 3
89507: NEG
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: PUSH
89513: LD_INT 0
89515: PUSH
89516: LD_INT 4
89518: NEG
89519: PUSH
89520: EMPTY
89521: LIST
89522: LIST
89523: PUSH
89524: LD_INT 1
89526: PUSH
89527: LD_INT 3
89529: NEG
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: LD_INT 2
89540: NEG
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PUSH
89546: LD_INT 0
89548: PUSH
89549: LD_INT 2
89551: NEG
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: LD_INT 1
89559: NEG
89560: PUSH
89561: LD_INT 3
89563: NEG
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 1
89571: NEG
89572: PUSH
89573: LD_INT 4
89575: NEG
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 2
89583: PUSH
89584: LD_INT 2
89586: NEG
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 2
89594: NEG
89595: PUSH
89596: LD_INT 4
89598: NEG
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 4
89606: PUSH
89607: LD_INT 0
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 4
89616: PUSH
89617: LD_INT 1
89619: NEG
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PUSH
89625: LD_INT 5
89627: PUSH
89628: LD_INT 0
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 5
89637: PUSH
89638: LD_INT 1
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 4
89647: PUSH
89648: LD_INT 1
89650: PUSH
89651: EMPTY
89652: LIST
89653: LIST
89654: PUSH
89655: LD_INT 3
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: LD_INT 3
89667: PUSH
89668: LD_INT 1
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 3
89678: PUSH
89679: LD_INT 2
89681: NEG
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 5
89689: PUSH
89690: LD_INT 2
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
89744: LD_ADDR_VAR 0 32
89748: PUSH
89749: LD_INT 4
89751: NEG
89752: PUSH
89753: LD_INT 0
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 4
89762: NEG
89763: PUSH
89764: LD_INT 1
89766: NEG
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 3
89774: NEG
89775: PUSH
89776: LD_INT 0
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 3
89785: NEG
89786: PUSH
89787: LD_INT 1
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: LD_INT 4
89796: NEG
89797: PUSH
89798: LD_INT 1
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 5
89807: NEG
89808: PUSH
89809: LD_INT 0
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 5
89818: NEG
89819: PUSH
89820: LD_INT 1
89822: NEG
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: PUSH
89828: LD_INT 5
89830: NEG
89831: PUSH
89832: LD_INT 2
89834: NEG
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: PUSH
89840: LD_INT 3
89842: NEG
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 3
89853: NEG
89854: PUSH
89855: LD_INT 3
89857: NEG
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 3
89865: NEG
89866: PUSH
89867: LD_INT 4
89869: NEG
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 2
89877: NEG
89878: PUSH
89879: LD_INT 3
89881: NEG
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 2
89889: NEG
89890: PUSH
89891: LD_INT 2
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 3
89901: NEG
89902: PUSH
89903: LD_INT 2
89905: NEG
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PUSH
89911: LD_INT 4
89913: NEG
89914: PUSH
89915: LD_INT 3
89917: NEG
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 4
89925: NEG
89926: PUSH
89927: LD_INT 4
89929: NEG
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 2
89937: NEG
89938: PUSH
89939: LD_INT 4
89941: NEG
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 4
89949: NEG
89950: PUSH
89951: LD_INT 2
89953: NEG
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: LD_INT 0
89961: PUSH
89962: LD_INT 4
89964: NEG
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 0
89972: PUSH
89973: LD_INT 5
89975: NEG
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 1
89983: PUSH
89984: LD_INT 4
89986: NEG
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 3
89997: NEG
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 0
90005: PUSH
90006: LD_INT 3
90008: NEG
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 1
90016: NEG
90017: PUSH
90018: LD_INT 4
90020: NEG
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 1
90028: NEG
90029: PUSH
90030: LD_INT 5
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 2
90040: PUSH
90041: LD_INT 3
90043: NEG
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 2
90051: NEG
90052: PUSH
90053: LD_INT 5
90055: NEG
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 3
90063: PUSH
90064: LD_INT 0
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: LD_INT 3
90073: PUSH
90074: LD_INT 1
90076: NEG
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 4
90084: PUSH
90085: LD_INT 0
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PUSH
90092: LD_INT 4
90094: PUSH
90095: LD_INT 1
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 3
90104: PUSH
90105: LD_INT 1
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 2
90114: PUSH
90115: LD_INT 0
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 2
90124: PUSH
90125: LD_INT 1
90127: NEG
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 2
90135: PUSH
90136: LD_INT 2
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 4
90146: PUSH
90147: LD_INT 2
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 4
90156: PUSH
90157: LD_INT 4
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 4
90166: PUSH
90167: LD_INT 3
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 5
90176: PUSH
90177: LD_INT 4
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 5
90186: PUSH
90187: LD_INT 5
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 4
90196: PUSH
90197: LD_INT 5
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 3
90206: PUSH
90207: LD_INT 4
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 3
90216: PUSH
90217: LD_INT 3
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 5
90226: PUSH
90227: LD_INT 3
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 3
90236: PUSH
90237: LD_INT 5
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
90291: LD_ADDR_VAR 0 33
90295: PUSH
90296: LD_INT 4
90298: NEG
90299: PUSH
90300: LD_INT 4
90302: NEG
90303: PUSH
90304: EMPTY
90305: LIST
90306: LIST
90307: PUSH
90308: LD_INT 4
90310: NEG
90311: PUSH
90312: LD_INT 5
90314: NEG
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 3
90322: NEG
90323: PUSH
90324: LD_INT 4
90326: NEG
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 3
90334: NEG
90335: PUSH
90336: LD_INT 3
90338: NEG
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 4
90346: NEG
90347: PUSH
90348: LD_INT 3
90350: NEG
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: PUSH
90356: LD_INT 5
90358: NEG
90359: PUSH
90360: LD_INT 4
90362: NEG
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 5
90370: NEG
90371: PUSH
90372: LD_INT 5
90374: NEG
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: LD_INT 3
90382: NEG
90383: PUSH
90384: LD_INT 5
90386: NEG
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 5
90394: NEG
90395: PUSH
90396: LD_INT 3
90398: NEG
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: PUSH
90404: LD_INT 0
90406: PUSH
90407: LD_INT 3
90409: NEG
90410: PUSH
90411: EMPTY
90412: LIST
90413: LIST
90414: PUSH
90415: LD_INT 0
90417: PUSH
90418: LD_INT 4
90420: NEG
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 1
90428: PUSH
90429: LD_INT 3
90431: NEG
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 1
90439: PUSH
90440: LD_INT 2
90442: NEG
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: LD_INT 0
90450: PUSH
90451: LD_INT 2
90453: NEG
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 1
90461: NEG
90462: PUSH
90463: LD_INT 3
90465: NEG
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: PUSH
90471: LD_INT 1
90473: NEG
90474: PUSH
90475: LD_INT 4
90477: NEG
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 2
90485: PUSH
90486: LD_INT 2
90488: NEG
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: PUSH
90494: LD_INT 2
90496: NEG
90497: PUSH
90498: LD_INT 4
90500: NEG
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 4
90508: PUSH
90509: LD_INT 0
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: LD_INT 4
90518: PUSH
90519: LD_INT 1
90521: NEG
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 5
90529: PUSH
90530: LD_INT 0
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 5
90539: PUSH
90540: LD_INT 1
90542: PUSH
90543: EMPTY
90544: LIST
90545: LIST
90546: PUSH
90547: LD_INT 4
90549: PUSH
90550: LD_INT 1
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 3
90559: PUSH
90560: LD_INT 0
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 3
90569: PUSH
90570: LD_INT 1
90572: NEG
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 3
90580: PUSH
90581: LD_INT 2
90583: NEG
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 5
90591: PUSH
90592: LD_INT 2
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 3
90601: PUSH
90602: LD_INT 3
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: PUSH
90609: LD_INT 3
90611: PUSH
90612: LD_INT 2
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 4
90621: PUSH
90622: LD_INT 3
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 4
90631: PUSH
90632: LD_INT 4
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 3
90641: PUSH
90642: LD_INT 4
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 2
90651: PUSH
90652: LD_INT 3
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 2
90661: PUSH
90662: LD_INT 2
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 4
90671: PUSH
90672: LD_INT 2
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 2
90681: PUSH
90682: LD_INT 4
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: LD_INT 0
90691: PUSH
90692: LD_INT 4
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: PUSH
90699: LD_INT 0
90701: PUSH
90702: LD_INT 3
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 1
90711: PUSH
90712: LD_INT 4
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 1
90721: PUSH
90722: LD_INT 5
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 0
90731: PUSH
90732: LD_INT 5
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 1
90741: NEG
90742: PUSH
90743: LD_INT 4
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 1
90752: NEG
90753: PUSH
90754: LD_INT 3
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 2
90763: PUSH
90764: LD_INT 5
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: LD_INT 3
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
90829: LD_ADDR_VAR 0 34
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: LD_INT 4
90839: NEG
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 0
90847: PUSH
90848: LD_INT 5
90850: NEG
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 1
90858: PUSH
90859: LD_INT 4
90861: NEG
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 1
90869: PUSH
90870: LD_INT 3
90872: NEG
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 0
90880: PUSH
90881: LD_INT 3
90883: NEG
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 1
90891: NEG
90892: PUSH
90893: LD_INT 4
90895: NEG
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 1
90903: NEG
90904: PUSH
90905: LD_INT 5
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 2
90915: PUSH
90916: LD_INT 3
90918: NEG
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 2
90926: NEG
90927: PUSH
90928: LD_INT 5
90930: NEG
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: PUSH
90936: LD_INT 3
90938: PUSH
90939: LD_INT 0
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 3
90948: PUSH
90949: LD_INT 1
90951: NEG
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 4
90959: PUSH
90960: LD_INT 0
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 4
90969: PUSH
90970: LD_INT 1
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 3
90979: PUSH
90980: LD_INT 1
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 2
90989: PUSH
90990: LD_INT 0
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 2
90999: PUSH
91000: LD_INT 1
91002: NEG
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 2
91010: PUSH
91011: LD_INT 2
91013: NEG
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 4
91021: PUSH
91022: LD_INT 2
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 4
91031: PUSH
91032: LD_INT 4
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 4
91041: PUSH
91042: LD_INT 3
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 5
91051: PUSH
91052: LD_INT 4
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 5
91061: PUSH
91062: LD_INT 5
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 4
91071: PUSH
91072: LD_INT 5
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 3
91081: PUSH
91082: LD_INT 4
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 3
91091: PUSH
91092: LD_INT 3
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 5
91101: PUSH
91102: LD_INT 3
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 3
91111: PUSH
91112: LD_INT 5
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 0
91121: PUSH
91122: LD_INT 3
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 0
91131: PUSH
91132: LD_INT 2
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 1
91141: PUSH
91142: LD_INT 3
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 1
91151: PUSH
91152: LD_INT 4
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 0
91161: PUSH
91162: LD_INT 4
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 1
91171: NEG
91172: PUSH
91173: LD_INT 3
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 1
91182: NEG
91183: PUSH
91184: LD_INT 2
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: PUSH
91191: LD_INT 2
91193: PUSH
91194: LD_INT 4
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: PUSH
91201: LD_INT 2
91203: NEG
91204: PUSH
91205: LD_INT 2
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 4
91214: NEG
91215: PUSH
91216: LD_INT 0
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 4
91225: NEG
91226: PUSH
91227: LD_INT 1
91229: NEG
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 3
91237: NEG
91238: PUSH
91239: LD_INT 0
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 3
91248: NEG
91249: PUSH
91250: LD_INT 1
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 4
91259: NEG
91260: PUSH
91261: LD_INT 1
91263: PUSH
91264: EMPTY
91265: LIST
91266: LIST
91267: PUSH
91268: LD_INT 5
91270: NEG
91271: PUSH
91272: LD_INT 0
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: LD_INT 5
91281: NEG
91282: PUSH
91283: LD_INT 1
91285: NEG
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 5
91293: NEG
91294: PUSH
91295: LD_INT 2
91297: NEG
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 3
91305: NEG
91306: PUSH
91307: LD_INT 2
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: ST_TO_ADDR
// end ; end ;
91361: GO 91364
91363: POP
// case btype of b_depot , b_warehouse :
91364: LD_VAR 0 1
91368: PUSH
91369: LD_INT 0
91371: DOUBLE
91372: EQUAL
91373: IFTRUE 91383
91375: LD_INT 1
91377: DOUBLE
91378: EQUAL
91379: IFTRUE 91383
91381: GO 91584
91383: POP
// case nation of nation_american :
91384: LD_VAR 0 5
91388: PUSH
91389: LD_INT 1
91391: DOUBLE
91392: EQUAL
91393: IFTRUE 91397
91395: GO 91453
91397: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
91398: LD_ADDR_VAR 0 9
91402: PUSH
91403: LD_VAR 0 11
91407: PUSH
91408: LD_VAR 0 12
91412: PUSH
91413: LD_VAR 0 13
91417: PUSH
91418: LD_VAR 0 14
91422: PUSH
91423: LD_VAR 0 15
91427: PUSH
91428: LD_VAR 0 16
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: PUSH
91441: LD_VAR 0 4
91445: PUSH
91446: LD_INT 1
91448: PLUS
91449: ARRAY
91450: ST_TO_ADDR
91451: GO 91582
91453: LD_INT 2
91455: DOUBLE
91456: EQUAL
91457: IFTRUE 91461
91459: GO 91517
91461: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
91462: LD_ADDR_VAR 0 9
91466: PUSH
91467: LD_VAR 0 17
91471: PUSH
91472: LD_VAR 0 18
91476: PUSH
91477: LD_VAR 0 19
91481: PUSH
91482: LD_VAR 0 20
91486: PUSH
91487: LD_VAR 0 21
91491: PUSH
91492: LD_VAR 0 22
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: PUSH
91505: LD_VAR 0 4
91509: PUSH
91510: LD_INT 1
91512: PLUS
91513: ARRAY
91514: ST_TO_ADDR
91515: GO 91582
91517: LD_INT 3
91519: DOUBLE
91520: EQUAL
91521: IFTRUE 91525
91523: GO 91581
91525: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
91526: LD_ADDR_VAR 0 9
91530: PUSH
91531: LD_VAR 0 23
91535: PUSH
91536: LD_VAR 0 24
91540: PUSH
91541: LD_VAR 0 25
91545: PUSH
91546: LD_VAR 0 26
91550: PUSH
91551: LD_VAR 0 27
91555: PUSH
91556: LD_VAR 0 28
91560: PUSH
91561: EMPTY
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: PUSH
91569: LD_VAR 0 4
91573: PUSH
91574: LD_INT 1
91576: PLUS
91577: ARRAY
91578: ST_TO_ADDR
91579: GO 91582
91581: POP
91582: GO 92137
91584: LD_INT 2
91586: DOUBLE
91587: EQUAL
91588: IFTRUE 91598
91590: LD_INT 3
91592: DOUBLE
91593: EQUAL
91594: IFTRUE 91598
91596: GO 91654
91598: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
91599: LD_ADDR_VAR 0 9
91603: PUSH
91604: LD_VAR 0 29
91608: PUSH
91609: LD_VAR 0 30
91613: PUSH
91614: LD_VAR 0 31
91618: PUSH
91619: LD_VAR 0 32
91623: PUSH
91624: LD_VAR 0 33
91628: PUSH
91629: LD_VAR 0 34
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: PUSH
91642: LD_VAR 0 4
91646: PUSH
91647: LD_INT 1
91649: PLUS
91650: ARRAY
91651: ST_TO_ADDR
91652: GO 92137
91654: LD_INT 16
91656: DOUBLE
91657: EQUAL
91658: IFTRUE 91716
91660: LD_INT 17
91662: DOUBLE
91663: EQUAL
91664: IFTRUE 91716
91666: LD_INT 18
91668: DOUBLE
91669: EQUAL
91670: IFTRUE 91716
91672: LD_INT 19
91674: DOUBLE
91675: EQUAL
91676: IFTRUE 91716
91678: LD_INT 22
91680: DOUBLE
91681: EQUAL
91682: IFTRUE 91716
91684: LD_INT 20
91686: DOUBLE
91687: EQUAL
91688: IFTRUE 91716
91690: LD_INT 21
91692: DOUBLE
91693: EQUAL
91694: IFTRUE 91716
91696: LD_INT 23
91698: DOUBLE
91699: EQUAL
91700: IFTRUE 91716
91702: LD_INT 24
91704: DOUBLE
91705: EQUAL
91706: IFTRUE 91716
91708: LD_INT 25
91710: DOUBLE
91711: EQUAL
91712: IFTRUE 91716
91714: GO 91772
91716: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
91717: LD_ADDR_VAR 0 9
91721: PUSH
91722: LD_VAR 0 35
91726: PUSH
91727: LD_VAR 0 36
91731: PUSH
91732: LD_VAR 0 37
91736: PUSH
91737: LD_VAR 0 38
91741: PUSH
91742: LD_VAR 0 39
91746: PUSH
91747: LD_VAR 0 40
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: PUSH
91760: LD_VAR 0 4
91764: PUSH
91765: LD_INT 1
91767: PLUS
91768: ARRAY
91769: ST_TO_ADDR
91770: GO 92137
91772: LD_INT 6
91774: DOUBLE
91775: EQUAL
91776: IFTRUE 91828
91778: LD_INT 7
91780: DOUBLE
91781: EQUAL
91782: IFTRUE 91828
91784: LD_INT 8
91786: DOUBLE
91787: EQUAL
91788: IFTRUE 91828
91790: LD_INT 13
91792: DOUBLE
91793: EQUAL
91794: IFTRUE 91828
91796: LD_INT 12
91798: DOUBLE
91799: EQUAL
91800: IFTRUE 91828
91802: LD_INT 15
91804: DOUBLE
91805: EQUAL
91806: IFTRUE 91828
91808: LD_INT 11
91810: DOUBLE
91811: EQUAL
91812: IFTRUE 91828
91814: LD_INT 14
91816: DOUBLE
91817: EQUAL
91818: IFTRUE 91828
91820: LD_INT 10
91822: DOUBLE
91823: EQUAL
91824: IFTRUE 91828
91826: GO 91884
91828: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
91829: LD_ADDR_VAR 0 9
91833: PUSH
91834: LD_VAR 0 41
91838: PUSH
91839: LD_VAR 0 42
91843: PUSH
91844: LD_VAR 0 43
91848: PUSH
91849: LD_VAR 0 44
91853: PUSH
91854: LD_VAR 0 45
91858: PUSH
91859: LD_VAR 0 46
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: PUSH
91872: LD_VAR 0 4
91876: PUSH
91877: LD_INT 1
91879: PLUS
91880: ARRAY
91881: ST_TO_ADDR
91882: GO 92137
91884: LD_INT 36
91886: DOUBLE
91887: EQUAL
91888: IFTRUE 91892
91890: GO 91948
91892: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
91893: LD_ADDR_VAR 0 9
91897: PUSH
91898: LD_VAR 0 47
91902: PUSH
91903: LD_VAR 0 48
91907: PUSH
91908: LD_VAR 0 49
91912: PUSH
91913: LD_VAR 0 50
91917: PUSH
91918: LD_VAR 0 51
91922: PUSH
91923: LD_VAR 0 52
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: PUSH
91936: LD_VAR 0 4
91940: PUSH
91941: LD_INT 1
91943: PLUS
91944: ARRAY
91945: ST_TO_ADDR
91946: GO 92137
91948: LD_INT 4
91950: DOUBLE
91951: EQUAL
91952: IFTRUE 91974
91954: LD_INT 5
91956: DOUBLE
91957: EQUAL
91958: IFTRUE 91974
91960: LD_INT 34
91962: DOUBLE
91963: EQUAL
91964: IFTRUE 91974
91966: LD_INT 37
91968: DOUBLE
91969: EQUAL
91970: IFTRUE 91974
91972: GO 92030
91974: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
91975: LD_ADDR_VAR 0 9
91979: PUSH
91980: LD_VAR 0 53
91984: PUSH
91985: LD_VAR 0 54
91989: PUSH
91990: LD_VAR 0 55
91994: PUSH
91995: LD_VAR 0 56
91999: PUSH
92000: LD_VAR 0 57
92004: PUSH
92005: LD_VAR 0 58
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: PUSH
92018: LD_VAR 0 4
92022: PUSH
92023: LD_INT 1
92025: PLUS
92026: ARRAY
92027: ST_TO_ADDR
92028: GO 92137
92030: LD_INT 31
92032: DOUBLE
92033: EQUAL
92034: IFTRUE 92080
92036: LD_INT 32
92038: DOUBLE
92039: EQUAL
92040: IFTRUE 92080
92042: LD_INT 33
92044: DOUBLE
92045: EQUAL
92046: IFTRUE 92080
92048: LD_INT 27
92050: DOUBLE
92051: EQUAL
92052: IFTRUE 92080
92054: LD_INT 26
92056: DOUBLE
92057: EQUAL
92058: IFTRUE 92080
92060: LD_INT 28
92062: DOUBLE
92063: EQUAL
92064: IFTRUE 92080
92066: LD_INT 29
92068: DOUBLE
92069: EQUAL
92070: IFTRUE 92080
92072: LD_INT 30
92074: DOUBLE
92075: EQUAL
92076: IFTRUE 92080
92078: GO 92136
92080: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
92081: LD_ADDR_VAR 0 9
92085: PUSH
92086: LD_VAR 0 59
92090: PUSH
92091: LD_VAR 0 60
92095: PUSH
92096: LD_VAR 0 61
92100: PUSH
92101: LD_VAR 0 62
92105: PUSH
92106: LD_VAR 0 63
92110: PUSH
92111: LD_VAR 0 64
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: PUSH
92124: LD_VAR 0 4
92128: PUSH
92129: LD_INT 1
92131: PLUS
92132: ARRAY
92133: ST_TO_ADDR
92134: GO 92137
92136: POP
// temp_list2 = [ ] ;
92137: LD_ADDR_VAR 0 10
92141: PUSH
92142: EMPTY
92143: ST_TO_ADDR
// for i in temp_list do
92144: LD_ADDR_VAR 0 8
92148: PUSH
92149: LD_VAR 0 9
92153: PUSH
92154: FOR_IN
92155: IFFALSE 92207
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
92157: LD_ADDR_VAR 0 10
92161: PUSH
92162: LD_VAR 0 10
92166: PUSH
92167: LD_VAR 0 8
92171: PUSH
92172: LD_INT 1
92174: ARRAY
92175: PUSH
92176: LD_VAR 0 2
92180: PLUS
92181: PUSH
92182: LD_VAR 0 8
92186: PUSH
92187: LD_INT 2
92189: ARRAY
92190: PUSH
92191: LD_VAR 0 3
92195: PLUS
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: EMPTY
92202: LIST
92203: ADD
92204: ST_TO_ADDR
92205: GO 92154
92207: POP
92208: POP
// result = temp_list2 ;
92209: LD_ADDR_VAR 0 7
92213: PUSH
92214: LD_VAR 0 10
92218: ST_TO_ADDR
// end ;
92219: LD_VAR 0 7
92223: RET
// export function EnemyInRange ( unit , dist ) ; begin
92224: LD_INT 0
92226: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
92227: LD_ADDR_VAR 0 3
92231: PUSH
92232: LD_VAR 0 1
92236: PPUSH
92237: CALL_OW 255
92241: PPUSH
92242: LD_VAR 0 1
92246: PPUSH
92247: CALL_OW 250
92251: PPUSH
92252: LD_VAR 0 1
92256: PPUSH
92257: CALL_OW 251
92261: PPUSH
92262: LD_VAR 0 2
92266: PPUSH
92267: CALL 66328 0 4
92271: PUSH
92272: LD_INT 4
92274: ARRAY
92275: ST_TO_ADDR
// end ;
92276: LD_VAR 0 3
92280: RET
// export function PlayerSeeMe ( unit ) ; begin
92281: LD_INT 0
92283: PPUSH
// result := See ( your_side , unit ) ;
92284: LD_ADDR_VAR 0 2
92288: PUSH
92289: LD_OWVAR 2
92293: PPUSH
92294: LD_VAR 0 1
92298: PPUSH
92299: CALL_OW 292
92303: ST_TO_ADDR
// end ;
92304: LD_VAR 0 2
92308: RET
// export function ReverseDir ( unit ) ; begin
92309: LD_INT 0
92311: PPUSH
// if not unit then
92312: LD_VAR 0 1
92316: NOT
92317: IFFALSE 92321
// exit ;
92319: GO 92344
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
92321: LD_ADDR_VAR 0 2
92325: PUSH
92326: LD_VAR 0 1
92330: PPUSH
92331: CALL_OW 254
92335: PUSH
92336: LD_INT 3
92338: PLUS
92339: PUSH
92340: LD_INT 6
92342: MOD
92343: ST_TO_ADDR
// end ;
92344: LD_VAR 0 2
92348: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
92349: LD_INT 0
92351: PPUSH
92352: PPUSH
92353: PPUSH
92354: PPUSH
92355: PPUSH
// if not hexes then
92356: LD_VAR 0 2
92360: NOT
92361: IFFALSE 92365
// exit ;
92363: GO 92513
// dist := 9999 ;
92365: LD_ADDR_VAR 0 5
92369: PUSH
92370: LD_INT 9999
92372: ST_TO_ADDR
// for i = 1 to hexes do
92373: LD_ADDR_VAR 0 4
92377: PUSH
92378: DOUBLE
92379: LD_INT 1
92381: DEC
92382: ST_TO_ADDR
92383: LD_VAR 0 2
92387: PUSH
92388: FOR_TO
92389: IFFALSE 92501
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
92391: LD_VAR 0 1
92395: PPUSH
92396: LD_VAR 0 2
92400: PUSH
92401: LD_VAR 0 4
92405: ARRAY
92406: PUSH
92407: LD_INT 1
92409: ARRAY
92410: PPUSH
92411: LD_VAR 0 2
92415: PUSH
92416: LD_VAR 0 4
92420: ARRAY
92421: PUSH
92422: LD_INT 2
92424: ARRAY
92425: PPUSH
92426: CALL_OW 297
92430: PUSH
92431: LD_VAR 0 5
92435: LESS
92436: IFFALSE 92499
// begin hex := hexes [ i ] ;
92438: LD_ADDR_VAR 0 7
92442: PUSH
92443: LD_VAR 0 2
92447: PUSH
92448: LD_VAR 0 4
92452: ARRAY
92453: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
92454: LD_ADDR_VAR 0 5
92458: PUSH
92459: LD_VAR 0 1
92463: PPUSH
92464: LD_VAR 0 2
92468: PUSH
92469: LD_VAR 0 4
92473: ARRAY
92474: PUSH
92475: LD_INT 1
92477: ARRAY
92478: PPUSH
92479: LD_VAR 0 2
92483: PUSH
92484: LD_VAR 0 4
92488: ARRAY
92489: PUSH
92490: LD_INT 2
92492: ARRAY
92493: PPUSH
92494: CALL_OW 297
92498: ST_TO_ADDR
// end ; end ;
92499: GO 92388
92501: POP
92502: POP
// result := hex ;
92503: LD_ADDR_VAR 0 3
92507: PUSH
92508: LD_VAR 0 7
92512: ST_TO_ADDR
// end ;
92513: LD_VAR 0 3
92517: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
92518: LD_INT 0
92520: PPUSH
92521: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
92522: LD_VAR 0 1
92526: NOT
92527: PUSH
92528: LD_VAR 0 1
92532: PUSH
92533: LD_INT 21
92535: PUSH
92536: LD_INT 2
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 23
92545: PUSH
92546: LD_INT 2
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PPUSH
92557: CALL_OW 69
92561: IN
92562: NOT
92563: OR
92564: IFFALSE 92568
// exit ;
92566: GO 92615
// for i = 1 to 3 do
92568: LD_ADDR_VAR 0 3
92572: PUSH
92573: DOUBLE
92574: LD_INT 1
92576: DEC
92577: ST_TO_ADDR
92578: LD_INT 3
92580: PUSH
92581: FOR_TO
92582: IFFALSE 92613
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
92584: LD_VAR 0 1
92588: PPUSH
92589: CALL_OW 250
92593: PPUSH
92594: LD_VAR 0 1
92598: PPUSH
92599: CALL_OW 251
92603: PPUSH
92604: LD_INT 1
92606: PPUSH
92607: CALL_OW 453
92611: GO 92581
92613: POP
92614: POP
// end ;
92615: LD_VAR 0 2
92619: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
92620: LD_INT 0
92622: PPUSH
92623: PPUSH
92624: PPUSH
92625: PPUSH
92626: PPUSH
92627: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
92628: LD_VAR 0 1
92632: NOT
92633: PUSH
92634: LD_VAR 0 2
92638: NOT
92639: OR
92640: PUSH
92641: LD_VAR 0 1
92645: PPUSH
92646: CALL_OW 314
92650: OR
92651: IFFALSE 92655
// exit ;
92653: GO 93096
// x := GetX ( enemy_unit ) ;
92655: LD_ADDR_VAR 0 7
92659: PUSH
92660: LD_VAR 0 2
92664: PPUSH
92665: CALL_OW 250
92669: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
92670: LD_ADDR_VAR 0 8
92674: PUSH
92675: LD_VAR 0 2
92679: PPUSH
92680: CALL_OW 251
92684: ST_TO_ADDR
// if not x or not y then
92685: LD_VAR 0 7
92689: NOT
92690: PUSH
92691: LD_VAR 0 8
92695: NOT
92696: OR
92697: IFFALSE 92701
// exit ;
92699: GO 93096
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
92701: LD_ADDR_VAR 0 6
92705: PUSH
92706: LD_VAR 0 7
92710: PPUSH
92711: LD_INT 0
92713: PPUSH
92714: LD_INT 4
92716: PPUSH
92717: CALL_OW 272
92721: PUSH
92722: LD_VAR 0 8
92726: PPUSH
92727: LD_INT 0
92729: PPUSH
92730: LD_INT 4
92732: PPUSH
92733: CALL_OW 273
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_VAR 0 7
92746: PPUSH
92747: LD_INT 1
92749: PPUSH
92750: LD_INT 4
92752: PPUSH
92753: CALL_OW 272
92757: PUSH
92758: LD_VAR 0 8
92762: PPUSH
92763: LD_INT 1
92765: PPUSH
92766: LD_INT 4
92768: PPUSH
92769: CALL_OW 273
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_VAR 0 7
92782: PPUSH
92783: LD_INT 2
92785: PPUSH
92786: LD_INT 4
92788: PPUSH
92789: CALL_OW 272
92793: PUSH
92794: LD_VAR 0 8
92798: PPUSH
92799: LD_INT 2
92801: PPUSH
92802: LD_INT 4
92804: PPUSH
92805: CALL_OW 273
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_VAR 0 7
92818: PPUSH
92819: LD_INT 3
92821: PPUSH
92822: LD_INT 4
92824: PPUSH
92825: CALL_OW 272
92829: PUSH
92830: LD_VAR 0 8
92834: PPUSH
92835: LD_INT 3
92837: PPUSH
92838: LD_INT 4
92840: PPUSH
92841: CALL_OW 273
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_VAR 0 7
92854: PPUSH
92855: LD_INT 4
92857: PPUSH
92858: LD_INT 4
92860: PPUSH
92861: CALL_OW 272
92865: PUSH
92866: LD_VAR 0 8
92870: PPUSH
92871: LD_INT 4
92873: PPUSH
92874: LD_INT 4
92876: PPUSH
92877: CALL_OW 273
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_VAR 0 7
92890: PPUSH
92891: LD_INT 5
92893: PPUSH
92894: LD_INT 4
92896: PPUSH
92897: CALL_OW 272
92901: PUSH
92902: LD_VAR 0 8
92906: PPUSH
92907: LD_INT 5
92909: PPUSH
92910: LD_INT 4
92912: PPUSH
92913: CALL_OW 273
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: PUSH
92922: EMPTY
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: ST_TO_ADDR
// for i = tmp downto 1 do
92930: LD_ADDR_VAR 0 4
92934: PUSH
92935: DOUBLE
92936: LD_VAR 0 6
92940: INC
92941: ST_TO_ADDR
92942: LD_INT 1
92944: PUSH
92945: FOR_DOWNTO
92946: IFFALSE 93047
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
92948: LD_VAR 0 6
92952: PUSH
92953: LD_VAR 0 4
92957: ARRAY
92958: PUSH
92959: LD_INT 1
92961: ARRAY
92962: PPUSH
92963: LD_VAR 0 6
92967: PUSH
92968: LD_VAR 0 4
92972: ARRAY
92973: PUSH
92974: LD_INT 2
92976: ARRAY
92977: PPUSH
92978: CALL_OW 488
92982: NOT
92983: PUSH
92984: LD_VAR 0 6
92988: PUSH
92989: LD_VAR 0 4
92993: ARRAY
92994: PUSH
92995: LD_INT 1
92997: ARRAY
92998: PPUSH
92999: LD_VAR 0 6
93003: PUSH
93004: LD_VAR 0 4
93008: ARRAY
93009: PUSH
93010: LD_INT 2
93012: ARRAY
93013: PPUSH
93014: CALL_OW 428
93018: PUSH
93019: LD_INT 0
93021: NONEQUAL
93022: OR
93023: IFFALSE 93045
// tmp := Delete ( tmp , i ) ;
93025: LD_ADDR_VAR 0 6
93029: PUSH
93030: LD_VAR 0 6
93034: PPUSH
93035: LD_VAR 0 4
93039: PPUSH
93040: CALL_OW 3
93044: ST_TO_ADDR
93045: GO 92945
93047: POP
93048: POP
// j := GetClosestHex ( unit , tmp ) ;
93049: LD_ADDR_VAR 0 5
93053: PUSH
93054: LD_VAR 0 1
93058: PPUSH
93059: LD_VAR 0 6
93063: PPUSH
93064: CALL 92349 0 2
93068: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
93069: LD_VAR 0 1
93073: PPUSH
93074: LD_VAR 0 5
93078: PUSH
93079: LD_INT 1
93081: ARRAY
93082: PPUSH
93083: LD_VAR 0 5
93087: PUSH
93088: LD_INT 2
93090: ARRAY
93091: PPUSH
93092: CALL_OW 111
// end ;
93096: LD_VAR 0 3
93100: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
93101: LD_INT 0
93103: PPUSH
93104: PPUSH
93105: PPUSH
// uc_side = 0 ;
93106: LD_ADDR_OWVAR 20
93110: PUSH
93111: LD_INT 0
93113: ST_TO_ADDR
// uc_nation = 0 ;
93114: LD_ADDR_OWVAR 21
93118: PUSH
93119: LD_INT 0
93121: ST_TO_ADDR
// InitHc_All ( ) ;
93122: CALL_OW 584
// InitVc ;
93126: CALL_OW 20
// if mastodonts then
93130: LD_VAR 0 6
93134: IFFALSE 93201
// for i = 1 to mastodonts do
93136: LD_ADDR_VAR 0 11
93140: PUSH
93141: DOUBLE
93142: LD_INT 1
93144: DEC
93145: ST_TO_ADDR
93146: LD_VAR 0 6
93150: PUSH
93151: FOR_TO
93152: IFFALSE 93199
// begin vc_chassis := 31 ;
93154: LD_ADDR_OWVAR 37
93158: PUSH
93159: LD_INT 31
93161: ST_TO_ADDR
// vc_control := control_rider ;
93162: LD_ADDR_OWVAR 38
93166: PUSH
93167: LD_INT 4
93169: ST_TO_ADDR
// animal := CreateVehicle ;
93170: LD_ADDR_VAR 0 12
93174: PUSH
93175: CALL_OW 45
93179: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93180: LD_VAR 0 12
93184: PPUSH
93185: LD_VAR 0 8
93189: PPUSH
93190: LD_INT 0
93192: PPUSH
93193: CALL 95389 0 3
// end ;
93197: GO 93151
93199: POP
93200: POP
// if horses then
93201: LD_VAR 0 5
93205: IFFALSE 93272
// for i = 1 to horses do
93207: LD_ADDR_VAR 0 11
93211: PUSH
93212: DOUBLE
93213: LD_INT 1
93215: DEC
93216: ST_TO_ADDR
93217: LD_VAR 0 5
93221: PUSH
93222: FOR_TO
93223: IFFALSE 93270
// begin hc_class := 21 ;
93225: LD_ADDR_OWVAR 28
93229: PUSH
93230: LD_INT 21
93232: ST_TO_ADDR
// hc_gallery :=  ;
93233: LD_ADDR_OWVAR 33
93237: PUSH
93238: LD_STRING 
93240: ST_TO_ADDR
// animal := CreateHuman ;
93241: LD_ADDR_VAR 0 12
93245: PUSH
93246: CALL_OW 44
93250: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93251: LD_VAR 0 12
93255: PPUSH
93256: LD_VAR 0 8
93260: PPUSH
93261: LD_INT 0
93263: PPUSH
93264: CALL 95389 0 3
// end ;
93268: GO 93222
93270: POP
93271: POP
// if birds then
93272: LD_VAR 0 1
93276: IFFALSE 93343
// for i = 1 to birds do
93278: LD_ADDR_VAR 0 11
93282: PUSH
93283: DOUBLE
93284: LD_INT 1
93286: DEC
93287: ST_TO_ADDR
93288: LD_VAR 0 1
93292: PUSH
93293: FOR_TO
93294: IFFALSE 93341
// begin hc_class = 18 ;
93296: LD_ADDR_OWVAR 28
93300: PUSH
93301: LD_INT 18
93303: ST_TO_ADDR
// hc_gallery =  ;
93304: LD_ADDR_OWVAR 33
93308: PUSH
93309: LD_STRING 
93311: ST_TO_ADDR
// animal := CreateHuman ;
93312: LD_ADDR_VAR 0 12
93316: PUSH
93317: CALL_OW 44
93321: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93322: LD_VAR 0 12
93326: PPUSH
93327: LD_VAR 0 8
93331: PPUSH
93332: LD_INT 0
93334: PPUSH
93335: CALL 95389 0 3
// end ;
93339: GO 93293
93341: POP
93342: POP
// if tigers then
93343: LD_VAR 0 2
93347: IFFALSE 93431
// for i = 1 to tigers do
93349: LD_ADDR_VAR 0 11
93353: PUSH
93354: DOUBLE
93355: LD_INT 1
93357: DEC
93358: ST_TO_ADDR
93359: LD_VAR 0 2
93363: PUSH
93364: FOR_TO
93365: IFFALSE 93429
// begin hc_class = class_tiger ;
93367: LD_ADDR_OWVAR 28
93371: PUSH
93372: LD_INT 14
93374: ST_TO_ADDR
// hc_gallery =  ;
93375: LD_ADDR_OWVAR 33
93379: PUSH
93380: LD_STRING 
93382: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
93383: LD_ADDR_OWVAR 35
93387: PUSH
93388: LD_INT 7
93390: NEG
93391: PPUSH
93392: LD_INT 7
93394: PPUSH
93395: CALL_OW 12
93399: ST_TO_ADDR
// animal := CreateHuman ;
93400: LD_ADDR_VAR 0 12
93404: PUSH
93405: CALL_OW 44
93409: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93410: LD_VAR 0 12
93414: PPUSH
93415: LD_VAR 0 8
93419: PPUSH
93420: LD_INT 0
93422: PPUSH
93423: CALL 95389 0 3
// end ;
93427: GO 93364
93429: POP
93430: POP
// if apemans then
93431: LD_VAR 0 3
93435: IFFALSE 93558
// for i = 1 to apemans do
93437: LD_ADDR_VAR 0 11
93441: PUSH
93442: DOUBLE
93443: LD_INT 1
93445: DEC
93446: ST_TO_ADDR
93447: LD_VAR 0 3
93451: PUSH
93452: FOR_TO
93453: IFFALSE 93556
// begin hc_class = class_apeman ;
93455: LD_ADDR_OWVAR 28
93459: PUSH
93460: LD_INT 12
93462: ST_TO_ADDR
// hc_gallery =  ;
93463: LD_ADDR_OWVAR 33
93467: PUSH
93468: LD_STRING 
93470: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
93471: LD_ADDR_OWVAR 35
93475: PUSH
93476: LD_INT 5
93478: NEG
93479: PPUSH
93480: LD_INT 5
93482: PPUSH
93483: CALL_OW 12
93487: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
93488: LD_ADDR_OWVAR 31
93492: PUSH
93493: LD_INT 1
93495: PPUSH
93496: LD_INT 3
93498: PPUSH
93499: CALL_OW 12
93503: PUSH
93504: LD_INT 1
93506: PPUSH
93507: LD_INT 3
93509: PPUSH
93510: CALL_OW 12
93514: PUSH
93515: LD_INT 0
93517: PUSH
93518: LD_INT 0
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: ST_TO_ADDR
// animal := CreateHuman ;
93527: LD_ADDR_VAR 0 12
93531: PUSH
93532: CALL_OW 44
93536: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93537: LD_VAR 0 12
93541: PPUSH
93542: LD_VAR 0 8
93546: PPUSH
93547: LD_INT 0
93549: PPUSH
93550: CALL 95389 0 3
// end ;
93554: GO 93452
93556: POP
93557: POP
// if enchidnas then
93558: LD_VAR 0 4
93562: IFFALSE 93629
// for i = 1 to enchidnas do
93564: LD_ADDR_VAR 0 11
93568: PUSH
93569: DOUBLE
93570: LD_INT 1
93572: DEC
93573: ST_TO_ADDR
93574: LD_VAR 0 4
93578: PUSH
93579: FOR_TO
93580: IFFALSE 93627
// begin hc_class = 13 ;
93582: LD_ADDR_OWVAR 28
93586: PUSH
93587: LD_INT 13
93589: ST_TO_ADDR
// hc_gallery =  ;
93590: LD_ADDR_OWVAR 33
93594: PUSH
93595: LD_STRING 
93597: ST_TO_ADDR
// animal := CreateHuman ;
93598: LD_ADDR_VAR 0 12
93602: PUSH
93603: CALL_OW 44
93607: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93608: LD_VAR 0 12
93612: PPUSH
93613: LD_VAR 0 8
93617: PPUSH
93618: LD_INT 0
93620: PPUSH
93621: CALL 95389 0 3
// end ;
93625: GO 93579
93627: POP
93628: POP
// if fishes then
93629: LD_VAR 0 7
93633: IFFALSE 93700
// for i = 1 to fishes do
93635: LD_ADDR_VAR 0 11
93639: PUSH
93640: DOUBLE
93641: LD_INT 1
93643: DEC
93644: ST_TO_ADDR
93645: LD_VAR 0 7
93649: PUSH
93650: FOR_TO
93651: IFFALSE 93698
// begin hc_class = 20 ;
93653: LD_ADDR_OWVAR 28
93657: PUSH
93658: LD_INT 20
93660: ST_TO_ADDR
// hc_gallery =  ;
93661: LD_ADDR_OWVAR 33
93665: PUSH
93666: LD_STRING 
93668: ST_TO_ADDR
// animal := CreateHuman ;
93669: LD_ADDR_VAR 0 12
93673: PUSH
93674: CALL_OW 44
93678: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
93679: LD_VAR 0 12
93683: PPUSH
93684: LD_VAR 0 9
93688: PPUSH
93689: LD_INT 0
93691: PPUSH
93692: CALL 95389 0 3
// end ;
93696: GO 93650
93698: POP
93699: POP
// end ;
93700: LD_VAR 0 10
93704: RET
// export function WantHeal ( sci , unit ) ; begin
93705: LD_INT 0
93707: PPUSH
// if GetTaskList ( sci ) > 0 then
93708: LD_VAR 0 1
93712: PPUSH
93713: CALL_OW 437
93717: PUSH
93718: LD_INT 0
93720: GREATER
93721: IFFALSE 93791
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
93723: LD_VAR 0 1
93727: PPUSH
93728: CALL_OW 437
93732: PUSH
93733: LD_INT 1
93735: ARRAY
93736: PUSH
93737: LD_INT 1
93739: ARRAY
93740: PUSH
93741: LD_STRING l
93743: EQUAL
93744: PUSH
93745: LD_VAR 0 1
93749: PPUSH
93750: CALL_OW 437
93754: PUSH
93755: LD_INT 1
93757: ARRAY
93758: PUSH
93759: LD_INT 4
93761: ARRAY
93762: PUSH
93763: LD_VAR 0 2
93767: EQUAL
93768: AND
93769: IFFALSE 93781
// result := true else
93771: LD_ADDR_VAR 0 3
93775: PUSH
93776: LD_INT 1
93778: ST_TO_ADDR
93779: GO 93789
// result := false ;
93781: LD_ADDR_VAR 0 3
93785: PUSH
93786: LD_INT 0
93788: ST_TO_ADDR
// end else
93789: GO 93799
// result := false ;
93791: LD_ADDR_VAR 0 3
93795: PUSH
93796: LD_INT 0
93798: ST_TO_ADDR
// end ;
93799: LD_VAR 0 3
93803: RET
// export function HealTarget ( sci ) ; begin
93804: LD_INT 0
93806: PPUSH
// if not sci then
93807: LD_VAR 0 1
93811: NOT
93812: IFFALSE 93816
// exit ;
93814: GO 93881
// result := 0 ;
93816: LD_ADDR_VAR 0 2
93820: PUSH
93821: LD_INT 0
93823: ST_TO_ADDR
// if GetTaskList ( sci ) then
93824: LD_VAR 0 1
93828: PPUSH
93829: CALL_OW 437
93833: IFFALSE 93881
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
93835: LD_VAR 0 1
93839: PPUSH
93840: CALL_OW 437
93844: PUSH
93845: LD_INT 1
93847: ARRAY
93848: PUSH
93849: LD_INT 1
93851: ARRAY
93852: PUSH
93853: LD_STRING l
93855: EQUAL
93856: IFFALSE 93881
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
93858: LD_ADDR_VAR 0 2
93862: PUSH
93863: LD_VAR 0 1
93867: PPUSH
93868: CALL_OW 437
93872: PUSH
93873: LD_INT 1
93875: ARRAY
93876: PUSH
93877: LD_INT 4
93879: ARRAY
93880: ST_TO_ADDR
// end ;
93881: LD_VAR 0 2
93885: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
93886: LD_INT 0
93888: PPUSH
93889: PPUSH
93890: PPUSH
93891: PPUSH
// if not base_units then
93892: LD_VAR 0 1
93896: NOT
93897: IFFALSE 93901
// exit ;
93899: GO 93988
// result := false ;
93901: LD_ADDR_VAR 0 2
93905: PUSH
93906: LD_INT 0
93908: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
93909: LD_ADDR_VAR 0 5
93913: PUSH
93914: LD_VAR 0 1
93918: PPUSH
93919: LD_INT 21
93921: PUSH
93922: LD_INT 3
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: PPUSH
93929: CALL_OW 72
93933: ST_TO_ADDR
// if not tmp then
93934: LD_VAR 0 5
93938: NOT
93939: IFFALSE 93943
// exit ;
93941: GO 93988
// for i in tmp do
93943: LD_ADDR_VAR 0 3
93947: PUSH
93948: LD_VAR 0 5
93952: PUSH
93953: FOR_IN
93954: IFFALSE 93986
// begin result := EnemyInRange ( i , 22 ) ;
93956: LD_ADDR_VAR 0 2
93960: PUSH
93961: LD_VAR 0 3
93965: PPUSH
93966: LD_INT 22
93968: PPUSH
93969: CALL 92224 0 2
93973: ST_TO_ADDR
// if result then
93974: LD_VAR 0 2
93978: IFFALSE 93984
// exit ;
93980: POP
93981: POP
93982: GO 93988
// end ;
93984: GO 93953
93986: POP
93987: POP
// end ;
93988: LD_VAR 0 2
93992: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
93993: LD_INT 0
93995: PPUSH
93996: PPUSH
// if not units then
93997: LD_VAR 0 1
94001: NOT
94002: IFFALSE 94006
// exit ;
94004: GO 94076
// result := [ ] ;
94006: LD_ADDR_VAR 0 3
94010: PUSH
94011: EMPTY
94012: ST_TO_ADDR
// for i in units do
94013: LD_ADDR_VAR 0 4
94017: PUSH
94018: LD_VAR 0 1
94022: PUSH
94023: FOR_IN
94024: IFFALSE 94074
// if GetTag ( i ) = tag then
94026: LD_VAR 0 4
94030: PPUSH
94031: CALL_OW 110
94035: PUSH
94036: LD_VAR 0 2
94040: EQUAL
94041: IFFALSE 94072
// result := Insert ( result , result + 1 , i ) ;
94043: LD_ADDR_VAR 0 3
94047: PUSH
94048: LD_VAR 0 3
94052: PPUSH
94053: LD_VAR 0 3
94057: PUSH
94058: LD_INT 1
94060: PLUS
94061: PPUSH
94062: LD_VAR 0 4
94066: PPUSH
94067: CALL_OW 2
94071: ST_TO_ADDR
94072: GO 94023
94074: POP
94075: POP
// end ;
94076: LD_VAR 0 3
94080: RET
// export function IsDriver ( un ) ; begin
94081: LD_INT 0
94083: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
94084: LD_ADDR_VAR 0 2
94088: PUSH
94089: LD_VAR 0 1
94093: PUSH
94094: LD_INT 55
94096: PUSH
94097: EMPTY
94098: LIST
94099: PPUSH
94100: CALL_OW 69
94104: IN
94105: ST_TO_ADDR
// end ;
94106: LD_VAR 0 2
94110: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
94111: LD_INT 0
94113: PPUSH
94114: PPUSH
// list := [ ] ;
94115: LD_ADDR_VAR 0 5
94119: PUSH
94120: EMPTY
94121: ST_TO_ADDR
// case d of 0 :
94122: LD_VAR 0 3
94126: PUSH
94127: LD_INT 0
94129: DOUBLE
94130: EQUAL
94131: IFTRUE 94135
94133: GO 94268
94135: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
94136: LD_ADDR_VAR 0 5
94140: PUSH
94141: LD_VAR 0 1
94145: PUSH
94146: LD_INT 4
94148: MINUS
94149: PUSH
94150: LD_VAR 0 2
94154: PUSH
94155: LD_INT 4
94157: MINUS
94158: PUSH
94159: LD_INT 2
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: LIST
94166: PUSH
94167: LD_VAR 0 1
94171: PUSH
94172: LD_INT 3
94174: MINUS
94175: PUSH
94176: LD_VAR 0 2
94180: PUSH
94181: LD_INT 1
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: PUSH
94189: LD_VAR 0 1
94193: PUSH
94194: LD_INT 4
94196: PLUS
94197: PUSH
94198: LD_VAR 0 2
94202: PUSH
94203: LD_INT 4
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: LIST
94210: PUSH
94211: LD_VAR 0 1
94215: PUSH
94216: LD_INT 3
94218: PLUS
94219: PUSH
94220: LD_VAR 0 2
94224: PUSH
94225: LD_INT 3
94227: PLUS
94228: PUSH
94229: LD_INT 5
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: LIST
94236: PUSH
94237: LD_VAR 0 1
94241: PUSH
94242: LD_VAR 0 2
94246: PUSH
94247: LD_INT 4
94249: PLUS
94250: PUSH
94251: LD_INT 0
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: LIST
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: ST_TO_ADDR
// end ; 1 :
94266: GO 94966
94268: LD_INT 1
94270: DOUBLE
94271: EQUAL
94272: IFTRUE 94276
94274: GO 94409
94276: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
94277: LD_ADDR_VAR 0 5
94281: PUSH
94282: LD_VAR 0 1
94286: PUSH
94287: LD_VAR 0 2
94291: PUSH
94292: LD_INT 4
94294: MINUS
94295: PUSH
94296: LD_INT 3
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: LIST
94303: PUSH
94304: LD_VAR 0 1
94308: PUSH
94309: LD_INT 3
94311: MINUS
94312: PUSH
94313: LD_VAR 0 2
94317: PUSH
94318: LD_INT 3
94320: MINUS
94321: PUSH
94322: LD_INT 2
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: LIST
94329: PUSH
94330: LD_VAR 0 1
94334: PUSH
94335: LD_INT 4
94337: MINUS
94338: PUSH
94339: LD_VAR 0 2
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: LIST
94351: PUSH
94352: LD_VAR 0 1
94356: PUSH
94357: LD_VAR 0 2
94361: PUSH
94362: LD_INT 3
94364: PLUS
94365: PUSH
94366: LD_INT 0
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: LIST
94373: PUSH
94374: LD_VAR 0 1
94378: PUSH
94379: LD_INT 4
94381: PLUS
94382: PUSH
94383: LD_VAR 0 2
94387: PUSH
94388: LD_INT 4
94390: PLUS
94391: PUSH
94392: LD_INT 5
94394: PUSH
94395: EMPTY
94396: LIST
94397: LIST
94398: LIST
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: ST_TO_ADDR
// end ; 2 :
94407: GO 94966
94409: LD_INT 2
94411: DOUBLE
94412: EQUAL
94413: IFTRUE 94417
94415: GO 94546
94417: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
94418: LD_ADDR_VAR 0 5
94422: PUSH
94423: LD_VAR 0 1
94427: PUSH
94428: LD_VAR 0 2
94432: PUSH
94433: LD_INT 3
94435: MINUS
94436: PUSH
94437: LD_INT 3
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: LIST
94444: PUSH
94445: LD_VAR 0 1
94449: PUSH
94450: LD_INT 4
94452: PLUS
94453: PUSH
94454: LD_VAR 0 2
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: LIST
94466: PUSH
94467: LD_VAR 0 1
94471: PUSH
94472: LD_VAR 0 2
94476: PUSH
94477: LD_INT 4
94479: PLUS
94480: PUSH
94481: LD_INT 0
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: LIST
94488: PUSH
94489: LD_VAR 0 1
94493: PUSH
94494: LD_INT 3
94496: MINUS
94497: PUSH
94498: LD_VAR 0 2
94502: PUSH
94503: LD_INT 1
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: LIST
94510: PUSH
94511: LD_VAR 0 1
94515: PUSH
94516: LD_INT 4
94518: MINUS
94519: PUSH
94520: LD_VAR 0 2
94524: PUSH
94525: LD_INT 4
94527: MINUS
94528: PUSH
94529: LD_INT 2
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: LIST
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: ST_TO_ADDR
// end ; 3 :
94544: GO 94966
94546: LD_INT 3
94548: DOUBLE
94549: EQUAL
94550: IFTRUE 94554
94552: GO 94687
94554: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
94555: LD_ADDR_VAR 0 5
94559: PUSH
94560: LD_VAR 0 1
94564: PUSH
94565: LD_INT 3
94567: PLUS
94568: PUSH
94569: LD_VAR 0 2
94573: PUSH
94574: LD_INT 4
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: LIST
94581: PUSH
94582: LD_VAR 0 1
94586: PUSH
94587: LD_INT 4
94589: PLUS
94590: PUSH
94591: LD_VAR 0 2
94595: PUSH
94596: LD_INT 4
94598: PLUS
94599: PUSH
94600: LD_INT 5
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: LIST
94607: PUSH
94608: LD_VAR 0 1
94612: PUSH
94613: LD_INT 4
94615: MINUS
94616: PUSH
94617: LD_VAR 0 2
94621: PUSH
94622: LD_INT 1
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: LIST
94629: PUSH
94630: LD_VAR 0 1
94634: PUSH
94635: LD_VAR 0 2
94639: PUSH
94640: LD_INT 4
94642: MINUS
94643: PUSH
94644: LD_INT 3
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: LIST
94651: PUSH
94652: LD_VAR 0 1
94656: PUSH
94657: LD_INT 3
94659: MINUS
94660: PUSH
94661: LD_VAR 0 2
94665: PUSH
94666: LD_INT 3
94668: MINUS
94669: PUSH
94670: LD_INT 2
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: LIST
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: ST_TO_ADDR
// end ; 4 :
94685: GO 94966
94687: LD_INT 4
94689: DOUBLE
94690: EQUAL
94691: IFTRUE 94695
94693: GO 94828
94695: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
94696: LD_ADDR_VAR 0 5
94700: PUSH
94701: LD_VAR 0 1
94705: PUSH
94706: LD_VAR 0 2
94710: PUSH
94711: LD_INT 4
94713: PLUS
94714: PUSH
94715: LD_INT 0
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: LIST
94722: PUSH
94723: LD_VAR 0 1
94727: PUSH
94728: LD_INT 3
94730: PLUS
94731: PUSH
94732: LD_VAR 0 2
94736: PUSH
94737: LD_INT 3
94739: PLUS
94740: PUSH
94741: LD_INT 5
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: LIST
94748: PUSH
94749: LD_VAR 0 1
94753: PUSH
94754: LD_INT 4
94756: PLUS
94757: PUSH
94758: LD_VAR 0 2
94762: PUSH
94763: LD_INT 4
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: LIST
94770: PUSH
94771: LD_VAR 0 1
94775: PUSH
94776: LD_VAR 0 2
94780: PUSH
94781: LD_INT 3
94783: MINUS
94784: PUSH
94785: LD_INT 3
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: LIST
94792: PUSH
94793: LD_VAR 0 1
94797: PUSH
94798: LD_INT 4
94800: MINUS
94801: PUSH
94802: LD_VAR 0 2
94806: PUSH
94807: LD_INT 4
94809: MINUS
94810: PUSH
94811: LD_INT 2
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: LIST
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: ST_TO_ADDR
// end ; 5 :
94826: GO 94966
94828: LD_INT 5
94830: DOUBLE
94831: EQUAL
94832: IFTRUE 94836
94834: GO 94965
94836: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
94837: LD_ADDR_VAR 0 5
94841: PUSH
94842: LD_VAR 0 1
94846: PUSH
94847: LD_INT 4
94849: MINUS
94850: PUSH
94851: LD_VAR 0 2
94855: PUSH
94856: LD_INT 1
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: LIST
94863: PUSH
94864: LD_VAR 0 1
94868: PUSH
94869: LD_VAR 0 2
94873: PUSH
94874: LD_INT 4
94876: MINUS
94877: PUSH
94878: LD_INT 3
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: PUSH
94886: LD_VAR 0 1
94890: PUSH
94891: LD_INT 4
94893: PLUS
94894: PUSH
94895: LD_VAR 0 2
94899: PUSH
94900: LD_INT 4
94902: PLUS
94903: PUSH
94904: LD_INT 5
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: LIST
94911: PUSH
94912: LD_VAR 0 1
94916: PUSH
94917: LD_INT 3
94919: PLUS
94920: PUSH
94921: LD_VAR 0 2
94925: PUSH
94926: LD_INT 4
94928: PUSH
94929: EMPTY
94930: LIST
94931: LIST
94932: LIST
94933: PUSH
94934: LD_VAR 0 1
94938: PUSH
94939: LD_VAR 0 2
94943: PUSH
94944: LD_INT 3
94946: PLUS
94947: PUSH
94948: LD_INT 0
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: LIST
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: ST_TO_ADDR
// end ; end ;
94963: GO 94966
94965: POP
// result := list ;
94966: LD_ADDR_VAR 0 4
94970: PUSH
94971: LD_VAR 0 5
94975: ST_TO_ADDR
// end ;
94976: LD_VAR 0 4
94980: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
94981: LD_INT 0
94983: PPUSH
94984: PPUSH
94985: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
94986: LD_VAR 0 1
94990: NOT
94991: PUSH
94992: LD_VAR 0 2
94996: PUSH
94997: LD_INT 1
94999: PUSH
95000: LD_INT 2
95002: PUSH
95003: LD_INT 3
95005: PUSH
95006: LD_INT 4
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: IN
95015: NOT
95016: OR
95017: IFFALSE 95021
// exit ;
95019: GO 95113
// tmp := [ ] ;
95021: LD_ADDR_VAR 0 5
95025: PUSH
95026: EMPTY
95027: ST_TO_ADDR
// for i in units do
95028: LD_ADDR_VAR 0 4
95032: PUSH
95033: LD_VAR 0 1
95037: PUSH
95038: FOR_IN
95039: IFFALSE 95082
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
95041: LD_ADDR_VAR 0 5
95045: PUSH
95046: LD_VAR 0 5
95050: PPUSH
95051: LD_VAR 0 5
95055: PUSH
95056: LD_INT 1
95058: PLUS
95059: PPUSH
95060: LD_VAR 0 4
95064: PPUSH
95065: LD_VAR 0 2
95069: PPUSH
95070: CALL_OW 259
95074: PPUSH
95075: CALL_OW 2
95079: ST_TO_ADDR
95080: GO 95038
95082: POP
95083: POP
// if not tmp then
95084: LD_VAR 0 5
95088: NOT
95089: IFFALSE 95093
// exit ;
95091: GO 95113
// result := SortListByListDesc ( units , tmp ) ;
95093: LD_ADDR_VAR 0 3
95097: PUSH
95098: LD_VAR 0 1
95102: PPUSH
95103: LD_VAR 0 5
95107: PPUSH
95108: CALL_OW 77
95112: ST_TO_ADDR
// end ;
95113: LD_VAR 0 3
95117: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
95118: LD_INT 0
95120: PPUSH
95121: PPUSH
95122: PPUSH
// result := false ;
95123: LD_ADDR_VAR 0 3
95127: PUSH
95128: LD_INT 0
95130: ST_TO_ADDR
// x := GetX ( building ) ;
95131: LD_ADDR_VAR 0 4
95135: PUSH
95136: LD_VAR 0 2
95140: PPUSH
95141: CALL_OW 250
95145: ST_TO_ADDR
// y := GetY ( building ) ;
95146: LD_ADDR_VAR 0 5
95150: PUSH
95151: LD_VAR 0 2
95155: PPUSH
95156: CALL_OW 251
95160: ST_TO_ADDR
// if not building or not x or not y then
95161: LD_VAR 0 2
95165: NOT
95166: PUSH
95167: LD_VAR 0 4
95171: NOT
95172: OR
95173: PUSH
95174: LD_VAR 0 5
95178: NOT
95179: OR
95180: IFFALSE 95184
// exit ;
95182: GO 95276
// if GetTaskList ( unit ) then
95184: LD_VAR 0 1
95188: PPUSH
95189: CALL_OW 437
95193: IFFALSE 95276
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95195: LD_STRING e
95197: PUSH
95198: LD_VAR 0 1
95202: PPUSH
95203: CALL_OW 437
95207: PUSH
95208: LD_INT 1
95210: ARRAY
95211: PUSH
95212: LD_INT 1
95214: ARRAY
95215: EQUAL
95216: PUSH
95217: LD_VAR 0 4
95221: PUSH
95222: LD_VAR 0 1
95226: PPUSH
95227: CALL_OW 437
95231: PUSH
95232: LD_INT 1
95234: ARRAY
95235: PUSH
95236: LD_INT 2
95238: ARRAY
95239: EQUAL
95240: AND
95241: PUSH
95242: LD_VAR 0 5
95246: PUSH
95247: LD_VAR 0 1
95251: PPUSH
95252: CALL_OW 437
95256: PUSH
95257: LD_INT 1
95259: ARRAY
95260: PUSH
95261: LD_INT 3
95263: ARRAY
95264: EQUAL
95265: AND
95266: IFFALSE 95276
// result := true end ;
95268: LD_ADDR_VAR 0 3
95272: PUSH
95273: LD_INT 1
95275: ST_TO_ADDR
// end ;
95276: LD_VAR 0 3
95280: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
95281: LD_INT 0
95283: PPUSH
// result := false ;
95284: LD_ADDR_VAR 0 4
95288: PUSH
95289: LD_INT 0
95291: ST_TO_ADDR
// if GetTaskList ( unit ) then
95292: LD_VAR 0 1
95296: PPUSH
95297: CALL_OW 437
95301: IFFALSE 95384
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95303: LD_STRING M
95305: PUSH
95306: LD_VAR 0 1
95310: PPUSH
95311: CALL_OW 437
95315: PUSH
95316: LD_INT 1
95318: ARRAY
95319: PUSH
95320: LD_INT 1
95322: ARRAY
95323: EQUAL
95324: PUSH
95325: LD_VAR 0 2
95329: PUSH
95330: LD_VAR 0 1
95334: PPUSH
95335: CALL_OW 437
95339: PUSH
95340: LD_INT 1
95342: ARRAY
95343: PUSH
95344: LD_INT 2
95346: ARRAY
95347: EQUAL
95348: AND
95349: PUSH
95350: LD_VAR 0 3
95354: PUSH
95355: LD_VAR 0 1
95359: PPUSH
95360: CALL_OW 437
95364: PUSH
95365: LD_INT 1
95367: ARRAY
95368: PUSH
95369: LD_INT 3
95371: ARRAY
95372: EQUAL
95373: AND
95374: IFFALSE 95384
// result := true ;
95376: LD_ADDR_VAR 0 4
95380: PUSH
95381: LD_INT 1
95383: ST_TO_ADDR
// end ; end ;
95384: LD_VAR 0 4
95388: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
95389: LD_INT 0
95391: PPUSH
95392: PPUSH
95393: PPUSH
95394: PPUSH
// if not unit or not area then
95395: LD_VAR 0 1
95399: NOT
95400: PUSH
95401: LD_VAR 0 2
95405: NOT
95406: OR
95407: IFFALSE 95411
// exit ;
95409: GO 95575
// tmp := AreaToList ( area , i ) ;
95411: LD_ADDR_VAR 0 6
95415: PUSH
95416: LD_VAR 0 2
95420: PPUSH
95421: LD_VAR 0 5
95425: PPUSH
95426: CALL_OW 517
95430: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
95431: LD_ADDR_VAR 0 5
95435: PUSH
95436: DOUBLE
95437: LD_INT 1
95439: DEC
95440: ST_TO_ADDR
95441: LD_VAR 0 6
95445: PUSH
95446: LD_INT 1
95448: ARRAY
95449: PUSH
95450: FOR_TO
95451: IFFALSE 95573
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
95453: LD_ADDR_VAR 0 7
95457: PUSH
95458: LD_VAR 0 6
95462: PUSH
95463: LD_INT 1
95465: ARRAY
95466: PUSH
95467: LD_VAR 0 5
95471: ARRAY
95472: PUSH
95473: LD_VAR 0 6
95477: PUSH
95478: LD_INT 2
95480: ARRAY
95481: PUSH
95482: LD_VAR 0 5
95486: ARRAY
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
95492: LD_VAR 0 7
95496: PUSH
95497: LD_INT 1
95499: ARRAY
95500: PPUSH
95501: LD_VAR 0 7
95505: PUSH
95506: LD_INT 2
95508: ARRAY
95509: PPUSH
95510: CALL_OW 428
95514: PUSH
95515: LD_INT 0
95517: EQUAL
95518: IFFALSE 95571
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
95520: LD_VAR 0 1
95524: PPUSH
95525: LD_VAR 0 7
95529: PUSH
95530: LD_INT 1
95532: ARRAY
95533: PPUSH
95534: LD_VAR 0 7
95538: PUSH
95539: LD_INT 2
95541: ARRAY
95542: PPUSH
95543: LD_VAR 0 3
95547: PPUSH
95548: CALL_OW 48
// result := IsPlaced ( unit ) ;
95552: LD_ADDR_VAR 0 4
95556: PUSH
95557: LD_VAR 0 1
95561: PPUSH
95562: CALL_OW 305
95566: ST_TO_ADDR
// exit ;
95567: POP
95568: POP
95569: GO 95575
// end ; end ;
95571: GO 95450
95573: POP
95574: POP
// end ;
95575: LD_VAR 0 4
95579: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
95580: LD_INT 0
95582: PPUSH
95583: PPUSH
95584: PPUSH
// if not side or side > 8 then
95585: LD_VAR 0 1
95589: NOT
95590: PUSH
95591: LD_VAR 0 1
95595: PUSH
95596: LD_INT 8
95598: GREATER
95599: OR
95600: IFFALSE 95604
// exit ;
95602: GO 95791
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
95604: LD_ADDR_VAR 0 4
95608: PUSH
95609: LD_INT 22
95611: PUSH
95612: LD_VAR 0 1
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: PUSH
95621: LD_INT 21
95623: PUSH
95624: LD_INT 3
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PPUSH
95635: CALL_OW 69
95639: ST_TO_ADDR
// if not tmp then
95640: LD_VAR 0 4
95644: NOT
95645: IFFALSE 95649
// exit ;
95647: GO 95791
// enable_addtolog := true ;
95649: LD_ADDR_OWVAR 81
95653: PUSH
95654: LD_INT 1
95656: ST_TO_ADDR
// AddToLog ( [ ) ;
95657: LD_STRING [
95659: PPUSH
95660: CALL_OW 561
// for i in tmp do
95664: LD_ADDR_VAR 0 3
95668: PUSH
95669: LD_VAR 0 4
95673: PUSH
95674: FOR_IN
95675: IFFALSE 95782
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
95677: LD_STRING [
95679: PUSH
95680: LD_VAR 0 3
95684: PPUSH
95685: CALL_OW 266
95689: STR
95690: PUSH
95691: LD_STRING , 
95693: STR
95694: PUSH
95695: LD_VAR 0 3
95699: PPUSH
95700: CALL_OW 250
95704: STR
95705: PUSH
95706: LD_STRING , 
95708: STR
95709: PUSH
95710: LD_VAR 0 3
95714: PPUSH
95715: CALL_OW 251
95719: STR
95720: PUSH
95721: LD_STRING , 
95723: STR
95724: PUSH
95725: LD_VAR 0 3
95729: PPUSH
95730: CALL_OW 254
95734: STR
95735: PUSH
95736: LD_STRING , 
95738: STR
95739: PUSH
95740: LD_VAR 0 3
95744: PPUSH
95745: LD_INT 1
95747: PPUSH
95748: CALL_OW 268
95752: STR
95753: PUSH
95754: LD_STRING , 
95756: STR
95757: PUSH
95758: LD_VAR 0 3
95762: PPUSH
95763: LD_INT 2
95765: PPUSH
95766: CALL_OW 268
95770: STR
95771: PUSH
95772: LD_STRING ],
95774: STR
95775: PPUSH
95776: CALL_OW 561
// end ;
95780: GO 95674
95782: POP
95783: POP
// AddToLog ( ]; ) ;
95784: LD_STRING ];
95786: PPUSH
95787: CALL_OW 561
// end ;
95791: LD_VAR 0 2
95795: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
95796: LD_INT 0
95798: PPUSH
95799: PPUSH
95800: PPUSH
95801: PPUSH
95802: PPUSH
// if not area or not rate or not max then
95803: LD_VAR 0 1
95807: NOT
95808: PUSH
95809: LD_VAR 0 2
95813: NOT
95814: OR
95815: PUSH
95816: LD_VAR 0 4
95820: NOT
95821: OR
95822: IFFALSE 95826
// exit ;
95824: GO 96018
// while 1 do
95826: LD_INT 1
95828: IFFALSE 96018
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
95830: LD_ADDR_VAR 0 9
95834: PUSH
95835: LD_VAR 0 1
95839: PPUSH
95840: LD_INT 1
95842: PPUSH
95843: CALL_OW 287
95847: PUSH
95848: LD_INT 10
95850: MUL
95851: ST_TO_ADDR
// r := rate / 10 ;
95852: LD_ADDR_VAR 0 7
95856: PUSH
95857: LD_VAR 0 2
95861: PUSH
95862: LD_INT 10
95864: DIVREAL
95865: ST_TO_ADDR
// time := 1 1$00 ;
95866: LD_ADDR_VAR 0 8
95870: PUSH
95871: LD_INT 2100
95873: ST_TO_ADDR
// if amount < min then
95874: LD_VAR 0 9
95878: PUSH
95879: LD_VAR 0 3
95883: LESS
95884: IFFALSE 95902
// r := r * 2 else
95886: LD_ADDR_VAR 0 7
95890: PUSH
95891: LD_VAR 0 7
95895: PUSH
95896: LD_INT 2
95898: MUL
95899: ST_TO_ADDR
95900: GO 95928
// if amount > max then
95902: LD_VAR 0 9
95906: PUSH
95907: LD_VAR 0 4
95911: GREATER
95912: IFFALSE 95928
// r := r / 2 ;
95914: LD_ADDR_VAR 0 7
95918: PUSH
95919: LD_VAR 0 7
95923: PUSH
95924: LD_INT 2
95926: DIVREAL
95927: ST_TO_ADDR
// time := time / r ;
95928: LD_ADDR_VAR 0 8
95932: PUSH
95933: LD_VAR 0 8
95937: PUSH
95938: LD_VAR 0 7
95942: DIVREAL
95943: ST_TO_ADDR
// if time < 0 then
95944: LD_VAR 0 8
95948: PUSH
95949: LD_INT 0
95951: LESS
95952: IFFALSE 95969
// time := time * - 1 ;
95954: LD_ADDR_VAR 0 8
95958: PUSH
95959: LD_VAR 0 8
95963: PUSH
95964: LD_INT 1
95966: NEG
95967: MUL
95968: ST_TO_ADDR
// wait ( time ) ;
95969: LD_VAR 0 8
95973: PPUSH
95974: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
95978: LD_INT 35
95980: PPUSH
95981: LD_INT 875
95983: PPUSH
95984: CALL_OW 12
95988: PPUSH
95989: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
95993: LD_INT 1
95995: PPUSH
95996: LD_INT 5
95998: PPUSH
95999: CALL_OW 12
96003: PPUSH
96004: LD_VAR 0 1
96008: PPUSH
96009: LD_INT 1
96011: PPUSH
96012: CALL_OW 55
// end ;
96016: GO 95826
// end ;
96018: LD_VAR 0 5
96022: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
96023: LD_INT 0
96025: PPUSH
96026: PPUSH
96027: PPUSH
96028: PPUSH
96029: PPUSH
96030: PPUSH
96031: PPUSH
96032: PPUSH
// if not turrets or not factories then
96033: LD_VAR 0 1
96037: NOT
96038: PUSH
96039: LD_VAR 0 2
96043: NOT
96044: OR
96045: IFFALSE 96049
// exit ;
96047: GO 96356
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
96049: LD_ADDR_VAR 0 10
96053: PUSH
96054: LD_INT 5
96056: PUSH
96057: LD_INT 6
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 2
96066: PUSH
96067: LD_INT 4
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 3
96076: PUSH
96077: LD_INT 5
96079: PUSH
96080: EMPTY
96081: LIST
96082: LIST
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: LIST
96088: PUSH
96089: LD_INT 24
96091: PUSH
96092: LD_INT 25
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: PUSH
96099: LD_INT 23
96101: PUSH
96102: LD_INT 27
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PUSH
96113: LD_INT 42
96115: PUSH
96116: LD_INT 43
96118: PUSH
96119: EMPTY
96120: LIST
96121: LIST
96122: PUSH
96123: LD_INT 44
96125: PUSH
96126: LD_INT 46
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 45
96135: PUSH
96136: LD_INT 47
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: LIST
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: LIST
96152: ST_TO_ADDR
// result := [ ] ;
96153: LD_ADDR_VAR 0 3
96157: PUSH
96158: EMPTY
96159: ST_TO_ADDR
// for i in turrets do
96160: LD_ADDR_VAR 0 4
96164: PUSH
96165: LD_VAR 0 1
96169: PUSH
96170: FOR_IN
96171: IFFALSE 96354
// begin nat := GetNation ( i ) ;
96173: LD_ADDR_VAR 0 7
96177: PUSH
96178: LD_VAR 0 4
96182: PPUSH
96183: CALL_OW 248
96187: ST_TO_ADDR
// weapon := 0 ;
96188: LD_ADDR_VAR 0 8
96192: PUSH
96193: LD_INT 0
96195: ST_TO_ADDR
// if not nat then
96196: LD_VAR 0 7
96200: NOT
96201: IFFALSE 96205
// continue ;
96203: GO 96170
// for j in list [ nat ] do
96205: LD_ADDR_VAR 0 5
96209: PUSH
96210: LD_VAR 0 10
96214: PUSH
96215: LD_VAR 0 7
96219: ARRAY
96220: PUSH
96221: FOR_IN
96222: IFFALSE 96263
// if GetBWeapon ( i ) = j [ 1 ] then
96224: LD_VAR 0 4
96228: PPUSH
96229: CALL_OW 269
96233: PUSH
96234: LD_VAR 0 5
96238: PUSH
96239: LD_INT 1
96241: ARRAY
96242: EQUAL
96243: IFFALSE 96261
// begin weapon := j [ 2 ] ;
96245: LD_ADDR_VAR 0 8
96249: PUSH
96250: LD_VAR 0 5
96254: PUSH
96255: LD_INT 2
96257: ARRAY
96258: ST_TO_ADDR
// break ;
96259: GO 96263
// end ;
96261: GO 96221
96263: POP
96264: POP
// if not weapon then
96265: LD_VAR 0 8
96269: NOT
96270: IFFALSE 96274
// continue ;
96272: GO 96170
// for k in factories do
96274: LD_ADDR_VAR 0 6
96278: PUSH
96279: LD_VAR 0 2
96283: PUSH
96284: FOR_IN
96285: IFFALSE 96350
// begin weapons := AvailableWeaponList ( k ) ;
96287: LD_ADDR_VAR 0 9
96291: PUSH
96292: LD_VAR 0 6
96296: PPUSH
96297: CALL_OW 478
96301: ST_TO_ADDR
// if not weapons then
96302: LD_VAR 0 9
96306: NOT
96307: IFFALSE 96311
// continue ;
96309: GO 96284
// if weapon in weapons then
96311: LD_VAR 0 8
96315: PUSH
96316: LD_VAR 0 9
96320: IN
96321: IFFALSE 96348
// begin result := [ i , weapon ] ;
96323: LD_ADDR_VAR 0 3
96327: PUSH
96328: LD_VAR 0 4
96332: PUSH
96333: LD_VAR 0 8
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: ST_TO_ADDR
// exit ;
96342: POP
96343: POP
96344: POP
96345: POP
96346: GO 96356
// end ; end ;
96348: GO 96284
96350: POP
96351: POP
// end ;
96352: GO 96170
96354: POP
96355: POP
// end ;
96356: LD_VAR 0 3
96360: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
96361: LD_INT 0
96363: PPUSH
// if not side or side > 8 then
96364: LD_VAR 0 3
96368: NOT
96369: PUSH
96370: LD_VAR 0 3
96374: PUSH
96375: LD_INT 8
96377: GREATER
96378: OR
96379: IFFALSE 96383
// exit ;
96381: GO 96442
// if not range then
96383: LD_VAR 0 4
96387: NOT
96388: IFFALSE 96399
// range := - 12 ;
96390: LD_ADDR_VAR 0 4
96394: PUSH
96395: LD_INT 12
96397: NEG
96398: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
96399: LD_VAR 0 1
96403: PPUSH
96404: LD_VAR 0 2
96408: PPUSH
96409: LD_VAR 0 3
96413: PPUSH
96414: LD_VAR 0 4
96418: PPUSH
96419: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
96423: LD_VAR 0 1
96427: PPUSH
96428: LD_VAR 0 2
96432: PPUSH
96433: LD_VAR 0 3
96437: PPUSH
96438: CALL_OW 331
// end ;
96442: LD_VAR 0 5
96446: RET
// export function Video ( mode ) ; begin
96447: LD_INT 0
96449: PPUSH
// ingame_video = mode ;
96450: LD_ADDR_OWVAR 52
96454: PUSH
96455: LD_VAR 0 1
96459: ST_TO_ADDR
// interface_hidden = mode ;
96460: LD_ADDR_OWVAR 54
96464: PUSH
96465: LD_VAR 0 1
96469: ST_TO_ADDR
// end ;
96470: LD_VAR 0 2
96474: RET
// export function Join ( array , element ) ; begin
96475: LD_INT 0
96477: PPUSH
// result := Replace ( array , array + 1 , element ) ;
96478: LD_ADDR_VAR 0 3
96482: PUSH
96483: LD_VAR 0 1
96487: PPUSH
96488: LD_VAR 0 1
96492: PUSH
96493: LD_INT 1
96495: PLUS
96496: PPUSH
96497: LD_VAR 0 2
96501: PPUSH
96502: CALL_OW 1
96506: ST_TO_ADDR
// end ;
96507: LD_VAR 0 3
96511: RET
// export function JoinUnion ( array , element ) ; begin
96512: LD_INT 0
96514: PPUSH
// result := array union element ;
96515: LD_ADDR_VAR 0 3
96519: PUSH
96520: LD_VAR 0 1
96524: PUSH
96525: LD_VAR 0 2
96529: UNION
96530: ST_TO_ADDR
// end ;
96531: LD_VAR 0 3
96535: RET
// export function GetBehemoths ( side ) ; begin
96536: LD_INT 0
96538: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
96539: LD_ADDR_VAR 0 2
96543: PUSH
96544: LD_INT 22
96546: PUSH
96547: LD_VAR 0 1
96551: PUSH
96552: EMPTY
96553: LIST
96554: LIST
96555: PUSH
96556: LD_INT 31
96558: PUSH
96559: LD_INT 25
96561: PUSH
96562: EMPTY
96563: LIST
96564: LIST
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PPUSH
96570: CALL_OW 69
96574: ST_TO_ADDR
// end ;
96575: LD_VAR 0 2
96579: RET
// export function Shuffle ( array ) ; var i , index ; begin
96580: LD_INT 0
96582: PPUSH
96583: PPUSH
96584: PPUSH
// result := [ ] ;
96585: LD_ADDR_VAR 0 2
96589: PUSH
96590: EMPTY
96591: ST_TO_ADDR
// if not array then
96592: LD_VAR 0 1
96596: NOT
96597: IFFALSE 96601
// exit ;
96599: GO 96700
// Randomize ;
96601: CALL_OW 10
// for i = array downto 1 do
96605: LD_ADDR_VAR 0 3
96609: PUSH
96610: DOUBLE
96611: LD_VAR 0 1
96615: INC
96616: ST_TO_ADDR
96617: LD_INT 1
96619: PUSH
96620: FOR_DOWNTO
96621: IFFALSE 96698
// begin index := rand ( 1 , array ) ;
96623: LD_ADDR_VAR 0 4
96627: PUSH
96628: LD_INT 1
96630: PPUSH
96631: LD_VAR 0 1
96635: PPUSH
96636: CALL_OW 12
96640: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
96641: LD_ADDR_VAR 0 2
96645: PUSH
96646: LD_VAR 0 2
96650: PPUSH
96651: LD_VAR 0 2
96655: PUSH
96656: LD_INT 1
96658: PLUS
96659: PPUSH
96660: LD_VAR 0 1
96664: PUSH
96665: LD_VAR 0 4
96669: ARRAY
96670: PPUSH
96671: CALL_OW 2
96675: ST_TO_ADDR
// array := Delete ( array , index ) ;
96676: LD_ADDR_VAR 0 1
96680: PUSH
96681: LD_VAR 0 1
96685: PPUSH
96686: LD_VAR 0 4
96690: PPUSH
96691: CALL_OW 3
96695: ST_TO_ADDR
// end ;
96696: GO 96620
96698: POP
96699: POP
// end ;
96700: LD_VAR 0 2
96704: RET
// export function GetBaseMaterials ( base ) ; begin
96705: LD_INT 0
96707: PPUSH
// result := [ 0 , 0 , 0 ] ;
96708: LD_ADDR_VAR 0 2
96712: PUSH
96713: LD_INT 0
96715: PUSH
96716: LD_INT 0
96718: PUSH
96719: LD_INT 0
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: LIST
96726: ST_TO_ADDR
// if not base then
96727: LD_VAR 0 1
96731: NOT
96732: IFFALSE 96736
// exit ;
96734: GO 96785
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
96736: LD_ADDR_VAR 0 2
96740: PUSH
96741: LD_VAR 0 1
96745: PPUSH
96746: LD_INT 1
96748: PPUSH
96749: CALL_OW 275
96753: PUSH
96754: LD_VAR 0 1
96758: PPUSH
96759: LD_INT 2
96761: PPUSH
96762: CALL_OW 275
96766: PUSH
96767: LD_VAR 0 1
96771: PPUSH
96772: LD_INT 3
96774: PPUSH
96775: CALL_OW 275
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: LIST
96784: ST_TO_ADDR
// end ;
96785: LD_VAR 0 2
96789: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
96790: LD_INT 0
96792: PPUSH
96793: PPUSH
// result := array ;
96794: LD_ADDR_VAR 0 3
96798: PUSH
96799: LD_VAR 0 1
96803: ST_TO_ADDR
// if size > 0 then
96804: LD_VAR 0 2
96808: PUSH
96809: LD_INT 0
96811: GREATER
96812: IFFALSE 96858
// for i := array downto size do
96814: LD_ADDR_VAR 0 4
96818: PUSH
96819: DOUBLE
96820: LD_VAR 0 1
96824: INC
96825: ST_TO_ADDR
96826: LD_VAR 0 2
96830: PUSH
96831: FOR_DOWNTO
96832: IFFALSE 96856
// result := Delete ( result , result ) ;
96834: LD_ADDR_VAR 0 3
96838: PUSH
96839: LD_VAR 0 3
96843: PPUSH
96844: LD_VAR 0 3
96848: PPUSH
96849: CALL_OW 3
96853: ST_TO_ADDR
96854: GO 96831
96856: POP
96857: POP
// end ;
96858: LD_VAR 0 3
96862: RET
// export function ComExit ( unit ) ; var tmp ; begin
96863: LD_INT 0
96865: PPUSH
96866: PPUSH
// if not IsInUnit ( unit ) then
96867: LD_VAR 0 1
96871: PPUSH
96872: CALL_OW 310
96876: NOT
96877: IFFALSE 96881
// exit ;
96879: GO 96941
// tmp := IsInUnit ( unit ) ;
96881: LD_ADDR_VAR 0 3
96885: PUSH
96886: LD_VAR 0 1
96890: PPUSH
96891: CALL_OW 310
96895: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
96896: LD_VAR 0 3
96900: PPUSH
96901: CALL_OW 247
96905: PUSH
96906: LD_INT 2
96908: EQUAL
96909: IFFALSE 96922
// ComExitVehicle ( unit ) else
96911: LD_VAR 0 1
96915: PPUSH
96916: CALL_OW 121
96920: GO 96931
// ComExitBuilding ( unit ) ;
96922: LD_VAR 0 1
96926: PPUSH
96927: CALL_OW 122
// result := tmp ;
96931: LD_ADDR_VAR 0 2
96935: PUSH
96936: LD_VAR 0 3
96940: ST_TO_ADDR
// end ;
96941: LD_VAR 0 2
96945: RET
// export function ResetHc ; begin
96946: LD_INT 0
96948: PPUSH
// InitHc ;
96949: CALL_OW 19
// hc_importance := 0 ;
96953: LD_ADDR_OWVAR 32
96957: PUSH
96958: LD_INT 0
96960: ST_TO_ADDR
// end ;
96961: LD_VAR 0 1
96965: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
96966: LD_INT 0
96968: PPUSH
96969: PPUSH
96970: PPUSH
// _x := ( x1 + x2 ) div 2 ;
96971: LD_ADDR_VAR 0 6
96975: PUSH
96976: LD_VAR 0 1
96980: PUSH
96981: LD_VAR 0 3
96985: PLUS
96986: PUSH
96987: LD_INT 2
96989: DIV
96990: ST_TO_ADDR
// if _x < 0 then
96991: LD_VAR 0 6
96995: PUSH
96996: LD_INT 0
96998: LESS
96999: IFFALSE 97016
// _x := _x * - 1 ;
97001: LD_ADDR_VAR 0 6
97005: PUSH
97006: LD_VAR 0 6
97010: PUSH
97011: LD_INT 1
97013: NEG
97014: MUL
97015: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
97016: LD_ADDR_VAR 0 7
97020: PUSH
97021: LD_VAR 0 2
97025: PUSH
97026: LD_VAR 0 4
97030: PLUS
97031: PUSH
97032: LD_INT 2
97034: DIV
97035: ST_TO_ADDR
// if _y < 0 then
97036: LD_VAR 0 7
97040: PUSH
97041: LD_INT 0
97043: LESS
97044: IFFALSE 97061
// _y := _y * - 1 ;
97046: LD_ADDR_VAR 0 7
97050: PUSH
97051: LD_VAR 0 7
97055: PUSH
97056: LD_INT 1
97058: NEG
97059: MUL
97060: ST_TO_ADDR
// result := [ _x , _y ] ;
97061: LD_ADDR_VAR 0 5
97065: PUSH
97066: LD_VAR 0 6
97070: PUSH
97071: LD_VAR 0 7
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: ST_TO_ADDR
// end ;
97080: LD_VAR 0 5
97084: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
97085: LD_INT 0
97087: PPUSH
97088: PPUSH
97089: PPUSH
97090: PPUSH
// task := GetTaskList ( unit ) ;
97091: LD_ADDR_VAR 0 7
97095: PUSH
97096: LD_VAR 0 1
97100: PPUSH
97101: CALL_OW 437
97105: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
97106: LD_VAR 0 7
97110: NOT
97111: PUSH
97112: LD_VAR 0 1
97116: PPUSH
97117: LD_VAR 0 2
97121: PPUSH
97122: CALL_OW 308
97126: NOT
97127: AND
97128: IFFALSE 97132
// exit ;
97130: GO 97250
// if IsInArea ( unit , area ) then
97132: LD_VAR 0 1
97136: PPUSH
97137: LD_VAR 0 2
97141: PPUSH
97142: CALL_OW 308
97146: IFFALSE 97164
// begin ComMoveToArea ( unit , goAway ) ;
97148: LD_VAR 0 1
97152: PPUSH
97153: LD_VAR 0 3
97157: PPUSH
97158: CALL_OW 113
// exit ;
97162: GO 97250
// end ; if task [ 1 ] [ 1 ] <> M then
97164: LD_VAR 0 7
97168: PUSH
97169: LD_INT 1
97171: ARRAY
97172: PUSH
97173: LD_INT 1
97175: ARRAY
97176: PUSH
97177: LD_STRING M
97179: NONEQUAL
97180: IFFALSE 97184
// exit ;
97182: GO 97250
// x := task [ 1 ] [ 2 ] ;
97184: LD_ADDR_VAR 0 5
97188: PUSH
97189: LD_VAR 0 7
97193: PUSH
97194: LD_INT 1
97196: ARRAY
97197: PUSH
97198: LD_INT 2
97200: ARRAY
97201: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
97202: LD_ADDR_VAR 0 6
97206: PUSH
97207: LD_VAR 0 7
97211: PUSH
97212: LD_INT 1
97214: ARRAY
97215: PUSH
97216: LD_INT 3
97218: ARRAY
97219: ST_TO_ADDR
// if InArea ( x , y , area ) then
97220: LD_VAR 0 5
97224: PPUSH
97225: LD_VAR 0 6
97229: PPUSH
97230: LD_VAR 0 2
97234: PPUSH
97235: CALL_OW 309
97239: IFFALSE 97250
// ComStop ( unit ) ;
97241: LD_VAR 0 1
97245: PPUSH
97246: CALL_OW 141
// end ;
97250: LD_VAR 0 4
97254: RET
// export function Abs ( value ) ; begin
97255: LD_INT 0
97257: PPUSH
// result := value ;
97258: LD_ADDR_VAR 0 2
97262: PUSH
97263: LD_VAR 0 1
97267: ST_TO_ADDR
// if value < 0 then
97268: LD_VAR 0 1
97272: PUSH
97273: LD_INT 0
97275: LESS
97276: IFFALSE 97293
// result := value * - 1 ;
97278: LD_ADDR_VAR 0 2
97282: PUSH
97283: LD_VAR 0 1
97287: PUSH
97288: LD_INT 1
97290: NEG
97291: MUL
97292: ST_TO_ADDR
// end ;
97293: LD_VAR 0 2
97297: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
97298: LD_INT 0
97300: PPUSH
97301: PPUSH
97302: PPUSH
97303: PPUSH
97304: PPUSH
97305: PPUSH
97306: PPUSH
97307: PPUSH
// if not unit or not building then
97308: LD_VAR 0 1
97312: NOT
97313: PUSH
97314: LD_VAR 0 2
97318: NOT
97319: OR
97320: IFFALSE 97324
// exit ;
97322: GO 97550
// x := GetX ( building ) ;
97324: LD_ADDR_VAR 0 4
97328: PUSH
97329: LD_VAR 0 2
97333: PPUSH
97334: CALL_OW 250
97338: ST_TO_ADDR
// y := GetY ( building ) ;
97339: LD_ADDR_VAR 0 6
97343: PUSH
97344: LD_VAR 0 2
97348: PPUSH
97349: CALL_OW 251
97353: ST_TO_ADDR
// d := GetDir ( building ) ;
97354: LD_ADDR_VAR 0 8
97358: PUSH
97359: LD_VAR 0 2
97363: PPUSH
97364: CALL_OW 254
97368: ST_TO_ADDR
// r := 4 ;
97369: LD_ADDR_VAR 0 9
97373: PUSH
97374: LD_INT 4
97376: ST_TO_ADDR
// for i := 1 to 5 do
97377: LD_ADDR_VAR 0 10
97381: PUSH
97382: DOUBLE
97383: LD_INT 1
97385: DEC
97386: ST_TO_ADDR
97387: LD_INT 5
97389: PUSH
97390: FOR_TO
97391: IFFALSE 97548
// begin _x := ShiftX ( x , d , r + i ) ;
97393: LD_ADDR_VAR 0 5
97397: PUSH
97398: LD_VAR 0 4
97402: PPUSH
97403: LD_VAR 0 8
97407: PPUSH
97408: LD_VAR 0 9
97412: PUSH
97413: LD_VAR 0 10
97417: PLUS
97418: PPUSH
97419: CALL_OW 272
97423: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
97424: LD_ADDR_VAR 0 7
97428: PUSH
97429: LD_VAR 0 6
97433: PPUSH
97434: LD_VAR 0 8
97438: PPUSH
97439: LD_VAR 0 9
97443: PUSH
97444: LD_VAR 0 10
97448: PLUS
97449: PPUSH
97450: CALL_OW 273
97454: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
97455: LD_VAR 0 5
97459: PPUSH
97460: LD_VAR 0 7
97464: PPUSH
97465: CALL_OW 488
97469: PUSH
97470: LD_VAR 0 5
97474: PPUSH
97475: LD_VAR 0 7
97479: PPUSH
97480: CALL_OW 428
97484: PPUSH
97485: CALL_OW 247
97489: PUSH
97490: LD_INT 3
97492: PUSH
97493: LD_INT 2
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: IN
97500: NOT
97501: AND
97502: IFFALSE 97546
// begin ComMoveXY ( unit , _x , _y ) ;
97504: LD_VAR 0 1
97508: PPUSH
97509: LD_VAR 0 5
97513: PPUSH
97514: LD_VAR 0 7
97518: PPUSH
97519: CALL_OW 111
// result := [ _x , _y ] ;
97523: LD_ADDR_VAR 0 3
97527: PUSH
97528: LD_VAR 0 5
97532: PUSH
97533: LD_VAR 0 7
97537: PUSH
97538: EMPTY
97539: LIST
97540: LIST
97541: ST_TO_ADDR
// exit ;
97542: POP
97543: POP
97544: GO 97550
// end ; end ;
97546: GO 97390
97548: POP
97549: POP
// end ;
97550: LD_VAR 0 3
97554: RET
