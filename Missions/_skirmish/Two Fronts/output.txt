// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7474 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4575 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 32
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4874 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3000 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2627 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3000 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2627 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3000 0 4
// MC_Registry ( ) ;
 213: CALL 41962 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42413 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 33
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21205 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21141 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18134 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21041 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22055 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21282 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21075 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21108 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17913 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21963 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20220 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20795 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20795 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20592 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20256 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20432 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19716 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20330 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20831 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21571 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21141 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18134 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21041 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21282 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21075 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21108 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17913 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21963 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20220 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20795 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20795 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20592 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20256 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20432 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19716 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20330 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20831 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21571 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 11
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 12
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 13
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 14
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 15
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 9
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// end ;
1629: LD_VAR 0 1
1633: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1634: LD_INT 8
1636: PPUSH
1637: CALL_OW 353
1641: PUSH
1642: LD_INT 0
1644: EQUAL
1645: IFFALSE 1680
1647: GO 1649
1649: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1650: LD_INT 1
1652: PPUSH
1653: LD_INT 32
1655: PPUSH
1656: LD_INT 50
1658: PUSH
1659: LD_INT 10
1661: PUSH
1662: LD_INT 4
1664: PUSH
1665: EMPTY
1666: LIST
1667: LIST
1668: LIST
1669: PPUSH
1670: LD_INT 7
1672: PUSH
1673: EMPTY
1674: LIST
1675: PPUSH
1676: CALL 19716 0 4
// end ;
1680: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1681: LD_INT 1
1683: PPUSH
1684: LD_INT 30
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: EMPTY
1691: LIST
1692: LIST
1693: PPUSH
1694: CALL 11421 0 2
1698: IFFALSE 1792
1700: GO 1702
1702: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1703: LD_INT 1
1705: PPUSH
1706: LD_INT 3
1708: PUSH
1709: LD_INT 1
1711: PUSH
1712: LD_INT 2
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 3
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: LD_INT 2
1726: PUSH
1727: LD_INT 5
1729: PUSH
1730: LD_INT 3
1732: PUSH
1733: LD_INT 1
1735: PUSH
1736: LD_INT 2
1738: PUSH
1739: LD_INT 5
1741: PUSH
1742: LD_INT 3
1744: PUSH
1745: LD_INT 1
1747: PUSH
1748: LD_INT 2
1750: PUSH
1751: LD_INT 7
1753: PUSH
1754: LD_INT 3
1756: PUSH
1757: LD_INT 1
1759: PUSH
1760: LD_INT 2
1762: PUSH
1763: LD_INT 7
1765: PUSH
1766: EMPTY
1767: LIST
1768: LIST
1769: LIST
1770: LIST
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: PPUSH
1788: CALL 21789 0 2
// end ;
1792: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1793: LD_INT 4
1795: PPUSH
1796: LD_INT 30
1798: PUSH
1799: LD_INT 3
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PPUSH
1806: CALL 11421 0 2
1810: IFFALSE 1904
1812: GO 1814
1814: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1815: LD_INT 4
1817: PPUSH
1818: LD_INT 3
1820: PUSH
1821: LD_INT 1
1823: PUSH
1824: LD_INT 2
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 3
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 2
1838: PUSH
1839: LD_INT 5
1841: PUSH
1842: LD_INT 3
1844: PUSH
1845: LD_INT 1
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 5
1853: PUSH
1854: LD_INT 4
1856: PUSH
1857: LD_INT 1
1859: PUSH
1860: LD_INT 2
1862: PUSH
1863: LD_INT 6
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 2
1874: PUSH
1875: LD_INT 6
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PPUSH
1900: CALL 21789 0 2
// end ;
1904: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1905: LD_INT 1
1907: PPUSH
1908: LD_INT 30
1910: PUSH
1911: LD_INT 3
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: PPUSH
1918: CALL 11421 0 2
1922: PUSH
1923: LD_EXP 70
1927: PUSH
1928: LD_INT 1
1930: ARRAY
1931: PUSH
1932: LD_INT 1
1934: ARRAY
1935: PUSH
1936: LD_INT 0
1938: EQUAL
1939: AND
1940: IFFALSE 2051
1942: GO 1944
1944: DISABLE
// begin enable ;
1945: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1946: LD_INT 1
1948: PPUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 2
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: LD_INT 3
1963: PUSH
1964: LD_INT 1
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 5
1972: PUSH
1973: LD_INT 3
1975: PUSH
1976: LD_INT 1
1978: PUSH
1979: LD_INT 2
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: LD_INT 3
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 2
1993: PUSH
1994: LD_INT 7
1996: PUSH
1997: LD_INT 3
1999: PUSH
2000: LD_INT 1
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 7
2008: PUSH
2009: LD_INT 4
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 2
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: LIST
2028: LIST
2029: LIST
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 21789 0 2
// end ;
2051: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2052: LD_INT 4
2054: PPUSH
2055: LD_INT 30
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PPUSH
2065: CALL 11421 0 2
2069: PUSH
2070: LD_EXP 70
2074: PUSH
2075: LD_INT 4
2077: ARRAY
2078: PUSH
2079: LD_INT 1
2081: ARRAY
2082: PUSH
2083: LD_INT 0
2085: EQUAL
2086: AND
2087: IFFALSE 2198
2089: GO 2091
2091: DISABLE
// begin enable ;
2092: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2093: LD_INT 4
2095: PPUSH
2096: LD_INT 3
2098: PUSH
2099: LD_INT 1
2101: PUSH
2102: LD_INT 2
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 3
2110: PUSH
2111: LD_INT 1
2113: PUSH
2114: LD_INT 2
2116: PUSH
2117: LD_INT 5
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 1
2125: PUSH
2126: LD_INT 2
2128: PUSH
2129: LD_INT 5
2131: PUSH
2132: LD_INT 4
2134: PUSH
2135: LD_INT 1
2137: PUSH
2138: LD_INT 2
2140: PUSH
2141: LD_INT 6
2143: PUSH
2144: LD_INT 4
2146: PUSH
2147: LD_INT 1
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: LD_INT 6
2155: PUSH
2156: LD_INT 3
2158: PUSH
2159: LD_INT 1
2161: PUSH
2162: LD_INT 2
2164: PUSH
2165: LD_INT 5
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: PPUSH
2194: CALL 21789 0 2
// end ;
2198: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2199: LD_EXP 12
2203: PUSH
2204: LD_INT 22
2206: PUSH
2207: LD_INT 6
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 21
2216: PUSH
2217: LD_INT 2
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 3
2226: PUSH
2227: LD_INT 34
2229: PUSH
2230: LD_INT 51
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: LIST
2245: PPUSH
2246: CALL_OW 69
2250: AND
2251: IFFALSE 2380
2253: GO 2255
2255: DISABLE
2256: LD_INT 0
2258: PPUSH
// begin enable ;
2259: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2260: LD_ADDR_VAR 0 1
2264: PUSH
2265: LD_INT 22
2267: PUSH
2268: LD_INT 6
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: LD_INT 21
2277: PUSH
2278: LD_INT 2
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: PUSH
2285: LD_INT 3
2287: PUSH
2288: LD_INT 34
2290: PUSH
2291: LD_INT 51
2293: PUSH
2294: EMPTY
2295: LIST
2296: LIST
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PPUSH
2307: CALL_OW 69
2311: PUSH
2312: FOR_IN
2313: IFFALSE 2378
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2315: LD_VAR 0 1
2319: PPUSH
2320: CALL_OW 314
2324: NOT
2325: PUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: CALL_OW 256
2335: PUSH
2336: LD_INT 250
2338: GREATER
2339: AND
2340: IFFALSE 2376
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2342: LD_VAR 0 1
2346: PPUSH
2347: LD_INT 81
2349: PUSH
2350: LD_INT 6
2352: PUSH
2353: EMPTY
2354: LIST
2355: LIST
2356: PPUSH
2357: CALL_OW 69
2361: PPUSH
2362: LD_VAR 0 1
2366: PPUSH
2367: CALL_OW 74
2371: PPUSH
2372: CALL_OW 115
2376: GO 2312
2378: POP
2379: POP
// end ;
2380: PPOPN 1
2382: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2383: LD_EXP 12
2387: PUSH
2388: LD_INT 22
2390: PUSH
2391: LD_INT 6
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: LD_INT 21
2400: PUSH
2401: LD_INT 2
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 34
2413: PUSH
2414: LD_INT 51
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: PUSH
2421: EMPTY
2422: LIST
2423: LIST
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: LIST
2429: PPUSH
2430: CALL_OW 69
2434: PUSH
2435: LD_INT 0
2437: EQUAL
2438: AND
2439: IFFALSE 2453
2441: GO 2443
2443: DISABLE
// begin enable ;
2444: ENABLE
// pink_attack := false ;
2445: LD_ADDR_EXP 12
2449: PUSH
2450: LD_INT 0
2452: ST_TO_ADDR
// end ;
2453: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2454: LD_EXP 13
2458: PUSH
2459: LD_INT 22
2461: PUSH
2462: LD_INT 8
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PPUSH
2469: CALL_OW 69
2473: AND
2474: IFFALSE 2585
2476: GO 2478
2478: DISABLE
2479: LD_INT 0
2481: PPUSH
// begin enable ;
2482: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2483: LD_ADDR_VAR 0 1
2487: PUSH
2488: LD_INT 22
2490: PUSH
2491: LD_INT 8
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: PUSH
2498: LD_INT 21
2500: PUSH
2501: LD_INT 2
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: PPUSH
2512: CALL_OW 69
2516: PUSH
2517: FOR_IN
2518: IFFALSE 2583
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2520: LD_VAR 0 1
2524: PPUSH
2525: CALL_OW 314
2529: NOT
2530: PUSH
2531: LD_VAR 0 1
2535: PPUSH
2536: CALL_OW 256
2540: PUSH
2541: LD_INT 250
2543: GREATER
2544: AND
2545: IFFALSE 2581
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2547: LD_VAR 0 1
2551: PPUSH
2552: LD_INT 81
2554: PUSH
2555: LD_INT 8
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: PPUSH
2562: CALL_OW 69
2566: PPUSH
2567: LD_VAR 0 1
2571: PPUSH
2572: CALL_OW 74
2576: PPUSH
2577: CALL_OW 115
2581: GO 2517
2583: POP
2584: POP
// end ;
2585: PPOPN 1
2587: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2588: LD_EXP 13
2592: PUSH
2593: LD_INT 22
2595: PUSH
2596: LD_INT 8
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: PPUSH
2603: CALL_OW 69
2607: PUSH
2608: LD_INT 0
2610: EQUAL
2611: AND
2612: IFFALSE 2626
2614: GO 2616
2616: DISABLE
// begin enable ;
2617: ENABLE
// alfa_support := false ;
2618: LD_ADDR_EXP 13
2622: PUSH
2623: LD_INT 0
2625: ST_TO_ADDR
// end ; end_of_file
2626: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2627: LD_INT 0
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := side ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_VAR 0 1
2642: ST_TO_ADDR
// uc_nation := nat ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// team := [ ] ;
2653: LD_ADDR_VAR 0 10
2657: PUSH
2658: EMPTY
2659: ST_TO_ADDR
// hc_importance := 100 ;
2660: LD_ADDR_OWVAR 32
2664: PUSH
2665: LD_INT 100
2667: ST_TO_ADDR
// case commander of jakes :
2668: LD_VAR 0 4
2672: PUSH
2673: LD_STRING jakes
2675: DOUBLE
2676: EQUAL
2677: IFTRUE 2681
2679: GO 2758
2681: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2682: LD_INT 1
2684: PPUSH
2685: LD_INT 1
2687: PPUSH
2688: LD_VAR 0 5
2692: PPUSH
2693: CALL_OW 380
// hc_gallery := pkremaster ;
2697: LD_ADDR_OWVAR 33
2701: PUSH
2702: LD_STRING pkremaster
2704: ST_TO_ADDR
// hc_face_number := 12 ;
2705: LD_ADDR_OWVAR 34
2709: PUSH
2710: LD_INT 12
2712: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2713: LD_ADDR_OWVAR 26
2717: PUSH
2718: LD_STRING Jan van Jakes
2720: ST_TO_ADDR
// houten := CreateHuman ;
2721: LD_ADDR_EXP 3
2725: PUSH
2726: CALL_OW 44
2730: ST_TO_ADDR
// LogHuman ( houten ) ;
2731: LD_EXP 3
2735: PPUSH
2736: CALL 7693 0 1
// team := team ^ houten ;
2740: LD_ADDR_VAR 0 10
2744: PUSH
2745: LD_VAR 0 10
2749: PUSH
2750: LD_EXP 3
2754: ADD
2755: ST_TO_ADDR
// end ; sylvia :
2756: GO 2844
2758: LD_STRING sylvia
2760: DOUBLE
2761: EQUAL
2762: IFTRUE 2766
2764: GO 2843
2766: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2767: LD_INT 2
2769: PPUSH
2770: LD_INT 1
2772: PPUSH
2773: LD_VAR 0 5
2777: PPUSH
2778: CALL_OW 380
// hc_gallery := pkremaster ;
2782: LD_ADDR_OWVAR 33
2786: PUSH
2787: LD_STRING pkremaster
2789: ST_TO_ADDR
// hc_face_number := 13 ;
2790: LD_ADDR_OWVAR 34
2794: PUSH
2795: LD_INT 13
2797: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2798: LD_ADDR_OWVAR 26
2802: PUSH
2803: LD_STRING Sylvia Johnson
2805: ST_TO_ADDR
// brown := CreateHuman ;
2806: LD_ADDR_EXP 4
2810: PUSH
2811: CALL_OW 44
2815: ST_TO_ADDR
// LogHuman ( brown ) ;
2816: LD_EXP 4
2820: PPUSH
2821: CALL 7693 0 1
// team := team ^ brown ;
2825: LD_ADDR_VAR 0 10
2829: PUSH
2830: LD_VAR 0 10
2834: PUSH
2835: LD_EXP 4
2839: ADD
2840: ST_TO_ADDR
// end ; end ;
2841: GO 2844
2843: POP
// hc_gallery :=  ;
2844: LD_ADDR_OWVAR 33
2848: PUSH
2849: LD_STRING 
2851: ST_TO_ADDR
// hc_name :=  ;
2852: LD_ADDR_OWVAR 26
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_importance := 0 ;
2860: LD_ADDR_OWVAR 32
2864: PUSH
2865: LD_INT 0
2867: ST_TO_ADDR
// for i = 1 to num do
2868: LD_ADDR_VAR 0 8
2872: PUSH
2873: DOUBLE
2874: LD_INT 1
2876: DEC
2877: ST_TO_ADDR
2878: LD_VAR 0 6
2882: PUSH
2883: FOR_TO
2884: IFFALSE 2948
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2886: LD_INT 0
2888: PPUSH
2889: LD_VAR 0 8
2893: PUSH
2894: LD_INT 4
2896: MOD
2897: PUSH
2898: LD_INT 1
2900: PLUS
2901: PPUSH
2902: LD_VAR 0 5
2906: PPUSH
2907: CALL_OW 380
// un := CreateHuman ;
2911: LD_ADDR_VAR 0 9
2915: PUSH
2916: CALL_OW 44
2920: ST_TO_ADDR
// LogHuman ( un ) ;
2921: LD_VAR 0 9
2925: PPUSH
2926: CALL 7693 0 1
// team := team ^ un ;
2930: LD_ADDR_VAR 0 10
2934: PUSH
2935: LD_VAR 0 10
2939: PUSH
2940: LD_VAR 0 9
2944: ADD
2945: ST_TO_ADDR
// end ;
2946: GO 2883
2948: POP
2949: POP
// for i = 1 to team do
2950: LD_ADDR_VAR 0 8
2954: PUSH
2955: DOUBLE
2956: LD_INT 1
2958: DEC
2959: ST_TO_ADDR
2960: LD_VAR 0 10
2964: PUSH
2965: FOR_TO
2966: IFFALSE 2993
// PlaceUnitArea ( team [ i ] , area , false ) ;
2968: LD_VAR 0 10
2972: PUSH
2973: LD_VAR 0 8
2977: ARRAY
2978: PPUSH
2979: LD_VAR 0 3
2983: PPUSH
2984: LD_INT 0
2986: PPUSH
2987: CALL_OW 49
2991: GO 2965
2993: POP
2994: POP
// end ;
2995: LD_VAR 0 7
2999: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3000: LD_INT 0
3002: PPUSH
3003: PPUSH
// for i = 1 to n1 do
3004: LD_ADDR_VAR 0 6
3008: PUSH
3009: DOUBLE
3010: LD_INT 1
3012: DEC
3013: ST_TO_ADDR
3014: LD_VAR 0 1
3018: PUSH
3019: FOR_TO
3020: IFFALSE 3042
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3022: LD_INT 1
3024: PPUSH
3025: LD_INT 1
3027: PPUSH
3028: LD_VAR 0 4
3032: PPUSH
3033: LD_INT 0
3035: PPUSH
3036: CALL_OW 59
3040: GO 3019
3042: POP
3043: POP
// for i = 1 to n2 do
3044: LD_ADDR_VAR 0 6
3048: PUSH
3049: DOUBLE
3050: LD_INT 1
3052: DEC
3053: ST_TO_ADDR
3054: LD_VAR 0 2
3058: PUSH
3059: FOR_TO
3060: IFFALSE 3082
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3062: LD_INT 2
3064: PPUSH
3065: LD_INT 1
3067: PPUSH
3068: LD_VAR 0 4
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 59
3080: GO 3059
3082: POP
3083: POP
// for i = 1 to n3 do
3084: LD_ADDR_VAR 0 6
3088: PUSH
3089: DOUBLE
3090: LD_INT 1
3092: DEC
3093: ST_TO_ADDR
3094: LD_VAR 0 3
3098: PUSH
3099: FOR_TO
3100: IFFALSE 3122
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3102: LD_INT 3
3104: PPUSH
3105: LD_INT 1
3107: PPUSH
3108: LD_VAR 0 4
3112: PPUSH
3113: LD_INT 0
3115: PPUSH
3116: CALL_OW 59
3120: GO 3099
3122: POP
3123: POP
// end ; end_of_file
3124: LD_VAR 0 5
3128: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3129: LD_INT 0
3131: PPUSH
3132: PPUSH
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
// uc_side := your_side ;
3137: LD_ADDR_OWVAR 20
3141: PUSH
3142: LD_OWVAR 2
3146: ST_TO_ADDR
// uc_nation := nation_russian ;
3147: LD_ADDR_OWVAR 21
3151: PUSH
3152: LD_INT 3
3154: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3155: LD_ADDR_EXP 18
3159: PUSH
3160: LD_STRING Gladkov
3162: PPUSH
3163: CALL_OW 25
3167: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3168: LD_ADDR_EXP 19
3172: PUSH
3173: LD_STRING Davidov
3175: PPUSH
3176: CALL_OW 25
3180: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3181: LD_ADDR_EXP 20
3185: PUSH
3186: LD_STRING Burlak
3188: PPUSH
3189: CALL_OW 25
3193: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3194: LD_ADDR_EXP 21
3198: PUSH
3199: LD_STRING Stolypin
3201: PPUSH
3202: CALL_OW 25
3206: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3207: LD_ADDR_EXP 16
3211: PUSH
3212: LD_EXP 18
3216: PUSH
3217: LD_EXP 19
3221: PUSH
3222: LD_EXP 20
3226: PUSH
3227: LD_EXP 21
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3238: LD_ADDR_EXP 24
3242: PUSH
3243: LD_EXP 16
3247: PUSH
3248: LD_VAR 0 1
3252: ARRAY
3253: ST_TO_ADDR
// team := [ ] ;
3254: LD_ADDR_VAR 0 6
3258: PUSH
3259: EMPTY
3260: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3261: LD_ADDR_VAR 0 4
3265: PUSH
3266: LD_INT 4
3268: PUSH
3269: LD_INT 3
3271: PUSH
3272: LD_INT 3
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PUSH
3280: LD_OWVAR 67
3284: ARRAY
3285: ST_TO_ADDR
// hc_gallery :=  ;
3286: LD_ADDR_OWVAR 33
3290: PUSH
3291: LD_STRING 
3293: ST_TO_ADDR
// hc_name :=  ;
3294: LD_ADDR_OWVAR 26
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_importance := 0 ;
3302: LD_ADDR_OWVAR 32
3306: PUSH
3307: LD_INT 0
3309: ST_TO_ADDR
// case player_com of gladkov :
3310: LD_EXP 24
3314: PUSH
3315: LD_EXP 18
3319: DOUBLE
3320: EQUAL
3321: IFTRUE 3325
3323: GO 3470
3325: POP
// begin for i = 1 to 10 do
3326: LD_ADDR_VAR 0 3
3330: PUSH
3331: DOUBLE
3332: LD_INT 1
3334: DEC
3335: ST_TO_ADDR
3336: LD_INT 10
3338: PUSH
3339: FOR_TO
3340: IFFALSE 3379
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3342: LD_INT 0
3344: PPUSH
3345: LD_INT 1
3347: PPUSH
3348: LD_VAR 0 4
3352: PUSH
3353: LD_INT 1
3355: PLUS
3356: PPUSH
3357: CALL_OW 380
// team := team ^ CreateHuman ;
3361: LD_ADDR_VAR 0 6
3365: PUSH
3366: LD_VAR 0 6
3370: PUSH
3371: CALL_OW 44
3375: ADD
3376: ST_TO_ADDR
// end ;
3377: GO 3339
3379: POP
3380: POP
// for i = 1 to 15 do
3381: LD_ADDR_VAR 0 3
3385: PUSH
3386: DOUBLE
3387: LD_INT 1
3389: DEC
3390: ST_TO_ADDR
3391: LD_INT 15
3393: PUSH
3394: FOR_TO
3395: IFFALSE 3440
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3397: LD_INT 0
3399: PPUSH
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: MOD
3408: PUSH
3409: LD_INT 2
3411: PLUS
3412: PPUSH
3413: LD_VAR 0 4
3417: PPUSH
3418: CALL_OW 380
// team := team ^ CreateHuman ;
3422: LD_ADDR_VAR 0 6
3426: PUSH
3427: LD_VAR 0 6
3431: PUSH
3432: CALL_OW 44
3436: ADD
3437: ST_TO_ADDR
// end ;
3438: GO 3394
3440: POP
3441: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3442: LD_INT 44
3444: PPUSH
3445: LD_INT 3
3447: PPUSH
3448: LD_INT 1
3450: PPUSH
3451: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3455: LD_INT 34
3457: PPUSH
3458: LD_INT 3
3460: PPUSH
3461: LD_INT 1
3463: PPUSH
3464: CALL_OW 322
// end ; davidov :
3468: GO 4353
3470: LD_EXP 19
3474: DOUBLE
3475: EQUAL
3476: IFTRUE 3480
3478: GO 3755
3480: POP
// begin for i = 1 to 10 do
3481: LD_ADDR_VAR 0 3
3485: PUSH
3486: DOUBLE
3487: LD_INT 1
3489: DEC
3490: ST_TO_ADDR
3491: LD_INT 10
3493: PUSH
3494: FOR_TO
3495: IFFALSE 3534
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3497: LD_INT 0
3499: PPUSH
3500: LD_INT 4
3502: PPUSH
3503: LD_VAR 0 4
3507: PUSH
3508: LD_INT 1
3510: PLUS
3511: PPUSH
3512: CALL_OW 380
// team := team ^ CreateHuman ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: CALL_OW 44
3530: ADD
3531: ST_TO_ADDR
// end ;
3532: GO 3494
3534: POP
3535: POP
// for i = 1 to 15 do
3536: LD_ADDR_VAR 0 3
3540: PUSH
3541: DOUBLE
3542: LD_INT 1
3544: DEC
3545: ST_TO_ADDR
3546: LD_INT 15
3548: PUSH
3549: FOR_TO
3550: IFFALSE 3595
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3552: LD_INT 0
3554: PPUSH
3555: LD_VAR 0 3
3559: PUSH
3560: LD_INT 3
3562: MOD
3563: PUSH
3564: LD_INT 1
3566: PLUS
3567: PPUSH
3568: LD_VAR 0 4
3572: PPUSH
3573: CALL_OW 380
// team := team ^ CreateHuman ;
3577: LD_ADDR_VAR 0 6
3581: PUSH
3582: LD_VAR 0 6
3586: PUSH
3587: CALL_OW 44
3591: ADD
3592: ST_TO_ADDR
// end ;
3593: GO 3549
3595: POP
3596: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3597: LD_INT 34
3599: PPUSH
3600: LD_INT 3
3602: PPUSH
3603: LD_INT 1
3605: PPUSH
3606: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3610: LD_INT 32
3612: PPUSH
3613: LD_INT 3
3615: PPUSH
3616: LD_INT 1
3618: PPUSH
3619: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3623: LD_INT 27
3625: PPUSH
3626: LD_INT 3
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3636: LD_INT 30
3638: PPUSH
3639: LD_INT 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3649: LD_INT 63
3651: PPUSH
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 1
3657: PPUSH
3658: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3662: LD_INT 57
3664: PPUSH
3665: LD_INT 3
3667: PPUSH
3668: LD_INT 1
3670: PPUSH
3671: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3675: LD_INT 58
3677: PPUSH
3678: LD_INT 3
3680: PPUSH
3681: LD_INT 1
3683: PPUSH
3684: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3688: LD_INT 8
3690: PPUSH
3691: LD_INT 3
3693: PPUSH
3694: LD_INT 1
3696: PPUSH
3697: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3701: LD_INT 12
3703: PPUSH
3704: LD_INT 3
3706: PPUSH
3707: LD_INT 1
3709: PPUSH
3710: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3714: LD_INT 14
3716: PPUSH
3717: LD_INT 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3727: LD_INT 24
3729: PPUSH
3730: LD_INT 3
3732: PPUSH
3733: LD_INT 1
3735: PPUSH
3736: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3740: LD_INT 33
3742: PPUSH
3743: LD_INT 3
3745: PPUSH
3746: LD_INT 1
3748: PPUSH
3749: CALL_OW 324
// end ; gorki :
3753: GO 4353
3755: LD_EXP 20
3759: DOUBLE
3760: EQUAL
3761: IFTRUE 3765
3763: GO 4046
3765: POP
// begin for i = 1 to 10 do
3766: LD_ADDR_VAR 0 3
3770: PUSH
3771: DOUBLE
3772: LD_INT 1
3774: DEC
3775: ST_TO_ADDR
3776: LD_INT 10
3778: PUSH
3779: FOR_TO
3780: IFFALSE 3834
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3782: LD_INT 0
3784: PPUSH
3785: LD_INT 3
3787: PPUSH
3788: LD_VAR 0 4
3792: PUSH
3793: LD_INT 1
3795: PLUS
3796: PPUSH
3797: CALL_OW 380
// team := team ^ CreateHuman ;
3801: LD_ADDR_VAR 0 6
3805: PUSH
3806: LD_VAR 0 6
3810: PUSH
3811: CALL_OW 44
3815: ADD
3816: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3817: LD_VAR 0 6
3821: PUSH
3822: LD_VAR 0 6
3826: ARRAY
3827: PPUSH
3828: CALL 7693 0 1
// end ;
3832: GO 3779
3834: POP
3835: POP
// for i = 1 to 15 do
3836: LD_ADDR_VAR 0 3
3840: PUSH
3841: DOUBLE
3842: LD_INT 1
3844: DEC
3845: ST_TO_ADDR
3846: LD_INT 15
3848: PUSH
3849: FOR_TO
3850: IFFALSE 3923
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3852: LD_INT 0
3854: PPUSH
3855: LD_INT 1
3857: PUSH
3858: LD_INT 2
3860: PUSH
3861: LD_INT 4
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: LIST
3868: PUSH
3869: LD_INT 1
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: CALL_OW 12
3879: ARRAY
3880: PPUSH
3881: LD_VAR 0 4
3885: PPUSH
3886: CALL_OW 380
// team := team ^ CreateHuman ;
3890: LD_ADDR_VAR 0 6
3894: PUSH
3895: LD_VAR 0 6
3899: PUSH
3900: CALL_OW 44
3904: ADD
3905: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3906: LD_VAR 0 6
3910: PUSH
3911: LD_VAR 0 6
3915: ARRAY
3916: PPUSH
3917: CALL 7693 0 1
// end ;
3921: GO 3849
3923: POP
3924: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3925: LD_INT 40
3927: PPUSH
3928: LD_INT 3
3930: PPUSH
3931: LD_INT 1
3933: PPUSH
3934: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3938: LD_INT 34
3940: PPUSH
3941: LD_INT 3
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3951: LD_INT 18
3953: PPUSH
3954: LD_INT 3
3956: PPUSH
3957: LD_INT 1
3959: PPUSH
3960: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3964: LD_ADDR_OWVAR 37
3968: PUSH
3969: LD_INT 22
3971: ST_TO_ADDR
// vc_engine := engine_combustion ;
3972: LD_ADDR_OWVAR 39
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// vc_control := control_manual ;
3980: LD_ADDR_OWVAR 38
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3988: LD_ADDR_OWVAR 40
3992: PUSH
3993: LD_INT 45
3995: ST_TO_ADDR
// vc_fuel_battery := 3 ;
3996: LD_ADDR_OWVAR 41
4000: PUSH
4001: LD_INT 3
4003: ST_TO_ADDR
// veh := CreateVehicle ;
4004: LD_ADDR_VAR 0 7
4008: PUSH
4009: CALL_OW 45
4013: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4014: LD_VAR 0 7
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4026: LD_VAR 0 7
4030: PPUSH
4031: LD_INT 107
4033: PPUSH
4034: LD_INT 83
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: CALL_OW 48
// end ; stolypin :
4044: GO 4353
4046: LD_EXP 21
4050: DOUBLE
4051: EQUAL
4052: IFTRUE 4056
4054: GO 4352
4056: POP
// begin for i = 1 to 10 do
4057: LD_ADDR_VAR 0 3
4061: PUSH
4062: DOUBLE
4063: LD_INT 1
4065: DEC
4066: ST_TO_ADDR
4067: LD_INT 10
4069: PUSH
4070: FOR_TO
4071: IFFALSE 4110
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4073: LD_INT 0
4075: PPUSH
4076: LD_INT 2
4078: PPUSH
4079: LD_VAR 0 4
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: PPUSH
4088: CALL_OW 380
// team := team ^ CreateHuman ;
4092: LD_ADDR_VAR 0 6
4096: PUSH
4097: LD_VAR 0 6
4101: PUSH
4102: CALL_OW 44
4106: ADD
4107: ST_TO_ADDR
// end ;
4108: GO 4070
4110: POP
4111: POP
// for i = 1 to 15 do
4112: LD_ADDR_VAR 0 3
4116: PUSH
4117: DOUBLE
4118: LD_INT 1
4120: DEC
4121: ST_TO_ADDR
4122: LD_INT 15
4124: PUSH
4125: FOR_TO
4126: IFFALSE 4184
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4128: LD_INT 0
4130: PPUSH
4131: LD_INT 1
4133: PUSH
4134: LD_INT 3
4136: PUSH
4137: LD_INT 4
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: PUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_INT 3
4150: PPUSH
4151: CALL_OW 12
4155: ARRAY
4156: PPUSH
4157: LD_VAR 0 4
4161: PPUSH
4162: CALL_OW 380
// team := team ^ CreateHuman ;
4166: LD_ADDR_VAR 0 6
4170: PUSH
4171: LD_VAR 0 6
4175: PUSH
4176: CALL_OW 44
4180: ADD
4181: ST_TO_ADDR
// end ;
4182: GO 4125
4184: POP
4185: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4186: LD_INT 34
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: LD_INT 1
4194: PPUSH
4195: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4199: LD_ADDR_OWVAR 37
4203: PUSH
4204: LD_INT 22
4206: ST_TO_ADDR
// vc_engine := engine_combustion ;
4207: LD_ADDR_OWVAR 39
4211: PUSH
4212: LD_INT 1
4214: ST_TO_ADDR
// vc_control := control_manual ;
4215: LD_ADDR_OWVAR 38
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4223: LD_ADDR_OWVAR 40
4227: PUSH
4228: LD_INT 51
4230: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4231: LD_ADDR_OWVAR 41
4235: PUSH
4236: LD_INT 30
4238: ST_TO_ADDR
// veh := CreateVehicle ;
4239: LD_ADDR_VAR 0 7
4243: PUSH
4244: CALL_OW 45
4248: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4249: LD_VAR 0 7
4253: PPUSH
4254: LD_INT 1
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4264: LD_VAR 0 7
4268: PPUSH
4269: LD_INT 107
4271: PPUSH
4272: LD_INT 83
4274: PPUSH
4275: LD_INT 0
4277: PPUSH
4278: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4282: LD_ADDR_OWVAR 37
4286: PUSH
4287: LD_INT 22
4289: ST_TO_ADDR
// vc_engine := engine_combustion ;
4290: LD_ADDR_OWVAR 39
4294: PUSH
4295: LD_INT 1
4297: ST_TO_ADDR
// vc_control := control_manual ;
4298: LD_ADDR_OWVAR 38
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_weapon := ru_crane ;
4306: LD_ADDR_OWVAR 40
4310: PUSH
4311: LD_INT 52
4313: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4314: LD_ADDR_OWVAR 41
4318: PUSH
4319: LD_INT 30
4321: ST_TO_ADDR
// veh := CreateVehicle ;
4322: LD_ADDR_VAR 0 7
4326: PUSH
4327: CALL_OW 45
4331: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4332: LD_VAR 0 7
4336: PPUSH
4337: LD_INT 115
4339: PPUSH
4340: LD_INT 96
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: CALL_OW 48
// end ; end ;
4350: GO 4353
4352: POP
// if isTest then
4353: LD_EXP 1
4357: IFFALSE 4371
// tmp := team else
4359: LD_ADDR_VAR 0 5
4363: PUSH
4364: LD_VAR 0 6
4368: ST_TO_ADDR
4369: GO 4435
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_STRING text
4378: PPUSH
4379: LD_INT 12
4381: PPUSH
4382: LD_INT 12
4384: PPUSH
4385: LD_INT -2
4387: PUSH
4388: LD_INT -5
4390: PUSH
4391: LD_INT -3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: LIST
4398: PUSH
4399: LD_VAR 0 6
4403: ADD
4404: PPUSH
4405: LD_INT 1
4407: PUSH
4408: LD_INT 2
4410: PUSH
4411: LD_INT 1
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 3
4420: PUSH
4421: LD_INT 4
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: PPUSH
4430: CALL_OW 42
4434: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4435: LD_EXP 24
4439: PPUSH
4440: LD_INT 9
4442: PPUSH
4443: LD_INT 0
4445: PPUSH
4446: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4450: LD_VAR 0 5
4454: PUSH
4455: LD_INT 1
4457: ARRAY
4458: PPUSH
4459: LD_INT 2
4461: PPUSH
4462: CALL_OW 336
// for i = 1 to tmp do
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: DOUBLE
4472: LD_INT 1
4474: DEC
4475: ST_TO_ADDR
4476: LD_VAR 0 5
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4537
// if i < 4 then
4484: LD_VAR 0 3
4488: PUSH
4489: LD_INT 4
4491: LESS
4492: IFFALSE 4517
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4494: LD_VAR 0 5
4498: PUSH
4499: LD_VAR 0 3
4503: ARRAY
4504: PPUSH
4505: LD_INT 9
4507: PPUSH
4508: LD_INT 0
4510: PPUSH
4511: CALL_OW 49
4515: GO 4535
// SetSide ( tmp [ i ] , 6 ) ;
4517: LD_VAR 0 5
4521: PUSH
4522: LD_VAR 0 3
4526: ARRAY
4527: PPUSH
4528: LD_INT 6
4530: PPUSH
4531: CALL_OW 235
4535: GO 4481
4537: POP
4538: POP
// player_squad := tmp ;
4539: LD_ADDR_EXP 22
4543: PUSH
4544: LD_VAR 0 5
4548: ST_TO_ADDR
// pl_counter := 4 ;
4549: LD_ADDR_EXP 23
4553: PUSH
4554: LD_INT 4
4556: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4557: LD_INT 17
4559: PPUSH
4560: LD_INT 5
4562: PPUSH
4563: LD_INT 1
4565: PPUSH
4566: CALL 18134 0 3
// end ;
4570: LD_VAR 0 2
4574: RET
// export Popov ; export function InitAction ; var commander ; begin
4575: LD_INT 0
4577: PPUSH
4578: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4579: LD_INT 6
4581: PPUSH
4582: LD_INT 3
4584: PPUSH
4585: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4589: LD_INT 1
4591: PPUSH
4592: LD_INT 1
4594: PPUSH
4595: CALL_OW 86
// uc_side := 6 ;
4599: LD_ADDR_OWVAR 20
4603: PUSH
4604: LD_INT 6
4606: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4607: LD_ADDR_EXP 25
4611: PUSH
4612: LD_STRING Popov
4614: PPUSH
4615: CALL_OW 25
4619: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4620: LD_ADDR_OWVAR 67
4624: PUSH
4625: LD_INT 0
4627: PPUSH
4628: CALL_OW 426
4632: ST_TO_ADDR
// if not Difficulty then
4633: LD_OWVAR 67
4637: NOT
4638: IFFALSE 4648
// Difficulty := 2 ;
4640: LD_ADDR_OWVAR 67
4644: PUSH
4645: LD_INT 2
4647: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4648: LD_ADDR_VAR 0 2
4652: PUSH
4653: LD_INT 1
4655: PPUSH
4656: CALL_OW 426
4660: ST_TO_ADDR
// if not commander then
4661: LD_VAR 0 2
4665: NOT
4666: IFFALSE 4676
// commander := 1 ;
4668: LD_ADDR_VAR 0 2
4672: PUSH
4673: LD_INT 1
4675: ST_TO_ADDR
// InitCommanders ( commander ) ;
4676: LD_VAR 0 2
4680: PPUSH
4681: CALL 3129 0 1
// end ;
4685: LD_VAR 0 1
4689: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4690: LD_EXP 23
4694: PUSH
4695: LD_INT 12
4697: LESS
4698: IFFALSE 4871
4700: GO 4702
4702: DISABLE
4703: LD_INT 0
4705: PPUSH
// begin enable ;
4706: ENABLE
// for i = pl_counter to pl_counter + 2 do
4707: LD_ADDR_VAR 0 1
4711: PUSH
4712: DOUBLE
4713: LD_EXP 23
4717: DEC
4718: ST_TO_ADDR
4719: LD_EXP 23
4723: PUSH
4724: LD_INT 2
4726: PLUS
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4775
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4731: LD_EXP 22
4735: PUSH
4736: LD_VAR 0 1
4740: ARRAY
4741: PPUSH
4742: LD_INT 18
4744: PPUSH
4745: LD_INT 0
4747: PPUSH
4748: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4752: LD_EXP 22
4756: PUSH
4757: LD_VAR 0 1
4761: ARRAY
4762: PPUSH
4763: LD_INT 107
4765: PPUSH
4766: LD_INT 88
4768: PPUSH
4769: CALL_OW 111
// end ;
4773: GO 4728
4775: POP
4776: POP
// for i = pl_counter to pl_counter + 2 do
4777: LD_ADDR_VAR 0 1
4781: PUSH
4782: DOUBLE
4783: LD_EXP 23
4787: DEC
4788: ST_TO_ADDR
4789: LD_EXP 23
4793: PUSH
4794: LD_INT 2
4796: PLUS
4797: PUSH
4798: FOR_TO
4799: IFFALSE 4855
// begin repeat wait ( 0 0$01 ) ;
4801: LD_INT 35
4803: PPUSH
4804: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4808: LD_EXP 22
4812: PUSH
4813: LD_VAR 0 1
4817: ARRAY
4818: PPUSH
4819: LD_INT 107
4821: PPUSH
4822: LD_INT 88
4824: PPUSH
4825: CALL_OW 297
4829: PUSH
4830: LD_INT 6
4832: LESS
4833: IFFALSE 4801
// SetSide ( player_squad [ i ] , 3 ) ;
4835: LD_EXP 22
4839: PUSH
4840: LD_VAR 0 1
4844: ARRAY
4845: PPUSH
4846: LD_INT 3
4848: PPUSH
4849: CALL_OW 235
// end ;
4853: GO 4798
4855: POP
4856: POP
// pl_counter := pl_counter + 3 ;
4857: LD_ADDR_EXP 23
4861: PUSH
4862: LD_EXP 23
4866: PUSH
4867: LD_INT 3
4869: PLUS
4870: ST_TO_ADDR
// end ;
4871: PPOPN 1
4873: END
// export function Dialog ; begin
4874: LD_INT 0
4876: PPUSH
// if not isTest then
4877: LD_EXP 1
4881: NOT
4882: IFFALSE 4904
// case query ( task ) of 1 :
4884: LD_STRING task
4886: PPUSH
4887: CALL_OW 97
4891: PUSH
4892: LD_INT 1
4894: DOUBLE
4895: EQUAL
4896: IFTRUE 4900
4898: GO 4903
4900: POP
// ; end ;
4901: GO 4904
4903: POP
// InGameOn ;
4904: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4908: LD_INT 107
4910: PPUSH
4911: LD_INT 84
4913: PPUSH
4914: CALL_OW 86
// if isTest then
4918: LD_EXP 1
4922: IFFALSE 4932
// dialogue_skipped := true ;
4924: LD_ADDR_OWVAR 59
4928: PUSH
4929: LD_INT 1
4931: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4932: LD_ADDR_EXP 10
4936: PUSH
4937: LD_EXP 22
4941: PUSH
4942: LD_INT 1
4944: ARRAY
4945: PPUSH
4946: LD_INT 0
4948: PPUSH
4949: LD_INT 96
4951: PPUSH
4952: LD_INT 79
4954: PPUSH
4955: LD_INT 2
4957: PPUSH
4958: CALL_OW 145
4962: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4963: LD_INT 35
4965: PPUSH
4966: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4970: LD_EXP 25
4974: PPUSH
4975: LD_STRING DR1
4977: PPUSH
4978: CALL_OW 94
// Wait ( 0 0$01 ) ;
4982: LD_INT 35
4984: PPUSH
4985: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4989: LD_EXP 25
4993: PPUSH
4994: LD_STRING DR2
4996: PPUSH
4997: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5001: LD_EXP 25
5005: PPUSH
5006: LD_STRING DR3
5008: PPUSH
5009: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5013: LD_INT 35
5015: PPUSH
5016: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5020: LD_INT 3
5022: PPUSH
5023: LD_INT 30
5025: PUSH
5026: LD_INT 0
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL 11421 0 2
5037: PUSH
5038: LD_EXP 1
5042: OR
5043: IFFALSE 5013
// InGameOff ;
5045: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5049: LD_STRING C1
5051: PPUSH
5052: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5056: LD_INT 35
5058: PPUSH
5059: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5063: LD_EXP 10
5067: PPUSH
5068: CALL_OW 461
5072: PUSH
5073: LD_INT 2
5075: EQUAL
5076: IFFALSE 5056
// if not isTest then
5078: LD_EXP 1
5082: NOT
5083: IFFALSE 5105
// case query ( support ) of 1 :
5085: LD_STRING support
5087: PPUSH
5088: CALL_OW 97
5092: PUSH
5093: LD_INT 1
5095: DOUBLE
5096: EQUAL
5097: IFTRUE 5101
5099: GO 5104
5101: POP
// ; end ;
5102: GO 5105
5104: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5105: LD_INT 3
5107: PPUSH
5108: LD_INT 12
5110: PPUSH
5111: LD_INT 2
5113: PPUSH
5114: LD_INT 22
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 30
5126: PUSH
5127: LD_INT 0
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PPUSH
5138: CALL_OW 69
5142: PUSH
5143: LD_INT 1
5145: ARRAY
5146: PPUSH
5147: CALL_OW 468
// if player_com = stolypin then
5151: LD_EXP 24
5155: PUSH
5156: LD_EXP 21
5160: EQUAL
5161: IFFALSE 5190
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5163: LD_INT 18
5165: PPUSH
5166: LD_INT 3
5168: PUSH
5169: LD_INT 3
5171: PUSH
5172: LD_INT 2
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PPUSH
5186: CALL 6490 0 2
// end ;
5190: LD_VAR 0 1
5194: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5195: LD_EXP 11
5199: PUSH
5200: LD_OWVAR 1
5204: PUSH
5205: LD_INT 31500
5207: LESS
5208: AND
5209: IFFALSE 5373
// case query ( call1 ) of 1 :
5211: LD_STRING call1
5213: PPUSH
5214: CALL_OW 97
5218: PUSH
5219: LD_INT 1
5221: DOUBLE
5222: EQUAL
5223: IFTRUE 5227
5225: GO 5361
5227: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5228: LD_INT 3
5230: PPUSH
5231: LD_INT 12
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: LD_EXP 10
5241: PPUSH
5242: CALL_OW 468
// call := false ;
5246: LD_ADDR_EXP 11
5250: PUSH
5251: LD_INT 0
5253: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5254: LD_EXP 25
5258: PPUSH
5259: LD_STRING DR6
5261: PPUSH
5262: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5266: LD_INT 6300
5268: PPUSH
5269: LD_INT 8400
5271: PPUSH
5272: CALL_OW 12
5276: PPUSH
5277: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5281: LD_INT 18
5283: PUSH
5284: LD_INT 19
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: LD_INT 1
5293: PPUSH
5294: LD_INT 2
5296: PPUSH
5297: CALL_OW 12
5301: ARRAY
5302: PPUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: PPUSH
5314: CALL 6490 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5318: LD_INT 25200
5320: PPUSH
5321: LD_INT 35700
5323: PPUSH
5324: CALL_OW 12
5328: PPUSH
5329: CALL_OW 67
// call := true ;
5333: LD_ADDR_EXP 11
5337: PUSH
5338: LD_INT 1
5340: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5341: LD_INT 3
5343: PPUSH
5344: LD_INT 12
5346: PPUSH
5347: LD_INT 2
5349: PPUSH
5350: LD_EXP 10
5354: PPUSH
5355: CALL_OW 468
// end ; 2 :
5359: GO 5373
5361: LD_INT 2
5363: DOUBLE
5364: EQUAL
5365: IFTRUE 5369
5367: GO 5372
5369: POP
// ; end ;
5370: GO 5373
5372: POP
// if call and tick >= 15 15$00 then
5373: LD_EXP 11
5377: PUSH
5378: LD_OWVAR 1
5382: PUSH
5383: LD_INT 31500
5385: GREATEREQUAL
5386: AND
5387: IFFALSE 5816
// case query ( call2 ) of 1 :
5389: LD_STRING call2
5391: PPUSH
5392: CALL_OW 97
5396: PUSH
5397: LD_INT 1
5399: DOUBLE
5400: EQUAL
5401: IFTRUE 5405
5403: GO 5641
5405: POP
// begin call := false ;
5406: LD_ADDR_EXP 11
5410: PUSH
5411: LD_INT 0
5413: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5414: LD_INT 1
5416: PPUSH
5417: LD_INT 21
5419: PUSH
5420: LD_INT 3
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PPUSH
5427: CALL 11421 0 2
5431: PUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11421 0 2
5449: AND
5450: IFFALSE 5498
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5452: LD_INT 18
5454: PUSH
5455: LD_INT 19
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 1
5464: PPUSH
5465: LD_INT 2
5467: PPUSH
5468: CALL_OW 12
5472: ARRAY
5473: PPUSH
5474: LD_INT 5
5476: PUSH
5477: LD_INT 4
5479: PUSH
5480: LD_INT 4
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: LD_OWVAR 67
5492: ARRAY
5493: PPUSH
5494: CALL 6251 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5498: LD_INT 1
5500: PPUSH
5501: LD_INT 21
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL 11421 0 2
5515: PUSH
5516: LD_INT 0
5518: EQUAL
5519: IFFALSE 5548
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5521: LD_INT 19
5523: PPUSH
5524: LD_INT 5
5526: PUSH
5527: LD_INT 4
5529: PUSH
5530: LD_INT 3
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: LD_OWVAR 67
5542: ARRAY
5543: PPUSH
5544: CALL 6251 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5548: LD_INT 4
5550: PPUSH
5551: LD_INT 21
5553: PUSH
5554: LD_INT 3
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PPUSH
5561: CALL 11421 0 2
5565: PUSH
5566: LD_INT 0
5568: EQUAL
5569: IFFALSE 5598
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5571: LD_INT 18
5573: PPUSH
5574: LD_INT 5
5576: PUSH
5577: LD_INT 4
5579: PUSH
5580: LD_INT 4
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: PUSH
5588: LD_OWVAR 67
5592: ARRAY
5593: PPUSH
5594: CALL 6251 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5598: LD_INT 10500
5600: PPUSH
5601: LD_INT 23100
5603: PPUSH
5604: CALL_OW 12
5608: PPUSH
5609: CALL_OW 67
// call := true ;
5613: LD_ADDR_EXP 11
5617: PUSH
5618: LD_INT 1
5620: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 12
5626: PPUSH
5627: LD_INT 2
5629: PPUSH
5630: LD_EXP 10
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5816
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5804
5649: POP
// begin SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5650: LD_INT 3
5652: PPUSH
5653: LD_INT 12
5655: PPUSH
5656: LD_INT 1
5658: PPUSH
5659: LD_EXP 10
5663: PPUSH
5664: CALL_OW 468
// call := false ;
5668: LD_ADDR_EXP 11
5672: PUSH
5673: LD_INT 0
5675: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5676: LD_EXP 25
5680: PPUSH
5681: LD_STRING DR6
5683: PPUSH
5684: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5688: LD_INT 6300
5690: PPUSH
5691: LD_INT 8400
5693: PPUSH
5694: CALL_OW 12
5698: PPUSH
5699: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5703: LD_INT 18
5705: PUSH
5706: LD_INT 19
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 1
5715: PPUSH
5716: LD_INT 2
5718: PPUSH
5719: CALL_OW 12
5723: ARRAY
5724: PPUSH
5725: LD_INT 3
5727: PUSH
5728: LD_INT 2
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: PUSH
5739: LD_OWVAR 67
5743: ARRAY
5744: PUSH
5745: LD_INT 0
5747: PPUSH
5748: LD_INT 1
5750: PPUSH
5751: CALL_OW 12
5755: MINUS
5756: PPUSH
5757: CALL 6490 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5761: LD_INT 35700
5763: PPUSH
5764: LD_INT 44100
5766: PPUSH
5767: CALL_OW 12
5771: PPUSH
5772: CALL_OW 67
// call := true ;
5776: LD_ADDR_EXP 11
5780: PUSH
5781: LD_INT 1
5783: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5784: LD_INT 3
5786: PPUSH
5787: LD_INT 12
5789: PPUSH
5790: LD_INT 2
5792: PPUSH
5793: LD_EXP 10
5797: PPUSH
5798: CALL_OW 468
// end ; 3 :
5802: GO 5816
5804: LD_INT 3
5806: DOUBLE
5807: EQUAL
5808: IFTRUE 5812
5810: GO 5815
5812: POP
// ; end ;
5813: GO 5816
5815: POP
// end ;
5816: PPOPN 4
5818: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5819: LD_INT 22
5821: PUSH
5822: LD_INT 1
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 21
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PPUSH
5843: CALL_OW 69
5847: PUSH
5848: LD_INT 0
5850: EQUAL
5851: PUSH
5852: LD_INT 22
5854: PUSH
5855: LD_INT 4
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 21
5864: PUSH
5865: LD_INT 1
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PPUSH
5876: CALL_OW 69
5880: PUSH
5881: LD_INT 0
5883: EQUAL
5884: AND
5885: IFFALSE 6089
5887: GO 5889
5889: DISABLE
// begin DialogueOn ;
5890: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5894: LD_EXP 25
5898: PPUSH
5899: LD_STRING DR7
5901: PPUSH
5902: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5906: LD_OWVAR 1
5910: PUSH
5911: LD_INT 116550
5913: PUSH
5914: LD_INT 95550
5916: PUSH
5917: LD_INT 89250
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_OWVAR 67
5929: ARRAY
5930: LESS
5931: IFFALSE 5945
// AddMedal ( med1 , 1 ) else
5933: LD_STRING med1
5935: PPUSH
5936: LD_INT 1
5938: PPUSH
5939: CALL_OW 101
5943: GO 5956
// AddMedal ( med1 , - 1 ) ;
5945: LD_STRING med1
5947: PPUSH
5948: LD_INT 1
5950: NEG
5951: PPUSH
5952: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5956: LD_INT 81
5958: PUSH
5959: LD_INT 3
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: PUSH
5966: LD_INT 21
5968: PUSH
5969: LD_INT 3
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 69
5984: PUSH
5985: LD_INT 0
5987: EQUAL
5988: IFFALSE 6002
// AddMedal ( med3 , 1 ) else
5990: LD_STRING med3
5992: PPUSH
5993: LD_INT 1
5995: PPUSH
5996: CALL_OW 101
6000: GO 6013
// AddMedal ( med3 , - 1 ) ;
6002: LD_STRING med3
6004: PPUSH
6005: LD_INT 1
6007: NEG
6008: PPUSH
6009: CALL_OW 101
// if player_loss = 0 then
6013: LD_EXP 9
6017: PUSH
6018: LD_INT 0
6020: EQUAL
6021: IFFALSE 6035
// AddMedal ( med2 , 1 ) else
6023: LD_STRING med2
6025: PPUSH
6026: LD_INT 1
6028: PPUSH
6029: CALL_OW 101
6033: GO 6078
// if player_loss > 0 and player_loss < 3 then
6035: LD_EXP 9
6039: PUSH
6040: LD_INT 0
6042: GREATER
6043: PUSH
6044: LD_EXP 9
6048: PUSH
6049: LD_INT 3
6051: LESS
6052: AND
6053: IFFALSE 6067
// AddMedal ( med2 , 2 ) else
6055: LD_STRING med2
6057: PPUSH
6058: LD_INT 2
6060: PPUSH
6061: CALL_OW 101
6065: GO 6078
// AddMedal ( med2 , - 1 ) ;
6067: LD_STRING med2
6069: PPUSH
6070: LD_INT 1
6072: NEG
6073: PPUSH
6074: CALL_OW 101
// GiveMedals ( MAIN ) ;
6078: LD_STRING MAIN
6080: PPUSH
6081: CALL_OW 102
// YouWin ;
6085: CALL_OW 103
// end ;
6089: END
// every 0 0$01 trigger IsDead ( player_com ) do
6090: LD_EXP 24
6094: PPUSH
6095: CALL_OW 301
6099: IFFALSE 6166
6101: GO 6103
6103: DISABLE
// begin if IsLive ( Houten ) then
6104: LD_EXP 3
6108: PPUSH
6109: CALL_OW 300
6113: IFFALSE 6129
// SayRadio ( Houten , DJ5 ) else
6115: LD_EXP 3
6119: PPUSH
6120: LD_STRING DJ5
6122: PPUSH
6123: CALL_OW 94
6127: GO 6152
// if IsLive ( Brown ) then
6129: LD_EXP 4
6133: PPUSH
6134: CALL_OW 300
6138: IFFALSE 6152
// SayRadio ( Brown , DS5 ) ;
6140: LD_EXP 4
6144: PPUSH
6145: LD_STRING DS5
6147: PPUSH
6148: CALL_OW 94
// Wait ( 0 0$01 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// YouLost ( dead ) ;
6159: LD_STRING dead
6161: PPUSH
6162: CALL_OW 104
// end ;
6166: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6167: LD_EXP 10
6171: PPUSH
6172: CALL_OW 301
6176: PUSH
6177: LD_EXP 1
6181: NOT
6182: AND
6183: IFFALSE 6250
6185: GO 6187
6187: DISABLE
// begin if IsLive ( Brown ) then
6188: LD_EXP 4
6192: PPUSH
6193: CALL_OW 300
6197: IFFALSE 6213
// SayRadio ( Brown , DS5 ) else
6199: LD_EXP 4
6203: PPUSH
6204: LD_STRING DS5
6206: PPUSH
6207: CALL_OW 94
6211: GO 6236
// if IsLive ( Houten ) then
6213: LD_EXP 3
6217: PPUSH
6218: CALL_OW 300
6222: IFFALSE 6236
// SayRadio ( Houten , DJ5 ) ;
6224: LD_EXP 3
6228: PPUSH
6229: LD_STRING DJ5
6231: PPUSH
6232: CALL_OW 94
// Wait ( 0 0$01 ) ;
6236: LD_INT 35
6238: PPUSH
6239: CALL_OW 67
// YouLost ( depot ) ;
6243: LD_STRING depot
6245: PPUSH
6246: CALL_OW 104
// end ;
6250: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6251: LD_INT 0
6253: PPUSH
6254: PPUSH
6255: PPUSH
// for i = 1 to n do
6256: LD_ADDR_VAR 0 4
6260: PUSH
6261: DOUBLE
6262: LD_INT 1
6264: DEC
6265: ST_TO_ADDR
6266: LD_VAR 0 2
6270: PUSH
6271: FOR_TO
6272: IFFALSE 6475
// begin uc_side := 6 ;
6274: LD_ADDR_OWVAR 20
6278: PUSH
6279: LD_INT 6
6281: ST_TO_ADDR
// uc_nation := 3 ;
6282: LD_ADDR_OWVAR 21
6286: PUSH
6287: LD_INT 3
6289: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6290: LD_ADDR_OWVAR 37
6294: PUSH
6295: LD_INT 23
6297: PUSH
6298: LD_INT 22
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 1
6307: PPUSH
6308: LD_INT 2
6310: PPUSH
6311: CALL_OW 12
6315: ARRAY
6316: ST_TO_ADDR
// vc_control := control_computer ;
6317: LD_ADDR_OWVAR 38
6321: PUSH
6322: LD_INT 3
6324: ST_TO_ADDR
// vc_engine := engine_siberite ;
6325: LD_ADDR_OWVAR 39
6329: PUSH
6330: LD_INT 3
6332: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6333: LD_ADDR_OWVAR 40
6337: PUSH
6338: LD_INT 43
6340: PUSH
6341: LD_INT 44
6343: PUSH
6344: LD_INT 44
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 1
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: CALL_OW 12
6362: ARRAY
6363: ST_TO_ADDR
// un := CreateVehicle ;
6364: LD_ADDR_VAR 0 5
6368: PUSH
6369: CALL_OW 45
6373: ST_TO_ADDR
// case area of east_arr :
6374: LD_VAR 0 1
6378: PUSH
6379: LD_INT 18
6381: DOUBLE
6382: EQUAL
6383: IFTRUE 6387
6385: GO 6422
6387: POP
// begin PlaceUnitArea ( un , area , false ) ;
6388: LD_VAR 0 5
6392: PPUSH
6393: LD_VAR 0 1
6397: PPUSH
6398: LD_INT 0
6400: PPUSH
6401: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6405: LD_VAR 0 5
6409: PPUSH
6410: LD_INT 79
6412: PPUSH
6413: LD_INT 33
6415: PPUSH
6416: CALL_OW 111
// end ; south_arr :
6420: GO 6466
6422: LD_INT 19
6424: DOUBLE
6425: EQUAL
6426: IFTRUE 6430
6428: GO 6465
6430: POP
// begin PlaceUnitArea ( un , area , false ) ;
6431: LD_VAR 0 5
6435: PPUSH
6436: LD_VAR 0 1
6440: PPUSH
6441: LD_INT 0
6443: PPUSH
6444: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6448: LD_VAR 0 5
6452: PPUSH
6453: LD_INT 131
6455: PPUSH
6456: LD_INT 148
6458: PPUSH
6459: CALL_OW 111
// end ; end ;
6463: GO 6466
6465: POP
// Wait ( 0 0$02 ) ;
6466: LD_INT 70
6468: PPUSH
6469: CALL_OW 67
// end ;
6473: GO 6271
6475: POP
6476: POP
// pink_attack := true ;
6477: LD_ADDR_EXP 12
6481: PUSH
6482: LD_INT 1
6484: ST_TO_ADDR
// end ;
6485: LD_VAR 0 3
6489: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6490: LD_INT 0
6492: PPUSH
6493: PPUSH
6494: PPUSH
// for i = 1 to n do
6495: LD_ADDR_VAR 0 4
6499: PUSH
6500: DOUBLE
6501: LD_INT 1
6503: DEC
6504: ST_TO_ADDR
6505: LD_VAR 0 2
6509: PUSH
6510: FOR_TO
6511: IFFALSE 6737
// begin uc_side := 6 ;
6513: LD_ADDR_OWVAR 20
6517: PUSH
6518: LD_INT 6
6520: ST_TO_ADDR
// uc_nation := 3 ;
6521: LD_ADDR_OWVAR 21
6525: PUSH
6526: LD_INT 3
6528: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6529: LD_INT 0
6531: PPUSH
6532: LD_INT 3
6534: PPUSH
6535: LD_INT 4
6537: PPUSH
6538: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6542: LD_ADDR_OWVAR 37
6546: PUSH
6547: LD_INT 22
6549: ST_TO_ADDR
// vc_control := control_manual ;
6550: LD_ADDR_OWVAR 38
6554: PUSH
6555: LD_INT 1
6557: ST_TO_ADDR
// vc_engine := engine_combustion ;
6558: LD_ADDR_OWVAR 39
6562: PUSH
6563: LD_INT 1
6565: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6566: LD_ADDR_OWVAR 40
6570: PUSH
6571: LD_INT 51
6573: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6574: LD_ADDR_OWVAR 41
6578: PUSH
6579: LD_INT 50
6581: ST_TO_ADDR
// un := CreateVehicle ;
6582: LD_ADDR_VAR 0 5
6586: PUSH
6587: CALL_OW 45
6591: ST_TO_ADDR
// case area of east_arr :
6592: LD_VAR 0 1
6596: PUSH
6597: LD_INT 18
6599: DOUBLE
6600: EQUAL
6601: IFTRUE 6605
6603: GO 6620
6605: POP
// SetDir ( un , 4 ) ; south_arr :
6606: LD_VAR 0 5
6610: PPUSH
6611: LD_INT 4
6613: PPUSH
6614: CALL_OW 233
6618: GO 6644
6620: LD_INT 19
6622: DOUBLE
6623: EQUAL
6624: IFTRUE 6628
6626: GO 6643
6628: POP
// SetDir ( un , 5 ) ; end ;
6629: LD_VAR 0 5
6633: PPUSH
6634: LD_INT 5
6636: PPUSH
6637: CALL_OW 233
6641: GO 6644
6643: POP
// PlaceUnitArea ( un , area , false ) ;
6644: LD_VAR 0 5
6648: PPUSH
6649: LD_VAR 0 1
6653: PPUSH
6654: LD_INT 0
6656: PPUSH
6657: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6661: CALL_OW 44
6665: PPUSH
6666: LD_VAR 0 5
6670: PPUSH
6671: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6675: LD_VAR 0 5
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: LD_INT 100
6685: PPUSH
6686: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6690: LD_VAR 0 5
6694: PPUSH
6695: LD_INT 106
6697: PPUSH
6698: LD_INT 88
6700: PPUSH
6701: CALL_OW 111
// AddComUnload ( un ) ;
6705: LD_VAR 0 5
6709: PPUSH
6710: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6714: LD_VAR 0 5
6718: PPUSH
6719: LD_VAR 0 1
6723: PPUSH
6724: CALL_OW 173
// Wait ( 0 0$02 ) ;
6728: LD_INT 70
6730: PPUSH
6731: CALL_OW 67
// end ;
6735: GO 6510
6737: POP
6738: POP
// Wait ( 0 0$05 ) ;
6739: LD_INT 175
6741: PPUSH
6742: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6746: LD_INT 6
6748: PPUSH
6749: LD_INT 34
6751: PUSH
6752: LD_INT 51
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PPUSH
6759: CALL 11421 0 2
6763: IFFALSE 6951
// begin wait ( 0 0$01 ) ;
6765: LD_INT 35
6767: PPUSH
6768: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6772: LD_ADDR_VAR 0 4
6776: PUSH
6777: LD_INT 6
6779: PPUSH
6780: LD_INT 34
6782: PUSH
6783: LD_INT 51
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL 11421 0 2
6794: PUSH
6795: FOR_IN
6796: IFFALSE 6947
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6798: LD_VAR 0 4
6802: PPUSH
6803: LD_INT 9
6805: PPUSH
6806: CALL_OW 308
6810: PUSH
6811: LD_VAR 0 4
6815: PPUSH
6816: CALL 31653 0 1
6820: PPUSH
6821: CALL_OW 258
6825: PUSH
6826: LD_INT 1
6828: EQUAL
6829: AND
6830: PUSH
6831: LD_EXP 8
6835: AND
6836: IFFALSE 6863
// begin Say ( GetDriver ( i ) , Dtran ) ;
6838: LD_VAR 0 4
6842: PPUSH
6843: CALL 31653 0 1
6847: PPUSH
6848: LD_STRING Dtran
6850: PPUSH
6851: CALL_OW 88
// dialog_trans := false ;
6855: LD_ADDR_EXP 8
6859: PUSH
6860: LD_INT 0
6862: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6863: LD_VAR 0 4
6867: PPUSH
6868: CALL_OW 316
6872: IFFALSE 6888
// ComMoveToArea ( i , area ) ;
6874: LD_VAR 0 4
6878: PPUSH
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6888: LD_VAR 0 4
6892: PPUSH
6893: LD_VAR 0 1
6897: PPUSH
6898: CALL_OW 308
6902: PUSH
6903: LD_VAR 0 4
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: CALL_OW 289
6915: PUSH
6916: LD_INT 0
6918: EQUAL
6919: AND
6920: IFFALSE 6945
// begin RemoveUnit ( GetDriver ( i ) ) ;
6922: LD_VAR 0 4
6926: PPUSH
6927: CALL 31653 0 1
6931: PPUSH
6932: CALL_OW 64
// RemoveUnit ( i ) ;
6936: LD_VAR 0 4
6940: PPUSH
6941: CALL_OW 64
// end ; end ;
6945: GO 6795
6947: POP
6948: POP
// end ;
6949: GO 6746
// end ;
6951: LD_VAR 0 3
6955: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
// if isTest then
6962: LD_EXP 1
6966: IFFALSE 6970
// exit ;
6968: GO 7359
// for i = 1 to n do
6970: LD_ADDR_VAR 0 4
6974: PUSH
6975: DOUBLE
6976: LD_INT 1
6978: DEC
6979: ST_TO_ADDR
6980: LD_VAR 0 2
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7218
// begin uc_side := 8 ;
6988: LD_ADDR_OWVAR 20
6992: PUSH
6993: LD_INT 8
6995: ST_TO_ADDR
// uc_nation := 1 ;
6996: LD_ADDR_OWVAR 21
7000: PUSH
7001: LD_INT 1
7003: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7004: LD_ADDR_VAR 0 6
7008: PUSH
7009: LD_INT 3
7011: PUSH
7012: LD_INT 4
7014: PUSH
7015: LD_INT 4
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 1
7025: PPUSH
7026: LD_OWVAR 67
7030: PPUSH
7031: CALL_OW 12
7035: ARRAY
7036: ST_TO_ADDR
// vc_chassis := ch ;
7037: LD_ADDR_OWVAR 37
7041: PUSH
7042: LD_VAR 0 6
7046: ST_TO_ADDR
// vc_control := control_computer ;
7047: LD_ADDR_OWVAR 38
7051: PUSH
7052: LD_INT 3
7054: ST_TO_ADDR
// vc_engine := engine_combustion ;
7055: LD_ADDR_OWVAR 39
7059: PUSH
7060: LD_INT 1
7062: ST_TO_ADDR
// if ch = us_medium_tracked then
7063: LD_VAR 0 6
7067: PUSH
7068: LD_INT 3
7070: EQUAL
7071: IFFALSE 7118
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7073: LD_ADDR_OWVAR 40
7077: PUSH
7078: LD_INT 3
7080: PUSH
7081: LD_INT 4
7083: PUSH
7084: LD_INT 5
7086: PUSH
7087: LD_INT 7
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: PUSH
7096: LD_OWVAR 67
7100: PPUSH
7101: LD_OWVAR 67
7105: PUSH
7106: LD_INT 1
7108: PLUS
7109: PPUSH
7110: CALL_OW 12
7114: ARRAY
7115: ST_TO_ADDR
7116: GO 7159
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7118: LD_ADDR_OWVAR 40
7122: PUSH
7123: LD_INT 5
7125: PUSH
7126: LD_INT 6
7128: PUSH
7129: LD_INT 7
7131: PUSH
7132: LD_INT 7
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PUSH
7149: LD_INT 1
7151: PLUS
7152: PPUSH
7153: CALL_OW 12
7157: ARRAY
7158: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7159: LD_ADDR_OWVAR 41
7163: PUSH
7164: LD_INT 70
7166: ST_TO_ADDR
// un := CreateVehicle ;
7167: LD_ADDR_VAR 0 5
7171: PUSH
7172: CALL_OW 45
7176: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7177: LD_VAR 0 5
7181: PPUSH
7182: LD_VAR 0 1
7186: PPUSH
7187: LD_INT 0
7189: PPUSH
7190: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7194: LD_VAR 0 5
7198: PPUSH
7199: LD_INT 65
7201: PPUSH
7202: LD_INT 9
7204: PPUSH
7205: CALL_OW 111
// Wait ( 0 0$02 ) ;
7209: LD_INT 70
7211: PPUSH
7212: CALL_OW 67
// end ;
7216: GO 6985
7218: POP
7219: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7220: LD_INT 90
7222: PUSH
7223: LD_INT 80
7225: PUSH
7226: LD_INT 70
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: LD_OWVAR 67
7238: ARRAY
7239: PPUSH
7240: CALL_OW 13
7244: IFFALSE 7351
// begin uc_side := 8 ;
7246: LD_ADDR_OWVAR 20
7250: PUSH
7251: LD_INT 8
7253: ST_TO_ADDR
// uc_nation := 1 ;
7254: LD_ADDR_OWVAR 21
7258: PUSH
7259: LD_INT 1
7261: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7262: LD_ADDR_OWVAR 37
7266: PUSH
7267: LD_INT 4
7269: ST_TO_ADDR
// vc_control := control_computer ;
7270: LD_ADDR_OWVAR 38
7274: PUSH
7275: LD_INT 3
7277: ST_TO_ADDR
// vc_engine := engine_combustion ;
7278: LD_ADDR_OWVAR 39
7282: PUSH
7283: LD_INT 1
7285: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7286: LD_ADDR_OWVAR 40
7290: PUSH
7291: LD_INT 14
7293: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7294: LD_ADDR_OWVAR 41
7298: PUSH
7299: LD_INT 70
7301: ST_TO_ADDR
// un := CreateVehicle ;
7302: LD_ADDR_VAR 0 5
7306: PUSH
7307: CALL_OW 45
7311: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7312: LD_VAR 0 5
7316: PPUSH
7317: LD_VAR 0 1
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7329: LD_VAR 0 5
7333: PPUSH
7334: LD_INT 65
7336: PPUSH
7337: LD_INT 9
7339: PPUSH
7340: CALL_OW 111
// Wait ( 0 0$02 ) ;
7344: LD_INT 70
7346: PPUSH
7347: CALL_OW 67
// end ; alfa_support := true ;
7351: LD_ADDR_EXP 13
7355: PUSH
7356: LD_INT 1
7358: ST_TO_ADDR
// end ;
7359: LD_VAR 0 3
7363: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7364: LD_OWVAR 1
7368: PUSH
7369: LD_INT 21000
7371: PUSH
7372: LD_INT 18900
7374: PUSH
7375: LD_INT 16800
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: LIST
7382: PUSH
7383: LD_OWVAR 67
7387: ARRAY
7388: GREATER
7389: IFFALSE 7473
7391: GO 7393
7393: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7394: LD_EXP 25
7398: PPUSH
7399: LD_STRING DR5
7401: PPUSH
7402: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7406: LD_INT 1050
7408: PPUSH
7409: LD_INT 4200
7411: PPUSH
7412: CALL_OW 12
7416: PPUSH
7417: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7421: LD_INT 20
7423: PPUSH
7424: LD_INT 5
7426: PUSH
7427: LD_INT 6
7429: PUSH
7430: LD_INT 7
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PUSH
7438: LD_OWVAR 67
7442: ARRAY
7443: PPUSH
7444: CALL 6956 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7448: LD_INT 8400
7450: PPUSH
7451: LD_INT 12600
7453: PPUSH
7454: CALL_OW 12
7458: PPUSH
7459: CALL_OW 67
// until tick >= 120 120$00 ;
7463: LD_OWVAR 1
7467: PUSH
7468: LD_INT 252000
7470: GREATEREQUAL
7471: IFFALSE 7394
// end ; end_of_file
7473: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7474: LD_INT 0
7476: PPUSH
// enable_addtolog := isTest ;
7477: LD_ADDR_OWVAR 81
7481: PUSH
7482: LD_EXP 1
7486: ST_TO_ADDR
// lines_break_limit := 5 ;
7487: LD_ADDR_EXP 27
7491: PUSH
7492: LD_INT 5
7494: ST_TO_ADDR
// lines_break_type := --- ;
7495: LD_ADDR_EXP 28
7499: PUSH
7500: LD_STRING ---
7502: ST_TO_ADDR
// lines_counter := 0 ;
7503: LD_ADDR_EXP 26
7507: PUSH
7508: LD_INT 0
7510: ST_TO_ADDR
// show_line_index := true ;
7511: LD_ADDR_EXP 29
7515: PUSH
7516: LD_INT 1
7518: ST_TO_ADDR
// tick_log := true ;
7519: LD_ADDR_EXP 30
7523: PUSH
7524: LD_INT 1
7526: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7527: LD_STRING ----------SAND OF SIBERIA LOG----------
7529: PPUSH
7530: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7534: LD_STRING Map Name: 
7536: PUSH
7537: LD_OWVAR 68
7541: STR
7542: PPUSH
7543: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7547: LD_STRING Map Number: 
7549: PUSH
7550: LD_OWVAR 70
7554: STR
7555: PPUSH
7556: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7560: LD_STRING Difficulty: 
7562: PUSH
7563: LD_OWVAR 67
7567: STR
7568: PPUSH
7569: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7573: LD_STRING ---------------------------------------
7575: PPUSH
7576: CALL_OW 561
// end ;
7580: LD_VAR 0 1
7584: RET
// function Log ( text ) ; begin
7585: LD_INT 0
7587: PPUSH
// if show_line_index then
7588: LD_EXP 29
7592: IFFALSE 7604
// result := lines_counter ;
7594: LD_ADDR_VAR 0 2
7598: PUSH
7599: LD_EXP 26
7603: ST_TO_ADDR
// if tick_log then
7604: LD_EXP 30
7608: IFFALSE 7634
// result := result &  T:  & tick &   ;
7610: LD_ADDR_VAR 0 2
7614: PUSH
7615: LD_VAR 0 2
7619: PUSH
7620: LD_STRING  T: 
7622: STR
7623: PUSH
7624: LD_OWVAR 1
7628: STR
7629: PUSH
7630: LD_STRING  
7632: STR
7633: ST_TO_ADDR
// AddToLog ( result & text ) ;
7634: LD_VAR 0 2
7638: PUSH
7639: LD_VAR 0 1
7643: STR
7644: PPUSH
7645: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7649: LD_ADDR_EXP 26
7653: PUSH
7654: LD_EXP 26
7658: PUSH
7659: LD_INT 1
7661: PLUS
7662: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7663: LD_EXP 26
7667: PUSH
7668: LD_EXP 27
7672: MOD
7673: PUSH
7674: LD_INT 0
7676: EQUAL
7677: IFFALSE 7688
// AddToLog ( lines_break_type ) ;
7679: LD_EXP 28
7683: PPUSH
7684: CALL_OW 561
// end ;
7688: LD_VAR 0 2
7692: RET
// export function LogHuman ( id ) ; begin
7693: LD_INT 0
7695: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7696: LD_STRING Human Created. id: 
7698: PUSH
7699: LD_VAR 0 1
7703: STR
7704: PUSH
7705: LD_STRING ; side: 
7707: STR
7708: PUSH
7709: LD_VAR 0 1
7713: PPUSH
7714: CALL_OW 255
7718: STR
7719: PUSH
7720: LD_STRING ; class: 
7722: STR
7723: PUSH
7724: LD_VAR 0 1
7728: PPUSH
7729: CALL_OW 257
7733: STR
7734: PUSH
7735: LD_STRING ; 
7737: STR
7738: PPUSH
7739: CALL 7585 0 1
// end ;
7743: LD_VAR 0 2
7747: RET
// export function LogVeh ( id ) ; begin
7748: LD_INT 0
7750: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7751: LD_STRING Vehicle Created. id: 
7753: PUSH
7754: LD_VAR 0 1
7758: STR
7759: PUSH
7760: LD_STRING ; side: 
7762: STR
7763: PUSH
7764: LD_VAR 0 1
7768: PPUSH
7769: CALL_OW 255
7773: STR
7774: PUSH
7775: LD_STRING ; nation: 
7777: STR
7778: PUSH
7779: LD_VAR 0 1
7783: PPUSH
7784: CALL_OW 248
7788: STR
7789: PUSH
7790: LD_STRING ; weapon: 
7792: STR
7793: PUSH
7794: LD_VAR 0 1
7798: PPUSH
7799: CALL_OW 264
7803: STR
7804: PUSH
7805: LD_STRING ; 
7807: STR
7808: PPUSH
7809: CALL 7585 0 1
// end ;
7813: LD_VAR 0 2
7817: RET
// export function LogEvent ( event ) ; begin
7818: LD_INT 0
7820: PPUSH
// Log ( Event Executed. id:  & event ) ;
7821: LD_STRING Event Executed. id: 
7823: PUSH
7824: LD_VAR 0 1
7828: STR
7829: PPUSH
7830: CALL 7585 0 1
// end ; end_of_file
7834: LD_VAR 0 2
7838: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7839: LD_INT 0
7841: PPUSH
7842: PPUSH
7843: PPUSH
7844: PPUSH
7845: PPUSH
7846: PPUSH
7847: PPUSH
7848: PPUSH
// if unit then
7849: LD_VAR 0 1
7853: IFFALSE 8253
// begin if mode = 0 then
7855: LD_VAR 0 3
7859: PUSH
7860: LD_INT 0
7862: EQUAL
7863: IFFALSE 8011
// begin if coords then
7865: LD_VAR 0 2
7869: IFFALSE 8009
// while ( coords > 1 ) do
7871: LD_VAR 0 2
7875: PUSH
7876: LD_INT 1
7878: GREATER
7879: IFFALSE 8009
// if not HasTask ( unit ) then
7881: LD_VAR 0 1
7885: PPUSH
7886: CALL_OW 314
7890: NOT
7891: IFFALSE 8007
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7893: LD_VAR 0 1
7897: PPUSH
7898: LD_VAR 0 2
7902: PUSH
7903: LD_INT 1
7905: ARRAY
7906: PPUSH
7907: LD_VAR 0 2
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7920: LD_INT 35
7922: PPUSH
7923: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7927: LD_VAR 0 1
7931: PPUSH
7932: CALL_OW 250
7936: PUSH
7937: LD_VAR 0 2
7941: PUSH
7942: LD_INT 1
7944: ARRAY
7945: EQUAL
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 251
7956: PUSH
7957: LD_VAR 0 2
7961: PUSH
7962: LD_INT 2
7964: ARRAY
7965: EQUAL
7966: AND
7967: IFFALSE 7920
// for i = 1 to 2 do
7969: LD_ADDR_VAR 0 5
7973: PUSH
7974: DOUBLE
7975: LD_INT 1
7977: DEC
7978: ST_TO_ADDR
7979: LD_INT 2
7981: PUSH
7982: FOR_TO
7983: IFFALSE 8005
// coords := Delete ( coords , 1 ) ;
7985: LD_ADDR_VAR 0 2
7989: PUSH
7990: LD_VAR 0 2
7994: PPUSH
7995: LD_INT 1
7997: PPUSH
7998: CALL_OW 3
8002: ST_TO_ADDR
8003: GO 7982
8005: POP
8006: POP
// end ;
8007: GO 7871
// end else
8009: GO 8253
// begin if coords then
8011: LD_VAR 0 2
8015: IFFALSE 8253
// begin x := GetX ( unit ) ;
8017: LD_ADDR_VAR 0 6
8021: PUSH
8022: LD_VAR 0 1
8026: PPUSH
8027: CALL_OW 250
8031: ST_TO_ADDR
// y := GetY ( unit ) ;
8032: LD_ADDR_VAR 0 7
8036: PUSH
8037: LD_VAR 0 1
8041: PPUSH
8042: CALL_OW 251
8046: ST_TO_ADDR
// while ( coords > 1 ) do
8047: LD_VAR 0 2
8051: PUSH
8052: LD_INT 1
8054: GREATER
8055: IFFALSE 8253
// begin Wait ( 0 0$0.3 ) ;
8057: LD_INT 10
8059: PPUSH
8060: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8064: LD_VAR 0 1
8068: PPUSH
8069: CALL_OW 255
8073: PPUSH
8074: LD_VAR 0 1
8078: PPUSH
8079: CALL_OW 250
8083: PPUSH
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 251
8093: PPUSH
8094: LD_INT 14
8096: PPUSH
8097: CALL 22591 0 4
8101: IFFALSE 8132
// begin ComMoveXY ( unit , x , y ) ;
8103: LD_VAR 0 1
8107: PPUSH
8108: LD_VAR 0 6
8112: PPUSH
8113: LD_VAR 0 7
8117: PPUSH
8118: CALL_OW 111
// result := false ;
8122: LD_ADDR_VAR 0 4
8126: PUSH
8127: LD_INT 0
8129: ST_TO_ADDR
// end else
8130: GO 8171
// if not HasTask ( unit ) then
8132: LD_VAR 0 1
8136: PPUSH
8137: CALL_OW 314
8141: NOT
8142: IFFALSE 8171
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8144: LD_VAR 0 1
8148: PPUSH
8149: LD_VAR 0 2
8153: PUSH
8154: LD_INT 1
8156: ARRAY
8157: PPUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 2
8165: ARRAY
8166: PPUSH
8167: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8171: LD_VAR 0 1
8175: PPUSH
8176: CALL_OW 250
8180: PUSH
8181: LD_VAR 0 2
8185: PUSH
8186: LD_INT 1
8188: ARRAY
8189: EQUAL
8190: PUSH
8191: LD_VAR 0 1
8195: PPUSH
8196: CALL_OW 251
8200: PUSH
8201: LD_VAR 0 2
8205: PUSH
8206: LD_INT 2
8208: ARRAY
8209: EQUAL
8210: AND
8211: IFFALSE 8251
// for i = 1 to 2 do
8213: LD_ADDR_VAR 0 5
8217: PUSH
8218: DOUBLE
8219: LD_INT 1
8221: DEC
8222: ST_TO_ADDR
8223: LD_INT 2
8225: PUSH
8226: FOR_TO
8227: IFFALSE 8249
// coords := Delete ( coords , 1 ) ;
8229: LD_ADDR_VAR 0 2
8233: PUSH
8234: LD_VAR 0 2
8238: PPUSH
8239: LD_INT 1
8241: PPUSH
8242: CALL_OW 3
8246: ST_TO_ADDR
8247: GO 8226
8249: POP
8250: POP
// end ;
8251: GO 8047
// end ; end ; end ; result := true ;
8253: LD_ADDR_VAR 0 4
8257: PUSH
8258: LD_INT 1
8260: ST_TO_ADDR
// end ;
8261: LD_VAR 0 4
8265: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8266: LD_INT 0
8268: PPUSH
8269: PPUSH
8270: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8271: LD_ADDR_VAR 0 5
8275: PUSH
8276: LD_INT 81
8278: PUSH
8279: LD_VAR 0 1
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PPUSH
8288: CALL_OW 69
8292: ST_TO_ADDR
// for i in units do
8293: LD_ADDR_VAR 0 4
8297: PUSH
8298: LD_VAR 0 2
8302: PUSH
8303: FOR_IN
8304: IFFALSE 8332
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8306: LD_VAR 0 4
8310: PPUSH
8311: LD_VAR 0 5
8315: PPUSH
8316: LD_VAR 0 4
8320: PPUSH
8321: CALL_OW 74
8325: PPUSH
8326: CALL_OW 115
// end ;
8330: GO 8303
8332: POP
8333: POP
// end ;
8334: LD_VAR 0 3
8338: RET
// export function MC_Show ( string ) ; begin
8339: LD_INT 0
8341: PPUSH
// display_strings := string ;
8342: LD_ADDR_OWVAR 47
8346: PUSH
8347: LD_VAR 0 1
8351: ST_TO_ADDR
// end ; end_of_file
8352: LD_VAR 0 2
8356: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8357: LD_INT 0
8359: PPUSH
8360: PPUSH
8361: PPUSH
8362: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8363: LD_ADDR_VAR 0 8
8367: PUSH
8368: LD_VAR 0 1
8372: PPUSH
8373: LD_INT 2
8375: PPUSH
8376: EMPTY
8377: PPUSH
8378: CALL 11504 0 3
8382: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8383: LD_VAR 0 8
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_VAR 0 3
8397: PPUSH
8398: CALL_OW 428
8402: PUSH
8403: LD_INT 0
8405: EQUAL
8406: AND
8407: IFFALSE 8481
// for i = 1 to plist do
8409: LD_ADDR_VAR 0 6
8413: PUSH
8414: DOUBLE
8415: LD_INT 1
8417: DEC
8418: ST_TO_ADDR
8419: LD_VAR 0 8
8423: PUSH
8424: FOR_TO
8425: IFFALSE 8479
// if NotTask ( plist [ i ] ) then
8427: LD_VAR 0 8
8431: PUSH
8432: LD_VAR 0 6
8436: ARRAY
8437: PPUSH
8438: CALL 32298 0 1
8442: IFFALSE 8477
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8444: LD_VAR 0 8
8448: PUSH
8449: LD_VAR 0 6
8453: ARRAY
8454: PPUSH
8455: LD_INT 0
8457: PPUSH
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_VAR 0 3
8467: PPUSH
8468: LD_VAR 0 4
8472: PPUSH
8473: CALL_OW 145
// end ;
8477: GO 8424
8479: POP
8480: POP
// end ;
8481: LD_VAR 0 5
8485: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8486: LD_INT 0
8488: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8489: LD_VAR 0 1
8493: PPUSH
8494: LD_INT 6
8496: PPUSH
8497: LD_VAR 0 2
8501: PPUSH
8502: LD_VAR 0 3
8506: PPUSH
8507: LD_VAR 0 4
8511: PPUSH
8512: CALL 9990 0 5
// end ;
8516: LD_VAR 0 5
8520: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8521: LD_INT 0
8523: PPUSH
8524: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8525: LD_ADDR_VAR 0 4
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 1
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 2
8544: PUSH
8545: LD_INT 30
8547: PUSH
8548: LD_INT 0
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: PUSH
8555: LD_INT 30
8557: PUSH
8558: LD_INT 1
8560: PUSH
8561: EMPTY
8562: LIST
8563: LIST
8564: PUSH
8565: EMPTY
8566: LIST
8567: LIST
8568: LIST
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: PUSH
8574: EMPTY
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: CALL_OW 250
8591: PPUSH
8592: LD_VAR 0 2
8596: PPUSH
8597: CALL_OW 251
8601: PPUSH
8602: CALL_OW 73
8606: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8607: LD_VAR 0 4
8611: PPUSH
8612: LD_VAR 0 2
8616: PPUSH
8617: CALL 10279 0 2
8621: IFFALSE 8680
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8623: LD_VAR 0 1
8627: PPUSH
8628: LD_INT 30
8630: PUSH
8631: LD_VAR 0 2
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PPUSH
8640: CALL 11421 0 2
8644: PUSH
8645: LD_INT 1
8647: ARRAY
8648: PPUSH
8649: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8653: LD_ADDR_EXP 49
8657: PUSH
8658: LD_EXP 49
8662: PPUSH
8663: LD_VAR 0 1
8667: PPUSH
8668: LD_VAR 0 2
8672: PPUSH
8673: EMPTY
8674: PPUSH
8675: CALL 42332 0 4
8679: ST_TO_ADDR
// end ; end ;
8680: LD_VAR 0 3
8684: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8685: LD_INT 0
8687: PPUSH
8688: PPUSH
8689: PPUSH
8690: PPUSH
8691: PPUSH
8692: PPUSH
// result := false ;
8693: LD_ADDR_VAR 0 4
8697: PUSH
8698: LD_INT 0
8700: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8701: LD_VAR 0 1
8705: PPUSH
8706: LD_EXP 41
8710: PPUSH
8711: CALL 43280 0 2
8715: IFFALSE 8928
// for i = 1 to MREG_LabList do
8717: LD_ADDR_VAR 0 5
8721: PUSH
8722: DOUBLE
8723: LD_INT 1
8725: DEC
8726: ST_TO_ADDR
8727: LD_EXP 41
8731: PUSH
8732: FOR_TO
8733: IFFALSE 8926
// begin if MREG_LabList [ i ] [ 1 ] = side then
8735: LD_EXP 41
8739: PUSH
8740: LD_VAR 0 5
8744: ARRAY
8745: PUSH
8746: LD_INT 1
8748: ARRAY
8749: PUSH
8750: LD_VAR 0 1
8754: EQUAL
8755: IFFALSE 8924
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8757: LD_ADDR_VAR 0 7
8761: PUSH
8762: LD_EXP 41
8766: PUSH
8767: LD_VAR 0 5
8771: ARRAY
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8777: LD_ADDR_VAR 0 9
8781: PUSH
8782: LD_INT 22
8784: PUSH
8785: LD_VAR 0 1
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: PUSH
8794: LD_INT 2
8796: PUSH
8797: LD_INT 30
8799: PUSH
8800: LD_INT 0
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 30
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: LIST
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PUSH
8826: EMPTY
8827: LIST
8828: PPUSH
8829: CALL_OW 69
8833: PPUSH
8834: LD_VAR 0 7
8838: PPUSH
8839: CALL_OW 250
8843: PPUSH
8844: LD_VAR 0 7
8848: PPUSH
8849: CALL_OW 251
8853: PPUSH
8854: CALL_OW 73
8858: ST_TO_ADDR
// if dep then
8859: LD_VAR 0 9
8863: IFFALSE 8922
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8865: LD_VAR 0 9
8869: PPUSH
8870: LD_VAR 0 2
8874: PPUSH
8875: LD_VAR 0 3
8879: PPUSH
8880: CALL 10395 0 3
8884: IFFALSE 8922
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8886: LD_VAR 0 7
8890: PPUSH
8891: LD_VAR 0 2
8895: PPUSH
8896: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8900: LD_VAR 0 7
8904: PPUSH
8905: LD_VAR 0 3
8909: PPUSH
8910: CALL_OW 207
// result := true ;
8914: LD_ADDR_VAR 0 4
8918: PUSH
8919: LD_INT 1
8921: ST_TO_ADDR
// end ; end ; break ;
8922: GO 8926
// end ; end ;
8924: GO 8732
8926: POP
8927: POP
// end ;
8928: LD_VAR 0 4
8932: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8933: LD_INT 0
8935: PPUSH
8936: PPUSH
8937: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8938: LD_ADDR_VAR 0 7
8942: PUSH
8943: LD_VAR 0 2
8947: PPUSH
8948: LD_VAR 0 3
8952: PPUSH
8953: LD_VAR 0 4
8957: PPUSH
8958: CALL 9120 0 3
8962: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8963: LD_ADDR_EXP 47
8967: PUSH
8968: LD_EXP 47
8972: PPUSH
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 2
8980: PPUSH
8981: LD_VAR 0 2
8985: PUSH
8986: LD_VAR 0 3
8990: PUSH
8991: LD_VAR 0 4
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: PPUSH
9001: CALL 42241 0 4
9005: ST_TO_ADDR
// if ext_list then
9006: LD_VAR 0 5
9010: IFFALSE 9115
// for i = 1 to ext_list do
9012: LD_ADDR_VAR 0 8
9016: PUSH
9017: DOUBLE
9018: LD_INT 1
9020: DEC
9021: ST_TO_ADDR
9022: LD_VAR 0 5
9026: PUSH
9027: FOR_TO
9028: IFFALSE 9113
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9030: LD_ADDR_EXP 47
9034: PUSH
9035: LD_EXP 47
9039: PPUSH
9040: LD_VAR 0 1
9044: PPUSH
9045: LD_VAR 0 5
9049: PUSH
9050: LD_VAR 0 8
9054: ARRAY
9055: PPUSH
9056: LD_VAR 0 7
9060: PUSH
9061: LD_VAR 0 8
9065: ARRAY
9066: PUSH
9067: LD_INT 1
9069: ARRAY
9070: PUSH
9071: LD_VAR 0 7
9075: PUSH
9076: LD_VAR 0 8
9080: ARRAY
9081: PUSH
9082: LD_INT 2
9084: ARRAY
9085: PUSH
9086: LD_VAR 0 7
9090: PUSH
9091: LD_VAR 0 8
9095: ARRAY
9096: PUSH
9097: LD_INT 3
9099: ARRAY
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: PPUSH
9106: CALL 42241 0 4
9110: ST_TO_ADDR
9111: GO 9027
9113: POP
9114: POP
// end ;
9115: LD_VAR 0 6
9119: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9120: LD_INT 0
9122: PPUSH
9123: PPUSH
// list := [ ] ;
9124: LD_ADDR_VAR 0 5
9128: PUSH
9129: EMPTY
9130: ST_TO_ADDR
// case d of 0 :
9131: LD_VAR 0 3
9135: PUSH
9136: LD_INT 0
9138: DOUBLE
9139: EQUAL
9140: IFTRUE 9144
9142: GO 9277
9144: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9145: LD_ADDR_VAR 0 5
9149: PUSH
9150: LD_VAR 0 1
9154: PUSH
9155: LD_INT 4
9157: MINUS
9158: PUSH
9159: LD_VAR 0 2
9163: PUSH
9164: LD_INT 4
9166: MINUS
9167: PUSH
9168: LD_INT 2
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: LIST
9175: PUSH
9176: LD_VAR 0 1
9180: PUSH
9181: LD_INT 3
9183: MINUS
9184: PUSH
9185: LD_VAR 0 2
9189: PUSH
9190: LD_INT 1
9192: PUSH
9193: EMPTY
9194: LIST
9195: LIST
9196: LIST
9197: PUSH
9198: LD_VAR 0 1
9202: PUSH
9203: LD_INT 4
9205: PLUS
9206: PUSH
9207: LD_VAR 0 2
9211: PUSH
9212: LD_INT 4
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PUSH
9220: LD_VAR 0 1
9224: PUSH
9225: LD_INT 3
9227: PLUS
9228: PUSH
9229: LD_VAR 0 2
9233: PUSH
9234: LD_INT 3
9236: PLUS
9237: PUSH
9238: LD_INT 5
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: LIST
9245: PUSH
9246: LD_VAR 0 1
9250: PUSH
9251: LD_VAR 0 2
9255: PUSH
9256: LD_INT 4
9258: PLUS
9259: PUSH
9260: LD_INT 0
9262: PUSH
9263: EMPTY
9264: LIST
9265: LIST
9266: LIST
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: LIST
9274: ST_TO_ADDR
// end ; 1 :
9275: GO 9975
9277: LD_INT 1
9279: DOUBLE
9280: EQUAL
9281: IFTRUE 9285
9283: GO 9418
9285: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9286: LD_ADDR_VAR 0 5
9290: PUSH
9291: LD_VAR 0 1
9295: PUSH
9296: LD_VAR 0 2
9300: PUSH
9301: LD_INT 4
9303: MINUS
9304: PUSH
9305: LD_INT 3
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_VAR 0 1
9317: PUSH
9318: LD_INT 3
9320: MINUS
9321: PUSH
9322: LD_VAR 0 2
9326: PUSH
9327: LD_INT 3
9329: MINUS
9330: PUSH
9331: LD_INT 2
9333: PUSH
9334: EMPTY
9335: LIST
9336: LIST
9337: LIST
9338: PUSH
9339: LD_VAR 0 1
9343: PUSH
9344: LD_INT 4
9346: MINUS
9347: PUSH
9348: LD_VAR 0 2
9352: PUSH
9353: LD_INT 1
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: LIST
9360: PUSH
9361: LD_VAR 0 1
9365: PUSH
9366: LD_VAR 0 2
9370: PUSH
9371: LD_INT 3
9373: PLUS
9374: PUSH
9375: LD_INT 0
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: LIST
9382: PUSH
9383: LD_VAR 0 1
9387: PUSH
9388: LD_INT 4
9390: PLUS
9391: PUSH
9392: LD_VAR 0 2
9396: PUSH
9397: LD_INT 4
9399: PLUS
9400: PUSH
9401: LD_INT 5
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// end ; 2 :
9416: GO 9975
9418: LD_INT 2
9420: DOUBLE
9421: EQUAL
9422: IFTRUE 9426
9424: GO 9555
9426: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9427: LD_ADDR_VAR 0 5
9431: PUSH
9432: LD_VAR 0 1
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 3
9444: MINUS
9445: PUSH
9446: LD_INT 3
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: LIST
9453: PUSH
9454: LD_VAR 0 1
9458: PUSH
9459: LD_INT 4
9461: PLUS
9462: PUSH
9463: LD_VAR 0 2
9467: PUSH
9468: LD_INT 4
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: LD_VAR 0 1
9502: PUSH
9503: LD_INT 3
9505: MINUS
9506: PUSH
9507: LD_VAR 0 2
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: LIST
9519: PUSH
9520: LD_VAR 0 1
9524: PUSH
9525: LD_INT 4
9527: MINUS
9528: PUSH
9529: LD_VAR 0 2
9533: PUSH
9534: LD_INT 4
9536: MINUS
9537: PUSH
9538: LD_INT 2
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: ST_TO_ADDR
// end ; 3 :
9553: GO 9975
9555: LD_INT 3
9557: DOUBLE
9558: EQUAL
9559: IFTRUE 9563
9561: GO 9696
9563: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 3
9576: PLUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 4
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_INT 4
9598: PLUS
9599: PUSH
9600: LD_VAR 0 2
9604: PUSH
9605: LD_INT 4
9607: PLUS
9608: PUSH
9609: LD_INT 5
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: PUSH
9617: LD_VAR 0 1
9621: PUSH
9622: LD_INT 4
9624: MINUS
9625: PUSH
9626: LD_VAR 0 2
9630: PUSH
9631: LD_INT 1
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: LD_VAR 0 1
9643: PUSH
9644: LD_VAR 0 2
9648: PUSH
9649: LD_INT 4
9651: MINUS
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: LIST
9660: PUSH
9661: LD_VAR 0 1
9665: PUSH
9666: LD_INT 3
9668: MINUS
9669: PUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_INT 3
9677: MINUS
9678: PUSH
9679: LD_INT 2
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: ST_TO_ADDR
// end ; 4 :
9694: GO 9975
9696: LD_INT 4
9698: DOUBLE
9699: EQUAL
9700: IFTRUE 9704
9702: GO 9837
9704: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9705: LD_ADDR_VAR 0 5
9709: PUSH
9710: LD_VAR 0 1
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: LD_INT 4
9722: PLUS
9723: PUSH
9724: LD_INT 0
9726: PUSH
9727: EMPTY
9728: LIST
9729: LIST
9730: LIST
9731: PUSH
9732: LD_VAR 0 1
9736: PUSH
9737: LD_INT 3
9739: PLUS
9740: PUSH
9741: LD_VAR 0 2
9745: PUSH
9746: LD_INT 3
9748: PLUS
9749: PUSH
9750: LD_INT 5
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: LIST
9757: PUSH
9758: LD_VAR 0 1
9762: PUSH
9763: LD_INT 3
9765: PLUS
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: LD_INT 4
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: LIST
9779: PUSH
9780: LD_VAR 0 1
9784: PUSH
9785: LD_VAR 0 2
9789: PUSH
9790: LD_INT 3
9792: MINUS
9793: PUSH
9794: LD_INT 3
9796: PUSH
9797: EMPTY
9798: LIST
9799: LIST
9800: LIST
9801: PUSH
9802: LD_VAR 0 1
9806: PUSH
9807: LD_INT 4
9809: MINUS
9810: PUSH
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 4
9818: MINUS
9819: PUSH
9820: LD_INT 2
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: LIST
9827: PUSH
9828: EMPTY
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: ST_TO_ADDR
// end ; 5 :
9835: GO 9975
9837: LD_INT 5
9839: DOUBLE
9840: EQUAL
9841: IFTRUE 9845
9843: GO 9974
9845: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9846: LD_ADDR_VAR 0 5
9850: PUSH
9851: LD_VAR 0 1
9855: PUSH
9856: LD_INT 4
9858: MINUS
9859: PUSH
9860: LD_VAR 0 2
9864: PUSH
9865: LD_INT 1
9867: PUSH
9868: EMPTY
9869: LIST
9870: LIST
9871: LIST
9872: PUSH
9873: LD_VAR 0 1
9877: PUSH
9878: LD_VAR 0 2
9882: PUSH
9883: LD_INT 4
9885: MINUS
9886: PUSH
9887: LD_INT 3
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: LIST
9894: PUSH
9895: LD_VAR 0 1
9899: PUSH
9900: LD_INT 4
9902: PLUS
9903: PUSH
9904: LD_VAR 0 2
9908: PUSH
9909: LD_INT 4
9911: PLUS
9912: PUSH
9913: LD_INT 5
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: LIST
9920: PUSH
9921: LD_VAR 0 1
9925: PUSH
9926: LD_INT 3
9928: PLUS
9929: PUSH
9930: LD_VAR 0 2
9934: PUSH
9935: LD_INT 4
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: LIST
9942: PUSH
9943: LD_VAR 0 1
9947: PUSH
9948: LD_VAR 0 2
9952: PUSH
9953: LD_INT 3
9955: PLUS
9956: PUSH
9957: LD_INT 0
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: ST_TO_ADDR
// end ; end ;
9972: GO 9975
9974: POP
// result := list ;
9975: LD_ADDR_VAR 0 4
9979: PUSH
9980: LD_VAR 0 5
9984: ST_TO_ADDR
// end ;
9985: LD_VAR 0 4
9989: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9990: LD_INT 0
9992: PPUSH
9993: PPUSH
9994: PPUSH
9995: PPUSH
9996: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9997: LD_ADDR_VAR 0 10
10001: PUSH
10002: LD_VAR 0 1
10006: PPUSH
10007: LD_INT 2
10009: PPUSH
10010: EMPTY
10011: PPUSH
10012: CALL 11504 0 3
10016: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10017: LD_ADDR_VAR 0 9
10021: PUSH
10022: LD_INT 22
10024: PUSH
10025: LD_VAR 0 1
10029: PUSH
10030: EMPTY
10031: LIST
10032: LIST
10033: PUSH
10034: LD_INT 2
10036: PUSH
10037: LD_INT 30
10039: PUSH
10040: LD_INT 0
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 30
10049: PUSH
10050: LD_INT 1
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: LIST
10061: PUSH
10062: EMPTY
10063: LIST
10064: LIST
10065: PUSH
10066: EMPTY
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: PPUSH
10074: LD_VAR 0 3
10078: PPUSH
10079: LD_VAR 0 4
10083: PPUSH
10084: CALL_OW 73
10088: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10089: LD_ADDR_VAR 0 8
10093: PUSH
10094: LD_VAR 0 9
10098: PPUSH
10099: LD_VAR 0 2
10103: PPUSH
10104: CALL 10279 0 2
10108: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10109: LD_VAR 0 10
10113: PUSH
10114: LD_VAR 0 8
10118: AND
10119: PUSH
10120: LD_VAR 0 9
10124: PPUSH
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_VAR 0 4
10134: PPUSH
10135: CALL_OW 297
10139: PUSH
10140: LD_INT 26
10142: LESSEQUAL
10143: AND
10144: PUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: LD_VAR 0 4
10154: PPUSH
10155: CALL_OW 428
10159: PUSH
10160: LD_INT 0
10162: EQUAL
10163: AND
10164: IFFALSE 10274
// for i = 1 to plist do
10166: LD_ADDR_VAR 0 7
10170: PUSH
10171: DOUBLE
10172: LD_INT 1
10174: DEC
10175: ST_TO_ADDR
10176: LD_VAR 0 10
10180: PUSH
10181: FOR_TO
10182: IFFALSE 10272
// if IsInUnit ( plist [ i ] ) then
10184: LD_VAR 0 10
10188: PUSH
10189: LD_VAR 0 7
10193: ARRAY
10194: PPUSH
10195: CALL_OW 310
10199: IFFALSE 10218
// ComExitBuilding ( plist [ i ] ) else
10201: LD_VAR 0 10
10205: PUSH
10206: LD_VAR 0 7
10210: ARRAY
10211: PPUSH
10212: CALL_OW 122
10216: GO 10270
// if NotTask ( plist [ i ] ) then
10218: LD_VAR 0 10
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL 32298 0 1
10233: IFFALSE 10270
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10235: LD_VAR 0 10
10239: PUSH
10240: LD_VAR 0 7
10244: ARRAY
10245: PPUSH
10246: LD_VAR 0 2
10250: PPUSH
10251: LD_VAR 0 3
10255: PPUSH
10256: LD_VAR 0 4
10260: PPUSH
10261: LD_VAR 0 5
10265: PPUSH
10266: CALL_OW 145
// end ;
10270: GO 10181
10272: POP
10273: POP
// end ;
10274: LD_VAR 0 6
10278: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10279: LD_INT 0
10281: PPUSH
10282: PPUSH
10283: PPUSH
// pom := GetBase ( bdepot ) ;
10284: LD_ADDR_VAR 0 4
10288: PUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 274
10298: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10299: LD_ADDR_VAR 0 5
10303: PUSH
10304: LD_VAR 0 2
10308: PPUSH
10309: LD_VAR 0 1
10313: PPUSH
10314: CALL_OW 248
10318: PPUSH
10319: CALL_OW 450
10323: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10324: LD_VAR 0 4
10328: PPUSH
10329: LD_INT 1
10331: PPUSH
10332: CALL_OW 275
10336: PUSH
10337: LD_VAR 0 5
10341: PUSH
10342: LD_INT 1
10344: ARRAY
10345: GREATEREQUAL
10346: PUSH
10347: LD_VAR 0 4
10351: PPUSH
10352: LD_INT 3
10354: PPUSH
10355: CALL_OW 275
10359: PUSH
10360: LD_VAR 0 5
10364: PUSH
10365: LD_INT 3
10367: ARRAY
10368: GREATEREQUAL
10369: AND
10370: IFFALSE 10382
// result := true else
10372: LD_ADDR_VAR 0 3
10376: PUSH
10377: LD_INT 1
10379: ST_TO_ADDR
10380: GO 10390
// result := false ;
10382: LD_ADDR_VAR 0 3
10386: PUSH
10387: LD_INT 0
10389: ST_TO_ADDR
// end ;
10390: LD_VAR 0 3
10394: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10395: LD_INT 0
10397: PPUSH
10398: PPUSH
10399: PPUSH
10400: PPUSH
10401: PPUSH
// pom := GetBase ( bdepot ) ;
10402: LD_ADDR_VAR 0 5
10406: PUSH
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 274
10416: ST_TO_ADDR
// cost := [ ] ;
10417: LD_ADDR_VAR 0 8
10421: PUSH
10422: EMPTY
10423: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10424: LD_ADDR_VAR 0 6
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_VAR 0 1
10438: PPUSH
10439: CALL_OW 248
10443: PPUSH
10444: CALL_OW 450
10448: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10449: LD_ADDR_VAR 0 7
10453: PUSH
10454: LD_VAR 0 3
10458: PPUSH
10459: LD_VAR 0 1
10463: PPUSH
10464: CALL_OW 248
10468: PPUSH
10469: CALL_OW 450
10473: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10474: LD_ADDR_VAR 0 8
10478: PUSH
10479: LD_VAR 0 8
10483: PPUSH
10484: LD_INT 1
10486: PPUSH
10487: LD_VAR 0 6
10491: PUSH
10492: LD_INT 1
10494: ARRAY
10495: PUSH
10496: LD_VAR 0 7
10500: PUSH
10501: LD_INT 1
10503: ARRAY
10504: PLUS
10505: PPUSH
10506: CALL_OW 1
10510: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10511: LD_ADDR_VAR 0 8
10515: PUSH
10516: LD_VAR 0 8
10520: PPUSH
10521: LD_INT 2
10523: PPUSH
10524: LD_VAR 0 6
10528: PUSH
10529: LD_INT 2
10531: ARRAY
10532: PUSH
10533: LD_VAR 0 7
10537: PUSH
10538: LD_INT 2
10540: ARRAY
10541: PLUS
10542: PPUSH
10543: CALL_OW 1
10547: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10548: LD_ADDR_VAR 0 8
10552: PUSH
10553: LD_VAR 0 8
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_VAR 0 6
10565: PUSH
10566: LD_INT 3
10568: ARRAY
10569: PUSH
10570: LD_VAR 0 7
10574: PUSH
10575: LD_INT 3
10577: ARRAY
10578: PLUS
10579: PPUSH
10580: CALL_OW 1
10584: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10585: LD_VAR 0 5
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL_OW 275
10597: PUSH
10598: LD_VAR 0 8
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: GREATEREQUAL
10607: PUSH
10608: LD_VAR 0 5
10612: PPUSH
10613: LD_INT 3
10615: PPUSH
10616: CALL_OW 275
10620: PUSH
10621: LD_VAR 0 8
10625: PUSH
10626: LD_INT 3
10628: ARRAY
10629: GREATEREQUAL
10630: AND
10631: IFFALSE 10643
// result := true else
10633: LD_ADDR_VAR 0 4
10637: PUSH
10638: LD_INT 1
10640: ST_TO_ADDR
10641: GO 10651
// result := false ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_INT 0
10650: ST_TO_ADDR
// end ;
10651: LD_VAR 0 4
10655: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10656: LD_INT 0
10658: PPUSH
10659: PPUSH
10660: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10661: LD_ADDR_VAR 0 5
10665: PUSH
10666: LD_VAR 0 1
10670: PPUSH
10671: LD_INT 2
10673: PPUSH
10674: EMPTY
10675: PPUSH
10676: CALL 11504 0 3
10680: ST_TO_ADDR
// if unit and plist then
10681: LD_VAR 0 2
10685: PUSH
10686: LD_VAR 0 5
10690: AND
10691: IFFALSE 10752
// for i = 1 to plist do
10693: LD_ADDR_VAR 0 4
10697: PUSH
10698: DOUBLE
10699: LD_INT 1
10701: DEC
10702: ST_TO_ADDR
10703: LD_VAR 0 5
10707: PUSH
10708: FOR_TO
10709: IFFALSE 10750
// if NotTask ( plist [ i ] ) then
10711: LD_VAR 0 5
10715: PUSH
10716: LD_VAR 0 4
10720: ARRAY
10721: PPUSH
10722: CALL 32298 0 1
10726: IFFALSE 10748
// ComDismantle ( plist [ i ] , unit ) ;
10728: LD_VAR 0 5
10732: PUSH
10733: LD_VAR 0 4
10737: ARRAY
10738: PPUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: CALL_OW 167
10748: GO 10708
10750: POP
10751: POP
// result := true ;
10752: LD_ADDR_VAR 0 3
10756: PUSH
10757: LD_INT 1
10759: ST_TO_ADDR
// end ;
10760: LD_VAR 0 3
10764: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10765: LD_INT 0
10767: PPUSH
10768: PPUSH
10769: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10770: LD_ADDR_VAR 0 5
10774: PUSH
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_INT 2
10782: PPUSH
10783: EMPTY
10784: PPUSH
10785: CALL 11504 0 3
10789: ST_TO_ADDR
// if unit and plist then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_VAR 0 5
10799: AND
10800: IFFALSE 10861
// for i = 1 to plist do
10802: LD_ADDR_VAR 0 4
10806: PUSH
10807: DOUBLE
10808: LD_INT 1
10810: DEC
10811: ST_TO_ADDR
10812: LD_VAR 0 5
10816: PUSH
10817: FOR_TO
10818: IFFALSE 10859
// if NotTask ( plist [ i ] ) then
10820: LD_VAR 0 5
10824: PUSH
10825: LD_VAR 0 4
10829: ARRAY
10830: PPUSH
10831: CALL 32298 0 1
10835: IFFALSE 10857
// ComComplete ( plist [ i ] , unit ) ;
10837: LD_VAR 0 5
10841: PUSH
10842: LD_VAR 0 4
10846: ARRAY
10847: PPUSH
10848: LD_VAR 0 2
10852: PPUSH
10853: CALL 31834 0 2
10857: GO 10817
10859: POP
10860: POP
// result := true ;
10861: LD_ADDR_VAR 0 3
10865: PUSH
10866: LD_INT 1
10868: ST_TO_ADDR
// end ;
10869: LD_VAR 0 3
10873: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10874: LD_INT 0
10876: PPUSH
10877: PPUSH
10878: PPUSH
10879: PPUSH
10880: PPUSH
10881: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10882: LD_ADDR_VAR 0 5
10886: PUSH
10887: LD_INT 22
10889: PUSH
10890: LD_VAR 0 1
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PUSH
10899: LD_INT 21
10901: PUSH
10902: LD_INT 3
10904: PUSH
10905: EMPTY
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 3
10911: PUSH
10912: LD_INT 57
10914: PUSH
10915: EMPTY
10916: LIST
10917: PUSH
10918: EMPTY
10919: LIST
10920: LIST
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 24
10927: PUSH
10928: LD_INT 1000
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: PPUSH
10945: CALL_OW 69
10949: ST_TO_ADDR
// r := [ ] ;
10950: LD_ADDR_VAR 0 6
10954: PUSH
10955: EMPTY
10956: ST_TO_ADDR
// if not tmp then
10957: LD_VAR 0 5
10961: NOT
10962: IFFALSE 10968
// exit else
10964: GO 11156
10966: GO 11136
// begin r := [ tmp [ 1 ] ] ;
10968: LD_ADDR_VAR 0 6
10972: PUSH
10973: LD_VAR 0 5
10977: PUSH
10978: LD_INT 1
10980: ARRAY
10981: PUSH
10982: EMPTY
10983: LIST
10984: ST_TO_ADDR
// for i = 2 to tmp do
10985: LD_ADDR_VAR 0 3
10989: PUSH
10990: DOUBLE
10991: LD_INT 2
10993: DEC
10994: ST_TO_ADDR
10995: LD_VAR 0 5
10999: PUSH
11000: FOR_TO
11001: IFFALSE 11134
// begin m := false ;
11003: LD_ADDR_VAR 0 7
11007: PUSH
11008: LD_INT 0
11010: ST_TO_ADDR
// for j = 1 to r do
11011: LD_ADDR_VAR 0 4
11015: PUSH
11016: DOUBLE
11017: LD_INT 1
11019: DEC
11020: ST_TO_ADDR
11021: LD_VAR 0 6
11025: PUSH
11026: FOR_TO
11027: IFFALSE 11101
// if GetLives ( tmp [ i ] ) < r [ j ] then
11029: LD_VAR 0 5
11033: PUSH
11034: LD_VAR 0 3
11038: ARRAY
11039: PPUSH
11040: CALL_OW 256
11044: PUSH
11045: LD_VAR 0 6
11049: PUSH
11050: LD_VAR 0 4
11054: ARRAY
11055: LESS
11056: IFFALSE 11099
// begin r := Insert ( r , j , tmp [ i ] ) ;
11058: LD_ADDR_VAR 0 6
11062: PUSH
11063: LD_VAR 0 6
11067: PPUSH
11068: LD_VAR 0 4
11072: PPUSH
11073: LD_VAR 0 5
11077: PUSH
11078: LD_VAR 0 3
11082: ARRAY
11083: PPUSH
11084: CALL_OW 2
11088: ST_TO_ADDR
// m := true ;
11089: LD_ADDR_VAR 0 7
11093: PUSH
11094: LD_INT 1
11096: ST_TO_ADDR
// break ;
11097: GO 11101
// end ;
11099: GO 11026
11101: POP
11102: POP
// if not m then
11103: LD_VAR 0 7
11107: NOT
11108: IFFALSE 11132
// r := r ^ tmp [ i ] ;
11110: LD_ADDR_VAR 0 6
11114: PUSH
11115: LD_VAR 0 6
11119: PUSH
11120: LD_VAR 0 5
11124: PUSH
11125: LD_VAR 0 3
11129: ARRAY
11130: ADD
11131: ST_TO_ADDR
// end ;
11132: GO 11000
11134: POP
11135: POP
// end ; if r then
11136: LD_VAR 0 6
11140: IFFALSE 11154
// result := r else
11142: LD_ADDR_VAR 0 2
11146: PUSH
11147: LD_VAR 0 6
11151: ST_TO_ADDR
11152: GO 11156
// exit ;
11154: GO 11156
// end ;
11156: LD_VAR 0 2
11160: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11161: LD_INT 0
11163: PPUSH
11164: PPUSH
11165: PPUSH
11166: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11167: LD_ADDR_VAR 0 5
11171: PUSH
11172: LD_INT 22
11174: PUSH
11175: LD_VAR 0 1
11179: PUSH
11180: EMPTY
11181: LIST
11182: LIST
11183: PUSH
11184: LD_INT 2
11186: PUSH
11187: LD_INT 25
11189: PUSH
11190: LD_INT 2
11192: PUSH
11193: EMPTY
11194: LIST
11195: LIST
11196: PUSH
11197: LD_INT 25
11199: PUSH
11200: LD_INT 16
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: PUSH
11207: LD_INT 34
11209: PUSH
11210: LD_INT 13
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: PUSH
11217: LD_INT 34
11219: PUSH
11220: LD_INT 52
11222: PUSH
11223: EMPTY
11224: LIST
11225: LIST
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 24
11236: PUSH
11237: LD_INT 650
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: LIST
11248: PPUSH
11249: CALL_OW 69
11253: ST_TO_ADDR
// p := 1 ;
11254: LD_ADDR_VAR 0 4
11258: PUSH
11259: LD_INT 1
11261: ST_TO_ADDR
// for i = 1 to repairs do
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: DOUBLE
11268: LD_INT 1
11270: DEC
11271: ST_TO_ADDR
11272: LD_VAR 0 5
11276: PUSH
11277: FOR_TO
11278: IFFALSE 11414
// begin if IsInUnit ( repairs [ i ] ) then
11280: LD_VAR 0 5
11284: PUSH
11285: LD_VAR 0 3
11289: ARRAY
11290: PPUSH
11291: CALL_OW 310
11295: IFFALSE 11314
// ComExitBuilding ( repairs [ i ] ) else
11297: LD_VAR 0 5
11301: PUSH
11302: LD_VAR 0 3
11306: ARRAY
11307: PPUSH
11308: CALL_OW 122
11312: GO 11412
// if not HasTask ( repairs [ i ] ) then
11314: LD_VAR 0 5
11318: PUSH
11319: LD_VAR 0 3
11323: ARRAY
11324: PPUSH
11325: CALL_OW 314
11329: NOT
11330: IFFALSE 11412
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11332: LD_VAR 0 5
11336: PUSH
11337: LD_VAR 0 3
11341: ARRAY
11342: PPUSH
11343: LD_EXP 48
11347: PUSH
11348: LD_VAR 0 1
11352: ARRAY
11353: PUSH
11354: LD_VAR 0 4
11358: ARRAY
11359: PPUSH
11360: CALL_OW 130
// if i mod 3 = 0 then
11364: LD_VAR 0 3
11368: PUSH
11369: LD_INT 3
11371: MOD
11372: PUSH
11373: LD_INT 0
11375: EQUAL
11376: IFFALSE 11392
// p := p + 1 ;
11378: LD_ADDR_VAR 0 4
11382: PUSH
11383: LD_VAR 0 4
11387: PUSH
11388: LD_INT 1
11390: PLUS
11391: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11392: LD_EXP 48
11396: PUSH
11397: LD_VAR 0 1
11401: ARRAY
11402: PUSH
11403: LD_VAR 0 4
11407: LESS
11408: IFFALSE 11412
// break ;
11410: GO 11414
// end ; end ;
11412: GO 11277
11414: POP
11415: POP
// end ; end_of_file
11416: LD_VAR 0 2
11420: RET
// export function MCF_Get ( side , filter ) ; begin
11421: LD_INT 0
11423: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11424: LD_ADDR_VAR 0 3
11428: PUSH
11429: LD_INT 22
11431: PUSH
11432: LD_VAR 0 1
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: PUSH
11441: LD_VAR 0 2
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: ST_TO_ADDR
// end ;
11455: LD_VAR 0 3
11459: RET
// export function MCF_Lab ( side ) ; begin
11460: LD_INT 0
11462: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11463: LD_ADDR_VAR 0 2
11467: PUSH
11468: LD_INT 22
11470: PUSH
11471: LD_VAR 0 1
11475: PUSH
11476: EMPTY
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 30
11482: PUSH
11483: LD_INT 8
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 69
11498: ST_TO_ADDR
// end ;
11499: LD_VAR 0 2
11503: RET
// export function MCF_Class ( side , class , filter ) ; begin
11504: LD_INT 0
11506: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11507: LD_ADDR_VAR 0 4
11511: PUSH
11512: LD_INT 22
11514: PUSH
11515: LD_VAR 0 1
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: LD_INT 25
11526: PUSH
11527: LD_VAR 0 2
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: LD_VAR 0 3
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: LIST
11545: PPUSH
11546: CALL_OW 69
11550: ST_TO_ADDR
// end ;
11551: LD_VAR 0 4
11555: RET
// export function MCF_All ( side , filter ) ; begin
11556: LD_INT 0
11558: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11559: LD_ADDR_VAR 0 3
11563: PUSH
11564: LD_INT 22
11566: PUSH
11567: LD_VAR 0 1
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: LD_INT 2
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PUSH
11589: LD_INT 25
11591: PUSH
11592: LD_INT 2
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: LD_INT 25
11601: PUSH
11602: LD_INT 3
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 25
11611: PUSH
11612: LD_INT 4
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: PUSH
11626: LD_VAR 0 2
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 69
11640: ST_TO_ADDR
// end ;
11641: LD_VAR 0 3
11645: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11646: LD_INT 0
11648: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11649: LD_ADDR_VAR 0 4
11653: PUSH
11654: LD_INT 22
11656: PUSH
11657: LD_VAR 0 1
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: PUSH
11666: LD_INT 92
11668: PUSH
11669: LD_VAR 0 2
11673: PUSH
11674: LD_INT 1
11676: ARRAY
11677: PUSH
11678: LD_VAR 0 2
11682: PUSH
11683: LD_INT 2
11685: ARRAY
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: LD_INT 3
11694: ARRAY
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 21
11744: PUSH
11745: LD_INT 2
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: LD_VAR 0 2
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: LIST
11761: PPUSH
11762: CALL_OW 69
11766: ST_TO_ADDR
// end ;
11767: LD_VAR 0 3
11771: RET
// export function MCF_Cargo ( side ) ; begin
11772: LD_INT 0
11774: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11775: LD_ADDR_VAR 0 2
11779: PUSH
11780: LD_VAR 0 1
11784: PPUSH
11785: LD_INT 2
11787: PUSH
11788: LD_INT 34
11790: PUSH
11791: LD_INT 12
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 34
11800: PUSH
11801: LD_INT 32
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: LD_INT 34
11810: PUSH
11811: LD_INT 51
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: PPUSH
11824: CALL 11722 0 2
11828: ST_TO_ADDR
// end ;
11829: LD_VAR 0 2
11833: RET
// export function MCF_Ape ( side ) ; begin
11834: LD_INT 0
11836: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11837: LD_ADDR_VAR 0 2
11841: PUSH
11842: LD_INT 22
11844: PUSH
11845: LD_VAR 0 1
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: LD_INT 25
11859: PUSH
11860: LD_INT 12
11862: PUSH
11863: EMPTY
11864: LIST
11865: LIST
11866: PUSH
11867: LD_INT 25
11869: PUSH
11870: LD_INT 15
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 25
11879: PUSH
11880: LD_INT 16
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 25
11889: PUSH
11890: LD_INT 17
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: EMPTY
11898: LIST
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PPUSH
11908: CALL_OW 69
11912: ST_TO_ADDR
// end ;
11913: LD_VAR 0 2
11917: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11918: LD_INT 0
11920: PPUSH
11921: PPUSH
11922: PPUSH
11923: PPUSH
// result := [ ] ;
11924: LD_ADDR_VAR 0 3
11928: PUSH
11929: EMPTY
11930: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11931: LD_ADDR_VAR 0 4
11935: PUSH
11936: LD_VAR 0 1
11940: PPUSH
11941: CALL 11834 0 1
11945: ST_TO_ADDR
// case type of 0 , normal :
11946: LD_VAR 0 2
11950: PUSH
11951: LD_INT 0
11953: DOUBLE
11954: EQUAL
11955: IFTRUE 11965
11957: LD_STRING normal
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// cl := class_apeman ; 1 , soldier :
11966: LD_ADDR_VAR 0 5
11970: PUSH
11971: LD_INT 12
11973: ST_TO_ADDR
11974: GO 12052
11976: LD_INT 1
11978: DOUBLE
11979: EQUAL
11980: IFTRUE 11990
11982: LD_STRING soldier
11984: DOUBLE
11985: EQUAL
11986: IFTRUE 11990
11988: GO 12001
11990: POP
// cl := class_apeman_soldier ; 2 , engineer :
11991: LD_ADDR_VAR 0 5
11995: PUSH
11996: LD_INT 15
11998: ST_TO_ADDR
11999: GO 12052
12001: LD_INT 2
12003: DOUBLE
12004: EQUAL
12005: IFTRUE 12015
12007: LD_STRING engineer
12009: DOUBLE
12010: EQUAL
12011: IFTRUE 12015
12013: GO 12026
12015: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12016: LD_ADDR_VAR 0 5
12020: PUSH
12021: LD_INT 16
12023: ST_TO_ADDR
12024: GO 12052
12026: LD_INT 3
12028: DOUBLE
12029: EQUAL
12030: IFTRUE 12040
12032: LD_STRING kamikaze
12034: DOUBLE
12035: EQUAL
12036: IFTRUE 12040
12038: GO 12051
12040: POP
// cl := class_apeman_kamikaze ; end ;
12041: LD_ADDR_VAR 0 5
12045: PUSH
12046: LD_INT 17
12048: ST_TO_ADDR
12049: GO 12052
12051: POP
// for i = 1 to tmp do
12052: LD_ADDR_VAR 0 6
12056: PUSH
12057: DOUBLE
12058: LD_INT 1
12060: DEC
12061: ST_TO_ADDR
12062: LD_VAR 0 4
12066: PUSH
12067: FOR_TO
12068: IFFALSE 12117
// if GetClass ( tmp [ i ] ) = cl then
12070: LD_VAR 0 4
12074: PUSH
12075: LD_VAR 0 6
12079: ARRAY
12080: PPUSH
12081: CALL_OW 257
12085: PUSH
12086: LD_VAR 0 5
12090: EQUAL
12091: IFFALSE 12115
// result := result ^ tmp [ i ] ;
12093: LD_ADDR_VAR 0 3
12097: PUSH
12098: LD_VAR 0 3
12102: PUSH
12103: LD_VAR 0 4
12107: PUSH
12108: LD_VAR 0 6
12112: ARRAY
12113: ADD
12114: ST_TO_ADDR
12115: GO 12067
12117: POP
12118: POP
// end ;
12119: LD_VAR 0 3
12123: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12124: LD_INT 0
12126: PPUSH
12127: PPUSH
12128: PPUSH
12129: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12130: LD_ADDR_VAR 0 5
12134: PUSH
12135: LD_INT 22
12137: PUSH
12138: LD_VAR 0 1
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_VAR 0 3
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: PPUSH
12156: CALL_OW 69
12160: ST_TO_ADDR
// r := [ ] ;
12161: LD_ADDR_VAR 0 6
12165: PUSH
12166: EMPTY
12167: ST_TO_ADDR
// if tmp then
12168: LD_VAR 0 5
12172: IFFALSE 12241
// for i = 1 to tmp do
12174: LD_ADDR_VAR 0 7
12178: PUSH
12179: DOUBLE
12180: LD_INT 1
12182: DEC
12183: ST_TO_ADDR
12184: LD_VAR 0 5
12188: PUSH
12189: FOR_TO
12190: IFFALSE 12239
// if GetTag ( tmp [ i ] ) = tag then
12192: LD_VAR 0 5
12196: PUSH
12197: LD_VAR 0 7
12201: ARRAY
12202: PPUSH
12203: CALL_OW 110
12207: PUSH
12208: LD_VAR 0 2
12212: EQUAL
12213: IFFALSE 12237
// r := r ^ tmp [ i ] ;
12215: LD_ADDR_VAR 0 6
12219: PUSH
12220: LD_VAR 0 6
12224: PUSH
12225: LD_VAR 0 5
12229: PUSH
12230: LD_VAR 0 7
12234: ARRAY
12235: ADD
12236: ST_TO_ADDR
12237: GO 12189
12239: POP
12240: POP
// result := r ;
12241: LD_ADDR_VAR 0 4
12245: PUSH
12246: LD_VAR 0 6
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 4
12255: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
// tmp := plist ;
12261: LD_ADDR_VAR 0 5
12265: PUSH
12266: LD_VAR 0 2
12270: ST_TO_ADDR
// if tmp then
12271: LD_VAR 0 5
12275: IFFALSE 12352
// begin for i = 1 to tmp do
12277: LD_ADDR_VAR 0 6
12281: PUSH
12282: DOUBLE
12283: LD_INT 1
12285: DEC
12286: ST_TO_ADDR
12287: LD_VAR 0 5
12291: PUSH
12292: FOR_TO
12293: IFFALSE 12340
// if GetTag ( tmp [ i ] ) <> tag then
12295: LD_VAR 0 5
12299: PUSH
12300: LD_VAR 0 6
12304: ARRAY
12305: PPUSH
12306: CALL_OW 110
12310: PUSH
12311: LD_VAR 0 3
12315: NONEQUAL
12316: IFFALSE 12338
// SetTag ( tmp [ i ] , tag ) ;
12318: LD_VAR 0 5
12322: PUSH
12323: LD_VAR 0 6
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 3
12333: PPUSH
12334: CALL_OW 109
12338: GO 12292
12340: POP
12341: POP
// result := true ;
12342: LD_ADDR_VAR 0 4
12346: PUSH
12347: LD_INT 1
12349: ST_TO_ADDR
// end else
12350: GO 12360
// result := false ;
12352: LD_ADDR_VAR 0 4
12356: PUSH
12357: LD_INT 0
12359: ST_TO_ADDR
// end ;
12360: LD_VAR 0 4
12364: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12365: LD_INT 0
12367: PPUSH
12368: PPUSH
12369: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12370: LD_ADDR_VAR 0 4
12374: PUSH
12375: LD_VAR 0 1
12379: PPUSH
12380: LD_VAR 0 2
12384: PPUSH
12385: EMPTY
12386: PPUSH
12387: CALL 12124 0 3
12391: ST_TO_ADDR
// if tmp then
12392: LD_VAR 0 4
12396: IFFALSE 12448
// begin for i = 1 to tmp do
12398: LD_ADDR_VAR 0 5
12402: PUSH
12403: DOUBLE
12404: LD_INT 1
12406: DEC
12407: ST_TO_ADDR
12408: LD_VAR 0 4
12412: PUSH
12413: FOR_TO
12414: IFFALSE 12436
// SetTag ( tmp [ i ] , 0 ) ;
12416: LD_VAR 0 4
12420: PUSH
12421: LD_VAR 0 5
12425: ARRAY
12426: PPUSH
12427: LD_INT 0
12429: PPUSH
12430: CALL_OW 109
12434: GO 12413
12436: POP
12437: POP
// result := true ;
12438: LD_ADDR_VAR 0 3
12442: PUSH
12443: LD_INT 1
12445: ST_TO_ADDR
// end else
12446: GO 12456
// result := false ;
12448: LD_ADDR_VAR 0 3
12452: PUSH
12453: LD_INT 0
12455: ST_TO_ADDR
// end ;
12456: LD_VAR 0 3
12460: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12461: LD_INT 0
12463: PPUSH
12464: PPUSH
12465: PPUSH
12466: PPUSH
12467: PPUSH
// sort_list := [ ] ;
12468: LD_ADDR_VAR 0 5
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to list do
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_VAR 0 1
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12653
// begin if i = 1 then
12493: LD_VAR 0 3
12497: PUSH
12498: LD_INT 1
12500: EQUAL
12501: IFFALSE 12527
// sort_list := sort_list ^ list [ i ] else
12503: LD_ADDR_VAR 0 5
12507: PUSH
12508: LD_VAR 0 5
12512: PUSH
12513: LD_VAR 0 1
12517: PUSH
12518: LD_VAR 0 3
12522: ARRAY
12523: ADD
12524: ST_TO_ADDR
12525: GO 12651
// begin for j = 1 to sort_list do
12527: LD_ADDR_VAR 0 4
12531: PUSH
12532: DOUBLE
12533: LD_INT 1
12535: DEC
12536: ST_TO_ADDR
12537: LD_VAR 0 5
12541: PUSH
12542: FOR_TO
12543: IFFALSE 12620
// begin add := false ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_INT 0
12552: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12553: LD_VAR 0 1
12557: PUSH
12558: LD_VAR 0 3
12562: ARRAY
12563: PUSH
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 4
12573: ARRAY
12574: LESS
12575: IFFALSE 12618
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12577: LD_ADDR_VAR 0 5
12581: PUSH
12582: LD_VAR 0 5
12586: PPUSH
12587: LD_VAR 0 4
12591: PPUSH
12592: LD_VAR 0 1
12596: PUSH
12597: LD_VAR 0 3
12601: ARRAY
12602: PPUSH
12603: CALL_OW 2
12607: ST_TO_ADDR
// add := true ;
12608: LD_ADDR_VAR 0 6
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// break ;
12616: GO 12620
// end ; end ;
12618: GO 12542
12620: POP
12621: POP
// if not add then
12622: LD_VAR 0 6
12626: NOT
12627: IFFALSE 12651
// sort_list := sort_list ^ list [ i ] ;
12629: LD_ADDR_VAR 0 5
12633: PUSH
12634: LD_VAR 0 5
12638: PUSH
12639: LD_VAR 0 1
12643: PUSH
12644: LD_VAR 0 3
12648: ARRAY
12649: ADD
12650: ST_TO_ADDR
// end ; end ;
12651: GO 12490
12653: POP
12654: POP
// result := sort_list ;
12655: LD_ADDR_VAR 0 2
12659: PUSH
12660: LD_VAR 0 5
12664: ST_TO_ADDR
// end ;
12665: LD_VAR 0 2
12669: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12670: LD_INT 0
12672: PPUSH
12673: PPUSH
12674: PPUSH
12675: PPUSH
12676: PPUSH
// sort_list := [ ] ;
12677: LD_ADDR_VAR 0 5
12681: PUSH
12682: EMPTY
12683: ST_TO_ADDR
// for i = 1 to list do
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: DOUBLE
12690: LD_INT 1
12692: DEC
12693: ST_TO_ADDR
12694: LD_VAR 0 1
12698: PUSH
12699: FOR_TO
12700: IFFALSE 12862
// begin if i = 1 then
12702: LD_VAR 0 3
12706: PUSH
12707: LD_INT 1
12709: EQUAL
12710: IFFALSE 12736
// sort_list := sort_list ^ list [ i ] else
12712: LD_ADDR_VAR 0 5
12716: PUSH
12717: LD_VAR 0 5
12721: PUSH
12722: LD_VAR 0 1
12726: PUSH
12727: LD_VAR 0 3
12731: ARRAY
12732: ADD
12733: ST_TO_ADDR
12734: GO 12860
// begin for j = 1 to sort_list do
12736: LD_ADDR_VAR 0 4
12740: PUSH
12741: DOUBLE
12742: LD_INT 1
12744: DEC
12745: ST_TO_ADDR
12746: LD_VAR 0 5
12750: PUSH
12751: FOR_TO
12752: IFFALSE 12829
// begin add := false ;
12754: LD_ADDR_VAR 0 6
12758: PUSH
12759: LD_INT 0
12761: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12762: LD_VAR 0 1
12766: PUSH
12767: LD_VAR 0 3
12771: ARRAY
12772: PUSH
12773: LD_VAR 0 5
12777: PUSH
12778: LD_VAR 0 4
12782: ARRAY
12783: GREATER
12784: IFFALSE 12827
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12786: LD_ADDR_VAR 0 5
12790: PUSH
12791: LD_VAR 0 5
12795: PPUSH
12796: LD_VAR 0 4
12800: PPUSH
12801: LD_VAR 0 1
12805: PUSH
12806: LD_VAR 0 3
12810: ARRAY
12811: PPUSH
12812: CALL_OW 2
12816: ST_TO_ADDR
// add := true ;
12817: LD_ADDR_VAR 0 6
12821: PUSH
12822: LD_INT 1
12824: ST_TO_ADDR
// break ;
12825: GO 12829
// end ; end ;
12827: GO 12751
12829: POP
12830: POP
// if not add then
12831: LD_VAR 0 6
12835: NOT
12836: IFFALSE 12860
// sort_list := sort_list ^ list [ i ] ;
12838: LD_ADDR_VAR 0 5
12842: PUSH
12843: LD_VAR 0 5
12847: PUSH
12848: LD_VAR 0 1
12852: PUSH
12853: LD_VAR 0 3
12857: ARRAY
12858: ADD
12859: ST_TO_ADDR
// end ; end ;
12860: GO 12699
12862: POP
12863: POP
// result := sort_list ;
12864: LD_ADDR_VAR 0 2
12868: PUSH
12869: LD_VAR 0 5
12873: ST_TO_ADDR
// end ;
12874: LD_VAR 0 2
12878: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12879: LD_INT 0
12881: PPUSH
12882: PPUSH
12883: PPUSH
12884: PPUSH
12885: PPUSH
12886: PPUSH
// tmp := [ ] ;
12887: LD_ADDR_VAR 0 8
12891: PUSH
12892: EMPTY
12893: ST_TO_ADDR
// r := [ ] ;
12894: LD_ADDR_VAR 0 7
12898: PUSH
12899: EMPTY
12900: ST_TO_ADDR
// add := false ;
12901: LD_ADDR_VAR 0 9
12905: PUSH
12906: LD_INT 0
12908: ST_TO_ADDR
// if plist then
12909: LD_VAR 0 2
12913: IFFALSE 12989
// begin for i = 1 to plist do
12915: LD_ADDR_VAR 0 5
12919: PUSH
12920: DOUBLE
12921: LD_INT 1
12923: DEC
12924: ST_TO_ADDR
12925: LD_VAR 0 2
12929: PUSH
12930: FOR_TO
12931: IFFALSE 12985
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12933: LD_ADDR_VAR 0 8
12937: PUSH
12938: LD_VAR 0 8
12942: PUSH
12943: LD_VAR 0 2
12947: PUSH
12948: LD_VAR 0 5
12952: ARRAY
12953: PUSH
12954: LD_VAR 0 2
12958: PUSH
12959: LD_VAR 0 5
12963: ARRAY
12964: PPUSH
12965: LD_VAR 0 3
12969: PPUSH
12970: CALL_OW 259
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: EMPTY
12980: LIST
12981: ADD
12982: ST_TO_ADDR
// end ;
12983: GO 12930
12985: POP
12986: POP
// end else
12987: GO 12997
// result := false ;
12989: LD_ADDR_VAR 0 4
12993: PUSH
12994: LD_INT 0
12996: ST_TO_ADDR
// if tmp then
12997: LD_VAR 0 8
13001: IFFALSE 13175
// begin r := r ^ [ tmp [ 1 ] ] ;
13003: LD_ADDR_VAR 0 7
13007: PUSH
13008: LD_VAR 0 7
13012: PUSH
13013: LD_VAR 0 8
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PUSH
13022: EMPTY
13023: LIST
13024: ADD
13025: ST_TO_ADDR
// for i = 2 to tmp do
13026: LD_ADDR_VAR 0 5
13030: PUSH
13031: DOUBLE
13032: LD_INT 2
13034: DEC
13035: ST_TO_ADDR
13036: LD_VAR 0 8
13040: PUSH
13041: FOR_TO
13042: IFFALSE 13173
// begin for j = 1 to r do
13044: LD_ADDR_VAR 0 6
13048: PUSH
13049: DOUBLE
13050: LD_INT 1
13052: DEC
13053: ST_TO_ADDR
13054: LD_VAR 0 7
13058: PUSH
13059: FOR_TO
13060: IFFALSE 13137
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13062: LD_VAR 0 8
13066: PUSH
13067: LD_VAR 0 5
13071: ARRAY
13072: PUSH
13073: LD_INT 2
13075: ARRAY
13076: PUSH
13077: LD_VAR 0 7
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PUSH
13088: LD_INT 2
13090: ARRAY
13091: LESS
13092: IFFALSE 13135
// begin r := Insert ( r , j , tmp [ i ] ) ;
13094: LD_ADDR_VAR 0 7
13098: PUSH
13099: LD_VAR 0 7
13103: PPUSH
13104: LD_VAR 0 6
13108: PPUSH
13109: LD_VAR 0 8
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PPUSH
13120: CALL_OW 2
13124: ST_TO_ADDR
// add := true ;
13125: LD_ADDR_VAR 0 9
13129: PUSH
13130: LD_INT 1
13132: ST_TO_ADDR
// break ;
13133: GO 13137
// end ; end ;
13135: GO 13059
13137: POP
13138: POP
// if not add then
13139: LD_VAR 0 9
13143: NOT
13144: IFFALSE 13171
// r := r ^ [ tmp [ i ] ] ;
13146: LD_ADDR_VAR 0 7
13150: PUSH
13151: LD_VAR 0 7
13155: PUSH
13156: LD_VAR 0 8
13160: PUSH
13161: LD_VAR 0 5
13165: ARRAY
13166: PUSH
13167: EMPTY
13168: LIST
13169: ADD
13170: ST_TO_ADDR
// end ;
13171: GO 13041
13173: POP
13174: POP
// end ; result := r ;
13175: LD_ADDR_VAR 0 4
13179: PUSH
13180: LD_VAR 0 7
13184: ST_TO_ADDR
// end ;
13185: LD_VAR 0 4
13189: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13190: LD_INT 0
13192: PPUSH
13193: PPUSH
13194: PPUSH
13195: PPUSH
13196: PPUSH
13197: PPUSH
// tmp := [ ] ;
13198: LD_ADDR_VAR 0 8
13202: PUSH
13203: EMPTY
13204: ST_TO_ADDR
// r := [ ] ;
13205: LD_ADDR_VAR 0 7
13209: PUSH
13210: EMPTY
13211: ST_TO_ADDR
// add := false ;
13212: LD_ADDR_VAR 0 9
13216: PUSH
13217: LD_INT 0
13219: ST_TO_ADDR
// if plist then
13220: LD_VAR 0 2
13224: IFFALSE 13300
// begin for i = 1 to plist do
13226: LD_ADDR_VAR 0 5
13230: PUSH
13231: DOUBLE
13232: LD_INT 1
13234: DEC
13235: ST_TO_ADDR
13236: LD_VAR 0 2
13240: PUSH
13241: FOR_TO
13242: IFFALSE 13296
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13244: LD_ADDR_VAR 0 8
13248: PUSH
13249: LD_VAR 0 8
13253: PUSH
13254: LD_VAR 0 2
13258: PUSH
13259: LD_VAR 0 5
13263: ARRAY
13264: PUSH
13265: LD_VAR 0 2
13269: PUSH
13270: LD_VAR 0 5
13274: ARRAY
13275: PPUSH
13276: LD_VAR 0 3
13280: PPUSH
13281: CALL_OW 259
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PUSH
13290: EMPTY
13291: LIST
13292: ADD
13293: ST_TO_ADDR
// end ;
13294: GO 13241
13296: POP
13297: POP
// end else
13298: GO 13308
// result := false ;
13300: LD_ADDR_VAR 0 4
13304: PUSH
13305: LD_INT 0
13307: ST_TO_ADDR
// if tmp then
13308: LD_VAR 0 8
13312: IFFALSE 13486
// begin r := r ^ [ tmp [ 1 ] ] ;
13314: LD_ADDR_VAR 0 7
13318: PUSH
13319: LD_VAR 0 7
13323: PUSH
13324: LD_VAR 0 8
13328: PUSH
13329: LD_INT 1
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// for i = 2 to tmp do
13337: LD_ADDR_VAR 0 5
13341: PUSH
13342: DOUBLE
13343: LD_INT 2
13345: DEC
13346: ST_TO_ADDR
13347: LD_VAR 0 8
13351: PUSH
13352: FOR_TO
13353: IFFALSE 13484
// begin for j = 1 to r do
13355: LD_ADDR_VAR 0 6
13359: PUSH
13360: DOUBLE
13361: LD_INT 1
13363: DEC
13364: ST_TO_ADDR
13365: LD_VAR 0 7
13369: PUSH
13370: FOR_TO
13371: IFFALSE 13448
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13373: LD_VAR 0 8
13377: PUSH
13378: LD_VAR 0 5
13382: ARRAY
13383: PUSH
13384: LD_INT 2
13386: ARRAY
13387: PUSH
13388: LD_VAR 0 7
13392: PUSH
13393: LD_VAR 0 6
13397: ARRAY
13398: PUSH
13399: LD_INT 2
13401: ARRAY
13402: GREATER
13403: IFFALSE 13446
// begin r := Insert ( r , j , tmp [ i ] ) ;
13405: LD_ADDR_VAR 0 7
13409: PUSH
13410: LD_VAR 0 7
13414: PPUSH
13415: LD_VAR 0 6
13419: PPUSH
13420: LD_VAR 0 8
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PPUSH
13431: CALL_OW 2
13435: ST_TO_ADDR
// add := true ;
13436: LD_ADDR_VAR 0 9
13440: PUSH
13441: LD_INT 1
13443: ST_TO_ADDR
// break ;
13444: GO 13448
// end ; end ;
13446: GO 13370
13448: POP
13449: POP
// if not add then
13450: LD_VAR 0 9
13454: NOT
13455: IFFALSE 13482
// r := r ^ [ tmp [ i ] ] ;
13457: LD_ADDR_VAR 0 7
13461: PUSH
13462: LD_VAR 0 7
13466: PUSH
13467: LD_VAR 0 8
13471: PUSH
13472: LD_VAR 0 5
13476: ARRAY
13477: PUSH
13478: EMPTY
13479: LIST
13480: ADD
13481: ST_TO_ADDR
// end ;
13482: GO 13352
13484: POP
13485: POP
// end ; result := r ;
13486: LD_ADDR_VAR 0 4
13490: PUSH
13491: LD_VAR 0 7
13495: ST_TO_ADDR
// end ;
13496: LD_VAR 0 4
13500: RET
// export function MCF_Clear ( side ) ; var i ; begin
13501: LD_INT 0
13503: PPUSH
13504: PPUSH
// for i = 1 to 100 do
13505: LD_ADDR_VAR 0 3
13509: PUSH
13510: DOUBLE
13511: LD_INT 1
13513: DEC
13514: ST_TO_ADDR
13515: LD_INT 100
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13555
// if MCF_Tag ( side , i , [ ] ) then
13521: LD_VAR 0 1
13525: PPUSH
13526: LD_VAR 0 3
13530: PPUSH
13531: EMPTY
13532: PPUSH
13533: CALL 12124 0 3
13537: IFFALSE 13553
// MCF_ClearTag ( side , i ) ;
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_VAR 0 3
13548: PPUSH
13549: CALL 12365 0 2
13553: GO 13518
13555: POP
13556: POP
// result := true ;
13557: LD_ADDR_VAR 0 2
13561: PUSH
13562: LD_INT 1
13564: ST_TO_ADDR
// end ;
13565: LD_VAR 0 2
13569: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13570: LD_INT 0
13572: PPUSH
13573: PPUSH
13574: PPUSH
// for i = 1 to plist do
13575: LD_ADDR_VAR 0 4
13579: PUSH
13580: DOUBLE
13581: LD_INT 1
13583: DEC
13584: ST_TO_ADDR
13585: LD_VAR 0 1
13589: PUSH
13590: FOR_TO
13591: IFFALSE 13640
// if MCF_HasClass ( plist [ i ] ) = n then
13593: LD_VAR 0 1
13597: PUSH
13598: LD_VAR 0 4
13602: ARRAY
13603: PPUSH
13604: CALL 14127 0 1
13608: PUSH
13609: LD_VAR 0 2
13613: EQUAL
13614: IFFALSE 13638
// tmp := tmp ^ plist [ i ] ;
13616: LD_ADDR_VAR 0 5
13620: PUSH
13621: LD_VAR 0 5
13625: PUSH
13626: LD_VAR 0 1
13630: PUSH
13631: LD_VAR 0 4
13635: ARRAY
13636: ADD
13637: ST_TO_ADDR
13638: GO 13590
13640: POP
13641: POP
// result := tmp ;
13642: LD_ADDR_VAR 0 3
13646: PUSH
13647: LD_VAR 0 5
13651: ST_TO_ADDR
// end ;
13652: LD_VAR 0 3
13656: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13657: LD_INT 0
13659: PPUSH
13660: PPUSH
13661: PPUSH
// if mreg = ToArm then
13662: LD_VAR 0 2
13666: PUSH
13667: LD_STRING ToArm
13669: EQUAL
13670: IFFALSE 13775
// begin tmp := MREG_ToArm [ side ] ;
13672: LD_ADDR_VAR 0 6
13676: PUSH
13677: LD_EXP 57
13681: PUSH
13682: LD_VAR 0 1
13686: ARRAY
13687: ST_TO_ADDR
// if tmp = 0 then
13688: LD_VAR 0 6
13692: PUSH
13693: LD_INT 0
13695: EQUAL
13696: IFFALSE 13702
// exit else
13698: GO 14122
13700: GO 13775
// begin for i = MREG_ToArm [ side ] downto n do
13702: LD_ADDR_VAR 0 5
13706: PUSH
13707: DOUBLE
13708: LD_EXP 57
13712: PUSH
13713: LD_VAR 0 1
13717: ARRAY
13718: INC
13719: ST_TO_ADDR
13720: LD_VAR 0 3
13724: PUSH
13725: FOR_DOWNTO
13726: IFFALSE 13748
// tmp := Delete ( tmp , 1 ) ;
13728: LD_ADDR_VAR 0 6
13732: PUSH
13733: LD_VAR 0 6
13737: PPUSH
13738: LD_INT 1
13740: PPUSH
13741: CALL_OW 3
13745: ST_TO_ADDR
13746: GO 13725
13748: POP
13749: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13750: LD_ADDR_EXP 57
13754: PUSH
13755: LD_EXP 57
13759: PPUSH
13760: LD_VAR 0 1
13764: PPUSH
13765: LD_VAR 0 6
13769: PPUSH
13770: CALL_OW 1
13774: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13775: LD_VAR 0 2
13779: PUSH
13780: LD_STRING ToDep
13782: EQUAL
13783: IFFALSE 13888
// begin tmp := MREG_ToDep [ side ] ;
13785: LD_ADDR_VAR 0 6
13789: PUSH
13790: LD_EXP 58
13794: PUSH
13795: LD_VAR 0 1
13799: ARRAY
13800: ST_TO_ADDR
// if tmp = 0 then
13801: LD_VAR 0 6
13805: PUSH
13806: LD_INT 0
13808: EQUAL
13809: IFFALSE 13815
// exit else
13811: GO 14122
13813: GO 13888
// begin for i = MREG_ToDep [ side ] downto n do
13815: LD_ADDR_VAR 0 5
13819: PUSH
13820: DOUBLE
13821: LD_EXP 58
13825: PUSH
13826: LD_VAR 0 1
13830: ARRAY
13831: INC
13832: ST_TO_ADDR
13833: LD_VAR 0 3
13837: PUSH
13838: FOR_DOWNTO
13839: IFFALSE 13861
// tmp := Delete ( tmp , 1 ) ;
13841: LD_ADDR_VAR 0 6
13845: PUSH
13846: LD_VAR 0 6
13850: PPUSH
13851: LD_INT 1
13853: PPUSH
13854: CALL_OW 3
13858: ST_TO_ADDR
13859: GO 13838
13861: POP
13862: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13863: LD_ADDR_EXP 58
13867: PUSH
13868: LD_EXP 58
13872: PPUSH
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_VAR 0 6
13882: PPUSH
13883: CALL_OW 1
13887: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13888: LD_VAR 0 2
13892: PUSH
13893: LD_STRING ToFac
13895: EQUAL
13896: IFFALSE 14001
// begin tmp := MREG_ToFac [ side ] ;
13898: LD_ADDR_VAR 0 6
13902: PUSH
13903: LD_EXP 56
13907: PUSH
13908: LD_VAR 0 1
13912: ARRAY
13913: ST_TO_ADDR
// if tmp = 0 then
13914: LD_VAR 0 6
13918: PUSH
13919: LD_INT 0
13921: EQUAL
13922: IFFALSE 13928
// exit else
13924: GO 14122
13926: GO 14001
// begin for i = MREG_ToFac [ side ] downto n do
13928: LD_ADDR_VAR 0 5
13932: PUSH
13933: DOUBLE
13934: LD_EXP 56
13938: PUSH
13939: LD_VAR 0 1
13943: ARRAY
13944: INC
13945: ST_TO_ADDR
13946: LD_VAR 0 3
13950: PUSH
13951: FOR_DOWNTO
13952: IFFALSE 13974
// tmp := Delete ( tmp , 1 ) ;
13954: LD_ADDR_VAR 0 6
13958: PUSH
13959: LD_VAR 0 6
13963: PPUSH
13964: LD_INT 1
13966: PPUSH
13967: CALL_OW 3
13971: ST_TO_ADDR
13972: GO 13951
13974: POP
13975: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13976: LD_ADDR_EXP 56
13980: PUSH
13981: LD_EXP 56
13985: PPUSH
13986: LD_VAR 0 1
13990: PPUSH
13991: LD_VAR 0 6
13995: PPUSH
13996: CALL_OW 1
14000: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14001: LD_VAR 0 2
14005: PUSH
14006: LD_STRING ToLab
14008: EQUAL
14009: IFFALSE 14114
// begin tmp := MREG_ToLab [ side ] ;
14011: LD_ADDR_VAR 0 6
14015: PUSH
14016: LD_EXP 55
14020: PUSH
14021: LD_VAR 0 1
14025: ARRAY
14026: ST_TO_ADDR
// if tmp = 0 then
14027: LD_VAR 0 6
14031: PUSH
14032: LD_INT 0
14034: EQUAL
14035: IFFALSE 14041
// exit else
14037: GO 14122
14039: GO 14114
// begin for i = MREG_ToLab [ side ] downto n do
14041: LD_ADDR_VAR 0 5
14045: PUSH
14046: DOUBLE
14047: LD_EXP 55
14051: PUSH
14052: LD_VAR 0 1
14056: ARRAY
14057: INC
14058: ST_TO_ADDR
14059: LD_VAR 0 3
14063: PUSH
14064: FOR_DOWNTO
14065: IFFALSE 14087
// tmp := Delete ( tmp , 1 ) ;
14067: LD_ADDR_VAR 0 6
14071: PUSH
14072: LD_VAR 0 6
14076: PPUSH
14077: LD_INT 1
14079: PPUSH
14080: CALL_OW 3
14084: ST_TO_ADDR
14085: GO 14064
14087: POP
14088: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14089: LD_ADDR_EXP 55
14093: PUSH
14094: LD_EXP 55
14098: PPUSH
14099: LD_VAR 0 1
14103: PPUSH
14104: LD_VAR 0 6
14108: PPUSH
14109: CALL_OW 1
14113: ST_TO_ADDR
// end ; end ; result := true ;
14114: LD_ADDR_VAR 0 4
14118: PUSH
14119: LD_INT 1
14121: ST_TO_ADDR
// end ;
14122: LD_VAR 0 4
14126: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14127: LD_INT 0
14129: PPUSH
14130: PPUSH
14131: PPUSH
// side := GetSide ( unit ) ;
14132: LD_ADDR_VAR 0 4
14136: PUSH
14137: LD_VAR 0 1
14141: PPUSH
14142: CALL_OW 255
14146: ST_TO_ADDR
// tmp := 0 ;
14147: LD_ADDR_VAR 0 3
14151: PUSH
14152: LD_INT 0
14154: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14155: LD_VAR 0 1
14159: PUSH
14160: LD_EXP 57
14164: PUSH
14165: LD_VAR 0 4
14169: ARRAY
14170: IN
14171: IFFALSE 14181
// tmp := 1 ;
14173: LD_ADDR_VAR 0 3
14177: PUSH
14178: LD_INT 1
14180: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14181: LD_VAR 0 1
14185: PUSH
14186: LD_EXP 58
14190: PUSH
14191: LD_VAR 0 4
14195: ARRAY
14196: IN
14197: IFFALSE 14207
// tmp := 2 ;
14199: LD_ADDR_VAR 0 3
14203: PUSH
14204: LD_INT 2
14206: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14207: LD_VAR 0 1
14211: PUSH
14212: LD_EXP 56
14216: PUSH
14217: LD_VAR 0 4
14221: ARRAY
14222: IN
14223: IFFALSE 14233
// tmp := 3 ;
14225: LD_ADDR_VAR 0 3
14229: PUSH
14230: LD_INT 3
14232: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14233: LD_VAR 0 1
14237: PUSH
14238: LD_EXP 55
14242: PUSH
14243: LD_VAR 0 4
14247: ARRAY
14248: IN
14249: IFFALSE 14259
// tmp := 4 ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 4
14258: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14259: LD_VAR 0 1
14263: PUSH
14264: LD_EXP 69
14268: PUSH
14269: LD_VAR 0 4
14273: ARRAY
14274: IN
14275: IFFALSE 14285
// tmp := 5 ;
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_INT 5
14284: ST_TO_ADDR
// result := tmp ;
14285: LD_ADDR_VAR 0 2
14289: PUSH
14290: LD_VAR 0 3
14294: ST_TO_ADDR
// end ;
14295: LD_VAR 0 2
14299: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14300: LD_INT 0
14302: PPUSH
14303: PPUSH
// if mreg = ToArm then
14304: LD_VAR 0 2
14308: PUSH
14309: LD_STRING ToArm
14311: EQUAL
14312: IFFALSE 14401
// for i = MREG_ToArm [ side ] downto 1 do
14314: LD_ADDR_VAR 0 5
14318: PUSH
14319: DOUBLE
14320: LD_EXP 57
14324: PUSH
14325: LD_VAR 0 1
14329: ARRAY
14330: INC
14331: ST_TO_ADDR
14332: LD_INT 1
14334: PUSH
14335: FOR_DOWNTO
14336: IFFALSE 14399
// if MREG_ToArm [ side ] [ i ] = unit then
14338: LD_EXP 57
14342: PUSH
14343: LD_VAR 0 1
14347: ARRAY
14348: PUSH
14349: LD_VAR 0 5
14353: ARRAY
14354: PUSH
14355: LD_VAR 0 3
14359: EQUAL
14360: IFFALSE 14397
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14362: LD_ADDR_EXP 57
14366: PUSH
14367: LD_EXP 57
14371: PPUSH
14372: LD_EXP 57
14376: PUSH
14377: LD_VAR 0 1
14381: ARRAY
14382: PUSH
14383: LD_VAR 0 5
14387: ARRAY
14388: PPUSH
14389: LD_INT 1
14391: PPUSH
14392: CALL 31118 0 3
14396: ST_TO_ADDR
// end ;
14397: GO 14335
14399: POP
14400: POP
// if mreg = ToDep then
14401: LD_VAR 0 2
14405: PUSH
14406: LD_STRING ToDep
14408: EQUAL
14409: IFFALSE 14498
// for i = MREG_ToDep [ side ] downto 1 do
14411: LD_ADDR_VAR 0 5
14415: PUSH
14416: DOUBLE
14417: LD_EXP 58
14421: PUSH
14422: LD_VAR 0 1
14426: ARRAY
14427: INC
14428: ST_TO_ADDR
14429: LD_INT 1
14431: PUSH
14432: FOR_DOWNTO
14433: IFFALSE 14496
// if MREG_ToDep [ side ] [ i ] = unit then
14435: LD_EXP 58
14439: PUSH
14440: LD_VAR 0 1
14444: ARRAY
14445: PUSH
14446: LD_VAR 0 5
14450: ARRAY
14451: PUSH
14452: LD_VAR 0 3
14456: EQUAL
14457: IFFALSE 14494
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14459: LD_ADDR_EXP 58
14463: PUSH
14464: LD_EXP 58
14468: PPUSH
14469: LD_EXP 58
14473: PUSH
14474: LD_VAR 0 1
14478: ARRAY
14479: PUSH
14480: LD_VAR 0 5
14484: ARRAY
14485: PPUSH
14486: LD_INT 1
14488: PPUSH
14489: CALL 31118 0 3
14493: ST_TO_ADDR
// end ;
14494: GO 14432
14496: POP
14497: POP
// if mreg = ToFac then
14498: LD_VAR 0 2
14502: PUSH
14503: LD_STRING ToFac
14505: EQUAL
14506: IFFALSE 14595
// for i = MREG_ToFac [ side ] downto 1 do
14508: LD_ADDR_VAR 0 5
14512: PUSH
14513: DOUBLE
14514: LD_EXP 56
14518: PUSH
14519: LD_VAR 0 1
14523: ARRAY
14524: INC
14525: ST_TO_ADDR
14526: LD_INT 1
14528: PUSH
14529: FOR_DOWNTO
14530: IFFALSE 14593
// if MREG_ToFac [ side ] [ i ] = unit then
14532: LD_EXP 56
14536: PUSH
14537: LD_VAR 0 1
14541: ARRAY
14542: PUSH
14543: LD_VAR 0 5
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 3
14553: EQUAL
14554: IFFALSE 14591
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14556: LD_ADDR_EXP 56
14560: PUSH
14561: LD_EXP 56
14565: PPUSH
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: PUSH
14577: LD_VAR 0 5
14581: ARRAY
14582: PPUSH
14583: LD_INT 1
14585: PPUSH
14586: CALL 31118 0 3
14590: ST_TO_ADDR
// end ;
14591: GO 14529
14593: POP
14594: POP
// if mreg = ToLab then
14595: LD_VAR 0 2
14599: PUSH
14600: LD_STRING ToLab
14602: EQUAL
14603: IFFALSE 14692
// for i = MREG_ToLab [ side ] downto 1 do
14605: LD_ADDR_VAR 0 5
14609: PUSH
14610: DOUBLE
14611: LD_EXP 55
14615: PUSH
14616: LD_VAR 0 1
14620: ARRAY
14621: INC
14622: ST_TO_ADDR
14623: LD_INT 1
14625: PUSH
14626: FOR_DOWNTO
14627: IFFALSE 14690
// if MREG_ToLab [ side ] [ i ] = unit then
14629: LD_EXP 55
14633: PUSH
14634: LD_VAR 0 1
14638: ARRAY
14639: PUSH
14640: LD_VAR 0 5
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 3
14650: EQUAL
14651: IFFALSE 14688
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14653: LD_ADDR_EXP 55
14657: PUSH
14658: LD_EXP 55
14662: PPUSH
14663: LD_EXP 55
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: PUSH
14674: LD_VAR 0 5
14678: ARRAY
14679: PPUSH
14680: LD_INT 1
14682: PPUSH
14683: CALL 31118 0 3
14687: ST_TO_ADDR
// end ;
14688: GO 14626
14690: POP
14691: POP
// end ;
14692: LD_VAR 0 4
14696: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14697: LD_INT 0
14699: PPUSH
14700: PPUSH
// result := false ;
14701: LD_ADDR_VAR 0 2
14705: PUSH
14706: LD_INT 0
14708: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14709: LD_ADDR_VAR 0 3
14713: PUSH
14714: DOUBLE
14715: LD_INT 1
14717: DEC
14718: ST_TO_ADDR
14719: LD_EXP 47
14723: PUSH
14724: FOR_TO
14725: IFFALSE 14789
// if MREG_ToBuild [ i ] [ 1 ] = side then
14727: LD_EXP 47
14731: PUSH
14732: LD_VAR 0 3
14736: ARRAY
14737: PUSH
14738: LD_INT 1
14740: ARRAY
14741: PUSH
14742: LD_VAR 0 1
14746: EQUAL
14747: IFFALSE 14787
// begin if MREG_ToBuild [ i ] [ 1 ] then
14749: LD_EXP 47
14753: PUSH
14754: LD_VAR 0 3
14758: ARRAY
14759: PUSH
14760: LD_INT 1
14762: ARRAY
14763: IFFALSE 14787
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14765: LD_ADDR_VAR 0 2
14769: PUSH
14770: LD_EXP 47
14774: PUSH
14775: LD_VAR 0 3
14779: ARRAY
14780: PUSH
14781: LD_INT 1
14783: ARRAY
14784: ST_TO_ADDR
// break ;
14785: GO 14789
// end ; end ;
14787: GO 14724
14789: POP
14790: POP
// for i = 1 to MREG_ToRepair do
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: DOUBLE
14797: LD_INT 1
14799: DEC
14800: ST_TO_ADDR
14801: LD_EXP 48
14805: PUSH
14806: FOR_TO
14807: IFFALSE 14871
// if MREG_ToRepair [ i ] [ 1 ] = side then
14809: LD_EXP 48
14813: PUSH
14814: LD_VAR 0 3
14818: ARRAY
14819: PUSH
14820: LD_INT 1
14822: ARRAY
14823: PUSH
14824: LD_VAR 0 1
14828: EQUAL
14829: IFFALSE 14869
// begin if MREG_ToRepair [ i ] [ 1 ] then
14831: LD_EXP 48
14835: PUSH
14836: LD_VAR 0 3
14840: ARRAY
14841: PUSH
14842: LD_INT 1
14844: ARRAY
14845: IFFALSE 14869
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14847: LD_ADDR_VAR 0 2
14851: PUSH
14852: LD_EXP 48
14856: PUSH
14857: LD_VAR 0 3
14861: ARRAY
14862: PUSH
14863: LD_INT 1
14865: ARRAY
14866: ST_TO_ADDR
// break ;
14867: GO 14871
// end ; end ;
14869: GO 14806
14871: POP
14872: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14873: LD_VAR 0 1
14877: PPUSH
14878: LD_INT 57
14880: PUSH
14881: EMPTY
14882: LIST
14883: PPUSH
14884: CALL 11421 0 2
14888: IFFALSE 14915
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14890: LD_ADDR_VAR 0 2
14894: PUSH
14895: LD_VAR 0 1
14899: PPUSH
14900: LD_INT 57
14902: PUSH
14903: EMPTY
14904: LIST
14905: PPUSH
14906: CALL 11421 0 2
14910: PUSH
14911: LD_INT 1
14913: ARRAY
14914: ST_TO_ADDR
// end ;
14915: LD_VAR 0 2
14919: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14920: LD_INT 0
14922: PPUSH
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14927: LD_ADDR_VAR 0 6
14931: PUSH
14932: LD_VAR 0 1
14936: PPUSH
14937: LD_INT 21
14939: PUSH
14940: LD_INT 3
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL 11421 0 2
14951: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14952: LD_ADDR_VAR 0 7
14956: PUSH
14957: LD_VAR 0 1
14961: PPUSH
14962: LD_INT 81
14964: PUSH
14965: LD_VAR 0 1
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL 11421 0 2
14978: ST_TO_ADDR
// if not enemy then
14979: LD_VAR 0 7
14983: NOT
14984: IFFALSE 14996
// result := false else
14986: LD_ADDR_VAR 0 3
14990: PUSH
14991: LD_INT 0
14993: ST_TO_ADDR
14994: GO 15050
// begin scan := NearestUnit ( b , enemy ) ;
14996: LD_ADDR_VAR 0 5
15000: PUSH
15001: LD_VAR 0 6
15005: PPUSH
15006: LD_VAR 0 7
15010: PPUSH
15011: CALL 32443 0 2
15015: ST_TO_ADDR
// if scan [ 2 ] < dist then
15016: LD_VAR 0 5
15020: PUSH
15021: LD_INT 2
15023: ARRAY
15024: PUSH
15025: LD_VAR 0 2
15029: LESS
15030: IFFALSE 15042
// result := true else
15032: LD_ADDR_VAR 0 3
15036: PUSH
15037: LD_INT 1
15039: ST_TO_ADDR
15040: GO 15050
// result := false ;
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_INT 0
15049: ST_TO_ADDR
// end ; end ;
15050: LD_VAR 0 3
15054: RET
// export function MCF_Info ( ) ; begin
15055: LD_INT 0
15057: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15058: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15060: PUSH
15061: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15063: ADD
15064: PUSH
15065: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15067: ADD
15068: PUSH
15069: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15071: ADD
15072: PUSH
15073: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15075: ADD
15076: PUSH
15077: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15079: ADD
15080: PUSH
15081: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15083: ADD
15084: PUSH
15085: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15087: ADD
15088: PUSH
15089: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15091: ADD
15092: PUSH
15093: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15095: ADD
15096: PPUSH
15097: CALL 8339 0 1
// end ; end_of_file
15101: LD_VAR 0 1
15105: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15106: LD_INT 0
15108: PPUSH
15109: PPUSH
15110: PPUSH
15111: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15112: LD_ADDR_VAR 0 5
15116: PUSH
15117: LD_VAR 0 1
15121: PPUSH
15122: LD_INT 2
15124: PUSH
15125: LD_INT 25
15127: PUSH
15128: LD_INT 2
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 25
15137: PUSH
15138: LD_INT 3
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 25
15147: PUSH
15148: LD_INT 4
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: PPUSH
15161: CALL 11421 0 2
15165: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15166: LD_ADDR_VAR 0 5
15170: PUSH
15171: LD_VAR 0 5
15175: PPUSH
15176: LD_INT 0
15178: PPUSH
15179: CALL 13570 0 2
15183: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15184: LD_ADDR_VAR 0 6
15188: PUSH
15189: LD_VAR 0 1
15193: PPUSH
15194: LD_VAR 0 5
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL 13190 0 3
15206: ST_TO_ADDR
// if n > sk then
15207: LD_VAR 0 2
15211: PUSH
15212: LD_VAR 0 6
15216: GREATER
15217: IFFALSE 15229
// n := sk ;
15219: LD_ADDR_VAR 0 2
15223: PUSH
15224: LD_VAR 0 6
15228: ST_TO_ADDR
// for i = 1 to n do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 1
15237: DEC
15238: ST_TO_ADDR
15239: LD_VAR 0 2
15243: PUSH
15244: FOR_TO
15245: IFFALSE 15357
// if ( sk [ i ] [ 1 ] ) <> 0 then
15247: LD_VAR 0 6
15251: PUSH
15252: LD_VAR 0 4
15256: ARRAY
15257: PUSH
15258: LD_INT 1
15260: ARRAY
15261: PUSH
15262: LD_INT 0
15264: NONEQUAL
15265: IFFALSE 15355
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15267: LD_ADDR_EXP 54
15271: PUSH
15272: LD_EXP 54
15276: PPUSH
15277: LD_VAR 0 1
15281: PPUSH
15282: LD_VAR 0 6
15286: PUSH
15287: LD_VAR 0 4
15291: ARRAY
15292: PUSH
15293: LD_INT 1
15295: ARRAY
15296: PPUSH
15297: LD_INT 1
15299: PPUSH
15300: CALL 42241 0 4
15304: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15305: LD_ADDR_EXP 57
15309: PUSH
15310: LD_EXP 57
15314: PPUSH
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_EXP 57
15324: PUSH
15325: LD_VAR 0 1
15329: ARRAY
15330: PUSH
15331: LD_INT 1
15333: PLUS
15334: PPUSH
15335: LD_VAR 0 6
15339: PUSH
15340: LD_VAR 0 4
15344: ARRAY
15345: PUSH
15346: LD_INT 1
15348: ARRAY
15349: PPUSH
15350: CALL 30959 0 4
15354: ST_TO_ADDR
// end ;
15355: GO 15244
15357: POP
15358: POP
// end ;
15359: LD_VAR 0 3
15363: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15364: LD_INT 0
15366: PPUSH
15367: PPUSH
15368: PPUSH
15369: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15370: LD_ADDR_VAR 0 5
15374: PUSH
15375: LD_VAR 0 1
15379: PPUSH
15380: LD_INT 2
15382: PUSH
15383: LD_INT 25
15385: PUSH
15386: LD_INT 1
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 25
15395: PUSH
15396: LD_INT 3
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: PUSH
15403: LD_INT 25
15405: PUSH
15406: LD_INT 4
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PPUSH
15419: CALL 11421 0 2
15423: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15424: LD_ADDR_VAR 0 5
15428: PUSH
15429: LD_VAR 0 5
15433: PPUSH
15434: LD_INT 0
15436: PPUSH
15437: CALL 13570 0 2
15441: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15442: LD_ADDR_VAR 0 6
15446: PUSH
15447: LD_VAR 0 1
15451: PPUSH
15452: LD_VAR 0 5
15456: PPUSH
15457: LD_INT 2
15459: PPUSH
15460: CALL 13190 0 3
15464: ST_TO_ADDR
// if n > sk then
15465: LD_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: GREATER
15475: IFFALSE 15487
// n := sk ;
15477: LD_ADDR_VAR 0 2
15481: PUSH
15482: LD_VAR 0 6
15486: ST_TO_ADDR
// for i = 1 to n do
15487: LD_ADDR_VAR 0 4
15491: PUSH
15492: DOUBLE
15493: LD_INT 1
15495: DEC
15496: ST_TO_ADDR
15497: LD_VAR 0 2
15501: PUSH
15502: FOR_TO
15503: IFFALSE 15615
// if ( sk [ i ] [ 1 ] ) <> 0 then
15505: LD_VAR 0 6
15509: PUSH
15510: LD_VAR 0 4
15514: ARRAY
15515: PUSH
15516: LD_INT 1
15518: ARRAY
15519: PUSH
15520: LD_INT 0
15522: NONEQUAL
15523: IFFALSE 15613
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15525: LD_ADDR_EXP 54
15529: PUSH
15530: LD_EXP 54
15534: PPUSH
15535: LD_VAR 0 1
15539: PPUSH
15540: LD_VAR 0 6
15544: PUSH
15545: LD_VAR 0 4
15549: ARRAY
15550: PUSH
15551: LD_INT 1
15553: ARRAY
15554: PPUSH
15555: LD_INT 2
15557: PPUSH
15558: CALL 42241 0 4
15562: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15563: LD_ADDR_EXP 58
15567: PUSH
15568: LD_EXP 58
15572: PPUSH
15573: LD_VAR 0 1
15577: PPUSH
15578: LD_EXP 58
15582: PUSH
15583: LD_VAR 0 1
15587: ARRAY
15588: PUSH
15589: LD_INT 1
15591: PLUS
15592: PPUSH
15593: LD_VAR 0 6
15597: PUSH
15598: LD_VAR 0 4
15602: ARRAY
15603: PUSH
15604: LD_INT 1
15606: ARRAY
15607: PPUSH
15608: CALL 30959 0 4
15612: ST_TO_ADDR
// end ;
15613: GO 15502
15615: POP
15616: POP
// end ;
15617: LD_VAR 0 3
15621: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15622: LD_INT 0
15624: PPUSH
15625: PPUSH
15626: PPUSH
15627: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15628: LD_ADDR_VAR 0 5
15632: PUSH
15633: LD_VAR 0 1
15637: PPUSH
15638: LD_INT 2
15640: PUSH
15641: LD_INT 25
15643: PUSH
15644: LD_INT 1
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: PUSH
15651: LD_INT 25
15653: PUSH
15654: LD_INT 2
15656: PUSH
15657: EMPTY
15658: LIST
15659: LIST
15660: PUSH
15661: LD_INT 25
15663: PUSH
15664: LD_INT 4
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: PPUSH
15677: CALL 11421 0 2
15681: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15682: LD_ADDR_VAR 0 5
15686: PUSH
15687: LD_VAR 0 5
15691: PPUSH
15692: LD_INT 0
15694: PPUSH
15695: CALL 13570 0 2
15699: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15700: LD_ADDR_VAR 0 6
15704: PUSH
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_VAR 0 5
15714: PPUSH
15715: LD_INT 3
15717: PPUSH
15718: CALL 13190 0 3
15722: ST_TO_ADDR
// if n > sk then
15723: LD_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: GREATER
15733: IFFALSE 15745
// n := sk ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_VAR 0 6
15744: ST_TO_ADDR
// for i = 1 to n do
15745: LD_ADDR_VAR 0 4
15749: PUSH
15750: DOUBLE
15751: LD_INT 1
15753: DEC
15754: ST_TO_ADDR
15755: LD_VAR 0 2
15759: PUSH
15760: FOR_TO
15761: IFFALSE 15873
// if ( sk [ i ] [ 1 ] ) <> 0 then
15763: LD_VAR 0 6
15767: PUSH
15768: LD_VAR 0 4
15772: ARRAY
15773: PUSH
15774: LD_INT 1
15776: ARRAY
15777: PUSH
15778: LD_INT 0
15780: NONEQUAL
15781: IFFALSE 15871
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15783: LD_ADDR_EXP 54
15787: PUSH
15788: LD_EXP 54
15792: PPUSH
15793: LD_VAR 0 1
15797: PPUSH
15798: LD_VAR 0 6
15802: PUSH
15803: LD_VAR 0 4
15807: ARRAY
15808: PUSH
15809: LD_INT 1
15811: ARRAY
15812: PPUSH
15813: LD_INT 3
15815: PPUSH
15816: CALL 42241 0 4
15820: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15821: LD_ADDR_EXP 56
15825: PUSH
15826: LD_EXP 56
15830: PPUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_EXP 56
15840: PUSH
15841: LD_VAR 0 1
15845: ARRAY
15846: PUSH
15847: LD_INT 1
15849: PLUS
15850: PPUSH
15851: LD_VAR 0 6
15855: PUSH
15856: LD_VAR 0 4
15860: ARRAY
15861: PUSH
15862: LD_INT 1
15864: ARRAY
15865: PPUSH
15866: CALL 30959 0 4
15870: ST_TO_ADDR
// end ;
15871: GO 15760
15873: POP
15874: POP
// end ;
15875: LD_VAR 0 3
15879: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15880: LD_INT 0
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15886: LD_ADDR_VAR 0 5
15890: PUSH
15891: LD_VAR 0 1
15895: PPUSH
15896: LD_INT 2
15898: PUSH
15899: LD_INT 25
15901: PUSH
15902: LD_INT 1
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 25
15911: PUSH
15912: LD_INT 2
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: PPUSH
15924: CALL 11421 0 2
15928: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_VAR 0 5
15938: PPUSH
15939: LD_INT 0
15941: PPUSH
15942: CALL 13570 0 2
15946: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15947: LD_ADDR_VAR 0 6
15951: PUSH
15952: LD_VAR 0 1
15956: PPUSH
15957: LD_VAR 0 5
15961: PPUSH
15962: LD_INT 4
15964: PPUSH
15965: CALL 13190 0 3
15969: ST_TO_ADDR
// if n > sk then
15970: LD_VAR 0 2
15974: PUSH
15975: LD_VAR 0 6
15979: GREATER
15980: IFFALSE 15992
// n := sk ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 6
15991: ST_TO_ADDR
// for i = 1 to n do
15992: LD_ADDR_VAR 0 4
15996: PUSH
15997: DOUBLE
15998: LD_INT 1
16000: DEC
16001: ST_TO_ADDR
16002: LD_VAR 0 2
16006: PUSH
16007: FOR_TO
16008: IFFALSE 16120
// if ( sk [ i ] [ 1 ] ) <> 0 then
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 4
16019: ARRAY
16020: PUSH
16021: LD_INT 1
16023: ARRAY
16024: PUSH
16025: LD_INT 0
16027: NONEQUAL
16028: IFFALSE 16118
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16030: LD_ADDR_EXP 54
16034: PUSH
16035: LD_EXP 54
16039: PPUSH
16040: LD_VAR 0 1
16044: PPUSH
16045: LD_VAR 0 6
16049: PUSH
16050: LD_VAR 0 4
16054: ARRAY
16055: PUSH
16056: LD_INT 1
16058: ARRAY
16059: PPUSH
16060: LD_INT 4
16062: PPUSH
16063: CALL 42241 0 4
16067: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16068: LD_ADDR_EXP 55
16072: PUSH
16073: LD_EXP 55
16077: PPUSH
16078: LD_VAR 0 1
16082: PPUSH
16083: LD_EXP 55
16087: PUSH
16088: LD_VAR 0 1
16092: ARRAY
16093: PUSH
16094: LD_INT 1
16096: PLUS
16097: PPUSH
16098: LD_VAR 0 6
16102: PUSH
16103: LD_VAR 0 4
16107: ARRAY
16108: PUSH
16109: LD_INT 1
16111: ARRAY
16112: PPUSH
16113: CALL 30959 0 4
16117: ST_TO_ADDR
// end ;
16118: GO 16007
16120: POP
16121: POP
// end ;
16122: LD_VAR 0 3
16126: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16127: LD_INT 0
16129: PPUSH
16130: PPUSH
16131: PPUSH
16132: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16133: LD_ADDR_VAR 0 6
16137: PUSH
16138: LD_VAR 0 1
16142: PPUSH
16143: LD_INT 2
16145: PUSH
16146: LD_INT 25
16148: PUSH
16149: LD_INT 1
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: PUSH
16156: LD_INT 25
16158: PUSH
16159: LD_INT 2
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: LD_INT 25
16168: PUSH
16169: LD_INT 3
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 25
16178: PUSH
16179: LD_INT 4
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: LIST
16191: LIST
16192: PPUSH
16193: CALL 11421 0 2
16197: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16198: LD_ADDR_VAR 0 6
16202: PUSH
16203: LD_VAR 0 6
16207: PPUSH
16208: LD_INT 0
16210: PPUSH
16211: CALL 13570 0 2
16215: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16216: LD_ADDR_VAR 0 7
16220: PUSH
16221: LD_VAR 0 1
16225: PPUSH
16226: LD_VAR 0 6
16230: PPUSH
16231: LD_INT 1
16233: PPUSH
16234: CALL 13190 0 3
16238: ST_TO_ADDR
// if n > sk then
16239: LD_VAR 0 2
16243: PUSH
16244: LD_VAR 0 7
16248: GREATER
16249: IFFALSE 16261
// n := sk ;
16251: LD_ADDR_VAR 0 2
16255: PUSH
16256: LD_VAR 0 7
16260: ST_TO_ADDR
// for i = 1 to n do
16261: LD_ADDR_VAR 0 5
16265: PUSH
16266: DOUBLE
16267: LD_INT 1
16269: DEC
16270: ST_TO_ADDR
16271: LD_VAR 0 2
16275: PUSH
16276: FOR_TO
16277: IFFALSE 16321
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16279: LD_ADDR_EXP 54
16283: PUSH
16284: LD_EXP 54
16288: PPUSH
16289: LD_VAR 0 1
16293: PPUSH
16294: LD_VAR 0 7
16298: PUSH
16299: LD_VAR 0 5
16303: ARRAY
16304: PUSH
16305: LD_INT 1
16307: ARRAY
16308: PPUSH
16309: LD_VAR 0 3
16313: PPUSH
16314: CALL 42241 0 4
16318: ST_TO_ADDR
// end ;
16319: GO 16276
16321: POP
16322: POP
// end ;
16323: LD_VAR 0 4
16327: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16328: LD_INT 0
16330: PPUSH
16331: PPUSH
16332: PPUSH
// b := false ;
16333: LD_ADDR_VAR 0 6
16337: PUSH
16338: LD_INT 0
16340: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16341: LD_VAR 0 3
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: LD_INT 9
16351: PUSH
16352: LD_INT 5
16354: PUSH
16355: LD_INT 8
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: LIST
16362: LIST
16363: IN
16364: IFFALSE 16452
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16366: LD_VAR 0 1
16370: PPUSH
16371: LD_INT 2
16373: PUSH
16374: LD_INT 30
16376: PUSH
16377: LD_INT 4
16379: PUSH
16380: EMPTY
16381: LIST
16382: LIST
16383: PUSH
16384: LD_INT 30
16386: PUSH
16387: LD_INT 5
16389: PUSH
16390: EMPTY
16391: LIST
16392: LIST
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: LIST
16398: PPUSH
16399: CALL 11421 0 2
16403: IFFALSE 16452
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16405: LD_ADDR_VAR 0 6
16409: PUSH
16410: LD_VAR 0 1
16414: PPUSH
16415: LD_INT 2
16417: PUSH
16418: LD_INT 30
16420: PUSH
16421: LD_INT 4
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: PUSH
16428: LD_INT 30
16430: PUSH
16431: LD_INT 5
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: PUSH
16438: EMPTY
16439: LIST
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL 11421 0 2
16447: PUSH
16448: LD_INT 1
16450: ARRAY
16451: ST_TO_ADDR
// if class = class_engineer then
16452: LD_VAR 0 3
16456: PUSH
16457: LD_INT 2
16459: EQUAL
16460: IFFALSE 16548
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16462: LD_VAR 0 1
16466: PPUSH
16467: LD_INT 2
16469: PUSH
16470: LD_INT 30
16472: PUSH
16473: LD_INT 0
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: PUSH
16480: LD_INT 30
16482: PUSH
16483: LD_INT 1
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: LIST
16494: PPUSH
16495: CALL 11421 0 2
16499: IFFALSE 16548
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16501: LD_ADDR_VAR 0 6
16505: PUSH
16506: LD_VAR 0 1
16510: PPUSH
16511: LD_INT 2
16513: PUSH
16514: LD_INT 30
16516: PUSH
16517: LD_INT 0
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: LD_INT 30
16526: PUSH
16527: LD_INT 1
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: LIST
16538: PPUSH
16539: CALL 11421 0 2
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: ST_TO_ADDR
// if class = class_mechanic then
16548: LD_VAR 0 3
16552: PUSH
16553: LD_INT 3
16555: EQUAL
16556: IFFALSE 16626
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16558: LD_VAR 0 1
16562: PPUSH
16563: LD_INT 30
16565: PUSH
16566: LD_INT 3
16568: PUSH
16569: EMPTY
16570: LIST
16571: LIST
16572: PPUSH
16573: CALL 11421 0 2
16577: IFFALSE 16626
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_VAR 0 1
16588: PPUSH
16589: LD_INT 2
16591: PUSH
16592: LD_INT 30
16594: PUSH
16595: LD_INT 2
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: LD_INT 30
16604: PUSH
16605: LD_INT 3
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: LIST
16616: PPUSH
16617: CALL 11421 0 2
16621: PUSH
16622: LD_INT 1
16624: ARRAY
16625: ST_TO_ADDR
// if class = class_scientistic then
16626: LD_VAR 0 3
16630: PUSH
16631: LD_INT 4
16633: EQUAL
16634: IFFALSE 16744
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16636: LD_VAR 0 1
16640: PPUSH
16641: LD_INT 2
16643: PUSH
16644: LD_INT 30
16646: PUSH
16647: LD_INT 6
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: PUSH
16654: LD_INT 30
16656: PUSH
16657: LD_INT 7
16659: PUSH
16660: EMPTY
16661: LIST
16662: LIST
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 8
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL 11421 0 2
16684: IFFALSE 16744
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16686: LD_ADDR_VAR 0 6
16690: PUSH
16691: LD_VAR 0 1
16695: PPUSH
16696: LD_INT 2
16698: PUSH
16699: LD_INT 30
16701: PUSH
16702: LD_INT 6
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: LD_INT 30
16711: PUSH
16712: LD_INT 7
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PUSH
16719: LD_INT 30
16721: PUSH
16722: LD_INT 8
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PUSH
16729: EMPTY
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: PPUSH
16735: CALL 11421 0 2
16739: PUSH
16740: LD_INT 1
16742: ARRAY
16743: ST_TO_ADDR
// if GetClass ( unit ) = class then
16744: LD_VAR 0 2
16748: PPUSH
16749: CALL_OW 257
16753: PUSH
16754: LD_VAR 0 3
16758: EQUAL
16759: IFFALSE 16793
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16761: LD_ADDR_EXP 54
16765: PUSH
16766: LD_EXP 54
16770: PPUSH
16771: LD_VAR 0 1
16775: PPUSH
16776: LD_VAR 0 2
16780: PPUSH
16781: LD_VAR 0 3
16785: PPUSH
16786: CALL 42332 0 4
16790: ST_TO_ADDR
// end else
16791: GO 16886
// if b then
16793: LD_VAR 0 6
16797: IFFALSE 16878
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16799: LD_VAR 0 2
16803: PPUSH
16804: CALL_OW 310
16808: PUSH
16809: LD_VAR 0 2
16813: PPUSH
16814: CALL_OW 310
16818: PUSH
16819: LD_VAR 0 6
16823: NONEQUAL
16824: AND
16825: IFFALSE 16836
// ComExitBuilding ( unit ) ;
16827: LD_VAR 0 2
16831: PPUSH
16832: CALL_OW 122
// if not IsInUnit ( unit ) then
16836: LD_VAR 0 2
16840: PPUSH
16841: CALL_OW 310
16845: NOT
16846: IFFALSE 16862
// ComEnterUnit ( unit , b ) ;
16848: LD_VAR 0 2
16852: PPUSH
16853: LD_VAR 0 6
16857: PPUSH
16858: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16862: LD_VAR 0 2
16866: PPUSH
16867: LD_VAR 0 3
16871: PPUSH
16872: CALL_OW 183
// end else
16876: GO 16886
// result := false ;
16878: LD_ADDR_VAR 0 4
16882: PUSH
16883: LD_INT 0
16885: ST_TO_ADDR
// end ; end_of_file
16886: LD_VAR 0 4
16890: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16891: LD_INT 0
16893: PPUSH
16894: PPUSH
16895: PPUSH
16896: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16897: LD_ADDR_VAR 0 5
16901: PUSH
16902: LD_INT 35
16904: PUSH
16905: LD_INT 45
16907: PUSH
16908: LD_INT 46
16910: PUSH
16911: LD_INT 47
16913: PUSH
16914: LD_INT 1
16916: PUSH
16917: LD_INT 2
16919: PUSH
16920: LD_INT 48
16922: PUSH
16923: LD_INT 49
16925: PUSH
16926: LD_INT 50
16928: PUSH
16929: LD_INT 20
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: ST_TO_ADDR
// if MCF_Lab ( side ) then
16944: LD_VAR 0 1
16948: PPUSH
16949: CALL 11460 0 1
16953: IFFALSE 17192
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16955: LD_VAR 0 1
16959: PPUSH
16960: CALL 11460 0 1
16964: PUSH
16965: LD_INT 1
16967: ARRAY
16968: PPUSH
16969: CALL_OW 461
16973: PUSH
16974: LD_INT 2
16976: EQUAL
16977: IFFALSE 17116
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL 11460 0 1
16988: PUSH
16989: LD_INT 1
16991: ARRAY
16992: PPUSH
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL 17288 0 2
17002: IFFALSE 17029
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL 11460 0 1
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: LD_VAR 0 2
17022: PPUSH
17023: CALL_OW 124
17027: GO 17116
// if MCF_Lab ( side ) > 1 then
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL 11460 0 1
17038: PUSH
17039: LD_INT 1
17041: GREATER
17042: IFFALSE 17116
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17044: LD_VAR 0 1
17048: PPUSH
17049: CALL 11460 0 1
17053: PUSH
17054: LD_INT 2
17056: ARRAY
17057: PPUSH
17058: CALL_OW 461
17062: PUSH
17063: LD_INT 2
17065: EQUAL
17066: IFFALSE 17116
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17068: LD_VAR 0 1
17072: PPUSH
17073: CALL 11460 0 1
17077: PUSH
17078: LD_INT 2
17080: ARRAY
17081: PPUSH
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL 17288 0 2
17091: IFFALSE 17116
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL 11460 0 1
17102: PUSH
17103: LD_INT 2
17105: ARRAY
17106: PPUSH
17107: LD_VAR 0 2
17111: PPUSH
17112: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17116: LD_VAR 0 2
17120: PUSH
17121: LD_INT 2
17123: PUSH
17124: LD_INT 11
17126: PUSH
17127: LD_INT 4
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: EMPTY
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: IN
17139: IFFALSE 17192
// begin for lab in MCF_Lab ( side ) do
17141: LD_ADDR_VAR 0 6
17145: PUSH
17146: LD_VAR 0 1
17150: PPUSH
17151: CALL 11460 0 1
17155: PUSH
17156: FOR_IN
17157: IFFALSE 17190
// if BuildingStatus ( lab ) = bs_need_ape then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 461
17168: PUSH
17169: LD_INT 10
17171: EQUAL
17172: IFFALSE 17188
// MCL_ResTame ( side , lab ) ;
17174: LD_VAR 0 1
17178: PPUSH
17179: LD_VAR 0 6
17183: PPUSH
17184: CALL 17413 0 2
17188: GO 17156
17190: POP
17191: POP
// end ; end ; end ;
17192: LD_VAR 0 3
17196: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17197: LD_INT 0
17199: PPUSH
17200: PPUSH
// tmp := [ ] ;
17201: LD_ADDR_VAR 0 3
17205: PUSH
17206: EMPTY
17207: ST_TO_ADDR
// if not lab then
17208: LD_VAR 0 1
17212: NOT
17213: IFFALSE 17225
// result := false else
17215: LD_ADDR_VAR 0 2
17219: PUSH
17220: LD_INT 0
17222: ST_TO_ADDR
17223: GO 17283
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17225: LD_ADDR_VAR 0 3
17229: PUSH
17230: LD_VAR 0 3
17234: PUSH
17235: LD_VAR 0 1
17239: PPUSH
17240: LD_INT 1
17242: PPUSH
17243: CALL_OW 268
17247: ADD
17248: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17249: LD_ADDR_VAR 0 3
17253: PUSH
17254: LD_VAR 0 3
17258: PUSH
17259: LD_VAR 0 1
17263: PPUSH
17264: LD_INT 2
17266: PPUSH
17267: CALL_OW 268
17271: ADD
17272: ST_TO_ADDR
// result := tmp ;
17273: LD_ADDR_VAR 0 2
17277: PUSH
17278: LD_VAR 0 3
17282: ST_TO_ADDR
// end ; end ;
17283: LD_VAR 0 2
17287: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17288: LD_INT 0
17290: PPUSH
17291: PPUSH
17292: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17293: LD_ADDR_VAR 0 5
17297: PUSH
17298: LD_INT 35
17300: PUSH
17301: LD_INT 45
17303: PUSH
17304: LD_INT 46
17306: PUSH
17307: LD_INT 47
17309: PUSH
17310: LD_INT 1
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 48
17318: PUSH
17319: LD_INT 49
17321: PUSH
17322: LD_INT 50
17324: PUSH
17325: LD_INT 20
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: LIST
17332: LIST
17333: LIST
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: ST_TO_ADDR
// if lab then
17340: LD_VAR 0 1
17344: IFFALSE 17400
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_VAR 0 5
17355: IN
17356: PUSH
17357: LD_VAR 0 2
17361: PPUSH
17362: CALL_OW 481
17366: PUSH
17367: LD_VAR 0 1
17371: PPUSH
17372: CALL 17197 0 1
17376: IN
17377: OR
17378: IFFALSE 17390
// result := true else
17380: LD_ADDR_VAR 0 3
17384: PUSH
17385: LD_INT 1
17387: ST_TO_ADDR
17388: GO 17398
// result := false ;
17390: LD_ADDR_VAR 0 3
17394: PUSH
17395: LD_INT 0
17397: ST_TO_ADDR
// end else
17398: GO 17408
// result := false ;
17400: LD_ADDR_VAR 0 3
17404: PUSH
17405: LD_INT 0
17407: ST_TO_ADDR
// end ;
17408: LD_VAR 0 3
17412: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17413: LD_INT 0
17415: PPUSH
17416: PPUSH
17417: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17418: LD_ADDR_VAR 0 4
17422: PUSH
17423: LD_VAR 0 1
17427: PPUSH
17428: LD_INT 171
17430: PPUSH
17431: EMPTY
17432: PPUSH
17433: CALL 12124 0 3
17437: ST_TO_ADDR
// if not ape then
17438: LD_VAR 0 4
17442: NOT
17443: IFFALSE 17475
// if MCF_Ape ( side ) then
17445: LD_VAR 0 1
17449: PPUSH
17450: CALL 11834 0 1
17454: IFFALSE 17475
// ape := MCF_Ape ( side ) [ 1 ] ;
17456: LD_ADDR_VAR 0 4
17460: PUSH
17461: LD_VAR 0 1
17465: PPUSH
17466: CALL 11834 0 1
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: ST_TO_ADDR
// if ape then
17475: LD_VAR 0 4
17479: IFFALSE 17530
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17481: LD_VAR 0 4
17485: PUSH
17486: LD_INT 1
17488: ARRAY
17489: PPUSH
17490: CALL_OW 310
17494: PUSH
17495: LD_VAR 0 4
17499: PUSH
17500: LD_INT 1
17502: ARRAY
17503: PPUSH
17504: CALL_OW 310
17508: PUSH
17509: LD_VAR 0 2
17513: NONEQUAL
17514: AND
17515: IFFALSE 17530
// ComExitBuilding ( ape [ 1 ] ) ;
17517: LD_VAR 0 4
17521: PUSH
17522: LD_INT 1
17524: ARRAY
17525: PPUSH
17526: CALL_OW 122
// if not lab then
17530: LD_VAR 0 2
17534: NOT
17535: IFFALSE 17541
// exit else
17537: GO 17689
17539: GO 17649
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17541: LD_VAR 0 1
17545: PPUSH
17546: LD_INT 16
17548: PPUSH
17549: LD_INT 25
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: PPUSH
17559: CALL 12124 0 3
17563: PUSH
17564: LD_INT 0
17566: EQUAL
17567: PUSH
17568: LD_VAR 0 2
17572: PPUSH
17573: CALL_OW 313
17577: PUSH
17578: LD_INT 6
17580: EQUAL
17581: AND
17582: IFFALSE 17649
// begin tmp := UnitsInside ( lab ) ;
17584: LD_ADDR_VAR 0 5
17588: PUSH
17589: LD_VAR 0 2
17593: PPUSH
17594: CALL_OW 313
17598: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17599: LD_VAR 0 5
17603: PUSH
17604: LD_VAR 0 5
17608: ARRAY
17609: PPUSH
17610: LD_INT 16
17612: PPUSH
17613: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17617: LD_VAR 0 5
17621: PUSH
17622: LD_VAR 0 5
17626: ARRAY
17627: PPUSH
17628: CALL_OW 310
17632: IFFALSE 17649
// ComExitBuilding ( tmp [ tmp ] ) ;
17634: LD_VAR 0 5
17638: PUSH
17639: LD_VAR 0 5
17643: ARRAY
17644: PPUSH
17645: CALL_OW 122
// end ; if ape then
17649: LD_VAR 0 4
17653: IFFALSE 17689
// if not IsInUnit ( ape [ 1 ] ) then
17655: LD_VAR 0 4
17659: PUSH
17660: LD_INT 1
17662: ARRAY
17663: PPUSH
17664: CALL_OW 310
17668: NOT
17669: IFFALSE 17689
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17671: LD_VAR 0 4
17675: PUSH
17676: LD_INT 1
17678: ARRAY
17679: PPUSH
17680: LD_VAR 0 2
17684: PPUSH
17685: CALL_OW 120
// end ;
17689: LD_VAR 0 3
17693: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17694: LD_INT 0
17696: PPUSH
17697: PPUSH
17698: PPUSH
// result := false ;
17699: LD_ADDR_VAR 0 2
17703: PUSH
17704: LD_INT 0
17706: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 1
17716: PPUSH
17717: CALL 17804 0 1
17721: ST_TO_ADDR
// if techs then
17722: LD_VAR 0 3
17726: IFFALSE 17756
// if techs [ 2 ] then
17728: LD_VAR 0 3
17732: PUSH
17733: LD_INT 2
17735: ARRAY
17736: IFFALSE 17748
// result := true else
17738: LD_ADDR_VAR 0 2
17742: PUSH
17743: LD_INT 1
17745: ST_TO_ADDR
17746: GO 17756
// result := false ;
17748: LD_ADDR_VAR 0 2
17752: PUSH
17753: LD_INT 0
17755: ST_TO_ADDR
// end ;
17756: LD_VAR 0 2
17760: RET
// export function MCL_Start ( side ) ; var i ; begin
17761: LD_INT 0
17763: PPUSH
17764: PPUSH
// if MCL_GetTechList ( side ) then
17765: LD_VAR 0 1
17769: PPUSH
17770: CALL 17804 0 1
17774: IFFALSE 17799
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17776: LD_VAR 0 1
17780: PPUSH
17781: LD_VAR 0 1
17785: PPUSH
17786: CALL 17804 0 1
17790: PUSH
17791: LD_INT 1
17793: ARRAY
17794: PPUSH
17795: CALL 16891 0 2
// end ;
17799: LD_VAR 0 2
17803: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17804: LD_INT 0
17806: PPUSH
17807: PPUSH
17808: PPUSH
// if MREG_ToRes then
17809: LD_EXP 51
17813: IFFALSE 17898
// for i = 1 to MREG_ToRes do
17815: LD_ADDR_VAR 0 3
17819: PUSH
17820: DOUBLE
17821: LD_INT 1
17823: DEC
17824: ST_TO_ADDR
17825: LD_EXP 51
17829: PUSH
17830: FOR_TO
17831: IFFALSE 17896
// if MREG_ToRes [ i ] [ 1 ] = side then
17833: LD_EXP 51
17837: PUSH
17838: LD_VAR 0 3
17842: ARRAY
17843: PUSH
17844: LD_INT 1
17846: ARRAY
17847: PUSH
17848: LD_VAR 0 1
17852: EQUAL
17853: IFFALSE 17894
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17855: LD_ADDR_VAR 0 4
17859: PUSH
17860: LD_VAR 0 4
17864: PPUSH
17865: LD_VAR 0 4
17869: PUSH
17870: LD_INT 1
17872: PLUS
17873: PPUSH
17874: LD_EXP 51
17878: PUSH
17879: LD_VAR 0 3
17883: ARRAY
17884: PUSH
17885: LD_INT 2
17887: ARRAY
17888: PPUSH
17889: CALL_OW 1
17893: ST_TO_ADDR
// end ;
17894: GO 17830
17896: POP
17897: POP
// result := techs ;
17898: LD_ADDR_VAR 0 2
17902: PUSH
17903: LD_VAR 0 4
17907: ST_TO_ADDR
// end ;
17908: LD_VAR 0 2
17912: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17913: LD_INT 0
17915: PPUSH
17916: PPUSH
// for i = 1 to tech_list do
17917: LD_ADDR_VAR 0 4
17921: PUSH
17922: DOUBLE
17923: LD_INT 1
17925: DEC
17926: ST_TO_ADDR
17927: LD_VAR 0 2
17931: PUSH
17932: FOR_TO
17933: IFFALSE 17987
// if not tech_list [ i ] = 20 then
17935: LD_VAR 0 2
17939: PUSH
17940: LD_VAR 0 4
17944: ARRAY
17945: PUSH
17946: LD_INT 20
17948: EQUAL
17949: NOT
17950: IFFALSE 17985
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17952: LD_ADDR_EXP 51
17956: PUSH
17957: LD_EXP 51
17961: PPUSH
17962: LD_VAR 0 1
17966: PPUSH
17967: LD_VAR 0 2
17971: PUSH
17972: LD_VAR 0 4
17976: ARRAY
17977: PPUSH
17978: EMPTY
17979: PPUSH
17980: CALL 42241 0 4
17984: ST_TO_ADDR
17985: GO 17932
17987: POP
17988: POP
// result := true ;
17989: LD_ADDR_VAR 0 3
17993: PUSH
17994: LD_INT 1
17996: ST_TO_ADDR
// end ;
17997: LD_VAR 0 3
18001: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18002: LD_INT 0
18004: PPUSH
18005: PPUSH
// for i = MREG_ToRes downto 1 do
18006: LD_ADDR_VAR 0 3
18010: PUSH
18011: DOUBLE
18012: LD_EXP 51
18016: INC
18017: ST_TO_ADDR
18018: LD_INT 1
18020: PUSH
18021: FOR_DOWNTO
18022: IFFALSE 18068
// if MREG_ToRes [ i ] [ 1 ] = side then
18024: LD_EXP 51
18028: PUSH
18029: LD_VAR 0 3
18033: ARRAY
18034: PUSH
18035: LD_INT 1
18037: ARRAY
18038: PUSH
18039: LD_VAR 0 1
18043: EQUAL
18044: IFFALSE 18066
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18046: LD_ADDR_EXP 51
18050: PUSH
18051: LD_EXP 51
18055: PPUSH
18056: LD_VAR 0 3
18060: PPUSH
18061: CALL_OW 3
18065: ST_TO_ADDR
18066: GO 18021
18068: POP
18069: POP
// result := true ;
18070: LD_ADDR_VAR 0 2
18074: PUSH
18075: LD_INT 1
18077: ST_TO_ADDR
// end ;
18078: LD_VAR 0 2
18082: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18083: LD_INT 0
18085: PPUSH
// result := GetTechProgress ( side , tech ) ;
18086: LD_ADDR_VAR 0 3
18090: PUSH
18091: LD_VAR 0 1
18095: PPUSH
18096: LD_VAR 0 2
18100: PPUSH
18101: CALL_OW 326
18105: ST_TO_ADDR
// end ;
18106: LD_VAR 0 3
18110: RET
// export function MCL_Require ( tech ) ; begin
18111: LD_INT 0
18113: PPUSH
// result := GetTechTechsReq ( tech ) ;
18114: LD_ADDR_VAR 0 2
18118: PUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: CALL_OW 480
18128: ST_TO_ADDR
// end ; end_of_file
18129: LD_VAR 0 2
18133: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18134: LD_INT 0
18136: PPUSH
18137: PPUSH
18138: PPUSH
// uc_side := 0 ;
18139: LD_ADDR_OWVAR 20
18143: PUSH
18144: LD_INT 0
18146: ST_TO_ADDR
// uc_nation := 0 ;
18147: LD_ADDR_OWVAR 21
18151: PUSH
18152: LD_INT 0
18154: ST_TO_ADDR
// for i = 1 to n do
18155: LD_ADDR_VAR 0 5
18159: PUSH
18160: DOUBLE
18161: LD_INT 1
18163: DEC
18164: ST_TO_ADDR
18165: LD_VAR 0 2
18169: PUSH
18170: FOR_TO
18171: IFFALSE 18316
// begin hc_importance := 0 ;
18173: LD_ADDR_OWVAR 32
18177: PUSH
18178: LD_INT 0
18180: ST_TO_ADDR
// hc_gallery :=  ;
18181: LD_ADDR_OWVAR 33
18185: PUSH
18186: LD_STRING 
18188: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18189: LD_ADDR_OWVAR 35
18193: PUSH
18194: LD_VAR 0 3
18198: PUSH
18199: LD_INT 20
18201: MINUS
18202: PPUSH
18203: LD_VAR 0 3
18207: PUSH
18208: LD_INT 20
18210: PLUS
18211: PPUSH
18212: CALL_OW 12
18216: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18217: LD_ADDR_OWVAR 31
18221: PUSH
18222: LD_INT 0
18224: PPUSH
18225: LD_INT 2
18227: PPUSH
18228: CALL_OW 12
18232: PUSH
18233: LD_INT 0
18235: PUSH
18236: LD_INT 0
18238: PUSH
18239: LD_INT 0
18241: PUSH
18242: EMPTY
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18248: LD_ADDR_OWVAR 30
18252: PUSH
18253: LD_INT 0
18255: PUSH
18256: LD_INT 0
18258: PUSH
18259: LD_INT 0
18261: PUSH
18262: LD_INT 0
18264: PUSH
18265: EMPTY
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: ST_TO_ADDR
// hc_name :=  ;
18271: LD_ADDR_OWVAR 26
18275: PUSH
18276: LD_STRING 
18278: ST_TO_ADDR
// hc_class := class_apeman ;
18279: LD_ADDR_OWVAR 28
18283: PUSH
18284: LD_INT 12
18286: ST_TO_ADDR
// ape := CreateHuman ;
18287: LD_ADDR_VAR 0 6
18291: PUSH
18292: CALL_OW 44
18296: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18297: LD_VAR 0 6
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: LD_INT 0
18309: PPUSH
18310: CALL_OW 49
// end ;
18314: GO 18170
18316: POP
18317: POP
// end ;
18318: LD_VAR 0 4
18322: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18323: LD_INT 0
18325: PPUSH
18326: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18327: LD_VAR 0 1
18331: PPUSH
18332: CALL 11834 0 1
18336: PUSH
18337: LD_EXP 38
18341: PUSH
18342: LD_VAR 0 1
18346: ARRAY
18347: GREATEREQUAL
18348: IFFALSE 18525
// begin if GetTag ( unit ) = 17 then
18350: LD_VAR 0 2
18354: PPUSH
18355: CALL_OW 110
18359: PUSH
18360: LD_INT 17
18362: EQUAL
18363: IFFALSE 18523
// begin SetTag ( unit , 0 ) ;
18365: LD_VAR 0 2
18369: PPUSH
18370: LD_INT 0
18372: PPUSH
18373: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18377: LD_VAR 0 1
18381: PPUSH
18382: CALL 11460 0 1
18386: PUSH
18387: LD_VAR 0 1
18391: PPUSH
18392: CALL 17804 0 1
18396: NOT
18397: AND
18398: IFFALSE 18423
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18400: LD_VAR 0 2
18404: PPUSH
18405: LD_VAR 0 1
18409: PPUSH
18410: CALL 11460 0 1
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18423: LD_VAR 0 1
18427: PPUSH
18428: CALL 11460 0 1
18432: NOT
18433: PUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: LD_INT 30
18441: PUSH
18442: LD_INT 1
18444: PUSH
18445: EMPTY
18446: LIST
18447: LIST
18448: PPUSH
18449: CALL 11421 0 2
18453: AND
18454: IFFALSE 18523
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18456: LD_VAR 0 2
18460: PPUSH
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 30
18468: PUSH
18469: LD_INT 1
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: PPUSH
18476: CALL 11421 0 2
18480: PUSH
18481: LD_INT 1
18483: ARRAY
18484: PPUSH
18485: CALL_OW 250
18489: PPUSH
18490: LD_VAR 0 1
18494: PPUSH
18495: LD_INT 30
18497: PUSH
18498: LD_INT 1
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: PPUSH
18505: CALL 11421 0 2
18509: PUSH
18510: LD_INT 1
18512: ARRAY
18513: PPUSH
18514: CALL_OW 251
18518: PPUSH
18519: CALL_OW 111
// end ; end else
18523: GO 18709
// if GetClass ( unit ) <> 4 then
18525: LD_VAR 0 2
18529: PPUSH
18530: CALL_OW 257
18534: PUSH
18535: LD_INT 4
18537: NONEQUAL
18538: IFFALSE 18544
// exit else
18540: GO 18709
18542: GO 18709
// if GetTag ( unit ) = 0 then
18544: LD_VAR 0 2
18548: PPUSH
18549: CALL_OW 110
18553: PUSH
18554: LD_INT 0
18556: EQUAL
18557: IFFALSE 18573
// SetTag ( unit , 17 ) else
18559: LD_VAR 0 2
18563: PPUSH
18564: LD_INT 17
18566: PPUSH
18567: CALL_OW 109
18571: GO 18709
// begin if IsInUnit ( unit ) then
18573: LD_VAR 0 2
18577: PPUSH
18578: CALL_OW 310
18582: IFFALSE 18593
// ComExitBuilding ( unit ) ;
18584: LD_VAR 0 2
18588: PPUSH
18589: CALL_OW 122
// Wait ( 1 ) ;
18593: LD_INT 1
18595: PPUSH
18596: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18600: LD_ADDR_VAR 0 4
18604: PUSH
18605: LD_INT 22
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: LD_INT 25
18617: PUSH
18618: LD_INT 12
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: PUSH
18625: EMPTY
18626: LIST
18627: LIST
18628: PPUSH
18629: CALL_OW 69
18633: PPUSH
18634: LD_VAR 0 2
18638: PPUSH
18639: CALL_OW 74
18643: ST_TO_ADDR
// if not ape then
18644: LD_VAR 0 4
18648: NOT
18649: IFFALSE 18655
// exit else
18651: GO 18709
18653: GO 18664
// ComHold ( ape ) ;
18655: LD_VAR 0 4
18659: PPUSH
18660: CALL_OW 140
// if not HasTask ( unit ) then
18664: LD_VAR 0 2
18668: PPUSH
18669: CALL_OW 314
18673: NOT
18674: IFFALSE 18707
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18676: LD_VAR 0 2
18680: PPUSH
18681: LD_VAR 0 4
18685: PPUSH
18686: CALL_OW 250
18690: PPUSH
18691: LD_VAR 0 4
18695: PPUSH
18696: CALL_OW 251
18700: PPUSH
18701: CALL_OW 131
18705: GO 18709
// exit ;
18707: GO 18709
// end ; end ;
18709: LD_VAR 0 3
18713: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18714: LD_INT 0
18716: PPUSH
18717: PPUSH
18718: PPUSH
18719: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18720: LD_ADDR_VAR 0 4
18724: PUSH
18725: LD_EXP 39
18729: PUSH
18730: LD_VAR 0 1
18734: ARRAY
18735: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18736: LD_ADDR_VAR 0 5
18740: PUSH
18741: LD_VAR 0 1
18745: PPUSH
18746: LD_STRING normal
18748: PPUSH
18749: CALL 11918 0 2
18753: ST_TO_ADDR
// if apes then
18754: LD_VAR 0 5
18758: IFFALSE 18986
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18760: LD_INT 2
18762: PPUSH
18763: LD_VAR 0 1
18767: PPUSH
18768: CALL_OW 321
18772: PUSH
18773: LD_INT 2
18775: EQUAL
18776: PUSH
18777: LD_VAR 0 4
18781: PUSH
18782: LD_INT 2
18784: ARRAY
18785: PUSH
18786: LD_INT 1
18788: EQUAL
18789: AND
18790: PUSH
18791: LD_VAR 0 1
18795: PPUSH
18796: LD_STRING engineer
18798: PPUSH
18799: CALL 11918 0 2
18803: PUSH
18804: LD_INT 3
18806: LESS
18807: AND
18808: PUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: LD_INT 30
18816: PUSH
18817: LD_INT 1
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL 11421 0 2
18828: AND
18829: IFFALSE 18883
// begin for i in apes do
18831: LD_ADDR_VAR 0 3
18835: PUSH
18836: LD_VAR 0 5
18840: PUSH
18841: FOR_IN
18842: IFFALSE 18879
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18844: LD_VAR 0 3
18848: PPUSH
18849: LD_VAR 0 1
18853: PPUSH
18854: LD_INT 30
18856: PUSH
18857: LD_INT 1
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PPUSH
18864: CALL 11421 0 2
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: PPUSH
18873: CALL_OW 120
// end ;
18877: GO 18841
18879: POP
18880: POP
// end else
18881: GO 18986
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18883: LD_INT 11
18885: PPUSH
18886: LD_VAR 0 1
18890: PPUSH
18891: CALL_OW 321
18895: PUSH
18896: LD_INT 2
18898: EQUAL
18899: PUSH
18900: LD_VAR 0 4
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: PUSH
18909: LD_INT 1
18911: EQUAL
18912: AND
18913: PUSH
18914: LD_VAR 0 1
18918: PPUSH
18919: LD_INT 30
18921: PUSH
18922: LD_INT 5
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: PPUSH
18929: CALL 11421 0 2
18933: AND
18934: IFFALSE 18986
// begin for i in apes do
18936: LD_ADDR_VAR 0 3
18940: PUSH
18941: LD_VAR 0 5
18945: PUSH
18946: FOR_IN
18947: IFFALSE 18984
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18949: LD_VAR 0 3
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: LD_INT 30
18961: PUSH
18962: LD_INT 5
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: PPUSH
18969: CALL 11421 0 2
18973: PUSH
18974: LD_INT 1
18976: ARRAY
18977: PPUSH
18978: CALL_OW 120
// end ;
18982: GO 18946
18984: POP
18985: POP
// end ; end ; end ; end_of_file
18986: LD_VAR 0 2
18990: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18991: LD_INT 0
18993: PPUSH
18994: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18995: LD_VAR 0 1
18999: PPUSH
19000: CALL_OW 257
19004: PUSH
19005: LD_INT 4
19007: EQUAL
19008: NOT
19009: PUSH
19010: LD_VAR 0 2
19014: NOT
19015: OR
19016: IFFALSE 19022
// exit else
19018: GO 19056
19020: GO 19056
// if not GetTag ( unit ) = 4 then
19022: LD_VAR 0 1
19026: PPUSH
19027: CALL_OW 110
19031: PUSH
19032: LD_INT 4
19034: EQUAL
19035: NOT
19036: IFFALSE 19042
// exit else
19038: GO 19056
19040: GO 19056
// ComHeal ( unit , target ) ;
19042: LD_VAR 0 1
19046: PPUSH
19047: LD_VAR 0 2
19051: PPUSH
19052: CALL_OW 128
// end ;
19056: LD_VAR 0 3
19060: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
19068: PPUSH
19069: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19070: LD_ADDR_VAR 0 5
19074: PUSH
19075: LD_INT 22
19077: PUSH
19078: LD_VAR 0 1
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PUSH
19087: LD_INT 21
19089: PUSH
19090: LD_INT 1
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: PUSH
19097: LD_INT 3
19099: PUSH
19100: LD_INT 55
19102: PUSH
19103: EMPTY
19104: LIST
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PUSH
19110: LD_INT 3
19112: PUSH
19113: LD_INT 54
19115: PUSH
19116: EMPTY
19117: LIST
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: PUSH
19123: LD_INT 3
19125: PUSH
19126: LD_INT 24
19128: PUSH
19129: LD_INT 1000
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: PUSH
19136: EMPTY
19137: LIST
19138: LIST
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: LIST
19146: PPUSH
19147: CALL_OW 69
19151: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19152: LD_ADDR_VAR 0 8
19156: PUSH
19157: LD_VAR 0 1
19161: PPUSH
19162: LD_INT 30
19164: PUSH
19165: LD_INT 1
19167: PUSH
19168: EMPTY
19169: LIST
19170: LIST
19171: PPUSH
19172: CALL 11421 0 2
19176: ST_TO_ADDR
// r := [ ] ;
19177: LD_ADDR_VAR 0 6
19181: PUSH
19182: EMPTY
19183: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 5
19191: PPUSH
19192: EMPTY
19193: PPUSH
19194: CALL 12124 0 3
19198: IFFALSE 19254
// for j in MCF_Tag ( side , 5 , [ ] ) do
19200: LD_ADDR_VAR 0 4
19204: PUSH
19205: LD_VAR 0 1
19209: PPUSH
19210: LD_INT 5
19212: PPUSH
19213: EMPTY
19214: PPUSH
19215: CALL 12124 0 3
19219: PUSH
19220: FOR_IN
19221: IFFALSE 19252
// if GetLives ( j ) = 1000 then
19223: LD_VAR 0 4
19227: PPUSH
19228: CALL_OW 256
19232: PUSH
19233: LD_INT 1000
19235: EQUAL
19236: IFFALSE 19250
// SetTag ( j , 0 ) ;
19238: LD_VAR 0 4
19242: PPUSH
19243: LD_INT 0
19245: PPUSH
19246: CALL_OW 109
19250: GO 19220
19252: POP
19253: POP
// if tmp then
19254: LD_VAR 0 5
19258: IFFALSE 19587
// begin r := [ tmp [ 1 ] ] ;
19260: LD_ADDR_VAR 0 6
19264: PUSH
19265: LD_VAR 0 5
19269: PUSH
19270: LD_INT 1
19272: ARRAY
19273: PUSH
19274: EMPTY
19275: LIST
19276: ST_TO_ADDR
// for i = 2 to tmp do
19277: LD_ADDR_VAR 0 3
19281: PUSH
19282: DOUBLE
19283: LD_INT 2
19285: DEC
19286: ST_TO_ADDR
19287: LD_VAR 0 5
19291: PUSH
19292: FOR_TO
19293: IFFALSE 19585
// begin m := false ;
19295: LD_ADDR_VAR 0 7
19299: PUSH
19300: LD_INT 0
19302: ST_TO_ADDR
// if d then
19303: LD_VAR 0 8
19307: IFFALSE 19462
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19309: LD_VAR 0 5
19313: PUSH
19314: LD_VAR 0 3
19318: ARRAY
19319: PPUSH
19320: CALL_OW 256
19324: PUSH
19325: LD_INT 650
19327: LESS
19328: PUSH
19329: LD_VAR 0 5
19333: PUSH
19334: LD_VAR 0 3
19338: ARRAY
19339: PPUSH
19340: LD_VAR 0 8
19344: PUSH
19345: LD_INT 1
19347: ARRAY
19348: PPUSH
19349: CALL_OW 250
19353: PPUSH
19354: LD_VAR 0 8
19358: PUSH
19359: LD_INT 1
19361: ARRAY
19362: PPUSH
19363: CALL_OW 251
19367: PPUSH
19368: CALL_OW 297
19372: PUSH
19373: LD_INT 10
19375: GREATER
19376: AND
19377: IFFALSE 19462
// begin if not GetTag ( tmp [ i ] ) = 5 then
19379: LD_VAR 0 5
19383: PUSH
19384: LD_VAR 0 3
19388: ARRAY
19389: PPUSH
19390: CALL_OW 110
19394: PUSH
19395: LD_INT 5
19397: EQUAL
19398: NOT
19399: IFFALSE 19419
// SetTag ( tmp [ i ] , 5 ) ;
19401: LD_VAR 0 5
19405: PUSH
19406: LD_VAR 0 3
19410: ARRAY
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19419: LD_VAR 0 5
19423: PUSH
19424: LD_VAR 0 3
19428: ARRAY
19429: PPUSH
19430: LD_VAR 0 8
19434: PUSH
19435: LD_INT 1
19437: ARRAY
19438: PPUSH
19439: CALL_OW 250
19443: PPUSH
19444: LD_VAR 0 8
19448: PUSH
19449: LD_INT 1
19451: ARRAY
19452: PPUSH
19453: CALL_OW 251
19457: PPUSH
19458: CALL_OW 111
// end ; for j = 1 to r do
19462: LD_ADDR_VAR 0 4
19466: PUSH
19467: DOUBLE
19468: LD_INT 1
19470: DEC
19471: ST_TO_ADDR
19472: LD_VAR 0 6
19476: PUSH
19477: FOR_TO
19478: IFFALSE 19552
// if GetLives ( tmp [ i ] ) < r [ j ] then
19480: LD_VAR 0 5
19484: PUSH
19485: LD_VAR 0 3
19489: ARRAY
19490: PPUSH
19491: CALL_OW 256
19495: PUSH
19496: LD_VAR 0 6
19500: PUSH
19501: LD_VAR 0 4
19505: ARRAY
19506: LESS
19507: IFFALSE 19550
// begin r := Insert ( r , j , tmp [ i ] ) ;
19509: LD_ADDR_VAR 0 6
19513: PUSH
19514: LD_VAR 0 6
19518: PPUSH
19519: LD_VAR 0 4
19523: PPUSH
19524: LD_VAR 0 5
19528: PUSH
19529: LD_VAR 0 3
19533: ARRAY
19534: PPUSH
19535: CALL_OW 2
19539: ST_TO_ADDR
// m := true ;
19540: LD_ADDR_VAR 0 7
19544: PUSH
19545: LD_INT 1
19547: ST_TO_ADDR
// break ;
19548: GO 19552
// end ;
19550: GO 19477
19552: POP
19553: POP
// if not m then
19554: LD_VAR 0 7
19558: NOT
19559: IFFALSE 19583
// r := r ^ tmp [ i ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_VAR 0 6
19570: PUSH
19571: LD_VAR 0 5
19575: PUSH
19576: LD_VAR 0 3
19580: ARRAY
19581: ADD
19582: ST_TO_ADDR
// end ;
19583: GO 19292
19585: POP
19586: POP
// end ; result := r end ; end_of_file
19587: LD_ADDR_VAR 0 2
19591: PUSH
19592: LD_VAR 0 6
19596: ST_TO_ADDR
19597: LD_VAR 0 2
19601: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19602: LD_INT 0
19604: PPUSH
19605: PPUSH
19606: PPUSH
// pom := GetBase ( bdepot ) ;
19607: LD_ADDR_VAR 0 3
19611: PUSH
19612: LD_VAR 0 1
19616: PPUSH
19617: CALL_OW 274
19621: ST_TO_ADDR
// sor := [ ] ;
19622: LD_ADDR_VAR 0 4
19626: PUSH
19627: EMPTY
19628: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19629: LD_ADDR_VAR 0 4
19633: PUSH
19634: LD_VAR 0 4
19638: PUSH
19639: LD_VAR 0 3
19643: PPUSH
19644: LD_INT 1
19646: PPUSH
19647: CALL_OW 275
19651: ADD
19652: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19653: LD_ADDR_VAR 0 4
19657: PUSH
19658: LD_VAR 0 4
19662: PUSH
19663: LD_VAR 0 3
19667: PPUSH
19668: LD_INT 2
19670: PPUSH
19671: CALL_OW 275
19675: ADD
19676: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19677: LD_ADDR_VAR 0 4
19681: PUSH
19682: LD_VAR 0 4
19686: PUSH
19687: LD_VAR 0 3
19691: PPUSH
19692: LD_INT 3
19694: PPUSH
19695: CALL_OW 275
19699: ADD
19700: ST_TO_ADDR
// result := sor ;
19701: LD_ADDR_VAR 0 2
19705: PUSH
19706: LD_VAR 0 4
19710: ST_TO_ADDR
// end ;
19711: LD_VAR 0 2
19715: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19716: LD_INT 0
19718: PPUSH
19719: PPUSH
// while ( coord_list ) do
19720: LD_VAR 0 3
19724: IFFALSE 19898
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19726: LD_ADDR_EXP 47
19730: PUSH
19731: LD_EXP 47
19735: PPUSH
19736: LD_VAR 0 1
19740: PPUSH
19741: LD_VAR 0 2
19745: PPUSH
19746: LD_VAR 0 3
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: LD_VAR 0 3
19759: PUSH
19760: LD_INT 2
19762: ARRAY
19763: PUSH
19764: LD_VAR 0 3
19768: PUSH
19769: LD_INT 3
19771: ARRAY
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL 42241 0 4
19782: ST_TO_ADDR
// if weapon_list then
19783: LD_VAR 0 4
19787: IFFALSE 19858
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19789: LD_ADDR_EXP 44
19793: PUSH
19794: LD_EXP 44
19798: PPUSH
19799: LD_VAR 0 1
19803: PPUSH
19804: LD_VAR 0 4
19808: PUSH
19809: LD_INT 1
19811: ARRAY
19812: PPUSH
19813: LD_VAR 0 3
19817: PUSH
19818: LD_INT 1
19820: ARRAY
19821: PUSH
19822: LD_VAR 0 3
19826: PUSH
19827: LD_INT 2
19829: ARRAY
19830: PUSH
19831: EMPTY
19832: LIST
19833: LIST
19834: PPUSH
19835: CALL 42241 0 4
19839: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19840: LD_ADDR_VAR 0 4
19844: PUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: LD_INT 1
19852: PPUSH
19853: CALL_OW 3
19857: ST_TO_ADDR
// end ; for i = 1 to 3 do
19858: LD_ADDR_VAR 0 6
19862: PUSH
19863: DOUBLE
19864: LD_INT 1
19866: DEC
19867: ST_TO_ADDR
19868: LD_INT 3
19870: PUSH
19871: FOR_TO
19872: IFFALSE 19894
// coord_list := Delete ( coord_list , 1 ) ;
19874: LD_ADDR_VAR 0 3
19878: PUSH
19879: LD_VAR 0 3
19883: PPUSH
19884: LD_INT 1
19886: PPUSH
19887: CALL_OW 3
19891: ST_TO_ADDR
19892: GO 19871
19894: POP
19895: POP
// end ;
19896: GO 19720
// result := true ;
19898: LD_ADDR_VAR 0 5
19902: PUSH
19903: LD_INT 1
19905: ST_TO_ADDR
// end ;
19906: LD_VAR 0 5
19910: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19911: LD_INT 0
19913: PPUSH
19914: PPUSH
// if not weapon_list then
19915: LD_VAR 0 3
19919: NOT
19920: IFFALSE 19924
// exit ;
19922: GO 20039
// while ( coord_list ) do
19924: LD_VAR 0 2
19928: IFFALSE 20039
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19930: LD_ADDR_EXP 44
19934: PUSH
19935: LD_EXP 44
19939: PPUSH
19940: LD_VAR 0 1
19944: PPUSH
19945: LD_VAR 0 3
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PPUSH
19954: LD_VAR 0 2
19958: PUSH
19959: LD_INT 1
19961: ARRAY
19962: PUSH
19963: LD_VAR 0 2
19967: PUSH
19968: LD_INT 2
19970: ARRAY
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: PPUSH
19976: CALL 42241 0 4
19980: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19981: LD_ADDR_VAR 0 3
19985: PUSH
19986: LD_VAR 0 3
19990: PPUSH
19991: LD_INT 1
19993: PPUSH
19994: CALL_OW 3
19998: ST_TO_ADDR
// for i = 1 to 2 do
19999: LD_ADDR_VAR 0 5
20003: PUSH
20004: DOUBLE
20005: LD_INT 1
20007: DEC
20008: ST_TO_ADDR
20009: LD_INT 2
20011: PUSH
20012: FOR_TO
20013: IFFALSE 20035
// coord_list := Delete ( coord_list , 1 ) ;
20015: LD_ADDR_VAR 0 2
20019: PUSH
20020: LD_VAR 0 2
20024: PPUSH
20025: LD_INT 1
20027: PPUSH
20028: CALL_OW 3
20032: ST_TO_ADDR
20033: GO 20012
20035: POP
20036: POP
// end ;
20037: GO 19924
// end ;
20039: LD_VAR 0 4
20043: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20044: LD_INT 0
20046: PPUSH
20047: PPUSH
// while ( coord_list ) do
20048: LD_VAR 0 2
20052: IFFALSE 20207
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20054: LD_VAR 0 2
20058: PUSH
20059: LD_INT 1
20061: ARRAY
20062: PPUSH
20063: LD_VAR 0 2
20067: PUSH
20068: LD_INT 2
20070: ARRAY
20071: PPUSH
20072: CALL_OW 428
20076: IFFALSE 20167
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20078: LD_VAR 0 2
20082: PUSH
20083: LD_INT 1
20085: ARRAY
20086: PPUSH
20087: LD_VAR 0 2
20091: PUSH
20092: LD_INT 2
20094: ARRAY
20095: PPUSH
20096: CALL_OW 428
20100: PPUSH
20101: CALL_OW 266
20105: PUSH
20106: LD_INT 31
20108: PUSH
20109: LD_INT 32
20111: PUSH
20112: LD_INT 33
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: LIST
20119: IN
20120: IFFALSE 20167
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20122: LD_ADDR_EXP 53
20126: PUSH
20127: LD_EXP 53
20131: PPUSH
20132: LD_VAR 0 1
20136: PPUSH
20137: LD_VAR 0 2
20141: PUSH
20142: LD_INT 1
20144: ARRAY
20145: PPUSH
20146: LD_VAR 0 2
20150: PUSH
20151: LD_INT 2
20153: ARRAY
20154: PPUSH
20155: CALL_OW 428
20159: PPUSH
20160: EMPTY
20161: PPUSH
20162: CALL 42241 0 4
20166: ST_TO_ADDR
// for i = 1 to 3 do
20167: LD_ADDR_VAR 0 4
20171: PUSH
20172: DOUBLE
20173: LD_INT 1
20175: DEC
20176: ST_TO_ADDR
20177: LD_INT 3
20179: PUSH
20180: FOR_TO
20181: IFFALSE 20203
// coord_list := Delete ( coord_list , 1 ) ;
20183: LD_ADDR_VAR 0 2
20187: PUSH
20188: LD_VAR 0 2
20192: PPUSH
20193: LD_INT 1
20195: PPUSH
20196: CALL_OW 3
20200: ST_TO_ADDR
20201: GO 20180
20203: POP
20204: POP
// end ;
20205: GO 20048
// result := true ;
20207: LD_ADDR_VAR 0 3
20211: PUSH
20212: LD_INT 1
20214: ST_TO_ADDR
// end ;
20215: LD_VAR 0 3
20219: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20220: LD_INT 0
20222: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20223: LD_ADDR_EXP 47
20227: PUSH
20228: LD_EXP 47
20232: PPUSH
20233: LD_VAR 0 1
20237: PPUSH
20238: LD_INT 0
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: CALL 42241 0 4
20250: ST_TO_ADDR
// end ;
20251: LD_VAR 0 3
20255: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20256: LD_INT 0
20258: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20259: LD_ADDR_EXP 47
20263: PUSH
20264: LD_EXP 47
20268: PPUSH
20269: LD_VAR 0 1
20273: PPUSH
20274: LD_INT 6
20276: PPUSH
20277: LD_VAR 0 2
20281: PPUSH
20282: CALL 42241 0 4
20286: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20287: LD_ADDR_EXP 50
20291: PUSH
20292: LD_EXP 50
20296: PPUSH
20297: LD_VAR 0 1
20301: PPUSH
20302: LD_VAR 0 3
20306: PUSH
20307: LD_INT 1
20309: ARRAY
20310: PPUSH
20311: LD_VAR 0 3
20315: PUSH
20316: LD_INT 2
20318: ARRAY
20319: PPUSH
20320: CALL 42241 0 4
20324: ST_TO_ADDR
// end ;
20325: LD_VAR 0 4
20329: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20330: LD_INT 0
20332: PPUSH
20333: PPUSH
// if ext_list > 5 then
20334: LD_VAR 0 3
20338: PUSH
20339: LD_INT 5
20341: GREATER
20342: IFFALSE 20386
// for i = 6 to ext_list do
20344: LD_ADDR_VAR 0 5
20348: PUSH
20349: DOUBLE
20350: LD_INT 6
20352: DEC
20353: ST_TO_ADDR
20354: LD_VAR 0 3
20358: PUSH
20359: FOR_TO
20360: IFFALSE 20384
// ext_list := Delete ( ext_list , ext_list ) ;
20362: LD_ADDR_VAR 0 3
20366: PUSH
20367: LD_VAR 0 3
20371: PPUSH
20372: LD_VAR 0 3
20376: PPUSH
20377: CALL_OW 3
20381: ST_TO_ADDR
20382: GO 20359
20384: POP
20385: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20386: LD_VAR 0 1
20390: PPUSH
20391: LD_VAR 0 2
20395: PUSH
20396: LD_INT 1
20398: ARRAY
20399: PPUSH
20400: LD_VAR 0 2
20404: PUSH
20405: LD_INT 2
20407: ARRAY
20408: PPUSH
20409: LD_VAR 0 2
20413: PUSH
20414: LD_INT 3
20416: ARRAY
20417: PPUSH
20418: LD_VAR 0 3
20422: PPUSH
20423: CALL 8933 0 5
// end ;
20427: LD_VAR 0 4
20431: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20432: LD_INT 0
20434: PPUSH
20435: PPUSH
20436: PPUSH
// p := 1 ;
20437: LD_ADDR_VAR 0 6
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// if type_list = [ ] then
20445: LD_VAR 0 3
20449: PUSH
20450: EMPTY
20451: EQUAL
20452: IFFALSE 20462
// type_list := b_oil_power ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 26
20461: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20462: LD_ADDR_VAR 0 5
20466: PUSH
20467: DOUBLE
20468: LD_INT 1
20470: DEC
20471: ST_TO_ADDR
20472: LD_VAR 0 2
20476: PUSH
20477: LD_INT 3
20479: DIVREAL
20480: PUSH
20481: FOR_TO
20482: IFFALSE 20585
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20484: LD_ADDR_EXP 47
20488: PUSH
20489: LD_EXP 47
20493: PPUSH
20494: LD_VAR 0 1
20498: PPUSH
20499: LD_VAR 0 3
20503: PUSH
20504: LD_INT 1
20506: PPUSH
20507: LD_VAR 0 3
20511: PPUSH
20512: CALL_OW 12
20516: ARRAY
20517: PPUSH
20518: LD_VAR 0 2
20522: PUSH
20523: LD_VAR 0 6
20527: ARRAY
20528: PUSH
20529: LD_VAR 0 2
20533: PUSH
20534: LD_VAR 0 6
20538: PUSH
20539: LD_INT 1
20541: PLUS
20542: ARRAY
20543: PUSH
20544: LD_VAR 0 2
20548: PUSH
20549: LD_VAR 0 6
20553: PUSH
20554: LD_INT 2
20556: PLUS
20557: ARRAY
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: LIST
20563: PPUSH
20564: CALL 42241 0 4
20568: ST_TO_ADDR
// p := p + 3 ;
20569: LD_ADDR_VAR 0 6
20573: PUSH
20574: LD_VAR 0 6
20578: PUSH
20579: LD_INT 3
20581: PLUS
20582: ST_TO_ADDR
// end ;
20583: GO 20481
20585: POP
20586: POP
// end ;
20587: LD_VAR 0 4
20591: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20592: LD_INT 0
20594: PPUSH
20595: PPUSH
20596: PPUSH
20597: PPUSH
// if not MREG_Deposit [ side ] then
20598: LD_EXP 62
20602: PUSH
20603: LD_VAR 0 1
20607: ARRAY
20608: NOT
20609: IFFALSE 20613
// exit ;
20611: GO 20790
// p := 1 ;
20613: LD_ADDR_VAR 0 4
20617: PUSH
20618: LD_INT 1
20620: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20621: LD_ADDR_VAR 0 3
20625: PUSH
20626: DOUBLE
20627: LD_INT 1
20629: DEC
20630: ST_TO_ADDR
20631: LD_EXP 62
20635: PUSH
20636: LD_VAR 0 1
20640: ARRAY
20641: PUSH
20642: LD_INT 3
20644: DIVREAL
20645: PUSH
20646: FOR_TO
20647: IFFALSE 20788
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20649: LD_EXP 62
20653: PUSH
20654: LD_VAR 0 1
20658: ARRAY
20659: PUSH
20660: LD_VAR 0 4
20664: PUSH
20665: LD_INT 2
20667: PLUS
20668: ARRAY
20669: PUSH
20670: LD_INT 2
20672: EQUAL
20673: IFFALSE 20685
// b := b_oil_mine else
20675: LD_ADDR_VAR 0 5
20679: PUSH
20680: LD_INT 29
20682: ST_TO_ADDR
20683: GO 20693
// b := b_siberite_mine ;
20685: LD_ADDR_VAR 0 5
20689: PUSH
20690: LD_INT 30
20692: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20693: LD_ADDR_EXP 47
20697: PUSH
20698: LD_EXP 47
20702: PPUSH
20703: LD_VAR 0 1
20707: PPUSH
20708: LD_VAR 0 5
20712: PPUSH
20713: LD_EXP 62
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_VAR 0 4
20728: ARRAY
20729: PUSH
20730: LD_EXP 62
20734: PUSH
20735: LD_VAR 0 1
20739: ARRAY
20740: PUSH
20741: LD_VAR 0 4
20745: PUSH
20746: LD_INT 1
20748: PLUS
20749: ARRAY
20750: PUSH
20751: LD_INT 0
20753: PPUSH
20754: LD_INT 5
20756: PPUSH
20757: CALL_OW 12
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: LIST
20766: PPUSH
20767: CALL 42241 0 4
20771: ST_TO_ADDR
// p := p + 3 ;
20772: LD_ADDR_VAR 0 4
20776: PUSH
20777: LD_VAR 0 4
20781: PUSH
20782: LD_INT 3
20784: PLUS
20785: ST_TO_ADDR
// end ;
20786: GO 20646
20788: POP
20789: POP
// end ;
20790: LD_VAR 0 2
20794: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20795: LD_INT 0
20797: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20798: LD_ADDR_EXP 47
20802: PUSH
20803: LD_EXP 47
20807: PPUSH
20808: LD_VAR 0 1
20812: PPUSH
20813: LD_INT 4
20815: PPUSH
20816: LD_VAR 0 2
20820: PPUSH
20821: CALL 42241 0 4
20825: ST_TO_ADDR
// end ;
20826: LD_VAR 0 3
20830: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20831: LD_INT 0
20833: PPUSH
// case nation of 1 , us :
20834: LD_VAR 0 2
20838: PUSH
20839: LD_INT 1
20841: DOUBLE
20842: EQUAL
20843: IFTRUE 20853
20845: LD_STRING us
20847: DOUBLE
20848: EQUAL
20849: IFTRUE 20853
20851: GO 20884
20853: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20854: LD_ADDR_EXP 47
20858: PUSH
20859: LD_EXP 47
20863: PPUSH
20864: LD_VAR 0 1
20868: PPUSH
20869: LD_INT 36
20871: PPUSH
20872: LD_VAR 0 3
20876: PPUSH
20877: CALL 42241 0 4
20881: ST_TO_ADDR
20882: GO 20935
20884: LD_INT 2
20886: DOUBLE
20887: EQUAL
20888: IFTRUE 20898
20890: LD_STRING ar
20892: DOUBLE
20893: EQUAL
20894: IFTRUE 20898
20896: GO 20934
20898: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20899: LD_ADDR_EXP 47
20903: PUSH
20904: LD_VAR 0 1
20908: PPUSH
20909: LD_INT 14
20911: PUSH
20912: LD_INT 2
20914: PUSH
20915: LD_INT 1
20917: PUSH
20918: LD_INT 31
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: LIST
20925: LIST
20926: PPUSH
20927: CALL 20940 0 2
20931: ST_TO_ADDR
20932: GO 20935
20934: POP
// end ;
20935: LD_VAR 0 4
20939: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20940: LD_INT 0
20942: PPUSH
20943: PPUSH
// for i = 1 to list do
20944: LD_ADDR_VAR 0 4
20948: PUSH
20949: DOUBLE
20950: LD_INT 1
20952: DEC
20953: ST_TO_ADDR
20954: LD_VAR 0 2
20958: PUSH
20959: FOR_TO
20960: IFFALSE 21010
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20962: LD_ADDR_EXP 52
20966: PUSH
20967: LD_EXP 52
20971: PPUSH
20972: LD_VAR 0 1
20976: PPUSH
20977: LD_EXP 52
20981: PUSH
20982: LD_VAR 0 1
20986: ARRAY
20987: PUSH
20988: LD_INT 1
20990: PLUS
20991: PPUSH
20992: LD_VAR 0 2
20996: PUSH
20997: LD_VAR 0 4
21001: ARRAY
21002: PPUSH
21003: CALL 30959 0 4
21007: ST_TO_ADDR
21008: GO 20959
21010: POP
21011: POP
// end ;
21012: LD_VAR 0 3
21016: RET
// export function MCS_GetVehicleList ( side ) ; begin
21017: LD_INT 0
21019: PPUSH
// result := MREG_ToConstruct [ side ] ;
21020: LD_ADDR_VAR 0 2
21024: PUSH
21025: LD_EXP 52
21029: PUSH
21030: LD_VAR 0 1
21034: ARRAY
21035: ST_TO_ADDR
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21041: LD_INT 0
21043: PPUSH
21044: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21045: LD_ADDR_EXP 59
21049: PUSH
21050: LD_EXP 59
21054: PPUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: LD_VAR 0 2
21064: PPUSH
21065: CALL_OW 1
21069: ST_TO_ADDR
// end ;
21070: LD_VAR 0 3
21074: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21075: LD_INT 0
21077: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21078: LD_ADDR_EXP 38
21082: PUSH
21083: LD_EXP 38
21087: PPUSH
21088: LD_VAR 0 1
21092: PPUSH
21093: LD_VAR 0 2
21097: PPUSH
21098: CALL_OW 1
21102: ST_TO_ADDR
// end ;
21103: LD_VAR 0 3
21107: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21108: LD_INT 0
21110: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21111: LD_ADDR_EXP 39
21115: PUSH
21116: LD_EXP 39
21120: PPUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: LD_VAR 0 2
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 3
21140: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21141: LD_INT 0
21143: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21144: LD_ADDR_EXP 61
21148: PUSH
21149: LD_EXP 61
21153: PPUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: LD_INT 1
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: CALL 30959 0 4
21171: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21172: LD_ADDR_EXP 61
21176: PUSH
21177: LD_EXP 61
21181: PPUSH
21182: LD_VAR 0 1
21186: PPUSH
21187: LD_INT 2
21189: PPUSH
21190: LD_VAR 0 3
21194: PPUSH
21195: CALL 30959 0 4
21199: ST_TO_ADDR
// end ;
21200: LD_VAR 0 4
21204: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21205: LD_INT 0
21207: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21208: LD_ADDR_EXP 73
21212: PUSH
21213: LD_EXP 73
21217: PPUSH
21218: LD_INT 1
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: CALL_OW 1
21230: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21231: LD_ADDR_EXP 73
21235: PUSH
21236: LD_EXP 73
21240: PPUSH
21241: LD_INT 2
21243: PPUSH
21244: LD_VAR 0 2
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21254: LD_ADDR_EXP 73
21258: PUSH
21259: LD_EXP 73
21263: PPUSH
21264: LD_INT 3
21266: PPUSH
21267: LD_VAR 0 3
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: LD_VAR 0 4
21281: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21282: LD_INT 0
21284: PPUSH
21285: PPUSH
21286: PPUSH
// if not side or not list then
21287: LD_VAR 0 1
21291: NOT
21292: PUSH
21293: LD_VAR 0 2
21297: NOT
21298: OR
21299: IFFALSE 21303
// exit ;
21301: GO 21471
// SetTech ( 20 , side , state_researched ) ;
21303: LD_INT 20
21305: PPUSH
21306: LD_VAR 0 1
21310: PPUSH
21311: LD_INT 2
21313: PPUSH
21314: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21318: LD_ADDR_EXP 62
21322: PUSH
21323: LD_EXP 62
21327: PPUSH
21328: LD_VAR 0 1
21332: PPUSH
21333: LD_VAR 0 2
21337: PPUSH
21338: CALL_OW 2
21342: ST_TO_ADDR
// p := 1 ;
21343: LD_ADDR_VAR 0 5
21347: PUSH
21348: LD_INT 1
21350: ST_TO_ADDR
// for i = 1 to list / 3 do
21351: LD_ADDR_VAR 0 4
21355: PUSH
21356: DOUBLE
21357: LD_INT 1
21359: DEC
21360: ST_TO_ADDR
21361: LD_VAR 0 2
21365: PUSH
21366: LD_INT 3
21368: DIVREAL
21369: PUSH
21370: FOR_TO
21371: IFFALSE 21469
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21373: LD_VAR 0 2
21377: PUSH
21378: LD_VAR 0 5
21382: ARRAY
21383: PPUSH
21384: LD_VAR 0 2
21388: PUSH
21389: LD_VAR 0 5
21393: PUSH
21394: LD_INT 1
21396: PLUS
21397: ARRAY
21398: PPUSH
21399: LD_VAR 0 2
21403: PUSH
21404: LD_VAR 0 5
21408: PUSH
21409: LD_INT 2
21411: PLUS
21412: ARRAY
21413: PPUSH
21414: CALL 22173 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21418: LD_VAR 0 2
21422: PUSH
21423: LD_VAR 0 5
21427: ARRAY
21428: PPUSH
21429: LD_VAR 0 2
21433: PUSH
21434: LD_VAR 0 5
21438: PUSH
21439: LD_INT 1
21441: PLUS
21442: ARRAY
21443: PPUSH
21444: LD_VAR 0 1
21448: PPUSH
21449: CALL_OW 441
// p := p + 3 ;
21453: LD_ADDR_VAR 0 5
21457: PUSH
21458: LD_VAR 0 5
21462: PUSH
21463: LD_INT 3
21465: PLUS
21466: ST_TO_ADDR
// end ;
21467: GO 21370
21469: POP
21470: POP
// end ;
21471: LD_VAR 0 3
21475: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
// if nat = nation_arabian then
21480: LD_VAR 0 2
21484: PUSH
21485: LD_INT 2
21487: EQUAL
21488: IFFALSE 21494
// exit else
21490: GO 21566
21492: GO 21552
// if nat = nation_american then
21494: LD_VAR 0 2
21498: PUSH
21499: LD_INT 1
21501: EQUAL
21502: IFFALSE 21529
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21504: LD_ADDR_VAR 0 4
21508: PUSH
21509: LD_INT 4
21511: PUSH
21512: LD_INT 3
21514: PUSH
21515: LD_INT 1
21517: PUSH
21518: LD_INT 8
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: LIST
21525: LIST
21526: ST_TO_ADDR
21527: GO 21552
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21529: LD_ADDR_VAR 0 4
21533: PUSH
21534: LD_INT 24
21536: PUSH
21537: LD_INT 3
21539: PUSH
21540: LD_INT 1
21542: PUSH
21543: LD_INT 48
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: LIST
21550: LIST
21551: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_VAR 0 4
21561: PPUSH
21562: CALL 20940 0 2
// end ;
21566: LD_VAR 0 3
21570: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21571: LD_INT 0
21573: PPUSH
21574: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21575: LD_ADDR_EXP 64
21579: PUSH
21580: LD_EXP 64
21584: PPUSH
21585: LD_VAR 0 1
21589: PPUSH
21590: LD_INT 1
21592: PPUSH
21593: LD_VAR 0 4
21597: PPUSH
21598: CALL 30959 0 4
21602: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21603: LD_ADDR_EXP 65
21607: PUSH
21608: LD_EXP 65
21612: PPUSH
21613: LD_VAR 0 1
21617: PPUSH
21618: LD_INT 1
21620: PPUSH
21621: LD_VAR 0 2
21625: PPUSH
21626: CALL 30959 0 4
21630: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21631: LD_ADDR_EXP 66
21635: PUSH
21636: LD_EXP 66
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 1
21648: PPUSH
21649: LD_VAR 0 3
21653: PPUSH
21654: CALL 30959 0 4
21658: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21659: LD_ADDR_EXP 67
21663: PUSH
21664: LD_EXP 67
21668: PPUSH
21669: LD_VAR 0 1
21673: PPUSH
21674: LD_INT 1
21676: PPUSH
21677: LD_VAR 0 5
21681: PPUSH
21682: CALL 30959 0 4
21686: ST_TO_ADDR
// while squad do
21687: LD_VAR 0 5
21691: IFFALSE 21784
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21693: LD_VAR 0 1
21697: PPUSH
21698: LD_VAR 0 5
21702: PUSH
21703: LD_INT 1
21705: ARRAY
21706: PUSH
21707: LD_VAR 0 5
21711: PUSH
21712: LD_INT 2
21714: ARRAY
21715: PUSH
21716: LD_VAR 0 5
21720: PUSH
21721: LD_INT 3
21723: ARRAY
21724: PUSH
21725: LD_VAR 0 5
21729: PUSH
21730: LD_INT 4
21732: ARRAY
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: PPUSH
21740: CALL 20940 0 2
// for i = 1 to 4 do
21744: LD_ADDR_VAR 0 7
21748: PUSH
21749: DOUBLE
21750: LD_INT 1
21752: DEC
21753: ST_TO_ADDR
21754: LD_INT 4
21756: PUSH
21757: FOR_TO
21758: IFFALSE 21780
// squad := Delete ( squad , 1 ) ;
21760: LD_ADDR_VAR 0 5
21764: PUSH
21765: LD_VAR 0 5
21769: PPUSH
21770: LD_INT 1
21772: PPUSH
21773: CALL_OW 3
21777: ST_TO_ADDR
21778: GO 21757
21780: POP
21781: POP
// end ;
21782: GO 21687
// end ;
21784: LD_VAR 0 6
21788: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21789: LD_INT 0
21791: PPUSH
21792: PPUSH
// for i = 1 to squad do
21793: LD_ADDR_VAR 0 4
21797: PUSH
21798: DOUBLE
21799: LD_INT 1
21801: DEC
21802: ST_TO_ADDR
21803: LD_VAR 0 2
21807: PUSH
21808: FOR_TO
21809: IFFALSE 21859
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21811: LD_ADDR_EXP 70
21815: PUSH
21816: LD_EXP 70
21820: PPUSH
21821: LD_VAR 0 1
21825: PPUSH
21826: LD_EXP 70
21830: PUSH
21831: LD_VAR 0 1
21835: ARRAY
21836: PUSH
21837: LD_INT 1
21839: PLUS
21840: PPUSH
21841: LD_VAR 0 2
21845: PUSH
21846: LD_VAR 0 4
21850: ARRAY
21851: PPUSH
21852: CALL 30959 0 4
21856: ST_TO_ADDR
21857: GO 21808
21859: POP
21860: POP
// while squad do
21861: LD_VAR 0 2
21865: IFFALSE 21958
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21867: LD_VAR 0 1
21871: PPUSH
21872: LD_VAR 0 2
21876: PUSH
21877: LD_INT 1
21879: ARRAY
21880: PUSH
21881: LD_VAR 0 2
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PUSH
21890: LD_VAR 0 2
21894: PUSH
21895: LD_INT 3
21897: ARRAY
21898: PUSH
21899: LD_VAR 0 2
21903: PUSH
21904: LD_INT 4
21906: ARRAY
21907: PUSH
21908: EMPTY
21909: LIST
21910: LIST
21911: LIST
21912: LIST
21913: PPUSH
21914: CALL 20940 0 2
// for i = 1 to 4 do
21918: LD_ADDR_VAR 0 4
21922: PUSH
21923: DOUBLE
21924: LD_INT 1
21926: DEC
21927: ST_TO_ADDR
21928: LD_INT 4
21930: PUSH
21931: FOR_TO
21932: IFFALSE 21954
// squad := Delete ( squad , 1 ) ;
21934: LD_ADDR_VAR 0 2
21938: PUSH
21939: LD_VAR 0 2
21943: PPUSH
21944: LD_INT 1
21946: PPUSH
21947: CALL_OW 3
21951: ST_TO_ADDR
21952: GO 21931
21954: POP
21955: POP
// end ;
21956: GO 21861
// end ;
21958: LD_VAR 0 3
21962: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21963: LD_INT 0
21965: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21966: LD_ADDR_EXP 63
21970: PUSH
21971: LD_EXP 63
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: LD_INT 1
21983: PPUSH
21984: LD_VAR 0 2
21988: PPUSH
21989: CALL 30959 0 4
21993: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21994: LD_ADDR_EXP 63
21998: PUSH
21999: LD_EXP 63
22003: PPUSH
22004: LD_VAR 0 1
22008: PPUSH
22009: LD_INT 2
22011: PPUSH
22012: LD_VAR 0 3
22016: PPUSH
22017: CALL 30959 0 4
22021: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22022: LD_ADDR_EXP 63
22026: PUSH
22027: LD_EXP 63
22031: PPUSH
22032: LD_VAR 0 1
22036: PPUSH
22037: LD_INT 3
22039: PPUSH
22040: LD_VAR 0 4
22044: PPUSH
22045: CALL 30959 0 4
22049: ST_TO_ADDR
// end ; end_of_file
22050: LD_VAR 0 5
22054: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22055: LD_INT 0
22057: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22058: LD_ADDR_EXP 43
22062: PUSH
22063: LD_EXP 43
22067: PPUSH
22068: LD_VAR 0 1
22072: PPUSH
22073: LD_INT 1
22075: PPUSH
22076: LD_VAR 0 2
22080: PPUSH
22081: CALL 30959 0 4
22085: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22086: LD_VAR 0 1
22090: PPUSH
22091: EMPTY
22092: PPUSH
22093: CALL 11556 0 2
22097: PUSH
22098: LD_INT 1
22100: ARRAY
22101: PPUSH
22102: CALL_OW 248
22106: PUSH
22107: LD_INT 1
22109: EQUAL
22110: IFFALSE 22141
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22112: LD_VAR 0 1
22116: PPUSH
22117: LD_INT 4
22119: PUSH
22120: LD_INT 1
22122: PUSH
22123: LD_INT 1
22125: PUSH
22126: LD_INT 14
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: LIST
22133: LIST
22134: PPUSH
22135: CALL 20940 0 2
22139: GO 22168
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22141: LD_VAR 0 1
22145: PPUSH
22146: LD_INT 24
22148: PUSH
22149: LD_INT 1
22151: PUSH
22152: LD_INT 1
22154: PUSH
22155: LD_INT 53
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: LIST
22162: LIST
22163: PPUSH
22164: CALL 20940 0 2
// end ;
22168: LD_VAR 0 3
22172: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22173: LD_INT 0
22175: PPUSH
// CreateDepositXY ( x , y , t ) ;
22176: LD_VAR 0 1
22180: PPUSH
22181: LD_VAR 0 2
22185: PPUSH
22186: LD_VAR 0 3
22190: PPUSH
22191: CALL_OW 62
// end ;
22195: LD_VAR 0 4
22199: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22200: LD_INT 0
22202: PPUSH
22203: PPUSH
// c := 1 ;
22204: LD_ADDR_VAR 0 5
22208: PUSH
22209: LD_INT 1
22211: ST_TO_ADDR
// case color of red :
22212: LD_VAR 0 3
22216: PUSH
22217: LD_STRING red
22219: DOUBLE
22220: EQUAL
22221: IFTRUE 22225
22223: GO 22236
22225: POP
// c = 1 ; dark-green :
22226: LD_ADDR_VAR 0 5
22230: PUSH
22231: LD_INT 1
22233: ST_TO_ADDR
22234: GO 22522
22236: LD_STRING dark-green
22238: DOUBLE
22239: EQUAL
22240: IFTRUE 22244
22242: GO 22255
22244: POP
// c = 2 ; purple :
22245: LD_ADDR_VAR 0 5
22249: PUSH
22250: LD_INT 2
22252: ST_TO_ADDR
22253: GO 22522
22255: LD_STRING purple
22257: DOUBLE
22258: EQUAL
22259: IFTRUE 22263
22261: GO 22274
22263: POP
// c = 3 ; aqua :
22264: LD_ADDR_VAR 0 5
22268: PUSH
22269: LD_INT 3
22271: ST_TO_ADDR
22272: GO 22522
22274: LD_STRING aqua
22276: DOUBLE
22277: EQUAL
22278: IFTRUE 22282
22280: GO 22293
22282: POP
// c = 4 ; grey :
22283: LD_ADDR_VAR 0 5
22287: PUSH
22288: LD_INT 4
22290: ST_TO_ADDR
22291: GO 22522
22293: LD_STRING grey
22295: DOUBLE
22296: EQUAL
22297: IFTRUE 22301
22299: GO 22312
22301: POP
// c = 5 ; lime :
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: LD_INT 5
22309: ST_TO_ADDR
22310: GO 22522
22312: LD_STRING lime
22314: DOUBLE
22315: EQUAL
22316: IFTRUE 22320
22318: GO 22331
22320: POP
// c = 6 ; tan :
22321: LD_ADDR_VAR 0 5
22325: PUSH
22326: LD_INT 6
22328: ST_TO_ADDR
22329: GO 22522
22331: LD_STRING tan
22333: DOUBLE
22334: EQUAL
22335: IFTRUE 22339
22337: GO 22350
22339: POP
// c = 7 ; pink :
22340: LD_ADDR_VAR 0 5
22344: PUSH
22345: LD_INT 7
22347: ST_TO_ADDR
22348: GO 22522
22350: LD_STRING pink
22352: DOUBLE
22353: EQUAL
22354: IFTRUE 22358
22356: GO 22369
22358: POP
// c = 8 ; green :
22359: LD_ADDR_VAR 0 5
22363: PUSH
22364: LD_INT 8
22366: ST_TO_ADDR
22367: GO 22522
22369: LD_STRING green
22371: DOUBLE
22372: EQUAL
22373: IFTRUE 22377
22375: GO 22388
22377: POP
// c = 9 ; blue :
22378: LD_ADDR_VAR 0 5
22382: PUSH
22383: LD_INT 9
22385: ST_TO_ADDR
22386: GO 22522
22388: LD_STRING blue
22390: DOUBLE
22391: EQUAL
22392: IFTRUE 22396
22394: GO 22407
22396: POP
// c = 10 ; yellow :
22397: LD_ADDR_VAR 0 5
22401: PUSH
22402: LD_INT 10
22404: ST_TO_ADDR
22405: GO 22522
22407: LD_STRING yellow
22409: DOUBLE
22410: EQUAL
22411: IFTRUE 22415
22413: GO 22426
22415: POP
// c = 11 ; brown :
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_INT 11
22423: ST_TO_ADDR
22424: GO 22522
22426: LD_STRING brown
22428: DOUBLE
22429: EQUAL
22430: IFTRUE 22434
22432: GO 22445
22434: POP
// c = 12 ; black :
22435: LD_ADDR_VAR 0 5
22439: PUSH
22440: LD_INT 12
22442: ST_TO_ADDR
22443: GO 22522
22445: LD_STRING black
22447: DOUBLE
22448: EQUAL
22449: IFTRUE 22453
22451: GO 22464
22453: POP
// c = 13 ; aqua2 :
22454: LD_ADDR_VAR 0 5
22458: PUSH
22459: LD_INT 13
22461: ST_TO_ADDR
22462: GO 22522
22464: LD_STRING aqua2
22466: DOUBLE
22467: EQUAL
22468: IFTRUE 22472
22470: GO 22483
22472: POP
// c = 14 ; orange :
22473: LD_ADDR_VAR 0 5
22477: PUSH
22478: LD_INT 14
22480: ST_TO_ADDR
22481: GO 22522
22483: LD_STRING orange
22485: DOUBLE
22486: EQUAL
22487: IFTRUE 22491
22489: GO 22502
22491: POP
// c = 15 ; white :
22492: LD_ADDR_VAR 0 5
22496: PUSH
22497: LD_INT 15
22499: ST_TO_ADDR
22500: GO 22522
22502: LD_STRING white
22504: DOUBLE
22505: EQUAL
22506: IFTRUE 22510
22508: GO 22521
22510: POP
// c = 16 ; end ;
22511: LD_ADDR_VAR 0 5
22515: PUSH
22516: LD_INT 16
22518: ST_TO_ADDR
22519: GO 22522
22521: POP
// if HexInfo ( x , y ) = 0 then
22522: LD_VAR 0 1
22526: PPUSH
22527: LD_VAR 0 2
22531: PPUSH
22532: CALL_OW 428
22536: PUSH
22537: LD_INT 0
22539: EQUAL
22540: IFFALSE 22564
// PlaceEnvironment ( x , y , 58 , c ) ;
22542: LD_VAR 0 1
22546: PPUSH
22547: LD_VAR 0 2
22551: PPUSH
22552: LD_INT 58
22554: PPUSH
22555: LD_VAR 0 5
22559: PPUSH
22560: CALL_OW 349
// end ;
22564: LD_VAR 0 4
22568: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22569: LD_INT 0
22571: PPUSH
// RemoveEnvironment ( x , y ) ;
22572: LD_VAR 0 1
22576: PPUSH
22577: LD_VAR 0 2
22581: PPUSH
22582: CALL_OW 347
// end ;
22586: LD_VAR 0 3
22590: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22591: LD_INT 0
22593: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22594: LD_INT 81
22596: PUSH
22597: LD_VAR 0 1
22601: PUSH
22602: EMPTY
22603: LIST
22604: LIST
22605: PPUSH
22606: CALL_OW 69
22610: PUSH
22611: LD_INT 0
22613: EQUAL
22614: IFFALSE 22626
// result := false else
22616: LD_ADDR_VAR 0 5
22620: PUSH
22621: LD_INT 0
22623: ST_TO_ADDR
22624: GO 22690
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22626: LD_INT 81
22628: PUSH
22629: LD_VAR 0 1
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: PUSH
22638: LD_INT 92
22640: PUSH
22641: LD_VAR 0 2
22645: PUSH
22646: LD_VAR 0 3
22650: PUSH
22651: LD_VAR 0 4
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: PPUSH
22666: CALL_OW 69
22670: IFFALSE 22682
// result := true else
22672: LD_ADDR_VAR 0 5
22676: PUSH
22677: LD_INT 1
22679: ST_TO_ADDR
22680: GO 22690
// result := false ;
22682: LD_ADDR_VAR 0 5
22686: PUSH
22687: LD_INT 0
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 5
22694: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22695: LD_INT 0
22697: PPUSH
22698: PPUSH
22699: PPUSH
22700: PPUSH
22701: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22702: LD_VAR 0 1
22706: PPUSH
22707: LD_INT 81
22709: PUSH
22710: LD_VAR 0 1
22714: PPUSH
22715: CALL_OW 255
22719: PUSH
22720: EMPTY
22721: LIST
22722: LIST
22723: PPUSH
22724: CALL_OW 69
22728: PPUSH
22729: LD_VAR 0 1
22733: PPUSH
22734: CALL_OW 74
22738: PPUSH
22739: CALL_OW 119
// dir := GetDir ( un ) ;
22743: LD_ADDR_VAR 0 4
22747: PUSH
22748: LD_VAR 0 1
22752: PPUSH
22753: CALL_OW 254
22757: ST_TO_ADDR
// dir := dir - 3 ;
22758: LD_ADDR_VAR 0 4
22762: PUSH
22763: LD_VAR 0 4
22767: PUSH
22768: LD_INT 3
22770: MINUS
22771: ST_TO_ADDR
// if dir < 0 then
22772: LD_VAR 0 4
22776: PUSH
22777: LD_INT 0
22779: LESS
22780: IFFALSE 22796
// dir := dir + 6 ;
22782: LD_ADDR_VAR 0 4
22786: PUSH
22787: LD_VAR 0 4
22791: PUSH
22792: LD_INT 6
22794: PLUS
22795: ST_TO_ADDR
// while true do
22796: LD_INT 1
22798: IFFALSE 23295
// begin coord_dist := 3 ;
22800: LD_ADDR_VAR 0 3
22804: PUSH
22805: LD_INT 3
22807: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22808: LD_ADDR_VAR 0 5
22812: PUSH
22813: LD_VAR 0 1
22817: PPUSH
22818: CALL_OW 250
22822: PPUSH
22823: LD_VAR 0 4
22827: PPUSH
22828: LD_VAR 0 3
22832: PPUSH
22833: CALL_OW 272
22837: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22838: LD_ADDR_VAR 0 6
22842: PUSH
22843: LD_VAR 0 1
22847: PPUSH
22848: CALL_OW 251
22852: PPUSH
22853: LD_VAR 0 4
22857: PPUSH
22858: LD_VAR 0 3
22862: PPUSH
22863: CALL_OW 273
22867: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 255
22877: PPUSH
22878: LD_VAR 0 1
22882: PPUSH
22883: CALL_OW 250
22887: PPUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 251
22897: PPUSH
22898: LD_INT 14
22900: PPUSH
22901: CALL 22591 0 4
22905: PUSH
22906: LD_VAR 0 5
22910: PPUSH
22911: LD_VAR 0 6
22915: PPUSH
22916: CALL_OW 351
22920: OR
22921: PUSH
22922: LD_VAR 0 5
22926: PPUSH
22927: LD_VAR 0 6
22931: PPUSH
22932: CALL_OW 488
22936: PUSH
22937: LD_INT 0
22939: EQUAL
22940: OR
22941: PUSH
22942: LD_VAR 0 5
22946: PPUSH
22947: LD_VAR 0 6
22951: PPUSH
22952: CALL_OW 546
22956: PUSH
22957: LD_INT 1
22959: EQUAL
22960: OR
22961: PUSH
22962: LD_VAR 0 5
22966: PPUSH
22967: LD_VAR 0 6
22971: PPUSH
22972: CALL_OW 428
22976: PUSH
22977: LD_INT 0
22979: NONEQUAL
22980: OR
22981: IFFALSE 23209
// begin repeat begin Wait ( 0 0$0.3 ) ;
22983: LD_INT 10
22985: PPUSH
22986: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22990: LD_ADDR_VAR 0 3
22994: PUSH
22995: LD_VAR 0 3
22999: PUSH
23000: LD_INT 1
23002: PLUS
23003: ST_TO_ADDR
// dir := dir + 1 ;
23004: LD_ADDR_VAR 0 4
23008: PUSH
23009: LD_VAR 0 4
23013: PUSH
23014: LD_INT 1
23016: PLUS
23017: ST_TO_ADDR
// if dir > 5 then
23018: LD_VAR 0 4
23022: PUSH
23023: LD_INT 5
23025: GREATER
23026: IFFALSE 23036
// dir = 0 ;
23028: LD_ADDR_VAR 0 4
23032: PUSH
23033: LD_INT 0
23035: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23036: LD_ADDR_VAR 0 5
23040: PUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: CALL_OW 250
23050: PPUSH
23051: LD_VAR 0 4
23055: PPUSH
23056: LD_VAR 0 3
23060: PPUSH
23061: CALL_OW 272
23065: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23066: LD_ADDR_VAR 0 6
23070: PUSH
23071: LD_VAR 0 1
23075: PPUSH
23076: CALL_OW 251
23080: PPUSH
23081: LD_VAR 0 4
23085: PPUSH
23086: LD_VAR 0 3
23090: PPUSH
23091: CALL_OW 273
23095: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23096: LD_VAR 0 1
23100: PPUSH
23101: CALL_OW 255
23105: PPUSH
23106: LD_VAR 0 1
23110: PPUSH
23111: CALL_OW 250
23115: PPUSH
23116: LD_VAR 0 1
23120: PPUSH
23121: CALL_OW 251
23125: PPUSH
23126: LD_INT 14
23128: PPUSH
23129: CALL 22591 0 4
23133: NOT
23134: PUSH
23135: LD_VAR 0 5
23139: PPUSH
23140: LD_VAR 0 6
23144: PPUSH
23145: CALL_OW 351
23149: NOT
23150: AND
23151: PUSH
23152: LD_VAR 0 5
23156: PPUSH
23157: LD_VAR 0 6
23161: PPUSH
23162: CALL_OW 488
23166: AND
23167: PUSH
23168: LD_VAR 0 5
23172: PPUSH
23173: LD_VAR 0 6
23177: PPUSH
23178: CALL_OW 546
23182: PUSH
23183: LD_INT 0
23185: EQUAL
23186: AND
23187: PUSH
23188: LD_VAR 0 5
23192: PPUSH
23193: LD_VAR 0 6
23197: PPUSH
23198: CALL_OW 428
23202: PUSH
23203: LD_INT 0
23205: EQUAL
23206: AND
23207: IFFALSE 22983
// end ; ComMoveXY ( un , x , y ) ;
23209: LD_VAR 0 1
23213: PPUSH
23214: LD_VAR 0 5
23218: PPUSH
23219: LD_VAR 0 6
23223: PPUSH
23224: CALL_OW 111
// Wait ( 0 0$1 ) ;
23228: LD_INT 35
23230: PPUSH
23231: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23235: LD_VAR 0 1
23239: PPUSH
23240: LD_INT 81
23242: PUSH
23243: LD_VAR 0 1
23247: PPUSH
23248: CALL_OW 255
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 69
23261: PPUSH
23262: LD_VAR 0 1
23266: PPUSH
23267: CALL_OW 74
23271: PPUSH
23272: CALL_OW 296
23276: PUSH
23277: LD_INT 14
23279: GREATEREQUAL
23280: IFFALSE 23293
// begin ComStop ( un ) ;
23282: LD_VAR 0 1
23286: PPUSH
23287: CALL_OW 141
// break ;
23291: GO 23295
// end ; end ;
23293: GO 22796
// end ;
23295: LD_VAR 0 2
23299: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23300: LD_INT 0
23302: PPUSH
23303: PPUSH
23304: PPUSH
23305: PPUSH
23306: PPUSH
23307: PPUSH
23308: PPUSH
23309: PPUSH
// x := GetX ( unit ) ;
23310: LD_ADDR_VAR 0 3
23314: PUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: CALL_OW 250
23324: ST_TO_ADDR
// y := GetY ( unit ) ;
23325: LD_ADDR_VAR 0 4
23329: PUSH
23330: LD_VAR 0 1
23334: PPUSH
23335: CALL_OW 251
23339: ST_TO_ADDR
// i := 0 ;
23340: LD_ADDR_VAR 0 8
23344: PUSH
23345: LD_INT 0
23347: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23348: LD_VAR 0 1
23352: PPUSH
23353: LD_INT 81
23355: PUSH
23356: LD_VAR 0 1
23360: PPUSH
23361: CALL_OW 255
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: PPUSH
23370: CALL_OW 69
23374: PPUSH
23375: LD_VAR 0 1
23379: PPUSH
23380: CALL_OW 74
23384: PPUSH
23385: CALL_OW 119
// dir := GetDir ( unit ) ;
23389: LD_ADDR_VAR 0 7
23393: PUSH
23394: LD_VAR 0 1
23398: PPUSH
23399: CALL_OW 254
23403: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23404: LD_ADDR_VAR 0 9
23408: PUSH
23409: LD_INT 0
23411: PPUSH
23412: LD_INT 1
23414: PPUSH
23415: CALL_OW 12
23419: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23420: LD_INT 10
23422: PPUSH
23423: CALL_OW 67
// if mode then
23427: LD_VAR 0 9
23431: IFFALSE 23449
// dir := dir + 1 else
23433: LD_ADDR_VAR 0 7
23437: PUSH
23438: LD_VAR 0 7
23442: PUSH
23443: LD_INT 1
23445: PLUS
23446: ST_TO_ADDR
23447: GO 23463
// dir := dir - 1 ;
23449: LD_ADDR_VAR 0 7
23453: PUSH
23454: LD_VAR 0 7
23458: PUSH
23459: LD_INT 1
23461: MINUS
23462: ST_TO_ADDR
// if ( dir < 0 ) then
23463: LD_VAR 0 7
23467: PUSH
23468: LD_INT 0
23470: LESS
23471: IFFALSE 23481
// dir := 5 ;
23473: LD_ADDR_VAR 0 7
23477: PUSH
23478: LD_INT 5
23480: ST_TO_ADDR
// if ( dir > 5 ) then
23481: LD_VAR 0 7
23485: PUSH
23486: LD_INT 5
23488: GREATER
23489: IFFALSE 23499
// dir := 0 ;
23491: LD_ADDR_VAR 0 7
23495: PUSH
23496: LD_INT 0
23498: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23499: LD_ADDR_VAR 0 5
23503: PUSH
23504: LD_VAR 0 3
23508: PPUSH
23509: LD_VAR 0 7
23513: PPUSH
23514: LD_INT 4
23516: PPUSH
23517: CALL_OW 272
23521: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23522: LD_ADDR_VAR 0 6
23526: PUSH
23527: LD_VAR 0 4
23531: PPUSH
23532: LD_VAR 0 7
23536: PPUSH
23537: LD_INT 4
23539: PPUSH
23540: CALL_OW 273
23544: ST_TO_ADDR
// i := i + 1 ;
23545: LD_ADDR_VAR 0 8
23549: PUSH
23550: LD_VAR 0 8
23554: PUSH
23555: LD_INT 1
23557: PLUS
23558: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 255
23568: PPUSH
23569: LD_VAR 0 5
23573: PPUSH
23574: LD_VAR 0 6
23578: PPUSH
23579: LD_INT 14
23581: PPUSH
23582: CALL 22591 0 4
23586: PUSH
23587: LD_INT 0
23589: EQUAL
23590: PUSH
23591: LD_VAR 0 5
23595: PPUSH
23596: LD_VAR 0 6
23600: PPUSH
23601: CALL_OW 546
23605: PUSH
23606: LD_INT 0
23608: EQUAL
23609: AND
23610: PUSH
23611: LD_VAR 0 5
23615: PPUSH
23616: LD_VAR 0 6
23620: PPUSH
23621: CALL_OW 428
23625: PUSH
23626: LD_INT 0
23628: EQUAL
23629: AND
23630: IFFALSE 23634
// break ;
23632: GO 23644
// end until i > 4 ;
23634: LD_VAR 0 8
23638: PUSH
23639: LD_INT 4
23641: GREATER
23642: IFFALSE 23420
// if x2 and y2 then
23644: LD_VAR 0 5
23648: PUSH
23649: LD_VAR 0 6
23653: AND
23654: IFFALSE 23677
// result := [ x2 , y2 ] else
23656: LD_ADDR_VAR 0 2
23660: PUSH
23661: LD_VAR 0 5
23665: PUSH
23666: LD_VAR 0 6
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: ST_TO_ADDR
23675: GO 23706
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23677: LD_ADDR_VAR 0 2
23681: PUSH
23682: LD_VAR 0 1
23686: PPUSH
23687: CALL_OW 250
23691: PUSH
23692: LD_VAR 0 1
23696: PPUSH
23697: CALL_OW 251
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: ST_TO_ADDR
// end ;
23706: LD_VAR 0 2
23710: RET
// export function MCT_Hex ( x , y ) ; begin
23711: LD_INT 0
23713: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23714: LD_ADDR_VAR 0 3
23718: PUSH
23719: LD_VAR 0 1
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: CALL_OW 546
23733: PUSH
23734: LD_VAR 0 1
23738: PPUSH
23739: LD_VAR 0 2
23743: PPUSH
23744: CALL_OW 428
23748: PUSH
23749: EMPTY
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: ST_TO_ADDR
// end ;
23756: LD_VAR 0 3
23760: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23761: LD_INT 0
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23776: LD_ADDR_VAR 0 10
23780: PUSH
23781: LD_EXP 61
23785: PUSH
23786: LD_VAR 0 1
23790: ARRAY
23791: PUSH
23792: LD_INT 1
23794: ARRAY
23795: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23796: LD_ADDR_VAR 0 11
23800: PUSH
23801: LD_EXP 61
23805: PUSH
23806: LD_VAR 0 1
23810: ARRAY
23811: PUSH
23812: LD_INT 2
23814: ARRAY
23815: ST_TO_ADDR
// collectors := [ ] ;
23816: LD_ADDR_VAR 0 12
23820: PUSH
23821: EMPTY
23822: ST_TO_ADDR
// is_cargo := false ;
23823: LD_ADDR_VAR 0 13
23827: PUSH
23828: LD_INT 0
23830: ST_TO_ADDR
// if isTest then
23831: LD_EXP 1
23835: IFFALSE 23841
// TimerStart ( ) ;
23837: CALL_OW 548
// if MCF_Cargo ( side ) then
23841: LD_VAR 0 1
23845: PPUSH
23846: CALL 11772 0 1
23850: IFFALSE 23877
// begin collectors := MCF_Cargo ( side ) ;
23852: LD_ADDR_VAR 0 12
23856: PUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL 11772 0 1
23866: ST_TO_ADDR
// is_cargo := true ;
23867: LD_ADDR_VAR 0 13
23871: PUSH
23872: LD_INT 1
23874: ST_TO_ADDR
// end else
23875: GO 24026
// begin if MCF_ApeSpec ( side , engineer ) then
23877: LD_VAR 0 1
23881: PPUSH
23882: LD_STRING engineer
23884: PPUSH
23885: CALL 11918 0 2
23889: IFFALSE 23909
// collectors := MCF_ApeSpec ( side , engineer ) ;
23891: LD_ADDR_VAR 0 12
23895: PUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: LD_STRING engineer
23903: PPUSH
23904: CALL 11918 0 2
23908: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23909: LD_VAR 0 1
23913: PPUSH
23914: LD_INT 2
23916: PPUSH
23917: EMPTY
23918: PPUSH
23919: CALL 11504 0 3
23923: IFFALSE 24026
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23925: LD_ADDR_VAR 0 7
23929: PUSH
23930: LD_VAR 0 1
23934: PPUSH
23935: LD_INT 2
23937: PPUSH
23938: EMPTY
23939: PPUSH
23940: CALL 11504 0 3
23944: ST_TO_ADDR
// if z > 5 then
23945: LD_VAR 0 7
23949: PUSH
23950: LD_INT 5
23952: GREATER
23953: IFFALSE 23965
// t1 := 5 else
23955: LD_ADDR_VAR 0 8
23959: PUSH
23960: LD_INT 5
23962: ST_TO_ADDR
23963: GO 23975
// t1 := z ;
23965: LD_ADDR_VAR 0 8
23969: PUSH
23970: LD_VAR 0 7
23974: ST_TO_ADDR
// for t2 = 1 to t1 do
23975: LD_ADDR_VAR 0 9
23979: PUSH
23980: DOUBLE
23981: LD_INT 1
23983: DEC
23984: ST_TO_ADDR
23985: LD_VAR 0 8
23989: PUSH
23990: FOR_TO
23991: IFFALSE 24024
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23993: LD_ADDR_VAR 0 12
23997: PUSH
23998: LD_VAR 0 12
24002: PPUSH
24003: LD_INT 1
24005: PPUSH
24006: LD_VAR 0 7
24010: PUSH
24011: LD_VAR 0 9
24015: ARRAY
24016: PPUSH
24017: CALL_OW 2
24021: ST_TO_ADDR
24022: GO 23990
24024: POP
24025: POP
// end ; end ; if not mode then
24026: LD_VAR 0 10
24030: NOT
24031: IFFALSE 24037
// exit else
24033: GO 24296
24035: GO 24296
// begin if collectors then
24037: LD_VAR 0 12
24041: IFFALSE 24296
// for i in areas do
24043: LD_ADDR_VAR 0 3
24047: PUSH
24048: LD_VAR 0 11
24052: PUSH
24053: FOR_IN
24054: IFFALSE 24294
// if GetListOfCratesInArea ( i ) then
24056: LD_VAR 0 3
24060: PPUSH
24061: CALL_OW 435
24065: IFFALSE 24292
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24067: LD_ADDR_VAR 0 5
24071: PUSH
24072: LD_VAR 0 3
24076: PPUSH
24077: CALL_OW 435
24081: PUSH
24082: LD_INT 1
24084: ARRAY
24085: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24086: LD_ADDR_VAR 0 6
24090: PUSH
24091: LD_VAR 0 3
24095: PPUSH
24096: CALL_OW 435
24100: PUSH
24101: LD_INT 2
24103: ARRAY
24104: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24105: LD_VAR 0 13
24109: PUSH
24110: LD_VAR 0 12
24114: PUSH
24115: LD_INT 1
24117: ARRAY
24118: PPUSH
24119: CALL_OW 110
24123: PUSH
24124: LD_INT 0
24126: EQUAL
24127: AND
24128: IFFALSE 24190
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24130: LD_VAR 0 12
24134: PUSH
24135: LD_INT 1
24137: ARRAY
24138: PPUSH
24139: CALL_OW 314
24143: NOT
24144: PUSH
24145: LD_VAR 0 12
24149: PUSH
24150: LD_INT 1
24152: ARRAY
24153: PPUSH
24154: CALL_OW 110
24158: PUSH
24159: LD_INT 0
24161: EQUAL
24162: AND
24163: IFFALSE 24188
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24165: LD_VAR 0 12
24169: PUSH
24170: LD_INT 1
24172: ARRAY
24173: PPUSH
24174: LD_VAR 0 5
24178: PPUSH
24179: LD_VAR 0 6
24183: PPUSH
24184: CALL_OW 117
// end ; end else
24188: GO 24276
// begin for j = 1 to collectors do
24190: LD_ADDR_VAR 0 4
24194: PUSH
24195: DOUBLE
24196: LD_INT 1
24198: DEC
24199: ST_TO_ADDR
24200: LD_VAR 0 12
24204: PUSH
24205: FOR_TO
24206: IFFALSE 24274
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24208: LD_VAR 0 12
24212: PUSH
24213: LD_VAR 0 4
24217: ARRAY
24218: PPUSH
24219: CALL_OW 314
24223: NOT
24224: PUSH
24225: LD_VAR 0 12
24229: PUSH
24230: LD_VAR 0 4
24234: ARRAY
24235: PPUSH
24236: CALL_OW 110
24240: PUSH
24241: LD_INT 0
24243: EQUAL
24244: AND
24245: IFFALSE 24272
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24247: LD_VAR 0 12
24251: PUSH
24252: LD_VAR 0 4
24256: ARRAY
24257: PPUSH
24258: LD_VAR 0 5
24262: PPUSH
24263: LD_VAR 0 6
24267: PPUSH
24268: CALL 24667 0 3
// end ;
24272: GO 24205
24274: POP
24275: POP
// end ; if isTest then
24276: LD_EXP 1
24280: IFFALSE 24292
// begin debug_time := TimerEnd ( ) ;
24282: LD_ADDR_VAR 0 14
24286: PUSH
24287: CALL_OW 549
24291: ST_TO_ADDR
// end ; end ;
24292: GO 24053
24294: POP
24295: POP
// end ; end ;
24296: LD_VAR 0 2
24300: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24301: LD_INT 0
24303: PPUSH
24304: PPUSH
24305: PPUSH
24306: PPUSH
24307: PPUSH
24308: PPUSH
// if not area then
24309: LD_VAR 0 1
24313: NOT
24314: IFFALSE 24320
// exit else
24316: GO 24582
24318: GO 24582
// if tick mod interval = 0 and Prob ( percent ) then
24320: LD_OWVAR 1
24324: PUSH
24325: LD_VAR 0 4
24329: MOD
24330: PUSH
24331: LD_INT 0
24333: EQUAL
24334: PUSH
24335: LD_VAR 0 3
24339: PPUSH
24340: CALL_OW 13
24344: AND
24345: IFFALSE 24582
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24347: LD_VAR 0 1
24351: PPUSH
24352: CALL_OW 435
24356: PUSH
24357: LD_VAR 0 5
24361: LESS
24362: PUSH
24363: LD_VAR 0 5
24367: PUSH
24368: LD_INT 0
24370: EQUAL
24371: OR
24372: IFFALSE 24582
// begin Randomize ;
24374: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24378: LD_ADDR_VAR 0 7
24382: PUSH
24383: LD_INT 1
24385: PPUSH
24386: LD_VAR 0 2
24390: PPUSH
24391: CALL_OW 12
24395: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24396: LD_ADDR_VAR 0 9
24400: PUSH
24401: LD_VAR 0 1
24405: PPUSH
24406: LD_INT 0
24408: PPUSH
24409: CALL_OW 517
24413: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24414: LD_ADDR_VAR 0 8
24418: PUSH
24419: LD_INT 1
24421: PPUSH
24422: LD_VAR 0 9
24426: PUSH
24427: LD_INT 1
24429: ARRAY
24430: PPUSH
24431: CALL_OW 12
24435: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24436: LD_VAR 0 9
24440: PUSH
24441: LD_INT 1
24443: ARRAY
24444: PUSH
24445: LD_VAR 0 8
24449: ARRAY
24450: PPUSH
24451: LD_VAR 0 9
24455: PUSH
24456: LD_INT 2
24458: ARRAY
24459: PUSH
24460: LD_VAR 0 8
24464: ARRAY
24465: PPUSH
24466: CALL_OW 428
24470: PUSH
24471: LD_INT 0
24473: GREATER
24474: PUSH
24475: LD_VAR 0 9
24479: PUSH
24480: LD_INT 1
24482: ARRAY
24483: PUSH
24484: LD_VAR 0 8
24488: ARRAY
24489: PPUSH
24490: LD_VAR 0 9
24494: PUSH
24495: LD_INT 2
24497: ARRAY
24498: PUSH
24499: LD_VAR 0 8
24503: ARRAY
24504: PPUSH
24505: CALL_OW 284
24509: PUSH
24510: LD_INT 0
24512: GREATER
24513: AND
24514: IFFALSE 24540
// c := Rand ( 1 , tmp [ 1 ] ) ;
24516: LD_ADDR_VAR 0 8
24520: PUSH
24521: LD_INT 1
24523: PPUSH
24524: LD_VAR 0 9
24528: PUSH
24529: LD_INT 1
24531: ARRAY
24532: PPUSH
24533: CALL_OW 12
24537: ST_TO_ADDR
24538: GO 24436
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24540: LD_VAR 0 7
24544: PPUSH
24545: LD_VAR 0 9
24549: PUSH
24550: LD_INT 1
24552: ARRAY
24553: PUSH
24554: LD_VAR 0 8
24558: ARRAY
24559: PPUSH
24560: LD_VAR 0 9
24564: PUSH
24565: LD_INT 2
24567: ARRAY
24568: PUSH
24569: LD_VAR 0 8
24573: ARRAY
24574: PPUSH
24575: LD_INT 1
24577: PPUSH
24578: CALL_OW 54
// end ; end ; end ;
24582: LD_VAR 0 6
24586: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24587: LD_INT 0
24589: PPUSH
24590: PPUSH
// if not MREG_Crates then
24591: LD_EXP 35
24595: NOT
24596: IFFALSE 24600
// exit ;
24598: GO 24662
// for i = MREG_Crates downto 1 do
24600: LD_ADDR_VAR 0 2
24604: PUSH
24605: DOUBLE
24606: LD_EXP 35
24610: INC
24611: ST_TO_ADDR
24612: LD_INT 1
24614: PUSH
24615: FOR_DOWNTO
24616: IFFALSE 24660
// if MREG_Crates [ i ] [ 3 ] = 0 then
24618: LD_EXP 35
24622: PUSH
24623: LD_VAR 0 2
24627: ARRAY
24628: PUSH
24629: LD_INT 3
24631: ARRAY
24632: PUSH
24633: LD_INT 0
24635: EQUAL
24636: IFFALSE 24658
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24638: LD_ADDR_EXP 35
24642: PUSH
24643: LD_EXP 35
24647: PPUSH
24648: LD_VAR 0 2
24652: PPUSH
24653: CALL_OW 3
24657: ST_TO_ADDR
24658: GO 24615
24660: POP
24661: POP
// end ;
24662: LD_VAR 0 1
24666: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24667: LD_INT 0
24669: PPUSH
24670: PPUSH
24671: PPUSH
24672: PPUSH
// if not unit then
24673: LD_VAR 0 1
24677: NOT
24678: IFFALSE 24682
// exit ;
24680: GO 24817
// if HasTask ( unit ) or not CanCarry ( unit ) then
24682: LD_VAR 0 1
24686: PPUSH
24687: CALL_OW 314
24691: PUSH
24692: LD_VAR 0 1
24696: PPUSH
24697: CALL_OW 280
24701: NOT
24702: OR
24703: IFFALSE 24707
// exit ;
24705: GO 24817
// side := GetSide ( unit ) ;
24707: LD_ADDR_VAR 0 6
24711: PUSH
24712: LD_VAR 0 1
24716: PPUSH
24717: CALL_OW 255
24721: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24722: LD_ADDR_VAR 0 7
24726: PUSH
24727: LD_VAR 0 6
24731: PPUSH
24732: LD_INT 30
24734: PUSH
24735: LD_INT 1
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PPUSH
24742: CALL 11421 0 2
24746: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24747: LD_VAR 0 1
24751: PPUSH
24752: CALL_OW 281
24756: PUSH
24757: LD_VAR 0 7
24761: NOT
24762: OR
24763: IFFALSE 24769
// exit else
24765: GO 24817
24767: GO 24817
// if GetResourceAmountXY ( x , y ) then
24769: LD_VAR 0 2
24773: PPUSH
24774: LD_VAR 0 3
24778: PPUSH
24779: CALL_OW 284
24783: IFFALSE 24815
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24785: LD_VAR 0 1
24789: PPUSH
24790: LD_VAR 0 2
24794: PPUSH
24795: LD_VAR 0 3
24799: PPUSH
24800: LD_VAR 0 7
24804: PUSH
24805: LD_INT 1
24807: ARRAY
24808: PPUSH
24809: CALL 32123 0 4
// end else
24813: GO 24817
// exit ;
24815: GO 24817
// end ;
24817: LD_VAR 0 4
24821: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24822: LD_INT 0
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
// result := 0 ;
24829: LD_ADDR_VAR 0 2
24833: PUSH
24834: LD_INT 0
24836: ST_TO_ADDR
// p := 1 ;
24837: LD_ADDR_VAR 0 4
24841: PUSH
24842: LD_INT 1
24844: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24845: LD_ADDR_VAR 0 3
24849: PUSH
24850: DOUBLE
24851: LD_INT 1
24853: DEC
24854: ST_TO_ADDR
24855: LD_EXP 64
24859: PUSH
24860: LD_VAR 0 1
24864: ARRAY
24865: PUSH
24866: LD_INT 1
24868: ARRAY
24869: PUSH
24870: LD_INT 2
24872: DIVREAL
24873: PUSH
24874: FOR_TO
24875: IFFALSE 24999
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24877: LD_ADDR_VAR 0 5
24881: PUSH
24882: LD_INT 81
24884: PUSH
24885: LD_VAR 0 1
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 92
24896: PUSH
24897: LD_EXP 64
24901: PUSH
24902: LD_VAR 0 1
24906: ARRAY
24907: PUSH
24908: LD_INT 1
24910: ARRAY
24911: PUSH
24912: LD_VAR 0 4
24916: ARRAY
24917: PUSH
24918: LD_EXP 64
24922: PUSH
24923: LD_VAR 0 1
24927: ARRAY
24928: PUSH
24929: LD_INT 1
24931: ARRAY
24932: PUSH
24933: LD_VAR 0 4
24937: PUSH
24938: LD_INT 1
24940: PLUS
24941: ARRAY
24942: PUSH
24943: LD_INT 12
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: ST_TO_ADDR
// if tmp then
24961: LD_VAR 0 5
24965: IFFALSE 24983
// result := result ^ tmp ;
24967: LD_ADDR_VAR 0 2
24971: PUSH
24972: LD_VAR 0 2
24976: PUSH
24977: LD_VAR 0 5
24981: ADD
24982: ST_TO_ADDR
// p := p + 2 ;
24983: LD_ADDR_VAR 0 4
24987: PUSH
24988: LD_VAR 0 4
24992: PUSH
24993: LD_INT 2
24995: PLUS
24996: ST_TO_ADDR
// end ;
24997: GO 24874
24999: POP
25000: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25001: LD_EXP 65
25005: PUSH
25006: LD_VAR 0 1
25010: ARRAY
25011: PPUSH
25012: LD_INT 81
25014: PUSH
25015: LD_VAR 0 1
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PPUSH
25024: CALL_OW 70
25028: IFFALSE 25069
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25030: LD_ADDR_VAR 0 2
25034: PUSH
25035: LD_VAR 0 2
25039: PUSH
25040: LD_EXP 65
25044: PUSH
25045: LD_VAR 0 1
25049: ARRAY
25050: PPUSH
25051: LD_INT 81
25053: PUSH
25054: LD_VAR 0 1
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PPUSH
25063: CALL_OW 70
25067: ADD
25068: ST_TO_ADDR
// end ; end_of_file
25069: LD_VAR 0 2
25073: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25074: LD_INT 0
25076: PPUSH
25077: PPUSH
25078: PPUSH
// pom := GetBase ( fac ) ;
25079: LD_ADDR_VAR 0 5
25083: PUSH
25084: LD_VAR 0 1
25088: PPUSH
25089: CALL_OW 274
25093: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25094: LD_ADDR_VAR 0 4
25098: PUSH
25099: LD_VAR 0 2
25103: PUSH
25104: LD_INT 1
25106: ARRAY
25107: PPUSH
25108: LD_VAR 0 2
25112: PUSH
25113: LD_INT 2
25115: ARRAY
25116: PPUSH
25117: LD_VAR 0 2
25121: PUSH
25122: LD_INT 3
25124: ARRAY
25125: PPUSH
25126: LD_VAR 0 2
25130: PUSH
25131: LD_INT 4
25133: ARRAY
25134: PPUSH
25135: CALL_OW 449
25139: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25140: LD_VAR 0 5
25144: PPUSH
25145: LD_INT 1
25147: PPUSH
25148: CALL_OW 275
25152: PUSH
25153: LD_VAR 0 4
25157: PUSH
25158: LD_INT 1
25160: ARRAY
25161: GREATEREQUAL
25162: PUSH
25163: LD_VAR 0 5
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 275
25175: PUSH
25176: LD_VAR 0 4
25180: PUSH
25181: LD_INT 2
25183: ARRAY
25184: GREATEREQUAL
25185: AND
25186: PUSH
25187: LD_VAR 0 5
25191: PPUSH
25192: LD_INT 3
25194: PPUSH
25195: CALL_OW 275
25199: PUSH
25200: LD_VAR 0 4
25204: PUSH
25205: LD_INT 3
25207: ARRAY
25208: GREATEREQUAL
25209: AND
25210: IFFALSE 25222
// result := true else
25212: LD_ADDR_VAR 0 3
25216: PUSH
25217: LD_INT 1
25219: ST_TO_ADDR
25220: GO 25230
// result := false ;
25222: LD_ADDR_VAR 0 3
25226: PUSH
25227: LD_INT 0
25229: ST_TO_ADDR
// end ;
25230: LD_VAR 0 3
25234: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25235: LD_INT 0
25237: PPUSH
25238: PPUSH
25239: PPUSH
// result := false ;
25240: LD_ADDR_VAR 0 3
25244: PUSH
25245: LD_INT 0
25247: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25248: LD_ADDR_VAR 0 4
25252: PUSH
25253: LD_EXP 52
25257: PUSH
25258: LD_VAR 0 1
25262: ARRAY
25263: ST_TO_ADDR
// if tmp then
25264: LD_VAR 0 4
25268: IFFALSE 25320
// for i = 1 to tmp do
25270: LD_ADDR_VAR 0 5
25274: PUSH
25275: DOUBLE
25276: LD_INT 1
25278: DEC
25279: ST_TO_ADDR
25280: LD_VAR 0 4
25284: PUSH
25285: FOR_TO
25286: IFFALSE 25318
// if component = tmp [ i ] then
25288: LD_VAR 0 2
25292: PUSH
25293: LD_VAR 0 4
25297: PUSH
25298: LD_VAR 0 5
25302: ARRAY
25303: EQUAL
25304: IFFALSE 25316
// begin result := true ;
25306: LD_ADDR_VAR 0 3
25310: PUSH
25311: LD_INT 1
25313: ST_TO_ADDR
// break ;
25314: GO 25318
// end ;
25316: GO 25285
25318: POP
25319: POP
// end ;
25320: LD_VAR 0 3
25324: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25325: LD_INT 0
25327: PPUSH
25328: PPUSH
25329: PPUSH
// if fac then
25330: LD_VAR 0 2
25334: IFFALSE 25569
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_VAR 0 3
25345: PPUSH
25346: CALL 25074 0 2
25350: PUSH
25351: LD_VAR 0 2
25355: PPUSH
25356: CALL_OW 461
25360: PUSH
25361: LD_INT 2
25363: EQUAL
25364: AND
25365: PUSH
25366: LD_VAR 0 2
25370: PPUSH
25371: LD_VAR 0 3
25375: PUSH
25376: LD_INT 1
25378: ARRAY
25379: PPUSH
25380: LD_VAR 0 3
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: PPUSH
25389: LD_VAR 0 3
25393: PUSH
25394: LD_INT 3
25396: ARRAY
25397: PPUSH
25398: LD_VAR 0 3
25402: PUSH
25403: LD_INT 4
25405: ARRAY
25406: PPUSH
25407: CALL_OW 448
25411: AND
25412: IFFALSE 25559
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25414: LD_VAR 0 2
25418: PPUSH
25419: LD_VAR 0 3
25423: PUSH
25424: LD_INT 1
25426: ARRAY
25427: PPUSH
25428: LD_VAR 0 3
25432: PUSH
25433: LD_INT 2
25435: ARRAY
25436: PPUSH
25437: LD_VAR 0 3
25441: PUSH
25442: LD_INT 3
25444: ARRAY
25445: PPUSH
25446: LD_VAR 0 3
25450: PUSH
25451: LD_INT 4
25453: ARRAY
25454: PPUSH
25455: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25459: LD_ADDR_VAR 0 6
25463: PUSH
25464: LD_EXP 52
25468: PUSH
25469: LD_VAR 0 1
25473: ARRAY
25474: ST_TO_ADDR
// for i = 4 downto 1 do
25475: LD_ADDR_VAR 0 5
25479: PUSH
25480: DOUBLE
25481: LD_INT 4
25483: INC
25484: ST_TO_ADDR
25485: LD_INT 1
25487: PUSH
25488: FOR_DOWNTO
25489: IFFALSE 25522
// tab := Remove ( tab , list [ i ] , true ) ;
25491: LD_ADDR_VAR 0 6
25495: PUSH
25496: LD_VAR 0 6
25500: PPUSH
25501: LD_VAR 0 3
25505: PUSH
25506: LD_VAR 0 5
25510: ARRAY
25511: PPUSH
25512: LD_INT 1
25514: PPUSH
25515: CALL 31118 0 3
25519: ST_TO_ADDR
25520: GO 25488
25522: POP
25523: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25524: LD_ADDR_EXP 52
25528: PUSH
25529: LD_EXP 52
25533: PPUSH
25534: LD_VAR 0 1
25538: PPUSH
25539: LD_VAR 0 6
25543: PPUSH
25544: CALL_OW 1
25548: ST_TO_ADDR
// result := true ;
25549: LD_ADDR_VAR 0 4
25553: PUSH
25554: LD_INT 1
25556: ST_TO_ADDR
// end else
25557: GO 25567
// result := false ;
25559: LD_ADDR_VAR 0 4
25563: PUSH
25564: LD_INT 0
25566: ST_TO_ADDR
// end else
25567: GO 25577
// result := false ;
25569: LD_ADDR_VAR 0 4
25573: PUSH
25574: LD_INT 0
25576: ST_TO_ADDR
// end ;
25577: LD_VAR 0 4
25581: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
// if not veh then
25586: LD_VAR 0 2
25590: NOT
25591: IFFALSE 25595
// exit ;
25593: GO 25769
// if MREG_Parking [ side ] then
25595: LD_EXP 59
25599: PUSH
25600: LD_VAR 0 1
25604: ARRAY
25605: IFFALSE 25769
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25607: LD_VAR 0 2
25611: PPUSH
25612: LD_EXP 59
25616: PUSH
25617: LD_VAR 0 1
25621: ARRAY
25622: PPUSH
25623: CALL_OW 308
25627: NOT
25628: IFFALSE 25769
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25630: LD_VAR 0 2
25634: PPUSH
25635: LD_EXP 59
25639: PUSH
25640: LD_VAR 0 1
25644: ARRAY
25645: PPUSH
25646: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25650: LD_VAR 0 2
25654: PPUSH
25655: CALL_OW 263
25659: PUSH
25660: LD_INT 1
25662: EQUAL
25663: IFFALSE 25769
// begin i := GetDriver ( veh ) ;
25665: LD_ADDR_VAR 0 4
25669: PUSH
25670: LD_VAR 0 2
25674: PPUSH
25675: CALL 31653 0 1
25679: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25680: LD_INT 35
25682: PPUSH
25683: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25687: LD_VAR 0 2
25691: PPUSH
25692: LD_EXP 59
25696: PUSH
25697: LD_VAR 0 1
25701: ARRAY
25702: PPUSH
25703: CALL_OW 308
25707: PUSH
25708: LD_VAR 0 2
25712: PPUSH
25713: CALL_OW 301
25717: OR
25718: IFFALSE 25680
// ComExitVehicle ( i ) ;
25720: LD_VAR 0 4
25724: PPUSH
25725: CALL_OW 121
// Wait ( 1 ) ;
25729: LD_INT 1
25731: PPUSH
25732: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25736: LD_VAR 0 4
25740: PPUSH
25741: LD_VAR 0 1
25745: PPUSH
25746: LD_INT 30
25748: PUSH
25749: LD_INT 3
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PPUSH
25756: CALL 11421 0 2
25760: PUSH
25761: LD_INT 1
25763: ARRAY
25764: PPUSH
25765: CALL_OW 180
// end ; end ; end ;
25769: LD_VAR 0 3
25773: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25774: LD_INT 0
25776: PPUSH
25777: PPUSH
25778: PPUSH
25779: PPUSH
25780: PPUSH
25781: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 30
25789: PUSH
25790: LD_INT 3
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PPUSH
25797: CALL 11421 0 2
25801: IFFALSE 25985
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25803: LD_VAR 0 1
25807: PPUSH
25808: LD_INT 30
25810: PUSH
25811: LD_INT 3
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PPUSH
25818: CALL 11421 0 2
25822: PUSH
25823: LD_INT 1
25825: ARRAY
25826: PPUSH
25827: CALL_OW 461
25831: PUSH
25832: LD_INT 2
25834: EQUAL
25835: IFFALSE 25985
// begin for i = 1 to MREG_TurretWeapon do
25837: LD_ADDR_VAR 0 3
25841: PUSH
25842: DOUBLE
25843: LD_INT 1
25845: DEC
25846: ST_TO_ADDR
25847: LD_EXP 44
25851: PUSH
25852: FOR_TO
25853: IFFALSE 25983
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25855: LD_EXP 44
25859: PUSH
25860: LD_VAR 0 3
25864: ARRAY
25865: PUSH
25866: LD_INT 1
25868: ARRAY
25869: PUSH
25870: LD_VAR 0 1
25874: EQUAL
25875: IFFALSE 25981
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25877: LD_ADDR_VAR 0 5
25881: PUSH
25882: LD_EXP 44
25886: PUSH
25887: LD_VAR 0 3
25891: ARRAY
25892: PUSH
25893: LD_INT 2
25895: ARRAY
25896: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25897: LD_ADDR_VAR 0 6
25901: PUSH
25902: LD_EXP 44
25906: PUSH
25907: LD_VAR 0 3
25911: ARRAY
25912: PUSH
25913: LD_INT 3
25915: ARRAY
25916: PUSH
25917: LD_INT 1
25919: ARRAY
25920: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25921: LD_ADDR_VAR 0 7
25925: PUSH
25926: LD_EXP 44
25930: PUSH
25931: LD_VAR 0 3
25935: ARRAY
25936: PUSH
25937: LD_INT 3
25939: ARRAY
25940: PUSH
25941: LD_INT 2
25943: ARRAY
25944: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25945: LD_ADDR_VAR 0 4
25949: PUSH
25950: LD_VAR 0 6
25954: PPUSH
25955: LD_VAR 0 7
25959: PPUSH
25960: CALL_OW 428
25964: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25965: LD_VAR 0 4
25969: PPUSH
25970: LD_VAR 0 5
25974: PPUSH
25975: CALL_OW 148
// break ;
25979: GO 25983
// end ;
25981: GO 25852
25983: POP
25984: POP
// end ; end ;
25985: LD_VAR 0 2
25989: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25990: LD_INT 0
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25996: LD_ADDR_VAR 0 4
26000: PUSH
26001: LD_VAR 0 1
26005: PPUSH
26006: LD_INT 32
26008: PUSH
26009: LD_INT 1
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PPUSH
26016: CALL 11421 0 2
26020: ST_TO_ADDR
// if not tmp then
26021: LD_VAR 0 4
26025: NOT
26026: IFFALSE 26032
// exit else
26028: GO 26114
26030: GO 26114
// begin for i = 1 to tmp do
26032: LD_ADDR_VAR 0 3
26036: PUSH
26037: DOUBLE
26038: LD_INT 1
26040: DEC
26041: ST_TO_ADDR
26042: LD_VAR 0 4
26046: PUSH
26047: FOR_TO
26048: IFFALSE 26112
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26050: LD_VAR 0 4
26054: PUSH
26055: LD_VAR 0 3
26059: ARRAY
26060: PPUSH
26061: CALL_OW 261
26065: PUSH
26066: LD_INT 20
26068: LESS
26069: PUSH
26070: LD_VAR 0 4
26074: PUSH
26075: LD_VAR 0 3
26079: ARRAY
26080: PPUSH
26081: CALL_OW 110
26085: PUSH
26086: LD_INT 0
26088: EQUAL
26089: AND
26090: IFFALSE 26110
// begin SetTag ( tmp [ i ] , 21 ) ;
26092: LD_VAR 0 4
26096: PUSH
26097: LD_VAR 0 3
26101: ARRAY
26102: PPUSH
26103: LD_INT 21
26105: PPUSH
26106: CALL_OW 109
// end ;
26110: GO 26047
26112: POP
26113: POP
// end ; end ;
26114: LD_VAR 0 2
26118: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26119: LD_INT 0
26121: PPUSH
26122: PPUSH
26123: PPUSH
26124: PPUSH
26125: PPUSH
// if not unit then
26126: LD_VAR 0 1
26130: NOT
26131: IFFALSE 26135
// exit ;
26133: GO 26323
// side := GetSide ( unit ) ;
26135: LD_ADDR_VAR 0 3
26139: PUSH
26140: LD_VAR 0 1
26144: PPUSH
26145: CALL_OW 255
26149: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26150: LD_ADDR_VAR 0 5
26154: PUSH
26155: LD_VAR 0 3
26159: PPUSH
26160: LD_INT 2
26162: PUSH
26163: LD_INT 30
26165: PUSH
26166: LD_INT 1
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PUSH
26173: LD_INT 30
26175: PUSH
26176: LD_INT 3
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 30
26185: PUSH
26186: LD_INT 29
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: LIST
26197: LIST
26198: PPUSH
26199: CALL 11421 0 2
26203: ST_TO_ADDR
// if not b then
26204: LD_VAR 0 5
26208: NOT
26209: IFFALSE 26213
// exit ;
26211: GO 26323
// if GetTag ( unit ) = 21 then
26213: LD_VAR 0 1
26217: PPUSH
26218: CALL_OW 110
26222: PUSH
26223: LD_INT 21
26225: EQUAL
26226: IFFALSE 26323
// begin c := NearestUnitToUnit ( b , unit ) ;
26228: LD_ADDR_VAR 0 6
26232: PUSH
26233: LD_VAR 0 5
26237: PPUSH
26238: LD_VAR 0 1
26242: PPUSH
26243: CALL_OW 74
26247: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26248: LD_VAR 0 1
26252: PPUSH
26253: LD_VAR 0 6
26257: PPUSH
26258: CALL_OW 250
26262: PPUSH
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 251
26272: PPUSH
26273: CALL_OW 297
26277: PUSH
26278: LD_INT 6
26280: GREATER
26281: IFFALSE 26299
// ComMoveUnit ( unit , c ) else
26283: LD_VAR 0 1
26287: PPUSH
26288: LD_VAR 0 6
26292: PPUSH
26293: CALL_OW 112
26297: GO 26323
// begin SetFuel ( unit , 100 ) ;
26299: LD_VAR 0 1
26303: PPUSH
26304: LD_INT 100
26306: PPUSH
26307: CALL_OW 240
// SetTag ( unit , 0 ) ;
26311: LD_VAR 0 1
26315: PPUSH
26316: LD_INT 0
26318: PPUSH
26319: CALL_OW 109
// end ; end ; end ;
26323: LD_VAR 0 2
26327: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26328: LD_INT 0
26330: PPUSH
26331: PPUSH
26332: PPUSH
26333: PPUSH
26334: PPUSH
26335: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26336: LD_ADDR_VAR 0 7
26340: PUSH
26341: LD_VAR 0 1
26345: PPUSH
26346: LD_INT 33
26348: PUSH
26349: LD_INT 2
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: LD_INT 3
26358: PUSH
26359: LD_INT 61
26361: PUSH
26362: EMPTY
26363: LIST
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PPUSH
26373: CALL 11421 0 2
26377: ST_TO_ADDR
// if not vehs then
26378: LD_VAR 0 7
26382: NOT
26383: IFFALSE 26387
// exit ;
26385: GO 26672
// if nation = 1 then
26387: LD_VAR 0 2
26391: PUSH
26392: LD_INT 1
26394: EQUAL
26395: IFFALSE 26565
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26397: LD_VAR 0 1
26401: PPUSH
26402: LD_INT 30
26404: PUSH
26405: LD_INT 36
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PPUSH
26412: CALL 11421 0 2
26416: NOT
26417: IFFALSE 26423
// exit else
26419: GO 26672
26421: GO 26563
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26423: LD_ADDR_VAR 0 5
26427: PUSH
26428: LD_VAR 0 1
26432: PPUSH
26433: LD_INT 30
26435: PUSH
26436: LD_INT 36
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PPUSH
26443: CALL 11421 0 2
26447: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26448: LD_ADDR_VAR 0 6
26452: PUSH
26453: LD_VAR 0 5
26457: PUSH
26458: LD_INT 1
26460: ARRAY
26461: PPUSH
26462: CALL_OW 313
26466: ST_TO_ADDR
// for i = vehs downto 1 do
26467: LD_ADDR_VAR 0 4
26471: PUSH
26472: DOUBLE
26473: LD_VAR 0 7
26477: INC
26478: ST_TO_ADDR
26479: LD_INT 1
26481: PUSH
26482: FOR_DOWNTO
26483: IFFALSE 26561
// begin if not IsControledBy ( vehs [ i ] ) then
26485: LD_VAR 0 7
26489: PUSH
26490: LD_VAR 0 4
26494: ARRAY
26495: PPUSH
26496: CALL_OW 312
26500: NOT
26501: IFFALSE 26559
// begin tmp := MCV_RemoteDriver ( oper ) ;
26503: LD_ADDR_VAR 0 8
26507: PUSH
26508: LD_VAR 0 6
26512: PPUSH
26513: CALL 26677 0 1
26517: ST_TO_ADDR
// if not tmp then
26518: LD_VAR 0 8
26522: NOT
26523: IFFALSE 26531
// exit else
26525: POP
26526: POP
26527: GO 26672
26529: GO 26559
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26531: LD_VAR 0 7
26535: PUSH
26536: LD_VAR 0 4
26540: ARRAY
26541: PPUSH
26542: LD_VAR 0 8
26546: PUSH
26547: LD_INT 1
26549: ARRAY
26550: PUSH
26551: LD_INT 1
26553: ARRAY
26554: PPUSH
26555: CALL_OW 135
// end ; end ;
26559: GO 26482
26561: POP
26562: POP
// end ; end else
26563: GO 26672
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26565: LD_VAR 0 1
26569: PPUSH
26570: LD_INT 34
26572: PUSH
26573: LD_INT 31
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PPUSH
26580: CALL 11421 0 2
26584: NOT
26585: IFFALSE 26591
// exit else
26587: GO 26672
26589: GO 26672
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26591: LD_ADDR_VAR 0 5
26595: PUSH
26596: LD_VAR 0 1
26600: PPUSH
26601: LD_INT 34
26603: PUSH
26604: LD_INT 31
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PPUSH
26611: CALL 11421 0 2
26615: ST_TO_ADDR
// oper := [ ] ;
26616: LD_ADDR_VAR 0 6
26620: PUSH
26621: EMPTY
26622: ST_TO_ADDR
// for i = 1 to ct do
26623: LD_ADDR_VAR 0 4
26627: PUSH
26628: DOUBLE
26629: LD_INT 1
26631: DEC
26632: ST_TO_ADDR
26633: LD_VAR 0 5
26637: PUSH
26638: FOR_TO
26639: IFFALSE 26670
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26641: LD_ADDR_VAR 0 6
26645: PUSH
26646: LD_VAR 0 6
26650: PUSH
26651: LD_VAR 0 5
26655: PUSH
26656: LD_VAR 0 4
26660: ARRAY
26661: PPUSH
26662: CALL 31653 0 1
26666: ADD
26667: ST_TO_ADDR
26668: GO 26638
26670: POP
26671: POP
// end ; end ; end ;
26672: LD_VAR 0 3
26676: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26677: LD_INT 0
26679: PPUSH
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
// if not drivers then
26685: LD_VAR 0 1
26689: NOT
26690: IFFALSE 26696
// exit else
26692: GO 26976
26694: GO 26976
// begin linked := [ ] ;
26696: LD_ADDR_VAR 0 5
26700: PUSH
26701: EMPTY
26702: ST_TO_ADDR
// for i = 1 to drivers do
26703: LD_ADDR_VAR 0 3
26707: PUSH
26708: DOUBLE
26709: LD_INT 1
26711: DEC
26712: ST_TO_ADDR
26713: LD_VAR 0 1
26717: PUSH
26718: FOR_TO
26719: IFFALSE 26964
// begin if CanControl ( drivers [ i ] ) then
26721: LD_VAR 0 1
26725: PUSH
26726: LD_VAR 0 3
26730: ARRAY
26731: PPUSH
26732: CALL 32225 0 1
26736: IFFALSE 26962
// if i > 1 then
26738: LD_VAR 0 3
26742: PUSH
26743: LD_INT 1
26745: GREATER
26746: IFFALSE 26923
// begin m := false ;
26748: LD_ADDR_VAR 0 6
26752: PUSH
26753: LD_INT 0
26755: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26756: LD_ADDR_VAR 0 7
26760: PUSH
26761: LD_VAR 0 1
26765: PUSH
26766: LD_VAR 0 3
26770: ARRAY
26771: PPUSH
26772: CALL_OW 432
26776: ST_TO_ADDR
// for j = 1 to linked do
26777: LD_ADDR_VAR 0 4
26781: PUSH
26782: DOUBLE
26783: LD_INT 1
26785: DEC
26786: ST_TO_ADDR
26787: LD_VAR 0 5
26791: PUSH
26792: FOR_TO
26793: IFFALSE 26867
// begin if l < linked [ j ] [ 2 ] then
26795: LD_VAR 0 7
26799: PUSH
26800: LD_VAR 0 5
26804: PUSH
26805: LD_VAR 0 4
26809: ARRAY
26810: PUSH
26811: LD_INT 2
26813: ARRAY
26814: LESS
26815: IFFALSE 26865
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26817: LD_ADDR_VAR 0 5
26821: PUSH
26822: LD_VAR 0 5
26826: PPUSH
26827: LD_INT 1
26829: PPUSH
26830: LD_VAR 0 1
26834: PUSH
26835: LD_VAR 0 3
26839: ARRAY
26840: PUSH
26841: LD_VAR 0 7
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PPUSH
26850: CALL_OW 2
26854: ST_TO_ADDR
// m := true ;
26855: LD_ADDR_VAR 0 6
26859: PUSH
26860: LD_INT 1
26862: ST_TO_ADDR
// break ;
26863: GO 26867
// end ; end ;
26865: GO 26792
26867: POP
26868: POP
// if not m then
26869: LD_VAR 0 6
26873: NOT
26874: IFFALSE 26921
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26876: LD_ADDR_VAR 0 5
26880: PUSH
26881: LD_VAR 0 5
26885: PUSH
26886: LD_VAR 0 1
26890: PUSH
26891: LD_VAR 0 3
26895: ARRAY
26896: PUSH
26897: LD_VAR 0 1
26901: PUSH
26902: LD_VAR 0 3
26906: ARRAY
26907: PPUSH
26908: CALL_OW 432
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: EMPTY
26918: LIST
26919: ADD
26920: ST_TO_ADDR
// end else
26921: GO 26962
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26923: LD_ADDR_VAR 0 5
26927: PUSH
26928: LD_VAR 0 1
26932: PUSH
26933: LD_VAR 0 3
26937: ARRAY
26938: PUSH
26939: LD_VAR 0 1
26943: PUSH
26944: LD_VAR 0 3
26948: ARRAY
26949: PPUSH
26950: CALL_OW 432
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: EMPTY
26960: LIST
26961: ST_TO_ADDR
// end ;
26962: GO 26718
26964: POP
26965: POP
// result := linked ;
26966: LD_ADDR_VAR 0 2
26970: PUSH
26971: LD_VAR 0 5
26975: ST_TO_ADDR
// end ; end ;
26976: LD_VAR 0 2
26980: RET
// export function MCV_ToRepair ( unit ) ; begin
26981: LD_INT 0
26983: PPUSH
// if not unit then
26984: LD_VAR 0 1
26988: NOT
26989: IFFALSE 26995
// exit else
26991: GO 27026
26993: GO 27026
// begin SetTag ( unit , 6 ) ;
26995: LD_VAR 0 1
26999: PPUSH
27000: LD_INT 6
27002: PPUSH
27003: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27007: LD_VAR 0 1
27011: PPUSH
27012: CALL_OW 255
27016: PPUSH
27017: LD_VAR 0 1
27021: PPUSH
27022: CALL 25582 0 2
// end ; end ;
27026: LD_VAR 0 2
27030: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27031: LD_INT 0
27033: PPUSH
27034: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27035: LD_VAR 0 1
27039: PPUSH
27040: LD_INT 6
27042: PPUSH
27043: EMPTY
27044: PPUSH
27045: CALL 12124 0 3
27049: IFFALSE 27142
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27051: LD_ADDR_VAR 0 3
27055: PUSH
27056: DOUBLE
27057: LD_VAR 0 1
27061: PPUSH
27062: LD_INT 6
27064: PPUSH
27065: EMPTY
27066: PPUSH
27067: CALL 12124 0 3
27071: INC
27072: ST_TO_ADDR
27073: LD_INT 1
27075: PUSH
27076: FOR_DOWNTO
27077: IFFALSE 27140
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27079: LD_VAR 0 1
27083: PPUSH
27084: LD_INT 6
27086: PPUSH
27087: EMPTY
27088: PPUSH
27089: CALL 12124 0 3
27093: PUSH
27094: LD_VAR 0 3
27098: ARRAY
27099: PPUSH
27100: CALL_OW 256
27104: PUSH
27105: LD_INT 1000
27107: EQUAL
27108: IFFALSE 27138
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27110: LD_VAR 0 1
27114: PPUSH
27115: LD_INT 6
27117: PPUSH
27118: EMPTY
27119: PPUSH
27120: CALL 12124 0 3
27124: PUSH
27125: LD_VAR 0 3
27129: ARRAY
27130: PPUSH
27131: LD_INT 0
27133: PPUSH
27134: CALL_OW 109
27138: GO 27076
27140: POP
27141: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27142: LD_VAR 0 1
27146: PPUSH
27147: LD_INT 10
27149: PPUSH
27150: EMPTY
27151: PPUSH
27152: CALL 12124 0 3
27156: IFFALSE 27273
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27158: LD_ADDR_VAR 0 3
27162: PUSH
27163: DOUBLE
27164: LD_VAR 0 1
27168: PPUSH
27169: LD_INT 10
27171: PPUSH
27172: EMPTY
27173: PPUSH
27174: CALL 12124 0 3
27178: INC
27179: ST_TO_ADDR
27180: LD_INT 1
27182: PUSH
27183: FOR_DOWNTO
27184: IFFALSE 27271
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27186: LD_VAR 0 1
27190: PPUSH
27191: LD_INT 10
27193: PPUSH
27194: EMPTY
27195: PPUSH
27196: CALL 12124 0 3
27200: PUSH
27201: LD_VAR 0 3
27205: ARRAY
27206: PPUSH
27207: CALL_OW 302
27211: NOT
27212: PUSH
27213: LD_VAR 0 1
27217: PPUSH
27218: LD_INT 10
27220: PPUSH
27221: EMPTY
27222: PPUSH
27223: CALL 12124 0 3
27227: PUSH
27228: LD_VAR 0 3
27232: ARRAY
27233: PPUSH
27234: CALL_OW 301
27238: OR
27239: IFFALSE 27269
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27241: LD_VAR 0 1
27245: PPUSH
27246: LD_INT 10
27248: PPUSH
27249: EMPTY
27250: PPUSH
27251: CALL 12124 0 3
27255: PUSH
27256: LD_VAR 0 3
27260: ARRAY
27261: PPUSH
27262: LD_INT 0
27264: PPUSH
27265: CALL_OW 109
27269: GO 27183
27271: POP
27272: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27273: LD_ADDR_VAR 0 3
27277: PUSH
27278: LD_VAR 0 1
27282: PPUSH
27283: EMPTY
27284: PPUSH
27285: CALL 11722 0 2
27289: PUSH
27290: LD_VAR 0 1
27294: PPUSH
27295: LD_INT 7
27297: PPUSH
27298: EMPTY
27299: PPUSH
27300: CALL 12124 0 3
27304: DIFF
27305: PUSH
27306: FOR_IN
27307: IFFALSE 27351
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27309: LD_VAR 0 3
27313: PPUSH
27314: CALL_OW 256
27318: PUSH
27319: LD_INT 650
27321: LESS
27322: PUSH
27323: LD_VAR 0 3
27327: PPUSH
27328: CALL_OW 110
27332: PUSH
27333: LD_INT 6
27335: EQUAL
27336: NOT
27337: AND
27338: IFFALSE 27349
// MCV_ToRepair ( i ) ;
27340: LD_VAR 0 3
27344: PPUSH
27345: CALL 26981 0 1
27349: GO 27306
27351: POP
27352: POP
// end ; end_of_file end_of_file
27353: LD_VAR 0 2
27357: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27358: LD_STRING SAILEvent [
27360: PUSH
27361: LD_VAR 0 1
27365: STR
27366: PUSH
27367: LD_STRING ]
27369: STR
27370: PPUSH
27371: CALL 7818 0 1
// if event = 101 and dialog_north then
27375: LD_VAR 0 1
27379: PUSH
27380: LD_INT 101
27382: EQUAL
27383: PUSH
27384: LD_EXP 5
27388: AND
27389: IFFALSE 27453
// begin dialog_north := false ;
27391: LD_ADDR_EXP 5
27395: PUSH
27396: LD_INT 0
27398: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27399: LD_EXP 4
27403: PPUSH
27404: LD_STRING DS1
27406: PUSH
27407: LD_STRING DS2
27409: PUSH
27410: LD_STRING DS3
27412: PUSH
27413: LD_STRING DS6
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 1
27424: PPUSH
27425: LD_INT 4
27427: PPUSH
27428: CALL_OW 12
27432: ARRAY
27433: PPUSH
27434: CALL_OW 94
// Wait ( 4 4$00 ) ;
27438: LD_INT 8400
27440: PPUSH
27441: CALL_OW 67
// dialog_north := true ;
27445: LD_ADDR_EXP 5
27449: PUSH
27450: LD_INT 1
27452: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27453: LD_VAR 0 1
27457: PUSH
27458: LD_INT 102
27460: EQUAL
27461: PUSH
27462: LD_EXP 6
27466: AND
27467: IFFALSE 27527
// begin dialog_south := false ;
27469: LD_ADDR_EXP 6
27473: PUSH
27474: LD_INT 0
27476: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27477: LD_EXP 3
27481: PPUSH
27482: LD_STRING DJ1
27484: PUSH
27485: LD_STRING DJ4
27487: PUSH
27488: LD_STRING DJ6
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 1
27498: PPUSH
27499: LD_INT 3
27501: PPUSH
27502: CALL_OW 12
27506: ARRAY
27507: PPUSH
27508: CALL_OW 94
// Wait ( 4 4$00 ) ;
27512: LD_INT 8400
27514: PPUSH
27515: CALL_OW 67
// dialog_south := true ;
27519: LD_ADDR_EXP 6
27523: PUSH
27524: LD_INT 1
27526: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27527: LD_VAR 0 1
27531: PUSH
27532: LD_INT 104
27534: EQUAL
27535: PUSH
27536: LD_EXP 7
27540: AND
27541: IFFALSE 27563
// begin dialog_popov := false ;
27543: LD_ADDR_EXP 7
27547: PUSH
27548: LD_INT 0
27550: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27551: LD_EXP 25
27555: PPUSH
27556: LD_STRING DR4
27558: PPUSH
27559: CALL_OW 94
// end ; end ;
27563: PPOPN 1
27565: END
// on BuildingStarted ( b , unit ) do var side , i ;
27566: LD_INT 0
27568: PPUSH
27569: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27570: LD_EXP 40
27574: PUSH
27575: LD_VAR 0 1
27579: PPUSH
27580: CALL_OW 255
27584: ARRAY
27585: IFFALSE 27763
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27587: LD_STRING BuildingStarted [side: 
27589: PUSH
27590: LD_VAR 0 1
27594: PPUSH
27595: CALL_OW 255
27599: STR
27600: PUSH
27601: LD_STRING ; btype: 
27603: STR
27604: PUSH
27605: LD_VAR 0 1
27609: PPUSH
27610: CALL_OW 266
27614: STR
27615: PUSH
27616: LD_STRING ; unit: 
27618: STR
27619: PUSH
27620: LD_VAR 0 2
27624: STR
27625: PUSH
27626: LD_STRING ]
27628: STR
27629: PPUSH
27630: CALL 7818 0 1
// side := GetSide ( b ) ;
27634: LD_ADDR_VAR 0 3
27638: PUSH
27639: LD_VAR 0 1
27643: PPUSH
27644: CALL_OW 255
27648: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27649: LD_VAR 0 3
27653: PPUSH
27654: LD_INT 21
27656: PUSH
27657: LD_INT 3
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PPUSH
27664: CALL 11421 0 2
27668: PUSH
27669: LD_INT 1
27671: EQUAL
27672: IFFALSE 27763
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27674: LD_ADDR_VAR 0 4
27678: PUSH
27679: LD_VAR 0 3
27683: PPUSH
27684: LD_INT 21
27686: PUSH
27687: LD_INT 1
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PPUSH
27694: CALL 11421 0 2
27698: PUSH
27699: LD_VAR 0 3
27703: PPUSH
27704: LD_INT 2
27706: PPUSH
27707: EMPTY
27708: PPUSH
27709: CALL 11504 0 3
27713: DIFF
27714: PUSH
27715: FOR_IN
27716: IFFALSE 27761
// if not HasTask ( i ) then
27718: LD_VAR 0 4
27722: PPUSH
27723: CALL_OW 314
27727: NOT
27728: IFFALSE 27759
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27730: LD_VAR 0 4
27734: PPUSH
27735: LD_VAR 0 1
27739: PPUSH
27740: CALL_OW 250
27744: PPUSH
27745: LD_VAR 0 1
27749: PPUSH
27750: CALL_OW 251
27754: PPUSH
27755: CALL_OW 111
27759: GO 27715
27761: POP
27762: POP
// end ;
27763: PPOPN 4
27765: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27766: LD_EXP 40
27770: PUSH
27771: LD_VAR 0 1
27775: PPUSH
27776: CALL_OW 255
27780: ARRAY
27781: IFFALSE 28150
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27783: LD_STRING BuildingComplete [side: 
27785: PUSH
27786: LD_VAR 0 1
27790: PPUSH
27791: CALL_OW 255
27795: STR
27796: PUSH
27797: LD_STRING ; btype: 
27799: STR
27800: PUSH
27801: LD_VAR 0 1
27805: PPUSH
27806: CALL_OW 266
27810: STR
27811: PUSH
27812: LD_STRING ]
27814: STR
27815: PPUSH
27816: CALL 7818 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27820: LD_ADDR_EXP 47
27824: PUSH
27825: LD_EXP 47
27829: PPUSH
27830: LD_VAR 0 1
27834: PPUSH
27835: CALL_OW 255
27839: PPUSH
27840: LD_VAR 0 1
27844: PPUSH
27845: CALL_OW 266
27849: PPUSH
27850: LD_VAR 0 1
27854: PPUSH
27855: CALL_OW 250
27859: PUSH
27860: LD_VAR 0 1
27864: PPUSH
27865: CALL_OW 251
27869: PUSH
27870: LD_VAR 0 1
27874: PPUSH
27875: CALL_OW 254
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: LIST
27884: PPUSH
27885: CALL 42332 0 4
27889: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27890: LD_VAR 0 1
27894: PPUSH
27895: CALL_OW 266
27899: PUSH
27900: LD_INT 6
27902: EQUAL
27903: IFFALSE 27937
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27905: LD_ADDR_EXP 41
27909: PUSH
27910: LD_EXP 41
27914: PPUSH
27915: LD_VAR 0 1
27919: PPUSH
27920: CALL_OW 255
27924: PPUSH
27925: LD_VAR 0 1
27929: PPUSH
27930: EMPTY
27931: PPUSH
27932: CALL 42241 0 4
27936: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27937: LD_VAR 0 1
27941: PPUSH
27942: CALL_OW 266
27946: PUSH
27947: LD_INT 0
27949: EQUAL
27950: IFFALSE 28060
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27952: LD_ADDR_EXP 49
27956: PUSH
27957: LD_EXP 49
27961: PPUSH
27962: LD_VAR 0 1
27966: PPUSH
27967: CALL_OW 255
27971: PPUSH
27972: LD_INT 0
27974: PPUSH
27975: EMPTY
27976: PPUSH
27977: CALL 42241 0 4
27981: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27982: LD_VAR 0 1
27986: PPUSH
27987: CALL_OW 274
27991: PPUSH
27992: LD_INT 1
27994: PPUSH
27995: LD_EXP 73
27999: PUSH
28000: LD_INT 1
28002: ARRAY
28003: PPUSH
28004: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 274
28017: PPUSH
28018: LD_INT 2
28020: PPUSH
28021: LD_EXP 73
28025: PUSH
28026: LD_INT 2
28028: ARRAY
28029: PPUSH
28030: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28034: LD_VAR 0 1
28038: PPUSH
28039: CALL_OW 274
28043: PPUSH
28044: LD_INT 3
28046: PPUSH
28047: LD_EXP 73
28051: PUSH
28052: LD_INT 3
28054: ARRAY
28055: PPUSH
28056: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28060: LD_VAR 0 1
28064: PPUSH
28065: CALL_OW 266
28069: PUSH
28070: LD_INT 2
28072: EQUAL
28073: IFFALSE 28105
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28075: LD_ADDR_EXP 49
28079: PUSH
28080: LD_EXP 49
28084: PPUSH
28085: LD_VAR 0 1
28089: PPUSH
28090: CALL_OW 255
28094: PPUSH
28095: LD_INT 2
28097: PPUSH
28098: EMPTY
28099: PPUSH
28100: CALL 42241 0 4
28104: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28105: LD_VAR 0 1
28109: PPUSH
28110: CALL_OW 266
28114: PUSH
28115: LD_INT 4
28117: EQUAL
28118: IFFALSE 28150
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28120: LD_ADDR_EXP 49
28124: PUSH
28125: LD_EXP 49
28129: PPUSH
28130: LD_VAR 0 1
28134: PPUSH
28135: CALL_OW 255
28139: PPUSH
28140: LD_INT 4
28142: PPUSH
28143: EMPTY
28144: PPUSH
28145: CALL 42241 0 4
28149: ST_TO_ADDR
// end ;
28150: PPOPN 1
28152: END
// on ResearchComplete ( tech , lab ) do var i ;
28153: LD_INT 0
28155: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28156: LD_EXP 40
28160: PUSH
28161: LD_VAR 0 2
28165: PPUSH
28166: CALL_OW 255
28170: ARRAY
28171: IFFALSE 28455
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28173: LD_STRING ResearchComplete [side: 
28175: PUSH
28176: LD_VAR 0 2
28180: PPUSH
28181: CALL_OW 255
28185: PPUSH
28186: CALL_OW 255
28190: STR
28191: PUSH
28192: LD_STRING ; tech:
28194: STR
28195: PUSH
28196: LD_VAR 0 1
28200: STR
28201: PUSH
28202: LD_STRING ]
28204: STR
28205: PPUSH
28206: CALL 7818 0 1
// for i = 1 to MREG_ToRes do
28210: LD_ADDR_VAR 0 3
28214: PUSH
28215: DOUBLE
28216: LD_INT 1
28218: DEC
28219: ST_TO_ADDR
28220: LD_EXP 51
28224: PUSH
28225: FOR_TO
28226: IFFALSE 28313
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28228: LD_EXP 51
28232: PUSH
28233: LD_VAR 0 3
28237: ARRAY
28238: PUSH
28239: LD_INT 1
28241: ARRAY
28242: PUSH
28243: LD_VAR 0 2
28247: PPUSH
28248: CALL_OW 255
28252: EQUAL
28253: PUSH
28254: LD_EXP 51
28258: PUSH
28259: LD_VAR 0 3
28263: ARRAY
28264: PUSH
28265: LD_INT 2
28267: ARRAY
28268: PUSH
28269: LD_VAR 0 1
28273: EQUAL
28274: AND
28275: IFFALSE 28311
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28277: LD_ADDR_EXP 51
28281: PUSH
28282: LD_EXP 51
28286: PPUSH
28287: LD_VAR 0 2
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_VAR 0 1
28301: PPUSH
28302: EMPTY
28303: PPUSH
28304: CALL 42332 0 4
28308: ST_TO_ADDR
// break ;
28309: GO 28313
// end ;
28311: GO 28225
28313: POP
28314: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28315: LD_VAR 0 1
28319: PUSH
28320: LD_INT 2
28322: PUSH
28323: LD_INT 11
28325: PUSH
28326: LD_INT 4
28328: PUSH
28329: LD_INT 3
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: IN
28338: IFFALSE 28455
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28340: LD_ADDR_VAR 0 3
28344: PUSH
28345: LD_VAR 0 2
28349: PPUSH
28350: CALL_OW 255
28354: PPUSH
28355: LD_INT 16
28357: PPUSH
28358: LD_INT 25
28360: PUSH
28361: LD_INT 4
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PPUSH
28368: CALL 12124 0 3
28372: ST_TO_ADDR
// if i then
28373: LD_VAR 0 3
28377: IFFALSE 28395
// SetTag ( i [ 1 ] , 0 ) ;
28379: LD_VAR 0 3
28383: PUSH
28384: LD_INT 1
28386: ARRAY
28387: PPUSH
28388: LD_INT 0
28390: PPUSH
28391: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28395: LD_ADDR_VAR 0 3
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: PPUSH
28410: LD_INT 171
28412: PPUSH
28413: EMPTY
28414: PPUSH
28415: CALL 12124 0 3
28419: ST_TO_ADDR
// if i then
28420: LD_VAR 0 3
28424: IFFALSE 28455
// begin SetTag ( i [ 1 ] , 0 ) ;
28426: LD_VAR 0 3
28430: PUSH
28431: LD_INT 1
28433: ARRAY
28434: PPUSH
28435: LD_INT 0
28437: PPUSH
28438: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28442: LD_VAR 0 3
28446: PUSH
28447: LD_INT 1
28449: ARRAY
28450: PPUSH
28451: CALL_OW 122
// end ; end ; end ;
28455: PPOPN 3
28457: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28458: LD_INT 0
28460: PPUSH
28461: PPUSH
28462: PPUSH
28463: PPUSH
28464: PPUSH
28465: PPUSH
28466: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28467: LD_EXP 40
28471: PUSH
28472: LD_VAR 0 2
28476: PPUSH
28477: CALL_OW 255
28481: ARRAY
28482: IFFALSE 29209
// begin side := GetSide ( veh ) ;
28484: LD_ADDR_VAR 0 4
28488: PUSH
28489: LD_VAR 0 1
28493: PPUSH
28494: CALL_OW 255
28498: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28499: LD_ADDR_VAR 0 6
28503: PUSH
28504: LD_VAR 0 1
28508: PPUSH
28509: CALL_OW 265
28513: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28514: LD_ADDR_VAR 0 7
28518: PUSH
28519: LD_VAR 0 1
28523: PPUSH
28524: CALL_OW 262
28528: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28529: LD_ADDR_VAR 0 8
28533: PUSH
28534: LD_VAR 0 1
28538: PPUSH
28539: CALL_OW 263
28543: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 1
28553: PPUSH
28554: CALL_OW 264
28558: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28559: LD_STRING VehicleConstructed [side: 
28561: PUSH
28562: LD_VAR 0 4
28566: STR
28567: PUSH
28568: LD_STRING ; id:
28570: STR
28571: PUSH
28572: LD_VAR 0 1
28576: STR
28577: PUSH
28578: LD_STRING ; components: [
28580: STR
28581: PUSH
28582: LD_VAR 0 6
28586: STR
28587: PUSH
28588: LD_STRING , 
28590: STR
28591: PUSH
28592: LD_VAR 0 7
28596: STR
28597: PUSH
28598: LD_STRING , 
28600: STR
28601: PUSH
28602: LD_VAR 0 8
28606: STR
28607: PUSH
28608: LD_STRING , 
28610: STR
28611: PUSH
28612: LD_VAR 0 9
28616: STR
28617: PUSH
28618: LD_STRING ]]
28620: STR
28621: PPUSH
28622: CALL 7818 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28626: LD_VAR 0 1
28630: PPUSH
28631: CALL_OW 264
28635: PUSH
28636: LD_INT 13
28638: PUSH
28639: LD_INT 12
28641: PUSH
28642: LD_INT 14
28644: PUSH
28645: LD_INT 51
28647: PUSH
28648: LD_INT 53
28650: PUSH
28651: LD_INT 52
28653: PUSH
28654: LD_INT 32
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: IN
28666: NOT
28667: IFFALSE 28709
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28669: LD_ADDR_EXP 60
28673: PUSH
28674: LD_EXP 60
28678: PPUSH
28679: LD_VAR 0 4
28683: PPUSH
28684: LD_EXP 60
28688: PUSH
28689: LD_VAR 0 4
28693: ARRAY
28694: PUSH
28695: LD_INT 1
28697: PLUS
28698: PPUSH
28699: LD_VAR 0 1
28703: PPUSH
28704: CALL 30959 0 4
28708: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28709: LD_VAR 0 1
28713: PPUSH
28714: CALL_OW 264
28718: PUSH
28719: LD_INT 31
28721: EQUAL
28722: IFFALSE 28741
// SetTag ( GetDriver ( veh ) , 9 ) ;
28724: LD_VAR 0 1
28728: PPUSH
28729: CALL 31653 0 1
28733: PPUSH
28734: LD_INT 9
28736: PPUSH
28737: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28741: LD_VAR 0 1
28745: PPUSH
28746: CALL_OW 264
28750: PUSH
28751: LD_INT 14
28753: PUSH
28754: LD_INT 53
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: IN
28761: IFFALSE 28798
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28763: LD_ADDR_EXP 43
28767: PUSH
28768: LD_EXP 43
28772: PPUSH
28773: LD_VAR 0 1
28777: PPUSH
28778: CALL_OW 255
28782: PPUSH
28783: LD_INT 2
28785: PPUSH
28786: LD_VAR 0 1
28790: PPUSH
28791: CALL 30959 0 4
28795: ST_TO_ADDR
// exit ;
28796: GO 29209
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28798: LD_VAR 0 1
28802: PPUSH
28803: CALL_OW 265
28807: PUSH
28808: LD_EXP 67
28812: PUSH
28813: LD_VAR 0 4
28817: ARRAY
28818: PUSH
28819: LD_INT 1
28821: ARRAY
28822: IN
28823: PUSH
28824: LD_VAR 0 1
28828: PPUSH
28829: CALL_OW 262
28833: PUSH
28834: LD_EXP 67
28838: PUSH
28839: LD_VAR 0 4
28843: ARRAY
28844: PUSH
28845: LD_INT 1
28847: ARRAY
28848: IN
28849: AND
28850: PUSH
28851: LD_VAR 0 1
28855: PPUSH
28856: CALL_OW 263
28860: PUSH
28861: LD_EXP 67
28865: PUSH
28866: LD_VAR 0 4
28870: ARRAY
28871: PUSH
28872: LD_INT 1
28874: ARRAY
28875: IN
28876: AND
28877: PUSH
28878: LD_VAR 0 1
28882: PPUSH
28883: CALL_OW 264
28887: PUSH
28888: LD_EXP 67
28892: PUSH
28893: LD_VAR 0 4
28897: ARRAY
28898: PUSH
28899: LD_INT 1
28901: ARRAY
28902: IN
28903: AND
28904: IFFALSE 28948
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28906: LD_ADDR_EXP 68
28910: PUSH
28911: LD_EXP 68
28915: PPUSH
28916: LD_VAR 0 4
28920: PPUSH
28921: LD_EXP 68
28925: PUSH
28926: LD_VAR 0 4
28930: ARRAY
28931: PUSH
28932: LD_INT 1
28934: PLUS
28935: PPUSH
28936: LD_VAR 0 1
28940: PPUSH
28941: CALL 30959 0 4
28945: ST_TO_ADDR
// exit ;
28946: GO 29209
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28948: LD_VAR 0 6
28952: PUSH
28953: LD_EXP 70
28957: PUSH
28958: LD_VAR 0 4
28962: ARRAY
28963: PUSH
28964: LD_INT 1
28966: ARRAY
28967: EQUAL
28968: PUSH
28969: LD_VAR 0 7
28973: PUSH
28974: LD_EXP 70
28978: PUSH
28979: LD_VAR 0 4
28983: ARRAY
28984: PUSH
28985: LD_INT 2
28987: ARRAY
28988: EQUAL
28989: AND
28990: PUSH
28991: LD_VAR 0 8
28995: PUSH
28996: LD_EXP 70
29000: PUSH
29001: LD_VAR 0 4
29005: ARRAY
29006: PUSH
29007: LD_INT 3
29009: ARRAY
29010: EQUAL
29011: AND
29012: PUSH
29013: LD_VAR 0 9
29017: PUSH
29018: LD_EXP 70
29022: PUSH
29023: LD_VAR 0 4
29027: ARRAY
29028: PUSH
29029: LD_INT 4
29031: ARRAY
29032: EQUAL
29033: AND
29034: IFFALSE 29190
// begin tmp := MREG_ToAttack [ side ] ;
29036: LD_ADDR_VAR 0 5
29040: PUSH
29041: LD_EXP 70
29045: PUSH
29046: LD_VAR 0 4
29050: ARRAY
29051: ST_TO_ADDR
// for i = 1 to 4 do
29052: LD_ADDR_VAR 0 3
29056: PUSH
29057: DOUBLE
29058: LD_INT 1
29060: DEC
29061: ST_TO_ADDR
29062: LD_INT 4
29064: PUSH
29065: FOR_TO
29066: IFFALSE 29088
// tmp := Delete ( tmp , 1 ) ;
29068: LD_ADDR_VAR 0 5
29072: PUSH
29073: LD_VAR 0 5
29077: PPUSH
29078: LD_INT 1
29080: PPUSH
29081: CALL_OW 3
29085: ST_TO_ADDR
29086: GO 29065
29088: POP
29089: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29090: LD_ADDR_EXP 70
29094: PUSH
29095: LD_EXP 70
29099: PPUSH
29100: LD_VAR 0 4
29104: PPUSH
29105: LD_VAR 0 5
29109: PPUSH
29110: CALL_OW 1
29114: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29115: LD_ADDR_EXP 72
29119: PUSH
29120: LD_EXP 72
29124: PPUSH
29125: LD_VAR 0 4
29129: PPUSH
29130: LD_EXP 72
29134: PUSH
29135: LD_VAR 0 4
29139: ARRAY
29140: PUSH
29141: LD_INT 1
29143: PLUS
29144: PPUSH
29145: LD_VAR 0 1
29149: PPUSH
29150: CALL 30959 0 4
29154: ST_TO_ADDR
// if tmp = 0 then
29155: LD_VAR 0 5
29159: PUSH
29160: LD_INT 0
29162: EQUAL
29163: IFFALSE 29188
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29165: LD_ADDR_EXP 70
29169: PUSH
29170: LD_EXP 70
29174: PPUSH
29175: LD_VAR 0 4
29179: PPUSH
29180: LD_INT 0
29182: PPUSH
29183: CALL_OW 1
29187: ST_TO_ADDR
// exit ;
29188: GO 29209
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29190: LD_VAR 0 1
29194: PPUSH
29195: CALL_OW 255
29199: PPUSH
29200: LD_VAR 0 1
29204: PPUSH
29205: CALL 25582 0 2
// end ;
29209: PPOPN 9
29211: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29212: LD_EXP 40
29216: PUSH
29217: LD_VAR 0 2
29221: PPUSH
29222: CALL_OW 255
29226: ARRAY
29227: IFFALSE 29459
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29229: LD_STRING ApemanTamed [side: 
29231: PUSH
29232: LD_VAR 0 2
29236: PPUSH
29237: CALL_OW 255
29241: STR
29242: PUSH
29243: LD_STRING ; sci: 
29245: STR
29246: PUSH
29247: LD_VAR 0 2
29251: STR
29252: PUSH
29253: LD_STRING ; ape: 
29255: STR
29256: PUSH
29257: LD_VAR 0 1
29261: STR
29262: PUSH
29263: LD_STRING ]
29265: STR
29266: PPUSH
29267: CALL 7818 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29271: LD_INT 11
29273: PPUSH
29274: LD_VAR 0 2
29278: PPUSH
29279: CALL_OW 255
29283: PPUSH
29284: CALL_OW 321
29288: PUSH
29289: LD_INT 2
29291: EQUAL
29292: NOT
29293: PUSH
29294: LD_INT 2
29296: PPUSH
29297: LD_VAR 0 2
29301: PPUSH
29302: CALL_OW 255
29306: PPUSH
29307: CALL_OW 321
29311: PUSH
29312: LD_INT 2
29314: EQUAL
29315: NOT
29316: OR
29317: PUSH
29318: LD_VAR 0 2
29322: PPUSH
29323: CALL_OW 255
29327: PPUSH
29328: LD_INT 171
29330: PPUSH
29331: EMPTY
29332: PPUSH
29333: CALL 12124 0 3
29337: PUSH
29338: LD_INT 0
29340: EQUAL
29341: AND
29342: IFFALSE 29356
// begin SetTag ( ape , 171 ) ;
29344: LD_VAR 0 1
29348: PPUSH
29349: LD_INT 171
29351: PPUSH
29352: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29356: LD_VAR 0 2
29360: PPUSH
29361: CALL_OW 255
29365: PPUSH
29366: LD_INT 30
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PPUSH
29376: CALL 11421 0 2
29380: IFFALSE 29459
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29382: LD_VAR 0 1
29386: PPUSH
29387: LD_VAR 0 2
29391: PPUSH
29392: CALL_OW 255
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL 11421 0 2
29411: PUSH
29412: LD_INT 1
29414: ARRAY
29415: PPUSH
29416: CALL_OW 250
29420: PPUSH
29421: LD_VAR 0 2
29425: PPUSH
29426: CALL_OW 255
29430: PPUSH
29431: LD_INT 30
29433: PUSH
29434: LD_INT 1
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PPUSH
29441: CALL 11421 0 2
29445: PUSH
29446: LD_INT 1
29448: ARRAY
29449: PPUSH
29450: CALL_OW 251
29454: PPUSH
29455: CALL_OW 111
// end ;
29459: PPOPN 2
29461: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29462: LD_EXP 40
29466: PUSH
29467: LD_VAR 0 1
29471: PPUSH
29472: CALL_OW 255
29476: ARRAY
29477: IFFALSE 29755
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29479: LD_VAR 0 2
29483: PUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: CALL 11834 0 1
29498: IN
29499: IFFALSE 29640
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29501: LD_VAR 0 1
29505: PPUSH
29506: CALL_OW 266
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: IN
29521: IFFALSE 29551
// begin Wait ( 0 0$0.3 ) ;
29523: LD_INT 10
29525: PPUSH
29526: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29530: LD_VAR 0 2
29534: PPUSH
29535: LD_INT 16
29537: PPUSH
29538: CALL_OW 336
// ComExitBuilding ( un ) ;
29542: LD_VAR 0 2
29546: PPUSH
29547: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29551: LD_VAR 0 1
29555: PPUSH
29556: CALL_OW 266
29560: PUSH
29561: LD_INT 4
29563: PUSH
29564: LD_INT 5
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: IN
29571: IFFALSE 29640
// begin Wait ( 0 0$0.3 ) ;
29573: LD_INT 10
29575: PPUSH
29576: CALL_OW 67
// if GetTag ( un ) = 0 then
29580: LD_VAR 0 2
29584: PPUSH
29585: CALL_OW 110
29589: PUSH
29590: LD_INT 0
29592: EQUAL
29593: IFFALSE 29609
// SetClass ( un , class_apeman_soldier ) else
29595: LD_VAR 0 2
29599: PPUSH
29600: LD_INT 15
29602: PPUSH
29603: CALL_OW 336
29607: GO 29640
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29609: LD_INT 3
29611: PPUSH
29612: LD_VAR 0 2
29616: PPUSH
29617: CALL_OW 255
29621: PPUSH
29622: CALL_OW 321
29626: IFFALSE 29640
// SetClass ( un , class_apeman_kamikaze ) ;
29628: LD_VAR 0 2
29632: PPUSH
29633: LD_INT 17
29635: PPUSH
29636: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 266
29649: PUSH
29650: LD_INT 32
29652: EQUAL
29653: IFFALSE 29755
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29655: LD_ADDR_EXP 69
29659: PUSH
29660: LD_EXP 69
29664: PPUSH
29665: LD_VAR 0 1
29669: PPUSH
29670: CALL_OW 255
29674: PPUSH
29675: LD_EXP 69
29679: PUSH
29680: LD_VAR 0 1
29684: PPUSH
29685: CALL_OW 255
29689: ARRAY
29690: PUSH
29691: LD_INT 1
29693: PLUS
29694: PPUSH
29695: LD_VAR 0 1
29699: PPUSH
29700: CALL 30959 0 4
29704: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29705: LD_ADDR_EXP 69
29709: PUSH
29710: LD_EXP 69
29714: PPUSH
29715: LD_VAR 0 1
29719: PPUSH
29720: CALL_OW 255
29724: PPUSH
29725: LD_EXP 69
29729: PUSH
29730: LD_VAR 0 1
29734: PPUSH
29735: CALL_OW 255
29739: ARRAY
29740: PUSH
29741: LD_INT 1
29743: PLUS
29744: PPUSH
29745: LD_VAR 0 2
29749: PPUSH
29750: CALL 30959 0 4
29754: ST_TO_ADDR
// end ; end ;
29755: PPOPN 2
29757: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29758: LD_VAR 0 1
29762: PPUSH
29763: CALL 54428 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29767: LD_VAR 0 1
29771: PUSH
29772: LD_INT 22
29774: PUSH
29775: LD_INT 3
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 23
29784: PUSH
29785: LD_INT 3
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 21
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: LIST
29806: PPUSH
29807: CALL_OW 69
29811: IN
29812: IFFALSE 29828
// player_loss := player_loss + 1 ;
29814: LD_ADDR_EXP 9
29818: PUSH
29819: LD_EXP 9
29823: PUSH
29824: LD_INT 1
29826: PLUS
29827: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29828: LD_VAR 0 1
29832: PUSH
29833: LD_INT 22
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 21
29845: PUSH
29846: LD_INT 3
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PPUSH
29857: CALL_OW 69
29861: IN
29862: PUSH
29863: LD_EXP 14
29867: NOT
29868: AND
29869: IFFALSE 29932
// begin alfa_north_triggered := true ;
29871: LD_ADDR_EXP 14
29875: PUSH
29876: LD_INT 1
29878: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29879: LD_EXP 4
29883: PPUSH
29884: LD_STRING DS4
29886: PPUSH
29887: CALL_OW 94
// Wait ( 1 1$25 ) ;
29891: LD_INT 2975
29893: PPUSH
29894: CALL_OW 67
// if not isTest then
29898: LD_EXP 1
29902: NOT
29903: IFFALSE 29932
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29905: LD_INT 20
29907: PPUSH
29908: LD_INT 5
29910: PUSH
29911: LD_INT 6
29913: PUSH
29914: LD_INT 7
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: LIST
29921: PUSH
29922: LD_OWVAR 67
29926: ARRAY
29927: PPUSH
29928: CALL 6956 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29932: LD_VAR 0 1
29936: PUSH
29937: LD_INT 22
29939: PUSH
29940: LD_INT 4
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 21
29949: PUSH
29950: LD_INT 3
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PPUSH
29961: CALL_OW 69
29965: IN
29966: PUSH
29967: LD_EXP 15
29971: NOT
29972: AND
29973: IFFALSE 30036
// begin alfa_south_triggered := true ;
29975: LD_ADDR_EXP 15
29979: PUSH
29980: LD_INT 1
29982: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29983: LD_EXP 3
29987: PPUSH
29988: LD_STRING DJ3
29990: PPUSH
29991: CALL_OW 94
// Wait ( 0 0$45 ) ;
29995: LD_INT 1575
29997: PPUSH
29998: CALL_OW 67
// if not isTest then
30002: LD_EXP 1
30006: NOT
30007: IFFALSE 30036
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30009: LD_INT 20
30011: PPUSH
30012: LD_INT 5
30014: PUSH
30015: LD_INT 6
30017: PUSH
30018: LD_INT 7
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: LIST
30025: PUSH
30026: LD_OWVAR 67
30030: ARRAY
30031: PPUSH
30032: CALL 6956 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30036: LD_VAR 0 1
30040: PPUSH
30041: CALL_OW 266
30045: PUSH
30046: LD_INT 1
30048: EQUAL
30049: PUSH
30050: LD_VAR 0 1
30054: PPUSH
30055: CALL_OW 255
30059: PUSH
30060: LD_INT 1
30062: PUSH
30063: LD_INT 4
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: IN
30070: AND
30071: IFFALSE 30080
// RaiseSailEvent ( 104 ) ;
30073: LD_INT 104
30075: PPUSH
30076: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30080: LD_EXP 40
30084: PUSH
30085: LD_VAR 0 1
30089: PPUSH
30090: CALL_OW 255
30094: ARRAY
30095: IFFALSE 30482
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30097: LD_STRING UnitDestroyed [side 
30099: PUSH
30100: LD_VAR 0 1
30104: PPUSH
30105: CALL_OW 255
30109: STR
30110: PUSH
30111: LD_STRING ; id: 
30113: STR
30114: PUSH
30115: LD_VAR 0 1
30119: STR
30120: PUSH
30121: LD_STRING ; type: 
30123: STR
30124: PUSH
30125: LD_VAR 0 1
30129: PPUSH
30130: CALL_OW 247
30134: STR
30135: PUSH
30136: LD_STRING ]
30138: STR
30139: PPUSH
30140: CALL 7818 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30144: LD_VAR 0 1
30148: PUSH
30149: LD_VAR 0 1
30153: PPUSH
30154: CALL_OW 255
30158: PPUSH
30159: LD_INT 21
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PPUSH
30169: CALL 11421 0 2
30173: IN
30174: IFFALSE 30330
// begin if MCF_HasClass ( un ) then
30176: LD_VAR 0 1
30180: PPUSH
30181: CALL 14127 0 1
30185: IFFALSE 30330
// case MCF_HasClass ( un ) of 1 :
30187: LD_VAR 0 1
30191: PPUSH
30192: CALL 14127 0 1
30196: PUSH
30197: LD_INT 1
30199: DOUBLE
30200: EQUAL
30201: IFTRUE 30205
30203: GO 30230
30205: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30206: LD_VAR 0 1
30210: PPUSH
30211: CALL_OW 255
30215: PPUSH
30216: LD_STRING ToArm
30218: PPUSH
30219: LD_VAR 0 1
30223: PPUSH
30224: CALL 14300 0 3
30228: GO 30330
30230: LD_INT 2
30232: DOUBLE
30233: EQUAL
30234: IFTRUE 30238
30236: GO 30263
30238: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30239: LD_VAR 0 1
30243: PPUSH
30244: CALL_OW 255
30248: PPUSH
30249: LD_STRING ToDep
30251: PPUSH
30252: LD_VAR 0 1
30256: PPUSH
30257: CALL 14300 0 3
30261: GO 30330
30263: LD_INT 3
30265: DOUBLE
30266: EQUAL
30267: IFTRUE 30271
30269: GO 30296
30271: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30272: LD_VAR 0 1
30276: PPUSH
30277: CALL_OW 255
30281: PPUSH
30282: LD_STRING ToFac
30284: PPUSH
30285: LD_VAR 0 1
30289: PPUSH
30290: CALL 14300 0 3
30294: GO 30330
30296: LD_INT 4
30298: DOUBLE
30299: EQUAL
30300: IFTRUE 30304
30302: GO 30329
30304: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30305: LD_VAR 0 1
30309: PPUSH
30310: CALL_OW 255
30314: PPUSH
30315: LD_STRING ToLab
30317: PPUSH
30318: LD_VAR 0 1
30322: PPUSH
30323: CALL 14300 0 3
30327: GO 30330
30329: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30330: LD_VAR 0 1
30334: PUSH
30335: LD_EXP 68
30339: PUSH
30340: LD_VAR 0 1
30344: PPUSH
30345: CALL_OW 255
30349: ARRAY
30350: IN
30351: IFFALSE 30436
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30353: LD_ADDR_EXP 68
30357: PUSH
30358: LD_EXP 68
30362: PPUSH
30363: LD_VAR 0 1
30367: PPUSH
30368: LD_INT 0
30370: PPUSH
30371: CALL 31118 0 3
30375: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30376: LD_VAR 0 1
30380: PPUSH
30381: CALL_OW 255
30385: PPUSH
30386: LD_VAR 0 1
30390: PPUSH
30391: CALL_OW 265
30395: PUSH
30396: LD_VAR 0 1
30400: PPUSH
30401: CALL_OW 262
30405: PUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: CALL_OW 263
30415: PUSH
30416: LD_VAR 0 1
30420: PPUSH
30421: CALL_OW 264
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: PPUSH
30432: CALL 20940 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30436: LD_VAR 0 1
30440: PUSH
30441: LD_EXP 72
30445: PUSH
30446: LD_VAR 0 1
30450: PPUSH
30451: CALL_OW 255
30455: ARRAY
30456: IN
30457: IFFALSE 30482
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30459: LD_ADDR_EXP 72
30463: PUSH
30464: LD_EXP 72
30468: PPUSH
30469: LD_VAR 0 1
30473: PPUSH
30474: LD_INT 0
30476: PPUSH
30477: CALL 31118 0 3
30481: ST_TO_ADDR
// end ; end ;
30482: PPOPN 1
30484: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30485: LD_EXP 40
30489: PUSH
30490: LD_VAR 0 2
30494: PPUSH
30495: CALL_OW 255
30499: ARRAY
30500: IFFALSE 30672
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30502: LD_VAR 0 2
30506: PUSH
30507: LD_EXP 69
30511: PUSH
30512: LD_VAR 0 2
30516: PPUSH
30517: CALL_OW 255
30521: ARRAY
30522: IN
30523: PUSH
30524: LD_VAR 0 1
30528: PPUSH
30529: CALL_OW 266
30533: PUSH
30534: LD_INT 32
30536: PUSH
30537: LD_INT 31
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: IN
30544: AND
30545: IFFALSE 30645
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30547: LD_ADDR_EXP 69
30551: PUSH
30552: LD_EXP 69
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: LD_INT 0
30564: PPUSH
30565: CALL 31118 0 3
30569: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30570: LD_ADDR_EXP 69
30574: PUSH
30575: LD_EXP 69
30579: PPUSH
30580: LD_VAR 0 2
30584: PPUSH
30585: LD_INT 0
30587: PPUSH
30588: CALL 31118 0 3
30592: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30593: LD_EXP 69
30597: PUSH
30598: LD_VAR 0 2
30602: PPUSH
30603: CALL_OW 255
30607: ARRAY
30608: PUSH
30609: LD_STRING 
30611: EQUAL
30612: IFFALSE 30645
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30614: LD_ADDR_EXP 69
30618: PUSH
30619: LD_EXP 69
30623: PPUSH
30624: LD_VAR 0 2
30628: PPUSH
30629: CALL_OW 255
30633: PPUSH
30634: LD_INT 1
30636: PPUSH
30637: LD_INT 0
30639: PPUSH
30640: CALL 30959 0 4
30644: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30645: LD_VAR 0 1
30649: PPUSH
30650: CALL_OW 266
30654: PUSH
30655: LD_INT 36
30657: IN
30658: IFFALSE 30672
// SetTag ( un , 0 ) ;
30660: LD_VAR 0 2
30664: PPUSH
30665: LD_INT 0
30667: PPUSH
30668: CALL_OW 109
// end ;
30672: PPOPN 2
30674: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30675: LD_EXP 40
30679: PUSH
30680: LD_VAR 0 1
30684: PPUSH
30685: CALL_OW 255
30689: ARRAY
30690: IFFALSE 30716
// begin if GetControl ( un ) = control_remote then
30692: LD_VAR 0 1
30696: PPUSH
30697: CALL_OW 263
30701: PUSH
30702: LD_INT 2
30704: EQUAL
30705: IFFALSE 30716
// ComUnlink ( un ) ;
30707: LD_VAR 0 1
30711: PPUSH
30712: CALL_OW 136
// end ;
30716: PPOPN 1
30718: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30719: LD_EXP 40
30723: PUSH
30724: LD_VAR 0 1
30728: PPUSH
30729: CALL_OW 255
30733: ARRAY
30734: IFFALSE 30763
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30736: LD_VAR 0 2
30740: PPUSH
30741: CALL_OW 264
30745: PUSH
30746: LD_INT 31
30748: IN
30749: IFFALSE 30763
// SetTag ( driver , 0 ) ;
30751: LD_VAR 0 1
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL_OW 109
// end ;
30763: PPOPN 4
30765: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30766: LD_INT 0
30768: PPUSH
30769: PPUSH
30770: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30771: LD_ADDR_VAR 0 3
30775: PUSH
30776: LD_VAR 0 1
30780: PPUSH
30781: CALL_OW 269
30785: ST_TO_ADDR
// x := GetX ( building ) ;
30786: LD_ADDR_VAR 0 4
30790: PUSH
30791: LD_VAR 0 1
30795: PPUSH
30796: CALL_OW 250
30800: ST_TO_ADDR
// y := GetY ( building ) ;
30801: LD_ADDR_VAR 0 5
30805: PUSH
30806: LD_VAR 0 1
30810: PPUSH
30811: CALL_OW 251
30815: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30816: LD_ADDR_EXP 44
30820: PUSH
30821: LD_EXP 44
30825: PPUSH
30826: LD_VAR 0 1
30830: PPUSH
30831: CALL_OW 255
30835: PPUSH
30836: LD_VAR 0 3
30840: PPUSH
30841: LD_VAR 0 4
30845: PUSH
30846: LD_VAR 0 5
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PPUSH
30855: CALL 42332 0 4
30859: ST_TO_ADDR
// end ;
30860: PPOPN 5
30862: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30863: LD_VAR 0 1
30867: PUSH
30868: LD_EXP 31
30872: IN
30873: NOT
30874: IFFALSE 30922
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30876: LD_ADDR_EXP 31
30880: PUSH
30881: LD_EXP 31
30885: PPUSH
30886: LD_EXP 31
30890: PUSH
30891: LD_INT 1
30893: PLUS
30894: PPUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 2
30904: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30905: LD_STRING DestinationUnrechable. [unit: 
30907: PUSH
30908: LD_VAR 0 1
30912: STR
30913: PUSH
30914: LD_STRING ]
30916: STR
30917: PPUSH
30918: CALL 7818 0 1
// end ; end ;
30922: PPOPN 1
30924: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
30925: LD_VAR 0 1
30929: PPUSH
30930: LD_VAR 0 2
30934: PPUSH
30935: LD_VAR 0 3
30939: PPUSH
30940: CALL 54526 0 3
// end ;
30944: PPOPN 3
30946: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL 54534 0 1
// end ; end_of_file
30956: PPOPN 1
30958: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30959: LD_INT 0
30961: PPUSH
30962: PPUSH
30963: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30964: LD_ADDR_VAR 0 7
30968: PUSH
30969: LD_VAR 0 1
30973: PUSH
30974: LD_VAR 0 2
30978: ARRAY
30979: PPUSH
30980: LD_VAR 0 3
30984: PPUSH
30985: LD_VAR 0 4
30989: PPUSH
30990: CALL_OW 1
30994: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30995: LD_ADDR_VAR 0 1
30999: PUSH
31000: LD_VAR 0 1
31004: PPUSH
31005: LD_VAR 0 2
31009: PPUSH
31010: LD_VAR 0 7
31014: PPUSH
31015: CALL_OW 1
31019: ST_TO_ADDR
// result := tab ;
31020: LD_ADDR_VAR 0 5
31024: PUSH
31025: LD_VAR 0 1
31029: ST_TO_ADDR
// end ;
31030: LD_VAR 0 5
31034: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31035: LD_INT 0
31037: PPUSH
31038: PPUSH
31039: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31040: LD_ADDR_VAR 0 5
31044: PUSH
31045: LD_VAR 0 1
31049: PUSH
31050: LD_VAR 0 2
31054: PUSH
31055: LD_INT 1
31057: ARRAY
31058: ARRAY
31059: PPUSH
31060: LD_VAR 0 2
31064: PUSH
31065: LD_INT 2
31067: ARRAY
31068: PPUSH
31069: CALL_OW 3
31073: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31074: LD_ADDR_VAR 0 1
31078: PUSH
31079: LD_VAR 0 1
31083: PPUSH
31084: LD_VAR 0 2
31088: PUSH
31089: LD_INT 1
31091: ARRAY
31092: PPUSH
31093: LD_VAR 0 5
31097: PPUSH
31098: CALL_OW 1
31102: ST_TO_ADDR
// result := tab ;
31103: LD_ADDR_VAR 0 3
31107: PUSH
31108: LD_VAR 0 1
31112: ST_TO_ADDR
// end ;
31113: LD_VAR 0 3
31117: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31118: LD_INT 0
31120: PPUSH
31121: PPUSH
31122: PPUSH
31123: PPUSH
// i := 1 ;
31124: LD_ADDR_VAR 0 5
31128: PUSH
31129: LD_INT 1
31131: ST_TO_ADDR
// while ( i <= tab ) do
31132: LD_VAR 0 5
31136: PUSH
31137: LD_VAR 0 1
31141: LESSEQUAL
31142: IFFALSE 31517
// begin if not tab [ i ] then
31144: LD_VAR 0 1
31148: PUSH
31149: LD_VAR 0 5
31153: ARRAY
31154: NOT
31155: IFFALSE 31159
// break ;
31157: GO 31517
// if value in tab then
31159: LD_VAR 0 2
31163: PUSH
31164: LD_VAR 0 1
31168: IN
31169: IFFALSE 31282
// begin if not mode then
31171: LD_VAR 0 3
31175: NOT
31176: IFFALSE 31196
// tab := tab diff value else
31178: LD_ADDR_VAR 0 1
31182: PUSH
31183: LD_VAR 0 1
31187: PUSH
31188: LD_VAR 0 2
31192: DIFF
31193: ST_TO_ADDR
31194: GO 31258
// for j = 1 to tab do
31196: LD_ADDR_VAR 0 6
31200: PUSH
31201: DOUBLE
31202: LD_INT 1
31204: DEC
31205: ST_TO_ADDR
31206: LD_VAR 0 1
31210: PUSH
31211: FOR_TO
31212: IFFALSE 31256
// if tab [ j ] = value then
31214: LD_VAR 0 1
31218: PUSH
31219: LD_VAR 0 6
31223: ARRAY
31224: PUSH
31225: LD_VAR 0 2
31229: EQUAL
31230: IFFALSE 31254
// begin tab := Delete ( tab , j ) ;
31232: LD_ADDR_VAR 0 1
31236: PUSH
31237: LD_VAR 0 1
31241: PPUSH
31242: LD_VAR 0 6
31246: PPUSH
31247: CALL_OW 3
31251: ST_TO_ADDR
// break ;
31252: GO 31256
// end ;
31254: GO 31211
31256: POP
31257: POP
// i := i - 1 ;
31258: LD_ADDR_VAR 0 5
31262: PUSH
31263: LD_VAR 0 5
31267: PUSH
31268: LD_INT 1
31270: MINUS
31271: ST_TO_ADDR
// if mode then
31272: LD_VAR 0 3
31276: IFFALSE 31280
// break ;
31278: GO 31517
// end else
31280: GO 31501
// if tab [ i ] and value in tab [ i ] then
31282: LD_VAR 0 1
31286: PUSH
31287: LD_VAR 0 5
31291: ARRAY
31292: PUSH
31293: LD_VAR 0 2
31297: PUSH
31298: LD_VAR 0 1
31302: PUSH
31303: LD_VAR 0 5
31307: ARRAY
31308: IN
31309: AND
31310: IFFALSE 31501
// begin if not mode then
31312: LD_VAR 0 3
31316: NOT
31317: IFFALSE 31343
// tmp := tab [ i ] diff value else
31319: LD_ADDR_VAR 0 7
31323: PUSH
31324: LD_VAR 0 1
31328: PUSH
31329: LD_VAR 0 5
31333: ARRAY
31334: PUSH
31335: LD_VAR 0 2
31339: DIFF
31340: ST_TO_ADDR
31341: GO 31423
// for j = 1 to tab [ i ] do
31343: LD_ADDR_VAR 0 6
31347: PUSH
31348: DOUBLE
31349: LD_INT 1
31351: DEC
31352: ST_TO_ADDR
31353: LD_VAR 0 1
31357: PUSH
31358: LD_VAR 0 5
31362: ARRAY
31363: PUSH
31364: FOR_TO
31365: IFFALSE 31421
// if value = tab [ i ] [ j ] then
31367: LD_VAR 0 2
31371: PUSH
31372: LD_VAR 0 1
31376: PUSH
31377: LD_VAR 0 5
31381: ARRAY
31382: PUSH
31383: LD_VAR 0 6
31387: ARRAY
31388: EQUAL
31389: IFFALSE 31419
// begin tmp := Delete ( tab [ i ] , j ) ;
31391: LD_ADDR_VAR 0 7
31395: PUSH
31396: LD_VAR 0 1
31400: PUSH
31401: LD_VAR 0 5
31405: ARRAY
31406: PPUSH
31407: LD_VAR 0 6
31411: PPUSH
31412: CALL_OW 3
31416: ST_TO_ADDR
// break ;
31417: GO 31421
// end ;
31419: GO 31364
31421: POP
31422: POP
// if tmp = [ ] then
31423: LD_VAR 0 7
31427: PUSH
31428: EMPTY
31429: EQUAL
31430: IFFALSE 31454
// begin tab := Delete ( tab , i ) ;
31432: LD_ADDR_VAR 0 1
31436: PUSH
31437: LD_VAR 0 1
31441: PPUSH
31442: LD_VAR 0 5
31446: PPUSH
31447: CALL_OW 3
31451: ST_TO_ADDR
// end else
31452: GO 31479
// tab := Replace ( tab , i , tmp ) ;
31454: LD_ADDR_VAR 0 1
31458: PUSH
31459: LD_VAR 0 1
31463: PPUSH
31464: LD_VAR 0 5
31468: PPUSH
31469: LD_VAR 0 7
31473: PPUSH
31474: CALL_OW 1
31478: ST_TO_ADDR
// i := i - 1 ;
31479: LD_ADDR_VAR 0 5
31483: PUSH
31484: LD_VAR 0 5
31488: PUSH
31489: LD_INT 1
31491: MINUS
31492: ST_TO_ADDR
// if mode then
31493: LD_VAR 0 3
31497: IFFALSE 31501
// break ;
31499: GO 31517
// end ; i := i + 1 ;
31501: LD_ADDR_VAR 0 5
31505: PUSH
31506: LD_VAR 0 5
31510: PUSH
31511: LD_INT 1
31513: PLUS
31514: ST_TO_ADDR
// end ;
31515: GO 31132
// result := tab ;
31517: LD_ADDR_VAR 0 4
31521: PUSH
31522: LD_VAR 0 1
31526: ST_TO_ADDR
// end ;
31527: LD_VAR 0 4
31531: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31532: LD_INT 0
31534: PPUSH
31535: PPUSH
// for i = 1 to values do
31536: LD_ADDR_VAR 0 4
31540: PUSH
31541: DOUBLE
31542: LD_INT 1
31544: DEC
31545: ST_TO_ADDR
31546: LD_VAR 0 2
31550: PUSH
31551: FOR_TO
31552: IFFALSE 31585
// tab := Remove ( tab , values [ i ] , false ) ;
31554: LD_ADDR_VAR 0 1
31558: PUSH
31559: LD_VAR 0 1
31563: PPUSH
31564: LD_VAR 0 2
31568: PUSH
31569: LD_VAR 0 4
31573: ARRAY
31574: PPUSH
31575: LD_INT 0
31577: PPUSH
31578: CALL 31118 0 3
31582: ST_TO_ADDR
31583: GO 31551
31585: POP
31586: POP
// result := tab ;
31587: LD_ADDR_VAR 0 3
31591: PUSH
31592: LD_VAR 0 1
31596: ST_TO_ADDR
// end ;
31597: LD_VAR 0 3
31601: RET
// export function IsDriver ( unit ) ; begin
31602: LD_INT 0
31604: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31605: LD_VAR 0 1
31609: PUSH
31610: LD_INT 55
31612: PUSH
31613: EMPTY
31614: LIST
31615: PPUSH
31616: CALL_OW 69
31620: IN
31621: IFFALSE 31640
// result := IsInUnit ( unit ) else
31623: LD_ADDR_VAR 0 2
31627: PUSH
31628: LD_VAR 0 1
31632: PPUSH
31633: CALL_OW 310
31637: ST_TO_ADDR
31638: GO 31648
// result := false ;
31640: LD_ADDR_VAR 0 2
31644: PUSH
31645: LD_INT 0
31647: ST_TO_ADDR
// end ;
31648: LD_VAR 0 2
31652: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31653: LD_INT 0
31655: PPUSH
31656: PPUSH
31657: PPUSH
// if not GetControl ( veh ) = control_manual then
31658: LD_VAR 0 1
31662: PPUSH
31663: CALL_OW 263
31667: PUSH
31668: LD_INT 1
31670: EQUAL
31671: NOT
31672: IFFALSE 31684
// result := false else
31674: LD_ADDR_VAR 0 2
31678: PUSH
31679: LD_INT 0
31681: ST_TO_ADDR
31682: GO 31829
// if veh in FilterAllUnits ( [ f_empty ] ) then
31684: LD_VAR 0 1
31688: PUSH
31689: LD_INT 58
31691: PUSH
31692: EMPTY
31693: LIST
31694: PPUSH
31695: CALL_OW 69
31699: IN
31700: IFFALSE 31712
// result := false else
31702: LD_ADDR_VAR 0 2
31706: PUSH
31707: LD_INT 0
31709: ST_TO_ADDR
31710: GO 31829
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31712: LD_ADDR_VAR 0 4
31716: PUSH
31717: LD_INT 22
31719: PUSH
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 255
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 55
31736: PUSH
31737: EMPTY
31738: LIST
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PPUSH
31744: CALL_OW 69
31748: ST_TO_ADDR
// if not filter then
31749: LD_VAR 0 4
31753: NOT
31754: IFFALSE 31766
// result := false else
31756: LD_ADDR_VAR 0 2
31760: PUSH
31761: LD_INT 0
31763: ST_TO_ADDR
31764: GO 31829
// for i = 1 to filter do
31766: LD_ADDR_VAR 0 3
31770: PUSH
31771: DOUBLE
31772: LD_INT 1
31774: DEC
31775: ST_TO_ADDR
31776: LD_VAR 0 4
31780: PUSH
31781: FOR_TO
31782: IFFALSE 31827
// if IsDriver ( filter [ i ] ) = veh then
31784: LD_VAR 0 4
31788: PUSH
31789: LD_VAR 0 3
31793: ARRAY
31794: PPUSH
31795: CALL 31602 0 1
31799: PUSH
31800: LD_VAR 0 1
31804: EQUAL
31805: IFFALSE 31825
// begin result := filter [ i ] ;
31807: LD_ADDR_VAR 0 2
31811: PUSH
31812: LD_VAR 0 4
31816: PUSH
31817: LD_VAR 0 3
31821: ARRAY
31822: ST_TO_ADDR
// break ;
31823: GO 31827
// end ;
31825: GO 31781
31827: POP
31828: POP
// end ; end ;
31829: LD_VAR 0 2
31833: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31834: LD_INT 0
31836: PPUSH
31837: PPUSH
// if BuildingStatus ( b ) = bs_build then
31838: LD_VAR 0 2
31842: PPUSH
31843: CALL_OW 461
31847: PUSH
31848: LD_INT 1
31850: EQUAL
31851: IFFALSE 31911
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31853: LD_VAR 0 1
31857: PPUSH
31858: LD_STRING h
31860: PUSH
31861: LD_VAR 0 2
31865: PPUSH
31866: CALL_OW 250
31870: PUSH
31871: LD_VAR 0 2
31875: PPUSH
31876: CALL_OW 251
31880: PUSH
31881: LD_VAR 0 2
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: PUSH
31904: EMPTY
31905: LIST
31906: PPUSH
31907: CALL_OW 446
// end ;
31911: LD_VAR 0 3
31915: RET
// export function Compare ( val1 , val2 ) ; begin
31916: LD_INT 0
31918: PPUSH
// if val1 = val2 then
31919: LD_VAR 0 1
31923: PUSH
31924: LD_VAR 0 2
31928: EQUAL
31929: IFFALSE 31941
// result := true else
31931: LD_ADDR_VAR 0 3
31935: PUSH
31936: LD_INT 1
31938: ST_TO_ADDR
31939: GO 31949
// result := false ;
31941: LD_ADDR_VAR 0 3
31945: PUSH
31946: LD_INT 0
31948: ST_TO_ADDR
// end ;
31949: LD_VAR 0 3
31953: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31954: LD_INT 0
31956: PPUSH
31957: PPUSH
// result := true ;
31958: LD_ADDR_VAR 0 3
31962: PUSH
31963: LD_INT 1
31965: ST_TO_ADDR
// if array1 = array2 then
31966: LD_VAR 0 1
31970: PUSH
31971: LD_VAR 0 2
31975: EQUAL
31976: IFFALSE 32041
// begin for i = 1 to array1 do
31978: LD_ADDR_VAR 0 4
31982: PUSH
31983: DOUBLE
31984: LD_INT 1
31986: DEC
31987: ST_TO_ADDR
31988: LD_VAR 0 1
31992: PUSH
31993: FOR_TO
31994: IFFALSE 32037
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31996: LD_VAR 0 1
32000: PUSH
32001: LD_VAR 0 4
32005: ARRAY
32006: PPUSH
32007: LD_VAR 0 2
32011: PUSH
32012: LD_VAR 0 4
32016: ARRAY
32017: PPUSH
32018: CALL 31916 0 2
32022: NOT
32023: IFFALSE 32035
// begin result := false ;
32025: LD_ADDR_VAR 0 3
32029: PUSH
32030: LD_INT 0
32032: ST_TO_ADDR
// break ;
32033: GO 32037
// end ;
32035: GO 31993
32037: POP
32038: POP
// end else
32039: GO 32049
// result := false ;
32041: LD_ADDR_VAR 0 3
32045: PUSH
32046: LD_INT 0
32048: ST_TO_ADDR
// end ;
32049: LD_VAR 0 3
32053: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32054: LD_INT 0
32056: PPUSH
32057: PPUSH
// result := false ;
32058: LD_ADDR_VAR 0 3
32062: PUSH
32063: LD_INT 0
32065: ST_TO_ADDR
// for j = 1 to e2 do
32066: LD_ADDR_VAR 0 4
32070: PUSH
32071: DOUBLE
32072: LD_INT 1
32074: DEC
32075: ST_TO_ADDR
32076: LD_VAR 0 2
32080: PUSH
32081: FOR_TO
32082: IFFALSE 32116
// if Compare ( e1 , e2 [ j ] ) then
32084: LD_VAR 0 1
32088: PPUSH
32089: LD_VAR 0 2
32093: PUSH
32094: LD_VAR 0 4
32098: ARRAY
32099: PPUSH
32100: CALL 31916 0 2
32104: IFFALSE 32114
// result := true ;
32106: LD_ADDR_VAR 0 3
32110: PUSH
32111: LD_INT 1
32113: ST_TO_ADDR
32114: GO 32081
32116: POP
32117: POP
// end ;
32118: LD_VAR 0 3
32122: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32123: LD_INT 0
32125: PPUSH
32126: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32127: LD_VAR 0 1
32131: PPUSH
32132: LD_STRING C
32134: PUSH
32135: LD_VAR 0 2
32139: PUSH
32140: LD_VAR 0 3
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: PUSH
32166: LD_STRING v
32168: PUSH
32169: LD_VAR 0 4
32173: PPUSH
32174: CALL_OW 250
32178: PUSH
32179: LD_VAR 0 4
32183: PPUSH
32184: CALL_OW 251
32188: PUSH
32189: LD_VAR 0 4
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: LD_INT 0
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PPUSH
32216: CALL_OW 446
// end ;
32220: LD_VAR 0 5
32224: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32225: LD_INT 0
32227: PPUSH
32228: PPUSH
32229: PPUSH
// linked := UnitsLinked ( unit ) ;
32230: LD_ADDR_VAR 0 4
32234: PUSH
32235: LD_VAR 0 1
32239: PPUSH
32240: CALL_OW 432
32244: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32245: LD_ADDR_VAR 0 3
32249: PUSH
32250: LD_VAR 0 1
32254: PPUSH
32255: LD_INT 3
32257: PPUSH
32258: CALL_OW 259
32262: ST_TO_ADDR
// if sk > linked then
32263: LD_VAR 0 3
32267: PUSH
32268: LD_VAR 0 4
32272: GREATER
32273: IFFALSE 32285
// result := true else
32275: LD_ADDR_VAR 0 2
32279: PUSH
32280: LD_INT 1
32282: ST_TO_ADDR
32283: GO 32293
// result := false ;
32285: LD_ADDR_VAR 0 2
32289: PUSH
32290: LD_INT 0
32292: ST_TO_ADDR
// end ;
32293: LD_VAR 0 2
32297: RET
// export function NotTask ( unit ) ; begin
32298: LD_INT 0
32300: PPUSH
// result := true ;
32301: LD_ADDR_VAR 0 2
32305: PUSH
32306: LD_INT 1
32308: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32309: LD_VAR 0 1
32313: PPUSH
32314: CALL_OW 437
32318: PUSH
32319: LD_VAR 0 1
32323: PPUSH
32324: CALL_OW 314
32328: OR
32329: IFFALSE 32339
// result := false ;
32331: LD_ADDR_VAR 0 2
32335: PUSH
32336: LD_INT 0
32338: ST_TO_ADDR
// end ;
32339: LD_VAR 0 2
32343: RET
// export function WantHeal ( sci , unit ) ; begin
32344: LD_INT 0
32346: PPUSH
// if GetTaskList ( sci ) > 0 then
32347: LD_VAR 0 1
32351: PPUSH
32352: CALL_OW 437
32356: PUSH
32357: LD_INT 0
32359: GREATER
32360: IFFALSE 32430
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32362: LD_VAR 0 1
32366: PPUSH
32367: CALL_OW 437
32371: PUSH
32372: LD_INT 1
32374: ARRAY
32375: PUSH
32376: LD_INT 1
32378: ARRAY
32379: PUSH
32380: LD_STRING l
32382: EQUAL
32383: PUSH
32384: LD_VAR 0 1
32388: PPUSH
32389: CALL_OW 437
32393: PUSH
32394: LD_INT 1
32396: ARRAY
32397: PUSH
32398: LD_INT 4
32400: ARRAY
32401: PUSH
32402: LD_VAR 0 2
32406: EQUAL
32407: AND
32408: IFFALSE 32420
// result := true else
32410: LD_ADDR_VAR 0 3
32414: PUSH
32415: LD_INT 1
32417: ST_TO_ADDR
32418: GO 32428
// result := false ;
32420: LD_ADDR_VAR 0 3
32424: PUSH
32425: LD_INT 0
32427: ST_TO_ADDR
// end else
32428: GO 32438
// result := false ;
32430: LD_ADDR_VAR 0 3
32434: PUSH
32435: LD_INT 0
32437: ST_TO_ADDR
// end ;
32438: LD_VAR 0 3
32442: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32443: LD_INT 0
32445: PPUSH
32446: PPUSH
32447: PPUSH
32448: PPUSH
32449: PPUSH
// dist := 99999 ;
32450: LD_ADDR_VAR 0 7
32454: PUSH
32455: LD_INT 99999
32457: ST_TO_ADDR
// un := - 1 ;
32458: LD_ADDR_VAR 0 6
32462: PUSH
32463: LD_INT 1
32465: NEG
32466: ST_TO_ADDR
// if units1 and units2 then
32467: LD_VAR 0 1
32471: PUSH
32472: LD_VAR 0 2
32476: AND
32477: IFFALSE 32565
// for i in units1 do
32479: LD_ADDR_VAR 0 4
32483: PUSH
32484: LD_VAR 0 1
32488: PUSH
32489: FOR_IN
32490: IFFALSE 32563
// for j in units2 do
32492: LD_ADDR_VAR 0 5
32496: PUSH
32497: LD_VAR 0 2
32501: PUSH
32502: FOR_IN
32503: IFFALSE 32559
// if GetDistUnits ( i , j ) < dist then
32505: LD_VAR 0 4
32509: PPUSH
32510: LD_VAR 0 5
32514: PPUSH
32515: CALL_OW 296
32519: PUSH
32520: LD_VAR 0 7
32524: LESS
32525: IFFALSE 32557
// begin un := i ;
32527: LD_ADDR_VAR 0 6
32531: PUSH
32532: LD_VAR 0 4
32536: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32537: LD_ADDR_VAR 0 7
32541: PUSH
32542: LD_VAR 0 4
32546: PPUSH
32547: LD_VAR 0 5
32551: PPUSH
32552: CALL_OW 296
32556: ST_TO_ADDR
// end ;
32557: GO 32502
32559: POP
32560: POP
32561: GO 32489
32563: POP
32564: POP
// result := [ un , dist ] ;
32565: LD_ADDR_VAR 0 3
32569: PUSH
32570: LD_VAR 0 6
32574: PUSH
32575: LD_VAR 0 7
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: ST_TO_ADDR
// end ;
32584: LD_VAR 0 3
32588: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32589: LD_INT 0
32591: PPUSH
32592: PPUSH
32593: PPUSH
32594: PPUSH
32595: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32596: LD_VAR 0 1
32600: NOT
32601: PUSH
32602: LD_VAR 0 1
32606: PPUSH
32607: CALL_OW 256
32611: PUSH
32612: LD_INT 250
32614: LESS
32615: OR
32616: PUSH
32617: LD_VAR 0 1
32621: PPUSH
32622: CALL_OW 314
32626: PUSH
32627: LD_VAR 0 1
32631: PPUSH
32632: CALL_OW 261
32636: PUSH
32637: LD_INT 20
32639: GREATER
32640: AND
32641: OR
32642: IFFALSE 32646
// exit ;
32644: GO 33020
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32646: LD_VAR 0 1
32650: PPUSH
32651: CALL_OW 261
32655: PUSH
32656: LD_INT 20
32658: LESS
32659: PUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 110
32669: PUSH
32670: LD_INT 21
32672: EQUAL
32673: NOT
32674: AND
32675: IFFALSE 32711
// begin ComStop ( bulldozer ) ;
32677: LD_VAR 0 1
32681: PPUSH
32682: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32686: LD_VAR 0 1
32690: PPUSH
32691: LD_INT 21
32693: PPUSH
32694: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32698: LD_VAR 0 1
32702: PPUSH
32703: CALL 26119 0 1
// exit ;
32707: GO 33020
// end else
32709: GO 32738
// if GetFuel ( bulldozer ) > 20 then
32711: LD_VAR 0 1
32715: PPUSH
32716: CALL_OW 261
32720: PUSH
32721: LD_INT 20
32723: GREATER
32724: IFFALSE 32738
// SetTag ( bulldozer , 0 ) ;
32726: LD_VAR 0 1
32730: PPUSH
32731: LD_INT 0
32733: PPUSH
32734: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32738: LD_ADDR_VAR 0 5
32742: PUSH
32743: LD_VAR 0 2
32747: PPUSH
32748: CALL_OW 353
32752: ST_TO_ADDR
// tmp := [ ] ;
32753: LD_ADDR_VAR 0 6
32757: PUSH
32758: EMPTY
32759: ST_TO_ADDR
// for i = 1 to list do
32760: LD_ADDR_VAR 0 4
32764: PUSH
32765: DOUBLE
32766: LD_INT 1
32768: DEC
32769: ST_TO_ADDR
32770: LD_VAR 0 5
32774: PUSH
32775: FOR_TO
32776: IFFALSE 32874
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32778: LD_VAR 0 5
32782: PUSH
32783: LD_VAR 0 4
32787: ARRAY
32788: PUSH
32789: LD_INT 1
32791: ARRAY
32792: PPUSH
32793: LD_VAR 0 5
32797: PUSH
32798: LD_VAR 0 4
32802: ARRAY
32803: PUSH
32804: LD_INT 2
32806: ARRAY
32807: PPUSH
32808: CALL_OW 554
32812: IFFALSE 32872
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32814: LD_ADDR_VAR 0 6
32818: PUSH
32819: LD_VAR 0 6
32823: PPUSH
32824: LD_VAR 0 6
32828: PUSH
32829: LD_INT 1
32831: PLUS
32832: PPUSH
32833: LD_VAR 0 5
32837: PUSH
32838: LD_VAR 0 4
32842: ARRAY
32843: PUSH
32844: LD_INT 1
32846: ARRAY
32847: PUSH
32848: LD_VAR 0 5
32852: PUSH
32853: LD_VAR 0 4
32857: ARRAY
32858: PUSH
32859: LD_INT 2
32861: ARRAY
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PPUSH
32867: CALL_OW 1
32871: ST_TO_ADDR
// end ;
32872: GO 32775
32874: POP
32875: POP
// ComStop ( bulldozer ) ;
32876: LD_VAR 0 1
32880: PPUSH
32881: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32885: LD_ADDR_VAR 0 7
32889: PUSH
32890: LD_VAR 0 1
32894: PPUSH
32895: CALL_OW 250
32899: PUSH
32900: LD_VAR 0 1
32904: PPUSH
32905: CALL_OW 251
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: ST_TO_ADDR
// for i = tmp downto 1 do
32914: LD_ADDR_VAR 0 4
32918: PUSH
32919: DOUBLE
32920: LD_VAR 0 6
32924: INC
32925: ST_TO_ADDR
32926: LD_INT 1
32928: PUSH
32929: FOR_DOWNTO
32930: IFFALSE 33018
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32932: LD_ADDR_VAR 0 7
32936: PUSH
32937: LD_VAR 0 7
32941: PUSH
32942: LD_INT 1
32944: ARRAY
32945: PPUSH
32946: LD_VAR 0 7
32950: PUSH
32951: LD_INT 2
32953: ARRAY
32954: PPUSH
32955: LD_VAR 0 6
32959: PPUSH
32960: CALL 33121 0 3
32964: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32965: LD_VAR 0 1
32969: PPUSH
32970: LD_VAR 0 7
32974: PUSH
32975: LD_INT 1
32977: ARRAY
32978: PPUSH
32979: LD_VAR 0 7
32983: PUSH
32984: LD_INT 2
32986: ARRAY
32987: PPUSH
32988: CALL 33025 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32992: LD_ADDR_VAR 0 6
32996: PUSH
32997: LD_VAR 0 6
33001: PPUSH
33002: LD_VAR 0 7
33006: PUSH
33007: LD_INT 3
33009: ARRAY
33010: PPUSH
33011: CALL_OW 3
33015: ST_TO_ADDR
// end ;
33016: GO 32929
33018: POP
33019: POP
// end ;
33020: LD_VAR 0 3
33024: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
33025: LD_INT 0
33027: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
33028: LD_VAR 0 2
33032: PPUSH
33033: LD_VAR 0 3
33037: PPUSH
33038: CALL_OW 351
33042: PUSH
33043: LD_VAR 0 2
33047: PPUSH
33048: LD_VAR 0 3
33052: PPUSH
33053: CALL_OW 554
33057: AND
33058: PUSH
33059: LD_VAR 0 2
33063: PPUSH
33064: LD_VAR 0 3
33068: PPUSH
33069: CALL_OW 488
33073: AND
33074: PUSH
33075: LD_VAR 0 2
33079: PPUSH
33080: LD_VAR 0 3
33084: PPUSH
33085: CALL_OW 428
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: EQUAL
33094: AND
33095: IFFALSE 33116
// AddComMoveXY ( bulldozer , x , y ) ;
33097: LD_VAR 0 1
33101: PPUSH
33102: LD_VAR 0 2
33106: PPUSH
33107: LD_VAR 0 3
33111: PPUSH
33112: CALL_OW 171
// end ;
33116: LD_VAR 0 4
33120: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33121: LD_INT 0
33123: PPUSH
33124: PPUSH
33125: PPUSH
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
// dist := 99999 ;
33130: LD_ADDR_VAR 0 6
33134: PUSH
33135: LD_INT 99999
33137: ST_TO_ADDR
// for i = 1 to list do
33138: LD_ADDR_VAR 0 5
33142: PUSH
33143: DOUBLE
33144: LD_INT 1
33146: DEC
33147: ST_TO_ADDR
33148: LD_VAR 0 3
33152: PUSH
33153: FOR_TO
33154: IFFALSE 33292
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33156: LD_ADDR_VAR 0 7
33160: PUSH
33161: LD_VAR 0 1
33165: PPUSH
33166: LD_VAR 0 2
33170: PPUSH
33171: LD_VAR 0 3
33175: PUSH
33176: LD_VAR 0 5
33180: ARRAY
33181: PUSH
33182: LD_INT 1
33184: ARRAY
33185: PPUSH
33186: LD_VAR 0 3
33190: PUSH
33191: LD_VAR 0 5
33195: ARRAY
33196: PUSH
33197: LD_INT 2
33199: ARRAY
33200: PPUSH
33201: CALL_OW 298
33205: ST_TO_ADDR
// if d = 0 then
33206: LD_VAR 0 7
33210: PUSH
33211: LD_INT 0
33213: EQUAL
33214: IFFALSE 33218
// continue ;
33216: GO 33153
// if d < dist then
33218: LD_VAR 0 7
33222: PUSH
33223: LD_VAR 0 6
33227: LESS
33228: IFFALSE 33290
// begin _x := list [ i ] [ 1 ] ;
33230: LD_ADDR_VAR 0 8
33234: PUSH
33235: LD_VAR 0 3
33239: PUSH
33240: LD_VAR 0 5
33244: ARRAY
33245: PUSH
33246: LD_INT 1
33248: ARRAY
33249: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33250: LD_ADDR_VAR 0 9
33254: PUSH
33255: LD_VAR 0 3
33259: PUSH
33260: LD_VAR 0 5
33264: ARRAY
33265: PUSH
33266: LD_INT 2
33268: ARRAY
33269: ST_TO_ADDR
// _i := i ;
33270: LD_ADDR_VAR 0 10
33274: PUSH
33275: LD_VAR 0 5
33279: ST_TO_ADDR
// dist := d ;
33280: LD_ADDR_VAR 0 6
33284: PUSH
33285: LD_VAR 0 7
33289: ST_TO_ADDR
// end ; end ;
33290: GO 33153
33292: POP
33293: POP
// result := [ _x , _y , _i , dist ] ;
33294: LD_ADDR_VAR 0 4
33298: PUSH
33299: LD_VAR 0 8
33303: PUSH
33304: LD_VAR 0 9
33308: PUSH
33309: LD_VAR 0 10
33313: PUSH
33314: LD_VAR 0 6
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: ST_TO_ADDR
// end ;
33325: LD_VAR 0 4
33329: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33330: LD_INT 0
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
// for i = 1 to list do
33337: LD_ADDR_VAR 0 5
33341: PUSH
33342: DOUBLE
33343: LD_INT 1
33345: DEC
33346: ST_TO_ADDR
33347: LD_VAR 0 1
33351: PUSH
33352: FOR_TO
33353: IFFALSE 33667
// begin for j = list downto 2 do
33355: LD_ADDR_VAR 0 6
33359: PUSH
33360: DOUBLE
33361: LD_VAR 0 1
33365: INC
33366: ST_TO_ADDR
33367: LD_INT 2
33369: PUSH
33370: FOR_DOWNTO
33371: IFFALSE 33663
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33373: LD_VAR 0 2
33377: PPUSH
33378: LD_VAR 0 3
33382: PPUSH
33383: LD_VAR 0 1
33387: PUSH
33388: LD_VAR 0 6
33392: ARRAY
33393: PUSH
33394: LD_INT 1
33396: ARRAY
33397: PPUSH
33398: LD_VAR 0 1
33402: PUSH
33403: LD_VAR 0 6
33407: ARRAY
33408: PUSH
33409: LD_INT 2
33411: ARRAY
33412: PPUSH
33413: CALL_OW 298
33417: PUSH
33418: LD_VAR 0 2
33422: PPUSH
33423: LD_VAR 0 3
33427: PPUSH
33428: LD_VAR 0 1
33432: PUSH
33433: LD_VAR 0 6
33437: PUSH
33438: LD_INT 1
33440: MINUS
33441: ARRAY
33442: PUSH
33443: LD_INT 1
33445: ARRAY
33446: PPUSH
33447: LD_VAR 0 1
33451: PUSH
33452: LD_VAR 0 6
33456: PUSH
33457: LD_INT 1
33459: MINUS
33460: ARRAY
33461: PUSH
33462: LD_INT 2
33464: ARRAY
33465: PPUSH
33466: CALL_OW 298
33470: LESS
33471: IFFALSE 33661
// begin _x := list [ j ] [ 1 ] ;
33473: LD_ADDR_VAR 0 7
33477: PUSH
33478: LD_VAR 0 1
33482: PUSH
33483: LD_VAR 0 6
33487: ARRAY
33488: PUSH
33489: LD_INT 1
33491: ARRAY
33492: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33493: LD_ADDR_VAR 0 8
33497: PUSH
33498: LD_VAR 0 1
33502: PUSH
33503: LD_VAR 0 6
33507: ARRAY
33508: PUSH
33509: LD_INT 2
33511: ARRAY
33512: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33513: LD_ADDR_VAR 0 1
33517: PUSH
33518: LD_VAR 0 1
33522: PPUSH
33523: LD_VAR 0 6
33527: PPUSH
33528: LD_INT 1
33530: PPUSH
33531: LD_VAR 0 1
33535: PUSH
33536: LD_VAR 0 6
33540: PUSH
33541: LD_INT 1
33543: MINUS
33544: ARRAY
33545: PUSH
33546: LD_INT 1
33548: ARRAY
33549: PPUSH
33550: CALL 30959 0 4
33554: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33555: LD_ADDR_VAR 0 1
33559: PUSH
33560: LD_VAR 0 1
33564: PPUSH
33565: LD_VAR 0 6
33569: PPUSH
33570: LD_INT 2
33572: PPUSH
33573: LD_VAR 0 1
33577: PUSH
33578: LD_VAR 0 6
33582: PUSH
33583: LD_INT 1
33585: MINUS
33586: ARRAY
33587: PUSH
33588: LD_INT 2
33590: ARRAY
33591: PPUSH
33592: CALL 30959 0 4
33596: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33597: LD_ADDR_VAR 0 1
33601: PUSH
33602: LD_VAR 0 1
33606: PPUSH
33607: LD_VAR 0 6
33611: PUSH
33612: LD_INT 1
33614: MINUS
33615: PPUSH
33616: LD_INT 1
33618: PPUSH
33619: LD_VAR 0 7
33623: PPUSH
33624: CALL 30959 0 4
33628: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33629: LD_ADDR_VAR 0 1
33633: PUSH
33634: LD_VAR 0 1
33638: PPUSH
33639: LD_VAR 0 6
33643: PUSH
33644: LD_INT 1
33646: MINUS
33647: PPUSH
33648: LD_INT 2
33650: PPUSH
33651: LD_VAR 0 8
33655: PPUSH
33656: CALL 30959 0 4
33660: ST_TO_ADDR
// end ; end ;
33661: GO 33370
33663: POP
33664: POP
// end ;
33665: GO 33352
33667: POP
33668: POP
// result := list ;
33669: LD_ADDR_VAR 0 4
33673: PUSH
33674: LD_VAR 0 1
33678: ST_TO_ADDR
// end ;
33679: LD_VAR 0 4
33683: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33684: LD_INT 0
33686: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33687: LD_ADDR_VAR 0 5
33691: PUSH
33692: LD_VAR 0 1
33696: PPUSH
33697: LD_VAR 0 2
33701: PPUSH
33702: CALL_OW 546
33706: PUSH
33707: LD_INT 2
33709: ARRAY
33710: PUSH
33711: LD_VAR 0 3
33715: PPUSH
33716: LD_VAR 0 4
33720: PPUSH
33721: CALL_OW 546
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: MINUS
33730: ST_TO_ADDR
// if result < 0 then
33731: LD_VAR 0 5
33735: PUSH
33736: LD_INT 0
33738: LESS
33739: IFFALSE 33756
// result := result * - 1 ;
33741: LD_ADDR_VAR 0 5
33745: PUSH
33746: LD_VAR 0 5
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: MUL
33755: ST_TO_ADDR
// end ;
33756: LD_VAR 0 5
33760: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33761: LD_INT 0
33763: PPUSH
33764: PPUSH
// area = ListEnvironmentArea ( area ) ;
33765: LD_ADDR_VAR 0 2
33769: PUSH
33770: LD_VAR 0 2
33774: PPUSH
33775: CALL_OW 353
33779: ST_TO_ADDR
// if bulldozer > 0 then
33780: LD_VAR 0 1
33784: PUSH
33785: LD_INT 0
33787: GREATER
33788: IFFALSE 33899
// for i = area downto 1 do
33790: LD_ADDR_VAR 0 4
33794: PUSH
33795: DOUBLE
33796: LD_VAR 0 2
33800: INC
33801: ST_TO_ADDR
33802: LD_INT 1
33804: PUSH
33805: FOR_DOWNTO
33806: IFFALSE 33897
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33808: LD_VAR 0 2
33812: PUSH
33813: LD_VAR 0 4
33817: ARRAY
33818: PUSH
33819: LD_INT 1
33821: ARRAY
33822: PPUSH
33823: LD_VAR 0 2
33827: PUSH
33828: LD_VAR 0 4
33832: ARRAY
33833: PUSH
33834: LD_INT 2
33836: ARRAY
33837: PPUSH
33838: CALL_OW 351
33842: IFFALSE 33895
// if not HasTask ( bulldozer ) then
33844: LD_VAR 0 1
33848: PPUSH
33849: CALL_OW 314
33853: NOT
33854: IFFALSE 33895
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33856: LD_VAR 0 1
33860: PPUSH
33861: LD_VAR 0 2
33865: PUSH
33866: LD_VAR 0 4
33870: ARRAY
33871: PUSH
33872: LD_INT 1
33874: ARRAY
33875: PPUSH
33876: LD_VAR 0 2
33880: PUSH
33881: LD_VAR 0 4
33885: ARRAY
33886: PUSH
33887: LD_INT 2
33889: ARRAY
33890: PPUSH
33891: CALL_OW 171
33895: GO 33805
33897: POP
33898: POP
// end ;
33899: LD_VAR 0 3
33903: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33904: LD_INT 0
33906: PPUSH
33907: PPUSH
33908: PPUSH
33909: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33910: LD_ADDR_VAR 0 6
33914: PUSH
33915: LD_INT 22
33917: PUSH
33918: LD_VAR 0 1
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 21
33929: PUSH
33930: LD_VAR 0 2
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PPUSH
33943: CALL_OW 69
33947: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33948: LD_ADDR_VAR 0 7
33952: PUSH
33953: LD_VAR 0 3
33957: PPUSH
33958: LD_INT 22
33960: PUSH
33961: LD_VAR 0 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 21
33972: PUSH
33973: LD_VAR 0 2
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PPUSH
33986: CALL_OW 70
33990: ST_TO_ADDR
// if tmp and pom then
33991: LD_VAR 0 6
33995: PUSH
33996: LD_VAR 0 7
34000: AND
34001: IFFALSE 34021
// result := tmp diff pom else
34003: LD_ADDR_VAR 0 4
34007: PUSH
34008: LD_VAR 0 6
34012: PUSH
34013: LD_VAR 0 7
34017: DIFF
34018: ST_TO_ADDR
34019: GO 34029
// result := false ;
34021: LD_ADDR_VAR 0 4
34025: PUSH
34026: LD_INT 0
34028: ST_TO_ADDR
// end ;
34029: LD_VAR 0 4
34033: RET
// export function SavePosition ( unit ) ; begin
34034: LD_INT 0
34036: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
34037: LD_VAR 0 1
34041: PPUSH
34042: LD_VAR 0 1
34046: PPUSH
34047: CALL_OW 250
34051: PPUSH
34052: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
34056: LD_VAR 0 1
34060: PPUSH
34061: LD_VAR 0 1
34065: PPUSH
34066: CALL_OW 251
34070: PPUSH
34071: CALL_OW 232
// end ;
34075: LD_VAR 0 2
34079: RET
// export function GetPosition ( unit ) ; begin
34080: LD_INT 0
34082: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
34083: LD_ADDR_VAR 0 2
34087: PUSH
34088: LD_VAR 0 1
34092: PPUSH
34093: CALL_OW 252
34097: PUSH
34098: LD_VAR 0 1
34102: PPUSH
34103: CALL_OW 253
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: ST_TO_ADDR
// end ;
34112: LD_VAR 0 2
34116: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34117: LD_INT 0
34119: PPUSH
// if unit in unreachableList then
34120: LD_VAR 0 1
34124: PUSH
34125: LD_EXP 31
34129: IN
34130: IFFALSE 34148
// unreachableList := unreachableList diff unit ;
34132: LD_ADDR_EXP 31
34136: PUSH
34137: LD_EXP 31
34141: PUSH
34142: LD_VAR 0 1
34146: DIFF
34147: ST_TO_ADDR
// if ValidHex ( x , y ) then
34148: LD_VAR 0 2
34152: PPUSH
34153: LD_VAR 0 3
34157: PPUSH
34158: CALL_OW 488
34162: IFFALSE 34188
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34164: LD_VAR 0 1
34168: PPUSH
34169: LD_VAR 0 2
34173: PPUSH
34174: LD_VAR 0 3
34178: PPUSH
34179: CALL_OW 428
34183: PPUSH
34184: CALL_OW 115
// Wait ( 3 ) ;
34188: LD_INT 3
34190: PPUSH
34191: CALL_OW 67
// if unit in unreachableList then
34195: LD_VAR 0 1
34199: PUSH
34200: LD_EXP 31
34204: IN
34205: IFFALSE 34217
// result := false else
34207: LD_ADDR_VAR 0 4
34211: PUSH
34212: LD_INT 0
34214: ST_TO_ADDR
34215: GO 34225
// result := true ;
34217: LD_ADDR_VAR 0 4
34221: PUSH
34222: LD_INT 1
34224: ST_TO_ADDR
// end ; end_of_file
34225: LD_VAR 0 4
34229: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34230: LD_EXP 32
34234: IFFALSE 34296
34236: GO 34238
34238: DISABLE
34239: LD_INT 0
34241: PPUSH
// begin enable ;
34242: ENABLE
// for i = 1 to mc_crates_list do
34243: LD_ADDR_VAR 0 1
34247: PUSH
34248: DOUBLE
34249: LD_INT 1
34251: DEC
34252: ST_TO_ADDR
34253: LD_EXP 33
34257: PUSH
34258: FOR_TO
34259: IFFALSE 34290
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34261: LD_EXP 33
34265: PUSH
34266: LD_VAR 0 1
34270: ARRAY
34271: PPUSH
34272: LD_INT 5
34274: PPUSH
34275: LD_INT 50
34277: PPUSH
34278: LD_INT 700
34280: PPUSH
34281: LD_INT 20
34283: PPUSH
34284: CALL 24301 0 5
34288: GO 34258
34290: POP
34291: POP
// MC_Game ( ) ;
34292: CALL 34299 0 0
// end ;
34296: PPOPN 1
34298: END
// export function MC_Game ( ) ; var i , side , un ; begin
34299: LD_INT 0
34301: PPUSH
34302: PPUSH
34303: PPUSH
34304: PPUSH
// if not isTest then
34305: LD_EXP 1
34309: NOT
34310: IFFALSE 34330
// MC_Show ( [ #tick , tick ] ) else
34312: LD_STRING #tick
34314: PUSH
34315: LD_OWVAR 1
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PPUSH
34324: CALL 8339 0 1
34328: GO 34339
// MC_Show ( debug_string ) ;
34330: LD_EXP 2
34334: PPUSH
34335: CALL 8339 0 1
// for side = 1 to 8 do
34339: LD_ADDR_VAR 0 3
34343: PUSH
34344: DOUBLE
34345: LD_INT 1
34347: DEC
34348: ST_TO_ADDR
34349: LD_INT 8
34351: PUSH
34352: FOR_TO
34353: IFFALSE 36353
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34355: LD_EXP 40
34359: PUSH
34360: LD_VAR 0 3
34364: ARRAY
34365: PUSH
34366: LD_INT 0
34368: EQUAL
34369: PUSH
34370: LD_VAR 0 3
34374: PPUSH
34375: EMPTY
34376: PPUSH
34377: CALL 11556 0 2
34381: PUSH
34382: LD_INT 0
34384: EQUAL
34385: OR
34386: IFFALSE 34390
// continue ;
34388: GO 34352
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: CALL 24822 0 1
34404: PPUSH
34405: CALL 36360 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34409: LD_EXP 72
34413: PUSH
34414: LD_VAR 0 3
34418: ARRAY
34419: PUSH
34420: LD_INT 1
34422: ARRAY
34423: PUSH
34424: LD_INT 0
34426: GREATER
34427: PUSH
34428: LD_EXP 70
34432: PUSH
34433: LD_VAR 0 3
34437: ARRAY
34438: PUSH
34439: LD_INT 1
34441: ARRAY
34442: PUSH
34443: LD_INT 0
34445: EQUAL
34446: AND
34447: PUSH
34448: LD_VAR 0 3
34452: PPUSH
34453: LD_INT 7
34455: PPUSH
34456: EMPTY
34457: PPUSH
34458: CALL 12124 0 3
34462: NOT
34463: AND
34464: IFFALSE 34535
// begin if side = 1 then
34466: LD_VAR 0 3
34470: PUSH
34471: LD_INT 1
34473: EQUAL
34474: IFFALSE 34483
// RaiseSailEvent ( 101 ) ;
34476: LD_INT 101
34478: PPUSH
34479: CALL_OW 427
// if side = 4 then
34483: LD_VAR 0 3
34487: PUSH
34488: LD_INT 4
34490: EQUAL
34491: IFFALSE 34500
// RaiseSailEvent ( 102 ) ;
34493: LD_INT 102
34495: PPUSH
34496: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34500: LD_ADDR_VAR 0 2
34504: PUSH
34505: LD_EXP 72
34509: PUSH
34510: LD_VAR 0 3
34514: ARRAY
34515: PUSH
34516: FOR_IN
34517: IFFALSE 34533
// SetTag ( i , 7 ) ;
34519: LD_VAR 0 2
34523: PPUSH
34524: LD_INT 7
34526: PPUSH
34527: CALL_OW 109
34531: GO 34516
34533: POP
34534: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_INT 7
34542: PPUSH
34543: EMPTY
34544: PPUSH
34545: CALL 12124 0 3
34549: IFFALSE 34575
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34551: LD_VAR 0 3
34555: PPUSH
34556: LD_VAR 0 3
34560: PPUSH
34561: LD_INT 7
34563: PPUSH
34564: EMPTY
34565: PPUSH
34566: CALL 12124 0 3
34570: PPUSH
34571: CALL 8266 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34575: LD_VAR 0 3
34579: PPUSH
34580: CALL 17804 0 1
34584: PUSH
34585: LD_VAR 0 3
34589: PPUSH
34590: CALL 11460 0 1
34594: AND
34595: IFFALSE 34606
// MCL_Start ( side ) ;
34597: LD_VAR 0 3
34601: PPUSH
34602: CALL 17761 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34606: LD_ADDR_EXP 36
34610: PUSH
34611: LD_EXP 36
34615: PPUSH
34616: LD_VAR 0 3
34620: PPUSH
34621: LD_VAR 0 3
34625: PPUSH
34626: CALL 19061 0 1
34630: PPUSH
34631: CALL_OW 1
34635: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34636: LD_ADDR_EXP 48
34640: PUSH
34641: LD_EXP 48
34645: PPUSH
34646: LD_VAR 0 3
34650: PPUSH
34651: LD_VAR 0 3
34655: PPUSH
34656: CALL 10874 0 1
34660: PPUSH
34661: CALL_OW 1
34665: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34666: LD_VAR 0 3
34670: PPUSH
34671: LD_INT 21
34673: PUSH
34674: LD_INT 2
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PPUSH
34681: CALL 11421 0 2
34685: IFFALSE 34696
// MCV_CheckStatus ( side ) ;
34687: LD_VAR 0 3
34691: PPUSH
34692: CALL 27031 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_EXP 54
34705: PPUSH
34706: CALL 43280 0 2
34710: IFFALSE 34795
// begin for i = MREG_ToChangeClass downto 1 do
34712: LD_ADDR_VAR 0 2
34716: PUSH
34717: DOUBLE
34718: LD_EXP 54
34722: INC
34723: ST_TO_ADDR
34724: LD_INT 1
34726: PUSH
34727: FOR_DOWNTO
34728: IFFALSE 34793
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34730: LD_EXP 54
34734: PUSH
34735: LD_VAR 0 2
34739: ARRAY
34740: PUSH
34741: LD_INT 1
34743: ARRAY
34744: PUSH
34745: LD_VAR 0 3
34749: EQUAL
34750: IFFALSE 34791
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34752: LD_VAR 0 3
34756: PPUSH
34757: LD_EXP 54
34761: PUSH
34762: LD_VAR 0 2
34766: ARRAY
34767: PUSH
34768: LD_INT 2
34770: ARRAY
34771: PPUSH
34772: LD_EXP 54
34776: PUSH
34777: LD_VAR 0 2
34781: ARRAY
34782: PUSH
34783: LD_INT 3
34785: ARRAY
34786: PPUSH
34787: CALL 16328 0 3
// end ; end ;
34791: GO 34727
34793: POP
34794: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34795: LD_INT 1
34797: PUSH
34798: LD_EXP 39
34802: PUSH
34803: LD_VAR 0 3
34807: ARRAY
34808: IN
34809: IFFALSE 34820
// begin MCN_TrainApe ( side ) ;
34811: LD_VAR 0 3
34815: PPUSH
34816: CALL 18714 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34820: LD_VAR 0 3
34824: PPUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 3
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PPUSH
34835: CALL 11421 0 2
34839: IFFALSE 35013
// begin if MCF_Tag ( side , 10 , [ ] ) then
34841: LD_VAR 0 3
34845: PPUSH
34846: LD_INT 10
34848: PPUSH
34849: EMPTY
34850: PPUSH
34851: CALL 12124 0 3
34855: IFFALSE 34902
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34857: LD_VAR 0 3
34861: PPUSH
34862: LD_INT 10
34864: PPUSH
34865: EMPTY
34866: PPUSH
34867: CALL 12124 0 3
34871: PPUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_INT 30
34879: PUSH
34880: LD_INT 3
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PPUSH
34887: CALL 11421 0 2
34891: PUSH
34892: LD_INT 1
34894: ARRAY
34895: PPUSH
34896: CALL_OW 168
// end else
34900: GO 35013
// if MREG_ToConstruct [ side ] then
34902: LD_EXP 52
34906: PUSH
34907: LD_VAR 0 3
34911: ARRAY
34912: IFFALSE 35013
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34914: LD_VAR 0 3
34918: PPUSH
34919: LD_VAR 0 3
34923: PPUSH
34924: LD_INT 30
34926: PUSH
34927: LD_INT 3
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PPUSH
34934: CALL 11421 0 2
34938: PUSH
34939: LD_INT 1
34941: ARRAY
34942: PPUSH
34943: LD_EXP 52
34947: PUSH
34948: LD_VAR 0 3
34952: ARRAY
34953: PUSH
34954: LD_INT 1
34956: ARRAY
34957: PUSH
34958: LD_EXP 52
34962: PUSH
34963: LD_VAR 0 3
34967: ARRAY
34968: PUSH
34969: LD_INT 2
34971: ARRAY
34972: PUSH
34973: LD_EXP 52
34977: PUSH
34978: LD_VAR 0 3
34982: ARRAY
34983: PUSH
34984: LD_INT 3
34986: ARRAY
34987: PUSH
34988: LD_EXP 52
34992: PUSH
34993: LD_VAR 0 3
34997: ARRAY
34998: PUSH
34999: LD_INT 4
35001: ARRAY
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: PPUSH
35009: CALL 25325 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
35013: LD_VAR 0 3
35017: PPUSH
35018: LD_INT 30
35020: PUSH
35021: LD_INT 3
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PPUSH
35028: CALL 11421 0 2
35032: PUSH
35033: LD_VAR 0 3
35037: PPUSH
35038: LD_EXP 44
35042: PPUSH
35043: CALL 43280 0 2
35047: AND
35048: PUSH
35049: LD_INT 22
35051: PUSH
35052: LD_VAR 0 3
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 2
35063: PUSH
35064: LD_INT 30
35066: PUSH
35067: LD_INT 33
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 30
35076: PUSH
35077: LD_INT 32
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 35
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: LIST
35103: PPUSH
35104: CALL_OW 69
35108: AND
35109: IFFALSE 35120
// MCV_Turret ( side ) ;
35111: LD_VAR 0 3
35115: PPUSH
35116: CALL 25774 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35120: LD_EXP 43
35124: PUSH
35125: LD_VAR 0 3
35129: ARRAY
35130: PUSH
35131: LD_INT 1
35133: GREATER
35134: PUSH
35135: LD_VAR 0 3
35139: PPUSH
35140: CALL 24822 0 1
35144: PUSH
35145: LD_INT 0
35147: EQUAL
35148: AND
35149: IFFALSE 35311
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35151: LD_EXP 43
35155: PUSH
35156: LD_VAR 0 3
35160: ARRAY
35161: PUSH
35162: LD_INT 1
35164: ARRAY
35165: PPUSH
35166: CALL_OW 353
35170: IFFALSE 35208
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35172: LD_EXP 43
35176: PUSH
35177: LD_VAR 0 3
35181: ARRAY
35182: PUSH
35183: LD_INT 2
35185: ARRAY
35186: PPUSH
35187: LD_EXP 43
35191: PUSH
35192: LD_VAR 0 3
35196: ARRAY
35197: PUSH
35198: LD_INT 1
35200: ARRAY
35201: PPUSH
35202: CALL 32589 0 2
35206: GO 35311
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35208: LD_VAR 0 3
35212: PPUSH
35213: LD_INT 30
35215: PUSH
35216: LD_INT 3
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PPUSH
35223: CALL 11421 0 2
35227: IFFALSE 35311
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35229: LD_VAR 0 3
35233: PPUSH
35234: LD_INT 30
35236: PUSH
35237: LD_INT 3
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PPUSH
35244: CALL 11421 0 2
35248: PUSH
35249: LD_INT 1
35251: ARRAY
35252: PPUSH
35253: CALL_OW 461
35257: PUSH
35258: LD_INT 2
35260: EQUAL
35261: IFFALSE 35311
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35263: LD_EXP 43
35267: PUSH
35268: LD_VAR 0 3
35272: ARRAY
35273: PUSH
35274: LD_INT 2
35276: ARRAY
35277: PPUSH
35278: LD_INT 10
35280: PPUSH
35281: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35285: LD_ADDR_EXP 43
35289: PUSH
35290: LD_EXP 43
35294: PPUSH
35295: LD_VAR 0 3
35299: PPUSH
35300: LD_INT 0
35302: PUSH
35303: EMPTY
35304: LIST
35305: PPUSH
35306: CALL_OW 1
35310: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35311: LD_VAR 0 3
35315: PPUSH
35316: LD_INT 33
35318: PUSH
35319: LD_INT 2
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PPUSH
35326: CALL 11421 0 2
35330: IFFALSE 35370
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35332: LD_VAR 0 3
35336: PPUSH
35337: LD_VAR 0 3
35341: PPUSH
35342: LD_INT 33
35344: PUSH
35345: LD_INT 2
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PPUSH
35352: CALL 11421 0 2
35356: PUSH
35357: LD_INT 1
35359: ARRAY
35360: PPUSH
35361: CALL_OW 248
35365: PPUSH
35366: CALL 26328 0 2
// if MREG_ToRepair [ side ] then
35370: LD_EXP 48
35374: PUSH
35375: LD_VAR 0 3
35379: ARRAY
35380: IFFALSE 35393
// begin MCB_Repair ( side ) ;
35382: LD_VAR 0 3
35386: PPUSH
35387: CALL 11161 0 1
// end else
35391: GO 36306
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35393: LD_VAR 0 3
35397: PPUSH
35398: LD_EXP 50
35402: PPUSH
35403: CALL 43280 0 2
35407: PUSH
35408: LD_VAR 0 3
35412: PPUSH
35413: LD_EXP 41
35417: PPUSH
35418: CALL 43280 0 2
35422: AND
35423: IFFALSE 35631
// begin for i = 1 to MREG_ToUpLab do
35425: LD_ADDR_VAR 0 2
35429: PUSH
35430: DOUBLE
35431: LD_INT 1
35433: DEC
35434: ST_TO_ADDR
35435: LD_EXP 50
35439: PUSH
35440: FOR_TO
35441: IFFALSE 35627
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35443: LD_EXP 50
35447: PUSH
35448: LD_VAR 0 2
35452: ARRAY
35453: PUSH
35454: LD_INT 1
35456: ARRAY
35457: PUSH
35458: LD_VAR 0 3
35462: EQUAL
35463: IFFALSE 35625
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35465: LD_EXP 50
35469: PUSH
35470: LD_VAR 0 2
35474: ARRAY
35475: PUSH
35476: LD_INT 2
35478: ARRAY
35479: PUSH
35480: LD_EXP 50
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PUSH
35491: LD_INT 3
35493: ARRAY
35494: AND
35495: IFFALSE 35623
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35497: LD_VAR 0 3
35501: PPUSH
35502: LD_EXP 50
35506: PUSH
35507: LD_VAR 0 2
35511: ARRAY
35512: PUSH
35513: LD_INT 2
35515: ARRAY
35516: PPUSH
35517: LD_EXP 50
35521: PUSH
35522: LD_VAR 0 2
35526: ARRAY
35527: PUSH
35528: LD_INT 3
35530: ARRAY
35531: PPUSH
35532: CALL 8685 0 3
35536: IFFALSE 35623
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35538: LD_ADDR_EXP 50
35542: PUSH
35543: LD_EXP 50
35547: PPUSH
35548: LD_VAR 0 3
35552: PPUSH
35553: LD_EXP 50
35557: PUSH
35558: LD_VAR 0 2
35562: ARRAY
35563: PUSH
35564: LD_INT 2
35566: ARRAY
35567: PPUSH
35568: LD_EXP 50
35572: PUSH
35573: LD_VAR 0 2
35577: ARRAY
35578: PUSH
35579: LD_INT 3
35581: ARRAY
35582: PPUSH
35583: CALL 42332 0 4
35587: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35588: LD_ADDR_EXP 41
35592: PUSH
35593: LD_EXP 41
35597: PPUSH
35598: LD_VAR 0 3
35602: PPUSH
35603: LD_EXP 41
35607: PUSH
35608: LD_INT 1
35610: ARRAY
35611: PUSH
35612: LD_INT 2
35614: ARRAY
35615: PPUSH
35616: EMPTY
35617: PPUSH
35618: CALL 42332 0 4
35622: ST_TO_ADDR
// end ; break ;
35623: GO 35627
// end ;
35625: GO 35440
35627: POP
35628: POP
// end else
35629: GO 36306
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35631: LD_VAR 0 3
35635: PPUSH
35636: LD_EXP 49
35640: PPUSH
35641: CALL 43280 0 2
35645: IFFALSE 35719
// begin for i = 1 to MREG_ToUpdate do
35647: LD_ADDR_VAR 0 2
35651: PUSH
35652: DOUBLE
35653: LD_INT 1
35655: DEC
35656: ST_TO_ADDR
35657: LD_EXP 49
35661: PUSH
35662: FOR_TO
35663: IFFALSE 35715
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35665: LD_EXP 49
35669: PUSH
35670: LD_VAR 0 2
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PUSH
35680: LD_VAR 0 3
35684: EQUAL
35685: IFFALSE 35713
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35687: LD_VAR 0 3
35691: PPUSH
35692: LD_EXP 49
35696: PUSH
35697: LD_VAR 0 2
35701: ARRAY
35702: PUSH
35703: LD_INT 2
35705: ARRAY
35706: PPUSH
35707: CALL 8521 0 2
// break ;
35711: GO 35715
// end ;
35713: GO 35662
35715: POP
35716: POP
// end else
35717: GO 36306
// if MCF_Get ( side , [ f_constructed ] ) then
35719: LD_VAR 0 3
35723: PPUSH
35724: LD_INT 57
35726: PUSH
35727: EMPTY
35728: LIST
35729: PPUSH
35730: CALL 11421 0 2
35734: IFFALSE 35767
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35736: LD_VAR 0 3
35740: PPUSH
35741: LD_VAR 0 3
35745: PPUSH
35746: LD_INT 57
35748: PUSH
35749: EMPTY
35750: LIST
35751: PPUSH
35752: CALL 11421 0 2
35756: PUSH
35757: LD_INT 1
35759: ARRAY
35760: PPUSH
35761: CALL 10765 0 2
35765: GO 36306
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35767: LD_VAR 0 3
35771: PPUSH
35772: LD_EXP 47
35776: PPUSH
35777: CALL 43280 0 2
35781: PUSH
35782: LD_VAR 0 3
35786: PPUSH
35787: CALL_OW 345
35791: NOT
35792: AND
35793: PUSH
35794: LD_VAR 0 3
35798: PPUSH
35799: CALL 24822 0 1
35803: PUSH
35804: LD_INT 0
35806: EQUAL
35807: AND
35808: IFFALSE 36207
// begin for i = 1 to MREG_ToBuild do
35810: LD_ADDR_VAR 0 2
35814: PUSH
35815: DOUBLE
35816: LD_INT 1
35818: DEC
35819: ST_TO_ADDR
35820: LD_EXP 47
35824: PUSH
35825: FOR_TO
35826: IFFALSE 36203
// if MREG_ToBuild [ i ] [ 1 ] = side then
35828: LD_EXP 47
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: PUSH
35839: LD_INT 1
35841: ARRAY
35842: PUSH
35843: LD_VAR 0 3
35847: EQUAL
35848: IFFALSE 36201
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35850: LD_OWVAR 84
35854: PUSH
35855: LD_EXP 47
35859: PUSH
35860: LD_VAR 0 2
35864: ARRAY
35865: PUSH
35866: LD_INT 3
35868: ARRAY
35869: PUSH
35870: LD_INT 1
35872: ARRAY
35873: PPUSH
35874: LD_EXP 47
35878: PUSH
35879: LD_VAR 0 2
35883: ARRAY
35884: PUSH
35885: LD_INT 3
35887: ARRAY
35888: PUSH
35889: LD_INT 2
35891: ARRAY
35892: PPUSH
35893: CALL_OW 351
35897: AND
35898: IFFALSE 35942
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35900: LD_EXP 47
35904: PUSH
35905: LD_VAR 0 2
35909: ARRAY
35910: PUSH
35911: LD_INT 3
35913: ARRAY
35914: PUSH
35915: LD_INT 1
35917: ARRAY
35918: PPUSH
35919: LD_EXP 47
35923: PUSH
35924: LD_VAR 0 2
35928: ARRAY
35929: PUSH
35930: LD_INT 3
35932: ARRAY
35933: PUSH
35934: LD_INT 2
35936: ARRAY
35937: PPUSH
35938: CALL 22569 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35942: LD_EXP 47
35946: PUSH
35947: LD_VAR 0 2
35951: ARRAY
35952: PUSH
35953: LD_INT 2
35955: ARRAY
35956: PUSH
35957: LD_INT 0
35959: EQUAL
35960: IFFALSE 36030
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35962: LD_VAR 0 3
35966: PPUSH
35967: LD_EXP 47
35971: PUSH
35972: LD_VAR 0 2
35976: ARRAY
35977: PUSH
35978: LD_INT 3
35980: ARRAY
35981: PUSH
35982: LD_INT 1
35984: ARRAY
35985: PPUSH
35986: LD_EXP 47
35990: PUSH
35991: LD_VAR 0 2
35995: ARRAY
35996: PUSH
35997: LD_INT 3
35999: ARRAY
36000: PUSH
36001: LD_INT 2
36003: ARRAY
36004: PPUSH
36005: LD_EXP 47
36009: PUSH
36010: LD_VAR 0 2
36014: ARRAY
36015: PUSH
36016: LD_INT 3
36018: ARRAY
36019: PUSH
36020: LD_INT 3
36022: ARRAY
36023: PPUSH
36024: CALL 8357 0 4
36028: GO 36199
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
36030: LD_EXP 47
36034: PUSH
36035: LD_VAR 0 2
36039: ARRAY
36040: PUSH
36041: LD_INT 2
36043: ARRAY
36044: PUSH
36045: LD_INT 6
36047: EQUAL
36048: IFFALSE 36118
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36050: LD_VAR 0 3
36054: PPUSH
36055: LD_EXP 47
36059: PUSH
36060: LD_VAR 0 2
36064: ARRAY
36065: PUSH
36066: LD_INT 3
36068: ARRAY
36069: PUSH
36070: LD_INT 1
36072: ARRAY
36073: PPUSH
36074: LD_EXP 47
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PUSH
36085: LD_INT 3
36087: ARRAY
36088: PUSH
36089: LD_INT 2
36091: ARRAY
36092: PPUSH
36093: LD_EXP 47
36097: PUSH
36098: LD_VAR 0 2
36102: ARRAY
36103: PUSH
36104: LD_INT 3
36106: ARRAY
36107: PUSH
36108: LD_INT 3
36110: ARRAY
36111: PPUSH
36112: CALL 8486 0 4
36116: GO 36199
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36118: LD_VAR 0 3
36122: PPUSH
36123: LD_EXP 47
36127: PUSH
36128: LD_VAR 0 2
36132: ARRAY
36133: PUSH
36134: LD_INT 2
36136: ARRAY
36137: PPUSH
36138: LD_EXP 47
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_INT 3
36151: ARRAY
36152: PUSH
36153: LD_INT 1
36155: ARRAY
36156: PPUSH
36157: LD_EXP 47
36161: PUSH
36162: LD_VAR 0 2
36166: ARRAY
36167: PUSH
36168: LD_INT 3
36170: ARRAY
36171: PUSH
36172: LD_INT 2
36174: ARRAY
36175: PPUSH
36176: LD_EXP 47
36180: PUSH
36181: LD_VAR 0 2
36185: ARRAY
36186: PUSH
36187: LD_INT 3
36189: ARRAY
36190: PUSH
36191: LD_INT 3
36193: ARRAY
36194: PPUSH
36195: CALL 9990 0 5
// break ;
36199: GO 36203
// end ;
36201: GO 35825
36203: POP
36204: POP
// end else
36205: GO 36306
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36207: LD_VAR 0 3
36211: PPUSH
36212: LD_EXP 53
36216: PPUSH
36217: CALL 43280 0 2
36221: PUSH
36222: LD_VAR 0 3
36226: PPUSH
36227: CALL 24822 0 1
36231: PUSH
36232: LD_INT 0
36234: EQUAL
36235: AND
36236: IFFALSE 36306
// begin for i = 1 to MREG_ToDismantle do
36238: LD_ADDR_VAR 0 2
36242: PUSH
36243: DOUBLE
36244: LD_INT 1
36246: DEC
36247: ST_TO_ADDR
36248: LD_EXP 53
36252: PUSH
36253: FOR_TO
36254: IFFALSE 36304
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36256: LD_EXP 53
36260: PUSH
36261: LD_VAR 0 2
36265: ARRAY
36266: PUSH
36267: LD_INT 1
36269: ARRAY
36270: PUSH
36271: LD_VAR 0 3
36275: EQUAL
36276: IFFALSE 36302
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36278: LD_VAR 0 3
36282: PPUSH
36283: LD_EXP 53
36287: PUSH
36288: LD_VAR 0 2
36292: ARRAY
36293: PUSH
36294: LD_INT 2
36296: ARRAY
36297: PPUSH
36298: CALL 10656 0 2
// end ;
36302: GO 36253
36304: POP
36305: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36306: LD_VAR 0 3
36310: PPUSH
36311: LD_INT 30
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PPUSH
36321: CALL 11421 0 2
36325: PUSH
36326: LD_VAR 0 3
36330: PPUSH
36331: CALL 24822 0 1
36335: PUSH
36336: LD_INT 0
36338: EQUAL
36339: AND
36340: IFFALSE 36351
// MCT_CollectCrates ( side ) ;
36342: LD_VAR 0 3
36346: PPUSH
36347: CALL 23761 0 1
// end ;
36351: GO 34352
36353: POP
36354: POP
// end ;
36355: LD_VAR 0 1
36359: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36360: LD_INT 0
36362: PPUSH
36363: PPUSH
36364: PPUSH
36365: PPUSH
36366: PPUSH
36367: PPUSH
36368: PPUSH
36369: PPUSH
36370: PPUSH
36371: PPUSH
36372: PPUSH
36373: PPUSH
36374: PPUSH
36375: PPUSH
36376: PPUSH
// all := MCF_All ( side , [ ] ) ;
36377: LD_ADDR_VAR 0 17
36381: PUSH
36382: LD_VAR 0 1
36386: PPUSH
36387: EMPTY
36388: PPUSH
36389: CALL 11556 0 2
36393: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36394: LD_ADDR_VAR 0 13
36398: PUSH
36399: LD_VAR 0 1
36403: PPUSH
36404: LD_INT 1
36406: PPUSH
36407: EMPTY
36408: PPUSH
36409: CALL 11504 0 3
36413: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36414: LD_ADDR_VAR 0 14
36418: PUSH
36419: LD_VAR 0 1
36423: PPUSH
36424: LD_INT 2
36426: PPUSH
36427: EMPTY
36428: PPUSH
36429: CALL 11504 0 3
36433: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36434: LD_ADDR_VAR 0 15
36438: PUSH
36439: LD_VAR 0 1
36443: PPUSH
36444: LD_INT 3
36446: PPUSH
36447: EMPTY
36448: PPUSH
36449: CALL 11504 0 3
36453: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36454: LD_ADDR_VAR 0 16
36458: PUSH
36459: LD_VAR 0 1
36463: PPUSH
36464: LD_INT 4
36466: PPUSH
36467: EMPTY
36468: PPUSH
36469: CALL 11504 0 3
36473: ST_TO_ADDR
// if mech then
36474: LD_VAR 0 15
36478: IFFALSE 36495
// mech := MCF_SortListDesc ( mech ) ;
36480: LD_ADDR_VAR 0 15
36484: PUSH
36485: LD_VAR 0 15
36489: PPUSH
36490: CALL 12670 0 1
36494: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36495: LD_EXP 57
36499: PUSH
36500: LD_VAR 0 1
36504: ARRAY
36505: PUSH
36506: LD_STRING 
36508: EQUAL
36509: NOT
36510: IFFALSE 36566
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36512: LD_EXP 57
36516: PUSH
36517: LD_VAR 0 1
36521: ARRAY
36522: PUSH
36523: LD_INT 1
36525: ARRAY
36526: PPUSH
36527: CALL_OW 257
36531: PUSH
36532: LD_INT 1
36534: EQUAL
36535: IFFALSE 36564
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36537: LD_VAR 0 1
36541: PPUSH
36542: LD_STRING ToArm
36544: PPUSH
36545: LD_EXP 57
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL 14300 0 3
// end else
36564: GO 36592
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36566: LD_ADDR_EXP 57
36570: PUSH
36571: LD_EXP 57
36575: PPUSH
36576: LD_VAR 0 1
36580: PPUSH
36581: LD_INT 1
36583: PPUSH
36584: LD_INT 0
36586: PPUSH
36587: CALL 30959 0 4
36591: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36592: LD_EXP 58
36596: PUSH
36597: LD_VAR 0 1
36601: ARRAY
36602: PUSH
36603: LD_STRING 
36605: EQUAL
36606: NOT
36607: IFFALSE 36663
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36609: LD_EXP 58
36613: PUSH
36614: LD_VAR 0 1
36618: ARRAY
36619: PUSH
36620: LD_INT 1
36622: ARRAY
36623: PPUSH
36624: CALL_OW 257
36628: PUSH
36629: LD_INT 2
36631: EQUAL
36632: IFFALSE 36661
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36634: LD_VAR 0 1
36638: PPUSH
36639: LD_STRING ToDep
36641: PPUSH
36642: LD_EXP 58
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL 14300 0 3
// end else
36661: GO 36689
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36663: LD_ADDR_EXP 58
36667: PUSH
36668: LD_EXP 58
36672: PPUSH
36673: LD_VAR 0 1
36677: PPUSH
36678: LD_INT 1
36680: PPUSH
36681: LD_INT 0
36683: PPUSH
36684: CALL 30959 0 4
36688: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36689: LD_EXP 56
36693: PUSH
36694: LD_VAR 0 1
36698: ARRAY
36699: PUSH
36700: LD_STRING 
36702: EQUAL
36703: NOT
36704: IFFALSE 36760
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36706: LD_EXP 56
36710: PUSH
36711: LD_VAR 0 1
36715: ARRAY
36716: PUSH
36717: LD_INT 1
36719: ARRAY
36720: PPUSH
36721: CALL_OW 257
36725: PUSH
36726: LD_INT 3
36728: EQUAL
36729: IFFALSE 36758
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36731: LD_VAR 0 1
36735: PPUSH
36736: LD_STRING ToFac
36738: PPUSH
36739: LD_EXP 56
36743: PUSH
36744: LD_VAR 0 1
36748: ARRAY
36749: PUSH
36750: LD_INT 1
36752: ARRAY
36753: PPUSH
36754: CALL 14300 0 3
// end else
36758: GO 36786
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36760: LD_ADDR_EXP 56
36764: PUSH
36765: LD_EXP 56
36769: PPUSH
36770: LD_VAR 0 1
36774: PPUSH
36775: LD_INT 1
36777: PPUSH
36778: LD_INT 0
36780: PPUSH
36781: CALL 30959 0 4
36785: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36786: LD_EXP 55
36790: PUSH
36791: LD_VAR 0 1
36795: ARRAY
36796: PUSH
36797: LD_STRING 
36799: EQUAL
36800: NOT
36801: IFFALSE 36857
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36803: LD_EXP 55
36807: PUSH
36808: LD_VAR 0 1
36812: ARRAY
36813: PUSH
36814: LD_INT 1
36816: ARRAY
36817: PPUSH
36818: CALL_OW 257
36822: PUSH
36823: LD_INT 4
36825: EQUAL
36826: IFFALSE 36855
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36828: LD_VAR 0 1
36832: PPUSH
36833: LD_STRING ToLab
36835: PPUSH
36836: LD_EXP 55
36840: PUSH
36841: LD_VAR 0 1
36845: ARRAY
36846: PUSH
36847: LD_INT 1
36849: ARRAY
36850: PPUSH
36851: CALL 14300 0 3
// end else
36855: GO 36883
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36857: LD_ADDR_EXP 55
36861: PUSH
36862: LD_EXP 55
36866: PPUSH
36867: LD_VAR 0 1
36871: PPUSH
36872: LD_INT 1
36874: PPUSH
36875: LD_INT 0
36877: PPUSH
36878: CALL 30959 0 4
36882: ST_TO_ADDR
// if mode = 0 then
36883: LD_VAR 0 2
36887: PUSH
36888: LD_INT 0
36890: EQUAL
36891: IFFALSE 38729
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36893: LD_VAR 0 1
36897: PPUSH
36898: LD_INT 30
36900: PUSH
36901: LD_INT 1
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PPUSH
36908: CALL 11421 0 2
36912: PUSH
36913: LD_VAR 0 1
36917: PPUSH
36918: LD_INT 21
36920: PUSH
36921: LD_INT 3
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PPUSH
36928: CALL 11421 0 2
36932: PUSH
36933: LD_INT 1
36935: EQUAL
36936: AND
36937: IFFALSE 37002
// begin if all then
36939: LD_VAR 0 17
36943: IFFALSE 37000
// for i in ( all diff eng ) do
36945: LD_ADDR_VAR 0 4
36949: PUSH
36950: LD_VAR 0 17
36954: PUSH
36955: LD_VAR 0 14
36959: DIFF
36960: PUSH
36961: FOR_IN
36962: IFFALSE 36998
// if GetTag ( i ) = 0 then
36964: LD_VAR 0 4
36968: PPUSH
36969: CALL_OW 110
36973: PUSH
36974: LD_INT 0
36976: EQUAL
36977: IFFALSE 36996
// MCH_ChangeClass ( side , i , 2 ) ;
36979: LD_VAR 0 1
36983: PPUSH
36984: LD_VAR 0 4
36988: PPUSH
36989: LD_INT 2
36991: PPUSH
36992: CALL 16328 0 3
36996: GO 36961
36998: POP
36999: POP
// end else
37000: GO 37321
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
37002: LD_VAR 0 13
37006: PUSH
37007: LD_EXP 57
37011: PUSH
37012: LD_VAR 0 1
37016: ARRAY
37017: PLUS
37018: PUSH
37019: LD_INT 22
37021: PUSH
37022: LD_VAR 0 1
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 30
37033: PUSH
37034: LD_INT 32
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PPUSH
37045: CALL_OW 69
37049: LESS
37050: IFFALSE 37075
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
37052: LD_VAR 0 1
37056: PPUSH
37057: LD_VAR 0 14
37061: PUSH
37062: LD_INT 1
37064: ARRAY
37065: PPUSH
37066: LD_INT 1
37068: PPUSH
37069: CALL 16328 0 3
// end else
37073: GO 37321
// if sci < 6 and MCF_Lab ( side ) then
37075: LD_VAR 0 16
37079: PUSH
37080: LD_INT 6
37082: LESS
37083: PUSH
37084: LD_VAR 0 1
37088: PPUSH
37089: CALL 11460 0 1
37093: AND
37094: IFFALSE 37199
// begin if MREG_ToBunker [ side ] then
37096: LD_EXP 69
37100: PUSH
37101: LD_VAR 0 1
37105: ARRAY
37106: IFFALSE 37132
// tmp := sol diff MREG_ToBunker [ side ] else
37108: LD_ADDR_VAR 0 12
37112: PUSH
37113: LD_VAR 0 13
37117: PUSH
37118: LD_EXP 69
37122: PUSH
37123: LD_VAR 0 1
37127: ARRAY
37128: DIFF
37129: ST_TO_ADDR
37130: GO 37142
// tmp := sol ;
37132: LD_ADDR_VAR 0 12
37136: PUSH
37137: LD_VAR 0 13
37141: ST_TO_ADDR
// if tmp then
37142: LD_VAR 0 12
37146: IFFALSE 37197
// for i in tmp do
37148: LD_ADDR_VAR 0 4
37152: PUSH
37153: LD_VAR 0 12
37157: PUSH
37158: FOR_IN
37159: IFFALSE 37195
// if GetTag ( i ) = 0 then
37161: LD_VAR 0 4
37165: PPUSH
37166: CALL_OW 110
37170: PUSH
37171: LD_INT 0
37173: EQUAL
37174: IFFALSE 37193
// MCH_ChangeClass ( side , i , 4 ) ;
37176: LD_VAR 0 1
37180: PPUSH
37181: LD_VAR 0 4
37185: PPUSH
37186: LD_INT 4
37188: PPUSH
37189: CALL 16328 0 3
37193: GO 37158
37195: POP
37196: POP
// end else
37197: GO 37321
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37199: LD_VAR 0 1
37203: PPUSH
37204: LD_INT 30
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PPUSH
37214: CALL 11421 0 2
37218: IFFALSE 37321
// begin if MREG_ToBunker [ side ] then
37220: LD_EXP 69
37224: PUSH
37225: LD_VAR 0 1
37229: ARRAY
37230: IFFALSE 37256
// tmp := sol diff MREG_ToBunker [ side ] else
37232: LD_ADDR_VAR 0 12
37236: PUSH
37237: LD_VAR 0 13
37241: PUSH
37242: LD_EXP 69
37246: PUSH
37247: LD_VAR 0 1
37251: ARRAY
37252: DIFF
37253: ST_TO_ADDR
37254: GO 37266
// tmp := sol ;
37256: LD_ADDR_VAR 0 12
37260: PUSH
37261: LD_VAR 0 13
37265: ST_TO_ADDR
// if tmp then
37266: LD_VAR 0 12
37270: IFFALSE 37321
// for i in tmp do
37272: LD_ADDR_VAR 0 4
37276: PUSH
37277: LD_VAR 0 12
37281: PUSH
37282: FOR_IN
37283: IFFALSE 37319
// if GetTag ( i ) = 0 then
37285: LD_VAR 0 4
37289: PPUSH
37290: CALL_OW 110
37294: PUSH
37295: LD_INT 0
37297: EQUAL
37298: IFFALSE 37317
// MCH_ChangeClass ( side , i , 2 ) ;
37300: LD_VAR 0 1
37304: PPUSH
37305: LD_VAR 0 4
37309: PPUSH
37310: LD_INT 2
37312: PPUSH
37313: CALL 16328 0 3
37317: GO 37282
37319: POP
37320: POP
// end ; if MCF_Lab ( side ) then
37321: LD_VAR 0 1
37325: PPUSH
37326: CALL 11460 0 1
37330: IFFALSE 37870
// begin if MCL_GetTechList ( side ) then
37332: LD_VAR 0 1
37336: PPUSH
37337: CALL 17804 0 1
37341: IFFALSE 37467
// begin if MREG_ToLab [ side ] then
37343: LD_EXP 55
37347: PUSH
37348: LD_VAR 0 1
37352: ARRAY
37353: IFFALSE 37373
// k := MREG_ToLab [ side ] else
37355: LD_ADDR_VAR 0 8
37359: PUSH
37360: LD_EXP 55
37364: PUSH
37365: LD_VAR 0 1
37369: ARRAY
37370: ST_TO_ADDR
37371: GO 37381
// k := 0 ;
37373: LD_ADDR_VAR 0 8
37377: PUSH
37378: LD_INT 0
37380: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37381: LD_VAR 0 16
37385: PUSH
37386: LD_VAR 0 8
37390: PLUS
37391: PUSH
37392: LD_INT 6
37394: LESSEQUAL
37395: PUSH
37396: LD_VAR 0 17
37400: PUSH
37401: LD_INT 6
37403: GREATER
37404: AND
37405: IFFALSE 37421
// MCH_TrainScientist ( side , 1 ) else
37407: LD_VAR 0 1
37411: PPUSH
37412: LD_INT 1
37414: PPUSH
37415: CALL 15880 0 2
37419: GO 37465
// if all < 6 then
37421: LD_VAR 0 17
37425: PUSH
37426: LD_INT 6
37428: LESS
37429: IFFALSE 37465
// if sci + k < all / 2 then
37431: LD_VAR 0 16
37435: PUSH
37436: LD_VAR 0 8
37440: PLUS
37441: PUSH
37442: LD_VAR 0 17
37446: PUSH
37447: LD_INT 2
37449: DIVREAL
37450: LESS
37451: IFFALSE 37465
// MCH_TrainScientist ( side , 1 ) ;
37453: LD_VAR 0 1
37457: PPUSH
37458: LD_INT 1
37460: PPUSH
37461: CALL 15880 0 2
// end else
37465: GO 37543
// begin if sci > 2 then
37467: LD_VAR 0 16
37471: PUSH
37472: LD_INT 2
37474: GREATER
37475: IFFALSE 37543
// for i = sci downto 2 do
37477: LD_ADDR_VAR 0 4
37481: PUSH
37482: DOUBLE
37483: LD_VAR 0 16
37487: INC
37488: ST_TO_ADDR
37489: LD_INT 2
37491: PUSH
37492: FOR_DOWNTO
37493: IFFALSE 37541
// if GetTag ( sci [ i ] ) = 0 then
37495: LD_VAR 0 16
37499: PUSH
37500: LD_VAR 0 4
37504: ARRAY
37505: PPUSH
37506: CALL_OW 110
37510: PUSH
37511: LD_INT 0
37513: EQUAL
37514: IFFALSE 37539
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37516: LD_VAR 0 1
37520: PPUSH
37521: LD_VAR 0 16
37525: PUSH
37526: LD_VAR 0 4
37530: ARRAY
37531: PPUSH
37532: LD_INT 2
37534: PPUSH
37535: CALL 16328 0 3
37539: GO 37492
37541: POP
37542: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37543: LD_VAR 0 1
37547: PPUSH
37548: CALL 17804 0 1
37552: PUSH
37553: LD_VAR 0 1
37557: PPUSH
37558: CALL 11460 0 1
37562: AND
37563: PUSH
37564: LD_EXP 36
37568: PUSH
37569: LD_VAR 0 1
37573: ARRAY
37574: NOT
37575: AND
37576: IFFALSE 37870
// begin for j = 1 to MCF_Lab ( side ) do
37578: LD_ADDR_VAR 0 5
37582: PUSH
37583: DOUBLE
37584: LD_INT 1
37586: DEC
37587: ST_TO_ADDR
37588: LD_VAR 0 1
37592: PPUSH
37593: CALL 11460 0 1
37597: PUSH
37598: FOR_TO
37599: IFFALSE 37659
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37601: LD_VAR 0 1
37605: PPUSH
37606: CALL 11460 0 1
37610: PUSH
37611: LD_VAR 0 5
37615: ARRAY
37616: PPUSH
37617: CALL_OW 461
37621: PUSH
37622: LD_INT 3
37624: PUSH
37625: LD_INT 6
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: IN
37632: IFFALSE 37657
// begin b := MCF_Lab ( side ) [ j ] ;
37634: LD_ADDR_VAR 0 11
37638: PUSH
37639: LD_VAR 0 1
37643: PPUSH
37644: CALL 11460 0 1
37648: PUSH
37649: LD_VAR 0 5
37653: ARRAY
37654: ST_TO_ADDR
// break ;
37655: GO 37659
// end ;
37657: GO 37598
37659: POP
37660: POP
// if MCF_Class ( side , 4 , [ ] ) then
37661: LD_VAR 0 1
37665: PPUSH
37666: LD_INT 4
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL 11504 0 3
37675: IFFALSE 37870
// for j in MCF_Class ( side , 4 , [ ] ) do
37677: LD_ADDR_VAR 0 5
37681: PUSH
37682: LD_VAR 0 1
37686: PPUSH
37687: LD_INT 4
37689: PPUSH
37690: EMPTY
37691: PPUSH
37692: CALL 11504 0 3
37696: PUSH
37697: FOR_IN
37698: IFFALSE 37868
// begin if GetTag ( j ) = 0 then
37700: LD_VAR 0 5
37704: PPUSH
37705: CALL_OW 110
37709: PUSH
37710: LD_INT 0
37712: EQUAL
37713: IFFALSE 37804
// begin if IsInUnit ( j ) and b then
37715: LD_VAR 0 5
37719: PPUSH
37720: CALL_OW 310
37724: PUSH
37725: LD_VAR 0 11
37729: AND
37730: IFFALSE 37778
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37732: LD_VAR 0 5
37736: PPUSH
37737: CALL_OW 310
37741: PPUSH
37742: CALL_OW 461
37746: PUSH
37747: LD_INT 2
37749: EQUAL
37750: PUSH
37751: LD_VAR 0 5
37755: PPUSH
37756: CALL_OW 310
37760: PUSH
37761: LD_VAR 0 11
37765: NONEQUAL
37766: AND
37767: IFFALSE 37778
// ComExitBuilding ( j ) ;
37769: LD_VAR 0 5
37773: PPUSH
37774: CALL_OW 122
// if not IsInUnit ( j ) then
37778: LD_VAR 0 5
37782: PPUSH
37783: CALL_OW 310
37787: NOT
37788: IFFALSE 37804
// ComEnterUnit ( j , b ) ;
37790: LD_VAR 0 5
37794: PPUSH
37795: LD_VAR 0 11
37799: PPUSH
37800: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37804: LD_INT 1
37806: PPUSH
37807: LD_VAR 0 5
37811: PPUSH
37812: CALL_OW 255
37816: PPUSH
37817: CALL_OW 321
37821: PUSH
37822: LD_INT 2
37824: EQUAL
37825: PUSH
37826: LD_VAR 0 5
37830: PPUSH
37831: CALL_OW 255
37835: PPUSH
37836: CALL 24822 0 1
37840: PUSH
37841: LD_INT 0
37843: EQUAL
37844: AND
37845: IFFALSE 37866
// MCN_Tame ( GetSide ( j ) , j ) ;
37847: LD_VAR 0 5
37851: PPUSH
37852: CALL_OW 255
37856: PPUSH
37857: LD_VAR 0 5
37861: PPUSH
37862: CALL 18323 0 2
// end ;
37866: GO 37697
37868: POP
37869: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37870: LD_VAR 0 1
37874: PPUSH
37875: LD_INT 30
37877: PUSH
37878: LD_INT 3
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PPUSH
37885: CALL 11421 0 2
37889: IFFALSE 38148
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37891: LD_ADDR_VAR 0 11
37895: PUSH
37896: LD_VAR 0 1
37900: PPUSH
37901: LD_INT 30
37903: PUSH
37904: LD_INT 3
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PPUSH
37911: CALL 11421 0 2
37915: PUSH
37916: LD_INT 1
37918: ARRAY
37919: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37920: LD_ADDR_VAR 0 12
37924: PUSH
37925: LD_VAR 0 1
37929: PPUSH
37930: LD_INT 0
37932: PPUSH
37933: LD_INT 25
37935: PUSH
37936: LD_INT 3
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PPUSH
37943: CALL 12124 0 3
37947: ST_TO_ADDR
// for i = 1 to tmp do
37948: LD_ADDR_VAR 0 4
37952: PUSH
37953: DOUBLE
37954: LD_INT 1
37956: DEC
37957: ST_TO_ADDR
37958: LD_VAR 0 12
37962: PUSH
37963: FOR_TO
37964: IFFALSE 38024
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37966: LD_VAR 0 12
37970: PUSH
37971: LD_VAR 0 4
37975: ARRAY
37976: PPUSH
37977: CALL_OW 310
37981: NOT
37982: PUSH
37983: LD_VAR 0 12
37987: PUSH
37988: LD_VAR 0 4
37992: ARRAY
37993: PPUSH
37994: CALL_OW 314
37998: NOT
37999: AND
38000: IFFALSE 38022
// ComEnterUnit ( tmp [ i ] , b ) ;
38002: LD_VAR 0 12
38006: PUSH
38007: LD_VAR 0 4
38011: ARRAY
38012: PPUSH
38013: LD_VAR 0 11
38017: PPUSH
38018: CALL_OW 120
38022: GO 37963
38024: POP
38025: POP
// if MREG_ToFac [ side ] then
38026: LD_EXP 56
38030: PUSH
38031: LD_VAR 0 1
38035: ARRAY
38036: IFFALSE 38056
// k := MREG_ToFac [ side ] else
38038: LD_ADDR_VAR 0 8
38042: PUSH
38043: LD_EXP 56
38047: PUSH
38048: LD_VAR 0 1
38052: ARRAY
38053: ST_TO_ADDR
38054: GO 38064
// k := 0 ;
38056: LD_ADDR_VAR 0 8
38060: PUSH
38061: LD_INT 0
38063: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
38064: LD_VAR 0 15
38068: PUSH
38069: LD_VAR 0 8
38073: PLUS
38074: PUSH
38075: LD_INT 6
38077: LESSEQUAL
38078: PUSH
38079: LD_VAR 0 17
38083: PUSH
38084: LD_INT 6
38086: GREATER
38087: AND
38088: IFFALSE 38104
// MCH_TrainMechanic ( side , 1 ) else
38090: LD_VAR 0 1
38094: PPUSH
38095: LD_INT 1
38097: PPUSH
38098: CALL 15622 0 2
38102: GO 38148
// if all < 6 then
38104: LD_VAR 0 17
38108: PUSH
38109: LD_INT 6
38111: LESS
38112: IFFALSE 38148
// if mech + k < all / 2 then
38114: LD_VAR 0 15
38118: PUSH
38119: LD_VAR 0 8
38123: PLUS
38124: PUSH
38125: LD_VAR 0 17
38129: PUSH
38130: LD_INT 2
38132: DIVREAL
38133: LESS
38134: IFFALSE 38148
// MCH_TrainMechanic ( side , 1 ) ;
38136: LD_VAR 0 1
38140: PPUSH
38141: LD_INT 1
38143: PPUSH
38144: CALL 15622 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38148: LD_ADDR_VAR 0 10
38152: PUSH
38153: LD_VAR 0 1
38157: PPUSH
38158: LD_INT 30
38160: PUSH
38161: LD_INT 36
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PPUSH
38168: CALL 11421 0 2
38172: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38173: LD_VAR 0 10
38177: PUSH
38178: LD_VAR 0 15
38182: AND
38183: PUSH
38184: LD_VAR 0 1
38188: PPUSH
38189: LD_INT 3
38191: PPUSH
38192: EMPTY
38193: PPUSH
38194: CALL 11504 0 3
38198: AND
38199: IFFALSE 38357
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38201: LD_VAR 0 1
38205: PPUSH
38206: LD_INT 9
38208: PPUSH
38209: EMPTY
38210: PPUSH
38211: CALL 12124 0 3
38215: PUSH
38216: LD_INT 3
38218: LESS
38219: IFFALSE 38357
// begin if mech < 3 then
38221: LD_VAR 0 15
38225: PUSH
38226: LD_INT 3
38228: LESS
38229: IFFALSE 38243
// k := mech else
38231: LD_ADDR_VAR 0 8
38235: PUSH
38236: LD_VAR 0 15
38240: ST_TO_ADDR
38241: GO 38251
// k := 3 ;
38243: LD_ADDR_VAR 0 8
38247: PUSH
38248: LD_INT 3
38250: ST_TO_ADDR
// for j = 1 to k do
38251: LD_ADDR_VAR 0 5
38255: PUSH
38256: DOUBLE
38257: LD_INT 1
38259: DEC
38260: ST_TO_ADDR
38261: LD_VAR 0 8
38265: PUSH
38266: FOR_TO
38267: IFFALSE 38325
// if GetClass ( mech [ j ] ) = 3 then
38269: LD_VAR 0 15
38273: PUSH
38274: LD_VAR 0 5
38278: ARRAY
38279: PPUSH
38280: CALL_OW 257
38284: PUSH
38285: LD_INT 3
38287: EQUAL
38288: IFFALSE 38323
// begin SetTag ( mech [ j ] , 9 ) ;
38290: LD_VAR 0 15
38294: PUSH
38295: LD_VAR 0 5
38299: ARRAY
38300: PPUSH
38301: LD_INT 9
38303: PPUSH
38304: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38308: LD_VAR 0 15
38312: PUSH
38313: LD_VAR 0 5
38317: ARRAY
38318: PPUSH
38319: CALL_OW 122
// end ;
38323: GO 38266
38325: POP
38326: POP
// if mech < 6 + k then
38327: LD_VAR 0 15
38331: PUSH
38332: LD_INT 6
38334: PUSH
38335: LD_VAR 0 8
38339: PLUS
38340: LESS
38341: IFFALSE 38357
// MCH_TrainMechanic ( side , k ) ;
38343: LD_VAR 0 1
38347: PPUSH
38348: LD_VAR 0 8
38352: PPUSH
38353: CALL 15622 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38357: LD_VAR 0 1
38361: PPUSH
38362: LD_INT 9
38364: PPUSH
38365: EMPTY
38366: PPUSH
38367: CALL 12124 0 3
38371: IFFALSE 38462
// for j in MCF_Tag ( side , 9 , [ ] ) do
38373: LD_ADDR_VAR 0 5
38377: PUSH
38378: LD_VAR 0 1
38382: PPUSH
38383: LD_INT 9
38385: PPUSH
38386: EMPTY
38387: PPUSH
38388: CALL 12124 0 3
38392: PUSH
38393: FOR_IN
38394: IFFALSE 38460
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38396: LD_VAR 0 5
38400: PPUSH
38401: CALL_OW 310
38405: NOT
38406: PUSH
38407: LD_VAR 0 5
38411: PPUSH
38412: CALL 31602 0 1
38416: NOT
38417: AND
38418: IFFALSE 38458
// if ct then
38420: LD_VAR 0 10
38424: IFFALSE 38446
// ComEnterUnit ( j , ct [ 1 ] ) else
38426: LD_VAR 0 5
38430: PPUSH
38431: LD_VAR 0 10
38435: PUSH
38436: LD_INT 1
38438: ARRAY
38439: PPUSH
38440: CALL_OW 120
38444: GO 38458
// SetTag ( j , 0 ) ;
38446: LD_VAR 0 5
38450: PPUSH
38451: LD_INT 0
38453: PPUSH
38454: CALL_OW 109
38458: GO 38393
38460: POP
38461: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38462: LD_INT 1
38464: PPUSH
38465: LD_VAR 0 1
38469: PPUSH
38470: CALL_OW 321
38474: PUSH
38475: LD_INT 2
38477: EQUAL
38478: PUSH
38479: LD_EXP 36
38483: PUSH
38484: LD_VAR 0 1
38488: ARRAY
38489: NOT
38490: AND
38491: PUSH
38492: LD_VAR 0 1
38496: PPUSH
38497: LD_INT 4
38499: PPUSH
38500: EMPTY
38501: PPUSH
38502: CALL 11504 0 3
38506: AND
38507: IFFALSE 38555
// for j in MCF_Class ( side , 4 , [ ] ) do
38509: LD_ADDR_VAR 0 5
38513: PUSH
38514: LD_VAR 0 1
38518: PPUSH
38519: LD_INT 4
38521: PPUSH
38522: EMPTY
38523: PPUSH
38524: CALL 11504 0 3
38528: PUSH
38529: FOR_IN
38530: IFFALSE 38553
// MCN_Tame ( GetSide ( j ) , j ) ;
38532: LD_VAR 0 5
38536: PPUSH
38537: CALL_OW 255
38541: PPUSH
38542: LD_VAR 0 5
38546: PPUSH
38547: CALL 18323 0 2
38551: GO 38529
38553: POP
38554: POP
// if MREG_DefVeh [ side ] then
38555: LD_EXP 68
38559: PUSH
38560: LD_VAR 0 1
38564: ARRAY
38565: IFFALSE 38729
// begin for i in MREG_DefVeh [ side ] do
38567: LD_ADDR_VAR 0 4
38571: PUSH
38572: LD_EXP 68
38576: PUSH
38577: LD_VAR 0 1
38581: ARRAY
38582: PUSH
38583: FOR_IN
38584: IFFALSE 38637
// begin SetTag ( i , 0 ) ;
38586: LD_VAR 0 4
38590: PPUSH
38591: LD_INT 0
38593: PPUSH
38594: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38598: LD_VAR 0 4
38602: PPUSH
38603: LD_EXP 65
38607: PUSH
38608: LD_VAR 0 1
38612: ARRAY
38613: PPUSH
38614: CALL_OW 308
38618: NOT
38619: IFFALSE 38635
// MCV_Parking ( side , i ) ;
38621: LD_VAR 0 1
38625: PPUSH
38626: LD_VAR 0 4
38630: PPUSH
38631: CALL 25582 0 2
// end ;
38635: GO 38583
38637: POP
38638: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38639: LD_VAR 0 1
38643: PPUSH
38644: LD_INT 36
38646: PPUSH
38647: EMPTY
38648: PPUSH
38649: CALL 12124 0 3
38653: IFFALSE 38694
// for i in MCF_Tag ( side , 36 , [ ] ) do
38655: LD_ADDR_VAR 0 4
38659: PUSH
38660: LD_VAR 0 1
38664: PPUSH
38665: LD_INT 36
38667: PPUSH
38668: EMPTY
38669: PPUSH
38670: CALL 12124 0 3
38674: PUSH
38675: FOR_IN
38676: IFFALSE 38692
// SetTag ( i , 0 ) ;
38678: LD_VAR 0 4
38682: PPUSH
38683: LD_INT 0
38685: PPUSH
38686: CALL_OW 109
38690: GO 38675
38692: POP
38693: POP
// if MREG_DefMobActive [ side ] then
38694: LD_EXP 71
38698: PUSH
38699: LD_VAR 0 1
38703: ARRAY
38704: IFFALSE 38729
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38706: LD_ADDR_EXP 71
38710: PUSH
38711: LD_EXP 71
38715: PPUSH
38716: LD_VAR 0 1
38720: PPUSH
38721: LD_INT 0
38723: PPUSH
38724: CALL_OW 1
38728: ST_TO_ADDR
// end ; end ; if mode > 0 then
38729: LD_VAR 0 2
38733: PUSH
38734: LD_INT 0
38736: GREATER
38737: IFFALSE 40752
// begin if tick <= 15 15$00 then
38739: LD_OWVAR 1
38743: PUSH
38744: LD_INT 31500
38746: LESSEQUAL
38747: IFFALSE 39171
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38749: LD_VAR 0 13
38753: PUSH
38754: LD_INT 4
38756: GREATER
38757: PUSH
38758: LD_VAR 0 1
38762: PPUSH
38763: CALL 24822 0 1
38767: PUSH
38768: LD_INT 4
38770: LESS
38771: AND
38772: IFFALSE 38883
// for i in sol do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 13
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38881
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38787: LD_ADDR_VAR 0 8
38791: PUSH
38792: LD_VAR 0 1
38796: PPUSH
38797: CALL 24822 0 1
38801: PPUSH
38802: LD_VAR 0 4
38806: PPUSH
38807: CALL_OW 74
38811: ST_TO_ADDR
// if IsInUnit ( i ) then
38812: LD_VAR 0 4
38816: PPUSH
38817: CALL_OW 310
38821: IFFALSE 38832
// ComExitBuilding ( i ) ;
38823: LD_VAR 0 4
38827: PPUSH
38828: CALL_OW 122
// if not HasTask ( i ) and k then
38832: LD_VAR 0 4
38836: PPUSH
38837: CALL_OW 314
38841: NOT
38842: PUSH
38843: LD_VAR 0 8
38847: AND
38848: IFFALSE 38879
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38850: LD_VAR 0 4
38854: PPUSH
38855: LD_VAR 0 8
38859: PPUSH
38860: CALL_OW 250
38864: PPUSH
38865: LD_VAR 0 8
38869: PPUSH
38870: CALL_OW 251
38874: PPUSH
38875: CALL_OW 114
// end ;
38879: GO 38784
38881: POP
38882: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38883: LD_VAR 0 1
38887: PPUSH
38888: LD_INT 30
38890: PUSH
38891: LD_INT 5
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PPUSH
38898: CALL 11421 0 2
38902: IFFALSE 39169
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38904: LD_ADDR_VAR 0 11
38908: PUSH
38909: LD_VAR 0 1
38913: PPUSH
38914: LD_INT 30
38916: PUSH
38917: LD_INT 5
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PPUSH
38924: CALL 11421 0 2
38928: PUSH
38929: LD_INT 1
38931: ARRAY
38932: ST_TO_ADDR
// if mech then
38933: LD_VAR 0 15
38937: IFFALSE 38973
// for i in mech do
38939: LD_ADDR_VAR 0 4
38943: PUSH
38944: LD_VAR 0 15
38948: PUSH
38949: FOR_IN
38950: IFFALSE 38971
// MCH_ChangeClass ( side , i , 1 ) ;
38952: LD_VAR 0 1
38956: PPUSH
38957: LD_VAR 0 4
38961: PPUSH
38962: LD_INT 1
38964: PPUSH
38965: CALL 16328 0 3
38969: GO 38949
38971: POP
38972: POP
// if eng > 1 then
38973: LD_VAR 0 14
38977: PUSH
38978: LD_INT 1
38980: GREATER
38981: IFFALSE 39028
// for i = eng downto 2 do
38983: LD_ADDR_VAR 0 4
38987: PUSH
38988: DOUBLE
38989: LD_VAR 0 14
38993: INC
38994: ST_TO_ADDR
38995: LD_INT 2
38997: PUSH
38998: FOR_DOWNTO
38999: IFFALSE 39026
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39001: LD_VAR 0 1
39005: PPUSH
39006: LD_VAR 0 14
39010: PUSH
39011: LD_VAR 0 4
39015: ARRAY
39016: PPUSH
39017: LD_INT 1
39019: PPUSH
39020: CALL 16328 0 3
39024: GO 38998
39026: POP
39027: POP
// if UnitsInside ( b ) = 6 then
39028: LD_VAR 0 11
39032: PPUSH
39033: CALL_OW 313
39037: PUSH
39038: LD_INT 6
39040: EQUAL
39041: IFFALSE 39169
// begin un := UnitsInside ( b ) [ 1 ] ;
39043: LD_ADDR_VAR 0 9
39047: PUSH
39048: LD_VAR 0 11
39052: PPUSH
39053: CALL_OW 313
39057: PUSH
39058: LD_INT 1
39060: ARRAY
39061: ST_TO_ADDR
// ComExitBuilding ( un ) ;
39062: LD_VAR 0 9
39066: PPUSH
39067: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
39071: LD_VAR 0 1
39075: PPUSH
39076: LD_INT 30
39078: PUSH
39079: LD_INT 5
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PPUSH
39086: CALL 11421 0 2
39090: PUSH
39091: LD_INT 1
39093: GREATER
39094: PUSH
39095: LD_VAR 0 1
39099: PPUSH
39100: CALL 24822 0 1
39104: PUSH
39105: LD_INT 4
39107: GREATEREQUAL
39108: AND
39109: IFFALSE 39169
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39111: LD_ADDR_VAR 0 8
39115: PUSH
39116: LD_VAR 0 1
39120: PPUSH
39121: LD_INT 30
39123: PUSH
39124: LD_INT 5
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: PPUSH
39131: CALL 11421 0 2
39135: PUSH
39136: LD_INT 2
39138: ARRAY
39139: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39140: LD_VAR 0 8
39144: PPUSH
39145: CALL_OW 313
39149: PUSH
39150: LD_INT 6
39152: LESS
39153: IFFALSE 39169
// AddComEnterUnit ( un , k ) ;
39155: LD_VAR 0 9
39159: PPUSH
39160: LD_VAR 0 8
39164: PPUSH
39165: CALL_OW 180
// end ; end ; end ; end else
39169: GO 40752
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39171: LD_VAR 0 1
39175: PPUSH
39176: LD_INT 1
39178: PPUSH
39179: LD_EXP 66
39183: PUSH
39184: LD_VAR 0 1
39188: ARRAY
39189: PUSH
39190: LD_INT 1
39192: ARRAY
39193: PPUSH
39194: CALL 33904 0 3
39198: IFFALSE 39337
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39200: LD_ADDR_VAR 0 12
39204: PUSH
39205: LD_VAR 0 1
39209: PPUSH
39210: LD_INT 21
39212: PUSH
39213: LD_INT 1
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PPUSH
39220: CALL 11421 0 2
39224: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39225: LD_ADDR_VAR 0 11
39229: PUSH
39230: LD_VAR 0 1
39234: PPUSH
39235: LD_INT 30
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PPUSH
39245: CALL 11421 0 2
39249: ST_TO_ADDR
// if b then
39250: LD_VAR 0 11
39254: IFFALSE 39337
// for i in tmp do
39256: LD_ADDR_VAR 0 4
39260: PUSH
39261: LD_VAR 0 12
39265: PUSH
39266: FOR_IN
39267: IFFALSE 39335
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39269: LD_VAR 0 4
39273: PPUSH
39274: LD_EXP 66
39278: PUSH
39279: LD_VAR 0 1
39283: ARRAY
39284: PUSH
39285: LD_INT 1
39287: ARRAY
39288: PPUSH
39289: CALL_OW 308
39293: NOT
39294: IFFALSE 39333
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39296: LD_VAR 0 4
39300: PPUSH
39301: LD_VAR 0 11
39305: PUSH
39306: LD_INT 1
39308: ARRAY
39309: PPUSH
39310: CALL_OW 250
39314: PPUSH
39315: LD_VAR 0 11
39319: PUSH
39320: LD_INT 1
39322: ARRAY
39323: PPUSH
39324: CALL_OW 251
39328: PPUSH
39329: CALL_OW 111
39333: GO 39266
39335: POP
39336: POP
// end ; if MREG_DefVeh [ side ] then
39337: LD_EXP 68
39341: PUSH
39342: LD_VAR 0 1
39346: ARRAY
39347: IFFALSE 39915
// begin tmp := [ ] ;
39349: LD_ADDR_VAR 0 12
39353: PUSH
39354: EMPTY
39355: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39356: LD_EXP 71
39360: PUSH
39361: LD_VAR 0 1
39365: ARRAY
39366: PUSH
39367: LD_INT 0
39369: EQUAL
39370: IFFALSE 39510
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39372: LD_ADDR_VAR 0 8
39376: PUSH
39377: LD_VAR 0 1
39381: PPUSH
39382: LD_INT 0
39384: PPUSH
39385: LD_INT 25
39387: PUSH
39388: LD_INT 3
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PPUSH
39395: CALL 12124 0 3
39399: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39400: LD_VAR 0 8
39404: PUSH
39405: LD_EXP 68
39409: PUSH
39410: LD_VAR 0 1
39414: ARRAY
39415: GREATER
39416: IFFALSE 39477
// begin for i = 1 to MREG_DefVeh [ side ] do
39418: LD_ADDR_VAR 0 4
39422: PUSH
39423: DOUBLE
39424: LD_INT 1
39426: DEC
39427: ST_TO_ADDR
39428: LD_EXP 68
39432: PUSH
39433: LD_VAR 0 1
39437: ARRAY
39438: PUSH
39439: FOR_TO
39440: IFFALSE 39473
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39442: LD_ADDR_VAR 0 12
39446: PUSH
39447: LD_VAR 0 12
39451: PPUSH
39452: LD_INT 1
39454: PPUSH
39455: LD_VAR 0 8
39459: PUSH
39460: LD_VAR 0 4
39464: ARRAY
39465: PPUSH
39466: CALL_OW 2
39470: ST_TO_ADDR
39471: GO 39439
39473: POP
39474: POP
// end else
39475: GO 39487
// tmp := k ;
39477: LD_ADDR_VAR 0 12
39481: PUSH
39482: LD_VAR 0 8
39486: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39487: LD_ADDR_EXP 71
39491: PUSH
39492: LD_EXP 71
39496: PPUSH
39497: LD_VAR 0 1
39501: PPUSH
39502: LD_INT 1
39504: PPUSH
39505: CALL_OW 1
39509: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39510: LD_ADDR_VAR 0 4
39514: PUSH
39515: LD_EXP 68
39519: PUSH
39520: LD_VAR 0 1
39524: ARRAY
39525: PUSH
39526: FOR_IN
39527: IFFALSE 39913
// begin if not GetDriver ( i ) then
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL 31653 0 1
39538: NOT
39539: IFFALSE 39614
// begin if tmp then
39541: LD_VAR 0 12
39545: IFFALSE 39612
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39547: LD_VAR 0 12
39551: PUSH
39552: LD_INT 1
39554: ARRAY
39555: PPUSH
39556: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39560: LD_VAR 0 12
39564: PUSH
39565: LD_INT 1
39567: ARRAY
39568: PPUSH
39569: LD_VAR 0 4
39573: PPUSH
39574: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39578: LD_VAR 0 12
39582: PUSH
39583: LD_INT 1
39585: ARRAY
39586: PPUSH
39587: LD_INT 36
39589: PPUSH
39590: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39594: LD_ADDR_VAR 0 12
39598: PUSH
39599: LD_VAR 0 12
39603: PPUSH
39604: LD_INT 1
39606: PPUSH
39607: CALL_OW 3
39611: ST_TO_ADDR
// end ; end else
39612: GO 39911
// begin if GetTag ( i ) = 0 then
39614: LD_VAR 0 4
39618: PPUSH
39619: CALL_OW 110
39623: PUSH
39624: LD_INT 0
39626: EQUAL
39627: IFFALSE 39643
// SetTag ( i , 31 ) else
39629: LD_VAR 0 4
39633: PPUSH
39634: LD_INT 31
39636: PPUSH
39637: CALL_OW 109
39641: GO 39911
// if GetTag ( i ) = 31 then
39643: LD_VAR 0 4
39647: PPUSH
39648: CALL_OW 110
39652: PUSH
39653: LD_INT 31
39655: EQUAL
39656: IFFALSE 39911
// begin if GetFuel ( i ) < 20 then
39658: LD_VAR 0 4
39662: PPUSH
39663: CALL_OW 261
39667: PUSH
39668: LD_INT 20
39670: LESS
39671: IFFALSE 39696
// begin SetTag ( i , 21 ) ;
39673: LD_VAR 0 4
39677: PPUSH
39678: LD_INT 21
39680: PPUSH
39681: CALL_OW 109
// MCV_Refuel ( i ) ;
39685: LD_VAR 0 4
39689: PPUSH
39690: CALL 26119 0 1
// continue ;
39694: GO 39526
// end ; if GetLives ( i ) < 700 then
39696: LD_VAR 0 4
39700: PPUSH
39701: CALL_OW 256
39705: PUSH
39706: LD_INT 700
39708: LESS
39709: IFFALSE 39821
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39711: LD_VAR 0 4
39715: PPUSH
39716: LD_EXP 59
39720: PUSH
39721: LD_VAR 0 1
39725: ARRAY
39726: PPUSH
39727: CALL_OW 308
39731: NOT
39732: IFFALSE 39756
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39734: LD_VAR 0 4
39738: PPUSH
39739: LD_EXP 59
39743: PUSH
39744: LD_VAR 0 1
39748: ARRAY
39749: PPUSH
39750: CALL_OW 113
39754: GO 39819
// if GetDriver ( i ) then
39756: LD_VAR 0 4
39760: PPUSH
39761: CALL 31653 0 1
39765: IFFALSE 39819
// begin k := GetDriver ( i ) ;
39767: LD_ADDR_VAR 0 8
39771: PUSH
39772: LD_VAR 0 4
39776: PPUSH
39777: CALL 31653 0 1
39781: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39782: LD_VAR 0 8
39786: PPUSH
39787: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39791: LD_VAR 0 8
39795: PPUSH
39796: LD_VAR 0 4
39800: PPUSH
39801: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39805: LD_VAR 0 8
39809: PPUSH
39810: LD_VAR 0 4
39814: PPUSH
39815: CALL_OW 180
// end ; end else
39819: GO 39911
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39821: LD_ADDR_VAR 0 8
39825: PUSH
39826: LD_VAR 0 1
39830: PPUSH
39831: CALL 24822 0 1
39835: PPUSH
39836: LD_VAR 0 4
39840: PPUSH
39841: CALL_OW 74
39845: ST_TO_ADDR
// if k then
39846: LD_VAR 0 8
39850: IFFALSE 39868
// ComAttackUnit ( i , k ) else
39852: LD_VAR 0 4
39856: PPUSH
39857: LD_VAR 0 8
39861: PPUSH
39862: CALL_OW 115
39866: GO 39911
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39868: LD_VAR 0 4
39872: PPUSH
39873: LD_EXP 59
39877: PUSH
39878: LD_VAR 0 1
39882: ARRAY
39883: PPUSH
39884: CALL_OW 308
39888: NOT
39889: IFFALSE 39911
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39891: LD_VAR 0 4
39895: PPUSH
39896: LD_EXP 59
39900: PUSH
39901: LD_VAR 0 1
39905: ARRAY
39906: PPUSH
39907: CALL_OW 113
// end ; end ; end ; end ;
39911: GO 39526
39913: POP
39914: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39915: LD_VAR 0 1
39919: PPUSH
39920: LD_INT 30
39922: PUSH
39923: LD_INT 5
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL 11421 0 2
39934: IFFALSE 40752
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39936: LD_ADDR_VAR 0 11
39940: PUSH
39941: LD_VAR 0 1
39945: PPUSH
39946: LD_INT 30
39948: PUSH
39949: LD_INT 5
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PPUSH
39956: CALL 11421 0 2
39960: PUSH
39961: LD_INT 1
39963: ARRAY
39964: ST_TO_ADDR
// if eng > 1 then
39965: LD_VAR 0 14
39969: PUSH
39970: LD_INT 1
39972: GREATER
39973: IFFALSE 40020
// for i = eng downto 2 do
39975: LD_ADDR_VAR 0 4
39979: PUSH
39980: DOUBLE
39981: LD_VAR 0 14
39985: INC
39986: ST_TO_ADDR
39987: LD_INT 2
39989: PUSH
39990: FOR_DOWNTO
39991: IFFALSE 40018
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39993: LD_VAR 0 1
39997: PPUSH
39998: LD_VAR 0 14
40002: PUSH
40003: LD_VAR 0 4
40007: ARRAY
40008: PPUSH
40009: LD_INT 1
40011: PPUSH
40012: CALL 16328 0 3
40016: GO 39990
40018: POP
40019: POP
// if sci > 1 then
40020: LD_VAR 0 16
40024: PUSH
40025: LD_INT 1
40027: GREATER
40028: IFFALSE 40075
// for i = sci downto 2 do
40030: LD_ADDR_VAR 0 4
40034: PUSH
40035: DOUBLE
40036: LD_VAR 0 16
40040: INC
40041: ST_TO_ADDR
40042: LD_INT 2
40044: PUSH
40045: FOR_DOWNTO
40046: IFFALSE 40073
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
40048: LD_VAR 0 1
40052: PPUSH
40053: LD_VAR 0 16
40057: PUSH
40058: LD_VAR 0 4
40062: ARRAY
40063: PPUSH
40064: LD_INT 1
40066: PPUSH
40067: CALL 16328 0 3
40071: GO 40045
40073: POP
40074: POP
// if sol then
40075: LD_VAR 0 13
40079: IFFALSE 40752
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
40081: LD_VAR 0 13
40085: PUSH
40086: LD_EXP 69
40090: PUSH
40091: LD_VAR 0 1
40095: ARRAY
40096: DIFF
40097: PUSH
40098: LD_INT 22
40100: PUSH
40101: LD_VAR 0 1
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 58
40112: PUSH
40113: EMPTY
40114: LIST
40115: PUSH
40116: LD_INT 2
40118: PUSH
40119: LD_INT 30
40121: PUSH
40122: LD_INT 32
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 30
40131: PUSH
40132: LD_INT 31
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: LIST
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: LIST
40148: PPUSH
40149: CALL_OW 69
40153: PUSH
40154: LD_INT 0
40156: EQUAL
40157: AND
40158: IFFALSE 40752
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40160: LD_ADDR_VAR 0 12
40164: PUSH
40165: LD_VAR 0 13
40169: PUSH
40170: LD_EXP 69
40174: PUSH
40175: LD_VAR 0 1
40179: ARRAY
40180: DIFF
40181: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40182: LD_VAR 0 1
40186: PPUSH
40187: LD_INT 30
40189: PUSH
40190: LD_INT 5
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PPUSH
40197: CALL 11421 0 2
40201: PUSH
40202: LD_INT 1
40204: GREATER
40205: IFFALSE 40236
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40207: LD_ADDR_VAR 0 8
40211: PUSH
40212: LD_VAR 0 1
40216: PPUSH
40217: LD_INT 30
40219: PUSH
40220: LD_INT 5
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PPUSH
40227: CALL 11421 0 2
40231: PUSH
40232: LD_INT 2
40234: ARRAY
40235: ST_TO_ADDR
// for j in tmp do
40236: LD_ADDR_VAR 0 5
40240: PUSH
40241: LD_VAR 0 12
40245: PUSH
40246: FOR_IN
40247: IFFALSE 40750
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40249: LD_VAR 0 5
40253: PUSH
40254: LD_VAR 0 11
40258: PPUSH
40259: CALL_OW 313
40263: IN
40264: PUSH
40265: LD_VAR 0 11
40269: PPUSH
40270: CALL_OW 313
40274: PUSH
40275: LD_INT 6
40277: EQUAL
40278: AND
40279: PUSH
40280: LD_VAR 0 8
40284: AND
40285: PUSH
40286: LD_VAR 0 8
40290: PPUSH
40291: CALL_OW 313
40295: PUSH
40296: LD_INT 6
40298: LESS
40299: AND
40300: IFFALSE 40327
// begin ComExitBuilding ( j ) ;
40302: LD_VAR 0 5
40306: PPUSH
40307: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40311: LD_VAR 0 5
40315: PPUSH
40316: LD_VAR 0 8
40320: PPUSH
40321: CALL_OW 180
// continue ;
40325: GO 40246
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40327: LD_VAR 0 5
40331: PPUSH
40332: CALL_OW 314
40336: NOT
40337: PUSH
40338: LD_VAR 0 5
40342: PPUSH
40343: CALL_OW 110
40347: PUSH
40348: LD_INT 0
40350: EQUAL
40351: AND
40352: PUSH
40353: LD_VAR 0 5
40357: PPUSH
40358: CALL_OW 310
40362: NOT
40363: AND
40364: IFFALSE 40470
// begin if k then
40366: LD_VAR 0 8
40370: IFFALSE 40441
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40372: LD_VAR 0 8
40376: PPUSH
40377: CALL_OW 313
40381: PUSH
40382: LD_VAR 0 11
40386: PPUSH
40387: CALL_OW 313
40391: LESS
40392: IFFALSE 40410
// ComEnterUnit ( j , k ) else
40394: LD_VAR 0 5
40398: PPUSH
40399: LD_VAR 0 8
40403: PPUSH
40404: CALL_OW 120
40408: GO 40439
// if UnitsInside ( b ) < 6 then
40410: LD_VAR 0 11
40414: PPUSH
40415: CALL_OW 313
40419: PUSH
40420: LD_INT 6
40422: LESS
40423: IFFALSE 40439
// ComEnterUnit ( j , b ) ;
40425: LD_VAR 0 5
40429: PPUSH
40430: LD_VAR 0 11
40434: PPUSH
40435: CALL_OW 120
// end else
40439: GO 40470
// if UnitsInside ( b ) < 6 then
40441: LD_VAR 0 11
40445: PPUSH
40446: CALL_OW 313
40450: PUSH
40451: LD_INT 6
40453: LESS
40454: IFFALSE 40470
// ComEnterUnit ( j , b ) ;
40456: LD_VAR 0 5
40460: PPUSH
40461: LD_VAR 0 11
40465: PPUSH
40466: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40470: LD_VAR 0 5
40474: PUSH
40475: LD_VAR 0 1
40479: PPUSH
40480: LD_INT 54
40482: PUSH
40483: EMPTY
40484: LIST
40485: PPUSH
40486: CALL 11421 0 2
40490: IN
40491: PUSH
40492: LD_VAR 0 5
40496: PPUSH
40497: CALL_OW 257
40501: PUSH
40502: LD_INT 1
40504: EQUAL
40505: AND
40506: IFFALSE 40748
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40508: LD_EXP 63
40512: PUSH
40513: LD_VAR 0 1
40517: ARRAY
40518: PUSH
40519: LD_INT 1
40521: ARRAY
40522: PUSH
40523: LD_INT 12
40525: PPUSH
40526: LD_VAR 0 1
40530: PPUSH
40531: CALL_OW 321
40535: PUSH
40536: LD_INT 2
40538: EQUAL
40539: AND
40540: IFFALSE 40588
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40542: LD_VAR 0 1
40546: PPUSH
40547: LD_INT 5
40549: PPUSH
40550: EMPTY
40551: PPUSH
40552: CALL 11504 0 3
40556: PUSH
40557: LD_EXP 63
40561: PUSH
40562: LD_VAR 0 1
40566: ARRAY
40567: PUSH
40568: LD_INT 1
40570: ARRAY
40571: LESS
40572: IFFALSE 40588
// begin SetClass ( j , class_sniper ) ;
40574: LD_VAR 0 5
40578: PPUSH
40579: LD_INT 5
40581: PPUSH
40582: CALL_OW 336
// continue ;
40586: GO 40246
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40588: LD_EXP 63
40592: PUSH
40593: LD_VAR 0 1
40597: ARRAY
40598: PUSH
40599: LD_INT 2
40601: ARRAY
40602: PUSH
40603: LD_INT 41
40605: PPUSH
40606: LD_VAR 0 1
40610: PPUSH
40611: CALL_OW 321
40615: PUSH
40616: LD_INT 2
40618: EQUAL
40619: AND
40620: IFFALSE 40668
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40622: LD_VAR 0 1
40626: PPUSH
40627: LD_INT 8
40629: PPUSH
40630: EMPTY
40631: PPUSH
40632: CALL 11504 0 3
40636: PUSH
40637: LD_EXP 63
40641: PUSH
40642: LD_VAR 0 1
40646: ARRAY
40647: PUSH
40648: LD_INT 2
40650: ARRAY
40651: LESS
40652: IFFALSE 40668
// begin SetClass ( j , class_mortar ) ;
40654: LD_VAR 0 5
40658: PPUSH
40659: LD_INT 8
40661: PPUSH
40662: CALL_OW 336
// continue ;
40666: GO 40246
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40668: LD_EXP 63
40672: PUSH
40673: LD_VAR 0 1
40677: ARRAY
40678: PUSH
40679: LD_INT 3
40681: ARRAY
40682: PUSH
40683: LD_INT 44
40685: PPUSH
40686: LD_VAR 0 1
40690: PPUSH
40691: CALL_OW 321
40695: PUSH
40696: LD_INT 2
40698: EQUAL
40699: AND
40700: IFFALSE 40748
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40702: LD_VAR 0 1
40706: PPUSH
40707: LD_INT 9
40709: PPUSH
40710: EMPTY
40711: PPUSH
40712: CALL 11504 0 3
40716: PUSH
40717: LD_EXP 63
40721: PUSH
40722: LD_VAR 0 1
40726: ARRAY
40727: PUSH
40728: LD_INT 3
40730: ARRAY
40731: LESS
40732: IFFALSE 40748
// begin SetClass ( j , class_bazooker ) ;
40734: LD_VAR 0 5
40738: PPUSH
40739: LD_INT 9
40741: PPUSH
40742: CALL_OW 336
// continue ;
40746: GO 40246
// end ; end ; end ;
40748: GO 40246
40750: POP
40751: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40752: LD_INT 22
40754: PUSH
40755: LD_VAR 0 1
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 58
40766: PUSH
40767: EMPTY
40768: LIST
40769: PUSH
40770: LD_INT 30
40772: PUSH
40773: LD_INT 32
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: PPUSH
40785: CALL_OW 69
40789: IFFALSE 40939
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40791: LD_ADDR_VAR 0 12
40795: PUSH
40796: LD_INT 22
40798: PUSH
40799: LD_VAR 0 1
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 58
40810: PUSH
40811: EMPTY
40812: LIST
40813: PUSH
40814: LD_INT 30
40816: PUSH
40817: LD_INT 32
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: LIST
40828: PPUSH
40829: CALL_OW 69
40833: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40834: LD_ADDR_VAR 0 8
40838: PUSH
40839: LD_VAR 0 13
40843: PUSH
40844: LD_EXP 69
40848: PUSH
40849: LD_VAR 0 1
40853: ARRAY
40854: DIFF
40855: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40856: LD_VAR 0 12
40860: PUSH
40861: LD_INT 1
40863: ARRAY
40864: PPUSH
40865: CALL_OW 461
40869: PUSH
40870: LD_INT 2
40872: EQUAL
40873: PUSH
40874: LD_VAR 0 12
40878: PUSH
40879: LD_INT 1
40881: ARRAY
40882: PUSH
40883: LD_EXP 69
40887: PUSH
40888: LD_VAR 0 1
40892: ARRAY
40893: IN
40894: NOT
40895: AND
40896: PUSH
40897: LD_VAR 0 8
40901: AND
40902: IFFALSE 40939
// begin ComExitBuilding ( k [ 1 ] ) ;
40904: LD_VAR 0 8
40908: PUSH
40909: LD_INT 1
40911: ARRAY
40912: PPUSH
40913: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40917: LD_VAR 0 8
40921: PUSH
40922: LD_INT 1
40924: ARRAY
40925: PPUSH
40926: LD_VAR 0 12
40930: PUSH
40931: LD_INT 1
40933: ARRAY
40934: PPUSH
40935: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40939: LD_EXP 36
40943: PUSH
40944: LD_VAR 0 1
40948: ARRAY
40949: IFFALSE 41097
// begin if MCF_Class ( side , 4 , [ ] ) then
40951: LD_VAR 0 1
40955: PPUSH
40956: LD_INT 4
40958: PPUSH
40959: EMPTY
40960: PPUSH
40961: CALL 11504 0 3
40965: IFFALSE 41095
// for j in MCF_Class ( side , 4 , [ ] ) do
40967: LD_ADDR_VAR 0 5
40971: PUSH
40972: LD_VAR 0 1
40976: PPUSH
40977: LD_INT 4
40979: PPUSH
40980: EMPTY
40981: PPUSH
40982: CALL 11504 0 3
40986: PUSH
40987: FOR_IN
40988: IFFALSE 41093
// begin if not GetTag ( j ) = 4 then
40990: LD_VAR 0 5
40994: PPUSH
40995: CALL_OW 110
40999: PUSH
41000: LD_INT 4
41002: EQUAL
41003: NOT
41004: IFFALSE 41040
// begin SetTag ( j , 4 ) ;
41006: LD_VAR 0 5
41010: PPUSH
41011: LD_INT 4
41013: PPUSH
41014: CALL_OW 109
// if IsInUnit ( j ) then
41018: LD_VAR 0 5
41022: PPUSH
41023: CALL_OW 310
41027: IFFALSE 41038
// ComExitBuilding ( j ) ;
41029: LD_VAR 0 5
41033: PPUSH
41034: CALL_OW 122
// end else
41038: GO 41091
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
41040: LD_VAR 0 5
41044: PPUSH
41045: LD_EXP 36
41049: PUSH
41050: LD_VAR 0 1
41054: ARRAY
41055: PUSH
41056: LD_INT 1
41058: ARRAY
41059: PPUSH
41060: CALL 32344 0 2
41064: NOT
41065: IFFALSE 41091
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
41067: LD_VAR 0 5
41071: PPUSH
41072: LD_EXP 36
41076: PUSH
41077: LD_VAR 0 1
41081: ARRAY
41082: PUSH
41083: LD_INT 1
41085: ARRAY
41086: PPUSH
41087: CALL 18991 0 2
// end ;
41091: GO 40987
41093: POP
41094: POP
// end else
41095: GO 41329
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
41097: LD_VAR 0 1
41101: PPUSH
41102: LD_INT 4
41104: PPUSH
41105: EMPTY
41106: PPUSH
41107: CALL 11504 0 3
41111: PUSH
41112: LD_VAR 0 1
41116: PPUSH
41117: LD_INT 4
41119: PPUSH
41120: EMPTY
41121: PPUSH
41122: CALL 12124 0 3
41126: AND
41127: IFFALSE 41329
// for j in MCF_Class ( side , 4 , [ ] ) do
41129: LD_ADDR_VAR 0 5
41133: PUSH
41134: LD_VAR 0 1
41138: PPUSH
41139: LD_INT 4
41141: PPUSH
41142: EMPTY
41143: PPUSH
41144: CALL 11504 0 3
41148: PUSH
41149: FOR_IN
41150: IFFALSE 41327
// begin if GetTag ( j ) = 4 then
41152: LD_VAR 0 5
41156: PPUSH
41157: CALL_OW 110
41161: PUSH
41162: LD_INT 4
41164: EQUAL
41165: IFFALSE 41325
// begin SetTag ( j , 0 ) ;
41167: LD_VAR 0 5
41171: PPUSH
41172: LD_INT 0
41174: PPUSH
41175: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41179: LD_VAR 0 1
41183: PPUSH
41184: CALL 11460 0 1
41188: PUSH
41189: LD_VAR 0 1
41193: PPUSH
41194: CALL 17804 0 1
41198: NOT
41199: AND
41200: IFFALSE 41225
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41202: LD_VAR 0 5
41206: PPUSH
41207: LD_VAR 0 1
41211: PPUSH
41212: CALL 11460 0 1
41216: PUSH
41217: LD_INT 1
41219: ARRAY
41220: PPUSH
41221: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41225: LD_VAR 0 1
41229: PPUSH
41230: CALL 11460 0 1
41234: NOT
41235: PUSH
41236: LD_VAR 0 1
41240: PPUSH
41241: LD_INT 30
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PPUSH
41251: CALL 11421 0 2
41255: AND
41256: IFFALSE 41325
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41258: LD_VAR 0 5
41262: PPUSH
41263: LD_VAR 0 1
41267: PPUSH
41268: LD_INT 30
41270: PUSH
41271: LD_INT 1
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PPUSH
41278: CALL 11421 0 2
41282: PUSH
41283: LD_INT 1
41285: ARRAY
41286: PPUSH
41287: CALL_OW 250
41291: PPUSH
41292: LD_VAR 0 1
41296: PPUSH
41297: LD_INT 30
41299: PUSH
41300: LD_INT 1
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL 11421 0 2
41311: PUSH
41312: LD_INT 1
41314: ARRAY
41315: PPUSH
41316: CALL_OW 251
41320: PPUSH
41321: CALL_OW 111
// end ; end ;
41325: GO 41149
41327: POP
41328: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41329: LD_VAR 0 1
41333: PPUSH
41334: LD_INT 3
41336: PPUSH
41337: EMPTY
41338: PPUSH
41339: CALL 11504 0 3
41343: PUSH
41344: LD_EXP 59
41348: PUSH
41349: LD_VAR 0 1
41353: ARRAY
41354: AND
41355: PUSH
41356: LD_VAR 0 1
41360: PPUSH
41361: LD_INT 6
41363: PPUSH
41364: EMPTY
41365: PPUSH
41366: CALL 12124 0 3
41370: AND
41371: IFFALSE 41902
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41373: LD_ADDR_VAR 0 6
41377: PUSH
41378: LD_EXP 59
41382: PUSH
41383: LD_VAR 0 1
41387: ARRAY
41388: PPUSH
41389: LD_INT 0
41391: PPUSH
41392: CALL_OW 517
41396: PUSH
41397: LD_INT 1
41399: ARRAY
41400: PUSH
41401: LD_INT 1
41403: ARRAY
41404: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41405: LD_ADDR_VAR 0 7
41409: PUSH
41410: LD_EXP 59
41414: PUSH
41415: LD_VAR 0 1
41419: ARRAY
41420: PPUSH
41421: LD_INT 0
41423: PPUSH
41424: CALL_OW 517
41428: PUSH
41429: LD_INT 2
41431: ARRAY
41432: PUSH
41433: LD_INT 1
41435: ARRAY
41436: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41437: LD_VAR 0 1
41441: PPUSH
41442: LD_INT 6
41444: PPUSH
41445: EMPTY
41446: PPUSH
41447: CALL 12124 0 3
41451: IFFALSE 41900
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41453: LD_ADDR_VAR 0 8
41457: PUSH
41458: LD_VAR 0 1
41462: PPUSH
41463: LD_INT 6
41465: PPUSH
41466: EMPTY
41467: PPUSH
41468: CALL 12124 0 3
41472: PUSH
41473: FOR_IN
41474: IFFALSE 41505
// if GetLives ( k ) = 1000 then
41476: LD_VAR 0 8
41480: PPUSH
41481: CALL_OW 256
41485: PUSH
41486: LD_INT 1000
41488: EQUAL
41489: IFFALSE 41503
// SetTag ( k , 0 ) ;
41491: LD_VAR 0 8
41495: PPUSH
41496: LD_INT 0
41498: PPUSH
41499: CALL_OW 109
41503: GO 41473
41505: POP
41506: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41507: LD_VAR 0 1
41511: PPUSH
41512: LD_INT 0
41514: PPUSH
41515: LD_INT 25
41517: PUSH
41518: LD_INT 3
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PPUSH
41525: CALL 12124 0 3
41529: IFFALSE 41593
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41531: LD_ADDR_VAR 0 8
41535: PUSH
41536: LD_VAR 0 4
41540: PPUSH
41541: LD_INT 0
41543: PPUSH
41544: LD_INT 25
41546: PUSH
41547: LD_INT 3
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PPUSH
41554: CALL 12124 0 3
41558: PUSH
41559: FOR_IN
41560: IFFALSE 41591
// if GetTag ( k ) = 0 then
41562: LD_VAR 0 8
41566: PPUSH
41567: CALL_OW 110
41571: PUSH
41572: LD_INT 0
41574: EQUAL
41575: IFFALSE 41589
// begin SetTag ( k , 8 ) ;
41577: LD_VAR 0 8
41581: PPUSH
41582: LD_INT 8
41584: PPUSH
41585: CALL_OW 109
// end ;
41589: GO 41559
41591: POP
41592: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41593: LD_VAR 0 1
41597: PPUSH
41598: LD_INT 6
41600: PPUSH
41601: LD_INT 92
41603: PUSH
41604: LD_VAR 0 6
41608: PUSH
41609: LD_VAR 0 7
41613: PUSH
41614: LD_INT 10
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: PPUSH
41623: CALL 12124 0 3
41627: IFFALSE 41751
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41629: LD_ADDR_VAR 0 5
41633: PUSH
41634: LD_VAR 0 4
41638: PPUSH
41639: LD_INT 6
41641: PPUSH
41642: LD_INT 92
41644: PUSH
41645: LD_VAR 0 6
41649: PUSH
41650: LD_VAR 0 7
41654: PUSH
41655: LD_INT 10
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: LIST
41662: LIST
41663: PPUSH
41664: CALL 12124 0 3
41668: PUSH
41669: FOR_IN
41670: IFFALSE 41749
// begin if not HasTask ( j ) and GetDriver ( j ) then
41672: LD_VAR 0 5
41676: PPUSH
41677: CALL_OW 314
41681: NOT
41682: PUSH
41683: LD_VAR 0 5
41687: PPUSH
41688: CALL 31653 0 1
41692: AND
41693: IFFALSE 41747
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41695: LD_VAR 0 5
41699: PPUSH
41700: CALL 31653 0 1
41704: PPUSH
41705: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41709: LD_VAR 0 5
41713: PPUSH
41714: CALL 31653 0 1
41718: PPUSH
41719: LD_VAR 0 5
41723: PPUSH
41724: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41728: LD_VAR 0 5
41732: PPUSH
41733: CALL 31653 0 1
41737: PPUSH
41738: LD_VAR 0 5
41742: PPUSH
41743: CALL_OW 180
// end ; end ;
41747: GO 41669
41749: POP
41750: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41751: LD_VAR 0 1
41755: PPUSH
41756: LD_INT 6
41758: PPUSH
41759: LD_INT 92
41761: PUSH
41762: LD_VAR 0 6
41766: PUSH
41767: LD_VAR 0 7
41771: PUSH
41772: LD_INT 10
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: PPUSH
41781: CALL 12124 0 3
41785: PUSH
41786: LD_VAR 0 1
41790: PPUSH
41791: LD_INT 8
41793: PPUSH
41794: EMPTY
41795: PPUSH
41796: CALL 12124 0 3
41800: AND
41801: IFFALSE 41900
// for j in MCF_Tag ( side , 8 , [ ] ) do
41803: LD_ADDR_VAR 0 5
41807: PUSH
41808: LD_VAR 0 1
41812: PPUSH
41813: LD_INT 8
41815: PPUSH
41816: EMPTY
41817: PPUSH
41818: CALL 12124 0 3
41822: PUSH
41823: FOR_IN
41824: IFFALSE 41898
// begin if IsInUnit ( j ) then
41826: LD_VAR 0 5
41830: PPUSH
41831: CALL_OW 310
41835: IFFALSE 41848
// ComExitBuilding ( j ) else
41837: LD_VAR 0 5
41841: PPUSH
41842: CALL_OW 122
41846: GO 41896
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41848: LD_VAR 0 5
41852: PPUSH
41853: LD_VAR 0 1
41857: PPUSH
41858: LD_INT 6
41860: PPUSH
41861: LD_INT 92
41863: PUSH
41864: LD_VAR 0 6
41868: PUSH
41869: LD_VAR 0 7
41873: PUSH
41874: LD_INT 10
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: LIST
41881: LIST
41882: PPUSH
41883: CALL 12124 0 3
41887: PUSH
41888: LD_INT 1
41890: ARRAY
41891: PPUSH
41892: CALL_OW 129
// end ;
41896: GO 41823
41898: POP
41899: POP
// end ; end else
41900: GO 41957
// if MCF_Tag ( side , 8 , [ ] ) then
41902: LD_VAR 0 1
41906: PPUSH
41907: LD_INT 8
41909: PPUSH
41910: EMPTY
41911: PPUSH
41912: CALL 12124 0 3
41916: IFFALSE 41957
// for k in MCF_Tag ( side , 8 , [ ] ) do
41918: LD_ADDR_VAR 0 8
41922: PUSH
41923: LD_VAR 0 1
41927: PPUSH
41928: LD_INT 8
41930: PPUSH
41931: EMPTY
41932: PPUSH
41933: CALL 12124 0 3
41937: PUSH
41938: FOR_IN
41939: IFFALSE 41955
// SetTag ( k , 0 ) ;
41941: LD_VAR 0 8
41945: PPUSH
41946: LD_INT 0
41948: PPUSH
41949: CALL_OW 109
41953: GO 41938
41955: POP
41956: POP
// end ; end_of_file
41957: LD_VAR 0 3
41961: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41962: LD_INT 0
41964: PPUSH
// MREG_Game := [ ] ;
41965: LD_ADDR_EXP 34
41969: PUSH
41970: EMPTY
41971: ST_TO_ADDR
// MREG_Crates := [ ] ;
41972: LD_ADDR_EXP 35
41976: PUSH
41977: EMPTY
41978: ST_TO_ADDR
// MREG_Heal := [ ] ;
41979: LD_ADDR_EXP 36
41983: PUSH
41984: EMPTY
41985: ST_TO_ADDR
// MREG_Tame := [ ] ;
41986: LD_ADDR_EXP 38
41990: PUSH
41991: EMPTY
41992: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41993: LD_ADDR_EXP 39
41997: PUSH
41998: EMPTY
41999: ST_TO_ADDR
// MREG_SidesList := [ ] ;
42000: LD_ADDR_EXP 40
42004: PUSH
42005: EMPTY
42006: ST_TO_ADDR
// MREG_LabList := [ ] ;
42007: LD_ADDR_EXP 41
42011: PUSH
42012: EMPTY
42013: ST_TO_ADDR
// MREG_Cargo := [ ] ;
42014: LD_ADDR_EXP 42
42018: PUSH
42019: EMPTY
42020: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
42021: LD_ADDR_EXP 43
42025: PUSH
42026: EMPTY
42027: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
42028: LD_ADDR_EXP 44
42032: PUSH
42033: EMPTY
42034: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
42035: LD_ADDR_EXP 45
42039: PUSH
42040: EMPTY
42041: ST_TO_ADDR
// MREG_Status := [ ] ;
42042: LD_ADDR_EXP 46
42046: PUSH
42047: EMPTY
42048: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
42049: LD_ADDR_EXP 47
42053: PUSH
42054: EMPTY
42055: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
42056: LD_ADDR_EXP 48
42060: PUSH
42061: EMPTY
42062: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
42063: LD_ADDR_EXP 49
42067: PUSH
42068: EMPTY
42069: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
42070: LD_ADDR_EXP 50
42074: PUSH
42075: EMPTY
42076: ST_TO_ADDR
// MREG_ToRes := [ ] ;
42077: LD_ADDR_EXP 51
42081: PUSH
42082: EMPTY
42083: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
42084: LD_ADDR_EXP 52
42088: PUSH
42089: EMPTY
42090: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
42091: LD_ADDR_EXP 53
42095: PUSH
42096: EMPTY
42097: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42098: LD_ADDR_EXP 54
42102: PUSH
42103: EMPTY
42104: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42105: LD_ADDR_EXP 55
42109: PUSH
42110: EMPTY
42111: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42112: LD_ADDR_EXP 56
42116: PUSH
42117: EMPTY
42118: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42119: LD_ADDR_EXP 57
42123: PUSH
42124: EMPTY
42125: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42126: LD_ADDR_EXP 58
42130: PUSH
42131: EMPTY
42132: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42133: LD_ADDR_EXP 62
42137: PUSH
42138: EMPTY
42139: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42140: LD_ADDR_EXP 63
42144: PUSH
42145: EMPTY
42146: ST_TO_ADDR
// MREG_Parking := [ ] ;
42147: LD_ADDR_EXP 59
42151: PUSH
42152: EMPTY
42153: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42154: LD_ADDR_EXP 60
42158: PUSH
42159: EMPTY
42160: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42161: LD_ADDR_EXP 64
42165: PUSH
42166: EMPTY
42167: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42168: LD_ADDR_EXP 65
42172: PUSH
42173: EMPTY
42174: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42175: LD_ADDR_EXP 66
42179: PUSH
42180: EMPTY
42181: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42182: LD_ADDR_EXP 68
42186: PUSH
42187: EMPTY
42188: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42189: LD_ADDR_EXP 69
42193: PUSH
42194: EMPTY
42195: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42196: LD_ADDR_EXP 70
42200: PUSH
42201: EMPTY
42202: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42203: LD_ADDR_EXP 72
42207: PUSH
42208: EMPTY
42209: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42210: LD_ADDR_EXP 71
42214: PUSH
42215: EMPTY
42216: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42217: LD_ADDR_EXP 73
42221: PUSH
42222: LD_INT 300
42224: PUSH
42225: LD_INT 100
42227: PUSH
42228: LD_INT 25
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: ST_TO_ADDR
// end ;
42236: LD_VAR 0 1
42240: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42241: LD_INT 0
42243: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42244: LD_VAR 0 2
42248: PUSH
42249: LD_VAR 0 3
42253: PUSH
42254: LD_VAR 0 4
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: LIST
42263: PUSH
42264: LD_VAR 0 1
42268: IN
42269: IFFALSE 42283
// result := mreg_list else
42271: LD_ADDR_VAR 0 5
42275: PUSH
42276: LD_VAR 0 1
42280: ST_TO_ADDR
42281: GO 42317
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42283: LD_ADDR_VAR 0 1
42287: PUSH
42288: LD_VAR 0 1
42292: PUSH
42293: LD_VAR 0 2
42297: PUSH
42298: LD_VAR 0 3
42302: PUSH
42303: LD_VAR 0 4
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: LIST
42312: PUSH
42313: EMPTY
42314: LIST
42315: ADD
42316: ST_TO_ADDR
// result := mreg_list ;
42317: LD_ADDR_VAR 0 5
42321: PUSH
42322: LD_VAR 0 1
42326: ST_TO_ADDR
// end ;
42327: LD_VAR 0 5
42331: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42332: LD_INT 0
42334: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42335: LD_VAR 0 2
42339: PUSH
42340: LD_VAR 0 3
42344: PUSH
42345: LD_VAR 0 4
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: LIST
42354: PUSH
42355: LD_VAR 0 1
42359: IN
42360: IFFALSE 42398
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42362: LD_ADDR_VAR 0 5
42366: PUSH
42367: LD_VAR 0 1
42371: PUSH
42372: LD_VAR 0 2
42376: PUSH
42377: LD_VAR 0 3
42381: PUSH
42382: LD_VAR 0 4
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: LIST
42391: PUSH
42392: EMPTY
42393: LIST
42394: DIFF
42395: ST_TO_ADDR
42396: GO 42408
// result := mreg_list ;
42398: LD_ADDR_VAR 0 5
42402: PUSH
42403: LD_VAR 0 1
42407: ST_TO_ADDR
// end ;
42408: LD_VAR 0 5
42412: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42413: LD_INT 0
42415: PPUSH
42416: PPUSH
42417: PPUSH
// for j = 1 to 8 do
42418: LD_ADDR_VAR 0 3
42422: PUSH
42423: DOUBLE
42424: LD_INT 1
42426: DEC
42427: ST_TO_ADDR
42428: LD_INT 8
42430: PUSH
42431: FOR_TO
42432: IFFALSE 43273
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42434: LD_VAR 0 3
42438: PPUSH
42439: LD_INT 51
42441: PUSH
42442: EMPTY
42443: LIST
42444: PPUSH
42445: CALL 11421 0 2
42449: PUSH
42450: LD_OWVAR 2
42454: PUSH
42455: LD_VAR 0 3
42459: EQUAL
42460: NOT
42461: AND
42462: IFFALSE 42480
// MREG_SidesList := MREG_SidesList ^ 1 else
42464: LD_ADDR_EXP 40
42468: PUSH
42469: LD_EXP 40
42473: PUSH
42474: LD_INT 1
42476: ADD
42477: ST_TO_ADDR
42478: GO 42494
// MREG_SidesList := MREG_SidesList ^ 0 ;
42480: LD_ADDR_EXP 40
42484: PUSH
42485: LD_EXP 40
42489: PUSH
42490: LD_INT 0
42492: ADD
42493: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42494: LD_VAR 0 3
42498: PPUSH
42499: LD_INT 2
42501: PUSH
42502: LD_INT 34
42504: PUSH
42505: LD_INT 12
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 34
42514: PUSH
42515: LD_INT 32
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 34
42524: PUSH
42525: LD_INT 51
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: PUSH
42538: EMPTY
42539: LIST
42540: PPUSH
42541: CALL 11722 0 2
42545: IFFALSE 42646
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42547: LD_ADDR_VAR 0 2
42551: PUSH
42552: LD_VAR 0 3
42556: PPUSH
42557: LD_INT 2
42559: PUSH
42560: LD_INT 34
42562: PUSH
42563: LD_INT 12
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 34
42572: PUSH
42573: LD_INT 32
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 34
42582: PUSH
42583: LD_INT 51
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: LIST
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PPUSH
42599: CALL 11722 0 2
42603: PUSH
42604: FOR_IN
42605: IFFALSE 42644
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42607: LD_ADDR_EXP 42
42611: PUSH
42612: LD_EXP 42
42616: PPUSH
42617: LD_VAR 0 3
42621: PPUSH
42622: LD_VAR 0 2
42626: PPUSH
42627: LD_VAR 0 2
42631: PPUSH
42632: CALL_OW 264
42636: PPUSH
42637: CALL 42241 0 4
42641: ST_TO_ADDR
42642: GO 42604
42644: POP
42645: POP
// if MCF_Class ( j , 4 , [ ] ) then
42646: LD_VAR 0 3
42650: PPUSH
42651: LD_INT 4
42653: PPUSH
42654: EMPTY
42655: PPUSH
42656: CALL 11504 0 3
42660: IFFALSE 42693
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42662: LD_ADDR_EXP 55
42666: PUSH
42667: LD_EXP 55
42671: PUSH
42672: LD_VAR 0 3
42676: PPUSH
42677: LD_INT 4
42679: PPUSH
42680: EMPTY
42681: PPUSH
42682: CALL 11504 0 3
42686: PUSH
42687: EMPTY
42688: LIST
42689: ADD
42690: ST_TO_ADDR
42691: GO 42710
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42693: LD_ADDR_EXP 55
42697: PUSH
42698: LD_EXP 55
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: ADD
42709: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42710: LD_VAR 0 3
42714: PPUSH
42715: LD_INT 3
42717: PPUSH
42718: EMPTY
42719: PPUSH
42720: CALL 11504 0 3
42724: IFFALSE 42757
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42726: LD_ADDR_EXP 56
42730: PUSH
42731: LD_EXP 56
42735: PUSH
42736: LD_VAR 0 3
42740: PPUSH
42741: LD_INT 3
42743: PPUSH
42744: EMPTY
42745: PPUSH
42746: CALL 11504 0 3
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
42755: GO 42774
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42757: LD_ADDR_EXP 56
42761: PUSH
42762: LD_EXP 56
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: LIST
42772: ADD
42773: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42774: LD_VAR 0 3
42778: PPUSH
42779: LD_INT 1
42781: PPUSH
42782: EMPTY
42783: PPUSH
42784: CALL 11504 0 3
42788: IFFALSE 42821
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42790: LD_ADDR_EXP 57
42794: PUSH
42795: LD_EXP 57
42799: PUSH
42800: LD_VAR 0 3
42804: PPUSH
42805: LD_INT 1
42807: PPUSH
42808: EMPTY
42809: PPUSH
42810: CALL 11504 0 3
42814: PUSH
42815: EMPTY
42816: LIST
42817: ADD
42818: ST_TO_ADDR
42819: GO 42838
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42821: LD_ADDR_EXP 57
42825: PUSH
42826: LD_EXP 57
42830: PUSH
42831: LD_INT 0
42833: PUSH
42834: EMPTY
42835: LIST
42836: ADD
42837: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42838: LD_VAR 0 3
42842: PPUSH
42843: LD_INT 2
42845: PPUSH
42846: EMPTY
42847: PPUSH
42848: CALL 11504 0 3
42852: IFFALSE 42885
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42854: LD_ADDR_EXP 58
42858: PUSH
42859: LD_EXP 58
42863: PUSH
42864: LD_VAR 0 3
42868: PPUSH
42869: LD_INT 2
42871: PPUSH
42872: EMPTY
42873: PPUSH
42874: CALL 11504 0 3
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
42883: GO 42902
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42885: LD_ADDR_EXP 58
42889: PUSH
42890: LD_EXP 58
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: ADD
42901: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42902: LD_ADDR_EXP 48
42906: PUSH
42907: LD_EXP 48
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: EMPTY
42916: LIST
42917: ADD
42918: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42919: LD_ADDR_EXP 36
42923: PUSH
42924: LD_EXP 36
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: ADD
42935: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42936: LD_ADDR_EXP 38
42940: PUSH
42941: LD_EXP 38
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: EMPTY
42950: LIST
42951: ADD
42952: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42953: LD_ADDR_EXP 59
42957: PUSH
42958: LD_EXP 59
42962: PUSH
42963: LD_INT 0
42965: PUSH
42966: EMPTY
42967: LIST
42968: ADD
42969: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42970: LD_ADDR_EXP 60
42974: PUSH
42975: LD_EXP 60
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: EMPTY
42984: LIST
42985: ADD
42986: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42987: LD_ADDR_EXP 52
42991: PUSH
42992: LD_EXP 52
42996: PUSH
42997: LD_INT 0
42999: PUSH
43000: EMPTY
43001: LIST
43002: ADD
43003: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
43004: LD_ADDR_EXP 39
43008: PUSH
43009: LD_EXP 39
43013: PUSH
43014: LD_INT 0
43016: PUSH
43017: LD_INT 0
43019: PUSH
43020: LD_INT 0
43022: PUSH
43023: LD_INT 0
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: PUSH
43032: EMPTY
43033: LIST
43034: ADD
43035: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
43036: LD_ADDR_EXP 61
43040: PUSH
43041: LD_EXP 61
43045: PUSH
43046: LD_INT 0
43048: PUSH
43049: EMPTY
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: EMPTY
43056: LIST
43057: ADD
43058: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
43059: LD_ADDR_EXP 62
43063: PUSH
43064: LD_EXP 62
43068: PUSH
43069: LD_INT 0
43071: PUSH
43072: EMPTY
43073: LIST
43074: PUSH
43075: EMPTY
43076: LIST
43077: ADD
43078: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
43079: LD_ADDR_EXP 43
43083: PUSH
43084: LD_EXP 43
43088: PUSH
43089: LD_INT 0
43091: PUSH
43092: EMPTY
43093: LIST
43094: ADD
43095: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
43096: LD_ADDR_EXP 64
43100: PUSH
43101: LD_EXP 64
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: EMPTY
43110: LIST
43111: ADD
43112: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43113: LD_ADDR_EXP 65
43117: PUSH
43118: LD_EXP 65
43122: PUSH
43123: LD_INT 0
43125: PUSH
43126: EMPTY
43127: LIST
43128: ADD
43129: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43130: LD_ADDR_EXP 66
43134: PUSH
43135: LD_EXP 66
43139: PUSH
43140: LD_INT 0
43142: PUSH
43143: EMPTY
43144: LIST
43145: ADD
43146: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43147: LD_ADDR_EXP 67
43151: PUSH
43152: LD_EXP 67
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: EMPTY
43161: LIST
43162: ADD
43163: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43164: LD_ADDR_EXP 68
43168: PUSH
43169: LD_EXP 68
43173: PUSH
43174: LD_INT 0
43176: PUSH
43177: EMPTY
43178: LIST
43179: ADD
43180: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43181: LD_ADDR_EXP 69
43185: PUSH
43186: LD_EXP 69
43190: PUSH
43191: LD_INT 0
43193: PUSH
43194: EMPTY
43195: LIST
43196: ADD
43197: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43198: LD_ADDR_EXP 70
43202: PUSH
43203: LD_EXP 70
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: EMPTY
43212: LIST
43213: ADD
43214: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43215: LD_ADDR_EXP 72
43219: PUSH
43220: LD_EXP 72
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: ADD
43231: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43232: LD_ADDR_EXP 71
43236: PUSH
43237: LD_EXP 71
43241: PUSH
43242: LD_INT 0
43244: ADD
43245: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43246: LD_ADDR_EXP 63
43250: PUSH
43251: LD_EXP 63
43255: PUSH
43256: LD_INT 0
43258: PUSH
43259: LD_INT 0
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: LIST
43269: ADD
43270: ST_TO_ADDR
// end ;
43271: GO 42431
43273: POP
43274: POP
// end ;
43275: LD_VAR 0 1
43279: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43280: LD_INT 0
43282: PPUSH
43283: PPUSH
43284: PPUSH
// m := false ;
43285: LD_ADDR_VAR 0 5
43289: PUSH
43290: LD_INT 0
43292: ST_TO_ADDR
// for i = 1 to mreg do
43293: LD_ADDR_VAR 0 4
43297: PUSH
43298: DOUBLE
43299: LD_INT 1
43301: DEC
43302: ST_TO_ADDR
43303: LD_VAR 0 2
43307: PUSH
43308: FOR_TO
43309: IFFALSE 43345
// if mreg [ i ] [ 1 ] = side then
43311: LD_VAR 0 2
43315: PUSH
43316: LD_VAR 0 4
43320: ARRAY
43321: PUSH
43322: LD_INT 1
43324: ARRAY
43325: PUSH
43326: LD_VAR 0 1
43330: EQUAL
43331: IFFALSE 43343
// begin m := true ;
43333: LD_ADDR_VAR 0 5
43337: PUSH
43338: LD_INT 1
43340: ST_TO_ADDR
// break ;
43341: GO 43345
// end ;
43343: GO 43308
43345: POP
43346: POP
// result := m ;
43347: LD_ADDR_VAR 0 3
43351: PUSH
43352: LD_VAR 0 5
43356: ST_TO_ADDR
// end ;
43357: LD_VAR 0 3
43361: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43362: LD_INT 0
43364: PPUSH
43365: PPUSH
43366: PPUSH
// m := 0 ;
43367: LD_ADDR_VAR 0 5
43371: PUSH
43372: LD_INT 0
43374: ST_TO_ADDR
// for i = 1 to mreg do
43375: LD_ADDR_VAR 0 4
43379: PUSH
43380: DOUBLE
43381: LD_INT 1
43383: DEC
43384: ST_TO_ADDR
43385: LD_VAR 0 2
43389: PUSH
43390: FOR_TO
43391: IFFALSE 43431
// if mreg [ i ] [ 1 ] = side then
43393: LD_VAR 0 2
43397: PUSH
43398: LD_VAR 0 4
43402: ARRAY
43403: PUSH
43404: LD_INT 1
43406: ARRAY
43407: PUSH
43408: LD_VAR 0 1
43412: EQUAL
43413: IFFALSE 43429
// begin m := m + 1 ;
43415: LD_ADDR_VAR 0 5
43419: PUSH
43420: LD_VAR 0 5
43424: PUSH
43425: LD_INT 1
43427: PLUS
43428: ST_TO_ADDR
// end ;
43429: GO 43390
43431: POP
43432: POP
// result := m ;
43433: LD_ADDR_VAR 0 3
43437: PUSH
43438: LD_VAR 0 5
43442: ST_TO_ADDR
// end ;
43443: LD_VAR 0 3
43447: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43448: LD_INT 0
43450: PPUSH
43451: PPUSH
// result := 0 ;
43452: LD_ADDR_VAR 0 3
43456: PUSH
43457: LD_INT 0
43459: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43460: LD_ADDR_VAR 0 4
43464: PUSH
43465: DOUBLE
43466: LD_INT 1
43468: DEC
43469: ST_TO_ADDR
43470: LD_EXP 54
43474: PUSH
43475: FOR_TO
43476: IFFALSE 43538
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43478: LD_EXP 54
43482: PUSH
43483: LD_VAR 0 4
43487: ARRAY
43488: PUSH
43489: LD_INT 1
43491: ARRAY
43492: PUSH
43493: LD_VAR 0 1
43497: EQUAL
43498: PUSH
43499: LD_EXP 54
43503: PUSH
43504: LD_VAR 0 4
43508: ARRAY
43509: PUSH
43510: LD_INT 2
43512: ARRAY
43513: PUSH
43514: LD_VAR 0 2
43518: EQUAL
43519: AND
43520: IFFALSE 43536
// begin result := result + 1 ;
43522: LD_ADDR_VAR 0 3
43526: PUSH
43527: LD_VAR 0 3
43531: PUSH
43532: LD_INT 1
43534: PLUS
43535: ST_TO_ADDR
// end ;
43536: GO 43475
43538: POP
43539: POP
// end ; end_of_file
43540: LD_VAR 0 3
43544: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
43545: GO 43547
43547: DISABLE
// begin ru_radar := 98 ;
43548: LD_ADDR_EXP 74
43552: PUSH
43553: LD_INT 98
43555: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43556: LD_ADDR_EXP 75
43560: PUSH
43561: LD_INT 89
43563: ST_TO_ADDR
// us_hack := 99 ;
43564: LD_ADDR_EXP 76
43568: PUSH
43569: LD_INT 99
43571: ST_TO_ADDR
// us_artillery := 97 ;
43572: LD_ADDR_EXP 77
43576: PUSH
43577: LD_INT 97
43579: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43580: LD_ADDR_EXP 78
43584: PUSH
43585: LD_INT 91
43587: ST_TO_ADDR
// end ; end_of_file end_of_file
43588: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
43589: GO 43591
43591: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
43592: LD_STRING initStreamRollete();
43594: PPUSH
43595: CALL_OW 559
// InitStreamMode ;
43599: CALL 43608 0 0
// DefineStreamItems ( ) ;
43603: CALL 44048 0 0
// end ;
43607: END
// function InitStreamMode ; begin
43608: LD_INT 0
43610: PPUSH
// streamModeActive := false ;
43611: LD_ADDR_EXP 79
43615: PUSH
43616: LD_INT 0
43618: ST_TO_ADDR
// normalCounter := 36 ;
43619: LD_ADDR_EXP 80
43623: PUSH
43624: LD_INT 36
43626: ST_TO_ADDR
// hardcoreCounter := 16 ;
43627: LD_ADDR_EXP 81
43631: PUSH
43632: LD_INT 16
43634: ST_TO_ADDR
// sRocket := false ;
43635: LD_ADDR_EXP 84
43639: PUSH
43640: LD_INT 0
43642: ST_TO_ADDR
// sSpeed := false ;
43643: LD_ADDR_EXP 83
43647: PUSH
43648: LD_INT 0
43650: ST_TO_ADDR
// sEngine := false ;
43651: LD_ADDR_EXP 85
43655: PUSH
43656: LD_INT 0
43658: ST_TO_ADDR
// sSpec := false ;
43659: LD_ADDR_EXP 82
43663: PUSH
43664: LD_INT 0
43666: ST_TO_ADDR
// sLevel := false ;
43667: LD_ADDR_EXP 86
43671: PUSH
43672: LD_INT 0
43674: ST_TO_ADDR
// sArmoury := false ;
43675: LD_ADDR_EXP 87
43679: PUSH
43680: LD_INT 0
43682: ST_TO_ADDR
// sRadar := false ;
43683: LD_ADDR_EXP 88
43687: PUSH
43688: LD_INT 0
43690: ST_TO_ADDR
// sBunker := false ;
43691: LD_ADDR_EXP 89
43695: PUSH
43696: LD_INT 0
43698: ST_TO_ADDR
// sHack := false ;
43699: LD_ADDR_EXP 90
43703: PUSH
43704: LD_INT 0
43706: ST_TO_ADDR
// sFire := false ;
43707: LD_ADDR_EXP 91
43711: PUSH
43712: LD_INT 0
43714: ST_TO_ADDR
// sRefresh := false ;
43715: LD_ADDR_EXP 92
43719: PUSH
43720: LD_INT 0
43722: ST_TO_ADDR
// sExp := false ;
43723: LD_ADDR_EXP 93
43727: PUSH
43728: LD_INT 0
43730: ST_TO_ADDR
// sDepot := false ;
43731: LD_ADDR_EXP 94
43735: PUSH
43736: LD_INT 0
43738: ST_TO_ADDR
// sFlag := false ;
43739: LD_ADDR_EXP 95
43743: PUSH
43744: LD_INT 0
43746: ST_TO_ADDR
// sKamikadze := false ;
43747: LD_ADDR_EXP 103
43751: PUSH
43752: LD_INT 0
43754: ST_TO_ADDR
// sTroll := false ;
43755: LD_ADDR_EXP 104
43759: PUSH
43760: LD_INT 0
43762: ST_TO_ADDR
// sSlow := false ;
43763: LD_ADDR_EXP 105
43767: PUSH
43768: LD_INT 0
43770: ST_TO_ADDR
// sLack := false ;
43771: LD_ADDR_EXP 106
43775: PUSH
43776: LD_INT 0
43778: ST_TO_ADDR
// sTank := false ;
43779: LD_ADDR_EXP 108
43783: PUSH
43784: LD_INT 0
43786: ST_TO_ADDR
// sRemote := false ;
43787: LD_ADDR_EXP 109
43791: PUSH
43792: LD_INT 0
43794: ST_TO_ADDR
// sPowell := false ;
43795: LD_ADDR_EXP 110
43799: PUSH
43800: LD_INT 0
43802: ST_TO_ADDR
// sTeleport := false ;
43803: LD_ADDR_EXP 113
43807: PUSH
43808: LD_INT 0
43810: ST_TO_ADDR
// sOilTower := false ;
43811: LD_ADDR_EXP 115
43815: PUSH
43816: LD_INT 0
43818: ST_TO_ADDR
// sShovel := false ;
43819: LD_ADDR_EXP 116
43823: PUSH
43824: LD_INT 0
43826: ST_TO_ADDR
// sSheik := false ;
43827: LD_ADDR_EXP 117
43831: PUSH
43832: LD_INT 0
43834: ST_TO_ADDR
// sEarthquake := false ;
43835: LD_ADDR_EXP 119
43839: PUSH
43840: LD_INT 0
43842: ST_TO_ADDR
// sAI := false ;
43843: LD_ADDR_EXP 120
43847: PUSH
43848: LD_INT 0
43850: ST_TO_ADDR
// sCargo := false ;
43851: LD_ADDR_EXP 123
43855: PUSH
43856: LD_INT 0
43858: ST_TO_ADDR
// sDLaser := false ;
43859: LD_ADDR_EXP 124
43863: PUSH
43864: LD_INT 0
43866: ST_TO_ADDR
// sExchange := false ;
43867: LD_ADDR_EXP 125
43871: PUSH
43872: LD_INT 0
43874: ST_TO_ADDR
// sFac := false ;
43875: LD_ADDR_EXP 126
43879: PUSH
43880: LD_INT 0
43882: ST_TO_ADDR
// sPower := false ;
43883: LD_ADDR_EXP 127
43887: PUSH
43888: LD_INT 0
43890: ST_TO_ADDR
// sRandom := false ;
43891: LD_ADDR_EXP 128
43895: PUSH
43896: LD_INT 0
43898: ST_TO_ADDR
// sShield := false ;
43899: LD_ADDR_EXP 129
43903: PUSH
43904: LD_INT 0
43906: ST_TO_ADDR
// sTime := false ;
43907: LD_ADDR_EXP 130
43911: PUSH
43912: LD_INT 0
43914: ST_TO_ADDR
// sTools := false ;
43915: LD_ADDR_EXP 131
43919: PUSH
43920: LD_INT 0
43922: ST_TO_ADDR
// sSold := false ;
43923: LD_ADDR_EXP 96
43927: PUSH
43928: LD_INT 0
43930: ST_TO_ADDR
// sDiff := false ;
43931: LD_ADDR_EXP 97
43935: PUSH
43936: LD_INT 0
43938: ST_TO_ADDR
// sFog := false ;
43939: LD_ADDR_EXP 100
43943: PUSH
43944: LD_INT 0
43946: ST_TO_ADDR
// sReset := false ;
43947: LD_ADDR_EXP 101
43951: PUSH
43952: LD_INT 0
43954: ST_TO_ADDR
// sSun := false ;
43955: LD_ADDR_EXP 102
43959: PUSH
43960: LD_INT 0
43962: ST_TO_ADDR
// sTiger := false ;
43963: LD_ADDR_EXP 98
43967: PUSH
43968: LD_INT 0
43970: ST_TO_ADDR
// sBomb := false ;
43971: LD_ADDR_EXP 99
43975: PUSH
43976: LD_INT 0
43978: ST_TO_ADDR
// sWound := false ;
43979: LD_ADDR_EXP 107
43983: PUSH
43984: LD_INT 0
43986: ST_TO_ADDR
// sBetray := false ;
43987: LD_ADDR_EXP 111
43991: PUSH
43992: LD_INT 0
43994: ST_TO_ADDR
// sContamin := false ;
43995: LD_ADDR_EXP 112
43999: PUSH
44000: LD_INT 0
44002: ST_TO_ADDR
// sOil := false ;
44003: LD_ADDR_EXP 114
44007: PUSH
44008: LD_INT 0
44010: ST_TO_ADDR
// sStu := false ;
44011: LD_ADDR_EXP 118
44015: PUSH
44016: LD_INT 0
44018: ST_TO_ADDR
// sBazooka := false ;
44019: LD_ADDR_EXP 121
44023: PUSH
44024: LD_INT 0
44026: ST_TO_ADDR
// sMortar := false ;
44027: LD_ADDR_EXP 122
44031: PUSH
44032: LD_INT 0
44034: ST_TO_ADDR
// sRanger := false ;
44035: LD_ADDR_EXP 132
44039: PUSH
44040: LD_INT 0
44042: ST_TO_ADDR
// end ;
44043: LD_VAR 0 1
44047: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44048: LD_INT 0
44050: PPUSH
44051: PPUSH
44052: PPUSH
44053: PPUSH
44054: PPUSH
// result := [ ] ;
44055: LD_ADDR_VAR 0 1
44059: PUSH
44060: EMPTY
44061: ST_TO_ADDR
// if campaign_id = 1 then
44062: LD_OWVAR 69
44066: PUSH
44067: LD_INT 1
44069: EQUAL
44070: IFFALSE 47008
// begin case mission_number of 1 :
44072: LD_OWVAR 70
44076: PUSH
44077: LD_INT 1
44079: DOUBLE
44080: EQUAL
44081: IFTRUE 44085
44083: GO 44149
44085: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44086: LD_ADDR_VAR 0 1
44090: PUSH
44091: LD_INT 2
44093: PUSH
44094: LD_INT 4
44096: PUSH
44097: LD_INT 11
44099: PUSH
44100: LD_INT 12
44102: PUSH
44103: LD_INT 15
44105: PUSH
44106: LD_INT 16
44108: PUSH
44109: LD_INT 22
44111: PUSH
44112: LD_INT 23
44114: PUSH
44115: LD_INT 26
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 101
44131: PUSH
44132: LD_INT 102
44134: PUSH
44135: LD_INT 106
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: LIST
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: ST_TO_ADDR
44147: GO 47006
44149: LD_INT 2
44151: DOUBLE
44152: EQUAL
44153: IFTRUE 44157
44155: GO 44229
44157: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44158: LD_ADDR_VAR 0 1
44162: PUSH
44163: LD_INT 2
44165: PUSH
44166: LD_INT 4
44168: PUSH
44169: LD_INT 11
44171: PUSH
44172: LD_INT 12
44174: PUSH
44175: LD_INT 15
44177: PUSH
44178: LD_INT 16
44180: PUSH
44181: LD_INT 22
44183: PUSH
44184: LD_INT 23
44186: PUSH
44187: LD_INT 26
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 101
44203: PUSH
44204: LD_INT 102
44206: PUSH
44207: LD_INT 105
44209: PUSH
44210: LD_INT 106
44212: PUSH
44213: LD_INT 108
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: LIST
44220: LIST
44221: LIST
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: ST_TO_ADDR
44227: GO 47006
44229: LD_INT 3
44231: DOUBLE
44232: EQUAL
44233: IFTRUE 44237
44235: GO 44313
44237: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
44238: LD_ADDR_VAR 0 1
44242: PUSH
44243: LD_INT 2
44245: PUSH
44246: LD_INT 4
44248: PUSH
44249: LD_INT 5
44251: PUSH
44252: LD_INT 11
44254: PUSH
44255: LD_INT 12
44257: PUSH
44258: LD_INT 15
44260: PUSH
44261: LD_INT 16
44263: PUSH
44264: LD_INT 22
44266: PUSH
44267: LD_INT 26
44269: PUSH
44270: LD_INT 36
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 101
44287: PUSH
44288: LD_INT 102
44290: PUSH
44291: LD_INT 105
44293: PUSH
44294: LD_INT 106
44296: PUSH
44297: LD_INT 108
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: PUSH
44307: EMPTY
44308: LIST
44309: LIST
44310: ST_TO_ADDR
44311: GO 47006
44313: LD_INT 4
44315: DOUBLE
44316: EQUAL
44317: IFTRUE 44321
44319: GO 44405
44321: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
44322: LD_ADDR_VAR 0 1
44326: PUSH
44327: LD_INT 2
44329: PUSH
44330: LD_INT 4
44332: PUSH
44333: LD_INT 5
44335: PUSH
44336: LD_INT 8
44338: PUSH
44339: LD_INT 11
44341: PUSH
44342: LD_INT 12
44344: PUSH
44345: LD_INT 15
44347: PUSH
44348: LD_INT 16
44350: PUSH
44351: LD_INT 22
44353: PUSH
44354: LD_INT 23
44356: PUSH
44357: LD_INT 26
44359: PUSH
44360: LD_INT 36
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 101
44379: PUSH
44380: LD_INT 102
44382: PUSH
44383: LD_INT 105
44385: PUSH
44386: LD_INT 106
44388: PUSH
44389: LD_INT 108
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: ST_TO_ADDR
44403: GO 47006
44405: LD_INT 5
44407: DOUBLE
44408: EQUAL
44409: IFTRUE 44413
44411: GO 44513
44413: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
44414: LD_ADDR_VAR 0 1
44418: PUSH
44419: LD_INT 2
44421: PUSH
44422: LD_INT 4
44424: PUSH
44425: LD_INT 5
44427: PUSH
44428: LD_INT 6
44430: PUSH
44431: LD_INT 8
44433: PUSH
44434: LD_INT 11
44436: PUSH
44437: LD_INT 12
44439: PUSH
44440: LD_INT 15
44442: PUSH
44443: LD_INT 16
44445: PUSH
44446: LD_INT 22
44448: PUSH
44449: LD_INT 23
44451: PUSH
44452: LD_INT 25
44454: PUSH
44455: LD_INT 26
44457: PUSH
44458: LD_INT 36
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: PUSH
44477: LD_INT 101
44479: PUSH
44480: LD_INT 102
44482: PUSH
44483: LD_INT 105
44485: PUSH
44486: LD_INT 106
44488: PUSH
44489: LD_INT 108
44491: PUSH
44492: LD_INT 109
44494: PUSH
44495: LD_INT 112
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: ST_TO_ADDR
44511: GO 47006
44513: LD_INT 6
44515: DOUBLE
44516: EQUAL
44517: IFTRUE 44521
44519: GO 44641
44521: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
44522: LD_ADDR_VAR 0 1
44526: PUSH
44527: LD_INT 2
44529: PUSH
44530: LD_INT 4
44532: PUSH
44533: LD_INT 5
44535: PUSH
44536: LD_INT 6
44538: PUSH
44539: LD_INT 8
44541: PUSH
44542: LD_INT 11
44544: PUSH
44545: LD_INT 12
44547: PUSH
44548: LD_INT 15
44550: PUSH
44551: LD_INT 16
44553: PUSH
44554: LD_INT 20
44556: PUSH
44557: LD_INT 21
44559: PUSH
44560: LD_INT 22
44562: PUSH
44563: LD_INT 23
44565: PUSH
44566: LD_INT 25
44568: PUSH
44569: LD_INT 26
44571: PUSH
44572: LD_INT 30
44574: PUSH
44575: LD_INT 31
44577: PUSH
44578: LD_INT 32
44580: PUSH
44581: LD_INT 36
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: LIST
44588: LIST
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 101
44607: PUSH
44608: LD_INT 102
44610: PUSH
44611: LD_INT 105
44613: PUSH
44614: LD_INT 106
44616: PUSH
44617: LD_INT 108
44619: PUSH
44620: LD_INT 109
44622: PUSH
44623: LD_INT 112
44625: PUSH
44626: EMPTY
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: ST_TO_ADDR
44639: GO 47006
44641: LD_INT 7
44643: DOUBLE
44644: EQUAL
44645: IFTRUE 44649
44647: GO 44749
44649: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
44650: LD_ADDR_VAR 0 1
44654: PUSH
44655: LD_INT 2
44657: PUSH
44658: LD_INT 4
44660: PUSH
44661: LD_INT 5
44663: PUSH
44664: LD_INT 7
44666: PUSH
44667: LD_INT 11
44669: PUSH
44670: LD_INT 12
44672: PUSH
44673: LD_INT 15
44675: PUSH
44676: LD_INT 16
44678: PUSH
44679: LD_INT 20
44681: PUSH
44682: LD_INT 21
44684: PUSH
44685: LD_INT 22
44687: PUSH
44688: LD_INT 23
44690: PUSH
44691: LD_INT 25
44693: PUSH
44694: LD_INT 26
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: PUSH
44713: LD_INT 101
44715: PUSH
44716: LD_INT 102
44718: PUSH
44719: LD_INT 103
44721: PUSH
44722: LD_INT 105
44724: PUSH
44725: LD_INT 106
44727: PUSH
44728: LD_INT 108
44730: PUSH
44731: LD_INT 112
44733: PUSH
44734: EMPTY
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: ST_TO_ADDR
44747: GO 47006
44749: LD_INT 8
44751: DOUBLE
44752: EQUAL
44753: IFTRUE 44757
44755: GO 44885
44757: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
44758: LD_ADDR_VAR 0 1
44762: PUSH
44763: LD_INT 2
44765: PUSH
44766: LD_INT 4
44768: PUSH
44769: LD_INT 5
44771: PUSH
44772: LD_INT 6
44774: PUSH
44775: LD_INT 7
44777: PUSH
44778: LD_INT 8
44780: PUSH
44781: LD_INT 11
44783: PUSH
44784: LD_INT 12
44786: PUSH
44787: LD_INT 15
44789: PUSH
44790: LD_INT 16
44792: PUSH
44793: LD_INT 20
44795: PUSH
44796: LD_INT 21
44798: PUSH
44799: LD_INT 22
44801: PUSH
44802: LD_INT 23
44804: PUSH
44805: LD_INT 25
44807: PUSH
44808: LD_INT 26
44810: PUSH
44811: LD_INT 30
44813: PUSH
44814: LD_INT 31
44816: PUSH
44817: LD_INT 32
44819: PUSH
44820: LD_INT 36
44822: PUSH
44823: EMPTY
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 101
44847: PUSH
44848: LD_INT 102
44850: PUSH
44851: LD_INT 103
44853: PUSH
44854: LD_INT 105
44856: PUSH
44857: LD_INT 106
44859: PUSH
44860: LD_INT 108
44862: PUSH
44863: LD_INT 109
44865: PUSH
44866: LD_INT 112
44868: PUSH
44869: EMPTY
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: LIST
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: ST_TO_ADDR
44883: GO 47006
44885: LD_INT 9
44887: DOUBLE
44888: EQUAL
44889: IFTRUE 44893
44891: GO 45029
44893: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
44894: LD_ADDR_VAR 0 1
44898: PUSH
44899: LD_INT 2
44901: PUSH
44902: LD_INT 4
44904: PUSH
44905: LD_INT 5
44907: PUSH
44908: LD_INT 6
44910: PUSH
44911: LD_INT 7
44913: PUSH
44914: LD_INT 8
44916: PUSH
44917: LD_INT 11
44919: PUSH
44920: LD_INT 12
44922: PUSH
44923: LD_INT 15
44925: PUSH
44926: LD_INT 16
44928: PUSH
44929: LD_INT 20
44931: PUSH
44932: LD_INT 21
44934: PUSH
44935: LD_INT 22
44937: PUSH
44938: LD_INT 23
44940: PUSH
44941: LD_INT 25
44943: PUSH
44944: LD_INT 26
44946: PUSH
44947: LD_INT 28
44949: PUSH
44950: LD_INT 30
44952: PUSH
44953: LD_INT 31
44955: PUSH
44956: LD_INT 32
44958: PUSH
44959: LD_INT 36
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: LIST
44966: LIST
44967: LIST
44968: LIST
44969: LIST
44970: LIST
44971: LIST
44972: LIST
44973: LIST
44974: LIST
44975: LIST
44976: LIST
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: PUSH
44985: LD_INT 101
44987: PUSH
44988: LD_INT 102
44990: PUSH
44991: LD_INT 103
44993: PUSH
44994: LD_INT 105
44996: PUSH
44997: LD_INT 106
44999: PUSH
45000: LD_INT 108
45002: PUSH
45003: LD_INT 109
45005: PUSH
45006: LD_INT 112
45008: PUSH
45009: LD_INT 114
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: ST_TO_ADDR
45027: GO 47006
45029: LD_INT 10
45031: DOUBLE
45032: EQUAL
45033: IFTRUE 45037
45035: GO 45221
45037: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45038: LD_ADDR_VAR 0 1
45042: PUSH
45043: LD_INT 2
45045: PUSH
45046: LD_INT 4
45048: PUSH
45049: LD_INT 5
45051: PUSH
45052: LD_INT 6
45054: PUSH
45055: LD_INT 7
45057: PUSH
45058: LD_INT 8
45060: PUSH
45061: LD_INT 9
45063: PUSH
45064: LD_INT 10
45066: PUSH
45067: LD_INT 11
45069: PUSH
45070: LD_INT 12
45072: PUSH
45073: LD_INT 13
45075: PUSH
45076: LD_INT 14
45078: PUSH
45079: LD_INT 15
45081: PUSH
45082: LD_INT 16
45084: PUSH
45085: LD_INT 17
45087: PUSH
45088: LD_INT 18
45090: PUSH
45091: LD_INT 19
45093: PUSH
45094: LD_INT 20
45096: PUSH
45097: LD_INT 21
45099: PUSH
45100: LD_INT 22
45102: PUSH
45103: LD_INT 23
45105: PUSH
45106: LD_INT 24
45108: PUSH
45109: LD_INT 25
45111: PUSH
45112: LD_INT 26
45114: PUSH
45115: LD_INT 28
45117: PUSH
45118: LD_INT 30
45120: PUSH
45121: LD_INT 31
45123: PUSH
45124: LD_INT 32
45126: PUSH
45127: LD_INT 36
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 101
45163: PUSH
45164: LD_INT 102
45166: PUSH
45167: LD_INT 103
45169: PUSH
45170: LD_INT 104
45172: PUSH
45173: LD_INT 105
45175: PUSH
45176: LD_INT 106
45178: PUSH
45179: LD_INT 107
45181: PUSH
45182: LD_INT 108
45184: PUSH
45185: LD_INT 109
45187: PUSH
45188: LD_INT 110
45190: PUSH
45191: LD_INT 111
45193: PUSH
45194: LD_INT 112
45196: PUSH
45197: LD_INT 114
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: ST_TO_ADDR
45219: GO 47006
45221: LD_INT 11
45223: DOUBLE
45224: EQUAL
45225: IFTRUE 45229
45227: GO 45421
45229: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
45230: LD_ADDR_VAR 0 1
45234: PUSH
45235: LD_INT 2
45237: PUSH
45238: LD_INT 3
45240: PUSH
45241: LD_INT 4
45243: PUSH
45244: LD_INT 5
45246: PUSH
45247: LD_INT 6
45249: PUSH
45250: LD_INT 7
45252: PUSH
45253: LD_INT 8
45255: PUSH
45256: LD_INT 9
45258: PUSH
45259: LD_INT 10
45261: PUSH
45262: LD_INT 11
45264: PUSH
45265: LD_INT 12
45267: PUSH
45268: LD_INT 13
45270: PUSH
45271: LD_INT 14
45273: PUSH
45274: LD_INT 15
45276: PUSH
45277: LD_INT 16
45279: PUSH
45280: LD_INT 17
45282: PUSH
45283: LD_INT 18
45285: PUSH
45286: LD_INT 19
45288: PUSH
45289: LD_INT 20
45291: PUSH
45292: LD_INT 21
45294: PUSH
45295: LD_INT 22
45297: PUSH
45298: LD_INT 23
45300: PUSH
45301: LD_INT 24
45303: PUSH
45304: LD_INT 25
45306: PUSH
45307: LD_INT 26
45309: PUSH
45310: LD_INT 28
45312: PUSH
45313: LD_INT 30
45315: PUSH
45316: LD_INT 31
45318: PUSH
45319: LD_INT 32
45321: PUSH
45322: LD_INT 34
45324: PUSH
45325: LD_INT 36
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 101
45363: PUSH
45364: LD_INT 102
45366: PUSH
45367: LD_INT 103
45369: PUSH
45370: LD_INT 104
45372: PUSH
45373: LD_INT 105
45375: PUSH
45376: LD_INT 106
45378: PUSH
45379: LD_INT 107
45381: PUSH
45382: LD_INT 108
45384: PUSH
45385: LD_INT 109
45387: PUSH
45388: LD_INT 110
45390: PUSH
45391: LD_INT 111
45393: PUSH
45394: LD_INT 112
45396: PUSH
45397: LD_INT 114
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: ST_TO_ADDR
45419: GO 47006
45421: LD_INT 12
45423: DOUBLE
45424: EQUAL
45425: IFTRUE 45429
45427: GO 45637
45429: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
45430: LD_ADDR_VAR 0 1
45434: PUSH
45435: LD_INT 1
45437: PUSH
45438: LD_INT 2
45440: PUSH
45441: LD_INT 3
45443: PUSH
45444: LD_INT 4
45446: PUSH
45447: LD_INT 5
45449: PUSH
45450: LD_INT 6
45452: PUSH
45453: LD_INT 7
45455: PUSH
45456: LD_INT 8
45458: PUSH
45459: LD_INT 9
45461: PUSH
45462: LD_INT 10
45464: PUSH
45465: LD_INT 11
45467: PUSH
45468: LD_INT 12
45470: PUSH
45471: LD_INT 13
45473: PUSH
45474: LD_INT 14
45476: PUSH
45477: LD_INT 15
45479: PUSH
45480: LD_INT 16
45482: PUSH
45483: LD_INT 17
45485: PUSH
45486: LD_INT 18
45488: PUSH
45489: LD_INT 19
45491: PUSH
45492: LD_INT 20
45494: PUSH
45495: LD_INT 21
45497: PUSH
45498: LD_INT 22
45500: PUSH
45501: LD_INT 23
45503: PUSH
45504: LD_INT 24
45506: PUSH
45507: LD_INT 25
45509: PUSH
45510: LD_INT 26
45512: PUSH
45513: LD_INT 27
45515: PUSH
45516: LD_INT 28
45518: PUSH
45519: LD_INT 30
45521: PUSH
45522: LD_INT 31
45524: PUSH
45525: LD_INT 32
45527: PUSH
45528: LD_INT 33
45530: PUSH
45531: LD_INT 34
45533: PUSH
45534: LD_INT 36
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: PUSH
45573: LD_INT 101
45575: PUSH
45576: LD_INT 102
45578: PUSH
45579: LD_INT 103
45581: PUSH
45582: LD_INT 104
45584: PUSH
45585: LD_INT 105
45587: PUSH
45588: LD_INT 106
45590: PUSH
45591: LD_INT 107
45593: PUSH
45594: LD_INT 108
45596: PUSH
45597: LD_INT 109
45599: PUSH
45600: LD_INT 110
45602: PUSH
45603: LD_INT 111
45605: PUSH
45606: LD_INT 112
45608: PUSH
45609: LD_INT 113
45611: PUSH
45612: LD_INT 114
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: ST_TO_ADDR
45635: GO 47006
45637: LD_INT 13
45639: DOUBLE
45640: EQUAL
45641: IFTRUE 45645
45643: GO 45841
45645: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
45646: LD_ADDR_VAR 0 1
45650: PUSH
45651: LD_INT 1
45653: PUSH
45654: LD_INT 2
45656: PUSH
45657: LD_INT 3
45659: PUSH
45660: LD_INT 4
45662: PUSH
45663: LD_INT 5
45665: PUSH
45666: LD_INT 8
45668: PUSH
45669: LD_INT 9
45671: PUSH
45672: LD_INT 10
45674: PUSH
45675: LD_INT 11
45677: PUSH
45678: LD_INT 12
45680: PUSH
45681: LD_INT 14
45683: PUSH
45684: LD_INT 15
45686: PUSH
45687: LD_INT 16
45689: PUSH
45690: LD_INT 17
45692: PUSH
45693: LD_INT 18
45695: PUSH
45696: LD_INT 19
45698: PUSH
45699: LD_INT 20
45701: PUSH
45702: LD_INT 21
45704: PUSH
45705: LD_INT 22
45707: PUSH
45708: LD_INT 23
45710: PUSH
45711: LD_INT 24
45713: PUSH
45714: LD_INT 25
45716: PUSH
45717: LD_INT 26
45719: PUSH
45720: LD_INT 27
45722: PUSH
45723: LD_INT 28
45725: PUSH
45726: LD_INT 30
45728: PUSH
45729: LD_INT 31
45731: PUSH
45732: LD_INT 32
45734: PUSH
45735: LD_INT 33
45737: PUSH
45738: LD_INT 34
45740: PUSH
45741: LD_INT 36
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: LIST
45768: LIST
45769: LIST
45770: LIST
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 101
45779: PUSH
45780: LD_INT 102
45782: PUSH
45783: LD_INT 103
45785: PUSH
45786: LD_INT 104
45788: PUSH
45789: LD_INT 105
45791: PUSH
45792: LD_INT 106
45794: PUSH
45795: LD_INT 107
45797: PUSH
45798: LD_INT 108
45800: PUSH
45801: LD_INT 109
45803: PUSH
45804: LD_INT 110
45806: PUSH
45807: LD_INT 111
45809: PUSH
45810: LD_INT 112
45812: PUSH
45813: LD_INT 113
45815: PUSH
45816: LD_INT 114
45818: PUSH
45819: EMPTY
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: ST_TO_ADDR
45839: GO 47006
45841: LD_INT 14
45843: DOUBLE
45844: EQUAL
45845: IFTRUE 45849
45847: GO 46061
45849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
45850: LD_ADDR_VAR 0 1
45854: PUSH
45855: LD_INT 1
45857: PUSH
45858: LD_INT 2
45860: PUSH
45861: LD_INT 3
45863: PUSH
45864: LD_INT 4
45866: PUSH
45867: LD_INT 5
45869: PUSH
45870: LD_INT 6
45872: PUSH
45873: LD_INT 7
45875: PUSH
45876: LD_INT 8
45878: PUSH
45879: LD_INT 9
45881: PUSH
45882: LD_INT 10
45884: PUSH
45885: LD_INT 11
45887: PUSH
45888: LD_INT 12
45890: PUSH
45891: LD_INT 13
45893: PUSH
45894: LD_INT 14
45896: PUSH
45897: LD_INT 15
45899: PUSH
45900: LD_INT 16
45902: PUSH
45903: LD_INT 17
45905: PUSH
45906: LD_INT 18
45908: PUSH
45909: LD_INT 19
45911: PUSH
45912: LD_INT 20
45914: PUSH
45915: LD_INT 21
45917: PUSH
45918: LD_INT 22
45920: PUSH
45921: LD_INT 23
45923: PUSH
45924: LD_INT 24
45926: PUSH
45927: LD_INT 25
45929: PUSH
45930: LD_INT 26
45932: PUSH
45933: LD_INT 27
45935: PUSH
45936: LD_INT 28
45938: PUSH
45939: LD_INT 29
45941: PUSH
45942: LD_INT 30
45944: PUSH
45945: LD_INT 31
45947: PUSH
45948: LD_INT 32
45950: PUSH
45951: LD_INT 33
45953: PUSH
45954: LD_INT 34
45956: PUSH
45957: LD_INT 36
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: PUSH
45997: LD_INT 101
45999: PUSH
46000: LD_INT 102
46002: PUSH
46003: LD_INT 103
46005: PUSH
46006: LD_INT 104
46008: PUSH
46009: LD_INT 105
46011: PUSH
46012: LD_INT 106
46014: PUSH
46015: LD_INT 107
46017: PUSH
46018: LD_INT 108
46020: PUSH
46021: LD_INT 109
46023: PUSH
46024: LD_INT 110
46026: PUSH
46027: LD_INT 111
46029: PUSH
46030: LD_INT 112
46032: PUSH
46033: LD_INT 113
46035: PUSH
46036: LD_INT 114
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: ST_TO_ADDR
46059: GO 47006
46061: LD_INT 15
46063: DOUBLE
46064: EQUAL
46065: IFTRUE 46069
46067: GO 46281
46069: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46070: LD_ADDR_VAR 0 1
46074: PUSH
46075: LD_INT 1
46077: PUSH
46078: LD_INT 2
46080: PUSH
46081: LD_INT 3
46083: PUSH
46084: LD_INT 4
46086: PUSH
46087: LD_INT 5
46089: PUSH
46090: LD_INT 6
46092: PUSH
46093: LD_INT 7
46095: PUSH
46096: LD_INT 8
46098: PUSH
46099: LD_INT 9
46101: PUSH
46102: LD_INT 10
46104: PUSH
46105: LD_INT 11
46107: PUSH
46108: LD_INT 12
46110: PUSH
46111: LD_INT 13
46113: PUSH
46114: LD_INT 14
46116: PUSH
46117: LD_INT 15
46119: PUSH
46120: LD_INT 16
46122: PUSH
46123: LD_INT 17
46125: PUSH
46126: LD_INT 18
46128: PUSH
46129: LD_INT 19
46131: PUSH
46132: LD_INT 20
46134: PUSH
46135: LD_INT 21
46137: PUSH
46138: LD_INT 22
46140: PUSH
46141: LD_INT 23
46143: PUSH
46144: LD_INT 24
46146: PUSH
46147: LD_INT 25
46149: PUSH
46150: LD_INT 26
46152: PUSH
46153: LD_INT 27
46155: PUSH
46156: LD_INT 28
46158: PUSH
46159: LD_INT 29
46161: PUSH
46162: LD_INT 30
46164: PUSH
46165: LD_INT 31
46167: PUSH
46168: LD_INT 32
46170: PUSH
46171: LD_INT 33
46173: PUSH
46174: LD_INT 34
46176: PUSH
46177: LD_INT 36
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: PUSH
46217: LD_INT 101
46219: PUSH
46220: LD_INT 102
46222: PUSH
46223: LD_INT 103
46225: PUSH
46226: LD_INT 104
46228: PUSH
46229: LD_INT 105
46231: PUSH
46232: LD_INT 106
46234: PUSH
46235: LD_INT 107
46237: PUSH
46238: LD_INT 108
46240: PUSH
46241: LD_INT 109
46243: PUSH
46244: LD_INT 110
46246: PUSH
46247: LD_INT 111
46249: PUSH
46250: LD_INT 112
46252: PUSH
46253: LD_INT 113
46255: PUSH
46256: LD_INT 114
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: LIST
46263: LIST
46264: LIST
46265: LIST
46266: LIST
46267: LIST
46268: LIST
46269: LIST
46270: LIST
46271: LIST
46272: LIST
46273: LIST
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: ST_TO_ADDR
46279: GO 47006
46281: LD_INT 16
46283: DOUBLE
46284: EQUAL
46285: IFTRUE 46289
46287: GO 46413
46289: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
46290: LD_ADDR_VAR 0 1
46294: PUSH
46295: LD_INT 2
46297: PUSH
46298: LD_INT 4
46300: PUSH
46301: LD_INT 5
46303: PUSH
46304: LD_INT 7
46306: PUSH
46307: LD_INT 11
46309: PUSH
46310: LD_INT 12
46312: PUSH
46313: LD_INT 15
46315: PUSH
46316: LD_INT 16
46318: PUSH
46319: LD_INT 20
46321: PUSH
46322: LD_INT 21
46324: PUSH
46325: LD_INT 22
46327: PUSH
46328: LD_INT 23
46330: PUSH
46331: LD_INT 25
46333: PUSH
46334: LD_INT 26
46336: PUSH
46337: LD_INT 30
46339: PUSH
46340: LD_INT 31
46342: PUSH
46343: LD_INT 32
46345: PUSH
46346: LD_INT 33
46348: PUSH
46349: LD_INT 34
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 101
46375: PUSH
46376: LD_INT 102
46378: PUSH
46379: LD_INT 103
46381: PUSH
46382: LD_INT 106
46384: PUSH
46385: LD_INT 108
46387: PUSH
46388: LD_INT 112
46390: PUSH
46391: LD_INT 113
46393: PUSH
46394: LD_INT 114
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: ST_TO_ADDR
46411: GO 47006
46413: LD_INT 17
46415: DOUBLE
46416: EQUAL
46417: IFTRUE 46421
46419: GO 46633
46421: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
46422: LD_ADDR_VAR 0 1
46426: PUSH
46427: LD_INT 1
46429: PUSH
46430: LD_INT 2
46432: PUSH
46433: LD_INT 3
46435: PUSH
46436: LD_INT 4
46438: PUSH
46439: LD_INT 5
46441: PUSH
46442: LD_INT 6
46444: PUSH
46445: LD_INT 7
46447: PUSH
46448: LD_INT 8
46450: PUSH
46451: LD_INT 9
46453: PUSH
46454: LD_INT 10
46456: PUSH
46457: LD_INT 11
46459: PUSH
46460: LD_INT 12
46462: PUSH
46463: LD_INT 13
46465: PUSH
46466: LD_INT 14
46468: PUSH
46469: LD_INT 15
46471: PUSH
46472: LD_INT 16
46474: PUSH
46475: LD_INT 17
46477: PUSH
46478: LD_INT 18
46480: PUSH
46481: LD_INT 19
46483: PUSH
46484: LD_INT 20
46486: PUSH
46487: LD_INT 21
46489: PUSH
46490: LD_INT 22
46492: PUSH
46493: LD_INT 23
46495: PUSH
46496: LD_INT 24
46498: PUSH
46499: LD_INT 25
46501: PUSH
46502: LD_INT 26
46504: PUSH
46505: LD_INT 27
46507: PUSH
46508: LD_INT 28
46510: PUSH
46511: LD_INT 29
46513: PUSH
46514: LD_INT 30
46516: PUSH
46517: LD_INT 31
46519: PUSH
46520: LD_INT 32
46522: PUSH
46523: LD_INT 33
46525: PUSH
46526: LD_INT 34
46528: PUSH
46529: LD_INT 36
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 101
46571: PUSH
46572: LD_INT 102
46574: PUSH
46575: LD_INT 103
46577: PUSH
46578: LD_INT 104
46580: PUSH
46581: LD_INT 105
46583: PUSH
46584: LD_INT 106
46586: PUSH
46587: LD_INT 107
46589: PUSH
46590: LD_INT 108
46592: PUSH
46593: LD_INT 109
46595: PUSH
46596: LD_INT 110
46598: PUSH
46599: LD_INT 111
46601: PUSH
46602: LD_INT 112
46604: PUSH
46605: LD_INT 113
46607: PUSH
46608: LD_INT 114
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: ST_TO_ADDR
46631: GO 47006
46633: LD_INT 18
46635: DOUBLE
46636: EQUAL
46637: IFTRUE 46641
46639: GO 46777
46641: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
46642: LD_ADDR_VAR 0 1
46646: PUSH
46647: LD_INT 2
46649: PUSH
46650: LD_INT 4
46652: PUSH
46653: LD_INT 5
46655: PUSH
46656: LD_INT 7
46658: PUSH
46659: LD_INT 11
46661: PUSH
46662: LD_INT 12
46664: PUSH
46665: LD_INT 15
46667: PUSH
46668: LD_INT 16
46670: PUSH
46671: LD_INT 20
46673: PUSH
46674: LD_INT 21
46676: PUSH
46677: LD_INT 22
46679: PUSH
46680: LD_INT 23
46682: PUSH
46683: LD_INT 25
46685: PUSH
46686: LD_INT 26
46688: PUSH
46689: LD_INT 30
46691: PUSH
46692: LD_INT 31
46694: PUSH
46695: LD_INT 32
46697: PUSH
46698: LD_INT 33
46700: PUSH
46701: LD_INT 34
46703: PUSH
46704: LD_INT 35
46706: PUSH
46707: LD_INT 36
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 101
46735: PUSH
46736: LD_INT 102
46738: PUSH
46739: LD_INT 103
46741: PUSH
46742: LD_INT 106
46744: PUSH
46745: LD_INT 108
46747: PUSH
46748: LD_INT 112
46750: PUSH
46751: LD_INT 113
46753: PUSH
46754: LD_INT 114
46756: PUSH
46757: LD_INT 115
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: ST_TO_ADDR
46775: GO 47006
46777: LD_INT 19
46779: DOUBLE
46780: EQUAL
46781: IFTRUE 46785
46783: GO 47005
46785: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
46786: LD_ADDR_VAR 0 1
46790: PUSH
46791: LD_INT 1
46793: PUSH
46794: LD_INT 2
46796: PUSH
46797: LD_INT 3
46799: PUSH
46800: LD_INT 4
46802: PUSH
46803: LD_INT 5
46805: PUSH
46806: LD_INT 6
46808: PUSH
46809: LD_INT 7
46811: PUSH
46812: LD_INT 8
46814: PUSH
46815: LD_INT 9
46817: PUSH
46818: LD_INT 10
46820: PUSH
46821: LD_INT 11
46823: PUSH
46824: LD_INT 12
46826: PUSH
46827: LD_INT 13
46829: PUSH
46830: LD_INT 14
46832: PUSH
46833: LD_INT 15
46835: PUSH
46836: LD_INT 16
46838: PUSH
46839: LD_INT 17
46841: PUSH
46842: LD_INT 18
46844: PUSH
46845: LD_INT 19
46847: PUSH
46848: LD_INT 20
46850: PUSH
46851: LD_INT 21
46853: PUSH
46854: LD_INT 22
46856: PUSH
46857: LD_INT 23
46859: PUSH
46860: LD_INT 24
46862: PUSH
46863: LD_INT 25
46865: PUSH
46866: LD_INT 26
46868: PUSH
46869: LD_INT 27
46871: PUSH
46872: LD_INT 28
46874: PUSH
46875: LD_INT 29
46877: PUSH
46878: LD_INT 30
46880: PUSH
46881: LD_INT 31
46883: PUSH
46884: LD_INT 32
46886: PUSH
46887: LD_INT 33
46889: PUSH
46890: LD_INT 34
46892: PUSH
46893: LD_INT 35
46895: PUSH
46896: LD_INT 36
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: PUSH
46937: LD_INT 101
46939: PUSH
46940: LD_INT 102
46942: PUSH
46943: LD_INT 103
46945: PUSH
46946: LD_INT 104
46948: PUSH
46949: LD_INT 105
46951: PUSH
46952: LD_INT 106
46954: PUSH
46955: LD_INT 107
46957: PUSH
46958: LD_INT 108
46960: PUSH
46961: LD_INT 109
46963: PUSH
46964: LD_INT 110
46966: PUSH
46967: LD_INT 111
46969: PUSH
46970: LD_INT 112
46972: PUSH
46973: LD_INT 113
46975: PUSH
46976: LD_INT 114
46978: PUSH
46979: LD_INT 115
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: ST_TO_ADDR
47003: GO 47006
47005: POP
// end else
47006: GO 47043
// if campaign_id = 5 then
47008: LD_OWVAR 69
47012: PUSH
47013: LD_INT 5
47015: EQUAL
47016: IFFALSE 47043
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
47018: LD_ADDR_VAR 0 1
47022: PUSH
47023: LD_INT 1
47025: PUSH
47026: LD_INT 2
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 100
47035: PUSH
47036: EMPTY
47037: LIST
47038: PUSH
47039: EMPTY
47040: LIST
47041: LIST
47042: ST_TO_ADDR
// end ; if result then
47043: LD_VAR 0 1
47047: IFFALSE 47336
// begin normal :=  ;
47049: LD_ADDR_VAR 0 3
47053: PUSH
47054: LD_STRING 
47056: ST_TO_ADDR
// hardcore :=  ;
47057: LD_ADDR_VAR 0 4
47061: PUSH
47062: LD_STRING 
47064: ST_TO_ADDR
// for i = 1 to normalCounter do
47065: LD_ADDR_VAR 0 5
47069: PUSH
47070: DOUBLE
47071: LD_INT 1
47073: DEC
47074: ST_TO_ADDR
47075: LD_EXP 80
47079: PUSH
47080: FOR_TO
47081: IFFALSE 47182
// begin tmp := 0 ;
47083: LD_ADDR_VAR 0 2
47087: PUSH
47088: LD_STRING 0
47090: ST_TO_ADDR
// if result [ 1 ] then
47091: LD_VAR 0 1
47095: PUSH
47096: LD_INT 1
47098: ARRAY
47099: IFFALSE 47164
// if result [ 1 ] [ 1 ] = i then
47101: LD_VAR 0 1
47105: PUSH
47106: LD_INT 1
47108: ARRAY
47109: PUSH
47110: LD_INT 1
47112: ARRAY
47113: PUSH
47114: LD_VAR 0 5
47118: EQUAL
47119: IFFALSE 47164
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
47121: LD_ADDR_VAR 0 1
47125: PUSH
47126: LD_VAR 0 1
47130: PPUSH
47131: LD_INT 1
47133: PPUSH
47134: LD_VAR 0 1
47138: PUSH
47139: LD_INT 1
47141: ARRAY
47142: PPUSH
47143: LD_INT 1
47145: PPUSH
47146: CALL_OW 3
47150: PPUSH
47151: CALL_OW 1
47155: ST_TO_ADDR
// tmp := 1 ;
47156: LD_ADDR_VAR 0 2
47160: PUSH
47161: LD_STRING 1
47163: ST_TO_ADDR
// end ; normal := normal & tmp ;
47164: LD_ADDR_VAR 0 3
47168: PUSH
47169: LD_VAR 0 3
47173: PUSH
47174: LD_VAR 0 2
47178: STR
47179: ST_TO_ADDR
// end ;
47180: GO 47080
47182: POP
47183: POP
// for i = 1 to hardcoreCounter do
47184: LD_ADDR_VAR 0 5
47188: PUSH
47189: DOUBLE
47190: LD_INT 1
47192: DEC
47193: ST_TO_ADDR
47194: LD_EXP 81
47198: PUSH
47199: FOR_TO
47200: IFFALSE 47305
// begin tmp := 0 ;
47202: LD_ADDR_VAR 0 2
47206: PUSH
47207: LD_STRING 0
47209: ST_TO_ADDR
// if result [ 2 ] then
47210: LD_VAR 0 1
47214: PUSH
47215: LD_INT 2
47217: ARRAY
47218: IFFALSE 47287
// if result [ 2 ] [ 1 ] = 100 + i then
47220: LD_VAR 0 1
47224: PUSH
47225: LD_INT 2
47227: ARRAY
47228: PUSH
47229: LD_INT 1
47231: ARRAY
47232: PUSH
47233: LD_INT 100
47235: PUSH
47236: LD_VAR 0 5
47240: PLUS
47241: EQUAL
47242: IFFALSE 47287
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
47244: LD_ADDR_VAR 0 1
47248: PUSH
47249: LD_VAR 0 1
47253: PPUSH
47254: LD_INT 2
47256: PPUSH
47257: LD_VAR 0 1
47261: PUSH
47262: LD_INT 2
47264: ARRAY
47265: PPUSH
47266: LD_INT 1
47268: PPUSH
47269: CALL_OW 3
47273: PPUSH
47274: CALL_OW 1
47278: ST_TO_ADDR
// tmp := 1 ;
47279: LD_ADDR_VAR 0 2
47283: PUSH
47284: LD_STRING 1
47286: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
47287: LD_ADDR_VAR 0 4
47291: PUSH
47292: LD_VAR 0 4
47296: PUSH
47297: LD_VAR 0 2
47301: STR
47302: ST_TO_ADDR
// end ;
47303: GO 47199
47305: POP
47306: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
47307: LD_STRING getStreamItemsFromMission("
47309: PUSH
47310: LD_VAR 0 3
47314: STR
47315: PUSH
47316: LD_STRING ","
47318: STR
47319: PUSH
47320: LD_VAR 0 4
47324: STR
47325: PUSH
47326: LD_STRING ")
47328: STR
47329: PPUSH
47330: CALL_OW 559
// end else
47334: GO 47343
// ToLua ( getStreamItemsFromMission("","") ) ;
47336: LD_STRING getStreamItemsFromMission("","")
47338: PPUSH
47339: CALL_OW 559
// end ;
47343: LD_VAR 0 1
47347: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
47348: LD_VAR 0 2
47352: PUSH
47353: LD_INT 100
47355: EQUAL
47356: IFFALSE 48305
// begin if not StreamModeActive then
47358: LD_EXP 79
47362: NOT
47363: IFFALSE 47373
// StreamModeActive := true ;
47365: LD_ADDR_EXP 79
47369: PUSH
47370: LD_INT 1
47372: ST_TO_ADDR
// if p3 = 0 then
47373: LD_VAR 0 3
47377: PUSH
47378: LD_INT 0
47380: EQUAL
47381: IFFALSE 47387
// InitStreamMode ;
47383: CALL 43608 0 0
// if p3 = 1 then
47387: LD_VAR 0 3
47391: PUSH
47392: LD_INT 1
47394: EQUAL
47395: IFFALSE 47405
// sRocket := true ;
47397: LD_ADDR_EXP 84
47401: PUSH
47402: LD_INT 1
47404: ST_TO_ADDR
// if p3 = 2 then
47405: LD_VAR 0 3
47409: PUSH
47410: LD_INT 2
47412: EQUAL
47413: IFFALSE 47423
// sSpeed := true ;
47415: LD_ADDR_EXP 83
47419: PUSH
47420: LD_INT 1
47422: ST_TO_ADDR
// if p3 = 3 then
47423: LD_VAR 0 3
47427: PUSH
47428: LD_INT 3
47430: EQUAL
47431: IFFALSE 47441
// sEngine := true ;
47433: LD_ADDR_EXP 85
47437: PUSH
47438: LD_INT 1
47440: ST_TO_ADDR
// if p3 = 4 then
47441: LD_VAR 0 3
47445: PUSH
47446: LD_INT 4
47448: EQUAL
47449: IFFALSE 47459
// sSpec := true ;
47451: LD_ADDR_EXP 82
47455: PUSH
47456: LD_INT 1
47458: ST_TO_ADDR
// if p3 = 5 then
47459: LD_VAR 0 3
47463: PUSH
47464: LD_INT 5
47466: EQUAL
47467: IFFALSE 47477
// sLevel := true ;
47469: LD_ADDR_EXP 86
47473: PUSH
47474: LD_INT 1
47476: ST_TO_ADDR
// if p3 = 6 then
47477: LD_VAR 0 3
47481: PUSH
47482: LD_INT 6
47484: EQUAL
47485: IFFALSE 47495
// sArmoury := true ;
47487: LD_ADDR_EXP 87
47491: PUSH
47492: LD_INT 1
47494: ST_TO_ADDR
// if p3 = 7 then
47495: LD_VAR 0 3
47499: PUSH
47500: LD_INT 7
47502: EQUAL
47503: IFFALSE 47513
// sRadar := true ;
47505: LD_ADDR_EXP 88
47509: PUSH
47510: LD_INT 1
47512: ST_TO_ADDR
// if p3 = 8 then
47513: LD_VAR 0 3
47517: PUSH
47518: LD_INT 8
47520: EQUAL
47521: IFFALSE 47531
// sBunker := true ;
47523: LD_ADDR_EXP 89
47527: PUSH
47528: LD_INT 1
47530: ST_TO_ADDR
// if p3 = 9 then
47531: LD_VAR 0 3
47535: PUSH
47536: LD_INT 9
47538: EQUAL
47539: IFFALSE 47549
// sHack := true ;
47541: LD_ADDR_EXP 90
47545: PUSH
47546: LD_INT 1
47548: ST_TO_ADDR
// if p3 = 10 then
47549: LD_VAR 0 3
47553: PUSH
47554: LD_INT 10
47556: EQUAL
47557: IFFALSE 47567
// sFire := true ;
47559: LD_ADDR_EXP 91
47563: PUSH
47564: LD_INT 1
47566: ST_TO_ADDR
// if p3 = 11 then
47567: LD_VAR 0 3
47571: PUSH
47572: LD_INT 11
47574: EQUAL
47575: IFFALSE 47585
// sRefresh := true ;
47577: LD_ADDR_EXP 92
47581: PUSH
47582: LD_INT 1
47584: ST_TO_ADDR
// if p3 = 12 then
47585: LD_VAR 0 3
47589: PUSH
47590: LD_INT 12
47592: EQUAL
47593: IFFALSE 47603
// sExp := true ;
47595: LD_ADDR_EXP 93
47599: PUSH
47600: LD_INT 1
47602: ST_TO_ADDR
// if p3 = 13 then
47603: LD_VAR 0 3
47607: PUSH
47608: LD_INT 13
47610: EQUAL
47611: IFFALSE 47621
// sDepot := true ;
47613: LD_ADDR_EXP 94
47617: PUSH
47618: LD_INT 1
47620: ST_TO_ADDR
// if p3 = 14 then
47621: LD_VAR 0 3
47625: PUSH
47626: LD_INT 14
47628: EQUAL
47629: IFFALSE 47639
// sFlag := true ;
47631: LD_ADDR_EXP 95
47635: PUSH
47636: LD_INT 1
47638: ST_TO_ADDR
// if p3 = 15 then
47639: LD_VAR 0 3
47643: PUSH
47644: LD_INT 15
47646: EQUAL
47647: IFFALSE 47657
// sKamikadze := true ;
47649: LD_ADDR_EXP 103
47653: PUSH
47654: LD_INT 1
47656: ST_TO_ADDR
// if p3 = 16 then
47657: LD_VAR 0 3
47661: PUSH
47662: LD_INT 16
47664: EQUAL
47665: IFFALSE 47675
// sTroll := true ;
47667: LD_ADDR_EXP 104
47671: PUSH
47672: LD_INT 1
47674: ST_TO_ADDR
// if p3 = 17 then
47675: LD_VAR 0 3
47679: PUSH
47680: LD_INT 17
47682: EQUAL
47683: IFFALSE 47693
// sSlow := true ;
47685: LD_ADDR_EXP 105
47689: PUSH
47690: LD_INT 1
47692: ST_TO_ADDR
// if p3 = 18 then
47693: LD_VAR 0 3
47697: PUSH
47698: LD_INT 18
47700: EQUAL
47701: IFFALSE 47711
// sLack := true ;
47703: LD_ADDR_EXP 106
47707: PUSH
47708: LD_INT 1
47710: ST_TO_ADDR
// if p3 = 19 then
47711: LD_VAR 0 3
47715: PUSH
47716: LD_INT 19
47718: EQUAL
47719: IFFALSE 47729
// sTank := true ;
47721: LD_ADDR_EXP 108
47725: PUSH
47726: LD_INT 1
47728: ST_TO_ADDR
// if p3 = 20 then
47729: LD_VAR 0 3
47733: PUSH
47734: LD_INT 20
47736: EQUAL
47737: IFFALSE 47747
// sRemote := true ;
47739: LD_ADDR_EXP 109
47743: PUSH
47744: LD_INT 1
47746: ST_TO_ADDR
// if p3 = 21 then
47747: LD_VAR 0 3
47751: PUSH
47752: LD_INT 21
47754: EQUAL
47755: IFFALSE 47765
// sPowell := true ;
47757: LD_ADDR_EXP 110
47761: PUSH
47762: LD_INT 1
47764: ST_TO_ADDR
// if p3 = 22 then
47765: LD_VAR 0 3
47769: PUSH
47770: LD_INT 22
47772: EQUAL
47773: IFFALSE 47783
// sTeleport := true ;
47775: LD_ADDR_EXP 113
47779: PUSH
47780: LD_INT 1
47782: ST_TO_ADDR
// if p3 = 23 then
47783: LD_VAR 0 3
47787: PUSH
47788: LD_INT 23
47790: EQUAL
47791: IFFALSE 47801
// sOilTower := true ;
47793: LD_ADDR_EXP 115
47797: PUSH
47798: LD_INT 1
47800: ST_TO_ADDR
// if p3 = 24 then
47801: LD_VAR 0 3
47805: PUSH
47806: LD_INT 24
47808: EQUAL
47809: IFFALSE 47819
// sShovel := true ;
47811: LD_ADDR_EXP 116
47815: PUSH
47816: LD_INT 1
47818: ST_TO_ADDR
// if p3 = 25 then
47819: LD_VAR 0 3
47823: PUSH
47824: LD_INT 25
47826: EQUAL
47827: IFFALSE 47837
// sSheik := true ;
47829: LD_ADDR_EXP 117
47833: PUSH
47834: LD_INT 1
47836: ST_TO_ADDR
// if p3 = 26 then
47837: LD_VAR 0 3
47841: PUSH
47842: LD_INT 26
47844: EQUAL
47845: IFFALSE 47855
// sEarthquake := true ;
47847: LD_ADDR_EXP 119
47851: PUSH
47852: LD_INT 1
47854: ST_TO_ADDR
// if p3 = 27 then
47855: LD_VAR 0 3
47859: PUSH
47860: LD_INT 27
47862: EQUAL
47863: IFFALSE 47873
// sAI := true ;
47865: LD_ADDR_EXP 120
47869: PUSH
47870: LD_INT 1
47872: ST_TO_ADDR
// if p3 = 28 then
47873: LD_VAR 0 3
47877: PUSH
47878: LD_INT 28
47880: EQUAL
47881: IFFALSE 47891
// sCargo := true ;
47883: LD_ADDR_EXP 123
47887: PUSH
47888: LD_INT 1
47890: ST_TO_ADDR
// if p3 = 29 then
47891: LD_VAR 0 3
47895: PUSH
47896: LD_INT 29
47898: EQUAL
47899: IFFALSE 47909
// sDLaser := true ;
47901: LD_ADDR_EXP 124
47905: PUSH
47906: LD_INT 1
47908: ST_TO_ADDR
// if p3 = 30 then
47909: LD_VAR 0 3
47913: PUSH
47914: LD_INT 30
47916: EQUAL
47917: IFFALSE 47927
// sExchange := true ;
47919: LD_ADDR_EXP 125
47923: PUSH
47924: LD_INT 1
47926: ST_TO_ADDR
// if p3 = 31 then
47927: LD_VAR 0 3
47931: PUSH
47932: LD_INT 31
47934: EQUAL
47935: IFFALSE 47945
// sFac := true ;
47937: LD_ADDR_EXP 126
47941: PUSH
47942: LD_INT 1
47944: ST_TO_ADDR
// if p3 = 32 then
47945: LD_VAR 0 3
47949: PUSH
47950: LD_INT 32
47952: EQUAL
47953: IFFALSE 47963
// sPower := true ;
47955: LD_ADDR_EXP 127
47959: PUSH
47960: LD_INT 1
47962: ST_TO_ADDR
// if p3 = 33 then
47963: LD_VAR 0 3
47967: PUSH
47968: LD_INT 33
47970: EQUAL
47971: IFFALSE 47981
// sRandom := true ;
47973: LD_ADDR_EXP 128
47977: PUSH
47978: LD_INT 1
47980: ST_TO_ADDR
// if p3 = 34 then
47981: LD_VAR 0 3
47985: PUSH
47986: LD_INT 34
47988: EQUAL
47989: IFFALSE 47999
// sShield := true ;
47991: LD_ADDR_EXP 129
47995: PUSH
47996: LD_INT 1
47998: ST_TO_ADDR
// if p3 = 35 then
47999: LD_VAR 0 3
48003: PUSH
48004: LD_INT 35
48006: EQUAL
48007: IFFALSE 48017
// sTime := true ;
48009: LD_ADDR_EXP 130
48013: PUSH
48014: LD_INT 1
48016: ST_TO_ADDR
// if p3 = 36 then
48017: LD_VAR 0 3
48021: PUSH
48022: LD_INT 36
48024: EQUAL
48025: IFFALSE 48035
// sTools := true ;
48027: LD_ADDR_EXP 131
48031: PUSH
48032: LD_INT 1
48034: ST_TO_ADDR
// if p3 = 101 then
48035: LD_VAR 0 3
48039: PUSH
48040: LD_INT 101
48042: EQUAL
48043: IFFALSE 48053
// sSold := true ;
48045: LD_ADDR_EXP 96
48049: PUSH
48050: LD_INT 1
48052: ST_TO_ADDR
// if p3 = 102 then
48053: LD_VAR 0 3
48057: PUSH
48058: LD_INT 102
48060: EQUAL
48061: IFFALSE 48071
// sDiff := true ;
48063: LD_ADDR_EXP 97
48067: PUSH
48068: LD_INT 1
48070: ST_TO_ADDR
// if p3 = 103 then
48071: LD_VAR 0 3
48075: PUSH
48076: LD_INT 103
48078: EQUAL
48079: IFFALSE 48089
// sFog := true ;
48081: LD_ADDR_EXP 100
48085: PUSH
48086: LD_INT 1
48088: ST_TO_ADDR
// if p3 = 104 then
48089: LD_VAR 0 3
48093: PUSH
48094: LD_INT 104
48096: EQUAL
48097: IFFALSE 48107
// sReset := true ;
48099: LD_ADDR_EXP 101
48103: PUSH
48104: LD_INT 1
48106: ST_TO_ADDR
// if p3 = 105 then
48107: LD_VAR 0 3
48111: PUSH
48112: LD_INT 105
48114: EQUAL
48115: IFFALSE 48125
// sSun := true ;
48117: LD_ADDR_EXP 102
48121: PUSH
48122: LD_INT 1
48124: ST_TO_ADDR
// if p3 = 106 then
48125: LD_VAR 0 3
48129: PUSH
48130: LD_INT 106
48132: EQUAL
48133: IFFALSE 48143
// sTiger := true ;
48135: LD_ADDR_EXP 98
48139: PUSH
48140: LD_INT 1
48142: ST_TO_ADDR
// if p3 = 107 then
48143: LD_VAR 0 3
48147: PUSH
48148: LD_INT 107
48150: EQUAL
48151: IFFALSE 48161
// sBomb := true ;
48153: LD_ADDR_EXP 99
48157: PUSH
48158: LD_INT 1
48160: ST_TO_ADDR
// if p3 = 108 then
48161: LD_VAR 0 3
48165: PUSH
48166: LD_INT 108
48168: EQUAL
48169: IFFALSE 48179
// sWound := true ;
48171: LD_ADDR_EXP 107
48175: PUSH
48176: LD_INT 1
48178: ST_TO_ADDR
// if p3 = 109 then
48179: LD_VAR 0 3
48183: PUSH
48184: LD_INT 109
48186: EQUAL
48187: IFFALSE 48197
// sBetray := true ;
48189: LD_ADDR_EXP 111
48193: PUSH
48194: LD_INT 1
48196: ST_TO_ADDR
// if p3 = 110 then
48197: LD_VAR 0 3
48201: PUSH
48202: LD_INT 110
48204: EQUAL
48205: IFFALSE 48215
// sContamin := true ;
48207: LD_ADDR_EXP 112
48211: PUSH
48212: LD_INT 1
48214: ST_TO_ADDR
// if p3 = 111 then
48215: LD_VAR 0 3
48219: PUSH
48220: LD_INT 111
48222: EQUAL
48223: IFFALSE 48233
// sOil := true ;
48225: LD_ADDR_EXP 114
48229: PUSH
48230: LD_INT 1
48232: ST_TO_ADDR
// if p3 = 112 then
48233: LD_VAR 0 3
48237: PUSH
48238: LD_INT 112
48240: EQUAL
48241: IFFALSE 48251
// sStu := true ;
48243: LD_ADDR_EXP 118
48247: PUSH
48248: LD_INT 1
48250: ST_TO_ADDR
// if p3 = 113 then
48251: LD_VAR 0 3
48255: PUSH
48256: LD_INT 113
48258: EQUAL
48259: IFFALSE 48269
// sBazooka := true ;
48261: LD_ADDR_EXP 121
48265: PUSH
48266: LD_INT 1
48268: ST_TO_ADDR
// if p3 = 114 then
48269: LD_VAR 0 3
48273: PUSH
48274: LD_INT 114
48276: EQUAL
48277: IFFALSE 48287
// sMortar := true ;
48279: LD_ADDR_EXP 122
48283: PUSH
48284: LD_INT 1
48286: ST_TO_ADDR
// if p3 = 115 then
48287: LD_VAR 0 3
48291: PUSH
48292: LD_INT 115
48294: EQUAL
48295: IFFALSE 48305
// sRanger := true ;
48297: LD_ADDR_EXP 132
48301: PUSH
48302: LD_INT 1
48304: ST_TO_ADDR
// end ; end ;
48305: PPOPN 6
48307: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48308: LD_EXP 79
48312: PUSH
48313: LD_EXP 84
48317: AND
48318: IFFALSE 48442
48320: GO 48322
48322: DISABLE
48323: LD_INT 0
48325: PPUSH
48326: PPUSH
// begin enable ;
48327: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48328: LD_ADDR_VAR 0 2
48332: PUSH
48333: LD_INT 22
48335: PUSH
48336: LD_OWVAR 2
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PUSH
48345: LD_INT 2
48347: PUSH
48348: LD_INT 34
48350: PUSH
48351: LD_INT 7
48353: PUSH
48354: EMPTY
48355: LIST
48356: LIST
48357: PUSH
48358: LD_INT 34
48360: PUSH
48361: LD_INT 45
48363: PUSH
48364: EMPTY
48365: LIST
48366: LIST
48367: PUSH
48368: LD_INT 34
48370: PUSH
48371: LD_INT 28
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: PUSH
48378: LD_INT 34
48380: PUSH
48381: LD_INT 47
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: PUSH
48395: EMPTY
48396: LIST
48397: LIST
48398: PPUSH
48399: CALL_OW 69
48403: ST_TO_ADDR
// if not tmp then
48404: LD_VAR 0 2
48408: NOT
48409: IFFALSE 48413
// exit ;
48411: GO 48442
// for i in tmp do
48413: LD_ADDR_VAR 0 1
48417: PUSH
48418: LD_VAR 0 2
48422: PUSH
48423: FOR_IN
48424: IFFALSE 48440
// begin SetLives ( i , 0 ) ;
48426: LD_VAR 0 1
48430: PPUSH
48431: LD_INT 0
48433: PPUSH
48434: CALL_OW 234
// end ;
48438: GO 48423
48440: POP
48441: POP
// end ;
48442: PPOPN 2
48444: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48445: LD_EXP 79
48449: PUSH
48450: LD_EXP 85
48454: AND
48455: IFFALSE 48539
48457: GO 48459
48459: DISABLE
48460: LD_INT 0
48462: PPUSH
48463: PPUSH
// begin enable ;
48464: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48465: LD_ADDR_VAR 0 2
48469: PUSH
48470: LD_INT 22
48472: PUSH
48473: LD_OWVAR 2
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: PUSH
48482: LD_INT 32
48484: PUSH
48485: LD_INT 3
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: EMPTY
48493: LIST
48494: LIST
48495: PPUSH
48496: CALL_OW 69
48500: ST_TO_ADDR
// if not tmp then
48501: LD_VAR 0 2
48505: NOT
48506: IFFALSE 48510
// exit ;
48508: GO 48539
// for i in tmp do
48510: LD_ADDR_VAR 0 1
48514: PUSH
48515: LD_VAR 0 2
48519: PUSH
48520: FOR_IN
48521: IFFALSE 48537
// begin SetLives ( i , 0 ) ;
48523: LD_VAR 0 1
48527: PPUSH
48528: LD_INT 0
48530: PPUSH
48531: CALL_OW 234
// end ;
48535: GO 48520
48537: POP
48538: POP
// end ;
48539: PPOPN 2
48541: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48542: LD_EXP 79
48546: PUSH
48547: LD_EXP 82
48551: AND
48552: IFFALSE 48645
48554: GO 48556
48556: DISABLE
48557: LD_INT 0
48559: PPUSH
// begin enable ;
48560: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48561: LD_ADDR_VAR 0 1
48565: PUSH
48566: LD_INT 22
48568: PUSH
48569: LD_OWVAR 2
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 25
48583: PUSH
48584: LD_INT 5
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 25
48593: PUSH
48594: LD_INT 9
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: PUSH
48601: LD_INT 25
48603: PUSH
48604: LD_INT 8
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: PUSH
48617: EMPTY
48618: LIST
48619: LIST
48620: PPUSH
48621: CALL_OW 69
48625: PUSH
48626: FOR_IN
48627: IFFALSE 48643
// begin SetClass ( i , 1 ) ;
48629: LD_VAR 0 1
48633: PPUSH
48634: LD_INT 1
48636: PPUSH
48637: CALL_OW 336
// end ;
48641: GO 48626
48643: POP
48644: POP
// end ;
48645: PPOPN 1
48647: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48648: LD_EXP 79
48652: PUSH
48653: LD_EXP 83
48657: AND
48658: PUSH
48659: LD_OWVAR 65
48663: PUSH
48664: LD_INT 7
48666: LESS
48667: AND
48668: IFFALSE 48682
48670: GO 48672
48672: DISABLE
// begin enable ;
48673: ENABLE
// game_speed := 7 ;
48674: LD_ADDR_OWVAR 65
48678: PUSH
48679: LD_INT 7
48681: ST_TO_ADDR
// end ;
48682: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48683: LD_EXP 79
48687: PUSH
48688: LD_EXP 86
48692: AND
48693: IFFALSE 48895
48695: GO 48697
48697: DISABLE
48698: LD_INT 0
48700: PPUSH
48701: PPUSH
48702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48703: LD_ADDR_VAR 0 3
48707: PUSH
48708: LD_INT 81
48710: PUSH
48711: LD_OWVAR 2
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PUSH
48720: LD_INT 21
48722: PUSH
48723: LD_INT 1
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: PPUSH
48734: CALL_OW 69
48738: ST_TO_ADDR
// if not tmp then
48739: LD_VAR 0 3
48743: NOT
48744: IFFALSE 48748
// exit ;
48746: GO 48895
// if tmp > 5 then
48748: LD_VAR 0 3
48752: PUSH
48753: LD_INT 5
48755: GREATER
48756: IFFALSE 48768
// k := 5 else
48758: LD_ADDR_VAR 0 2
48762: PUSH
48763: LD_INT 5
48765: ST_TO_ADDR
48766: GO 48778
// k := tmp ;
48768: LD_ADDR_VAR 0 2
48772: PUSH
48773: LD_VAR 0 3
48777: ST_TO_ADDR
// for i := 1 to k do
48778: LD_ADDR_VAR 0 1
48782: PUSH
48783: DOUBLE
48784: LD_INT 1
48786: DEC
48787: ST_TO_ADDR
48788: LD_VAR 0 2
48792: PUSH
48793: FOR_TO
48794: IFFALSE 48893
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48796: LD_VAR 0 3
48800: PUSH
48801: LD_VAR 0 1
48805: ARRAY
48806: PPUSH
48807: LD_VAR 0 1
48811: PUSH
48812: LD_INT 4
48814: MOD
48815: PUSH
48816: LD_INT 1
48818: PLUS
48819: PPUSH
48820: CALL_OW 259
48824: PUSH
48825: LD_INT 10
48827: LESS
48828: IFFALSE 48891
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48830: LD_VAR 0 3
48834: PUSH
48835: LD_VAR 0 1
48839: ARRAY
48840: PPUSH
48841: LD_VAR 0 1
48845: PUSH
48846: LD_INT 4
48848: MOD
48849: PUSH
48850: LD_INT 1
48852: PLUS
48853: PPUSH
48854: LD_VAR 0 3
48858: PUSH
48859: LD_VAR 0 1
48863: ARRAY
48864: PPUSH
48865: LD_VAR 0 1
48869: PUSH
48870: LD_INT 4
48872: MOD
48873: PUSH
48874: LD_INT 1
48876: PLUS
48877: PPUSH
48878: CALL_OW 259
48882: PUSH
48883: LD_INT 1
48885: PLUS
48886: PPUSH
48887: CALL_OW 237
48891: GO 48793
48893: POP
48894: POP
// end ;
48895: PPOPN 3
48897: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
48898: LD_EXP 79
48902: PUSH
48903: LD_EXP 87
48907: AND
48908: IFFALSE 48928
48910: GO 48912
48912: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
48913: LD_INT 4
48915: PPUSH
48916: LD_OWVAR 2
48920: PPUSH
48921: LD_INT 0
48923: PPUSH
48924: CALL_OW 324
48928: END
// every 0 0$1 trigger StreamModeActive and sShovel do
48929: LD_EXP 79
48933: PUSH
48934: LD_EXP 116
48938: AND
48939: IFFALSE 48959
48941: GO 48943
48943: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
48944: LD_INT 19
48946: PPUSH
48947: LD_OWVAR 2
48951: PPUSH
48952: LD_INT 0
48954: PPUSH
48955: CALL_OW 324
48959: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
48960: LD_EXP 79
48964: PUSH
48965: LD_EXP 88
48969: AND
48970: IFFALSE 49072
48972: GO 48974
48974: DISABLE
48975: LD_INT 0
48977: PPUSH
48978: PPUSH
// begin enable ;
48979: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
48980: LD_ADDR_VAR 0 2
48984: PUSH
48985: LD_INT 22
48987: PUSH
48988: LD_OWVAR 2
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: PUSH
48997: LD_INT 2
48999: PUSH
49000: LD_INT 34
49002: PUSH
49003: LD_INT 11
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 34
49012: PUSH
49013: LD_INT 30
49015: PUSH
49016: EMPTY
49017: LIST
49018: LIST
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: LIST
49024: PUSH
49025: EMPTY
49026: LIST
49027: LIST
49028: PPUSH
49029: CALL_OW 69
49033: ST_TO_ADDR
// if not tmp then
49034: LD_VAR 0 2
49038: NOT
49039: IFFALSE 49043
// exit ;
49041: GO 49072
// for i in tmp do
49043: LD_ADDR_VAR 0 1
49047: PUSH
49048: LD_VAR 0 2
49052: PUSH
49053: FOR_IN
49054: IFFALSE 49070
// begin SetLives ( i , 0 ) ;
49056: LD_VAR 0 1
49060: PPUSH
49061: LD_INT 0
49063: PPUSH
49064: CALL_OW 234
// end ;
49068: GO 49053
49070: POP
49071: POP
// end ;
49072: PPOPN 2
49074: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49075: LD_EXP 79
49079: PUSH
49080: LD_EXP 89
49084: AND
49085: IFFALSE 49105
49087: GO 49089
49089: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49090: LD_INT 32
49092: PPUSH
49093: LD_OWVAR 2
49097: PPUSH
49098: LD_INT 0
49100: PPUSH
49101: CALL_OW 324
49105: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49106: LD_EXP 79
49110: PUSH
49111: LD_EXP 90
49115: AND
49116: IFFALSE 49297
49118: GO 49120
49120: DISABLE
49121: LD_INT 0
49123: PPUSH
49124: PPUSH
49125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49126: LD_ADDR_VAR 0 2
49130: PUSH
49131: LD_INT 22
49133: PUSH
49134: LD_OWVAR 2
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: PUSH
49143: LD_INT 33
49145: PUSH
49146: LD_INT 3
49148: PUSH
49149: EMPTY
49150: LIST
49151: LIST
49152: PUSH
49153: EMPTY
49154: LIST
49155: LIST
49156: PPUSH
49157: CALL_OW 69
49161: ST_TO_ADDR
// if not tmp then
49162: LD_VAR 0 2
49166: NOT
49167: IFFALSE 49171
// exit ;
49169: GO 49297
// side := 0 ;
49171: LD_ADDR_VAR 0 3
49175: PUSH
49176: LD_INT 0
49178: ST_TO_ADDR
// for i := 1 to 8 do
49179: LD_ADDR_VAR 0 1
49183: PUSH
49184: DOUBLE
49185: LD_INT 1
49187: DEC
49188: ST_TO_ADDR
49189: LD_INT 8
49191: PUSH
49192: FOR_TO
49193: IFFALSE 49241
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49195: LD_OWVAR 2
49199: PUSH
49200: LD_VAR 0 1
49204: NONEQUAL
49205: PUSH
49206: LD_OWVAR 2
49210: PPUSH
49211: LD_VAR 0 1
49215: PPUSH
49216: CALL_OW 81
49220: PUSH
49221: LD_INT 2
49223: EQUAL
49224: AND
49225: IFFALSE 49239
// begin side := i ;
49227: LD_ADDR_VAR 0 3
49231: PUSH
49232: LD_VAR 0 1
49236: ST_TO_ADDR
// break ;
49237: GO 49241
// end ;
49239: GO 49192
49241: POP
49242: POP
// if not side then
49243: LD_VAR 0 3
49247: NOT
49248: IFFALSE 49252
// exit ;
49250: GO 49297
// for i := 1 to tmp do
49252: LD_ADDR_VAR 0 1
49256: PUSH
49257: DOUBLE
49258: LD_INT 1
49260: DEC
49261: ST_TO_ADDR
49262: LD_VAR 0 2
49266: PUSH
49267: FOR_TO
49268: IFFALSE 49295
// if Prob ( 60 ) then
49270: LD_INT 60
49272: PPUSH
49273: CALL_OW 13
49277: IFFALSE 49293
// SetSide ( i , side ) ;
49279: LD_VAR 0 1
49283: PPUSH
49284: LD_VAR 0 3
49288: PPUSH
49289: CALL_OW 235
49293: GO 49267
49295: POP
49296: POP
// end ;
49297: PPOPN 3
49299: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49300: LD_EXP 79
49304: PUSH
49305: LD_EXP 92
49309: AND
49310: IFFALSE 49429
49312: GO 49314
49314: DISABLE
49315: LD_INT 0
49317: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49318: LD_ADDR_VAR 0 1
49322: PUSH
49323: LD_INT 22
49325: PUSH
49326: LD_OWVAR 2
49330: PUSH
49331: EMPTY
49332: LIST
49333: LIST
49334: PUSH
49335: LD_INT 21
49337: PUSH
49338: LD_INT 1
49340: PUSH
49341: EMPTY
49342: LIST
49343: LIST
49344: PUSH
49345: LD_INT 3
49347: PUSH
49348: LD_INT 23
49350: PUSH
49351: LD_INT 0
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: PUSH
49362: EMPTY
49363: LIST
49364: LIST
49365: LIST
49366: PPUSH
49367: CALL_OW 69
49371: PUSH
49372: FOR_IN
49373: IFFALSE 49427
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49375: LD_VAR 0 1
49379: PPUSH
49380: CALL_OW 257
49384: PUSH
49385: LD_INT 1
49387: PUSH
49388: LD_INT 2
49390: PUSH
49391: LD_INT 3
49393: PUSH
49394: LD_INT 4
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: IN
49403: IFFALSE 49425
// SetClass ( un , rand ( 1 , 4 ) ) ;
49405: LD_VAR 0 1
49409: PPUSH
49410: LD_INT 1
49412: PPUSH
49413: LD_INT 4
49415: PPUSH
49416: CALL_OW 12
49420: PPUSH
49421: CALL_OW 336
49425: GO 49372
49427: POP
49428: POP
// end ;
49429: PPOPN 1
49431: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49432: LD_EXP 79
49436: PUSH
49437: LD_EXP 91
49441: AND
49442: IFFALSE 49521
49444: GO 49446
49446: DISABLE
49447: LD_INT 0
49449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49450: LD_ADDR_VAR 0 1
49454: PUSH
49455: LD_INT 22
49457: PUSH
49458: LD_OWVAR 2
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 21
49469: PUSH
49470: LD_INT 3
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: PUSH
49477: EMPTY
49478: LIST
49479: LIST
49480: PPUSH
49481: CALL_OW 69
49485: ST_TO_ADDR
// if not tmp then
49486: LD_VAR 0 1
49490: NOT
49491: IFFALSE 49495
// exit ;
49493: GO 49521
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49495: LD_VAR 0 1
49499: PUSH
49500: LD_INT 1
49502: PPUSH
49503: LD_VAR 0 1
49507: PPUSH
49508: CALL_OW 12
49512: ARRAY
49513: PPUSH
49514: LD_INT 100
49516: PPUSH
49517: CALL_OW 234
// end ;
49521: PPOPN 1
49523: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49524: LD_EXP 79
49528: PUSH
49529: LD_EXP 93
49533: AND
49534: IFFALSE 49632
49536: GO 49538
49538: DISABLE
49539: LD_INT 0
49541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49542: LD_ADDR_VAR 0 1
49546: PUSH
49547: LD_INT 22
49549: PUSH
49550: LD_OWVAR 2
49554: PUSH
49555: EMPTY
49556: LIST
49557: LIST
49558: PUSH
49559: LD_INT 21
49561: PUSH
49562: LD_INT 1
49564: PUSH
49565: EMPTY
49566: LIST
49567: LIST
49568: PUSH
49569: EMPTY
49570: LIST
49571: LIST
49572: PPUSH
49573: CALL_OW 69
49577: ST_TO_ADDR
// if not tmp then
49578: LD_VAR 0 1
49582: NOT
49583: IFFALSE 49587
// exit ;
49585: GO 49632
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49587: LD_VAR 0 1
49591: PUSH
49592: LD_INT 1
49594: PPUSH
49595: LD_VAR 0 1
49599: PPUSH
49600: CALL_OW 12
49604: ARRAY
49605: PPUSH
49606: LD_INT 1
49608: PPUSH
49609: LD_INT 4
49611: PPUSH
49612: CALL_OW 12
49616: PPUSH
49617: LD_INT 3000
49619: PPUSH
49620: LD_INT 9000
49622: PPUSH
49623: CALL_OW 12
49627: PPUSH
49628: CALL_OW 492
// end ;
49632: PPOPN 1
49634: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49635: LD_EXP 79
49639: PUSH
49640: LD_EXP 94
49644: AND
49645: IFFALSE 49665
49647: GO 49649
49649: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49650: LD_INT 1
49652: PPUSH
49653: LD_OWVAR 2
49657: PPUSH
49658: LD_INT 0
49660: PPUSH
49661: CALL_OW 324
49665: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49666: LD_EXP 79
49670: PUSH
49671: LD_EXP 95
49675: AND
49676: IFFALSE 49759
49678: GO 49680
49680: DISABLE
49681: LD_INT 0
49683: PPUSH
49684: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49685: LD_ADDR_VAR 0 2
49689: PUSH
49690: LD_INT 22
49692: PUSH
49693: LD_OWVAR 2
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PUSH
49702: LD_INT 21
49704: PUSH
49705: LD_INT 3
49707: PUSH
49708: EMPTY
49709: LIST
49710: LIST
49711: PUSH
49712: EMPTY
49713: LIST
49714: LIST
49715: PPUSH
49716: CALL_OW 69
49720: ST_TO_ADDR
// if not tmp then
49721: LD_VAR 0 2
49725: NOT
49726: IFFALSE 49730
// exit ;
49728: GO 49759
// for i in tmp do
49730: LD_ADDR_VAR 0 1
49734: PUSH
49735: LD_VAR 0 2
49739: PUSH
49740: FOR_IN
49741: IFFALSE 49757
// SetBLevel ( i , 10 ) ;
49743: LD_VAR 0 1
49747: PPUSH
49748: LD_INT 10
49750: PPUSH
49751: CALL_OW 241
49755: GO 49740
49757: POP
49758: POP
// end ;
49759: PPOPN 2
49761: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49762: LD_EXP 79
49766: PUSH
49767: LD_EXP 96
49771: AND
49772: IFFALSE 49883
49774: GO 49776
49776: DISABLE
49777: LD_INT 0
49779: PPUSH
49780: PPUSH
49781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49782: LD_ADDR_VAR 0 3
49786: PUSH
49787: LD_INT 22
49789: PUSH
49790: LD_OWVAR 2
49794: PUSH
49795: EMPTY
49796: LIST
49797: LIST
49798: PUSH
49799: LD_INT 25
49801: PUSH
49802: LD_INT 1
49804: PUSH
49805: EMPTY
49806: LIST
49807: LIST
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: PPUSH
49813: CALL_OW 69
49817: ST_TO_ADDR
// if not tmp then
49818: LD_VAR 0 3
49822: NOT
49823: IFFALSE 49827
// exit ;
49825: GO 49883
// un := tmp [ rand ( 1 , tmp ) ] ;
49827: LD_ADDR_VAR 0 2
49831: PUSH
49832: LD_VAR 0 3
49836: PUSH
49837: LD_INT 1
49839: PPUSH
49840: LD_VAR 0 3
49844: PPUSH
49845: CALL_OW 12
49849: ARRAY
49850: ST_TO_ADDR
// if Crawls ( un ) then
49851: LD_VAR 0 2
49855: PPUSH
49856: CALL_OW 318
49860: IFFALSE 49871
// ComWalk ( un ) ;
49862: LD_VAR 0 2
49866: PPUSH
49867: CALL_OW 138
// SetClass ( un , class_sniper ) ;
49871: LD_VAR 0 2
49875: PPUSH
49876: LD_INT 5
49878: PPUSH
49879: CALL_OW 336
// end ;
49883: PPOPN 3
49885: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
49886: LD_EXP 79
49890: PUSH
49891: LD_EXP 97
49895: AND
49896: PUSH
49897: LD_OWVAR 67
49901: PUSH
49902: LD_INT 3
49904: LESS
49905: AND
49906: IFFALSE 49925
49908: GO 49910
49910: DISABLE
// Difficulty := Difficulty + 1 ;
49911: LD_ADDR_OWVAR 67
49915: PUSH
49916: LD_OWVAR 67
49920: PUSH
49921: LD_INT 1
49923: PLUS
49924: ST_TO_ADDR
49925: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
49926: LD_EXP 79
49930: PUSH
49931: LD_EXP 98
49935: AND
49936: IFFALSE 50039
49938: GO 49940
49940: DISABLE
49941: LD_INT 0
49943: PPUSH
// begin for i := 1 to 5 do
49944: LD_ADDR_VAR 0 1
49948: PUSH
49949: DOUBLE
49950: LD_INT 1
49952: DEC
49953: ST_TO_ADDR
49954: LD_INT 5
49956: PUSH
49957: FOR_TO
49958: IFFALSE 50037
// begin uc_nation := nation_nature ;
49960: LD_ADDR_OWVAR 21
49964: PUSH
49965: LD_INT 0
49967: ST_TO_ADDR
// uc_side := 0 ;
49968: LD_ADDR_OWVAR 20
49972: PUSH
49973: LD_INT 0
49975: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
49976: LD_ADDR_OWVAR 29
49980: PUSH
49981: LD_INT 12
49983: PUSH
49984: LD_INT 12
49986: PUSH
49987: EMPTY
49988: LIST
49989: LIST
49990: ST_TO_ADDR
// hc_agressivity := 20 ;
49991: LD_ADDR_OWVAR 35
49995: PUSH
49996: LD_INT 20
49998: ST_TO_ADDR
// hc_class := class_tiger ;
49999: LD_ADDR_OWVAR 28
50003: PUSH
50004: LD_INT 14
50006: ST_TO_ADDR
// hc_gallery :=  ;
50007: LD_ADDR_OWVAR 33
50011: PUSH
50012: LD_STRING 
50014: ST_TO_ADDR
// hc_name :=  ;
50015: LD_ADDR_OWVAR 26
50019: PUSH
50020: LD_STRING 
50022: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50023: CALL_OW 44
50027: PPUSH
50028: LD_INT 0
50030: PPUSH
50031: CALL_OW 51
// end ;
50035: GO 49957
50037: POP
50038: POP
// end ;
50039: PPOPN 1
50041: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50042: LD_EXP 79
50046: PUSH
50047: LD_EXP 99
50051: AND
50052: IFFALSE 50061
50054: GO 50056
50056: DISABLE
// StreamSibBomb ;
50057: CALL 50062 0 0
50061: END
// export function StreamSibBomb ; var i , x , y ; begin
50062: LD_INT 0
50064: PPUSH
50065: PPUSH
50066: PPUSH
50067: PPUSH
// result := false ;
50068: LD_ADDR_VAR 0 1
50072: PUSH
50073: LD_INT 0
50075: ST_TO_ADDR
// for i := 1 to 16 do
50076: LD_ADDR_VAR 0 2
50080: PUSH
50081: DOUBLE
50082: LD_INT 1
50084: DEC
50085: ST_TO_ADDR
50086: LD_INT 16
50088: PUSH
50089: FOR_TO
50090: IFFALSE 50289
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50092: LD_ADDR_VAR 0 3
50096: PUSH
50097: LD_INT 10
50099: PUSH
50100: LD_INT 20
50102: PUSH
50103: LD_INT 30
50105: PUSH
50106: LD_INT 40
50108: PUSH
50109: LD_INT 50
50111: PUSH
50112: LD_INT 60
50114: PUSH
50115: LD_INT 70
50117: PUSH
50118: LD_INT 80
50120: PUSH
50121: LD_INT 90
50123: PUSH
50124: LD_INT 100
50126: PUSH
50127: LD_INT 110
50129: PUSH
50130: LD_INT 120
50132: PUSH
50133: LD_INT 130
50135: PUSH
50136: LD_INT 140
50138: PUSH
50139: LD_INT 150
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: LIST
50146: LIST
50147: LIST
50148: LIST
50149: LIST
50150: LIST
50151: LIST
50152: LIST
50153: LIST
50154: LIST
50155: LIST
50156: LIST
50157: LIST
50158: PUSH
50159: LD_INT 1
50161: PPUSH
50162: LD_INT 15
50164: PPUSH
50165: CALL_OW 12
50169: ARRAY
50170: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50171: LD_ADDR_VAR 0 4
50175: PUSH
50176: LD_INT 10
50178: PUSH
50179: LD_INT 20
50181: PUSH
50182: LD_INT 30
50184: PUSH
50185: LD_INT 40
50187: PUSH
50188: LD_INT 50
50190: PUSH
50191: LD_INT 60
50193: PUSH
50194: LD_INT 70
50196: PUSH
50197: LD_INT 80
50199: PUSH
50200: LD_INT 90
50202: PUSH
50203: LD_INT 100
50205: PUSH
50206: LD_INT 110
50208: PUSH
50209: LD_INT 120
50211: PUSH
50212: LD_INT 130
50214: PUSH
50215: LD_INT 140
50217: PUSH
50218: LD_INT 150
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: LIST
50225: LIST
50226: LIST
50227: LIST
50228: LIST
50229: LIST
50230: LIST
50231: LIST
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 1
50240: PPUSH
50241: LD_INT 15
50243: PPUSH
50244: CALL_OW 12
50248: ARRAY
50249: ST_TO_ADDR
// if ValidHex ( x , y ) then
50250: LD_VAR 0 3
50254: PPUSH
50255: LD_VAR 0 4
50259: PPUSH
50260: CALL_OW 488
50264: IFFALSE 50287
// begin result := [ x , y ] ;
50266: LD_ADDR_VAR 0 1
50270: PUSH
50271: LD_VAR 0 3
50275: PUSH
50276: LD_VAR 0 4
50280: PUSH
50281: EMPTY
50282: LIST
50283: LIST
50284: ST_TO_ADDR
// break ;
50285: GO 50289
// end ; end ;
50287: GO 50089
50289: POP
50290: POP
// if result then
50291: LD_VAR 0 1
50295: IFFALSE 50355
// begin ToLua ( playSibBomb() ) ;
50297: LD_STRING playSibBomb()
50299: PPUSH
50300: CALL_OW 559
// wait ( 0 0$14 ) ;
50304: LD_INT 490
50306: PPUSH
50307: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50311: LD_VAR 0 1
50315: PUSH
50316: LD_INT 1
50318: ARRAY
50319: PPUSH
50320: LD_VAR 0 1
50324: PUSH
50325: LD_INT 2
50327: ARRAY
50328: PPUSH
50329: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50333: LD_VAR 0 1
50337: PUSH
50338: LD_INT 1
50340: ARRAY
50341: PPUSH
50342: LD_VAR 0 1
50346: PUSH
50347: LD_INT 2
50349: ARRAY
50350: PPUSH
50351: CALL_OW 429
// end ; end ;
50355: LD_VAR 0 1
50359: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50360: LD_EXP 79
50364: PUSH
50365: LD_EXP 101
50369: AND
50370: IFFALSE 50382
50372: GO 50374
50374: DISABLE
// YouLost (  ) ;
50375: LD_STRING 
50377: PPUSH
50378: CALL_OW 104
50382: END
// every 0 0$1 trigger StreamModeActive and sFog do
50383: LD_EXP 79
50387: PUSH
50388: LD_EXP 100
50392: AND
50393: IFFALSE 50407
50395: GO 50397
50397: DISABLE
// FogOff ( your_side ) ;
50398: LD_OWVAR 2
50402: PPUSH
50403: CALL_OW 344
50407: END
// every 0 0$1 trigger StreamModeActive and sSun do
50408: LD_EXP 79
50412: PUSH
50413: LD_EXP 102
50417: AND
50418: IFFALSE 50446
50420: GO 50422
50422: DISABLE
// begin solar_recharge_percent := 0 ;
50423: LD_ADDR_OWVAR 79
50427: PUSH
50428: LD_INT 0
50430: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50431: LD_INT 10500
50433: PPUSH
50434: CALL_OW 67
// solar_recharge_percent := 100 ;
50438: LD_ADDR_OWVAR 79
50442: PUSH
50443: LD_INT 100
50445: ST_TO_ADDR
// end ;
50446: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50447: LD_EXP 79
50451: PUSH
50452: LD_EXP 103
50456: AND
50457: IFFALSE 50696
50459: GO 50461
50461: DISABLE
50462: LD_INT 0
50464: PPUSH
50465: PPUSH
50466: PPUSH
// begin tmp := [ ] ;
50467: LD_ADDR_VAR 0 3
50471: PUSH
50472: EMPTY
50473: ST_TO_ADDR
// for i := 1 to 6 do
50474: LD_ADDR_VAR 0 1
50478: PUSH
50479: DOUBLE
50480: LD_INT 1
50482: DEC
50483: ST_TO_ADDR
50484: LD_INT 6
50486: PUSH
50487: FOR_TO
50488: IFFALSE 50593
// begin uc_nation := nation_nature ;
50490: LD_ADDR_OWVAR 21
50494: PUSH
50495: LD_INT 0
50497: ST_TO_ADDR
// uc_side := 0 ;
50498: LD_ADDR_OWVAR 20
50502: PUSH
50503: LD_INT 0
50505: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50506: LD_ADDR_OWVAR 29
50510: PUSH
50511: LD_INT 12
50513: PUSH
50514: LD_INT 12
50516: PUSH
50517: EMPTY
50518: LIST
50519: LIST
50520: ST_TO_ADDR
// hc_agressivity := 20 ;
50521: LD_ADDR_OWVAR 35
50525: PUSH
50526: LD_INT 20
50528: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50529: LD_ADDR_OWVAR 28
50533: PUSH
50534: LD_INT 17
50536: ST_TO_ADDR
// hc_gallery :=  ;
50537: LD_ADDR_OWVAR 33
50541: PUSH
50542: LD_STRING 
50544: ST_TO_ADDR
// hc_name :=  ;
50545: LD_ADDR_OWVAR 26
50549: PUSH
50550: LD_STRING 
50552: ST_TO_ADDR
// un := CreateHuman ;
50553: LD_ADDR_VAR 0 2
50557: PUSH
50558: CALL_OW 44
50562: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50563: LD_VAR 0 2
50567: PPUSH
50568: LD_INT 1
50570: PPUSH
50571: CALL_OW 51
// tmp := tmp ^ un ;
50575: LD_ADDR_VAR 0 3
50579: PUSH
50580: LD_VAR 0 3
50584: PUSH
50585: LD_VAR 0 2
50589: ADD
50590: ST_TO_ADDR
// end ;
50591: GO 50487
50593: POP
50594: POP
// repeat wait ( 0 0$1 ) ;
50595: LD_INT 35
50597: PPUSH
50598: CALL_OW 67
// for un in tmp do
50602: LD_ADDR_VAR 0 2
50606: PUSH
50607: LD_VAR 0 3
50611: PUSH
50612: FOR_IN
50613: IFFALSE 50687
// begin if IsDead ( un ) then
50615: LD_VAR 0 2
50619: PPUSH
50620: CALL_OW 301
50624: IFFALSE 50644
// begin tmp := tmp diff un ;
50626: LD_ADDR_VAR 0 3
50630: PUSH
50631: LD_VAR 0 3
50635: PUSH
50636: LD_VAR 0 2
50640: DIFF
50641: ST_TO_ADDR
// continue ;
50642: GO 50612
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50644: LD_VAR 0 2
50648: PPUSH
50649: LD_INT 3
50651: PUSH
50652: LD_INT 22
50654: PUSH
50655: LD_INT 0
50657: PUSH
50658: EMPTY
50659: LIST
50660: LIST
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PPUSH
50666: CALL_OW 69
50670: PPUSH
50671: LD_VAR 0 2
50675: PPUSH
50676: CALL_OW 74
50680: PPUSH
50681: CALL_OW 115
// end ;
50685: GO 50612
50687: POP
50688: POP
// until not tmp ;
50689: LD_VAR 0 3
50693: NOT
50694: IFFALSE 50595
// end ;
50696: PPOPN 3
50698: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50699: LD_EXP 79
50703: PUSH
50704: LD_EXP 104
50708: AND
50709: IFFALSE 50763
50711: GO 50713
50713: DISABLE
// begin ToLua ( displayTroll(); ) ;
50714: LD_STRING displayTroll();
50716: PPUSH
50717: CALL_OW 559
// wait ( 3 3$00 ) ;
50721: LD_INT 6300
50723: PPUSH
50724: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50728: LD_STRING hideTroll();
50730: PPUSH
50731: CALL_OW 559
// wait ( 1 1$00 ) ;
50735: LD_INT 2100
50737: PPUSH
50738: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50742: LD_STRING displayTroll();
50744: PPUSH
50745: CALL_OW 559
// wait ( 1 1$00 ) ;
50749: LD_INT 2100
50751: PPUSH
50752: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50756: LD_STRING hideTroll();
50758: PPUSH
50759: CALL_OW 559
// end ;
50763: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50764: LD_EXP 79
50768: PUSH
50769: LD_EXP 105
50773: AND
50774: IFFALSE 50837
50776: GO 50778
50778: DISABLE
50779: LD_INT 0
50781: PPUSH
// begin p := 0 ;
50782: LD_ADDR_VAR 0 1
50786: PUSH
50787: LD_INT 0
50789: ST_TO_ADDR
// repeat game_speed := 1 ;
50790: LD_ADDR_OWVAR 65
50794: PUSH
50795: LD_INT 1
50797: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50798: LD_INT 35
50800: PPUSH
50801: CALL_OW 67
// p := p + 1 ;
50805: LD_ADDR_VAR 0 1
50809: PUSH
50810: LD_VAR 0 1
50814: PUSH
50815: LD_INT 1
50817: PLUS
50818: ST_TO_ADDR
// until p >= 60 ;
50819: LD_VAR 0 1
50823: PUSH
50824: LD_INT 60
50826: GREATEREQUAL
50827: IFFALSE 50790
// game_speed := 4 ;
50829: LD_ADDR_OWVAR 65
50833: PUSH
50834: LD_INT 4
50836: ST_TO_ADDR
// end ;
50837: PPOPN 1
50839: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
50840: LD_EXP 79
50844: PUSH
50845: LD_EXP 106
50849: AND
50850: IFFALSE 50996
50852: GO 50854
50854: DISABLE
50855: LD_INT 0
50857: PPUSH
50858: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
50859: LD_ADDR_VAR 0 1
50863: PUSH
50864: LD_INT 22
50866: PUSH
50867: LD_OWVAR 2
50871: PUSH
50872: EMPTY
50873: LIST
50874: LIST
50875: PUSH
50876: LD_INT 2
50878: PUSH
50879: LD_INT 30
50881: PUSH
50882: LD_INT 0
50884: PUSH
50885: EMPTY
50886: LIST
50887: LIST
50888: PUSH
50889: LD_INT 30
50891: PUSH
50892: LD_INT 1
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PUSH
50899: EMPTY
50900: LIST
50901: LIST
50902: LIST
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: PPUSH
50908: CALL_OW 69
50912: ST_TO_ADDR
// if not depot then
50913: LD_VAR 0 1
50917: NOT
50918: IFFALSE 50922
// exit ;
50920: GO 50996
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
50922: LD_ADDR_VAR 0 2
50926: PUSH
50927: LD_VAR 0 1
50931: PUSH
50932: LD_INT 1
50934: PPUSH
50935: LD_VAR 0 1
50939: PPUSH
50940: CALL_OW 12
50944: ARRAY
50945: PPUSH
50946: CALL_OW 274
50950: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
50951: LD_VAR 0 2
50955: PPUSH
50956: LD_INT 1
50958: PPUSH
50959: LD_INT 0
50961: PPUSH
50962: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
50966: LD_VAR 0 2
50970: PPUSH
50971: LD_INT 2
50973: PPUSH
50974: LD_INT 0
50976: PPUSH
50977: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
50981: LD_VAR 0 2
50985: PPUSH
50986: LD_INT 3
50988: PPUSH
50989: LD_INT 0
50991: PPUSH
50992: CALL_OW 277
// end ;
50996: PPOPN 2
50998: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
50999: LD_EXP 79
51003: PUSH
51004: LD_EXP 107
51008: AND
51009: IFFALSE 51106
51011: GO 51013
51013: DISABLE
51014: LD_INT 0
51016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51017: LD_ADDR_VAR 0 1
51021: PUSH
51022: LD_INT 22
51024: PUSH
51025: LD_OWVAR 2
51029: PUSH
51030: EMPTY
51031: LIST
51032: LIST
51033: PUSH
51034: LD_INT 21
51036: PUSH
51037: LD_INT 1
51039: PUSH
51040: EMPTY
51041: LIST
51042: LIST
51043: PUSH
51044: LD_INT 3
51046: PUSH
51047: LD_INT 23
51049: PUSH
51050: LD_INT 0
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: PUSH
51057: EMPTY
51058: LIST
51059: LIST
51060: PUSH
51061: EMPTY
51062: LIST
51063: LIST
51064: LIST
51065: PPUSH
51066: CALL_OW 69
51070: ST_TO_ADDR
// if not tmp then
51071: LD_VAR 0 1
51075: NOT
51076: IFFALSE 51080
// exit ;
51078: GO 51106
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51080: LD_VAR 0 1
51084: PUSH
51085: LD_INT 1
51087: PPUSH
51088: LD_VAR 0 1
51092: PPUSH
51093: CALL_OW 12
51097: ARRAY
51098: PPUSH
51099: LD_INT 200
51101: PPUSH
51102: CALL_OW 234
// end ;
51106: PPOPN 1
51108: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51109: LD_EXP 79
51113: PUSH
51114: LD_EXP 108
51118: AND
51119: IFFALSE 51198
51121: GO 51123
51123: DISABLE
51124: LD_INT 0
51126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51127: LD_ADDR_VAR 0 1
51131: PUSH
51132: LD_INT 22
51134: PUSH
51135: LD_OWVAR 2
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: PUSH
51144: LD_INT 21
51146: PUSH
51147: LD_INT 2
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: PUSH
51154: EMPTY
51155: LIST
51156: LIST
51157: PPUSH
51158: CALL_OW 69
51162: ST_TO_ADDR
// if not tmp then
51163: LD_VAR 0 1
51167: NOT
51168: IFFALSE 51172
// exit ;
51170: GO 51198
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51172: LD_VAR 0 1
51176: PUSH
51177: LD_INT 1
51179: PPUSH
51180: LD_VAR 0 1
51184: PPUSH
51185: CALL_OW 12
51189: ARRAY
51190: PPUSH
51191: LD_INT 60
51193: PPUSH
51194: CALL_OW 234
// end ;
51198: PPOPN 1
51200: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51201: LD_EXP 79
51205: PUSH
51206: LD_EXP 109
51210: AND
51211: IFFALSE 51310
51213: GO 51215
51215: DISABLE
51216: LD_INT 0
51218: PPUSH
51219: PPUSH
// begin enable ;
51220: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51221: LD_ADDR_VAR 0 1
51225: PUSH
51226: LD_INT 22
51228: PUSH
51229: LD_OWVAR 2
51233: PUSH
51234: EMPTY
51235: LIST
51236: LIST
51237: PUSH
51238: LD_INT 61
51240: PUSH
51241: EMPTY
51242: LIST
51243: PUSH
51244: LD_INT 33
51246: PUSH
51247: LD_INT 2
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: LIST
51258: PPUSH
51259: CALL_OW 69
51263: ST_TO_ADDR
// if not tmp then
51264: LD_VAR 0 1
51268: NOT
51269: IFFALSE 51273
// exit ;
51271: GO 51310
// for i in tmp do
51273: LD_ADDR_VAR 0 2
51277: PUSH
51278: LD_VAR 0 1
51282: PUSH
51283: FOR_IN
51284: IFFALSE 51308
// if IsControledBy ( i ) then
51286: LD_VAR 0 2
51290: PPUSH
51291: CALL_OW 312
51295: IFFALSE 51306
// ComUnlink ( i ) ;
51297: LD_VAR 0 2
51301: PPUSH
51302: CALL_OW 136
51306: GO 51283
51308: POP
51309: POP
// end ;
51310: PPOPN 2
51312: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51313: LD_EXP 79
51317: PUSH
51318: LD_EXP 110
51322: AND
51323: IFFALSE 51463
51325: GO 51327
51327: DISABLE
51328: LD_INT 0
51330: PPUSH
51331: PPUSH
// begin ToLua ( displayPowell(); ) ;
51332: LD_STRING displayPowell();
51334: PPUSH
51335: CALL_OW 559
// uc_side := 0 ;
51339: LD_ADDR_OWVAR 20
51343: PUSH
51344: LD_INT 0
51346: ST_TO_ADDR
// uc_nation := 2 ;
51347: LD_ADDR_OWVAR 21
51351: PUSH
51352: LD_INT 2
51354: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51355: LD_ADDR_OWVAR 37
51359: PUSH
51360: LD_INT 14
51362: ST_TO_ADDR
// vc_engine := engine_siberite ;
51363: LD_ADDR_OWVAR 39
51367: PUSH
51368: LD_INT 3
51370: ST_TO_ADDR
// vc_control := control_apeman ;
51371: LD_ADDR_OWVAR 38
51375: PUSH
51376: LD_INT 5
51378: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51379: LD_ADDR_OWVAR 40
51383: PUSH
51384: LD_INT 29
51386: ST_TO_ADDR
// un := CreateVehicle ;
51387: LD_ADDR_VAR 0 2
51391: PUSH
51392: CALL_OW 45
51396: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51397: LD_VAR 0 2
51401: PPUSH
51402: LD_INT 1
51404: PPUSH
51405: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51409: LD_INT 35
51411: PPUSH
51412: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51416: LD_VAR 0 2
51420: PPUSH
51421: LD_INT 22
51423: PUSH
51424: LD_OWVAR 2
51428: PUSH
51429: EMPTY
51430: LIST
51431: LIST
51432: PPUSH
51433: CALL_OW 69
51437: PPUSH
51438: LD_VAR 0 2
51442: PPUSH
51443: CALL_OW 74
51447: PPUSH
51448: CALL_OW 115
// until IsDead ( un ) ;
51452: LD_VAR 0 2
51456: PPUSH
51457: CALL_OW 301
51461: IFFALSE 51409
// end ;
51463: PPOPN 2
51465: END
// every 0 0$1 trigger StreamModeActive and sStu do
51466: LD_EXP 79
51470: PUSH
51471: LD_EXP 118
51475: AND
51476: IFFALSE 51492
51478: GO 51480
51480: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51481: LD_STRING displayStucuk();
51483: PPUSH
51484: CALL_OW 559
// ResetFog ;
51488: CALL_OW 335
// end ;
51492: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51493: LD_EXP 79
51497: PUSH
51498: LD_EXP 111
51502: AND
51503: IFFALSE 51644
51505: GO 51507
51507: DISABLE
51508: LD_INT 0
51510: PPUSH
51511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51512: LD_ADDR_VAR 0 2
51516: PUSH
51517: LD_INT 22
51519: PUSH
51520: LD_OWVAR 2
51524: PUSH
51525: EMPTY
51526: LIST
51527: LIST
51528: PUSH
51529: LD_INT 21
51531: PUSH
51532: LD_INT 1
51534: PUSH
51535: EMPTY
51536: LIST
51537: LIST
51538: PUSH
51539: EMPTY
51540: LIST
51541: LIST
51542: PPUSH
51543: CALL_OW 69
51547: ST_TO_ADDR
// if not tmp then
51548: LD_VAR 0 2
51552: NOT
51553: IFFALSE 51557
// exit ;
51555: GO 51644
// un := tmp [ rand ( 1 , tmp ) ] ;
51557: LD_ADDR_VAR 0 1
51561: PUSH
51562: LD_VAR 0 2
51566: PUSH
51567: LD_INT 1
51569: PPUSH
51570: LD_VAR 0 2
51574: PPUSH
51575: CALL_OW 12
51579: ARRAY
51580: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51581: LD_VAR 0 1
51585: PPUSH
51586: LD_INT 0
51588: PPUSH
51589: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51593: LD_VAR 0 1
51597: PPUSH
51598: LD_OWVAR 3
51602: PUSH
51603: LD_VAR 0 1
51607: DIFF
51608: PPUSH
51609: LD_VAR 0 1
51613: PPUSH
51614: CALL_OW 74
51618: PPUSH
51619: CALL_OW 115
// wait ( 0 0$20 ) ;
51623: LD_INT 700
51625: PPUSH
51626: CALL_OW 67
// SetSide ( un , your_side ) ;
51630: LD_VAR 0 1
51634: PPUSH
51635: LD_OWVAR 2
51639: PPUSH
51640: CALL_OW 235
// end ;
51644: PPOPN 2
51646: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51647: LD_EXP 79
51651: PUSH
51652: LD_EXP 112
51656: AND
51657: IFFALSE 51763
51659: GO 51661
51661: DISABLE
51662: LD_INT 0
51664: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51665: LD_ADDR_VAR 0 1
51669: PUSH
51670: LD_INT 22
51672: PUSH
51673: LD_OWVAR 2
51677: PUSH
51678: EMPTY
51679: LIST
51680: LIST
51681: PUSH
51682: LD_INT 2
51684: PUSH
51685: LD_INT 30
51687: PUSH
51688: LD_INT 0
51690: PUSH
51691: EMPTY
51692: LIST
51693: LIST
51694: PUSH
51695: LD_INT 30
51697: PUSH
51698: LD_INT 1
51700: PUSH
51701: EMPTY
51702: LIST
51703: LIST
51704: PUSH
51705: EMPTY
51706: LIST
51707: LIST
51708: LIST
51709: PUSH
51710: EMPTY
51711: LIST
51712: LIST
51713: PPUSH
51714: CALL_OW 69
51718: ST_TO_ADDR
// if not depot then
51719: LD_VAR 0 1
51723: NOT
51724: IFFALSE 51728
// exit ;
51726: GO 51763
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51728: LD_VAR 0 1
51732: PUSH
51733: LD_INT 1
51735: ARRAY
51736: PPUSH
51737: CALL_OW 250
51741: PPUSH
51742: LD_VAR 0 1
51746: PUSH
51747: LD_INT 1
51749: ARRAY
51750: PPUSH
51751: CALL_OW 251
51755: PPUSH
51756: LD_INT 70
51758: PPUSH
51759: CALL_OW 495
// end ;
51763: PPOPN 1
51765: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51766: LD_EXP 79
51770: PUSH
51771: LD_EXP 113
51775: AND
51776: IFFALSE 51987
51778: GO 51780
51780: DISABLE
51781: LD_INT 0
51783: PPUSH
51784: PPUSH
51785: PPUSH
51786: PPUSH
51787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51788: LD_ADDR_VAR 0 5
51792: PUSH
51793: LD_INT 22
51795: PUSH
51796: LD_OWVAR 2
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: PUSH
51805: LD_INT 21
51807: PUSH
51808: LD_INT 1
51810: PUSH
51811: EMPTY
51812: LIST
51813: LIST
51814: PUSH
51815: EMPTY
51816: LIST
51817: LIST
51818: PPUSH
51819: CALL_OW 69
51823: ST_TO_ADDR
// if not tmp then
51824: LD_VAR 0 5
51828: NOT
51829: IFFALSE 51833
// exit ;
51831: GO 51987
// for i in tmp do
51833: LD_ADDR_VAR 0 1
51837: PUSH
51838: LD_VAR 0 5
51842: PUSH
51843: FOR_IN
51844: IFFALSE 51985
// begin d := rand ( 0 , 5 ) ;
51846: LD_ADDR_VAR 0 4
51850: PUSH
51851: LD_INT 0
51853: PPUSH
51854: LD_INT 5
51856: PPUSH
51857: CALL_OW 12
51861: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
51862: LD_ADDR_VAR 0 2
51866: PUSH
51867: LD_VAR 0 1
51871: PPUSH
51872: CALL_OW 250
51876: PPUSH
51877: LD_VAR 0 4
51881: PPUSH
51882: LD_INT 3
51884: PPUSH
51885: LD_INT 12
51887: PPUSH
51888: CALL_OW 12
51892: PPUSH
51893: CALL_OW 272
51897: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
51898: LD_ADDR_VAR 0 3
51902: PUSH
51903: LD_VAR 0 1
51907: PPUSH
51908: CALL_OW 251
51912: PPUSH
51913: LD_VAR 0 4
51917: PPUSH
51918: LD_INT 3
51920: PPUSH
51921: LD_INT 12
51923: PPUSH
51924: CALL_OW 12
51928: PPUSH
51929: CALL_OW 273
51933: ST_TO_ADDR
// if ValidHex ( x , y ) then
51934: LD_VAR 0 2
51938: PPUSH
51939: LD_VAR 0 3
51943: PPUSH
51944: CALL_OW 488
51948: IFFALSE 51983
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
51950: LD_VAR 0 1
51954: PPUSH
51955: LD_VAR 0 2
51959: PPUSH
51960: LD_VAR 0 3
51964: PPUSH
51965: LD_INT 3
51967: PPUSH
51968: LD_INT 6
51970: PPUSH
51971: CALL_OW 12
51975: PPUSH
51976: LD_INT 1
51978: PPUSH
51979: CALL_OW 483
// end ;
51983: GO 51843
51985: POP
51986: POP
// end ;
51987: PPOPN 5
51989: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
51990: LD_EXP 79
51994: PUSH
51995: LD_EXP 114
51999: AND
52000: IFFALSE 52094
52002: GO 52004
52004: DISABLE
52005: LD_INT 0
52007: PPUSH
52008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52009: LD_ADDR_VAR 0 2
52013: PUSH
52014: LD_INT 22
52016: PUSH
52017: LD_OWVAR 2
52021: PUSH
52022: EMPTY
52023: LIST
52024: LIST
52025: PUSH
52026: LD_INT 32
52028: PUSH
52029: LD_INT 1
52031: PUSH
52032: EMPTY
52033: LIST
52034: LIST
52035: PUSH
52036: LD_INT 21
52038: PUSH
52039: LD_INT 2
52041: PUSH
52042: EMPTY
52043: LIST
52044: LIST
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: LIST
52050: PPUSH
52051: CALL_OW 69
52055: ST_TO_ADDR
// if not tmp then
52056: LD_VAR 0 2
52060: NOT
52061: IFFALSE 52065
// exit ;
52063: GO 52094
// for i in tmp do
52065: LD_ADDR_VAR 0 1
52069: PUSH
52070: LD_VAR 0 2
52074: PUSH
52075: FOR_IN
52076: IFFALSE 52092
// SetFuel ( i , 0 ) ;
52078: LD_VAR 0 1
52082: PPUSH
52083: LD_INT 0
52085: PPUSH
52086: CALL_OW 240
52090: GO 52075
52092: POP
52093: POP
// end ;
52094: PPOPN 2
52096: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52097: LD_EXP 79
52101: PUSH
52102: LD_EXP 115
52106: AND
52107: IFFALSE 52173
52109: GO 52111
52111: DISABLE
52112: LD_INT 0
52114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52115: LD_ADDR_VAR 0 1
52119: PUSH
52120: LD_INT 22
52122: PUSH
52123: LD_OWVAR 2
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: PUSH
52132: LD_INT 30
52134: PUSH
52135: LD_INT 29
52137: PUSH
52138: EMPTY
52139: LIST
52140: LIST
52141: PUSH
52142: EMPTY
52143: LIST
52144: LIST
52145: PPUSH
52146: CALL_OW 69
52150: ST_TO_ADDR
// if not tmp then
52151: LD_VAR 0 1
52155: NOT
52156: IFFALSE 52160
// exit ;
52158: GO 52173
// DestroyUnit ( tmp [ 1 ] ) ;
52160: LD_VAR 0 1
52164: PUSH
52165: LD_INT 1
52167: ARRAY
52168: PPUSH
52169: CALL_OW 65
// end ;
52173: PPOPN 1
52175: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52176: LD_EXP 79
52180: PUSH
52181: LD_EXP 117
52185: AND
52186: IFFALSE 52315
52188: GO 52190
52190: DISABLE
52191: LD_INT 0
52193: PPUSH
// begin uc_side := 0 ;
52194: LD_ADDR_OWVAR 20
52198: PUSH
52199: LD_INT 0
52201: ST_TO_ADDR
// uc_nation := nation_arabian ;
52202: LD_ADDR_OWVAR 21
52206: PUSH
52207: LD_INT 2
52209: ST_TO_ADDR
// hc_gallery :=  ;
52210: LD_ADDR_OWVAR 33
52214: PUSH
52215: LD_STRING 
52217: ST_TO_ADDR
// hc_name :=  ;
52218: LD_ADDR_OWVAR 26
52222: PUSH
52223: LD_STRING 
52225: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52226: LD_INT 1
52228: PPUSH
52229: LD_INT 11
52231: PPUSH
52232: LD_INT 10
52234: PPUSH
52235: CALL_OW 380
// un := CreateHuman ;
52239: LD_ADDR_VAR 0 1
52243: PUSH
52244: CALL_OW 44
52248: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52249: LD_VAR 0 1
52253: PPUSH
52254: LD_INT 1
52256: PPUSH
52257: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52261: LD_INT 35
52263: PPUSH
52264: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52268: LD_VAR 0 1
52272: PPUSH
52273: LD_INT 22
52275: PUSH
52276: LD_OWVAR 2
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PPUSH
52285: CALL_OW 69
52289: PPUSH
52290: LD_VAR 0 1
52294: PPUSH
52295: CALL_OW 74
52299: PPUSH
52300: CALL_OW 115
// until IsDead ( un ) ;
52304: LD_VAR 0 1
52308: PPUSH
52309: CALL_OW 301
52313: IFFALSE 52261
// end ;
52315: PPOPN 1
52317: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52318: LD_EXP 79
52322: PUSH
52323: LD_EXP 119
52327: AND
52328: IFFALSE 52340
52330: GO 52332
52332: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52333: LD_STRING earthquake(getX(game), 0, 32)
52335: PPUSH
52336: CALL_OW 559
52340: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52341: LD_EXP 79
52345: PUSH
52346: LD_EXP 120
52350: AND
52351: IFFALSE 52442
52353: GO 52355
52355: DISABLE
52356: LD_INT 0
52358: PPUSH
// begin enable ;
52359: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52360: LD_ADDR_VAR 0 1
52364: PUSH
52365: LD_INT 22
52367: PUSH
52368: LD_OWVAR 2
52372: PUSH
52373: EMPTY
52374: LIST
52375: LIST
52376: PUSH
52377: LD_INT 21
52379: PUSH
52380: LD_INT 2
52382: PUSH
52383: EMPTY
52384: LIST
52385: LIST
52386: PUSH
52387: LD_INT 33
52389: PUSH
52390: LD_INT 3
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: LIST
52401: PPUSH
52402: CALL_OW 69
52406: ST_TO_ADDR
// if not tmp then
52407: LD_VAR 0 1
52411: NOT
52412: IFFALSE 52416
// exit ;
52414: GO 52442
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52416: LD_VAR 0 1
52420: PUSH
52421: LD_INT 1
52423: PPUSH
52424: LD_VAR 0 1
52428: PPUSH
52429: CALL_OW 12
52433: ARRAY
52434: PPUSH
52435: LD_INT 1
52437: PPUSH
52438: CALL_OW 234
// end ;
52442: PPOPN 1
52444: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52445: LD_EXP 79
52449: PUSH
52450: LD_EXP 121
52454: AND
52455: IFFALSE 52596
52457: GO 52459
52459: DISABLE
52460: LD_INT 0
52462: PPUSH
52463: PPUSH
52464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52465: LD_ADDR_VAR 0 3
52469: PUSH
52470: LD_INT 22
52472: PUSH
52473: LD_OWVAR 2
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: PUSH
52482: LD_INT 25
52484: PUSH
52485: LD_INT 1
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: PPUSH
52496: CALL_OW 69
52500: ST_TO_ADDR
// if not tmp then
52501: LD_VAR 0 3
52505: NOT
52506: IFFALSE 52510
// exit ;
52508: GO 52596
// un := tmp [ rand ( 1 , tmp ) ] ;
52510: LD_ADDR_VAR 0 2
52514: PUSH
52515: LD_VAR 0 3
52519: PUSH
52520: LD_INT 1
52522: PPUSH
52523: LD_VAR 0 3
52527: PPUSH
52528: CALL_OW 12
52532: ARRAY
52533: ST_TO_ADDR
// if Crawls ( un ) then
52534: LD_VAR 0 2
52538: PPUSH
52539: CALL_OW 318
52543: IFFALSE 52554
// ComWalk ( un ) ;
52545: LD_VAR 0 2
52549: PPUSH
52550: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52554: LD_VAR 0 2
52558: PPUSH
52559: LD_INT 9
52561: PPUSH
52562: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52566: LD_INT 28
52568: PPUSH
52569: LD_OWVAR 2
52573: PPUSH
52574: LD_INT 2
52576: PPUSH
52577: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52581: LD_INT 29
52583: PPUSH
52584: LD_OWVAR 2
52588: PPUSH
52589: LD_INT 2
52591: PPUSH
52592: CALL_OW 322
// end ;
52596: PPOPN 3
52598: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52599: LD_EXP 79
52603: PUSH
52604: LD_EXP 122
52608: AND
52609: IFFALSE 52720
52611: GO 52613
52613: DISABLE
52614: LD_INT 0
52616: PPUSH
52617: PPUSH
52618: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52619: LD_ADDR_VAR 0 3
52623: PUSH
52624: LD_INT 22
52626: PUSH
52627: LD_OWVAR 2
52631: PUSH
52632: EMPTY
52633: LIST
52634: LIST
52635: PUSH
52636: LD_INT 25
52638: PUSH
52639: LD_INT 1
52641: PUSH
52642: EMPTY
52643: LIST
52644: LIST
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: PPUSH
52650: CALL_OW 69
52654: ST_TO_ADDR
// if not tmp then
52655: LD_VAR 0 3
52659: NOT
52660: IFFALSE 52664
// exit ;
52662: GO 52720
// un := tmp [ rand ( 1 , tmp ) ] ;
52664: LD_ADDR_VAR 0 2
52668: PUSH
52669: LD_VAR 0 3
52673: PUSH
52674: LD_INT 1
52676: PPUSH
52677: LD_VAR 0 3
52681: PPUSH
52682: CALL_OW 12
52686: ARRAY
52687: ST_TO_ADDR
// if Crawls ( un ) then
52688: LD_VAR 0 2
52692: PPUSH
52693: CALL_OW 318
52697: IFFALSE 52708
// ComWalk ( un ) ;
52699: LD_VAR 0 2
52703: PPUSH
52704: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52708: LD_VAR 0 2
52712: PPUSH
52713: LD_INT 8
52715: PPUSH
52716: CALL_OW 336
// end ;
52720: PPOPN 3
52722: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52723: LD_EXP 79
52727: PUSH
52728: LD_EXP 123
52732: AND
52733: IFFALSE 52877
52735: GO 52737
52737: DISABLE
52738: LD_INT 0
52740: PPUSH
52741: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52742: LD_ADDR_VAR 0 2
52746: PUSH
52747: LD_INT 22
52749: PUSH
52750: LD_OWVAR 2
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PUSH
52759: LD_INT 21
52761: PUSH
52762: LD_INT 2
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: PUSH
52769: LD_INT 2
52771: PUSH
52772: LD_INT 34
52774: PUSH
52775: LD_INT 12
52777: PUSH
52778: EMPTY
52779: LIST
52780: LIST
52781: PUSH
52782: LD_INT 34
52784: PUSH
52785: LD_INT 51
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: PUSH
52792: LD_INT 34
52794: PUSH
52795: LD_INT 32
52797: PUSH
52798: EMPTY
52799: LIST
52800: LIST
52801: PUSH
52802: EMPTY
52803: LIST
52804: LIST
52805: LIST
52806: LIST
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: LIST
52812: PPUSH
52813: CALL_OW 69
52817: ST_TO_ADDR
// if not tmp then
52818: LD_VAR 0 2
52822: NOT
52823: IFFALSE 52827
// exit ;
52825: GO 52877
// for i in tmp do
52827: LD_ADDR_VAR 0 1
52831: PUSH
52832: LD_VAR 0 2
52836: PUSH
52837: FOR_IN
52838: IFFALSE 52875
// if GetCargo ( i , mat_artifact ) = 0 then
52840: LD_VAR 0 1
52844: PPUSH
52845: LD_INT 4
52847: PPUSH
52848: CALL_OW 289
52852: PUSH
52853: LD_INT 0
52855: EQUAL
52856: IFFALSE 52873
// SetCargo ( i , mat_siberit , 100 ) ;
52858: LD_VAR 0 1
52862: PPUSH
52863: LD_INT 3
52865: PPUSH
52866: LD_INT 100
52868: PPUSH
52869: CALL_OW 290
52873: GO 52837
52875: POP
52876: POP
// end ;
52877: PPOPN 2
52879: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
52880: LD_EXP 79
52884: PUSH
52885: LD_EXP 124
52889: AND
52890: IFFALSE 53043
52892: GO 52894
52894: DISABLE
52895: LD_INT 0
52897: PPUSH
52898: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
52899: LD_ADDR_VAR 0 2
52903: PUSH
52904: LD_INT 22
52906: PUSH
52907: LD_OWVAR 2
52911: PUSH
52912: EMPTY
52913: LIST
52914: LIST
52915: PPUSH
52916: CALL_OW 69
52920: ST_TO_ADDR
// if not tmp then
52921: LD_VAR 0 2
52925: NOT
52926: IFFALSE 52930
// exit ;
52928: GO 53043
// for i := 1 to 2 do
52930: LD_ADDR_VAR 0 1
52934: PUSH
52935: DOUBLE
52936: LD_INT 1
52938: DEC
52939: ST_TO_ADDR
52940: LD_INT 2
52942: PUSH
52943: FOR_TO
52944: IFFALSE 53041
// begin uc_side := your_side ;
52946: LD_ADDR_OWVAR 20
52950: PUSH
52951: LD_OWVAR 2
52955: ST_TO_ADDR
// uc_nation := nation_american ;
52956: LD_ADDR_OWVAR 21
52960: PUSH
52961: LD_INT 1
52963: ST_TO_ADDR
// vc_chassis := us_morphling ;
52964: LD_ADDR_OWVAR 37
52968: PUSH
52969: LD_INT 5
52971: ST_TO_ADDR
// vc_engine := engine_siberite ;
52972: LD_ADDR_OWVAR 39
52976: PUSH
52977: LD_INT 3
52979: ST_TO_ADDR
// vc_control := control_computer ;
52980: LD_ADDR_OWVAR 38
52984: PUSH
52985: LD_INT 3
52987: ST_TO_ADDR
// vc_weapon := us_double_laser ;
52988: LD_ADDR_OWVAR 40
52992: PUSH
52993: LD_INT 10
52995: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
52996: CALL_OW 45
53000: PPUSH
53001: LD_VAR 0 2
53005: PUSH
53006: LD_INT 1
53008: ARRAY
53009: PPUSH
53010: CALL_OW 250
53014: PPUSH
53015: LD_VAR 0 2
53019: PUSH
53020: LD_INT 1
53022: ARRAY
53023: PPUSH
53024: CALL_OW 251
53028: PPUSH
53029: LD_INT 12
53031: PPUSH
53032: LD_INT 1
53034: PPUSH
53035: CALL_OW 50
// end ;
53039: GO 52943
53041: POP
53042: POP
// end ;
53043: PPOPN 2
53045: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53046: LD_EXP 79
53050: PUSH
53051: LD_EXP 125
53055: AND
53056: IFFALSE 53278
53058: GO 53060
53060: DISABLE
53061: LD_INT 0
53063: PPUSH
53064: PPUSH
53065: PPUSH
53066: PPUSH
53067: PPUSH
53068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53069: LD_ADDR_VAR 0 6
53073: PUSH
53074: LD_INT 22
53076: PUSH
53077: LD_OWVAR 2
53081: PUSH
53082: EMPTY
53083: LIST
53084: LIST
53085: PUSH
53086: LD_INT 21
53088: PUSH
53089: LD_INT 1
53091: PUSH
53092: EMPTY
53093: LIST
53094: LIST
53095: PUSH
53096: LD_INT 3
53098: PUSH
53099: LD_INT 23
53101: PUSH
53102: LD_INT 0
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: LIST
53117: PPUSH
53118: CALL_OW 69
53122: ST_TO_ADDR
// if not tmp then
53123: LD_VAR 0 6
53127: NOT
53128: IFFALSE 53132
// exit ;
53130: GO 53278
// s1 := rand ( 1 , 4 ) ;
53132: LD_ADDR_VAR 0 2
53136: PUSH
53137: LD_INT 1
53139: PPUSH
53140: LD_INT 4
53142: PPUSH
53143: CALL_OW 12
53147: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53148: LD_ADDR_VAR 0 4
53152: PUSH
53153: LD_VAR 0 6
53157: PUSH
53158: LD_INT 1
53160: ARRAY
53161: PPUSH
53162: LD_VAR 0 2
53166: PPUSH
53167: CALL_OW 259
53171: ST_TO_ADDR
// if s1 = 1 then
53172: LD_VAR 0 2
53176: PUSH
53177: LD_INT 1
53179: EQUAL
53180: IFFALSE 53200
// s2 := rand ( 2 , 4 ) else
53182: LD_ADDR_VAR 0 3
53186: PUSH
53187: LD_INT 2
53189: PPUSH
53190: LD_INT 4
53192: PPUSH
53193: CALL_OW 12
53197: ST_TO_ADDR
53198: GO 53208
// s2 := 1 ;
53200: LD_ADDR_VAR 0 3
53204: PUSH
53205: LD_INT 1
53207: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53208: LD_ADDR_VAR 0 5
53212: PUSH
53213: LD_VAR 0 6
53217: PUSH
53218: LD_INT 1
53220: ARRAY
53221: PPUSH
53222: LD_VAR 0 3
53226: PPUSH
53227: CALL_OW 259
53231: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53232: LD_VAR 0 6
53236: PUSH
53237: LD_INT 1
53239: ARRAY
53240: PPUSH
53241: LD_VAR 0 2
53245: PPUSH
53246: LD_VAR 0 5
53250: PPUSH
53251: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53255: LD_VAR 0 6
53259: PUSH
53260: LD_INT 1
53262: ARRAY
53263: PPUSH
53264: LD_VAR 0 3
53268: PPUSH
53269: LD_VAR 0 4
53273: PPUSH
53274: CALL_OW 237
// end ;
53278: PPOPN 6
53280: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53281: LD_EXP 79
53285: PUSH
53286: LD_EXP 126
53290: AND
53291: IFFALSE 53370
53293: GO 53295
53295: DISABLE
53296: LD_INT 0
53298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53299: LD_ADDR_VAR 0 1
53303: PUSH
53304: LD_INT 22
53306: PUSH
53307: LD_OWVAR 2
53311: PUSH
53312: EMPTY
53313: LIST
53314: LIST
53315: PUSH
53316: LD_INT 30
53318: PUSH
53319: LD_INT 3
53321: PUSH
53322: EMPTY
53323: LIST
53324: LIST
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PPUSH
53330: CALL_OW 69
53334: ST_TO_ADDR
// if not tmp then
53335: LD_VAR 0 1
53339: NOT
53340: IFFALSE 53344
// exit ;
53342: GO 53370
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53344: LD_VAR 0 1
53348: PUSH
53349: LD_INT 1
53351: PPUSH
53352: LD_VAR 0 1
53356: PPUSH
53357: CALL_OW 12
53361: ARRAY
53362: PPUSH
53363: LD_INT 1
53365: PPUSH
53366: CALL_OW 234
// end ;
53370: PPOPN 1
53372: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53373: LD_EXP 79
53377: PUSH
53378: LD_EXP 127
53382: AND
53383: IFFALSE 53495
53385: GO 53387
53387: DISABLE
53388: LD_INT 0
53390: PPUSH
53391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53392: LD_ADDR_VAR 0 2
53396: PUSH
53397: LD_INT 22
53399: PUSH
53400: LD_OWVAR 2
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: PUSH
53409: LD_INT 2
53411: PUSH
53412: LD_INT 30
53414: PUSH
53415: LD_INT 27
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: PUSH
53422: LD_INT 30
53424: PUSH
53425: LD_INT 26
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: PUSH
53432: LD_INT 30
53434: PUSH
53435: LD_INT 28
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: LIST
53446: LIST
53447: PUSH
53448: EMPTY
53449: LIST
53450: LIST
53451: PPUSH
53452: CALL_OW 69
53456: ST_TO_ADDR
// if not tmp then
53457: LD_VAR 0 2
53461: NOT
53462: IFFALSE 53466
// exit ;
53464: GO 53495
// for i in tmp do
53466: LD_ADDR_VAR 0 1
53470: PUSH
53471: LD_VAR 0 2
53475: PUSH
53476: FOR_IN
53477: IFFALSE 53493
// SetLives ( i , 1 ) ;
53479: LD_VAR 0 1
53483: PPUSH
53484: LD_INT 1
53486: PPUSH
53487: CALL_OW 234
53491: GO 53476
53493: POP
53494: POP
// end ;
53495: PPOPN 2
53497: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53498: LD_EXP 79
53502: PUSH
53503: LD_EXP 128
53507: AND
53508: IFFALSE 53782
53510: GO 53512
53512: DISABLE
53513: LD_INT 0
53515: PPUSH
53516: PPUSH
53517: PPUSH
// begin i := rand ( 1 , 7 ) ;
53518: LD_ADDR_VAR 0 1
53522: PUSH
53523: LD_INT 1
53525: PPUSH
53526: LD_INT 7
53528: PPUSH
53529: CALL_OW 12
53533: ST_TO_ADDR
// case i of 1 :
53534: LD_VAR 0 1
53538: PUSH
53539: LD_INT 1
53541: DOUBLE
53542: EQUAL
53543: IFTRUE 53547
53545: GO 53557
53547: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53548: LD_STRING earthquake(getX(game), 0, 32)
53550: PPUSH
53551: CALL_OW 559
53555: GO 53782
53557: LD_INT 2
53559: DOUBLE
53560: EQUAL
53561: IFTRUE 53565
53563: GO 53579
53565: POP
// begin ToLua ( displayStucuk(); ) ;
53566: LD_STRING displayStucuk();
53568: PPUSH
53569: CALL_OW 559
// ResetFog ;
53573: CALL_OW 335
// end ; 3 :
53577: GO 53782
53579: LD_INT 3
53581: DOUBLE
53582: EQUAL
53583: IFTRUE 53587
53585: GO 53691
53587: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53588: LD_ADDR_VAR 0 2
53592: PUSH
53593: LD_INT 22
53595: PUSH
53596: LD_OWVAR 2
53600: PUSH
53601: EMPTY
53602: LIST
53603: LIST
53604: PUSH
53605: LD_INT 25
53607: PUSH
53608: LD_INT 1
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: PUSH
53615: EMPTY
53616: LIST
53617: LIST
53618: PPUSH
53619: CALL_OW 69
53623: ST_TO_ADDR
// if not tmp then
53624: LD_VAR 0 2
53628: NOT
53629: IFFALSE 53633
// exit ;
53631: GO 53782
// un := tmp [ rand ( 1 , tmp ) ] ;
53633: LD_ADDR_VAR 0 3
53637: PUSH
53638: LD_VAR 0 2
53642: PUSH
53643: LD_INT 1
53645: PPUSH
53646: LD_VAR 0 2
53650: PPUSH
53651: CALL_OW 12
53655: ARRAY
53656: ST_TO_ADDR
// if Crawls ( un ) then
53657: LD_VAR 0 3
53661: PPUSH
53662: CALL_OW 318
53666: IFFALSE 53677
// ComWalk ( un ) ;
53668: LD_VAR 0 3
53672: PPUSH
53673: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53677: LD_VAR 0 3
53681: PPUSH
53682: LD_INT 8
53684: PPUSH
53685: CALL_OW 336
// end ; 4 :
53689: GO 53782
53691: LD_INT 4
53693: DOUBLE
53694: EQUAL
53695: IFTRUE 53699
53697: GO 53760
53699: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53700: LD_ADDR_VAR 0 2
53704: PUSH
53705: LD_INT 22
53707: PUSH
53708: LD_OWVAR 2
53712: PUSH
53713: EMPTY
53714: LIST
53715: LIST
53716: PUSH
53717: LD_INT 30
53719: PUSH
53720: LD_INT 29
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: PUSH
53727: EMPTY
53728: LIST
53729: LIST
53730: PPUSH
53731: CALL_OW 69
53735: ST_TO_ADDR
// if not tmp then
53736: LD_VAR 0 2
53740: NOT
53741: IFFALSE 53745
// exit ;
53743: GO 53782
// DestroyUnit ( tmp [ 1 ] ) ;
53745: LD_VAR 0 2
53749: PUSH
53750: LD_INT 1
53752: ARRAY
53753: PPUSH
53754: CALL_OW 65
// end ; 5 .. 7 :
53758: GO 53782
53760: LD_INT 5
53762: DOUBLE
53763: GREATEREQUAL
53764: IFFALSE 53772
53766: LD_INT 7
53768: DOUBLE
53769: LESSEQUAL
53770: IFTRUE 53774
53772: GO 53781
53774: POP
// StreamSibBomb ; end ;
53775: CALL 50062 0 0
53779: GO 53782
53781: POP
// end ;
53782: PPOPN 3
53784: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53785: LD_EXP 79
53789: PUSH
53790: LD_EXP 129
53794: AND
53795: IFFALSE 53951
53797: GO 53799
53799: DISABLE
53800: LD_INT 0
53802: PPUSH
53803: PPUSH
53804: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
53805: LD_ADDR_VAR 0 2
53809: PUSH
53810: LD_INT 81
53812: PUSH
53813: LD_OWVAR 2
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: PUSH
53822: LD_INT 2
53824: PUSH
53825: LD_INT 21
53827: PUSH
53828: LD_INT 1
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: PUSH
53835: LD_INT 21
53837: PUSH
53838: LD_INT 2
53840: PUSH
53841: EMPTY
53842: LIST
53843: LIST
53844: PUSH
53845: EMPTY
53846: LIST
53847: LIST
53848: LIST
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: PPUSH
53854: CALL_OW 69
53858: ST_TO_ADDR
// if not tmp then
53859: LD_VAR 0 2
53863: NOT
53864: IFFALSE 53868
// exit ;
53866: GO 53951
// p := 0 ;
53868: LD_ADDR_VAR 0 3
53872: PUSH
53873: LD_INT 0
53875: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53876: LD_INT 35
53878: PPUSH
53879: CALL_OW 67
// p := p + 1 ;
53883: LD_ADDR_VAR 0 3
53887: PUSH
53888: LD_VAR 0 3
53892: PUSH
53893: LD_INT 1
53895: PLUS
53896: ST_TO_ADDR
// for i in tmp do
53897: LD_ADDR_VAR 0 1
53901: PUSH
53902: LD_VAR 0 2
53906: PUSH
53907: FOR_IN
53908: IFFALSE 53939
// if GetLives ( i ) < 1000 then
53910: LD_VAR 0 1
53914: PPUSH
53915: CALL_OW 256
53919: PUSH
53920: LD_INT 1000
53922: LESS
53923: IFFALSE 53937
// SetLives ( i , 1000 ) ;
53925: LD_VAR 0 1
53929: PPUSH
53930: LD_INT 1000
53932: PPUSH
53933: CALL_OW 234
53937: GO 53907
53939: POP
53940: POP
// until p > 20 ;
53941: LD_VAR 0 3
53945: PUSH
53946: LD_INT 20
53948: GREATER
53949: IFFALSE 53876
// end ;
53951: PPOPN 3
53953: END
// every 0 0$1 trigger StreamModeActive and sTime do
53954: LD_EXP 79
53958: PUSH
53959: LD_EXP 130
53963: AND
53964: IFFALSE 53999
53966: GO 53968
53968: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
53969: LD_INT 28
53971: PPUSH
53972: LD_OWVAR 2
53976: PPUSH
53977: LD_INT 2
53979: PPUSH
53980: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
53984: LD_INT 30
53986: PPUSH
53987: LD_OWVAR 2
53991: PPUSH
53992: LD_INT 2
53994: PPUSH
53995: CALL_OW 322
// end ;
53999: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54000: LD_EXP 79
54004: PUSH
54005: LD_EXP 131
54009: AND
54010: IFFALSE 54131
54012: GO 54014
54014: DISABLE
54015: LD_INT 0
54017: PPUSH
54018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54019: LD_ADDR_VAR 0 2
54023: PUSH
54024: LD_INT 22
54026: PUSH
54027: LD_OWVAR 2
54031: PUSH
54032: EMPTY
54033: LIST
54034: LIST
54035: PUSH
54036: LD_INT 21
54038: PUSH
54039: LD_INT 1
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: PUSH
54046: LD_INT 3
54048: PUSH
54049: LD_INT 23
54051: PUSH
54052: LD_INT 0
54054: PUSH
54055: EMPTY
54056: LIST
54057: LIST
54058: PUSH
54059: EMPTY
54060: LIST
54061: LIST
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: PPUSH
54068: CALL_OW 69
54072: ST_TO_ADDR
// if not tmp then
54073: LD_VAR 0 2
54077: NOT
54078: IFFALSE 54082
// exit ;
54080: GO 54131
// for i in tmp do
54082: LD_ADDR_VAR 0 1
54086: PUSH
54087: LD_VAR 0 2
54091: PUSH
54092: FOR_IN
54093: IFFALSE 54129
// begin if Crawls ( i ) then
54095: LD_VAR 0 1
54099: PPUSH
54100: CALL_OW 318
54104: IFFALSE 54115
// ComWalk ( i ) ;
54106: LD_VAR 0 1
54110: PPUSH
54111: CALL_OW 138
// SetClass ( i , 2 ) ;
54115: LD_VAR 0 1
54119: PPUSH
54120: LD_INT 2
54122: PPUSH
54123: CALL_OW 336
// end ;
54127: GO 54092
54129: POP
54130: POP
// end ;
54131: PPOPN 2
54133: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54134: LD_EXP 79
54138: PUSH
54139: LD_EXP 132
54143: AND
54144: IFFALSE 54425
54146: GO 54148
54148: DISABLE
54149: LD_INT 0
54151: PPUSH
54152: PPUSH
54153: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54154: LD_OWVAR 2
54158: PPUSH
54159: LD_INT 9
54161: PPUSH
54162: LD_INT 1
54164: PPUSH
54165: LD_INT 1
54167: PPUSH
54168: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54172: LD_INT 9
54174: PPUSH
54175: LD_OWVAR 2
54179: PPUSH
54180: CALL_OW 343
// uc_side := 9 ;
54184: LD_ADDR_OWVAR 20
54188: PUSH
54189: LD_INT 9
54191: ST_TO_ADDR
// uc_nation := 2 ;
54192: LD_ADDR_OWVAR 21
54196: PUSH
54197: LD_INT 2
54199: ST_TO_ADDR
// hc_name := Dark Warrior ;
54200: LD_ADDR_OWVAR 26
54204: PUSH
54205: LD_STRING Dark Warrior
54207: ST_TO_ADDR
// hc_gallery :=  ;
54208: LD_ADDR_OWVAR 33
54212: PUSH
54213: LD_STRING 
54215: ST_TO_ADDR
// hc_noskilllimit := true ;
54216: LD_ADDR_OWVAR 76
54220: PUSH
54221: LD_INT 1
54223: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54224: LD_ADDR_OWVAR 31
54228: PUSH
54229: LD_INT 30
54231: PUSH
54232: LD_INT 30
54234: PUSH
54235: LD_INT 30
54237: PUSH
54238: LD_INT 30
54240: PUSH
54241: EMPTY
54242: LIST
54243: LIST
54244: LIST
54245: LIST
54246: ST_TO_ADDR
// un := CreateHuman ;
54247: LD_ADDR_VAR 0 3
54251: PUSH
54252: CALL_OW 44
54256: ST_TO_ADDR
// hc_noskilllimit := false ;
54257: LD_ADDR_OWVAR 76
54261: PUSH
54262: LD_INT 0
54264: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54265: LD_VAR 0 3
54269: PPUSH
54270: LD_INT 1
54272: PPUSH
54273: CALL_OW 51
// p := 0 ;
54277: LD_ADDR_VAR 0 2
54281: PUSH
54282: LD_INT 0
54284: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54285: LD_INT 35
54287: PPUSH
54288: CALL_OW 67
// p := p + 1 ;
54292: LD_ADDR_VAR 0 2
54296: PUSH
54297: LD_VAR 0 2
54301: PUSH
54302: LD_INT 1
54304: PLUS
54305: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54306: LD_VAR 0 3
54310: PPUSH
54311: CALL_OW 256
54315: PUSH
54316: LD_INT 1000
54318: LESS
54319: IFFALSE 54333
// SetLives ( un , 1000 ) ;
54321: LD_VAR 0 3
54325: PPUSH
54326: LD_INT 1000
54328: PPUSH
54329: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54333: LD_VAR 0 3
54337: PPUSH
54338: LD_INT 81
54340: PUSH
54341: LD_OWVAR 2
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: PUSH
54350: LD_INT 91
54352: PUSH
54353: LD_VAR 0 3
54357: PUSH
54358: LD_INT 30
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: LIST
54365: PUSH
54366: EMPTY
54367: LIST
54368: LIST
54369: PPUSH
54370: CALL_OW 69
54374: PPUSH
54375: LD_VAR 0 3
54379: PPUSH
54380: CALL_OW 74
54384: PPUSH
54385: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54389: LD_VAR 0 2
54393: PUSH
54394: LD_INT 60
54396: GREATER
54397: PUSH
54398: LD_VAR 0 3
54402: PPUSH
54403: CALL_OW 301
54407: OR
54408: IFFALSE 54285
// if un then
54410: LD_VAR 0 3
54414: IFFALSE 54425
// RemoveUnit ( un ) ;
54416: LD_VAR 0 3
54420: PPUSH
54421: CALL_OW 64
// end ; end_of_file
54425: PPOPN 3
54427: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
54428: LD_INT 0
54430: PPUSH
54431: PPUSH
54432: PPUSH
54433: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
54434: LD_VAR 0 1
54438: PPUSH
54439: CALL_OW 264
54443: PUSH
54444: LD_EXP 78
54448: EQUAL
54449: IFFALSE 54521
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
54451: LD_INT 68
54453: PPUSH
54454: LD_VAR 0 1
54458: PPUSH
54459: CALL_OW 255
54463: PPUSH
54464: CALL_OW 321
54468: PUSH
54469: LD_INT 2
54471: EQUAL
54472: IFFALSE 54484
// eff := 70 else
54474: LD_ADDR_VAR 0 4
54478: PUSH
54479: LD_INT 70
54481: ST_TO_ADDR
54482: GO 54492
// eff := 30 ;
54484: LD_ADDR_VAR 0 4
54488: PUSH
54489: LD_INT 30
54491: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
54492: LD_VAR 0 1
54496: PPUSH
54497: CALL_OW 250
54501: PPUSH
54502: LD_VAR 0 1
54506: PPUSH
54507: CALL_OW 251
54511: PPUSH
54512: LD_VAR 0 4
54516: PPUSH
54517: CALL_OW 495
// end ; end ;
54521: LD_VAR 0 2
54525: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
54526: LD_INT 0
54528: PPUSH
// end ;
54529: LD_VAR 0 4
54533: RET
// export function SOS_Command ( cmd ) ; begin
54534: LD_INT 0
54536: PPUSH
// end ;
54537: LD_VAR 0 2
54541: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
54542: LD_VAR 0 1
54546: PUSH
54547: LD_INT 255
54549: EQUAL
54550: PUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: CALL_OW 264
54560: PUSH
54561: LD_INT 14
54563: PUSH
54564: LD_INT 53
54566: PUSH
54567: EMPTY
54568: LIST
54569: LIST
54570: IN
54571: AND
54572: PUSH
54573: LD_VAR 0 4
54577: PPUSH
54578: LD_VAR 0 5
54582: PPUSH
54583: CALL_OW 488
54587: AND
54588: IFFALSE 54612
// CutTreeXYR ( unit , x , y , 12 ) ;
54590: LD_VAR 0 2
54594: PPUSH
54595: LD_VAR 0 4
54599: PPUSH
54600: LD_VAR 0 5
54604: PPUSH
54605: LD_INT 12
54607: PPUSH
54608: CALL 54615 0 4
// end ;
54612: PPOPN 5
54614: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
54615: LD_INT 0
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
54622: PPUSH
54623: PPUSH
54624: PPUSH
54625: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
54626: LD_VAR 0 1
54630: NOT
54631: PUSH
54632: LD_VAR 0 2
54636: PPUSH
54637: LD_VAR 0 3
54641: PPUSH
54642: CALL_OW 488
54646: NOT
54647: OR
54648: PUSH
54649: LD_VAR 0 4
54653: NOT
54654: OR
54655: IFFALSE 54659
// exit ;
54657: GO 54999
// list := [ ] ;
54659: LD_ADDR_VAR 0 13
54663: PUSH
54664: EMPTY
54665: ST_TO_ADDR
// if x - r < 0 then
54666: LD_VAR 0 2
54670: PUSH
54671: LD_VAR 0 4
54675: MINUS
54676: PUSH
54677: LD_INT 0
54679: LESS
54680: IFFALSE 54692
// min_x := 0 else
54682: LD_ADDR_VAR 0 7
54686: PUSH
54687: LD_INT 0
54689: ST_TO_ADDR
54690: GO 54708
// min_x := x - r ;
54692: LD_ADDR_VAR 0 7
54696: PUSH
54697: LD_VAR 0 2
54701: PUSH
54702: LD_VAR 0 4
54706: MINUS
54707: ST_TO_ADDR
// if y - r < 0 then
54708: LD_VAR 0 3
54712: PUSH
54713: LD_VAR 0 4
54717: MINUS
54718: PUSH
54719: LD_INT 0
54721: LESS
54722: IFFALSE 54734
// min_y := 0 else
54724: LD_ADDR_VAR 0 8
54728: PUSH
54729: LD_INT 0
54731: ST_TO_ADDR
54732: GO 54750
// min_y := y - r ;
54734: LD_ADDR_VAR 0 8
54738: PUSH
54739: LD_VAR 0 3
54743: PUSH
54744: LD_VAR 0 4
54748: MINUS
54749: ST_TO_ADDR
// max_x := x + r ;
54750: LD_ADDR_VAR 0 9
54754: PUSH
54755: LD_VAR 0 2
54759: PUSH
54760: LD_VAR 0 4
54764: PLUS
54765: ST_TO_ADDR
// max_y := y + r ;
54766: LD_ADDR_VAR 0 10
54770: PUSH
54771: LD_VAR 0 3
54775: PUSH
54776: LD_VAR 0 4
54780: PLUS
54781: ST_TO_ADDR
// for _x = min_x to max_x do
54782: LD_ADDR_VAR 0 11
54786: PUSH
54787: DOUBLE
54788: LD_VAR 0 7
54792: DEC
54793: ST_TO_ADDR
54794: LD_VAR 0 9
54798: PUSH
54799: FOR_TO
54800: IFFALSE 54917
// for _y = min_y to max_y do
54802: LD_ADDR_VAR 0 12
54806: PUSH
54807: DOUBLE
54808: LD_VAR 0 8
54812: DEC
54813: ST_TO_ADDR
54814: LD_VAR 0 10
54818: PUSH
54819: FOR_TO
54820: IFFALSE 54913
// begin if not ValidHex ( _x , _y ) then
54822: LD_VAR 0 11
54826: PPUSH
54827: LD_VAR 0 12
54831: PPUSH
54832: CALL_OW 488
54836: NOT
54837: IFFALSE 54841
// continue ;
54839: GO 54819
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
54841: LD_VAR 0 11
54845: PPUSH
54846: LD_VAR 0 12
54850: PPUSH
54851: CALL_OW 351
54855: PUSH
54856: LD_VAR 0 11
54860: PPUSH
54861: LD_VAR 0 12
54865: PPUSH
54866: CALL_OW 554
54870: AND
54871: IFFALSE 54911
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
54873: LD_ADDR_VAR 0 13
54877: PUSH
54878: LD_VAR 0 13
54882: PPUSH
54883: LD_VAR 0 13
54887: PUSH
54888: LD_INT 1
54890: PLUS
54891: PPUSH
54892: LD_VAR 0 11
54896: PUSH
54897: LD_VAR 0 12
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: PPUSH
54906: CALL_OW 2
54910: ST_TO_ADDR
// end ;
54911: GO 54819
54913: POP
54914: POP
54915: GO 54799
54917: POP
54918: POP
// if not list then
54919: LD_VAR 0 13
54923: NOT
54924: IFFALSE 54928
// exit ;
54926: GO 54999
// for i in list do
54928: LD_ADDR_VAR 0 6
54932: PUSH
54933: LD_VAR 0 13
54937: PUSH
54938: FOR_IN
54939: IFFALSE 54997
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
54941: LD_VAR 0 1
54945: PPUSH
54946: LD_STRING M
54948: PUSH
54949: LD_VAR 0 6
54953: PUSH
54954: LD_INT 1
54956: ARRAY
54957: PUSH
54958: LD_VAR 0 6
54962: PUSH
54963: LD_INT 2
54965: ARRAY
54966: PUSH
54967: LD_INT 0
54969: PUSH
54970: LD_INT 0
54972: PUSH
54973: LD_INT 0
54975: PUSH
54976: LD_INT 0
54978: PUSH
54979: EMPTY
54980: LIST
54981: LIST
54982: LIST
54983: LIST
54984: LIST
54985: LIST
54986: LIST
54987: PUSH
54988: EMPTY
54989: LIST
54990: PPUSH
54991: CALL_OW 447
54995: GO 54938
54997: POP
54998: POP
// end ;
54999: LD_VAR 0 5
55003: RET
