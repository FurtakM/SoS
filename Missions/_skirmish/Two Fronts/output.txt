// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7393 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4583 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4841 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41777 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42228 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21124 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21060 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18053 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 20960 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 21974 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21201 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 20994 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21027 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 17832 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 21882 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20139 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20714 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20714 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20511 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20175 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20351 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19635 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radar , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 20
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20249 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20750 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21490 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21060 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18053 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 20960 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21201 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 20994 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21027 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 17832 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 21882 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20139 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20714 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20714 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20511 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20175 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20351 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19635 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radar , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 20
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20249 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20750 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21490 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string ; export houten , brown ; export ar_crane , ru_big_cargo_bay ; export dialog_north , dialog_south , dialog_popov , dialog_trans ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// ar_crane := 88 ;
1549: LD_ADDR_EXP 5
1553: PUSH
1554: LD_INT 88
1556: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
1557: LD_ADDR_EXP 6
1561: PUSH
1562: LD_INT 89
1564: ST_TO_ADDR
// dialog_north := true ;
1565: LD_ADDR_EXP 7
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_south := true ;
1573: LD_ADDR_EXP 8
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// dialog_popov := true ;
1581: LD_ADDR_EXP 9
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// dialog_trans := true ;
1589: LD_ADDR_EXP 10
1593: PUSH
1594: LD_INT 1
1596: ST_TO_ADDR
// call := true ;
1597: LD_ADDR_EXP 12
1601: PUSH
1602: LD_INT 1
1604: ST_TO_ADDR
// pink_attack := false ;
1605: LD_ADDR_EXP 13
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_support := false ;
1613: LD_ADDR_EXP 14
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// alfa_north_triggered := false ;
1621: LD_ADDR_EXP 15
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// alfa_south_triggered := false ;
1629: LD_ADDR_EXP 16
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19635 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11340 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21708 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11340 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21708 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11340 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21708 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11340 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21708 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 3
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 3
2743: PPUSH
2744: CALL 7612 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 3
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 4
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 4
2828: PPUSH
2829: CALL 7612 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 4
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7612 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7612 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7612 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4443
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 12
4392: PPUSH
4393: LD_INT -2
4395: PUSH
4396: LD_INT -5
4398: PUSH
4399: LD_INT -3
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PUSH
4407: LD_VAR 0 6
4411: ADD
4412: PPUSH
4413: LD_INT 1
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 3
4428: PUSH
4429: LD_INT 4
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: PPUSH
4438: CALL_OW 42
4442: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4443: LD_EXP 25
4447: PPUSH
4448: LD_INT 9
4450: PPUSH
4451: LD_INT 0
4453: PPUSH
4454: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4458: LD_VAR 0 5
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PPUSH
4467: LD_INT 2
4469: PPUSH
4470: CALL_OW 336
// for i = 1 to tmp do
4474: LD_ADDR_VAR 0 3
4478: PUSH
4479: DOUBLE
4480: LD_INT 1
4482: DEC
4483: ST_TO_ADDR
4484: LD_VAR 0 5
4488: PUSH
4489: FOR_TO
4490: IFFALSE 4545
// if i < 4 then
4492: LD_VAR 0 3
4496: PUSH
4497: LD_INT 4
4499: LESS
4500: IFFALSE 4525
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4502: LD_VAR 0 5
4506: PUSH
4507: LD_VAR 0 3
4511: ARRAY
4512: PPUSH
4513: LD_INT 9
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 49
4523: GO 4543
// SetSide ( tmp [ i ] , 6 ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 3
4534: ARRAY
4535: PPUSH
4536: LD_INT 6
4538: PPUSH
4539: CALL_OW 235
4543: GO 4489
4545: POP
4546: POP
// player_squad := tmp ;
4547: LD_ADDR_EXP 23
4551: PUSH
4552: LD_VAR 0 5
4556: ST_TO_ADDR
// pl_counter := 4 ;
4557: LD_ADDR_EXP 24
4561: PUSH
4562: LD_INT 4
4564: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4565: LD_INT 17
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: LD_INT 1
4573: PPUSH
4574: CALL 18053 0 3
// end ;
4578: LD_VAR 0 2
4582: RET
// export Popov ; export function InitAction ; begin
4583: LD_INT 0
4585: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4586: LD_INT 6
4588: PPUSH
4589: LD_INT 3
4591: PPUSH
4592: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4596: LD_INT 1
4598: PPUSH
4599: LD_INT 1
4601: PPUSH
4602: CALL_OW 86
// uc_side := 6 ;
4606: LD_ADDR_OWVAR 20
4610: PUSH
4611: LD_INT 6
4613: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4614: LD_ADDR_EXP 26
4618: PUSH
4619: LD_STRING Popov
4621: PPUSH
4622: CALL_OW 25
4626: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4627: LD_ADDR_OWVAR 67
4631: PUSH
4632: LD_INT 0
4634: PPUSH
4635: CALL_OW 426
4639: ST_TO_ADDR
// InitCommanders ( GetMultiplayerSetting ( 1 ) ) ;
4640: LD_INT 1
4642: PPUSH
4643: CALL_OW 426
4647: PPUSH
4648: CALL 3137 0 1
// end ;
4652: LD_VAR 0 1
4656: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4657: LD_EXP 24
4661: PUSH
4662: LD_INT 12
4664: LESS
4665: IFFALSE 4838
4667: GO 4669
4669: DISABLE
4670: LD_INT 0
4672: PPUSH
// begin enable ;
4673: ENABLE
// for i = pl_counter to pl_counter + 2 do
4674: LD_ADDR_VAR 0 1
4678: PUSH
4679: DOUBLE
4680: LD_EXP 24
4684: DEC
4685: ST_TO_ADDR
4686: LD_EXP 24
4690: PUSH
4691: LD_INT 2
4693: PLUS
4694: PUSH
4695: FOR_TO
4696: IFFALSE 4742
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4698: LD_EXP 23
4702: PUSH
4703: LD_VAR 0 1
4707: ARRAY
4708: PPUSH
4709: LD_INT 18
4711: PPUSH
4712: LD_INT 0
4714: PPUSH
4715: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4719: LD_EXP 23
4723: PUSH
4724: LD_VAR 0 1
4728: ARRAY
4729: PPUSH
4730: LD_INT 107
4732: PPUSH
4733: LD_INT 88
4735: PPUSH
4736: CALL_OW 111
// end ;
4740: GO 4695
4742: POP
4743: POP
// for i = pl_counter to pl_counter + 2 do
4744: LD_ADDR_VAR 0 1
4748: PUSH
4749: DOUBLE
4750: LD_EXP 24
4754: DEC
4755: ST_TO_ADDR
4756: LD_EXP 24
4760: PUSH
4761: LD_INT 2
4763: PLUS
4764: PUSH
4765: FOR_TO
4766: IFFALSE 4822
// begin repeat wait ( 0 0$01 ) ;
4768: LD_INT 35
4770: PPUSH
4771: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4775: LD_EXP 23
4779: PUSH
4780: LD_VAR 0 1
4784: ARRAY
4785: PPUSH
4786: LD_INT 107
4788: PPUSH
4789: LD_INT 88
4791: PPUSH
4792: CALL_OW 297
4796: PUSH
4797: LD_INT 6
4799: LESS
4800: IFFALSE 4768
// SetSide ( player_squad [ i ] , 3 ) ;
4802: LD_EXP 23
4806: PUSH
4807: LD_VAR 0 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 3
4815: PPUSH
4816: CALL_OW 235
// end ;
4820: GO 4765
4822: POP
4823: POP
// pl_counter := pl_counter + 3 ;
4824: LD_ADDR_EXP 24
4828: PUSH
4829: LD_EXP 24
4833: PUSH
4834: LD_INT 3
4836: PLUS
4837: ST_TO_ADDR
// end ;
4838: PPOPN 1
4840: END
// export function Dialog ; begin
4841: LD_INT 0
4843: PPUSH
// if not isTest then
4844: LD_EXP 1
4848: NOT
4849: IFFALSE 4871
// case query ( task ) of 1 :
4851: LD_STRING task
4853: PPUSH
4854: CALL_OW 97
4858: PUSH
4859: LD_INT 1
4861: DOUBLE
4862: EQUAL
4863: IFTRUE 4867
4865: GO 4870
4867: POP
// ; end ;
4868: GO 4871
4870: POP
// InGameOn ;
4871: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4875: LD_INT 107
4877: PPUSH
4878: LD_INT 84
4880: PPUSH
4881: CALL_OW 86
// if isTest then
4885: LD_EXP 1
4889: IFFALSE 4899
// dialogue_skipped := true ;
4891: LD_ADDR_OWVAR 59
4895: PUSH
4896: LD_INT 1
4898: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4899: LD_ADDR_EXP 11
4903: PUSH
4904: LD_EXP 23
4908: PUSH
4909: LD_INT 1
4911: ARRAY
4912: PPUSH
4913: LD_INT 0
4915: PPUSH
4916: LD_INT 96
4918: PPUSH
4919: LD_INT 79
4921: PPUSH
4922: LD_INT 2
4924: PPUSH
4925: CALL_OW 145
4929: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4930: LD_INT 35
4932: PPUSH
4933: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4937: LD_EXP 26
4941: PPUSH
4942: LD_STRING DR1
4944: PPUSH
4945: CALL_OW 94
// Wait ( 0 0$01 ) ;
4949: LD_INT 35
4951: PPUSH
4952: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4956: LD_EXP 26
4960: PPUSH
4961: LD_STRING DR2
4963: PPUSH
4964: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4968: LD_EXP 26
4972: PPUSH
4973: LD_STRING DR3
4975: PPUSH
4976: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
4980: LD_INT 35
4982: PPUSH
4983: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 30
4992: PUSH
4993: LD_INT 0
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PPUSH
5000: CALL 11340 0 2
5004: PUSH
5005: LD_EXP 1
5009: OR
5010: IFFALSE 4980
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5012: LD_INT 3
5014: PPUSH
5015: LD_INT 2
5017: PPUSH
5018: LD_INT 2
5020: PPUSH
5021: LD_EXP 11
5025: PPUSH
5026: CALL_OW 468
// InGameOff ;
5030: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5034: LD_STRING C1
5036: PPUSH
5037: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5048: LD_EXP 11
5052: PPUSH
5053: CALL_OW 461
5057: PUSH
5058: LD_INT 2
5060: EQUAL
5061: IFFALSE 5041
// if not isTest then
5063: LD_EXP 1
5067: NOT
5068: IFFALSE 5090
// case query ( support ) of 1 :
5070: LD_STRING support
5072: PPUSH
5073: CALL_OW 97
5077: PUSH
5078: LD_INT 1
5080: DOUBLE
5081: EQUAL
5082: IFTRUE 5086
5084: GO 5089
5086: POP
// ; end ;
5087: GO 5090
5089: POP
// if player_com = stolypin then
5090: LD_EXP 25
5094: PUSH
5095: LD_EXP 22
5099: EQUAL
5100: IFFALSE 5129
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5102: LD_INT 18
5104: PPUSH
5105: LD_INT 3
5107: PUSH
5108: LD_INT 3
5110: PUSH
5111: LD_INT 2
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: LIST
5118: PUSH
5119: LD_OWVAR 67
5123: ARRAY
5124: PPUSH
5125: CALL 6429 0 2
// end ;
5129: LD_VAR 0 1
5133: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5134: LD_EXP 12
5138: PUSH
5139: LD_OWVAR 1
5143: PUSH
5144: LD_INT 31500
5146: LESS
5147: AND
5148: IFFALSE 5312
// case query ( call1 ) of 1 :
5150: LD_STRING call1
5152: PPUSH
5153: CALL_OW 97
5157: PUSH
5158: LD_INT 1
5160: DOUBLE
5161: EQUAL
5162: IFTRUE 5166
5164: GO 5300
5166: POP
// begin SetArtifactUse ( 3 , art_exp_mid , art_gray , player_depot ) ;
5167: LD_INT 3
5169: PPUSH
5170: LD_INT 2
5172: PPUSH
5173: LD_INT 1
5175: PPUSH
5176: LD_EXP 11
5180: PPUSH
5181: CALL_OW 468
// call := false ;
5185: LD_ADDR_EXP 12
5189: PUSH
5190: LD_INT 0
5192: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5193: LD_EXP 26
5197: PPUSH
5198: LD_STRING DR6
5200: PPUSH
5201: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5205: LD_INT 6300
5207: PPUSH
5208: LD_INT 8400
5210: PPUSH
5211: CALL_OW 12
5215: PPUSH
5216: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5220: LD_INT 18
5222: PUSH
5223: LD_INT 19
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_INT 2
5235: PPUSH
5236: CALL_OW 12
5240: ARRAY
5241: PPUSH
5242: LD_INT 1
5244: PPUSH
5245: LD_INT 2
5247: PPUSH
5248: CALL_OW 12
5252: PPUSH
5253: CALL 6429 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5257: LD_INT 25200
5259: PPUSH
5260: LD_INT 35700
5262: PPUSH
5263: CALL_OW 12
5267: PPUSH
5268: CALL_OW 67
// call := true ;
5272: LD_ADDR_EXP 12
5276: PUSH
5277: LD_INT 1
5279: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5280: LD_INT 3
5282: PPUSH
5283: LD_INT 2
5285: PPUSH
5286: LD_INT 2
5288: PPUSH
5289: LD_EXP 11
5293: PPUSH
5294: CALL_OW 468
// end ; 2 :
5298: GO 5312
5300: LD_INT 2
5302: DOUBLE
5303: EQUAL
5304: IFTRUE 5308
5306: GO 5311
5308: POP
// ; end ;
5309: GO 5312
5311: POP
// if call and tick >= 15 15$00 then
5312: LD_EXP 12
5316: PUSH
5317: LD_OWVAR 1
5321: PUSH
5322: LD_INT 31500
5324: GREATEREQUAL
5325: AND
5326: IFFALSE 5755
// case query ( call2 ) of 1 :
5328: LD_STRING call2
5330: PPUSH
5331: CALL_OW 97
5335: PUSH
5336: LD_INT 1
5338: DOUBLE
5339: EQUAL
5340: IFTRUE 5344
5342: GO 5580
5344: POP
// begin call := false ;
5345: LD_ADDR_EXP 12
5349: PUSH
5350: LD_INT 0
5352: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 21
5358: PUSH
5359: LD_INT 3
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: PPUSH
5366: CALL 11340 0 2
5370: PUSH
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 21
5376: PUSH
5377: LD_INT 3
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: PPUSH
5384: CALL 11340 0 2
5388: AND
5389: IFFALSE 5437
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5391: LD_INT 18
5393: PUSH
5394: LD_INT 19
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 1
5403: PPUSH
5404: LD_INT 2
5406: PPUSH
5407: CALL_OW 12
5411: ARRAY
5412: PPUSH
5413: LD_INT 5
5415: PUSH
5416: LD_INT 4
5418: PUSH
5419: LD_INT 4
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: LIST
5426: PUSH
5427: LD_OWVAR 67
5431: ARRAY
5432: PPUSH
5433: CALL 6190 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5437: LD_INT 1
5439: PPUSH
5440: LD_INT 21
5442: PUSH
5443: LD_INT 3
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: PPUSH
5450: CALL 11340 0 2
5454: PUSH
5455: LD_INT 0
5457: EQUAL
5458: IFFALSE 5487
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5460: LD_INT 19
5462: PPUSH
5463: LD_INT 5
5465: PUSH
5466: LD_INT 4
5468: PUSH
5469: LD_INT 3
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: PUSH
5477: LD_OWVAR 67
5481: ARRAY
5482: PPUSH
5483: CALL 6190 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5487: LD_INT 4
5489: PPUSH
5490: LD_INT 21
5492: PUSH
5493: LD_INT 3
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: PPUSH
5500: CALL 11340 0 2
5504: PUSH
5505: LD_INT 0
5507: EQUAL
5508: IFFALSE 5537
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PPUSH
5513: LD_INT 5
5515: PUSH
5516: LD_INT 4
5518: PUSH
5519: LD_INT 4
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: PUSH
5527: LD_OWVAR 67
5531: ARRAY
5532: PPUSH
5533: CALL 6190 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5537: LD_INT 10500
5539: PPUSH
5540: LD_INT 23100
5542: PPUSH
5543: CALL_OW 12
5547: PPUSH
5548: CALL_OW 67
// call := true ;
5552: LD_ADDR_EXP 12
5556: PUSH
5557: LD_INT 1
5559: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5560: LD_INT 3
5562: PPUSH
5563: LD_INT 2
5565: PPUSH
5566: LD_INT 2
5568: PPUSH
5569: LD_EXP 11
5573: PPUSH
5574: CALL_OW 468
// end ; 2 :
5578: GO 5755
5580: LD_INT 2
5582: DOUBLE
5583: EQUAL
5584: IFTRUE 5588
5586: GO 5743
5588: POP
// begin SetArtifactUse ( 3 , art_exp_mid , art_gray , player_depot ) ;
5589: LD_INT 3
5591: PPUSH
5592: LD_INT 2
5594: PPUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_EXP 11
5602: PPUSH
5603: CALL_OW 468
// call := false ;
5607: LD_ADDR_EXP 12
5611: PUSH
5612: LD_INT 0
5614: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5615: LD_EXP 26
5619: PPUSH
5620: LD_STRING DR6
5622: PPUSH
5623: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5627: LD_INT 6300
5629: PPUSH
5630: LD_INT 8400
5632: PPUSH
5633: CALL_OW 12
5637: PPUSH
5638: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5642: LD_INT 18
5644: PUSH
5645: LD_INT 19
5647: PUSH
5648: EMPTY
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 1
5654: PPUSH
5655: LD_INT 2
5657: PPUSH
5658: CALL_OW 12
5662: ARRAY
5663: PPUSH
5664: LD_INT 3
5666: PUSH
5667: LD_INT 2
5669: PUSH
5670: LD_INT 2
5672: PUSH
5673: EMPTY
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_OWVAR 67
5682: ARRAY
5683: PUSH
5684: LD_INT 0
5686: PPUSH
5687: LD_INT 1
5689: PPUSH
5690: CALL_OW 12
5694: MINUS
5695: PPUSH
5696: CALL 6429 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5700: LD_INT 35700
5702: PPUSH
5703: LD_INT 44100
5705: PPUSH
5706: CALL_OW 12
5710: PPUSH
5711: CALL_OW 67
// call := true ;
5715: LD_ADDR_EXP 12
5719: PUSH
5720: LD_INT 1
5722: ST_TO_ADDR
// SetArtifactUse ( 3 , art_exp_mid , art_instant , player_depot ) ;
5723: LD_INT 3
5725: PPUSH
5726: LD_INT 2
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: LD_EXP 11
5736: PPUSH
5737: CALL_OW 468
// end ; 3 :
5741: GO 5755
5743: LD_INT 3
5745: DOUBLE
5746: EQUAL
5747: IFTRUE 5751
5749: GO 5754
5751: POP
// ; end ;
5752: GO 5755
5754: POP
// end ;
5755: PPOPN 4
5757: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5758: LD_INT 22
5760: PUSH
5761: LD_INT 1
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: LD_INT 21
5770: PUSH
5771: LD_INT 1
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: PPUSH
5782: CALL_OW 69
5786: PUSH
5787: LD_INT 0
5789: EQUAL
5790: PUSH
5791: LD_INT 22
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: PUSH
5801: LD_INT 21
5803: PUSH
5804: LD_INT 1
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PPUSH
5815: CALL_OW 69
5819: PUSH
5820: LD_INT 0
5822: EQUAL
5823: AND
5824: IFFALSE 6028
5826: GO 5828
5828: DISABLE
// begin DialogueOn ;
5829: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5833: LD_EXP 26
5837: PPUSH
5838: LD_STRING DR7
5840: PPUSH
5841: CALL_OW 94
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
5845: LD_OWVAR 1
5849: PUSH
5850: LD_INT 116550
5852: PUSH
5853: LD_INT 95550
5855: PUSH
5856: LD_INT 89250
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_OWVAR 67
5868: ARRAY
5869: LESS
5870: IFFALSE 5884
// AddMedal ( med1 , 1 ) else
5872: LD_STRING med1
5874: PPUSH
5875: LD_INT 1
5877: PPUSH
5878: CALL_OW 101
5882: GO 5895
// AddMedal ( med1 , - 1 ) ;
5884: LD_STRING med1
5886: PPUSH
5887: LD_INT 1
5889: NEG
5890: PPUSH
5891: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
5895: LD_INT 81
5897: PUSH
5898: LD_INT 3
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 21
5907: PUSH
5908: LD_INT 3
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PPUSH
5919: CALL_OW 69
5923: PUSH
5924: LD_INT 0
5926: EQUAL
5927: IFFALSE 5941
// AddMedal ( med3 , 1 ) else
5929: LD_STRING med3
5931: PPUSH
5932: LD_INT 1
5934: PPUSH
5935: CALL_OW 101
5939: GO 5952
// AddMedal ( med3 , - 1 ) ;
5941: LD_STRING med3
5943: PPUSH
5944: LD_INT 1
5946: NEG
5947: PPUSH
5948: CALL_OW 101
// if player_squad = 15 then
5952: LD_EXP 23
5956: PUSH
5957: LD_INT 15
5959: EQUAL
5960: IFFALSE 5974
// AddMedal ( med2 , 1 ) else
5962: LD_STRING med2
5964: PPUSH
5965: LD_INT 1
5967: PPUSH
5968: CALL_OW 101
5972: GO 6017
// if player_squad > 12 and player_squad < 15 then
5974: LD_EXP 23
5978: PUSH
5979: LD_INT 12
5981: GREATER
5982: PUSH
5983: LD_EXP 23
5987: PUSH
5988: LD_INT 15
5990: LESS
5991: AND
5992: IFFALSE 6006
// AddMedal ( med2 , 2 ) else
5994: LD_STRING med2
5996: PPUSH
5997: LD_INT 2
5999: PPUSH
6000: CALL_OW 101
6004: GO 6017
// AddMedal ( med2 , - 1 ) ;
6006: LD_STRING med2
6008: PPUSH
6009: LD_INT 1
6011: NEG
6012: PPUSH
6013: CALL_OW 101
// GiveMedals ( MAIN ) ;
6017: LD_STRING MAIN
6019: PPUSH
6020: CALL_OW 102
// YouWin ;
6024: CALL_OW 103
// end ;
6028: END
// every 0 0$01 trigger IsDead ( player_com ) do
6029: LD_EXP 25
6033: PPUSH
6034: CALL_OW 301
6038: IFFALSE 6105
6040: GO 6042
6042: DISABLE
// begin if IsLive ( Houten ) then
6043: LD_EXP 3
6047: PPUSH
6048: CALL_OW 300
6052: IFFALSE 6068
// SayRadio ( Houten , DJ5 ) else
6054: LD_EXP 3
6058: PPUSH
6059: LD_STRING DJ5
6061: PPUSH
6062: CALL_OW 94
6066: GO 6091
// if IsLive ( Brown ) then
6068: LD_EXP 4
6072: PPUSH
6073: CALL_OW 300
6077: IFFALSE 6091
// SayRadio ( Brown , DS5 ) ;
6079: LD_EXP 4
6083: PPUSH
6084: LD_STRING DS5
6086: PPUSH
6087: CALL_OW 94
// Wait ( 0 0$01 ) ;
6091: LD_INT 35
6093: PPUSH
6094: CALL_OW 67
// YouLost ( dead ) ;
6098: LD_STRING dead
6100: PPUSH
6101: CALL_OW 104
// end ;
6105: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6106: LD_EXP 11
6110: PPUSH
6111: CALL_OW 301
6115: PUSH
6116: LD_EXP 1
6120: NOT
6121: AND
6122: IFFALSE 6189
6124: GO 6126
6126: DISABLE
// begin if IsLive ( Brown ) then
6127: LD_EXP 4
6131: PPUSH
6132: CALL_OW 300
6136: IFFALSE 6152
// SayRadio ( Brown , DS5 ) else
6138: LD_EXP 4
6142: PPUSH
6143: LD_STRING DS5
6145: PPUSH
6146: CALL_OW 94
6150: GO 6175
// if IsLive ( Houten ) then
6152: LD_EXP 3
6156: PPUSH
6157: CALL_OW 300
6161: IFFALSE 6175
// SayRadio ( Houten , DJ5 ) ;
6163: LD_EXP 3
6167: PPUSH
6168: LD_STRING DJ5
6170: PPUSH
6171: CALL_OW 94
// Wait ( 0 0$01 ) ;
6175: LD_INT 35
6177: PPUSH
6178: CALL_OW 67
// YouLost ( depot ) ;
6182: LD_STRING depot
6184: PPUSH
6185: CALL_OW 104
// end ;
6189: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6190: LD_INT 0
6192: PPUSH
6193: PPUSH
6194: PPUSH
// for i = 1 to n do
6195: LD_ADDR_VAR 0 4
6199: PUSH
6200: DOUBLE
6201: LD_INT 1
6203: DEC
6204: ST_TO_ADDR
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6414
// begin uc_side := 6 ;
6213: LD_ADDR_OWVAR 20
6217: PUSH
6218: LD_INT 6
6220: ST_TO_ADDR
// uc_nation := 3 ;
6221: LD_ADDR_OWVAR 21
6225: PUSH
6226: LD_INT 3
6228: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6229: LD_ADDR_OWVAR 37
6233: PUSH
6234: LD_INT 23
6236: PUSH
6237: LD_INT 22
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 1
6246: PPUSH
6247: LD_INT 2
6249: PPUSH
6250: CALL_OW 12
6254: ARRAY
6255: ST_TO_ADDR
// vc_control := control_computer ;
6256: LD_ADDR_OWVAR 38
6260: PUSH
6261: LD_INT 3
6263: ST_TO_ADDR
// vc_engine := engine_siberite ;
6264: LD_ADDR_OWVAR 39
6268: PUSH
6269: LD_INT 3
6271: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6272: LD_ADDR_OWVAR 40
6276: PUSH
6277: LD_INT 43
6279: PUSH
6280: LD_INT 44
6282: PUSH
6283: LD_INT 44
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: LIST
6290: PUSH
6291: LD_INT 1
6293: PPUSH
6294: LD_INT 3
6296: PPUSH
6297: CALL_OW 12
6301: ARRAY
6302: ST_TO_ADDR
// un := CreateVehicle ;
6303: LD_ADDR_VAR 0 5
6307: PUSH
6308: CALL_OW 45
6312: ST_TO_ADDR
// case area of east_arr :
6313: LD_VAR 0 1
6317: PUSH
6318: LD_INT 18
6320: DOUBLE
6321: EQUAL
6322: IFTRUE 6326
6324: GO 6361
6326: POP
// begin PlaceUnitArea ( un , area , false ) ;
6327: LD_VAR 0 5
6331: PPUSH
6332: LD_VAR 0 1
6336: PPUSH
6337: LD_INT 0
6339: PPUSH
6340: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6344: LD_VAR 0 5
6348: PPUSH
6349: LD_INT 79
6351: PPUSH
6352: LD_INT 33
6354: PPUSH
6355: CALL_OW 111
// end ; south_arr :
6359: GO 6405
6361: LD_INT 19
6363: DOUBLE
6364: EQUAL
6365: IFTRUE 6369
6367: GO 6404
6369: POP
// begin PlaceUnitArea ( un , area , false ) ;
6370: LD_VAR 0 5
6374: PPUSH
6375: LD_VAR 0 1
6379: PPUSH
6380: LD_INT 0
6382: PPUSH
6383: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6387: LD_VAR 0 5
6391: PPUSH
6392: LD_INT 131
6394: PPUSH
6395: LD_INT 148
6397: PPUSH
6398: CALL_OW 111
// end ; end ;
6402: GO 6405
6404: POP
// Wait ( 0 0$02 ) ;
6405: LD_INT 70
6407: PPUSH
6408: CALL_OW 67
// end ;
6412: GO 6210
6414: POP
6415: POP
// pink_attack := true ;
6416: LD_ADDR_EXP 13
6420: PUSH
6421: LD_INT 1
6423: ST_TO_ADDR
// end ;
6424: LD_VAR 0 3
6428: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6429: LD_INT 0
6431: PPUSH
6432: PPUSH
6433: PPUSH
// for i = 1 to n do
6434: LD_ADDR_VAR 0 4
6438: PUSH
6439: DOUBLE
6440: LD_INT 1
6442: DEC
6443: ST_TO_ADDR
6444: LD_VAR 0 2
6448: PUSH
6449: FOR_TO
6450: IFFALSE 6676
// begin uc_side := 6 ;
6452: LD_ADDR_OWVAR 20
6456: PUSH
6457: LD_INT 6
6459: ST_TO_ADDR
// uc_nation := 3 ;
6460: LD_ADDR_OWVAR 21
6464: PUSH
6465: LD_INT 3
6467: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6468: LD_INT 0
6470: PPUSH
6471: LD_INT 3
6473: PPUSH
6474: LD_INT 4
6476: PPUSH
6477: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6481: LD_ADDR_OWVAR 37
6485: PUSH
6486: LD_INT 22
6488: ST_TO_ADDR
// vc_control := control_manual ;
6489: LD_ADDR_OWVAR 38
6493: PUSH
6494: LD_INT 1
6496: ST_TO_ADDR
// vc_engine := engine_combustion ;
6497: LD_ADDR_OWVAR 39
6501: PUSH
6502: LD_INT 1
6504: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6505: LD_ADDR_OWVAR 40
6509: PUSH
6510: LD_INT 51
6512: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6513: LD_ADDR_OWVAR 41
6517: PUSH
6518: LD_INT 50
6520: ST_TO_ADDR
// un := CreateVehicle ;
6521: LD_ADDR_VAR 0 5
6525: PUSH
6526: CALL_OW 45
6530: ST_TO_ADDR
// case area of east_arr :
6531: LD_VAR 0 1
6535: PUSH
6536: LD_INT 18
6538: DOUBLE
6539: EQUAL
6540: IFTRUE 6544
6542: GO 6559
6544: POP
// SetDir ( un , 4 ) ; south_arr :
6545: LD_VAR 0 5
6549: PPUSH
6550: LD_INT 4
6552: PPUSH
6553: CALL_OW 233
6557: GO 6583
6559: LD_INT 19
6561: DOUBLE
6562: EQUAL
6563: IFTRUE 6567
6565: GO 6582
6567: POP
// SetDir ( un , 5 ) ; end ;
6568: LD_VAR 0 5
6572: PPUSH
6573: LD_INT 5
6575: PPUSH
6576: CALL_OW 233
6580: GO 6583
6582: POP
// PlaceUnitArea ( un , area , false ) ;
6583: LD_VAR 0 5
6587: PPUSH
6588: LD_VAR 0 1
6592: PPUSH
6593: LD_INT 0
6595: PPUSH
6596: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6600: CALL_OW 44
6604: PPUSH
6605: LD_VAR 0 5
6609: PPUSH
6610: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 1
6621: PPUSH
6622: LD_INT 100
6624: PPUSH
6625: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6629: LD_VAR 0 5
6633: PPUSH
6634: LD_INT 106
6636: PPUSH
6637: LD_INT 88
6639: PPUSH
6640: CALL_OW 111
// AddComUnload ( un ) ;
6644: LD_VAR 0 5
6648: PPUSH
6649: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6653: LD_VAR 0 5
6657: PPUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 173
// Wait ( 0 0$02 ) ;
6667: LD_INT 70
6669: PPUSH
6670: CALL_OW 67
// end ;
6674: GO 6449
6676: POP
6677: POP
// Wait ( 0 0$05 ) ;
6678: LD_INT 175
6680: PPUSH
6681: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6685: LD_INT 6
6687: PPUSH
6688: LD_INT 34
6690: PUSH
6691: LD_INT 51
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PPUSH
6698: CALL 11340 0 2
6702: IFFALSE 6890
// begin wait ( 0 0$01 ) ;
6704: LD_INT 35
6706: PPUSH
6707: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6711: LD_ADDR_VAR 0 4
6715: PUSH
6716: LD_INT 6
6718: PPUSH
6719: LD_INT 34
6721: PUSH
6722: LD_INT 51
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: PPUSH
6729: CALL 11340 0 2
6733: PUSH
6734: FOR_IN
6735: IFFALSE 6886
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6737: LD_VAR 0 4
6741: PPUSH
6742: LD_INT 9
6744: PPUSH
6745: CALL_OW 308
6749: PUSH
6750: LD_VAR 0 4
6754: PPUSH
6755: CALL 31468 0 1
6759: PPUSH
6760: CALL_OW 258
6764: PUSH
6765: LD_INT 1
6767: EQUAL
6768: AND
6769: PUSH
6770: LD_EXP 10
6774: AND
6775: IFFALSE 6802
// begin Say ( GetDriver ( i ) , Dtran ) ;
6777: LD_VAR 0 4
6781: PPUSH
6782: CALL 31468 0 1
6786: PPUSH
6787: LD_STRING Dtran
6789: PPUSH
6790: CALL_OW 88
// dialog_trans := false ;
6794: LD_ADDR_EXP 10
6798: PUSH
6799: LD_INT 0
6801: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6802: LD_VAR 0 4
6806: PPUSH
6807: CALL_OW 316
6811: IFFALSE 6827
// ComMoveToArea ( i , area ) ;
6813: LD_VAR 0 4
6817: PPUSH
6818: LD_VAR 0 1
6822: PPUSH
6823: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6827: LD_VAR 0 4
6831: PPUSH
6832: LD_VAR 0 1
6836: PPUSH
6837: CALL_OW 308
6841: PUSH
6842: LD_VAR 0 4
6846: PPUSH
6847: LD_INT 1
6849: PPUSH
6850: CALL_OW 289
6854: PUSH
6855: LD_INT 0
6857: EQUAL
6858: AND
6859: IFFALSE 6884
// begin RemoveUnit ( GetDriver ( i ) ) ;
6861: LD_VAR 0 4
6865: PPUSH
6866: CALL 31468 0 1
6870: PPUSH
6871: CALL_OW 64
// RemoveUnit ( i ) ;
6875: LD_VAR 0 4
6879: PPUSH
6880: CALL_OW 64
// end ; end ;
6884: GO 6734
6886: POP
6887: POP
// end ;
6888: GO 6685
// end ;
6890: LD_VAR 0 3
6894: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
6895: LD_INT 0
6897: PPUSH
6898: PPUSH
6899: PPUSH
6900: PPUSH
// if isTest then
6901: LD_EXP 1
6905: IFFALSE 6909
// exit ;
6907: GO 7298
// for i = 1 to n do
6909: LD_ADDR_VAR 0 4
6913: PUSH
6914: DOUBLE
6915: LD_INT 1
6917: DEC
6918: ST_TO_ADDR
6919: LD_VAR 0 2
6923: PUSH
6924: FOR_TO
6925: IFFALSE 7157
// begin uc_side := 8 ;
6927: LD_ADDR_OWVAR 20
6931: PUSH
6932: LD_INT 8
6934: ST_TO_ADDR
// uc_nation := 1 ;
6935: LD_ADDR_OWVAR 21
6939: PUSH
6940: LD_INT 1
6942: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
6943: LD_ADDR_VAR 0 6
6947: PUSH
6948: LD_INT 3
6950: PUSH
6951: LD_INT 4
6953: PUSH
6954: LD_INT 4
6956: PUSH
6957: EMPTY
6958: LIST
6959: LIST
6960: LIST
6961: PUSH
6962: LD_INT 1
6964: PPUSH
6965: LD_OWVAR 67
6969: PPUSH
6970: CALL_OW 12
6974: ARRAY
6975: ST_TO_ADDR
// vc_chassis := ch ;
6976: LD_ADDR_OWVAR 37
6980: PUSH
6981: LD_VAR 0 6
6985: ST_TO_ADDR
// vc_control := control_computer ;
6986: LD_ADDR_OWVAR 38
6990: PUSH
6991: LD_INT 3
6993: ST_TO_ADDR
// vc_engine := engine_combustion ;
6994: LD_ADDR_OWVAR 39
6998: PUSH
6999: LD_INT 1
7001: ST_TO_ADDR
// if ch = us_medium_tracked then
7002: LD_VAR 0 6
7006: PUSH
7007: LD_INT 3
7009: EQUAL
7010: IFFALSE 7057
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7012: LD_ADDR_OWVAR 40
7016: PUSH
7017: LD_INT 3
7019: PUSH
7020: LD_INT 4
7022: PUSH
7023: LD_INT 5
7025: PUSH
7026: LD_INT 7
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_OWVAR 67
7039: PPUSH
7040: LD_OWVAR 67
7044: PUSH
7045: LD_INT 1
7047: PLUS
7048: PPUSH
7049: CALL_OW 12
7053: ARRAY
7054: ST_TO_ADDR
7055: GO 7098
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7057: LD_ADDR_OWVAR 40
7061: PUSH
7062: LD_INT 5
7064: PUSH
7065: LD_INT 6
7067: PUSH
7068: LD_INT 7
7070: PUSH
7071: LD_INT 7
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: LIST
7078: LIST
7079: PUSH
7080: LD_INT 1
7082: PPUSH
7083: LD_OWVAR 67
7087: PUSH
7088: LD_INT 1
7090: PLUS
7091: PPUSH
7092: CALL_OW 12
7096: ARRAY
7097: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7098: LD_ADDR_OWVAR 41
7102: PUSH
7103: LD_INT 70
7105: ST_TO_ADDR
// un := CreateVehicle ;
7106: LD_ADDR_VAR 0 5
7110: PUSH
7111: CALL_OW 45
7115: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7116: LD_VAR 0 5
7120: PPUSH
7121: LD_VAR 0 1
7125: PPUSH
7126: LD_INT 0
7128: PPUSH
7129: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7133: LD_VAR 0 5
7137: PPUSH
7138: LD_INT 65
7140: PPUSH
7141: LD_INT 9
7143: PPUSH
7144: CALL_OW 111
// Wait ( 0 0$02 ) ;
7148: LD_INT 70
7150: PPUSH
7151: CALL_OW 67
// end ;
7155: GO 6924
7157: POP
7158: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7159: LD_INT 90
7161: PUSH
7162: LD_INT 80
7164: PUSH
7165: LD_INT 70
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_OWVAR 67
7177: ARRAY
7178: PPUSH
7179: CALL_OW 13
7183: IFFALSE 7290
// begin uc_side := 8 ;
7185: LD_ADDR_OWVAR 20
7189: PUSH
7190: LD_INT 8
7192: ST_TO_ADDR
// uc_nation := 1 ;
7193: LD_ADDR_OWVAR 21
7197: PUSH
7198: LD_INT 1
7200: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7201: LD_ADDR_OWVAR 37
7205: PUSH
7206: LD_INT 4
7208: ST_TO_ADDR
// vc_control := control_computer ;
7209: LD_ADDR_OWVAR 38
7213: PUSH
7214: LD_INT 3
7216: ST_TO_ADDR
// vc_engine := engine_combustion ;
7217: LD_ADDR_OWVAR 39
7221: PUSH
7222: LD_INT 1
7224: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7225: LD_ADDR_OWVAR 40
7229: PUSH
7230: LD_INT 14
7232: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7233: LD_ADDR_OWVAR 41
7237: PUSH
7238: LD_INT 70
7240: ST_TO_ADDR
// un := CreateVehicle ;
7241: LD_ADDR_VAR 0 5
7245: PUSH
7246: CALL_OW 45
7250: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7251: LD_VAR 0 5
7255: PPUSH
7256: LD_VAR 0 1
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7268: LD_VAR 0 5
7272: PPUSH
7273: LD_INT 65
7275: PPUSH
7276: LD_INT 9
7278: PPUSH
7279: CALL_OW 111
// Wait ( 0 0$02 ) ;
7283: LD_INT 70
7285: PPUSH
7286: CALL_OW 67
// end ; alfa_support := true ;
7290: LD_ADDR_EXP 14
7294: PUSH
7295: LD_INT 1
7297: ST_TO_ADDR
// end ;
7298: LD_VAR 0 3
7302: RET
// every 0 0$01 trigger tick mod [ 21 21$00 , 16 16$00 , 12 12$00 ] [ Difficulty ] = 0 do
7303: LD_OWVAR 1
7307: PUSH
7308: LD_INT 44100
7310: PUSH
7311: LD_INT 33600
7313: PUSH
7314: LD_INT 25200
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: LIST
7321: PUSH
7322: LD_OWVAR 67
7326: ARRAY
7327: MOD
7328: PUSH
7329: LD_INT 0
7331: EQUAL
7332: IFFALSE 7392
7334: GO 7336
7336: DISABLE
// begin enable ;
7337: ENABLE
// SayRadio ( Popov , DR5 ) ;
7338: LD_EXP 26
7342: PPUSH
7343: LD_STRING DR5
7345: PPUSH
7346: CALL_OW 94
// Wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7350: LD_INT 1050
7352: PPUSH
7353: LD_INT 4200
7355: PPUSH
7356: CALL_OW 12
7360: PPUSH
7361: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7365: LD_INT 20
7367: PPUSH
7368: LD_INT 5
7370: PUSH
7371: LD_INT 6
7373: PUSH
7374: LD_INT 7
7376: PUSH
7377: EMPTY
7378: LIST
7379: LIST
7380: LIST
7381: PUSH
7382: LD_OWVAR 67
7386: ARRAY
7387: PPUSH
7388: CALL 6895 0 2
// end ; end_of_file
7392: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7393: LD_INT 0
7395: PPUSH
// enable_addtolog := isTest ;
7396: LD_ADDR_OWVAR 81
7400: PUSH
7401: LD_EXP 1
7405: ST_TO_ADDR
// lines_break_limit := 5 ;
7406: LD_ADDR_EXP 28
7410: PUSH
7411: LD_INT 5
7413: ST_TO_ADDR
// lines_break_type := --- ;
7414: LD_ADDR_EXP 29
7418: PUSH
7419: LD_STRING ---
7421: ST_TO_ADDR
// lines_counter := 0 ;
7422: LD_ADDR_EXP 27
7426: PUSH
7427: LD_INT 0
7429: ST_TO_ADDR
// show_line_index := true ;
7430: LD_ADDR_EXP 30
7434: PUSH
7435: LD_INT 1
7437: ST_TO_ADDR
// tick_log := true ;
7438: LD_ADDR_EXP 31
7442: PUSH
7443: LD_INT 1
7445: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7446: LD_STRING ----------SAND OF SIBERIA LOG----------
7448: PPUSH
7449: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7453: LD_STRING Map Name: 
7455: PUSH
7456: LD_OWVAR 68
7460: STR
7461: PPUSH
7462: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7466: LD_STRING Map Number: 
7468: PUSH
7469: LD_OWVAR 70
7473: STR
7474: PPUSH
7475: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7479: LD_STRING Difficulty: 
7481: PUSH
7482: LD_OWVAR 67
7486: STR
7487: PPUSH
7488: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7492: LD_STRING ---------------------------------------
7494: PPUSH
7495: CALL_OW 561
// end ;
7499: LD_VAR 0 1
7503: RET
// function Log ( text ) ; begin
7504: LD_INT 0
7506: PPUSH
// if show_line_index then
7507: LD_EXP 30
7511: IFFALSE 7523
// result := lines_counter ;
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_EXP 27
7522: ST_TO_ADDR
// if tick_log then
7523: LD_EXP 31
7527: IFFALSE 7553
// result := result &  T:  & tick &   ;
7529: LD_ADDR_VAR 0 2
7533: PUSH
7534: LD_VAR 0 2
7538: PUSH
7539: LD_STRING  T: 
7541: STR
7542: PUSH
7543: LD_OWVAR 1
7547: STR
7548: PUSH
7549: LD_STRING  
7551: STR
7552: ST_TO_ADDR
// AddToLog ( result & text ) ;
7553: LD_VAR 0 2
7557: PUSH
7558: LD_VAR 0 1
7562: STR
7563: PPUSH
7564: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7568: LD_ADDR_EXP 27
7572: PUSH
7573: LD_EXP 27
7577: PUSH
7578: LD_INT 1
7580: PLUS
7581: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7582: LD_EXP 27
7586: PUSH
7587: LD_EXP 28
7591: MOD
7592: PUSH
7593: LD_INT 0
7595: EQUAL
7596: IFFALSE 7607
// AddToLog ( lines_break_type ) ;
7598: LD_EXP 29
7602: PPUSH
7603: CALL_OW 561
// end ;
7607: LD_VAR 0 2
7611: RET
// export function LogHuman ( id ) ; begin
7612: LD_INT 0
7614: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7615: LD_STRING Human Created. id: 
7617: PUSH
7618: LD_VAR 0 1
7622: STR
7623: PUSH
7624: LD_STRING ; side: 
7626: STR
7627: PUSH
7628: LD_VAR 0 1
7632: PPUSH
7633: CALL_OW 255
7637: STR
7638: PUSH
7639: LD_STRING ; class: 
7641: STR
7642: PUSH
7643: LD_VAR 0 1
7647: PPUSH
7648: CALL_OW 257
7652: STR
7653: PUSH
7654: LD_STRING ; 
7656: STR
7657: PPUSH
7658: CALL 7504 0 1
// end ;
7662: LD_VAR 0 2
7666: RET
// export function LogVeh ( id ) ; begin
7667: LD_INT 0
7669: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7670: LD_STRING Vehicle Created. id: 
7672: PUSH
7673: LD_VAR 0 1
7677: STR
7678: PUSH
7679: LD_STRING ; side: 
7681: STR
7682: PUSH
7683: LD_VAR 0 1
7687: PPUSH
7688: CALL_OW 255
7692: STR
7693: PUSH
7694: LD_STRING ; nation: 
7696: STR
7697: PUSH
7698: LD_VAR 0 1
7702: PPUSH
7703: CALL_OW 248
7707: STR
7708: PUSH
7709: LD_STRING ; weapon: 
7711: STR
7712: PUSH
7713: LD_VAR 0 1
7717: PPUSH
7718: CALL_OW 264
7722: STR
7723: PUSH
7724: LD_STRING ; 
7726: STR
7727: PPUSH
7728: CALL 7504 0 1
// end ;
7732: LD_VAR 0 2
7736: RET
// export function LogEvent ( event ) ; begin
7737: LD_INT 0
7739: PPUSH
// Log ( Event Executed. id:  & event ) ;
7740: LD_STRING Event Executed. id: 
7742: PUSH
7743: LD_VAR 0 1
7747: STR
7748: PPUSH
7749: CALL 7504 0 1
// end ; end_of_file
7753: LD_VAR 0 2
7757: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7758: LD_INT 0
7760: PPUSH
7761: PPUSH
7762: PPUSH
7763: PPUSH
7764: PPUSH
7765: PPUSH
7766: PPUSH
7767: PPUSH
// if unit then
7768: LD_VAR 0 1
7772: IFFALSE 8172
// begin if mode = 0 then
7774: LD_VAR 0 3
7778: PUSH
7779: LD_INT 0
7781: EQUAL
7782: IFFALSE 7930
// begin if coords then
7784: LD_VAR 0 2
7788: IFFALSE 7928
// while ( coords > 1 ) do
7790: LD_VAR 0 2
7794: PUSH
7795: LD_INT 1
7797: GREATER
7798: IFFALSE 7928
// if not HasTask ( unit ) then
7800: LD_VAR 0 1
7804: PPUSH
7805: CALL_OW 314
7809: NOT
7810: IFFALSE 7926
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
7812: LD_VAR 0 1
7816: PPUSH
7817: LD_VAR 0 2
7821: PUSH
7822: LD_INT 1
7824: ARRAY
7825: PPUSH
7826: LD_VAR 0 2
7830: PUSH
7831: LD_INT 2
7833: ARRAY
7834: PPUSH
7835: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
7839: LD_INT 35
7841: PPUSH
7842: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
7846: LD_VAR 0 1
7850: PPUSH
7851: CALL_OW 250
7855: PUSH
7856: LD_VAR 0 2
7860: PUSH
7861: LD_INT 1
7863: ARRAY
7864: EQUAL
7865: PUSH
7866: LD_VAR 0 1
7870: PPUSH
7871: CALL_OW 251
7875: PUSH
7876: LD_VAR 0 2
7880: PUSH
7881: LD_INT 2
7883: ARRAY
7884: EQUAL
7885: AND
7886: IFFALSE 7839
// for i = 1 to 2 do
7888: LD_ADDR_VAR 0 5
7892: PUSH
7893: DOUBLE
7894: LD_INT 1
7896: DEC
7897: ST_TO_ADDR
7898: LD_INT 2
7900: PUSH
7901: FOR_TO
7902: IFFALSE 7924
// coords := Delete ( coords , 1 ) ;
7904: LD_ADDR_VAR 0 2
7908: PUSH
7909: LD_VAR 0 2
7913: PPUSH
7914: LD_INT 1
7916: PPUSH
7917: CALL_OW 3
7921: ST_TO_ADDR
7922: GO 7901
7924: POP
7925: POP
// end ;
7926: GO 7790
// end else
7928: GO 8172
// begin if coords then
7930: LD_VAR 0 2
7934: IFFALSE 8172
// begin x := GetX ( unit ) ;
7936: LD_ADDR_VAR 0 6
7940: PUSH
7941: LD_VAR 0 1
7945: PPUSH
7946: CALL_OW 250
7950: ST_TO_ADDR
// y := GetY ( unit ) ;
7951: LD_ADDR_VAR 0 7
7955: PUSH
7956: LD_VAR 0 1
7960: PPUSH
7961: CALL_OW 251
7965: ST_TO_ADDR
// while ( coords > 1 ) do
7966: LD_VAR 0 2
7970: PUSH
7971: LD_INT 1
7973: GREATER
7974: IFFALSE 8172
// begin Wait ( 0 0$0.3 ) ;
7976: LD_INT 10
7978: PPUSH
7979: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
7983: LD_VAR 0 1
7987: PPUSH
7988: CALL_OW 255
7992: PPUSH
7993: LD_VAR 0 1
7997: PPUSH
7998: CALL_OW 250
8002: PPUSH
8003: LD_VAR 0 1
8007: PPUSH
8008: CALL_OW 251
8012: PPUSH
8013: LD_INT 14
8015: PPUSH
8016: CALL 22510 0 4
8020: IFFALSE 8051
// begin ComMoveXY ( unit , x , y ) ;
8022: LD_VAR 0 1
8026: PPUSH
8027: LD_VAR 0 6
8031: PPUSH
8032: LD_VAR 0 7
8036: PPUSH
8037: CALL_OW 111
// result := false ;
8041: LD_ADDR_VAR 0 4
8045: PUSH
8046: LD_INT 0
8048: ST_TO_ADDR
// end else
8049: GO 8090
// if not HasTask ( unit ) then
8051: LD_VAR 0 1
8055: PPUSH
8056: CALL_OW 314
8060: NOT
8061: IFFALSE 8090
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8063: LD_VAR 0 1
8067: PPUSH
8068: LD_VAR 0 2
8072: PUSH
8073: LD_INT 1
8075: ARRAY
8076: PPUSH
8077: LD_VAR 0 2
8081: PUSH
8082: LD_INT 2
8084: ARRAY
8085: PPUSH
8086: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8090: LD_VAR 0 1
8094: PPUSH
8095: CALL_OW 250
8099: PUSH
8100: LD_VAR 0 2
8104: PUSH
8105: LD_INT 1
8107: ARRAY
8108: EQUAL
8109: PUSH
8110: LD_VAR 0 1
8114: PPUSH
8115: CALL_OW 251
8119: PUSH
8120: LD_VAR 0 2
8124: PUSH
8125: LD_INT 2
8127: ARRAY
8128: EQUAL
8129: AND
8130: IFFALSE 8170
// for i = 1 to 2 do
8132: LD_ADDR_VAR 0 5
8136: PUSH
8137: DOUBLE
8138: LD_INT 1
8140: DEC
8141: ST_TO_ADDR
8142: LD_INT 2
8144: PUSH
8145: FOR_TO
8146: IFFALSE 8168
// coords := Delete ( coords , 1 ) ;
8148: LD_ADDR_VAR 0 2
8152: PUSH
8153: LD_VAR 0 2
8157: PPUSH
8158: LD_INT 1
8160: PPUSH
8161: CALL_OW 3
8165: ST_TO_ADDR
8166: GO 8145
8168: POP
8169: POP
// end ;
8170: GO 7966
// end ; end ; end ; result := true ;
8172: LD_ADDR_VAR 0 4
8176: PUSH
8177: LD_INT 1
8179: ST_TO_ADDR
// end ;
8180: LD_VAR 0 4
8184: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8185: LD_INT 0
8187: PPUSH
8188: PPUSH
8189: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: LD_INT 81
8197: PUSH
8198: LD_VAR 0 1
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PPUSH
8207: CALL_OW 69
8211: ST_TO_ADDR
// for i in units do
8212: LD_ADDR_VAR 0 4
8216: PUSH
8217: LD_VAR 0 2
8221: PUSH
8222: FOR_IN
8223: IFFALSE 8251
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8225: LD_VAR 0 4
8229: PPUSH
8230: LD_VAR 0 5
8234: PPUSH
8235: LD_VAR 0 4
8239: PPUSH
8240: CALL_OW 74
8244: PPUSH
8245: CALL_OW 115
// end ;
8249: GO 8222
8251: POP
8252: POP
// end ;
8253: LD_VAR 0 3
8257: RET
// export function MC_Show ( string ) ; begin
8258: LD_INT 0
8260: PPUSH
// display_strings := string ;
8261: LD_ADDR_OWVAR 47
8265: PUSH
8266: LD_VAR 0 1
8270: ST_TO_ADDR
// end ; end_of_file
8271: LD_VAR 0 2
8275: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8276: LD_INT 0
8278: PPUSH
8279: PPUSH
8280: PPUSH
8281: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8282: LD_ADDR_VAR 0 8
8286: PUSH
8287: LD_VAR 0 1
8291: PPUSH
8292: LD_INT 2
8294: PPUSH
8295: EMPTY
8296: PPUSH
8297: CALL 11423 0 3
8301: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8302: LD_VAR 0 8
8306: PUSH
8307: LD_VAR 0 2
8311: PPUSH
8312: LD_VAR 0 3
8316: PPUSH
8317: CALL_OW 428
8321: PUSH
8322: LD_INT 0
8324: EQUAL
8325: AND
8326: IFFALSE 8400
// for i = 1 to plist do
8328: LD_ADDR_VAR 0 6
8332: PUSH
8333: DOUBLE
8334: LD_INT 1
8336: DEC
8337: ST_TO_ADDR
8338: LD_VAR 0 8
8342: PUSH
8343: FOR_TO
8344: IFFALSE 8398
// if NotTask ( plist [ i ] ) then
8346: LD_VAR 0 8
8350: PUSH
8351: LD_VAR 0 6
8355: ARRAY
8356: PPUSH
8357: CALL 32113 0 1
8361: IFFALSE 8396
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8363: LD_VAR 0 8
8367: PUSH
8368: LD_VAR 0 6
8372: ARRAY
8373: PPUSH
8374: LD_INT 0
8376: PPUSH
8377: LD_VAR 0 2
8381: PPUSH
8382: LD_VAR 0 3
8386: PPUSH
8387: LD_VAR 0 4
8391: PPUSH
8392: CALL_OW 145
// end ;
8396: GO 8343
8398: POP
8399: POP
// end ;
8400: LD_VAR 0 5
8404: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8405: LD_INT 0
8407: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8408: LD_VAR 0 1
8412: PPUSH
8413: LD_INT 6
8415: PPUSH
8416: LD_VAR 0 2
8420: PPUSH
8421: LD_VAR 0 3
8425: PPUSH
8426: LD_VAR 0 4
8430: PPUSH
8431: CALL 9909 0 5
// end ;
8435: LD_VAR 0 5
8439: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8440: LD_INT 0
8442: PPUSH
8443: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8444: LD_ADDR_VAR 0 4
8448: PUSH
8449: LD_INT 22
8451: PUSH
8452: LD_VAR 0 1
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PUSH
8461: LD_INT 2
8463: PUSH
8464: LD_INT 30
8466: PUSH
8467: LD_INT 0
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: PUSH
8474: LD_INT 30
8476: PUSH
8477: LD_INT 1
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: LIST
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: PUSH
8493: EMPTY
8494: LIST
8495: PPUSH
8496: CALL_OW 69
8500: PPUSH
8501: LD_VAR 0 2
8505: PPUSH
8506: CALL_OW 250
8510: PPUSH
8511: LD_VAR 0 2
8515: PPUSH
8516: CALL_OW 251
8520: PPUSH
8521: CALL_OW 73
8525: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8526: LD_VAR 0 4
8530: PPUSH
8531: LD_VAR 0 2
8535: PPUSH
8536: CALL 10198 0 2
8540: IFFALSE 8599
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8542: LD_VAR 0 1
8546: PPUSH
8547: LD_INT 30
8549: PUSH
8550: LD_VAR 0 2
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PPUSH
8559: CALL 11340 0 2
8563: PUSH
8564: LD_INT 1
8566: ARRAY
8567: PPUSH
8568: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8572: LD_ADDR_EXP 50
8576: PUSH
8577: LD_EXP 50
8581: PPUSH
8582: LD_VAR 0 1
8586: PPUSH
8587: LD_VAR 0 2
8591: PPUSH
8592: EMPTY
8593: PPUSH
8594: CALL 42147 0 4
8598: ST_TO_ADDR
// end ; end ;
8599: LD_VAR 0 3
8603: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8604: LD_INT 0
8606: PPUSH
8607: PPUSH
8608: PPUSH
8609: PPUSH
8610: PPUSH
8611: PPUSH
// result := false ;
8612: LD_ADDR_VAR 0 4
8616: PUSH
8617: LD_INT 0
8619: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8620: LD_VAR 0 1
8624: PPUSH
8625: LD_EXP 42
8629: PPUSH
8630: CALL 43095 0 2
8634: IFFALSE 8847
// for i = 1 to MREG_LabList do
8636: LD_ADDR_VAR 0 5
8640: PUSH
8641: DOUBLE
8642: LD_INT 1
8644: DEC
8645: ST_TO_ADDR
8646: LD_EXP 42
8650: PUSH
8651: FOR_TO
8652: IFFALSE 8845
// begin if MREG_LabList [ i ] [ 1 ] = side then
8654: LD_EXP 42
8658: PUSH
8659: LD_VAR 0 5
8663: ARRAY
8664: PUSH
8665: LD_INT 1
8667: ARRAY
8668: PUSH
8669: LD_VAR 0 1
8673: EQUAL
8674: IFFALSE 8843
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8676: LD_ADDR_VAR 0 7
8680: PUSH
8681: LD_EXP 42
8685: PUSH
8686: LD_VAR 0 5
8690: ARRAY
8691: PUSH
8692: LD_INT 2
8694: ARRAY
8695: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8696: LD_ADDR_VAR 0 9
8700: PUSH
8701: LD_INT 22
8703: PUSH
8704: LD_VAR 0 1
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: LD_INT 2
8715: PUSH
8716: LD_INT 30
8718: PUSH
8719: LD_INT 0
8721: PUSH
8722: EMPTY
8723: LIST
8724: LIST
8725: PUSH
8726: LD_INT 30
8728: PUSH
8729: LD_INT 1
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: LIST
8740: PUSH
8741: EMPTY
8742: LIST
8743: LIST
8744: PUSH
8745: EMPTY
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: PPUSH
8753: LD_VAR 0 7
8757: PPUSH
8758: CALL_OW 250
8762: PPUSH
8763: LD_VAR 0 7
8767: PPUSH
8768: CALL_OW 251
8772: PPUSH
8773: CALL_OW 73
8777: ST_TO_ADDR
// if dep then
8778: LD_VAR 0 9
8782: IFFALSE 8841
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8784: LD_VAR 0 9
8788: PPUSH
8789: LD_VAR 0 2
8793: PPUSH
8794: LD_VAR 0 3
8798: PPUSH
8799: CALL 10314 0 3
8803: IFFALSE 8841
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
8805: LD_VAR 0 7
8809: PPUSH
8810: LD_VAR 0 2
8814: PPUSH
8815: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
8819: LD_VAR 0 7
8823: PPUSH
8824: LD_VAR 0 3
8828: PPUSH
8829: CALL_OW 207
// result := true ;
8833: LD_ADDR_VAR 0 4
8837: PUSH
8838: LD_INT 1
8840: ST_TO_ADDR
// end ; end ; break ;
8841: GO 8845
// end ; end ;
8843: GO 8651
8845: POP
8846: POP
// end ;
8847: LD_VAR 0 4
8851: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
8852: LD_INT 0
8854: PPUSH
8855: PPUSH
8856: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
8857: LD_ADDR_VAR 0 7
8861: PUSH
8862: LD_VAR 0 2
8866: PPUSH
8867: LD_VAR 0 3
8871: PPUSH
8872: LD_VAR 0 4
8876: PPUSH
8877: CALL 9039 0 3
8881: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
8882: LD_ADDR_EXP 48
8886: PUSH
8887: LD_EXP 48
8891: PPUSH
8892: LD_VAR 0 1
8896: PPUSH
8897: LD_INT 2
8899: PPUSH
8900: LD_VAR 0 2
8904: PUSH
8905: LD_VAR 0 3
8909: PUSH
8910: LD_VAR 0 4
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL 42056 0 4
8924: ST_TO_ADDR
// if ext_list then
8925: LD_VAR 0 5
8929: IFFALSE 9034
// for i = 1 to ext_list do
8931: LD_ADDR_VAR 0 8
8935: PUSH
8936: DOUBLE
8937: LD_INT 1
8939: DEC
8940: ST_TO_ADDR
8941: LD_VAR 0 5
8945: PUSH
8946: FOR_TO
8947: IFFALSE 9032
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
8949: LD_ADDR_EXP 48
8953: PUSH
8954: LD_EXP 48
8958: PPUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: LD_VAR 0 5
8968: PUSH
8969: LD_VAR 0 8
8973: ARRAY
8974: PPUSH
8975: LD_VAR 0 7
8979: PUSH
8980: LD_VAR 0 8
8984: ARRAY
8985: PUSH
8986: LD_INT 1
8988: ARRAY
8989: PUSH
8990: LD_VAR 0 7
8994: PUSH
8995: LD_VAR 0 8
8999: ARRAY
9000: PUSH
9001: LD_INT 2
9003: ARRAY
9004: PUSH
9005: LD_VAR 0 7
9009: PUSH
9010: LD_VAR 0 8
9014: ARRAY
9015: PUSH
9016: LD_INT 3
9018: ARRAY
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: LIST
9024: PPUSH
9025: CALL 42056 0 4
9029: ST_TO_ADDR
9030: GO 8946
9032: POP
9033: POP
// end ;
9034: LD_VAR 0 6
9038: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9039: LD_INT 0
9041: PPUSH
9042: PPUSH
// list := [ ] ;
9043: LD_ADDR_VAR 0 5
9047: PUSH
9048: EMPTY
9049: ST_TO_ADDR
// case d of 0 :
9050: LD_VAR 0 3
9054: PUSH
9055: LD_INT 0
9057: DOUBLE
9058: EQUAL
9059: IFTRUE 9063
9061: GO 9196
9063: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9064: LD_ADDR_VAR 0 5
9068: PUSH
9069: LD_VAR 0 1
9073: PUSH
9074: LD_INT 4
9076: MINUS
9077: PUSH
9078: LD_VAR 0 2
9082: PUSH
9083: LD_INT 4
9085: MINUS
9086: PUSH
9087: LD_INT 2
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: LD_VAR 0 1
9099: PUSH
9100: LD_INT 3
9102: MINUS
9103: PUSH
9104: LD_VAR 0 2
9108: PUSH
9109: LD_INT 1
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: PUSH
9117: LD_VAR 0 1
9121: PUSH
9122: LD_INT 4
9124: PLUS
9125: PUSH
9126: LD_VAR 0 2
9130: PUSH
9131: LD_INT 4
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: LIST
9138: PUSH
9139: LD_VAR 0 1
9143: PUSH
9144: LD_INT 3
9146: PLUS
9147: PUSH
9148: LD_VAR 0 2
9152: PUSH
9153: LD_INT 3
9155: PLUS
9156: PUSH
9157: LD_INT 5
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: LIST
9164: PUSH
9165: LD_VAR 0 1
9169: PUSH
9170: LD_VAR 0 2
9174: PUSH
9175: LD_INT 4
9177: PLUS
9178: PUSH
9179: LD_INT 0
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: LIST
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: LIST
9193: ST_TO_ADDR
// end ; 1 :
9194: GO 9894
9196: LD_INT 1
9198: DOUBLE
9199: EQUAL
9200: IFTRUE 9204
9202: GO 9337
9204: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9205: LD_ADDR_VAR 0 5
9209: PUSH
9210: LD_VAR 0 1
9214: PUSH
9215: LD_VAR 0 2
9219: PUSH
9220: LD_INT 4
9222: MINUS
9223: PUSH
9224: LD_INT 3
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: LIST
9231: PUSH
9232: LD_VAR 0 1
9236: PUSH
9237: LD_INT 3
9239: MINUS
9240: PUSH
9241: LD_VAR 0 2
9245: PUSH
9246: LD_INT 3
9248: MINUS
9249: PUSH
9250: LD_INT 2
9252: PUSH
9253: EMPTY
9254: LIST
9255: LIST
9256: LIST
9257: PUSH
9258: LD_VAR 0 1
9262: PUSH
9263: LD_INT 4
9265: MINUS
9266: PUSH
9267: LD_VAR 0 2
9271: PUSH
9272: LD_INT 1
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: LIST
9279: PUSH
9280: LD_VAR 0 1
9284: PUSH
9285: LD_VAR 0 2
9289: PUSH
9290: LD_INT 3
9292: PLUS
9293: PUSH
9294: LD_INT 0
9296: PUSH
9297: EMPTY
9298: LIST
9299: LIST
9300: LIST
9301: PUSH
9302: LD_VAR 0 1
9306: PUSH
9307: LD_INT 4
9309: PLUS
9310: PUSH
9311: LD_VAR 0 2
9315: PUSH
9316: LD_INT 4
9318: PLUS
9319: PUSH
9320: LD_INT 5
9322: PUSH
9323: EMPTY
9324: LIST
9325: LIST
9326: LIST
9327: PUSH
9328: EMPTY
9329: LIST
9330: LIST
9331: LIST
9332: LIST
9333: LIST
9334: ST_TO_ADDR
// end ; 2 :
9335: GO 9894
9337: LD_INT 2
9339: DOUBLE
9340: EQUAL
9341: IFTRUE 9345
9343: GO 9474
9345: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9346: LD_ADDR_VAR 0 5
9350: PUSH
9351: LD_VAR 0 1
9355: PUSH
9356: LD_VAR 0 2
9360: PUSH
9361: LD_INT 3
9363: MINUS
9364: PUSH
9365: LD_INT 3
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: LIST
9372: PUSH
9373: LD_VAR 0 1
9377: PUSH
9378: LD_INT 4
9380: PLUS
9381: PUSH
9382: LD_VAR 0 2
9386: PUSH
9387: LD_INT 4
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: LIST
9394: PUSH
9395: LD_VAR 0 1
9399: PUSH
9400: LD_VAR 0 2
9404: PUSH
9405: LD_INT 4
9407: PLUS
9408: PUSH
9409: LD_INT 0
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: LIST
9416: PUSH
9417: LD_VAR 0 1
9421: PUSH
9422: LD_INT 3
9424: MINUS
9425: PUSH
9426: LD_VAR 0 2
9430: PUSH
9431: LD_INT 1
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: PUSH
9439: LD_VAR 0 1
9443: PUSH
9444: LD_INT 4
9446: MINUS
9447: PUSH
9448: LD_VAR 0 2
9452: PUSH
9453: LD_INT 4
9455: MINUS
9456: PUSH
9457: LD_INT 2
9459: PUSH
9460: EMPTY
9461: LIST
9462: LIST
9463: LIST
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: LIST
9469: LIST
9470: LIST
9471: ST_TO_ADDR
// end ; 3 :
9472: GO 9894
9474: LD_INT 3
9476: DOUBLE
9477: EQUAL
9478: IFTRUE 9482
9480: GO 9615
9482: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9483: LD_ADDR_VAR 0 5
9487: PUSH
9488: LD_VAR 0 1
9492: PUSH
9493: LD_INT 3
9495: PLUS
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PUSH
9505: EMPTY
9506: LIST
9507: LIST
9508: LIST
9509: PUSH
9510: LD_VAR 0 1
9514: PUSH
9515: LD_INT 4
9517: PLUS
9518: PUSH
9519: LD_VAR 0 2
9523: PUSH
9524: LD_INT 4
9526: PLUS
9527: PUSH
9528: LD_INT 5
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: LIST
9535: PUSH
9536: LD_VAR 0 1
9540: PUSH
9541: LD_INT 4
9543: MINUS
9544: PUSH
9545: LD_VAR 0 2
9549: PUSH
9550: LD_INT 1
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_VAR 0 1
9562: PUSH
9563: LD_VAR 0 2
9567: PUSH
9568: LD_INT 4
9570: MINUS
9571: PUSH
9572: LD_INT 3
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: PUSH
9580: LD_VAR 0 1
9584: PUSH
9585: LD_INT 3
9587: MINUS
9588: PUSH
9589: LD_VAR 0 2
9593: PUSH
9594: LD_INT 3
9596: MINUS
9597: PUSH
9598: LD_INT 2
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: ST_TO_ADDR
// end ; 4 :
9613: GO 9894
9615: LD_INT 4
9617: DOUBLE
9618: EQUAL
9619: IFTRUE 9623
9621: GO 9756
9623: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9624: LD_ADDR_VAR 0 5
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_VAR 0 2
9638: PUSH
9639: LD_INT 4
9641: PLUS
9642: PUSH
9643: LD_INT 0
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: LIST
9650: PUSH
9651: LD_VAR 0 1
9655: PUSH
9656: LD_INT 3
9658: PLUS
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: LD_INT 3
9667: PLUS
9668: PUSH
9669: LD_INT 5
9671: PUSH
9672: EMPTY
9673: LIST
9674: LIST
9675: LIST
9676: PUSH
9677: LD_VAR 0 1
9681: PUSH
9682: LD_INT 3
9684: PLUS
9685: PUSH
9686: LD_VAR 0 2
9690: PUSH
9691: LD_INT 4
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PUSH
9699: LD_VAR 0 1
9703: PUSH
9704: LD_VAR 0 2
9708: PUSH
9709: LD_INT 3
9711: MINUS
9712: PUSH
9713: LD_INT 3
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: LIST
9720: PUSH
9721: LD_VAR 0 1
9725: PUSH
9726: LD_INT 4
9728: MINUS
9729: PUSH
9730: LD_VAR 0 2
9734: PUSH
9735: LD_INT 4
9737: MINUS
9738: PUSH
9739: LD_INT 2
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: ST_TO_ADDR
// end ; 5 :
9754: GO 9894
9756: LD_INT 5
9758: DOUBLE
9759: EQUAL
9760: IFTRUE 9764
9762: GO 9893
9764: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9765: LD_ADDR_VAR 0 5
9769: PUSH
9770: LD_VAR 0 1
9774: PUSH
9775: LD_INT 4
9777: MINUS
9778: PUSH
9779: LD_VAR 0 2
9783: PUSH
9784: LD_INT 1
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: LD_VAR 0 1
9796: PUSH
9797: LD_VAR 0 2
9801: PUSH
9802: LD_INT 4
9804: MINUS
9805: PUSH
9806: LD_INT 3
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: LIST
9813: PUSH
9814: LD_VAR 0 1
9818: PUSH
9819: LD_INT 4
9821: PLUS
9822: PUSH
9823: LD_VAR 0 2
9827: PUSH
9828: LD_INT 4
9830: PLUS
9831: PUSH
9832: LD_INT 5
9834: PUSH
9835: EMPTY
9836: LIST
9837: LIST
9838: LIST
9839: PUSH
9840: LD_VAR 0 1
9844: PUSH
9845: LD_INT 3
9847: PLUS
9848: PUSH
9849: LD_VAR 0 2
9853: PUSH
9854: LD_INT 4
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: LIST
9861: PUSH
9862: LD_VAR 0 1
9866: PUSH
9867: LD_VAR 0 2
9871: PUSH
9872: LD_INT 3
9874: PLUS
9875: PUSH
9876: LD_INT 0
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: LIST
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: ST_TO_ADDR
// end ; end ;
9891: GO 9894
9893: POP
// result := list ;
9894: LD_ADDR_VAR 0 4
9898: PUSH
9899: LD_VAR 0 5
9903: ST_TO_ADDR
// end ;
9904: LD_VAR 0 4
9908: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
9909: LD_INT 0
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
9916: LD_ADDR_VAR 0 10
9920: PUSH
9921: LD_VAR 0 1
9925: PPUSH
9926: LD_INT 2
9928: PPUSH
9929: EMPTY
9930: PPUSH
9931: CALL 11423 0 3
9935: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
9936: LD_ADDR_VAR 0 9
9940: PUSH
9941: LD_INT 22
9943: PUSH
9944: LD_VAR 0 1
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: PUSH
9953: LD_INT 2
9955: PUSH
9956: LD_INT 30
9958: PUSH
9959: LD_INT 0
9961: PUSH
9962: EMPTY
9963: LIST
9964: LIST
9965: PUSH
9966: LD_INT 30
9968: PUSH
9969: LD_INT 1
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: LIST
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PUSH
9985: EMPTY
9986: LIST
9987: PPUSH
9988: CALL_OW 69
9992: PPUSH
9993: LD_VAR 0 3
9997: PPUSH
9998: LD_VAR 0 4
10002: PPUSH
10003: CALL_OW 73
10007: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10008: LD_ADDR_VAR 0 8
10012: PUSH
10013: LD_VAR 0 9
10017: PPUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: CALL 10198 0 2
10027: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10028: LD_VAR 0 10
10032: PUSH
10033: LD_VAR 0 8
10037: AND
10038: PUSH
10039: LD_VAR 0 9
10043: PPUSH
10044: LD_VAR 0 3
10048: PPUSH
10049: LD_VAR 0 4
10053: PPUSH
10054: CALL_OW 297
10058: PUSH
10059: LD_INT 26
10061: LESSEQUAL
10062: AND
10063: PUSH
10064: LD_VAR 0 3
10068: PPUSH
10069: LD_VAR 0 4
10073: PPUSH
10074: CALL_OW 428
10078: PUSH
10079: LD_INT 0
10081: EQUAL
10082: AND
10083: IFFALSE 10193
// for i = 1 to plist do
10085: LD_ADDR_VAR 0 7
10089: PUSH
10090: DOUBLE
10091: LD_INT 1
10093: DEC
10094: ST_TO_ADDR
10095: LD_VAR 0 10
10099: PUSH
10100: FOR_TO
10101: IFFALSE 10191
// if IsInUnit ( plist [ i ] ) then
10103: LD_VAR 0 10
10107: PUSH
10108: LD_VAR 0 7
10112: ARRAY
10113: PPUSH
10114: CALL_OW 310
10118: IFFALSE 10137
// ComExitBuilding ( plist [ i ] ) else
10120: LD_VAR 0 10
10124: PUSH
10125: LD_VAR 0 7
10129: ARRAY
10130: PPUSH
10131: CALL_OW 122
10135: GO 10189
// if NotTask ( plist [ i ] ) then
10137: LD_VAR 0 10
10141: PUSH
10142: LD_VAR 0 7
10146: ARRAY
10147: PPUSH
10148: CALL 32113 0 1
10152: IFFALSE 10189
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10154: LD_VAR 0 10
10158: PUSH
10159: LD_VAR 0 7
10163: ARRAY
10164: PPUSH
10165: LD_VAR 0 2
10169: PPUSH
10170: LD_VAR 0 3
10174: PPUSH
10175: LD_VAR 0 4
10179: PPUSH
10180: LD_VAR 0 5
10184: PPUSH
10185: CALL_OW 145
// end ;
10189: GO 10100
10191: POP
10192: POP
// end ;
10193: LD_VAR 0 6
10197: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10198: LD_INT 0
10200: PPUSH
10201: PPUSH
10202: PPUSH
// pom := GetBase ( bdepot ) ;
10203: LD_ADDR_VAR 0 4
10207: PUSH
10208: LD_VAR 0 1
10212: PPUSH
10213: CALL_OW 274
10217: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10218: LD_ADDR_VAR 0 5
10222: PUSH
10223: LD_VAR 0 2
10227: PPUSH
10228: LD_VAR 0 1
10232: PPUSH
10233: CALL_OW 248
10237: PPUSH
10238: CALL_OW 450
10242: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10243: LD_VAR 0 4
10247: PPUSH
10248: LD_INT 1
10250: PPUSH
10251: CALL_OW 275
10255: PUSH
10256: LD_VAR 0 5
10260: PUSH
10261: LD_INT 1
10263: ARRAY
10264: GREATEREQUAL
10265: PUSH
10266: LD_VAR 0 4
10270: PPUSH
10271: LD_INT 3
10273: PPUSH
10274: CALL_OW 275
10278: PUSH
10279: LD_VAR 0 5
10283: PUSH
10284: LD_INT 3
10286: ARRAY
10287: GREATEREQUAL
10288: AND
10289: IFFALSE 10301
// result := true else
10291: LD_ADDR_VAR 0 3
10295: PUSH
10296: LD_INT 1
10298: ST_TO_ADDR
10299: GO 10309
// result := false ;
10301: LD_ADDR_VAR 0 3
10305: PUSH
10306: LD_INT 0
10308: ST_TO_ADDR
// end ;
10309: LD_VAR 0 3
10313: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10314: LD_INT 0
10316: PPUSH
10317: PPUSH
10318: PPUSH
10319: PPUSH
10320: PPUSH
// pom := GetBase ( bdepot ) ;
10321: LD_ADDR_VAR 0 5
10325: PUSH
10326: LD_VAR 0 1
10330: PPUSH
10331: CALL_OW 274
10335: ST_TO_ADDR
// cost := [ ] ;
10336: LD_ADDR_VAR 0 8
10340: PUSH
10341: EMPTY
10342: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10343: LD_ADDR_VAR 0 6
10347: PUSH
10348: LD_VAR 0 2
10352: PPUSH
10353: LD_VAR 0 1
10357: PPUSH
10358: CALL_OW 248
10362: PPUSH
10363: CALL_OW 450
10367: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10368: LD_ADDR_VAR 0 7
10372: PUSH
10373: LD_VAR 0 3
10377: PPUSH
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 248
10387: PPUSH
10388: CALL_OW 450
10392: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10393: LD_ADDR_VAR 0 8
10397: PUSH
10398: LD_VAR 0 8
10402: PPUSH
10403: LD_INT 1
10405: PPUSH
10406: LD_VAR 0 6
10410: PUSH
10411: LD_INT 1
10413: ARRAY
10414: PUSH
10415: LD_VAR 0 7
10419: PUSH
10420: LD_INT 1
10422: ARRAY
10423: PLUS
10424: PPUSH
10425: CALL_OW 1
10429: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10430: LD_ADDR_VAR 0 8
10434: PUSH
10435: LD_VAR 0 8
10439: PPUSH
10440: LD_INT 2
10442: PPUSH
10443: LD_VAR 0 6
10447: PUSH
10448: LD_INT 2
10450: ARRAY
10451: PUSH
10452: LD_VAR 0 7
10456: PUSH
10457: LD_INT 2
10459: ARRAY
10460: PLUS
10461: PPUSH
10462: CALL_OW 1
10466: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10467: LD_ADDR_VAR 0 8
10471: PUSH
10472: LD_VAR 0 8
10476: PPUSH
10477: LD_INT 3
10479: PPUSH
10480: LD_VAR 0 6
10484: PUSH
10485: LD_INT 3
10487: ARRAY
10488: PUSH
10489: LD_VAR 0 7
10493: PUSH
10494: LD_INT 3
10496: ARRAY
10497: PLUS
10498: PPUSH
10499: CALL_OW 1
10503: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10504: LD_VAR 0 5
10508: PPUSH
10509: LD_INT 1
10511: PPUSH
10512: CALL_OW 275
10516: PUSH
10517: LD_VAR 0 8
10521: PUSH
10522: LD_INT 1
10524: ARRAY
10525: GREATEREQUAL
10526: PUSH
10527: LD_VAR 0 5
10531: PPUSH
10532: LD_INT 3
10534: PPUSH
10535: CALL_OW 275
10539: PUSH
10540: LD_VAR 0 8
10544: PUSH
10545: LD_INT 3
10547: ARRAY
10548: GREATEREQUAL
10549: AND
10550: IFFALSE 10562
// result := true else
10552: LD_ADDR_VAR 0 4
10556: PUSH
10557: LD_INT 1
10559: ST_TO_ADDR
10560: GO 10570
// result := false ;
10562: LD_ADDR_VAR 0 4
10566: PUSH
10567: LD_INT 0
10569: ST_TO_ADDR
// end ;
10570: LD_VAR 0 4
10574: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10575: LD_INT 0
10577: PPUSH
10578: PPUSH
10579: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10580: LD_ADDR_VAR 0 5
10584: PUSH
10585: LD_VAR 0 1
10589: PPUSH
10590: LD_INT 2
10592: PPUSH
10593: EMPTY
10594: PPUSH
10595: CALL 11423 0 3
10599: ST_TO_ADDR
// if unit and plist then
10600: LD_VAR 0 2
10604: PUSH
10605: LD_VAR 0 5
10609: AND
10610: IFFALSE 10671
// for i = 1 to plist do
10612: LD_ADDR_VAR 0 4
10616: PUSH
10617: DOUBLE
10618: LD_INT 1
10620: DEC
10621: ST_TO_ADDR
10622: LD_VAR 0 5
10626: PUSH
10627: FOR_TO
10628: IFFALSE 10669
// if NotTask ( plist [ i ] ) then
10630: LD_VAR 0 5
10634: PUSH
10635: LD_VAR 0 4
10639: ARRAY
10640: PPUSH
10641: CALL 32113 0 1
10645: IFFALSE 10667
// ComDismantle ( plist [ i ] , unit ) ;
10647: LD_VAR 0 5
10651: PUSH
10652: LD_VAR 0 4
10656: ARRAY
10657: PPUSH
10658: LD_VAR 0 2
10662: PPUSH
10663: CALL_OW 167
10667: GO 10627
10669: POP
10670: POP
// result := true ;
10671: LD_ADDR_VAR 0 3
10675: PUSH
10676: LD_INT 1
10678: ST_TO_ADDR
// end ;
10679: LD_VAR 0 3
10683: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10684: LD_INT 0
10686: PPUSH
10687: PPUSH
10688: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10689: LD_ADDR_VAR 0 5
10693: PUSH
10694: LD_VAR 0 1
10698: PPUSH
10699: LD_INT 2
10701: PPUSH
10702: EMPTY
10703: PPUSH
10704: CALL 11423 0 3
10708: ST_TO_ADDR
// if unit and plist then
10709: LD_VAR 0 2
10713: PUSH
10714: LD_VAR 0 5
10718: AND
10719: IFFALSE 10780
// for i = 1 to plist do
10721: LD_ADDR_VAR 0 4
10725: PUSH
10726: DOUBLE
10727: LD_INT 1
10729: DEC
10730: ST_TO_ADDR
10731: LD_VAR 0 5
10735: PUSH
10736: FOR_TO
10737: IFFALSE 10778
// if NotTask ( plist [ i ] ) then
10739: LD_VAR 0 5
10743: PUSH
10744: LD_VAR 0 4
10748: ARRAY
10749: PPUSH
10750: CALL 32113 0 1
10754: IFFALSE 10776
// ComComplete ( plist [ i ] , unit ) ;
10756: LD_VAR 0 5
10760: PUSH
10761: LD_VAR 0 4
10765: ARRAY
10766: PPUSH
10767: LD_VAR 0 2
10771: PPUSH
10772: CALL 31649 0 2
10776: GO 10736
10778: POP
10779: POP
// result := true ;
10780: LD_ADDR_VAR 0 3
10784: PUSH
10785: LD_INT 1
10787: ST_TO_ADDR
// end ;
10788: LD_VAR 0 3
10792: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
10793: LD_INT 0
10795: PPUSH
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
10800: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
10801: LD_ADDR_VAR 0 5
10805: PUSH
10806: LD_INT 22
10808: PUSH
10809: LD_VAR 0 1
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PUSH
10818: LD_INT 21
10820: PUSH
10821: LD_INT 3
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: LD_INT 3
10830: PUSH
10831: LD_INT 57
10833: PUSH
10834: EMPTY
10835: LIST
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: PUSH
10841: LD_INT 3
10843: PUSH
10844: LD_INT 24
10846: PUSH
10847: LD_INT 1000
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: PPUSH
10864: CALL_OW 69
10868: ST_TO_ADDR
// r := [ ] ;
10869: LD_ADDR_VAR 0 6
10873: PUSH
10874: EMPTY
10875: ST_TO_ADDR
// if not tmp then
10876: LD_VAR 0 5
10880: NOT
10881: IFFALSE 10887
// exit else
10883: GO 11075
10885: GO 11055
// begin r := [ tmp [ 1 ] ] ;
10887: LD_ADDR_VAR 0 6
10891: PUSH
10892: LD_VAR 0 5
10896: PUSH
10897: LD_INT 1
10899: ARRAY
10900: PUSH
10901: EMPTY
10902: LIST
10903: ST_TO_ADDR
// for i = 2 to tmp do
10904: LD_ADDR_VAR 0 3
10908: PUSH
10909: DOUBLE
10910: LD_INT 2
10912: DEC
10913: ST_TO_ADDR
10914: LD_VAR 0 5
10918: PUSH
10919: FOR_TO
10920: IFFALSE 11053
// begin m := false ;
10922: LD_ADDR_VAR 0 7
10926: PUSH
10927: LD_INT 0
10929: ST_TO_ADDR
// for j = 1 to r do
10930: LD_ADDR_VAR 0 4
10934: PUSH
10935: DOUBLE
10936: LD_INT 1
10938: DEC
10939: ST_TO_ADDR
10940: LD_VAR 0 6
10944: PUSH
10945: FOR_TO
10946: IFFALSE 11020
// if GetLives ( tmp [ i ] ) < r [ j ] then
10948: LD_VAR 0 5
10952: PUSH
10953: LD_VAR 0 3
10957: ARRAY
10958: PPUSH
10959: CALL_OW 256
10963: PUSH
10964: LD_VAR 0 6
10968: PUSH
10969: LD_VAR 0 4
10973: ARRAY
10974: LESS
10975: IFFALSE 11018
// begin r := Insert ( r , j , tmp [ i ] ) ;
10977: LD_ADDR_VAR 0 6
10981: PUSH
10982: LD_VAR 0 6
10986: PPUSH
10987: LD_VAR 0 4
10991: PPUSH
10992: LD_VAR 0 5
10996: PUSH
10997: LD_VAR 0 3
11001: ARRAY
11002: PPUSH
11003: CALL_OW 2
11007: ST_TO_ADDR
// m := true ;
11008: LD_ADDR_VAR 0 7
11012: PUSH
11013: LD_INT 1
11015: ST_TO_ADDR
// break ;
11016: GO 11020
// end ;
11018: GO 10945
11020: POP
11021: POP
// if not m then
11022: LD_VAR 0 7
11026: NOT
11027: IFFALSE 11051
// r := r ^ tmp [ i ] ;
11029: LD_ADDR_VAR 0 6
11033: PUSH
11034: LD_VAR 0 6
11038: PUSH
11039: LD_VAR 0 5
11043: PUSH
11044: LD_VAR 0 3
11048: ARRAY
11049: ADD
11050: ST_TO_ADDR
// end ;
11051: GO 10919
11053: POP
11054: POP
// end ; if r then
11055: LD_VAR 0 6
11059: IFFALSE 11073
// result := r else
11061: LD_ADDR_VAR 0 2
11065: PUSH
11066: LD_VAR 0 6
11070: ST_TO_ADDR
11071: GO 11075
// exit ;
11073: GO 11075
// end ;
11075: LD_VAR 0 2
11079: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11080: LD_INT 0
11082: PPUSH
11083: PPUSH
11084: PPUSH
11085: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11086: LD_ADDR_VAR 0 5
11090: PUSH
11091: LD_INT 22
11093: PUSH
11094: LD_VAR 0 1
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: PUSH
11103: LD_INT 2
11105: PUSH
11106: LD_INT 25
11108: PUSH
11109: LD_INT 2
11111: PUSH
11112: EMPTY
11113: LIST
11114: LIST
11115: PUSH
11116: LD_INT 25
11118: PUSH
11119: LD_INT 16
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 34
11128: PUSH
11129: LD_INT 13
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: LD_INT 34
11138: PUSH
11139: LD_INT 52
11141: PUSH
11142: EMPTY
11143: LIST
11144: LIST
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: PUSH
11153: LD_INT 24
11155: PUSH
11156: LD_INT 650
11158: PUSH
11159: EMPTY
11160: LIST
11161: LIST
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: PPUSH
11168: CALL_OW 69
11172: ST_TO_ADDR
// p := 1 ;
11173: LD_ADDR_VAR 0 4
11177: PUSH
11178: LD_INT 1
11180: ST_TO_ADDR
// for i = 1 to repairs do
11181: LD_ADDR_VAR 0 3
11185: PUSH
11186: DOUBLE
11187: LD_INT 1
11189: DEC
11190: ST_TO_ADDR
11191: LD_VAR 0 5
11195: PUSH
11196: FOR_TO
11197: IFFALSE 11333
// begin if IsInUnit ( repairs [ i ] ) then
11199: LD_VAR 0 5
11203: PUSH
11204: LD_VAR 0 3
11208: ARRAY
11209: PPUSH
11210: CALL_OW 310
11214: IFFALSE 11233
// ComExitBuilding ( repairs [ i ] ) else
11216: LD_VAR 0 5
11220: PUSH
11221: LD_VAR 0 3
11225: ARRAY
11226: PPUSH
11227: CALL_OW 122
11231: GO 11331
// if not HasTask ( repairs [ i ] ) then
11233: LD_VAR 0 5
11237: PUSH
11238: LD_VAR 0 3
11242: ARRAY
11243: PPUSH
11244: CALL_OW 314
11248: NOT
11249: IFFALSE 11331
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11251: LD_VAR 0 5
11255: PUSH
11256: LD_VAR 0 3
11260: ARRAY
11261: PPUSH
11262: LD_EXP 49
11266: PUSH
11267: LD_VAR 0 1
11271: ARRAY
11272: PUSH
11273: LD_VAR 0 4
11277: ARRAY
11278: PPUSH
11279: CALL_OW 130
// if i mod 3 = 0 then
11283: LD_VAR 0 3
11287: PUSH
11288: LD_INT 3
11290: MOD
11291: PUSH
11292: LD_INT 0
11294: EQUAL
11295: IFFALSE 11311
// p := p + 1 ;
11297: LD_ADDR_VAR 0 4
11301: PUSH
11302: LD_VAR 0 4
11306: PUSH
11307: LD_INT 1
11309: PLUS
11310: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11311: LD_EXP 49
11315: PUSH
11316: LD_VAR 0 1
11320: ARRAY
11321: PUSH
11322: LD_VAR 0 4
11326: LESS
11327: IFFALSE 11331
// break ;
11329: GO 11333
// end ; end ;
11331: GO 11196
11333: POP
11334: POP
// end ; end_of_file
11335: LD_VAR 0 2
11339: RET
// export function MCF_Get ( side , filter ) ; begin
11340: LD_INT 0
11342: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11343: LD_ADDR_VAR 0 3
11347: PUSH
11348: LD_INT 22
11350: PUSH
11351: LD_VAR 0 1
11355: PUSH
11356: EMPTY
11357: LIST
11358: LIST
11359: PUSH
11360: LD_VAR 0 2
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PPUSH
11369: CALL_OW 69
11373: ST_TO_ADDR
// end ;
11374: LD_VAR 0 3
11378: RET
// export function MCF_Lab ( side ) ; begin
11379: LD_INT 0
11381: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11382: LD_ADDR_VAR 0 2
11386: PUSH
11387: LD_INT 22
11389: PUSH
11390: LD_VAR 0 1
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: PUSH
11399: LD_INT 30
11401: PUSH
11402: LD_INT 8
11404: PUSH
11405: EMPTY
11406: LIST
11407: LIST
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: PPUSH
11413: CALL_OW 69
11417: ST_TO_ADDR
// end ;
11418: LD_VAR 0 2
11422: RET
// export function MCF_Class ( side , class , filter ) ; begin
11423: LD_INT 0
11425: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11426: LD_ADDR_VAR 0 4
11430: PUSH
11431: LD_INT 22
11433: PUSH
11434: LD_VAR 0 1
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_VAR 0 2
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PUSH
11455: LD_VAR 0 3
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: LIST
11464: PPUSH
11465: CALL_OW 69
11469: ST_TO_ADDR
// end ;
11470: LD_VAR 0 4
11474: RET
// export function MCF_All ( side , filter ) ; begin
11475: LD_INT 0
11477: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11478: LD_ADDR_VAR 0 3
11482: PUSH
11483: LD_INT 22
11485: PUSH
11486: LD_VAR 0 1
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PUSH
11495: LD_INT 2
11497: PUSH
11498: LD_INT 25
11500: PUSH
11501: LD_INT 1
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: LD_INT 25
11510: PUSH
11511: LD_INT 2
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: PUSH
11518: LD_INT 25
11520: PUSH
11521: LD_INT 3
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: PUSH
11528: LD_INT 25
11530: PUSH
11531: LD_INT 4
11533: PUSH
11534: EMPTY
11535: LIST
11536: LIST
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: PUSH
11545: LD_VAR 0 2
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: LIST
11554: PPUSH
11555: CALL_OW 69
11559: ST_TO_ADDR
// end ;
11560: LD_VAR 0 3
11564: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11565: LD_INT 0
11567: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11568: LD_ADDR_VAR 0 4
11572: PUSH
11573: LD_INT 22
11575: PUSH
11576: LD_VAR 0 1
11580: PUSH
11581: EMPTY
11582: LIST
11583: LIST
11584: PUSH
11585: LD_INT 92
11587: PUSH
11588: LD_VAR 0 2
11592: PUSH
11593: LD_INT 1
11595: ARRAY
11596: PUSH
11597: LD_VAR 0 2
11601: PUSH
11602: LD_INT 2
11604: ARRAY
11605: PUSH
11606: LD_VAR 0 2
11610: PUSH
11611: LD_INT 3
11613: ARRAY
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: PUSH
11621: LD_VAR 0 3
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: PPUSH
11631: CALL_OW 69
11635: ST_TO_ADDR
// end ;
11636: LD_VAR 0 4
11640: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11641: LD_INT 0
11643: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11644: LD_ADDR_VAR 0 3
11648: PUSH
11649: LD_INT 22
11651: PUSH
11652: LD_VAR 0 1
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PUSH
11661: LD_INT 21
11663: PUSH
11664: LD_INT 2
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: LIST
11680: PPUSH
11681: CALL_OW 69
11685: ST_TO_ADDR
// end ;
11686: LD_VAR 0 3
11690: RET
// export function MCF_Cargo ( side ) ; begin
11691: LD_INT 0
11693: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11694: LD_ADDR_VAR 0 2
11698: PUSH
11699: LD_VAR 0 1
11703: PPUSH
11704: LD_INT 2
11706: PUSH
11707: LD_INT 34
11709: PUSH
11710: LD_INT 12
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: PUSH
11717: LD_INT 34
11719: PUSH
11720: LD_INT 32
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PUSH
11727: LD_INT 34
11729: PUSH
11730: LD_INT 51
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: PPUSH
11743: CALL 11641 0 2
11747: ST_TO_ADDR
// end ;
11748: LD_VAR 0 2
11752: RET
// export function MCF_Ape ( side ) ; begin
11753: LD_INT 0
11755: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11756: LD_ADDR_VAR 0 2
11760: PUSH
11761: LD_INT 22
11763: PUSH
11764: LD_VAR 0 1
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 2
11775: PUSH
11776: LD_INT 25
11778: PUSH
11779: LD_INT 12
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: PUSH
11786: LD_INT 25
11788: PUSH
11789: LD_INT 15
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: PUSH
11796: LD_INT 25
11798: PUSH
11799: LD_INT 16
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 25
11808: PUSH
11809: LD_INT 17
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: PPUSH
11827: CALL_OW 69
11831: ST_TO_ADDR
// end ;
11832: LD_VAR 0 2
11836: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
11837: LD_INT 0
11839: PPUSH
11840: PPUSH
11841: PPUSH
11842: PPUSH
// result := [ ] ;
11843: LD_ADDR_VAR 0 3
11847: PUSH
11848: EMPTY
11849: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
11850: LD_ADDR_VAR 0 4
11854: PUSH
11855: LD_VAR 0 1
11859: PPUSH
11860: CALL 11753 0 1
11864: ST_TO_ADDR
// case type of 0 , normal :
11865: LD_VAR 0 2
11869: PUSH
11870: LD_INT 0
11872: DOUBLE
11873: EQUAL
11874: IFTRUE 11884
11876: LD_STRING normal
11878: DOUBLE
11879: EQUAL
11880: IFTRUE 11884
11882: GO 11895
11884: POP
// cl := class_apeman ; 1 , soldier :
11885: LD_ADDR_VAR 0 5
11889: PUSH
11890: LD_INT 12
11892: ST_TO_ADDR
11893: GO 11971
11895: LD_INT 1
11897: DOUBLE
11898: EQUAL
11899: IFTRUE 11909
11901: LD_STRING soldier
11903: DOUBLE
11904: EQUAL
11905: IFTRUE 11909
11907: GO 11920
11909: POP
// cl := class_apeman_soldier ; 2 , engineer :
11910: LD_ADDR_VAR 0 5
11914: PUSH
11915: LD_INT 15
11917: ST_TO_ADDR
11918: GO 11971
11920: LD_INT 2
11922: DOUBLE
11923: EQUAL
11924: IFTRUE 11934
11926: LD_STRING engineer
11928: DOUBLE
11929: EQUAL
11930: IFTRUE 11934
11932: GO 11945
11934: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
11935: LD_ADDR_VAR 0 5
11939: PUSH
11940: LD_INT 16
11942: ST_TO_ADDR
11943: GO 11971
11945: LD_INT 3
11947: DOUBLE
11948: EQUAL
11949: IFTRUE 11959
11951: LD_STRING kamikaze
11953: DOUBLE
11954: EQUAL
11955: IFTRUE 11959
11957: GO 11970
11959: POP
// cl := class_apeman_kamikaze ; end ;
11960: LD_ADDR_VAR 0 5
11964: PUSH
11965: LD_INT 17
11967: ST_TO_ADDR
11968: GO 11971
11970: POP
// for i = 1 to tmp do
11971: LD_ADDR_VAR 0 6
11975: PUSH
11976: DOUBLE
11977: LD_INT 1
11979: DEC
11980: ST_TO_ADDR
11981: LD_VAR 0 4
11985: PUSH
11986: FOR_TO
11987: IFFALSE 12036
// if GetClass ( tmp [ i ] ) = cl then
11989: LD_VAR 0 4
11993: PUSH
11994: LD_VAR 0 6
11998: ARRAY
11999: PPUSH
12000: CALL_OW 257
12004: PUSH
12005: LD_VAR 0 5
12009: EQUAL
12010: IFFALSE 12034
// result := result ^ tmp [ i ] ;
12012: LD_ADDR_VAR 0 3
12016: PUSH
12017: LD_VAR 0 3
12021: PUSH
12022: LD_VAR 0 4
12026: PUSH
12027: LD_VAR 0 6
12031: ARRAY
12032: ADD
12033: ST_TO_ADDR
12034: GO 11986
12036: POP
12037: POP
// end ;
12038: LD_VAR 0 3
12042: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12043: LD_INT 0
12045: PPUSH
12046: PPUSH
12047: PPUSH
12048: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12049: LD_ADDR_VAR 0 5
12053: PUSH
12054: LD_INT 22
12056: PUSH
12057: LD_VAR 0 1
12061: PUSH
12062: EMPTY
12063: LIST
12064: LIST
12065: PUSH
12066: LD_VAR 0 3
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PPUSH
12075: CALL_OW 69
12079: ST_TO_ADDR
// r := [ ] ;
12080: LD_ADDR_VAR 0 6
12084: PUSH
12085: EMPTY
12086: ST_TO_ADDR
// if tmp then
12087: LD_VAR 0 5
12091: IFFALSE 12160
// for i = 1 to tmp do
12093: LD_ADDR_VAR 0 7
12097: PUSH
12098: DOUBLE
12099: LD_INT 1
12101: DEC
12102: ST_TO_ADDR
12103: LD_VAR 0 5
12107: PUSH
12108: FOR_TO
12109: IFFALSE 12158
// if GetTag ( tmp [ i ] ) = tag then
12111: LD_VAR 0 5
12115: PUSH
12116: LD_VAR 0 7
12120: ARRAY
12121: PPUSH
12122: CALL_OW 110
12126: PUSH
12127: LD_VAR 0 2
12131: EQUAL
12132: IFFALSE 12156
// r := r ^ tmp [ i ] ;
12134: LD_ADDR_VAR 0 6
12138: PUSH
12139: LD_VAR 0 6
12143: PUSH
12144: LD_VAR 0 5
12148: PUSH
12149: LD_VAR 0 7
12153: ARRAY
12154: ADD
12155: ST_TO_ADDR
12156: GO 12108
12158: POP
12159: POP
// result := r ;
12160: LD_ADDR_VAR 0 4
12164: PUSH
12165: LD_VAR 0 6
12169: ST_TO_ADDR
// end ;
12170: LD_VAR 0 4
12174: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12175: LD_INT 0
12177: PPUSH
12178: PPUSH
12179: PPUSH
// tmp := plist ;
12180: LD_ADDR_VAR 0 5
12184: PUSH
12185: LD_VAR 0 2
12189: ST_TO_ADDR
// if tmp then
12190: LD_VAR 0 5
12194: IFFALSE 12271
// begin for i = 1 to tmp do
12196: LD_ADDR_VAR 0 6
12200: PUSH
12201: DOUBLE
12202: LD_INT 1
12204: DEC
12205: ST_TO_ADDR
12206: LD_VAR 0 5
12210: PUSH
12211: FOR_TO
12212: IFFALSE 12259
// if GetTag ( tmp [ i ] ) <> tag then
12214: LD_VAR 0 5
12218: PUSH
12219: LD_VAR 0 6
12223: ARRAY
12224: PPUSH
12225: CALL_OW 110
12229: PUSH
12230: LD_VAR 0 3
12234: NONEQUAL
12235: IFFALSE 12257
// SetTag ( tmp [ i ] , tag ) ;
12237: LD_VAR 0 5
12241: PUSH
12242: LD_VAR 0 6
12246: ARRAY
12247: PPUSH
12248: LD_VAR 0 3
12252: PPUSH
12253: CALL_OW 109
12257: GO 12211
12259: POP
12260: POP
// result := true ;
12261: LD_ADDR_VAR 0 4
12265: PUSH
12266: LD_INT 1
12268: ST_TO_ADDR
// end else
12269: GO 12279
// result := false ;
12271: LD_ADDR_VAR 0 4
12275: PUSH
12276: LD_INT 0
12278: ST_TO_ADDR
// end ;
12279: LD_VAR 0 4
12283: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
12288: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12289: LD_ADDR_VAR 0 4
12293: PUSH
12294: LD_VAR 0 1
12298: PPUSH
12299: LD_VAR 0 2
12303: PPUSH
12304: EMPTY
12305: PPUSH
12306: CALL 12043 0 3
12310: ST_TO_ADDR
// if tmp then
12311: LD_VAR 0 4
12315: IFFALSE 12367
// begin for i = 1 to tmp do
12317: LD_ADDR_VAR 0 5
12321: PUSH
12322: DOUBLE
12323: LD_INT 1
12325: DEC
12326: ST_TO_ADDR
12327: LD_VAR 0 4
12331: PUSH
12332: FOR_TO
12333: IFFALSE 12355
// SetTag ( tmp [ i ] , 0 ) ;
12335: LD_VAR 0 4
12339: PUSH
12340: LD_VAR 0 5
12344: ARRAY
12345: PPUSH
12346: LD_INT 0
12348: PPUSH
12349: CALL_OW 109
12353: GO 12332
12355: POP
12356: POP
// result := true ;
12357: LD_ADDR_VAR 0 3
12361: PUSH
12362: LD_INT 1
12364: ST_TO_ADDR
// end else
12365: GO 12375
// result := false ;
12367: LD_ADDR_VAR 0 3
12371: PUSH
12372: LD_INT 0
12374: ST_TO_ADDR
// end ;
12375: LD_VAR 0 3
12379: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12380: LD_INT 0
12382: PPUSH
12383: PPUSH
12384: PPUSH
12385: PPUSH
12386: PPUSH
// sort_list := [ ] ;
12387: LD_ADDR_VAR 0 5
12391: PUSH
12392: EMPTY
12393: ST_TO_ADDR
// for i = 1 to list do
12394: LD_ADDR_VAR 0 3
12398: PUSH
12399: DOUBLE
12400: LD_INT 1
12402: DEC
12403: ST_TO_ADDR
12404: LD_VAR 0 1
12408: PUSH
12409: FOR_TO
12410: IFFALSE 12572
// begin if i = 1 then
12412: LD_VAR 0 3
12416: PUSH
12417: LD_INT 1
12419: EQUAL
12420: IFFALSE 12446
// sort_list := sort_list ^ list [ i ] else
12422: LD_ADDR_VAR 0 5
12426: PUSH
12427: LD_VAR 0 5
12431: PUSH
12432: LD_VAR 0 1
12436: PUSH
12437: LD_VAR 0 3
12441: ARRAY
12442: ADD
12443: ST_TO_ADDR
12444: GO 12570
// begin for j = 1 to sort_list do
12446: LD_ADDR_VAR 0 4
12450: PUSH
12451: DOUBLE
12452: LD_INT 1
12454: DEC
12455: ST_TO_ADDR
12456: LD_VAR 0 5
12460: PUSH
12461: FOR_TO
12462: IFFALSE 12539
// begin add := false ;
12464: LD_ADDR_VAR 0 6
12468: PUSH
12469: LD_INT 0
12471: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12472: LD_VAR 0 1
12476: PUSH
12477: LD_VAR 0 3
12481: ARRAY
12482: PUSH
12483: LD_VAR 0 5
12487: PUSH
12488: LD_VAR 0 4
12492: ARRAY
12493: LESS
12494: IFFALSE 12537
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12496: LD_ADDR_VAR 0 5
12500: PUSH
12501: LD_VAR 0 5
12505: PPUSH
12506: LD_VAR 0 4
12510: PPUSH
12511: LD_VAR 0 1
12515: PUSH
12516: LD_VAR 0 3
12520: ARRAY
12521: PPUSH
12522: CALL_OW 2
12526: ST_TO_ADDR
// add := true ;
12527: LD_ADDR_VAR 0 6
12531: PUSH
12532: LD_INT 1
12534: ST_TO_ADDR
// break ;
12535: GO 12539
// end ; end ;
12537: GO 12461
12539: POP
12540: POP
// if not add then
12541: LD_VAR 0 6
12545: NOT
12546: IFFALSE 12570
// sort_list := sort_list ^ list [ i ] ;
12548: LD_ADDR_VAR 0 5
12552: PUSH
12553: LD_VAR 0 5
12557: PUSH
12558: LD_VAR 0 1
12562: PUSH
12563: LD_VAR 0 3
12567: ARRAY
12568: ADD
12569: ST_TO_ADDR
// end ; end ;
12570: GO 12409
12572: POP
12573: POP
// result := sort_list ;
12574: LD_ADDR_VAR 0 2
12578: PUSH
12579: LD_VAR 0 5
12583: ST_TO_ADDR
// end ;
12584: LD_VAR 0 2
12588: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12589: LD_INT 0
12591: PPUSH
12592: PPUSH
12593: PPUSH
12594: PPUSH
12595: PPUSH
// sort_list := [ ] ;
12596: LD_ADDR_VAR 0 5
12600: PUSH
12601: EMPTY
12602: ST_TO_ADDR
// for i = 1 to list do
12603: LD_ADDR_VAR 0 3
12607: PUSH
12608: DOUBLE
12609: LD_INT 1
12611: DEC
12612: ST_TO_ADDR
12613: LD_VAR 0 1
12617: PUSH
12618: FOR_TO
12619: IFFALSE 12781
// begin if i = 1 then
12621: LD_VAR 0 3
12625: PUSH
12626: LD_INT 1
12628: EQUAL
12629: IFFALSE 12655
// sort_list := sort_list ^ list [ i ] else
12631: LD_ADDR_VAR 0 5
12635: PUSH
12636: LD_VAR 0 5
12640: PUSH
12641: LD_VAR 0 1
12645: PUSH
12646: LD_VAR 0 3
12650: ARRAY
12651: ADD
12652: ST_TO_ADDR
12653: GO 12779
// begin for j = 1 to sort_list do
12655: LD_ADDR_VAR 0 4
12659: PUSH
12660: DOUBLE
12661: LD_INT 1
12663: DEC
12664: ST_TO_ADDR
12665: LD_VAR 0 5
12669: PUSH
12670: FOR_TO
12671: IFFALSE 12748
// begin add := false ;
12673: LD_ADDR_VAR 0 6
12677: PUSH
12678: LD_INT 0
12680: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12681: LD_VAR 0 1
12685: PUSH
12686: LD_VAR 0 3
12690: ARRAY
12691: PUSH
12692: LD_VAR 0 5
12696: PUSH
12697: LD_VAR 0 4
12701: ARRAY
12702: GREATER
12703: IFFALSE 12746
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12705: LD_ADDR_VAR 0 5
12709: PUSH
12710: LD_VAR 0 5
12714: PPUSH
12715: LD_VAR 0 4
12719: PPUSH
12720: LD_VAR 0 1
12724: PUSH
12725: LD_VAR 0 3
12729: ARRAY
12730: PPUSH
12731: CALL_OW 2
12735: ST_TO_ADDR
// add := true ;
12736: LD_ADDR_VAR 0 6
12740: PUSH
12741: LD_INT 1
12743: ST_TO_ADDR
// break ;
12744: GO 12748
// end ; end ;
12746: GO 12670
12748: POP
12749: POP
// if not add then
12750: LD_VAR 0 6
12754: NOT
12755: IFFALSE 12779
// sort_list := sort_list ^ list [ i ] ;
12757: LD_ADDR_VAR 0 5
12761: PUSH
12762: LD_VAR 0 5
12766: PUSH
12767: LD_VAR 0 1
12771: PUSH
12772: LD_VAR 0 3
12776: ARRAY
12777: ADD
12778: ST_TO_ADDR
// end ; end ;
12779: GO 12618
12781: POP
12782: POP
// result := sort_list ;
12783: LD_ADDR_VAR 0 2
12787: PUSH
12788: LD_VAR 0 5
12792: ST_TO_ADDR
// end ;
12793: LD_VAR 0 2
12797: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
12798: LD_INT 0
12800: PPUSH
12801: PPUSH
12802: PPUSH
12803: PPUSH
12804: PPUSH
12805: PPUSH
// tmp := [ ] ;
12806: LD_ADDR_VAR 0 8
12810: PUSH
12811: EMPTY
12812: ST_TO_ADDR
// r := [ ] ;
12813: LD_ADDR_VAR 0 7
12817: PUSH
12818: EMPTY
12819: ST_TO_ADDR
// add := false ;
12820: LD_ADDR_VAR 0 9
12824: PUSH
12825: LD_INT 0
12827: ST_TO_ADDR
// if plist then
12828: LD_VAR 0 2
12832: IFFALSE 12908
// begin for i = 1 to plist do
12834: LD_ADDR_VAR 0 5
12838: PUSH
12839: DOUBLE
12840: LD_INT 1
12842: DEC
12843: ST_TO_ADDR
12844: LD_VAR 0 2
12848: PUSH
12849: FOR_TO
12850: IFFALSE 12904
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
12852: LD_ADDR_VAR 0 8
12856: PUSH
12857: LD_VAR 0 8
12861: PUSH
12862: LD_VAR 0 2
12866: PUSH
12867: LD_VAR 0 5
12871: ARRAY
12872: PUSH
12873: LD_VAR 0 2
12877: PUSH
12878: LD_VAR 0 5
12882: ARRAY
12883: PPUSH
12884: LD_VAR 0 3
12888: PPUSH
12889: CALL_OW 259
12893: PUSH
12894: EMPTY
12895: LIST
12896: LIST
12897: PUSH
12898: EMPTY
12899: LIST
12900: ADD
12901: ST_TO_ADDR
// end ;
12902: GO 12849
12904: POP
12905: POP
// end else
12906: GO 12916
// result := false ;
12908: LD_ADDR_VAR 0 4
12912: PUSH
12913: LD_INT 0
12915: ST_TO_ADDR
// if tmp then
12916: LD_VAR 0 8
12920: IFFALSE 13094
// begin r := r ^ [ tmp [ 1 ] ] ;
12922: LD_ADDR_VAR 0 7
12926: PUSH
12927: LD_VAR 0 7
12931: PUSH
12932: LD_VAR 0 8
12936: PUSH
12937: LD_INT 1
12939: ARRAY
12940: PUSH
12941: EMPTY
12942: LIST
12943: ADD
12944: ST_TO_ADDR
// for i = 2 to tmp do
12945: LD_ADDR_VAR 0 5
12949: PUSH
12950: DOUBLE
12951: LD_INT 2
12953: DEC
12954: ST_TO_ADDR
12955: LD_VAR 0 8
12959: PUSH
12960: FOR_TO
12961: IFFALSE 13092
// begin for j = 1 to r do
12963: LD_ADDR_VAR 0 6
12967: PUSH
12968: DOUBLE
12969: LD_INT 1
12971: DEC
12972: ST_TO_ADDR
12973: LD_VAR 0 7
12977: PUSH
12978: FOR_TO
12979: IFFALSE 13056
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
12981: LD_VAR 0 8
12985: PUSH
12986: LD_VAR 0 5
12990: ARRAY
12991: PUSH
12992: LD_INT 2
12994: ARRAY
12995: PUSH
12996: LD_VAR 0 7
13000: PUSH
13001: LD_VAR 0 6
13005: ARRAY
13006: PUSH
13007: LD_INT 2
13009: ARRAY
13010: LESS
13011: IFFALSE 13054
// begin r := Insert ( r , j , tmp [ i ] ) ;
13013: LD_ADDR_VAR 0 7
13017: PUSH
13018: LD_VAR 0 7
13022: PPUSH
13023: LD_VAR 0 6
13027: PPUSH
13028: LD_VAR 0 8
13032: PUSH
13033: LD_VAR 0 5
13037: ARRAY
13038: PPUSH
13039: CALL_OW 2
13043: ST_TO_ADDR
// add := true ;
13044: LD_ADDR_VAR 0 9
13048: PUSH
13049: LD_INT 1
13051: ST_TO_ADDR
// break ;
13052: GO 13056
// end ; end ;
13054: GO 12978
13056: POP
13057: POP
// if not add then
13058: LD_VAR 0 9
13062: NOT
13063: IFFALSE 13090
// r := r ^ [ tmp [ i ] ] ;
13065: LD_ADDR_VAR 0 7
13069: PUSH
13070: LD_VAR 0 7
13074: PUSH
13075: LD_VAR 0 8
13079: PUSH
13080: LD_VAR 0 5
13084: ARRAY
13085: PUSH
13086: EMPTY
13087: LIST
13088: ADD
13089: ST_TO_ADDR
// end ;
13090: GO 12960
13092: POP
13093: POP
// end ; result := r ;
13094: LD_ADDR_VAR 0 4
13098: PUSH
13099: LD_VAR 0 7
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 4
13108: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: GREATER
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_Clear ( side ) ; var i ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
// for i = 1 to 100 do
13424: LD_ADDR_VAR 0 3
13428: PUSH
13429: DOUBLE
13430: LD_INT 1
13432: DEC
13433: ST_TO_ADDR
13434: LD_INT 100
13436: PUSH
13437: FOR_TO
13438: IFFALSE 13474
// if MCF_Tag ( side , i , [ ] ) then
13440: LD_VAR 0 1
13444: PPUSH
13445: LD_VAR 0 3
13449: PPUSH
13450: EMPTY
13451: PPUSH
13452: CALL 12043 0 3
13456: IFFALSE 13472
// MCF_ClearTag ( side , i ) ;
13458: LD_VAR 0 1
13462: PPUSH
13463: LD_VAR 0 3
13467: PPUSH
13468: CALL 12284 0 2
13472: GO 13437
13474: POP
13475: POP
// result := true ;
13476: LD_ADDR_VAR 0 2
13480: PUSH
13481: LD_INT 1
13483: ST_TO_ADDR
// end ;
13484: LD_VAR 0 2
13488: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13489: LD_INT 0
13491: PPUSH
13492: PPUSH
13493: PPUSH
// for i = 1 to plist do
13494: LD_ADDR_VAR 0 4
13498: PUSH
13499: DOUBLE
13500: LD_INT 1
13502: DEC
13503: ST_TO_ADDR
13504: LD_VAR 0 1
13508: PUSH
13509: FOR_TO
13510: IFFALSE 13559
// if MCF_HasClass ( plist [ i ] ) = n then
13512: LD_VAR 0 1
13516: PUSH
13517: LD_VAR 0 4
13521: ARRAY
13522: PPUSH
13523: CALL 14046 0 1
13527: PUSH
13528: LD_VAR 0 2
13532: EQUAL
13533: IFFALSE 13557
// tmp := tmp ^ plist [ i ] ;
13535: LD_ADDR_VAR 0 5
13539: PUSH
13540: LD_VAR 0 5
13544: PUSH
13545: LD_VAR 0 1
13549: PUSH
13550: LD_VAR 0 4
13554: ARRAY
13555: ADD
13556: ST_TO_ADDR
13557: GO 13509
13559: POP
13560: POP
// result := tmp ;
13561: LD_ADDR_VAR 0 3
13565: PUSH
13566: LD_VAR 0 5
13570: ST_TO_ADDR
// end ;
13571: LD_VAR 0 3
13575: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13576: LD_INT 0
13578: PPUSH
13579: PPUSH
13580: PPUSH
// if mreg = ToArm then
13581: LD_VAR 0 2
13585: PUSH
13586: LD_STRING ToArm
13588: EQUAL
13589: IFFALSE 13694
// begin tmp := MREG_ToArm [ side ] ;
13591: LD_ADDR_VAR 0 6
13595: PUSH
13596: LD_EXP 58
13600: PUSH
13601: LD_VAR 0 1
13605: ARRAY
13606: ST_TO_ADDR
// if tmp = 0 then
13607: LD_VAR 0 6
13611: PUSH
13612: LD_INT 0
13614: EQUAL
13615: IFFALSE 13621
// exit else
13617: GO 14041
13619: GO 13694
// begin for i = MREG_ToArm [ side ] downto n do
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: DOUBLE
13627: LD_EXP 58
13631: PUSH
13632: LD_VAR 0 1
13636: ARRAY
13637: INC
13638: ST_TO_ADDR
13639: LD_VAR 0 3
13643: PUSH
13644: FOR_DOWNTO
13645: IFFALSE 13667
// tmp := Delete ( tmp , 1 ) ;
13647: LD_ADDR_VAR 0 6
13651: PUSH
13652: LD_VAR 0 6
13656: PPUSH
13657: LD_INT 1
13659: PPUSH
13660: CALL_OW 3
13664: ST_TO_ADDR
13665: GO 13644
13667: POP
13668: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13669: LD_ADDR_EXP 58
13673: PUSH
13674: LD_EXP 58
13678: PPUSH
13679: LD_VAR 0 1
13683: PPUSH
13684: LD_VAR 0 6
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13694: LD_VAR 0 2
13698: PUSH
13699: LD_STRING ToDep
13701: EQUAL
13702: IFFALSE 13807
// begin tmp := MREG_ToDep [ side ] ;
13704: LD_ADDR_VAR 0 6
13708: PUSH
13709: LD_EXP 59
13713: PUSH
13714: LD_VAR 0 1
13718: ARRAY
13719: ST_TO_ADDR
// if tmp = 0 then
13720: LD_VAR 0 6
13724: PUSH
13725: LD_INT 0
13727: EQUAL
13728: IFFALSE 13734
// exit else
13730: GO 14041
13732: GO 13807
// begin for i = MREG_ToDep [ side ] downto n do
13734: LD_ADDR_VAR 0 5
13738: PUSH
13739: DOUBLE
13740: LD_EXP 59
13744: PUSH
13745: LD_VAR 0 1
13749: ARRAY
13750: INC
13751: ST_TO_ADDR
13752: LD_VAR 0 3
13756: PUSH
13757: FOR_DOWNTO
13758: IFFALSE 13780
// tmp := Delete ( tmp , 1 ) ;
13760: LD_ADDR_VAR 0 6
13764: PUSH
13765: LD_VAR 0 6
13769: PPUSH
13770: LD_INT 1
13772: PPUSH
13773: CALL_OW 3
13777: ST_TO_ADDR
13778: GO 13757
13780: POP
13781: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13782: LD_ADDR_EXP 59
13786: PUSH
13787: LD_EXP 59
13791: PPUSH
13792: LD_VAR 0 1
13796: PPUSH
13797: LD_VAR 0 6
13801: PPUSH
13802: CALL_OW 1
13806: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
13807: LD_VAR 0 2
13811: PUSH
13812: LD_STRING ToFac
13814: EQUAL
13815: IFFALSE 13920
// begin tmp := MREG_ToFac [ side ] ;
13817: LD_ADDR_VAR 0 6
13821: PUSH
13822: LD_EXP 57
13826: PUSH
13827: LD_VAR 0 1
13831: ARRAY
13832: ST_TO_ADDR
// if tmp = 0 then
13833: LD_VAR 0 6
13837: PUSH
13838: LD_INT 0
13840: EQUAL
13841: IFFALSE 13847
// exit else
13843: GO 14041
13845: GO 13920
// begin for i = MREG_ToFac [ side ] downto n do
13847: LD_ADDR_VAR 0 5
13851: PUSH
13852: DOUBLE
13853: LD_EXP 57
13857: PUSH
13858: LD_VAR 0 1
13862: ARRAY
13863: INC
13864: ST_TO_ADDR
13865: LD_VAR 0 3
13869: PUSH
13870: FOR_DOWNTO
13871: IFFALSE 13893
// tmp := Delete ( tmp , 1 ) ;
13873: LD_ADDR_VAR 0 6
13877: PUSH
13878: LD_VAR 0 6
13882: PPUSH
13883: LD_INT 1
13885: PPUSH
13886: CALL_OW 3
13890: ST_TO_ADDR
13891: GO 13870
13893: POP
13894: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
13895: LD_ADDR_EXP 57
13899: PUSH
13900: LD_EXP 57
13904: PPUSH
13905: LD_VAR 0 1
13909: PPUSH
13910: LD_VAR 0 6
13914: PPUSH
13915: CALL_OW 1
13919: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
13920: LD_VAR 0 2
13924: PUSH
13925: LD_STRING ToLab
13927: EQUAL
13928: IFFALSE 14033
// begin tmp := MREG_ToLab [ side ] ;
13930: LD_ADDR_VAR 0 6
13934: PUSH
13935: LD_EXP 56
13939: PUSH
13940: LD_VAR 0 1
13944: ARRAY
13945: ST_TO_ADDR
// if tmp = 0 then
13946: LD_VAR 0 6
13950: PUSH
13951: LD_INT 0
13953: EQUAL
13954: IFFALSE 13960
// exit else
13956: GO 14041
13958: GO 14033
// begin for i = MREG_ToLab [ side ] downto n do
13960: LD_ADDR_VAR 0 5
13964: PUSH
13965: DOUBLE
13966: LD_EXP 56
13970: PUSH
13971: LD_VAR 0 1
13975: ARRAY
13976: INC
13977: ST_TO_ADDR
13978: LD_VAR 0 3
13982: PUSH
13983: FOR_DOWNTO
13984: IFFALSE 14006
// tmp := Delete ( tmp , 1 ) ;
13986: LD_ADDR_VAR 0 6
13990: PUSH
13991: LD_VAR 0 6
13995: PPUSH
13996: LD_INT 1
13998: PPUSH
13999: CALL_OW 3
14003: ST_TO_ADDR
14004: GO 13983
14006: POP
14007: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14008: LD_ADDR_EXP 56
14012: PUSH
14013: LD_EXP 56
14017: PPUSH
14018: LD_VAR 0 1
14022: PPUSH
14023: LD_VAR 0 6
14027: PPUSH
14028: CALL_OW 1
14032: ST_TO_ADDR
// end ; end ; result := true ;
14033: LD_ADDR_VAR 0 4
14037: PUSH
14038: LD_INT 1
14040: ST_TO_ADDR
// end ;
14041: LD_VAR 0 4
14045: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14046: LD_INT 0
14048: PPUSH
14049: PPUSH
14050: PPUSH
// side := GetSide ( unit ) ;
14051: LD_ADDR_VAR 0 4
14055: PUSH
14056: LD_VAR 0 1
14060: PPUSH
14061: CALL_OW 255
14065: ST_TO_ADDR
// tmp := 0 ;
14066: LD_ADDR_VAR 0 3
14070: PUSH
14071: LD_INT 0
14073: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14074: LD_VAR 0 1
14078: PUSH
14079: LD_EXP 58
14083: PUSH
14084: LD_VAR 0 4
14088: ARRAY
14089: IN
14090: IFFALSE 14100
// tmp := 1 ;
14092: LD_ADDR_VAR 0 3
14096: PUSH
14097: LD_INT 1
14099: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14100: LD_VAR 0 1
14104: PUSH
14105: LD_EXP 59
14109: PUSH
14110: LD_VAR 0 4
14114: ARRAY
14115: IN
14116: IFFALSE 14126
// tmp := 2 ;
14118: LD_ADDR_VAR 0 3
14122: PUSH
14123: LD_INT 2
14125: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14126: LD_VAR 0 1
14130: PUSH
14131: LD_EXP 57
14135: PUSH
14136: LD_VAR 0 4
14140: ARRAY
14141: IN
14142: IFFALSE 14152
// tmp := 3 ;
14144: LD_ADDR_VAR 0 3
14148: PUSH
14149: LD_INT 3
14151: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14152: LD_VAR 0 1
14156: PUSH
14157: LD_EXP 56
14161: PUSH
14162: LD_VAR 0 4
14166: ARRAY
14167: IN
14168: IFFALSE 14178
// tmp := 4 ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: LD_INT 4
14177: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14178: LD_VAR 0 1
14182: PUSH
14183: LD_EXP 70
14187: PUSH
14188: LD_VAR 0 4
14192: ARRAY
14193: IN
14194: IFFALSE 14204
// tmp := 5 ;
14196: LD_ADDR_VAR 0 3
14200: PUSH
14201: LD_INT 5
14203: ST_TO_ADDR
// result := tmp ;
14204: LD_ADDR_VAR 0 2
14208: PUSH
14209: LD_VAR 0 3
14213: ST_TO_ADDR
// end ;
14214: LD_VAR 0 2
14218: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14219: LD_INT 0
14221: PPUSH
14222: PPUSH
// if mreg = ToArm then
14223: LD_VAR 0 2
14227: PUSH
14228: LD_STRING ToArm
14230: EQUAL
14231: IFFALSE 14320
// for i = MREG_ToArm [ side ] downto 1 do
14233: LD_ADDR_VAR 0 5
14237: PUSH
14238: DOUBLE
14239: LD_EXP 58
14243: PUSH
14244: LD_VAR 0 1
14248: ARRAY
14249: INC
14250: ST_TO_ADDR
14251: LD_INT 1
14253: PUSH
14254: FOR_DOWNTO
14255: IFFALSE 14318
// if MREG_ToArm [ side ] [ i ] = unit then
14257: LD_EXP 58
14261: PUSH
14262: LD_VAR 0 1
14266: ARRAY
14267: PUSH
14268: LD_VAR 0 5
14272: ARRAY
14273: PUSH
14274: LD_VAR 0 3
14278: EQUAL
14279: IFFALSE 14316
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14281: LD_ADDR_EXP 58
14285: PUSH
14286: LD_EXP 58
14290: PPUSH
14291: LD_EXP 58
14295: PUSH
14296: LD_VAR 0 1
14300: ARRAY
14301: PUSH
14302: LD_VAR 0 5
14306: ARRAY
14307: PPUSH
14308: LD_INT 1
14310: PPUSH
14311: CALL 30933 0 3
14315: ST_TO_ADDR
// end ;
14316: GO 14254
14318: POP
14319: POP
// if mreg = ToDep then
14320: LD_VAR 0 2
14324: PUSH
14325: LD_STRING ToDep
14327: EQUAL
14328: IFFALSE 14417
// for i = MREG_ToDep [ side ] downto 1 do
14330: LD_ADDR_VAR 0 5
14334: PUSH
14335: DOUBLE
14336: LD_EXP 59
14340: PUSH
14341: LD_VAR 0 1
14345: ARRAY
14346: INC
14347: ST_TO_ADDR
14348: LD_INT 1
14350: PUSH
14351: FOR_DOWNTO
14352: IFFALSE 14415
// if MREG_ToDep [ side ] [ i ] = unit then
14354: LD_EXP 59
14358: PUSH
14359: LD_VAR 0 1
14363: ARRAY
14364: PUSH
14365: LD_VAR 0 5
14369: ARRAY
14370: PUSH
14371: LD_VAR 0 3
14375: EQUAL
14376: IFFALSE 14413
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14378: LD_ADDR_EXP 59
14382: PUSH
14383: LD_EXP 59
14387: PPUSH
14388: LD_EXP 59
14392: PUSH
14393: LD_VAR 0 1
14397: ARRAY
14398: PUSH
14399: LD_VAR 0 5
14403: ARRAY
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: CALL 30933 0 3
14412: ST_TO_ADDR
// end ;
14413: GO 14351
14415: POP
14416: POP
// if mreg = ToFac then
14417: LD_VAR 0 2
14421: PUSH
14422: LD_STRING ToFac
14424: EQUAL
14425: IFFALSE 14514
// for i = MREG_ToFac [ side ] downto 1 do
14427: LD_ADDR_VAR 0 5
14431: PUSH
14432: DOUBLE
14433: LD_EXP 57
14437: PUSH
14438: LD_VAR 0 1
14442: ARRAY
14443: INC
14444: ST_TO_ADDR
14445: LD_INT 1
14447: PUSH
14448: FOR_DOWNTO
14449: IFFALSE 14512
// if MREG_ToFac [ side ] [ i ] = unit then
14451: LD_EXP 57
14455: PUSH
14456: LD_VAR 0 1
14460: ARRAY
14461: PUSH
14462: LD_VAR 0 5
14466: ARRAY
14467: PUSH
14468: LD_VAR 0 3
14472: EQUAL
14473: IFFALSE 14510
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14475: LD_ADDR_EXP 57
14479: PUSH
14480: LD_EXP 57
14484: PPUSH
14485: LD_EXP 57
14489: PUSH
14490: LD_VAR 0 1
14494: ARRAY
14495: PUSH
14496: LD_VAR 0 5
14500: ARRAY
14501: PPUSH
14502: LD_INT 1
14504: PPUSH
14505: CALL 30933 0 3
14509: ST_TO_ADDR
// end ;
14510: GO 14448
14512: POP
14513: POP
// if mreg = ToLab then
14514: LD_VAR 0 2
14518: PUSH
14519: LD_STRING ToLab
14521: EQUAL
14522: IFFALSE 14611
// for i = MREG_ToLab [ side ] downto 1 do
14524: LD_ADDR_VAR 0 5
14528: PUSH
14529: DOUBLE
14530: LD_EXP 56
14534: PUSH
14535: LD_VAR 0 1
14539: ARRAY
14540: INC
14541: ST_TO_ADDR
14542: LD_INT 1
14544: PUSH
14545: FOR_DOWNTO
14546: IFFALSE 14609
// if MREG_ToLab [ side ] [ i ] = unit then
14548: LD_EXP 56
14552: PUSH
14553: LD_VAR 0 1
14557: ARRAY
14558: PUSH
14559: LD_VAR 0 5
14563: ARRAY
14564: PUSH
14565: LD_VAR 0 3
14569: EQUAL
14570: IFFALSE 14607
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14572: LD_ADDR_EXP 56
14576: PUSH
14577: LD_EXP 56
14581: PPUSH
14582: LD_EXP 56
14586: PUSH
14587: LD_VAR 0 1
14591: ARRAY
14592: PUSH
14593: LD_VAR 0 5
14597: ARRAY
14598: PPUSH
14599: LD_INT 1
14601: PPUSH
14602: CALL 30933 0 3
14606: ST_TO_ADDR
// end ;
14607: GO 14545
14609: POP
14610: POP
// end ;
14611: LD_VAR 0 4
14615: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14616: LD_INT 0
14618: PPUSH
14619: PPUSH
// result := false ;
14620: LD_ADDR_VAR 0 2
14624: PUSH
14625: LD_INT 0
14627: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: DOUBLE
14634: LD_INT 1
14636: DEC
14637: ST_TO_ADDR
14638: LD_EXP 48
14642: PUSH
14643: FOR_TO
14644: IFFALSE 14708
// if MREG_ToBuild [ i ] [ 1 ] = side then
14646: LD_EXP 48
14650: PUSH
14651: LD_VAR 0 3
14655: ARRAY
14656: PUSH
14657: LD_INT 1
14659: ARRAY
14660: PUSH
14661: LD_VAR 0 1
14665: EQUAL
14666: IFFALSE 14706
// begin if MREG_ToBuild [ i ] [ 1 ] then
14668: LD_EXP 48
14672: PUSH
14673: LD_VAR 0 3
14677: ARRAY
14678: PUSH
14679: LD_INT 1
14681: ARRAY
14682: IFFALSE 14706
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14684: LD_ADDR_VAR 0 2
14688: PUSH
14689: LD_EXP 48
14693: PUSH
14694: LD_VAR 0 3
14698: ARRAY
14699: PUSH
14700: LD_INT 1
14702: ARRAY
14703: ST_TO_ADDR
// break ;
14704: GO 14708
// end ; end ;
14706: GO 14643
14708: POP
14709: POP
// for i = 1 to MREG_ToRepair do
14710: LD_ADDR_VAR 0 3
14714: PUSH
14715: DOUBLE
14716: LD_INT 1
14718: DEC
14719: ST_TO_ADDR
14720: LD_EXP 49
14724: PUSH
14725: FOR_TO
14726: IFFALSE 14790
// if MREG_ToRepair [ i ] [ 1 ] = side then
14728: LD_EXP 49
14732: PUSH
14733: LD_VAR 0 3
14737: ARRAY
14738: PUSH
14739: LD_INT 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 1
14747: EQUAL
14748: IFFALSE 14788
// begin if MREG_ToRepair [ i ] [ 1 ] then
14750: LD_EXP 49
14754: PUSH
14755: LD_VAR 0 3
14759: ARRAY
14760: PUSH
14761: LD_INT 1
14763: ARRAY
14764: IFFALSE 14788
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14766: LD_ADDR_VAR 0 2
14770: PUSH
14771: LD_EXP 49
14775: PUSH
14776: LD_VAR 0 3
14780: ARRAY
14781: PUSH
14782: LD_INT 1
14784: ARRAY
14785: ST_TO_ADDR
// break ;
14786: GO 14790
// end ; end ;
14788: GO 14725
14790: POP
14791: POP
// if MCF_Get ( side , [ f_constructed ] ) then
14792: LD_VAR 0 1
14796: PPUSH
14797: LD_INT 57
14799: PUSH
14800: EMPTY
14801: LIST
14802: PPUSH
14803: CALL 11340 0 2
14807: IFFALSE 14834
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
14809: LD_ADDR_VAR 0 2
14813: PUSH
14814: LD_VAR 0 1
14818: PPUSH
14819: LD_INT 57
14821: PUSH
14822: EMPTY
14823: LIST
14824: PPUSH
14825: CALL 11340 0 2
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: ST_TO_ADDR
// end ;
14834: LD_VAR 0 2
14838: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
14839: LD_INT 0
14841: PPUSH
14842: PPUSH
14843: PPUSH
14844: PPUSH
14845: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
14846: LD_ADDR_VAR 0 6
14850: PUSH
14851: LD_VAR 0 1
14855: PPUSH
14856: LD_INT 21
14858: PUSH
14859: LD_INT 3
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL 11340 0 2
14870: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
14871: LD_ADDR_VAR 0 7
14875: PUSH
14876: LD_VAR 0 1
14880: PPUSH
14881: LD_INT 81
14883: PUSH
14884: LD_VAR 0 1
14888: PUSH
14889: EMPTY
14890: LIST
14891: LIST
14892: PPUSH
14893: CALL 11340 0 2
14897: ST_TO_ADDR
// if not enemy then
14898: LD_VAR 0 7
14902: NOT
14903: IFFALSE 14915
// result := false else
14905: LD_ADDR_VAR 0 3
14909: PUSH
14910: LD_INT 0
14912: ST_TO_ADDR
14913: GO 14969
// begin scan := NearestUnit ( b , enemy ) ;
14915: LD_ADDR_VAR 0 5
14919: PUSH
14920: LD_VAR 0 6
14924: PPUSH
14925: LD_VAR 0 7
14929: PPUSH
14930: CALL 32258 0 2
14934: ST_TO_ADDR
// if scan [ 2 ] < dist then
14935: LD_VAR 0 5
14939: PUSH
14940: LD_INT 2
14942: ARRAY
14943: PUSH
14944: LD_VAR 0 2
14948: LESS
14949: IFFALSE 14961
// result := true else
14951: LD_ADDR_VAR 0 3
14955: PUSH
14956: LD_INT 1
14958: ST_TO_ADDR
14959: GO 14969
// result := false ;
14961: LD_ADDR_VAR 0 3
14965: PUSH
14966: LD_INT 0
14968: ST_TO_ADDR
// end ; end ;
14969: LD_VAR 0 3
14973: RET
// export function MCF_Info ( ) ; begin
14974: LD_INT 0
14976: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
14977: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
14979: PUSH
14980: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
14982: ADD
14983: PUSH
14984: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
14986: ADD
14987: PUSH
14988: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
14990: ADD
14991: PUSH
14992: LD_STRING - MCF_ClearTag -> Kasuje dany tag
14994: ADD
14995: PUSH
14996: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
14998: ADD
14999: PUSH
15000: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15002: ADD
15003: PUSH
15004: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15006: ADD
15007: PUSH
15008: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15010: ADD
15011: PUSH
15012: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15014: ADD
15015: PPUSH
15016: CALL 8258 0 1
// end ; end_of_file
15020: LD_VAR 0 1
15024: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15025: LD_INT 0
15027: PPUSH
15028: PPUSH
15029: PPUSH
15030: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15031: LD_ADDR_VAR 0 5
15035: PUSH
15036: LD_VAR 0 1
15040: PPUSH
15041: LD_INT 2
15043: PUSH
15044: LD_INT 25
15046: PUSH
15047: LD_INT 2
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 25
15056: PUSH
15057: LD_INT 3
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: LD_INT 25
15066: PUSH
15067: LD_INT 4
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: PPUSH
15080: CALL 11340 0 2
15084: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15085: LD_ADDR_VAR 0 5
15089: PUSH
15090: LD_VAR 0 5
15094: PPUSH
15095: LD_INT 0
15097: PPUSH
15098: CALL 13489 0 2
15102: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15103: LD_ADDR_VAR 0 6
15107: PUSH
15108: LD_VAR 0 1
15112: PPUSH
15113: LD_VAR 0 5
15117: PPUSH
15118: LD_INT 1
15120: PPUSH
15121: CALL 13109 0 3
15125: ST_TO_ADDR
// if n > sk then
15126: LD_VAR 0 2
15130: PUSH
15131: LD_VAR 0 6
15135: GREATER
15136: IFFALSE 15148
// n := sk ;
15138: LD_ADDR_VAR 0 2
15142: PUSH
15143: LD_VAR 0 6
15147: ST_TO_ADDR
// for i = 1 to n do
15148: LD_ADDR_VAR 0 4
15152: PUSH
15153: DOUBLE
15154: LD_INT 1
15156: DEC
15157: ST_TO_ADDR
15158: LD_VAR 0 2
15162: PUSH
15163: FOR_TO
15164: IFFALSE 15276
// if ( sk [ i ] [ 1 ] ) <> 0 then
15166: LD_VAR 0 6
15170: PUSH
15171: LD_VAR 0 4
15175: ARRAY
15176: PUSH
15177: LD_INT 1
15179: ARRAY
15180: PUSH
15181: LD_INT 0
15183: NONEQUAL
15184: IFFALSE 15274
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15186: LD_ADDR_EXP 55
15190: PUSH
15191: LD_EXP 55
15195: PPUSH
15196: LD_VAR 0 1
15200: PPUSH
15201: LD_VAR 0 6
15205: PUSH
15206: LD_VAR 0 4
15210: ARRAY
15211: PUSH
15212: LD_INT 1
15214: ARRAY
15215: PPUSH
15216: LD_INT 1
15218: PPUSH
15219: CALL 42056 0 4
15223: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15224: LD_ADDR_EXP 58
15228: PUSH
15229: LD_EXP 58
15233: PPUSH
15234: LD_VAR 0 1
15238: PPUSH
15239: LD_EXP 58
15243: PUSH
15244: LD_VAR 0 1
15248: ARRAY
15249: PUSH
15250: LD_INT 1
15252: PLUS
15253: PPUSH
15254: LD_VAR 0 6
15258: PUSH
15259: LD_VAR 0 4
15263: ARRAY
15264: PUSH
15265: LD_INT 1
15267: ARRAY
15268: PPUSH
15269: CALL 30774 0 4
15273: ST_TO_ADDR
// end ;
15274: GO 15163
15276: POP
15277: POP
// end ;
15278: LD_VAR 0 3
15282: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15283: LD_INT 0
15285: PPUSH
15286: PPUSH
15287: PPUSH
15288: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15289: LD_ADDR_VAR 0 5
15293: PUSH
15294: LD_VAR 0 1
15298: PPUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 25
15304: PUSH
15305: LD_INT 1
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: LD_INT 25
15314: PUSH
15315: LD_INT 3
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 25
15324: PUSH
15325: LD_INT 4
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: PPUSH
15338: CALL 11340 0 2
15342: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15343: LD_ADDR_VAR 0 5
15347: PUSH
15348: LD_VAR 0 5
15352: PPUSH
15353: LD_INT 0
15355: PPUSH
15356: CALL 13489 0 2
15360: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15361: LD_ADDR_VAR 0 6
15365: PUSH
15366: LD_VAR 0 1
15370: PPUSH
15371: LD_VAR 0 5
15375: PPUSH
15376: LD_INT 2
15378: PPUSH
15379: CALL 13109 0 3
15383: ST_TO_ADDR
// if n > sk then
15384: LD_VAR 0 2
15388: PUSH
15389: LD_VAR 0 6
15393: GREATER
15394: IFFALSE 15406
// n := sk ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 6
15405: ST_TO_ADDR
// for i = 1 to n do
15406: LD_ADDR_VAR 0 4
15410: PUSH
15411: DOUBLE
15412: LD_INT 1
15414: DEC
15415: ST_TO_ADDR
15416: LD_VAR 0 2
15420: PUSH
15421: FOR_TO
15422: IFFALSE 15534
// if ( sk [ i ] [ 1 ] ) <> 0 then
15424: LD_VAR 0 6
15428: PUSH
15429: LD_VAR 0 4
15433: ARRAY
15434: PUSH
15435: LD_INT 1
15437: ARRAY
15438: PUSH
15439: LD_INT 0
15441: NONEQUAL
15442: IFFALSE 15532
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15444: LD_ADDR_EXP 55
15448: PUSH
15449: LD_EXP 55
15453: PPUSH
15454: LD_VAR 0 1
15458: PPUSH
15459: LD_VAR 0 6
15463: PUSH
15464: LD_VAR 0 4
15468: ARRAY
15469: PUSH
15470: LD_INT 1
15472: ARRAY
15473: PPUSH
15474: LD_INT 2
15476: PPUSH
15477: CALL 42056 0 4
15481: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15482: LD_ADDR_EXP 59
15486: PUSH
15487: LD_EXP 59
15491: PPUSH
15492: LD_VAR 0 1
15496: PPUSH
15497: LD_EXP 59
15501: PUSH
15502: LD_VAR 0 1
15506: ARRAY
15507: PUSH
15508: LD_INT 1
15510: PLUS
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: CALL 30774 0 4
15531: ST_TO_ADDR
// end ;
15532: GO 15421
15534: POP
15535: POP
// end ;
15536: LD_VAR 0 3
15540: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15541: LD_INT 0
15543: PPUSH
15544: PPUSH
15545: PPUSH
15546: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15547: LD_ADDR_VAR 0 5
15551: PUSH
15552: LD_VAR 0 1
15556: PPUSH
15557: LD_INT 2
15559: PUSH
15560: LD_INT 25
15562: PUSH
15563: LD_INT 1
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PUSH
15570: LD_INT 25
15572: PUSH
15573: LD_INT 2
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: PUSH
15580: LD_INT 25
15582: PUSH
15583: LD_INT 4
15585: PUSH
15586: EMPTY
15587: LIST
15588: LIST
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: PPUSH
15596: CALL 11340 0 2
15600: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15601: LD_ADDR_VAR 0 5
15605: PUSH
15606: LD_VAR 0 5
15610: PPUSH
15611: LD_INT 0
15613: PPUSH
15614: CALL 13489 0 2
15618: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15619: LD_ADDR_VAR 0 6
15623: PUSH
15624: LD_VAR 0 1
15628: PPUSH
15629: LD_VAR 0 5
15633: PPUSH
15634: LD_INT 3
15636: PPUSH
15637: CALL 13109 0 3
15641: ST_TO_ADDR
// if n > sk then
15642: LD_VAR 0 2
15646: PUSH
15647: LD_VAR 0 6
15651: GREATER
15652: IFFALSE 15664
// n := sk ;
15654: LD_ADDR_VAR 0 2
15658: PUSH
15659: LD_VAR 0 6
15663: ST_TO_ADDR
// for i = 1 to n do
15664: LD_ADDR_VAR 0 4
15668: PUSH
15669: DOUBLE
15670: LD_INT 1
15672: DEC
15673: ST_TO_ADDR
15674: LD_VAR 0 2
15678: PUSH
15679: FOR_TO
15680: IFFALSE 15792
// if ( sk [ i ] [ 1 ] ) <> 0 then
15682: LD_VAR 0 6
15686: PUSH
15687: LD_VAR 0 4
15691: ARRAY
15692: PUSH
15693: LD_INT 1
15695: ARRAY
15696: PUSH
15697: LD_INT 0
15699: NONEQUAL
15700: IFFALSE 15790
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15702: LD_ADDR_EXP 55
15706: PUSH
15707: LD_EXP 55
15711: PPUSH
15712: LD_VAR 0 1
15716: PPUSH
15717: LD_VAR 0 6
15721: PUSH
15722: LD_VAR 0 4
15726: ARRAY
15727: PUSH
15728: LD_INT 1
15730: ARRAY
15731: PPUSH
15732: LD_INT 3
15734: PPUSH
15735: CALL 42056 0 4
15739: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15740: LD_ADDR_EXP 57
15744: PUSH
15745: LD_EXP 57
15749: PPUSH
15750: LD_VAR 0 1
15754: PPUSH
15755: LD_EXP 57
15759: PUSH
15760: LD_VAR 0 1
15764: ARRAY
15765: PUSH
15766: LD_INT 1
15768: PLUS
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: CALL 30774 0 4
15789: ST_TO_ADDR
// end ;
15790: GO 15679
15792: POP
15793: POP
// end ;
15794: LD_VAR 0 3
15798: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
15799: LD_INT 0
15801: PPUSH
15802: PPUSH
15803: PPUSH
15804: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
15805: LD_ADDR_VAR 0 5
15809: PUSH
15810: LD_VAR 0 1
15814: PPUSH
15815: LD_INT 2
15817: PUSH
15818: LD_INT 25
15820: PUSH
15821: LD_INT 1
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: PUSH
15828: LD_INT 25
15830: PUSH
15831: LD_INT 2
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: EMPTY
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11340 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13489 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 4
15883: PPUSH
15884: CALL 13109 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 4
15981: PPUSH
15982: CALL 42056 0 4
15986: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 56
15991: PUSH
15992: LD_EXP 56
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 56
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 30774 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16052: LD_ADDR_VAR 0 6
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: LD_INT 25
16087: PUSH
16088: LD_INT 3
16090: PUSH
16091: EMPTY
16092: LIST
16093: LIST
16094: PUSH
16095: LD_INT 25
16097: PUSH
16098: LD_INT 4
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: LIST
16109: LIST
16110: LIST
16111: PPUSH
16112: CALL 11340 0 2
16116: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16117: LD_ADDR_VAR 0 6
16121: PUSH
16122: LD_VAR 0 6
16126: PPUSH
16127: LD_INT 0
16129: PPUSH
16130: CALL 13489 0 2
16134: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16135: LD_ADDR_VAR 0 7
16139: PUSH
16140: LD_VAR 0 1
16144: PPUSH
16145: LD_VAR 0 6
16149: PPUSH
16150: LD_INT 1
16152: PPUSH
16153: CALL 13109 0 3
16157: ST_TO_ADDR
// if n > sk then
16158: LD_VAR 0 2
16162: PUSH
16163: LD_VAR 0 7
16167: GREATER
16168: IFFALSE 16180
// n := sk ;
16170: LD_ADDR_VAR 0 2
16174: PUSH
16175: LD_VAR 0 7
16179: ST_TO_ADDR
// for i = 1 to n do
16180: LD_ADDR_VAR 0 5
16184: PUSH
16185: DOUBLE
16186: LD_INT 1
16188: DEC
16189: ST_TO_ADDR
16190: LD_VAR 0 2
16194: PUSH
16195: FOR_TO
16196: IFFALSE 16240
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16198: LD_ADDR_EXP 55
16202: PUSH
16203: LD_EXP 55
16207: PPUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: LD_VAR 0 7
16217: PUSH
16218: LD_VAR 0 5
16222: ARRAY
16223: PUSH
16224: LD_INT 1
16226: ARRAY
16227: PPUSH
16228: LD_VAR 0 3
16232: PPUSH
16233: CALL 42056 0 4
16237: ST_TO_ADDR
// end ;
16238: GO 16195
16240: POP
16241: POP
// end ;
16242: LD_VAR 0 4
16246: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16247: LD_INT 0
16249: PPUSH
16250: PPUSH
16251: PPUSH
// b := false ;
16252: LD_ADDR_VAR 0 6
16256: PUSH
16257: LD_INT 0
16259: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16260: LD_VAR 0 3
16264: PUSH
16265: LD_INT 1
16267: PUSH
16268: LD_INT 9
16270: PUSH
16271: LD_INT 5
16273: PUSH
16274: LD_INT 8
16276: PUSH
16277: EMPTY
16278: LIST
16279: LIST
16280: LIST
16281: LIST
16282: IN
16283: IFFALSE 16371
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16285: LD_VAR 0 1
16289: PPUSH
16290: LD_INT 2
16292: PUSH
16293: LD_INT 30
16295: PUSH
16296: LD_INT 4
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: LD_INT 30
16305: PUSH
16306: LD_INT 5
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: LIST
16317: PPUSH
16318: CALL 11340 0 2
16322: IFFALSE 16371
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16324: LD_ADDR_VAR 0 6
16328: PUSH
16329: LD_VAR 0 1
16333: PPUSH
16334: LD_INT 2
16336: PUSH
16337: LD_INT 30
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PUSH
16347: LD_INT 30
16349: PUSH
16350: LD_INT 5
16352: PUSH
16353: EMPTY
16354: LIST
16355: LIST
16356: PUSH
16357: EMPTY
16358: LIST
16359: LIST
16360: LIST
16361: PPUSH
16362: CALL 11340 0 2
16366: PUSH
16367: LD_INT 1
16369: ARRAY
16370: ST_TO_ADDR
// if class = class_engineer then
16371: LD_VAR 0 3
16375: PUSH
16376: LD_INT 2
16378: EQUAL
16379: IFFALSE 16467
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16381: LD_VAR 0 1
16385: PPUSH
16386: LD_INT 2
16388: PUSH
16389: LD_INT 30
16391: PUSH
16392: LD_INT 0
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PUSH
16399: LD_INT 30
16401: PUSH
16402: LD_INT 1
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: LIST
16413: PPUSH
16414: CALL 11340 0 2
16418: IFFALSE 16467
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16420: LD_ADDR_VAR 0 6
16424: PUSH
16425: LD_VAR 0 1
16429: PPUSH
16430: LD_INT 2
16432: PUSH
16433: LD_INT 30
16435: PUSH
16436: LD_INT 0
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PUSH
16443: LD_INT 30
16445: PUSH
16446: LD_INT 1
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: LIST
16457: PPUSH
16458: CALL 11340 0 2
16462: PUSH
16463: LD_INT 1
16465: ARRAY
16466: ST_TO_ADDR
// if class = class_mechanic then
16467: LD_VAR 0 3
16471: PUSH
16472: LD_INT 3
16474: EQUAL
16475: IFFALSE 16545
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16477: LD_VAR 0 1
16481: PPUSH
16482: LD_INT 30
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PPUSH
16492: CALL 11340 0 2
16496: IFFALSE 16545
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16498: LD_ADDR_VAR 0 6
16502: PUSH
16503: LD_VAR 0 1
16507: PPUSH
16508: LD_INT 2
16510: PUSH
16511: LD_INT 30
16513: PUSH
16514: LD_INT 2
16516: PUSH
16517: EMPTY
16518: LIST
16519: LIST
16520: PUSH
16521: LD_INT 30
16523: PUSH
16524: LD_INT 3
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: LIST
16535: PPUSH
16536: CALL 11340 0 2
16540: PUSH
16541: LD_INT 1
16543: ARRAY
16544: ST_TO_ADDR
// if class = class_scientistic then
16545: LD_VAR 0 3
16549: PUSH
16550: LD_INT 4
16552: EQUAL
16553: IFFALSE 16663
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16555: LD_VAR 0 1
16559: PPUSH
16560: LD_INT 2
16562: PUSH
16563: LD_INT 30
16565: PUSH
16566: LD_INT 6
16568: PUSH
16569: EMPTY
16570: LIST
16571: LIST
16572: PUSH
16573: LD_INT 30
16575: PUSH
16576: LD_INT 7
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: PUSH
16583: LD_INT 30
16585: PUSH
16586: LD_INT 8
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: PUSH
16593: EMPTY
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: PPUSH
16599: CALL 11340 0 2
16603: IFFALSE 16663
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16605: LD_ADDR_VAR 0 6
16609: PUSH
16610: LD_VAR 0 1
16614: PPUSH
16615: LD_INT 2
16617: PUSH
16618: LD_INT 30
16620: PUSH
16621: LD_INT 6
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: PUSH
16628: LD_INT 30
16630: PUSH
16631: LD_INT 7
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: PUSH
16638: LD_INT 30
16640: PUSH
16641: LD_INT 8
16643: PUSH
16644: EMPTY
16645: LIST
16646: LIST
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: LIST
16652: LIST
16653: PPUSH
16654: CALL 11340 0 2
16658: PUSH
16659: LD_INT 1
16661: ARRAY
16662: ST_TO_ADDR
// if GetClass ( unit ) = class then
16663: LD_VAR 0 2
16667: PPUSH
16668: CALL_OW 257
16672: PUSH
16673: LD_VAR 0 3
16677: EQUAL
16678: IFFALSE 16712
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16680: LD_ADDR_EXP 55
16684: PUSH
16685: LD_EXP 55
16689: PPUSH
16690: LD_VAR 0 1
16694: PPUSH
16695: LD_VAR 0 2
16699: PPUSH
16700: LD_VAR 0 3
16704: PPUSH
16705: CALL 42147 0 4
16709: ST_TO_ADDR
// end else
16710: GO 16805
// if b then
16712: LD_VAR 0 6
16716: IFFALSE 16797
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16718: LD_VAR 0 2
16722: PPUSH
16723: CALL_OW 310
16727: PUSH
16728: LD_VAR 0 2
16732: PPUSH
16733: CALL_OW 310
16737: PUSH
16738: LD_VAR 0 6
16742: NONEQUAL
16743: AND
16744: IFFALSE 16755
// ComExitBuilding ( unit ) ;
16746: LD_VAR 0 2
16750: PPUSH
16751: CALL_OW 122
// if not IsInUnit ( unit ) then
16755: LD_VAR 0 2
16759: PPUSH
16760: CALL_OW 310
16764: NOT
16765: IFFALSE 16781
// ComEnterUnit ( unit , b ) ;
16767: LD_VAR 0 2
16771: PPUSH
16772: LD_VAR 0 6
16776: PPUSH
16777: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16781: LD_VAR 0 2
16785: PPUSH
16786: LD_VAR 0 3
16790: PPUSH
16791: CALL_OW 183
// end else
16795: GO 16805
// result := false ;
16797: LD_ADDR_VAR 0 4
16801: PUSH
16802: LD_INT 0
16804: ST_TO_ADDR
// end ; end_of_file
16805: LD_VAR 0 4
16809: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: LD_INT 35
16823: PUSH
16824: LD_INT 45
16826: PUSH
16827: LD_INT 46
16829: PUSH
16830: LD_INT 47
16832: PUSH
16833: LD_INT 1
16835: PUSH
16836: LD_INT 2
16838: PUSH
16839: LD_INT 48
16841: PUSH
16842: LD_INT 49
16844: PUSH
16845: LD_INT 50
16847: PUSH
16848: LD_INT 20
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: ST_TO_ADDR
// if MCF_Lab ( side ) then
16863: LD_VAR 0 1
16867: PPUSH
16868: CALL 11379 0 1
16872: IFFALSE 17111
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
16874: LD_VAR 0 1
16878: PPUSH
16879: CALL 11379 0 1
16883: PUSH
16884: LD_INT 1
16886: ARRAY
16887: PPUSH
16888: CALL_OW 461
16892: PUSH
16893: LD_INT 2
16895: EQUAL
16896: IFFALSE 17035
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
16898: LD_VAR 0 1
16902: PPUSH
16903: CALL 11379 0 1
16907: PUSH
16908: LD_INT 1
16910: ARRAY
16911: PPUSH
16912: LD_VAR 0 2
16916: PPUSH
16917: CALL 17207 0 2
16921: IFFALSE 16948
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
16923: LD_VAR 0 1
16927: PPUSH
16928: CALL 11379 0 1
16932: PUSH
16933: LD_INT 1
16935: ARRAY
16936: PPUSH
16937: LD_VAR 0 2
16941: PPUSH
16942: CALL_OW 124
16946: GO 17035
// if MCF_Lab ( side ) > 1 then
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL 11379 0 1
16957: PUSH
16958: LD_INT 1
16960: GREATER
16961: IFFALSE 17035
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
16963: LD_VAR 0 1
16967: PPUSH
16968: CALL 11379 0 1
16972: PUSH
16973: LD_INT 2
16975: ARRAY
16976: PPUSH
16977: CALL_OW 461
16981: PUSH
16982: LD_INT 2
16984: EQUAL
16985: IFFALSE 17035
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
16987: LD_VAR 0 1
16991: PPUSH
16992: CALL 11379 0 1
16996: PUSH
16997: LD_INT 2
16999: ARRAY
17000: PPUSH
17001: LD_VAR 0 2
17005: PPUSH
17006: CALL 17207 0 2
17010: IFFALSE 17035
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17012: LD_VAR 0 1
17016: PPUSH
17017: CALL 11379 0 1
17021: PUSH
17022: LD_INT 2
17024: ARRAY
17025: PPUSH
17026: LD_VAR 0 2
17030: PPUSH
17031: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17035: LD_VAR 0 2
17039: PUSH
17040: LD_INT 2
17042: PUSH
17043: LD_INT 11
17045: PUSH
17046: LD_INT 4
17048: PUSH
17049: LD_INT 3
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: IN
17058: IFFALSE 17111
// begin for lab in MCF_Lab ( side ) do
17060: LD_ADDR_VAR 0 6
17064: PUSH
17065: LD_VAR 0 1
17069: PPUSH
17070: CALL 11379 0 1
17074: PUSH
17075: FOR_IN
17076: IFFALSE 17109
// if BuildingStatus ( lab ) = bs_need_ape then
17078: LD_VAR 0 6
17082: PPUSH
17083: CALL_OW 461
17087: PUSH
17088: LD_INT 10
17090: EQUAL
17091: IFFALSE 17107
// MCL_ResTame ( side , lab ) ;
17093: LD_VAR 0 1
17097: PPUSH
17098: LD_VAR 0 6
17102: PPUSH
17103: CALL 17332 0 2
17107: GO 17075
17109: POP
17110: POP
// end ; end ; end ;
17111: LD_VAR 0 3
17115: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17116: LD_INT 0
17118: PPUSH
17119: PPUSH
// tmp := [ ] ;
17120: LD_ADDR_VAR 0 3
17124: PUSH
17125: EMPTY
17126: ST_TO_ADDR
// if not lab then
17127: LD_VAR 0 1
17131: NOT
17132: IFFALSE 17144
// result := false else
17134: LD_ADDR_VAR 0 2
17138: PUSH
17139: LD_INT 0
17141: ST_TO_ADDR
17142: GO 17202
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_VAR 0 3
17153: PUSH
17154: LD_VAR 0 1
17158: PPUSH
17159: LD_INT 1
17161: PPUSH
17162: CALL_OW 268
17166: ADD
17167: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17168: LD_ADDR_VAR 0 3
17172: PUSH
17173: LD_VAR 0 3
17177: PUSH
17178: LD_VAR 0 1
17182: PPUSH
17183: LD_INT 2
17185: PPUSH
17186: CALL_OW 268
17190: ADD
17191: ST_TO_ADDR
// result := tmp ;
17192: LD_ADDR_VAR 0 2
17196: PUSH
17197: LD_VAR 0 3
17201: ST_TO_ADDR
// end ; end ;
17202: LD_VAR 0 2
17206: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17207: LD_INT 0
17209: PPUSH
17210: PPUSH
17211: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17212: LD_ADDR_VAR 0 5
17216: PUSH
17217: LD_INT 35
17219: PUSH
17220: LD_INT 45
17222: PUSH
17223: LD_INT 46
17225: PUSH
17226: LD_INT 47
17228: PUSH
17229: LD_INT 1
17231: PUSH
17232: LD_INT 2
17234: PUSH
17235: LD_INT 48
17237: PUSH
17238: LD_INT 49
17240: PUSH
17241: LD_INT 50
17243: PUSH
17244: LD_INT 20
17246: PUSH
17247: EMPTY
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: LIST
17256: LIST
17257: LIST
17258: ST_TO_ADDR
// if lab then
17259: LD_VAR 0 1
17263: IFFALSE 17319
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17265: LD_VAR 0 2
17269: PUSH
17270: LD_VAR 0 5
17274: IN
17275: PUSH
17276: LD_VAR 0 2
17280: PPUSH
17281: CALL_OW 481
17285: PUSH
17286: LD_VAR 0 1
17290: PPUSH
17291: CALL 17116 0 1
17295: IN
17296: OR
17297: IFFALSE 17309
// result := true else
17299: LD_ADDR_VAR 0 3
17303: PUSH
17304: LD_INT 1
17306: ST_TO_ADDR
17307: GO 17317
// result := false ;
17309: LD_ADDR_VAR 0 3
17313: PUSH
17314: LD_INT 0
17316: ST_TO_ADDR
// end else
17317: GO 17327
// result := false ;
17319: LD_ADDR_VAR 0 3
17323: PUSH
17324: LD_INT 0
17326: ST_TO_ADDR
// end ;
17327: LD_VAR 0 3
17331: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17332: LD_INT 0
17334: PPUSH
17335: PPUSH
17336: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17337: LD_ADDR_VAR 0 4
17341: PUSH
17342: LD_VAR 0 1
17346: PPUSH
17347: LD_INT 171
17349: PPUSH
17350: EMPTY
17351: PPUSH
17352: CALL 12043 0 3
17356: ST_TO_ADDR
// if not ape then
17357: LD_VAR 0 4
17361: NOT
17362: IFFALSE 17394
// if MCF_Ape ( side ) then
17364: LD_VAR 0 1
17368: PPUSH
17369: CALL 11753 0 1
17373: IFFALSE 17394
// ape := MCF_Ape ( side ) [ 1 ] ;
17375: LD_ADDR_VAR 0 4
17379: PUSH
17380: LD_VAR 0 1
17384: PPUSH
17385: CALL 11753 0 1
17389: PUSH
17390: LD_INT 1
17392: ARRAY
17393: ST_TO_ADDR
// if ape then
17394: LD_VAR 0 4
17398: IFFALSE 17449
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17400: LD_VAR 0 4
17404: PUSH
17405: LD_INT 1
17407: ARRAY
17408: PPUSH
17409: CALL_OW 310
17413: PUSH
17414: LD_VAR 0 4
17418: PUSH
17419: LD_INT 1
17421: ARRAY
17422: PPUSH
17423: CALL_OW 310
17427: PUSH
17428: LD_VAR 0 2
17432: NONEQUAL
17433: AND
17434: IFFALSE 17449
// ComExitBuilding ( ape [ 1 ] ) ;
17436: LD_VAR 0 4
17440: PUSH
17441: LD_INT 1
17443: ARRAY
17444: PPUSH
17445: CALL_OW 122
// if not lab then
17449: LD_VAR 0 2
17453: NOT
17454: IFFALSE 17460
// exit else
17456: GO 17608
17458: GO 17568
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17460: LD_VAR 0 1
17464: PPUSH
17465: LD_INT 16
17467: PPUSH
17468: LD_INT 25
17470: PUSH
17471: LD_INT 4
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PPUSH
17478: CALL 12043 0 3
17482: PUSH
17483: LD_INT 0
17485: EQUAL
17486: PUSH
17487: LD_VAR 0 2
17491: PPUSH
17492: CALL_OW 313
17496: PUSH
17497: LD_INT 6
17499: EQUAL
17500: AND
17501: IFFALSE 17568
// begin tmp := UnitsInside ( lab ) ;
17503: LD_ADDR_VAR 0 5
17507: PUSH
17508: LD_VAR 0 2
17512: PPUSH
17513: CALL_OW 313
17517: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17518: LD_VAR 0 5
17522: PUSH
17523: LD_VAR 0 5
17527: ARRAY
17528: PPUSH
17529: LD_INT 16
17531: PPUSH
17532: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17536: LD_VAR 0 5
17540: PUSH
17541: LD_VAR 0 5
17545: ARRAY
17546: PPUSH
17547: CALL_OW 310
17551: IFFALSE 17568
// ComExitBuilding ( tmp [ tmp ] ) ;
17553: LD_VAR 0 5
17557: PUSH
17558: LD_VAR 0 5
17562: ARRAY
17563: PPUSH
17564: CALL_OW 122
// end ; if ape then
17568: LD_VAR 0 4
17572: IFFALSE 17608
// if not IsInUnit ( ape [ 1 ] ) then
17574: LD_VAR 0 4
17578: PUSH
17579: LD_INT 1
17581: ARRAY
17582: PPUSH
17583: CALL_OW 310
17587: NOT
17588: IFFALSE 17608
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17590: LD_VAR 0 4
17594: PUSH
17595: LD_INT 1
17597: ARRAY
17598: PPUSH
17599: LD_VAR 0 2
17603: PPUSH
17604: CALL_OW 120
// end ;
17608: LD_VAR 0 3
17612: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17613: LD_INT 0
17615: PPUSH
17616: PPUSH
17617: PPUSH
// result := false ;
17618: LD_ADDR_VAR 0 2
17622: PUSH
17623: LD_INT 0
17625: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_VAR 0 1
17635: PPUSH
17636: CALL 17723 0 1
17640: ST_TO_ADDR
// if techs then
17641: LD_VAR 0 3
17645: IFFALSE 17675
// if techs [ 2 ] then
17647: LD_VAR 0 3
17651: PUSH
17652: LD_INT 2
17654: ARRAY
17655: IFFALSE 17667
// result := true else
17657: LD_ADDR_VAR 0 2
17661: PUSH
17662: LD_INT 1
17664: ST_TO_ADDR
17665: GO 17675
// result := false ;
17667: LD_ADDR_VAR 0 2
17671: PUSH
17672: LD_INT 0
17674: ST_TO_ADDR
// end ;
17675: LD_VAR 0 2
17679: RET
// export function MCL_Start ( side ) ; var i ; begin
17680: LD_INT 0
17682: PPUSH
17683: PPUSH
// if MCL_GetTechList ( side ) then
17684: LD_VAR 0 1
17688: PPUSH
17689: CALL 17723 0 1
17693: IFFALSE 17718
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17695: LD_VAR 0 1
17699: PPUSH
17700: LD_VAR 0 1
17704: PPUSH
17705: CALL 17723 0 1
17709: PUSH
17710: LD_INT 1
17712: ARRAY
17713: PPUSH
17714: CALL 16810 0 2
// end ;
17718: LD_VAR 0 2
17722: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17723: LD_INT 0
17725: PPUSH
17726: PPUSH
17727: PPUSH
// if MREG_ToRes then
17728: LD_EXP 52
17732: IFFALSE 17817
// for i = 1 to MREG_ToRes do
17734: LD_ADDR_VAR 0 3
17738: PUSH
17739: DOUBLE
17740: LD_INT 1
17742: DEC
17743: ST_TO_ADDR
17744: LD_EXP 52
17748: PUSH
17749: FOR_TO
17750: IFFALSE 17815
// if MREG_ToRes [ i ] [ 1 ] = side then
17752: LD_EXP 52
17756: PUSH
17757: LD_VAR 0 3
17761: ARRAY
17762: PUSH
17763: LD_INT 1
17765: ARRAY
17766: PUSH
17767: LD_VAR 0 1
17771: EQUAL
17772: IFFALSE 17813
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17774: LD_ADDR_VAR 0 4
17778: PUSH
17779: LD_VAR 0 4
17783: PPUSH
17784: LD_VAR 0 4
17788: PUSH
17789: LD_INT 1
17791: PLUS
17792: PPUSH
17793: LD_EXP 52
17797: PUSH
17798: LD_VAR 0 3
17802: ARRAY
17803: PUSH
17804: LD_INT 2
17806: ARRAY
17807: PPUSH
17808: CALL_OW 1
17812: ST_TO_ADDR
// end ;
17813: GO 17749
17815: POP
17816: POP
// result := techs ;
17817: LD_ADDR_VAR 0 2
17821: PUSH
17822: LD_VAR 0 4
17826: ST_TO_ADDR
// end ;
17827: LD_VAR 0 2
17831: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
17832: LD_INT 0
17834: PPUSH
17835: PPUSH
// for i = 1 to tech_list do
17836: LD_ADDR_VAR 0 4
17840: PUSH
17841: DOUBLE
17842: LD_INT 1
17844: DEC
17845: ST_TO_ADDR
17846: LD_VAR 0 2
17850: PUSH
17851: FOR_TO
17852: IFFALSE 17906
// if not tech_list [ i ] = 20 then
17854: LD_VAR 0 2
17858: PUSH
17859: LD_VAR 0 4
17863: ARRAY
17864: PUSH
17865: LD_INT 20
17867: EQUAL
17868: NOT
17869: IFFALSE 17904
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
17871: LD_ADDR_EXP 52
17875: PUSH
17876: LD_EXP 52
17880: PPUSH
17881: LD_VAR 0 1
17885: PPUSH
17886: LD_VAR 0 2
17890: PUSH
17891: LD_VAR 0 4
17895: ARRAY
17896: PPUSH
17897: EMPTY
17898: PPUSH
17899: CALL 42056 0 4
17903: ST_TO_ADDR
17904: GO 17851
17906: POP
17907: POP
// result := true ;
17908: LD_ADDR_VAR 0 3
17912: PUSH
17913: LD_INT 1
17915: ST_TO_ADDR
// end ;
17916: LD_VAR 0 3
17920: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
17921: LD_INT 0
17923: PPUSH
17924: PPUSH
// for i = MREG_ToRes downto 1 do
17925: LD_ADDR_VAR 0 3
17929: PUSH
17930: DOUBLE
17931: LD_EXP 52
17935: INC
17936: ST_TO_ADDR
17937: LD_INT 1
17939: PUSH
17940: FOR_DOWNTO
17941: IFFALSE 17987
// if MREG_ToRes [ i ] [ 1 ] = side then
17943: LD_EXP 52
17947: PUSH
17948: LD_VAR 0 3
17952: ARRAY
17953: PUSH
17954: LD_INT 1
17956: ARRAY
17957: PUSH
17958: LD_VAR 0 1
17962: EQUAL
17963: IFFALSE 17985
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
17965: LD_ADDR_EXP 52
17969: PUSH
17970: LD_EXP 52
17974: PPUSH
17975: LD_VAR 0 3
17979: PPUSH
17980: CALL_OW 3
17984: ST_TO_ADDR
17985: GO 17940
17987: POP
17988: POP
// result := true ;
17989: LD_ADDR_VAR 0 2
17993: PUSH
17994: LD_INT 1
17996: ST_TO_ADDR
// end ;
17997: LD_VAR 0 2
18001: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18002: LD_INT 0
18004: PPUSH
// result := GetTechProgress ( side , tech ) ;
18005: LD_ADDR_VAR 0 3
18009: PUSH
18010: LD_VAR 0 1
18014: PPUSH
18015: LD_VAR 0 2
18019: PPUSH
18020: CALL_OW 326
18024: ST_TO_ADDR
// end ;
18025: LD_VAR 0 3
18029: RET
// export function MCL_Require ( tech ) ; begin
18030: LD_INT 0
18032: PPUSH
// result := GetTechTechsReq ( tech ) ;
18033: LD_ADDR_VAR 0 2
18037: PUSH
18038: LD_VAR 0 1
18042: PPUSH
18043: CALL_OW 480
18047: ST_TO_ADDR
// end ; end_of_file
18048: LD_VAR 0 2
18052: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18053: LD_INT 0
18055: PPUSH
18056: PPUSH
18057: PPUSH
// uc_side := 0 ;
18058: LD_ADDR_OWVAR 20
18062: PUSH
18063: LD_INT 0
18065: ST_TO_ADDR
// uc_nation := 0 ;
18066: LD_ADDR_OWVAR 21
18070: PUSH
18071: LD_INT 0
18073: ST_TO_ADDR
// for i = 1 to n do
18074: LD_ADDR_VAR 0 5
18078: PUSH
18079: DOUBLE
18080: LD_INT 1
18082: DEC
18083: ST_TO_ADDR
18084: LD_VAR 0 2
18088: PUSH
18089: FOR_TO
18090: IFFALSE 18235
// begin hc_importance := 0 ;
18092: LD_ADDR_OWVAR 32
18096: PUSH
18097: LD_INT 0
18099: ST_TO_ADDR
// hc_gallery :=  ;
18100: LD_ADDR_OWVAR 33
18104: PUSH
18105: LD_STRING 
18107: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18108: LD_ADDR_OWVAR 35
18112: PUSH
18113: LD_VAR 0 3
18117: PUSH
18118: LD_INT 20
18120: MINUS
18121: PPUSH
18122: LD_VAR 0 3
18126: PUSH
18127: LD_INT 20
18129: PLUS
18130: PPUSH
18131: CALL_OW 12
18135: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18136: LD_ADDR_OWVAR 31
18140: PUSH
18141: LD_INT 0
18143: PPUSH
18144: LD_INT 2
18146: PPUSH
18147: CALL_OW 12
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: LD_INT 0
18160: PUSH
18161: EMPTY
18162: LIST
18163: LIST
18164: LIST
18165: LIST
18166: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18167: LD_ADDR_OWVAR 30
18171: PUSH
18172: LD_INT 0
18174: PUSH
18175: LD_INT 0
18177: PUSH
18178: LD_INT 0
18180: PUSH
18181: LD_INT 0
18183: PUSH
18184: EMPTY
18185: LIST
18186: LIST
18187: LIST
18188: LIST
18189: ST_TO_ADDR
// hc_name :=  ;
18190: LD_ADDR_OWVAR 26
18194: PUSH
18195: LD_STRING 
18197: ST_TO_ADDR
// hc_class := class_apeman ;
18198: LD_ADDR_OWVAR 28
18202: PUSH
18203: LD_INT 12
18205: ST_TO_ADDR
// ape := CreateHuman ;
18206: LD_ADDR_VAR 0 6
18210: PUSH
18211: CALL_OW 44
18215: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18216: LD_VAR 0 6
18220: PPUSH
18221: LD_VAR 0 1
18225: PPUSH
18226: LD_INT 0
18228: PPUSH
18229: CALL_OW 49
// end ;
18233: GO 18089
18235: POP
18236: POP
// end ;
18237: LD_VAR 0 4
18241: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18242: LD_INT 0
18244: PPUSH
18245: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18246: LD_VAR 0 1
18250: PPUSH
18251: CALL 11753 0 1
18255: PUSH
18256: LD_EXP 39
18260: PUSH
18261: LD_VAR 0 1
18265: ARRAY
18266: GREATEREQUAL
18267: IFFALSE 18444
// begin if GetTag ( unit ) = 17 then
18269: LD_VAR 0 2
18273: PPUSH
18274: CALL_OW 110
18278: PUSH
18279: LD_INT 17
18281: EQUAL
18282: IFFALSE 18442
// begin SetTag ( unit , 0 ) ;
18284: LD_VAR 0 2
18288: PPUSH
18289: LD_INT 0
18291: PPUSH
18292: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18296: LD_VAR 0 1
18300: PPUSH
18301: CALL 11379 0 1
18305: PUSH
18306: LD_VAR 0 1
18310: PPUSH
18311: CALL 17723 0 1
18315: NOT
18316: AND
18317: IFFALSE 18342
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18319: LD_VAR 0 2
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: CALL 11379 0 1
18333: PUSH
18334: LD_INT 1
18336: ARRAY
18337: PPUSH
18338: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18342: LD_VAR 0 1
18346: PPUSH
18347: CALL 11379 0 1
18351: NOT
18352: PUSH
18353: LD_VAR 0 1
18357: PPUSH
18358: LD_INT 30
18360: PUSH
18361: LD_INT 1
18363: PUSH
18364: EMPTY
18365: LIST
18366: LIST
18367: PPUSH
18368: CALL 11340 0 2
18372: AND
18373: IFFALSE 18442
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18375: LD_VAR 0 2
18379: PPUSH
18380: LD_VAR 0 1
18384: PPUSH
18385: LD_INT 30
18387: PUSH
18388: LD_INT 1
18390: PUSH
18391: EMPTY
18392: LIST
18393: LIST
18394: PPUSH
18395: CALL 11340 0 2
18399: PUSH
18400: LD_INT 1
18402: ARRAY
18403: PPUSH
18404: CALL_OW 250
18408: PPUSH
18409: LD_VAR 0 1
18413: PPUSH
18414: LD_INT 30
18416: PUSH
18417: LD_INT 1
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PPUSH
18424: CALL 11340 0 2
18428: PUSH
18429: LD_INT 1
18431: ARRAY
18432: PPUSH
18433: CALL_OW 251
18437: PPUSH
18438: CALL_OW 111
// end ; end else
18442: GO 18628
// if GetClass ( unit ) <> 4 then
18444: LD_VAR 0 2
18448: PPUSH
18449: CALL_OW 257
18453: PUSH
18454: LD_INT 4
18456: NONEQUAL
18457: IFFALSE 18463
// exit else
18459: GO 18628
18461: GO 18628
// if GetTag ( unit ) = 0 then
18463: LD_VAR 0 2
18467: PPUSH
18468: CALL_OW 110
18472: PUSH
18473: LD_INT 0
18475: EQUAL
18476: IFFALSE 18492
// SetTag ( unit , 17 ) else
18478: LD_VAR 0 2
18482: PPUSH
18483: LD_INT 17
18485: PPUSH
18486: CALL_OW 109
18490: GO 18628
// begin if IsInUnit ( unit ) then
18492: LD_VAR 0 2
18496: PPUSH
18497: CALL_OW 310
18501: IFFALSE 18512
// ComExitBuilding ( unit ) ;
18503: LD_VAR 0 2
18507: PPUSH
18508: CALL_OW 122
// Wait ( 1 ) ;
18512: LD_INT 1
18514: PPUSH
18515: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18519: LD_ADDR_VAR 0 4
18523: PUSH
18524: LD_INT 22
18526: PUSH
18527: LD_INT 0
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: LD_INT 25
18536: PUSH
18537: LD_INT 12
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: PPUSH
18548: CALL_OW 69
18552: PPUSH
18553: LD_VAR 0 2
18557: PPUSH
18558: CALL_OW 74
18562: ST_TO_ADDR
// if not ape then
18563: LD_VAR 0 4
18567: NOT
18568: IFFALSE 18574
// exit else
18570: GO 18628
18572: GO 18583
// ComHold ( ape ) ;
18574: LD_VAR 0 4
18578: PPUSH
18579: CALL_OW 140
// if not HasTask ( unit ) then
18583: LD_VAR 0 2
18587: PPUSH
18588: CALL_OW 314
18592: NOT
18593: IFFALSE 18626
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_VAR 0 4
18604: PPUSH
18605: CALL_OW 250
18609: PPUSH
18610: LD_VAR 0 4
18614: PPUSH
18615: CALL_OW 251
18619: PPUSH
18620: CALL_OW 131
18624: GO 18628
// exit ;
18626: GO 18628
// end ; end ;
18628: LD_VAR 0 3
18632: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18633: LD_INT 0
18635: PPUSH
18636: PPUSH
18637: PPUSH
18638: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18639: LD_ADDR_VAR 0 4
18643: PUSH
18644: LD_EXP 40
18648: PUSH
18649: LD_VAR 0 1
18653: ARRAY
18654: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18655: LD_ADDR_VAR 0 5
18659: PUSH
18660: LD_VAR 0 1
18664: PPUSH
18665: LD_STRING normal
18667: PPUSH
18668: CALL 11837 0 2
18672: ST_TO_ADDR
// if apes then
18673: LD_VAR 0 5
18677: IFFALSE 18905
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18679: LD_INT 2
18681: PPUSH
18682: LD_VAR 0 1
18686: PPUSH
18687: CALL_OW 321
18691: PUSH
18692: LD_INT 2
18694: EQUAL
18695: PUSH
18696: LD_VAR 0 4
18700: PUSH
18701: LD_INT 2
18703: ARRAY
18704: PUSH
18705: LD_INT 1
18707: EQUAL
18708: AND
18709: PUSH
18710: LD_VAR 0 1
18714: PPUSH
18715: LD_STRING engineer
18717: PPUSH
18718: CALL 11837 0 2
18722: PUSH
18723: LD_INT 3
18725: LESS
18726: AND
18727: PUSH
18728: LD_VAR 0 1
18732: PPUSH
18733: LD_INT 30
18735: PUSH
18736: LD_INT 1
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL 11340 0 2
18747: AND
18748: IFFALSE 18802
// begin for i in apes do
18750: LD_ADDR_VAR 0 3
18754: PUSH
18755: LD_VAR 0 5
18759: PUSH
18760: FOR_IN
18761: IFFALSE 18798
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18763: LD_VAR 0 3
18767: PPUSH
18768: LD_VAR 0 1
18772: PPUSH
18773: LD_INT 30
18775: PUSH
18776: LD_INT 1
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL 11340 0 2
18787: PUSH
18788: LD_INT 1
18790: ARRAY
18791: PPUSH
18792: CALL_OW 120
// end ;
18796: GO 18760
18798: POP
18799: POP
// end else
18800: GO 18905
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
18802: LD_INT 11
18804: PPUSH
18805: LD_VAR 0 1
18809: PPUSH
18810: CALL_OW 321
18814: PUSH
18815: LD_INT 2
18817: EQUAL
18818: PUSH
18819: LD_VAR 0 4
18823: PUSH
18824: LD_INT 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: EQUAL
18831: AND
18832: PUSH
18833: LD_VAR 0 1
18837: PPUSH
18838: LD_INT 30
18840: PUSH
18841: LD_INT 5
18843: PUSH
18844: EMPTY
18845: LIST
18846: LIST
18847: PPUSH
18848: CALL 11340 0 2
18852: AND
18853: IFFALSE 18905
// begin for i in apes do
18855: LD_ADDR_VAR 0 3
18859: PUSH
18860: LD_VAR 0 5
18864: PUSH
18865: FOR_IN
18866: IFFALSE 18903
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
18868: LD_VAR 0 3
18872: PPUSH
18873: LD_VAR 0 1
18877: PPUSH
18878: LD_INT 30
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PPUSH
18888: CALL 11340 0 2
18892: PUSH
18893: LD_INT 1
18895: ARRAY
18896: PPUSH
18897: CALL_OW 120
// end ;
18901: GO 18865
18903: POP
18904: POP
// end ; end ; end ; end_of_file
18905: LD_VAR 0 2
18909: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
18910: LD_INT 0
18912: PPUSH
18913: PPUSH
// if not GetClass ( unit ) = 4 or not target then
18914: LD_VAR 0 1
18918: PPUSH
18919: CALL_OW 257
18923: PUSH
18924: LD_INT 4
18926: EQUAL
18927: NOT
18928: PUSH
18929: LD_VAR 0 2
18933: NOT
18934: OR
18935: IFFALSE 18941
// exit else
18937: GO 18975
18939: GO 18975
// if not GetTag ( unit ) = 4 then
18941: LD_VAR 0 1
18945: PPUSH
18946: CALL_OW 110
18950: PUSH
18951: LD_INT 4
18953: EQUAL
18954: NOT
18955: IFFALSE 18961
// exit else
18957: GO 18975
18959: GO 18975
// ComHeal ( unit , target ) ;
18961: LD_VAR 0 1
18965: PPUSH
18966: LD_VAR 0 2
18970: PPUSH
18971: CALL_OW 128
// end ;
18975: LD_VAR 0 3
18979: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
18980: LD_INT 0
18982: PPUSH
18983: PPUSH
18984: PPUSH
18985: PPUSH
18986: PPUSH
18987: PPUSH
18988: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
18989: LD_ADDR_VAR 0 5
18993: PUSH
18994: LD_INT 22
18996: PUSH
18997: LD_VAR 0 1
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PUSH
19006: LD_INT 21
19008: PUSH
19009: LD_INT 1
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: PUSH
19016: LD_INT 3
19018: PUSH
19019: LD_INT 55
19021: PUSH
19022: EMPTY
19023: LIST
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: PUSH
19029: LD_INT 3
19031: PUSH
19032: LD_INT 54
19034: PUSH
19035: EMPTY
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: PUSH
19042: LD_INT 3
19044: PUSH
19045: LD_INT 24
19047: PUSH
19048: LD_INT 1000
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: EMPTY
19060: LIST
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: PPUSH
19066: CALL_OW 69
19070: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19071: LD_ADDR_VAR 0 8
19075: PUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 30
19083: PUSH
19084: LD_INT 1
19086: PUSH
19087: EMPTY
19088: LIST
19089: LIST
19090: PPUSH
19091: CALL 11340 0 2
19095: ST_TO_ADDR
// r := [ ] ;
19096: LD_ADDR_VAR 0 6
19100: PUSH
19101: EMPTY
19102: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19103: LD_VAR 0 1
19107: PPUSH
19108: LD_INT 5
19110: PPUSH
19111: EMPTY
19112: PPUSH
19113: CALL 12043 0 3
19117: IFFALSE 19173
// for j in MCF_Tag ( side , 5 , [ ] ) do
19119: LD_ADDR_VAR 0 4
19123: PUSH
19124: LD_VAR 0 1
19128: PPUSH
19129: LD_INT 5
19131: PPUSH
19132: EMPTY
19133: PPUSH
19134: CALL 12043 0 3
19138: PUSH
19139: FOR_IN
19140: IFFALSE 19171
// if GetLives ( j ) = 1000 then
19142: LD_VAR 0 4
19146: PPUSH
19147: CALL_OW 256
19151: PUSH
19152: LD_INT 1000
19154: EQUAL
19155: IFFALSE 19169
// SetTag ( j , 0 ) ;
19157: LD_VAR 0 4
19161: PPUSH
19162: LD_INT 0
19164: PPUSH
19165: CALL_OW 109
19169: GO 19139
19171: POP
19172: POP
// if tmp then
19173: LD_VAR 0 5
19177: IFFALSE 19506
// begin r := [ tmp [ 1 ] ] ;
19179: LD_ADDR_VAR 0 6
19183: PUSH
19184: LD_VAR 0 5
19188: PUSH
19189: LD_INT 1
19191: ARRAY
19192: PUSH
19193: EMPTY
19194: LIST
19195: ST_TO_ADDR
// for i = 2 to tmp do
19196: LD_ADDR_VAR 0 3
19200: PUSH
19201: DOUBLE
19202: LD_INT 2
19204: DEC
19205: ST_TO_ADDR
19206: LD_VAR 0 5
19210: PUSH
19211: FOR_TO
19212: IFFALSE 19504
// begin m := false ;
19214: LD_ADDR_VAR 0 7
19218: PUSH
19219: LD_INT 0
19221: ST_TO_ADDR
// if d then
19222: LD_VAR 0 8
19226: IFFALSE 19381
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19228: LD_VAR 0 5
19232: PUSH
19233: LD_VAR 0 3
19237: ARRAY
19238: PPUSH
19239: CALL_OW 256
19243: PUSH
19244: LD_INT 650
19246: LESS
19247: PUSH
19248: LD_VAR 0 5
19252: PUSH
19253: LD_VAR 0 3
19257: ARRAY
19258: PPUSH
19259: LD_VAR 0 8
19263: PUSH
19264: LD_INT 1
19266: ARRAY
19267: PPUSH
19268: CALL_OW 250
19272: PPUSH
19273: LD_VAR 0 8
19277: PUSH
19278: LD_INT 1
19280: ARRAY
19281: PPUSH
19282: CALL_OW 251
19286: PPUSH
19287: CALL_OW 297
19291: PUSH
19292: LD_INT 10
19294: GREATER
19295: AND
19296: IFFALSE 19381
// begin if not GetTag ( tmp [ i ] ) = 5 then
19298: LD_VAR 0 5
19302: PUSH
19303: LD_VAR 0 3
19307: ARRAY
19308: PPUSH
19309: CALL_OW 110
19313: PUSH
19314: LD_INT 5
19316: EQUAL
19317: NOT
19318: IFFALSE 19338
// SetTag ( tmp [ i ] , 5 ) ;
19320: LD_VAR 0 5
19324: PUSH
19325: LD_VAR 0 3
19329: ARRAY
19330: PPUSH
19331: LD_INT 5
19333: PPUSH
19334: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19338: LD_VAR 0 5
19342: PUSH
19343: LD_VAR 0 3
19347: ARRAY
19348: PPUSH
19349: LD_VAR 0 8
19353: PUSH
19354: LD_INT 1
19356: ARRAY
19357: PPUSH
19358: CALL_OW 250
19362: PPUSH
19363: LD_VAR 0 8
19367: PUSH
19368: LD_INT 1
19370: ARRAY
19371: PPUSH
19372: CALL_OW 251
19376: PPUSH
19377: CALL_OW 111
// end ; for j = 1 to r do
19381: LD_ADDR_VAR 0 4
19385: PUSH
19386: DOUBLE
19387: LD_INT 1
19389: DEC
19390: ST_TO_ADDR
19391: LD_VAR 0 6
19395: PUSH
19396: FOR_TO
19397: IFFALSE 19471
// if GetLives ( tmp [ i ] ) < r [ j ] then
19399: LD_VAR 0 5
19403: PUSH
19404: LD_VAR 0 3
19408: ARRAY
19409: PPUSH
19410: CALL_OW 256
19414: PUSH
19415: LD_VAR 0 6
19419: PUSH
19420: LD_VAR 0 4
19424: ARRAY
19425: LESS
19426: IFFALSE 19469
// begin r := Insert ( r , j , tmp [ i ] ) ;
19428: LD_ADDR_VAR 0 6
19432: PUSH
19433: LD_VAR 0 6
19437: PPUSH
19438: LD_VAR 0 4
19442: PPUSH
19443: LD_VAR 0 5
19447: PUSH
19448: LD_VAR 0 3
19452: ARRAY
19453: PPUSH
19454: CALL_OW 2
19458: ST_TO_ADDR
// m := true ;
19459: LD_ADDR_VAR 0 7
19463: PUSH
19464: LD_INT 1
19466: ST_TO_ADDR
// break ;
19467: GO 19471
// end ;
19469: GO 19396
19471: POP
19472: POP
// if not m then
19473: LD_VAR 0 7
19477: NOT
19478: IFFALSE 19502
// r := r ^ tmp [ i ] ;
19480: LD_ADDR_VAR 0 6
19484: PUSH
19485: LD_VAR 0 6
19489: PUSH
19490: LD_VAR 0 5
19494: PUSH
19495: LD_VAR 0 3
19499: ARRAY
19500: ADD
19501: ST_TO_ADDR
// end ;
19502: GO 19211
19504: POP
19505: POP
// end ; result := r end ; end_of_file
19506: LD_ADDR_VAR 0 2
19510: PUSH
19511: LD_VAR 0 6
19515: ST_TO_ADDR
19516: LD_VAR 0 2
19520: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19521: LD_INT 0
19523: PPUSH
19524: PPUSH
19525: PPUSH
// pom := GetBase ( bdepot ) ;
19526: LD_ADDR_VAR 0 3
19530: PUSH
19531: LD_VAR 0 1
19535: PPUSH
19536: CALL_OW 274
19540: ST_TO_ADDR
// sor := [ ] ;
19541: LD_ADDR_VAR 0 4
19545: PUSH
19546: EMPTY
19547: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19548: LD_ADDR_VAR 0 4
19552: PUSH
19553: LD_VAR 0 4
19557: PUSH
19558: LD_VAR 0 3
19562: PPUSH
19563: LD_INT 1
19565: PPUSH
19566: CALL_OW 275
19570: ADD
19571: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19572: LD_ADDR_VAR 0 4
19576: PUSH
19577: LD_VAR 0 4
19581: PUSH
19582: LD_VAR 0 3
19586: PPUSH
19587: LD_INT 2
19589: PPUSH
19590: CALL_OW 275
19594: ADD
19595: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19596: LD_ADDR_VAR 0 4
19600: PUSH
19601: LD_VAR 0 4
19605: PUSH
19606: LD_VAR 0 3
19610: PPUSH
19611: LD_INT 3
19613: PPUSH
19614: CALL_OW 275
19618: ADD
19619: ST_TO_ADDR
// result := sor ;
19620: LD_ADDR_VAR 0 2
19624: PUSH
19625: LD_VAR 0 4
19629: ST_TO_ADDR
// end ;
19630: LD_VAR 0 2
19634: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19635: LD_INT 0
19637: PPUSH
19638: PPUSH
// while ( coord_list ) do
19639: LD_VAR 0 3
19643: IFFALSE 19817
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19645: LD_ADDR_EXP 48
19649: PUSH
19650: LD_EXP 48
19654: PPUSH
19655: LD_VAR 0 1
19659: PPUSH
19660: LD_VAR 0 2
19664: PPUSH
19665: LD_VAR 0 3
19669: PUSH
19670: LD_INT 1
19672: ARRAY
19673: PUSH
19674: LD_VAR 0 3
19678: PUSH
19679: LD_INT 2
19681: ARRAY
19682: PUSH
19683: LD_VAR 0 3
19687: PUSH
19688: LD_INT 3
19690: ARRAY
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: LIST
19696: PPUSH
19697: CALL 42056 0 4
19701: ST_TO_ADDR
// if weapon_list then
19702: LD_VAR 0 4
19706: IFFALSE 19777
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19708: LD_ADDR_EXP 45
19712: PUSH
19713: LD_EXP 45
19717: PPUSH
19718: LD_VAR 0 1
19722: PPUSH
19723: LD_VAR 0 4
19727: PUSH
19728: LD_INT 1
19730: ARRAY
19731: PPUSH
19732: LD_VAR 0 3
19736: PUSH
19737: LD_INT 1
19739: ARRAY
19740: PUSH
19741: LD_VAR 0 3
19745: PUSH
19746: LD_INT 2
19748: ARRAY
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: PPUSH
19754: CALL 42056 0 4
19758: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19759: LD_ADDR_VAR 0 4
19763: PUSH
19764: LD_VAR 0 4
19768: PPUSH
19769: LD_INT 1
19771: PPUSH
19772: CALL_OW 3
19776: ST_TO_ADDR
// end ; for i = 1 to 3 do
19777: LD_ADDR_VAR 0 6
19781: PUSH
19782: DOUBLE
19783: LD_INT 1
19785: DEC
19786: ST_TO_ADDR
19787: LD_INT 3
19789: PUSH
19790: FOR_TO
19791: IFFALSE 19813
// coord_list := Delete ( coord_list , 1 ) ;
19793: LD_ADDR_VAR 0 3
19797: PUSH
19798: LD_VAR 0 3
19802: PPUSH
19803: LD_INT 1
19805: PPUSH
19806: CALL_OW 3
19810: ST_TO_ADDR
19811: GO 19790
19813: POP
19814: POP
// end ;
19815: GO 19639
// result := true ;
19817: LD_ADDR_VAR 0 5
19821: PUSH
19822: LD_INT 1
19824: ST_TO_ADDR
// end ;
19825: LD_VAR 0 5
19829: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
19830: LD_INT 0
19832: PPUSH
19833: PPUSH
// if not weapon_list then
19834: LD_VAR 0 3
19838: NOT
19839: IFFALSE 19843
// exit ;
19841: GO 19958
// while ( coord_list ) do
19843: LD_VAR 0 2
19847: IFFALSE 19958
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19849: LD_ADDR_EXP 45
19853: PUSH
19854: LD_EXP 45
19858: PPUSH
19859: LD_VAR 0 1
19863: PPUSH
19864: LD_VAR 0 3
19868: PUSH
19869: LD_INT 1
19871: ARRAY
19872: PPUSH
19873: LD_VAR 0 2
19877: PUSH
19878: LD_INT 1
19880: ARRAY
19881: PUSH
19882: LD_VAR 0 2
19886: PUSH
19887: LD_INT 2
19889: ARRAY
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: PPUSH
19895: CALL 42056 0 4
19899: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19900: LD_ADDR_VAR 0 3
19904: PUSH
19905: LD_VAR 0 3
19909: PPUSH
19910: LD_INT 1
19912: PPUSH
19913: CALL_OW 3
19917: ST_TO_ADDR
// for i = 1 to 2 do
19918: LD_ADDR_VAR 0 5
19922: PUSH
19923: DOUBLE
19924: LD_INT 1
19926: DEC
19927: ST_TO_ADDR
19928: LD_INT 2
19930: PUSH
19931: FOR_TO
19932: IFFALSE 19954
// coord_list := Delete ( coord_list , 1 ) ;
19934: LD_ADDR_VAR 0 2
19938: PUSH
19939: LD_VAR 0 2
19943: PPUSH
19944: LD_INT 1
19946: PPUSH
19947: CALL_OW 3
19951: ST_TO_ADDR
19952: GO 19931
19954: POP
19955: POP
// end ;
19956: GO 19843
// end ;
19958: LD_VAR 0 4
19962: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
19963: LD_INT 0
19965: PPUSH
19966: PPUSH
// while ( coord_list ) do
19967: LD_VAR 0 2
19971: IFFALSE 20126
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
19973: LD_VAR 0 2
19977: PUSH
19978: LD_INT 1
19980: ARRAY
19981: PPUSH
19982: LD_VAR 0 2
19986: PUSH
19987: LD_INT 2
19989: ARRAY
19990: PPUSH
19991: CALL_OW 428
19995: IFFALSE 20086
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
19997: LD_VAR 0 2
20001: PUSH
20002: LD_INT 1
20004: ARRAY
20005: PPUSH
20006: LD_VAR 0 2
20010: PUSH
20011: LD_INT 2
20013: ARRAY
20014: PPUSH
20015: CALL_OW 428
20019: PPUSH
20020: CALL_OW 266
20024: PUSH
20025: LD_INT 31
20027: PUSH
20028: LD_INT 32
20030: PUSH
20031: LD_INT 33
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: LIST
20038: IN
20039: IFFALSE 20086
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20041: LD_ADDR_EXP 54
20045: PUSH
20046: LD_EXP 54
20050: PPUSH
20051: LD_VAR 0 1
20055: PPUSH
20056: LD_VAR 0 2
20060: PUSH
20061: LD_INT 1
20063: ARRAY
20064: PPUSH
20065: LD_VAR 0 2
20069: PUSH
20070: LD_INT 2
20072: ARRAY
20073: PPUSH
20074: CALL_OW 428
20078: PPUSH
20079: EMPTY
20080: PPUSH
20081: CALL 42056 0 4
20085: ST_TO_ADDR
// for i = 1 to 3 do
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: DOUBLE
20092: LD_INT 1
20094: DEC
20095: ST_TO_ADDR
20096: LD_INT 3
20098: PUSH
20099: FOR_TO
20100: IFFALSE 20122
// coord_list := Delete ( coord_list , 1 ) ;
20102: LD_ADDR_VAR 0 2
20106: PUSH
20107: LD_VAR 0 2
20111: PPUSH
20112: LD_INT 1
20114: PPUSH
20115: CALL_OW 3
20119: ST_TO_ADDR
20120: GO 20099
20122: POP
20123: POP
// end ;
20124: GO 19967
// result := true ;
20126: LD_ADDR_VAR 0 3
20130: PUSH
20131: LD_INT 1
20133: ST_TO_ADDR
// end ;
20134: LD_VAR 0 3
20138: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20139: LD_INT 0
20141: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20142: LD_ADDR_EXP 48
20146: PUSH
20147: LD_EXP 48
20151: PPUSH
20152: LD_VAR 0 1
20156: PPUSH
20157: LD_INT 0
20159: PPUSH
20160: LD_VAR 0 2
20164: PPUSH
20165: CALL 42056 0 4
20169: ST_TO_ADDR
// end ;
20170: LD_VAR 0 3
20174: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20175: LD_INT 0
20177: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20178: LD_ADDR_EXP 48
20182: PUSH
20183: LD_EXP 48
20187: PPUSH
20188: LD_VAR 0 1
20192: PPUSH
20193: LD_INT 6
20195: PPUSH
20196: LD_VAR 0 2
20200: PPUSH
20201: CALL 42056 0 4
20205: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20206: LD_ADDR_EXP 51
20210: PUSH
20211: LD_EXP 51
20215: PPUSH
20216: LD_VAR 0 1
20220: PPUSH
20221: LD_VAR 0 3
20225: PUSH
20226: LD_INT 1
20228: ARRAY
20229: PPUSH
20230: LD_VAR 0 3
20234: PUSH
20235: LD_INT 2
20237: ARRAY
20238: PPUSH
20239: CALL 42056 0 4
20243: ST_TO_ADDR
// end ;
20244: LD_VAR 0 4
20248: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20249: LD_INT 0
20251: PPUSH
20252: PPUSH
// if ext_list > 5 then
20253: LD_VAR 0 3
20257: PUSH
20258: LD_INT 5
20260: GREATER
20261: IFFALSE 20305
// for i = 6 to ext_list do
20263: LD_ADDR_VAR 0 5
20267: PUSH
20268: DOUBLE
20269: LD_INT 6
20271: DEC
20272: ST_TO_ADDR
20273: LD_VAR 0 3
20277: PUSH
20278: FOR_TO
20279: IFFALSE 20303
// ext_list := Delete ( ext_list , ext_list ) ;
20281: LD_ADDR_VAR 0 3
20285: PUSH
20286: LD_VAR 0 3
20290: PPUSH
20291: LD_VAR 0 3
20295: PPUSH
20296: CALL_OW 3
20300: ST_TO_ADDR
20301: GO 20278
20303: POP
20304: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20305: LD_VAR 0 1
20309: PPUSH
20310: LD_VAR 0 2
20314: PUSH
20315: LD_INT 1
20317: ARRAY
20318: PPUSH
20319: LD_VAR 0 2
20323: PUSH
20324: LD_INT 2
20326: ARRAY
20327: PPUSH
20328: LD_VAR 0 2
20332: PUSH
20333: LD_INT 3
20335: ARRAY
20336: PPUSH
20337: LD_VAR 0 3
20341: PPUSH
20342: CALL 8852 0 5
// end ;
20346: LD_VAR 0 4
20350: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20351: LD_INT 0
20353: PPUSH
20354: PPUSH
20355: PPUSH
// p := 1 ;
20356: LD_ADDR_VAR 0 6
20360: PUSH
20361: LD_INT 1
20363: ST_TO_ADDR
// if type_list = [ ] then
20364: LD_VAR 0 3
20368: PUSH
20369: EMPTY
20370: EQUAL
20371: IFFALSE 20381
// type_list := b_oil_power ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 26
20380: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20381: LD_ADDR_VAR 0 5
20385: PUSH
20386: DOUBLE
20387: LD_INT 1
20389: DEC
20390: ST_TO_ADDR
20391: LD_VAR 0 2
20395: PUSH
20396: LD_INT 3
20398: DIVREAL
20399: PUSH
20400: FOR_TO
20401: IFFALSE 20504
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20403: LD_ADDR_EXP 48
20407: PUSH
20408: LD_EXP 48
20412: PPUSH
20413: LD_VAR 0 1
20417: PPUSH
20418: LD_VAR 0 3
20422: PUSH
20423: LD_INT 1
20425: PPUSH
20426: LD_VAR 0 3
20430: PPUSH
20431: CALL_OW 12
20435: ARRAY
20436: PPUSH
20437: LD_VAR 0 2
20441: PUSH
20442: LD_VAR 0 6
20446: ARRAY
20447: PUSH
20448: LD_VAR 0 2
20452: PUSH
20453: LD_VAR 0 6
20457: PUSH
20458: LD_INT 1
20460: PLUS
20461: ARRAY
20462: PUSH
20463: LD_VAR 0 2
20467: PUSH
20468: LD_VAR 0 6
20472: PUSH
20473: LD_INT 2
20475: PLUS
20476: ARRAY
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: LIST
20482: PPUSH
20483: CALL 42056 0 4
20487: ST_TO_ADDR
// p := p + 3 ;
20488: LD_ADDR_VAR 0 6
20492: PUSH
20493: LD_VAR 0 6
20497: PUSH
20498: LD_INT 3
20500: PLUS
20501: ST_TO_ADDR
// end ;
20502: GO 20400
20504: POP
20505: POP
// end ;
20506: LD_VAR 0 4
20510: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20511: LD_INT 0
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
// if not MREG_Deposit [ side ] then
20517: LD_EXP 63
20521: PUSH
20522: LD_VAR 0 1
20526: ARRAY
20527: NOT
20528: IFFALSE 20532
// exit ;
20530: GO 20709
// p := 1 ;
20532: LD_ADDR_VAR 0 4
20536: PUSH
20537: LD_INT 1
20539: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20540: LD_ADDR_VAR 0 3
20544: PUSH
20545: DOUBLE
20546: LD_INT 1
20548: DEC
20549: ST_TO_ADDR
20550: LD_EXP 63
20554: PUSH
20555: LD_VAR 0 1
20559: ARRAY
20560: PUSH
20561: LD_INT 3
20563: DIVREAL
20564: PUSH
20565: FOR_TO
20566: IFFALSE 20707
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20568: LD_EXP 63
20572: PUSH
20573: LD_VAR 0 1
20577: ARRAY
20578: PUSH
20579: LD_VAR 0 4
20583: PUSH
20584: LD_INT 2
20586: PLUS
20587: ARRAY
20588: PUSH
20589: LD_INT 2
20591: EQUAL
20592: IFFALSE 20604
// b := b_oil_mine else
20594: LD_ADDR_VAR 0 5
20598: PUSH
20599: LD_INT 29
20601: ST_TO_ADDR
20602: GO 20612
// b := b_siberite_mine ;
20604: LD_ADDR_VAR 0 5
20608: PUSH
20609: LD_INT 30
20611: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20612: LD_ADDR_EXP 48
20616: PUSH
20617: LD_EXP 48
20621: PPUSH
20622: LD_VAR 0 1
20626: PPUSH
20627: LD_VAR 0 5
20631: PPUSH
20632: LD_EXP 63
20636: PUSH
20637: LD_VAR 0 1
20641: ARRAY
20642: PUSH
20643: LD_VAR 0 4
20647: ARRAY
20648: PUSH
20649: LD_EXP 63
20653: PUSH
20654: LD_VAR 0 1
20658: ARRAY
20659: PUSH
20660: LD_VAR 0 4
20664: PUSH
20665: LD_INT 1
20667: PLUS
20668: ARRAY
20669: PUSH
20670: LD_INT 0
20672: PPUSH
20673: LD_INT 5
20675: PPUSH
20676: CALL_OW 12
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: LIST
20685: PPUSH
20686: CALL 42056 0 4
20690: ST_TO_ADDR
// p := p + 3 ;
20691: LD_ADDR_VAR 0 4
20695: PUSH
20696: LD_VAR 0 4
20700: PUSH
20701: LD_INT 3
20703: PLUS
20704: ST_TO_ADDR
// end ;
20705: GO 20565
20707: POP
20708: POP
// end ;
20709: LD_VAR 0 2
20713: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20714: LD_INT 0
20716: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20717: LD_ADDR_EXP 48
20721: PUSH
20722: LD_EXP 48
20726: PPUSH
20727: LD_VAR 0 1
20731: PPUSH
20732: LD_INT 4
20734: PPUSH
20735: LD_VAR 0 2
20739: PPUSH
20740: CALL 42056 0 4
20744: ST_TO_ADDR
// end ;
20745: LD_VAR 0 3
20749: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20750: LD_INT 0
20752: PPUSH
// case nation of 1 , us :
20753: LD_VAR 0 2
20757: PUSH
20758: LD_INT 1
20760: DOUBLE
20761: EQUAL
20762: IFTRUE 20772
20764: LD_STRING us
20766: DOUBLE
20767: EQUAL
20768: IFTRUE 20772
20770: GO 20803
20772: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20773: LD_ADDR_EXP 48
20777: PUSH
20778: LD_EXP 48
20782: PPUSH
20783: LD_VAR 0 1
20787: PPUSH
20788: LD_INT 36
20790: PPUSH
20791: LD_VAR 0 3
20795: PPUSH
20796: CALL 42056 0 4
20800: ST_TO_ADDR
20801: GO 20854
20803: LD_INT 2
20805: DOUBLE
20806: EQUAL
20807: IFTRUE 20817
20809: LD_STRING ar
20811: DOUBLE
20812: EQUAL
20813: IFTRUE 20817
20815: GO 20853
20817: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
20818: LD_ADDR_EXP 48
20822: PUSH
20823: LD_VAR 0 1
20827: PPUSH
20828: LD_INT 14
20830: PUSH
20831: LD_INT 2
20833: PUSH
20834: LD_INT 1
20836: PUSH
20837: LD_INT 31
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: LIST
20844: LIST
20845: PPUSH
20846: CALL 20859 0 2
20850: ST_TO_ADDR
20851: GO 20854
20853: POP
// end ;
20854: LD_VAR 0 4
20858: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
20859: LD_INT 0
20861: PPUSH
20862: PPUSH
// for i = 1 to list do
20863: LD_ADDR_VAR 0 4
20867: PUSH
20868: DOUBLE
20869: LD_INT 1
20871: DEC
20872: ST_TO_ADDR
20873: LD_VAR 0 2
20877: PUSH
20878: FOR_TO
20879: IFFALSE 20929
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
20881: LD_ADDR_EXP 53
20885: PUSH
20886: LD_EXP 53
20890: PPUSH
20891: LD_VAR 0 1
20895: PPUSH
20896: LD_EXP 53
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_INT 1
20909: PLUS
20910: PPUSH
20911: LD_VAR 0 2
20915: PUSH
20916: LD_VAR 0 4
20920: ARRAY
20921: PPUSH
20922: CALL 30774 0 4
20926: ST_TO_ADDR
20927: GO 20878
20929: POP
20930: POP
// end ;
20931: LD_VAR 0 3
20935: RET
// export function MCS_GetVehicleList ( side ) ; begin
20936: LD_INT 0
20938: PPUSH
// result := MREG_ToConstruct [ side ] ;
20939: LD_ADDR_VAR 0 2
20943: PUSH
20944: LD_EXP 53
20948: PUSH
20949: LD_VAR 0 1
20953: ARRAY
20954: ST_TO_ADDR
// end ;
20955: LD_VAR 0 2
20959: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
20960: LD_INT 0
20962: PPUSH
20963: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
20964: LD_ADDR_EXP 60
20968: PUSH
20969: LD_EXP 60
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_VAR 0 2
20983: PPUSH
20984: CALL_OW 1
20988: ST_TO_ADDR
// end ;
20989: LD_VAR 0 3
20993: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
20994: LD_INT 0
20996: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
20997: LD_ADDR_EXP 39
21001: PUSH
21002: LD_EXP 39
21006: PPUSH
21007: LD_VAR 0 1
21011: PPUSH
21012: LD_VAR 0 2
21016: PPUSH
21017: CALL_OW 1
21021: ST_TO_ADDR
// end ;
21022: LD_VAR 0 3
21026: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21027: LD_INT 0
21029: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21030: LD_ADDR_EXP 40
21034: PUSH
21035: LD_EXP 40
21039: PPUSH
21040: LD_VAR 0 1
21044: PPUSH
21045: LD_VAR 0 2
21049: PPUSH
21050: CALL_OW 1
21054: ST_TO_ADDR
// end ;
21055: LD_VAR 0 3
21059: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21060: LD_INT 0
21062: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21063: LD_ADDR_EXP 62
21067: PUSH
21068: LD_EXP 62
21072: PPUSH
21073: LD_VAR 0 1
21077: PPUSH
21078: LD_INT 1
21080: PPUSH
21081: LD_VAR 0 2
21085: PPUSH
21086: CALL 30774 0 4
21090: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21091: LD_ADDR_EXP 62
21095: PUSH
21096: LD_EXP 62
21100: PPUSH
21101: LD_VAR 0 1
21105: PPUSH
21106: LD_INT 2
21108: PPUSH
21109: LD_VAR 0 3
21113: PPUSH
21114: CALL 30774 0 4
21118: ST_TO_ADDR
// end ;
21119: LD_VAR 0 4
21123: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21124: LD_INT 0
21126: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21127: LD_ADDR_EXP 74
21131: PUSH
21132: LD_EXP 74
21136: PPUSH
21137: LD_INT 1
21139: PPUSH
21140: LD_VAR 0 1
21144: PPUSH
21145: CALL_OW 1
21149: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21150: LD_ADDR_EXP 74
21154: PUSH
21155: LD_EXP 74
21159: PPUSH
21160: LD_INT 2
21162: PPUSH
21163: LD_VAR 0 2
21167: PPUSH
21168: CALL_OW 1
21172: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21173: LD_ADDR_EXP 74
21177: PUSH
21178: LD_EXP 74
21182: PPUSH
21183: LD_INT 3
21185: PPUSH
21186: LD_VAR 0 3
21190: PPUSH
21191: CALL_OW 1
21195: ST_TO_ADDR
// end ;
21196: LD_VAR 0 4
21200: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21201: LD_INT 0
21203: PPUSH
21204: PPUSH
21205: PPUSH
// if not side or not list then
21206: LD_VAR 0 1
21210: NOT
21211: PUSH
21212: LD_VAR 0 2
21216: NOT
21217: OR
21218: IFFALSE 21222
// exit ;
21220: GO 21390
// SetTech ( 20 , side , state_researched ) ;
21222: LD_INT 20
21224: PPUSH
21225: LD_VAR 0 1
21229: PPUSH
21230: LD_INT 2
21232: PPUSH
21233: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21237: LD_ADDR_EXP 63
21241: PUSH
21242: LD_EXP 63
21246: PPUSH
21247: LD_VAR 0 1
21251: PPUSH
21252: LD_VAR 0 2
21256: PPUSH
21257: CALL_OW 2
21261: ST_TO_ADDR
// p := 1 ;
21262: LD_ADDR_VAR 0 5
21266: PUSH
21267: LD_INT 1
21269: ST_TO_ADDR
// for i = 1 to list / 3 do
21270: LD_ADDR_VAR 0 4
21274: PUSH
21275: DOUBLE
21276: LD_INT 1
21278: DEC
21279: ST_TO_ADDR
21280: LD_VAR 0 2
21284: PUSH
21285: LD_INT 3
21287: DIVREAL
21288: PUSH
21289: FOR_TO
21290: IFFALSE 21388
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21292: LD_VAR 0 2
21296: PUSH
21297: LD_VAR 0 5
21301: ARRAY
21302: PPUSH
21303: LD_VAR 0 2
21307: PUSH
21308: LD_VAR 0 5
21312: PUSH
21313: LD_INT 1
21315: PLUS
21316: ARRAY
21317: PPUSH
21318: LD_VAR 0 2
21322: PUSH
21323: LD_VAR 0 5
21327: PUSH
21328: LD_INT 2
21330: PLUS
21331: ARRAY
21332: PPUSH
21333: CALL 22092 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21337: LD_VAR 0 2
21341: PUSH
21342: LD_VAR 0 5
21346: ARRAY
21347: PPUSH
21348: LD_VAR 0 2
21352: PUSH
21353: LD_VAR 0 5
21357: PUSH
21358: LD_INT 1
21360: PLUS
21361: ARRAY
21362: PPUSH
21363: LD_VAR 0 1
21367: PPUSH
21368: CALL_OW 441
// p := p + 3 ;
21372: LD_ADDR_VAR 0 5
21376: PUSH
21377: LD_VAR 0 5
21381: PUSH
21382: LD_INT 3
21384: PLUS
21385: ST_TO_ADDR
// end ;
21386: GO 21289
21388: POP
21389: POP
// end ;
21390: LD_VAR 0 3
21394: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21395: LD_INT 0
21397: PPUSH
21398: PPUSH
// if nat = nation_arabian then
21399: LD_VAR 0 2
21403: PUSH
21404: LD_INT 2
21406: EQUAL
21407: IFFALSE 21413
// exit else
21409: GO 21485
21411: GO 21471
// if nat = nation_american then
21413: LD_VAR 0 2
21417: PUSH
21418: LD_INT 1
21420: EQUAL
21421: IFFALSE 21448
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21423: LD_ADDR_VAR 0 4
21427: PUSH
21428: LD_INT 4
21430: PUSH
21431: LD_INT 3
21433: PUSH
21434: LD_INT 1
21436: PUSH
21437: LD_INT 8
21439: PUSH
21440: EMPTY
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: ST_TO_ADDR
21446: GO 21471
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21448: LD_ADDR_VAR 0 4
21452: PUSH
21453: LD_INT 24
21455: PUSH
21456: LD_INT 3
21458: PUSH
21459: LD_INT 1
21461: PUSH
21462: LD_INT 48
21464: PUSH
21465: EMPTY
21466: LIST
21467: LIST
21468: LIST
21469: LIST
21470: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21471: LD_VAR 0 1
21475: PPUSH
21476: LD_VAR 0 4
21480: PPUSH
21481: CALL 20859 0 2
// end ;
21485: LD_VAR 0 3
21489: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21490: LD_INT 0
21492: PPUSH
21493: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21494: LD_ADDR_EXP 65
21498: PUSH
21499: LD_EXP 65
21503: PPUSH
21504: LD_VAR 0 1
21508: PPUSH
21509: LD_INT 1
21511: PPUSH
21512: LD_VAR 0 4
21516: PPUSH
21517: CALL 30774 0 4
21521: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21522: LD_ADDR_EXP 66
21526: PUSH
21527: LD_EXP 66
21531: PPUSH
21532: LD_VAR 0 1
21536: PPUSH
21537: LD_INT 1
21539: PPUSH
21540: LD_VAR 0 2
21544: PPUSH
21545: CALL 30774 0 4
21549: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21550: LD_ADDR_EXP 67
21554: PUSH
21555: LD_EXP 67
21559: PPUSH
21560: LD_VAR 0 1
21564: PPUSH
21565: LD_INT 1
21567: PPUSH
21568: LD_VAR 0 3
21572: PPUSH
21573: CALL 30774 0 4
21577: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21578: LD_ADDR_EXP 68
21582: PUSH
21583: LD_EXP 68
21587: PPUSH
21588: LD_VAR 0 1
21592: PPUSH
21593: LD_INT 1
21595: PPUSH
21596: LD_VAR 0 5
21600: PPUSH
21601: CALL 30774 0 4
21605: ST_TO_ADDR
// while squad do
21606: LD_VAR 0 5
21610: IFFALSE 21703
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21612: LD_VAR 0 1
21616: PPUSH
21617: LD_VAR 0 5
21621: PUSH
21622: LD_INT 1
21624: ARRAY
21625: PUSH
21626: LD_VAR 0 5
21630: PUSH
21631: LD_INT 2
21633: ARRAY
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 3
21642: ARRAY
21643: PUSH
21644: LD_VAR 0 5
21648: PUSH
21649: LD_INT 4
21651: ARRAY
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: PPUSH
21659: CALL 20859 0 2
// for i = 1 to 4 do
21663: LD_ADDR_VAR 0 7
21667: PUSH
21668: DOUBLE
21669: LD_INT 1
21671: DEC
21672: ST_TO_ADDR
21673: LD_INT 4
21675: PUSH
21676: FOR_TO
21677: IFFALSE 21699
// squad := Delete ( squad , 1 ) ;
21679: LD_ADDR_VAR 0 5
21683: PUSH
21684: LD_VAR 0 5
21688: PPUSH
21689: LD_INT 1
21691: PPUSH
21692: CALL_OW 3
21696: ST_TO_ADDR
21697: GO 21676
21699: POP
21700: POP
// end ;
21701: GO 21606
// end ;
21703: LD_VAR 0 6
21707: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21708: LD_INT 0
21710: PPUSH
21711: PPUSH
// for i = 1 to squad do
21712: LD_ADDR_VAR 0 4
21716: PUSH
21717: DOUBLE
21718: LD_INT 1
21720: DEC
21721: ST_TO_ADDR
21722: LD_VAR 0 2
21726: PUSH
21727: FOR_TO
21728: IFFALSE 21778
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21730: LD_ADDR_EXP 71
21734: PUSH
21735: LD_EXP 71
21739: PPUSH
21740: LD_VAR 0 1
21744: PPUSH
21745: LD_EXP 71
21749: PUSH
21750: LD_VAR 0 1
21754: ARRAY
21755: PUSH
21756: LD_INT 1
21758: PLUS
21759: PPUSH
21760: LD_VAR 0 2
21764: PUSH
21765: LD_VAR 0 4
21769: ARRAY
21770: PPUSH
21771: CALL 30774 0 4
21775: ST_TO_ADDR
21776: GO 21727
21778: POP
21779: POP
// while squad do
21780: LD_VAR 0 2
21784: IFFALSE 21877
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21786: LD_VAR 0 1
21790: PPUSH
21791: LD_VAR 0 2
21795: PUSH
21796: LD_INT 1
21798: ARRAY
21799: PUSH
21800: LD_VAR 0 2
21804: PUSH
21805: LD_INT 2
21807: ARRAY
21808: PUSH
21809: LD_VAR 0 2
21813: PUSH
21814: LD_INT 3
21816: ARRAY
21817: PUSH
21818: LD_VAR 0 2
21822: PUSH
21823: LD_INT 4
21825: ARRAY
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: LIST
21831: LIST
21832: PPUSH
21833: CALL 20859 0 2
// for i = 1 to 4 do
21837: LD_ADDR_VAR 0 4
21841: PUSH
21842: DOUBLE
21843: LD_INT 1
21845: DEC
21846: ST_TO_ADDR
21847: LD_INT 4
21849: PUSH
21850: FOR_TO
21851: IFFALSE 21873
// squad := Delete ( squad , 1 ) ;
21853: LD_ADDR_VAR 0 2
21857: PUSH
21858: LD_VAR 0 2
21862: PPUSH
21863: LD_INT 1
21865: PPUSH
21866: CALL_OW 3
21870: ST_TO_ADDR
21871: GO 21850
21873: POP
21874: POP
// end ;
21875: GO 21780
// end ;
21877: LD_VAR 0 3
21881: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
21882: LD_INT 0
21884: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
21885: LD_ADDR_EXP 64
21889: PUSH
21890: LD_EXP 64
21894: PPUSH
21895: LD_VAR 0 1
21899: PPUSH
21900: LD_INT 1
21902: PPUSH
21903: LD_VAR 0 2
21907: PPUSH
21908: CALL 30774 0 4
21912: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
21913: LD_ADDR_EXP 64
21917: PUSH
21918: LD_EXP 64
21922: PPUSH
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_INT 2
21930: PPUSH
21931: LD_VAR 0 3
21935: PPUSH
21936: CALL 30774 0 4
21940: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
21941: LD_ADDR_EXP 64
21945: PUSH
21946: LD_EXP 64
21950: PPUSH
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 3
21958: PPUSH
21959: LD_VAR 0 4
21963: PPUSH
21964: CALL 30774 0 4
21968: ST_TO_ADDR
// end ; end_of_file
21969: LD_VAR 0 5
21973: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
21974: LD_INT 0
21976: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
21977: LD_ADDR_EXP 44
21981: PUSH
21982: LD_EXP 44
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_INT 1
21994: PPUSH
21995: LD_VAR 0 2
21999: PPUSH
22000: CALL 30774 0 4
22004: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22005: LD_VAR 0 1
22009: PPUSH
22010: EMPTY
22011: PPUSH
22012: CALL 11475 0 2
22016: PUSH
22017: LD_INT 1
22019: ARRAY
22020: PPUSH
22021: CALL_OW 248
22025: PUSH
22026: LD_INT 1
22028: EQUAL
22029: IFFALSE 22060
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_INT 4
22038: PUSH
22039: LD_INT 1
22041: PUSH
22042: LD_INT 1
22044: PUSH
22045: LD_INT 14
22047: PUSH
22048: EMPTY
22049: LIST
22050: LIST
22051: LIST
22052: LIST
22053: PPUSH
22054: CALL 20859 0 2
22058: GO 22087
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22060: LD_VAR 0 1
22064: PPUSH
22065: LD_INT 24
22067: PUSH
22068: LD_INT 1
22070: PUSH
22071: LD_INT 1
22073: PUSH
22074: LD_INT 53
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: LIST
22081: LIST
22082: PPUSH
22083: CALL 20859 0 2
// end ;
22087: LD_VAR 0 3
22091: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22092: LD_INT 0
22094: PPUSH
// CreateDepositXY ( x , y , t ) ;
22095: LD_VAR 0 1
22099: PPUSH
22100: LD_VAR 0 2
22104: PPUSH
22105: LD_VAR 0 3
22109: PPUSH
22110: CALL_OW 62
// end ;
22114: LD_VAR 0 4
22118: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22119: LD_INT 0
22121: PPUSH
22122: PPUSH
// c := 1 ;
22123: LD_ADDR_VAR 0 5
22127: PUSH
22128: LD_INT 1
22130: ST_TO_ADDR
// case color of red :
22131: LD_VAR 0 3
22135: PUSH
22136: LD_STRING red
22138: DOUBLE
22139: EQUAL
22140: IFTRUE 22144
22142: GO 22155
22144: POP
// c = 1 ; dark-green :
22145: LD_ADDR_VAR 0 5
22149: PUSH
22150: LD_INT 1
22152: ST_TO_ADDR
22153: GO 22441
22155: LD_STRING dark-green
22157: DOUBLE
22158: EQUAL
22159: IFTRUE 22163
22161: GO 22174
22163: POP
// c = 2 ; purple :
22164: LD_ADDR_VAR 0 5
22168: PUSH
22169: LD_INT 2
22171: ST_TO_ADDR
22172: GO 22441
22174: LD_STRING purple
22176: DOUBLE
22177: EQUAL
22178: IFTRUE 22182
22180: GO 22193
22182: POP
// c = 3 ; aqua :
22183: LD_ADDR_VAR 0 5
22187: PUSH
22188: LD_INT 3
22190: ST_TO_ADDR
22191: GO 22441
22193: LD_STRING aqua
22195: DOUBLE
22196: EQUAL
22197: IFTRUE 22201
22199: GO 22212
22201: POP
// c = 4 ; grey :
22202: LD_ADDR_VAR 0 5
22206: PUSH
22207: LD_INT 4
22209: ST_TO_ADDR
22210: GO 22441
22212: LD_STRING grey
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22220
22218: GO 22231
22220: POP
// c = 5 ; lime :
22221: LD_ADDR_VAR 0 5
22225: PUSH
22226: LD_INT 5
22228: ST_TO_ADDR
22229: GO 22441
22231: LD_STRING lime
22233: DOUBLE
22234: EQUAL
22235: IFTRUE 22239
22237: GO 22250
22239: POP
// c = 6 ; tan :
22240: LD_ADDR_VAR 0 5
22244: PUSH
22245: LD_INT 6
22247: ST_TO_ADDR
22248: GO 22441
22250: LD_STRING tan
22252: DOUBLE
22253: EQUAL
22254: IFTRUE 22258
22256: GO 22269
22258: POP
// c = 7 ; pink :
22259: LD_ADDR_VAR 0 5
22263: PUSH
22264: LD_INT 7
22266: ST_TO_ADDR
22267: GO 22441
22269: LD_STRING pink
22271: DOUBLE
22272: EQUAL
22273: IFTRUE 22277
22275: GO 22288
22277: POP
// c = 8 ; green :
22278: LD_ADDR_VAR 0 5
22282: PUSH
22283: LD_INT 8
22285: ST_TO_ADDR
22286: GO 22441
22288: LD_STRING green
22290: DOUBLE
22291: EQUAL
22292: IFTRUE 22296
22294: GO 22307
22296: POP
// c = 9 ; blue :
22297: LD_ADDR_VAR 0 5
22301: PUSH
22302: LD_INT 9
22304: ST_TO_ADDR
22305: GO 22441
22307: LD_STRING blue
22309: DOUBLE
22310: EQUAL
22311: IFTRUE 22315
22313: GO 22326
22315: POP
// c = 10 ; yellow :
22316: LD_ADDR_VAR 0 5
22320: PUSH
22321: LD_INT 10
22323: ST_TO_ADDR
22324: GO 22441
22326: LD_STRING yellow
22328: DOUBLE
22329: EQUAL
22330: IFTRUE 22334
22332: GO 22345
22334: POP
// c = 11 ; brown :
22335: LD_ADDR_VAR 0 5
22339: PUSH
22340: LD_INT 11
22342: ST_TO_ADDR
22343: GO 22441
22345: LD_STRING brown
22347: DOUBLE
22348: EQUAL
22349: IFTRUE 22353
22351: GO 22364
22353: POP
// c = 12 ; black :
22354: LD_ADDR_VAR 0 5
22358: PUSH
22359: LD_INT 12
22361: ST_TO_ADDR
22362: GO 22441
22364: LD_STRING black
22366: DOUBLE
22367: EQUAL
22368: IFTRUE 22372
22370: GO 22383
22372: POP
// c = 13 ; aqua2 :
22373: LD_ADDR_VAR 0 5
22377: PUSH
22378: LD_INT 13
22380: ST_TO_ADDR
22381: GO 22441
22383: LD_STRING aqua2
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 14 ; orange :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 14
22399: ST_TO_ADDR
22400: GO 22441
22402: LD_STRING orange
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 15 ; white :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 15
22418: ST_TO_ADDR
22419: GO 22441
22421: LD_STRING white
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 16 ; end ;
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 16
22437: ST_TO_ADDR
22438: GO 22441
22440: POP
// if HexInfo ( x , y ) = 0 then
22441: LD_VAR 0 1
22445: PPUSH
22446: LD_VAR 0 2
22450: PPUSH
22451: CALL_OW 428
22455: PUSH
22456: LD_INT 0
22458: EQUAL
22459: IFFALSE 22483
// PlaceEnvironment ( x , y , 58 , c ) ;
22461: LD_VAR 0 1
22465: PPUSH
22466: LD_VAR 0 2
22470: PPUSH
22471: LD_INT 58
22473: PPUSH
22474: LD_VAR 0 5
22478: PPUSH
22479: CALL_OW 349
// end ;
22483: LD_VAR 0 4
22487: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22488: LD_INT 0
22490: PPUSH
// RemoveEnvironment ( x , y ) ;
22491: LD_VAR 0 1
22495: PPUSH
22496: LD_VAR 0 2
22500: PPUSH
22501: CALL_OW 347
// end ;
22505: LD_VAR 0 3
22509: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22510: LD_INT 0
22512: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22513: LD_INT 81
22515: PUSH
22516: LD_VAR 0 1
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: PPUSH
22525: CALL_OW 69
22529: PUSH
22530: LD_INT 0
22532: EQUAL
22533: IFFALSE 22545
// result := false else
22535: LD_ADDR_VAR 0 5
22539: PUSH
22540: LD_INT 0
22542: ST_TO_ADDR
22543: GO 22609
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22545: LD_INT 81
22547: PUSH
22548: LD_VAR 0 1
22552: PUSH
22553: EMPTY
22554: LIST
22555: LIST
22556: PUSH
22557: LD_INT 92
22559: PUSH
22560: LD_VAR 0 2
22564: PUSH
22565: LD_VAR 0 3
22569: PUSH
22570: LD_VAR 0 4
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: LIST
22579: LIST
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: IFFALSE 22601
// result := true else
22591: LD_ADDR_VAR 0 5
22595: PUSH
22596: LD_INT 1
22598: ST_TO_ADDR
22599: GO 22609
// result := false ;
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 0
22608: ST_TO_ADDR
// end ;
22609: LD_VAR 0 5
22613: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22614: LD_INT 0
22616: PPUSH
22617: PPUSH
22618: PPUSH
22619: PPUSH
22620: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22621: LD_VAR 0 1
22625: PPUSH
22626: LD_INT 81
22628: PUSH
22629: LD_VAR 0 1
22633: PPUSH
22634: CALL_OW 255
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: PPUSH
22643: CALL_OW 69
22647: PPUSH
22648: LD_VAR 0 1
22652: PPUSH
22653: CALL_OW 74
22657: PPUSH
22658: CALL_OW 119
// dir := GetDir ( un ) ;
22662: LD_ADDR_VAR 0 4
22666: PUSH
22667: LD_VAR 0 1
22671: PPUSH
22672: CALL_OW 254
22676: ST_TO_ADDR
// dir := dir - 3 ;
22677: LD_ADDR_VAR 0 4
22681: PUSH
22682: LD_VAR 0 4
22686: PUSH
22687: LD_INT 3
22689: MINUS
22690: ST_TO_ADDR
// if dir < 0 then
22691: LD_VAR 0 4
22695: PUSH
22696: LD_INT 0
22698: LESS
22699: IFFALSE 22715
// dir := dir + 6 ;
22701: LD_ADDR_VAR 0 4
22705: PUSH
22706: LD_VAR 0 4
22710: PUSH
22711: LD_INT 6
22713: PLUS
22714: ST_TO_ADDR
// while true do
22715: LD_INT 1
22717: IFFALSE 23214
// begin coord_dist := 3 ;
22719: LD_ADDR_VAR 0 3
22723: PUSH
22724: LD_INT 3
22726: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22727: LD_ADDR_VAR 0 5
22731: PUSH
22732: LD_VAR 0 1
22736: PPUSH
22737: CALL_OW 250
22741: PPUSH
22742: LD_VAR 0 4
22746: PPUSH
22747: LD_VAR 0 3
22751: PPUSH
22752: CALL_OW 272
22756: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22757: LD_ADDR_VAR 0 6
22761: PUSH
22762: LD_VAR 0 1
22766: PPUSH
22767: CALL_OW 251
22771: PPUSH
22772: LD_VAR 0 4
22776: PPUSH
22777: LD_VAR 0 3
22781: PPUSH
22782: CALL_OW 273
22786: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22787: LD_VAR 0 1
22791: PPUSH
22792: CALL_OW 255
22796: PPUSH
22797: LD_VAR 0 1
22801: PPUSH
22802: CALL_OW 250
22806: PPUSH
22807: LD_VAR 0 1
22811: PPUSH
22812: CALL_OW 251
22816: PPUSH
22817: LD_INT 14
22819: PPUSH
22820: CALL 22510 0 4
22824: PUSH
22825: LD_VAR 0 5
22829: PPUSH
22830: LD_VAR 0 6
22834: PPUSH
22835: CALL_OW 351
22839: OR
22840: PUSH
22841: LD_VAR 0 5
22845: PPUSH
22846: LD_VAR 0 6
22850: PPUSH
22851: CALL_OW 488
22855: PUSH
22856: LD_INT 0
22858: EQUAL
22859: OR
22860: PUSH
22861: LD_VAR 0 5
22865: PPUSH
22866: LD_VAR 0 6
22870: PPUSH
22871: CALL_OW 546
22875: PUSH
22876: LD_INT 1
22878: EQUAL
22879: OR
22880: PUSH
22881: LD_VAR 0 5
22885: PPUSH
22886: LD_VAR 0 6
22890: PPUSH
22891: CALL_OW 428
22895: PUSH
22896: LD_INT 0
22898: NONEQUAL
22899: OR
22900: IFFALSE 23128
// begin repeat begin Wait ( 0 0$0.3 ) ;
22902: LD_INT 10
22904: PPUSH
22905: CALL_OW 67
// coord_dist := coord_dist + 1 ;
22909: LD_ADDR_VAR 0 3
22913: PUSH
22914: LD_VAR 0 3
22918: PUSH
22919: LD_INT 1
22921: PLUS
22922: ST_TO_ADDR
// dir := dir + 1 ;
22923: LD_ADDR_VAR 0 4
22927: PUSH
22928: LD_VAR 0 4
22932: PUSH
22933: LD_INT 1
22935: PLUS
22936: ST_TO_ADDR
// if dir > 5 then
22937: LD_VAR 0 4
22941: PUSH
22942: LD_INT 5
22944: GREATER
22945: IFFALSE 22955
// dir = 0 ;
22947: LD_ADDR_VAR 0 4
22951: PUSH
22952: LD_INT 0
22954: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22955: LD_ADDR_VAR 0 5
22959: PUSH
22960: LD_VAR 0 1
22964: PPUSH
22965: CALL_OW 250
22969: PPUSH
22970: LD_VAR 0 4
22974: PPUSH
22975: LD_VAR 0 3
22979: PPUSH
22980: CALL_OW 272
22984: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22985: LD_ADDR_VAR 0 6
22989: PUSH
22990: LD_VAR 0 1
22994: PPUSH
22995: CALL_OW 251
22999: PPUSH
23000: LD_VAR 0 4
23004: PPUSH
23005: LD_VAR 0 3
23009: PPUSH
23010: CALL_OW 273
23014: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23015: LD_VAR 0 1
23019: PPUSH
23020: CALL_OW 255
23024: PPUSH
23025: LD_VAR 0 1
23029: PPUSH
23030: CALL_OW 250
23034: PPUSH
23035: LD_VAR 0 1
23039: PPUSH
23040: CALL_OW 251
23044: PPUSH
23045: LD_INT 14
23047: PPUSH
23048: CALL 22510 0 4
23052: NOT
23053: PUSH
23054: LD_VAR 0 5
23058: PPUSH
23059: LD_VAR 0 6
23063: PPUSH
23064: CALL_OW 351
23068: NOT
23069: AND
23070: PUSH
23071: LD_VAR 0 5
23075: PPUSH
23076: LD_VAR 0 6
23080: PPUSH
23081: CALL_OW 488
23085: AND
23086: PUSH
23087: LD_VAR 0 5
23091: PPUSH
23092: LD_VAR 0 6
23096: PPUSH
23097: CALL_OW 546
23101: PUSH
23102: LD_INT 0
23104: EQUAL
23105: AND
23106: PUSH
23107: LD_VAR 0 5
23111: PPUSH
23112: LD_VAR 0 6
23116: PPUSH
23117: CALL_OW 428
23121: PUSH
23122: LD_INT 0
23124: EQUAL
23125: AND
23126: IFFALSE 22902
// end ; ComMoveXY ( un , x , y ) ;
23128: LD_VAR 0 1
23132: PPUSH
23133: LD_VAR 0 5
23137: PPUSH
23138: LD_VAR 0 6
23142: PPUSH
23143: CALL_OW 111
// Wait ( 0 0$1 ) ;
23147: LD_INT 35
23149: PPUSH
23150: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23154: LD_VAR 0 1
23158: PPUSH
23159: LD_INT 81
23161: PUSH
23162: LD_VAR 0 1
23166: PPUSH
23167: CALL_OW 255
23171: PUSH
23172: EMPTY
23173: LIST
23174: LIST
23175: PPUSH
23176: CALL_OW 69
23180: PPUSH
23181: LD_VAR 0 1
23185: PPUSH
23186: CALL_OW 74
23190: PPUSH
23191: CALL_OW 296
23195: PUSH
23196: LD_INT 14
23198: GREATEREQUAL
23199: IFFALSE 23212
// begin ComStop ( un ) ;
23201: LD_VAR 0 1
23205: PPUSH
23206: CALL_OW 141
// break ;
23210: GO 23214
// end ; end ;
23212: GO 22715
// end ;
23214: LD_VAR 0 2
23218: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23219: LD_INT 0
23221: PPUSH
23222: PPUSH
23223: PPUSH
23224: PPUSH
23225: PPUSH
23226: PPUSH
23227: PPUSH
23228: PPUSH
// x := GetX ( unit ) ;
23229: LD_ADDR_VAR 0 3
23233: PUSH
23234: LD_VAR 0 1
23238: PPUSH
23239: CALL_OW 250
23243: ST_TO_ADDR
// y := GetY ( unit ) ;
23244: LD_ADDR_VAR 0 4
23248: PUSH
23249: LD_VAR 0 1
23253: PPUSH
23254: CALL_OW 251
23258: ST_TO_ADDR
// i := 0 ;
23259: LD_ADDR_VAR 0 8
23263: PUSH
23264: LD_INT 0
23266: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23267: LD_VAR 0 1
23271: PPUSH
23272: LD_INT 81
23274: PUSH
23275: LD_VAR 0 1
23279: PPUSH
23280: CALL_OW 255
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PPUSH
23289: CALL_OW 69
23293: PPUSH
23294: LD_VAR 0 1
23298: PPUSH
23299: CALL_OW 74
23303: PPUSH
23304: CALL_OW 119
// dir := GetDir ( unit ) ;
23308: LD_ADDR_VAR 0 7
23312: PUSH
23313: LD_VAR 0 1
23317: PPUSH
23318: CALL_OW 254
23322: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23323: LD_ADDR_VAR 0 9
23327: PUSH
23328: LD_INT 0
23330: PPUSH
23331: LD_INT 1
23333: PPUSH
23334: CALL_OW 12
23338: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23339: LD_INT 10
23341: PPUSH
23342: CALL_OW 67
// if mode then
23346: LD_VAR 0 9
23350: IFFALSE 23368
// dir := dir + 1 else
23352: LD_ADDR_VAR 0 7
23356: PUSH
23357: LD_VAR 0 7
23361: PUSH
23362: LD_INT 1
23364: PLUS
23365: ST_TO_ADDR
23366: GO 23382
// dir := dir - 1 ;
23368: LD_ADDR_VAR 0 7
23372: PUSH
23373: LD_VAR 0 7
23377: PUSH
23378: LD_INT 1
23380: MINUS
23381: ST_TO_ADDR
// if ( dir < 0 ) then
23382: LD_VAR 0 7
23386: PUSH
23387: LD_INT 0
23389: LESS
23390: IFFALSE 23400
// dir := 5 ;
23392: LD_ADDR_VAR 0 7
23396: PUSH
23397: LD_INT 5
23399: ST_TO_ADDR
// if ( dir > 5 ) then
23400: LD_VAR 0 7
23404: PUSH
23405: LD_INT 5
23407: GREATER
23408: IFFALSE 23418
// dir := 0 ;
23410: LD_ADDR_VAR 0 7
23414: PUSH
23415: LD_INT 0
23417: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23418: LD_ADDR_VAR 0 5
23422: PUSH
23423: LD_VAR 0 3
23427: PPUSH
23428: LD_VAR 0 7
23432: PPUSH
23433: LD_INT 4
23435: PPUSH
23436: CALL_OW 272
23440: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23441: LD_ADDR_VAR 0 6
23445: PUSH
23446: LD_VAR 0 4
23450: PPUSH
23451: LD_VAR 0 7
23455: PPUSH
23456: LD_INT 4
23458: PPUSH
23459: CALL_OW 273
23463: ST_TO_ADDR
// i := i + 1 ;
23464: LD_ADDR_VAR 0 8
23468: PUSH
23469: LD_VAR 0 8
23473: PUSH
23474: LD_INT 1
23476: PLUS
23477: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23478: LD_VAR 0 1
23482: PPUSH
23483: CALL_OW 255
23487: PPUSH
23488: LD_VAR 0 5
23492: PPUSH
23493: LD_VAR 0 6
23497: PPUSH
23498: LD_INT 14
23500: PPUSH
23501: CALL 22510 0 4
23505: PUSH
23506: LD_INT 0
23508: EQUAL
23509: PUSH
23510: LD_VAR 0 5
23514: PPUSH
23515: LD_VAR 0 6
23519: PPUSH
23520: CALL_OW 546
23524: PUSH
23525: LD_INT 0
23527: EQUAL
23528: AND
23529: PUSH
23530: LD_VAR 0 5
23534: PPUSH
23535: LD_VAR 0 6
23539: PPUSH
23540: CALL_OW 428
23544: PUSH
23545: LD_INT 0
23547: EQUAL
23548: AND
23549: IFFALSE 23553
// break ;
23551: GO 23563
// end until i > 4 ;
23553: LD_VAR 0 8
23557: PUSH
23558: LD_INT 4
23560: GREATER
23561: IFFALSE 23339
// if x2 and y2 then
23563: LD_VAR 0 5
23567: PUSH
23568: LD_VAR 0 6
23572: AND
23573: IFFALSE 23596
// result := [ x2 , y2 ] else
23575: LD_ADDR_VAR 0 2
23579: PUSH
23580: LD_VAR 0 5
23584: PUSH
23585: LD_VAR 0 6
23589: PUSH
23590: EMPTY
23591: LIST
23592: LIST
23593: ST_TO_ADDR
23594: GO 23625
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23596: LD_ADDR_VAR 0 2
23600: PUSH
23601: LD_VAR 0 1
23605: PPUSH
23606: CALL_OW 250
23610: PUSH
23611: LD_VAR 0 1
23615: PPUSH
23616: CALL_OW 251
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: ST_TO_ADDR
// end ;
23625: LD_VAR 0 2
23629: RET
// export function MCT_Hex ( x , y ) ; begin
23630: LD_INT 0
23632: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23633: LD_ADDR_VAR 0 3
23637: PUSH
23638: LD_VAR 0 1
23642: PPUSH
23643: LD_VAR 0 2
23647: PPUSH
23648: CALL_OW 546
23652: PUSH
23653: LD_VAR 0 1
23657: PPUSH
23658: LD_VAR 0 2
23662: PPUSH
23663: CALL_OW 428
23667: PUSH
23668: EMPTY
23669: LIST
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: ST_TO_ADDR
// end ;
23675: LD_VAR 0 3
23679: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23680: LD_INT 0
23682: PPUSH
23683: PPUSH
23684: PPUSH
23685: PPUSH
23686: PPUSH
23687: PPUSH
23688: PPUSH
23689: PPUSH
23690: PPUSH
23691: PPUSH
23692: PPUSH
23693: PPUSH
23694: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23695: LD_ADDR_VAR 0 10
23699: PUSH
23700: LD_EXP 62
23704: PUSH
23705: LD_VAR 0 1
23709: ARRAY
23710: PUSH
23711: LD_INT 1
23713: ARRAY
23714: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23715: LD_ADDR_VAR 0 11
23719: PUSH
23720: LD_EXP 62
23724: PUSH
23725: LD_VAR 0 1
23729: ARRAY
23730: PUSH
23731: LD_INT 2
23733: ARRAY
23734: ST_TO_ADDR
// collectors := [ ] ;
23735: LD_ADDR_VAR 0 12
23739: PUSH
23740: EMPTY
23741: ST_TO_ADDR
// is_cargo := false ;
23742: LD_ADDR_VAR 0 13
23746: PUSH
23747: LD_INT 0
23749: ST_TO_ADDR
// if isTest then
23750: LD_EXP 1
23754: IFFALSE 23760
// TimerStart ( ) ;
23756: CALL_OW 548
// if MCF_Cargo ( side ) then
23760: LD_VAR 0 1
23764: PPUSH
23765: CALL 11691 0 1
23769: IFFALSE 23796
// begin collectors := MCF_Cargo ( side ) ;
23771: LD_ADDR_VAR 0 12
23775: PUSH
23776: LD_VAR 0 1
23780: PPUSH
23781: CALL 11691 0 1
23785: ST_TO_ADDR
// is_cargo := true ;
23786: LD_ADDR_VAR 0 13
23790: PUSH
23791: LD_INT 1
23793: ST_TO_ADDR
// end else
23794: GO 23945
// begin if MCF_ApeSpec ( side , engineer ) then
23796: LD_VAR 0 1
23800: PPUSH
23801: LD_STRING engineer
23803: PPUSH
23804: CALL 11837 0 2
23808: IFFALSE 23828
// collectors := MCF_ApeSpec ( side , engineer ) ;
23810: LD_ADDR_VAR 0 12
23814: PUSH
23815: LD_VAR 0 1
23819: PPUSH
23820: LD_STRING engineer
23822: PPUSH
23823: CALL 11837 0 2
23827: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
23828: LD_VAR 0 1
23832: PPUSH
23833: LD_INT 2
23835: PPUSH
23836: EMPTY
23837: PPUSH
23838: CALL 11423 0 3
23842: IFFALSE 23945
// begin z := MCF_Class ( side , 2 , [ ] ) ;
23844: LD_ADDR_VAR 0 7
23848: PUSH
23849: LD_VAR 0 1
23853: PPUSH
23854: LD_INT 2
23856: PPUSH
23857: EMPTY
23858: PPUSH
23859: CALL 11423 0 3
23863: ST_TO_ADDR
// if z > 5 then
23864: LD_VAR 0 7
23868: PUSH
23869: LD_INT 5
23871: GREATER
23872: IFFALSE 23884
// t1 := 5 else
23874: LD_ADDR_VAR 0 8
23878: PUSH
23879: LD_INT 5
23881: ST_TO_ADDR
23882: GO 23894
// t1 := z ;
23884: LD_ADDR_VAR 0 8
23888: PUSH
23889: LD_VAR 0 7
23893: ST_TO_ADDR
// for t2 = 1 to t1 do
23894: LD_ADDR_VAR 0 9
23898: PUSH
23899: DOUBLE
23900: LD_INT 1
23902: DEC
23903: ST_TO_ADDR
23904: LD_VAR 0 8
23908: PUSH
23909: FOR_TO
23910: IFFALSE 23943
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
23912: LD_ADDR_VAR 0 12
23916: PUSH
23917: LD_VAR 0 12
23921: PPUSH
23922: LD_INT 1
23924: PPUSH
23925: LD_VAR 0 7
23929: PUSH
23930: LD_VAR 0 9
23934: ARRAY
23935: PPUSH
23936: CALL_OW 2
23940: ST_TO_ADDR
23941: GO 23909
23943: POP
23944: POP
// end ; end ; if not mode then
23945: LD_VAR 0 10
23949: NOT
23950: IFFALSE 23956
// exit else
23952: GO 24215
23954: GO 24215
// begin if collectors then
23956: LD_VAR 0 12
23960: IFFALSE 24215
// for i in areas do
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: LD_VAR 0 11
23971: PUSH
23972: FOR_IN
23973: IFFALSE 24213
// if GetListOfCratesInArea ( i ) then
23975: LD_VAR 0 3
23979: PPUSH
23980: CALL_OW 435
23984: IFFALSE 24211
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
23986: LD_ADDR_VAR 0 5
23990: PUSH
23991: LD_VAR 0 3
23995: PPUSH
23996: CALL_OW 435
24000: PUSH
24001: LD_INT 1
24003: ARRAY
24004: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24005: LD_ADDR_VAR 0 6
24009: PUSH
24010: LD_VAR 0 3
24014: PPUSH
24015: CALL_OW 435
24019: PUSH
24020: LD_INT 2
24022: ARRAY
24023: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24024: LD_VAR 0 13
24028: PUSH
24029: LD_VAR 0 12
24033: PUSH
24034: LD_INT 1
24036: ARRAY
24037: PPUSH
24038: CALL_OW 110
24042: PUSH
24043: LD_INT 0
24045: EQUAL
24046: AND
24047: IFFALSE 24109
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24049: LD_VAR 0 12
24053: PUSH
24054: LD_INT 1
24056: ARRAY
24057: PPUSH
24058: CALL_OW 314
24062: NOT
24063: PUSH
24064: LD_VAR 0 12
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: CALL_OW 110
24077: PUSH
24078: LD_INT 0
24080: EQUAL
24081: AND
24082: IFFALSE 24107
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24084: LD_VAR 0 12
24088: PUSH
24089: LD_INT 1
24091: ARRAY
24092: PPUSH
24093: LD_VAR 0 5
24097: PPUSH
24098: LD_VAR 0 6
24102: PPUSH
24103: CALL_OW 117
// end ; end else
24107: GO 24195
// begin for j = 1 to collectors do
24109: LD_ADDR_VAR 0 4
24113: PUSH
24114: DOUBLE
24115: LD_INT 1
24117: DEC
24118: ST_TO_ADDR
24119: LD_VAR 0 12
24123: PUSH
24124: FOR_TO
24125: IFFALSE 24193
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24127: LD_VAR 0 12
24131: PUSH
24132: LD_VAR 0 4
24136: ARRAY
24137: PPUSH
24138: CALL_OW 314
24142: NOT
24143: PUSH
24144: LD_VAR 0 12
24148: PUSH
24149: LD_VAR 0 4
24153: ARRAY
24154: PPUSH
24155: CALL_OW 110
24159: PUSH
24160: LD_INT 0
24162: EQUAL
24163: AND
24164: IFFALSE 24191
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24166: LD_VAR 0 12
24170: PUSH
24171: LD_VAR 0 4
24175: ARRAY
24176: PPUSH
24177: LD_VAR 0 5
24181: PPUSH
24182: LD_VAR 0 6
24186: PPUSH
24187: CALL 24586 0 3
// end ;
24191: GO 24124
24193: POP
24194: POP
// end ; if isTest then
24195: LD_EXP 1
24199: IFFALSE 24211
// begin debug_time := TimerEnd ( ) ;
24201: LD_ADDR_VAR 0 14
24205: PUSH
24206: CALL_OW 549
24210: ST_TO_ADDR
// end ; end ;
24211: GO 23972
24213: POP
24214: POP
// end ; end ;
24215: LD_VAR 0 2
24219: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24220: LD_INT 0
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
24226: PPUSH
24227: PPUSH
// if not area then
24228: LD_VAR 0 1
24232: NOT
24233: IFFALSE 24239
// exit else
24235: GO 24501
24237: GO 24501
// if tick mod interval = 0 and Prob ( percent ) then
24239: LD_OWVAR 1
24243: PUSH
24244: LD_VAR 0 4
24248: MOD
24249: PUSH
24250: LD_INT 0
24252: EQUAL
24253: PUSH
24254: LD_VAR 0 3
24258: PPUSH
24259: CALL_OW 13
24263: AND
24264: IFFALSE 24501
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24266: LD_VAR 0 1
24270: PPUSH
24271: CALL_OW 435
24275: PUSH
24276: LD_VAR 0 5
24280: LESS
24281: PUSH
24282: LD_VAR 0 5
24286: PUSH
24287: LD_INT 0
24289: EQUAL
24290: OR
24291: IFFALSE 24501
// begin Randomize ;
24293: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24297: LD_ADDR_VAR 0 7
24301: PUSH
24302: LD_INT 1
24304: PPUSH
24305: LD_VAR 0 2
24309: PPUSH
24310: CALL_OW 12
24314: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24315: LD_ADDR_VAR 0 9
24319: PUSH
24320: LD_VAR 0 1
24324: PPUSH
24325: LD_INT 0
24327: PPUSH
24328: CALL_OW 517
24332: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24333: LD_ADDR_VAR 0 8
24337: PUSH
24338: LD_INT 1
24340: PPUSH
24341: LD_VAR 0 9
24345: PUSH
24346: LD_INT 1
24348: ARRAY
24349: PPUSH
24350: CALL_OW 12
24354: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24355: LD_VAR 0 9
24359: PUSH
24360: LD_INT 1
24362: ARRAY
24363: PUSH
24364: LD_VAR 0 8
24368: ARRAY
24369: PPUSH
24370: LD_VAR 0 9
24374: PUSH
24375: LD_INT 2
24377: ARRAY
24378: PUSH
24379: LD_VAR 0 8
24383: ARRAY
24384: PPUSH
24385: CALL_OW 428
24389: PUSH
24390: LD_INT 0
24392: GREATER
24393: PUSH
24394: LD_VAR 0 9
24398: PUSH
24399: LD_INT 1
24401: ARRAY
24402: PUSH
24403: LD_VAR 0 8
24407: ARRAY
24408: PPUSH
24409: LD_VAR 0 9
24413: PUSH
24414: LD_INT 2
24416: ARRAY
24417: PUSH
24418: LD_VAR 0 8
24422: ARRAY
24423: PPUSH
24424: CALL_OW 284
24428: PUSH
24429: LD_INT 0
24431: GREATER
24432: AND
24433: IFFALSE 24459
// c := Rand ( 1 , tmp [ 1 ] ) ;
24435: LD_ADDR_VAR 0 8
24439: PUSH
24440: LD_INT 1
24442: PPUSH
24443: LD_VAR 0 9
24447: PUSH
24448: LD_INT 1
24450: ARRAY
24451: PPUSH
24452: CALL_OW 12
24456: ST_TO_ADDR
24457: GO 24355
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24459: LD_VAR 0 7
24463: PPUSH
24464: LD_VAR 0 9
24468: PUSH
24469: LD_INT 1
24471: ARRAY
24472: PUSH
24473: LD_VAR 0 8
24477: ARRAY
24478: PPUSH
24479: LD_VAR 0 9
24483: PUSH
24484: LD_INT 2
24486: ARRAY
24487: PUSH
24488: LD_VAR 0 8
24492: ARRAY
24493: PPUSH
24494: LD_INT 1
24496: PPUSH
24497: CALL_OW 54
// end ; end ; end ;
24501: LD_VAR 0 6
24505: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24506: LD_INT 0
24508: PPUSH
24509: PPUSH
// if not MREG_Crates then
24510: LD_EXP 36
24514: NOT
24515: IFFALSE 24519
// exit ;
24517: GO 24581
// for i = MREG_Crates downto 1 do
24519: LD_ADDR_VAR 0 2
24523: PUSH
24524: DOUBLE
24525: LD_EXP 36
24529: INC
24530: ST_TO_ADDR
24531: LD_INT 1
24533: PUSH
24534: FOR_DOWNTO
24535: IFFALSE 24579
// if MREG_Crates [ i ] [ 3 ] = 0 then
24537: LD_EXP 36
24541: PUSH
24542: LD_VAR 0 2
24546: ARRAY
24547: PUSH
24548: LD_INT 3
24550: ARRAY
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: IFFALSE 24577
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24557: LD_ADDR_EXP 36
24561: PUSH
24562: LD_EXP 36
24566: PPUSH
24567: LD_VAR 0 2
24571: PPUSH
24572: CALL_OW 3
24576: ST_TO_ADDR
24577: GO 24534
24579: POP
24580: POP
// end ;
24581: LD_VAR 0 1
24585: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24586: LD_INT 0
24588: PPUSH
24589: PPUSH
24590: PPUSH
24591: PPUSH
// if not unit then
24592: LD_VAR 0 1
24596: NOT
24597: IFFALSE 24601
// exit ;
24599: GO 24736
// if HasTask ( unit ) or not CanCarry ( unit ) then
24601: LD_VAR 0 1
24605: PPUSH
24606: CALL_OW 314
24610: PUSH
24611: LD_VAR 0 1
24615: PPUSH
24616: CALL_OW 280
24620: NOT
24621: OR
24622: IFFALSE 24626
// exit ;
24624: GO 24736
// side := GetSide ( unit ) ;
24626: LD_ADDR_VAR 0 6
24630: PUSH
24631: LD_VAR 0 1
24635: PPUSH
24636: CALL_OW 255
24640: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24641: LD_ADDR_VAR 0 7
24645: PUSH
24646: LD_VAR 0 6
24650: PPUSH
24651: LD_INT 30
24653: PUSH
24654: LD_INT 1
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PPUSH
24661: CALL 11340 0 2
24665: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24666: LD_VAR 0 1
24670: PPUSH
24671: CALL_OW 281
24675: PUSH
24676: LD_VAR 0 7
24680: NOT
24681: OR
24682: IFFALSE 24688
// exit else
24684: GO 24736
24686: GO 24736
// if GetResourceAmountXY ( x , y ) then
24688: LD_VAR 0 2
24692: PPUSH
24693: LD_VAR 0 3
24697: PPUSH
24698: CALL_OW 284
24702: IFFALSE 24734
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24704: LD_VAR 0 1
24708: PPUSH
24709: LD_VAR 0 2
24713: PPUSH
24714: LD_VAR 0 3
24718: PPUSH
24719: LD_VAR 0 7
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: CALL 31938 0 4
// end else
24732: GO 24736
// exit ;
24734: GO 24736
// end ;
24736: LD_VAR 0 4
24740: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24741: LD_INT 0
24743: PPUSH
24744: PPUSH
24745: PPUSH
24746: PPUSH
24747: PPUSH
// result := 0 ;
24748: LD_ADDR_VAR 0 2
24752: PUSH
24753: LD_INT 0
24755: ST_TO_ADDR
// p := 1 ;
24756: LD_ADDR_VAR 0 4
24760: PUSH
24761: LD_INT 1
24763: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24764: LD_ADDR_VAR 0 3
24768: PUSH
24769: DOUBLE
24770: LD_INT 1
24772: DEC
24773: ST_TO_ADDR
24774: LD_EXP 65
24778: PUSH
24779: LD_VAR 0 1
24783: ARRAY
24784: PUSH
24785: LD_INT 1
24787: ARRAY
24788: PUSH
24789: LD_INT 2
24791: DIVREAL
24792: PUSH
24793: FOR_TO
24794: IFFALSE 24918
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24796: LD_ADDR_VAR 0 5
24800: PUSH
24801: LD_INT 81
24803: PUSH
24804: LD_VAR 0 1
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PUSH
24813: LD_INT 92
24815: PUSH
24816: LD_EXP 65
24820: PUSH
24821: LD_VAR 0 1
24825: ARRAY
24826: PUSH
24827: LD_INT 1
24829: ARRAY
24830: PUSH
24831: LD_VAR 0 4
24835: ARRAY
24836: PUSH
24837: LD_EXP 65
24841: PUSH
24842: LD_VAR 0 1
24846: ARRAY
24847: PUSH
24848: LD_INT 1
24850: ARRAY
24851: PUSH
24852: LD_VAR 0 4
24856: PUSH
24857: LD_INT 1
24859: PLUS
24860: ARRAY
24861: PUSH
24862: LD_INT 12
24864: PUSH
24865: EMPTY
24866: LIST
24867: LIST
24868: LIST
24869: LIST
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PPUSH
24875: CALL_OW 69
24879: ST_TO_ADDR
// if tmp then
24880: LD_VAR 0 5
24884: IFFALSE 24902
// result := result ^ tmp ;
24886: LD_ADDR_VAR 0 2
24890: PUSH
24891: LD_VAR 0 2
24895: PUSH
24896: LD_VAR 0 5
24900: ADD
24901: ST_TO_ADDR
// p := p + 2 ;
24902: LD_ADDR_VAR 0 4
24906: PUSH
24907: LD_VAR 0 4
24911: PUSH
24912: LD_INT 2
24914: PLUS
24915: ST_TO_ADDR
// end ;
24916: GO 24793
24918: POP
24919: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
24920: LD_EXP 66
24924: PUSH
24925: LD_VAR 0 1
24929: ARRAY
24930: PPUSH
24931: LD_INT 81
24933: PUSH
24934: LD_VAR 0 1
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PPUSH
24943: CALL_OW 70
24947: IFFALSE 24988
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
24949: LD_ADDR_VAR 0 2
24953: PUSH
24954: LD_VAR 0 2
24958: PUSH
24959: LD_EXP 66
24963: PUSH
24964: LD_VAR 0 1
24968: ARRAY
24969: PPUSH
24970: LD_INT 81
24972: PUSH
24973: LD_VAR 0 1
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PPUSH
24982: CALL_OW 70
24986: ADD
24987: ST_TO_ADDR
// end ; end_of_file
24988: LD_VAR 0 2
24992: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
24993: LD_INT 0
24995: PPUSH
24996: PPUSH
24997: PPUSH
// pom := GetBase ( fac ) ;
24998: LD_ADDR_VAR 0 5
25002: PUSH
25003: LD_VAR 0 1
25007: PPUSH
25008: CALL_OW 274
25012: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25013: LD_ADDR_VAR 0 4
25017: PUSH
25018: LD_VAR 0 2
25022: PUSH
25023: LD_INT 1
25025: ARRAY
25026: PPUSH
25027: LD_VAR 0 2
25031: PUSH
25032: LD_INT 2
25034: ARRAY
25035: PPUSH
25036: LD_VAR 0 2
25040: PUSH
25041: LD_INT 3
25043: ARRAY
25044: PPUSH
25045: LD_VAR 0 2
25049: PUSH
25050: LD_INT 4
25052: ARRAY
25053: PPUSH
25054: CALL_OW 449
25058: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25059: LD_VAR 0 5
25063: PPUSH
25064: LD_INT 1
25066: PPUSH
25067: CALL_OW 275
25071: PUSH
25072: LD_VAR 0 4
25076: PUSH
25077: LD_INT 1
25079: ARRAY
25080: GREATEREQUAL
25081: PUSH
25082: LD_VAR 0 5
25086: PPUSH
25087: LD_INT 2
25089: PPUSH
25090: CALL_OW 275
25094: PUSH
25095: LD_VAR 0 4
25099: PUSH
25100: LD_INT 2
25102: ARRAY
25103: GREATEREQUAL
25104: AND
25105: PUSH
25106: LD_VAR 0 5
25110: PPUSH
25111: LD_INT 3
25113: PPUSH
25114: CALL_OW 275
25118: PUSH
25119: LD_VAR 0 4
25123: PUSH
25124: LD_INT 3
25126: ARRAY
25127: GREATEREQUAL
25128: AND
25129: IFFALSE 25141
// result := true else
25131: LD_ADDR_VAR 0 3
25135: PUSH
25136: LD_INT 1
25138: ST_TO_ADDR
25139: GO 25149
// result := false ;
25141: LD_ADDR_VAR 0 3
25145: PUSH
25146: LD_INT 0
25148: ST_TO_ADDR
// end ;
25149: LD_VAR 0 3
25153: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25154: LD_INT 0
25156: PPUSH
25157: PPUSH
25158: PPUSH
// result := false ;
25159: LD_ADDR_VAR 0 3
25163: PUSH
25164: LD_INT 0
25166: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25167: LD_ADDR_VAR 0 4
25171: PUSH
25172: LD_EXP 53
25176: PUSH
25177: LD_VAR 0 1
25181: ARRAY
25182: ST_TO_ADDR
// if tmp then
25183: LD_VAR 0 4
25187: IFFALSE 25239
// for i = 1 to tmp do
25189: LD_ADDR_VAR 0 5
25193: PUSH
25194: DOUBLE
25195: LD_INT 1
25197: DEC
25198: ST_TO_ADDR
25199: LD_VAR 0 4
25203: PUSH
25204: FOR_TO
25205: IFFALSE 25237
// if component = tmp [ i ] then
25207: LD_VAR 0 2
25211: PUSH
25212: LD_VAR 0 4
25216: PUSH
25217: LD_VAR 0 5
25221: ARRAY
25222: EQUAL
25223: IFFALSE 25235
// begin result := true ;
25225: LD_ADDR_VAR 0 3
25229: PUSH
25230: LD_INT 1
25232: ST_TO_ADDR
// break ;
25233: GO 25237
// end ;
25235: GO 25204
25237: POP
25238: POP
// end ;
25239: LD_VAR 0 3
25243: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25244: LD_INT 0
25246: PPUSH
25247: PPUSH
25248: PPUSH
// if fac then
25249: LD_VAR 0 2
25253: IFFALSE 25488
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25255: LD_VAR 0 2
25259: PPUSH
25260: LD_VAR 0 3
25264: PPUSH
25265: CALL 24993 0 2
25269: PUSH
25270: LD_VAR 0 2
25274: PPUSH
25275: CALL_OW 461
25279: PUSH
25280: LD_INT 2
25282: EQUAL
25283: AND
25284: PUSH
25285: LD_VAR 0 2
25289: PPUSH
25290: LD_VAR 0 3
25294: PUSH
25295: LD_INT 1
25297: ARRAY
25298: PPUSH
25299: LD_VAR 0 3
25303: PUSH
25304: LD_INT 2
25306: ARRAY
25307: PPUSH
25308: LD_VAR 0 3
25312: PUSH
25313: LD_INT 3
25315: ARRAY
25316: PPUSH
25317: LD_VAR 0 3
25321: PUSH
25322: LD_INT 4
25324: ARRAY
25325: PPUSH
25326: CALL_OW 448
25330: AND
25331: IFFALSE 25478
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25333: LD_VAR 0 2
25337: PPUSH
25338: LD_VAR 0 3
25342: PUSH
25343: LD_INT 1
25345: ARRAY
25346: PPUSH
25347: LD_VAR 0 3
25351: PUSH
25352: LD_INT 2
25354: ARRAY
25355: PPUSH
25356: LD_VAR 0 3
25360: PUSH
25361: LD_INT 3
25363: ARRAY
25364: PPUSH
25365: LD_VAR 0 3
25369: PUSH
25370: LD_INT 4
25372: ARRAY
25373: PPUSH
25374: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25378: LD_ADDR_VAR 0 6
25382: PUSH
25383: LD_EXP 53
25387: PUSH
25388: LD_VAR 0 1
25392: ARRAY
25393: ST_TO_ADDR
// for i = 4 downto 1 do
25394: LD_ADDR_VAR 0 5
25398: PUSH
25399: DOUBLE
25400: LD_INT 4
25402: INC
25403: ST_TO_ADDR
25404: LD_INT 1
25406: PUSH
25407: FOR_DOWNTO
25408: IFFALSE 25441
// tab := Remove ( tab , list [ i ] , true ) ;
25410: LD_ADDR_VAR 0 6
25414: PUSH
25415: LD_VAR 0 6
25419: PPUSH
25420: LD_VAR 0 3
25424: PUSH
25425: LD_VAR 0 5
25429: ARRAY
25430: PPUSH
25431: LD_INT 1
25433: PPUSH
25434: CALL 30933 0 3
25438: ST_TO_ADDR
25439: GO 25407
25441: POP
25442: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25443: LD_ADDR_EXP 53
25447: PUSH
25448: LD_EXP 53
25452: PPUSH
25453: LD_VAR 0 1
25457: PPUSH
25458: LD_VAR 0 6
25462: PPUSH
25463: CALL_OW 1
25467: ST_TO_ADDR
// result := true ;
25468: LD_ADDR_VAR 0 4
25472: PUSH
25473: LD_INT 1
25475: ST_TO_ADDR
// end else
25476: GO 25486
// result := false ;
25478: LD_ADDR_VAR 0 4
25482: PUSH
25483: LD_INT 0
25485: ST_TO_ADDR
// end else
25486: GO 25496
// result := false ;
25488: LD_ADDR_VAR 0 4
25492: PUSH
25493: LD_INT 0
25495: ST_TO_ADDR
// end ;
25496: LD_VAR 0 4
25500: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25501: LD_INT 0
25503: PPUSH
25504: PPUSH
// if not veh then
25505: LD_VAR 0 2
25509: NOT
25510: IFFALSE 25514
// exit ;
25512: GO 25688
// if MREG_Parking [ side ] then
25514: LD_EXP 60
25518: PUSH
25519: LD_VAR 0 1
25523: ARRAY
25524: IFFALSE 25688
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25526: LD_VAR 0 2
25530: PPUSH
25531: LD_EXP 60
25535: PUSH
25536: LD_VAR 0 1
25540: ARRAY
25541: PPUSH
25542: CALL_OW 308
25546: NOT
25547: IFFALSE 25688
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25549: LD_VAR 0 2
25553: PPUSH
25554: LD_EXP 60
25558: PUSH
25559: LD_VAR 0 1
25563: ARRAY
25564: PPUSH
25565: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25569: LD_VAR 0 2
25573: PPUSH
25574: CALL_OW 263
25578: PUSH
25579: LD_INT 1
25581: EQUAL
25582: IFFALSE 25688
// begin i := GetDriver ( veh ) ;
25584: LD_ADDR_VAR 0 4
25588: PUSH
25589: LD_VAR 0 2
25593: PPUSH
25594: CALL 31468 0 1
25598: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25599: LD_INT 35
25601: PPUSH
25602: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25606: LD_VAR 0 2
25610: PPUSH
25611: LD_EXP 60
25615: PUSH
25616: LD_VAR 0 1
25620: ARRAY
25621: PPUSH
25622: CALL_OW 308
25626: PUSH
25627: LD_VAR 0 2
25631: PPUSH
25632: CALL_OW 301
25636: OR
25637: IFFALSE 25599
// ComExitVehicle ( i ) ;
25639: LD_VAR 0 4
25643: PPUSH
25644: CALL_OW 121
// Wait ( 1 ) ;
25648: LD_INT 1
25650: PPUSH
25651: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25655: LD_VAR 0 4
25659: PPUSH
25660: LD_VAR 0 1
25664: PPUSH
25665: LD_INT 30
25667: PUSH
25668: LD_INT 3
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: PPUSH
25675: CALL 11340 0 2
25679: PUSH
25680: LD_INT 1
25682: ARRAY
25683: PPUSH
25684: CALL_OW 180
// end ; end ; end ;
25688: LD_VAR 0 3
25692: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25693: LD_INT 0
25695: PPUSH
25696: PPUSH
25697: PPUSH
25698: PPUSH
25699: PPUSH
25700: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25701: LD_VAR 0 1
25705: PPUSH
25706: LD_INT 30
25708: PUSH
25709: LD_INT 3
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PPUSH
25716: CALL 11340 0 2
25720: IFFALSE 25904
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25722: LD_VAR 0 1
25726: PPUSH
25727: LD_INT 30
25729: PUSH
25730: LD_INT 3
25732: PUSH
25733: EMPTY
25734: LIST
25735: LIST
25736: PPUSH
25737: CALL 11340 0 2
25741: PUSH
25742: LD_INT 1
25744: ARRAY
25745: PPUSH
25746: CALL_OW 461
25750: PUSH
25751: LD_INT 2
25753: EQUAL
25754: IFFALSE 25904
// begin for i = 1 to MREG_TurretWeapon do
25756: LD_ADDR_VAR 0 3
25760: PUSH
25761: DOUBLE
25762: LD_INT 1
25764: DEC
25765: ST_TO_ADDR
25766: LD_EXP 45
25770: PUSH
25771: FOR_TO
25772: IFFALSE 25902
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25774: LD_EXP 45
25778: PUSH
25779: LD_VAR 0 3
25783: ARRAY
25784: PUSH
25785: LD_INT 1
25787: ARRAY
25788: PUSH
25789: LD_VAR 0 1
25793: EQUAL
25794: IFFALSE 25900
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25796: LD_ADDR_VAR 0 5
25800: PUSH
25801: LD_EXP 45
25805: PUSH
25806: LD_VAR 0 3
25810: ARRAY
25811: PUSH
25812: LD_INT 2
25814: ARRAY
25815: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25816: LD_ADDR_VAR 0 6
25820: PUSH
25821: LD_EXP 45
25825: PUSH
25826: LD_VAR 0 3
25830: ARRAY
25831: PUSH
25832: LD_INT 3
25834: ARRAY
25835: PUSH
25836: LD_INT 1
25838: ARRAY
25839: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
25840: LD_ADDR_VAR 0 7
25844: PUSH
25845: LD_EXP 45
25849: PUSH
25850: LD_VAR 0 3
25854: ARRAY
25855: PUSH
25856: LD_INT 3
25858: ARRAY
25859: PUSH
25860: LD_INT 2
25862: ARRAY
25863: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
25864: LD_ADDR_VAR 0 4
25868: PUSH
25869: LD_VAR 0 6
25873: PPUSH
25874: LD_VAR 0 7
25878: PPUSH
25879: CALL_OW 428
25883: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
25884: LD_VAR 0 4
25888: PPUSH
25889: LD_VAR 0 5
25893: PPUSH
25894: CALL_OW 148
// break ;
25898: GO 25902
// end ;
25900: GO 25771
25902: POP
25903: POP
// end ; end ;
25904: LD_VAR 0 2
25908: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
25909: LD_INT 0
25911: PPUSH
25912: PPUSH
25913: PPUSH
25914: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
25915: LD_ADDR_VAR 0 4
25919: PUSH
25920: LD_VAR 0 1
25924: PPUSH
25925: LD_INT 32
25927: PUSH
25928: LD_INT 1
25930: PUSH
25931: EMPTY
25932: LIST
25933: LIST
25934: PPUSH
25935: CALL 11340 0 2
25939: ST_TO_ADDR
// if not tmp then
25940: LD_VAR 0 4
25944: NOT
25945: IFFALSE 25951
// exit else
25947: GO 26033
25949: GO 26033
// begin for i = 1 to tmp do
25951: LD_ADDR_VAR 0 3
25955: PUSH
25956: DOUBLE
25957: LD_INT 1
25959: DEC
25960: ST_TO_ADDR
25961: LD_VAR 0 4
25965: PUSH
25966: FOR_TO
25967: IFFALSE 26031
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
25969: LD_VAR 0 4
25973: PUSH
25974: LD_VAR 0 3
25978: ARRAY
25979: PPUSH
25980: CALL_OW 261
25984: PUSH
25985: LD_INT 20
25987: LESS
25988: PUSH
25989: LD_VAR 0 4
25993: PUSH
25994: LD_VAR 0 3
25998: ARRAY
25999: PPUSH
26000: CALL_OW 110
26004: PUSH
26005: LD_INT 0
26007: EQUAL
26008: AND
26009: IFFALSE 26029
// begin SetTag ( tmp [ i ] , 21 ) ;
26011: LD_VAR 0 4
26015: PUSH
26016: LD_VAR 0 3
26020: ARRAY
26021: PPUSH
26022: LD_INT 21
26024: PPUSH
26025: CALL_OW 109
// end ;
26029: GO 25966
26031: POP
26032: POP
// end ; end ;
26033: LD_VAR 0 2
26037: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26038: LD_INT 0
26040: PPUSH
26041: PPUSH
26042: PPUSH
26043: PPUSH
26044: PPUSH
// if not unit then
26045: LD_VAR 0 1
26049: NOT
26050: IFFALSE 26054
// exit ;
26052: GO 26242
// side := GetSide ( unit ) ;
26054: LD_ADDR_VAR 0 3
26058: PUSH
26059: LD_VAR 0 1
26063: PPUSH
26064: CALL_OW 255
26068: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26069: LD_ADDR_VAR 0 5
26073: PUSH
26074: LD_VAR 0 3
26078: PPUSH
26079: LD_INT 2
26081: PUSH
26082: LD_INT 30
26084: PUSH
26085: LD_INT 1
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 30
26094: PUSH
26095: LD_INT 3
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 30
26104: PUSH
26105: LD_INT 29
26107: PUSH
26108: EMPTY
26109: LIST
26110: LIST
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: LIST
26116: LIST
26117: PPUSH
26118: CALL 11340 0 2
26122: ST_TO_ADDR
// if not b then
26123: LD_VAR 0 5
26127: NOT
26128: IFFALSE 26132
// exit ;
26130: GO 26242
// if GetTag ( unit ) = 21 then
26132: LD_VAR 0 1
26136: PPUSH
26137: CALL_OW 110
26141: PUSH
26142: LD_INT 21
26144: EQUAL
26145: IFFALSE 26242
// begin c := NearestUnitToUnit ( b , unit ) ;
26147: LD_ADDR_VAR 0 6
26151: PUSH
26152: LD_VAR 0 5
26156: PPUSH
26157: LD_VAR 0 1
26161: PPUSH
26162: CALL_OW 74
26166: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26167: LD_VAR 0 1
26171: PPUSH
26172: LD_VAR 0 6
26176: PPUSH
26177: CALL_OW 250
26181: PPUSH
26182: LD_VAR 0 6
26186: PPUSH
26187: CALL_OW 251
26191: PPUSH
26192: CALL_OW 297
26196: PUSH
26197: LD_INT 6
26199: GREATER
26200: IFFALSE 26218
// ComMoveUnit ( unit , c ) else
26202: LD_VAR 0 1
26206: PPUSH
26207: LD_VAR 0 6
26211: PPUSH
26212: CALL_OW 112
26216: GO 26242
// begin SetFuel ( unit , 100 ) ;
26218: LD_VAR 0 1
26222: PPUSH
26223: LD_INT 100
26225: PPUSH
26226: CALL_OW 240
// SetTag ( unit , 0 ) ;
26230: LD_VAR 0 1
26234: PPUSH
26235: LD_INT 0
26237: PPUSH
26238: CALL_OW 109
// end ; end ; end ;
26242: LD_VAR 0 2
26246: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26247: LD_INT 0
26249: PPUSH
26250: PPUSH
26251: PPUSH
26252: PPUSH
26253: PPUSH
26254: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26255: LD_ADDR_VAR 0 7
26259: PUSH
26260: LD_VAR 0 1
26264: PPUSH
26265: LD_INT 33
26267: PUSH
26268: LD_INT 2
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 3
26277: PUSH
26278: LD_INT 61
26280: PUSH
26281: EMPTY
26282: LIST
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PPUSH
26292: CALL 11340 0 2
26296: ST_TO_ADDR
// if not vehs then
26297: LD_VAR 0 7
26301: NOT
26302: IFFALSE 26306
// exit ;
26304: GO 26591
// if nation = 1 then
26306: LD_VAR 0 2
26310: PUSH
26311: LD_INT 1
26313: EQUAL
26314: IFFALSE 26484
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26316: LD_VAR 0 1
26320: PPUSH
26321: LD_INT 30
26323: PUSH
26324: LD_INT 36
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PPUSH
26331: CALL 11340 0 2
26335: NOT
26336: IFFALSE 26342
// exit else
26338: GO 26591
26340: GO 26482
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26342: LD_ADDR_VAR 0 5
26346: PUSH
26347: LD_VAR 0 1
26351: PPUSH
26352: LD_INT 30
26354: PUSH
26355: LD_INT 36
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PPUSH
26362: CALL 11340 0 2
26366: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26367: LD_ADDR_VAR 0 6
26371: PUSH
26372: LD_VAR 0 5
26376: PUSH
26377: LD_INT 1
26379: ARRAY
26380: PPUSH
26381: CALL_OW 313
26385: ST_TO_ADDR
// for i = vehs downto 1 do
26386: LD_ADDR_VAR 0 4
26390: PUSH
26391: DOUBLE
26392: LD_VAR 0 7
26396: INC
26397: ST_TO_ADDR
26398: LD_INT 1
26400: PUSH
26401: FOR_DOWNTO
26402: IFFALSE 26480
// begin if not IsControledBy ( vehs [ i ] ) then
26404: LD_VAR 0 7
26408: PUSH
26409: LD_VAR 0 4
26413: ARRAY
26414: PPUSH
26415: CALL_OW 312
26419: NOT
26420: IFFALSE 26478
// begin tmp := MCV_RemoteDriver ( oper ) ;
26422: LD_ADDR_VAR 0 8
26426: PUSH
26427: LD_VAR 0 6
26431: PPUSH
26432: CALL 26596 0 1
26436: ST_TO_ADDR
// if not tmp then
26437: LD_VAR 0 8
26441: NOT
26442: IFFALSE 26450
// exit else
26444: POP
26445: POP
26446: GO 26591
26448: GO 26478
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26450: LD_VAR 0 7
26454: PUSH
26455: LD_VAR 0 4
26459: ARRAY
26460: PPUSH
26461: LD_VAR 0 8
26465: PUSH
26466: LD_INT 1
26468: ARRAY
26469: PUSH
26470: LD_INT 1
26472: ARRAY
26473: PPUSH
26474: CALL_OW 135
// end ; end ;
26478: GO 26401
26480: POP
26481: POP
// end ; end else
26482: GO 26591
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26484: LD_VAR 0 1
26488: PPUSH
26489: LD_INT 34
26491: PUSH
26492: LD_INT 31
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PPUSH
26499: CALL 11340 0 2
26503: NOT
26504: IFFALSE 26510
// exit else
26506: GO 26591
26508: GO 26591
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26510: LD_ADDR_VAR 0 5
26514: PUSH
26515: LD_VAR 0 1
26519: PPUSH
26520: LD_INT 34
26522: PUSH
26523: LD_INT 31
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: PPUSH
26530: CALL 11340 0 2
26534: ST_TO_ADDR
// oper := [ ] ;
26535: LD_ADDR_VAR 0 6
26539: PUSH
26540: EMPTY
26541: ST_TO_ADDR
// for i = 1 to ct do
26542: LD_ADDR_VAR 0 4
26546: PUSH
26547: DOUBLE
26548: LD_INT 1
26550: DEC
26551: ST_TO_ADDR
26552: LD_VAR 0 5
26556: PUSH
26557: FOR_TO
26558: IFFALSE 26589
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26560: LD_ADDR_VAR 0 6
26564: PUSH
26565: LD_VAR 0 6
26569: PUSH
26570: LD_VAR 0 5
26574: PUSH
26575: LD_VAR 0 4
26579: ARRAY
26580: PPUSH
26581: CALL 31468 0 1
26585: ADD
26586: ST_TO_ADDR
26587: GO 26557
26589: POP
26590: POP
// end ; end ; end ;
26591: LD_VAR 0 3
26595: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26596: LD_INT 0
26598: PPUSH
26599: PPUSH
26600: PPUSH
26601: PPUSH
26602: PPUSH
26603: PPUSH
// if not drivers then
26604: LD_VAR 0 1
26608: NOT
26609: IFFALSE 26615
// exit else
26611: GO 26895
26613: GO 26895
// begin linked := [ ] ;
26615: LD_ADDR_VAR 0 5
26619: PUSH
26620: EMPTY
26621: ST_TO_ADDR
// for i = 1 to drivers do
26622: LD_ADDR_VAR 0 3
26626: PUSH
26627: DOUBLE
26628: LD_INT 1
26630: DEC
26631: ST_TO_ADDR
26632: LD_VAR 0 1
26636: PUSH
26637: FOR_TO
26638: IFFALSE 26883
// begin if CanControl ( drivers [ i ] ) then
26640: LD_VAR 0 1
26644: PUSH
26645: LD_VAR 0 3
26649: ARRAY
26650: PPUSH
26651: CALL 32040 0 1
26655: IFFALSE 26881
// if i > 1 then
26657: LD_VAR 0 3
26661: PUSH
26662: LD_INT 1
26664: GREATER
26665: IFFALSE 26842
// begin m := false ;
26667: LD_ADDR_VAR 0 6
26671: PUSH
26672: LD_INT 0
26674: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26675: LD_ADDR_VAR 0 7
26679: PUSH
26680: LD_VAR 0 1
26684: PUSH
26685: LD_VAR 0 3
26689: ARRAY
26690: PPUSH
26691: CALL_OW 432
26695: ST_TO_ADDR
// for j = 1 to linked do
26696: LD_ADDR_VAR 0 4
26700: PUSH
26701: DOUBLE
26702: LD_INT 1
26704: DEC
26705: ST_TO_ADDR
26706: LD_VAR 0 5
26710: PUSH
26711: FOR_TO
26712: IFFALSE 26786
// begin if l < linked [ j ] [ 2 ] then
26714: LD_VAR 0 7
26718: PUSH
26719: LD_VAR 0 5
26723: PUSH
26724: LD_VAR 0 4
26728: ARRAY
26729: PUSH
26730: LD_INT 2
26732: ARRAY
26733: LESS
26734: IFFALSE 26784
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_VAR 0 5
26745: PPUSH
26746: LD_INT 1
26748: PPUSH
26749: LD_VAR 0 1
26753: PUSH
26754: LD_VAR 0 3
26758: ARRAY
26759: PUSH
26760: LD_VAR 0 7
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PPUSH
26769: CALL_OW 2
26773: ST_TO_ADDR
// m := true ;
26774: LD_ADDR_VAR 0 6
26778: PUSH
26779: LD_INT 1
26781: ST_TO_ADDR
// break ;
26782: GO 26786
// end ; end ;
26784: GO 26711
26786: POP
26787: POP
// if not m then
26788: LD_VAR 0 6
26792: NOT
26793: IFFALSE 26840
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26795: LD_ADDR_VAR 0 5
26799: PUSH
26800: LD_VAR 0 5
26804: PUSH
26805: LD_VAR 0 1
26809: PUSH
26810: LD_VAR 0 3
26814: ARRAY
26815: PUSH
26816: LD_VAR 0 1
26820: PUSH
26821: LD_VAR 0 3
26825: ARRAY
26826: PPUSH
26827: CALL_OW 432
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: EMPTY
26837: LIST
26838: ADD
26839: ST_TO_ADDR
// end else
26840: GO 26881
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26842: LD_ADDR_VAR 0 5
26846: PUSH
26847: LD_VAR 0 1
26851: PUSH
26852: LD_VAR 0 3
26856: ARRAY
26857: PUSH
26858: LD_VAR 0 1
26862: PUSH
26863: LD_VAR 0 3
26867: ARRAY
26868: PPUSH
26869: CALL_OW 432
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: PUSH
26878: EMPTY
26879: LIST
26880: ST_TO_ADDR
// end ;
26881: GO 26637
26883: POP
26884: POP
// result := linked ;
26885: LD_ADDR_VAR 0 2
26889: PUSH
26890: LD_VAR 0 5
26894: ST_TO_ADDR
// end ; end ;
26895: LD_VAR 0 2
26899: RET
// export function MCV_ToRepair ( unit ) ; begin
26900: LD_INT 0
26902: PPUSH
// if not unit then
26903: LD_VAR 0 1
26907: NOT
26908: IFFALSE 26914
// exit else
26910: GO 26945
26912: GO 26945
// begin SetTag ( unit , 6 ) ;
26914: LD_VAR 0 1
26918: PPUSH
26919: LD_INT 6
26921: PPUSH
26922: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
26926: LD_VAR 0 1
26930: PPUSH
26931: CALL_OW 255
26935: PPUSH
26936: LD_VAR 0 1
26940: PPUSH
26941: CALL 25501 0 2
// end ; end ;
26945: LD_VAR 0 2
26949: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
26950: LD_INT 0
26952: PPUSH
26953: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
26954: LD_VAR 0 1
26958: PPUSH
26959: LD_INT 6
26961: PPUSH
26962: EMPTY
26963: PPUSH
26964: CALL 12043 0 3
26968: IFFALSE 27061
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
26970: LD_ADDR_VAR 0 3
26974: PUSH
26975: DOUBLE
26976: LD_VAR 0 1
26980: PPUSH
26981: LD_INT 6
26983: PPUSH
26984: EMPTY
26985: PPUSH
26986: CALL 12043 0 3
26990: INC
26991: ST_TO_ADDR
26992: LD_INT 1
26994: PUSH
26995: FOR_DOWNTO
26996: IFFALSE 27059
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
26998: LD_VAR 0 1
27002: PPUSH
27003: LD_INT 6
27005: PPUSH
27006: EMPTY
27007: PPUSH
27008: CALL 12043 0 3
27012: PUSH
27013: LD_VAR 0 3
27017: ARRAY
27018: PPUSH
27019: CALL_OW 256
27023: PUSH
27024: LD_INT 1000
27026: EQUAL
27027: IFFALSE 27057
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27029: LD_VAR 0 1
27033: PPUSH
27034: LD_INT 6
27036: PPUSH
27037: EMPTY
27038: PPUSH
27039: CALL 12043 0 3
27043: PUSH
27044: LD_VAR 0 3
27048: ARRAY
27049: PPUSH
27050: LD_INT 0
27052: PPUSH
27053: CALL_OW 109
27057: GO 26995
27059: POP
27060: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27061: LD_VAR 0 1
27065: PPUSH
27066: LD_INT 10
27068: PPUSH
27069: EMPTY
27070: PPUSH
27071: CALL 12043 0 3
27075: IFFALSE 27192
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27077: LD_ADDR_VAR 0 3
27081: PUSH
27082: DOUBLE
27083: LD_VAR 0 1
27087: PPUSH
27088: LD_INT 10
27090: PPUSH
27091: EMPTY
27092: PPUSH
27093: CALL 12043 0 3
27097: INC
27098: ST_TO_ADDR
27099: LD_INT 1
27101: PUSH
27102: FOR_DOWNTO
27103: IFFALSE 27190
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27105: LD_VAR 0 1
27109: PPUSH
27110: LD_INT 10
27112: PPUSH
27113: EMPTY
27114: PPUSH
27115: CALL 12043 0 3
27119: PUSH
27120: LD_VAR 0 3
27124: ARRAY
27125: PPUSH
27126: CALL_OW 302
27130: NOT
27131: PUSH
27132: LD_VAR 0 1
27136: PPUSH
27137: LD_INT 10
27139: PPUSH
27140: EMPTY
27141: PPUSH
27142: CALL 12043 0 3
27146: PUSH
27147: LD_VAR 0 3
27151: ARRAY
27152: PPUSH
27153: CALL_OW 301
27157: OR
27158: IFFALSE 27188
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27160: LD_VAR 0 1
27164: PPUSH
27165: LD_INT 10
27167: PPUSH
27168: EMPTY
27169: PPUSH
27170: CALL 12043 0 3
27174: PUSH
27175: LD_VAR 0 3
27179: ARRAY
27180: PPUSH
27181: LD_INT 0
27183: PPUSH
27184: CALL_OW 109
27188: GO 27102
27190: POP
27191: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27192: LD_ADDR_VAR 0 3
27196: PUSH
27197: LD_VAR 0 1
27201: PPUSH
27202: EMPTY
27203: PPUSH
27204: CALL 11641 0 2
27208: PUSH
27209: LD_VAR 0 1
27213: PPUSH
27214: LD_INT 7
27216: PPUSH
27217: EMPTY
27218: PPUSH
27219: CALL 12043 0 3
27223: DIFF
27224: PUSH
27225: FOR_IN
27226: IFFALSE 27270
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27228: LD_VAR 0 3
27232: PPUSH
27233: CALL_OW 256
27237: PUSH
27238: LD_INT 650
27240: LESS
27241: PUSH
27242: LD_VAR 0 3
27246: PPUSH
27247: CALL_OW 110
27251: PUSH
27252: LD_INT 6
27254: EQUAL
27255: NOT
27256: AND
27257: IFFALSE 27268
// MCV_ToRepair ( i ) ;
27259: LD_VAR 0 3
27263: PPUSH
27264: CALL 26900 0 1
27268: GO 27225
27270: POP
27271: POP
// end ; end_of_file end_of_file
27272: LD_VAR 0 2
27276: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27277: LD_STRING SAILEvent [
27279: PUSH
27280: LD_VAR 0 1
27284: STR
27285: PUSH
27286: LD_STRING ]
27288: STR
27289: PPUSH
27290: CALL 7737 0 1
// if event = 101 and dialog_north then
27294: LD_VAR 0 1
27298: PUSH
27299: LD_INT 101
27301: EQUAL
27302: PUSH
27303: LD_EXP 7
27307: AND
27308: IFFALSE 27372
// begin dialog_north := false ;
27310: LD_ADDR_EXP 7
27314: PUSH
27315: LD_INT 0
27317: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27318: LD_EXP 4
27322: PPUSH
27323: LD_STRING DS1
27325: PUSH
27326: LD_STRING DS2
27328: PUSH
27329: LD_STRING DS3
27331: PUSH
27332: LD_STRING DS6
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 1
27343: PPUSH
27344: LD_INT 4
27346: PPUSH
27347: CALL_OW 12
27351: ARRAY
27352: PPUSH
27353: CALL_OW 94
// Wait ( 4 4$00 ) ;
27357: LD_INT 8400
27359: PPUSH
27360: CALL_OW 67
// dialog_north := true ;
27364: LD_ADDR_EXP 7
27368: PUSH
27369: LD_INT 1
27371: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27372: LD_VAR 0 1
27376: PUSH
27377: LD_INT 102
27379: EQUAL
27380: PUSH
27381: LD_EXP 8
27385: AND
27386: IFFALSE 27446
// begin dialog_south := false ;
27388: LD_ADDR_EXP 8
27392: PUSH
27393: LD_INT 0
27395: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27396: LD_EXP 3
27400: PPUSH
27401: LD_STRING DJ1
27403: PUSH
27404: LD_STRING DJ4
27406: PUSH
27407: LD_STRING DJ6
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 1
27417: PPUSH
27418: LD_INT 3
27420: PPUSH
27421: CALL_OW 12
27425: ARRAY
27426: PPUSH
27427: CALL_OW 94
// Wait ( 4 4$00 ) ;
27431: LD_INT 8400
27433: PPUSH
27434: CALL_OW 67
// dialog_south := true ;
27438: LD_ADDR_EXP 8
27442: PUSH
27443: LD_INT 1
27445: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27446: LD_VAR 0 1
27450: PUSH
27451: LD_INT 104
27453: EQUAL
27454: PUSH
27455: LD_EXP 9
27459: AND
27460: IFFALSE 27482
// begin dialog_popov := false ;
27462: LD_ADDR_EXP 9
27466: PUSH
27467: LD_INT 0
27469: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27470: LD_EXP 26
27474: PPUSH
27475: LD_STRING DR4
27477: PPUSH
27478: CALL_OW 94
// end ; end ;
27482: PPOPN 1
27484: END
// on BuildingStarted ( b , unit ) do var side , i ;
27485: LD_INT 0
27487: PPUSH
27488: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27489: LD_EXP 41
27493: PUSH
27494: LD_VAR 0 1
27498: PPUSH
27499: CALL_OW 255
27503: ARRAY
27504: IFFALSE 27682
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27506: LD_STRING BuildingStarted [side: 
27508: PUSH
27509: LD_VAR 0 1
27513: PPUSH
27514: CALL_OW 255
27518: STR
27519: PUSH
27520: LD_STRING ; btype: 
27522: STR
27523: PUSH
27524: LD_VAR 0 1
27528: PPUSH
27529: CALL_OW 266
27533: STR
27534: PUSH
27535: LD_STRING ; unit: 
27537: STR
27538: PUSH
27539: LD_VAR 0 2
27543: STR
27544: PUSH
27545: LD_STRING ]
27547: STR
27548: PPUSH
27549: CALL 7737 0 1
// side := GetSide ( b ) ;
27553: LD_ADDR_VAR 0 3
27557: PUSH
27558: LD_VAR 0 1
27562: PPUSH
27563: CALL_OW 255
27567: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27568: LD_VAR 0 3
27572: PPUSH
27573: LD_INT 21
27575: PUSH
27576: LD_INT 3
27578: PUSH
27579: EMPTY
27580: LIST
27581: LIST
27582: PPUSH
27583: CALL 11340 0 2
27587: PUSH
27588: LD_INT 1
27590: EQUAL
27591: IFFALSE 27682
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27593: LD_ADDR_VAR 0 4
27597: PUSH
27598: LD_VAR 0 3
27602: PPUSH
27603: LD_INT 21
27605: PUSH
27606: LD_INT 1
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PPUSH
27613: CALL 11340 0 2
27617: PUSH
27618: LD_VAR 0 3
27622: PPUSH
27623: LD_INT 2
27625: PPUSH
27626: EMPTY
27627: PPUSH
27628: CALL 11423 0 3
27632: DIFF
27633: PUSH
27634: FOR_IN
27635: IFFALSE 27680
// if not HasTask ( i ) then
27637: LD_VAR 0 4
27641: PPUSH
27642: CALL_OW 314
27646: NOT
27647: IFFALSE 27678
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27649: LD_VAR 0 4
27653: PPUSH
27654: LD_VAR 0 1
27658: PPUSH
27659: CALL_OW 250
27663: PPUSH
27664: LD_VAR 0 1
27668: PPUSH
27669: CALL_OW 251
27673: PPUSH
27674: CALL_OW 111
27678: GO 27634
27680: POP
27681: POP
// end ;
27682: PPOPN 4
27684: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27685: LD_EXP 41
27689: PUSH
27690: LD_VAR 0 1
27694: PPUSH
27695: CALL_OW 255
27699: ARRAY
27700: IFFALSE 28069
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27702: LD_STRING BuildingComplete [side: 
27704: PUSH
27705: LD_VAR 0 1
27709: PPUSH
27710: CALL_OW 255
27714: STR
27715: PUSH
27716: LD_STRING ; btype: 
27718: STR
27719: PUSH
27720: LD_VAR 0 1
27724: PPUSH
27725: CALL_OW 266
27729: STR
27730: PUSH
27731: LD_STRING ]
27733: STR
27734: PPUSH
27735: CALL 7737 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27739: LD_ADDR_EXP 48
27743: PUSH
27744: LD_EXP 48
27748: PPUSH
27749: LD_VAR 0 1
27753: PPUSH
27754: CALL_OW 255
27758: PPUSH
27759: LD_VAR 0 1
27763: PPUSH
27764: CALL_OW 266
27768: PPUSH
27769: LD_VAR 0 1
27773: PPUSH
27774: CALL_OW 250
27778: PUSH
27779: LD_VAR 0 1
27783: PPUSH
27784: CALL_OW 251
27788: PUSH
27789: LD_VAR 0 1
27793: PPUSH
27794: CALL_OW 254
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: LIST
27803: PPUSH
27804: CALL 42147 0 4
27808: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27809: LD_VAR 0 1
27813: PPUSH
27814: CALL_OW 266
27818: PUSH
27819: LD_INT 6
27821: EQUAL
27822: IFFALSE 27856
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27824: LD_ADDR_EXP 42
27828: PUSH
27829: LD_EXP 42
27833: PPUSH
27834: LD_VAR 0 1
27838: PPUSH
27839: CALL_OW 255
27843: PPUSH
27844: LD_VAR 0 1
27848: PPUSH
27849: EMPTY
27850: PPUSH
27851: CALL 42056 0 4
27855: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
27856: LD_VAR 0 1
27860: PPUSH
27861: CALL_OW 266
27865: PUSH
27866: LD_INT 0
27868: EQUAL
27869: IFFALSE 27979
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
27871: LD_ADDR_EXP 50
27875: PUSH
27876: LD_EXP 50
27880: PPUSH
27881: LD_VAR 0 1
27885: PPUSH
27886: CALL_OW 255
27890: PPUSH
27891: LD_INT 0
27893: PPUSH
27894: EMPTY
27895: PPUSH
27896: CALL 42056 0 4
27900: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
27901: LD_VAR 0 1
27905: PPUSH
27906: CALL_OW 274
27910: PPUSH
27911: LD_INT 1
27913: PPUSH
27914: LD_EXP 74
27918: PUSH
27919: LD_INT 1
27921: ARRAY
27922: PPUSH
27923: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
27927: LD_VAR 0 1
27931: PPUSH
27932: CALL_OW 274
27936: PPUSH
27937: LD_INT 2
27939: PPUSH
27940: LD_EXP 74
27944: PUSH
27945: LD_INT 2
27947: ARRAY
27948: PPUSH
27949: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
27953: LD_VAR 0 1
27957: PPUSH
27958: CALL_OW 274
27962: PPUSH
27963: LD_INT 3
27965: PPUSH
27966: LD_EXP 74
27970: PUSH
27971: LD_INT 3
27973: ARRAY
27974: PPUSH
27975: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
27979: LD_VAR 0 1
27983: PPUSH
27984: CALL_OW 266
27988: PUSH
27989: LD_INT 2
27991: EQUAL
27992: IFFALSE 28024
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
27994: LD_ADDR_EXP 50
27998: PUSH
27999: LD_EXP 50
28003: PPUSH
28004: LD_VAR 0 1
28008: PPUSH
28009: CALL_OW 255
28013: PPUSH
28014: LD_INT 2
28016: PPUSH
28017: EMPTY
28018: PPUSH
28019: CALL 42056 0 4
28023: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28024: LD_VAR 0 1
28028: PPUSH
28029: CALL_OW 266
28033: PUSH
28034: LD_INT 4
28036: EQUAL
28037: IFFALSE 28069
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28039: LD_ADDR_EXP 50
28043: PUSH
28044: LD_EXP 50
28048: PPUSH
28049: LD_VAR 0 1
28053: PPUSH
28054: CALL_OW 255
28058: PPUSH
28059: LD_INT 4
28061: PPUSH
28062: EMPTY
28063: PPUSH
28064: CALL 42056 0 4
28068: ST_TO_ADDR
// end ;
28069: PPOPN 1
28071: END
// on ResearchComplete ( tech , lab ) do var i ;
28072: LD_INT 0
28074: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28075: LD_EXP 41
28079: PUSH
28080: LD_VAR 0 2
28084: PPUSH
28085: CALL_OW 255
28089: ARRAY
28090: IFFALSE 28374
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28092: LD_STRING ResearchComplete [side: 
28094: PUSH
28095: LD_VAR 0 2
28099: PPUSH
28100: CALL_OW 255
28104: PPUSH
28105: CALL_OW 255
28109: STR
28110: PUSH
28111: LD_STRING ; tech:
28113: STR
28114: PUSH
28115: LD_VAR 0 1
28119: STR
28120: PUSH
28121: LD_STRING ]
28123: STR
28124: PPUSH
28125: CALL 7737 0 1
// for i = 1 to MREG_ToRes do
28129: LD_ADDR_VAR 0 3
28133: PUSH
28134: DOUBLE
28135: LD_INT 1
28137: DEC
28138: ST_TO_ADDR
28139: LD_EXP 52
28143: PUSH
28144: FOR_TO
28145: IFFALSE 28232
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28147: LD_EXP 52
28151: PUSH
28152: LD_VAR 0 3
28156: ARRAY
28157: PUSH
28158: LD_INT 1
28160: ARRAY
28161: PUSH
28162: LD_VAR 0 2
28166: PPUSH
28167: CALL_OW 255
28171: EQUAL
28172: PUSH
28173: LD_EXP 52
28177: PUSH
28178: LD_VAR 0 3
28182: ARRAY
28183: PUSH
28184: LD_INT 2
28186: ARRAY
28187: PUSH
28188: LD_VAR 0 1
28192: EQUAL
28193: AND
28194: IFFALSE 28230
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28196: LD_ADDR_EXP 52
28200: PUSH
28201: LD_EXP 52
28205: PPUSH
28206: LD_VAR 0 2
28210: PPUSH
28211: CALL_OW 255
28215: PPUSH
28216: LD_VAR 0 1
28220: PPUSH
28221: EMPTY
28222: PPUSH
28223: CALL 42147 0 4
28227: ST_TO_ADDR
// break ;
28228: GO 28232
// end ;
28230: GO 28144
28232: POP
28233: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28234: LD_VAR 0 1
28238: PUSH
28239: LD_INT 2
28241: PUSH
28242: LD_INT 11
28244: PUSH
28245: LD_INT 4
28247: PUSH
28248: LD_INT 3
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: IN
28257: IFFALSE 28374
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28259: LD_ADDR_VAR 0 3
28263: PUSH
28264: LD_VAR 0 2
28268: PPUSH
28269: CALL_OW 255
28273: PPUSH
28274: LD_INT 16
28276: PPUSH
28277: LD_INT 25
28279: PUSH
28280: LD_INT 4
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PPUSH
28287: CALL 12043 0 3
28291: ST_TO_ADDR
// if i then
28292: LD_VAR 0 3
28296: IFFALSE 28314
// SetTag ( i [ 1 ] , 0 ) ;
28298: LD_VAR 0 3
28302: PUSH
28303: LD_INT 1
28305: ARRAY
28306: PPUSH
28307: LD_INT 0
28309: PPUSH
28310: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28314: LD_ADDR_VAR 0 3
28318: PUSH
28319: LD_VAR 0 2
28323: PPUSH
28324: CALL_OW 255
28328: PPUSH
28329: LD_INT 171
28331: PPUSH
28332: EMPTY
28333: PPUSH
28334: CALL 12043 0 3
28338: ST_TO_ADDR
// if i then
28339: LD_VAR 0 3
28343: IFFALSE 28374
// begin SetTag ( i [ 1 ] , 0 ) ;
28345: LD_VAR 0 3
28349: PUSH
28350: LD_INT 1
28352: ARRAY
28353: PPUSH
28354: LD_INT 0
28356: PPUSH
28357: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28361: LD_VAR 0 3
28365: PUSH
28366: LD_INT 1
28368: ARRAY
28369: PPUSH
28370: CALL_OW 122
// end ; end ; end ;
28374: PPOPN 3
28376: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28377: LD_INT 0
28379: PPUSH
28380: PPUSH
28381: PPUSH
28382: PPUSH
28383: PPUSH
28384: PPUSH
28385: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28386: LD_EXP 41
28390: PUSH
28391: LD_VAR 0 2
28395: PPUSH
28396: CALL_OW 255
28400: ARRAY
28401: IFFALSE 29128
// begin side := GetSide ( veh ) ;
28403: LD_ADDR_VAR 0 4
28407: PUSH
28408: LD_VAR 0 1
28412: PPUSH
28413: CALL_OW 255
28417: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28418: LD_ADDR_VAR 0 6
28422: PUSH
28423: LD_VAR 0 1
28427: PPUSH
28428: CALL_OW 265
28432: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28433: LD_ADDR_VAR 0 7
28437: PUSH
28438: LD_VAR 0 1
28442: PPUSH
28443: CALL_OW 262
28447: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28448: LD_ADDR_VAR 0 8
28452: PUSH
28453: LD_VAR 0 1
28457: PPUSH
28458: CALL_OW 263
28462: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28463: LD_ADDR_VAR 0 9
28467: PUSH
28468: LD_VAR 0 1
28472: PPUSH
28473: CALL_OW 264
28477: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28478: LD_STRING VehicleConstructed [side: 
28480: PUSH
28481: LD_VAR 0 4
28485: STR
28486: PUSH
28487: LD_STRING ; id:
28489: STR
28490: PUSH
28491: LD_VAR 0 1
28495: STR
28496: PUSH
28497: LD_STRING ; components: [
28499: STR
28500: PUSH
28501: LD_VAR 0 6
28505: STR
28506: PUSH
28507: LD_STRING , 
28509: STR
28510: PUSH
28511: LD_VAR 0 7
28515: STR
28516: PUSH
28517: LD_STRING , 
28519: STR
28520: PUSH
28521: LD_VAR 0 8
28525: STR
28526: PUSH
28527: LD_STRING , 
28529: STR
28530: PUSH
28531: LD_VAR 0 9
28535: STR
28536: PUSH
28537: LD_STRING ]]
28539: STR
28540: PPUSH
28541: CALL 7737 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28545: LD_VAR 0 1
28549: PPUSH
28550: CALL_OW 264
28554: PUSH
28555: LD_INT 13
28557: PUSH
28558: LD_INT 12
28560: PUSH
28561: LD_INT 14
28563: PUSH
28564: LD_INT 51
28566: PUSH
28567: LD_INT 53
28569: PUSH
28570: LD_INT 52
28572: PUSH
28573: LD_INT 32
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: IN
28585: NOT
28586: IFFALSE 28628
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28588: LD_ADDR_EXP 61
28592: PUSH
28593: LD_EXP 61
28597: PPUSH
28598: LD_VAR 0 4
28602: PPUSH
28603: LD_EXP 61
28607: PUSH
28608: LD_VAR 0 4
28612: ARRAY
28613: PUSH
28614: LD_INT 1
28616: PLUS
28617: PPUSH
28618: LD_VAR 0 1
28622: PPUSH
28623: CALL 30774 0 4
28627: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28628: LD_VAR 0 1
28632: PPUSH
28633: CALL_OW 264
28637: PUSH
28638: LD_INT 31
28640: EQUAL
28641: IFFALSE 28660
// SetTag ( GetDriver ( veh ) , 9 ) ;
28643: LD_VAR 0 1
28647: PPUSH
28648: CALL 31468 0 1
28652: PPUSH
28653: LD_INT 9
28655: PPUSH
28656: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 264
28669: PUSH
28670: LD_INT 14
28672: PUSH
28673: LD_INT 53
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: IN
28680: IFFALSE 28717
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28682: LD_ADDR_EXP 44
28686: PUSH
28687: LD_EXP 44
28691: PPUSH
28692: LD_VAR 0 1
28696: PPUSH
28697: CALL_OW 255
28701: PPUSH
28702: LD_INT 2
28704: PPUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL 30774 0 4
28714: ST_TO_ADDR
// exit ;
28715: GO 29128
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28717: LD_VAR 0 1
28721: PPUSH
28722: CALL_OW 265
28726: PUSH
28727: LD_EXP 68
28731: PUSH
28732: LD_VAR 0 4
28736: ARRAY
28737: PUSH
28738: LD_INT 1
28740: ARRAY
28741: IN
28742: PUSH
28743: LD_VAR 0 1
28747: PPUSH
28748: CALL_OW 262
28752: PUSH
28753: LD_EXP 68
28757: PUSH
28758: LD_VAR 0 4
28762: ARRAY
28763: PUSH
28764: LD_INT 1
28766: ARRAY
28767: IN
28768: AND
28769: PUSH
28770: LD_VAR 0 1
28774: PPUSH
28775: CALL_OW 263
28779: PUSH
28780: LD_EXP 68
28784: PUSH
28785: LD_VAR 0 4
28789: ARRAY
28790: PUSH
28791: LD_INT 1
28793: ARRAY
28794: IN
28795: AND
28796: PUSH
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_EXP 68
28811: PUSH
28812: LD_VAR 0 4
28816: ARRAY
28817: PUSH
28818: LD_INT 1
28820: ARRAY
28821: IN
28822: AND
28823: IFFALSE 28867
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28825: LD_ADDR_EXP 69
28829: PUSH
28830: LD_EXP 69
28834: PPUSH
28835: LD_VAR 0 4
28839: PPUSH
28840: LD_EXP 69
28844: PUSH
28845: LD_VAR 0 4
28849: ARRAY
28850: PUSH
28851: LD_INT 1
28853: PLUS
28854: PPUSH
28855: LD_VAR 0 1
28859: PPUSH
28860: CALL 30774 0 4
28864: ST_TO_ADDR
// exit ;
28865: GO 29128
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
28867: LD_VAR 0 6
28871: PUSH
28872: LD_EXP 71
28876: PUSH
28877: LD_VAR 0 4
28881: ARRAY
28882: PUSH
28883: LD_INT 1
28885: ARRAY
28886: EQUAL
28887: PUSH
28888: LD_VAR 0 7
28892: PUSH
28893: LD_EXP 71
28897: PUSH
28898: LD_VAR 0 4
28902: ARRAY
28903: PUSH
28904: LD_INT 2
28906: ARRAY
28907: EQUAL
28908: AND
28909: PUSH
28910: LD_VAR 0 8
28914: PUSH
28915: LD_EXP 71
28919: PUSH
28920: LD_VAR 0 4
28924: ARRAY
28925: PUSH
28926: LD_INT 3
28928: ARRAY
28929: EQUAL
28930: AND
28931: PUSH
28932: LD_VAR 0 9
28936: PUSH
28937: LD_EXP 71
28941: PUSH
28942: LD_VAR 0 4
28946: ARRAY
28947: PUSH
28948: LD_INT 4
28950: ARRAY
28951: EQUAL
28952: AND
28953: IFFALSE 29109
// begin tmp := MREG_ToAttack [ side ] ;
28955: LD_ADDR_VAR 0 5
28959: PUSH
28960: LD_EXP 71
28964: PUSH
28965: LD_VAR 0 4
28969: ARRAY
28970: ST_TO_ADDR
// for i = 1 to 4 do
28971: LD_ADDR_VAR 0 3
28975: PUSH
28976: DOUBLE
28977: LD_INT 1
28979: DEC
28980: ST_TO_ADDR
28981: LD_INT 4
28983: PUSH
28984: FOR_TO
28985: IFFALSE 29007
// tmp := Delete ( tmp , 1 ) ;
28987: LD_ADDR_VAR 0 5
28991: PUSH
28992: LD_VAR 0 5
28996: PPUSH
28997: LD_INT 1
28999: PPUSH
29000: CALL_OW 3
29004: ST_TO_ADDR
29005: GO 28984
29007: POP
29008: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29009: LD_ADDR_EXP 71
29013: PUSH
29014: LD_EXP 71
29018: PPUSH
29019: LD_VAR 0 4
29023: PPUSH
29024: LD_VAR 0 5
29028: PPUSH
29029: CALL_OW 1
29033: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29034: LD_ADDR_EXP 73
29038: PUSH
29039: LD_EXP 73
29043: PPUSH
29044: LD_VAR 0 4
29048: PPUSH
29049: LD_EXP 73
29053: PUSH
29054: LD_VAR 0 4
29058: ARRAY
29059: PUSH
29060: LD_INT 1
29062: PLUS
29063: PPUSH
29064: LD_VAR 0 1
29068: PPUSH
29069: CALL 30774 0 4
29073: ST_TO_ADDR
// if tmp = 0 then
29074: LD_VAR 0 5
29078: PUSH
29079: LD_INT 0
29081: EQUAL
29082: IFFALSE 29107
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29084: LD_ADDR_EXP 71
29088: PUSH
29089: LD_EXP 71
29093: PPUSH
29094: LD_VAR 0 4
29098: PPUSH
29099: LD_INT 0
29101: PPUSH
29102: CALL_OW 1
29106: ST_TO_ADDR
// exit ;
29107: GO 29128
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29109: LD_VAR 0 1
29113: PPUSH
29114: CALL_OW 255
29118: PPUSH
29119: LD_VAR 0 1
29123: PPUSH
29124: CALL 25501 0 2
// end ;
29128: PPOPN 9
29130: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29131: LD_EXP 41
29135: PUSH
29136: LD_VAR 0 2
29140: PPUSH
29141: CALL_OW 255
29145: ARRAY
29146: IFFALSE 29378
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29148: LD_STRING ApemanTamed [side: 
29150: PUSH
29151: LD_VAR 0 2
29155: PPUSH
29156: CALL_OW 255
29160: STR
29161: PUSH
29162: LD_STRING ; sci: 
29164: STR
29165: PUSH
29166: LD_VAR 0 2
29170: STR
29171: PUSH
29172: LD_STRING ; ape: 
29174: STR
29175: PUSH
29176: LD_VAR 0 1
29180: STR
29181: PUSH
29182: LD_STRING ]
29184: STR
29185: PPUSH
29186: CALL 7737 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29190: LD_INT 11
29192: PPUSH
29193: LD_VAR 0 2
29197: PPUSH
29198: CALL_OW 255
29202: PPUSH
29203: CALL_OW 321
29207: PUSH
29208: LD_INT 2
29210: EQUAL
29211: NOT
29212: PUSH
29213: LD_INT 2
29215: PPUSH
29216: LD_VAR 0 2
29220: PPUSH
29221: CALL_OW 255
29225: PPUSH
29226: CALL_OW 321
29230: PUSH
29231: LD_INT 2
29233: EQUAL
29234: NOT
29235: OR
29236: PUSH
29237: LD_VAR 0 2
29241: PPUSH
29242: CALL_OW 255
29246: PPUSH
29247: LD_INT 171
29249: PPUSH
29250: EMPTY
29251: PPUSH
29252: CALL 12043 0 3
29256: PUSH
29257: LD_INT 0
29259: EQUAL
29260: AND
29261: IFFALSE 29275
// begin SetTag ( ape , 171 ) ;
29263: LD_VAR 0 1
29267: PPUSH
29268: LD_INT 171
29270: PPUSH
29271: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29275: LD_VAR 0 2
29279: PPUSH
29280: CALL_OW 255
29284: PPUSH
29285: LD_INT 30
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PPUSH
29295: CALL 11340 0 2
29299: IFFALSE 29378
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29301: LD_VAR 0 1
29305: PPUSH
29306: LD_VAR 0 2
29310: PPUSH
29311: CALL_OW 255
29315: PPUSH
29316: LD_INT 30
29318: PUSH
29319: LD_INT 1
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PPUSH
29326: CALL 11340 0 2
29330: PUSH
29331: LD_INT 1
29333: ARRAY
29334: PPUSH
29335: CALL_OW 250
29339: PPUSH
29340: LD_VAR 0 2
29344: PPUSH
29345: CALL_OW 255
29349: PPUSH
29350: LD_INT 30
29352: PUSH
29353: LD_INT 1
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PPUSH
29360: CALL 11340 0 2
29364: PUSH
29365: LD_INT 1
29367: ARRAY
29368: PPUSH
29369: CALL_OW 251
29373: PPUSH
29374: CALL_OW 111
// end ;
29378: PPOPN 2
29380: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29381: LD_EXP 41
29385: PUSH
29386: LD_VAR 0 1
29390: PPUSH
29391: CALL_OW 255
29395: ARRAY
29396: IFFALSE 29674
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29398: LD_VAR 0 2
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: PPUSH
29413: CALL 11753 0 1
29417: IN
29418: IFFALSE 29559
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29420: LD_VAR 0 1
29424: PPUSH
29425: CALL_OW 266
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 1
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: IN
29440: IFFALSE 29470
// begin Wait ( 0 0$0.3 ) ;
29442: LD_INT 10
29444: PPUSH
29445: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29449: LD_VAR 0 2
29453: PPUSH
29454: LD_INT 16
29456: PPUSH
29457: CALL_OW 336
// ComExitBuilding ( un ) ;
29461: LD_VAR 0 2
29465: PPUSH
29466: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29470: LD_VAR 0 1
29474: PPUSH
29475: CALL_OW 266
29479: PUSH
29480: LD_INT 4
29482: PUSH
29483: LD_INT 5
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: IN
29490: IFFALSE 29559
// begin Wait ( 0 0$0.3 ) ;
29492: LD_INT 10
29494: PPUSH
29495: CALL_OW 67
// if GetTag ( un ) = 0 then
29499: LD_VAR 0 2
29503: PPUSH
29504: CALL_OW 110
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: IFFALSE 29528
// SetClass ( un , class_apeman_soldier ) else
29514: LD_VAR 0 2
29518: PPUSH
29519: LD_INT 15
29521: PPUSH
29522: CALL_OW 336
29526: GO 29559
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29528: LD_INT 3
29530: PPUSH
29531: LD_VAR 0 2
29535: PPUSH
29536: CALL_OW 255
29540: PPUSH
29541: CALL_OW 321
29545: IFFALSE 29559
// SetClass ( un , class_apeman_kamikaze ) ;
29547: LD_VAR 0 2
29551: PPUSH
29552: LD_INT 17
29554: PPUSH
29555: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29559: LD_VAR 0 1
29563: PPUSH
29564: CALL_OW 266
29568: PUSH
29569: LD_INT 32
29571: EQUAL
29572: IFFALSE 29674
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29574: LD_ADDR_EXP 70
29578: PUSH
29579: LD_EXP 70
29583: PPUSH
29584: LD_VAR 0 1
29588: PPUSH
29589: CALL_OW 255
29593: PPUSH
29594: LD_EXP 70
29598: PUSH
29599: LD_VAR 0 1
29603: PPUSH
29604: CALL_OW 255
29608: ARRAY
29609: PUSH
29610: LD_INT 1
29612: PLUS
29613: PPUSH
29614: LD_VAR 0 1
29618: PPUSH
29619: CALL 30774 0 4
29623: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29624: LD_ADDR_EXP 70
29628: PUSH
29629: LD_EXP 70
29633: PPUSH
29634: LD_VAR 0 1
29638: PPUSH
29639: CALL_OW 255
29643: PPUSH
29644: LD_EXP 70
29648: PUSH
29649: LD_VAR 0 1
29653: PPUSH
29654: CALL_OW 255
29658: ARRAY
29659: PUSH
29660: LD_INT 1
29662: PLUS
29663: PPUSH
29664: LD_VAR 0 2
29668: PPUSH
29669: CALL 30774 0 4
29673: ST_TO_ADDR
// end ; end ;
29674: PPOPN 2
29676: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29677: LD_VAR 0 1
29681: PUSH
29682: LD_INT 22
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 21
29694: PUSH
29695: LD_INT 3
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PPUSH
29706: CALL_OW 69
29710: IN
29711: PUSH
29712: LD_EXP 15
29716: NOT
29717: AND
29718: IFFALSE 29781
// begin alfa_north_triggered := true ;
29720: LD_ADDR_EXP 15
29724: PUSH
29725: LD_INT 1
29727: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29728: LD_EXP 4
29732: PPUSH
29733: LD_STRING DS4
29735: PPUSH
29736: CALL_OW 94
// Wait ( 1 1$25 ) ;
29740: LD_INT 2975
29742: PPUSH
29743: CALL_OW 67
// if not isTest then
29747: LD_EXP 1
29751: NOT
29752: IFFALSE 29781
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29754: LD_INT 20
29756: PPUSH
29757: LD_INT 5
29759: PUSH
29760: LD_INT 6
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: LIST
29770: PUSH
29771: LD_OWVAR 67
29775: ARRAY
29776: PPUSH
29777: CALL 6895 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
29781: LD_VAR 0 1
29785: PUSH
29786: LD_INT 22
29788: PUSH
29789: LD_INT 4
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 21
29798: PUSH
29799: LD_INT 3
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PPUSH
29810: CALL_OW 69
29814: IN
29815: PUSH
29816: LD_EXP 16
29820: NOT
29821: AND
29822: IFFALSE 29885
// begin alfa_south_triggered := true ;
29824: LD_ADDR_EXP 16
29828: PUSH
29829: LD_INT 1
29831: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
29832: LD_EXP 3
29836: PPUSH
29837: LD_STRING DJ3
29839: PPUSH
29840: CALL_OW 94
// Wait ( 0 0$45 ) ;
29844: LD_INT 1575
29846: PPUSH
29847: CALL_OW 67
// if not isTest then
29851: LD_EXP 1
29855: NOT
29856: IFFALSE 29885
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29858: LD_INT 20
29860: PPUSH
29861: LD_INT 5
29863: PUSH
29864: LD_INT 6
29866: PUSH
29867: LD_INT 7
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: LIST
29874: PUSH
29875: LD_OWVAR 67
29879: ARRAY
29880: PPUSH
29881: CALL 6895 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
29885: LD_VAR 0 1
29889: PPUSH
29890: CALL_OW 266
29894: PUSH
29895: LD_INT 1
29897: EQUAL
29898: PUSH
29899: LD_VAR 0 1
29903: PPUSH
29904: CALL_OW 255
29908: PUSH
29909: LD_INT 1
29911: PUSH
29912: LD_INT 4
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: IN
29919: AND
29920: IFFALSE 29929
// RaiseSailEvent ( 104 ) ;
29922: LD_INT 104
29924: PPUSH
29925: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
29929: LD_EXP 41
29933: PUSH
29934: LD_VAR 0 1
29938: PPUSH
29939: CALL_OW 255
29943: ARRAY
29944: IFFALSE 30331
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
29946: LD_STRING UnitDestroyed [side 
29948: PUSH
29949: LD_VAR 0 1
29953: PPUSH
29954: CALL_OW 255
29958: STR
29959: PUSH
29960: LD_STRING ; id: 
29962: STR
29963: PUSH
29964: LD_VAR 0 1
29968: STR
29969: PUSH
29970: LD_STRING ; type: 
29972: STR
29973: PUSH
29974: LD_VAR 0 1
29978: PPUSH
29979: CALL_OW 247
29983: STR
29984: PUSH
29985: LD_STRING ]
29987: STR
29988: PPUSH
29989: CALL 7737 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
29993: LD_VAR 0 1
29997: PUSH
29998: LD_VAR 0 1
30002: PPUSH
30003: CALL_OW 255
30007: PPUSH
30008: LD_INT 21
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PPUSH
30018: CALL 11340 0 2
30022: IN
30023: IFFALSE 30179
// begin if MCF_HasClass ( un ) then
30025: LD_VAR 0 1
30029: PPUSH
30030: CALL 14046 0 1
30034: IFFALSE 30179
// case MCF_HasClass ( un ) of 1 :
30036: LD_VAR 0 1
30040: PPUSH
30041: CALL 14046 0 1
30045: PUSH
30046: LD_INT 1
30048: DOUBLE
30049: EQUAL
30050: IFTRUE 30054
30052: GO 30079
30054: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30055: LD_VAR 0 1
30059: PPUSH
30060: CALL_OW 255
30064: PPUSH
30065: LD_STRING ToArm
30067: PPUSH
30068: LD_VAR 0 1
30072: PPUSH
30073: CALL 14219 0 3
30077: GO 30179
30079: LD_INT 2
30081: DOUBLE
30082: EQUAL
30083: IFTRUE 30087
30085: GO 30112
30087: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30088: LD_VAR 0 1
30092: PPUSH
30093: CALL_OW 255
30097: PPUSH
30098: LD_STRING ToDep
30100: PPUSH
30101: LD_VAR 0 1
30105: PPUSH
30106: CALL 14219 0 3
30110: GO 30179
30112: LD_INT 3
30114: DOUBLE
30115: EQUAL
30116: IFTRUE 30120
30118: GO 30145
30120: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30121: LD_VAR 0 1
30125: PPUSH
30126: CALL_OW 255
30130: PPUSH
30131: LD_STRING ToFac
30133: PPUSH
30134: LD_VAR 0 1
30138: PPUSH
30139: CALL 14219 0 3
30143: GO 30179
30145: LD_INT 4
30147: DOUBLE
30148: EQUAL
30149: IFTRUE 30153
30151: GO 30178
30153: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30154: LD_VAR 0 1
30158: PPUSH
30159: CALL_OW 255
30163: PPUSH
30164: LD_STRING ToLab
30166: PPUSH
30167: LD_VAR 0 1
30171: PPUSH
30172: CALL 14219 0 3
30176: GO 30179
30178: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30179: LD_VAR 0 1
30183: PUSH
30184: LD_EXP 69
30188: PUSH
30189: LD_VAR 0 1
30193: PPUSH
30194: CALL_OW 255
30198: ARRAY
30199: IN
30200: IFFALSE 30285
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30202: LD_ADDR_EXP 69
30206: PUSH
30207: LD_EXP 69
30211: PPUSH
30212: LD_VAR 0 1
30216: PPUSH
30217: LD_INT 0
30219: PPUSH
30220: CALL 30933 0 3
30224: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30225: LD_VAR 0 1
30229: PPUSH
30230: CALL_OW 255
30234: PPUSH
30235: LD_VAR 0 1
30239: PPUSH
30240: CALL_OW 265
30244: PUSH
30245: LD_VAR 0 1
30249: PPUSH
30250: CALL_OW 262
30254: PUSH
30255: LD_VAR 0 1
30259: PPUSH
30260: CALL_OW 263
30264: PUSH
30265: LD_VAR 0 1
30269: PPUSH
30270: CALL_OW 264
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: PPUSH
30281: CALL 20859 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30285: LD_VAR 0 1
30289: PUSH
30290: LD_EXP 73
30294: PUSH
30295: LD_VAR 0 1
30299: PPUSH
30300: CALL_OW 255
30304: ARRAY
30305: IN
30306: IFFALSE 30331
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30308: LD_ADDR_EXP 73
30312: PUSH
30313: LD_EXP 73
30317: PPUSH
30318: LD_VAR 0 1
30322: PPUSH
30323: LD_INT 0
30325: PPUSH
30326: CALL 30933 0 3
30330: ST_TO_ADDR
// end ; end ;
30331: PPOPN 1
30333: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30334: LD_EXP 41
30338: PUSH
30339: LD_VAR 0 2
30343: PPUSH
30344: CALL_OW 255
30348: ARRAY
30349: IFFALSE 30521
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30351: LD_VAR 0 2
30355: PUSH
30356: LD_EXP 70
30360: PUSH
30361: LD_VAR 0 2
30365: PPUSH
30366: CALL_OW 255
30370: ARRAY
30371: IN
30372: PUSH
30373: LD_VAR 0 1
30377: PPUSH
30378: CALL_OW 266
30382: PUSH
30383: LD_INT 32
30385: PUSH
30386: LD_INT 31
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: IN
30393: AND
30394: IFFALSE 30494
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30396: LD_ADDR_EXP 70
30400: PUSH
30401: LD_EXP 70
30405: PPUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: LD_INT 0
30413: PPUSH
30414: CALL 30933 0 3
30418: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30419: LD_ADDR_EXP 70
30423: PUSH
30424: LD_EXP 70
30428: PPUSH
30429: LD_VAR 0 2
30433: PPUSH
30434: LD_INT 0
30436: PPUSH
30437: CALL 30933 0 3
30441: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30442: LD_EXP 70
30446: PUSH
30447: LD_VAR 0 2
30451: PPUSH
30452: CALL_OW 255
30456: ARRAY
30457: PUSH
30458: LD_STRING 
30460: EQUAL
30461: IFFALSE 30494
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30463: LD_ADDR_EXP 70
30467: PUSH
30468: LD_EXP 70
30472: PPUSH
30473: LD_VAR 0 2
30477: PPUSH
30478: CALL_OW 255
30482: PPUSH
30483: LD_INT 1
30485: PPUSH
30486: LD_INT 0
30488: PPUSH
30489: CALL 30774 0 4
30493: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30494: LD_VAR 0 1
30498: PPUSH
30499: CALL_OW 266
30503: PUSH
30504: LD_INT 36
30506: IN
30507: IFFALSE 30521
// SetTag ( un , 0 ) ;
30509: LD_VAR 0 2
30513: PPUSH
30514: LD_INT 0
30516: PPUSH
30517: CALL_OW 109
// end ;
30521: PPOPN 2
30523: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30524: LD_EXP 41
30528: PUSH
30529: LD_VAR 0 1
30533: PPUSH
30534: CALL_OW 255
30538: ARRAY
30539: IFFALSE 30565
// begin if GetControl ( un ) = control_remote then
30541: LD_VAR 0 1
30545: PPUSH
30546: CALL_OW 263
30550: PUSH
30551: LD_INT 2
30553: EQUAL
30554: IFFALSE 30565
// ComUnlink ( un ) ;
30556: LD_VAR 0 1
30560: PPUSH
30561: CALL_OW 136
// end ;
30565: PPOPN 1
30567: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30568: LD_EXP 41
30572: PUSH
30573: LD_VAR 0 1
30577: PPUSH
30578: CALL_OW 255
30582: ARRAY
30583: IFFALSE 30612
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30585: LD_VAR 0 2
30589: PPUSH
30590: CALL_OW 264
30594: PUSH
30595: LD_INT 31
30597: IN
30598: IFFALSE 30612
// SetTag ( driver , 0 ) ;
30600: LD_VAR 0 1
30604: PPUSH
30605: LD_INT 0
30607: PPUSH
30608: CALL_OW 109
// end ;
30612: PPOPN 4
30614: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30615: LD_INT 0
30617: PPUSH
30618: PPUSH
30619: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30620: LD_ADDR_VAR 0 3
30624: PUSH
30625: LD_VAR 0 1
30629: PPUSH
30630: CALL_OW 269
30634: ST_TO_ADDR
// x := GetX ( building ) ;
30635: LD_ADDR_VAR 0 4
30639: PUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: CALL_OW 250
30649: ST_TO_ADDR
// y := GetY ( building ) ;
30650: LD_ADDR_VAR 0 5
30654: PUSH
30655: LD_VAR 0 1
30659: PPUSH
30660: CALL_OW 251
30664: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30665: LD_ADDR_EXP 45
30669: PUSH
30670: LD_EXP 45
30674: PPUSH
30675: LD_VAR 0 1
30679: PPUSH
30680: CALL_OW 255
30684: PPUSH
30685: LD_VAR 0 3
30689: PPUSH
30690: LD_VAR 0 4
30694: PUSH
30695: LD_VAR 0 5
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PPUSH
30704: CALL 42147 0 4
30708: ST_TO_ADDR
// end ;
30709: PPOPN 5
30711: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30712: LD_VAR 0 1
30716: PUSH
30717: LD_EXP 32
30721: IN
30722: NOT
30723: IFFALSE 30771
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30725: LD_ADDR_EXP 32
30729: PUSH
30730: LD_EXP 32
30734: PPUSH
30735: LD_EXP 32
30739: PUSH
30740: LD_INT 1
30742: PLUS
30743: PPUSH
30744: LD_VAR 0 1
30748: PPUSH
30749: CALL_OW 2
30753: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30754: LD_STRING DestinationUnrechable. [unit: 
30756: PUSH
30757: LD_VAR 0 1
30761: STR
30762: PUSH
30763: LD_STRING ]
30765: STR
30766: PPUSH
30767: CALL 7737 0 1
// end ; end ; end_of_file
30771: PPOPN 1
30773: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
30774: LD_INT 0
30776: PPUSH
30777: PPUSH
30778: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
30779: LD_ADDR_VAR 0 7
30783: PUSH
30784: LD_VAR 0 1
30788: PUSH
30789: LD_VAR 0 2
30793: ARRAY
30794: PPUSH
30795: LD_VAR 0 3
30799: PPUSH
30800: LD_VAR 0 4
30804: PPUSH
30805: CALL_OW 1
30809: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
30810: LD_ADDR_VAR 0 1
30814: PUSH
30815: LD_VAR 0 1
30819: PPUSH
30820: LD_VAR 0 2
30824: PPUSH
30825: LD_VAR 0 7
30829: PPUSH
30830: CALL_OW 1
30834: ST_TO_ADDR
// result := tab ;
30835: LD_ADDR_VAR 0 5
30839: PUSH
30840: LD_VAR 0 1
30844: ST_TO_ADDR
// end ;
30845: LD_VAR 0 5
30849: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
30850: LD_INT 0
30852: PPUSH
30853: PPUSH
30854: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
30855: LD_ADDR_VAR 0 5
30859: PUSH
30860: LD_VAR 0 1
30864: PUSH
30865: LD_VAR 0 2
30869: PUSH
30870: LD_INT 1
30872: ARRAY
30873: ARRAY
30874: PPUSH
30875: LD_VAR 0 2
30879: PUSH
30880: LD_INT 2
30882: ARRAY
30883: PPUSH
30884: CALL_OW 3
30888: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
30889: LD_ADDR_VAR 0 1
30893: PUSH
30894: LD_VAR 0 1
30898: PPUSH
30899: LD_VAR 0 2
30903: PUSH
30904: LD_INT 1
30906: ARRAY
30907: PPUSH
30908: LD_VAR 0 5
30912: PPUSH
30913: CALL_OW 1
30917: ST_TO_ADDR
// result := tab ;
30918: LD_ADDR_VAR 0 3
30922: PUSH
30923: LD_VAR 0 1
30927: ST_TO_ADDR
// end ;
30928: LD_VAR 0 3
30932: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
30933: LD_INT 0
30935: PPUSH
30936: PPUSH
30937: PPUSH
30938: PPUSH
// i := 1 ;
30939: LD_ADDR_VAR 0 5
30943: PUSH
30944: LD_INT 1
30946: ST_TO_ADDR
// while ( i <= tab ) do
30947: LD_VAR 0 5
30951: PUSH
30952: LD_VAR 0 1
30956: LESSEQUAL
30957: IFFALSE 31332
// begin if not tab [ i ] then
30959: LD_VAR 0 1
30963: PUSH
30964: LD_VAR 0 5
30968: ARRAY
30969: NOT
30970: IFFALSE 30974
// break ;
30972: GO 31332
// if value in tab then
30974: LD_VAR 0 2
30978: PUSH
30979: LD_VAR 0 1
30983: IN
30984: IFFALSE 31097
// begin if not mode then
30986: LD_VAR 0 3
30990: NOT
30991: IFFALSE 31011
// tab := tab diff value else
30993: LD_ADDR_VAR 0 1
30997: PUSH
30998: LD_VAR 0 1
31002: PUSH
31003: LD_VAR 0 2
31007: DIFF
31008: ST_TO_ADDR
31009: GO 31073
// for j = 1 to tab do
31011: LD_ADDR_VAR 0 6
31015: PUSH
31016: DOUBLE
31017: LD_INT 1
31019: DEC
31020: ST_TO_ADDR
31021: LD_VAR 0 1
31025: PUSH
31026: FOR_TO
31027: IFFALSE 31071
// if tab [ j ] = value then
31029: LD_VAR 0 1
31033: PUSH
31034: LD_VAR 0 6
31038: ARRAY
31039: PUSH
31040: LD_VAR 0 2
31044: EQUAL
31045: IFFALSE 31069
// begin tab := Delete ( tab , j ) ;
31047: LD_ADDR_VAR 0 1
31051: PUSH
31052: LD_VAR 0 1
31056: PPUSH
31057: LD_VAR 0 6
31061: PPUSH
31062: CALL_OW 3
31066: ST_TO_ADDR
// break ;
31067: GO 31071
// end ;
31069: GO 31026
31071: POP
31072: POP
// i := i - 1 ;
31073: LD_ADDR_VAR 0 5
31077: PUSH
31078: LD_VAR 0 5
31082: PUSH
31083: LD_INT 1
31085: MINUS
31086: ST_TO_ADDR
// if mode then
31087: LD_VAR 0 3
31091: IFFALSE 31095
// break ;
31093: GO 31332
// end else
31095: GO 31316
// if tab [ i ] and value in tab [ i ] then
31097: LD_VAR 0 1
31101: PUSH
31102: LD_VAR 0 5
31106: ARRAY
31107: PUSH
31108: LD_VAR 0 2
31112: PUSH
31113: LD_VAR 0 1
31117: PUSH
31118: LD_VAR 0 5
31122: ARRAY
31123: IN
31124: AND
31125: IFFALSE 31316
// begin if not mode then
31127: LD_VAR 0 3
31131: NOT
31132: IFFALSE 31158
// tmp := tab [ i ] diff value else
31134: LD_ADDR_VAR 0 7
31138: PUSH
31139: LD_VAR 0 1
31143: PUSH
31144: LD_VAR 0 5
31148: ARRAY
31149: PUSH
31150: LD_VAR 0 2
31154: DIFF
31155: ST_TO_ADDR
31156: GO 31238
// for j = 1 to tab [ i ] do
31158: LD_ADDR_VAR 0 6
31162: PUSH
31163: DOUBLE
31164: LD_INT 1
31166: DEC
31167: ST_TO_ADDR
31168: LD_VAR 0 1
31172: PUSH
31173: LD_VAR 0 5
31177: ARRAY
31178: PUSH
31179: FOR_TO
31180: IFFALSE 31236
// if value = tab [ i ] [ j ] then
31182: LD_VAR 0 2
31186: PUSH
31187: LD_VAR 0 1
31191: PUSH
31192: LD_VAR 0 5
31196: ARRAY
31197: PUSH
31198: LD_VAR 0 6
31202: ARRAY
31203: EQUAL
31204: IFFALSE 31234
// begin tmp := Delete ( tab [ i ] , j ) ;
31206: LD_ADDR_VAR 0 7
31210: PUSH
31211: LD_VAR 0 1
31215: PUSH
31216: LD_VAR 0 5
31220: ARRAY
31221: PPUSH
31222: LD_VAR 0 6
31226: PPUSH
31227: CALL_OW 3
31231: ST_TO_ADDR
// break ;
31232: GO 31236
// end ;
31234: GO 31179
31236: POP
31237: POP
// if tmp = [ ] then
31238: LD_VAR 0 7
31242: PUSH
31243: EMPTY
31244: EQUAL
31245: IFFALSE 31269
// begin tab := Delete ( tab , i ) ;
31247: LD_ADDR_VAR 0 1
31251: PUSH
31252: LD_VAR 0 1
31256: PPUSH
31257: LD_VAR 0 5
31261: PPUSH
31262: CALL_OW 3
31266: ST_TO_ADDR
// end else
31267: GO 31294
// tab := Replace ( tab , i , tmp ) ;
31269: LD_ADDR_VAR 0 1
31273: PUSH
31274: LD_VAR 0 1
31278: PPUSH
31279: LD_VAR 0 5
31283: PPUSH
31284: LD_VAR 0 7
31288: PPUSH
31289: CALL_OW 1
31293: ST_TO_ADDR
// i := i - 1 ;
31294: LD_ADDR_VAR 0 5
31298: PUSH
31299: LD_VAR 0 5
31303: PUSH
31304: LD_INT 1
31306: MINUS
31307: ST_TO_ADDR
// if mode then
31308: LD_VAR 0 3
31312: IFFALSE 31316
// break ;
31314: GO 31332
// end ; i := i + 1 ;
31316: LD_ADDR_VAR 0 5
31320: PUSH
31321: LD_VAR 0 5
31325: PUSH
31326: LD_INT 1
31328: PLUS
31329: ST_TO_ADDR
// end ;
31330: GO 30947
// result := tab ;
31332: LD_ADDR_VAR 0 4
31336: PUSH
31337: LD_VAR 0 1
31341: ST_TO_ADDR
// end ;
31342: LD_VAR 0 4
31346: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31347: LD_INT 0
31349: PPUSH
31350: PPUSH
// for i = 1 to values do
31351: LD_ADDR_VAR 0 4
31355: PUSH
31356: DOUBLE
31357: LD_INT 1
31359: DEC
31360: ST_TO_ADDR
31361: LD_VAR 0 2
31365: PUSH
31366: FOR_TO
31367: IFFALSE 31400
// tab := Remove ( tab , values [ i ] , false ) ;
31369: LD_ADDR_VAR 0 1
31373: PUSH
31374: LD_VAR 0 1
31378: PPUSH
31379: LD_VAR 0 2
31383: PUSH
31384: LD_VAR 0 4
31388: ARRAY
31389: PPUSH
31390: LD_INT 0
31392: PPUSH
31393: CALL 30933 0 3
31397: ST_TO_ADDR
31398: GO 31366
31400: POP
31401: POP
// result := tab ;
31402: LD_ADDR_VAR 0 3
31406: PUSH
31407: LD_VAR 0 1
31411: ST_TO_ADDR
// end ;
31412: LD_VAR 0 3
31416: RET
// export function IsDriver ( unit ) ; begin
31417: LD_INT 0
31419: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31420: LD_VAR 0 1
31424: PUSH
31425: LD_INT 55
31427: PUSH
31428: EMPTY
31429: LIST
31430: PPUSH
31431: CALL_OW 69
31435: IN
31436: IFFALSE 31455
// result := IsInUnit ( unit ) else
31438: LD_ADDR_VAR 0 2
31442: PUSH
31443: LD_VAR 0 1
31447: PPUSH
31448: CALL_OW 310
31452: ST_TO_ADDR
31453: GO 31463
// result := false ;
31455: LD_ADDR_VAR 0 2
31459: PUSH
31460: LD_INT 0
31462: ST_TO_ADDR
// end ;
31463: LD_VAR 0 2
31467: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31468: LD_INT 0
31470: PPUSH
31471: PPUSH
31472: PPUSH
// if not GetControl ( veh ) = control_manual then
31473: LD_VAR 0 1
31477: PPUSH
31478: CALL_OW 263
31482: PUSH
31483: LD_INT 1
31485: EQUAL
31486: NOT
31487: IFFALSE 31499
// result := false else
31489: LD_ADDR_VAR 0 2
31493: PUSH
31494: LD_INT 0
31496: ST_TO_ADDR
31497: GO 31644
// if veh in FilterAllUnits ( [ f_empty ] ) then
31499: LD_VAR 0 1
31503: PUSH
31504: LD_INT 58
31506: PUSH
31507: EMPTY
31508: LIST
31509: PPUSH
31510: CALL_OW 69
31514: IN
31515: IFFALSE 31527
// result := false else
31517: LD_ADDR_VAR 0 2
31521: PUSH
31522: LD_INT 0
31524: ST_TO_ADDR
31525: GO 31644
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31527: LD_ADDR_VAR 0 4
31531: PUSH
31532: LD_INT 22
31534: PUSH
31535: LD_VAR 0 1
31539: PPUSH
31540: CALL_OW 255
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 55
31551: PUSH
31552: EMPTY
31553: LIST
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PPUSH
31559: CALL_OW 69
31563: ST_TO_ADDR
// if not filter then
31564: LD_VAR 0 4
31568: NOT
31569: IFFALSE 31581
// result := false else
31571: LD_ADDR_VAR 0 2
31575: PUSH
31576: LD_INT 0
31578: ST_TO_ADDR
31579: GO 31644
// for i = 1 to filter do
31581: LD_ADDR_VAR 0 3
31585: PUSH
31586: DOUBLE
31587: LD_INT 1
31589: DEC
31590: ST_TO_ADDR
31591: LD_VAR 0 4
31595: PUSH
31596: FOR_TO
31597: IFFALSE 31642
// if IsDriver ( filter [ i ] ) = veh then
31599: LD_VAR 0 4
31603: PUSH
31604: LD_VAR 0 3
31608: ARRAY
31609: PPUSH
31610: CALL 31417 0 1
31614: PUSH
31615: LD_VAR 0 1
31619: EQUAL
31620: IFFALSE 31640
// begin result := filter [ i ] ;
31622: LD_ADDR_VAR 0 2
31626: PUSH
31627: LD_VAR 0 4
31631: PUSH
31632: LD_VAR 0 3
31636: ARRAY
31637: ST_TO_ADDR
// break ;
31638: GO 31642
// end ;
31640: GO 31596
31642: POP
31643: POP
// end ; end ;
31644: LD_VAR 0 2
31648: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31649: LD_INT 0
31651: PPUSH
31652: PPUSH
// if BuildingStatus ( b ) = bs_build then
31653: LD_VAR 0 2
31657: PPUSH
31658: CALL_OW 461
31662: PUSH
31663: LD_INT 1
31665: EQUAL
31666: IFFALSE 31726
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31668: LD_VAR 0 1
31672: PPUSH
31673: LD_STRING h
31675: PUSH
31676: LD_VAR 0 2
31680: PPUSH
31681: CALL_OW 250
31685: PUSH
31686: LD_VAR 0 2
31690: PPUSH
31691: CALL_OW 251
31695: PUSH
31696: LD_VAR 0 2
31700: PUSH
31701: LD_INT 0
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: PUSH
31719: EMPTY
31720: LIST
31721: PPUSH
31722: CALL_OW 446
// end ;
31726: LD_VAR 0 3
31730: RET
// export function Compare ( val1 , val2 ) ; begin
31731: LD_INT 0
31733: PPUSH
// if val1 = val2 then
31734: LD_VAR 0 1
31738: PUSH
31739: LD_VAR 0 2
31743: EQUAL
31744: IFFALSE 31756
// result := true else
31746: LD_ADDR_VAR 0 3
31750: PUSH
31751: LD_INT 1
31753: ST_TO_ADDR
31754: GO 31764
// result := false ;
31756: LD_ADDR_VAR 0 3
31760: PUSH
31761: LD_INT 0
31763: ST_TO_ADDR
// end ;
31764: LD_VAR 0 3
31768: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31769: LD_INT 0
31771: PPUSH
31772: PPUSH
// result := true ;
31773: LD_ADDR_VAR 0 3
31777: PUSH
31778: LD_INT 1
31780: ST_TO_ADDR
// if array1 = array2 then
31781: LD_VAR 0 1
31785: PUSH
31786: LD_VAR 0 2
31790: EQUAL
31791: IFFALSE 31856
// begin for i = 1 to array1 do
31793: LD_ADDR_VAR 0 4
31797: PUSH
31798: DOUBLE
31799: LD_INT 1
31801: DEC
31802: ST_TO_ADDR
31803: LD_VAR 0 1
31807: PUSH
31808: FOR_TO
31809: IFFALSE 31852
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
31811: LD_VAR 0 1
31815: PUSH
31816: LD_VAR 0 4
31820: ARRAY
31821: PPUSH
31822: LD_VAR 0 2
31826: PUSH
31827: LD_VAR 0 4
31831: ARRAY
31832: PPUSH
31833: CALL 31731 0 2
31837: NOT
31838: IFFALSE 31850
// begin result := false ;
31840: LD_ADDR_VAR 0 3
31844: PUSH
31845: LD_INT 0
31847: ST_TO_ADDR
// break ;
31848: GO 31852
// end ;
31850: GO 31808
31852: POP
31853: POP
// end else
31854: GO 31864
// result := false ;
31856: LD_ADDR_VAR 0 3
31860: PUSH
31861: LD_INT 0
31863: ST_TO_ADDR
// end ;
31864: LD_VAR 0 3
31868: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31869: LD_INT 0
31871: PPUSH
31872: PPUSH
// result := false ;
31873: LD_ADDR_VAR 0 3
31877: PUSH
31878: LD_INT 0
31880: ST_TO_ADDR
// for j = 1 to e2 do
31881: LD_ADDR_VAR 0 4
31885: PUSH
31886: DOUBLE
31887: LD_INT 1
31889: DEC
31890: ST_TO_ADDR
31891: LD_VAR 0 2
31895: PUSH
31896: FOR_TO
31897: IFFALSE 31931
// if Compare ( e1 , e2 [ j ] ) then
31899: LD_VAR 0 1
31903: PPUSH
31904: LD_VAR 0 2
31908: PUSH
31909: LD_VAR 0 4
31913: ARRAY
31914: PPUSH
31915: CALL 31731 0 2
31919: IFFALSE 31929
// result := true ;
31921: LD_ADDR_VAR 0 3
31925: PUSH
31926: LD_INT 1
31928: ST_TO_ADDR
31929: GO 31896
31931: POP
31932: POP
// end ;
31933: LD_VAR 0 3
31937: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
31938: LD_INT 0
31940: PPUSH
31941: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
31942: LD_VAR 0 1
31946: PPUSH
31947: LD_STRING C
31949: PUSH
31950: LD_VAR 0 2
31954: PUSH
31955: LD_VAR 0 3
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: LD_INT 0
31965: PUSH
31966: LD_INT 0
31968: PUSH
31969: LD_INT 0
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: LIST
31976: LIST
31977: LIST
31978: LIST
31979: LIST
31980: PUSH
31981: LD_STRING v
31983: PUSH
31984: LD_VAR 0 4
31988: PPUSH
31989: CALL_OW 250
31993: PUSH
31994: LD_VAR 0 4
31998: PPUSH
31999: CALL_OW 251
32003: PUSH
32004: LD_VAR 0 4
32008: PUSH
32009: LD_INT 0
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PPUSH
32031: CALL_OW 446
// end ;
32035: LD_VAR 0 5
32039: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32040: LD_INT 0
32042: PPUSH
32043: PPUSH
32044: PPUSH
// linked := UnitsLinked ( unit ) ;
32045: LD_ADDR_VAR 0 4
32049: PUSH
32050: LD_VAR 0 1
32054: PPUSH
32055: CALL_OW 432
32059: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32060: LD_ADDR_VAR 0 3
32064: PUSH
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_INT 3
32072: PPUSH
32073: CALL_OW 259
32077: ST_TO_ADDR
// if sk > linked then
32078: LD_VAR 0 3
32082: PUSH
32083: LD_VAR 0 4
32087: GREATER
32088: IFFALSE 32100
// result := true else
32090: LD_ADDR_VAR 0 2
32094: PUSH
32095: LD_INT 1
32097: ST_TO_ADDR
32098: GO 32108
// result := false ;
32100: LD_ADDR_VAR 0 2
32104: PUSH
32105: LD_INT 0
32107: ST_TO_ADDR
// end ;
32108: LD_VAR 0 2
32112: RET
// export function NotTask ( unit ) ; begin
32113: LD_INT 0
32115: PPUSH
// result := true ;
32116: LD_ADDR_VAR 0 2
32120: PUSH
32121: LD_INT 1
32123: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32124: LD_VAR 0 1
32128: PPUSH
32129: CALL_OW 437
32133: PUSH
32134: LD_VAR 0 1
32138: PPUSH
32139: CALL_OW 314
32143: OR
32144: IFFALSE 32154
// result := false ;
32146: LD_ADDR_VAR 0 2
32150: PUSH
32151: LD_INT 0
32153: ST_TO_ADDR
// end ;
32154: LD_VAR 0 2
32158: RET
// export function WantHeal ( sci , unit ) ; begin
32159: LD_INT 0
32161: PPUSH
// if GetTaskList ( sci ) > 0 then
32162: LD_VAR 0 1
32166: PPUSH
32167: CALL_OW 437
32171: PUSH
32172: LD_INT 0
32174: GREATER
32175: IFFALSE 32245
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32177: LD_VAR 0 1
32181: PPUSH
32182: CALL_OW 437
32186: PUSH
32187: LD_INT 1
32189: ARRAY
32190: PUSH
32191: LD_INT 1
32193: ARRAY
32194: PUSH
32195: LD_STRING l
32197: EQUAL
32198: PUSH
32199: LD_VAR 0 1
32203: PPUSH
32204: CALL_OW 437
32208: PUSH
32209: LD_INT 1
32211: ARRAY
32212: PUSH
32213: LD_INT 4
32215: ARRAY
32216: PUSH
32217: LD_VAR 0 2
32221: EQUAL
32222: AND
32223: IFFALSE 32235
// result := true else
32225: LD_ADDR_VAR 0 3
32229: PUSH
32230: LD_INT 1
32232: ST_TO_ADDR
32233: GO 32243
// result := false ;
32235: LD_ADDR_VAR 0 3
32239: PUSH
32240: LD_INT 0
32242: ST_TO_ADDR
// end else
32243: GO 32253
// result := false ;
32245: LD_ADDR_VAR 0 3
32249: PUSH
32250: LD_INT 0
32252: ST_TO_ADDR
// end ;
32253: LD_VAR 0 3
32257: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32258: LD_INT 0
32260: PPUSH
32261: PPUSH
32262: PPUSH
32263: PPUSH
32264: PPUSH
// dist := 99999 ;
32265: LD_ADDR_VAR 0 7
32269: PUSH
32270: LD_INT 99999
32272: ST_TO_ADDR
// un := - 1 ;
32273: LD_ADDR_VAR 0 6
32277: PUSH
32278: LD_INT 1
32280: NEG
32281: ST_TO_ADDR
// if units1 and units2 then
32282: LD_VAR 0 1
32286: PUSH
32287: LD_VAR 0 2
32291: AND
32292: IFFALSE 32380
// for i in units1 do
32294: LD_ADDR_VAR 0 4
32298: PUSH
32299: LD_VAR 0 1
32303: PUSH
32304: FOR_IN
32305: IFFALSE 32378
// for j in units2 do
32307: LD_ADDR_VAR 0 5
32311: PUSH
32312: LD_VAR 0 2
32316: PUSH
32317: FOR_IN
32318: IFFALSE 32374
// if GetDistUnits ( i , j ) < dist then
32320: LD_VAR 0 4
32324: PPUSH
32325: LD_VAR 0 5
32329: PPUSH
32330: CALL_OW 296
32334: PUSH
32335: LD_VAR 0 7
32339: LESS
32340: IFFALSE 32372
// begin un := i ;
32342: LD_ADDR_VAR 0 6
32346: PUSH
32347: LD_VAR 0 4
32351: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32352: LD_ADDR_VAR 0 7
32356: PUSH
32357: LD_VAR 0 4
32361: PPUSH
32362: LD_VAR 0 5
32366: PPUSH
32367: CALL_OW 296
32371: ST_TO_ADDR
// end ;
32372: GO 32317
32374: POP
32375: POP
32376: GO 32304
32378: POP
32379: POP
// result := [ un , dist ] ;
32380: LD_ADDR_VAR 0 3
32384: PUSH
32385: LD_VAR 0 6
32389: PUSH
32390: LD_VAR 0 7
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: ST_TO_ADDR
// end ;
32399: LD_VAR 0 3
32403: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32404: LD_INT 0
32406: PPUSH
32407: PPUSH
32408: PPUSH
32409: PPUSH
32410: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32411: LD_VAR 0 1
32415: NOT
32416: PUSH
32417: LD_VAR 0 1
32421: PPUSH
32422: CALL_OW 256
32426: PUSH
32427: LD_INT 250
32429: LESS
32430: OR
32431: PUSH
32432: LD_VAR 0 1
32436: PPUSH
32437: CALL_OW 314
32441: PUSH
32442: LD_VAR 0 1
32446: PPUSH
32447: CALL_OW 261
32451: PUSH
32452: LD_INT 20
32454: GREATER
32455: AND
32456: OR
32457: IFFALSE 32461
// exit ;
32459: GO 32835
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32461: LD_VAR 0 1
32465: PPUSH
32466: CALL_OW 261
32470: PUSH
32471: LD_INT 20
32473: LESS
32474: PUSH
32475: LD_VAR 0 1
32479: PPUSH
32480: CALL_OW 110
32484: PUSH
32485: LD_INT 21
32487: EQUAL
32488: NOT
32489: AND
32490: IFFALSE 32526
// begin ComStop ( bulldozer ) ;
32492: LD_VAR 0 1
32496: PPUSH
32497: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32501: LD_VAR 0 1
32505: PPUSH
32506: LD_INT 21
32508: PPUSH
32509: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32513: LD_VAR 0 1
32517: PPUSH
32518: CALL 26038 0 1
// exit ;
32522: GO 32835
// end else
32524: GO 32553
// if GetFuel ( bulldozer ) > 20 then
32526: LD_VAR 0 1
32530: PPUSH
32531: CALL_OW 261
32535: PUSH
32536: LD_INT 20
32538: GREATER
32539: IFFALSE 32553
// SetTag ( bulldozer , 0 ) ;
32541: LD_VAR 0 1
32545: PPUSH
32546: LD_INT 0
32548: PPUSH
32549: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32553: LD_ADDR_VAR 0 5
32557: PUSH
32558: LD_VAR 0 2
32562: PPUSH
32563: CALL_OW 353
32567: ST_TO_ADDR
// tmp := [ ] ;
32568: LD_ADDR_VAR 0 6
32572: PUSH
32573: EMPTY
32574: ST_TO_ADDR
// for i = 1 to list do
32575: LD_ADDR_VAR 0 4
32579: PUSH
32580: DOUBLE
32581: LD_INT 1
32583: DEC
32584: ST_TO_ADDR
32585: LD_VAR 0 5
32589: PUSH
32590: FOR_TO
32591: IFFALSE 32689
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32593: LD_VAR 0 5
32597: PUSH
32598: LD_VAR 0 4
32602: ARRAY
32603: PUSH
32604: LD_INT 1
32606: ARRAY
32607: PPUSH
32608: LD_VAR 0 5
32612: PUSH
32613: LD_VAR 0 4
32617: ARRAY
32618: PUSH
32619: LD_INT 2
32621: ARRAY
32622: PPUSH
32623: CALL_OW 554
32627: IFFALSE 32687
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32629: LD_ADDR_VAR 0 6
32633: PUSH
32634: LD_VAR 0 6
32638: PPUSH
32639: LD_VAR 0 6
32643: PUSH
32644: LD_INT 1
32646: PLUS
32647: PPUSH
32648: LD_VAR 0 5
32652: PUSH
32653: LD_VAR 0 4
32657: ARRAY
32658: PUSH
32659: LD_INT 1
32661: ARRAY
32662: PUSH
32663: LD_VAR 0 5
32667: PUSH
32668: LD_VAR 0 4
32672: ARRAY
32673: PUSH
32674: LD_INT 2
32676: ARRAY
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PPUSH
32682: CALL_OW 1
32686: ST_TO_ADDR
// end ;
32687: GO 32590
32689: POP
32690: POP
// ComStop ( bulldozer ) ;
32691: LD_VAR 0 1
32695: PPUSH
32696: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32700: LD_ADDR_VAR 0 7
32704: PUSH
32705: LD_VAR 0 1
32709: PPUSH
32710: CALL_OW 250
32714: PUSH
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 251
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: ST_TO_ADDR
// for i = tmp downto 1 do
32729: LD_ADDR_VAR 0 4
32733: PUSH
32734: DOUBLE
32735: LD_VAR 0 6
32739: INC
32740: ST_TO_ADDR
32741: LD_INT 1
32743: PUSH
32744: FOR_DOWNTO
32745: IFFALSE 32833
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32747: LD_ADDR_VAR 0 7
32751: PUSH
32752: LD_VAR 0 7
32756: PUSH
32757: LD_INT 1
32759: ARRAY
32760: PPUSH
32761: LD_VAR 0 7
32765: PUSH
32766: LD_INT 2
32768: ARRAY
32769: PPUSH
32770: LD_VAR 0 6
32774: PPUSH
32775: CALL 32936 0 3
32779: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32780: LD_VAR 0 1
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 1
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 7
32798: PUSH
32799: LD_INT 2
32801: ARRAY
32802: PPUSH
32803: CALL 32840 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32807: LD_ADDR_VAR 0 6
32811: PUSH
32812: LD_VAR 0 6
32816: PPUSH
32817: LD_VAR 0 7
32821: PUSH
32822: LD_INT 3
32824: ARRAY
32825: PPUSH
32826: CALL_OW 3
32830: ST_TO_ADDR
// end ;
32831: GO 32744
32833: POP
32834: POP
// end ;
32835: LD_VAR 0 3
32839: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32840: LD_INT 0
32842: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32843: LD_VAR 0 2
32847: PPUSH
32848: LD_VAR 0 3
32852: PPUSH
32853: CALL_OW 351
32857: PUSH
32858: LD_VAR 0 2
32862: PPUSH
32863: LD_VAR 0 3
32867: PPUSH
32868: CALL_OW 554
32872: AND
32873: PUSH
32874: LD_VAR 0 2
32878: PPUSH
32879: LD_VAR 0 3
32883: PPUSH
32884: CALL_OW 488
32888: AND
32889: PUSH
32890: LD_VAR 0 2
32894: PPUSH
32895: LD_VAR 0 3
32899: PPUSH
32900: CALL_OW 428
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: EQUAL
32909: AND
32910: IFFALSE 32931
// AddComMoveXY ( bulldozer , x , y ) ;
32912: LD_VAR 0 1
32916: PPUSH
32917: LD_VAR 0 2
32921: PPUSH
32922: LD_VAR 0 3
32926: PPUSH
32927: CALL_OW 171
// end ;
32931: LD_VAR 0 4
32935: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32936: LD_INT 0
32938: PPUSH
32939: PPUSH
32940: PPUSH
32941: PPUSH
32942: PPUSH
32943: PPUSH
32944: PPUSH
// dist := 99999 ;
32945: LD_ADDR_VAR 0 6
32949: PUSH
32950: LD_INT 99999
32952: ST_TO_ADDR
// for i = 1 to list do
32953: LD_ADDR_VAR 0 5
32957: PUSH
32958: DOUBLE
32959: LD_INT 1
32961: DEC
32962: ST_TO_ADDR
32963: LD_VAR 0 3
32967: PUSH
32968: FOR_TO
32969: IFFALSE 33107
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32971: LD_ADDR_VAR 0 7
32975: PUSH
32976: LD_VAR 0 1
32980: PPUSH
32981: LD_VAR 0 2
32985: PPUSH
32986: LD_VAR 0 3
32990: PUSH
32991: LD_VAR 0 5
32995: ARRAY
32996: PUSH
32997: LD_INT 1
32999: ARRAY
33000: PPUSH
33001: LD_VAR 0 3
33005: PUSH
33006: LD_VAR 0 5
33010: ARRAY
33011: PUSH
33012: LD_INT 2
33014: ARRAY
33015: PPUSH
33016: CALL_OW 298
33020: ST_TO_ADDR
// if d = 0 then
33021: LD_VAR 0 7
33025: PUSH
33026: LD_INT 0
33028: EQUAL
33029: IFFALSE 33033
// continue ;
33031: GO 32968
// if d < dist then
33033: LD_VAR 0 7
33037: PUSH
33038: LD_VAR 0 6
33042: LESS
33043: IFFALSE 33105
// begin _x := list [ i ] [ 1 ] ;
33045: LD_ADDR_VAR 0 8
33049: PUSH
33050: LD_VAR 0 3
33054: PUSH
33055: LD_VAR 0 5
33059: ARRAY
33060: PUSH
33061: LD_INT 1
33063: ARRAY
33064: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33065: LD_ADDR_VAR 0 9
33069: PUSH
33070: LD_VAR 0 3
33074: PUSH
33075: LD_VAR 0 5
33079: ARRAY
33080: PUSH
33081: LD_INT 2
33083: ARRAY
33084: ST_TO_ADDR
// _i := i ;
33085: LD_ADDR_VAR 0 10
33089: PUSH
33090: LD_VAR 0 5
33094: ST_TO_ADDR
// dist := d ;
33095: LD_ADDR_VAR 0 6
33099: PUSH
33100: LD_VAR 0 7
33104: ST_TO_ADDR
// end ; end ;
33105: GO 32968
33107: POP
33108: POP
// result := [ _x , _y , _i , dist ] ;
33109: LD_ADDR_VAR 0 4
33113: PUSH
33114: LD_VAR 0 8
33118: PUSH
33119: LD_VAR 0 9
33123: PUSH
33124: LD_VAR 0 10
33128: PUSH
33129: LD_VAR 0 6
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: ST_TO_ADDR
// end ;
33140: LD_VAR 0 4
33144: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33145: LD_INT 0
33147: PPUSH
33148: PPUSH
33149: PPUSH
33150: PPUSH
33151: PPUSH
// for i = 1 to list do
33152: LD_ADDR_VAR 0 5
33156: PUSH
33157: DOUBLE
33158: LD_INT 1
33160: DEC
33161: ST_TO_ADDR
33162: LD_VAR 0 1
33166: PUSH
33167: FOR_TO
33168: IFFALSE 33482
// begin for j = list downto 2 do
33170: LD_ADDR_VAR 0 6
33174: PUSH
33175: DOUBLE
33176: LD_VAR 0 1
33180: INC
33181: ST_TO_ADDR
33182: LD_INT 2
33184: PUSH
33185: FOR_DOWNTO
33186: IFFALSE 33478
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33188: LD_VAR 0 2
33192: PPUSH
33193: LD_VAR 0 3
33197: PPUSH
33198: LD_VAR 0 1
33202: PUSH
33203: LD_VAR 0 6
33207: ARRAY
33208: PUSH
33209: LD_INT 1
33211: ARRAY
33212: PPUSH
33213: LD_VAR 0 1
33217: PUSH
33218: LD_VAR 0 6
33222: ARRAY
33223: PUSH
33224: LD_INT 2
33226: ARRAY
33227: PPUSH
33228: CALL_OW 298
33232: PUSH
33233: LD_VAR 0 2
33237: PPUSH
33238: LD_VAR 0 3
33242: PPUSH
33243: LD_VAR 0 1
33247: PUSH
33248: LD_VAR 0 6
33252: PUSH
33253: LD_INT 1
33255: MINUS
33256: ARRAY
33257: PUSH
33258: LD_INT 1
33260: ARRAY
33261: PPUSH
33262: LD_VAR 0 1
33266: PUSH
33267: LD_VAR 0 6
33271: PUSH
33272: LD_INT 1
33274: MINUS
33275: ARRAY
33276: PUSH
33277: LD_INT 2
33279: ARRAY
33280: PPUSH
33281: CALL_OW 298
33285: LESS
33286: IFFALSE 33476
// begin _x := list [ j ] [ 1 ] ;
33288: LD_ADDR_VAR 0 7
33292: PUSH
33293: LD_VAR 0 1
33297: PUSH
33298: LD_VAR 0 6
33302: ARRAY
33303: PUSH
33304: LD_INT 1
33306: ARRAY
33307: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33308: LD_ADDR_VAR 0 8
33312: PUSH
33313: LD_VAR 0 1
33317: PUSH
33318: LD_VAR 0 6
33322: ARRAY
33323: PUSH
33324: LD_INT 2
33326: ARRAY
33327: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33328: LD_ADDR_VAR 0 1
33332: PUSH
33333: LD_VAR 0 1
33337: PPUSH
33338: LD_VAR 0 6
33342: PPUSH
33343: LD_INT 1
33345: PPUSH
33346: LD_VAR 0 1
33350: PUSH
33351: LD_VAR 0 6
33355: PUSH
33356: LD_INT 1
33358: MINUS
33359: ARRAY
33360: PUSH
33361: LD_INT 1
33363: ARRAY
33364: PPUSH
33365: CALL 30774 0 4
33369: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33370: LD_ADDR_VAR 0 1
33374: PUSH
33375: LD_VAR 0 1
33379: PPUSH
33380: LD_VAR 0 6
33384: PPUSH
33385: LD_INT 2
33387: PPUSH
33388: LD_VAR 0 1
33392: PUSH
33393: LD_VAR 0 6
33397: PUSH
33398: LD_INT 1
33400: MINUS
33401: ARRAY
33402: PUSH
33403: LD_INT 2
33405: ARRAY
33406: PPUSH
33407: CALL 30774 0 4
33411: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33412: LD_ADDR_VAR 0 1
33416: PUSH
33417: LD_VAR 0 1
33421: PPUSH
33422: LD_VAR 0 6
33426: PUSH
33427: LD_INT 1
33429: MINUS
33430: PPUSH
33431: LD_INT 1
33433: PPUSH
33434: LD_VAR 0 7
33438: PPUSH
33439: CALL 30774 0 4
33443: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33444: LD_ADDR_VAR 0 1
33448: PUSH
33449: LD_VAR 0 1
33453: PPUSH
33454: LD_VAR 0 6
33458: PUSH
33459: LD_INT 1
33461: MINUS
33462: PPUSH
33463: LD_INT 2
33465: PPUSH
33466: LD_VAR 0 8
33470: PPUSH
33471: CALL 30774 0 4
33475: ST_TO_ADDR
// end ; end ;
33476: GO 33185
33478: POP
33479: POP
// end ;
33480: GO 33167
33482: POP
33483: POP
// result := list ;
33484: LD_ADDR_VAR 0 4
33488: PUSH
33489: LD_VAR 0 1
33493: ST_TO_ADDR
// end ;
33494: LD_VAR 0 4
33498: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33499: LD_INT 0
33501: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_VAR 0 1
33511: PPUSH
33512: LD_VAR 0 2
33516: PPUSH
33517: CALL_OW 546
33521: PUSH
33522: LD_INT 2
33524: ARRAY
33525: PUSH
33526: LD_VAR 0 3
33530: PPUSH
33531: LD_VAR 0 4
33535: PPUSH
33536: CALL_OW 546
33540: PUSH
33541: LD_INT 2
33543: ARRAY
33544: MINUS
33545: ST_TO_ADDR
// if result < 0 then
33546: LD_VAR 0 5
33550: PUSH
33551: LD_INT 0
33553: LESS
33554: IFFALSE 33571
// result := result * - 1 ;
33556: LD_ADDR_VAR 0 5
33560: PUSH
33561: LD_VAR 0 5
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: MUL
33570: ST_TO_ADDR
// end ;
33571: LD_VAR 0 5
33575: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33576: LD_INT 0
33578: PPUSH
33579: PPUSH
// area = ListEnvironmentArea ( area ) ;
33580: LD_ADDR_VAR 0 2
33584: PUSH
33585: LD_VAR 0 2
33589: PPUSH
33590: CALL_OW 353
33594: ST_TO_ADDR
// if bulldozer > 0 then
33595: LD_VAR 0 1
33599: PUSH
33600: LD_INT 0
33602: GREATER
33603: IFFALSE 33714
// for i = area downto 1 do
33605: LD_ADDR_VAR 0 4
33609: PUSH
33610: DOUBLE
33611: LD_VAR 0 2
33615: INC
33616: ST_TO_ADDR
33617: LD_INT 1
33619: PUSH
33620: FOR_DOWNTO
33621: IFFALSE 33712
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33623: LD_VAR 0 2
33627: PUSH
33628: LD_VAR 0 4
33632: ARRAY
33633: PUSH
33634: LD_INT 1
33636: ARRAY
33637: PPUSH
33638: LD_VAR 0 2
33642: PUSH
33643: LD_VAR 0 4
33647: ARRAY
33648: PUSH
33649: LD_INT 2
33651: ARRAY
33652: PPUSH
33653: CALL_OW 351
33657: IFFALSE 33710
// if not HasTask ( bulldozer ) then
33659: LD_VAR 0 1
33663: PPUSH
33664: CALL_OW 314
33668: NOT
33669: IFFALSE 33710
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33671: LD_VAR 0 1
33675: PPUSH
33676: LD_VAR 0 2
33680: PUSH
33681: LD_VAR 0 4
33685: ARRAY
33686: PUSH
33687: LD_INT 1
33689: ARRAY
33690: PPUSH
33691: LD_VAR 0 2
33695: PUSH
33696: LD_VAR 0 4
33700: ARRAY
33701: PUSH
33702: LD_INT 2
33704: ARRAY
33705: PPUSH
33706: CALL_OW 171
33710: GO 33620
33712: POP
33713: POP
// end ;
33714: LD_VAR 0 3
33718: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33719: LD_INT 0
33721: PPUSH
33722: PPUSH
33723: PPUSH
33724: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33725: LD_ADDR_VAR 0 6
33729: PUSH
33730: LD_INT 22
33732: PUSH
33733: LD_VAR 0 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 21
33744: PUSH
33745: LD_VAR 0 2
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PPUSH
33758: CALL_OW 69
33762: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33763: LD_ADDR_VAR 0 7
33767: PUSH
33768: LD_VAR 0 3
33772: PPUSH
33773: LD_INT 22
33775: PUSH
33776: LD_VAR 0 1
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 21
33787: PUSH
33788: LD_VAR 0 2
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PPUSH
33801: CALL_OW 70
33805: ST_TO_ADDR
// if tmp and pom then
33806: LD_VAR 0 6
33810: PUSH
33811: LD_VAR 0 7
33815: AND
33816: IFFALSE 33836
// result := tmp diff pom else
33818: LD_ADDR_VAR 0 4
33822: PUSH
33823: LD_VAR 0 6
33827: PUSH
33828: LD_VAR 0 7
33832: DIFF
33833: ST_TO_ADDR
33834: GO 33844
// result := false ;
33836: LD_ADDR_VAR 0 4
33840: PUSH
33841: LD_INT 0
33843: ST_TO_ADDR
// end ;
33844: LD_VAR 0 4
33848: RET
// export function SavePosition ( unit ) ; begin
33849: LD_INT 0
33851: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33852: LD_VAR 0 1
33856: PPUSH
33857: LD_VAR 0 1
33861: PPUSH
33862: CALL_OW 250
33866: PPUSH
33867: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33871: LD_VAR 0 1
33875: PPUSH
33876: LD_VAR 0 1
33880: PPUSH
33881: CALL_OW 251
33885: PPUSH
33886: CALL_OW 232
// end ;
33890: LD_VAR 0 2
33894: RET
// export function GetPosition ( unit ) ; begin
33895: LD_INT 0
33897: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33898: LD_ADDR_VAR 0 2
33902: PUSH
33903: LD_VAR 0 1
33907: PPUSH
33908: CALL_OW 252
33912: PUSH
33913: LD_VAR 0 1
33917: PPUSH
33918: CALL_OW 253
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: ST_TO_ADDR
// end ;
33927: LD_VAR 0 2
33931: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33932: LD_INT 0
33934: PPUSH
// if unit in unreachableList then
33935: LD_VAR 0 1
33939: PUSH
33940: LD_EXP 32
33944: IN
33945: IFFALSE 33963
// unreachableList := unreachableList diff unit ;
33947: LD_ADDR_EXP 32
33951: PUSH
33952: LD_EXP 32
33956: PUSH
33957: LD_VAR 0 1
33961: DIFF
33962: ST_TO_ADDR
// if ValidHex ( x , y ) then
33963: LD_VAR 0 2
33967: PPUSH
33968: LD_VAR 0 3
33972: PPUSH
33973: CALL_OW 488
33977: IFFALSE 34003
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33979: LD_VAR 0 1
33983: PPUSH
33984: LD_VAR 0 2
33988: PPUSH
33989: LD_VAR 0 3
33993: PPUSH
33994: CALL_OW 428
33998: PPUSH
33999: CALL_OW 115
// Wait ( 3 ) ;
34003: LD_INT 3
34005: PPUSH
34006: CALL_OW 67
// if unit in unreachableList then
34010: LD_VAR 0 1
34014: PUSH
34015: LD_EXP 32
34019: IN
34020: IFFALSE 34032
// result := false else
34022: LD_ADDR_VAR 0 4
34026: PUSH
34027: LD_INT 0
34029: ST_TO_ADDR
34030: GO 34040
// result := true ;
34032: LD_ADDR_VAR 0 4
34036: PUSH
34037: LD_INT 1
34039: ST_TO_ADDR
// end ; end_of_file
34040: LD_VAR 0 4
34044: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34045: LD_EXP 33
34049: IFFALSE 34111
34051: GO 34053
34053: DISABLE
34054: LD_INT 0
34056: PPUSH
// begin enable ;
34057: ENABLE
// for i = 1 to mc_crates_list do
34058: LD_ADDR_VAR 0 1
34062: PUSH
34063: DOUBLE
34064: LD_INT 1
34066: DEC
34067: ST_TO_ADDR
34068: LD_EXP 34
34072: PUSH
34073: FOR_TO
34074: IFFALSE 34105
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34076: LD_EXP 34
34080: PUSH
34081: LD_VAR 0 1
34085: ARRAY
34086: PPUSH
34087: LD_INT 5
34089: PPUSH
34090: LD_INT 50
34092: PPUSH
34093: LD_INT 700
34095: PPUSH
34096: LD_INT 20
34098: PPUSH
34099: CALL 24220 0 5
34103: GO 34073
34105: POP
34106: POP
// MC_Game ( ) ;
34107: CALL 34114 0 0
// end ;
34111: PPOPN 1
34113: END
// export function MC_Game ( ) ; var i , side , un ; begin
34114: LD_INT 0
34116: PPUSH
34117: PPUSH
34118: PPUSH
34119: PPUSH
// if not isTest then
34120: LD_EXP 1
34124: NOT
34125: IFFALSE 34145
// MC_Show ( [ #tick , tick ] ) else
34127: LD_STRING #tick
34129: PUSH
34130: LD_OWVAR 1
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PPUSH
34139: CALL 8258 0 1
34143: GO 34154
// MC_Show ( debug_string ) ;
34145: LD_EXP 2
34149: PPUSH
34150: CALL 8258 0 1
// for side = 1 to 8 do
34154: LD_ADDR_VAR 0 3
34158: PUSH
34159: DOUBLE
34160: LD_INT 1
34162: DEC
34163: ST_TO_ADDR
34164: LD_INT 8
34166: PUSH
34167: FOR_TO
34168: IFFALSE 36168
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34170: LD_EXP 41
34174: PUSH
34175: LD_VAR 0 3
34179: ARRAY
34180: PUSH
34181: LD_INT 0
34183: EQUAL
34184: PUSH
34185: LD_VAR 0 3
34189: PPUSH
34190: EMPTY
34191: PPUSH
34192: CALL 11475 0 2
34196: PUSH
34197: LD_INT 0
34199: EQUAL
34200: OR
34201: IFFALSE 34205
// continue ;
34203: GO 34167
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34205: LD_VAR 0 3
34209: PPUSH
34210: LD_VAR 0 3
34214: PPUSH
34215: CALL 24741 0 1
34219: PPUSH
34220: CALL 36175 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34224: LD_EXP 73
34228: PUSH
34229: LD_VAR 0 3
34233: ARRAY
34234: PUSH
34235: LD_INT 1
34237: ARRAY
34238: PUSH
34239: LD_INT 0
34241: GREATER
34242: PUSH
34243: LD_EXP 71
34247: PUSH
34248: LD_VAR 0 3
34252: ARRAY
34253: PUSH
34254: LD_INT 1
34256: ARRAY
34257: PUSH
34258: LD_INT 0
34260: EQUAL
34261: AND
34262: PUSH
34263: LD_VAR 0 3
34267: PPUSH
34268: LD_INT 7
34270: PPUSH
34271: EMPTY
34272: PPUSH
34273: CALL 12043 0 3
34277: NOT
34278: AND
34279: IFFALSE 34350
// begin if side = 1 then
34281: LD_VAR 0 3
34285: PUSH
34286: LD_INT 1
34288: EQUAL
34289: IFFALSE 34298
// RaiseSailEvent ( 101 ) ;
34291: LD_INT 101
34293: PPUSH
34294: CALL_OW 427
// if side = 4 then
34298: LD_VAR 0 3
34302: PUSH
34303: LD_INT 4
34305: EQUAL
34306: IFFALSE 34315
// RaiseSailEvent ( 102 ) ;
34308: LD_INT 102
34310: PPUSH
34311: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34315: LD_ADDR_VAR 0 2
34319: PUSH
34320: LD_EXP 73
34324: PUSH
34325: LD_VAR 0 3
34329: ARRAY
34330: PUSH
34331: FOR_IN
34332: IFFALSE 34348
// SetTag ( i , 7 ) ;
34334: LD_VAR 0 2
34338: PPUSH
34339: LD_INT 7
34341: PPUSH
34342: CALL_OW 109
34346: GO 34331
34348: POP
34349: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34350: LD_VAR 0 3
34354: PPUSH
34355: LD_INT 7
34357: PPUSH
34358: EMPTY
34359: PPUSH
34360: CALL 12043 0 3
34364: IFFALSE 34390
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34366: LD_VAR 0 3
34370: PPUSH
34371: LD_VAR 0 3
34375: PPUSH
34376: LD_INT 7
34378: PPUSH
34379: EMPTY
34380: PPUSH
34381: CALL 12043 0 3
34385: PPUSH
34386: CALL 8185 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34390: LD_VAR 0 3
34394: PPUSH
34395: CALL 17723 0 1
34399: PUSH
34400: LD_VAR 0 3
34404: PPUSH
34405: CALL 11379 0 1
34409: AND
34410: IFFALSE 34421
// MCL_Start ( side ) ;
34412: LD_VAR 0 3
34416: PPUSH
34417: CALL 17680 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34421: LD_ADDR_EXP 37
34425: PUSH
34426: LD_EXP 37
34430: PPUSH
34431: LD_VAR 0 3
34435: PPUSH
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 18980 0 1
34445: PPUSH
34446: CALL_OW 1
34450: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34451: LD_ADDR_EXP 49
34455: PUSH
34456: LD_EXP 49
34460: PPUSH
34461: LD_VAR 0 3
34465: PPUSH
34466: LD_VAR 0 3
34470: PPUSH
34471: CALL 10793 0 1
34475: PPUSH
34476: CALL_OW 1
34480: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34481: LD_VAR 0 3
34485: PPUSH
34486: LD_INT 21
34488: PUSH
34489: LD_INT 2
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PPUSH
34496: CALL 11340 0 2
34500: IFFALSE 34511
// MCV_CheckStatus ( side ) ;
34502: LD_VAR 0 3
34506: PPUSH
34507: CALL 26950 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34511: LD_VAR 0 3
34515: PPUSH
34516: LD_EXP 55
34520: PPUSH
34521: CALL 43095 0 2
34525: IFFALSE 34610
// begin for i = MREG_ToChangeClass downto 1 do
34527: LD_ADDR_VAR 0 2
34531: PUSH
34532: DOUBLE
34533: LD_EXP 55
34537: INC
34538: ST_TO_ADDR
34539: LD_INT 1
34541: PUSH
34542: FOR_DOWNTO
34543: IFFALSE 34608
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34545: LD_EXP 55
34549: PUSH
34550: LD_VAR 0 2
34554: ARRAY
34555: PUSH
34556: LD_INT 1
34558: ARRAY
34559: PUSH
34560: LD_VAR 0 3
34564: EQUAL
34565: IFFALSE 34606
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34567: LD_VAR 0 3
34571: PPUSH
34572: LD_EXP 55
34576: PUSH
34577: LD_VAR 0 2
34581: ARRAY
34582: PUSH
34583: LD_INT 2
34585: ARRAY
34586: PPUSH
34587: LD_EXP 55
34591: PUSH
34592: LD_VAR 0 2
34596: ARRAY
34597: PUSH
34598: LD_INT 3
34600: ARRAY
34601: PPUSH
34602: CALL 16247 0 3
// end ; end ;
34606: GO 34542
34608: POP
34609: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34610: LD_INT 1
34612: PUSH
34613: LD_EXP 40
34617: PUSH
34618: LD_VAR 0 3
34622: ARRAY
34623: IN
34624: IFFALSE 34635
// begin MCN_TrainApe ( side ) ;
34626: LD_VAR 0 3
34630: PPUSH
34631: CALL 18633 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34635: LD_VAR 0 3
34639: PPUSH
34640: LD_INT 30
34642: PUSH
34643: LD_INT 3
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PPUSH
34650: CALL 11340 0 2
34654: IFFALSE 34828
// begin if MCF_Tag ( side , 10 , [ ] ) then
34656: LD_VAR 0 3
34660: PPUSH
34661: LD_INT 10
34663: PPUSH
34664: EMPTY
34665: PPUSH
34666: CALL 12043 0 3
34670: IFFALSE 34717
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34672: LD_VAR 0 3
34676: PPUSH
34677: LD_INT 10
34679: PPUSH
34680: EMPTY
34681: PPUSH
34682: CALL 12043 0 3
34686: PPUSH
34687: LD_VAR 0 3
34691: PPUSH
34692: LD_INT 30
34694: PUSH
34695: LD_INT 3
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PPUSH
34702: CALL 11340 0 2
34706: PUSH
34707: LD_INT 1
34709: ARRAY
34710: PPUSH
34711: CALL_OW 168
// end else
34715: GO 34828
// if MREG_ToConstruct [ side ] then
34717: LD_EXP 53
34721: PUSH
34722: LD_VAR 0 3
34726: ARRAY
34727: IFFALSE 34828
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34729: LD_VAR 0 3
34733: PPUSH
34734: LD_VAR 0 3
34738: PPUSH
34739: LD_INT 30
34741: PUSH
34742: LD_INT 3
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PPUSH
34749: CALL 11340 0 2
34753: PUSH
34754: LD_INT 1
34756: ARRAY
34757: PPUSH
34758: LD_EXP 53
34762: PUSH
34763: LD_VAR 0 3
34767: ARRAY
34768: PUSH
34769: LD_INT 1
34771: ARRAY
34772: PUSH
34773: LD_EXP 53
34777: PUSH
34778: LD_VAR 0 3
34782: ARRAY
34783: PUSH
34784: LD_INT 2
34786: ARRAY
34787: PUSH
34788: LD_EXP 53
34792: PUSH
34793: LD_VAR 0 3
34797: ARRAY
34798: PUSH
34799: LD_INT 3
34801: ARRAY
34802: PUSH
34803: LD_EXP 53
34807: PUSH
34808: LD_VAR 0 3
34812: ARRAY
34813: PUSH
34814: LD_INT 4
34816: ARRAY
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: PPUSH
34824: CALL 25244 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34828: LD_VAR 0 3
34832: PPUSH
34833: LD_INT 30
34835: PUSH
34836: LD_INT 3
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PPUSH
34843: CALL 11340 0 2
34847: PUSH
34848: LD_VAR 0 3
34852: PPUSH
34853: LD_EXP 45
34857: PPUSH
34858: CALL 43095 0 2
34862: AND
34863: PUSH
34864: LD_INT 22
34866: PUSH
34867: LD_VAR 0 3
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 2
34878: PUSH
34879: LD_INT 30
34881: PUSH
34882: LD_INT 33
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 30
34891: PUSH
34892: LD_INT 32
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 35
34906: PUSH
34907: LD_INT 0
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: LIST
34918: PPUSH
34919: CALL_OW 69
34923: AND
34924: IFFALSE 34935
// MCV_Turret ( side ) ;
34926: LD_VAR 0 3
34930: PPUSH
34931: CALL 25693 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34935: LD_EXP 44
34939: PUSH
34940: LD_VAR 0 3
34944: ARRAY
34945: PUSH
34946: LD_INT 1
34948: GREATER
34949: PUSH
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 24741 0 1
34959: PUSH
34960: LD_INT 0
34962: EQUAL
34963: AND
34964: IFFALSE 35126
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34966: LD_EXP 44
34970: PUSH
34971: LD_VAR 0 3
34975: ARRAY
34976: PUSH
34977: LD_INT 1
34979: ARRAY
34980: PPUSH
34981: CALL_OW 353
34985: IFFALSE 35023
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
34987: LD_EXP 44
34991: PUSH
34992: LD_VAR 0 3
34996: ARRAY
34997: PUSH
34998: LD_INT 2
35000: ARRAY
35001: PPUSH
35002: LD_EXP 44
35006: PUSH
35007: LD_VAR 0 3
35011: ARRAY
35012: PUSH
35013: LD_INT 1
35015: ARRAY
35016: PPUSH
35017: CALL 32404 0 2
35021: GO 35126
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35023: LD_VAR 0 3
35027: PPUSH
35028: LD_INT 30
35030: PUSH
35031: LD_INT 3
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PPUSH
35038: CALL 11340 0 2
35042: IFFALSE 35126
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35044: LD_VAR 0 3
35048: PPUSH
35049: LD_INT 30
35051: PUSH
35052: LD_INT 3
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PPUSH
35059: CALL 11340 0 2
35063: PUSH
35064: LD_INT 1
35066: ARRAY
35067: PPUSH
35068: CALL_OW 461
35072: PUSH
35073: LD_INT 2
35075: EQUAL
35076: IFFALSE 35126
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35078: LD_EXP 44
35082: PUSH
35083: LD_VAR 0 3
35087: ARRAY
35088: PUSH
35089: LD_INT 2
35091: ARRAY
35092: PPUSH
35093: LD_INT 10
35095: PPUSH
35096: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35100: LD_ADDR_EXP 44
35104: PUSH
35105: LD_EXP 44
35109: PPUSH
35110: LD_VAR 0 3
35114: PPUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: PPUSH
35121: CALL_OW 1
35125: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35126: LD_VAR 0 3
35130: PPUSH
35131: LD_INT 33
35133: PUSH
35134: LD_INT 2
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PPUSH
35141: CALL 11340 0 2
35145: IFFALSE 35185
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35147: LD_VAR 0 3
35151: PPUSH
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_INT 33
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PPUSH
35167: CALL 11340 0 2
35171: PUSH
35172: LD_INT 1
35174: ARRAY
35175: PPUSH
35176: CALL_OW 248
35180: PPUSH
35181: CALL 26247 0 2
// if MREG_ToRepair [ side ] then
35185: LD_EXP 49
35189: PUSH
35190: LD_VAR 0 3
35194: ARRAY
35195: IFFALSE 35208
// begin MCB_Repair ( side ) ;
35197: LD_VAR 0 3
35201: PPUSH
35202: CALL 11080 0 1
// end else
35206: GO 36121
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35208: LD_VAR 0 3
35212: PPUSH
35213: LD_EXP 51
35217: PPUSH
35218: CALL 43095 0 2
35222: PUSH
35223: LD_VAR 0 3
35227: PPUSH
35228: LD_EXP 42
35232: PPUSH
35233: CALL 43095 0 2
35237: AND
35238: IFFALSE 35446
// begin for i = 1 to MREG_ToUpLab do
35240: LD_ADDR_VAR 0 2
35244: PUSH
35245: DOUBLE
35246: LD_INT 1
35248: DEC
35249: ST_TO_ADDR
35250: LD_EXP 51
35254: PUSH
35255: FOR_TO
35256: IFFALSE 35442
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35258: LD_EXP 51
35262: PUSH
35263: LD_VAR 0 2
35267: ARRAY
35268: PUSH
35269: LD_INT 1
35271: ARRAY
35272: PUSH
35273: LD_VAR 0 3
35277: EQUAL
35278: IFFALSE 35440
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35280: LD_EXP 51
35284: PUSH
35285: LD_VAR 0 2
35289: ARRAY
35290: PUSH
35291: LD_INT 2
35293: ARRAY
35294: PUSH
35295: LD_EXP 51
35299: PUSH
35300: LD_VAR 0 2
35304: ARRAY
35305: PUSH
35306: LD_INT 3
35308: ARRAY
35309: AND
35310: IFFALSE 35438
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35312: LD_VAR 0 3
35316: PPUSH
35317: LD_EXP 51
35321: PUSH
35322: LD_VAR 0 2
35326: ARRAY
35327: PUSH
35328: LD_INT 2
35330: ARRAY
35331: PPUSH
35332: LD_EXP 51
35336: PUSH
35337: LD_VAR 0 2
35341: ARRAY
35342: PUSH
35343: LD_INT 3
35345: ARRAY
35346: PPUSH
35347: CALL 8604 0 3
35351: IFFALSE 35438
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35353: LD_ADDR_EXP 51
35357: PUSH
35358: LD_EXP 51
35362: PPUSH
35363: LD_VAR 0 3
35367: PPUSH
35368: LD_EXP 51
35372: PUSH
35373: LD_VAR 0 2
35377: ARRAY
35378: PUSH
35379: LD_INT 2
35381: ARRAY
35382: PPUSH
35383: LD_EXP 51
35387: PUSH
35388: LD_VAR 0 2
35392: ARRAY
35393: PUSH
35394: LD_INT 3
35396: ARRAY
35397: PPUSH
35398: CALL 42147 0 4
35402: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35403: LD_ADDR_EXP 42
35407: PUSH
35408: LD_EXP 42
35412: PPUSH
35413: LD_VAR 0 3
35417: PPUSH
35418: LD_EXP 42
35422: PUSH
35423: LD_INT 1
35425: ARRAY
35426: PUSH
35427: LD_INT 2
35429: ARRAY
35430: PPUSH
35431: EMPTY
35432: PPUSH
35433: CALL 42147 0 4
35437: ST_TO_ADDR
// end ; break ;
35438: GO 35442
// end ;
35440: GO 35255
35442: POP
35443: POP
// end else
35444: GO 36121
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35446: LD_VAR 0 3
35450: PPUSH
35451: LD_EXP 50
35455: PPUSH
35456: CALL 43095 0 2
35460: IFFALSE 35534
// begin for i = 1 to MREG_ToUpdate do
35462: LD_ADDR_VAR 0 2
35466: PUSH
35467: DOUBLE
35468: LD_INT 1
35470: DEC
35471: ST_TO_ADDR
35472: LD_EXP 50
35476: PUSH
35477: FOR_TO
35478: IFFALSE 35530
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35480: LD_EXP 50
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PUSH
35491: LD_INT 1
35493: ARRAY
35494: PUSH
35495: LD_VAR 0 3
35499: EQUAL
35500: IFFALSE 35528
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35502: LD_VAR 0 3
35506: PPUSH
35507: LD_EXP 50
35511: PUSH
35512: LD_VAR 0 2
35516: ARRAY
35517: PUSH
35518: LD_INT 2
35520: ARRAY
35521: PPUSH
35522: CALL 8440 0 2
// break ;
35526: GO 35530
// end ;
35528: GO 35477
35530: POP
35531: POP
// end else
35532: GO 36121
// if MCF_Get ( side , [ f_constructed ] ) then
35534: LD_VAR 0 3
35538: PPUSH
35539: LD_INT 57
35541: PUSH
35542: EMPTY
35543: LIST
35544: PPUSH
35545: CALL 11340 0 2
35549: IFFALSE 35582
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35551: LD_VAR 0 3
35555: PPUSH
35556: LD_VAR 0 3
35560: PPUSH
35561: LD_INT 57
35563: PUSH
35564: EMPTY
35565: LIST
35566: PPUSH
35567: CALL 11340 0 2
35571: PUSH
35572: LD_INT 1
35574: ARRAY
35575: PPUSH
35576: CALL 10684 0 2
35580: GO 36121
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35582: LD_VAR 0 3
35586: PPUSH
35587: LD_EXP 48
35591: PPUSH
35592: CALL 43095 0 2
35596: PUSH
35597: LD_VAR 0 3
35601: PPUSH
35602: CALL_OW 345
35606: NOT
35607: AND
35608: PUSH
35609: LD_VAR 0 3
35613: PPUSH
35614: CALL 24741 0 1
35618: PUSH
35619: LD_INT 0
35621: EQUAL
35622: AND
35623: IFFALSE 36022
// begin for i = 1 to MREG_ToBuild do
35625: LD_ADDR_VAR 0 2
35629: PUSH
35630: DOUBLE
35631: LD_INT 1
35633: DEC
35634: ST_TO_ADDR
35635: LD_EXP 48
35639: PUSH
35640: FOR_TO
35641: IFFALSE 36018
// if MREG_ToBuild [ i ] [ 1 ] = side then
35643: LD_EXP 48
35647: PUSH
35648: LD_VAR 0 2
35652: ARRAY
35653: PUSH
35654: LD_INT 1
35656: ARRAY
35657: PUSH
35658: LD_VAR 0 3
35662: EQUAL
35663: IFFALSE 36016
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35665: LD_OWVAR 84
35669: PUSH
35670: LD_EXP 48
35674: PUSH
35675: LD_VAR 0 2
35679: ARRAY
35680: PUSH
35681: LD_INT 3
35683: ARRAY
35684: PUSH
35685: LD_INT 1
35687: ARRAY
35688: PPUSH
35689: LD_EXP 48
35693: PUSH
35694: LD_VAR 0 2
35698: ARRAY
35699: PUSH
35700: LD_INT 3
35702: ARRAY
35703: PUSH
35704: LD_INT 2
35706: ARRAY
35707: PPUSH
35708: CALL_OW 351
35712: AND
35713: IFFALSE 35757
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35715: LD_EXP 48
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_INT 3
35728: ARRAY
35729: PUSH
35730: LD_INT 1
35732: ARRAY
35733: PPUSH
35734: LD_EXP 48
35738: PUSH
35739: LD_VAR 0 2
35743: ARRAY
35744: PUSH
35745: LD_INT 3
35747: ARRAY
35748: PUSH
35749: LD_INT 2
35751: ARRAY
35752: PPUSH
35753: CALL 22488 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35757: LD_EXP 48
35761: PUSH
35762: LD_VAR 0 2
35766: ARRAY
35767: PUSH
35768: LD_INT 2
35770: ARRAY
35771: PUSH
35772: LD_INT 0
35774: EQUAL
35775: IFFALSE 35845
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35777: LD_VAR 0 3
35781: PPUSH
35782: LD_EXP 48
35786: PUSH
35787: LD_VAR 0 2
35791: ARRAY
35792: PUSH
35793: LD_INT 3
35795: ARRAY
35796: PUSH
35797: LD_INT 1
35799: ARRAY
35800: PPUSH
35801: LD_EXP 48
35805: PUSH
35806: LD_VAR 0 2
35810: ARRAY
35811: PUSH
35812: LD_INT 3
35814: ARRAY
35815: PUSH
35816: LD_INT 2
35818: ARRAY
35819: PPUSH
35820: LD_EXP 48
35824: PUSH
35825: LD_VAR 0 2
35829: ARRAY
35830: PUSH
35831: LD_INT 3
35833: ARRAY
35834: PUSH
35835: LD_INT 3
35837: ARRAY
35838: PPUSH
35839: CALL 8276 0 4
35843: GO 36014
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35845: LD_EXP 48
35849: PUSH
35850: LD_VAR 0 2
35854: ARRAY
35855: PUSH
35856: LD_INT 2
35858: ARRAY
35859: PUSH
35860: LD_INT 6
35862: EQUAL
35863: IFFALSE 35933
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35865: LD_VAR 0 3
35869: PPUSH
35870: LD_EXP 48
35874: PUSH
35875: LD_VAR 0 2
35879: ARRAY
35880: PUSH
35881: LD_INT 3
35883: ARRAY
35884: PUSH
35885: LD_INT 1
35887: ARRAY
35888: PPUSH
35889: LD_EXP 48
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 3
35902: ARRAY
35903: PUSH
35904: LD_INT 2
35906: ARRAY
35907: PPUSH
35908: LD_EXP 48
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: PUSH
35919: LD_INT 3
35921: ARRAY
35922: PUSH
35923: LD_INT 3
35925: ARRAY
35926: PPUSH
35927: CALL 8405 0 4
35931: GO 36014
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35933: LD_VAR 0 3
35937: PPUSH
35938: LD_EXP 48
35942: PUSH
35943: LD_VAR 0 2
35947: ARRAY
35948: PUSH
35949: LD_INT 2
35951: ARRAY
35952: PPUSH
35953: LD_EXP 48
35957: PUSH
35958: LD_VAR 0 2
35962: ARRAY
35963: PUSH
35964: LD_INT 3
35966: ARRAY
35967: PUSH
35968: LD_INT 1
35970: ARRAY
35971: PPUSH
35972: LD_EXP 48
35976: PUSH
35977: LD_VAR 0 2
35981: ARRAY
35982: PUSH
35983: LD_INT 3
35985: ARRAY
35986: PUSH
35987: LD_INT 2
35989: ARRAY
35990: PPUSH
35991: LD_EXP 48
35995: PUSH
35996: LD_VAR 0 2
36000: ARRAY
36001: PUSH
36002: LD_INT 3
36004: ARRAY
36005: PUSH
36006: LD_INT 3
36008: ARRAY
36009: PPUSH
36010: CALL 9909 0 5
// break ;
36014: GO 36018
// end ;
36016: GO 35640
36018: POP
36019: POP
// end else
36020: GO 36121
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36022: LD_VAR 0 3
36026: PPUSH
36027: LD_EXP 54
36031: PPUSH
36032: CALL 43095 0 2
36036: PUSH
36037: LD_VAR 0 3
36041: PPUSH
36042: CALL 24741 0 1
36046: PUSH
36047: LD_INT 0
36049: EQUAL
36050: AND
36051: IFFALSE 36121
// begin for i = 1 to MREG_ToDismantle do
36053: LD_ADDR_VAR 0 2
36057: PUSH
36058: DOUBLE
36059: LD_INT 1
36061: DEC
36062: ST_TO_ADDR
36063: LD_EXP 54
36067: PUSH
36068: FOR_TO
36069: IFFALSE 36119
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36071: LD_EXP 54
36075: PUSH
36076: LD_VAR 0 2
36080: ARRAY
36081: PUSH
36082: LD_INT 1
36084: ARRAY
36085: PUSH
36086: LD_VAR 0 3
36090: EQUAL
36091: IFFALSE 36117
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36093: LD_VAR 0 3
36097: PPUSH
36098: LD_EXP 54
36102: PUSH
36103: LD_VAR 0 2
36107: ARRAY
36108: PUSH
36109: LD_INT 2
36111: ARRAY
36112: PPUSH
36113: CALL 10575 0 2
// end ;
36117: GO 36068
36119: POP
36120: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36121: LD_VAR 0 3
36125: PPUSH
36126: LD_INT 30
36128: PUSH
36129: LD_INT 1
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PPUSH
36136: CALL 11340 0 2
36140: PUSH
36141: LD_VAR 0 3
36145: PPUSH
36146: CALL 24741 0 1
36150: PUSH
36151: LD_INT 0
36153: EQUAL
36154: AND
36155: IFFALSE 36166
// MCT_CollectCrates ( side ) ;
36157: LD_VAR 0 3
36161: PPUSH
36162: CALL 23680 0 1
// end ;
36166: GO 34167
36168: POP
36169: POP
// end ;
36170: LD_VAR 0 1
36174: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36175: LD_INT 0
36177: PPUSH
36178: PPUSH
36179: PPUSH
36180: PPUSH
36181: PPUSH
36182: PPUSH
36183: PPUSH
36184: PPUSH
36185: PPUSH
36186: PPUSH
36187: PPUSH
36188: PPUSH
36189: PPUSH
36190: PPUSH
36191: PPUSH
// all := MCF_All ( side , [ ] ) ;
36192: LD_ADDR_VAR 0 17
36196: PUSH
36197: LD_VAR 0 1
36201: PPUSH
36202: EMPTY
36203: PPUSH
36204: CALL 11475 0 2
36208: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36209: LD_ADDR_VAR 0 13
36213: PUSH
36214: LD_VAR 0 1
36218: PPUSH
36219: LD_INT 1
36221: PPUSH
36222: EMPTY
36223: PPUSH
36224: CALL 11423 0 3
36228: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36229: LD_ADDR_VAR 0 14
36233: PUSH
36234: LD_VAR 0 1
36238: PPUSH
36239: LD_INT 2
36241: PPUSH
36242: EMPTY
36243: PPUSH
36244: CALL 11423 0 3
36248: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36249: LD_ADDR_VAR 0 15
36253: PUSH
36254: LD_VAR 0 1
36258: PPUSH
36259: LD_INT 3
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL 11423 0 3
36268: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36269: LD_ADDR_VAR 0 16
36273: PUSH
36274: LD_VAR 0 1
36278: PPUSH
36279: LD_INT 4
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL 11423 0 3
36288: ST_TO_ADDR
// if mech then
36289: LD_VAR 0 15
36293: IFFALSE 36310
// mech := MCF_SortListDesc ( mech ) ;
36295: LD_ADDR_VAR 0 15
36299: PUSH
36300: LD_VAR 0 15
36304: PPUSH
36305: CALL 12589 0 1
36309: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36310: LD_EXP 58
36314: PUSH
36315: LD_VAR 0 1
36319: ARRAY
36320: PUSH
36321: LD_STRING 
36323: EQUAL
36324: NOT
36325: IFFALSE 36381
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36327: LD_EXP 58
36331: PUSH
36332: LD_VAR 0 1
36336: ARRAY
36337: PUSH
36338: LD_INT 1
36340: ARRAY
36341: PPUSH
36342: CALL_OW 257
36346: PUSH
36347: LD_INT 1
36349: EQUAL
36350: IFFALSE 36379
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36352: LD_VAR 0 1
36356: PPUSH
36357: LD_STRING ToArm
36359: PPUSH
36360: LD_EXP 58
36364: PUSH
36365: LD_VAR 0 1
36369: ARRAY
36370: PUSH
36371: LD_INT 1
36373: ARRAY
36374: PPUSH
36375: CALL 14219 0 3
// end else
36379: GO 36407
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36381: LD_ADDR_EXP 58
36385: PUSH
36386: LD_EXP 58
36390: PPUSH
36391: LD_VAR 0 1
36395: PPUSH
36396: LD_INT 1
36398: PPUSH
36399: LD_INT 0
36401: PPUSH
36402: CALL 30774 0 4
36406: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36407: LD_EXP 59
36411: PUSH
36412: LD_VAR 0 1
36416: ARRAY
36417: PUSH
36418: LD_STRING 
36420: EQUAL
36421: NOT
36422: IFFALSE 36478
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36424: LD_EXP 59
36428: PUSH
36429: LD_VAR 0 1
36433: ARRAY
36434: PUSH
36435: LD_INT 1
36437: ARRAY
36438: PPUSH
36439: CALL_OW 257
36443: PUSH
36444: LD_INT 2
36446: EQUAL
36447: IFFALSE 36476
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36449: LD_VAR 0 1
36453: PPUSH
36454: LD_STRING ToDep
36456: PPUSH
36457: LD_EXP 59
36461: PUSH
36462: LD_VAR 0 1
36466: ARRAY
36467: PUSH
36468: LD_INT 1
36470: ARRAY
36471: PPUSH
36472: CALL 14219 0 3
// end else
36476: GO 36504
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36478: LD_ADDR_EXP 59
36482: PUSH
36483: LD_EXP 59
36487: PPUSH
36488: LD_VAR 0 1
36492: PPUSH
36493: LD_INT 1
36495: PPUSH
36496: LD_INT 0
36498: PPUSH
36499: CALL 30774 0 4
36503: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36504: LD_EXP 57
36508: PUSH
36509: LD_VAR 0 1
36513: ARRAY
36514: PUSH
36515: LD_STRING 
36517: EQUAL
36518: NOT
36519: IFFALSE 36575
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36521: LD_EXP 57
36525: PUSH
36526: LD_VAR 0 1
36530: ARRAY
36531: PUSH
36532: LD_INT 1
36534: ARRAY
36535: PPUSH
36536: CALL_OW 257
36540: PUSH
36541: LD_INT 3
36543: EQUAL
36544: IFFALSE 36573
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36546: LD_VAR 0 1
36550: PPUSH
36551: LD_STRING ToFac
36553: PPUSH
36554: LD_EXP 57
36558: PUSH
36559: LD_VAR 0 1
36563: ARRAY
36564: PUSH
36565: LD_INT 1
36567: ARRAY
36568: PPUSH
36569: CALL 14219 0 3
// end else
36573: GO 36601
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36575: LD_ADDR_EXP 57
36579: PUSH
36580: LD_EXP 57
36584: PPUSH
36585: LD_VAR 0 1
36589: PPUSH
36590: LD_INT 1
36592: PPUSH
36593: LD_INT 0
36595: PPUSH
36596: CALL 30774 0 4
36600: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36601: LD_EXP 56
36605: PUSH
36606: LD_VAR 0 1
36610: ARRAY
36611: PUSH
36612: LD_STRING 
36614: EQUAL
36615: NOT
36616: IFFALSE 36672
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36618: LD_EXP 56
36622: PUSH
36623: LD_VAR 0 1
36627: ARRAY
36628: PUSH
36629: LD_INT 1
36631: ARRAY
36632: PPUSH
36633: CALL_OW 257
36637: PUSH
36638: LD_INT 4
36640: EQUAL
36641: IFFALSE 36670
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36643: LD_VAR 0 1
36647: PPUSH
36648: LD_STRING ToLab
36650: PPUSH
36651: LD_EXP 56
36655: PUSH
36656: LD_VAR 0 1
36660: ARRAY
36661: PUSH
36662: LD_INT 1
36664: ARRAY
36665: PPUSH
36666: CALL 14219 0 3
// end else
36670: GO 36698
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36672: LD_ADDR_EXP 56
36676: PUSH
36677: LD_EXP 56
36681: PPUSH
36682: LD_VAR 0 1
36686: PPUSH
36687: LD_INT 1
36689: PPUSH
36690: LD_INT 0
36692: PPUSH
36693: CALL 30774 0 4
36697: ST_TO_ADDR
// if mode = 0 then
36698: LD_VAR 0 2
36702: PUSH
36703: LD_INT 0
36705: EQUAL
36706: IFFALSE 38544
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36708: LD_VAR 0 1
36712: PPUSH
36713: LD_INT 30
36715: PUSH
36716: LD_INT 1
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PPUSH
36723: CALL 11340 0 2
36727: PUSH
36728: LD_VAR 0 1
36732: PPUSH
36733: LD_INT 21
36735: PUSH
36736: LD_INT 3
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PPUSH
36743: CALL 11340 0 2
36747: PUSH
36748: LD_INT 1
36750: EQUAL
36751: AND
36752: IFFALSE 36817
// begin if all then
36754: LD_VAR 0 17
36758: IFFALSE 36815
// for i in ( all diff eng ) do
36760: LD_ADDR_VAR 0 4
36764: PUSH
36765: LD_VAR 0 17
36769: PUSH
36770: LD_VAR 0 14
36774: DIFF
36775: PUSH
36776: FOR_IN
36777: IFFALSE 36813
// if GetTag ( i ) = 0 then
36779: LD_VAR 0 4
36783: PPUSH
36784: CALL_OW 110
36788: PUSH
36789: LD_INT 0
36791: EQUAL
36792: IFFALSE 36811
// MCH_ChangeClass ( side , i , 2 ) ;
36794: LD_VAR 0 1
36798: PPUSH
36799: LD_VAR 0 4
36803: PPUSH
36804: LD_INT 2
36806: PPUSH
36807: CALL 16247 0 3
36811: GO 36776
36813: POP
36814: POP
// end else
36815: GO 37136
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36817: LD_VAR 0 13
36821: PUSH
36822: LD_EXP 58
36826: PUSH
36827: LD_VAR 0 1
36831: ARRAY
36832: PLUS
36833: PUSH
36834: LD_INT 22
36836: PUSH
36837: LD_VAR 0 1
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 30
36848: PUSH
36849: LD_INT 32
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PPUSH
36860: CALL_OW 69
36864: LESS
36865: IFFALSE 36890
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36867: LD_VAR 0 1
36871: PPUSH
36872: LD_VAR 0 14
36876: PUSH
36877: LD_INT 1
36879: ARRAY
36880: PPUSH
36881: LD_INT 1
36883: PPUSH
36884: CALL 16247 0 3
// end else
36888: GO 37136
// if sci < 6 and MCF_Lab ( side ) then
36890: LD_VAR 0 16
36894: PUSH
36895: LD_INT 6
36897: LESS
36898: PUSH
36899: LD_VAR 0 1
36903: PPUSH
36904: CALL 11379 0 1
36908: AND
36909: IFFALSE 37014
// begin if MREG_ToBunker [ side ] then
36911: LD_EXP 70
36915: PUSH
36916: LD_VAR 0 1
36920: ARRAY
36921: IFFALSE 36947
// tmp := sol diff MREG_ToBunker [ side ] else
36923: LD_ADDR_VAR 0 12
36927: PUSH
36928: LD_VAR 0 13
36932: PUSH
36933: LD_EXP 70
36937: PUSH
36938: LD_VAR 0 1
36942: ARRAY
36943: DIFF
36944: ST_TO_ADDR
36945: GO 36957
// tmp := sol ;
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: ST_TO_ADDR
// if tmp then
36957: LD_VAR 0 12
36961: IFFALSE 37012
// for i in tmp do
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: LD_VAR 0 12
36972: PUSH
36973: FOR_IN
36974: IFFALSE 37010
// if GetTag ( i ) = 0 then
36976: LD_VAR 0 4
36980: PPUSH
36981: CALL_OW 110
36985: PUSH
36986: LD_INT 0
36988: EQUAL
36989: IFFALSE 37008
// MCH_ChangeClass ( side , i , 4 ) ;
36991: LD_VAR 0 1
36995: PPUSH
36996: LD_VAR 0 4
37000: PPUSH
37001: LD_INT 4
37003: PPUSH
37004: CALL 16247 0 3
37008: GO 36973
37010: POP
37011: POP
// end else
37012: GO 37136
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37014: LD_VAR 0 1
37018: PPUSH
37019: LD_INT 30
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PPUSH
37029: CALL 11340 0 2
37033: IFFALSE 37136
// begin if MREG_ToBunker [ side ] then
37035: LD_EXP 70
37039: PUSH
37040: LD_VAR 0 1
37044: ARRAY
37045: IFFALSE 37071
// tmp := sol diff MREG_ToBunker [ side ] else
37047: LD_ADDR_VAR 0 12
37051: PUSH
37052: LD_VAR 0 13
37056: PUSH
37057: LD_EXP 70
37061: PUSH
37062: LD_VAR 0 1
37066: ARRAY
37067: DIFF
37068: ST_TO_ADDR
37069: GO 37081
// tmp := sol ;
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: ST_TO_ADDR
// if tmp then
37081: LD_VAR 0 12
37085: IFFALSE 37136
// for i in tmp do
37087: LD_ADDR_VAR 0 4
37091: PUSH
37092: LD_VAR 0 12
37096: PUSH
37097: FOR_IN
37098: IFFALSE 37134
// if GetTag ( i ) = 0 then
37100: LD_VAR 0 4
37104: PPUSH
37105: CALL_OW 110
37109: PUSH
37110: LD_INT 0
37112: EQUAL
37113: IFFALSE 37132
// MCH_ChangeClass ( side , i , 2 ) ;
37115: LD_VAR 0 1
37119: PPUSH
37120: LD_VAR 0 4
37124: PPUSH
37125: LD_INT 2
37127: PPUSH
37128: CALL 16247 0 3
37132: GO 37097
37134: POP
37135: POP
// end ; if MCF_Lab ( side ) then
37136: LD_VAR 0 1
37140: PPUSH
37141: CALL 11379 0 1
37145: IFFALSE 37685
// begin if MCL_GetTechList ( side ) then
37147: LD_VAR 0 1
37151: PPUSH
37152: CALL 17723 0 1
37156: IFFALSE 37282
// begin if MREG_ToLab [ side ] then
37158: LD_EXP 56
37162: PUSH
37163: LD_VAR 0 1
37167: ARRAY
37168: IFFALSE 37188
// k := MREG_ToLab [ side ] else
37170: LD_ADDR_VAR 0 8
37174: PUSH
37175: LD_EXP 56
37179: PUSH
37180: LD_VAR 0 1
37184: ARRAY
37185: ST_TO_ADDR
37186: GO 37196
// k := 0 ;
37188: LD_ADDR_VAR 0 8
37192: PUSH
37193: LD_INT 0
37195: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37196: LD_VAR 0 16
37200: PUSH
37201: LD_VAR 0 8
37205: PLUS
37206: PUSH
37207: LD_INT 6
37209: LESSEQUAL
37210: PUSH
37211: LD_VAR 0 17
37215: PUSH
37216: LD_INT 6
37218: GREATER
37219: AND
37220: IFFALSE 37236
// MCH_TrainScientist ( side , 1 ) else
37222: LD_VAR 0 1
37226: PPUSH
37227: LD_INT 1
37229: PPUSH
37230: CALL 15799 0 2
37234: GO 37280
// if all < 6 then
37236: LD_VAR 0 17
37240: PUSH
37241: LD_INT 6
37243: LESS
37244: IFFALSE 37280
// if sci + k < all / 2 then
37246: LD_VAR 0 16
37250: PUSH
37251: LD_VAR 0 8
37255: PLUS
37256: PUSH
37257: LD_VAR 0 17
37261: PUSH
37262: LD_INT 2
37264: DIVREAL
37265: LESS
37266: IFFALSE 37280
// MCH_TrainScientist ( side , 1 ) ;
37268: LD_VAR 0 1
37272: PPUSH
37273: LD_INT 1
37275: PPUSH
37276: CALL 15799 0 2
// end else
37280: GO 37358
// begin if sci > 2 then
37282: LD_VAR 0 16
37286: PUSH
37287: LD_INT 2
37289: GREATER
37290: IFFALSE 37358
// for i = sci downto 2 do
37292: LD_ADDR_VAR 0 4
37296: PUSH
37297: DOUBLE
37298: LD_VAR 0 16
37302: INC
37303: ST_TO_ADDR
37304: LD_INT 2
37306: PUSH
37307: FOR_DOWNTO
37308: IFFALSE 37356
// if GetTag ( sci [ i ] ) = 0 then
37310: LD_VAR 0 16
37314: PUSH
37315: LD_VAR 0 4
37319: ARRAY
37320: PPUSH
37321: CALL_OW 110
37325: PUSH
37326: LD_INT 0
37328: EQUAL
37329: IFFALSE 37354
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37331: LD_VAR 0 1
37335: PPUSH
37336: LD_VAR 0 16
37340: PUSH
37341: LD_VAR 0 4
37345: ARRAY
37346: PPUSH
37347: LD_INT 2
37349: PPUSH
37350: CALL 16247 0 3
37354: GO 37307
37356: POP
37357: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37358: LD_VAR 0 1
37362: PPUSH
37363: CALL 17723 0 1
37367: PUSH
37368: LD_VAR 0 1
37372: PPUSH
37373: CALL 11379 0 1
37377: AND
37378: PUSH
37379: LD_EXP 37
37383: PUSH
37384: LD_VAR 0 1
37388: ARRAY
37389: NOT
37390: AND
37391: IFFALSE 37685
// begin for j = 1 to MCF_Lab ( side ) do
37393: LD_ADDR_VAR 0 5
37397: PUSH
37398: DOUBLE
37399: LD_INT 1
37401: DEC
37402: ST_TO_ADDR
37403: LD_VAR 0 1
37407: PPUSH
37408: CALL 11379 0 1
37412: PUSH
37413: FOR_TO
37414: IFFALSE 37474
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37416: LD_VAR 0 1
37420: PPUSH
37421: CALL 11379 0 1
37425: PUSH
37426: LD_VAR 0 5
37430: ARRAY
37431: PPUSH
37432: CALL_OW 461
37436: PUSH
37437: LD_INT 3
37439: PUSH
37440: LD_INT 6
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: IN
37447: IFFALSE 37472
// begin b := MCF_Lab ( side ) [ j ] ;
37449: LD_ADDR_VAR 0 11
37453: PUSH
37454: LD_VAR 0 1
37458: PPUSH
37459: CALL 11379 0 1
37463: PUSH
37464: LD_VAR 0 5
37468: ARRAY
37469: ST_TO_ADDR
// break ;
37470: GO 37474
// end ;
37472: GO 37413
37474: POP
37475: POP
// if MCF_Class ( side , 4 , [ ] ) then
37476: LD_VAR 0 1
37480: PPUSH
37481: LD_INT 4
37483: PPUSH
37484: EMPTY
37485: PPUSH
37486: CALL 11423 0 3
37490: IFFALSE 37685
// for j in MCF_Class ( side , 4 , [ ] ) do
37492: LD_ADDR_VAR 0 5
37496: PUSH
37497: LD_VAR 0 1
37501: PPUSH
37502: LD_INT 4
37504: PPUSH
37505: EMPTY
37506: PPUSH
37507: CALL 11423 0 3
37511: PUSH
37512: FOR_IN
37513: IFFALSE 37683
// begin if GetTag ( j ) = 0 then
37515: LD_VAR 0 5
37519: PPUSH
37520: CALL_OW 110
37524: PUSH
37525: LD_INT 0
37527: EQUAL
37528: IFFALSE 37619
// begin if IsInUnit ( j ) and b then
37530: LD_VAR 0 5
37534: PPUSH
37535: CALL_OW 310
37539: PUSH
37540: LD_VAR 0 11
37544: AND
37545: IFFALSE 37593
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37547: LD_VAR 0 5
37551: PPUSH
37552: CALL_OW 310
37556: PPUSH
37557: CALL_OW 461
37561: PUSH
37562: LD_INT 2
37564: EQUAL
37565: PUSH
37566: LD_VAR 0 5
37570: PPUSH
37571: CALL_OW 310
37575: PUSH
37576: LD_VAR 0 11
37580: NONEQUAL
37581: AND
37582: IFFALSE 37593
// ComExitBuilding ( j ) ;
37584: LD_VAR 0 5
37588: PPUSH
37589: CALL_OW 122
// if not IsInUnit ( j ) then
37593: LD_VAR 0 5
37597: PPUSH
37598: CALL_OW 310
37602: NOT
37603: IFFALSE 37619
// ComEnterUnit ( j , b ) ;
37605: LD_VAR 0 5
37609: PPUSH
37610: LD_VAR 0 11
37614: PPUSH
37615: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37619: LD_INT 1
37621: PPUSH
37622: LD_VAR 0 5
37626: PPUSH
37627: CALL_OW 255
37631: PPUSH
37632: CALL_OW 321
37636: PUSH
37637: LD_INT 2
37639: EQUAL
37640: PUSH
37641: LD_VAR 0 5
37645: PPUSH
37646: CALL_OW 255
37650: PPUSH
37651: CALL 24741 0 1
37655: PUSH
37656: LD_INT 0
37658: EQUAL
37659: AND
37660: IFFALSE 37681
// MCN_Tame ( GetSide ( j ) , j ) ;
37662: LD_VAR 0 5
37666: PPUSH
37667: CALL_OW 255
37671: PPUSH
37672: LD_VAR 0 5
37676: PPUSH
37677: CALL 18242 0 2
// end ;
37681: GO 37512
37683: POP
37684: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37685: LD_VAR 0 1
37689: PPUSH
37690: LD_INT 30
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: PPUSH
37700: CALL 11340 0 2
37704: IFFALSE 37963
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37706: LD_ADDR_VAR 0 11
37710: PUSH
37711: LD_VAR 0 1
37715: PPUSH
37716: LD_INT 30
37718: PUSH
37719: LD_INT 3
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PPUSH
37726: CALL 11340 0 2
37730: PUSH
37731: LD_INT 1
37733: ARRAY
37734: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37735: LD_ADDR_VAR 0 12
37739: PUSH
37740: LD_VAR 0 1
37744: PPUSH
37745: LD_INT 0
37747: PPUSH
37748: LD_INT 25
37750: PUSH
37751: LD_INT 3
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PPUSH
37758: CALL 12043 0 3
37762: ST_TO_ADDR
// for i = 1 to tmp do
37763: LD_ADDR_VAR 0 4
37767: PUSH
37768: DOUBLE
37769: LD_INT 1
37771: DEC
37772: ST_TO_ADDR
37773: LD_VAR 0 12
37777: PUSH
37778: FOR_TO
37779: IFFALSE 37839
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37781: LD_VAR 0 12
37785: PUSH
37786: LD_VAR 0 4
37790: ARRAY
37791: PPUSH
37792: CALL_OW 310
37796: NOT
37797: PUSH
37798: LD_VAR 0 12
37802: PUSH
37803: LD_VAR 0 4
37807: ARRAY
37808: PPUSH
37809: CALL_OW 314
37813: NOT
37814: AND
37815: IFFALSE 37837
// ComEnterUnit ( tmp [ i ] , b ) ;
37817: LD_VAR 0 12
37821: PUSH
37822: LD_VAR 0 4
37826: ARRAY
37827: PPUSH
37828: LD_VAR 0 11
37832: PPUSH
37833: CALL_OW 120
37837: GO 37778
37839: POP
37840: POP
// if MREG_ToFac [ side ] then
37841: LD_EXP 57
37845: PUSH
37846: LD_VAR 0 1
37850: ARRAY
37851: IFFALSE 37871
// k := MREG_ToFac [ side ] else
37853: LD_ADDR_VAR 0 8
37857: PUSH
37858: LD_EXP 57
37862: PUSH
37863: LD_VAR 0 1
37867: ARRAY
37868: ST_TO_ADDR
37869: GO 37879
// k := 0 ;
37871: LD_ADDR_VAR 0 8
37875: PUSH
37876: LD_INT 0
37878: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37879: LD_VAR 0 15
37883: PUSH
37884: LD_VAR 0 8
37888: PLUS
37889: PUSH
37890: LD_INT 6
37892: LESSEQUAL
37893: PUSH
37894: LD_VAR 0 17
37898: PUSH
37899: LD_INT 6
37901: GREATER
37902: AND
37903: IFFALSE 37919
// MCH_TrainMechanic ( side , 1 ) else
37905: LD_VAR 0 1
37909: PPUSH
37910: LD_INT 1
37912: PPUSH
37913: CALL 15541 0 2
37917: GO 37963
// if all < 6 then
37919: LD_VAR 0 17
37923: PUSH
37924: LD_INT 6
37926: LESS
37927: IFFALSE 37963
// if mech + k < all / 2 then
37929: LD_VAR 0 15
37933: PUSH
37934: LD_VAR 0 8
37938: PLUS
37939: PUSH
37940: LD_VAR 0 17
37944: PUSH
37945: LD_INT 2
37947: DIVREAL
37948: LESS
37949: IFFALSE 37963
// MCH_TrainMechanic ( side , 1 ) ;
37951: LD_VAR 0 1
37955: PPUSH
37956: LD_INT 1
37958: PPUSH
37959: CALL 15541 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37963: LD_ADDR_VAR 0 10
37967: PUSH
37968: LD_VAR 0 1
37972: PPUSH
37973: LD_INT 30
37975: PUSH
37976: LD_INT 36
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PPUSH
37983: CALL 11340 0 2
37987: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
37988: LD_VAR 0 10
37992: PUSH
37993: LD_VAR 0 15
37997: AND
37998: PUSH
37999: LD_VAR 0 1
38003: PPUSH
38004: LD_INT 3
38006: PPUSH
38007: EMPTY
38008: PPUSH
38009: CALL 11423 0 3
38013: AND
38014: IFFALSE 38172
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38016: LD_VAR 0 1
38020: PPUSH
38021: LD_INT 9
38023: PPUSH
38024: EMPTY
38025: PPUSH
38026: CALL 12043 0 3
38030: PUSH
38031: LD_INT 3
38033: LESS
38034: IFFALSE 38172
// begin if mech < 3 then
38036: LD_VAR 0 15
38040: PUSH
38041: LD_INT 3
38043: LESS
38044: IFFALSE 38058
// k := mech else
38046: LD_ADDR_VAR 0 8
38050: PUSH
38051: LD_VAR 0 15
38055: ST_TO_ADDR
38056: GO 38066
// k := 3 ;
38058: LD_ADDR_VAR 0 8
38062: PUSH
38063: LD_INT 3
38065: ST_TO_ADDR
// for j = 1 to k do
38066: LD_ADDR_VAR 0 5
38070: PUSH
38071: DOUBLE
38072: LD_INT 1
38074: DEC
38075: ST_TO_ADDR
38076: LD_VAR 0 8
38080: PUSH
38081: FOR_TO
38082: IFFALSE 38140
// if GetClass ( mech [ j ] ) = 3 then
38084: LD_VAR 0 15
38088: PUSH
38089: LD_VAR 0 5
38093: ARRAY
38094: PPUSH
38095: CALL_OW 257
38099: PUSH
38100: LD_INT 3
38102: EQUAL
38103: IFFALSE 38138
// begin SetTag ( mech [ j ] , 9 ) ;
38105: LD_VAR 0 15
38109: PUSH
38110: LD_VAR 0 5
38114: ARRAY
38115: PPUSH
38116: LD_INT 9
38118: PPUSH
38119: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38123: LD_VAR 0 15
38127: PUSH
38128: LD_VAR 0 5
38132: ARRAY
38133: PPUSH
38134: CALL_OW 122
// end ;
38138: GO 38081
38140: POP
38141: POP
// if mech < 6 + k then
38142: LD_VAR 0 15
38146: PUSH
38147: LD_INT 6
38149: PUSH
38150: LD_VAR 0 8
38154: PLUS
38155: LESS
38156: IFFALSE 38172
// MCH_TrainMechanic ( side , k ) ;
38158: LD_VAR 0 1
38162: PPUSH
38163: LD_VAR 0 8
38167: PPUSH
38168: CALL 15541 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38172: LD_VAR 0 1
38176: PPUSH
38177: LD_INT 9
38179: PPUSH
38180: EMPTY
38181: PPUSH
38182: CALL 12043 0 3
38186: IFFALSE 38277
// for j in MCF_Tag ( side , 9 , [ ] ) do
38188: LD_ADDR_VAR 0 5
38192: PUSH
38193: LD_VAR 0 1
38197: PPUSH
38198: LD_INT 9
38200: PPUSH
38201: EMPTY
38202: PPUSH
38203: CALL 12043 0 3
38207: PUSH
38208: FOR_IN
38209: IFFALSE 38275
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38211: LD_VAR 0 5
38215: PPUSH
38216: CALL_OW 310
38220: NOT
38221: PUSH
38222: LD_VAR 0 5
38226: PPUSH
38227: CALL 31417 0 1
38231: NOT
38232: AND
38233: IFFALSE 38273
// if ct then
38235: LD_VAR 0 10
38239: IFFALSE 38261
// ComEnterUnit ( j , ct [ 1 ] ) else
38241: LD_VAR 0 5
38245: PPUSH
38246: LD_VAR 0 10
38250: PUSH
38251: LD_INT 1
38253: ARRAY
38254: PPUSH
38255: CALL_OW 120
38259: GO 38273
// SetTag ( j , 0 ) ;
38261: LD_VAR 0 5
38265: PPUSH
38266: LD_INT 0
38268: PPUSH
38269: CALL_OW 109
38273: GO 38208
38275: POP
38276: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38277: LD_INT 1
38279: PPUSH
38280: LD_VAR 0 1
38284: PPUSH
38285: CALL_OW 321
38289: PUSH
38290: LD_INT 2
38292: EQUAL
38293: PUSH
38294: LD_EXP 37
38298: PUSH
38299: LD_VAR 0 1
38303: ARRAY
38304: NOT
38305: AND
38306: PUSH
38307: LD_VAR 0 1
38311: PPUSH
38312: LD_INT 4
38314: PPUSH
38315: EMPTY
38316: PPUSH
38317: CALL 11423 0 3
38321: AND
38322: IFFALSE 38370
// for j in MCF_Class ( side , 4 , [ ] ) do
38324: LD_ADDR_VAR 0 5
38328: PUSH
38329: LD_VAR 0 1
38333: PPUSH
38334: LD_INT 4
38336: PPUSH
38337: EMPTY
38338: PPUSH
38339: CALL 11423 0 3
38343: PUSH
38344: FOR_IN
38345: IFFALSE 38368
// MCN_Tame ( GetSide ( j ) , j ) ;
38347: LD_VAR 0 5
38351: PPUSH
38352: CALL_OW 255
38356: PPUSH
38357: LD_VAR 0 5
38361: PPUSH
38362: CALL 18242 0 2
38366: GO 38344
38368: POP
38369: POP
// if MREG_DefVeh [ side ] then
38370: LD_EXP 69
38374: PUSH
38375: LD_VAR 0 1
38379: ARRAY
38380: IFFALSE 38544
// begin for i in MREG_DefVeh [ side ] do
38382: LD_ADDR_VAR 0 4
38386: PUSH
38387: LD_EXP 69
38391: PUSH
38392: LD_VAR 0 1
38396: ARRAY
38397: PUSH
38398: FOR_IN
38399: IFFALSE 38452
// begin SetTag ( i , 0 ) ;
38401: LD_VAR 0 4
38405: PPUSH
38406: LD_INT 0
38408: PPUSH
38409: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38413: LD_VAR 0 4
38417: PPUSH
38418: LD_EXP 66
38422: PUSH
38423: LD_VAR 0 1
38427: ARRAY
38428: PPUSH
38429: CALL_OW 308
38433: NOT
38434: IFFALSE 38450
// MCV_Parking ( side , i ) ;
38436: LD_VAR 0 1
38440: PPUSH
38441: LD_VAR 0 4
38445: PPUSH
38446: CALL 25501 0 2
// end ;
38450: GO 38398
38452: POP
38453: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38454: LD_VAR 0 1
38458: PPUSH
38459: LD_INT 36
38461: PPUSH
38462: EMPTY
38463: PPUSH
38464: CALL 12043 0 3
38468: IFFALSE 38509
// for i in MCF_Tag ( side , 36 , [ ] ) do
38470: LD_ADDR_VAR 0 4
38474: PUSH
38475: LD_VAR 0 1
38479: PPUSH
38480: LD_INT 36
38482: PPUSH
38483: EMPTY
38484: PPUSH
38485: CALL 12043 0 3
38489: PUSH
38490: FOR_IN
38491: IFFALSE 38507
// SetTag ( i , 0 ) ;
38493: LD_VAR 0 4
38497: PPUSH
38498: LD_INT 0
38500: PPUSH
38501: CALL_OW 109
38505: GO 38490
38507: POP
38508: POP
// if MREG_DefMobActive [ side ] then
38509: LD_EXP 72
38513: PUSH
38514: LD_VAR 0 1
38518: ARRAY
38519: IFFALSE 38544
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38521: LD_ADDR_EXP 72
38525: PUSH
38526: LD_EXP 72
38530: PPUSH
38531: LD_VAR 0 1
38535: PPUSH
38536: LD_INT 0
38538: PPUSH
38539: CALL_OW 1
38543: ST_TO_ADDR
// end ; end ; if mode > 0 then
38544: LD_VAR 0 2
38548: PUSH
38549: LD_INT 0
38551: GREATER
38552: IFFALSE 40567
// begin if tick <= 15 15$00 then
38554: LD_OWVAR 1
38558: PUSH
38559: LD_INT 31500
38561: LESSEQUAL
38562: IFFALSE 38986
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38564: LD_VAR 0 13
38568: PUSH
38569: LD_INT 4
38571: GREATER
38572: PUSH
38573: LD_VAR 0 1
38577: PPUSH
38578: CALL 24741 0 1
38582: PUSH
38583: LD_INT 4
38585: LESS
38586: AND
38587: IFFALSE 38698
// for i in sol do
38589: LD_ADDR_VAR 0 4
38593: PUSH
38594: LD_VAR 0 13
38598: PUSH
38599: FOR_IN
38600: IFFALSE 38696
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38602: LD_ADDR_VAR 0 8
38606: PUSH
38607: LD_VAR 0 1
38611: PPUSH
38612: CALL 24741 0 1
38616: PPUSH
38617: LD_VAR 0 4
38621: PPUSH
38622: CALL_OW 74
38626: ST_TO_ADDR
// if IsInUnit ( i ) then
38627: LD_VAR 0 4
38631: PPUSH
38632: CALL_OW 310
38636: IFFALSE 38647
// ComExitBuilding ( i ) ;
38638: LD_VAR 0 4
38642: PPUSH
38643: CALL_OW 122
// if not HasTask ( i ) and k then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 314
38656: NOT
38657: PUSH
38658: LD_VAR 0 8
38662: AND
38663: IFFALSE 38694
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38665: LD_VAR 0 4
38669: PPUSH
38670: LD_VAR 0 8
38674: PPUSH
38675: CALL_OW 250
38679: PPUSH
38680: LD_VAR 0 8
38684: PPUSH
38685: CALL_OW 251
38689: PPUSH
38690: CALL_OW 114
// end ;
38694: GO 38599
38696: POP
38697: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38698: LD_VAR 0 1
38702: PPUSH
38703: LD_INT 30
38705: PUSH
38706: LD_INT 5
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PPUSH
38713: CALL 11340 0 2
38717: IFFALSE 38984
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38719: LD_ADDR_VAR 0 11
38723: PUSH
38724: LD_VAR 0 1
38728: PPUSH
38729: LD_INT 30
38731: PUSH
38732: LD_INT 5
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PPUSH
38739: CALL 11340 0 2
38743: PUSH
38744: LD_INT 1
38746: ARRAY
38747: ST_TO_ADDR
// if mech then
38748: LD_VAR 0 15
38752: IFFALSE 38788
// for i in mech do
38754: LD_ADDR_VAR 0 4
38758: PUSH
38759: LD_VAR 0 15
38763: PUSH
38764: FOR_IN
38765: IFFALSE 38786
// MCH_ChangeClass ( side , i , 1 ) ;
38767: LD_VAR 0 1
38771: PPUSH
38772: LD_VAR 0 4
38776: PPUSH
38777: LD_INT 1
38779: PPUSH
38780: CALL 16247 0 3
38784: GO 38764
38786: POP
38787: POP
// if eng > 1 then
38788: LD_VAR 0 14
38792: PUSH
38793: LD_INT 1
38795: GREATER
38796: IFFALSE 38843
// for i = eng downto 2 do
38798: LD_ADDR_VAR 0 4
38802: PUSH
38803: DOUBLE
38804: LD_VAR 0 14
38808: INC
38809: ST_TO_ADDR
38810: LD_INT 2
38812: PUSH
38813: FOR_DOWNTO
38814: IFFALSE 38841
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38816: LD_VAR 0 1
38820: PPUSH
38821: LD_VAR 0 14
38825: PUSH
38826: LD_VAR 0 4
38830: ARRAY
38831: PPUSH
38832: LD_INT 1
38834: PPUSH
38835: CALL 16247 0 3
38839: GO 38813
38841: POP
38842: POP
// if UnitsInside ( b ) = 6 then
38843: LD_VAR 0 11
38847: PPUSH
38848: CALL_OW 313
38852: PUSH
38853: LD_INT 6
38855: EQUAL
38856: IFFALSE 38984
// begin un := UnitsInside ( b ) [ 1 ] ;
38858: LD_ADDR_VAR 0 9
38862: PUSH
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: PUSH
38873: LD_INT 1
38875: ARRAY
38876: ST_TO_ADDR
// ComExitBuilding ( un ) ;
38877: LD_VAR 0 9
38881: PPUSH
38882: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
38886: LD_VAR 0 1
38890: PPUSH
38891: LD_INT 30
38893: PUSH
38894: LD_INT 5
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PPUSH
38901: CALL 11340 0 2
38905: PUSH
38906: LD_INT 1
38908: GREATER
38909: PUSH
38910: LD_VAR 0 1
38914: PPUSH
38915: CALL 24741 0 1
38919: PUSH
38920: LD_INT 4
38922: GREATEREQUAL
38923: AND
38924: IFFALSE 38984
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
38926: LD_ADDR_VAR 0 8
38930: PUSH
38931: LD_VAR 0 1
38935: PPUSH
38936: LD_INT 30
38938: PUSH
38939: LD_INT 5
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PPUSH
38946: CALL 11340 0 2
38950: PUSH
38951: LD_INT 2
38953: ARRAY
38954: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
38955: LD_VAR 0 8
38959: PPUSH
38960: CALL_OW 313
38964: PUSH
38965: LD_INT 6
38967: LESS
38968: IFFALSE 38984
// AddComEnterUnit ( un , k ) ;
38970: LD_VAR 0 9
38974: PPUSH
38975: LD_VAR 0 8
38979: PPUSH
38980: CALL_OW 180
// end ; end ; end ; end else
38984: GO 40567
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38986: LD_VAR 0 1
38990: PPUSH
38991: LD_INT 1
38993: PPUSH
38994: LD_EXP 67
38998: PUSH
38999: LD_VAR 0 1
39003: ARRAY
39004: PUSH
39005: LD_INT 1
39007: ARRAY
39008: PPUSH
39009: CALL 33719 0 3
39013: IFFALSE 39152
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39015: LD_ADDR_VAR 0 12
39019: PUSH
39020: LD_VAR 0 1
39024: PPUSH
39025: LD_INT 21
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PPUSH
39035: CALL 11340 0 2
39039: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39040: LD_ADDR_VAR 0 11
39044: PUSH
39045: LD_VAR 0 1
39049: PPUSH
39050: LD_INT 30
39052: PUSH
39053: LD_INT 1
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PPUSH
39060: CALL 11340 0 2
39064: ST_TO_ADDR
// if b then
39065: LD_VAR 0 11
39069: IFFALSE 39152
// for i in tmp do
39071: LD_ADDR_VAR 0 4
39075: PUSH
39076: LD_VAR 0 12
39080: PUSH
39081: FOR_IN
39082: IFFALSE 39150
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39084: LD_VAR 0 4
39088: PPUSH
39089: LD_EXP 67
39093: PUSH
39094: LD_VAR 0 1
39098: ARRAY
39099: PUSH
39100: LD_INT 1
39102: ARRAY
39103: PPUSH
39104: CALL_OW 308
39108: NOT
39109: IFFALSE 39148
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39111: LD_VAR 0 4
39115: PPUSH
39116: LD_VAR 0 11
39120: PUSH
39121: LD_INT 1
39123: ARRAY
39124: PPUSH
39125: CALL_OW 250
39129: PPUSH
39130: LD_VAR 0 11
39134: PUSH
39135: LD_INT 1
39137: ARRAY
39138: PPUSH
39139: CALL_OW 251
39143: PPUSH
39144: CALL_OW 111
39148: GO 39081
39150: POP
39151: POP
// end ; if MREG_DefVeh [ side ] then
39152: LD_EXP 69
39156: PUSH
39157: LD_VAR 0 1
39161: ARRAY
39162: IFFALSE 39730
// begin tmp := [ ] ;
39164: LD_ADDR_VAR 0 12
39168: PUSH
39169: EMPTY
39170: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39171: LD_EXP 72
39175: PUSH
39176: LD_VAR 0 1
39180: ARRAY
39181: PUSH
39182: LD_INT 0
39184: EQUAL
39185: IFFALSE 39325
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39187: LD_ADDR_VAR 0 8
39191: PUSH
39192: LD_VAR 0 1
39196: PPUSH
39197: LD_INT 0
39199: PPUSH
39200: LD_INT 25
39202: PUSH
39203: LD_INT 3
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PPUSH
39210: CALL 12043 0 3
39214: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39215: LD_VAR 0 8
39219: PUSH
39220: LD_EXP 69
39224: PUSH
39225: LD_VAR 0 1
39229: ARRAY
39230: GREATER
39231: IFFALSE 39292
// begin for i = 1 to MREG_DefVeh [ side ] do
39233: LD_ADDR_VAR 0 4
39237: PUSH
39238: DOUBLE
39239: LD_INT 1
39241: DEC
39242: ST_TO_ADDR
39243: LD_EXP 69
39247: PUSH
39248: LD_VAR 0 1
39252: ARRAY
39253: PUSH
39254: FOR_TO
39255: IFFALSE 39288
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39257: LD_ADDR_VAR 0 12
39261: PUSH
39262: LD_VAR 0 12
39266: PPUSH
39267: LD_INT 1
39269: PPUSH
39270: LD_VAR 0 8
39274: PUSH
39275: LD_VAR 0 4
39279: ARRAY
39280: PPUSH
39281: CALL_OW 2
39285: ST_TO_ADDR
39286: GO 39254
39288: POP
39289: POP
// end else
39290: GO 39302
// tmp := k ;
39292: LD_ADDR_VAR 0 12
39296: PUSH
39297: LD_VAR 0 8
39301: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39302: LD_ADDR_EXP 72
39306: PUSH
39307: LD_EXP 72
39311: PPUSH
39312: LD_VAR 0 1
39316: PPUSH
39317: LD_INT 1
39319: PPUSH
39320: CALL_OW 1
39324: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39325: LD_ADDR_VAR 0 4
39329: PUSH
39330: LD_EXP 69
39334: PUSH
39335: LD_VAR 0 1
39339: ARRAY
39340: PUSH
39341: FOR_IN
39342: IFFALSE 39728
// begin if not GetDriver ( i ) then
39344: LD_VAR 0 4
39348: PPUSH
39349: CALL 31468 0 1
39353: NOT
39354: IFFALSE 39429
// begin if tmp then
39356: LD_VAR 0 12
39360: IFFALSE 39427
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39362: LD_VAR 0 12
39366: PUSH
39367: LD_INT 1
39369: ARRAY
39370: PPUSH
39371: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39375: LD_VAR 0 12
39379: PUSH
39380: LD_INT 1
39382: ARRAY
39383: PPUSH
39384: LD_VAR 0 4
39388: PPUSH
39389: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39393: LD_VAR 0 12
39397: PUSH
39398: LD_INT 1
39400: ARRAY
39401: PPUSH
39402: LD_INT 36
39404: PPUSH
39405: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39409: LD_ADDR_VAR 0 12
39413: PUSH
39414: LD_VAR 0 12
39418: PPUSH
39419: LD_INT 1
39421: PPUSH
39422: CALL_OW 3
39426: ST_TO_ADDR
// end ; end else
39427: GO 39726
// begin if GetTag ( i ) = 0 then
39429: LD_VAR 0 4
39433: PPUSH
39434: CALL_OW 110
39438: PUSH
39439: LD_INT 0
39441: EQUAL
39442: IFFALSE 39458
// SetTag ( i , 31 ) else
39444: LD_VAR 0 4
39448: PPUSH
39449: LD_INT 31
39451: PPUSH
39452: CALL_OW 109
39456: GO 39726
// if GetTag ( i ) = 31 then
39458: LD_VAR 0 4
39462: PPUSH
39463: CALL_OW 110
39467: PUSH
39468: LD_INT 31
39470: EQUAL
39471: IFFALSE 39726
// begin if GetFuel ( i ) < 20 then
39473: LD_VAR 0 4
39477: PPUSH
39478: CALL_OW 261
39482: PUSH
39483: LD_INT 20
39485: LESS
39486: IFFALSE 39511
// begin SetTag ( i , 21 ) ;
39488: LD_VAR 0 4
39492: PPUSH
39493: LD_INT 21
39495: PPUSH
39496: CALL_OW 109
// MCV_Refuel ( i ) ;
39500: LD_VAR 0 4
39504: PPUSH
39505: CALL 26038 0 1
// continue ;
39509: GO 39341
// end ; if GetLives ( i ) < 700 then
39511: LD_VAR 0 4
39515: PPUSH
39516: CALL_OW 256
39520: PUSH
39521: LD_INT 700
39523: LESS
39524: IFFALSE 39636
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39526: LD_VAR 0 4
39530: PPUSH
39531: LD_EXP 60
39535: PUSH
39536: LD_VAR 0 1
39540: ARRAY
39541: PPUSH
39542: CALL_OW 308
39546: NOT
39547: IFFALSE 39571
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39549: LD_VAR 0 4
39553: PPUSH
39554: LD_EXP 60
39558: PUSH
39559: LD_VAR 0 1
39563: ARRAY
39564: PPUSH
39565: CALL_OW 113
39569: GO 39634
// if GetDriver ( i ) then
39571: LD_VAR 0 4
39575: PPUSH
39576: CALL 31468 0 1
39580: IFFALSE 39634
// begin k := GetDriver ( i ) ;
39582: LD_ADDR_VAR 0 8
39586: PUSH
39587: LD_VAR 0 4
39591: PPUSH
39592: CALL 31468 0 1
39596: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39597: LD_VAR 0 8
39601: PPUSH
39602: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39606: LD_VAR 0 8
39610: PPUSH
39611: LD_VAR 0 4
39615: PPUSH
39616: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39620: LD_VAR 0 8
39624: PPUSH
39625: LD_VAR 0 4
39629: PPUSH
39630: CALL_OW 180
// end ; end else
39634: GO 39726
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39636: LD_ADDR_VAR 0 8
39640: PUSH
39641: LD_VAR 0 1
39645: PPUSH
39646: CALL 24741 0 1
39650: PPUSH
39651: LD_VAR 0 4
39655: PPUSH
39656: CALL_OW 74
39660: ST_TO_ADDR
// if k then
39661: LD_VAR 0 8
39665: IFFALSE 39683
// ComAttackUnit ( i , k ) else
39667: LD_VAR 0 4
39671: PPUSH
39672: LD_VAR 0 8
39676: PPUSH
39677: CALL_OW 115
39681: GO 39726
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39683: LD_VAR 0 4
39687: PPUSH
39688: LD_EXP 60
39692: PUSH
39693: LD_VAR 0 1
39697: ARRAY
39698: PPUSH
39699: CALL_OW 308
39703: NOT
39704: IFFALSE 39726
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39706: LD_VAR 0 4
39710: PPUSH
39711: LD_EXP 60
39715: PUSH
39716: LD_VAR 0 1
39720: ARRAY
39721: PPUSH
39722: CALL_OW 113
// end ; end ; end ; end ;
39726: GO 39341
39728: POP
39729: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39730: LD_VAR 0 1
39734: PPUSH
39735: LD_INT 30
39737: PUSH
39738: LD_INT 5
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PPUSH
39745: CALL 11340 0 2
39749: IFFALSE 40567
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39751: LD_ADDR_VAR 0 11
39755: PUSH
39756: LD_VAR 0 1
39760: PPUSH
39761: LD_INT 30
39763: PUSH
39764: LD_INT 5
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PPUSH
39771: CALL 11340 0 2
39775: PUSH
39776: LD_INT 1
39778: ARRAY
39779: ST_TO_ADDR
// if eng > 1 then
39780: LD_VAR 0 14
39784: PUSH
39785: LD_INT 1
39787: GREATER
39788: IFFALSE 39835
// for i = eng downto 2 do
39790: LD_ADDR_VAR 0 4
39794: PUSH
39795: DOUBLE
39796: LD_VAR 0 14
39800: INC
39801: ST_TO_ADDR
39802: LD_INT 2
39804: PUSH
39805: FOR_DOWNTO
39806: IFFALSE 39833
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39808: LD_VAR 0 1
39812: PPUSH
39813: LD_VAR 0 14
39817: PUSH
39818: LD_VAR 0 4
39822: ARRAY
39823: PPUSH
39824: LD_INT 1
39826: PPUSH
39827: CALL 16247 0 3
39831: GO 39805
39833: POP
39834: POP
// if sci > 1 then
39835: LD_VAR 0 16
39839: PUSH
39840: LD_INT 1
39842: GREATER
39843: IFFALSE 39890
// for i = sci downto 2 do
39845: LD_ADDR_VAR 0 4
39849: PUSH
39850: DOUBLE
39851: LD_VAR 0 16
39855: INC
39856: ST_TO_ADDR
39857: LD_INT 2
39859: PUSH
39860: FOR_DOWNTO
39861: IFFALSE 39888
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39863: LD_VAR 0 1
39867: PPUSH
39868: LD_VAR 0 16
39872: PUSH
39873: LD_VAR 0 4
39877: ARRAY
39878: PPUSH
39879: LD_INT 1
39881: PPUSH
39882: CALL 16247 0 3
39886: GO 39860
39888: POP
39889: POP
// if sol then
39890: LD_VAR 0 13
39894: IFFALSE 40567
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39896: LD_VAR 0 13
39900: PUSH
39901: LD_EXP 70
39905: PUSH
39906: LD_VAR 0 1
39910: ARRAY
39911: DIFF
39912: PUSH
39913: LD_INT 22
39915: PUSH
39916: LD_VAR 0 1
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 58
39927: PUSH
39928: EMPTY
39929: LIST
39930: PUSH
39931: LD_INT 2
39933: PUSH
39934: LD_INT 30
39936: PUSH
39937: LD_INT 32
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 30
39946: PUSH
39947: LD_INT 31
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: LIST
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: LIST
39963: PPUSH
39964: CALL_OW 69
39968: PUSH
39969: LD_INT 0
39971: EQUAL
39972: AND
39973: IFFALSE 40567
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39975: LD_ADDR_VAR 0 12
39979: PUSH
39980: LD_VAR 0 13
39984: PUSH
39985: LD_EXP 70
39989: PUSH
39990: LD_VAR 0 1
39994: ARRAY
39995: DIFF
39996: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39997: LD_VAR 0 1
40001: PPUSH
40002: LD_INT 30
40004: PUSH
40005: LD_INT 5
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PPUSH
40012: CALL 11340 0 2
40016: PUSH
40017: LD_INT 1
40019: GREATER
40020: IFFALSE 40051
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40022: LD_ADDR_VAR 0 8
40026: PUSH
40027: LD_VAR 0 1
40031: PPUSH
40032: LD_INT 30
40034: PUSH
40035: LD_INT 5
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PPUSH
40042: CALL 11340 0 2
40046: PUSH
40047: LD_INT 2
40049: ARRAY
40050: ST_TO_ADDR
// for j in tmp do
40051: LD_ADDR_VAR 0 5
40055: PUSH
40056: LD_VAR 0 12
40060: PUSH
40061: FOR_IN
40062: IFFALSE 40565
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40064: LD_VAR 0 5
40068: PUSH
40069: LD_VAR 0 11
40073: PPUSH
40074: CALL_OW 313
40078: IN
40079: PUSH
40080: LD_VAR 0 11
40084: PPUSH
40085: CALL_OW 313
40089: PUSH
40090: LD_INT 6
40092: EQUAL
40093: AND
40094: PUSH
40095: LD_VAR 0 8
40099: AND
40100: PUSH
40101: LD_VAR 0 8
40105: PPUSH
40106: CALL_OW 313
40110: PUSH
40111: LD_INT 6
40113: LESS
40114: AND
40115: IFFALSE 40142
// begin ComExitBuilding ( j ) ;
40117: LD_VAR 0 5
40121: PPUSH
40122: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40126: LD_VAR 0 5
40130: PPUSH
40131: LD_VAR 0 8
40135: PPUSH
40136: CALL_OW 180
// continue ;
40140: GO 40061
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40142: LD_VAR 0 5
40146: PPUSH
40147: CALL_OW 314
40151: NOT
40152: PUSH
40153: LD_VAR 0 5
40157: PPUSH
40158: CALL_OW 110
40162: PUSH
40163: LD_INT 0
40165: EQUAL
40166: AND
40167: PUSH
40168: LD_VAR 0 5
40172: PPUSH
40173: CALL_OW 310
40177: NOT
40178: AND
40179: IFFALSE 40285
// begin if k then
40181: LD_VAR 0 8
40185: IFFALSE 40256
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40187: LD_VAR 0 8
40191: PPUSH
40192: CALL_OW 313
40196: PUSH
40197: LD_VAR 0 11
40201: PPUSH
40202: CALL_OW 313
40206: LESS
40207: IFFALSE 40225
// ComEnterUnit ( j , k ) else
40209: LD_VAR 0 5
40213: PPUSH
40214: LD_VAR 0 8
40218: PPUSH
40219: CALL_OW 120
40223: GO 40254
// if UnitsInside ( b ) < 6 then
40225: LD_VAR 0 11
40229: PPUSH
40230: CALL_OW 313
40234: PUSH
40235: LD_INT 6
40237: LESS
40238: IFFALSE 40254
// ComEnterUnit ( j , b ) ;
40240: LD_VAR 0 5
40244: PPUSH
40245: LD_VAR 0 11
40249: PPUSH
40250: CALL_OW 120
// end else
40254: GO 40285
// if UnitsInside ( b ) < 6 then
40256: LD_VAR 0 11
40260: PPUSH
40261: CALL_OW 313
40265: PUSH
40266: LD_INT 6
40268: LESS
40269: IFFALSE 40285
// ComEnterUnit ( j , b ) ;
40271: LD_VAR 0 5
40275: PPUSH
40276: LD_VAR 0 11
40280: PPUSH
40281: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40285: LD_VAR 0 5
40289: PUSH
40290: LD_VAR 0 1
40294: PPUSH
40295: LD_INT 54
40297: PUSH
40298: EMPTY
40299: LIST
40300: PPUSH
40301: CALL 11340 0 2
40305: IN
40306: PUSH
40307: LD_VAR 0 5
40311: PPUSH
40312: CALL_OW 257
40316: PUSH
40317: LD_INT 1
40319: EQUAL
40320: AND
40321: IFFALSE 40563
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40323: LD_EXP 64
40327: PUSH
40328: LD_VAR 0 1
40332: ARRAY
40333: PUSH
40334: LD_INT 1
40336: ARRAY
40337: PUSH
40338: LD_INT 12
40340: PPUSH
40341: LD_VAR 0 1
40345: PPUSH
40346: CALL_OW 321
40350: PUSH
40351: LD_INT 2
40353: EQUAL
40354: AND
40355: IFFALSE 40403
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40357: LD_VAR 0 1
40361: PPUSH
40362: LD_INT 5
40364: PPUSH
40365: EMPTY
40366: PPUSH
40367: CALL 11423 0 3
40371: PUSH
40372: LD_EXP 64
40376: PUSH
40377: LD_VAR 0 1
40381: ARRAY
40382: PUSH
40383: LD_INT 1
40385: ARRAY
40386: LESS
40387: IFFALSE 40403
// begin SetClass ( j , class_sniper ) ;
40389: LD_VAR 0 5
40393: PPUSH
40394: LD_INT 5
40396: PPUSH
40397: CALL_OW 336
// continue ;
40401: GO 40061
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40403: LD_EXP 64
40407: PUSH
40408: LD_VAR 0 1
40412: ARRAY
40413: PUSH
40414: LD_INT 2
40416: ARRAY
40417: PUSH
40418: LD_INT 41
40420: PPUSH
40421: LD_VAR 0 1
40425: PPUSH
40426: CALL_OW 321
40430: PUSH
40431: LD_INT 2
40433: EQUAL
40434: AND
40435: IFFALSE 40483
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40437: LD_VAR 0 1
40441: PPUSH
40442: LD_INT 8
40444: PPUSH
40445: EMPTY
40446: PPUSH
40447: CALL 11423 0 3
40451: PUSH
40452: LD_EXP 64
40456: PUSH
40457: LD_VAR 0 1
40461: ARRAY
40462: PUSH
40463: LD_INT 2
40465: ARRAY
40466: LESS
40467: IFFALSE 40483
// begin SetClass ( j , class_mortar ) ;
40469: LD_VAR 0 5
40473: PPUSH
40474: LD_INT 8
40476: PPUSH
40477: CALL_OW 336
// continue ;
40481: GO 40061
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40483: LD_EXP 64
40487: PUSH
40488: LD_VAR 0 1
40492: ARRAY
40493: PUSH
40494: LD_INT 3
40496: ARRAY
40497: PUSH
40498: LD_INT 44
40500: PPUSH
40501: LD_VAR 0 1
40505: PPUSH
40506: CALL_OW 321
40510: PUSH
40511: LD_INT 2
40513: EQUAL
40514: AND
40515: IFFALSE 40563
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40517: LD_VAR 0 1
40521: PPUSH
40522: LD_INT 9
40524: PPUSH
40525: EMPTY
40526: PPUSH
40527: CALL 11423 0 3
40531: PUSH
40532: LD_EXP 64
40536: PUSH
40537: LD_VAR 0 1
40541: ARRAY
40542: PUSH
40543: LD_INT 3
40545: ARRAY
40546: LESS
40547: IFFALSE 40563
// begin SetClass ( j , class_bazooker ) ;
40549: LD_VAR 0 5
40553: PPUSH
40554: LD_INT 9
40556: PPUSH
40557: CALL_OW 336
// continue ;
40561: GO 40061
// end ; end ; end ;
40563: GO 40061
40565: POP
40566: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40567: LD_INT 22
40569: PUSH
40570: LD_VAR 0 1
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 58
40581: PUSH
40582: EMPTY
40583: LIST
40584: PUSH
40585: LD_INT 30
40587: PUSH
40588: LD_INT 32
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: LIST
40599: PPUSH
40600: CALL_OW 69
40604: IFFALSE 40754
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40606: LD_ADDR_VAR 0 12
40610: PUSH
40611: LD_INT 22
40613: PUSH
40614: LD_VAR 0 1
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 58
40625: PUSH
40626: EMPTY
40627: LIST
40628: PUSH
40629: LD_INT 30
40631: PUSH
40632: LD_INT 32
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: LIST
40643: PPUSH
40644: CALL_OW 69
40648: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40649: LD_ADDR_VAR 0 8
40653: PUSH
40654: LD_VAR 0 13
40658: PUSH
40659: LD_EXP 70
40663: PUSH
40664: LD_VAR 0 1
40668: ARRAY
40669: DIFF
40670: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40671: LD_VAR 0 12
40675: PUSH
40676: LD_INT 1
40678: ARRAY
40679: PPUSH
40680: CALL_OW 461
40684: PUSH
40685: LD_INT 2
40687: EQUAL
40688: PUSH
40689: LD_VAR 0 12
40693: PUSH
40694: LD_INT 1
40696: ARRAY
40697: PUSH
40698: LD_EXP 70
40702: PUSH
40703: LD_VAR 0 1
40707: ARRAY
40708: IN
40709: NOT
40710: AND
40711: PUSH
40712: LD_VAR 0 8
40716: AND
40717: IFFALSE 40754
// begin ComExitBuilding ( k [ 1 ] ) ;
40719: LD_VAR 0 8
40723: PUSH
40724: LD_INT 1
40726: ARRAY
40727: PPUSH
40728: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40732: LD_VAR 0 8
40736: PUSH
40737: LD_INT 1
40739: ARRAY
40740: PPUSH
40741: LD_VAR 0 12
40745: PUSH
40746: LD_INT 1
40748: ARRAY
40749: PPUSH
40750: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40754: LD_EXP 37
40758: PUSH
40759: LD_VAR 0 1
40763: ARRAY
40764: IFFALSE 40912
// begin if MCF_Class ( side , 4 , [ ] ) then
40766: LD_VAR 0 1
40770: PPUSH
40771: LD_INT 4
40773: PPUSH
40774: EMPTY
40775: PPUSH
40776: CALL 11423 0 3
40780: IFFALSE 40910
// for j in MCF_Class ( side , 4 , [ ] ) do
40782: LD_ADDR_VAR 0 5
40786: PUSH
40787: LD_VAR 0 1
40791: PPUSH
40792: LD_INT 4
40794: PPUSH
40795: EMPTY
40796: PPUSH
40797: CALL 11423 0 3
40801: PUSH
40802: FOR_IN
40803: IFFALSE 40908
// begin if not GetTag ( j ) = 4 then
40805: LD_VAR 0 5
40809: PPUSH
40810: CALL_OW 110
40814: PUSH
40815: LD_INT 4
40817: EQUAL
40818: NOT
40819: IFFALSE 40855
// begin SetTag ( j , 4 ) ;
40821: LD_VAR 0 5
40825: PPUSH
40826: LD_INT 4
40828: PPUSH
40829: CALL_OW 109
// if IsInUnit ( j ) then
40833: LD_VAR 0 5
40837: PPUSH
40838: CALL_OW 310
40842: IFFALSE 40853
// ComExitBuilding ( j ) ;
40844: LD_VAR 0 5
40848: PPUSH
40849: CALL_OW 122
// end else
40853: GO 40906
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40855: LD_VAR 0 5
40859: PPUSH
40860: LD_EXP 37
40864: PUSH
40865: LD_VAR 0 1
40869: ARRAY
40870: PUSH
40871: LD_INT 1
40873: ARRAY
40874: PPUSH
40875: CALL 32159 0 2
40879: NOT
40880: IFFALSE 40906
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40882: LD_VAR 0 5
40886: PPUSH
40887: LD_EXP 37
40891: PUSH
40892: LD_VAR 0 1
40896: ARRAY
40897: PUSH
40898: LD_INT 1
40900: ARRAY
40901: PPUSH
40902: CALL 18910 0 2
// end ;
40906: GO 40802
40908: POP
40909: POP
// end else
40910: GO 41144
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40912: LD_VAR 0 1
40916: PPUSH
40917: LD_INT 4
40919: PPUSH
40920: EMPTY
40921: PPUSH
40922: CALL 11423 0 3
40926: PUSH
40927: LD_VAR 0 1
40931: PPUSH
40932: LD_INT 4
40934: PPUSH
40935: EMPTY
40936: PPUSH
40937: CALL 12043 0 3
40941: AND
40942: IFFALSE 41144
// for j in MCF_Class ( side , 4 , [ ] ) do
40944: LD_ADDR_VAR 0 5
40948: PUSH
40949: LD_VAR 0 1
40953: PPUSH
40954: LD_INT 4
40956: PPUSH
40957: EMPTY
40958: PPUSH
40959: CALL 11423 0 3
40963: PUSH
40964: FOR_IN
40965: IFFALSE 41142
// begin if GetTag ( j ) = 4 then
40967: LD_VAR 0 5
40971: PPUSH
40972: CALL_OW 110
40976: PUSH
40977: LD_INT 4
40979: EQUAL
40980: IFFALSE 41140
// begin SetTag ( j , 0 ) ;
40982: LD_VAR 0 5
40986: PPUSH
40987: LD_INT 0
40989: PPUSH
40990: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40994: LD_VAR 0 1
40998: PPUSH
40999: CALL 11379 0 1
41003: PUSH
41004: LD_VAR 0 1
41008: PPUSH
41009: CALL 17723 0 1
41013: NOT
41014: AND
41015: IFFALSE 41040
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41017: LD_VAR 0 5
41021: PPUSH
41022: LD_VAR 0 1
41026: PPUSH
41027: CALL 11379 0 1
41031: PUSH
41032: LD_INT 1
41034: ARRAY
41035: PPUSH
41036: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41040: LD_VAR 0 1
41044: PPUSH
41045: CALL 11379 0 1
41049: NOT
41050: PUSH
41051: LD_VAR 0 1
41055: PPUSH
41056: LD_INT 30
41058: PUSH
41059: LD_INT 1
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PPUSH
41066: CALL 11340 0 2
41070: AND
41071: IFFALSE 41140
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41073: LD_VAR 0 5
41077: PPUSH
41078: LD_VAR 0 1
41082: PPUSH
41083: LD_INT 30
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PPUSH
41093: CALL 11340 0 2
41097: PUSH
41098: LD_INT 1
41100: ARRAY
41101: PPUSH
41102: CALL_OW 250
41106: PPUSH
41107: LD_VAR 0 1
41111: PPUSH
41112: LD_INT 30
41114: PUSH
41115: LD_INT 1
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PPUSH
41122: CALL 11340 0 2
41126: PUSH
41127: LD_INT 1
41129: ARRAY
41130: PPUSH
41131: CALL_OW 251
41135: PPUSH
41136: CALL_OW 111
// end ; end ;
41140: GO 40964
41142: POP
41143: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41144: LD_VAR 0 1
41148: PPUSH
41149: LD_INT 3
41151: PPUSH
41152: EMPTY
41153: PPUSH
41154: CALL 11423 0 3
41158: PUSH
41159: LD_EXP 60
41163: PUSH
41164: LD_VAR 0 1
41168: ARRAY
41169: AND
41170: PUSH
41171: LD_VAR 0 1
41175: PPUSH
41176: LD_INT 6
41178: PPUSH
41179: EMPTY
41180: PPUSH
41181: CALL 12043 0 3
41185: AND
41186: IFFALSE 41717
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41188: LD_ADDR_VAR 0 6
41192: PUSH
41193: LD_EXP 60
41197: PUSH
41198: LD_VAR 0 1
41202: ARRAY
41203: PPUSH
41204: LD_INT 0
41206: PPUSH
41207: CALL_OW 517
41211: PUSH
41212: LD_INT 1
41214: ARRAY
41215: PUSH
41216: LD_INT 1
41218: ARRAY
41219: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41220: LD_ADDR_VAR 0 7
41224: PUSH
41225: LD_EXP 60
41229: PUSH
41230: LD_VAR 0 1
41234: ARRAY
41235: PPUSH
41236: LD_INT 0
41238: PPUSH
41239: CALL_OW 517
41243: PUSH
41244: LD_INT 2
41246: ARRAY
41247: PUSH
41248: LD_INT 1
41250: ARRAY
41251: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41252: LD_VAR 0 1
41256: PPUSH
41257: LD_INT 6
41259: PPUSH
41260: EMPTY
41261: PPUSH
41262: CALL 12043 0 3
41266: IFFALSE 41715
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41268: LD_ADDR_VAR 0 8
41272: PUSH
41273: LD_VAR 0 1
41277: PPUSH
41278: LD_INT 6
41280: PPUSH
41281: EMPTY
41282: PPUSH
41283: CALL 12043 0 3
41287: PUSH
41288: FOR_IN
41289: IFFALSE 41320
// if GetLives ( k ) = 1000 then
41291: LD_VAR 0 8
41295: PPUSH
41296: CALL_OW 256
41300: PUSH
41301: LD_INT 1000
41303: EQUAL
41304: IFFALSE 41318
// SetTag ( k , 0 ) ;
41306: LD_VAR 0 8
41310: PPUSH
41311: LD_INT 0
41313: PPUSH
41314: CALL_OW 109
41318: GO 41288
41320: POP
41321: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41322: LD_VAR 0 1
41326: PPUSH
41327: LD_INT 0
41329: PPUSH
41330: LD_INT 25
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PPUSH
41340: CALL 12043 0 3
41344: IFFALSE 41408
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41346: LD_ADDR_VAR 0 8
41350: PUSH
41351: LD_VAR 0 4
41355: PPUSH
41356: LD_INT 0
41358: PPUSH
41359: LD_INT 25
41361: PUSH
41362: LD_INT 3
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PPUSH
41369: CALL 12043 0 3
41373: PUSH
41374: FOR_IN
41375: IFFALSE 41406
// if GetTag ( k ) = 0 then
41377: LD_VAR 0 8
41381: PPUSH
41382: CALL_OW 110
41386: PUSH
41387: LD_INT 0
41389: EQUAL
41390: IFFALSE 41404
// begin SetTag ( k , 8 ) ;
41392: LD_VAR 0 8
41396: PPUSH
41397: LD_INT 8
41399: PPUSH
41400: CALL_OW 109
// end ;
41404: GO 41374
41406: POP
41407: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41408: LD_VAR 0 1
41412: PPUSH
41413: LD_INT 6
41415: PPUSH
41416: LD_INT 92
41418: PUSH
41419: LD_VAR 0 6
41423: PUSH
41424: LD_VAR 0 7
41428: PUSH
41429: LD_INT 10
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: PPUSH
41438: CALL 12043 0 3
41442: IFFALSE 41566
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41444: LD_ADDR_VAR 0 5
41448: PUSH
41449: LD_VAR 0 4
41453: PPUSH
41454: LD_INT 6
41456: PPUSH
41457: LD_INT 92
41459: PUSH
41460: LD_VAR 0 6
41464: PUSH
41465: LD_VAR 0 7
41469: PUSH
41470: LD_INT 10
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: LIST
41477: LIST
41478: PPUSH
41479: CALL 12043 0 3
41483: PUSH
41484: FOR_IN
41485: IFFALSE 41564
// begin if not HasTask ( j ) and GetDriver ( j ) then
41487: LD_VAR 0 5
41491: PPUSH
41492: CALL_OW 314
41496: NOT
41497: PUSH
41498: LD_VAR 0 5
41502: PPUSH
41503: CALL 31468 0 1
41507: AND
41508: IFFALSE 41562
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41510: LD_VAR 0 5
41514: PPUSH
41515: CALL 31468 0 1
41519: PPUSH
41520: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41524: LD_VAR 0 5
41528: PPUSH
41529: CALL 31468 0 1
41533: PPUSH
41534: LD_VAR 0 5
41538: PPUSH
41539: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41543: LD_VAR 0 5
41547: PPUSH
41548: CALL 31468 0 1
41552: PPUSH
41553: LD_VAR 0 5
41557: PPUSH
41558: CALL_OW 180
// end ; end ;
41562: GO 41484
41564: POP
41565: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41566: LD_VAR 0 1
41570: PPUSH
41571: LD_INT 6
41573: PPUSH
41574: LD_INT 92
41576: PUSH
41577: LD_VAR 0 6
41581: PUSH
41582: LD_VAR 0 7
41586: PUSH
41587: LD_INT 10
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: PPUSH
41596: CALL 12043 0 3
41600: PUSH
41601: LD_VAR 0 1
41605: PPUSH
41606: LD_INT 8
41608: PPUSH
41609: EMPTY
41610: PPUSH
41611: CALL 12043 0 3
41615: AND
41616: IFFALSE 41715
// for j in MCF_Tag ( side , 8 , [ ] ) do
41618: LD_ADDR_VAR 0 5
41622: PUSH
41623: LD_VAR 0 1
41627: PPUSH
41628: LD_INT 8
41630: PPUSH
41631: EMPTY
41632: PPUSH
41633: CALL 12043 0 3
41637: PUSH
41638: FOR_IN
41639: IFFALSE 41713
// begin if IsInUnit ( j ) then
41641: LD_VAR 0 5
41645: PPUSH
41646: CALL_OW 310
41650: IFFALSE 41663
// ComExitBuilding ( j ) else
41652: LD_VAR 0 5
41656: PPUSH
41657: CALL_OW 122
41661: GO 41711
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41663: LD_VAR 0 5
41667: PPUSH
41668: LD_VAR 0 1
41672: PPUSH
41673: LD_INT 6
41675: PPUSH
41676: LD_INT 92
41678: PUSH
41679: LD_VAR 0 6
41683: PUSH
41684: LD_VAR 0 7
41688: PUSH
41689: LD_INT 10
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: PPUSH
41698: CALL 12043 0 3
41702: PUSH
41703: LD_INT 1
41705: ARRAY
41706: PPUSH
41707: CALL_OW 129
// end ;
41711: GO 41638
41713: POP
41714: POP
// end ; end else
41715: GO 41772
// if MCF_Tag ( side , 8 , [ ] ) then
41717: LD_VAR 0 1
41721: PPUSH
41722: LD_INT 8
41724: PPUSH
41725: EMPTY
41726: PPUSH
41727: CALL 12043 0 3
41731: IFFALSE 41772
// for k in MCF_Tag ( side , 8 , [ ] ) do
41733: LD_ADDR_VAR 0 8
41737: PUSH
41738: LD_VAR 0 1
41742: PPUSH
41743: LD_INT 8
41745: PPUSH
41746: EMPTY
41747: PPUSH
41748: CALL 12043 0 3
41752: PUSH
41753: FOR_IN
41754: IFFALSE 41770
// SetTag ( k , 0 ) ;
41756: LD_VAR 0 8
41760: PPUSH
41761: LD_INT 0
41763: PPUSH
41764: CALL_OW 109
41768: GO 41753
41770: POP
41771: POP
// end ; end_of_file
41772: LD_VAR 0 3
41776: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41777: LD_INT 0
41779: PPUSH
// MREG_Game := [ ] ;
41780: LD_ADDR_EXP 35
41784: PUSH
41785: EMPTY
41786: ST_TO_ADDR
// MREG_Crates := [ ] ;
41787: LD_ADDR_EXP 36
41791: PUSH
41792: EMPTY
41793: ST_TO_ADDR
// MREG_Heal := [ ] ;
41794: LD_ADDR_EXP 37
41798: PUSH
41799: EMPTY
41800: ST_TO_ADDR
// MREG_Tame := [ ] ;
41801: LD_ADDR_EXP 39
41805: PUSH
41806: EMPTY
41807: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41808: LD_ADDR_EXP 40
41812: PUSH
41813: EMPTY
41814: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41815: LD_ADDR_EXP 41
41819: PUSH
41820: EMPTY
41821: ST_TO_ADDR
// MREG_LabList := [ ] ;
41822: LD_ADDR_EXP 42
41826: PUSH
41827: EMPTY
41828: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41829: LD_ADDR_EXP 43
41833: PUSH
41834: EMPTY
41835: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41836: LD_ADDR_EXP 44
41840: PUSH
41841: EMPTY
41842: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41843: LD_ADDR_EXP 45
41847: PUSH
41848: EMPTY
41849: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41850: LD_ADDR_EXP 46
41854: PUSH
41855: EMPTY
41856: ST_TO_ADDR
// MREG_Status := [ ] ;
41857: LD_ADDR_EXP 47
41861: PUSH
41862: EMPTY
41863: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41864: LD_ADDR_EXP 48
41868: PUSH
41869: EMPTY
41870: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41871: LD_ADDR_EXP 49
41875: PUSH
41876: EMPTY
41877: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41878: LD_ADDR_EXP 50
41882: PUSH
41883: EMPTY
41884: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41885: LD_ADDR_EXP 51
41889: PUSH
41890: EMPTY
41891: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41892: LD_ADDR_EXP 52
41896: PUSH
41897: EMPTY
41898: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41899: LD_ADDR_EXP 53
41903: PUSH
41904: EMPTY
41905: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41906: LD_ADDR_EXP 54
41910: PUSH
41911: EMPTY
41912: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41913: LD_ADDR_EXP 55
41917: PUSH
41918: EMPTY
41919: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41920: LD_ADDR_EXP 56
41924: PUSH
41925: EMPTY
41926: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41927: LD_ADDR_EXP 57
41931: PUSH
41932: EMPTY
41933: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41934: LD_ADDR_EXP 58
41938: PUSH
41939: EMPTY
41940: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41941: LD_ADDR_EXP 59
41945: PUSH
41946: EMPTY
41947: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41948: LD_ADDR_EXP 63
41952: PUSH
41953: EMPTY
41954: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41955: LD_ADDR_EXP 64
41959: PUSH
41960: EMPTY
41961: ST_TO_ADDR
// MREG_Parking := [ ] ;
41962: LD_ADDR_EXP 60
41966: PUSH
41967: EMPTY
41968: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41969: LD_ADDR_EXP 61
41973: PUSH
41974: EMPTY
41975: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41976: LD_ADDR_EXP 65
41980: PUSH
41981: EMPTY
41982: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41983: LD_ADDR_EXP 66
41987: PUSH
41988: EMPTY
41989: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41990: LD_ADDR_EXP 67
41994: PUSH
41995: EMPTY
41996: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41997: LD_ADDR_EXP 69
42001: PUSH
42002: EMPTY
42003: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42004: LD_ADDR_EXP 70
42008: PUSH
42009: EMPTY
42010: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42011: LD_ADDR_EXP 71
42015: PUSH
42016: EMPTY
42017: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42018: LD_ADDR_EXP 73
42022: PUSH
42023: EMPTY
42024: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42025: LD_ADDR_EXP 72
42029: PUSH
42030: EMPTY
42031: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42032: LD_ADDR_EXP 74
42036: PUSH
42037: LD_INT 300
42039: PUSH
42040: LD_INT 100
42042: PUSH
42043: LD_INT 25
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: LIST
42050: ST_TO_ADDR
// end ;
42051: LD_VAR 0 1
42055: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42056: LD_INT 0
42058: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42059: LD_VAR 0 2
42063: PUSH
42064: LD_VAR 0 3
42068: PUSH
42069: LD_VAR 0 4
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: LIST
42078: PUSH
42079: LD_VAR 0 1
42083: IN
42084: IFFALSE 42098
// result := mreg_list else
42086: LD_ADDR_VAR 0 5
42090: PUSH
42091: LD_VAR 0 1
42095: ST_TO_ADDR
42096: GO 42132
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42098: LD_ADDR_VAR 0 1
42102: PUSH
42103: LD_VAR 0 1
42107: PUSH
42108: LD_VAR 0 2
42112: PUSH
42113: LD_VAR 0 3
42117: PUSH
42118: LD_VAR 0 4
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: LIST
42127: PUSH
42128: EMPTY
42129: LIST
42130: ADD
42131: ST_TO_ADDR
// result := mreg_list ;
42132: LD_ADDR_VAR 0 5
42136: PUSH
42137: LD_VAR 0 1
42141: ST_TO_ADDR
// end ;
42142: LD_VAR 0 5
42146: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42147: LD_INT 0
42149: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42150: LD_VAR 0 2
42154: PUSH
42155: LD_VAR 0 3
42159: PUSH
42160: LD_VAR 0 4
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: LIST
42169: PUSH
42170: LD_VAR 0 1
42174: IN
42175: IFFALSE 42213
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42177: LD_ADDR_VAR 0 5
42181: PUSH
42182: LD_VAR 0 1
42186: PUSH
42187: LD_VAR 0 2
42191: PUSH
42192: LD_VAR 0 3
42196: PUSH
42197: LD_VAR 0 4
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: LIST
42206: PUSH
42207: EMPTY
42208: LIST
42209: DIFF
42210: ST_TO_ADDR
42211: GO 42223
// result := mreg_list ;
42213: LD_ADDR_VAR 0 5
42217: PUSH
42218: LD_VAR 0 1
42222: ST_TO_ADDR
// end ;
42223: LD_VAR 0 5
42227: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42228: LD_INT 0
42230: PPUSH
42231: PPUSH
42232: PPUSH
// for j = 1 to 8 do
42233: LD_ADDR_VAR 0 3
42237: PUSH
42238: DOUBLE
42239: LD_INT 1
42241: DEC
42242: ST_TO_ADDR
42243: LD_INT 8
42245: PUSH
42246: FOR_TO
42247: IFFALSE 43088
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42249: LD_VAR 0 3
42253: PPUSH
42254: LD_INT 51
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11340 0 2
42264: PUSH
42265: LD_OWVAR 2
42269: PUSH
42270: LD_VAR 0 3
42274: EQUAL
42275: NOT
42276: AND
42277: IFFALSE 42295
// MREG_SidesList := MREG_SidesList ^ 1 else
42279: LD_ADDR_EXP 41
42283: PUSH
42284: LD_EXP 41
42288: PUSH
42289: LD_INT 1
42291: ADD
42292: ST_TO_ADDR
42293: GO 42309
// MREG_SidesList := MREG_SidesList ^ 0 ;
42295: LD_ADDR_EXP 41
42299: PUSH
42300: LD_EXP 41
42304: PUSH
42305: LD_INT 0
42307: ADD
42308: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42309: LD_VAR 0 3
42313: PPUSH
42314: LD_INT 2
42316: PUSH
42317: LD_INT 34
42319: PUSH
42320: LD_INT 12
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 34
42329: PUSH
42330: LD_INT 32
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 34
42339: PUSH
42340: LD_INT 51
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: PUSH
42353: EMPTY
42354: LIST
42355: PPUSH
42356: CALL 11641 0 2
42360: IFFALSE 42461
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42362: LD_ADDR_VAR 0 2
42366: PUSH
42367: LD_VAR 0 3
42371: PPUSH
42372: LD_INT 2
42374: PUSH
42375: LD_INT 34
42377: PUSH
42378: LD_INT 12
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 34
42387: PUSH
42388: LD_INT 32
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 34
42397: PUSH
42398: LD_INT 51
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: LIST
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PPUSH
42414: CALL 11641 0 2
42418: PUSH
42419: FOR_IN
42420: IFFALSE 42459
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42422: LD_ADDR_EXP 43
42426: PUSH
42427: LD_EXP 43
42431: PPUSH
42432: LD_VAR 0 3
42436: PPUSH
42437: LD_VAR 0 2
42441: PPUSH
42442: LD_VAR 0 2
42446: PPUSH
42447: CALL_OW 264
42451: PPUSH
42452: CALL 42056 0 4
42456: ST_TO_ADDR
42457: GO 42419
42459: POP
42460: POP
// if MCF_Class ( j , 4 , [ ] ) then
42461: LD_VAR 0 3
42465: PPUSH
42466: LD_INT 4
42468: PPUSH
42469: EMPTY
42470: PPUSH
42471: CALL 11423 0 3
42475: IFFALSE 42508
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42477: LD_ADDR_EXP 56
42481: PUSH
42482: LD_EXP 56
42486: PUSH
42487: LD_VAR 0 3
42491: PPUSH
42492: LD_INT 4
42494: PPUSH
42495: EMPTY
42496: PPUSH
42497: CALL 11423 0 3
42501: PUSH
42502: EMPTY
42503: LIST
42504: ADD
42505: ST_TO_ADDR
42506: GO 42525
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42508: LD_ADDR_EXP 56
42512: PUSH
42513: LD_EXP 56
42517: PUSH
42518: LD_INT 0
42520: PUSH
42521: EMPTY
42522: LIST
42523: ADD
42524: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42525: LD_VAR 0 3
42529: PPUSH
42530: LD_INT 3
42532: PPUSH
42533: EMPTY
42534: PPUSH
42535: CALL 11423 0 3
42539: IFFALSE 42572
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42541: LD_ADDR_EXP 57
42545: PUSH
42546: LD_EXP 57
42550: PUSH
42551: LD_VAR 0 3
42555: PPUSH
42556: LD_INT 3
42558: PPUSH
42559: EMPTY
42560: PPUSH
42561: CALL 11423 0 3
42565: PUSH
42566: EMPTY
42567: LIST
42568: ADD
42569: ST_TO_ADDR
42570: GO 42589
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42572: LD_ADDR_EXP 57
42576: PUSH
42577: LD_EXP 57
42581: PUSH
42582: LD_INT 0
42584: PUSH
42585: EMPTY
42586: LIST
42587: ADD
42588: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42589: LD_VAR 0 3
42593: PPUSH
42594: LD_INT 1
42596: PPUSH
42597: EMPTY
42598: PPUSH
42599: CALL 11423 0 3
42603: IFFALSE 42636
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42605: LD_ADDR_EXP 58
42609: PUSH
42610: LD_EXP 58
42614: PUSH
42615: LD_VAR 0 3
42619: PPUSH
42620: LD_INT 1
42622: PPUSH
42623: EMPTY
42624: PPUSH
42625: CALL 11423 0 3
42629: PUSH
42630: EMPTY
42631: LIST
42632: ADD
42633: ST_TO_ADDR
42634: GO 42653
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42636: LD_ADDR_EXP 58
42640: PUSH
42641: LD_EXP 58
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: EMPTY
42650: LIST
42651: ADD
42652: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42653: LD_VAR 0 3
42657: PPUSH
42658: LD_INT 2
42660: PPUSH
42661: EMPTY
42662: PPUSH
42663: CALL 11423 0 3
42667: IFFALSE 42700
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42669: LD_ADDR_EXP 59
42673: PUSH
42674: LD_EXP 59
42678: PUSH
42679: LD_VAR 0 3
42683: PPUSH
42684: LD_INT 2
42686: PPUSH
42687: EMPTY
42688: PPUSH
42689: CALL 11423 0 3
42693: PUSH
42694: EMPTY
42695: LIST
42696: ADD
42697: ST_TO_ADDR
42698: GO 42717
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42700: LD_ADDR_EXP 59
42704: PUSH
42705: LD_EXP 59
42709: PUSH
42710: LD_INT 0
42712: PUSH
42713: EMPTY
42714: LIST
42715: ADD
42716: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42717: LD_ADDR_EXP 49
42721: PUSH
42722: LD_EXP 49
42726: PUSH
42727: LD_INT 0
42729: PUSH
42730: EMPTY
42731: LIST
42732: ADD
42733: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42734: LD_ADDR_EXP 37
42738: PUSH
42739: LD_EXP 37
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: ADD
42750: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42751: LD_ADDR_EXP 39
42755: PUSH
42756: LD_EXP 39
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: EMPTY
42765: LIST
42766: ADD
42767: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42768: LD_ADDR_EXP 60
42772: PUSH
42773: LD_EXP 60
42777: PUSH
42778: LD_INT 0
42780: PUSH
42781: EMPTY
42782: LIST
42783: ADD
42784: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42785: LD_ADDR_EXP 61
42789: PUSH
42790: LD_EXP 61
42794: PUSH
42795: LD_INT 0
42797: PUSH
42798: EMPTY
42799: LIST
42800: ADD
42801: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42802: LD_ADDR_EXP 53
42806: PUSH
42807: LD_EXP 53
42811: PUSH
42812: LD_INT 0
42814: PUSH
42815: EMPTY
42816: LIST
42817: ADD
42818: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42819: LD_ADDR_EXP 40
42823: PUSH
42824: LD_EXP 40
42828: PUSH
42829: LD_INT 0
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: LD_INT 0
42837: PUSH
42838: LD_INT 0
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: PUSH
42847: EMPTY
42848: LIST
42849: ADD
42850: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42851: LD_ADDR_EXP 62
42855: PUSH
42856: LD_EXP 62
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: EMPTY
42871: LIST
42872: ADD
42873: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42874: LD_ADDR_EXP 63
42878: PUSH
42879: LD_EXP 63
42883: PUSH
42884: LD_INT 0
42886: PUSH
42887: EMPTY
42888: LIST
42889: PUSH
42890: EMPTY
42891: LIST
42892: ADD
42893: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42894: LD_ADDR_EXP 44
42898: PUSH
42899: LD_EXP 44
42903: PUSH
42904: LD_INT 0
42906: PUSH
42907: EMPTY
42908: LIST
42909: ADD
42910: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42911: LD_ADDR_EXP 65
42915: PUSH
42916: LD_EXP 65
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: EMPTY
42925: LIST
42926: ADD
42927: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42928: LD_ADDR_EXP 66
42932: PUSH
42933: LD_EXP 66
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: EMPTY
42942: LIST
42943: ADD
42944: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42945: LD_ADDR_EXP 67
42949: PUSH
42950: LD_EXP 67
42954: PUSH
42955: LD_INT 0
42957: PUSH
42958: EMPTY
42959: LIST
42960: ADD
42961: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42962: LD_ADDR_EXP 68
42966: PUSH
42967: LD_EXP 68
42971: PUSH
42972: LD_INT 0
42974: PUSH
42975: EMPTY
42976: LIST
42977: ADD
42978: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42979: LD_ADDR_EXP 69
42983: PUSH
42984: LD_EXP 69
42988: PUSH
42989: LD_INT 0
42991: PUSH
42992: EMPTY
42993: LIST
42994: ADD
42995: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42996: LD_ADDR_EXP 70
43000: PUSH
43001: LD_EXP 70
43005: PUSH
43006: LD_INT 0
43008: PUSH
43009: EMPTY
43010: LIST
43011: ADD
43012: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43013: LD_ADDR_EXP 71
43017: PUSH
43018: LD_EXP 71
43022: PUSH
43023: LD_INT 0
43025: PUSH
43026: EMPTY
43027: LIST
43028: ADD
43029: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43030: LD_ADDR_EXP 73
43034: PUSH
43035: LD_EXP 73
43039: PUSH
43040: LD_INT 0
43042: PUSH
43043: EMPTY
43044: LIST
43045: ADD
43046: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43047: LD_ADDR_EXP 72
43051: PUSH
43052: LD_EXP 72
43056: PUSH
43057: LD_INT 0
43059: ADD
43060: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43061: LD_ADDR_EXP 64
43065: PUSH
43066: LD_EXP 64
43070: PUSH
43071: LD_INT 0
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: LD_INT 0
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: LIST
43084: ADD
43085: ST_TO_ADDR
// end ;
43086: GO 42246
43088: POP
43089: POP
// end ;
43090: LD_VAR 0 1
43094: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43095: LD_INT 0
43097: PPUSH
43098: PPUSH
43099: PPUSH
// m := false ;
43100: LD_ADDR_VAR 0 5
43104: PUSH
43105: LD_INT 0
43107: ST_TO_ADDR
// for i = 1 to mreg do
43108: LD_ADDR_VAR 0 4
43112: PUSH
43113: DOUBLE
43114: LD_INT 1
43116: DEC
43117: ST_TO_ADDR
43118: LD_VAR 0 2
43122: PUSH
43123: FOR_TO
43124: IFFALSE 43160
// if mreg [ i ] [ 1 ] = side then
43126: LD_VAR 0 2
43130: PUSH
43131: LD_VAR 0 4
43135: ARRAY
43136: PUSH
43137: LD_INT 1
43139: ARRAY
43140: PUSH
43141: LD_VAR 0 1
43145: EQUAL
43146: IFFALSE 43158
// begin m := true ;
43148: LD_ADDR_VAR 0 5
43152: PUSH
43153: LD_INT 1
43155: ST_TO_ADDR
// break ;
43156: GO 43160
// end ;
43158: GO 43123
43160: POP
43161: POP
// result := m ;
43162: LD_ADDR_VAR 0 3
43166: PUSH
43167: LD_VAR 0 5
43171: ST_TO_ADDR
// end ;
43172: LD_VAR 0 3
43176: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43177: LD_INT 0
43179: PPUSH
43180: PPUSH
43181: PPUSH
// m := 0 ;
43182: LD_ADDR_VAR 0 5
43186: PUSH
43187: LD_INT 0
43189: ST_TO_ADDR
// for i = 1 to mreg do
43190: LD_ADDR_VAR 0 4
43194: PUSH
43195: DOUBLE
43196: LD_INT 1
43198: DEC
43199: ST_TO_ADDR
43200: LD_VAR 0 2
43204: PUSH
43205: FOR_TO
43206: IFFALSE 43246
// if mreg [ i ] [ 1 ] = side then
43208: LD_VAR 0 2
43212: PUSH
43213: LD_VAR 0 4
43217: ARRAY
43218: PUSH
43219: LD_INT 1
43221: ARRAY
43222: PUSH
43223: LD_VAR 0 1
43227: EQUAL
43228: IFFALSE 43244
// begin m := m + 1 ;
43230: LD_ADDR_VAR 0 5
43234: PUSH
43235: LD_VAR 0 5
43239: PUSH
43240: LD_INT 1
43242: PLUS
43243: ST_TO_ADDR
// end ;
43244: GO 43205
43246: POP
43247: POP
// result := m ;
43248: LD_ADDR_VAR 0 3
43252: PUSH
43253: LD_VAR 0 5
43257: ST_TO_ADDR
// end ;
43258: LD_VAR 0 3
43262: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43263: LD_INT 0
43265: PPUSH
43266: PPUSH
// result := 0 ;
43267: LD_ADDR_VAR 0 3
43271: PUSH
43272: LD_INT 0
43274: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43275: LD_ADDR_VAR 0 4
43279: PUSH
43280: DOUBLE
43281: LD_INT 1
43283: DEC
43284: ST_TO_ADDR
43285: LD_EXP 55
43289: PUSH
43290: FOR_TO
43291: IFFALSE 43353
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43293: LD_EXP 55
43297: PUSH
43298: LD_VAR 0 4
43302: ARRAY
43303: PUSH
43304: LD_INT 1
43306: ARRAY
43307: PUSH
43308: LD_VAR 0 1
43312: EQUAL
43313: PUSH
43314: LD_EXP 55
43318: PUSH
43319: LD_VAR 0 4
43323: ARRAY
43324: PUSH
43325: LD_INT 2
43327: ARRAY
43328: PUSH
43329: LD_VAR 0 2
43333: EQUAL
43334: AND
43335: IFFALSE 43351
// begin result := result + 1 ;
43337: LD_ADDR_VAR 0 3
43341: PUSH
43342: LD_VAR 0 3
43346: PUSH
43347: LD_INT 1
43349: PLUS
43350: ST_TO_ADDR
// end ;
43351: GO 43290
43353: POP
43354: POP
// end ;
43355: LD_VAR 0 3
43359: RET
