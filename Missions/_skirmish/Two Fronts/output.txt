// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41697 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42148 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31789 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31789 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31789 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32252 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42067 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43015 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41976 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41976 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32252 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32252 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32252 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 70271 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31305 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31305 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31305 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31305 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32298 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41976 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31146 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41976 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31146 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41976 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31146 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41976 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31146 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41976 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42067 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41976 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41976 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41976 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41976 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41976 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41976 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41976 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41976 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41976 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41976 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41976 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41976 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31146 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31146 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31146 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31146 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31146 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31146 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31146 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31146 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31146 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31146 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31146 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31146 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32077 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31305 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31789 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31789 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32179 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42067 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41976 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41976 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41976 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41976 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42067 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28640: LD_VAR 0 1
28644: PPUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL 57904 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28654: LD_EXP 39
28658: PUSH
28659: LD_VAR 0 2
28663: PPUSH
28664: CALL_OW 255
28668: ARRAY
28669: IFFALSE 29396
// begin side := GetSide ( veh ) ;
28671: LD_ADDR_VAR 0 4
28675: PUSH
28676: LD_VAR 0 1
28680: PPUSH
28681: CALL_OW 255
28685: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28686: LD_ADDR_VAR 0 6
28690: PUSH
28691: LD_VAR 0 1
28695: PPUSH
28696: CALL_OW 265
28700: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28701: LD_ADDR_VAR 0 7
28705: PUSH
28706: LD_VAR 0 1
28710: PPUSH
28711: CALL_OW 262
28715: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28716: LD_ADDR_VAR 0 8
28720: PUSH
28721: LD_VAR 0 1
28725: PPUSH
28726: CALL_OW 263
28730: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28731: LD_ADDR_VAR 0 9
28735: PUSH
28736: LD_VAR 0 1
28740: PPUSH
28741: CALL_OW 264
28745: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28746: LD_STRING VehicleConstructed [side: 
28748: PUSH
28749: LD_VAR 0 4
28753: STR
28754: PUSH
28755: LD_STRING ; id:
28757: STR
28758: PUSH
28759: LD_VAR 0 1
28763: STR
28764: PUSH
28765: LD_STRING ; components: [
28767: STR
28768: PUSH
28769: LD_VAR 0 6
28773: STR
28774: PUSH
28775: LD_STRING , 
28777: STR
28778: PUSH
28779: LD_VAR 0 7
28783: STR
28784: PUSH
28785: LD_STRING , 
28787: STR
28788: PUSH
28789: LD_VAR 0 8
28793: STR
28794: PUSH
28795: LD_STRING , 
28797: STR
28798: PUSH
28799: LD_VAR 0 9
28803: STR
28804: PUSH
28805: LD_STRING ]]
28807: STR
28808: PPUSH
28809: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28813: LD_VAR 0 1
28817: PPUSH
28818: CALL_OW 264
28822: PUSH
28823: LD_INT 13
28825: PUSH
28826: LD_INT 12
28828: PUSH
28829: LD_INT 14
28831: PUSH
28832: LD_INT 51
28834: PUSH
28835: LD_INT 53
28837: PUSH
28838: LD_INT 52
28840: PUSH
28841: LD_INT 32
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: IN
28853: NOT
28854: IFFALSE 28896
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28856: LD_ADDR_EXP 59
28860: PUSH
28861: LD_EXP 59
28865: PPUSH
28866: LD_VAR 0 4
28870: PPUSH
28871: LD_EXP 59
28875: PUSH
28876: LD_VAR 0 4
28880: ARRAY
28881: PUSH
28882: LD_INT 1
28884: PLUS
28885: PPUSH
28886: LD_VAR 0 1
28890: PPUSH
28891: CALL 31146 0 4
28895: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28896: LD_VAR 0 1
28900: PPUSH
28901: CALL_OW 264
28905: PUSH
28906: LD_INT 31
28908: EQUAL
28909: IFFALSE 28928
// SetTag ( GetDriver ( veh ) , 9 ) ;
28911: LD_VAR 0 1
28915: PPUSH
28916: CALL 31789 0 1
28920: PPUSH
28921: LD_INT 9
28923: PPUSH
28924: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28928: LD_VAR 0 1
28932: PPUSH
28933: CALL_OW 264
28937: PUSH
28938: LD_INT 14
28940: PUSH
28941: LD_INT 53
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: IN
28948: IFFALSE 28985
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28950: LD_ADDR_EXP 42
28954: PUSH
28955: LD_EXP 42
28959: PPUSH
28960: LD_VAR 0 1
28964: PPUSH
28965: CALL_OW 255
28969: PPUSH
28970: LD_INT 2
28972: PPUSH
28973: LD_VAR 0 1
28977: PPUSH
28978: CALL 31146 0 4
28982: ST_TO_ADDR
// exit ;
28983: GO 29396
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28985: LD_VAR 0 1
28989: PPUSH
28990: CALL_OW 265
28994: PUSH
28995: LD_EXP 66
28999: PUSH
29000: LD_VAR 0 4
29004: ARRAY
29005: PUSH
29006: LD_INT 1
29008: ARRAY
29009: IN
29010: PUSH
29011: LD_VAR 0 1
29015: PPUSH
29016: CALL_OW 262
29020: PUSH
29021: LD_EXP 66
29025: PUSH
29026: LD_VAR 0 4
29030: ARRAY
29031: PUSH
29032: LD_INT 1
29034: ARRAY
29035: IN
29036: AND
29037: PUSH
29038: LD_VAR 0 1
29042: PPUSH
29043: CALL_OW 263
29047: PUSH
29048: LD_EXP 66
29052: PUSH
29053: LD_VAR 0 4
29057: ARRAY
29058: PUSH
29059: LD_INT 1
29061: ARRAY
29062: IN
29063: AND
29064: PUSH
29065: LD_VAR 0 1
29069: PPUSH
29070: CALL_OW 264
29074: PUSH
29075: LD_EXP 66
29079: PUSH
29080: LD_VAR 0 4
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: IN
29090: AND
29091: IFFALSE 29135
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29093: LD_ADDR_EXP 67
29097: PUSH
29098: LD_EXP 67
29102: PPUSH
29103: LD_VAR 0 4
29107: PPUSH
29108: LD_EXP 67
29112: PUSH
29113: LD_VAR 0 4
29117: ARRAY
29118: PUSH
29119: LD_INT 1
29121: PLUS
29122: PPUSH
29123: LD_VAR 0 1
29127: PPUSH
29128: CALL 31146 0 4
29132: ST_TO_ADDR
// exit ;
29133: GO 29396
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29135: LD_VAR 0 6
29139: PUSH
29140: LD_EXP 69
29144: PUSH
29145: LD_VAR 0 4
29149: ARRAY
29150: PUSH
29151: LD_INT 1
29153: ARRAY
29154: EQUAL
29155: PUSH
29156: LD_VAR 0 7
29160: PUSH
29161: LD_EXP 69
29165: PUSH
29166: LD_VAR 0 4
29170: ARRAY
29171: PUSH
29172: LD_INT 2
29174: ARRAY
29175: EQUAL
29176: AND
29177: PUSH
29178: LD_VAR 0 8
29182: PUSH
29183: LD_EXP 69
29187: PUSH
29188: LD_VAR 0 4
29192: ARRAY
29193: PUSH
29194: LD_INT 3
29196: ARRAY
29197: EQUAL
29198: AND
29199: PUSH
29200: LD_VAR 0 9
29204: PUSH
29205: LD_EXP 69
29209: PUSH
29210: LD_VAR 0 4
29214: ARRAY
29215: PUSH
29216: LD_INT 4
29218: ARRAY
29219: EQUAL
29220: AND
29221: IFFALSE 29377
// begin tmp := MREG_ToAttack [ side ] ;
29223: LD_ADDR_VAR 0 5
29227: PUSH
29228: LD_EXP 69
29232: PUSH
29233: LD_VAR 0 4
29237: ARRAY
29238: ST_TO_ADDR
// for i = 1 to 4 do
29239: LD_ADDR_VAR 0 3
29243: PUSH
29244: DOUBLE
29245: LD_INT 1
29247: DEC
29248: ST_TO_ADDR
29249: LD_INT 4
29251: PUSH
29252: FOR_TO
29253: IFFALSE 29275
// tmp := Delete ( tmp , 1 ) ;
29255: LD_ADDR_VAR 0 5
29259: PUSH
29260: LD_VAR 0 5
29264: PPUSH
29265: LD_INT 1
29267: PPUSH
29268: CALL_OW 3
29272: ST_TO_ADDR
29273: GO 29252
29275: POP
29276: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29277: LD_ADDR_EXP 69
29281: PUSH
29282: LD_EXP 69
29286: PPUSH
29287: LD_VAR 0 4
29291: PPUSH
29292: LD_VAR 0 5
29296: PPUSH
29297: CALL_OW 1
29301: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29302: LD_ADDR_EXP 71
29306: PUSH
29307: LD_EXP 71
29311: PPUSH
29312: LD_VAR 0 4
29316: PPUSH
29317: LD_EXP 71
29321: PUSH
29322: LD_VAR 0 4
29326: ARRAY
29327: PUSH
29328: LD_INT 1
29330: PLUS
29331: PPUSH
29332: LD_VAR 0 1
29336: PPUSH
29337: CALL 31146 0 4
29341: ST_TO_ADDR
// if tmp = 0 then
29342: LD_VAR 0 5
29346: PUSH
29347: LD_INT 0
29349: EQUAL
29350: IFFALSE 29375
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29352: LD_ADDR_EXP 69
29356: PUSH
29357: LD_EXP 69
29361: PPUSH
29362: LD_VAR 0 4
29366: PPUSH
29367: LD_INT 0
29369: PPUSH
29370: CALL_OW 1
29374: ST_TO_ADDR
// exit ;
29375: GO 29396
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29377: LD_VAR 0 1
29381: PPUSH
29382: CALL_OW 255
29386: PPUSH
29387: LD_VAR 0 1
29391: PPUSH
29392: CALL 25757 0 2
// end ; end ;
29396: PPOPN 9
29398: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29399: LD_EXP 39
29403: PUSH
29404: LD_VAR 0 2
29408: PPUSH
29409: CALL_OW 255
29413: ARRAY
29414: IFFALSE 29646
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29416: LD_STRING ApemanTamed [side: 
29418: PUSH
29419: LD_VAR 0 2
29423: PPUSH
29424: CALL_OW 255
29428: STR
29429: PUSH
29430: LD_STRING ; sci: 
29432: STR
29433: PUSH
29434: LD_VAR 0 2
29438: STR
29439: PUSH
29440: LD_STRING ; ape: 
29442: STR
29443: PUSH
29444: LD_VAR 0 1
29448: STR
29449: PUSH
29450: LD_STRING ]
29452: STR
29453: PPUSH
29454: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29458: LD_INT 11
29460: PPUSH
29461: LD_VAR 0 2
29465: PPUSH
29466: CALL_OW 255
29470: PPUSH
29471: CALL_OW 321
29475: PUSH
29476: LD_INT 2
29478: EQUAL
29479: NOT
29480: PUSH
29481: LD_INT 2
29483: PPUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: CALL_OW 321
29498: PUSH
29499: LD_INT 2
29501: EQUAL
29502: NOT
29503: OR
29504: PUSH
29505: LD_VAR 0 2
29509: PPUSH
29510: CALL_OW 255
29514: PPUSH
29515: LD_INT 171
29517: PPUSH
29518: EMPTY
29519: PPUSH
29520: CALL 12370 0 3
29524: PUSH
29525: LD_INT 0
29527: EQUAL
29528: AND
29529: IFFALSE 29543
// begin SetTag ( ape , 171 ) ;
29531: LD_VAR 0 1
29535: PPUSH
29536: LD_INT 171
29538: PPUSH
29539: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29543: LD_VAR 0 2
29547: PPUSH
29548: CALL_OW 255
29552: PPUSH
29553: LD_INT 30
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PPUSH
29563: CALL 11667 0 2
29567: IFFALSE 29646
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29569: LD_VAR 0 1
29573: PPUSH
29574: LD_VAR 0 2
29578: PPUSH
29579: CALL_OW 255
29583: PPUSH
29584: LD_INT 30
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PPUSH
29594: CALL 11667 0 2
29598: PUSH
29599: LD_INT 1
29601: ARRAY
29602: PPUSH
29603: CALL_OW 250
29607: PPUSH
29608: LD_VAR 0 2
29612: PPUSH
29613: CALL_OW 255
29617: PPUSH
29618: LD_INT 30
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PPUSH
29628: CALL 11667 0 2
29632: PUSH
29633: LD_INT 1
29635: ARRAY
29636: PPUSH
29637: CALL_OW 251
29641: PPUSH
29642: CALL_OW 111
// end ;
29646: PPOPN 2
29648: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29649: LD_EXP 39
29653: PUSH
29654: LD_VAR 0 1
29658: PPUSH
29659: CALL_OW 255
29663: ARRAY
29664: IFFALSE 29942
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29666: LD_VAR 0 2
29670: PUSH
29671: LD_VAR 0 2
29675: PPUSH
29676: CALL_OW 255
29680: PPUSH
29681: CALL 12080 0 1
29685: IN
29686: IFFALSE 29827
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29688: LD_VAR 0 1
29692: PPUSH
29693: CALL_OW 266
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: IN
29708: IFFALSE 29738
// begin Wait ( 0 0$0.3 ) ;
29710: LD_INT 10
29712: PPUSH
29713: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29717: LD_VAR 0 2
29721: PPUSH
29722: LD_INT 16
29724: PPUSH
29725: CALL_OW 336
// ComExitBuilding ( un ) ;
29729: LD_VAR 0 2
29733: PPUSH
29734: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29738: LD_VAR 0 1
29742: PPUSH
29743: CALL_OW 266
29747: PUSH
29748: LD_INT 4
29750: PUSH
29751: LD_INT 5
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: IN
29758: IFFALSE 29827
// begin Wait ( 0 0$0.3 ) ;
29760: LD_INT 10
29762: PPUSH
29763: CALL_OW 67
// if GetTag ( un ) = 0 then
29767: LD_VAR 0 2
29771: PPUSH
29772: CALL_OW 110
29776: PUSH
29777: LD_INT 0
29779: EQUAL
29780: IFFALSE 29796
// SetClass ( un , class_apeman_soldier ) else
29782: LD_VAR 0 2
29786: PPUSH
29787: LD_INT 15
29789: PPUSH
29790: CALL_OW 336
29794: GO 29827
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29796: LD_INT 3
29798: PPUSH
29799: LD_VAR 0 2
29803: PPUSH
29804: CALL_OW 255
29808: PPUSH
29809: CALL_OW 321
29813: IFFALSE 29827
// SetClass ( un , class_apeman_kamikaze ) ;
29815: LD_VAR 0 2
29819: PPUSH
29820: LD_INT 17
29822: PPUSH
29823: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29827: LD_VAR 0 1
29831: PPUSH
29832: CALL_OW 266
29836: PUSH
29837: LD_INT 32
29839: EQUAL
29840: IFFALSE 29942
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29842: LD_ADDR_EXP 68
29846: PUSH
29847: LD_EXP 68
29851: PPUSH
29852: LD_VAR 0 1
29856: PPUSH
29857: CALL_OW 255
29861: PPUSH
29862: LD_EXP 68
29866: PUSH
29867: LD_VAR 0 1
29871: PPUSH
29872: CALL_OW 255
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: PLUS
29881: PPUSH
29882: LD_VAR 0 1
29886: PPUSH
29887: CALL 31146 0 4
29891: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29892: LD_ADDR_EXP 68
29896: PUSH
29897: LD_EXP 68
29901: PPUSH
29902: LD_VAR 0 1
29906: PPUSH
29907: CALL_OW 255
29911: PPUSH
29912: LD_EXP 68
29916: PUSH
29917: LD_VAR 0 1
29921: PPUSH
29922: CALL_OW 255
29926: ARRAY
29927: PUSH
29928: LD_INT 1
29930: PLUS
29931: PPUSH
29932: LD_VAR 0 2
29936: PPUSH
29937: CALL 31146 0 4
29941: ST_TO_ADDR
// end ; end ;
29942: PPOPN 2
29944: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29945: LD_VAR 0 1
29949: PPUSH
29950: CALL 57782 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29954: LD_VAR 0 1
29958: PUSH
29959: LD_INT 22
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 23
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 21
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PPUSH
29994: CALL_OW 69
29998: IN
29999: IFFALSE 30015
// player_loss := player_loss + 1 ;
30001: LD_ADDR_EXP 10
30005: PUSH
30006: LD_EXP 10
30010: PUSH
30011: LD_INT 1
30013: PLUS
30014: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30015: LD_VAR 0 1
30019: PUSH
30020: LD_INT 22
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 21
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PPUSH
30044: CALL_OW 69
30048: IN
30049: PUSH
30050: LD_EXP 14
30054: NOT
30055: AND
30056: IFFALSE 30119
// begin alfa_north_triggered := true ;
30058: LD_ADDR_EXP 14
30062: PUSH
30063: LD_INT 1
30065: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30066: LD_EXP 5
30070: PPUSH
30071: LD_STRING DS4
30073: PPUSH
30074: CALL_OW 94
// Wait ( 1 1$25 ) ;
30078: LD_INT 2975
30080: PPUSH
30081: CALL_OW 67
// if not isTest then
30085: LD_EXP 1
30089: NOT
30090: IFFALSE 30119
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30092: LD_INT 20
30094: PPUSH
30095: LD_INT 5
30097: PUSH
30098: LD_INT 6
30100: PUSH
30101: LD_INT 7
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: LIST
30108: PUSH
30109: LD_OWVAR 67
30113: ARRAY
30114: PPUSH
30115: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30119: LD_VAR 0 1
30123: PUSH
30124: LD_INT 22
30126: PUSH
30127: LD_INT 4
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 21
30136: PUSH
30137: LD_INT 3
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PPUSH
30148: CALL_OW 69
30152: IN
30153: PUSH
30154: LD_EXP 15
30158: NOT
30159: AND
30160: IFFALSE 30223
// begin alfa_south_triggered := true ;
30162: LD_ADDR_EXP 15
30166: PUSH
30167: LD_INT 1
30169: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30170: LD_EXP 4
30174: PPUSH
30175: LD_STRING DJ3
30177: PPUSH
30178: CALL_OW 94
// Wait ( 0 0$45 ) ;
30182: LD_INT 1575
30184: PPUSH
30185: CALL_OW 67
// if not isTest then
30189: LD_EXP 1
30193: NOT
30194: IFFALSE 30223
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30196: LD_INT 20
30198: PPUSH
30199: LD_INT 5
30201: PUSH
30202: LD_INT 6
30204: PUSH
30205: LD_INT 7
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: LIST
30212: PUSH
30213: LD_OWVAR 67
30217: ARRAY
30218: PPUSH
30219: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 266
30232: PUSH
30233: LD_INT 1
30235: EQUAL
30236: PUSH
30237: LD_VAR 0 1
30241: PPUSH
30242: CALL_OW 255
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: LD_INT 4
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: IN
30257: AND
30258: IFFALSE 30267
// RaiseSailEvent ( 104 ) ;
30260: LD_INT 104
30262: PPUSH
30263: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30267: LD_EXP 39
30271: PUSH
30272: LD_VAR 0 1
30276: PPUSH
30277: CALL_OW 255
30281: ARRAY
30282: IFFALSE 30669
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30284: LD_STRING UnitDestroyed [side 
30286: PUSH
30287: LD_VAR 0 1
30291: PPUSH
30292: CALL_OW 255
30296: STR
30297: PUSH
30298: LD_STRING ; id: 
30300: STR
30301: PUSH
30302: LD_VAR 0 1
30306: STR
30307: PUSH
30308: LD_STRING ; type: 
30310: STR
30311: PUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL_OW 247
30321: STR
30322: PUSH
30323: LD_STRING ]
30325: STR
30326: PPUSH
30327: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30331: LD_VAR 0 1
30335: PUSH
30336: LD_VAR 0 1
30340: PPUSH
30341: CALL_OW 255
30345: PPUSH
30346: LD_INT 21
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PPUSH
30356: CALL 11667 0 2
30360: IN
30361: IFFALSE 30517
// begin if MCF_HasClass ( un ) then
30363: LD_VAR 0 1
30367: PPUSH
30368: CALL 14373 0 1
30372: IFFALSE 30517
// case MCF_HasClass ( un ) of 1 :
30374: LD_VAR 0 1
30378: PPUSH
30379: CALL 14373 0 1
30383: PUSH
30384: LD_INT 1
30386: DOUBLE
30387: EQUAL
30388: IFTRUE 30392
30390: GO 30417
30392: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30393: LD_VAR 0 1
30397: PPUSH
30398: CALL_OW 255
30402: PPUSH
30403: LD_STRING ToArm
30405: PPUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: CALL 14546 0 3
30415: GO 30517
30417: LD_INT 2
30419: DOUBLE
30420: EQUAL
30421: IFTRUE 30425
30423: GO 30450
30425: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30426: LD_VAR 0 1
30430: PPUSH
30431: CALL_OW 255
30435: PPUSH
30436: LD_STRING ToDep
30438: PPUSH
30439: LD_VAR 0 1
30443: PPUSH
30444: CALL 14546 0 3
30448: GO 30517
30450: LD_INT 3
30452: DOUBLE
30453: EQUAL
30454: IFTRUE 30458
30456: GO 30483
30458: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30459: LD_VAR 0 1
30463: PPUSH
30464: CALL_OW 255
30468: PPUSH
30469: LD_STRING ToFac
30471: PPUSH
30472: LD_VAR 0 1
30476: PPUSH
30477: CALL 14546 0 3
30481: GO 30517
30483: LD_INT 4
30485: DOUBLE
30486: EQUAL
30487: IFTRUE 30491
30489: GO 30516
30491: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30492: LD_VAR 0 1
30496: PPUSH
30497: CALL_OW 255
30501: PPUSH
30502: LD_STRING ToLab
30504: PPUSH
30505: LD_VAR 0 1
30509: PPUSH
30510: CALL 14546 0 3
30514: GO 30517
30516: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30517: LD_VAR 0 1
30521: PUSH
30522: LD_EXP 67
30526: PUSH
30527: LD_VAR 0 1
30531: PPUSH
30532: CALL_OW 255
30536: ARRAY
30537: IN
30538: IFFALSE 30623
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30540: LD_ADDR_EXP 67
30544: PUSH
30545: LD_EXP 67
30549: PPUSH
30550: LD_VAR 0 1
30554: PPUSH
30555: LD_INT 0
30557: PPUSH
30558: CALL 31305 0 3
30562: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30563: LD_VAR 0 1
30567: PPUSH
30568: CALL_OW 255
30572: PPUSH
30573: LD_VAR 0 1
30577: PPUSH
30578: CALL_OW 265
30582: PUSH
30583: LD_VAR 0 1
30587: PPUSH
30588: CALL_OW 262
30592: PUSH
30593: LD_VAR 0 1
30597: PPUSH
30598: CALL_OW 263
30602: PUSH
30603: LD_VAR 0 1
30607: PPUSH
30608: CALL_OW 264
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: PPUSH
30619: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30623: LD_VAR 0 1
30627: PUSH
30628: LD_EXP 71
30632: PUSH
30633: LD_VAR 0 1
30637: PPUSH
30638: CALL_OW 255
30642: ARRAY
30643: IN
30644: IFFALSE 30669
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30646: LD_ADDR_EXP 71
30650: PUSH
30651: LD_EXP 71
30655: PPUSH
30656: LD_VAR 0 1
30660: PPUSH
30661: LD_INT 0
30663: PPUSH
30664: CALL 31305 0 3
30668: ST_TO_ADDR
// end ; end ;
30669: PPOPN 1
30671: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30672: LD_EXP 39
30676: PUSH
30677: LD_VAR 0 2
30681: PPUSH
30682: CALL_OW 255
30686: ARRAY
30687: IFFALSE 30859
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30689: LD_VAR 0 2
30693: PUSH
30694: LD_EXP 68
30698: PUSH
30699: LD_VAR 0 2
30703: PPUSH
30704: CALL_OW 255
30708: ARRAY
30709: IN
30710: PUSH
30711: LD_VAR 0 1
30715: PPUSH
30716: CALL_OW 266
30720: PUSH
30721: LD_INT 32
30723: PUSH
30724: LD_INT 31
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: IN
30731: AND
30732: IFFALSE 30832
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30734: LD_ADDR_EXP 68
30738: PUSH
30739: LD_EXP 68
30743: PPUSH
30744: LD_VAR 0 1
30748: PPUSH
30749: LD_INT 0
30751: PPUSH
30752: CALL 31305 0 3
30756: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30757: LD_ADDR_EXP 68
30761: PUSH
30762: LD_EXP 68
30766: PPUSH
30767: LD_VAR 0 2
30771: PPUSH
30772: LD_INT 0
30774: PPUSH
30775: CALL 31305 0 3
30779: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30780: LD_EXP 68
30784: PUSH
30785: LD_VAR 0 2
30789: PPUSH
30790: CALL_OW 255
30794: ARRAY
30795: PUSH
30796: LD_STRING 
30798: EQUAL
30799: IFFALSE 30832
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30801: LD_ADDR_EXP 68
30805: PUSH
30806: LD_EXP 68
30810: PPUSH
30811: LD_VAR 0 2
30815: PPUSH
30816: CALL_OW 255
30820: PPUSH
30821: LD_INT 1
30823: PPUSH
30824: LD_INT 0
30826: PPUSH
30827: CALL 31146 0 4
30831: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 266
30841: PUSH
30842: LD_INT 36
30844: IN
30845: IFFALSE 30859
// SetTag ( un , 0 ) ;
30847: LD_VAR 0 2
30851: PPUSH
30852: LD_INT 0
30854: PPUSH
30855: CALL_OW 109
// end ;
30859: PPOPN 2
30861: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30862: LD_EXP 39
30866: PUSH
30867: LD_VAR 0 1
30871: PPUSH
30872: CALL_OW 255
30876: ARRAY
30877: IFFALSE 30903
// begin if GetControl ( un ) = control_remote then
30879: LD_VAR 0 1
30883: PPUSH
30884: CALL_OW 263
30888: PUSH
30889: LD_INT 2
30891: EQUAL
30892: IFFALSE 30903
// ComUnlink ( un ) ;
30894: LD_VAR 0 1
30898: PPUSH
30899: CALL_OW 136
// end ;
30903: PPOPN 1
30905: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30906: LD_EXP 39
30910: PUSH
30911: LD_VAR 0 1
30915: PPUSH
30916: CALL_OW 255
30920: ARRAY
30921: IFFALSE 30950
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30923: LD_VAR 0 2
30927: PPUSH
30928: CALL_OW 264
30932: PUSH
30933: LD_INT 31
30935: IN
30936: IFFALSE 30950
// SetTag ( driver , 0 ) ;
30938: LD_VAR 0 1
30942: PPUSH
30943: LD_INT 0
30945: PPUSH
30946: CALL_OW 109
// end ;
30950: PPOPN 4
30952: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30953: LD_INT 0
30955: PPUSH
30956: PPUSH
30957: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30958: LD_ADDR_VAR 0 3
30962: PUSH
30963: LD_VAR 0 1
30967: PPUSH
30968: CALL_OW 269
30972: ST_TO_ADDR
// x := GetX ( building ) ;
30973: LD_ADDR_VAR 0 4
30977: PUSH
30978: LD_VAR 0 1
30982: PPUSH
30983: CALL_OW 250
30987: ST_TO_ADDR
// y := GetY ( building ) ;
30988: LD_ADDR_VAR 0 5
30992: PUSH
30993: LD_VAR 0 1
30997: PPUSH
30998: CALL_OW 251
31002: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
31003: LD_ADDR_EXP 43
31007: PUSH
31008: LD_EXP 43
31012: PPUSH
31013: LD_VAR 0 1
31017: PPUSH
31018: CALL_OW 255
31022: PPUSH
31023: LD_VAR 0 3
31027: PPUSH
31028: LD_VAR 0 4
31032: PUSH
31033: LD_VAR 0 5
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL 42067 0 4
31046: ST_TO_ADDR
// end ;
31047: PPOPN 5
31049: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31050: LD_VAR 0 1
31054: PUSH
31055: LD_EXP 30
31059: IN
31060: NOT
31061: IFFALSE 31109
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31063: LD_ADDR_EXP 30
31067: PUSH
31068: LD_EXP 30
31072: PPUSH
31073: LD_EXP 30
31077: PUSH
31078: LD_INT 1
31080: PLUS
31081: PPUSH
31082: LD_VAR 0 1
31086: PPUSH
31087: CALL_OW 2
31091: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31092: LD_STRING DestinationUnrechable. [unit: 
31094: PUSH
31095: LD_VAR 0 1
31099: STR
31100: PUSH
31101: LD_STRING ]
31103: STR
31104: PPUSH
31105: CALL 8055 0 1
// end ; end ;
31109: PPOPN 1
31111: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31112: LD_VAR 0 1
31116: PPUSH
31117: LD_VAR 0 2
31121: PPUSH
31122: LD_VAR 0 3
31126: PPUSH
31127: CALL 57880 0 3
// end ;
31131: PPOPN 3
31133: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31134: LD_VAR 0 1
31138: PPUSH
31139: CALL 57888 0 1
// end ; end_of_file
31143: PPOPN 1
31145: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31146: LD_INT 0
31148: PPUSH
31149: PPUSH
31150: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31151: LD_ADDR_VAR 0 7
31155: PUSH
31156: LD_VAR 0 1
31160: PUSH
31161: LD_VAR 0 2
31165: ARRAY
31166: PPUSH
31167: LD_VAR 0 3
31171: PPUSH
31172: LD_VAR 0 4
31176: PPUSH
31177: CALL_OW 1
31181: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31182: LD_ADDR_VAR 0 1
31186: PUSH
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_VAR 0 2
31196: PPUSH
31197: LD_VAR 0 7
31201: PPUSH
31202: CALL_OW 1
31206: ST_TO_ADDR
// result := tab ;
31207: LD_ADDR_VAR 0 5
31211: PUSH
31212: LD_VAR 0 1
31216: ST_TO_ADDR
// end ;
31217: LD_VAR 0 5
31221: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31222: LD_INT 0
31224: PPUSH
31225: PPUSH
31226: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31227: LD_ADDR_VAR 0 5
31231: PUSH
31232: LD_VAR 0 1
31236: PUSH
31237: LD_VAR 0 2
31241: PUSH
31242: LD_INT 1
31244: ARRAY
31245: ARRAY
31246: PPUSH
31247: LD_VAR 0 2
31251: PUSH
31252: LD_INT 2
31254: ARRAY
31255: PPUSH
31256: CALL_OW 3
31260: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31261: LD_ADDR_VAR 0 1
31265: PUSH
31266: LD_VAR 0 1
31270: PPUSH
31271: LD_VAR 0 2
31275: PUSH
31276: LD_INT 1
31278: ARRAY
31279: PPUSH
31280: LD_VAR 0 5
31284: PPUSH
31285: CALL_OW 1
31289: ST_TO_ADDR
// result := tab ;
31290: LD_ADDR_VAR 0 3
31294: PUSH
31295: LD_VAR 0 1
31299: ST_TO_ADDR
// end ;
31300: LD_VAR 0 3
31304: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31305: LD_INT 0
31307: PPUSH
31308: PPUSH
31309: PPUSH
31310: PPUSH
// i := 1 ;
31311: LD_ADDR_VAR 0 5
31315: PUSH
31316: LD_INT 1
31318: ST_TO_ADDR
// while ( i <= tab ) do
31319: LD_VAR 0 5
31323: PUSH
31324: LD_VAR 0 1
31328: LESSEQUAL
31329: IFFALSE 31704
// begin if not tab [ i ] then
31331: LD_VAR 0 1
31335: PUSH
31336: LD_VAR 0 5
31340: ARRAY
31341: NOT
31342: IFFALSE 31346
// break ;
31344: GO 31704
// if value in tab then
31346: LD_VAR 0 2
31350: PUSH
31351: LD_VAR 0 1
31355: IN
31356: IFFALSE 31469
// begin if not mode then
31358: LD_VAR 0 3
31362: NOT
31363: IFFALSE 31383
// tab := tab diff value else
31365: LD_ADDR_VAR 0 1
31369: PUSH
31370: LD_VAR 0 1
31374: PUSH
31375: LD_VAR 0 2
31379: DIFF
31380: ST_TO_ADDR
31381: GO 31445
// for j = 1 to tab do
31383: LD_ADDR_VAR 0 6
31387: PUSH
31388: DOUBLE
31389: LD_INT 1
31391: DEC
31392: ST_TO_ADDR
31393: LD_VAR 0 1
31397: PUSH
31398: FOR_TO
31399: IFFALSE 31443
// if tab [ j ] = value then
31401: LD_VAR 0 1
31405: PUSH
31406: LD_VAR 0 6
31410: ARRAY
31411: PUSH
31412: LD_VAR 0 2
31416: EQUAL
31417: IFFALSE 31441
// begin tab := Delete ( tab , j ) ;
31419: LD_ADDR_VAR 0 1
31423: PUSH
31424: LD_VAR 0 1
31428: PPUSH
31429: LD_VAR 0 6
31433: PPUSH
31434: CALL_OW 3
31438: ST_TO_ADDR
// break ;
31439: GO 31443
// end ;
31441: GO 31398
31443: POP
31444: POP
// i := i - 1 ;
31445: LD_ADDR_VAR 0 5
31449: PUSH
31450: LD_VAR 0 5
31454: PUSH
31455: LD_INT 1
31457: MINUS
31458: ST_TO_ADDR
// if mode then
31459: LD_VAR 0 3
31463: IFFALSE 31467
// break ;
31465: GO 31704
// end else
31467: GO 31688
// if tab [ i ] and value in tab [ i ] then
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: PUSH
31480: LD_VAR 0 2
31484: PUSH
31485: LD_VAR 0 1
31489: PUSH
31490: LD_VAR 0 5
31494: ARRAY
31495: IN
31496: AND
31497: IFFALSE 31688
// begin if not mode then
31499: LD_VAR 0 3
31503: NOT
31504: IFFALSE 31530
// tmp := tab [ i ] diff value else
31506: LD_ADDR_VAR 0 7
31510: PUSH
31511: LD_VAR 0 1
31515: PUSH
31516: LD_VAR 0 5
31520: ARRAY
31521: PUSH
31522: LD_VAR 0 2
31526: DIFF
31527: ST_TO_ADDR
31528: GO 31610
// for j = 1 to tab [ i ] do
31530: LD_ADDR_VAR 0 6
31534: PUSH
31535: DOUBLE
31536: LD_INT 1
31538: DEC
31539: ST_TO_ADDR
31540: LD_VAR 0 1
31544: PUSH
31545: LD_VAR 0 5
31549: ARRAY
31550: PUSH
31551: FOR_TO
31552: IFFALSE 31608
// if value = tab [ i ] [ j ] then
31554: LD_VAR 0 2
31558: PUSH
31559: LD_VAR 0 1
31563: PUSH
31564: LD_VAR 0 5
31568: ARRAY
31569: PUSH
31570: LD_VAR 0 6
31574: ARRAY
31575: EQUAL
31576: IFFALSE 31606
// begin tmp := Delete ( tab [ i ] , j ) ;
31578: LD_ADDR_VAR 0 7
31582: PUSH
31583: LD_VAR 0 1
31587: PUSH
31588: LD_VAR 0 5
31592: ARRAY
31593: PPUSH
31594: LD_VAR 0 6
31598: PPUSH
31599: CALL_OW 3
31603: ST_TO_ADDR
// break ;
31604: GO 31608
// end ;
31606: GO 31551
31608: POP
31609: POP
// if tmp = [ ] then
31610: LD_VAR 0 7
31614: PUSH
31615: EMPTY
31616: EQUAL
31617: IFFALSE 31641
// begin tab := Delete ( tab , i ) ;
31619: LD_ADDR_VAR 0 1
31623: PUSH
31624: LD_VAR 0 1
31628: PPUSH
31629: LD_VAR 0 5
31633: PPUSH
31634: CALL_OW 3
31638: ST_TO_ADDR
// end else
31639: GO 31666
// tab := Replace ( tab , i , tmp ) ;
31641: LD_ADDR_VAR 0 1
31645: PUSH
31646: LD_VAR 0 1
31650: PPUSH
31651: LD_VAR 0 5
31655: PPUSH
31656: LD_VAR 0 7
31660: PPUSH
31661: CALL_OW 1
31665: ST_TO_ADDR
// i := i - 1 ;
31666: LD_ADDR_VAR 0 5
31670: PUSH
31671: LD_VAR 0 5
31675: PUSH
31676: LD_INT 1
31678: MINUS
31679: ST_TO_ADDR
// if mode then
31680: LD_VAR 0 3
31684: IFFALSE 31688
// break ;
31686: GO 31704
// end ; i := i + 1 ;
31688: LD_ADDR_VAR 0 5
31692: PUSH
31693: LD_VAR 0 5
31697: PUSH
31698: LD_INT 1
31700: PLUS
31701: ST_TO_ADDR
// end ;
31702: GO 31319
// result := tab ;
31704: LD_ADDR_VAR 0 4
31708: PUSH
31709: LD_VAR 0 1
31713: ST_TO_ADDR
// end ;
31714: LD_VAR 0 4
31718: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31719: LD_INT 0
31721: PPUSH
31722: PPUSH
// for i = 1 to values do
31723: LD_ADDR_VAR 0 4
31727: PUSH
31728: DOUBLE
31729: LD_INT 1
31731: DEC
31732: ST_TO_ADDR
31733: LD_VAR 0 2
31737: PUSH
31738: FOR_TO
31739: IFFALSE 31772
// tab := Remove ( tab , values [ i ] , false ) ;
31741: LD_ADDR_VAR 0 1
31745: PUSH
31746: LD_VAR 0 1
31750: PPUSH
31751: LD_VAR 0 2
31755: PUSH
31756: LD_VAR 0 4
31760: ARRAY
31761: PPUSH
31762: LD_INT 0
31764: PPUSH
31765: CALL 31305 0 3
31769: ST_TO_ADDR
31770: GO 31738
31772: POP
31773: POP
// result := tab ;
31774: LD_ADDR_VAR 0 3
31778: PUSH
31779: LD_VAR 0 1
31783: ST_TO_ADDR
// end ;
31784: LD_VAR 0 3
31788: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31789: LD_INT 0
31791: PPUSH
31792: PPUSH
31793: PPUSH
// if not GetControl ( veh ) = control_manual then
31794: LD_VAR 0 1
31798: PPUSH
31799: CALL_OW 263
31803: PUSH
31804: LD_INT 1
31806: EQUAL
31807: NOT
31808: IFFALSE 31820
// result := false else
31810: LD_ADDR_VAR 0 2
31814: PUSH
31815: LD_INT 0
31817: ST_TO_ADDR
31818: GO 31965
// if veh in FilterAllUnits ( [ f_empty ] ) then
31820: LD_VAR 0 1
31824: PUSH
31825: LD_INT 58
31827: PUSH
31828: EMPTY
31829: LIST
31830: PPUSH
31831: CALL_OW 69
31835: IN
31836: IFFALSE 31848
// result := false else
31838: LD_ADDR_VAR 0 2
31842: PUSH
31843: LD_INT 0
31845: ST_TO_ADDR
31846: GO 31965
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31848: LD_ADDR_VAR 0 4
31852: PUSH
31853: LD_INT 22
31855: PUSH
31856: LD_VAR 0 1
31860: PPUSH
31861: CALL_OW 255
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 55
31872: PUSH
31873: EMPTY
31874: LIST
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PPUSH
31880: CALL_OW 69
31884: ST_TO_ADDR
// if not filter then
31885: LD_VAR 0 4
31889: NOT
31890: IFFALSE 31902
// result := false else
31892: LD_ADDR_VAR 0 2
31896: PUSH
31897: LD_INT 0
31899: ST_TO_ADDR
31900: GO 31965
// for i = 1 to filter do
31902: LD_ADDR_VAR 0 3
31906: PUSH
31907: DOUBLE
31908: LD_INT 1
31910: DEC
31911: ST_TO_ADDR
31912: LD_VAR 0 4
31916: PUSH
31917: FOR_TO
31918: IFFALSE 31963
// if IsDriver ( filter [ i ] ) = veh then
31920: LD_VAR 0 4
31924: PUSH
31925: LD_VAR 0 3
31929: ARRAY
31930: PPUSH
31931: CALL 96712 0 1
31935: PUSH
31936: LD_VAR 0 1
31940: EQUAL
31941: IFFALSE 31961
// begin result := filter [ i ] ;
31943: LD_ADDR_VAR 0 2
31947: PUSH
31948: LD_VAR 0 4
31952: PUSH
31953: LD_VAR 0 3
31957: ARRAY
31958: ST_TO_ADDR
// break ;
31959: GO 31963
// end ;
31961: GO 31917
31963: POP
31964: POP
// end ; end ;
31965: LD_VAR 0 2
31969: RET
// export function Compare ( val1 , val2 ) ; begin
31970: LD_INT 0
31972: PPUSH
// if val1 = val2 then
31973: LD_VAR 0 1
31977: PUSH
31978: LD_VAR 0 2
31982: EQUAL
31983: IFFALSE 31995
// result := true else
31985: LD_ADDR_VAR 0 3
31989: PUSH
31990: LD_INT 1
31992: ST_TO_ADDR
31993: GO 32003
// result := false ;
31995: LD_ADDR_VAR 0 3
31999: PUSH
32000: LD_INT 0
32002: ST_TO_ADDR
// end ;
32003: LD_VAR 0 3
32007: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32008: LD_INT 0
32010: PPUSH
32011: PPUSH
// result := false ;
32012: LD_ADDR_VAR 0 3
32016: PUSH
32017: LD_INT 0
32019: ST_TO_ADDR
// for j = 1 to e2 do
32020: LD_ADDR_VAR 0 4
32024: PUSH
32025: DOUBLE
32026: LD_INT 1
32028: DEC
32029: ST_TO_ADDR
32030: LD_VAR 0 2
32034: PUSH
32035: FOR_TO
32036: IFFALSE 32070
// if Compare ( e1 , e2 [ j ] ) then
32038: LD_VAR 0 1
32042: PPUSH
32043: LD_VAR 0 2
32047: PUSH
32048: LD_VAR 0 4
32052: ARRAY
32053: PPUSH
32054: CALL 31970 0 2
32058: IFFALSE 32068
// result := true ;
32060: LD_ADDR_VAR 0 3
32064: PUSH
32065: LD_INT 1
32067: ST_TO_ADDR
32068: GO 32035
32070: POP
32071: POP
// end ;
32072: LD_VAR 0 3
32076: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32077: LD_INT 0
32079: PPUSH
32080: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32081: LD_VAR 0 1
32085: PPUSH
32086: LD_STRING C
32088: PUSH
32089: LD_VAR 0 2
32093: PUSH
32094: LD_VAR 0 3
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: PUSH
32120: LD_STRING v
32122: PUSH
32123: LD_VAR 0 4
32127: PPUSH
32128: CALL_OW 250
32132: PUSH
32133: LD_VAR 0 4
32137: PPUSH
32138: CALL_OW 251
32142: PUSH
32143: LD_VAR 0 4
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PPUSH
32170: CALL_OW 446
// end ;
32174: LD_VAR 0 5
32178: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32179: LD_INT 0
32181: PPUSH
32182: PPUSH
32183: PPUSH
// linked := UnitsLinked ( unit ) ;
32184: LD_ADDR_VAR 0 4
32188: PUSH
32189: LD_VAR 0 1
32193: PPUSH
32194: CALL_OW 432
32198: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32199: LD_ADDR_VAR 0 3
32203: PUSH
32204: LD_VAR 0 1
32208: PPUSH
32209: LD_INT 3
32211: PPUSH
32212: CALL_OW 259
32216: ST_TO_ADDR
// if sk > linked then
32217: LD_VAR 0 3
32221: PUSH
32222: LD_VAR 0 4
32226: GREATER
32227: IFFALSE 32239
// result := true else
32229: LD_ADDR_VAR 0 2
32233: PUSH
32234: LD_INT 1
32236: ST_TO_ADDR
32237: GO 32247
// result := false ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 0
32246: ST_TO_ADDR
// end ;
32247: LD_VAR 0 2
32251: RET
// export function NotTask ( unit ) ; begin
32252: LD_INT 0
32254: PPUSH
// result := true ;
32255: LD_ADDR_VAR 0 2
32259: PUSH
32260: LD_INT 1
32262: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32263: LD_VAR 0 1
32267: PPUSH
32268: CALL_OW 437
32272: PUSH
32273: LD_VAR 0 1
32277: PPUSH
32278: CALL_OW 314
32282: OR
32283: IFFALSE 32293
// result := false ;
32285: LD_ADDR_VAR 0 2
32289: PUSH
32290: LD_INT 0
32292: ST_TO_ADDR
// end ;
32293: LD_VAR 0 2
32297: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32298: LD_INT 0
32300: PPUSH
32301: PPUSH
32302: PPUSH
32303: PPUSH
32304: PPUSH
// dist := 99999 ;
32305: LD_ADDR_VAR 0 7
32309: PUSH
32310: LD_INT 99999
32312: ST_TO_ADDR
// un := - 1 ;
32313: LD_ADDR_VAR 0 6
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: ST_TO_ADDR
// if units1 and units2 then
32322: LD_VAR 0 1
32326: PUSH
32327: LD_VAR 0 2
32331: AND
32332: IFFALSE 32420
// for i in units1 do
32334: LD_ADDR_VAR 0 4
32338: PUSH
32339: LD_VAR 0 1
32343: PUSH
32344: FOR_IN
32345: IFFALSE 32418
// for j in units2 do
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_VAR 0 2
32356: PUSH
32357: FOR_IN
32358: IFFALSE 32414
// if GetDistUnits ( i , j ) < dist then
32360: LD_VAR 0 4
32364: PPUSH
32365: LD_VAR 0 5
32369: PPUSH
32370: CALL_OW 296
32374: PUSH
32375: LD_VAR 0 7
32379: LESS
32380: IFFALSE 32412
// begin un := i ;
32382: LD_ADDR_VAR 0 6
32386: PUSH
32387: LD_VAR 0 4
32391: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32392: LD_ADDR_VAR 0 7
32396: PUSH
32397: LD_VAR 0 4
32401: PPUSH
32402: LD_VAR 0 5
32406: PPUSH
32407: CALL_OW 296
32411: ST_TO_ADDR
// end ;
32412: GO 32357
32414: POP
32415: POP
32416: GO 32344
32418: POP
32419: POP
// result := [ un , dist ] ;
32420: LD_ADDR_VAR 0 3
32424: PUSH
32425: LD_VAR 0 6
32429: PUSH
32430: LD_VAR 0 7
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: ST_TO_ADDR
// end ;
32439: LD_VAR 0 3
32443: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32444: LD_INT 0
32446: PPUSH
32447: PPUSH
32448: PPUSH
32449: PPUSH
32450: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32451: LD_VAR 0 1
32455: NOT
32456: PUSH
32457: LD_VAR 0 1
32461: PPUSH
32462: CALL_OW 256
32466: PUSH
32467: LD_INT 250
32469: LESS
32470: OR
32471: PUSH
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 314
32481: PUSH
32482: LD_VAR 0 1
32486: PPUSH
32487: CALL_OW 261
32491: PUSH
32492: LD_INT 20
32494: GREATER
32495: AND
32496: OR
32497: IFFALSE 32501
// exit ;
32499: GO 32875
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 261
32510: PUSH
32511: LD_INT 20
32513: LESS
32514: PUSH
32515: LD_VAR 0 1
32519: PPUSH
32520: CALL_OW 110
32524: PUSH
32525: LD_INT 21
32527: EQUAL
32528: NOT
32529: AND
32530: IFFALSE 32566
// begin ComStop ( bulldozer ) ;
32532: LD_VAR 0 1
32536: PPUSH
32537: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32541: LD_VAR 0 1
32545: PPUSH
32546: LD_INT 21
32548: PPUSH
32549: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32553: LD_VAR 0 1
32557: PPUSH
32558: CALL 26294 0 1
// exit ;
32562: GO 32875
// end else
32564: GO 32593
// if GetFuel ( bulldozer ) > 20 then
32566: LD_VAR 0 1
32570: PPUSH
32571: CALL_OW 261
32575: PUSH
32576: LD_INT 20
32578: GREATER
32579: IFFALSE 32593
// SetTag ( bulldozer , 0 ) ;
32581: LD_VAR 0 1
32585: PPUSH
32586: LD_INT 0
32588: PPUSH
32589: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32593: LD_ADDR_VAR 0 5
32597: PUSH
32598: LD_VAR 0 2
32602: PPUSH
32603: CALL_OW 353
32607: ST_TO_ADDR
// tmp := [ ] ;
32608: LD_ADDR_VAR 0 6
32612: PUSH
32613: EMPTY
32614: ST_TO_ADDR
// for i = 1 to list do
32615: LD_ADDR_VAR 0 4
32619: PUSH
32620: DOUBLE
32621: LD_INT 1
32623: DEC
32624: ST_TO_ADDR
32625: LD_VAR 0 5
32629: PUSH
32630: FOR_TO
32631: IFFALSE 32729
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32633: LD_VAR 0 5
32637: PUSH
32638: LD_VAR 0 4
32642: ARRAY
32643: PUSH
32644: LD_INT 1
32646: ARRAY
32647: PPUSH
32648: LD_VAR 0 5
32652: PUSH
32653: LD_VAR 0 4
32657: ARRAY
32658: PUSH
32659: LD_INT 2
32661: ARRAY
32662: PPUSH
32663: CALL_OW 554
32667: IFFALSE 32727
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32669: LD_ADDR_VAR 0 6
32673: PUSH
32674: LD_VAR 0 6
32678: PPUSH
32679: LD_VAR 0 6
32683: PUSH
32684: LD_INT 1
32686: PLUS
32687: PPUSH
32688: LD_VAR 0 5
32692: PUSH
32693: LD_VAR 0 4
32697: ARRAY
32698: PUSH
32699: LD_INT 1
32701: ARRAY
32702: PUSH
32703: LD_VAR 0 5
32707: PUSH
32708: LD_VAR 0 4
32712: ARRAY
32713: PUSH
32714: LD_INT 2
32716: ARRAY
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PPUSH
32722: CALL_OW 1
32726: ST_TO_ADDR
// end ;
32727: GO 32630
32729: POP
32730: POP
// ComStop ( bulldozer ) ;
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32740: LD_ADDR_VAR 0 7
32744: PUSH
32745: LD_VAR 0 1
32749: PPUSH
32750: CALL_OW 250
32754: PUSH
32755: LD_VAR 0 1
32759: PPUSH
32760: CALL_OW 251
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: ST_TO_ADDR
// for i = tmp downto 1 do
32769: LD_ADDR_VAR 0 4
32773: PUSH
32774: DOUBLE
32775: LD_VAR 0 6
32779: INC
32780: ST_TO_ADDR
32781: LD_INT 1
32783: PUSH
32784: FOR_DOWNTO
32785: IFFALSE 32873
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32787: LD_ADDR_VAR 0 7
32791: PUSH
32792: LD_VAR 0 7
32796: PUSH
32797: LD_INT 1
32799: ARRAY
32800: PPUSH
32801: LD_VAR 0 7
32805: PUSH
32806: LD_INT 2
32808: ARRAY
32809: PPUSH
32810: LD_VAR 0 6
32814: PPUSH
32815: CALL 32976 0 3
32819: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32820: LD_VAR 0 1
32824: PPUSH
32825: LD_VAR 0 7
32829: PUSH
32830: LD_INT 1
32832: ARRAY
32833: PPUSH
32834: LD_VAR 0 7
32838: PUSH
32839: LD_INT 2
32841: ARRAY
32842: PPUSH
32843: CALL 32880 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32847: LD_ADDR_VAR 0 6
32851: PUSH
32852: LD_VAR 0 6
32856: PPUSH
32857: LD_VAR 0 7
32861: PUSH
32862: LD_INT 3
32864: ARRAY
32865: PPUSH
32866: CALL_OW 3
32870: ST_TO_ADDR
// end ;
32871: GO 32784
32873: POP
32874: POP
// end ;
32875: LD_VAR 0 3
32879: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32880: LD_INT 0
32882: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32883: LD_VAR 0 2
32887: PPUSH
32888: LD_VAR 0 3
32892: PPUSH
32893: CALL_OW 351
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 554
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 488
32928: AND
32929: PUSH
32930: LD_VAR 0 2
32934: PPUSH
32935: LD_VAR 0 3
32939: PPUSH
32940: CALL_OW 428
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: EQUAL
32949: AND
32950: IFFALSE 32971
// AddComMoveXY ( bulldozer , x , y ) ;
32952: LD_VAR 0 1
32956: PPUSH
32957: LD_VAR 0 2
32961: PPUSH
32962: LD_VAR 0 3
32966: PPUSH
32967: CALL_OW 171
// end ;
32971: LD_VAR 0 4
32975: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32976: LD_INT 0
32978: PPUSH
32979: PPUSH
32980: PPUSH
32981: PPUSH
32982: PPUSH
32983: PPUSH
32984: PPUSH
// dist := 99999 ;
32985: LD_ADDR_VAR 0 6
32989: PUSH
32990: LD_INT 99999
32992: ST_TO_ADDR
// for i = 1 to list do
32993: LD_ADDR_VAR 0 5
32997: PUSH
32998: DOUBLE
32999: LD_INT 1
33001: DEC
33002: ST_TO_ADDR
33003: LD_VAR 0 3
33007: PUSH
33008: FOR_TO
33009: IFFALSE 33147
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33011: LD_ADDR_VAR 0 7
33015: PUSH
33016: LD_VAR 0 1
33020: PPUSH
33021: LD_VAR 0 2
33025: PPUSH
33026: LD_VAR 0 3
33030: PUSH
33031: LD_VAR 0 5
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: ARRAY
33040: PPUSH
33041: LD_VAR 0 3
33045: PUSH
33046: LD_VAR 0 5
33050: ARRAY
33051: PUSH
33052: LD_INT 2
33054: ARRAY
33055: PPUSH
33056: CALL_OW 298
33060: ST_TO_ADDR
// if d = 0 then
33061: LD_VAR 0 7
33065: PUSH
33066: LD_INT 0
33068: EQUAL
33069: IFFALSE 33073
// continue ;
33071: GO 33008
// if d < dist then
33073: LD_VAR 0 7
33077: PUSH
33078: LD_VAR 0 6
33082: LESS
33083: IFFALSE 33145
// begin _x := list [ i ] [ 1 ] ;
33085: LD_ADDR_VAR 0 8
33089: PUSH
33090: LD_VAR 0 3
33094: PUSH
33095: LD_VAR 0 5
33099: ARRAY
33100: PUSH
33101: LD_INT 1
33103: ARRAY
33104: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33105: LD_ADDR_VAR 0 9
33109: PUSH
33110: LD_VAR 0 3
33114: PUSH
33115: LD_VAR 0 5
33119: ARRAY
33120: PUSH
33121: LD_INT 2
33123: ARRAY
33124: ST_TO_ADDR
// _i := i ;
33125: LD_ADDR_VAR 0 10
33129: PUSH
33130: LD_VAR 0 5
33134: ST_TO_ADDR
// dist := d ;
33135: LD_ADDR_VAR 0 6
33139: PUSH
33140: LD_VAR 0 7
33144: ST_TO_ADDR
// end ; end ;
33145: GO 33008
33147: POP
33148: POP
// result := [ _x , _y , _i , dist ] ;
33149: LD_ADDR_VAR 0 4
33153: PUSH
33154: LD_VAR 0 8
33158: PUSH
33159: LD_VAR 0 9
33163: PUSH
33164: LD_VAR 0 10
33168: PUSH
33169: LD_VAR 0 6
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: ST_TO_ADDR
// end ;
33180: LD_VAR 0 4
33184: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33185: LD_INT 0
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
// for i = 1 to list do
33192: LD_ADDR_VAR 0 5
33196: PUSH
33197: DOUBLE
33198: LD_INT 1
33200: DEC
33201: ST_TO_ADDR
33202: LD_VAR 0 1
33206: PUSH
33207: FOR_TO
33208: IFFALSE 33522
// begin for j = list downto 2 do
33210: LD_ADDR_VAR 0 6
33214: PUSH
33215: DOUBLE
33216: LD_VAR 0 1
33220: INC
33221: ST_TO_ADDR
33222: LD_INT 2
33224: PUSH
33225: FOR_DOWNTO
33226: IFFALSE 33518
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33228: LD_VAR 0 2
33232: PPUSH
33233: LD_VAR 0 3
33237: PPUSH
33238: LD_VAR 0 1
33242: PUSH
33243: LD_VAR 0 6
33247: ARRAY
33248: PUSH
33249: LD_INT 1
33251: ARRAY
33252: PPUSH
33253: LD_VAR 0 1
33257: PUSH
33258: LD_VAR 0 6
33262: ARRAY
33263: PUSH
33264: LD_INT 2
33266: ARRAY
33267: PPUSH
33268: CALL_OW 298
33272: PUSH
33273: LD_VAR 0 2
33277: PPUSH
33278: LD_VAR 0 3
33282: PPUSH
33283: LD_VAR 0 1
33287: PUSH
33288: LD_VAR 0 6
33292: PUSH
33293: LD_INT 1
33295: MINUS
33296: ARRAY
33297: PUSH
33298: LD_INT 1
33300: ARRAY
33301: PPUSH
33302: LD_VAR 0 1
33306: PUSH
33307: LD_VAR 0 6
33311: PUSH
33312: LD_INT 1
33314: MINUS
33315: ARRAY
33316: PUSH
33317: LD_INT 2
33319: ARRAY
33320: PPUSH
33321: CALL_OW 298
33325: LESS
33326: IFFALSE 33516
// begin _x := list [ j ] [ 1 ] ;
33328: LD_ADDR_VAR 0 7
33332: PUSH
33333: LD_VAR 0 1
33337: PUSH
33338: LD_VAR 0 6
33342: ARRAY
33343: PUSH
33344: LD_INT 1
33346: ARRAY
33347: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33348: LD_ADDR_VAR 0 8
33352: PUSH
33353: LD_VAR 0 1
33357: PUSH
33358: LD_VAR 0 6
33362: ARRAY
33363: PUSH
33364: LD_INT 2
33366: ARRAY
33367: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33368: LD_ADDR_VAR 0 1
33372: PUSH
33373: LD_VAR 0 1
33377: PPUSH
33378: LD_VAR 0 6
33382: PPUSH
33383: LD_INT 1
33385: PPUSH
33386: LD_VAR 0 1
33390: PUSH
33391: LD_VAR 0 6
33395: PUSH
33396: LD_INT 1
33398: MINUS
33399: ARRAY
33400: PUSH
33401: LD_INT 1
33403: ARRAY
33404: PPUSH
33405: CALL 31146 0 4
33409: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33410: LD_ADDR_VAR 0 1
33414: PUSH
33415: LD_VAR 0 1
33419: PPUSH
33420: LD_VAR 0 6
33424: PPUSH
33425: LD_INT 2
33427: PPUSH
33428: LD_VAR 0 1
33432: PUSH
33433: LD_VAR 0 6
33437: PUSH
33438: LD_INT 1
33440: MINUS
33441: ARRAY
33442: PUSH
33443: LD_INT 2
33445: ARRAY
33446: PPUSH
33447: CALL 31146 0 4
33451: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33452: LD_ADDR_VAR 0 1
33456: PUSH
33457: LD_VAR 0 1
33461: PPUSH
33462: LD_VAR 0 6
33466: PUSH
33467: LD_INT 1
33469: MINUS
33470: PPUSH
33471: LD_INT 1
33473: PPUSH
33474: LD_VAR 0 7
33478: PPUSH
33479: CALL 31146 0 4
33483: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33484: LD_ADDR_VAR 0 1
33488: PUSH
33489: LD_VAR 0 1
33493: PPUSH
33494: LD_VAR 0 6
33498: PUSH
33499: LD_INT 1
33501: MINUS
33502: PPUSH
33503: LD_INT 2
33505: PPUSH
33506: LD_VAR 0 8
33510: PPUSH
33511: CALL 31146 0 4
33515: ST_TO_ADDR
// end ; end ;
33516: GO 33225
33518: POP
33519: POP
// end ;
33520: GO 33207
33522: POP
33523: POP
// result := list ;
33524: LD_ADDR_VAR 0 4
33528: PUSH
33529: LD_VAR 0 1
33533: ST_TO_ADDR
// end ;
33534: LD_VAR 0 4
33538: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33539: LD_INT 0
33541: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33542: LD_ADDR_VAR 0 5
33546: PUSH
33547: LD_VAR 0 1
33551: PPUSH
33552: LD_VAR 0 2
33556: PPUSH
33557: CALL_OW 546
33561: PUSH
33562: LD_INT 2
33564: ARRAY
33565: PUSH
33566: LD_VAR 0 3
33570: PPUSH
33571: LD_VAR 0 4
33575: PPUSH
33576: CALL_OW 546
33580: PUSH
33581: LD_INT 2
33583: ARRAY
33584: MINUS
33585: ST_TO_ADDR
// if result < 0 then
33586: LD_VAR 0 5
33590: PUSH
33591: LD_INT 0
33593: LESS
33594: IFFALSE 33611
// result := result * - 1 ;
33596: LD_ADDR_VAR 0 5
33600: PUSH
33601: LD_VAR 0 5
33605: PUSH
33606: LD_INT 1
33608: NEG
33609: MUL
33610: ST_TO_ADDR
// end ;
33611: LD_VAR 0 5
33615: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33616: LD_INT 0
33618: PPUSH
33619: PPUSH
// area = ListEnvironmentArea ( area ) ;
33620: LD_ADDR_VAR 0 2
33624: PUSH
33625: LD_VAR 0 2
33629: PPUSH
33630: CALL_OW 353
33634: ST_TO_ADDR
// if bulldozer > 0 then
33635: LD_VAR 0 1
33639: PUSH
33640: LD_INT 0
33642: GREATER
33643: IFFALSE 33754
// for i = area downto 1 do
33645: LD_ADDR_VAR 0 4
33649: PUSH
33650: DOUBLE
33651: LD_VAR 0 2
33655: INC
33656: ST_TO_ADDR
33657: LD_INT 1
33659: PUSH
33660: FOR_DOWNTO
33661: IFFALSE 33752
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33663: LD_VAR 0 2
33667: PUSH
33668: LD_VAR 0 4
33672: ARRAY
33673: PUSH
33674: LD_INT 1
33676: ARRAY
33677: PPUSH
33678: LD_VAR 0 2
33682: PUSH
33683: LD_VAR 0 4
33687: ARRAY
33688: PUSH
33689: LD_INT 2
33691: ARRAY
33692: PPUSH
33693: CALL_OW 351
33697: IFFALSE 33750
// if not HasTask ( bulldozer ) then
33699: LD_VAR 0 1
33703: PPUSH
33704: CALL_OW 314
33708: NOT
33709: IFFALSE 33750
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33711: LD_VAR 0 1
33715: PPUSH
33716: LD_VAR 0 2
33720: PUSH
33721: LD_VAR 0 4
33725: ARRAY
33726: PUSH
33727: LD_INT 1
33729: ARRAY
33730: PPUSH
33731: LD_VAR 0 2
33735: PUSH
33736: LD_VAR 0 4
33740: ARRAY
33741: PUSH
33742: LD_INT 2
33744: ARRAY
33745: PPUSH
33746: CALL_OW 171
33750: GO 33660
33752: POP
33753: POP
// end ;
33754: LD_VAR 0 3
33758: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33759: LD_INT 0
33761: PPUSH
33762: PPUSH
33763: PPUSH
33764: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33765: LD_ADDR_VAR 0 6
33769: PUSH
33770: LD_INT 22
33772: PUSH
33773: LD_VAR 0 1
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 21
33784: PUSH
33785: LD_VAR 0 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PPUSH
33798: CALL_OW 69
33802: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33803: LD_ADDR_VAR 0 7
33807: PUSH
33808: LD_VAR 0 3
33812: PPUSH
33813: LD_INT 22
33815: PUSH
33816: LD_VAR 0 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 21
33827: PUSH
33828: LD_VAR 0 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PPUSH
33841: CALL_OW 70
33845: ST_TO_ADDR
// if tmp and pom then
33846: LD_VAR 0 6
33850: PUSH
33851: LD_VAR 0 7
33855: AND
33856: IFFALSE 33876
// result := tmp diff pom else
33858: LD_ADDR_VAR 0 4
33862: PUSH
33863: LD_VAR 0 6
33867: PUSH
33868: LD_VAR 0 7
33872: DIFF
33873: ST_TO_ADDR
33874: GO 33884
// result := false ;
33876: LD_ADDR_VAR 0 4
33880: PUSH
33881: LD_INT 0
33883: ST_TO_ADDR
// end ;
33884: LD_VAR 0 4
33888: RET
// export function SavePosition ( unit ) ; begin
33889: LD_INT 0
33891: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33892: LD_VAR 0 1
33896: PPUSH
33897: LD_VAR 0 1
33901: PPUSH
33902: CALL_OW 250
33906: PPUSH
33907: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33911: LD_VAR 0 1
33915: PPUSH
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL_OW 251
33925: PPUSH
33926: CALL_OW 232
// end ;
33930: LD_VAR 0 2
33934: RET
// export function GetPosition ( unit ) ; begin
33935: LD_INT 0
33937: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33938: LD_ADDR_VAR 0 2
33942: PUSH
33943: LD_VAR 0 1
33947: PPUSH
33948: CALL_OW 252
33952: PUSH
33953: LD_VAR 0 1
33957: PPUSH
33958: CALL_OW 253
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: ST_TO_ADDR
// end ;
33967: LD_VAR 0 2
33971: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33972: LD_INT 0
33974: PPUSH
// if unit in unreachableList then
33975: LD_VAR 0 1
33979: PUSH
33980: LD_EXP 30
33984: IN
33985: IFFALSE 34003
// unreachableList := unreachableList diff unit ;
33987: LD_ADDR_EXP 30
33991: PUSH
33992: LD_EXP 30
33996: PUSH
33997: LD_VAR 0 1
34001: DIFF
34002: ST_TO_ADDR
// if ValidHex ( x , y ) then
34003: LD_VAR 0 2
34007: PPUSH
34008: LD_VAR 0 3
34012: PPUSH
34013: CALL_OW 488
34017: IFFALSE 34043
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34019: LD_VAR 0 1
34023: PPUSH
34024: LD_VAR 0 2
34028: PPUSH
34029: LD_VAR 0 3
34033: PPUSH
34034: CALL_OW 428
34038: PPUSH
34039: CALL_OW 115
// Wait ( 3 ) ;
34043: LD_INT 3
34045: PPUSH
34046: CALL_OW 67
// if unit in unreachableList then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 30
34059: IN
34060: IFFALSE 34072
// result := false else
34062: LD_ADDR_VAR 0 4
34066: PUSH
34067: LD_INT 0
34069: ST_TO_ADDR
34070: GO 34080
// result := true ;
34072: LD_ADDR_VAR 0 4
34076: PUSH
34077: LD_INT 1
34079: ST_TO_ADDR
// end ; end_of_file
34080: LD_VAR 0 4
34084: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34085: LD_EXP 31
34089: IFFALSE 34151
34091: GO 34093
34093: DISABLE
34094: LD_INT 0
34096: PPUSH
// begin enable ;
34097: ENABLE
// for i = 1 to mc_crates_list do
34098: LD_ADDR_VAR 0 1
34102: PUSH
34103: DOUBLE
34104: LD_INT 1
34106: DEC
34107: ST_TO_ADDR
34108: LD_EXP 32
34112: PUSH
34113: FOR_TO
34114: IFFALSE 34145
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34116: LD_EXP 32
34120: PUSH
34121: LD_VAR 0 1
34125: ARRAY
34126: PPUSH
34127: LD_INT 5
34129: PPUSH
34130: LD_INT 50
34132: PPUSH
34133: LD_INT 700
34135: PPUSH
34136: LD_INT 20
34138: PPUSH
34139: CALL 24501 0 5
34143: GO 34113
34145: POP
34146: POP
// MC_Game ( ) ;
34147: CALL 34154 0 0
// end ;
34151: PPOPN 1
34153: END
// export function MC_Game ( ) ; var i , side , un ; begin
34154: LD_INT 0
34156: PPUSH
34157: PPUSH
34158: PPUSH
34159: PPUSH
// if not isTest then
34160: LD_EXP 1
34164: NOT
34165: IFFALSE 34185
// MC_Show ( [ #tick , tick ] ) else
34167: LD_STRING #tick
34169: PUSH
34170: LD_OWVAR 1
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PPUSH
34179: CALL 8585 0 1
34183: GO 34194
// MC_Show ( debug_string ) ;
34185: LD_EXP 2
34189: PPUSH
34190: CALL 8585 0 1
// for side = 1 to 8 do
34194: LD_ADDR_VAR 0 3
34198: PUSH
34199: DOUBLE
34200: LD_INT 1
34202: DEC
34203: ST_TO_ADDR
34204: LD_INT 8
34206: PUSH
34207: FOR_TO
34208: IFFALSE 36208
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34210: LD_EXP 39
34214: PUSH
34215: LD_VAR 0 3
34219: ARRAY
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: PUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: EMPTY
34231: PPUSH
34232: CALL 11802 0 2
34236: PUSH
34237: LD_INT 0
34239: EQUAL
34240: OR
34241: IFFALSE 34245
// continue ;
34243: GO 34207
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34245: LD_VAR 0 3
34249: PPUSH
34250: LD_VAR 0 3
34254: PPUSH
34255: CALL 25022 0 1
34259: PPUSH
34260: CALL 36215 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34264: LD_EXP 71
34268: PUSH
34269: LD_VAR 0 3
34273: ARRAY
34274: PUSH
34275: LD_INT 1
34277: ARRAY
34278: PUSH
34279: LD_INT 0
34281: GREATER
34282: PUSH
34283: LD_EXP 69
34287: PUSH
34288: LD_VAR 0 3
34292: ARRAY
34293: PUSH
34294: LD_INT 1
34296: ARRAY
34297: PUSH
34298: LD_INT 0
34300: EQUAL
34301: AND
34302: PUSH
34303: LD_VAR 0 3
34307: PPUSH
34308: LD_INT 7
34310: PPUSH
34311: EMPTY
34312: PPUSH
34313: CALL 12370 0 3
34317: NOT
34318: AND
34319: IFFALSE 34356
// begin for i in MREG_Attackers [ side ] do
34321: LD_ADDR_VAR 0 2
34325: PUSH
34326: LD_EXP 71
34330: PUSH
34331: LD_VAR 0 3
34335: ARRAY
34336: PUSH
34337: FOR_IN
34338: IFFALSE 34354
// SetTag ( i , 7 ) ;
34340: LD_VAR 0 2
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: CALL_OW 109
34352: GO 34337
34354: POP
34355: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34356: LD_VAR 0 3
34360: PPUSH
34361: LD_INT 7
34363: PPUSH
34364: EMPTY
34365: PPUSH
34366: CALL 12370 0 3
34370: IFFALSE 34430
// begin if side = 1 then
34372: LD_VAR 0 3
34376: PUSH
34377: LD_INT 1
34379: EQUAL
34380: IFFALSE 34389
// RaiseSailEvent ( 101 ) ;
34382: LD_INT 101
34384: PPUSH
34385: CALL_OW 427
// if side = 4 then
34389: LD_VAR 0 3
34393: PUSH
34394: LD_INT 4
34396: EQUAL
34397: IFFALSE 34406
// RaiseSailEvent ( 102 ) ;
34399: LD_INT 102
34401: PPUSH
34402: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34406: LD_VAR 0 3
34410: PPUSH
34411: LD_VAR 0 3
34415: PPUSH
34416: LD_INT 7
34418: PPUSH
34419: EMPTY
34420: PPUSH
34421: CALL 12370 0 3
34425: PPUSH
34426: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34430: LD_VAR 0 3
34434: PPUSH
34435: CALL 18050 0 1
34439: PUSH
34440: LD_VAR 0 3
34444: PPUSH
34445: CALL 11706 0 1
34449: AND
34450: IFFALSE 34461
// MCL_Start ( side ) ;
34452: LD_VAR 0 3
34456: PPUSH
34457: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34461: LD_ADDR_EXP 35
34465: PUSH
34466: LD_EXP 35
34470: PPUSH
34471: LD_VAR 0 3
34475: PPUSH
34476: LD_VAR 0 3
34480: PPUSH
34481: CALL 19307 0 1
34485: PPUSH
34486: CALL_OW 1
34490: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34491: LD_ADDR_EXP 47
34495: PUSH
34496: LD_EXP 47
34500: PPUSH
34501: LD_VAR 0 3
34505: PPUSH
34506: LD_VAR 0 3
34510: PPUSH
34511: CALL 11120 0 1
34515: PPUSH
34516: CALL_OW 1
34520: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34521: LD_VAR 0 3
34525: PPUSH
34526: LD_INT 21
34528: PUSH
34529: LD_INT 2
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PPUSH
34536: CALL 11667 0 2
34540: IFFALSE 34551
// MCV_CheckStatus ( side ) ;
34542: LD_VAR 0 3
34546: PPUSH
34547: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34551: LD_VAR 0 3
34555: PPUSH
34556: LD_EXP 53
34560: PPUSH
34561: CALL 43015 0 2
34565: IFFALSE 34650
// begin for i = MREG_ToChangeClass downto 1 do
34567: LD_ADDR_VAR 0 2
34571: PUSH
34572: DOUBLE
34573: LD_EXP 53
34577: INC
34578: ST_TO_ADDR
34579: LD_INT 1
34581: PUSH
34582: FOR_DOWNTO
34583: IFFALSE 34648
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34585: LD_EXP 53
34589: PUSH
34590: LD_VAR 0 2
34594: ARRAY
34595: PUSH
34596: LD_INT 1
34598: ARRAY
34599: PUSH
34600: LD_VAR 0 3
34604: EQUAL
34605: IFFALSE 34646
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34607: LD_VAR 0 3
34611: PPUSH
34612: LD_EXP 53
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PUSH
34623: LD_INT 2
34625: ARRAY
34626: PPUSH
34627: LD_EXP 53
34631: PUSH
34632: LD_VAR 0 2
34636: ARRAY
34637: PUSH
34638: LD_INT 3
34640: ARRAY
34641: PPUSH
34642: CALL 16574 0 3
// end ; end ;
34646: GO 34582
34648: POP
34649: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34650: LD_INT 1
34652: PUSH
34653: LD_EXP 38
34657: PUSH
34658: LD_VAR 0 3
34662: ARRAY
34663: IN
34664: IFFALSE 34675
// begin MCN_TrainApe ( side ) ;
34666: LD_VAR 0 3
34670: PPUSH
34671: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_INT 30
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PPUSH
34690: CALL 11667 0 2
34694: IFFALSE 34868
// begin if MCF_Tag ( side , 10 , [ ] ) then
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12370 0 3
34710: IFFALSE 34757
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34712: LD_VAR 0 3
34716: PPUSH
34717: LD_INT 10
34719: PPUSH
34720: EMPTY
34721: PPUSH
34722: CALL 12370 0 3
34726: PPUSH
34727: LD_VAR 0 3
34731: PPUSH
34732: LD_INT 30
34734: PUSH
34735: LD_INT 3
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PPUSH
34742: CALL 11667 0 2
34746: PUSH
34747: LD_INT 1
34749: ARRAY
34750: PPUSH
34751: CALL_OW 168
// end else
34755: GO 34868
// if MREG_ToConstruct [ side ] then
34757: LD_EXP 51
34761: PUSH
34762: LD_VAR 0 3
34766: ARRAY
34767: IFFALSE 34868
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34769: LD_VAR 0 3
34773: PPUSH
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11667 0 2
34793: PUSH
34794: LD_INT 1
34796: ARRAY
34797: PPUSH
34798: LD_EXP 51
34802: PUSH
34803: LD_VAR 0 3
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PUSH
34813: LD_EXP 51
34817: PUSH
34818: LD_VAR 0 3
34822: ARRAY
34823: PUSH
34824: LD_INT 2
34826: ARRAY
34827: PUSH
34828: LD_EXP 51
34832: PUSH
34833: LD_VAR 0 3
34837: ARRAY
34838: PUSH
34839: LD_INT 3
34841: ARRAY
34842: PUSH
34843: LD_EXP 51
34847: PUSH
34848: LD_VAR 0 3
34852: ARRAY
34853: PUSH
34854: LD_INT 4
34856: ARRAY
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: PPUSH
34864: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34868: LD_VAR 0 3
34872: PPUSH
34873: LD_INT 30
34875: PUSH
34876: LD_INT 3
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PPUSH
34883: CALL 11667 0 2
34887: PUSH
34888: LD_VAR 0 3
34892: PPUSH
34893: LD_EXP 43
34897: PPUSH
34898: CALL 43015 0 2
34902: AND
34903: PUSH
34904: LD_INT 22
34906: PUSH
34907: LD_VAR 0 3
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: PUSH
34919: LD_INT 30
34921: PUSH
34922: LD_INT 33
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 30
34931: PUSH
34932: LD_INT 32
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 35
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: LIST
34958: PPUSH
34959: CALL_OW 69
34963: AND
34964: IFFALSE 34975
// MCV_Turret ( side ) ;
34966: LD_VAR 0 3
34970: PPUSH
34971: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34975: LD_EXP 42
34979: PUSH
34980: LD_VAR 0 3
34984: ARRAY
34985: PUSH
34986: LD_INT 1
34988: GREATER
34989: PUSH
34990: LD_VAR 0 3
34994: PPUSH
34995: CALL 25022 0 1
34999: PUSH
35000: LD_INT 0
35002: EQUAL
35003: AND
35004: IFFALSE 35166
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35006: LD_EXP 42
35010: PUSH
35011: LD_VAR 0 3
35015: ARRAY
35016: PUSH
35017: LD_INT 1
35019: ARRAY
35020: PPUSH
35021: CALL_OW 353
35025: IFFALSE 35063
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35027: LD_EXP 42
35031: PUSH
35032: LD_VAR 0 3
35036: ARRAY
35037: PUSH
35038: LD_INT 2
35040: ARRAY
35041: PPUSH
35042: LD_EXP 42
35046: PUSH
35047: LD_VAR 0 3
35051: ARRAY
35052: PUSH
35053: LD_INT 1
35055: ARRAY
35056: PPUSH
35057: CALL 32444 0 2
35061: GO 35166
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35063: LD_VAR 0 3
35067: PPUSH
35068: LD_INT 30
35070: PUSH
35071: LD_INT 3
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PPUSH
35078: CALL 11667 0 2
35082: IFFALSE 35166
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35084: LD_VAR 0 3
35088: PPUSH
35089: LD_INT 30
35091: PUSH
35092: LD_INT 3
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PPUSH
35099: CALL 11667 0 2
35103: PUSH
35104: LD_INT 1
35106: ARRAY
35107: PPUSH
35108: CALL_OW 461
35112: PUSH
35113: LD_INT 2
35115: EQUAL
35116: IFFALSE 35166
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35118: LD_EXP 42
35122: PUSH
35123: LD_VAR 0 3
35127: ARRAY
35128: PUSH
35129: LD_INT 2
35131: ARRAY
35132: PPUSH
35133: LD_INT 10
35135: PPUSH
35136: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35140: LD_ADDR_EXP 42
35144: PUSH
35145: LD_EXP 42
35149: PPUSH
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 0
35157: PUSH
35158: EMPTY
35159: LIST
35160: PPUSH
35161: CALL_OW 1
35165: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35166: LD_VAR 0 3
35170: PPUSH
35171: LD_INT 33
35173: PUSH
35174: LD_INT 2
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PPUSH
35181: CALL 11667 0 2
35185: IFFALSE 35225
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35187: LD_VAR 0 3
35191: PPUSH
35192: LD_VAR 0 3
35196: PPUSH
35197: LD_INT 33
35199: PUSH
35200: LD_INT 2
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PPUSH
35207: CALL 11667 0 2
35211: PUSH
35212: LD_INT 1
35214: ARRAY
35215: PPUSH
35216: CALL_OW 248
35220: PPUSH
35221: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35225: LD_EXP 47
35229: PUSH
35230: LD_VAR 0 3
35234: ARRAY
35235: IFFALSE 35248
// begin MCB_Repair ( side ) ;
35237: LD_VAR 0 3
35241: PPUSH
35242: CALL 11407 0 1
// end else
35246: GO 36161
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35248: LD_VAR 0 3
35252: PPUSH
35253: LD_EXP 49
35257: PPUSH
35258: CALL 43015 0 2
35262: PUSH
35263: LD_VAR 0 3
35267: PPUSH
35268: LD_EXP 40
35272: PPUSH
35273: CALL 43015 0 2
35277: AND
35278: IFFALSE 35486
// begin for i = 1 to MREG_ToUpLab do
35280: LD_ADDR_VAR 0 2
35284: PUSH
35285: DOUBLE
35286: LD_INT 1
35288: DEC
35289: ST_TO_ADDR
35290: LD_EXP 49
35294: PUSH
35295: FOR_TO
35296: IFFALSE 35482
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35298: LD_EXP 49
35302: PUSH
35303: LD_VAR 0 2
35307: ARRAY
35308: PUSH
35309: LD_INT 1
35311: ARRAY
35312: PUSH
35313: LD_VAR 0 3
35317: EQUAL
35318: IFFALSE 35480
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35320: LD_EXP 49
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: PUSH
35331: LD_INT 2
35333: ARRAY
35334: PUSH
35335: LD_EXP 49
35339: PUSH
35340: LD_VAR 0 2
35344: ARRAY
35345: PUSH
35346: LD_INT 3
35348: ARRAY
35349: AND
35350: IFFALSE 35478
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35352: LD_VAR 0 3
35356: PPUSH
35357: LD_EXP 49
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_INT 2
35370: ARRAY
35371: PPUSH
35372: LD_EXP 49
35376: PUSH
35377: LD_VAR 0 2
35381: ARRAY
35382: PUSH
35383: LD_INT 3
35385: ARRAY
35386: PPUSH
35387: CALL 8931 0 3
35391: IFFALSE 35478
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35393: LD_ADDR_EXP 49
35397: PUSH
35398: LD_EXP 49
35402: PPUSH
35403: LD_VAR 0 3
35407: PPUSH
35408: LD_EXP 49
35412: PUSH
35413: LD_VAR 0 2
35417: ARRAY
35418: PUSH
35419: LD_INT 2
35421: ARRAY
35422: PPUSH
35423: LD_EXP 49
35427: PUSH
35428: LD_VAR 0 2
35432: ARRAY
35433: PUSH
35434: LD_INT 3
35436: ARRAY
35437: PPUSH
35438: CALL 42067 0 4
35442: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35443: LD_ADDR_EXP 40
35447: PUSH
35448: LD_EXP 40
35452: PPUSH
35453: LD_VAR 0 3
35457: PPUSH
35458: LD_EXP 40
35462: PUSH
35463: LD_INT 1
35465: ARRAY
35466: PUSH
35467: LD_INT 2
35469: ARRAY
35470: PPUSH
35471: EMPTY
35472: PPUSH
35473: CALL 42067 0 4
35477: ST_TO_ADDR
// end ; break ;
35478: GO 35482
// end ;
35480: GO 35295
35482: POP
35483: POP
// end else
35484: GO 36161
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35486: LD_VAR 0 3
35490: PPUSH
35491: LD_EXP 48
35495: PPUSH
35496: CALL 43015 0 2
35500: IFFALSE 35574
// begin for i = 1 to MREG_ToUpdate do
35502: LD_ADDR_VAR 0 2
35506: PUSH
35507: DOUBLE
35508: LD_INT 1
35510: DEC
35511: ST_TO_ADDR
35512: LD_EXP 48
35516: PUSH
35517: FOR_TO
35518: IFFALSE 35570
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35520: LD_EXP 48
35524: PUSH
35525: LD_VAR 0 2
35529: ARRAY
35530: PUSH
35531: LD_INT 1
35533: ARRAY
35534: PUSH
35535: LD_VAR 0 3
35539: EQUAL
35540: IFFALSE 35568
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35542: LD_VAR 0 3
35546: PPUSH
35547: LD_EXP 48
35551: PUSH
35552: LD_VAR 0 2
35556: ARRAY
35557: PUSH
35558: LD_INT 2
35560: ARRAY
35561: PPUSH
35562: CALL 8767 0 2
// break ;
35566: GO 35570
// end ;
35568: GO 35517
35570: POP
35571: POP
// end else
35572: GO 36161
// if MCF_Get ( side , [ f_constructed ] ) then
35574: LD_VAR 0 3
35578: PPUSH
35579: LD_INT 57
35581: PUSH
35582: EMPTY
35583: LIST
35584: PPUSH
35585: CALL 11667 0 2
35589: IFFALSE 35622
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35591: LD_VAR 0 3
35595: PPUSH
35596: LD_VAR 0 3
35600: PPUSH
35601: LD_INT 57
35603: PUSH
35604: EMPTY
35605: LIST
35606: PPUSH
35607: CALL 11667 0 2
35611: PUSH
35612: LD_INT 1
35614: ARRAY
35615: PPUSH
35616: CALL 11011 0 2
35620: GO 36161
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35622: LD_VAR 0 3
35626: PPUSH
35627: LD_EXP 46
35631: PPUSH
35632: CALL 43015 0 2
35636: PUSH
35637: LD_VAR 0 3
35641: PPUSH
35642: CALL_OW 345
35646: NOT
35647: AND
35648: PUSH
35649: LD_VAR 0 3
35653: PPUSH
35654: CALL 25022 0 1
35658: PUSH
35659: LD_INT 0
35661: EQUAL
35662: AND
35663: IFFALSE 36062
// begin for i = 1 to MREG_ToBuild do
35665: LD_ADDR_VAR 0 2
35669: PUSH
35670: DOUBLE
35671: LD_INT 1
35673: DEC
35674: ST_TO_ADDR
35675: LD_EXP 46
35679: PUSH
35680: FOR_TO
35681: IFFALSE 36058
// if MREG_ToBuild [ i ] [ 1 ] = side then
35683: LD_EXP 46
35687: PUSH
35688: LD_VAR 0 2
35692: ARRAY
35693: PUSH
35694: LD_INT 1
35696: ARRAY
35697: PUSH
35698: LD_VAR 0 3
35702: EQUAL
35703: IFFALSE 36056
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35705: LD_OWVAR 84
35709: PUSH
35710: LD_EXP 46
35714: PUSH
35715: LD_VAR 0 2
35719: ARRAY
35720: PUSH
35721: LD_INT 3
35723: ARRAY
35724: PUSH
35725: LD_INT 1
35727: ARRAY
35728: PPUSH
35729: LD_EXP 46
35733: PUSH
35734: LD_VAR 0 2
35738: ARRAY
35739: PUSH
35740: LD_INT 3
35742: ARRAY
35743: PUSH
35744: LD_INT 2
35746: ARRAY
35747: PPUSH
35748: CALL_OW 351
35752: AND
35753: IFFALSE 35797
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35755: LD_EXP 46
35759: PUSH
35760: LD_VAR 0 2
35764: ARRAY
35765: PUSH
35766: LD_INT 3
35768: ARRAY
35769: PUSH
35770: LD_INT 1
35772: ARRAY
35773: PPUSH
35774: LD_EXP 46
35778: PUSH
35779: LD_VAR 0 2
35783: ARRAY
35784: PUSH
35785: LD_INT 3
35787: ARRAY
35788: PUSH
35789: LD_INT 2
35791: ARRAY
35792: PPUSH
35793: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35797: LD_EXP 46
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: PUSH
35808: LD_INT 2
35810: ARRAY
35811: PUSH
35812: LD_INT 0
35814: EQUAL
35815: IFFALSE 35885
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35817: LD_VAR 0 3
35821: PPUSH
35822: LD_EXP 46
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: PUSH
35833: LD_INT 3
35835: ARRAY
35836: PUSH
35837: LD_INT 1
35839: ARRAY
35840: PPUSH
35841: LD_EXP 46
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_INT 3
35854: ARRAY
35855: PUSH
35856: LD_INT 2
35858: ARRAY
35859: PPUSH
35860: LD_EXP 46
35864: PUSH
35865: LD_VAR 0 2
35869: ARRAY
35870: PUSH
35871: LD_INT 3
35873: ARRAY
35874: PUSH
35875: LD_INT 3
35877: ARRAY
35878: PPUSH
35879: CALL 8603 0 4
35883: GO 36054
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35885: LD_EXP 46
35889: PUSH
35890: LD_VAR 0 2
35894: ARRAY
35895: PUSH
35896: LD_INT 2
35898: ARRAY
35899: PUSH
35900: LD_INT 6
35902: EQUAL
35903: IFFALSE 35973
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35905: LD_VAR 0 3
35909: PPUSH
35910: LD_EXP 46
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PUSH
35921: LD_INT 3
35923: ARRAY
35924: PUSH
35925: LD_INT 1
35927: ARRAY
35928: PPUSH
35929: LD_EXP 46
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: PUSH
35940: LD_INT 3
35942: ARRAY
35943: PUSH
35944: LD_INT 2
35946: ARRAY
35947: PPUSH
35948: LD_EXP 46
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PUSH
35959: LD_INT 3
35961: ARRAY
35962: PUSH
35963: LD_INT 3
35965: ARRAY
35966: PPUSH
35967: CALL 8732 0 4
35971: GO 36054
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35973: LD_VAR 0 3
35977: PPUSH
35978: LD_EXP 46
35982: PUSH
35983: LD_VAR 0 2
35987: ARRAY
35988: PUSH
35989: LD_INT 2
35991: ARRAY
35992: PPUSH
35993: LD_EXP 46
35997: PUSH
35998: LD_VAR 0 2
36002: ARRAY
36003: PUSH
36004: LD_INT 3
36006: ARRAY
36007: PUSH
36008: LD_INT 1
36010: ARRAY
36011: PPUSH
36012: LD_EXP 46
36016: PUSH
36017: LD_VAR 0 2
36021: ARRAY
36022: PUSH
36023: LD_INT 3
36025: ARRAY
36026: PUSH
36027: LD_INT 2
36029: ARRAY
36030: PPUSH
36031: LD_EXP 46
36035: PUSH
36036: LD_VAR 0 2
36040: ARRAY
36041: PUSH
36042: LD_INT 3
36044: ARRAY
36045: PUSH
36046: LD_INT 3
36048: ARRAY
36049: PPUSH
36050: CALL 10236 0 5
// break ;
36054: GO 36058
// end ;
36056: GO 35680
36058: POP
36059: POP
// end else
36060: GO 36161
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36062: LD_VAR 0 3
36066: PPUSH
36067: LD_EXP 52
36071: PPUSH
36072: CALL 43015 0 2
36076: PUSH
36077: LD_VAR 0 3
36081: PPUSH
36082: CALL 25022 0 1
36086: PUSH
36087: LD_INT 0
36089: EQUAL
36090: AND
36091: IFFALSE 36161
// begin for i = 1 to MREG_ToDismantle do
36093: LD_ADDR_VAR 0 2
36097: PUSH
36098: DOUBLE
36099: LD_INT 1
36101: DEC
36102: ST_TO_ADDR
36103: LD_EXP 52
36107: PUSH
36108: FOR_TO
36109: IFFALSE 36159
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36111: LD_EXP 52
36115: PUSH
36116: LD_VAR 0 2
36120: ARRAY
36121: PUSH
36122: LD_INT 1
36124: ARRAY
36125: PUSH
36126: LD_VAR 0 3
36130: EQUAL
36131: IFFALSE 36157
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36133: LD_VAR 0 3
36137: PPUSH
36138: LD_EXP 52
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_INT 2
36151: ARRAY
36152: PPUSH
36153: CALL 10902 0 2
// end ;
36157: GO 36108
36159: POP
36160: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36161: LD_VAR 0 3
36165: PPUSH
36166: LD_INT 30
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PPUSH
36176: CALL 11667 0 2
36180: PUSH
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 25022 0 1
36190: PUSH
36191: LD_INT 0
36193: EQUAL
36194: AND
36195: IFFALSE 36206
// MCT_CollectCrates ( side ) ;
36197: LD_VAR 0 3
36201: PPUSH
36202: CALL 23961 0 1
// end ;
36206: GO 34207
36208: POP
36209: POP
// end ;
36210: LD_VAR 0 1
36214: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36215: LD_INT 0
36217: PPUSH
36218: PPUSH
36219: PPUSH
36220: PPUSH
36221: PPUSH
36222: PPUSH
36223: PPUSH
36224: PPUSH
36225: PPUSH
36226: PPUSH
36227: PPUSH
36228: PPUSH
36229: PPUSH
36230: PPUSH
36231: PPUSH
// all := MCF_All ( side , [ ] ) ;
36232: LD_ADDR_VAR 0 17
36236: PUSH
36237: LD_VAR 0 1
36241: PPUSH
36242: EMPTY
36243: PPUSH
36244: CALL 11802 0 2
36248: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36249: LD_ADDR_VAR 0 13
36253: PUSH
36254: LD_VAR 0 1
36258: PPUSH
36259: LD_INT 1
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL 11750 0 3
36268: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36269: LD_ADDR_VAR 0 14
36273: PUSH
36274: LD_VAR 0 1
36278: PPUSH
36279: LD_INT 2
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL 11750 0 3
36288: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36289: LD_ADDR_VAR 0 15
36293: PUSH
36294: LD_VAR 0 1
36298: PPUSH
36299: LD_INT 3
36301: PPUSH
36302: EMPTY
36303: PPUSH
36304: CALL 11750 0 3
36308: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36309: LD_ADDR_VAR 0 16
36313: PUSH
36314: LD_VAR 0 1
36318: PPUSH
36319: LD_INT 4
36321: PPUSH
36322: EMPTY
36323: PPUSH
36324: CALL 11750 0 3
36328: ST_TO_ADDR
// if mech then
36329: LD_VAR 0 15
36333: IFFALSE 36350
// mech := MCF_SortListDesc ( mech ) ;
36335: LD_ADDR_VAR 0 15
36339: PUSH
36340: LD_VAR 0 15
36344: PPUSH
36345: CALL 12916 0 1
36349: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36350: LD_EXP 56
36354: PUSH
36355: LD_VAR 0 1
36359: ARRAY
36360: PUSH
36361: LD_STRING 
36363: EQUAL
36364: NOT
36365: IFFALSE 36421
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36367: LD_EXP 56
36371: PUSH
36372: LD_VAR 0 1
36376: ARRAY
36377: PUSH
36378: LD_INT 1
36380: ARRAY
36381: PPUSH
36382: CALL_OW 257
36386: PUSH
36387: LD_INT 1
36389: EQUAL
36390: IFFALSE 36419
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36392: LD_VAR 0 1
36396: PPUSH
36397: LD_STRING ToArm
36399: PPUSH
36400: LD_EXP 56
36404: PUSH
36405: LD_VAR 0 1
36409: ARRAY
36410: PUSH
36411: LD_INT 1
36413: ARRAY
36414: PPUSH
36415: CALL 14546 0 3
// end else
36419: GO 36447
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36421: LD_ADDR_EXP 56
36425: PUSH
36426: LD_EXP 56
36430: PPUSH
36431: LD_VAR 0 1
36435: PPUSH
36436: LD_INT 1
36438: PPUSH
36439: LD_INT 0
36441: PPUSH
36442: CALL 31146 0 4
36446: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36447: LD_EXP 57
36451: PUSH
36452: LD_VAR 0 1
36456: ARRAY
36457: PUSH
36458: LD_STRING 
36460: EQUAL
36461: NOT
36462: IFFALSE 36518
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36464: LD_EXP 57
36468: PUSH
36469: LD_VAR 0 1
36473: ARRAY
36474: PUSH
36475: LD_INT 1
36477: ARRAY
36478: PPUSH
36479: CALL_OW 257
36483: PUSH
36484: LD_INT 2
36486: EQUAL
36487: IFFALSE 36516
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36489: LD_VAR 0 1
36493: PPUSH
36494: LD_STRING ToDep
36496: PPUSH
36497: LD_EXP 57
36501: PUSH
36502: LD_VAR 0 1
36506: ARRAY
36507: PUSH
36508: LD_INT 1
36510: ARRAY
36511: PPUSH
36512: CALL 14546 0 3
// end else
36516: GO 36544
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36518: LD_ADDR_EXP 57
36522: PUSH
36523: LD_EXP 57
36527: PPUSH
36528: LD_VAR 0 1
36532: PPUSH
36533: LD_INT 1
36535: PPUSH
36536: LD_INT 0
36538: PPUSH
36539: CALL 31146 0 4
36543: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36544: LD_EXP 55
36548: PUSH
36549: LD_VAR 0 1
36553: ARRAY
36554: PUSH
36555: LD_STRING 
36557: EQUAL
36558: NOT
36559: IFFALSE 36615
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36561: LD_EXP 55
36565: PUSH
36566: LD_VAR 0 1
36570: ARRAY
36571: PUSH
36572: LD_INT 1
36574: ARRAY
36575: PPUSH
36576: CALL_OW 257
36580: PUSH
36581: LD_INT 3
36583: EQUAL
36584: IFFALSE 36613
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36586: LD_VAR 0 1
36590: PPUSH
36591: LD_STRING ToFac
36593: PPUSH
36594: LD_EXP 55
36598: PUSH
36599: LD_VAR 0 1
36603: ARRAY
36604: PUSH
36605: LD_INT 1
36607: ARRAY
36608: PPUSH
36609: CALL 14546 0 3
// end else
36613: GO 36641
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36615: LD_ADDR_EXP 55
36619: PUSH
36620: LD_EXP 55
36624: PPUSH
36625: LD_VAR 0 1
36629: PPUSH
36630: LD_INT 1
36632: PPUSH
36633: LD_INT 0
36635: PPUSH
36636: CALL 31146 0 4
36640: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36641: LD_EXP 54
36645: PUSH
36646: LD_VAR 0 1
36650: ARRAY
36651: PUSH
36652: LD_STRING 
36654: EQUAL
36655: NOT
36656: IFFALSE 36712
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36658: LD_EXP 54
36662: PUSH
36663: LD_VAR 0 1
36667: ARRAY
36668: PUSH
36669: LD_INT 1
36671: ARRAY
36672: PPUSH
36673: CALL_OW 257
36677: PUSH
36678: LD_INT 4
36680: EQUAL
36681: IFFALSE 36710
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36683: LD_VAR 0 1
36687: PPUSH
36688: LD_STRING ToLab
36690: PPUSH
36691: LD_EXP 54
36695: PUSH
36696: LD_VAR 0 1
36700: ARRAY
36701: PUSH
36702: LD_INT 1
36704: ARRAY
36705: PPUSH
36706: CALL 14546 0 3
// end else
36710: GO 36738
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36712: LD_ADDR_EXP 54
36716: PUSH
36717: LD_EXP 54
36721: PPUSH
36722: LD_VAR 0 1
36726: PPUSH
36727: LD_INT 1
36729: PPUSH
36730: LD_INT 0
36732: PPUSH
36733: CALL 31146 0 4
36737: ST_TO_ADDR
// if mode = 0 then
36738: LD_VAR 0 2
36742: PUSH
36743: LD_INT 0
36745: EQUAL
36746: IFFALSE 38584
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36748: LD_VAR 0 1
36752: PPUSH
36753: LD_INT 30
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PPUSH
36763: CALL 11667 0 2
36767: PUSH
36768: LD_VAR 0 1
36772: PPUSH
36773: LD_INT 21
36775: PUSH
36776: LD_INT 3
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PPUSH
36783: CALL 11667 0 2
36787: PUSH
36788: LD_INT 1
36790: EQUAL
36791: AND
36792: IFFALSE 36857
// begin if all then
36794: LD_VAR 0 17
36798: IFFALSE 36855
// for i in ( all diff eng ) do
36800: LD_ADDR_VAR 0 4
36804: PUSH
36805: LD_VAR 0 17
36809: PUSH
36810: LD_VAR 0 14
36814: DIFF
36815: PUSH
36816: FOR_IN
36817: IFFALSE 36853
// if GetTag ( i ) = 0 then
36819: LD_VAR 0 4
36823: PPUSH
36824: CALL_OW 110
36828: PUSH
36829: LD_INT 0
36831: EQUAL
36832: IFFALSE 36851
// MCH_ChangeClass ( side , i , 2 ) ;
36834: LD_VAR 0 1
36838: PPUSH
36839: LD_VAR 0 4
36843: PPUSH
36844: LD_INT 2
36846: PPUSH
36847: CALL 16574 0 3
36851: GO 36816
36853: POP
36854: POP
// end else
36855: GO 37176
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36857: LD_VAR 0 13
36861: PUSH
36862: LD_EXP 56
36866: PUSH
36867: LD_VAR 0 1
36871: ARRAY
36872: PLUS
36873: PUSH
36874: LD_INT 22
36876: PUSH
36877: LD_VAR 0 1
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 30
36888: PUSH
36889: LD_INT 32
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PPUSH
36900: CALL_OW 69
36904: LESS
36905: IFFALSE 36930
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36907: LD_VAR 0 1
36911: PPUSH
36912: LD_VAR 0 14
36916: PUSH
36917: LD_INT 1
36919: ARRAY
36920: PPUSH
36921: LD_INT 1
36923: PPUSH
36924: CALL 16574 0 3
// end else
36928: GO 37176
// if sci < 6 and MCF_Lab ( side ) then
36930: LD_VAR 0 16
36934: PUSH
36935: LD_INT 6
36937: LESS
36938: PUSH
36939: LD_VAR 0 1
36943: PPUSH
36944: CALL 11706 0 1
36948: AND
36949: IFFALSE 37054
// begin if MREG_ToBunker [ side ] then
36951: LD_EXP 68
36955: PUSH
36956: LD_VAR 0 1
36960: ARRAY
36961: IFFALSE 36987
// tmp := sol diff MREG_ToBunker [ side ] else
36963: LD_ADDR_VAR 0 12
36967: PUSH
36968: LD_VAR 0 13
36972: PUSH
36973: LD_EXP 68
36977: PUSH
36978: LD_VAR 0 1
36982: ARRAY
36983: DIFF
36984: ST_TO_ADDR
36985: GO 36997
// tmp := sol ;
36987: LD_ADDR_VAR 0 12
36991: PUSH
36992: LD_VAR 0 13
36996: ST_TO_ADDR
// if tmp then
36997: LD_VAR 0 12
37001: IFFALSE 37052
// for i in tmp do
37003: LD_ADDR_VAR 0 4
37007: PUSH
37008: LD_VAR 0 12
37012: PUSH
37013: FOR_IN
37014: IFFALSE 37050
// if GetTag ( i ) = 0 then
37016: LD_VAR 0 4
37020: PPUSH
37021: CALL_OW 110
37025: PUSH
37026: LD_INT 0
37028: EQUAL
37029: IFFALSE 37048
// MCH_ChangeClass ( side , i , 4 ) ;
37031: LD_VAR 0 1
37035: PPUSH
37036: LD_VAR 0 4
37040: PPUSH
37041: LD_INT 4
37043: PPUSH
37044: CALL 16574 0 3
37048: GO 37013
37050: POP
37051: POP
// end else
37052: GO 37176
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37054: LD_VAR 0 1
37058: PPUSH
37059: LD_INT 30
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PPUSH
37069: CALL 11667 0 2
37073: IFFALSE 37176
// begin if MREG_ToBunker [ side ] then
37075: LD_EXP 68
37079: PUSH
37080: LD_VAR 0 1
37084: ARRAY
37085: IFFALSE 37111
// tmp := sol diff MREG_ToBunker [ side ] else
37087: LD_ADDR_VAR 0 12
37091: PUSH
37092: LD_VAR 0 13
37096: PUSH
37097: LD_EXP 68
37101: PUSH
37102: LD_VAR 0 1
37106: ARRAY
37107: DIFF
37108: ST_TO_ADDR
37109: GO 37121
// tmp := sol ;
37111: LD_ADDR_VAR 0 12
37115: PUSH
37116: LD_VAR 0 13
37120: ST_TO_ADDR
// if tmp then
37121: LD_VAR 0 12
37125: IFFALSE 37176
// for i in tmp do
37127: LD_ADDR_VAR 0 4
37131: PUSH
37132: LD_VAR 0 12
37136: PUSH
37137: FOR_IN
37138: IFFALSE 37174
// if GetTag ( i ) = 0 then
37140: LD_VAR 0 4
37144: PPUSH
37145: CALL_OW 110
37149: PUSH
37150: LD_INT 0
37152: EQUAL
37153: IFFALSE 37172
// MCH_ChangeClass ( side , i , 2 ) ;
37155: LD_VAR 0 1
37159: PPUSH
37160: LD_VAR 0 4
37164: PPUSH
37165: LD_INT 2
37167: PPUSH
37168: CALL 16574 0 3
37172: GO 37137
37174: POP
37175: POP
// end ; if MCF_Lab ( side ) then
37176: LD_VAR 0 1
37180: PPUSH
37181: CALL 11706 0 1
37185: IFFALSE 37725
// begin if MCL_GetTechList ( side ) then
37187: LD_VAR 0 1
37191: PPUSH
37192: CALL 18050 0 1
37196: IFFALSE 37322
// begin if MREG_ToLab [ side ] then
37198: LD_EXP 54
37202: PUSH
37203: LD_VAR 0 1
37207: ARRAY
37208: IFFALSE 37228
// k := MREG_ToLab [ side ] else
37210: LD_ADDR_VAR 0 8
37214: PUSH
37215: LD_EXP 54
37219: PUSH
37220: LD_VAR 0 1
37224: ARRAY
37225: ST_TO_ADDR
37226: GO 37236
// k := 0 ;
37228: LD_ADDR_VAR 0 8
37232: PUSH
37233: LD_INT 0
37235: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37236: LD_VAR 0 16
37240: PUSH
37241: LD_VAR 0 8
37245: PLUS
37246: PUSH
37247: LD_INT 6
37249: LESSEQUAL
37250: PUSH
37251: LD_VAR 0 17
37255: PUSH
37256: LD_INT 6
37258: GREATER
37259: AND
37260: IFFALSE 37276
// MCH_TrainScientist ( side , 1 ) else
37262: LD_VAR 0 1
37266: PPUSH
37267: LD_INT 1
37269: PPUSH
37270: CALL 16126 0 2
37274: GO 37320
// if all < 6 then
37276: LD_VAR 0 17
37280: PUSH
37281: LD_INT 6
37283: LESS
37284: IFFALSE 37320
// if sci + k < all / 2 then
37286: LD_VAR 0 16
37290: PUSH
37291: LD_VAR 0 8
37295: PLUS
37296: PUSH
37297: LD_VAR 0 17
37301: PUSH
37302: LD_INT 2
37304: DIVREAL
37305: LESS
37306: IFFALSE 37320
// MCH_TrainScientist ( side , 1 ) ;
37308: LD_VAR 0 1
37312: PPUSH
37313: LD_INT 1
37315: PPUSH
37316: CALL 16126 0 2
// end else
37320: GO 37398
// begin if sci > 2 then
37322: LD_VAR 0 16
37326: PUSH
37327: LD_INT 2
37329: GREATER
37330: IFFALSE 37398
// for i = sci downto 2 do
37332: LD_ADDR_VAR 0 4
37336: PUSH
37337: DOUBLE
37338: LD_VAR 0 16
37342: INC
37343: ST_TO_ADDR
37344: LD_INT 2
37346: PUSH
37347: FOR_DOWNTO
37348: IFFALSE 37396
// if GetTag ( sci [ i ] ) = 0 then
37350: LD_VAR 0 16
37354: PUSH
37355: LD_VAR 0 4
37359: ARRAY
37360: PPUSH
37361: CALL_OW 110
37365: PUSH
37366: LD_INT 0
37368: EQUAL
37369: IFFALSE 37394
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37371: LD_VAR 0 1
37375: PPUSH
37376: LD_VAR 0 16
37380: PUSH
37381: LD_VAR 0 4
37385: ARRAY
37386: PPUSH
37387: LD_INT 2
37389: PPUSH
37390: CALL 16574 0 3
37394: GO 37347
37396: POP
37397: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37398: LD_VAR 0 1
37402: PPUSH
37403: CALL 18050 0 1
37407: PUSH
37408: LD_VAR 0 1
37412: PPUSH
37413: CALL 11706 0 1
37417: AND
37418: PUSH
37419: LD_EXP 35
37423: PUSH
37424: LD_VAR 0 1
37428: ARRAY
37429: NOT
37430: AND
37431: IFFALSE 37725
// begin for j = 1 to MCF_Lab ( side ) do
37433: LD_ADDR_VAR 0 5
37437: PUSH
37438: DOUBLE
37439: LD_INT 1
37441: DEC
37442: ST_TO_ADDR
37443: LD_VAR 0 1
37447: PPUSH
37448: CALL 11706 0 1
37452: PUSH
37453: FOR_TO
37454: IFFALSE 37514
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37456: LD_VAR 0 1
37460: PPUSH
37461: CALL 11706 0 1
37465: PUSH
37466: LD_VAR 0 5
37470: ARRAY
37471: PPUSH
37472: CALL_OW 461
37476: PUSH
37477: LD_INT 3
37479: PUSH
37480: LD_INT 6
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: IN
37487: IFFALSE 37512
// begin b := MCF_Lab ( side ) [ j ] ;
37489: LD_ADDR_VAR 0 11
37493: PUSH
37494: LD_VAR 0 1
37498: PPUSH
37499: CALL 11706 0 1
37503: PUSH
37504: LD_VAR 0 5
37508: ARRAY
37509: ST_TO_ADDR
// break ;
37510: GO 37514
// end ;
37512: GO 37453
37514: POP
37515: POP
// if MCF_Class ( side , 4 , [ ] ) then
37516: LD_VAR 0 1
37520: PPUSH
37521: LD_INT 4
37523: PPUSH
37524: EMPTY
37525: PPUSH
37526: CALL 11750 0 3
37530: IFFALSE 37725
// for j in MCF_Class ( side , 4 , [ ] ) do
37532: LD_ADDR_VAR 0 5
37536: PUSH
37537: LD_VAR 0 1
37541: PPUSH
37542: LD_INT 4
37544: PPUSH
37545: EMPTY
37546: PPUSH
37547: CALL 11750 0 3
37551: PUSH
37552: FOR_IN
37553: IFFALSE 37723
// begin if GetTag ( j ) = 0 then
37555: LD_VAR 0 5
37559: PPUSH
37560: CALL_OW 110
37564: PUSH
37565: LD_INT 0
37567: EQUAL
37568: IFFALSE 37659
// begin if IsInUnit ( j ) and b then
37570: LD_VAR 0 5
37574: PPUSH
37575: CALL_OW 310
37579: PUSH
37580: LD_VAR 0 11
37584: AND
37585: IFFALSE 37633
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 310
37596: PPUSH
37597: CALL_OW 461
37601: PUSH
37602: LD_INT 2
37604: EQUAL
37605: PUSH
37606: LD_VAR 0 5
37610: PPUSH
37611: CALL_OW 310
37615: PUSH
37616: LD_VAR 0 11
37620: NONEQUAL
37621: AND
37622: IFFALSE 37633
// ComExitBuilding ( j ) ;
37624: LD_VAR 0 5
37628: PPUSH
37629: CALL_OW 122
// if not IsInUnit ( j ) then
37633: LD_VAR 0 5
37637: PPUSH
37638: CALL_OW 310
37642: NOT
37643: IFFALSE 37659
// ComEnterUnit ( j , b ) ;
37645: LD_VAR 0 5
37649: PPUSH
37650: LD_VAR 0 11
37654: PPUSH
37655: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37659: LD_INT 1
37661: PPUSH
37662: LD_VAR 0 5
37666: PPUSH
37667: CALL_OW 255
37671: PPUSH
37672: CALL_OW 321
37676: PUSH
37677: LD_INT 2
37679: EQUAL
37680: PUSH
37681: LD_VAR 0 5
37685: PPUSH
37686: CALL_OW 255
37690: PPUSH
37691: CALL 25022 0 1
37695: PUSH
37696: LD_INT 0
37698: EQUAL
37699: AND
37700: IFFALSE 37721
// MCN_Tame ( GetSide ( j ) , j ) ;
37702: LD_VAR 0 5
37706: PPUSH
37707: CALL_OW 255
37711: PPUSH
37712: LD_VAR 0 5
37716: PPUSH
37717: CALL 18569 0 2
// end ;
37721: GO 37552
37723: POP
37724: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37725: LD_VAR 0 1
37729: PPUSH
37730: LD_INT 30
37732: PUSH
37733: LD_INT 3
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PPUSH
37740: CALL 11667 0 2
37744: IFFALSE 38003
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37746: LD_ADDR_VAR 0 11
37750: PUSH
37751: LD_VAR 0 1
37755: PPUSH
37756: LD_INT 30
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PPUSH
37766: CALL 11667 0 2
37770: PUSH
37771: LD_INT 1
37773: ARRAY
37774: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37775: LD_ADDR_VAR 0 12
37779: PUSH
37780: LD_VAR 0 1
37784: PPUSH
37785: LD_INT 0
37787: PPUSH
37788: LD_INT 25
37790: PUSH
37791: LD_INT 3
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PPUSH
37798: CALL 12370 0 3
37802: ST_TO_ADDR
// for i = 1 to tmp do
37803: LD_ADDR_VAR 0 4
37807: PUSH
37808: DOUBLE
37809: LD_INT 1
37811: DEC
37812: ST_TO_ADDR
37813: LD_VAR 0 12
37817: PUSH
37818: FOR_TO
37819: IFFALSE 37879
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37821: LD_VAR 0 12
37825: PUSH
37826: LD_VAR 0 4
37830: ARRAY
37831: PPUSH
37832: CALL_OW 310
37836: NOT
37837: PUSH
37838: LD_VAR 0 12
37842: PUSH
37843: LD_VAR 0 4
37847: ARRAY
37848: PPUSH
37849: CALL_OW 314
37853: NOT
37854: AND
37855: IFFALSE 37877
// ComEnterUnit ( tmp [ i ] , b ) ;
37857: LD_VAR 0 12
37861: PUSH
37862: LD_VAR 0 4
37866: ARRAY
37867: PPUSH
37868: LD_VAR 0 11
37872: PPUSH
37873: CALL_OW 120
37877: GO 37818
37879: POP
37880: POP
// if MREG_ToFac [ side ] then
37881: LD_EXP 55
37885: PUSH
37886: LD_VAR 0 1
37890: ARRAY
37891: IFFALSE 37911
// k := MREG_ToFac [ side ] else
37893: LD_ADDR_VAR 0 8
37897: PUSH
37898: LD_EXP 55
37902: PUSH
37903: LD_VAR 0 1
37907: ARRAY
37908: ST_TO_ADDR
37909: GO 37919
// k := 0 ;
37911: LD_ADDR_VAR 0 8
37915: PUSH
37916: LD_INT 0
37918: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37919: LD_VAR 0 15
37923: PUSH
37924: LD_VAR 0 8
37928: PLUS
37929: PUSH
37930: LD_INT 6
37932: LESSEQUAL
37933: PUSH
37934: LD_VAR 0 17
37938: PUSH
37939: LD_INT 6
37941: GREATER
37942: AND
37943: IFFALSE 37959
// MCH_TrainMechanic ( side , 1 ) else
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 1
37952: PPUSH
37953: CALL 15868 0 2
37957: GO 38003
// if all < 6 then
37959: LD_VAR 0 17
37963: PUSH
37964: LD_INT 6
37966: LESS
37967: IFFALSE 38003
// if mech + k < all / 2 then
37969: LD_VAR 0 15
37973: PUSH
37974: LD_VAR 0 8
37978: PLUS
37979: PUSH
37980: LD_VAR 0 17
37984: PUSH
37985: LD_INT 2
37987: DIVREAL
37988: LESS
37989: IFFALSE 38003
// MCH_TrainMechanic ( side , 1 ) ;
37991: LD_VAR 0 1
37995: PPUSH
37996: LD_INT 1
37998: PPUSH
37999: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38003: LD_ADDR_VAR 0 10
38007: PUSH
38008: LD_VAR 0 1
38012: PPUSH
38013: LD_INT 30
38015: PUSH
38016: LD_INT 36
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PPUSH
38023: CALL 11667 0 2
38027: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38028: LD_VAR 0 10
38032: PUSH
38033: LD_VAR 0 15
38037: AND
38038: PUSH
38039: LD_VAR 0 1
38043: PPUSH
38044: LD_INT 3
38046: PPUSH
38047: EMPTY
38048: PPUSH
38049: CALL 11750 0 3
38053: AND
38054: IFFALSE 38212
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38056: LD_VAR 0 1
38060: PPUSH
38061: LD_INT 9
38063: PPUSH
38064: EMPTY
38065: PPUSH
38066: CALL 12370 0 3
38070: PUSH
38071: LD_INT 3
38073: LESS
38074: IFFALSE 38212
// begin if mech < 3 then
38076: LD_VAR 0 15
38080: PUSH
38081: LD_INT 3
38083: LESS
38084: IFFALSE 38098
// k := mech else
38086: LD_ADDR_VAR 0 8
38090: PUSH
38091: LD_VAR 0 15
38095: ST_TO_ADDR
38096: GO 38106
// k := 3 ;
38098: LD_ADDR_VAR 0 8
38102: PUSH
38103: LD_INT 3
38105: ST_TO_ADDR
// for j = 1 to k do
38106: LD_ADDR_VAR 0 5
38110: PUSH
38111: DOUBLE
38112: LD_INT 1
38114: DEC
38115: ST_TO_ADDR
38116: LD_VAR 0 8
38120: PUSH
38121: FOR_TO
38122: IFFALSE 38180
// if GetClass ( mech [ j ] ) = 3 then
38124: LD_VAR 0 15
38128: PUSH
38129: LD_VAR 0 5
38133: ARRAY
38134: PPUSH
38135: CALL_OW 257
38139: PUSH
38140: LD_INT 3
38142: EQUAL
38143: IFFALSE 38178
// begin SetTag ( mech [ j ] , 9 ) ;
38145: LD_VAR 0 15
38149: PUSH
38150: LD_VAR 0 5
38154: ARRAY
38155: PPUSH
38156: LD_INT 9
38158: PPUSH
38159: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38163: LD_VAR 0 15
38167: PUSH
38168: LD_VAR 0 5
38172: ARRAY
38173: PPUSH
38174: CALL_OW 122
// end ;
38178: GO 38121
38180: POP
38181: POP
// if mech < 6 + k then
38182: LD_VAR 0 15
38186: PUSH
38187: LD_INT 6
38189: PUSH
38190: LD_VAR 0 8
38194: PLUS
38195: LESS
38196: IFFALSE 38212
// MCH_TrainMechanic ( side , k ) ;
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_VAR 0 8
38207: PPUSH
38208: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38212: LD_VAR 0 1
38216: PPUSH
38217: LD_INT 9
38219: PPUSH
38220: EMPTY
38221: PPUSH
38222: CALL 12370 0 3
38226: IFFALSE 38317
// for j in MCF_Tag ( side , 9 , [ ] ) do
38228: LD_ADDR_VAR 0 5
38232: PUSH
38233: LD_VAR 0 1
38237: PPUSH
38238: LD_INT 9
38240: PPUSH
38241: EMPTY
38242: PPUSH
38243: CALL 12370 0 3
38247: PUSH
38248: FOR_IN
38249: IFFALSE 38315
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38251: LD_VAR 0 5
38255: PPUSH
38256: CALL_OW 310
38260: NOT
38261: PUSH
38262: LD_VAR 0 5
38266: PPUSH
38267: CALL 96712 0 1
38271: NOT
38272: AND
38273: IFFALSE 38313
// if ct then
38275: LD_VAR 0 10
38279: IFFALSE 38301
// ComEnterUnit ( j , ct [ 1 ] ) else
38281: LD_VAR 0 5
38285: PPUSH
38286: LD_VAR 0 10
38290: PUSH
38291: LD_INT 1
38293: ARRAY
38294: PPUSH
38295: CALL_OW 120
38299: GO 38313
// SetTag ( j , 0 ) ;
38301: LD_VAR 0 5
38305: PPUSH
38306: LD_INT 0
38308: PPUSH
38309: CALL_OW 109
38313: GO 38248
38315: POP
38316: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38317: LD_INT 1
38319: PPUSH
38320: LD_VAR 0 1
38324: PPUSH
38325: CALL_OW 321
38329: PUSH
38330: LD_INT 2
38332: EQUAL
38333: PUSH
38334: LD_EXP 35
38338: PUSH
38339: LD_VAR 0 1
38343: ARRAY
38344: NOT
38345: AND
38346: PUSH
38347: LD_VAR 0 1
38351: PPUSH
38352: LD_INT 4
38354: PPUSH
38355: EMPTY
38356: PPUSH
38357: CALL 11750 0 3
38361: AND
38362: IFFALSE 38410
// for j in MCF_Class ( side , 4 , [ ] ) do
38364: LD_ADDR_VAR 0 5
38368: PUSH
38369: LD_VAR 0 1
38373: PPUSH
38374: LD_INT 4
38376: PPUSH
38377: EMPTY
38378: PPUSH
38379: CALL 11750 0 3
38383: PUSH
38384: FOR_IN
38385: IFFALSE 38408
// MCN_Tame ( GetSide ( j ) , j ) ;
38387: LD_VAR 0 5
38391: PPUSH
38392: CALL_OW 255
38396: PPUSH
38397: LD_VAR 0 5
38401: PPUSH
38402: CALL 18569 0 2
38406: GO 38384
38408: POP
38409: POP
// if MREG_DefVeh [ side ] then
38410: LD_EXP 67
38414: PUSH
38415: LD_VAR 0 1
38419: ARRAY
38420: IFFALSE 38584
// begin for i in MREG_DefVeh [ side ] do
38422: LD_ADDR_VAR 0 4
38426: PUSH
38427: LD_EXP 67
38431: PUSH
38432: LD_VAR 0 1
38436: ARRAY
38437: PUSH
38438: FOR_IN
38439: IFFALSE 38492
// begin SetTag ( i , 0 ) ;
38441: LD_VAR 0 4
38445: PPUSH
38446: LD_INT 0
38448: PPUSH
38449: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38453: LD_VAR 0 4
38457: PPUSH
38458: LD_EXP 64
38462: PUSH
38463: LD_VAR 0 1
38467: ARRAY
38468: PPUSH
38469: CALL_OW 308
38473: NOT
38474: IFFALSE 38490
// MCV_Parking ( side , i ) ;
38476: LD_VAR 0 1
38480: PPUSH
38481: LD_VAR 0 4
38485: PPUSH
38486: CALL 25757 0 2
// end ;
38490: GO 38438
38492: POP
38493: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38494: LD_VAR 0 1
38498: PPUSH
38499: LD_INT 36
38501: PPUSH
38502: EMPTY
38503: PPUSH
38504: CALL 12370 0 3
38508: IFFALSE 38549
// for i in MCF_Tag ( side , 36 , [ ] ) do
38510: LD_ADDR_VAR 0 4
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: LD_INT 36
38522: PPUSH
38523: EMPTY
38524: PPUSH
38525: CALL 12370 0 3
38529: PUSH
38530: FOR_IN
38531: IFFALSE 38547
// SetTag ( i , 0 ) ;
38533: LD_VAR 0 4
38537: PPUSH
38538: LD_INT 0
38540: PPUSH
38541: CALL_OW 109
38545: GO 38530
38547: POP
38548: POP
// if MREG_DefMobActive [ side ] then
38549: LD_EXP 70
38553: PUSH
38554: LD_VAR 0 1
38558: ARRAY
38559: IFFALSE 38584
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38561: LD_ADDR_EXP 70
38565: PUSH
38566: LD_EXP 70
38570: PPUSH
38571: LD_VAR 0 1
38575: PPUSH
38576: LD_INT 0
38578: PPUSH
38579: CALL_OW 1
38583: ST_TO_ADDR
// end ; end ; if mode > 0 then
38584: LD_VAR 0 2
38588: PUSH
38589: LD_INT 0
38591: GREATER
38592: IFFALSE 40487
// begin if tick <= 15 15$00 then
38594: LD_OWVAR 1
38598: PUSH
38599: LD_INT 31500
38601: LESSEQUAL
38602: IFFALSE 38906
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38604: LD_VAR 0 13
38608: PUSH
38609: LD_VAR 0 1
38613: PPUSH
38614: CALL 25022 0 1
38618: PUSH
38619: LD_INT 4
38621: LESS
38622: AND
38623: IFFALSE 38734
// begin for i in sol do
38625: LD_ADDR_VAR 0 4
38629: PUSH
38630: LD_VAR 0 13
38634: PUSH
38635: FOR_IN
38636: IFFALSE 38732
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38638: LD_ADDR_VAR 0 8
38642: PUSH
38643: LD_VAR 0 1
38647: PPUSH
38648: CALL 25022 0 1
38652: PPUSH
38653: LD_VAR 0 4
38657: PPUSH
38658: CALL_OW 74
38662: ST_TO_ADDR
// if IsInUnit ( i ) then
38663: LD_VAR 0 4
38667: PPUSH
38668: CALL_OW 310
38672: IFFALSE 38683
// ComExitBuilding ( i ) ;
38674: LD_VAR 0 4
38678: PPUSH
38679: CALL_OW 122
// if not HasTask ( i ) and k then
38683: LD_VAR 0 4
38687: PPUSH
38688: CALL_OW 314
38692: NOT
38693: PUSH
38694: LD_VAR 0 8
38698: AND
38699: IFFALSE 38730
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38701: LD_VAR 0 4
38705: PPUSH
38706: LD_VAR 0 8
38710: PPUSH
38711: CALL_OW 250
38715: PPUSH
38716: LD_VAR 0 8
38720: PPUSH
38721: CALL_OW 251
38725: PPUSH
38726: CALL_OW 174
// end ;
38730: GO 38635
38732: POP
38733: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38734: LD_VAR 0 1
38738: PPUSH
38739: LD_INT 30
38741: PUSH
38742: LD_INT 5
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PPUSH
38749: CALL 11667 0 2
38753: IFFALSE 38904
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38755: LD_ADDR_VAR 0 11
38759: PUSH
38760: LD_VAR 0 1
38764: PPUSH
38765: LD_INT 30
38767: PUSH
38768: LD_INT 5
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PPUSH
38775: CALL 11667 0 2
38779: PUSH
38780: LD_INT 1
38782: ARRAY
38783: ST_TO_ADDR
// if mech then
38784: LD_VAR 0 15
38788: IFFALSE 38824
// for i in mech do
38790: LD_ADDR_VAR 0 4
38794: PUSH
38795: LD_VAR 0 15
38799: PUSH
38800: FOR_IN
38801: IFFALSE 38822
// MCH_ChangeClass ( side , i , 1 ) ;
38803: LD_VAR 0 1
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_INT 1
38815: PPUSH
38816: CALL 16574 0 3
38820: GO 38800
38822: POP
38823: POP
// if eng > 1 then
38824: LD_VAR 0 14
38828: PUSH
38829: LD_INT 1
38831: GREATER
38832: IFFALSE 38879
// for i = eng downto 2 do
38834: LD_ADDR_VAR 0 4
38838: PUSH
38839: DOUBLE
38840: LD_VAR 0 14
38844: INC
38845: ST_TO_ADDR
38846: LD_INT 2
38848: PUSH
38849: FOR_DOWNTO
38850: IFFALSE 38877
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38852: LD_VAR 0 1
38856: PPUSH
38857: LD_VAR 0 14
38861: PUSH
38862: LD_VAR 0 4
38866: ARRAY
38867: PPUSH
38868: LD_INT 1
38870: PPUSH
38871: CALL 16574 0 3
38875: GO 38849
38877: POP
38878: POP
// if UnitsInside ( b ) then
38879: LD_VAR 0 11
38883: PPUSH
38884: CALL_OW 313
38888: IFFALSE 38904
// ComExitBuilding ( UnitsInside ( b ) ) ;
38890: LD_VAR 0 11
38894: PPUSH
38895: CALL_OW 313
38899: PPUSH
38900: CALL_OW 122
// end ; end else
38904: GO 40487
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38906: LD_VAR 0 1
38910: PPUSH
38911: LD_INT 1
38913: PPUSH
38914: LD_EXP 65
38918: PUSH
38919: LD_VAR 0 1
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: ARRAY
38928: PPUSH
38929: CALL 33759 0 3
38933: IFFALSE 39072
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38935: LD_ADDR_VAR 0 12
38939: PUSH
38940: LD_VAR 0 1
38944: PPUSH
38945: LD_INT 21
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PPUSH
38955: CALL 11667 0 2
38959: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38960: LD_ADDR_VAR 0 11
38964: PUSH
38965: LD_VAR 0 1
38969: PPUSH
38970: LD_INT 30
38972: PUSH
38973: LD_INT 1
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PPUSH
38980: CALL 11667 0 2
38984: ST_TO_ADDR
// if b then
38985: LD_VAR 0 11
38989: IFFALSE 39072
// for i in tmp do
38991: LD_ADDR_VAR 0 4
38995: PUSH
38996: LD_VAR 0 12
39000: PUSH
39001: FOR_IN
39002: IFFALSE 39070
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39004: LD_VAR 0 4
39008: PPUSH
39009: LD_EXP 65
39013: PUSH
39014: LD_VAR 0 1
39018: ARRAY
39019: PUSH
39020: LD_INT 1
39022: ARRAY
39023: PPUSH
39024: CALL_OW 308
39028: NOT
39029: IFFALSE 39068
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39031: LD_VAR 0 4
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 250
39049: PPUSH
39050: LD_VAR 0 11
39054: PUSH
39055: LD_INT 1
39057: ARRAY
39058: PPUSH
39059: CALL_OW 251
39063: PPUSH
39064: CALL_OW 111
39068: GO 39001
39070: POP
39071: POP
// end ; if MREG_DefVeh [ side ] then
39072: LD_EXP 67
39076: PUSH
39077: LD_VAR 0 1
39081: ARRAY
39082: IFFALSE 39650
// begin tmp := [ ] ;
39084: LD_ADDR_VAR 0 12
39088: PUSH
39089: EMPTY
39090: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39091: LD_EXP 70
39095: PUSH
39096: LD_VAR 0 1
39100: ARRAY
39101: PUSH
39102: LD_INT 0
39104: EQUAL
39105: IFFALSE 39245
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39107: LD_ADDR_VAR 0 8
39111: PUSH
39112: LD_VAR 0 1
39116: PPUSH
39117: LD_INT 0
39119: PPUSH
39120: LD_INT 25
39122: PUSH
39123: LD_INT 3
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PPUSH
39130: CALL 12370 0 3
39134: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39135: LD_VAR 0 8
39139: PUSH
39140: LD_EXP 67
39144: PUSH
39145: LD_VAR 0 1
39149: ARRAY
39150: GREATER
39151: IFFALSE 39212
// begin for i = 1 to MREG_DefVeh [ side ] do
39153: LD_ADDR_VAR 0 4
39157: PUSH
39158: DOUBLE
39159: LD_INT 1
39161: DEC
39162: ST_TO_ADDR
39163: LD_EXP 67
39167: PUSH
39168: LD_VAR 0 1
39172: ARRAY
39173: PUSH
39174: FOR_TO
39175: IFFALSE 39208
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39177: LD_ADDR_VAR 0 12
39181: PUSH
39182: LD_VAR 0 12
39186: PPUSH
39187: LD_INT 1
39189: PPUSH
39190: LD_VAR 0 8
39194: PUSH
39195: LD_VAR 0 4
39199: ARRAY
39200: PPUSH
39201: CALL_OW 2
39205: ST_TO_ADDR
39206: GO 39174
39208: POP
39209: POP
// end else
39210: GO 39222
// tmp := k ;
39212: LD_ADDR_VAR 0 12
39216: PUSH
39217: LD_VAR 0 8
39221: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39222: LD_ADDR_EXP 70
39226: PUSH
39227: LD_EXP 70
39231: PPUSH
39232: LD_VAR 0 1
39236: PPUSH
39237: LD_INT 1
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39245: LD_ADDR_VAR 0 4
39249: PUSH
39250: LD_EXP 67
39254: PUSH
39255: LD_VAR 0 1
39259: ARRAY
39260: PUSH
39261: FOR_IN
39262: IFFALSE 39648
// begin if not GetDriver ( i ) then
39264: LD_VAR 0 4
39268: PPUSH
39269: CALL 31789 0 1
39273: NOT
39274: IFFALSE 39349
// begin if tmp then
39276: LD_VAR 0 12
39280: IFFALSE 39347
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39282: LD_VAR 0 12
39286: PUSH
39287: LD_INT 1
39289: ARRAY
39290: PPUSH
39291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39295: LD_VAR 0 12
39299: PUSH
39300: LD_INT 1
39302: ARRAY
39303: PPUSH
39304: LD_VAR 0 4
39308: PPUSH
39309: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39313: LD_VAR 0 12
39317: PUSH
39318: LD_INT 1
39320: ARRAY
39321: PPUSH
39322: LD_INT 36
39324: PPUSH
39325: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39329: LD_ADDR_VAR 0 12
39333: PUSH
39334: LD_VAR 0 12
39338: PPUSH
39339: LD_INT 1
39341: PPUSH
39342: CALL_OW 3
39346: ST_TO_ADDR
// end ; end else
39347: GO 39646
// begin if GetTag ( i ) = 0 then
39349: LD_VAR 0 4
39353: PPUSH
39354: CALL_OW 110
39358: PUSH
39359: LD_INT 0
39361: EQUAL
39362: IFFALSE 39378
// SetTag ( i , 31 ) else
39364: LD_VAR 0 4
39368: PPUSH
39369: LD_INT 31
39371: PPUSH
39372: CALL_OW 109
39376: GO 39646
// if GetTag ( i ) = 31 then
39378: LD_VAR 0 4
39382: PPUSH
39383: CALL_OW 110
39387: PUSH
39388: LD_INT 31
39390: EQUAL
39391: IFFALSE 39646
// begin if GetFuel ( i ) < 20 then
39393: LD_VAR 0 4
39397: PPUSH
39398: CALL_OW 261
39402: PUSH
39403: LD_INT 20
39405: LESS
39406: IFFALSE 39431
// begin SetTag ( i , 21 ) ;
39408: LD_VAR 0 4
39412: PPUSH
39413: LD_INT 21
39415: PPUSH
39416: CALL_OW 109
// MCV_Refuel ( i ) ;
39420: LD_VAR 0 4
39424: PPUSH
39425: CALL 26294 0 1
// continue ;
39429: GO 39261
// end ; if GetLives ( i ) < 700 then
39431: LD_VAR 0 4
39435: PPUSH
39436: CALL_OW 256
39440: PUSH
39441: LD_INT 700
39443: LESS
39444: IFFALSE 39556
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39446: LD_VAR 0 4
39450: PPUSH
39451: LD_EXP 58
39455: PUSH
39456: LD_VAR 0 1
39460: ARRAY
39461: PPUSH
39462: CALL_OW 308
39466: NOT
39467: IFFALSE 39491
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39469: LD_VAR 0 4
39473: PPUSH
39474: LD_EXP 58
39478: PUSH
39479: LD_VAR 0 1
39483: ARRAY
39484: PPUSH
39485: CALL_OW 113
39489: GO 39554
// if GetDriver ( i ) then
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31789 0 1
39500: IFFALSE 39554
// begin k := GetDriver ( i ) ;
39502: LD_ADDR_VAR 0 8
39506: PUSH
39507: LD_VAR 0 4
39511: PPUSH
39512: CALL 31789 0 1
39516: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39517: LD_VAR 0 8
39521: PPUSH
39522: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39540: LD_VAR 0 8
39544: PPUSH
39545: LD_VAR 0 4
39549: PPUSH
39550: CALL_OW 180
// end ; end else
39554: GO 39646
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39556: LD_ADDR_VAR 0 8
39560: PUSH
39561: LD_VAR 0 1
39565: PPUSH
39566: CALL 25022 0 1
39570: PPUSH
39571: LD_VAR 0 4
39575: PPUSH
39576: CALL_OW 74
39580: ST_TO_ADDR
// if k then
39581: LD_VAR 0 8
39585: IFFALSE 39603
// ComAttackUnit ( i , k ) else
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_VAR 0 8
39596: PPUSH
39597: CALL_OW 115
39601: GO 39646
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39603: LD_VAR 0 4
39607: PPUSH
39608: LD_EXP 58
39612: PUSH
39613: LD_VAR 0 1
39617: ARRAY
39618: PPUSH
39619: CALL_OW 308
39623: NOT
39624: IFFALSE 39646
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39626: LD_VAR 0 4
39630: PPUSH
39631: LD_EXP 58
39635: PUSH
39636: LD_VAR 0 1
39640: ARRAY
39641: PPUSH
39642: CALL_OW 113
// end ; end ; end ; end ;
39646: GO 39261
39648: POP
39649: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39650: LD_VAR 0 1
39654: PPUSH
39655: LD_INT 30
39657: PUSH
39658: LD_INT 5
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PPUSH
39665: CALL 11667 0 2
39669: IFFALSE 40487
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39671: LD_ADDR_VAR 0 11
39675: PUSH
39676: LD_VAR 0 1
39680: PPUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 5
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PPUSH
39691: CALL 11667 0 2
39695: PUSH
39696: LD_INT 1
39698: ARRAY
39699: ST_TO_ADDR
// if eng > 1 then
39700: LD_VAR 0 14
39704: PUSH
39705: LD_INT 1
39707: GREATER
39708: IFFALSE 39755
// for i = eng downto 2 do
39710: LD_ADDR_VAR 0 4
39714: PUSH
39715: DOUBLE
39716: LD_VAR 0 14
39720: INC
39721: ST_TO_ADDR
39722: LD_INT 2
39724: PUSH
39725: FOR_DOWNTO
39726: IFFALSE 39753
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39728: LD_VAR 0 1
39732: PPUSH
39733: LD_VAR 0 14
39737: PUSH
39738: LD_VAR 0 4
39742: ARRAY
39743: PPUSH
39744: LD_INT 1
39746: PPUSH
39747: CALL 16574 0 3
39751: GO 39725
39753: POP
39754: POP
// if sci > 1 then
39755: LD_VAR 0 16
39759: PUSH
39760: LD_INT 1
39762: GREATER
39763: IFFALSE 39810
// for i = sci downto 2 do
39765: LD_ADDR_VAR 0 4
39769: PUSH
39770: DOUBLE
39771: LD_VAR 0 16
39775: INC
39776: ST_TO_ADDR
39777: LD_INT 2
39779: PUSH
39780: FOR_DOWNTO
39781: IFFALSE 39808
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39783: LD_VAR 0 1
39787: PPUSH
39788: LD_VAR 0 16
39792: PUSH
39793: LD_VAR 0 4
39797: ARRAY
39798: PPUSH
39799: LD_INT 1
39801: PPUSH
39802: CALL 16574 0 3
39806: GO 39780
39808: POP
39809: POP
// if sol then
39810: LD_VAR 0 13
39814: IFFALSE 40487
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39816: LD_VAR 0 13
39820: PUSH
39821: LD_EXP 68
39825: PUSH
39826: LD_VAR 0 1
39830: ARRAY
39831: DIFF
39832: PUSH
39833: LD_INT 22
39835: PUSH
39836: LD_VAR 0 1
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 58
39847: PUSH
39848: EMPTY
39849: LIST
39850: PUSH
39851: LD_INT 2
39853: PUSH
39854: LD_INT 30
39856: PUSH
39857: LD_INT 32
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 30
39866: PUSH
39867: LD_INT 31
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: LIST
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: LIST
39883: PPUSH
39884: CALL_OW 69
39888: PUSH
39889: LD_INT 0
39891: EQUAL
39892: AND
39893: IFFALSE 40487
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39895: LD_ADDR_VAR 0 12
39899: PUSH
39900: LD_VAR 0 13
39904: PUSH
39905: LD_EXP 68
39909: PUSH
39910: LD_VAR 0 1
39914: ARRAY
39915: DIFF
39916: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39917: LD_VAR 0 1
39921: PPUSH
39922: LD_INT 30
39924: PUSH
39925: LD_INT 5
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PPUSH
39932: CALL 11667 0 2
39936: PUSH
39937: LD_INT 1
39939: GREATER
39940: IFFALSE 39971
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39942: LD_ADDR_VAR 0 8
39946: PUSH
39947: LD_VAR 0 1
39951: PPUSH
39952: LD_INT 30
39954: PUSH
39955: LD_INT 5
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PPUSH
39962: CALL 11667 0 2
39966: PUSH
39967: LD_INT 2
39969: ARRAY
39970: ST_TO_ADDR
// for j in tmp do
39971: LD_ADDR_VAR 0 5
39975: PUSH
39976: LD_VAR 0 12
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40485
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39984: LD_VAR 0 5
39988: PUSH
39989: LD_VAR 0 11
39993: PPUSH
39994: CALL_OW 313
39998: IN
39999: PUSH
40000: LD_VAR 0 11
40004: PPUSH
40005: CALL_OW 313
40009: PUSH
40010: LD_INT 6
40012: EQUAL
40013: AND
40014: PUSH
40015: LD_VAR 0 8
40019: AND
40020: PUSH
40021: LD_VAR 0 8
40025: PPUSH
40026: CALL_OW 313
40030: PUSH
40031: LD_INT 6
40033: LESS
40034: AND
40035: IFFALSE 40062
// begin ComExitBuilding ( j ) ;
40037: LD_VAR 0 5
40041: PPUSH
40042: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40046: LD_VAR 0 5
40050: PPUSH
40051: LD_VAR 0 8
40055: PPUSH
40056: CALL_OW 180
// continue ;
40060: GO 39981
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40062: LD_VAR 0 5
40066: PPUSH
40067: CALL_OW 314
40071: NOT
40072: PUSH
40073: LD_VAR 0 5
40077: PPUSH
40078: CALL_OW 110
40082: PUSH
40083: LD_INT 0
40085: EQUAL
40086: AND
40087: PUSH
40088: LD_VAR 0 5
40092: PPUSH
40093: CALL_OW 310
40097: NOT
40098: AND
40099: IFFALSE 40205
// begin if k then
40101: LD_VAR 0 8
40105: IFFALSE 40176
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40107: LD_VAR 0 8
40111: PPUSH
40112: CALL_OW 313
40116: PUSH
40117: LD_VAR 0 11
40121: PPUSH
40122: CALL_OW 313
40126: LESS
40127: IFFALSE 40145
// ComEnterUnit ( j , k ) else
40129: LD_VAR 0 5
40133: PPUSH
40134: LD_VAR 0 8
40138: PPUSH
40139: CALL_OW 120
40143: GO 40174
// if UnitsInside ( b ) < 6 then
40145: LD_VAR 0 11
40149: PPUSH
40150: CALL_OW 313
40154: PUSH
40155: LD_INT 6
40157: LESS
40158: IFFALSE 40174
// ComEnterUnit ( j , b ) ;
40160: LD_VAR 0 5
40164: PPUSH
40165: LD_VAR 0 11
40169: PPUSH
40170: CALL_OW 120
// end else
40174: GO 40205
// if UnitsInside ( b ) < 6 then
40176: LD_VAR 0 11
40180: PPUSH
40181: CALL_OW 313
40185: PUSH
40186: LD_INT 6
40188: LESS
40189: IFFALSE 40205
// ComEnterUnit ( j , b ) ;
40191: LD_VAR 0 5
40195: PPUSH
40196: LD_VAR 0 11
40200: PPUSH
40201: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40205: LD_VAR 0 5
40209: PUSH
40210: LD_VAR 0 1
40214: PPUSH
40215: LD_INT 54
40217: PUSH
40218: EMPTY
40219: LIST
40220: PPUSH
40221: CALL 11667 0 2
40225: IN
40226: PUSH
40227: LD_VAR 0 5
40231: PPUSH
40232: CALL_OW 257
40236: PUSH
40237: LD_INT 1
40239: EQUAL
40240: AND
40241: IFFALSE 40483
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40243: LD_EXP 62
40247: PUSH
40248: LD_VAR 0 1
40252: ARRAY
40253: PUSH
40254: LD_INT 1
40256: ARRAY
40257: PUSH
40258: LD_INT 12
40260: PPUSH
40261: LD_VAR 0 1
40265: PPUSH
40266: CALL_OW 321
40270: PUSH
40271: LD_INT 2
40273: EQUAL
40274: AND
40275: IFFALSE 40323
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40277: LD_VAR 0 1
40281: PPUSH
40282: LD_INT 5
40284: PPUSH
40285: EMPTY
40286: PPUSH
40287: CALL 11750 0 3
40291: PUSH
40292: LD_EXP 62
40296: PUSH
40297: LD_VAR 0 1
40301: ARRAY
40302: PUSH
40303: LD_INT 1
40305: ARRAY
40306: LESS
40307: IFFALSE 40323
// begin SetClass ( j , class_sniper ) ;
40309: LD_VAR 0 5
40313: PPUSH
40314: LD_INT 5
40316: PPUSH
40317: CALL_OW 336
// continue ;
40321: GO 39981
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40323: LD_EXP 62
40327: PUSH
40328: LD_VAR 0 1
40332: ARRAY
40333: PUSH
40334: LD_INT 2
40336: ARRAY
40337: PUSH
40338: LD_INT 41
40340: PPUSH
40341: LD_VAR 0 1
40345: PPUSH
40346: CALL_OW 321
40350: PUSH
40351: LD_INT 2
40353: EQUAL
40354: AND
40355: IFFALSE 40403
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40357: LD_VAR 0 1
40361: PPUSH
40362: LD_INT 8
40364: PPUSH
40365: EMPTY
40366: PPUSH
40367: CALL 11750 0 3
40371: PUSH
40372: LD_EXP 62
40376: PUSH
40377: LD_VAR 0 1
40381: ARRAY
40382: PUSH
40383: LD_INT 2
40385: ARRAY
40386: LESS
40387: IFFALSE 40403
// begin SetClass ( j , class_mortar ) ;
40389: LD_VAR 0 5
40393: PPUSH
40394: LD_INT 8
40396: PPUSH
40397: CALL_OW 336
// continue ;
40401: GO 39981
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40403: LD_EXP 62
40407: PUSH
40408: LD_VAR 0 1
40412: ARRAY
40413: PUSH
40414: LD_INT 3
40416: ARRAY
40417: PUSH
40418: LD_INT 44
40420: PPUSH
40421: LD_VAR 0 1
40425: PPUSH
40426: CALL_OW 321
40430: PUSH
40431: LD_INT 2
40433: EQUAL
40434: AND
40435: IFFALSE 40483
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40437: LD_VAR 0 1
40441: PPUSH
40442: LD_INT 9
40444: PPUSH
40445: EMPTY
40446: PPUSH
40447: CALL 11750 0 3
40451: PUSH
40452: LD_EXP 62
40456: PUSH
40457: LD_VAR 0 1
40461: ARRAY
40462: PUSH
40463: LD_INT 3
40465: ARRAY
40466: LESS
40467: IFFALSE 40483
// begin SetClass ( j , class_bazooker ) ;
40469: LD_VAR 0 5
40473: PPUSH
40474: LD_INT 9
40476: PPUSH
40477: CALL_OW 336
// continue ;
40481: GO 39981
// end ; end ; end ;
40483: GO 39981
40485: POP
40486: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40487: LD_INT 22
40489: PUSH
40490: LD_VAR 0 1
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 58
40501: PUSH
40502: EMPTY
40503: LIST
40504: PUSH
40505: LD_INT 30
40507: PUSH
40508: LD_INT 32
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: LIST
40519: PPUSH
40520: CALL_OW 69
40524: IFFALSE 40674
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40526: LD_ADDR_VAR 0 12
40530: PUSH
40531: LD_INT 22
40533: PUSH
40534: LD_VAR 0 1
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 58
40545: PUSH
40546: EMPTY
40547: LIST
40548: PUSH
40549: LD_INT 30
40551: PUSH
40552: LD_INT 32
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: LIST
40563: PPUSH
40564: CALL_OW 69
40568: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40569: LD_ADDR_VAR 0 8
40573: PUSH
40574: LD_VAR 0 13
40578: PUSH
40579: LD_EXP 68
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: DIFF
40590: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40591: LD_VAR 0 12
40595: PUSH
40596: LD_INT 1
40598: ARRAY
40599: PPUSH
40600: CALL_OW 461
40604: PUSH
40605: LD_INT 2
40607: EQUAL
40608: PUSH
40609: LD_VAR 0 12
40613: PUSH
40614: LD_INT 1
40616: ARRAY
40617: PUSH
40618: LD_EXP 68
40622: PUSH
40623: LD_VAR 0 1
40627: ARRAY
40628: IN
40629: NOT
40630: AND
40631: PUSH
40632: LD_VAR 0 8
40636: AND
40637: IFFALSE 40674
// begin ComExitBuilding ( k [ 1 ] ) ;
40639: LD_VAR 0 8
40643: PUSH
40644: LD_INT 1
40646: ARRAY
40647: PPUSH
40648: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40652: LD_VAR 0 8
40656: PUSH
40657: LD_INT 1
40659: ARRAY
40660: PPUSH
40661: LD_VAR 0 12
40665: PUSH
40666: LD_INT 1
40668: ARRAY
40669: PPUSH
40670: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40674: LD_EXP 35
40678: PUSH
40679: LD_VAR 0 1
40683: ARRAY
40684: IFFALSE 40832
// begin if MCF_Class ( side , 4 , [ ] ) then
40686: LD_VAR 0 1
40690: PPUSH
40691: LD_INT 4
40693: PPUSH
40694: EMPTY
40695: PPUSH
40696: CALL 11750 0 3
40700: IFFALSE 40830
// for j in MCF_Class ( side , 4 , [ ] ) do
40702: LD_ADDR_VAR 0 5
40706: PUSH
40707: LD_VAR 0 1
40711: PPUSH
40712: LD_INT 4
40714: PPUSH
40715: EMPTY
40716: PPUSH
40717: CALL 11750 0 3
40721: PUSH
40722: FOR_IN
40723: IFFALSE 40828
// begin if not GetTag ( j ) = 4 then
40725: LD_VAR 0 5
40729: PPUSH
40730: CALL_OW 110
40734: PUSH
40735: LD_INT 4
40737: EQUAL
40738: NOT
40739: IFFALSE 40775
// begin SetTag ( j , 4 ) ;
40741: LD_VAR 0 5
40745: PPUSH
40746: LD_INT 4
40748: PPUSH
40749: CALL_OW 109
// if IsInUnit ( j ) then
40753: LD_VAR 0 5
40757: PPUSH
40758: CALL_OW 310
40762: IFFALSE 40773
// ComExitBuilding ( j ) ;
40764: LD_VAR 0 5
40768: PPUSH
40769: CALL_OW 122
// end else
40773: GO 40826
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40775: LD_VAR 0 5
40779: PPUSH
40780: LD_EXP 35
40784: PUSH
40785: LD_VAR 0 1
40789: ARRAY
40790: PUSH
40791: LD_INT 1
40793: ARRAY
40794: PPUSH
40795: CALL 96389 0 2
40799: NOT
40800: IFFALSE 40826
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40802: LD_VAR 0 5
40806: PPUSH
40807: LD_EXP 35
40811: PUSH
40812: LD_VAR 0 1
40816: ARRAY
40817: PUSH
40818: LD_INT 1
40820: ARRAY
40821: PPUSH
40822: CALL 19237 0 2
// end ;
40826: GO 40722
40828: POP
40829: POP
// end else
40830: GO 41064
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40832: LD_VAR 0 1
40836: PPUSH
40837: LD_INT 4
40839: PPUSH
40840: EMPTY
40841: PPUSH
40842: CALL 11750 0 3
40846: PUSH
40847: LD_VAR 0 1
40851: PPUSH
40852: LD_INT 4
40854: PPUSH
40855: EMPTY
40856: PPUSH
40857: CALL 12370 0 3
40861: AND
40862: IFFALSE 41064
// for j in MCF_Class ( side , 4 , [ ] ) do
40864: LD_ADDR_VAR 0 5
40868: PUSH
40869: LD_VAR 0 1
40873: PPUSH
40874: LD_INT 4
40876: PPUSH
40877: EMPTY
40878: PPUSH
40879: CALL 11750 0 3
40883: PUSH
40884: FOR_IN
40885: IFFALSE 41062
// begin if GetTag ( j ) = 4 then
40887: LD_VAR 0 5
40891: PPUSH
40892: CALL_OW 110
40896: PUSH
40897: LD_INT 4
40899: EQUAL
40900: IFFALSE 41060
// begin SetTag ( j , 0 ) ;
40902: LD_VAR 0 5
40906: PPUSH
40907: LD_INT 0
40909: PPUSH
40910: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40914: LD_VAR 0 1
40918: PPUSH
40919: CALL 11706 0 1
40923: PUSH
40924: LD_VAR 0 1
40928: PPUSH
40929: CALL 18050 0 1
40933: NOT
40934: AND
40935: IFFALSE 40960
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40937: LD_VAR 0 5
40941: PPUSH
40942: LD_VAR 0 1
40946: PPUSH
40947: CALL 11706 0 1
40951: PUSH
40952: LD_INT 1
40954: ARRAY
40955: PPUSH
40956: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40960: LD_VAR 0 1
40964: PPUSH
40965: CALL 11706 0 1
40969: NOT
40970: PUSH
40971: LD_VAR 0 1
40975: PPUSH
40976: LD_INT 30
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PPUSH
40986: CALL 11667 0 2
40990: AND
40991: IFFALSE 41060
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40993: LD_VAR 0 5
40997: PPUSH
40998: LD_VAR 0 1
41002: PPUSH
41003: LD_INT 30
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PPUSH
41013: CALL 11667 0 2
41017: PUSH
41018: LD_INT 1
41020: ARRAY
41021: PPUSH
41022: CALL_OW 250
41026: PPUSH
41027: LD_VAR 0 1
41031: PPUSH
41032: LD_INT 30
41034: PUSH
41035: LD_INT 1
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PPUSH
41042: CALL 11667 0 2
41046: PUSH
41047: LD_INT 1
41049: ARRAY
41050: PPUSH
41051: CALL_OW 251
41055: PPUSH
41056: CALL_OW 111
// end ; end ;
41060: GO 40884
41062: POP
41063: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41064: LD_VAR 0 1
41068: PPUSH
41069: LD_INT 3
41071: PPUSH
41072: EMPTY
41073: PPUSH
41074: CALL 11750 0 3
41078: PUSH
41079: LD_EXP 58
41083: PUSH
41084: LD_VAR 0 1
41088: ARRAY
41089: AND
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: LD_INT 6
41098: PPUSH
41099: EMPTY
41100: PPUSH
41101: CALL 12370 0 3
41105: AND
41106: IFFALSE 41637
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41108: LD_ADDR_VAR 0 6
41112: PUSH
41113: LD_EXP 58
41117: PUSH
41118: LD_VAR 0 1
41122: ARRAY
41123: PPUSH
41124: LD_INT 0
41126: PPUSH
41127: CALL_OW 517
41131: PUSH
41132: LD_INT 1
41134: ARRAY
41135: PUSH
41136: LD_INT 1
41138: ARRAY
41139: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41140: LD_ADDR_VAR 0 7
41144: PUSH
41145: LD_EXP 58
41149: PUSH
41150: LD_VAR 0 1
41154: ARRAY
41155: PPUSH
41156: LD_INT 0
41158: PPUSH
41159: CALL_OW 517
41163: PUSH
41164: LD_INT 2
41166: ARRAY
41167: PUSH
41168: LD_INT 1
41170: ARRAY
41171: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41172: LD_VAR 0 1
41176: PPUSH
41177: LD_INT 6
41179: PPUSH
41180: EMPTY
41181: PPUSH
41182: CALL 12370 0 3
41186: IFFALSE 41635
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41188: LD_ADDR_VAR 0 8
41192: PUSH
41193: LD_VAR 0 1
41197: PPUSH
41198: LD_INT 6
41200: PPUSH
41201: EMPTY
41202: PPUSH
41203: CALL 12370 0 3
41207: PUSH
41208: FOR_IN
41209: IFFALSE 41240
// if GetLives ( k ) = 1000 then
41211: LD_VAR 0 8
41215: PPUSH
41216: CALL_OW 256
41220: PUSH
41221: LD_INT 1000
41223: EQUAL
41224: IFFALSE 41238
// SetTag ( k , 0 ) ;
41226: LD_VAR 0 8
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: CALL_OW 109
41238: GO 41208
41240: POP
41241: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41242: LD_VAR 0 1
41246: PPUSH
41247: LD_INT 0
41249: PPUSH
41250: LD_INT 25
41252: PUSH
41253: LD_INT 3
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PPUSH
41260: CALL 12370 0 3
41264: IFFALSE 41328
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41266: LD_ADDR_VAR 0 8
41270: PUSH
41271: LD_VAR 0 4
41275: PPUSH
41276: LD_INT 0
41278: PPUSH
41279: LD_INT 25
41281: PUSH
41282: LD_INT 3
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PPUSH
41289: CALL 12370 0 3
41293: PUSH
41294: FOR_IN
41295: IFFALSE 41326
// if GetTag ( k ) = 0 then
41297: LD_VAR 0 8
41301: PPUSH
41302: CALL_OW 110
41306: PUSH
41307: LD_INT 0
41309: EQUAL
41310: IFFALSE 41324
// begin SetTag ( k , 8 ) ;
41312: LD_VAR 0 8
41316: PPUSH
41317: LD_INT 8
41319: PPUSH
41320: CALL_OW 109
// end ;
41324: GO 41294
41326: POP
41327: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41328: LD_VAR 0 1
41332: PPUSH
41333: LD_INT 6
41335: PPUSH
41336: LD_INT 92
41338: PUSH
41339: LD_VAR 0 6
41343: PUSH
41344: LD_VAR 0 7
41348: PUSH
41349: LD_INT 10
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: PPUSH
41358: CALL 12370 0 3
41362: IFFALSE 41486
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41364: LD_ADDR_VAR 0 5
41368: PUSH
41369: LD_VAR 0 4
41373: PPUSH
41374: LD_INT 6
41376: PPUSH
41377: LD_INT 92
41379: PUSH
41380: LD_VAR 0 6
41384: PUSH
41385: LD_VAR 0 7
41389: PUSH
41390: LD_INT 10
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: PPUSH
41399: CALL 12370 0 3
41403: PUSH
41404: FOR_IN
41405: IFFALSE 41484
// begin if not HasTask ( j ) and GetDriver ( j ) then
41407: LD_VAR 0 5
41411: PPUSH
41412: CALL_OW 314
41416: NOT
41417: PUSH
41418: LD_VAR 0 5
41422: PPUSH
41423: CALL 31789 0 1
41427: AND
41428: IFFALSE 41482
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31789 0 1
41439: PPUSH
41440: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41444: LD_VAR 0 5
41448: PPUSH
41449: CALL 31789 0 1
41453: PPUSH
41454: LD_VAR 0 5
41458: PPUSH
41459: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41463: LD_VAR 0 5
41467: PPUSH
41468: CALL 31789 0 1
41472: PPUSH
41473: LD_VAR 0 5
41477: PPUSH
41478: CALL_OW 180
// end ; end ;
41482: GO 41404
41484: POP
41485: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41486: LD_VAR 0 1
41490: PPUSH
41491: LD_INT 6
41493: PPUSH
41494: LD_INT 92
41496: PUSH
41497: LD_VAR 0 6
41501: PUSH
41502: LD_VAR 0 7
41506: PUSH
41507: LD_INT 10
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: PPUSH
41516: CALL 12370 0 3
41520: PUSH
41521: LD_VAR 0 1
41525: PPUSH
41526: LD_INT 8
41528: PPUSH
41529: EMPTY
41530: PPUSH
41531: CALL 12370 0 3
41535: AND
41536: IFFALSE 41635
// for j in MCF_Tag ( side , 8 , [ ] ) do
41538: LD_ADDR_VAR 0 5
41542: PUSH
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12370 0 3
41557: PUSH
41558: FOR_IN
41559: IFFALSE 41633
// begin if IsInUnit ( j ) then
41561: LD_VAR 0 5
41565: PPUSH
41566: CALL_OW 310
41570: IFFALSE 41583
// ComExitBuilding ( j ) else
41572: LD_VAR 0 5
41576: PPUSH
41577: CALL_OW 122
41581: GO 41631
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41583: LD_VAR 0 5
41587: PPUSH
41588: LD_VAR 0 1
41592: PPUSH
41593: LD_INT 6
41595: PPUSH
41596: LD_INT 92
41598: PUSH
41599: LD_VAR 0 6
41603: PUSH
41604: LD_VAR 0 7
41608: PUSH
41609: LD_INT 10
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: PPUSH
41618: CALL 12370 0 3
41622: PUSH
41623: LD_INT 1
41625: ARRAY
41626: PPUSH
41627: CALL_OW 129
// end ;
41631: GO 41558
41633: POP
41634: POP
// end ; end else
41635: GO 41692
// if MCF_Tag ( side , 8 , [ ] ) then
41637: LD_VAR 0 1
41641: PPUSH
41642: LD_INT 8
41644: PPUSH
41645: EMPTY
41646: PPUSH
41647: CALL 12370 0 3
41651: IFFALSE 41692
// for k in MCF_Tag ( side , 8 , [ ] ) do
41653: LD_ADDR_VAR 0 8
41657: PUSH
41658: LD_VAR 0 1
41662: PPUSH
41663: LD_INT 8
41665: PPUSH
41666: EMPTY
41667: PPUSH
41668: CALL 12370 0 3
41672: PUSH
41673: FOR_IN
41674: IFFALSE 41690
// SetTag ( k , 0 ) ;
41676: LD_VAR 0 8
41680: PPUSH
41681: LD_INT 0
41683: PPUSH
41684: CALL_OW 109
41688: GO 41673
41690: POP
41691: POP
// end ; end_of_file
41692: LD_VAR 0 3
41696: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41697: LD_INT 0
41699: PPUSH
// MREG_Game := [ ] ;
41700: LD_ADDR_EXP 33
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Crates := [ ] ;
41707: LD_ADDR_EXP 34
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_Heal := [ ] ;
41714: LD_ADDR_EXP 35
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_Tame := [ ] ;
41721: LD_ADDR_EXP 37
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41728: LD_ADDR_EXP 38
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41735: LD_ADDR_EXP 39
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_LabList := [ ] ;
41742: LD_ADDR_EXP 40
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41749: LD_ADDR_EXP 41
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41756: LD_ADDR_EXP 42
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41763: LD_ADDR_EXP 43
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41770: LD_ADDR_EXP 44
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_Status := [ ] ;
41777: LD_ADDR_EXP 45
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41784: LD_ADDR_EXP 46
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41791: LD_ADDR_EXP 47
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41798: LD_ADDR_EXP 48
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41805: LD_ADDR_EXP 49
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41812: LD_ADDR_EXP 50
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41819: LD_ADDR_EXP 51
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41826: LD_ADDR_EXP 52
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41833: LD_ADDR_EXP 53
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41840: LD_ADDR_EXP 54
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41847: LD_ADDR_EXP 55
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41854: LD_ADDR_EXP 56
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41861: LD_ADDR_EXP 57
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41868: LD_ADDR_EXP 61
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41875: LD_ADDR_EXP 62
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_Parking := [ ] ;
41882: LD_ADDR_EXP 58
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41889: LD_ADDR_EXP 59
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41896: LD_ADDR_EXP 63
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41903: LD_ADDR_EXP 64
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41910: LD_ADDR_EXP 65
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41917: LD_ADDR_EXP 67
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41924: LD_ADDR_EXP 68
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41931: LD_ADDR_EXP 69
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41938: LD_ADDR_EXP 71
41942: PUSH
41943: EMPTY
41944: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41945: LD_ADDR_EXP 70
41949: PUSH
41950: EMPTY
41951: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41952: LD_ADDR_EXP 72
41956: PUSH
41957: LD_INT 300
41959: PUSH
41960: LD_INT 100
41962: PUSH
41963: LD_INT 25
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: LIST
41970: ST_TO_ADDR
// end ;
41971: LD_VAR 0 1
41975: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41976: LD_INT 0
41978: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41979: LD_VAR 0 2
41983: PUSH
41984: LD_VAR 0 3
41988: PUSH
41989: LD_VAR 0 4
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: LIST
41998: PUSH
41999: LD_VAR 0 1
42003: IN
42004: IFFALSE 42018
// result := mreg_list else
42006: LD_ADDR_VAR 0 5
42010: PUSH
42011: LD_VAR 0 1
42015: ST_TO_ADDR
42016: GO 42052
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42018: LD_ADDR_VAR 0 1
42022: PUSH
42023: LD_VAR 0 1
42027: PUSH
42028: LD_VAR 0 2
42032: PUSH
42033: LD_VAR 0 3
42037: PUSH
42038: LD_VAR 0 4
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: ADD
42051: ST_TO_ADDR
// result := mreg_list ;
42052: LD_ADDR_VAR 0 5
42056: PUSH
42057: LD_VAR 0 1
42061: ST_TO_ADDR
// end ;
42062: LD_VAR 0 5
42066: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42067: LD_INT 0
42069: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42070: LD_VAR 0 2
42074: PUSH
42075: LD_VAR 0 3
42079: PUSH
42080: LD_VAR 0 4
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: LIST
42089: PUSH
42090: LD_VAR 0 1
42094: IN
42095: IFFALSE 42133
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42097: LD_ADDR_VAR 0 5
42101: PUSH
42102: LD_VAR 0 1
42106: PUSH
42107: LD_VAR 0 2
42111: PUSH
42112: LD_VAR 0 3
42116: PUSH
42117: LD_VAR 0 4
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: LIST
42126: PUSH
42127: EMPTY
42128: LIST
42129: DIFF
42130: ST_TO_ADDR
42131: GO 42143
// result := mreg_list ;
42133: LD_ADDR_VAR 0 5
42137: PUSH
42138: LD_VAR 0 1
42142: ST_TO_ADDR
// end ;
42143: LD_VAR 0 5
42147: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42148: LD_INT 0
42150: PPUSH
42151: PPUSH
42152: PPUSH
// for j = 1 to 8 do
42153: LD_ADDR_VAR 0 3
42157: PUSH
42158: DOUBLE
42159: LD_INT 1
42161: DEC
42162: ST_TO_ADDR
42163: LD_INT 8
42165: PUSH
42166: FOR_TO
42167: IFFALSE 43008
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42169: LD_VAR 0 3
42173: PPUSH
42174: LD_INT 51
42176: PUSH
42177: EMPTY
42178: LIST
42179: PPUSH
42180: CALL 11667 0 2
42184: PUSH
42185: LD_OWVAR 2
42189: PUSH
42190: LD_VAR 0 3
42194: EQUAL
42195: NOT
42196: AND
42197: IFFALSE 42215
// MREG_SidesList := MREG_SidesList ^ 1 else
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 1
42211: ADD
42212: ST_TO_ADDR
42213: GO 42229
// MREG_SidesList := MREG_SidesList ^ 0 ;
42215: LD_ADDR_EXP 39
42219: PUSH
42220: LD_EXP 39
42224: PUSH
42225: LD_INT 0
42227: ADD
42228: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42229: LD_VAR 0 3
42233: PPUSH
42234: LD_INT 2
42236: PUSH
42237: LD_INT 34
42239: PUSH
42240: LD_INT 12
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 34
42249: PUSH
42250: LD_INT 32
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 34
42259: PUSH
42260: LD_INT 51
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: PUSH
42273: EMPTY
42274: LIST
42275: PPUSH
42276: CALL 11968 0 2
42280: IFFALSE 42381
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42282: LD_ADDR_VAR 0 2
42286: PUSH
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 2
42294: PUSH
42295: LD_INT 34
42297: PUSH
42298: LD_INT 12
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 34
42307: PUSH
42308: LD_INT 32
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 34
42317: PUSH
42318: LD_INT 51
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: LIST
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PPUSH
42334: CALL 11968 0 2
42338: PUSH
42339: FOR_IN
42340: IFFALSE 42379
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42342: LD_ADDR_EXP 41
42346: PUSH
42347: LD_EXP 41
42351: PPUSH
42352: LD_VAR 0 3
42356: PPUSH
42357: LD_VAR 0 2
42361: PPUSH
42362: LD_VAR 0 2
42366: PPUSH
42367: CALL_OW 264
42371: PPUSH
42372: CALL 41976 0 4
42376: ST_TO_ADDR
42377: GO 42339
42379: POP
42380: POP
// if MCF_Class ( j , 4 , [ ] ) then
42381: LD_VAR 0 3
42385: PPUSH
42386: LD_INT 4
42388: PPUSH
42389: EMPTY
42390: PPUSH
42391: CALL 11750 0 3
42395: IFFALSE 42428
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42397: LD_ADDR_EXP 54
42401: PUSH
42402: LD_EXP 54
42406: PUSH
42407: LD_VAR 0 3
42411: PPUSH
42412: LD_INT 4
42414: PPUSH
42415: EMPTY
42416: PPUSH
42417: CALL 11750 0 3
42421: PUSH
42422: EMPTY
42423: LIST
42424: ADD
42425: ST_TO_ADDR
42426: GO 42445
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42428: LD_ADDR_EXP 54
42432: PUSH
42433: LD_EXP 54
42437: PUSH
42438: LD_INT 0
42440: PUSH
42441: EMPTY
42442: LIST
42443: ADD
42444: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42445: LD_VAR 0 3
42449: PPUSH
42450: LD_INT 3
42452: PPUSH
42453: EMPTY
42454: PPUSH
42455: CALL 11750 0 3
42459: IFFALSE 42492
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42461: LD_ADDR_EXP 55
42465: PUSH
42466: LD_EXP 55
42470: PUSH
42471: LD_VAR 0 3
42475: PPUSH
42476: LD_INT 3
42478: PPUSH
42479: EMPTY
42480: PPUSH
42481: CALL 11750 0 3
42485: PUSH
42486: EMPTY
42487: LIST
42488: ADD
42489: ST_TO_ADDR
42490: GO 42509
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42492: LD_ADDR_EXP 55
42496: PUSH
42497: LD_EXP 55
42501: PUSH
42502: LD_INT 0
42504: PUSH
42505: EMPTY
42506: LIST
42507: ADD
42508: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42509: LD_VAR 0 3
42513: PPUSH
42514: LD_INT 1
42516: PPUSH
42517: EMPTY
42518: PPUSH
42519: CALL 11750 0 3
42523: IFFALSE 42556
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42525: LD_ADDR_EXP 56
42529: PUSH
42530: LD_EXP 56
42534: PUSH
42535: LD_VAR 0 3
42539: PPUSH
42540: LD_INT 1
42542: PPUSH
42543: EMPTY
42544: PPUSH
42545: CALL 11750 0 3
42549: PUSH
42550: EMPTY
42551: LIST
42552: ADD
42553: ST_TO_ADDR
42554: GO 42573
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42556: LD_ADDR_EXP 56
42560: PUSH
42561: LD_EXP 56
42565: PUSH
42566: LD_INT 0
42568: PUSH
42569: EMPTY
42570: LIST
42571: ADD
42572: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42573: LD_VAR 0 3
42577: PPUSH
42578: LD_INT 2
42580: PPUSH
42581: EMPTY
42582: PPUSH
42583: CALL 11750 0 3
42587: IFFALSE 42620
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42589: LD_ADDR_EXP 57
42593: PUSH
42594: LD_EXP 57
42598: PUSH
42599: LD_VAR 0 3
42603: PPUSH
42604: LD_INT 2
42606: PPUSH
42607: EMPTY
42608: PPUSH
42609: CALL 11750 0 3
42613: PUSH
42614: EMPTY
42615: LIST
42616: ADD
42617: ST_TO_ADDR
42618: GO 42637
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42620: LD_ADDR_EXP 57
42624: PUSH
42625: LD_EXP 57
42629: PUSH
42630: LD_INT 0
42632: PUSH
42633: EMPTY
42634: LIST
42635: ADD
42636: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42637: LD_ADDR_EXP 47
42641: PUSH
42642: LD_EXP 47
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: ADD
42653: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42654: LD_ADDR_EXP 35
42658: PUSH
42659: LD_EXP 35
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: ADD
42670: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42671: LD_ADDR_EXP 37
42675: PUSH
42676: LD_EXP 37
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: EMPTY
42685: LIST
42686: ADD
42687: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42688: LD_ADDR_EXP 58
42692: PUSH
42693: LD_EXP 58
42697: PUSH
42698: LD_INT 0
42700: PUSH
42701: EMPTY
42702: LIST
42703: ADD
42704: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42705: LD_ADDR_EXP 59
42709: PUSH
42710: LD_EXP 59
42714: PUSH
42715: LD_INT 0
42717: PUSH
42718: EMPTY
42719: LIST
42720: ADD
42721: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42722: LD_ADDR_EXP 51
42726: PUSH
42727: LD_EXP 51
42731: PUSH
42732: LD_INT 0
42734: PUSH
42735: EMPTY
42736: LIST
42737: ADD
42738: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42739: LD_ADDR_EXP 38
42743: PUSH
42744: LD_EXP 38
42748: PUSH
42749: LD_INT 0
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: LD_INT 0
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42771: LD_ADDR_EXP 60
42775: PUSH
42776: LD_EXP 60
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: EMPTY
42791: LIST
42792: ADD
42793: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42794: LD_ADDR_EXP 61
42798: PUSH
42799: LD_EXP 61
42803: PUSH
42804: LD_INT 0
42806: PUSH
42807: EMPTY
42808: LIST
42809: PUSH
42810: EMPTY
42811: LIST
42812: ADD
42813: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42814: LD_ADDR_EXP 42
42818: PUSH
42819: LD_EXP 42
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: EMPTY
42828: LIST
42829: ADD
42830: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42831: LD_ADDR_EXP 63
42835: PUSH
42836: LD_EXP 63
42840: PUSH
42841: LD_INT 0
42843: PUSH
42844: EMPTY
42845: LIST
42846: ADD
42847: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42848: LD_ADDR_EXP 64
42852: PUSH
42853: LD_EXP 64
42857: PUSH
42858: LD_INT 0
42860: PUSH
42861: EMPTY
42862: LIST
42863: ADD
42864: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42865: LD_ADDR_EXP 65
42869: PUSH
42870: LD_EXP 65
42874: PUSH
42875: LD_INT 0
42877: PUSH
42878: EMPTY
42879: LIST
42880: ADD
42881: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42882: LD_ADDR_EXP 66
42886: PUSH
42887: LD_EXP 66
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: EMPTY
42896: LIST
42897: ADD
42898: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42899: LD_ADDR_EXP 67
42903: PUSH
42904: LD_EXP 67
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: EMPTY
42913: LIST
42914: ADD
42915: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42916: LD_ADDR_EXP 68
42920: PUSH
42921: LD_EXP 68
42925: PUSH
42926: LD_INT 0
42928: PUSH
42929: EMPTY
42930: LIST
42931: ADD
42932: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42933: LD_ADDR_EXP 69
42937: PUSH
42938: LD_EXP 69
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: EMPTY
42947: LIST
42948: ADD
42949: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42950: LD_ADDR_EXP 71
42954: PUSH
42955: LD_EXP 71
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: ADD
42966: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42967: LD_ADDR_EXP 70
42971: PUSH
42972: LD_EXP 70
42976: PUSH
42977: LD_INT 0
42979: ADD
42980: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42981: LD_ADDR_EXP 62
42985: PUSH
42986: LD_EXP 62
42990: PUSH
42991: LD_INT 0
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: LD_INT 0
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: LIST
43004: ADD
43005: ST_TO_ADDR
// end ;
43006: GO 42166
43008: POP
43009: POP
// end ;
43010: LD_VAR 0 1
43014: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43015: LD_INT 0
43017: PPUSH
43018: PPUSH
43019: PPUSH
// m := false ;
43020: LD_ADDR_VAR 0 5
43024: PUSH
43025: LD_INT 0
43027: ST_TO_ADDR
// for i = 1 to mreg do
43028: LD_ADDR_VAR 0 4
43032: PUSH
43033: DOUBLE
43034: LD_INT 1
43036: DEC
43037: ST_TO_ADDR
43038: LD_VAR 0 2
43042: PUSH
43043: FOR_TO
43044: IFFALSE 43080
// if mreg [ i ] [ 1 ] = side then
43046: LD_VAR 0 2
43050: PUSH
43051: LD_VAR 0 4
43055: ARRAY
43056: PUSH
43057: LD_INT 1
43059: ARRAY
43060: PUSH
43061: LD_VAR 0 1
43065: EQUAL
43066: IFFALSE 43078
// begin m := true ;
43068: LD_ADDR_VAR 0 5
43072: PUSH
43073: LD_INT 1
43075: ST_TO_ADDR
// break ;
43076: GO 43080
// end ;
43078: GO 43043
43080: POP
43081: POP
// result := m ;
43082: LD_ADDR_VAR 0 3
43086: PUSH
43087: LD_VAR 0 5
43091: ST_TO_ADDR
// end ;
43092: LD_VAR 0 3
43096: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43097: LD_INT 0
43099: PPUSH
43100: PPUSH
43101: PPUSH
// m := 0 ;
43102: LD_ADDR_VAR 0 5
43106: PUSH
43107: LD_INT 0
43109: ST_TO_ADDR
// for i = 1 to mreg do
43110: LD_ADDR_VAR 0 4
43114: PUSH
43115: DOUBLE
43116: LD_INT 1
43118: DEC
43119: ST_TO_ADDR
43120: LD_VAR 0 2
43124: PUSH
43125: FOR_TO
43126: IFFALSE 43166
// if mreg [ i ] [ 1 ] = side then
43128: LD_VAR 0 2
43132: PUSH
43133: LD_VAR 0 4
43137: ARRAY
43138: PUSH
43139: LD_INT 1
43141: ARRAY
43142: PUSH
43143: LD_VAR 0 1
43147: EQUAL
43148: IFFALSE 43164
// begin m := m + 1 ;
43150: LD_ADDR_VAR 0 5
43154: PUSH
43155: LD_VAR 0 5
43159: PUSH
43160: LD_INT 1
43162: PLUS
43163: ST_TO_ADDR
// end ;
43164: GO 43125
43166: POP
43167: POP
// result := m ;
43168: LD_ADDR_VAR 0 3
43172: PUSH
43173: LD_VAR 0 5
43177: ST_TO_ADDR
// end ;
43178: LD_VAR 0 3
43182: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43183: LD_INT 0
43185: PPUSH
43186: PPUSH
// result := 0 ;
43187: LD_ADDR_VAR 0 3
43191: PUSH
43192: LD_INT 0
43194: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43195: LD_ADDR_VAR 0 4
43199: PUSH
43200: DOUBLE
43201: LD_INT 1
43203: DEC
43204: ST_TO_ADDR
43205: LD_EXP 53
43209: PUSH
43210: FOR_TO
43211: IFFALSE 43273
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43213: LD_EXP 53
43217: PUSH
43218: LD_VAR 0 4
43222: ARRAY
43223: PUSH
43224: LD_INT 1
43226: ARRAY
43227: PUSH
43228: LD_VAR 0 1
43232: EQUAL
43233: PUSH
43234: LD_EXP 53
43238: PUSH
43239: LD_VAR 0 4
43243: ARRAY
43244: PUSH
43245: LD_INT 2
43247: ARRAY
43248: PUSH
43249: LD_VAR 0 2
43253: EQUAL
43254: AND
43255: IFFALSE 43271
// begin result := result + 1 ;
43257: LD_ADDR_VAR 0 3
43261: PUSH
43262: LD_VAR 0 3
43266: PUSH
43267: LD_INT 1
43269: PLUS
43270: ST_TO_ADDR
// end ;
43271: GO 43210
43273: POP
43274: POP
// end ; end_of_file
43275: LD_VAR 0 3
43279: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43280: LD_INT 0
43282: PPUSH
// ar_miner := 81 ;
43283: LD_ADDR_EXP 80
43287: PUSH
43288: LD_INT 81
43290: ST_TO_ADDR
// ar_crane := 88 ;
43291: LD_ADDR_EXP 79
43295: PUSH
43296: LD_INT 88
43298: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43299: LD_ADDR_EXP 74
43303: PUSH
43304: LD_INT 89
43306: ST_TO_ADDR
// us_hack := 99 ;
43307: LD_ADDR_EXP 75
43311: PUSH
43312: LD_INT 99
43314: ST_TO_ADDR
// us_artillery := 97 ;
43315: LD_ADDR_EXP 76
43319: PUSH
43320: LD_INT 97
43322: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43323: LD_ADDR_EXP 77
43327: PUSH
43328: LD_INT 91
43330: ST_TO_ADDR
// ar_mortar := 92 ;
43331: LD_ADDR_EXP 78
43335: PUSH
43336: LD_INT 92
43338: ST_TO_ADDR
// ru_radar := 98 ;
43339: LD_ADDR_EXP 73
43343: PUSH
43344: LD_INT 98
43346: ST_TO_ADDR
// tech_Artillery := 80 ;
43347: LD_ADDR_EXP 81
43351: PUSH
43352: LD_INT 80
43354: ST_TO_ADDR
// tech_RadMat := 81 ;
43355: LD_ADDR_EXP 82
43359: PUSH
43360: LD_INT 81
43362: ST_TO_ADDR
// tech_BasicTools := 82 ;
43363: LD_ADDR_EXP 83
43367: PUSH
43368: LD_INT 82
43370: ST_TO_ADDR
// tech_Cargo := 83 ;
43371: LD_ADDR_EXP 84
43375: PUSH
43376: LD_INT 83
43378: ST_TO_ADDR
// tech_Track := 84 ;
43379: LD_ADDR_EXP 85
43383: PUSH
43384: LD_INT 84
43386: ST_TO_ADDR
// tech_Crane := 85 ;
43387: LD_ADDR_EXP 86
43391: PUSH
43392: LD_INT 85
43394: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43395: LD_ADDR_EXP 87
43399: PUSH
43400: LD_INT 86
43402: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43403: LD_ADDR_EXP 88
43407: PUSH
43408: LD_INT 87
43410: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43411: LD_ADDR_EXP 89
43415: PUSH
43416: LD_INT 88
43418: ST_TO_ADDR
// class_mastodont := 31 ;
43419: LD_ADDR_EXP 90
43423: PUSH
43424: LD_INT 31
43426: ST_TO_ADDR
// class_horse := 21 ;
43427: LD_ADDR_EXP 91
43431: PUSH
43432: LD_INT 21
43434: ST_TO_ADDR
// end ;
43435: LD_VAR 0 1
43439: RET
// every 1 do
43440: GO 43442
43442: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43443: CALL 43280 0 0
43447: END
// every 0 0$1 do
43448: GO 43450
43450: DISABLE
// begin enable ;
43451: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43452: LD_STRING updateTimer(
43454: PUSH
43455: LD_OWVAR 1
43459: STR
43460: PUSH
43461: LD_STRING );
43463: STR
43464: PPUSH
43465: CALL_OW 559
// end ;
43469: END
// export function SOS_MapStart ( ) ; begin
43470: LD_INT 0
43472: PPUSH
// if streamModeActive then
43473: LD_EXP 92
43477: IFFALSE 43486
// DefineStreamItems ( true ) ;
43479: LD_INT 1
43481: PPUSH
43482: CALL 45136 0 1
// UpdateFactoryWaypoints ( ) ;
43486: CALL 58720 0 0
// end ;
43490: LD_VAR 0 1
43494: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43495: LD_INT 0
43497: PPUSH
// if p2 = 100 then
43498: LD_VAR 0 2
43502: PUSH
43503: LD_INT 100
43505: EQUAL
43506: IFFALSE 44509
// begin if not StreamModeActive then
43508: LD_EXP 92
43512: NOT
43513: IFFALSE 43523
// StreamModeActive := true ;
43515: LD_ADDR_EXP 92
43519: PUSH
43520: LD_INT 1
43522: ST_TO_ADDR
// if p3 = 0 then
43523: LD_VAR 0 3
43527: PUSH
43528: LD_INT 0
43530: EQUAL
43531: IFFALSE 43537
// InitStreamMode ;
43533: CALL 44672 0 0
// if p3 = 1 then
43537: LD_VAR 0 3
43541: PUSH
43542: LD_INT 1
43544: EQUAL
43545: IFFALSE 43555
// sRocket := true ;
43547: LD_ADDR_EXP 97
43551: PUSH
43552: LD_INT 1
43554: ST_TO_ADDR
// if p3 = 2 then
43555: LD_VAR 0 3
43559: PUSH
43560: LD_INT 2
43562: EQUAL
43563: IFFALSE 43573
// sSpeed := true ;
43565: LD_ADDR_EXP 96
43569: PUSH
43570: LD_INT 1
43572: ST_TO_ADDR
// if p3 = 3 then
43573: LD_VAR 0 3
43577: PUSH
43578: LD_INT 3
43580: EQUAL
43581: IFFALSE 43591
// sEngine := true ;
43583: LD_ADDR_EXP 98
43587: PUSH
43588: LD_INT 1
43590: ST_TO_ADDR
// if p3 = 4 then
43591: LD_VAR 0 3
43595: PUSH
43596: LD_INT 4
43598: EQUAL
43599: IFFALSE 43609
// sSpec := true ;
43601: LD_ADDR_EXP 95
43605: PUSH
43606: LD_INT 1
43608: ST_TO_ADDR
// if p3 = 5 then
43609: LD_VAR 0 3
43613: PUSH
43614: LD_INT 5
43616: EQUAL
43617: IFFALSE 43627
// sLevel := true ;
43619: LD_ADDR_EXP 99
43623: PUSH
43624: LD_INT 1
43626: ST_TO_ADDR
// if p3 = 6 then
43627: LD_VAR 0 3
43631: PUSH
43632: LD_INT 6
43634: EQUAL
43635: IFFALSE 43645
// sArmoury := true ;
43637: LD_ADDR_EXP 100
43641: PUSH
43642: LD_INT 1
43644: ST_TO_ADDR
// if p3 = 7 then
43645: LD_VAR 0 3
43649: PUSH
43650: LD_INT 7
43652: EQUAL
43653: IFFALSE 43663
// sRadar := true ;
43655: LD_ADDR_EXP 101
43659: PUSH
43660: LD_INT 1
43662: ST_TO_ADDR
// if p3 = 8 then
43663: LD_VAR 0 3
43667: PUSH
43668: LD_INT 8
43670: EQUAL
43671: IFFALSE 43681
// sBunker := true ;
43673: LD_ADDR_EXP 102
43677: PUSH
43678: LD_INT 1
43680: ST_TO_ADDR
// if p3 = 9 then
43681: LD_VAR 0 3
43685: PUSH
43686: LD_INT 9
43688: EQUAL
43689: IFFALSE 43699
// sHack := true ;
43691: LD_ADDR_EXP 103
43695: PUSH
43696: LD_INT 1
43698: ST_TO_ADDR
// if p3 = 10 then
43699: LD_VAR 0 3
43703: PUSH
43704: LD_INT 10
43706: EQUAL
43707: IFFALSE 43717
// sFire := true ;
43709: LD_ADDR_EXP 104
43713: PUSH
43714: LD_INT 1
43716: ST_TO_ADDR
// if p3 = 11 then
43717: LD_VAR 0 3
43721: PUSH
43722: LD_INT 11
43724: EQUAL
43725: IFFALSE 43735
// sRefresh := true ;
43727: LD_ADDR_EXP 105
43731: PUSH
43732: LD_INT 1
43734: ST_TO_ADDR
// if p3 = 12 then
43735: LD_VAR 0 3
43739: PUSH
43740: LD_INT 12
43742: EQUAL
43743: IFFALSE 43753
// sExp := true ;
43745: LD_ADDR_EXP 106
43749: PUSH
43750: LD_INT 1
43752: ST_TO_ADDR
// if p3 = 13 then
43753: LD_VAR 0 3
43757: PUSH
43758: LD_INT 13
43760: EQUAL
43761: IFFALSE 43771
// sDepot := true ;
43763: LD_ADDR_EXP 107
43767: PUSH
43768: LD_INT 1
43770: ST_TO_ADDR
// if p3 = 14 then
43771: LD_VAR 0 3
43775: PUSH
43776: LD_INT 14
43778: EQUAL
43779: IFFALSE 43789
// sFlag := true ;
43781: LD_ADDR_EXP 108
43785: PUSH
43786: LD_INT 1
43788: ST_TO_ADDR
// if p3 = 15 then
43789: LD_VAR 0 3
43793: PUSH
43794: LD_INT 15
43796: EQUAL
43797: IFFALSE 43807
// sKamikadze := true ;
43799: LD_ADDR_EXP 116
43803: PUSH
43804: LD_INT 1
43806: ST_TO_ADDR
// if p3 = 16 then
43807: LD_VAR 0 3
43811: PUSH
43812: LD_INT 16
43814: EQUAL
43815: IFFALSE 43825
// sTroll := true ;
43817: LD_ADDR_EXP 117
43821: PUSH
43822: LD_INT 1
43824: ST_TO_ADDR
// if p3 = 17 then
43825: LD_VAR 0 3
43829: PUSH
43830: LD_INT 17
43832: EQUAL
43833: IFFALSE 43843
// sSlow := true ;
43835: LD_ADDR_EXP 118
43839: PUSH
43840: LD_INT 1
43842: ST_TO_ADDR
// if p3 = 18 then
43843: LD_VAR 0 3
43847: PUSH
43848: LD_INT 18
43850: EQUAL
43851: IFFALSE 43861
// sLack := true ;
43853: LD_ADDR_EXP 119
43857: PUSH
43858: LD_INT 1
43860: ST_TO_ADDR
// if p3 = 19 then
43861: LD_VAR 0 3
43865: PUSH
43866: LD_INT 19
43868: EQUAL
43869: IFFALSE 43879
// sTank := true ;
43871: LD_ADDR_EXP 121
43875: PUSH
43876: LD_INT 1
43878: ST_TO_ADDR
// if p3 = 20 then
43879: LD_VAR 0 3
43883: PUSH
43884: LD_INT 20
43886: EQUAL
43887: IFFALSE 43897
// sRemote := true ;
43889: LD_ADDR_EXP 122
43893: PUSH
43894: LD_INT 1
43896: ST_TO_ADDR
// if p3 = 21 then
43897: LD_VAR 0 3
43901: PUSH
43902: LD_INT 21
43904: EQUAL
43905: IFFALSE 43915
// sPowell := true ;
43907: LD_ADDR_EXP 123
43911: PUSH
43912: LD_INT 1
43914: ST_TO_ADDR
// if p3 = 22 then
43915: LD_VAR 0 3
43919: PUSH
43920: LD_INT 22
43922: EQUAL
43923: IFFALSE 43933
// sTeleport := true ;
43925: LD_ADDR_EXP 126
43929: PUSH
43930: LD_INT 1
43932: ST_TO_ADDR
// if p3 = 23 then
43933: LD_VAR 0 3
43937: PUSH
43938: LD_INT 23
43940: EQUAL
43941: IFFALSE 43951
// sOilTower := true ;
43943: LD_ADDR_EXP 128
43947: PUSH
43948: LD_INT 1
43950: ST_TO_ADDR
// if p3 = 24 then
43951: LD_VAR 0 3
43955: PUSH
43956: LD_INT 24
43958: EQUAL
43959: IFFALSE 43969
// sShovel := true ;
43961: LD_ADDR_EXP 129
43965: PUSH
43966: LD_INT 1
43968: ST_TO_ADDR
// if p3 = 25 then
43969: LD_VAR 0 3
43973: PUSH
43974: LD_INT 25
43976: EQUAL
43977: IFFALSE 43987
// sSheik := true ;
43979: LD_ADDR_EXP 130
43983: PUSH
43984: LD_INT 1
43986: ST_TO_ADDR
// if p3 = 26 then
43987: LD_VAR 0 3
43991: PUSH
43992: LD_INT 26
43994: EQUAL
43995: IFFALSE 44005
// sEarthquake := true ;
43997: LD_ADDR_EXP 132
44001: PUSH
44002: LD_INT 1
44004: ST_TO_ADDR
// if p3 = 27 then
44005: LD_VAR 0 3
44009: PUSH
44010: LD_INT 27
44012: EQUAL
44013: IFFALSE 44023
// sAI := true ;
44015: LD_ADDR_EXP 133
44019: PUSH
44020: LD_INT 1
44022: ST_TO_ADDR
// if p3 = 28 then
44023: LD_VAR 0 3
44027: PUSH
44028: LD_INT 28
44030: EQUAL
44031: IFFALSE 44041
// sCargo := true ;
44033: LD_ADDR_EXP 136
44037: PUSH
44038: LD_INT 1
44040: ST_TO_ADDR
// if p3 = 29 then
44041: LD_VAR 0 3
44045: PUSH
44046: LD_INT 29
44048: EQUAL
44049: IFFALSE 44059
// sDLaser := true ;
44051: LD_ADDR_EXP 137
44055: PUSH
44056: LD_INT 1
44058: ST_TO_ADDR
// if p3 = 30 then
44059: LD_VAR 0 3
44063: PUSH
44064: LD_INT 30
44066: EQUAL
44067: IFFALSE 44077
// sExchange := true ;
44069: LD_ADDR_EXP 138
44073: PUSH
44074: LD_INT 1
44076: ST_TO_ADDR
// if p3 = 31 then
44077: LD_VAR 0 3
44081: PUSH
44082: LD_INT 31
44084: EQUAL
44085: IFFALSE 44095
// sFac := true ;
44087: LD_ADDR_EXP 139
44091: PUSH
44092: LD_INT 1
44094: ST_TO_ADDR
// if p3 = 32 then
44095: LD_VAR 0 3
44099: PUSH
44100: LD_INT 32
44102: EQUAL
44103: IFFALSE 44113
// sPower := true ;
44105: LD_ADDR_EXP 140
44109: PUSH
44110: LD_INT 1
44112: ST_TO_ADDR
// if p3 = 33 then
44113: LD_VAR 0 3
44117: PUSH
44118: LD_INT 33
44120: EQUAL
44121: IFFALSE 44131
// sRandom := true ;
44123: LD_ADDR_EXP 141
44127: PUSH
44128: LD_INT 1
44130: ST_TO_ADDR
// if p3 = 34 then
44131: LD_VAR 0 3
44135: PUSH
44136: LD_INT 34
44138: EQUAL
44139: IFFALSE 44149
// sShield := true ;
44141: LD_ADDR_EXP 142
44145: PUSH
44146: LD_INT 1
44148: ST_TO_ADDR
// if p3 = 35 then
44149: LD_VAR 0 3
44153: PUSH
44154: LD_INT 35
44156: EQUAL
44157: IFFALSE 44167
// sTime := true ;
44159: LD_ADDR_EXP 143
44163: PUSH
44164: LD_INT 1
44166: ST_TO_ADDR
// if p3 = 36 then
44167: LD_VAR 0 3
44171: PUSH
44172: LD_INT 36
44174: EQUAL
44175: IFFALSE 44185
// sTools := true ;
44177: LD_ADDR_EXP 144
44181: PUSH
44182: LD_INT 1
44184: ST_TO_ADDR
// if p3 = 101 then
44185: LD_VAR 0 3
44189: PUSH
44190: LD_INT 101
44192: EQUAL
44193: IFFALSE 44203
// sSold := true ;
44195: LD_ADDR_EXP 109
44199: PUSH
44200: LD_INT 1
44202: ST_TO_ADDR
// if p3 = 102 then
44203: LD_VAR 0 3
44207: PUSH
44208: LD_INT 102
44210: EQUAL
44211: IFFALSE 44221
// sDiff := true ;
44213: LD_ADDR_EXP 110
44217: PUSH
44218: LD_INT 1
44220: ST_TO_ADDR
// if p3 = 103 then
44221: LD_VAR 0 3
44225: PUSH
44226: LD_INT 103
44228: EQUAL
44229: IFFALSE 44239
// sFog := true ;
44231: LD_ADDR_EXP 113
44235: PUSH
44236: LD_INT 1
44238: ST_TO_ADDR
// if p3 = 104 then
44239: LD_VAR 0 3
44243: PUSH
44244: LD_INT 104
44246: EQUAL
44247: IFFALSE 44257
// sReset := true ;
44249: LD_ADDR_EXP 114
44253: PUSH
44254: LD_INT 1
44256: ST_TO_ADDR
// if p3 = 105 then
44257: LD_VAR 0 3
44261: PUSH
44262: LD_INT 105
44264: EQUAL
44265: IFFALSE 44275
// sSun := true ;
44267: LD_ADDR_EXP 115
44271: PUSH
44272: LD_INT 1
44274: ST_TO_ADDR
// if p3 = 106 then
44275: LD_VAR 0 3
44279: PUSH
44280: LD_INT 106
44282: EQUAL
44283: IFFALSE 44293
// sTiger := true ;
44285: LD_ADDR_EXP 111
44289: PUSH
44290: LD_INT 1
44292: ST_TO_ADDR
// if p3 = 107 then
44293: LD_VAR 0 3
44297: PUSH
44298: LD_INT 107
44300: EQUAL
44301: IFFALSE 44311
// sBomb := true ;
44303: LD_ADDR_EXP 112
44307: PUSH
44308: LD_INT 1
44310: ST_TO_ADDR
// if p3 = 108 then
44311: LD_VAR 0 3
44315: PUSH
44316: LD_INT 108
44318: EQUAL
44319: IFFALSE 44329
// sWound := true ;
44321: LD_ADDR_EXP 120
44325: PUSH
44326: LD_INT 1
44328: ST_TO_ADDR
// if p3 = 109 then
44329: LD_VAR 0 3
44333: PUSH
44334: LD_INT 109
44336: EQUAL
44337: IFFALSE 44347
// sBetray := true ;
44339: LD_ADDR_EXP 124
44343: PUSH
44344: LD_INT 1
44346: ST_TO_ADDR
// if p3 = 110 then
44347: LD_VAR 0 3
44351: PUSH
44352: LD_INT 110
44354: EQUAL
44355: IFFALSE 44365
// sContamin := true ;
44357: LD_ADDR_EXP 125
44361: PUSH
44362: LD_INT 1
44364: ST_TO_ADDR
// if p3 = 111 then
44365: LD_VAR 0 3
44369: PUSH
44370: LD_INT 111
44372: EQUAL
44373: IFFALSE 44383
// sOil := true ;
44375: LD_ADDR_EXP 127
44379: PUSH
44380: LD_INT 1
44382: ST_TO_ADDR
// if p3 = 112 then
44383: LD_VAR 0 3
44387: PUSH
44388: LD_INT 112
44390: EQUAL
44391: IFFALSE 44401
// sStu := true ;
44393: LD_ADDR_EXP 131
44397: PUSH
44398: LD_INT 1
44400: ST_TO_ADDR
// if p3 = 113 then
44401: LD_VAR 0 3
44405: PUSH
44406: LD_INT 113
44408: EQUAL
44409: IFFALSE 44419
// sBazooka := true ;
44411: LD_ADDR_EXP 134
44415: PUSH
44416: LD_INT 1
44418: ST_TO_ADDR
// if p3 = 114 then
44419: LD_VAR 0 3
44423: PUSH
44424: LD_INT 114
44426: EQUAL
44427: IFFALSE 44437
// sMortar := true ;
44429: LD_ADDR_EXP 135
44433: PUSH
44434: LD_INT 1
44436: ST_TO_ADDR
// if p3 = 115 then
44437: LD_VAR 0 3
44441: PUSH
44442: LD_INT 115
44444: EQUAL
44445: IFFALSE 44455
// sRanger := true ;
44447: LD_ADDR_EXP 145
44451: PUSH
44452: LD_INT 1
44454: ST_TO_ADDR
// if p3 = 116 then
44455: LD_VAR 0 3
44459: PUSH
44460: LD_INT 116
44462: EQUAL
44463: IFFALSE 44473
// sComputer := true ;
44465: LD_ADDR_EXP 146
44469: PUSH
44470: LD_INT 1
44472: ST_TO_ADDR
// if p3 = 117 then
44473: LD_VAR 0 3
44477: PUSH
44478: LD_INT 117
44480: EQUAL
44481: IFFALSE 44491
// s30 := true ;
44483: LD_ADDR_EXP 147
44487: PUSH
44488: LD_INT 1
44490: ST_TO_ADDR
// if p3 = 118 then
44491: LD_VAR 0 3
44495: PUSH
44496: LD_INT 118
44498: EQUAL
44499: IFFALSE 44509
// s60 := true ;
44501: LD_ADDR_EXP 148
44505: PUSH
44506: LD_INT 1
44508: ST_TO_ADDR
// end ; if p2 = 101 then
44509: LD_VAR 0 2
44513: PUSH
44514: LD_INT 101
44516: EQUAL
44517: IFFALSE 44645
// begin case p3 of 1 :
44519: LD_VAR 0 3
44523: PUSH
44524: LD_INT 1
44526: DOUBLE
44527: EQUAL
44528: IFTRUE 44532
44530: GO 44539
44532: POP
// hHackUnlimitedResources ; 2 :
44533: CALL 56743 0 0
44537: GO 44645
44539: LD_INT 2
44541: DOUBLE
44542: EQUAL
44543: IFTRUE 44547
44545: GO 44554
44547: POP
// hHackSetLevel10 ; 3 :
44548: CALL 56876 0 0
44552: GO 44645
44554: LD_INT 3
44556: DOUBLE
44557: EQUAL
44558: IFTRUE 44562
44560: GO 44569
44562: POP
// hHackSetLevel10YourUnits ; 4 :
44563: CALL 56961 0 0
44567: GO 44645
44569: LD_INT 4
44571: DOUBLE
44572: EQUAL
44573: IFTRUE 44577
44575: GO 44584
44577: POP
// hHackInvincible ; 5 :
44578: CALL 57409 0 0
44582: GO 44645
44584: LD_INT 5
44586: DOUBLE
44587: EQUAL
44588: IFTRUE 44592
44590: GO 44599
44592: POP
// hHackInvisible ; 6 :
44593: CALL 57520 0 0
44597: GO 44645
44599: LD_INT 6
44601: DOUBLE
44602: EQUAL
44603: IFTRUE 44607
44605: GO 44614
44607: POP
// hHackChangeYourSide ; 7 :
44608: CALL 57577 0 0
44612: GO 44645
44614: LD_INT 7
44616: DOUBLE
44617: EQUAL
44618: IFTRUE 44622
44620: GO 44629
44622: POP
// hHackChangeUnitSide ; 8 :
44623: CALL 57619 0 0
44627: GO 44645
44629: LD_INT 8
44631: DOUBLE
44632: EQUAL
44633: IFTRUE 44637
44635: GO 44644
44637: POP
// hHackFog ; end ;
44638: CALL 57720 0 0
44642: GO 44645
44644: POP
// end ; end ;
44645: LD_VAR 0 7
44649: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44650: GO 44652
44652: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44653: LD_STRING initStreamRollete();
44655: PPUSH
44656: CALL_OW 559
// InitStreamMode ;
44660: CALL 44672 0 0
// DefineStreamItems ( false ) ;
44664: LD_INT 0
44666: PPUSH
44667: CALL 45136 0 1
// end ;
44671: END
// function InitStreamMode ; begin
44672: LD_INT 0
44674: PPUSH
// streamModeActive := false ;
44675: LD_ADDR_EXP 92
44679: PUSH
44680: LD_INT 0
44682: ST_TO_ADDR
// normalCounter := 36 ;
44683: LD_ADDR_EXP 93
44687: PUSH
44688: LD_INT 36
44690: ST_TO_ADDR
// hardcoreCounter := 18 ;
44691: LD_ADDR_EXP 94
44695: PUSH
44696: LD_INT 18
44698: ST_TO_ADDR
// sRocket := false ;
44699: LD_ADDR_EXP 97
44703: PUSH
44704: LD_INT 0
44706: ST_TO_ADDR
// sSpeed := false ;
44707: LD_ADDR_EXP 96
44711: PUSH
44712: LD_INT 0
44714: ST_TO_ADDR
// sEngine := false ;
44715: LD_ADDR_EXP 98
44719: PUSH
44720: LD_INT 0
44722: ST_TO_ADDR
// sSpec := false ;
44723: LD_ADDR_EXP 95
44727: PUSH
44728: LD_INT 0
44730: ST_TO_ADDR
// sLevel := false ;
44731: LD_ADDR_EXP 99
44735: PUSH
44736: LD_INT 0
44738: ST_TO_ADDR
// sArmoury := false ;
44739: LD_ADDR_EXP 100
44743: PUSH
44744: LD_INT 0
44746: ST_TO_ADDR
// sRadar := false ;
44747: LD_ADDR_EXP 101
44751: PUSH
44752: LD_INT 0
44754: ST_TO_ADDR
// sBunker := false ;
44755: LD_ADDR_EXP 102
44759: PUSH
44760: LD_INT 0
44762: ST_TO_ADDR
// sHack := false ;
44763: LD_ADDR_EXP 103
44767: PUSH
44768: LD_INT 0
44770: ST_TO_ADDR
// sFire := false ;
44771: LD_ADDR_EXP 104
44775: PUSH
44776: LD_INT 0
44778: ST_TO_ADDR
// sRefresh := false ;
44779: LD_ADDR_EXP 105
44783: PUSH
44784: LD_INT 0
44786: ST_TO_ADDR
// sExp := false ;
44787: LD_ADDR_EXP 106
44791: PUSH
44792: LD_INT 0
44794: ST_TO_ADDR
// sDepot := false ;
44795: LD_ADDR_EXP 107
44799: PUSH
44800: LD_INT 0
44802: ST_TO_ADDR
// sFlag := false ;
44803: LD_ADDR_EXP 108
44807: PUSH
44808: LD_INT 0
44810: ST_TO_ADDR
// sKamikadze := false ;
44811: LD_ADDR_EXP 116
44815: PUSH
44816: LD_INT 0
44818: ST_TO_ADDR
// sTroll := false ;
44819: LD_ADDR_EXP 117
44823: PUSH
44824: LD_INT 0
44826: ST_TO_ADDR
// sSlow := false ;
44827: LD_ADDR_EXP 118
44831: PUSH
44832: LD_INT 0
44834: ST_TO_ADDR
// sLack := false ;
44835: LD_ADDR_EXP 119
44839: PUSH
44840: LD_INT 0
44842: ST_TO_ADDR
// sTank := false ;
44843: LD_ADDR_EXP 121
44847: PUSH
44848: LD_INT 0
44850: ST_TO_ADDR
// sRemote := false ;
44851: LD_ADDR_EXP 122
44855: PUSH
44856: LD_INT 0
44858: ST_TO_ADDR
// sPowell := false ;
44859: LD_ADDR_EXP 123
44863: PUSH
44864: LD_INT 0
44866: ST_TO_ADDR
// sTeleport := false ;
44867: LD_ADDR_EXP 126
44871: PUSH
44872: LD_INT 0
44874: ST_TO_ADDR
// sOilTower := false ;
44875: LD_ADDR_EXP 128
44879: PUSH
44880: LD_INT 0
44882: ST_TO_ADDR
// sShovel := false ;
44883: LD_ADDR_EXP 129
44887: PUSH
44888: LD_INT 0
44890: ST_TO_ADDR
// sSheik := false ;
44891: LD_ADDR_EXP 130
44895: PUSH
44896: LD_INT 0
44898: ST_TO_ADDR
// sEarthquake := false ;
44899: LD_ADDR_EXP 132
44903: PUSH
44904: LD_INT 0
44906: ST_TO_ADDR
// sAI := false ;
44907: LD_ADDR_EXP 133
44911: PUSH
44912: LD_INT 0
44914: ST_TO_ADDR
// sCargo := false ;
44915: LD_ADDR_EXP 136
44919: PUSH
44920: LD_INT 0
44922: ST_TO_ADDR
// sDLaser := false ;
44923: LD_ADDR_EXP 137
44927: PUSH
44928: LD_INT 0
44930: ST_TO_ADDR
// sExchange := false ;
44931: LD_ADDR_EXP 138
44935: PUSH
44936: LD_INT 0
44938: ST_TO_ADDR
// sFac := false ;
44939: LD_ADDR_EXP 139
44943: PUSH
44944: LD_INT 0
44946: ST_TO_ADDR
// sPower := false ;
44947: LD_ADDR_EXP 140
44951: PUSH
44952: LD_INT 0
44954: ST_TO_ADDR
// sRandom := false ;
44955: LD_ADDR_EXP 141
44959: PUSH
44960: LD_INT 0
44962: ST_TO_ADDR
// sShield := false ;
44963: LD_ADDR_EXP 142
44967: PUSH
44968: LD_INT 0
44970: ST_TO_ADDR
// sTime := false ;
44971: LD_ADDR_EXP 143
44975: PUSH
44976: LD_INT 0
44978: ST_TO_ADDR
// sTools := false ;
44979: LD_ADDR_EXP 144
44983: PUSH
44984: LD_INT 0
44986: ST_TO_ADDR
// sSold := false ;
44987: LD_ADDR_EXP 109
44991: PUSH
44992: LD_INT 0
44994: ST_TO_ADDR
// sDiff := false ;
44995: LD_ADDR_EXP 110
44999: PUSH
45000: LD_INT 0
45002: ST_TO_ADDR
// sFog := false ;
45003: LD_ADDR_EXP 113
45007: PUSH
45008: LD_INT 0
45010: ST_TO_ADDR
// sReset := false ;
45011: LD_ADDR_EXP 114
45015: PUSH
45016: LD_INT 0
45018: ST_TO_ADDR
// sSun := false ;
45019: LD_ADDR_EXP 115
45023: PUSH
45024: LD_INT 0
45026: ST_TO_ADDR
// sTiger := false ;
45027: LD_ADDR_EXP 111
45031: PUSH
45032: LD_INT 0
45034: ST_TO_ADDR
// sBomb := false ;
45035: LD_ADDR_EXP 112
45039: PUSH
45040: LD_INT 0
45042: ST_TO_ADDR
// sWound := false ;
45043: LD_ADDR_EXP 120
45047: PUSH
45048: LD_INT 0
45050: ST_TO_ADDR
// sBetray := false ;
45051: LD_ADDR_EXP 124
45055: PUSH
45056: LD_INT 0
45058: ST_TO_ADDR
// sContamin := false ;
45059: LD_ADDR_EXP 125
45063: PUSH
45064: LD_INT 0
45066: ST_TO_ADDR
// sOil := false ;
45067: LD_ADDR_EXP 127
45071: PUSH
45072: LD_INT 0
45074: ST_TO_ADDR
// sStu := false ;
45075: LD_ADDR_EXP 131
45079: PUSH
45080: LD_INT 0
45082: ST_TO_ADDR
// sBazooka := false ;
45083: LD_ADDR_EXP 134
45087: PUSH
45088: LD_INT 0
45090: ST_TO_ADDR
// sMortar := false ;
45091: LD_ADDR_EXP 135
45095: PUSH
45096: LD_INT 0
45098: ST_TO_ADDR
// sRanger := false ;
45099: LD_ADDR_EXP 145
45103: PUSH
45104: LD_INT 0
45106: ST_TO_ADDR
// sComputer := false ;
45107: LD_ADDR_EXP 146
45111: PUSH
45112: LD_INT 0
45114: ST_TO_ADDR
// s30 := false ;
45115: LD_ADDR_EXP 147
45119: PUSH
45120: LD_INT 0
45122: ST_TO_ADDR
// s60 := false ;
45123: LD_ADDR_EXP 148
45127: PUSH
45128: LD_INT 0
45130: ST_TO_ADDR
// end ;
45131: LD_VAR 0 1
45135: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45136: LD_INT 0
45138: PPUSH
45139: PPUSH
45140: PPUSH
45141: PPUSH
45142: PPUSH
45143: PPUSH
45144: PPUSH
// result := [ ] ;
45145: LD_ADDR_VAR 0 2
45149: PUSH
45150: EMPTY
45151: ST_TO_ADDR
// if campaign_id = 1 then
45152: LD_OWVAR 69
45156: PUSH
45157: LD_INT 1
45159: EQUAL
45160: IFFALSE 48326
// begin case mission_number of 1 :
45162: LD_OWVAR 70
45166: PUSH
45167: LD_INT 1
45169: DOUBLE
45170: EQUAL
45171: IFTRUE 45175
45173: GO 45251
45175: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45176: LD_ADDR_VAR 0 2
45180: PUSH
45181: LD_INT 2
45183: PUSH
45184: LD_INT 4
45186: PUSH
45187: LD_INT 11
45189: PUSH
45190: LD_INT 12
45192: PUSH
45193: LD_INT 15
45195: PUSH
45196: LD_INT 16
45198: PUSH
45199: LD_INT 22
45201: PUSH
45202: LD_INT 23
45204: PUSH
45205: LD_INT 26
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 101
45221: PUSH
45222: LD_INT 102
45224: PUSH
45225: LD_INT 106
45227: PUSH
45228: LD_INT 116
45230: PUSH
45231: LD_INT 117
45233: PUSH
45234: LD_INT 118
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: ST_TO_ADDR
45249: GO 48324
45251: LD_INT 2
45253: DOUBLE
45254: EQUAL
45255: IFTRUE 45259
45257: GO 45343
45259: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45260: LD_ADDR_VAR 0 2
45264: PUSH
45265: LD_INT 2
45267: PUSH
45268: LD_INT 4
45270: PUSH
45271: LD_INT 11
45273: PUSH
45274: LD_INT 12
45276: PUSH
45277: LD_INT 15
45279: PUSH
45280: LD_INT 16
45282: PUSH
45283: LD_INT 22
45285: PUSH
45286: LD_INT 23
45288: PUSH
45289: LD_INT 26
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 101
45305: PUSH
45306: LD_INT 102
45308: PUSH
45309: LD_INT 105
45311: PUSH
45312: LD_INT 106
45314: PUSH
45315: LD_INT 108
45317: PUSH
45318: LD_INT 116
45320: PUSH
45321: LD_INT 117
45323: PUSH
45324: LD_INT 118
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: ST_TO_ADDR
45341: GO 48324
45343: LD_INT 3
45345: DOUBLE
45346: EQUAL
45347: IFTRUE 45351
45349: GO 45439
45351: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45352: LD_ADDR_VAR 0 2
45356: PUSH
45357: LD_INT 2
45359: PUSH
45360: LD_INT 4
45362: PUSH
45363: LD_INT 5
45365: PUSH
45366: LD_INT 11
45368: PUSH
45369: LD_INT 12
45371: PUSH
45372: LD_INT 15
45374: PUSH
45375: LD_INT 16
45377: PUSH
45378: LD_INT 22
45380: PUSH
45381: LD_INT 26
45383: PUSH
45384: LD_INT 36
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 101
45401: PUSH
45402: LD_INT 102
45404: PUSH
45405: LD_INT 105
45407: PUSH
45408: LD_INT 106
45410: PUSH
45411: LD_INT 108
45413: PUSH
45414: LD_INT 116
45416: PUSH
45417: LD_INT 117
45419: PUSH
45420: LD_INT 118
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: ST_TO_ADDR
45437: GO 48324
45439: LD_INT 4
45441: DOUBLE
45442: EQUAL
45443: IFTRUE 45447
45445: GO 45543
45447: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45448: LD_ADDR_VAR 0 2
45452: PUSH
45453: LD_INT 2
45455: PUSH
45456: LD_INT 4
45458: PUSH
45459: LD_INT 5
45461: PUSH
45462: LD_INT 8
45464: PUSH
45465: LD_INT 11
45467: PUSH
45468: LD_INT 12
45470: PUSH
45471: LD_INT 15
45473: PUSH
45474: LD_INT 16
45476: PUSH
45477: LD_INT 22
45479: PUSH
45480: LD_INT 23
45482: PUSH
45483: LD_INT 26
45485: PUSH
45486: LD_INT 36
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 101
45505: PUSH
45506: LD_INT 102
45508: PUSH
45509: LD_INT 105
45511: PUSH
45512: LD_INT 106
45514: PUSH
45515: LD_INT 108
45517: PUSH
45518: LD_INT 116
45520: PUSH
45521: LD_INT 117
45523: PUSH
45524: LD_INT 118
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: ST_TO_ADDR
45541: GO 48324
45543: LD_INT 5
45545: DOUBLE
45546: EQUAL
45547: IFTRUE 45551
45549: GO 45663
45551: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45552: LD_ADDR_VAR 0 2
45556: PUSH
45557: LD_INT 2
45559: PUSH
45560: LD_INT 4
45562: PUSH
45563: LD_INT 5
45565: PUSH
45566: LD_INT 6
45568: PUSH
45569: LD_INT 8
45571: PUSH
45572: LD_INT 11
45574: PUSH
45575: LD_INT 12
45577: PUSH
45578: LD_INT 15
45580: PUSH
45581: LD_INT 16
45583: PUSH
45584: LD_INT 22
45586: PUSH
45587: LD_INT 23
45589: PUSH
45590: LD_INT 25
45592: PUSH
45593: LD_INT 26
45595: PUSH
45596: LD_INT 36
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: PUSH
45615: LD_INT 101
45617: PUSH
45618: LD_INT 102
45620: PUSH
45621: LD_INT 105
45623: PUSH
45624: LD_INT 106
45626: PUSH
45627: LD_INT 108
45629: PUSH
45630: LD_INT 109
45632: PUSH
45633: LD_INT 112
45635: PUSH
45636: LD_INT 116
45638: PUSH
45639: LD_INT 117
45641: PUSH
45642: LD_INT 118
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: ST_TO_ADDR
45661: GO 48324
45663: LD_INT 6
45665: DOUBLE
45666: EQUAL
45667: IFTRUE 45671
45669: GO 45803
45671: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45672: LD_ADDR_VAR 0 2
45676: PUSH
45677: LD_INT 2
45679: PUSH
45680: LD_INT 4
45682: PUSH
45683: LD_INT 5
45685: PUSH
45686: LD_INT 6
45688: PUSH
45689: LD_INT 8
45691: PUSH
45692: LD_INT 11
45694: PUSH
45695: LD_INT 12
45697: PUSH
45698: LD_INT 15
45700: PUSH
45701: LD_INT 16
45703: PUSH
45704: LD_INT 20
45706: PUSH
45707: LD_INT 21
45709: PUSH
45710: LD_INT 22
45712: PUSH
45713: LD_INT 23
45715: PUSH
45716: LD_INT 25
45718: PUSH
45719: LD_INT 26
45721: PUSH
45722: LD_INT 30
45724: PUSH
45725: LD_INT 31
45727: PUSH
45728: LD_INT 32
45730: PUSH
45731: LD_INT 36
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 101
45757: PUSH
45758: LD_INT 102
45760: PUSH
45761: LD_INT 105
45763: PUSH
45764: LD_INT 106
45766: PUSH
45767: LD_INT 108
45769: PUSH
45770: LD_INT 109
45772: PUSH
45773: LD_INT 112
45775: PUSH
45776: LD_INT 116
45778: PUSH
45779: LD_INT 117
45781: PUSH
45782: LD_INT 118
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: ST_TO_ADDR
45801: GO 48324
45803: LD_INT 7
45805: DOUBLE
45806: EQUAL
45807: IFTRUE 45811
45809: GO 45923
45811: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45812: LD_ADDR_VAR 0 2
45816: PUSH
45817: LD_INT 2
45819: PUSH
45820: LD_INT 4
45822: PUSH
45823: LD_INT 5
45825: PUSH
45826: LD_INT 7
45828: PUSH
45829: LD_INT 11
45831: PUSH
45832: LD_INT 12
45834: PUSH
45835: LD_INT 15
45837: PUSH
45838: LD_INT 16
45840: PUSH
45841: LD_INT 20
45843: PUSH
45844: LD_INT 21
45846: PUSH
45847: LD_INT 22
45849: PUSH
45850: LD_INT 23
45852: PUSH
45853: LD_INT 25
45855: PUSH
45856: LD_INT 26
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: PUSH
45875: LD_INT 101
45877: PUSH
45878: LD_INT 102
45880: PUSH
45881: LD_INT 103
45883: PUSH
45884: LD_INT 105
45886: PUSH
45887: LD_INT 106
45889: PUSH
45890: LD_INT 108
45892: PUSH
45893: LD_INT 112
45895: PUSH
45896: LD_INT 116
45898: PUSH
45899: LD_INT 117
45901: PUSH
45902: LD_INT 118
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: ST_TO_ADDR
45921: GO 48324
45923: LD_INT 8
45925: DOUBLE
45926: EQUAL
45927: IFTRUE 45931
45929: GO 46071
45931: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45932: LD_ADDR_VAR 0 2
45936: PUSH
45937: LD_INT 2
45939: PUSH
45940: LD_INT 4
45942: PUSH
45943: LD_INT 5
45945: PUSH
45946: LD_INT 6
45948: PUSH
45949: LD_INT 7
45951: PUSH
45952: LD_INT 8
45954: PUSH
45955: LD_INT 11
45957: PUSH
45958: LD_INT 12
45960: PUSH
45961: LD_INT 15
45963: PUSH
45964: LD_INT 16
45966: PUSH
45967: LD_INT 20
45969: PUSH
45970: LD_INT 21
45972: PUSH
45973: LD_INT 22
45975: PUSH
45976: LD_INT 23
45978: PUSH
45979: LD_INT 25
45981: PUSH
45982: LD_INT 26
45984: PUSH
45985: LD_INT 30
45987: PUSH
45988: LD_INT 31
45990: PUSH
45991: LD_INT 32
45993: PUSH
45994: LD_INT 36
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 101
46021: PUSH
46022: LD_INT 102
46024: PUSH
46025: LD_INT 103
46027: PUSH
46028: LD_INT 105
46030: PUSH
46031: LD_INT 106
46033: PUSH
46034: LD_INT 108
46036: PUSH
46037: LD_INT 109
46039: PUSH
46040: LD_INT 112
46042: PUSH
46043: LD_INT 116
46045: PUSH
46046: LD_INT 117
46048: PUSH
46049: LD_INT 118
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: ST_TO_ADDR
46069: GO 48324
46071: LD_INT 9
46073: DOUBLE
46074: EQUAL
46075: IFTRUE 46079
46077: GO 46227
46079: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46080: LD_ADDR_VAR 0 2
46084: PUSH
46085: LD_INT 2
46087: PUSH
46088: LD_INT 4
46090: PUSH
46091: LD_INT 5
46093: PUSH
46094: LD_INT 6
46096: PUSH
46097: LD_INT 7
46099: PUSH
46100: LD_INT 8
46102: PUSH
46103: LD_INT 11
46105: PUSH
46106: LD_INT 12
46108: PUSH
46109: LD_INT 15
46111: PUSH
46112: LD_INT 16
46114: PUSH
46115: LD_INT 20
46117: PUSH
46118: LD_INT 21
46120: PUSH
46121: LD_INT 22
46123: PUSH
46124: LD_INT 23
46126: PUSH
46127: LD_INT 25
46129: PUSH
46130: LD_INT 26
46132: PUSH
46133: LD_INT 28
46135: PUSH
46136: LD_INT 30
46138: PUSH
46139: LD_INT 31
46141: PUSH
46142: LD_INT 32
46144: PUSH
46145: LD_INT 36
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 101
46173: PUSH
46174: LD_INT 102
46176: PUSH
46177: LD_INT 103
46179: PUSH
46180: LD_INT 105
46182: PUSH
46183: LD_INT 106
46185: PUSH
46186: LD_INT 108
46188: PUSH
46189: LD_INT 109
46191: PUSH
46192: LD_INT 112
46194: PUSH
46195: LD_INT 114
46197: PUSH
46198: LD_INT 116
46200: PUSH
46201: LD_INT 117
46203: PUSH
46204: LD_INT 118
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: ST_TO_ADDR
46225: GO 48324
46227: LD_INT 10
46229: DOUBLE
46230: EQUAL
46231: IFTRUE 46235
46233: GO 46431
46235: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46236: LD_ADDR_VAR 0 2
46240: PUSH
46241: LD_INT 2
46243: PUSH
46244: LD_INT 4
46246: PUSH
46247: LD_INT 5
46249: PUSH
46250: LD_INT 6
46252: PUSH
46253: LD_INT 7
46255: PUSH
46256: LD_INT 8
46258: PUSH
46259: LD_INT 9
46261: PUSH
46262: LD_INT 10
46264: PUSH
46265: LD_INT 11
46267: PUSH
46268: LD_INT 12
46270: PUSH
46271: LD_INT 13
46273: PUSH
46274: LD_INT 14
46276: PUSH
46277: LD_INT 15
46279: PUSH
46280: LD_INT 16
46282: PUSH
46283: LD_INT 17
46285: PUSH
46286: LD_INT 18
46288: PUSH
46289: LD_INT 19
46291: PUSH
46292: LD_INT 20
46294: PUSH
46295: LD_INT 21
46297: PUSH
46298: LD_INT 22
46300: PUSH
46301: LD_INT 23
46303: PUSH
46304: LD_INT 24
46306: PUSH
46307: LD_INT 25
46309: PUSH
46310: LD_INT 26
46312: PUSH
46313: LD_INT 28
46315: PUSH
46316: LD_INT 30
46318: PUSH
46319: LD_INT 31
46321: PUSH
46322: LD_INT 32
46324: PUSH
46325: LD_INT 36
46327: PUSH
46328: EMPTY
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: PUSH
46359: LD_INT 101
46361: PUSH
46362: LD_INT 102
46364: PUSH
46365: LD_INT 103
46367: PUSH
46368: LD_INT 104
46370: PUSH
46371: LD_INT 105
46373: PUSH
46374: LD_INT 106
46376: PUSH
46377: LD_INT 107
46379: PUSH
46380: LD_INT 108
46382: PUSH
46383: LD_INT 109
46385: PUSH
46386: LD_INT 110
46388: PUSH
46389: LD_INT 111
46391: PUSH
46392: LD_INT 112
46394: PUSH
46395: LD_INT 114
46397: PUSH
46398: LD_INT 116
46400: PUSH
46401: LD_INT 117
46403: PUSH
46404: LD_INT 118
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: ST_TO_ADDR
46429: GO 48324
46431: LD_INT 11
46433: DOUBLE
46434: EQUAL
46435: IFTRUE 46439
46437: GO 46643
46439: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46440: LD_ADDR_VAR 0 2
46444: PUSH
46445: LD_INT 2
46447: PUSH
46448: LD_INT 3
46450: PUSH
46451: LD_INT 4
46453: PUSH
46454: LD_INT 5
46456: PUSH
46457: LD_INT 6
46459: PUSH
46460: LD_INT 7
46462: PUSH
46463: LD_INT 8
46465: PUSH
46466: LD_INT 9
46468: PUSH
46469: LD_INT 10
46471: PUSH
46472: LD_INT 11
46474: PUSH
46475: LD_INT 12
46477: PUSH
46478: LD_INT 13
46480: PUSH
46481: LD_INT 14
46483: PUSH
46484: LD_INT 15
46486: PUSH
46487: LD_INT 16
46489: PUSH
46490: LD_INT 17
46492: PUSH
46493: LD_INT 18
46495: PUSH
46496: LD_INT 19
46498: PUSH
46499: LD_INT 20
46501: PUSH
46502: LD_INT 21
46504: PUSH
46505: LD_INT 22
46507: PUSH
46508: LD_INT 23
46510: PUSH
46511: LD_INT 24
46513: PUSH
46514: LD_INT 25
46516: PUSH
46517: LD_INT 26
46519: PUSH
46520: LD_INT 28
46522: PUSH
46523: LD_INT 30
46525: PUSH
46526: LD_INT 31
46528: PUSH
46529: LD_INT 32
46531: PUSH
46532: LD_INT 34
46534: PUSH
46535: LD_INT 36
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 101
46573: PUSH
46574: LD_INT 102
46576: PUSH
46577: LD_INT 103
46579: PUSH
46580: LD_INT 104
46582: PUSH
46583: LD_INT 105
46585: PUSH
46586: LD_INT 106
46588: PUSH
46589: LD_INT 107
46591: PUSH
46592: LD_INT 108
46594: PUSH
46595: LD_INT 109
46597: PUSH
46598: LD_INT 110
46600: PUSH
46601: LD_INT 111
46603: PUSH
46604: LD_INT 112
46606: PUSH
46607: LD_INT 114
46609: PUSH
46610: LD_INT 116
46612: PUSH
46613: LD_INT 117
46615: PUSH
46616: LD_INT 118
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: ST_TO_ADDR
46641: GO 48324
46643: LD_INT 12
46645: DOUBLE
46646: EQUAL
46647: IFTRUE 46651
46649: GO 46871
46651: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46652: LD_ADDR_VAR 0 2
46656: PUSH
46657: LD_INT 1
46659: PUSH
46660: LD_INT 2
46662: PUSH
46663: LD_INT 3
46665: PUSH
46666: LD_INT 4
46668: PUSH
46669: LD_INT 5
46671: PUSH
46672: LD_INT 6
46674: PUSH
46675: LD_INT 7
46677: PUSH
46678: LD_INT 8
46680: PUSH
46681: LD_INT 9
46683: PUSH
46684: LD_INT 10
46686: PUSH
46687: LD_INT 11
46689: PUSH
46690: LD_INT 12
46692: PUSH
46693: LD_INT 13
46695: PUSH
46696: LD_INT 14
46698: PUSH
46699: LD_INT 15
46701: PUSH
46702: LD_INT 16
46704: PUSH
46705: LD_INT 17
46707: PUSH
46708: LD_INT 18
46710: PUSH
46711: LD_INT 19
46713: PUSH
46714: LD_INT 20
46716: PUSH
46717: LD_INT 21
46719: PUSH
46720: LD_INT 22
46722: PUSH
46723: LD_INT 23
46725: PUSH
46726: LD_INT 24
46728: PUSH
46729: LD_INT 25
46731: PUSH
46732: LD_INT 26
46734: PUSH
46735: LD_INT 27
46737: PUSH
46738: LD_INT 28
46740: PUSH
46741: LD_INT 30
46743: PUSH
46744: LD_INT 31
46746: PUSH
46747: LD_INT 32
46749: PUSH
46750: LD_INT 33
46752: PUSH
46753: LD_INT 34
46755: PUSH
46756: LD_INT 36
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: PUSH
46795: LD_INT 101
46797: PUSH
46798: LD_INT 102
46800: PUSH
46801: LD_INT 103
46803: PUSH
46804: LD_INT 104
46806: PUSH
46807: LD_INT 105
46809: PUSH
46810: LD_INT 106
46812: PUSH
46813: LD_INT 107
46815: PUSH
46816: LD_INT 108
46818: PUSH
46819: LD_INT 109
46821: PUSH
46822: LD_INT 110
46824: PUSH
46825: LD_INT 111
46827: PUSH
46828: LD_INT 112
46830: PUSH
46831: LD_INT 113
46833: PUSH
46834: LD_INT 114
46836: PUSH
46837: LD_INT 116
46839: PUSH
46840: LD_INT 117
46842: PUSH
46843: LD_INT 118
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: LIST
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: ST_TO_ADDR
46869: GO 48324
46871: LD_INT 13
46873: DOUBLE
46874: EQUAL
46875: IFTRUE 46879
46877: GO 47087
46879: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46880: LD_ADDR_VAR 0 2
46884: PUSH
46885: LD_INT 1
46887: PUSH
46888: LD_INT 2
46890: PUSH
46891: LD_INT 3
46893: PUSH
46894: LD_INT 4
46896: PUSH
46897: LD_INT 5
46899: PUSH
46900: LD_INT 8
46902: PUSH
46903: LD_INT 9
46905: PUSH
46906: LD_INT 10
46908: PUSH
46909: LD_INT 11
46911: PUSH
46912: LD_INT 12
46914: PUSH
46915: LD_INT 14
46917: PUSH
46918: LD_INT 15
46920: PUSH
46921: LD_INT 16
46923: PUSH
46924: LD_INT 17
46926: PUSH
46927: LD_INT 18
46929: PUSH
46930: LD_INT 19
46932: PUSH
46933: LD_INT 20
46935: PUSH
46936: LD_INT 21
46938: PUSH
46939: LD_INT 22
46941: PUSH
46942: LD_INT 23
46944: PUSH
46945: LD_INT 24
46947: PUSH
46948: LD_INT 25
46950: PUSH
46951: LD_INT 26
46953: PUSH
46954: LD_INT 27
46956: PUSH
46957: LD_INT 28
46959: PUSH
46960: LD_INT 30
46962: PUSH
46963: LD_INT 31
46965: PUSH
46966: LD_INT 32
46968: PUSH
46969: LD_INT 33
46971: PUSH
46972: LD_INT 34
46974: PUSH
46975: LD_INT 36
46977: PUSH
46978: EMPTY
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 101
47013: PUSH
47014: LD_INT 102
47016: PUSH
47017: LD_INT 103
47019: PUSH
47020: LD_INT 104
47022: PUSH
47023: LD_INT 105
47025: PUSH
47026: LD_INT 106
47028: PUSH
47029: LD_INT 107
47031: PUSH
47032: LD_INT 108
47034: PUSH
47035: LD_INT 109
47037: PUSH
47038: LD_INT 110
47040: PUSH
47041: LD_INT 111
47043: PUSH
47044: LD_INT 112
47046: PUSH
47047: LD_INT 113
47049: PUSH
47050: LD_INT 114
47052: PUSH
47053: LD_INT 116
47055: PUSH
47056: LD_INT 117
47058: PUSH
47059: LD_INT 118
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: ST_TO_ADDR
47085: GO 48324
47087: LD_INT 14
47089: DOUBLE
47090: EQUAL
47091: IFTRUE 47095
47093: GO 47319
47095: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47096: LD_ADDR_VAR 0 2
47100: PUSH
47101: LD_INT 1
47103: PUSH
47104: LD_INT 2
47106: PUSH
47107: LD_INT 3
47109: PUSH
47110: LD_INT 4
47112: PUSH
47113: LD_INT 5
47115: PUSH
47116: LD_INT 6
47118: PUSH
47119: LD_INT 7
47121: PUSH
47122: LD_INT 8
47124: PUSH
47125: LD_INT 9
47127: PUSH
47128: LD_INT 10
47130: PUSH
47131: LD_INT 11
47133: PUSH
47134: LD_INT 12
47136: PUSH
47137: LD_INT 13
47139: PUSH
47140: LD_INT 14
47142: PUSH
47143: LD_INT 15
47145: PUSH
47146: LD_INT 16
47148: PUSH
47149: LD_INT 17
47151: PUSH
47152: LD_INT 18
47154: PUSH
47155: LD_INT 19
47157: PUSH
47158: LD_INT 20
47160: PUSH
47161: LD_INT 21
47163: PUSH
47164: LD_INT 22
47166: PUSH
47167: LD_INT 23
47169: PUSH
47170: LD_INT 24
47172: PUSH
47173: LD_INT 25
47175: PUSH
47176: LD_INT 26
47178: PUSH
47179: LD_INT 27
47181: PUSH
47182: LD_INT 28
47184: PUSH
47185: LD_INT 29
47187: PUSH
47188: LD_INT 30
47190: PUSH
47191: LD_INT 31
47193: PUSH
47194: LD_INT 32
47196: PUSH
47197: LD_INT 33
47199: PUSH
47200: LD_INT 34
47202: PUSH
47203: LD_INT 36
47205: PUSH
47206: EMPTY
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: PUSH
47243: LD_INT 101
47245: PUSH
47246: LD_INT 102
47248: PUSH
47249: LD_INT 103
47251: PUSH
47252: LD_INT 104
47254: PUSH
47255: LD_INT 105
47257: PUSH
47258: LD_INT 106
47260: PUSH
47261: LD_INT 107
47263: PUSH
47264: LD_INT 108
47266: PUSH
47267: LD_INT 109
47269: PUSH
47270: LD_INT 110
47272: PUSH
47273: LD_INT 111
47275: PUSH
47276: LD_INT 112
47278: PUSH
47279: LD_INT 113
47281: PUSH
47282: LD_INT 114
47284: PUSH
47285: LD_INT 116
47287: PUSH
47288: LD_INT 117
47290: PUSH
47291: LD_INT 118
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: ST_TO_ADDR
47317: GO 48324
47319: LD_INT 15
47321: DOUBLE
47322: EQUAL
47323: IFTRUE 47327
47325: GO 47551
47327: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47328: LD_ADDR_VAR 0 2
47332: PUSH
47333: LD_INT 1
47335: PUSH
47336: LD_INT 2
47338: PUSH
47339: LD_INT 3
47341: PUSH
47342: LD_INT 4
47344: PUSH
47345: LD_INT 5
47347: PUSH
47348: LD_INT 6
47350: PUSH
47351: LD_INT 7
47353: PUSH
47354: LD_INT 8
47356: PUSH
47357: LD_INT 9
47359: PUSH
47360: LD_INT 10
47362: PUSH
47363: LD_INT 11
47365: PUSH
47366: LD_INT 12
47368: PUSH
47369: LD_INT 13
47371: PUSH
47372: LD_INT 14
47374: PUSH
47375: LD_INT 15
47377: PUSH
47378: LD_INT 16
47380: PUSH
47381: LD_INT 17
47383: PUSH
47384: LD_INT 18
47386: PUSH
47387: LD_INT 19
47389: PUSH
47390: LD_INT 20
47392: PUSH
47393: LD_INT 21
47395: PUSH
47396: LD_INT 22
47398: PUSH
47399: LD_INT 23
47401: PUSH
47402: LD_INT 24
47404: PUSH
47405: LD_INT 25
47407: PUSH
47408: LD_INT 26
47410: PUSH
47411: LD_INT 27
47413: PUSH
47414: LD_INT 28
47416: PUSH
47417: LD_INT 29
47419: PUSH
47420: LD_INT 30
47422: PUSH
47423: LD_INT 31
47425: PUSH
47426: LD_INT 32
47428: PUSH
47429: LD_INT 33
47431: PUSH
47432: LD_INT 34
47434: PUSH
47435: LD_INT 36
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: PUSH
47475: LD_INT 101
47477: PUSH
47478: LD_INT 102
47480: PUSH
47481: LD_INT 103
47483: PUSH
47484: LD_INT 104
47486: PUSH
47487: LD_INT 105
47489: PUSH
47490: LD_INT 106
47492: PUSH
47493: LD_INT 107
47495: PUSH
47496: LD_INT 108
47498: PUSH
47499: LD_INT 109
47501: PUSH
47502: LD_INT 110
47504: PUSH
47505: LD_INT 111
47507: PUSH
47508: LD_INT 112
47510: PUSH
47511: LD_INT 113
47513: PUSH
47514: LD_INT 114
47516: PUSH
47517: LD_INT 116
47519: PUSH
47520: LD_INT 117
47522: PUSH
47523: LD_INT 118
47525: PUSH
47526: EMPTY
47527: LIST
47528: LIST
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: LIST
47537: LIST
47538: LIST
47539: LIST
47540: LIST
47541: LIST
47542: LIST
47543: LIST
47544: PUSH
47545: EMPTY
47546: LIST
47547: LIST
47548: ST_TO_ADDR
47549: GO 48324
47551: LD_INT 16
47553: DOUBLE
47554: EQUAL
47555: IFTRUE 47559
47557: GO 47695
47559: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47560: LD_ADDR_VAR 0 2
47564: PUSH
47565: LD_INT 2
47567: PUSH
47568: LD_INT 4
47570: PUSH
47571: LD_INT 5
47573: PUSH
47574: LD_INT 7
47576: PUSH
47577: LD_INT 11
47579: PUSH
47580: LD_INT 12
47582: PUSH
47583: LD_INT 15
47585: PUSH
47586: LD_INT 16
47588: PUSH
47589: LD_INT 20
47591: PUSH
47592: LD_INT 21
47594: PUSH
47595: LD_INT 22
47597: PUSH
47598: LD_INT 23
47600: PUSH
47601: LD_INT 25
47603: PUSH
47604: LD_INT 26
47606: PUSH
47607: LD_INT 30
47609: PUSH
47610: LD_INT 31
47612: PUSH
47613: LD_INT 32
47615: PUSH
47616: LD_INT 33
47618: PUSH
47619: LD_INT 34
47621: PUSH
47622: EMPTY
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: PUSH
47643: LD_INT 101
47645: PUSH
47646: LD_INT 102
47648: PUSH
47649: LD_INT 103
47651: PUSH
47652: LD_INT 106
47654: PUSH
47655: LD_INT 108
47657: PUSH
47658: LD_INT 112
47660: PUSH
47661: LD_INT 113
47663: PUSH
47664: LD_INT 114
47666: PUSH
47667: LD_INT 116
47669: PUSH
47670: LD_INT 117
47672: PUSH
47673: LD_INT 118
47675: PUSH
47676: EMPTY
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: LIST
47687: LIST
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: ST_TO_ADDR
47693: GO 48324
47695: LD_INT 17
47697: DOUBLE
47698: EQUAL
47699: IFTRUE 47703
47701: GO 47927
47703: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47704: LD_ADDR_VAR 0 2
47708: PUSH
47709: LD_INT 1
47711: PUSH
47712: LD_INT 2
47714: PUSH
47715: LD_INT 3
47717: PUSH
47718: LD_INT 4
47720: PUSH
47721: LD_INT 5
47723: PUSH
47724: LD_INT 6
47726: PUSH
47727: LD_INT 7
47729: PUSH
47730: LD_INT 8
47732: PUSH
47733: LD_INT 9
47735: PUSH
47736: LD_INT 10
47738: PUSH
47739: LD_INT 11
47741: PUSH
47742: LD_INT 12
47744: PUSH
47745: LD_INT 13
47747: PUSH
47748: LD_INT 14
47750: PUSH
47751: LD_INT 15
47753: PUSH
47754: LD_INT 16
47756: PUSH
47757: LD_INT 17
47759: PUSH
47760: LD_INT 18
47762: PUSH
47763: LD_INT 19
47765: PUSH
47766: LD_INT 20
47768: PUSH
47769: LD_INT 21
47771: PUSH
47772: LD_INT 22
47774: PUSH
47775: LD_INT 23
47777: PUSH
47778: LD_INT 24
47780: PUSH
47781: LD_INT 25
47783: PUSH
47784: LD_INT 26
47786: PUSH
47787: LD_INT 27
47789: PUSH
47790: LD_INT 28
47792: PUSH
47793: LD_INT 29
47795: PUSH
47796: LD_INT 30
47798: PUSH
47799: LD_INT 31
47801: PUSH
47802: LD_INT 32
47804: PUSH
47805: LD_INT 33
47807: PUSH
47808: LD_INT 34
47810: PUSH
47811: LD_INT 36
47813: PUSH
47814: EMPTY
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: PUSH
47851: LD_INT 101
47853: PUSH
47854: LD_INT 102
47856: PUSH
47857: LD_INT 103
47859: PUSH
47860: LD_INT 104
47862: PUSH
47863: LD_INT 105
47865: PUSH
47866: LD_INT 106
47868: PUSH
47869: LD_INT 107
47871: PUSH
47872: LD_INT 108
47874: PUSH
47875: LD_INT 109
47877: PUSH
47878: LD_INT 110
47880: PUSH
47881: LD_INT 111
47883: PUSH
47884: LD_INT 112
47886: PUSH
47887: LD_INT 113
47889: PUSH
47890: LD_INT 114
47892: PUSH
47893: LD_INT 116
47895: PUSH
47896: LD_INT 117
47898: PUSH
47899: LD_INT 118
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: LIST
47918: LIST
47919: LIST
47920: PUSH
47921: EMPTY
47922: LIST
47923: LIST
47924: ST_TO_ADDR
47925: GO 48324
47927: LD_INT 18
47929: DOUBLE
47930: EQUAL
47931: IFTRUE 47935
47933: GO 48083
47935: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47936: LD_ADDR_VAR 0 2
47940: PUSH
47941: LD_INT 2
47943: PUSH
47944: LD_INT 4
47946: PUSH
47947: LD_INT 5
47949: PUSH
47950: LD_INT 7
47952: PUSH
47953: LD_INT 11
47955: PUSH
47956: LD_INT 12
47958: PUSH
47959: LD_INT 15
47961: PUSH
47962: LD_INT 16
47964: PUSH
47965: LD_INT 20
47967: PUSH
47968: LD_INT 21
47970: PUSH
47971: LD_INT 22
47973: PUSH
47974: LD_INT 23
47976: PUSH
47977: LD_INT 25
47979: PUSH
47980: LD_INT 26
47982: PUSH
47983: LD_INT 30
47985: PUSH
47986: LD_INT 31
47988: PUSH
47989: LD_INT 32
47991: PUSH
47992: LD_INT 33
47994: PUSH
47995: LD_INT 34
47997: PUSH
47998: LD_INT 35
48000: PUSH
48001: LD_INT 36
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 101
48029: PUSH
48030: LD_INT 102
48032: PUSH
48033: LD_INT 103
48035: PUSH
48036: LD_INT 106
48038: PUSH
48039: LD_INT 108
48041: PUSH
48042: LD_INT 112
48044: PUSH
48045: LD_INT 113
48047: PUSH
48048: LD_INT 114
48050: PUSH
48051: LD_INT 115
48053: PUSH
48054: LD_INT 116
48056: PUSH
48057: LD_INT 117
48059: PUSH
48060: LD_INT 118
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: PUSH
48077: EMPTY
48078: LIST
48079: LIST
48080: ST_TO_ADDR
48081: GO 48324
48083: LD_INT 19
48085: DOUBLE
48086: EQUAL
48087: IFTRUE 48091
48089: GO 48323
48091: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48092: LD_ADDR_VAR 0 2
48096: PUSH
48097: LD_INT 1
48099: PUSH
48100: LD_INT 2
48102: PUSH
48103: LD_INT 3
48105: PUSH
48106: LD_INT 4
48108: PUSH
48109: LD_INT 5
48111: PUSH
48112: LD_INT 6
48114: PUSH
48115: LD_INT 7
48117: PUSH
48118: LD_INT 8
48120: PUSH
48121: LD_INT 9
48123: PUSH
48124: LD_INT 10
48126: PUSH
48127: LD_INT 11
48129: PUSH
48130: LD_INT 12
48132: PUSH
48133: LD_INT 13
48135: PUSH
48136: LD_INT 14
48138: PUSH
48139: LD_INT 15
48141: PUSH
48142: LD_INT 16
48144: PUSH
48145: LD_INT 17
48147: PUSH
48148: LD_INT 18
48150: PUSH
48151: LD_INT 19
48153: PUSH
48154: LD_INT 20
48156: PUSH
48157: LD_INT 21
48159: PUSH
48160: LD_INT 22
48162: PUSH
48163: LD_INT 23
48165: PUSH
48166: LD_INT 24
48168: PUSH
48169: LD_INT 25
48171: PUSH
48172: LD_INT 26
48174: PUSH
48175: LD_INT 27
48177: PUSH
48178: LD_INT 28
48180: PUSH
48181: LD_INT 29
48183: PUSH
48184: LD_INT 30
48186: PUSH
48187: LD_INT 31
48189: PUSH
48190: LD_INT 32
48192: PUSH
48193: LD_INT 33
48195: PUSH
48196: LD_INT 34
48198: PUSH
48199: LD_INT 35
48201: PUSH
48202: LD_INT 36
48204: PUSH
48205: EMPTY
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 101
48245: PUSH
48246: LD_INT 102
48248: PUSH
48249: LD_INT 103
48251: PUSH
48252: LD_INT 104
48254: PUSH
48255: LD_INT 105
48257: PUSH
48258: LD_INT 106
48260: PUSH
48261: LD_INT 107
48263: PUSH
48264: LD_INT 108
48266: PUSH
48267: LD_INT 109
48269: PUSH
48270: LD_INT 110
48272: PUSH
48273: LD_INT 111
48275: PUSH
48276: LD_INT 112
48278: PUSH
48279: LD_INT 113
48281: PUSH
48282: LD_INT 114
48284: PUSH
48285: LD_INT 115
48287: PUSH
48288: LD_INT 116
48290: PUSH
48291: LD_INT 117
48293: PUSH
48294: LD_INT 118
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: LIST
48306: LIST
48307: LIST
48308: LIST
48309: LIST
48310: LIST
48311: LIST
48312: LIST
48313: LIST
48314: LIST
48315: LIST
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: ST_TO_ADDR
48321: GO 48324
48323: POP
// end else
48324: GO 48555
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48326: LD_ADDR_VAR 0 2
48330: PUSH
48331: LD_INT 1
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: LD_INT 3
48339: PUSH
48340: LD_INT 4
48342: PUSH
48343: LD_INT 5
48345: PUSH
48346: LD_INT 6
48348: PUSH
48349: LD_INT 7
48351: PUSH
48352: LD_INT 8
48354: PUSH
48355: LD_INT 9
48357: PUSH
48358: LD_INT 10
48360: PUSH
48361: LD_INT 11
48363: PUSH
48364: LD_INT 12
48366: PUSH
48367: LD_INT 13
48369: PUSH
48370: LD_INT 14
48372: PUSH
48373: LD_INT 15
48375: PUSH
48376: LD_INT 16
48378: PUSH
48379: LD_INT 17
48381: PUSH
48382: LD_INT 18
48384: PUSH
48385: LD_INT 19
48387: PUSH
48388: LD_INT 20
48390: PUSH
48391: LD_INT 21
48393: PUSH
48394: LD_INT 22
48396: PUSH
48397: LD_INT 23
48399: PUSH
48400: LD_INT 24
48402: PUSH
48403: LD_INT 25
48405: PUSH
48406: LD_INT 26
48408: PUSH
48409: LD_INT 27
48411: PUSH
48412: LD_INT 28
48414: PUSH
48415: LD_INT 29
48417: PUSH
48418: LD_INT 30
48420: PUSH
48421: LD_INT 31
48423: PUSH
48424: LD_INT 32
48426: PUSH
48427: LD_INT 33
48429: PUSH
48430: LD_INT 34
48432: PUSH
48433: LD_INT 35
48435: PUSH
48436: LD_INT 36
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: LIST
48458: LIST
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: LIST
48466: LIST
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: LIST
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 101
48479: PUSH
48480: LD_INT 102
48482: PUSH
48483: LD_INT 103
48485: PUSH
48486: LD_INT 104
48488: PUSH
48489: LD_INT 105
48491: PUSH
48492: LD_INT 106
48494: PUSH
48495: LD_INT 107
48497: PUSH
48498: LD_INT 108
48500: PUSH
48501: LD_INT 109
48503: PUSH
48504: LD_INT 110
48506: PUSH
48507: LD_INT 111
48509: PUSH
48510: LD_INT 112
48512: PUSH
48513: LD_INT 113
48515: PUSH
48516: LD_INT 114
48518: PUSH
48519: LD_INT 115
48521: PUSH
48522: LD_INT 116
48524: PUSH
48525: LD_INT 117
48527: PUSH
48528: LD_INT 118
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: LIST
48535: LIST
48536: LIST
48537: LIST
48538: LIST
48539: LIST
48540: LIST
48541: LIST
48542: LIST
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: LIST
48549: LIST
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: ST_TO_ADDR
// if result then
48555: LD_VAR 0 2
48559: IFFALSE 49345
// begin normal :=  ;
48561: LD_ADDR_VAR 0 5
48565: PUSH
48566: LD_STRING 
48568: ST_TO_ADDR
// hardcore :=  ;
48569: LD_ADDR_VAR 0 6
48573: PUSH
48574: LD_STRING 
48576: ST_TO_ADDR
// active :=  ;
48577: LD_ADDR_VAR 0 7
48581: PUSH
48582: LD_STRING 
48584: ST_TO_ADDR
// for i = 1 to normalCounter do
48585: LD_ADDR_VAR 0 8
48589: PUSH
48590: DOUBLE
48591: LD_INT 1
48593: DEC
48594: ST_TO_ADDR
48595: LD_EXP 93
48599: PUSH
48600: FOR_TO
48601: IFFALSE 48702
// begin tmp := 0 ;
48603: LD_ADDR_VAR 0 3
48607: PUSH
48608: LD_STRING 0
48610: ST_TO_ADDR
// if result [ 1 ] then
48611: LD_VAR 0 2
48615: PUSH
48616: LD_INT 1
48618: ARRAY
48619: IFFALSE 48684
// if result [ 1 ] [ 1 ] = i then
48621: LD_VAR 0 2
48625: PUSH
48626: LD_INT 1
48628: ARRAY
48629: PUSH
48630: LD_INT 1
48632: ARRAY
48633: PUSH
48634: LD_VAR 0 8
48638: EQUAL
48639: IFFALSE 48684
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48641: LD_ADDR_VAR 0 2
48645: PUSH
48646: LD_VAR 0 2
48650: PPUSH
48651: LD_INT 1
48653: PPUSH
48654: LD_VAR 0 2
48658: PUSH
48659: LD_INT 1
48661: ARRAY
48662: PPUSH
48663: LD_INT 1
48665: PPUSH
48666: CALL_OW 3
48670: PPUSH
48671: CALL_OW 1
48675: ST_TO_ADDR
// tmp := 1 ;
48676: LD_ADDR_VAR 0 3
48680: PUSH
48681: LD_STRING 1
48683: ST_TO_ADDR
// end ; normal := normal & tmp ;
48684: LD_ADDR_VAR 0 5
48688: PUSH
48689: LD_VAR 0 5
48693: PUSH
48694: LD_VAR 0 3
48698: STR
48699: ST_TO_ADDR
// end ;
48700: GO 48600
48702: POP
48703: POP
// for i = 1 to hardcoreCounter do
48704: LD_ADDR_VAR 0 8
48708: PUSH
48709: DOUBLE
48710: LD_INT 1
48712: DEC
48713: ST_TO_ADDR
48714: LD_EXP 94
48718: PUSH
48719: FOR_TO
48720: IFFALSE 48825
// begin tmp := 0 ;
48722: LD_ADDR_VAR 0 3
48726: PUSH
48727: LD_STRING 0
48729: ST_TO_ADDR
// if result [ 2 ] then
48730: LD_VAR 0 2
48734: PUSH
48735: LD_INT 2
48737: ARRAY
48738: IFFALSE 48807
// if result [ 2 ] [ 1 ] = 100 + i then
48740: LD_VAR 0 2
48744: PUSH
48745: LD_INT 2
48747: ARRAY
48748: PUSH
48749: LD_INT 1
48751: ARRAY
48752: PUSH
48753: LD_INT 100
48755: PUSH
48756: LD_VAR 0 8
48760: PLUS
48761: EQUAL
48762: IFFALSE 48807
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48764: LD_ADDR_VAR 0 2
48768: PUSH
48769: LD_VAR 0 2
48773: PPUSH
48774: LD_INT 2
48776: PPUSH
48777: LD_VAR 0 2
48781: PUSH
48782: LD_INT 2
48784: ARRAY
48785: PPUSH
48786: LD_INT 1
48788: PPUSH
48789: CALL_OW 3
48793: PPUSH
48794: CALL_OW 1
48798: ST_TO_ADDR
// tmp := 1 ;
48799: LD_ADDR_VAR 0 3
48803: PUSH
48804: LD_STRING 1
48806: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48807: LD_ADDR_VAR 0 6
48811: PUSH
48812: LD_VAR 0 6
48816: PUSH
48817: LD_VAR 0 3
48821: STR
48822: ST_TO_ADDR
// end ;
48823: GO 48719
48825: POP
48826: POP
// if isGameLoad then
48827: LD_VAR 0 1
48831: IFFALSE 49306
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48833: LD_ADDR_VAR 0 4
48837: PUSH
48838: LD_EXP 97
48842: PUSH
48843: LD_EXP 96
48847: PUSH
48848: LD_EXP 98
48852: PUSH
48853: LD_EXP 95
48857: PUSH
48858: LD_EXP 99
48862: PUSH
48863: LD_EXP 100
48867: PUSH
48868: LD_EXP 101
48872: PUSH
48873: LD_EXP 102
48877: PUSH
48878: LD_EXP 103
48882: PUSH
48883: LD_EXP 104
48887: PUSH
48888: LD_EXP 105
48892: PUSH
48893: LD_EXP 106
48897: PUSH
48898: LD_EXP 107
48902: PUSH
48903: LD_EXP 108
48907: PUSH
48908: LD_EXP 116
48912: PUSH
48913: LD_EXP 117
48917: PUSH
48918: LD_EXP 118
48922: PUSH
48923: LD_EXP 119
48927: PUSH
48928: LD_EXP 121
48932: PUSH
48933: LD_EXP 122
48937: PUSH
48938: LD_EXP 123
48942: PUSH
48943: LD_EXP 126
48947: PUSH
48948: LD_EXP 128
48952: PUSH
48953: LD_EXP 129
48957: PUSH
48958: LD_EXP 130
48962: PUSH
48963: LD_EXP 132
48967: PUSH
48968: LD_EXP 133
48972: PUSH
48973: LD_EXP 136
48977: PUSH
48978: LD_EXP 137
48982: PUSH
48983: LD_EXP 138
48987: PUSH
48988: LD_EXP 139
48992: PUSH
48993: LD_EXP 140
48997: PUSH
48998: LD_EXP 141
49002: PUSH
49003: LD_EXP 142
49007: PUSH
49008: LD_EXP 143
49012: PUSH
49013: LD_EXP 144
49017: PUSH
49018: LD_EXP 109
49022: PUSH
49023: LD_EXP 110
49027: PUSH
49028: LD_EXP 113
49032: PUSH
49033: LD_EXP 114
49037: PUSH
49038: LD_EXP 115
49042: PUSH
49043: LD_EXP 111
49047: PUSH
49048: LD_EXP 112
49052: PUSH
49053: LD_EXP 120
49057: PUSH
49058: LD_EXP 124
49062: PUSH
49063: LD_EXP 125
49067: PUSH
49068: LD_EXP 127
49072: PUSH
49073: LD_EXP 131
49077: PUSH
49078: LD_EXP 134
49082: PUSH
49083: LD_EXP 135
49087: PUSH
49088: LD_EXP 145
49092: PUSH
49093: LD_EXP 146
49097: PUSH
49098: LD_EXP 147
49102: PUSH
49103: LD_EXP 148
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: ST_TO_ADDR
// tmp :=  ;
49164: LD_ADDR_VAR 0 3
49168: PUSH
49169: LD_STRING 
49171: ST_TO_ADDR
// for i = 1 to normalCounter do
49172: LD_ADDR_VAR 0 8
49176: PUSH
49177: DOUBLE
49178: LD_INT 1
49180: DEC
49181: ST_TO_ADDR
49182: LD_EXP 93
49186: PUSH
49187: FOR_TO
49188: IFFALSE 49224
// begin if flags [ i ] then
49190: LD_VAR 0 4
49194: PUSH
49195: LD_VAR 0 8
49199: ARRAY
49200: IFFALSE 49222
// tmp := tmp & i & ; ;
49202: LD_ADDR_VAR 0 3
49206: PUSH
49207: LD_VAR 0 3
49211: PUSH
49212: LD_VAR 0 8
49216: STR
49217: PUSH
49218: LD_STRING ;
49220: STR
49221: ST_TO_ADDR
// end ;
49222: GO 49187
49224: POP
49225: POP
// for i = 1 to hardcoreCounter do
49226: LD_ADDR_VAR 0 8
49230: PUSH
49231: DOUBLE
49232: LD_INT 1
49234: DEC
49235: ST_TO_ADDR
49236: LD_EXP 94
49240: PUSH
49241: FOR_TO
49242: IFFALSE 49288
// begin if flags [ normalCounter + i ] then
49244: LD_VAR 0 4
49248: PUSH
49249: LD_EXP 93
49253: PUSH
49254: LD_VAR 0 8
49258: PLUS
49259: ARRAY
49260: IFFALSE 49286
// tmp := tmp & ( 100 + i ) & ; ;
49262: LD_ADDR_VAR 0 3
49266: PUSH
49267: LD_VAR 0 3
49271: PUSH
49272: LD_INT 100
49274: PUSH
49275: LD_VAR 0 8
49279: PLUS
49280: STR
49281: PUSH
49282: LD_STRING ;
49284: STR
49285: ST_TO_ADDR
// end ;
49286: GO 49241
49288: POP
49289: POP
// if tmp then
49290: LD_VAR 0 3
49294: IFFALSE 49306
// active := tmp ;
49296: LD_ADDR_VAR 0 7
49300: PUSH
49301: LD_VAR 0 3
49305: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49306: LD_STRING getStreamItemsFromMission("
49308: PUSH
49309: LD_VAR 0 5
49313: STR
49314: PUSH
49315: LD_STRING ","
49317: STR
49318: PUSH
49319: LD_VAR 0 6
49323: STR
49324: PUSH
49325: LD_STRING ","
49327: STR
49328: PUSH
49329: LD_VAR 0 7
49333: STR
49334: PUSH
49335: LD_STRING ")
49337: STR
49338: PPUSH
49339: CALL_OW 559
// end else
49343: GO 49352
// ToLua ( getStreamItemsFromMission("","","") ) ;
49345: LD_STRING getStreamItemsFromMission("","","")
49347: PPUSH
49348: CALL_OW 559
// end ;
49352: LD_VAR 0 2
49356: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49357: LD_EXP 92
49361: PUSH
49362: LD_EXP 97
49366: AND
49367: IFFALSE 49491
49369: GO 49371
49371: DISABLE
49372: LD_INT 0
49374: PPUSH
49375: PPUSH
// begin enable ;
49376: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49377: LD_ADDR_VAR 0 2
49381: PUSH
49382: LD_INT 22
49384: PUSH
49385: LD_OWVAR 2
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 2
49396: PUSH
49397: LD_INT 34
49399: PUSH
49400: LD_INT 7
49402: PUSH
49403: EMPTY
49404: LIST
49405: LIST
49406: PUSH
49407: LD_INT 34
49409: PUSH
49410: LD_INT 45
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: PUSH
49417: LD_INT 34
49419: PUSH
49420: LD_INT 28
49422: PUSH
49423: EMPTY
49424: LIST
49425: LIST
49426: PUSH
49427: LD_INT 34
49429: PUSH
49430: LD_INT 47
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: PUSH
49437: EMPTY
49438: LIST
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: PPUSH
49448: CALL_OW 69
49452: ST_TO_ADDR
// if not tmp then
49453: LD_VAR 0 2
49457: NOT
49458: IFFALSE 49462
// exit ;
49460: GO 49491
// for i in tmp do
49462: LD_ADDR_VAR 0 1
49466: PUSH
49467: LD_VAR 0 2
49471: PUSH
49472: FOR_IN
49473: IFFALSE 49489
// begin SetLives ( i , 0 ) ;
49475: LD_VAR 0 1
49479: PPUSH
49480: LD_INT 0
49482: PPUSH
49483: CALL_OW 234
// end ;
49487: GO 49472
49489: POP
49490: POP
// end ;
49491: PPOPN 2
49493: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49494: LD_EXP 92
49498: PUSH
49499: LD_EXP 98
49503: AND
49504: IFFALSE 49588
49506: GO 49508
49508: DISABLE
49509: LD_INT 0
49511: PPUSH
49512: PPUSH
// begin enable ;
49513: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49514: LD_ADDR_VAR 0 2
49518: PUSH
49519: LD_INT 22
49521: PUSH
49522: LD_OWVAR 2
49526: PUSH
49527: EMPTY
49528: LIST
49529: LIST
49530: PUSH
49531: LD_INT 32
49533: PUSH
49534: LD_INT 3
49536: PUSH
49537: EMPTY
49538: LIST
49539: LIST
49540: PUSH
49541: EMPTY
49542: LIST
49543: LIST
49544: PPUSH
49545: CALL_OW 69
49549: ST_TO_ADDR
// if not tmp then
49550: LD_VAR 0 2
49554: NOT
49555: IFFALSE 49559
// exit ;
49557: GO 49588
// for i in tmp do
49559: LD_ADDR_VAR 0 1
49563: PUSH
49564: LD_VAR 0 2
49568: PUSH
49569: FOR_IN
49570: IFFALSE 49586
// begin SetLives ( i , 0 ) ;
49572: LD_VAR 0 1
49576: PPUSH
49577: LD_INT 0
49579: PPUSH
49580: CALL_OW 234
// end ;
49584: GO 49569
49586: POP
49587: POP
// end ;
49588: PPOPN 2
49590: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49591: LD_EXP 92
49595: PUSH
49596: LD_EXP 95
49600: AND
49601: IFFALSE 49694
49603: GO 49605
49605: DISABLE
49606: LD_INT 0
49608: PPUSH
// begin enable ;
49609: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49610: LD_ADDR_VAR 0 1
49614: PUSH
49615: LD_INT 22
49617: PUSH
49618: LD_OWVAR 2
49622: PUSH
49623: EMPTY
49624: LIST
49625: LIST
49626: PUSH
49627: LD_INT 2
49629: PUSH
49630: LD_INT 25
49632: PUSH
49633: LD_INT 5
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: LD_INT 25
49642: PUSH
49643: LD_INT 9
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 25
49652: PUSH
49653: LD_INT 8
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: EMPTY
49661: LIST
49662: LIST
49663: LIST
49664: LIST
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PPUSH
49670: CALL_OW 69
49674: PUSH
49675: FOR_IN
49676: IFFALSE 49692
// begin SetClass ( i , 1 ) ;
49678: LD_VAR 0 1
49682: PPUSH
49683: LD_INT 1
49685: PPUSH
49686: CALL_OW 336
// end ;
49690: GO 49675
49692: POP
49693: POP
// end ;
49694: PPOPN 1
49696: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49697: LD_EXP 92
49701: PUSH
49702: LD_EXP 96
49706: AND
49707: PUSH
49708: LD_OWVAR 65
49712: PUSH
49713: LD_INT 7
49715: LESS
49716: AND
49717: IFFALSE 49731
49719: GO 49721
49721: DISABLE
// begin enable ;
49722: ENABLE
// game_speed := 7 ;
49723: LD_ADDR_OWVAR 65
49727: PUSH
49728: LD_INT 7
49730: ST_TO_ADDR
// end ;
49731: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49732: LD_EXP 92
49736: PUSH
49737: LD_EXP 99
49741: AND
49742: IFFALSE 49944
49744: GO 49746
49746: DISABLE
49747: LD_INT 0
49749: PPUSH
49750: PPUSH
49751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49752: LD_ADDR_VAR 0 3
49756: PUSH
49757: LD_INT 81
49759: PUSH
49760: LD_OWVAR 2
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 21
49771: PUSH
49772: LD_INT 1
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: EMPTY
49780: LIST
49781: LIST
49782: PPUSH
49783: CALL_OW 69
49787: ST_TO_ADDR
// if not tmp then
49788: LD_VAR 0 3
49792: NOT
49793: IFFALSE 49797
// exit ;
49795: GO 49944
// if tmp > 5 then
49797: LD_VAR 0 3
49801: PUSH
49802: LD_INT 5
49804: GREATER
49805: IFFALSE 49817
// k := 5 else
49807: LD_ADDR_VAR 0 2
49811: PUSH
49812: LD_INT 5
49814: ST_TO_ADDR
49815: GO 49827
// k := tmp ;
49817: LD_ADDR_VAR 0 2
49821: PUSH
49822: LD_VAR 0 3
49826: ST_TO_ADDR
// for i := 1 to k do
49827: LD_ADDR_VAR 0 1
49831: PUSH
49832: DOUBLE
49833: LD_INT 1
49835: DEC
49836: ST_TO_ADDR
49837: LD_VAR 0 2
49841: PUSH
49842: FOR_TO
49843: IFFALSE 49942
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49845: LD_VAR 0 3
49849: PUSH
49850: LD_VAR 0 1
49854: ARRAY
49855: PPUSH
49856: LD_VAR 0 1
49860: PUSH
49861: LD_INT 4
49863: MOD
49864: PUSH
49865: LD_INT 1
49867: PLUS
49868: PPUSH
49869: CALL_OW 259
49873: PUSH
49874: LD_INT 10
49876: LESS
49877: IFFALSE 49940
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49879: LD_VAR 0 3
49883: PUSH
49884: LD_VAR 0 1
49888: ARRAY
49889: PPUSH
49890: LD_VAR 0 1
49894: PUSH
49895: LD_INT 4
49897: MOD
49898: PUSH
49899: LD_INT 1
49901: PLUS
49902: PPUSH
49903: LD_VAR 0 3
49907: PUSH
49908: LD_VAR 0 1
49912: ARRAY
49913: PPUSH
49914: LD_VAR 0 1
49918: PUSH
49919: LD_INT 4
49921: MOD
49922: PUSH
49923: LD_INT 1
49925: PLUS
49926: PPUSH
49927: CALL_OW 259
49931: PUSH
49932: LD_INT 1
49934: PLUS
49935: PPUSH
49936: CALL_OW 237
49940: GO 49842
49942: POP
49943: POP
// end ;
49944: PPOPN 3
49946: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49947: LD_EXP 92
49951: PUSH
49952: LD_EXP 100
49956: AND
49957: IFFALSE 49977
49959: GO 49961
49961: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49962: LD_INT 4
49964: PPUSH
49965: LD_OWVAR 2
49969: PPUSH
49970: LD_INT 0
49972: PPUSH
49973: CALL_OW 324
49977: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49978: LD_EXP 92
49982: PUSH
49983: LD_EXP 129
49987: AND
49988: IFFALSE 50008
49990: GO 49992
49992: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49993: LD_INT 19
49995: PPUSH
49996: LD_OWVAR 2
50000: PPUSH
50001: LD_INT 0
50003: PPUSH
50004: CALL_OW 324
50008: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
50009: LD_EXP 92
50013: PUSH
50014: LD_EXP 101
50018: AND
50019: IFFALSE 50121
50021: GO 50023
50023: DISABLE
50024: LD_INT 0
50026: PPUSH
50027: PPUSH
// begin enable ;
50028: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
50029: LD_ADDR_VAR 0 2
50033: PUSH
50034: LD_INT 22
50036: PUSH
50037: LD_OWVAR 2
50041: PUSH
50042: EMPTY
50043: LIST
50044: LIST
50045: PUSH
50046: LD_INT 2
50048: PUSH
50049: LD_INT 34
50051: PUSH
50052: LD_INT 11
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PUSH
50059: LD_INT 34
50061: PUSH
50062: LD_INT 30
50064: PUSH
50065: EMPTY
50066: LIST
50067: LIST
50068: PUSH
50069: EMPTY
50070: LIST
50071: LIST
50072: LIST
50073: PUSH
50074: EMPTY
50075: LIST
50076: LIST
50077: PPUSH
50078: CALL_OW 69
50082: ST_TO_ADDR
// if not tmp then
50083: LD_VAR 0 2
50087: NOT
50088: IFFALSE 50092
// exit ;
50090: GO 50121
// for i in tmp do
50092: LD_ADDR_VAR 0 1
50096: PUSH
50097: LD_VAR 0 2
50101: PUSH
50102: FOR_IN
50103: IFFALSE 50119
// begin SetLives ( i , 0 ) ;
50105: LD_VAR 0 1
50109: PPUSH
50110: LD_INT 0
50112: PPUSH
50113: CALL_OW 234
// end ;
50117: GO 50102
50119: POP
50120: POP
// end ;
50121: PPOPN 2
50123: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50124: LD_EXP 92
50128: PUSH
50129: LD_EXP 102
50133: AND
50134: IFFALSE 50154
50136: GO 50138
50138: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50139: LD_INT 32
50141: PPUSH
50142: LD_OWVAR 2
50146: PPUSH
50147: LD_INT 0
50149: PPUSH
50150: CALL_OW 324
50154: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50155: LD_EXP 92
50159: PUSH
50160: LD_EXP 103
50164: AND
50165: IFFALSE 50346
50167: GO 50169
50169: DISABLE
50170: LD_INT 0
50172: PPUSH
50173: PPUSH
50174: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50175: LD_ADDR_VAR 0 2
50179: PUSH
50180: LD_INT 22
50182: PUSH
50183: LD_OWVAR 2
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: PUSH
50192: LD_INT 33
50194: PUSH
50195: LD_INT 3
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PPUSH
50206: CALL_OW 69
50210: ST_TO_ADDR
// if not tmp then
50211: LD_VAR 0 2
50215: NOT
50216: IFFALSE 50220
// exit ;
50218: GO 50346
// side := 0 ;
50220: LD_ADDR_VAR 0 3
50224: PUSH
50225: LD_INT 0
50227: ST_TO_ADDR
// for i := 1 to 8 do
50228: LD_ADDR_VAR 0 1
50232: PUSH
50233: DOUBLE
50234: LD_INT 1
50236: DEC
50237: ST_TO_ADDR
50238: LD_INT 8
50240: PUSH
50241: FOR_TO
50242: IFFALSE 50290
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50244: LD_OWVAR 2
50248: PUSH
50249: LD_VAR 0 1
50253: NONEQUAL
50254: PUSH
50255: LD_OWVAR 2
50259: PPUSH
50260: LD_VAR 0 1
50264: PPUSH
50265: CALL_OW 81
50269: PUSH
50270: LD_INT 2
50272: EQUAL
50273: AND
50274: IFFALSE 50288
// begin side := i ;
50276: LD_ADDR_VAR 0 3
50280: PUSH
50281: LD_VAR 0 1
50285: ST_TO_ADDR
// break ;
50286: GO 50290
// end ;
50288: GO 50241
50290: POP
50291: POP
// if not side then
50292: LD_VAR 0 3
50296: NOT
50297: IFFALSE 50301
// exit ;
50299: GO 50346
// for i := 1 to tmp do
50301: LD_ADDR_VAR 0 1
50305: PUSH
50306: DOUBLE
50307: LD_INT 1
50309: DEC
50310: ST_TO_ADDR
50311: LD_VAR 0 2
50315: PUSH
50316: FOR_TO
50317: IFFALSE 50344
// if Prob ( 60 ) then
50319: LD_INT 60
50321: PPUSH
50322: CALL_OW 13
50326: IFFALSE 50342
// SetSide ( i , side ) ;
50328: LD_VAR 0 1
50332: PPUSH
50333: LD_VAR 0 3
50337: PPUSH
50338: CALL_OW 235
50342: GO 50316
50344: POP
50345: POP
// end ;
50346: PPOPN 3
50348: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50349: LD_EXP 92
50353: PUSH
50354: LD_EXP 105
50358: AND
50359: IFFALSE 50478
50361: GO 50363
50363: DISABLE
50364: LD_INT 0
50366: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50367: LD_ADDR_VAR 0 1
50371: PUSH
50372: LD_INT 22
50374: PUSH
50375: LD_OWVAR 2
50379: PUSH
50380: EMPTY
50381: LIST
50382: LIST
50383: PUSH
50384: LD_INT 21
50386: PUSH
50387: LD_INT 1
50389: PUSH
50390: EMPTY
50391: LIST
50392: LIST
50393: PUSH
50394: LD_INT 3
50396: PUSH
50397: LD_INT 23
50399: PUSH
50400: LD_INT 0
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: PUSH
50407: EMPTY
50408: LIST
50409: LIST
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: LIST
50415: PPUSH
50416: CALL_OW 69
50420: PUSH
50421: FOR_IN
50422: IFFALSE 50476
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50424: LD_VAR 0 1
50428: PPUSH
50429: CALL_OW 257
50433: PUSH
50434: LD_INT 1
50436: PUSH
50437: LD_INT 2
50439: PUSH
50440: LD_INT 3
50442: PUSH
50443: LD_INT 4
50445: PUSH
50446: EMPTY
50447: LIST
50448: LIST
50449: LIST
50450: LIST
50451: IN
50452: IFFALSE 50474
// SetClass ( un , rand ( 1 , 4 ) ) ;
50454: LD_VAR 0 1
50458: PPUSH
50459: LD_INT 1
50461: PPUSH
50462: LD_INT 4
50464: PPUSH
50465: CALL_OW 12
50469: PPUSH
50470: CALL_OW 336
50474: GO 50421
50476: POP
50477: POP
// end ;
50478: PPOPN 1
50480: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50481: LD_EXP 92
50485: PUSH
50486: LD_EXP 104
50490: AND
50491: IFFALSE 50570
50493: GO 50495
50495: DISABLE
50496: LD_INT 0
50498: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50499: LD_ADDR_VAR 0 1
50503: PUSH
50504: LD_INT 22
50506: PUSH
50507: LD_OWVAR 2
50511: PUSH
50512: EMPTY
50513: LIST
50514: LIST
50515: PUSH
50516: LD_INT 21
50518: PUSH
50519: LD_INT 3
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: PUSH
50526: EMPTY
50527: LIST
50528: LIST
50529: PPUSH
50530: CALL_OW 69
50534: ST_TO_ADDR
// if not tmp then
50535: LD_VAR 0 1
50539: NOT
50540: IFFALSE 50544
// exit ;
50542: GO 50570
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50544: LD_VAR 0 1
50548: PUSH
50549: LD_INT 1
50551: PPUSH
50552: LD_VAR 0 1
50556: PPUSH
50557: CALL_OW 12
50561: ARRAY
50562: PPUSH
50563: LD_INT 100
50565: PPUSH
50566: CALL_OW 234
// end ;
50570: PPOPN 1
50572: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50573: LD_EXP 92
50577: PUSH
50578: LD_EXP 106
50582: AND
50583: IFFALSE 50681
50585: GO 50587
50587: DISABLE
50588: LD_INT 0
50590: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50591: LD_ADDR_VAR 0 1
50595: PUSH
50596: LD_INT 22
50598: PUSH
50599: LD_OWVAR 2
50603: PUSH
50604: EMPTY
50605: LIST
50606: LIST
50607: PUSH
50608: LD_INT 21
50610: PUSH
50611: LD_INT 1
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PPUSH
50622: CALL_OW 69
50626: ST_TO_ADDR
// if not tmp then
50627: LD_VAR 0 1
50631: NOT
50632: IFFALSE 50636
// exit ;
50634: GO 50681
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50636: LD_VAR 0 1
50640: PUSH
50641: LD_INT 1
50643: PPUSH
50644: LD_VAR 0 1
50648: PPUSH
50649: CALL_OW 12
50653: ARRAY
50654: PPUSH
50655: LD_INT 1
50657: PPUSH
50658: LD_INT 4
50660: PPUSH
50661: CALL_OW 12
50665: PPUSH
50666: LD_INT 3000
50668: PPUSH
50669: LD_INT 9000
50671: PPUSH
50672: CALL_OW 12
50676: PPUSH
50677: CALL_OW 492
// end ;
50681: PPOPN 1
50683: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50684: LD_EXP 92
50688: PUSH
50689: LD_EXP 107
50693: AND
50694: IFFALSE 50714
50696: GO 50698
50698: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50699: LD_INT 1
50701: PPUSH
50702: LD_OWVAR 2
50706: PPUSH
50707: LD_INT 0
50709: PPUSH
50710: CALL_OW 324
50714: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50715: LD_EXP 92
50719: PUSH
50720: LD_EXP 108
50724: AND
50725: IFFALSE 50808
50727: GO 50729
50729: DISABLE
50730: LD_INT 0
50732: PPUSH
50733: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50734: LD_ADDR_VAR 0 2
50738: PUSH
50739: LD_INT 22
50741: PUSH
50742: LD_OWVAR 2
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PUSH
50751: LD_INT 21
50753: PUSH
50754: LD_INT 3
50756: PUSH
50757: EMPTY
50758: LIST
50759: LIST
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PPUSH
50765: CALL_OW 69
50769: ST_TO_ADDR
// if not tmp then
50770: LD_VAR 0 2
50774: NOT
50775: IFFALSE 50779
// exit ;
50777: GO 50808
// for i in tmp do
50779: LD_ADDR_VAR 0 1
50783: PUSH
50784: LD_VAR 0 2
50788: PUSH
50789: FOR_IN
50790: IFFALSE 50806
// SetBLevel ( i , 10 ) ;
50792: LD_VAR 0 1
50796: PPUSH
50797: LD_INT 10
50799: PPUSH
50800: CALL_OW 241
50804: GO 50789
50806: POP
50807: POP
// end ;
50808: PPOPN 2
50810: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50811: LD_EXP 92
50815: PUSH
50816: LD_EXP 109
50820: AND
50821: IFFALSE 50932
50823: GO 50825
50825: DISABLE
50826: LD_INT 0
50828: PPUSH
50829: PPUSH
50830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50831: LD_ADDR_VAR 0 3
50835: PUSH
50836: LD_INT 22
50838: PUSH
50839: LD_OWVAR 2
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 25
50850: PUSH
50851: LD_INT 1
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: PPUSH
50862: CALL_OW 69
50866: ST_TO_ADDR
// if not tmp then
50867: LD_VAR 0 3
50871: NOT
50872: IFFALSE 50876
// exit ;
50874: GO 50932
// un := tmp [ rand ( 1 , tmp ) ] ;
50876: LD_ADDR_VAR 0 2
50880: PUSH
50881: LD_VAR 0 3
50885: PUSH
50886: LD_INT 1
50888: PPUSH
50889: LD_VAR 0 3
50893: PPUSH
50894: CALL_OW 12
50898: ARRAY
50899: ST_TO_ADDR
// if Crawls ( un ) then
50900: LD_VAR 0 2
50904: PPUSH
50905: CALL_OW 318
50909: IFFALSE 50920
// ComWalk ( un ) ;
50911: LD_VAR 0 2
50915: PPUSH
50916: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50920: LD_VAR 0 2
50924: PPUSH
50925: LD_INT 5
50927: PPUSH
50928: CALL_OW 336
// end ;
50932: PPOPN 3
50934: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50935: LD_EXP 92
50939: PUSH
50940: LD_EXP 110
50944: AND
50945: PUSH
50946: LD_OWVAR 67
50950: PUSH
50951: LD_INT 4
50953: LESS
50954: AND
50955: IFFALSE 50974
50957: GO 50959
50959: DISABLE
// begin Difficulty := Difficulty + 1 ;
50960: LD_ADDR_OWVAR 67
50964: PUSH
50965: LD_OWVAR 67
50969: PUSH
50970: LD_INT 1
50972: PLUS
50973: ST_TO_ADDR
// end ;
50974: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50975: LD_EXP 92
50979: PUSH
50980: LD_EXP 111
50984: AND
50985: IFFALSE 51088
50987: GO 50989
50989: DISABLE
50990: LD_INT 0
50992: PPUSH
// begin for i := 1 to 5 do
50993: LD_ADDR_VAR 0 1
50997: PUSH
50998: DOUBLE
50999: LD_INT 1
51001: DEC
51002: ST_TO_ADDR
51003: LD_INT 5
51005: PUSH
51006: FOR_TO
51007: IFFALSE 51086
// begin uc_nation := nation_nature ;
51009: LD_ADDR_OWVAR 21
51013: PUSH
51014: LD_INT 0
51016: ST_TO_ADDR
// uc_side := 0 ;
51017: LD_ADDR_OWVAR 20
51021: PUSH
51022: LD_INT 0
51024: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51025: LD_ADDR_OWVAR 29
51029: PUSH
51030: LD_INT 12
51032: PUSH
51033: LD_INT 12
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: ST_TO_ADDR
// hc_agressivity := 20 ;
51040: LD_ADDR_OWVAR 35
51044: PUSH
51045: LD_INT 20
51047: ST_TO_ADDR
// hc_class := class_tiger ;
51048: LD_ADDR_OWVAR 28
51052: PUSH
51053: LD_INT 14
51055: ST_TO_ADDR
// hc_gallery :=  ;
51056: LD_ADDR_OWVAR 33
51060: PUSH
51061: LD_STRING 
51063: ST_TO_ADDR
// hc_name :=  ;
51064: LD_ADDR_OWVAR 26
51068: PUSH
51069: LD_STRING 
51071: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51072: CALL_OW 44
51076: PPUSH
51077: LD_INT 0
51079: PPUSH
51080: CALL_OW 51
// end ;
51084: GO 51006
51086: POP
51087: POP
// end ;
51088: PPOPN 1
51090: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51091: LD_EXP 92
51095: PUSH
51096: LD_EXP 112
51100: AND
51101: IFFALSE 51110
51103: GO 51105
51105: DISABLE
// StreamSibBomb ;
51106: CALL 51111 0 0
51110: END
// export function StreamSibBomb ; var i , x , y ; begin
51111: LD_INT 0
51113: PPUSH
51114: PPUSH
51115: PPUSH
51116: PPUSH
// result := false ;
51117: LD_ADDR_VAR 0 1
51121: PUSH
51122: LD_INT 0
51124: ST_TO_ADDR
// for i := 1 to 16 do
51125: LD_ADDR_VAR 0 2
51129: PUSH
51130: DOUBLE
51131: LD_INT 1
51133: DEC
51134: ST_TO_ADDR
51135: LD_INT 16
51137: PUSH
51138: FOR_TO
51139: IFFALSE 51338
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51141: LD_ADDR_VAR 0 3
51145: PUSH
51146: LD_INT 10
51148: PUSH
51149: LD_INT 20
51151: PUSH
51152: LD_INT 30
51154: PUSH
51155: LD_INT 40
51157: PUSH
51158: LD_INT 50
51160: PUSH
51161: LD_INT 60
51163: PUSH
51164: LD_INT 70
51166: PUSH
51167: LD_INT 80
51169: PUSH
51170: LD_INT 90
51172: PUSH
51173: LD_INT 100
51175: PUSH
51176: LD_INT 110
51178: PUSH
51179: LD_INT 120
51181: PUSH
51182: LD_INT 130
51184: PUSH
51185: LD_INT 140
51187: PUSH
51188: LD_INT 150
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: LIST
51200: LIST
51201: LIST
51202: LIST
51203: LIST
51204: LIST
51205: LIST
51206: LIST
51207: PUSH
51208: LD_INT 1
51210: PPUSH
51211: LD_INT 15
51213: PPUSH
51214: CALL_OW 12
51218: ARRAY
51219: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51220: LD_ADDR_VAR 0 4
51224: PUSH
51225: LD_INT 10
51227: PUSH
51228: LD_INT 20
51230: PUSH
51231: LD_INT 30
51233: PUSH
51234: LD_INT 40
51236: PUSH
51237: LD_INT 50
51239: PUSH
51240: LD_INT 60
51242: PUSH
51243: LD_INT 70
51245: PUSH
51246: LD_INT 80
51248: PUSH
51249: LD_INT 90
51251: PUSH
51252: LD_INT 100
51254: PUSH
51255: LD_INT 110
51257: PUSH
51258: LD_INT 120
51260: PUSH
51261: LD_INT 130
51263: PUSH
51264: LD_INT 140
51266: PUSH
51267: LD_INT 150
51269: PUSH
51270: EMPTY
51271: LIST
51272: LIST
51273: LIST
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: LIST
51281: LIST
51282: LIST
51283: LIST
51284: LIST
51285: LIST
51286: PUSH
51287: LD_INT 1
51289: PPUSH
51290: LD_INT 15
51292: PPUSH
51293: CALL_OW 12
51297: ARRAY
51298: ST_TO_ADDR
// if ValidHex ( x , y ) then
51299: LD_VAR 0 3
51303: PPUSH
51304: LD_VAR 0 4
51308: PPUSH
51309: CALL_OW 488
51313: IFFALSE 51336
// begin result := [ x , y ] ;
51315: LD_ADDR_VAR 0 1
51319: PUSH
51320: LD_VAR 0 3
51324: PUSH
51325: LD_VAR 0 4
51329: PUSH
51330: EMPTY
51331: LIST
51332: LIST
51333: ST_TO_ADDR
// break ;
51334: GO 51338
// end ; end ;
51336: GO 51138
51338: POP
51339: POP
// if result then
51340: LD_VAR 0 1
51344: IFFALSE 51404
// begin ToLua ( playSibBomb() ) ;
51346: LD_STRING playSibBomb()
51348: PPUSH
51349: CALL_OW 559
// wait ( 0 0$14 ) ;
51353: LD_INT 490
51355: PPUSH
51356: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51360: LD_VAR 0 1
51364: PUSH
51365: LD_INT 1
51367: ARRAY
51368: PPUSH
51369: LD_VAR 0 1
51373: PUSH
51374: LD_INT 2
51376: ARRAY
51377: PPUSH
51378: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51382: LD_VAR 0 1
51386: PUSH
51387: LD_INT 1
51389: ARRAY
51390: PPUSH
51391: LD_VAR 0 1
51395: PUSH
51396: LD_INT 2
51398: ARRAY
51399: PPUSH
51400: CALL_OW 429
// end ; end ;
51404: LD_VAR 0 1
51408: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51409: LD_EXP 92
51413: PUSH
51414: LD_EXP 114
51418: AND
51419: IFFALSE 51431
51421: GO 51423
51423: DISABLE
// YouLost (  ) ;
51424: LD_STRING 
51426: PPUSH
51427: CALL_OW 104
51431: END
// every 0 0$1 trigger StreamModeActive and sFog do
51432: LD_EXP 92
51436: PUSH
51437: LD_EXP 113
51441: AND
51442: IFFALSE 51456
51444: GO 51446
51446: DISABLE
// FogOff ( your_side ) ;
51447: LD_OWVAR 2
51451: PPUSH
51452: CALL_OW 344
51456: END
// every 0 0$1 trigger StreamModeActive and sSun do
51457: LD_EXP 92
51461: PUSH
51462: LD_EXP 115
51466: AND
51467: IFFALSE 51495
51469: GO 51471
51471: DISABLE
// begin solar_recharge_percent := 0 ;
51472: LD_ADDR_OWVAR 79
51476: PUSH
51477: LD_INT 0
51479: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51480: LD_INT 10500
51482: PPUSH
51483: CALL_OW 67
// solar_recharge_percent := 100 ;
51487: LD_ADDR_OWVAR 79
51491: PUSH
51492: LD_INT 100
51494: ST_TO_ADDR
// end ;
51495: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51496: LD_EXP 92
51500: PUSH
51501: LD_EXP 116
51505: AND
51506: IFFALSE 51745
51508: GO 51510
51510: DISABLE
51511: LD_INT 0
51513: PPUSH
51514: PPUSH
51515: PPUSH
// begin tmp := [ ] ;
51516: LD_ADDR_VAR 0 3
51520: PUSH
51521: EMPTY
51522: ST_TO_ADDR
// for i := 1 to 6 do
51523: LD_ADDR_VAR 0 1
51527: PUSH
51528: DOUBLE
51529: LD_INT 1
51531: DEC
51532: ST_TO_ADDR
51533: LD_INT 6
51535: PUSH
51536: FOR_TO
51537: IFFALSE 51642
// begin uc_nation := nation_nature ;
51539: LD_ADDR_OWVAR 21
51543: PUSH
51544: LD_INT 0
51546: ST_TO_ADDR
// uc_side := 0 ;
51547: LD_ADDR_OWVAR 20
51551: PUSH
51552: LD_INT 0
51554: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51555: LD_ADDR_OWVAR 29
51559: PUSH
51560: LD_INT 12
51562: PUSH
51563: LD_INT 12
51565: PUSH
51566: EMPTY
51567: LIST
51568: LIST
51569: ST_TO_ADDR
// hc_agressivity := 20 ;
51570: LD_ADDR_OWVAR 35
51574: PUSH
51575: LD_INT 20
51577: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51578: LD_ADDR_OWVAR 28
51582: PUSH
51583: LD_INT 17
51585: ST_TO_ADDR
// hc_gallery :=  ;
51586: LD_ADDR_OWVAR 33
51590: PUSH
51591: LD_STRING 
51593: ST_TO_ADDR
// hc_name :=  ;
51594: LD_ADDR_OWVAR 26
51598: PUSH
51599: LD_STRING 
51601: ST_TO_ADDR
// un := CreateHuman ;
51602: LD_ADDR_VAR 0 2
51606: PUSH
51607: CALL_OW 44
51611: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51612: LD_VAR 0 2
51616: PPUSH
51617: LD_INT 1
51619: PPUSH
51620: CALL_OW 51
// tmp := tmp ^ un ;
51624: LD_ADDR_VAR 0 3
51628: PUSH
51629: LD_VAR 0 3
51633: PUSH
51634: LD_VAR 0 2
51638: ADD
51639: ST_TO_ADDR
// end ;
51640: GO 51536
51642: POP
51643: POP
// repeat wait ( 0 0$1 ) ;
51644: LD_INT 35
51646: PPUSH
51647: CALL_OW 67
// for un in tmp do
51651: LD_ADDR_VAR 0 2
51655: PUSH
51656: LD_VAR 0 3
51660: PUSH
51661: FOR_IN
51662: IFFALSE 51736
// begin if IsDead ( un ) then
51664: LD_VAR 0 2
51668: PPUSH
51669: CALL_OW 301
51673: IFFALSE 51693
// begin tmp := tmp diff un ;
51675: LD_ADDR_VAR 0 3
51679: PUSH
51680: LD_VAR 0 3
51684: PUSH
51685: LD_VAR 0 2
51689: DIFF
51690: ST_TO_ADDR
// continue ;
51691: GO 51661
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51693: LD_VAR 0 2
51697: PPUSH
51698: LD_INT 3
51700: PUSH
51701: LD_INT 22
51703: PUSH
51704: LD_INT 0
51706: PUSH
51707: EMPTY
51708: LIST
51709: LIST
51710: PUSH
51711: EMPTY
51712: LIST
51713: LIST
51714: PPUSH
51715: CALL_OW 69
51719: PPUSH
51720: LD_VAR 0 2
51724: PPUSH
51725: CALL_OW 74
51729: PPUSH
51730: CALL_OW 115
// end ;
51734: GO 51661
51736: POP
51737: POP
// until not tmp ;
51738: LD_VAR 0 3
51742: NOT
51743: IFFALSE 51644
// end ;
51745: PPOPN 3
51747: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51748: LD_EXP 92
51752: PUSH
51753: LD_EXP 117
51757: AND
51758: IFFALSE 51812
51760: GO 51762
51762: DISABLE
// begin ToLua ( displayTroll(); ) ;
51763: LD_STRING displayTroll();
51765: PPUSH
51766: CALL_OW 559
// wait ( 3 3$00 ) ;
51770: LD_INT 6300
51772: PPUSH
51773: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51777: LD_STRING hideTroll();
51779: PPUSH
51780: CALL_OW 559
// wait ( 1 1$00 ) ;
51784: LD_INT 2100
51786: PPUSH
51787: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51791: LD_STRING displayTroll();
51793: PPUSH
51794: CALL_OW 559
// wait ( 1 1$00 ) ;
51798: LD_INT 2100
51800: PPUSH
51801: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51805: LD_STRING hideTroll();
51807: PPUSH
51808: CALL_OW 559
// end ;
51812: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51813: LD_EXP 92
51817: PUSH
51818: LD_EXP 118
51822: AND
51823: IFFALSE 51886
51825: GO 51827
51827: DISABLE
51828: LD_INT 0
51830: PPUSH
// begin p := 0 ;
51831: LD_ADDR_VAR 0 1
51835: PUSH
51836: LD_INT 0
51838: ST_TO_ADDR
// repeat game_speed := 1 ;
51839: LD_ADDR_OWVAR 65
51843: PUSH
51844: LD_INT 1
51846: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51847: LD_INT 35
51849: PPUSH
51850: CALL_OW 67
// p := p + 1 ;
51854: LD_ADDR_VAR 0 1
51858: PUSH
51859: LD_VAR 0 1
51863: PUSH
51864: LD_INT 1
51866: PLUS
51867: ST_TO_ADDR
// until p >= 60 ;
51868: LD_VAR 0 1
51872: PUSH
51873: LD_INT 60
51875: GREATEREQUAL
51876: IFFALSE 51839
// game_speed := 4 ;
51878: LD_ADDR_OWVAR 65
51882: PUSH
51883: LD_INT 4
51885: ST_TO_ADDR
// end ;
51886: PPOPN 1
51888: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51889: LD_EXP 92
51893: PUSH
51894: LD_EXP 119
51898: AND
51899: IFFALSE 52045
51901: GO 51903
51903: DISABLE
51904: LD_INT 0
51906: PPUSH
51907: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51908: LD_ADDR_VAR 0 1
51912: PUSH
51913: LD_INT 22
51915: PUSH
51916: LD_OWVAR 2
51920: PUSH
51921: EMPTY
51922: LIST
51923: LIST
51924: PUSH
51925: LD_INT 2
51927: PUSH
51928: LD_INT 30
51930: PUSH
51931: LD_INT 0
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PUSH
51938: LD_INT 30
51940: PUSH
51941: LD_INT 1
51943: PUSH
51944: EMPTY
51945: LIST
51946: LIST
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: LIST
51952: PUSH
51953: EMPTY
51954: LIST
51955: LIST
51956: PPUSH
51957: CALL_OW 69
51961: ST_TO_ADDR
// if not depot then
51962: LD_VAR 0 1
51966: NOT
51967: IFFALSE 51971
// exit ;
51969: GO 52045
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51971: LD_ADDR_VAR 0 2
51975: PUSH
51976: LD_VAR 0 1
51980: PUSH
51981: LD_INT 1
51983: PPUSH
51984: LD_VAR 0 1
51988: PPUSH
51989: CALL_OW 12
51993: ARRAY
51994: PPUSH
51995: CALL_OW 274
51999: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
52000: LD_VAR 0 2
52004: PPUSH
52005: LD_INT 1
52007: PPUSH
52008: LD_INT 0
52010: PPUSH
52011: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
52015: LD_VAR 0 2
52019: PPUSH
52020: LD_INT 2
52022: PPUSH
52023: LD_INT 0
52025: PPUSH
52026: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
52030: LD_VAR 0 2
52034: PPUSH
52035: LD_INT 3
52037: PPUSH
52038: LD_INT 0
52040: PPUSH
52041: CALL_OW 277
// end ;
52045: PPOPN 2
52047: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52048: LD_EXP 92
52052: PUSH
52053: LD_EXP 120
52057: AND
52058: IFFALSE 52155
52060: GO 52062
52062: DISABLE
52063: LD_INT 0
52065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52066: LD_ADDR_VAR 0 1
52070: PUSH
52071: LD_INT 22
52073: PUSH
52074: LD_OWVAR 2
52078: PUSH
52079: EMPTY
52080: LIST
52081: LIST
52082: PUSH
52083: LD_INT 21
52085: PUSH
52086: LD_INT 1
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: PUSH
52093: LD_INT 3
52095: PUSH
52096: LD_INT 23
52098: PUSH
52099: LD_INT 0
52101: PUSH
52102: EMPTY
52103: LIST
52104: LIST
52105: PUSH
52106: EMPTY
52107: LIST
52108: LIST
52109: PUSH
52110: EMPTY
52111: LIST
52112: LIST
52113: LIST
52114: PPUSH
52115: CALL_OW 69
52119: ST_TO_ADDR
// if not tmp then
52120: LD_VAR 0 1
52124: NOT
52125: IFFALSE 52129
// exit ;
52127: GO 52155
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52129: LD_VAR 0 1
52133: PUSH
52134: LD_INT 1
52136: PPUSH
52137: LD_VAR 0 1
52141: PPUSH
52142: CALL_OW 12
52146: ARRAY
52147: PPUSH
52148: LD_INT 200
52150: PPUSH
52151: CALL_OW 234
// end ;
52155: PPOPN 1
52157: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52158: LD_EXP 92
52162: PUSH
52163: LD_EXP 121
52167: AND
52168: IFFALSE 52247
52170: GO 52172
52172: DISABLE
52173: LD_INT 0
52175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52176: LD_ADDR_VAR 0 1
52180: PUSH
52181: LD_INT 22
52183: PUSH
52184: LD_OWVAR 2
52188: PUSH
52189: EMPTY
52190: LIST
52191: LIST
52192: PUSH
52193: LD_INT 21
52195: PUSH
52196: LD_INT 2
52198: PUSH
52199: EMPTY
52200: LIST
52201: LIST
52202: PUSH
52203: EMPTY
52204: LIST
52205: LIST
52206: PPUSH
52207: CALL_OW 69
52211: ST_TO_ADDR
// if not tmp then
52212: LD_VAR 0 1
52216: NOT
52217: IFFALSE 52221
// exit ;
52219: GO 52247
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52221: LD_VAR 0 1
52225: PUSH
52226: LD_INT 1
52228: PPUSH
52229: LD_VAR 0 1
52233: PPUSH
52234: CALL_OW 12
52238: ARRAY
52239: PPUSH
52240: LD_INT 60
52242: PPUSH
52243: CALL_OW 234
// end ;
52247: PPOPN 1
52249: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52250: LD_EXP 92
52254: PUSH
52255: LD_EXP 122
52259: AND
52260: IFFALSE 52359
52262: GO 52264
52264: DISABLE
52265: LD_INT 0
52267: PPUSH
52268: PPUSH
// begin enable ;
52269: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52270: LD_ADDR_VAR 0 1
52274: PUSH
52275: LD_INT 22
52277: PUSH
52278: LD_OWVAR 2
52282: PUSH
52283: EMPTY
52284: LIST
52285: LIST
52286: PUSH
52287: LD_INT 61
52289: PUSH
52290: EMPTY
52291: LIST
52292: PUSH
52293: LD_INT 33
52295: PUSH
52296: LD_INT 2
52298: PUSH
52299: EMPTY
52300: LIST
52301: LIST
52302: PUSH
52303: EMPTY
52304: LIST
52305: LIST
52306: LIST
52307: PPUSH
52308: CALL_OW 69
52312: ST_TO_ADDR
// if not tmp then
52313: LD_VAR 0 1
52317: NOT
52318: IFFALSE 52322
// exit ;
52320: GO 52359
// for i in tmp do
52322: LD_ADDR_VAR 0 2
52326: PUSH
52327: LD_VAR 0 1
52331: PUSH
52332: FOR_IN
52333: IFFALSE 52357
// if IsControledBy ( i ) then
52335: LD_VAR 0 2
52339: PPUSH
52340: CALL_OW 312
52344: IFFALSE 52355
// ComUnlink ( i ) ;
52346: LD_VAR 0 2
52350: PPUSH
52351: CALL_OW 136
52355: GO 52332
52357: POP
52358: POP
// end ;
52359: PPOPN 2
52361: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52362: LD_EXP 92
52366: PUSH
52367: LD_EXP 123
52371: AND
52372: IFFALSE 52512
52374: GO 52376
52376: DISABLE
52377: LD_INT 0
52379: PPUSH
52380: PPUSH
// begin ToLua ( displayPowell(); ) ;
52381: LD_STRING displayPowell();
52383: PPUSH
52384: CALL_OW 559
// uc_side := 0 ;
52388: LD_ADDR_OWVAR 20
52392: PUSH
52393: LD_INT 0
52395: ST_TO_ADDR
// uc_nation := 2 ;
52396: LD_ADDR_OWVAR 21
52400: PUSH
52401: LD_INT 2
52403: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52404: LD_ADDR_OWVAR 37
52408: PUSH
52409: LD_INT 14
52411: ST_TO_ADDR
// vc_engine := engine_siberite ;
52412: LD_ADDR_OWVAR 39
52416: PUSH
52417: LD_INT 3
52419: ST_TO_ADDR
// vc_control := control_apeman ;
52420: LD_ADDR_OWVAR 38
52424: PUSH
52425: LD_INT 5
52427: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52428: LD_ADDR_OWVAR 40
52432: PUSH
52433: LD_INT 29
52435: ST_TO_ADDR
// un := CreateVehicle ;
52436: LD_ADDR_VAR 0 2
52440: PUSH
52441: CALL_OW 45
52445: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52446: LD_VAR 0 2
52450: PPUSH
52451: LD_INT 1
52453: PPUSH
52454: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52458: LD_INT 35
52460: PPUSH
52461: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52465: LD_VAR 0 2
52469: PPUSH
52470: LD_INT 22
52472: PUSH
52473: LD_OWVAR 2
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: PPUSH
52482: CALL_OW 69
52486: PPUSH
52487: LD_VAR 0 2
52491: PPUSH
52492: CALL_OW 74
52496: PPUSH
52497: CALL_OW 115
// until IsDead ( un ) ;
52501: LD_VAR 0 2
52505: PPUSH
52506: CALL_OW 301
52510: IFFALSE 52458
// end ;
52512: PPOPN 2
52514: END
// every 0 0$1 trigger StreamModeActive and sStu do
52515: LD_EXP 92
52519: PUSH
52520: LD_EXP 131
52524: AND
52525: IFFALSE 52541
52527: GO 52529
52529: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52530: LD_STRING displayStucuk();
52532: PPUSH
52533: CALL_OW 559
// ResetFog ;
52537: CALL_OW 335
// end ;
52541: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52542: LD_EXP 92
52546: PUSH
52547: LD_EXP 124
52551: AND
52552: IFFALSE 52693
52554: GO 52556
52556: DISABLE
52557: LD_INT 0
52559: PPUSH
52560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52561: LD_ADDR_VAR 0 2
52565: PUSH
52566: LD_INT 22
52568: PUSH
52569: LD_OWVAR 2
52573: PUSH
52574: EMPTY
52575: LIST
52576: LIST
52577: PUSH
52578: LD_INT 21
52580: PUSH
52581: LD_INT 1
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: PUSH
52588: EMPTY
52589: LIST
52590: LIST
52591: PPUSH
52592: CALL_OW 69
52596: ST_TO_ADDR
// if not tmp then
52597: LD_VAR 0 2
52601: NOT
52602: IFFALSE 52606
// exit ;
52604: GO 52693
// un := tmp [ rand ( 1 , tmp ) ] ;
52606: LD_ADDR_VAR 0 1
52610: PUSH
52611: LD_VAR 0 2
52615: PUSH
52616: LD_INT 1
52618: PPUSH
52619: LD_VAR 0 2
52623: PPUSH
52624: CALL_OW 12
52628: ARRAY
52629: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52630: LD_VAR 0 1
52634: PPUSH
52635: LD_INT 0
52637: PPUSH
52638: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52642: LD_VAR 0 1
52646: PPUSH
52647: LD_OWVAR 3
52651: PUSH
52652: LD_VAR 0 1
52656: DIFF
52657: PPUSH
52658: LD_VAR 0 1
52662: PPUSH
52663: CALL_OW 74
52667: PPUSH
52668: CALL_OW 115
// wait ( 0 0$20 ) ;
52672: LD_INT 700
52674: PPUSH
52675: CALL_OW 67
// SetSide ( un , your_side ) ;
52679: LD_VAR 0 1
52683: PPUSH
52684: LD_OWVAR 2
52688: PPUSH
52689: CALL_OW 235
// end ;
52693: PPOPN 2
52695: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52696: LD_EXP 92
52700: PUSH
52701: LD_EXP 125
52705: AND
52706: IFFALSE 52812
52708: GO 52710
52710: DISABLE
52711: LD_INT 0
52713: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52714: LD_ADDR_VAR 0 1
52718: PUSH
52719: LD_INT 22
52721: PUSH
52722: LD_OWVAR 2
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PUSH
52731: LD_INT 2
52733: PUSH
52734: LD_INT 30
52736: PUSH
52737: LD_INT 0
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PUSH
52744: LD_INT 30
52746: PUSH
52747: LD_INT 1
52749: PUSH
52750: EMPTY
52751: LIST
52752: LIST
52753: PUSH
52754: EMPTY
52755: LIST
52756: LIST
52757: LIST
52758: PUSH
52759: EMPTY
52760: LIST
52761: LIST
52762: PPUSH
52763: CALL_OW 69
52767: ST_TO_ADDR
// if not depot then
52768: LD_VAR 0 1
52772: NOT
52773: IFFALSE 52777
// exit ;
52775: GO 52812
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52777: LD_VAR 0 1
52781: PUSH
52782: LD_INT 1
52784: ARRAY
52785: PPUSH
52786: CALL_OW 250
52790: PPUSH
52791: LD_VAR 0 1
52795: PUSH
52796: LD_INT 1
52798: ARRAY
52799: PPUSH
52800: CALL_OW 251
52804: PPUSH
52805: LD_INT 70
52807: PPUSH
52808: CALL_OW 495
// end ;
52812: PPOPN 1
52814: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52815: LD_EXP 92
52819: PUSH
52820: LD_EXP 126
52824: AND
52825: IFFALSE 53036
52827: GO 52829
52829: DISABLE
52830: LD_INT 0
52832: PPUSH
52833: PPUSH
52834: PPUSH
52835: PPUSH
52836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52837: LD_ADDR_VAR 0 5
52841: PUSH
52842: LD_INT 22
52844: PUSH
52845: LD_OWVAR 2
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PUSH
52854: LD_INT 21
52856: PUSH
52857: LD_INT 1
52859: PUSH
52860: EMPTY
52861: LIST
52862: LIST
52863: PUSH
52864: EMPTY
52865: LIST
52866: LIST
52867: PPUSH
52868: CALL_OW 69
52872: ST_TO_ADDR
// if not tmp then
52873: LD_VAR 0 5
52877: NOT
52878: IFFALSE 52882
// exit ;
52880: GO 53036
// for i in tmp do
52882: LD_ADDR_VAR 0 1
52886: PUSH
52887: LD_VAR 0 5
52891: PUSH
52892: FOR_IN
52893: IFFALSE 53034
// begin d := rand ( 0 , 5 ) ;
52895: LD_ADDR_VAR 0 4
52899: PUSH
52900: LD_INT 0
52902: PPUSH
52903: LD_INT 5
52905: PPUSH
52906: CALL_OW 12
52910: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52911: LD_ADDR_VAR 0 2
52915: PUSH
52916: LD_VAR 0 1
52920: PPUSH
52921: CALL_OW 250
52925: PPUSH
52926: LD_VAR 0 4
52930: PPUSH
52931: LD_INT 3
52933: PPUSH
52934: LD_INT 12
52936: PPUSH
52937: CALL_OW 12
52941: PPUSH
52942: CALL_OW 272
52946: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52947: LD_ADDR_VAR 0 3
52951: PUSH
52952: LD_VAR 0 1
52956: PPUSH
52957: CALL_OW 251
52961: PPUSH
52962: LD_VAR 0 4
52966: PPUSH
52967: LD_INT 3
52969: PPUSH
52970: LD_INT 12
52972: PPUSH
52973: CALL_OW 12
52977: PPUSH
52978: CALL_OW 273
52982: ST_TO_ADDR
// if ValidHex ( x , y ) then
52983: LD_VAR 0 2
52987: PPUSH
52988: LD_VAR 0 3
52992: PPUSH
52993: CALL_OW 488
52997: IFFALSE 53032
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52999: LD_VAR 0 1
53003: PPUSH
53004: LD_VAR 0 2
53008: PPUSH
53009: LD_VAR 0 3
53013: PPUSH
53014: LD_INT 3
53016: PPUSH
53017: LD_INT 6
53019: PPUSH
53020: CALL_OW 12
53024: PPUSH
53025: LD_INT 1
53027: PPUSH
53028: CALL_OW 483
// end ;
53032: GO 52892
53034: POP
53035: POP
// end ;
53036: PPOPN 5
53038: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53039: LD_EXP 92
53043: PUSH
53044: LD_EXP 127
53048: AND
53049: IFFALSE 53143
53051: GO 53053
53053: DISABLE
53054: LD_INT 0
53056: PPUSH
53057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53058: LD_ADDR_VAR 0 2
53062: PUSH
53063: LD_INT 22
53065: PUSH
53066: LD_OWVAR 2
53070: PUSH
53071: EMPTY
53072: LIST
53073: LIST
53074: PUSH
53075: LD_INT 32
53077: PUSH
53078: LD_INT 1
53080: PUSH
53081: EMPTY
53082: LIST
53083: LIST
53084: PUSH
53085: LD_INT 21
53087: PUSH
53088: LD_INT 2
53090: PUSH
53091: EMPTY
53092: LIST
53093: LIST
53094: PUSH
53095: EMPTY
53096: LIST
53097: LIST
53098: LIST
53099: PPUSH
53100: CALL_OW 69
53104: ST_TO_ADDR
// if not tmp then
53105: LD_VAR 0 2
53109: NOT
53110: IFFALSE 53114
// exit ;
53112: GO 53143
// for i in tmp do
53114: LD_ADDR_VAR 0 1
53118: PUSH
53119: LD_VAR 0 2
53123: PUSH
53124: FOR_IN
53125: IFFALSE 53141
// SetFuel ( i , 0 ) ;
53127: LD_VAR 0 1
53131: PPUSH
53132: LD_INT 0
53134: PPUSH
53135: CALL_OW 240
53139: GO 53124
53141: POP
53142: POP
// end ;
53143: PPOPN 2
53145: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53146: LD_EXP 92
53150: PUSH
53151: LD_EXP 128
53155: AND
53156: IFFALSE 53222
53158: GO 53160
53160: DISABLE
53161: LD_INT 0
53163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53164: LD_ADDR_VAR 0 1
53168: PUSH
53169: LD_INT 22
53171: PUSH
53172: LD_OWVAR 2
53176: PUSH
53177: EMPTY
53178: LIST
53179: LIST
53180: PUSH
53181: LD_INT 30
53183: PUSH
53184: LD_INT 29
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: PUSH
53191: EMPTY
53192: LIST
53193: LIST
53194: PPUSH
53195: CALL_OW 69
53199: ST_TO_ADDR
// if not tmp then
53200: LD_VAR 0 1
53204: NOT
53205: IFFALSE 53209
// exit ;
53207: GO 53222
// DestroyUnit ( tmp [ 1 ] ) ;
53209: LD_VAR 0 1
53213: PUSH
53214: LD_INT 1
53216: ARRAY
53217: PPUSH
53218: CALL_OW 65
// end ;
53222: PPOPN 1
53224: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53225: LD_EXP 92
53229: PUSH
53230: LD_EXP 130
53234: AND
53235: IFFALSE 53364
53237: GO 53239
53239: DISABLE
53240: LD_INT 0
53242: PPUSH
// begin uc_side := 0 ;
53243: LD_ADDR_OWVAR 20
53247: PUSH
53248: LD_INT 0
53250: ST_TO_ADDR
// uc_nation := nation_arabian ;
53251: LD_ADDR_OWVAR 21
53255: PUSH
53256: LD_INT 2
53258: ST_TO_ADDR
// hc_gallery :=  ;
53259: LD_ADDR_OWVAR 33
53263: PUSH
53264: LD_STRING 
53266: ST_TO_ADDR
// hc_name :=  ;
53267: LD_ADDR_OWVAR 26
53271: PUSH
53272: LD_STRING 
53274: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53275: LD_INT 1
53277: PPUSH
53278: LD_INT 11
53280: PPUSH
53281: LD_INT 10
53283: PPUSH
53284: CALL_OW 380
// un := CreateHuman ;
53288: LD_ADDR_VAR 0 1
53292: PUSH
53293: CALL_OW 44
53297: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53298: LD_VAR 0 1
53302: PPUSH
53303: LD_INT 1
53305: PPUSH
53306: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53310: LD_INT 35
53312: PPUSH
53313: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53317: LD_VAR 0 1
53321: PPUSH
53322: LD_INT 22
53324: PUSH
53325: LD_OWVAR 2
53329: PUSH
53330: EMPTY
53331: LIST
53332: LIST
53333: PPUSH
53334: CALL_OW 69
53338: PPUSH
53339: LD_VAR 0 1
53343: PPUSH
53344: CALL_OW 74
53348: PPUSH
53349: CALL_OW 115
// until IsDead ( un ) ;
53353: LD_VAR 0 1
53357: PPUSH
53358: CALL_OW 301
53362: IFFALSE 53310
// end ;
53364: PPOPN 1
53366: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53367: LD_EXP 92
53371: PUSH
53372: LD_EXP 132
53376: AND
53377: IFFALSE 53389
53379: GO 53381
53381: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53382: LD_STRING earthquake(getX(game), 0, 32)
53384: PPUSH
53385: CALL_OW 559
53389: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53390: LD_EXP 92
53394: PUSH
53395: LD_EXP 133
53399: AND
53400: IFFALSE 53491
53402: GO 53404
53404: DISABLE
53405: LD_INT 0
53407: PPUSH
// begin enable ;
53408: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53409: LD_ADDR_VAR 0 1
53413: PUSH
53414: LD_INT 22
53416: PUSH
53417: LD_OWVAR 2
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PUSH
53426: LD_INT 21
53428: PUSH
53429: LD_INT 2
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: LD_INT 33
53438: PUSH
53439: LD_INT 3
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: PUSH
53446: EMPTY
53447: LIST
53448: LIST
53449: LIST
53450: PPUSH
53451: CALL_OW 69
53455: ST_TO_ADDR
// if not tmp then
53456: LD_VAR 0 1
53460: NOT
53461: IFFALSE 53465
// exit ;
53463: GO 53491
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53465: LD_VAR 0 1
53469: PUSH
53470: LD_INT 1
53472: PPUSH
53473: LD_VAR 0 1
53477: PPUSH
53478: CALL_OW 12
53482: ARRAY
53483: PPUSH
53484: LD_INT 1
53486: PPUSH
53487: CALL_OW 234
// end ;
53491: PPOPN 1
53493: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53494: LD_EXP 92
53498: PUSH
53499: LD_EXP 134
53503: AND
53504: IFFALSE 53645
53506: GO 53508
53508: DISABLE
53509: LD_INT 0
53511: PPUSH
53512: PPUSH
53513: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53514: LD_ADDR_VAR 0 3
53518: PUSH
53519: LD_INT 22
53521: PUSH
53522: LD_OWVAR 2
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: PUSH
53531: LD_INT 25
53533: PUSH
53534: LD_INT 1
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PUSH
53541: EMPTY
53542: LIST
53543: LIST
53544: PPUSH
53545: CALL_OW 69
53549: ST_TO_ADDR
// if not tmp then
53550: LD_VAR 0 3
53554: NOT
53555: IFFALSE 53559
// exit ;
53557: GO 53645
// un := tmp [ rand ( 1 , tmp ) ] ;
53559: LD_ADDR_VAR 0 2
53563: PUSH
53564: LD_VAR 0 3
53568: PUSH
53569: LD_INT 1
53571: PPUSH
53572: LD_VAR 0 3
53576: PPUSH
53577: CALL_OW 12
53581: ARRAY
53582: ST_TO_ADDR
// if Crawls ( un ) then
53583: LD_VAR 0 2
53587: PPUSH
53588: CALL_OW 318
53592: IFFALSE 53603
// ComWalk ( un ) ;
53594: LD_VAR 0 2
53598: PPUSH
53599: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53603: LD_VAR 0 2
53607: PPUSH
53608: LD_INT 9
53610: PPUSH
53611: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53615: LD_INT 28
53617: PPUSH
53618: LD_OWVAR 2
53622: PPUSH
53623: LD_INT 2
53625: PPUSH
53626: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53630: LD_INT 29
53632: PPUSH
53633: LD_OWVAR 2
53637: PPUSH
53638: LD_INT 2
53640: PPUSH
53641: CALL_OW 322
// end ;
53645: PPOPN 3
53647: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53648: LD_EXP 92
53652: PUSH
53653: LD_EXP 135
53657: AND
53658: IFFALSE 53769
53660: GO 53662
53662: DISABLE
53663: LD_INT 0
53665: PPUSH
53666: PPUSH
53667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53668: LD_ADDR_VAR 0 3
53672: PUSH
53673: LD_INT 22
53675: PUSH
53676: LD_OWVAR 2
53680: PUSH
53681: EMPTY
53682: LIST
53683: LIST
53684: PUSH
53685: LD_INT 25
53687: PUSH
53688: LD_INT 1
53690: PUSH
53691: EMPTY
53692: LIST
53693: LIST
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: PPUSH
53699: CALL_OW 69
53703: ST_TO_ADDR
// if not tmp then
53704: LD_VAR 0 3
53708: NOT
53709: IFFALSE 53713
// exit ;
53711: GO 53769
// un := tmp [ rand ( 1 , tmp ) ] ;
53713: LD_ADDR_VAR 0 2
53717: PUSH
53718: LD_VAR 0 3
53722: PUSH
53723: LD_INT 1
53725: PPUSH
53726: LD_VAR 0 3
53730: PPUSH
53731: CALL_OW 12
53735: ARRAY
53736: ST_TO_ADDR
// if Crawls ( un ) then
53737: LD_VAR 0 2
53741: PPUSH
53742: CALL_OW 318
53746: IFFALSE 53757
// ComWalk ( un ) ;
53748: LD_VAR 0 2
53752: PPUSH
53753: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53757: LD_VAR 0 2
53761: PPUSH
53762: LD_INT 8
53764: PPUSH
53765: CALL_OW 336
// end ;
53769: PPOPN 3
53771: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53772: LD_EXP 92
53776: PUSH
53777: LD_EXP 136
53781: AND
53782: IFFALSE 53926
53784: GO 53786
53786: DISABLE
53787: LD_INT 0
53789: PPUSH
53790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53791: LD_ADDR_VAR 0 2
53795: PUSH
53796: LD_INT 22
53798: PUSH
53799: LD_OWVAR 2
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: PUSH
53808: LD_INT 21
53810: PUSH
53811: LD_INT 2
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: PUSH
53818: LD_INT 2
53820: PUSH
53821: LD_INT 34
53823: PUSH
53824: LD_INT 12
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: PUSH
53831: LD_INT 34
53833: PUSH
53834: LD_INT 51
53836: PUSH
53837: EMPTY
53838: LIST
53839: LIST
53840: PUSH
53841: LD_INT 34
53843: PUSH
53844: LD_INT 32
53846: PUSH
53847: EMPTY
53848: LIST
53849: LIST
53850: PUSH
53851: EMPTY
53852: LIST
53853: LIST
53854: LIST
53855: LIST
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: LIST
53861: PPUSH
53862: CALL_OW 69
53866: ST_TO_ADDR
// if not tmp then
53867: LD_VAR 0 2
53871: NOT
53872: IFFALSE 53876
// exit ;
53874: GO 53926
// for i in tmp do
53876: LD_ADDR_VAR 0 1
53880: PUSH
53881: LD_VAR 0 2
53885: PUSH
53886: FOR_IN
53887: IFFALSE 53924
// if GetCargo ( i , mat_artifact ) = 0 then
53889: LD_VAR 0 1
53893: PPUSH
53894: LD_INT 4
53896: PPUSH
53897: CALL_OW 289
53901: PUSH
53902: LD_INT 0
53904: EQUAL
53905: IFFALSE 53922
// SetCargo ( i , mat_siberit , 100 ) ;
53907: LD_VAR 0 1
53911: PPUSH
53912: LD_INT 3
53914: PPUSH
53915: LD_INT 100
53917: PPUSH
53918: CALL_OW 290
53922: GO 53886
53924: POP
53925: POP
// end ;
53926: PPOPN 2
53928: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53929: LD_EXP 92
53933: PUSH
53934: LD_EXP 137
53938: AND
53939: IFFALSE 54122
53941: GO 53943
53943: DISABLE
53944: LD_INT 0
53946: PPUSH
53947: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53948: LD_ADDR_VAR 0 2
53952: PUSH
53953: LD_INT 22
53955: PUSH
53956: LD_OWVAR 2
53960: PUSH
53961: EMPTY
53962: LIST
53963: LIST
53964: PPUSH
53965: CALL_OW 69
53969: ST_TO_ADDR
// if not tmp then
53970: LD_VAR 0 2
53974: NOT
53975: IFFALSE 53979
// exit ;
53977: GO 54122
// for i := 1 to 2 do
53979: LD_ADDR_VAR 0 1
53983: PUSH
53984: DOUBLE
53985: LD_INT 1
53987: DEC
53988: ST_TO_ADDR
53989: LD_INT 2
53991: PUSH
53992: FOR_TO
53993: IFFALSE 54120
// begin uc_side := your_side ;
53995: LD_ADDR_OWVAR 20
53999: PUSH
54000: LD_OWVAR 2
54004: ST_TO_ADDR
// uc_nation := nation_american ;
54005: LD_ADDR_OWVAR 21
54009: PUSH
54010: LD_INT 1
54012: ST_TO_ADDR
// vc_chassis := us_morphling ;
54013: LD_ADDR_OWVAR 37
54017: PUSH
54018: LD_INT 5
54020: ST_TO_ADDR
// vc_engine := engine_siberite ;
54021: LD_ADDR_OWVAR 39
54025: PUSH
54026: LD_INT 3
54028: ST_TO_ADDR
// vc_control := control_computer ;
54029: LD_ADDR_OWVAR 38
54033: PUSH
54034: LD_INT 3
54036: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54037: LD_ADDR_OWVAR 40
54041: PUSH
54042: LD_INT 10
54044: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: PPUSH
54054: CALL_OW 310
54058: NOT
54059: IFFALSE 54106
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54061: CALL_OW 45
54065: PPUSH
54066: LD_VAR 0 2
54070: PUSH
54071: LD_INT 1
54073: ARRAY
54074: PPUSH
54075: CALL_OW 250
54079: PPUSH
54080: LD_VAR 0 2
54084: PUSH
54085: LD_INT 1
54087: ARRAY
54088: PPUSH
54089: CALL_OW 251
54093: PPUSH
54094: LD_INT 12
54096: PPUSH
54097: LD_INT 1
54099: PPUSH
54100: CALL_OW 50
54104: GO 54118
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54106: CALL_OW 45
54110: PPUSH
54111: LD_INT 1
54113: PPUSH
54114: CALL_OW 51
// end ;
54118: GO 53992
54120: POP
54121: POP
// end ;
54122: PPOPN 2
54124: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54125: LD_EXP 92
54129: PUSH
54130: LD_EXP 138
54134: AND
54135: IFFALSE 54357
54137: GO 54139
54139: DISABLE
54140: LD_INT 0
54142: PPUSH
54143: PPUSH
54144: PPUSH
54145: PPUSH
54146: PPUSH
54147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54148: LD_ADDR_VAR 0 6
54152: PUSH
54153: LD_INT 22
54155: PUSH
54156: LD_OWVAR 2
54160: PUSH
54161: EMPTY
54162: LIST
54163: LIST
54164: PUSH
54165: LD_INT 21
54167: PUSH
54168: LD_INT 1
54170: PUSH
54171: EMPTY
54172: LIST
54173: LIST
54174: PUSH
54175: LD_INT 3
54177: PUSH
54178: LD_INT 23
54180: PUSH
54181: LD_INT 0
54183: PUSH
54184: EMPTY
54185: LIST
54186: LIST
54187: PUSH
54188: EMPTY
54189: LIST
54190: LIST
54191: PUSH
54192: EMPTY
54193: LIST
54194: LIST
54195: LIST
54196: PPUSH
54197: CALL_OW 69
54201: ST_TO_ADDR
// if not tmp then
54202: LD_VAR 0 6
54206: NOT
54207: IFFALSE 54211
// exit ;
54209: GO 54357
// s1 := rand ( 1 , 4 ) ;
54211: LD_ADDR_VAR 0 2
54215: PUSH
54216: LD_INT 1
54218: PPUSH
54219: LD_INT 4
54221: PPUSH
54222: CALL_OW 12
54226: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54227: LD_ADDR_VAR 0 4
54231: PUSH
54232: LD_VAR 0 6
54236: PUSH
54237: LD_INT 1
54239: ARRAY
54240: PPUSH
54241: LD_VAR 0 2
54245: PPUSH
54246: CALL_OW 259
54250: ST_TO_ADDR
// if s1 = 1 then
54251: LD_VAR 0 2
54255: PUSH
54256: LD_INT 1
54258: EQUAL
54259: IFFALSE 54279
// s2 := rand ( 2 , 4 ) else
54261: LD_ADDR_VAR 0 3
54265: PUSH
54266: LD_INT 2
54268: PPUSH
54269: LD_INT 4
54271: PPUSH
54272: CALL_OW 12
54276: ST_TO_ADDR
54277: GO 54287
// s2 := 1 ;
54279: LD_ADDR_VAR 0 3
54283: PUSH
54284: LD_INT 1
54286: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54287: LD_ADDR_VAR 0 5
54291: PUSH
54292: LD_VAR 0 6
54296: PUSH
54297: LD_INT 1
54299: ARRAY
54300: PPUSH
54301: LD_VAR 0 3
54305: PPUSH
54306: CALL_OW 259
54310: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54311: LD_VAR 0 6
54315: PUSH
54316: LD_INT 1
54318: ARRAY
54319: PPUSH
54320: LD_VAR 0 2
54324: PPUSH
54325: LD_VAR 0 5
54329: PPUSH
54330: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54334: LD_VAR 0 6
54338: PUSH
54339: LD_INT 1
54341: ARRAY
54342: PPUSH
54343: LD_VAR 0 3
54347: PPUSH
54348: LD_VAR 0 4
54352: PPUSH
54353: CALL_OW 237
// end ;
54357: PPOPN 6
54359: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54360: LD_EXP 92
54364: PUSH
54365: LD_EXP 139
54369: AND
54370: IFFALSE 54449
54372: GO 54374
54374: DISABLE
54375: LD_INT 0
54377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54378: LD_ADDR_VAR 0 1
54382: PUSH
54383: LD_INT 22
54385: PUSH
54386: LD_OWVAR 2
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: PUSH
54395: LD_INT 30
54397: PUSH
54398: LD_INT 3
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PUSH
54405: EMPTY
54406: LIST
54407: LIST
54408: PPUSH
54409: CALL_OW 69
54413: ST_TO_ADDR
// if not tmp then
54414: LD_VAR 0 1
54418: NOT
54419: IFFALSE 54423
// exit ;
54421: GO 54449
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54423: LD_VAR 0 1
54427: PUSH
54428: LD_INT 1
54430: PPUSH
54431: LD_VAR 0 1
54435: PPUSH
54436: CALL_OW 12
54440: ARRAY
54441: PPUSH
54442: LD_INT 1
54444: PPUSH
54445: CALL_OW 234
// end ;
54449: PPOPN 1
54451: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54452: LD_EXP 92
54456: PUSH
54457: LD_EXP 140
54461: AND
54462: IFFALSE 54574
54464: GO 54466
54466: DISABLE
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54471: LD_ADDR_VAR 0 2
54475: PUSH
54476: LD_INT 22
54478: PUSH
54479: LD_OWVAR 2
54483: PUSH
54484: EMPTY
54485: LIST
54486: LIST
54487: PUSH
54488: LD_INT 2
54490: PUSH
54491: LD_INT 30
54493: PUSH
54494: LD_INT 27
54496: PUSH
54497: EMPTY
54498: LIST
54499: LIST
54500: PUSH
54501: LD_INT 30
54503: PUSH
54504: LD_INT 26
54506: PUSH
54507: EMPTY
54508: LIST
54509: LIST
54510: PUSH
54511: LD_INT 30
54513: PUSH
54514: LD_INT 28
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PUSH
54521: EMPTY
54522: LIST
54523: LIST
54524: LIST
54525: LIST
54526: PUSH
54527: EMPTY
54528: LIST
54529: LIST
54530: PPUSH
54531: CALL_OW 69
54535: ST_TO_ADDR
// if not tmp then
54536: LD_VAR 0 2
54540: NOT
54541: IFFALSE 54545
// exit ;
54543: GO 54574
// for i in tmp do
54545: LD_ADDR_VAR 0 1
54549: PUSH
54550: LD_VAR 0 2
54554: PUSH
54555: FOR_IN
54556: IFFALSE 54572
// SetLives ( i , 1 ) ;
54558: LD_VAR 0 1
54562: PPUSH
54563: LD_INT 1
54565: PPUSH
54566: CALL_OW 234
54570: GO 54555
54572: POP
54573: POP
// end ;
54574: PPOPN 2
54576: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54577: LD_EXP 92
54581: PUSH
54582: LD_EXP 141
54586: AND
54587: IFFALSE 54874
54589: GO 54591
54591: DISABLE
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
// begin i := rand ( 1 , 7 ) ;
54597: LD_ADDR_VAR 0 1
54601: PUSH
54602: LD_INT 1
54604: PPUSH
54605: LD_INT 7
54607: PPUSH
54608: CALL_OW 12
54612: ST_TO_ADDR
// case i of 1 :
54613: LD_VAR 0 1
54617: PUSH
54618: LD_INT 1
54620: DOUBLE
54621: EQUAL
54622: IFTRUE 54626
54624: GO 54636
54626: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54627: LD_STRING earthquake(getX(game), 0, 32)
54629: PPUSH
54630: CALL_OW 559
54634: GO 54874
54636: LD_INT 2
54638: DOUBLE
54639: EQUAL
54640: IFTRUE 54644
54642: GO 54658
54644: POP
// begin ToLua ( displayStucuk(); ) ;
54645: LD_STRING displayStucuk();
54647: PPUSH
54648: CALL_OW 559
// ResetFog ;
54652: CALL_OW 335
// end ; 3 :
54656: GO 54874
54658: LD_INT 3
54660: DOUBLE
54661: EQUAL
54662: IFTRUE 54666
54664: GO 54770
54666: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54667: LD_ADDR_VAR 0 2
54671: PUSH
54672: LD_INT 22
54674: PUSH
54675: LD_OWVAR 2
54679: PUSH
54680: EMPTY
54681: LIST
54682: LIST
54683: PUSH
54684: LD_INT 25
54686: PUSH
54687: LD_INT 1
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: PUSH
54694: EMPTY
54695: LIST
54696: LIST
54697: PPUSH
54698: CALL_OW 69
54702: ST_TO_ADDR
// if not tmp then
54703: LD_VAR 0 2
54707: NOT
54708: IFFALSE 54712
// exit ;
54710: GO 54874
// un := tmp [ rand ( 1 , tmp ) ] ;
54712: LD_ADDR_VAR 0 3
54716: PUSH
54717: LD_VAR 0 2
54721: PUSH
54722: LD_INT 1
54724: PPUSH
54725: LD_VAR 0 2
54729: PPUSH
54730: CALL_OW 12
54734: ARRAY
54735: ST_TO_ADDR
// if Crawls ( un ) then
54736: LD_VAR 0 3
54740: PPUSH
54741: CALL_OW 318
54745: IFFALSE 54756
// ComWalk ( un ) ;
54747: LD_VAR 0 3
54751: PPUSH
54752: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54756: LD_VAR 0 3
54760: PPUSH
54761: LD_INT 8
54763: PPUSH
54764: CALL_OW 336
// end ; 4 :
54768: GO 54874
54770: LD_INT 4
54772: DOUBLE
54773: EQUAL
54774: IFTRUE 54778
54776: GO 54852
54778: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54779: LD_ADDR_VAR 0 2
54783: PUSH
54784: LD_INT 22
54786: PUSH
54787: LD_OWVAR 2
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: PUSH
54796: LD_INT 30
54798: PUSH
54799: LD_INT 29
54801: PUSH
54802: EMPTY
54803: LIST
54804: LIST
54805: PUSH
54806: EMPTY
54807: LIST
54808: LIST
54809: PPUSH
54810: CALL_OW 69
54814: ST_TO_ADDR
// if not tmp then
54815: LD_VAR 0 2
54819: NOT
54820: IFFALSE 54824
// exit ;
54822: GO 54874
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54824: LD_VAR 0 2
54828: PUSH
54829: LD_INT 1
54831: ARRAY
54832: PPUSH
54833: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54837: LD_VAR 0 2
54841: PUSH
54842: LD_INT 1
54844: ARRAY
54845: PPUSH
54846: CALL_OW 65
// end ; 5 .. 7 :
54850: GO 54874
54852: LD_INT 5
54854: DOUBLE
54855: GREATEREQUAL
54856: IFFALSE 54864
54858: LD_INT 7
54860: DOUBLE
54861: LESSEQUAL
54862: IFTRUE 54866
54864: GO 54873
54866: POP
// StreamSibBomb ; end ;
54867: CALL 51111 0 0
54871: GO 54874
54873: POP
// end ;
54874: PPOPN 3
54876: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54877: LD_EXP 92
54881: PUSH
54882: LD_EXP 142
54886: AND
54887: IFFALSE 55043
54889: GO 54891
54891: DISABLE
54892: LD_INT 0
54894: PPUSH
54895: PPUSH
54896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54897: LD_ADDR_VAR 0 2
54901: PUSH
54902: LD_INT 81
54904: PUSH
54905: LD_OWVAR 2
54909: PUSH
54910: EMPTY
54911: LIST
54912: LIST
54913: PUSH
54914: LD_INT 2
54916: PUSH
54917: LD_INT 21
54919: PUSH
54920: LD_INT 1
54922: PUSH
54923: EMPTY
54924: LIST
54925: LIST
54926: PUSH
54927: LD_INT 21
54929: PUSH
54930: LD_INT 2
54932: PUSH
54933: EMPTY
54934: LIST
54935: LIST
54936: PUSH
54937: EMPTY
54938: LIST
54939: LIST
54940: LIST
54941: PUSH
54942: EMPTY
54943: LIST
54944: LIST
54945: PPUSH
54946: CALL_OW 69
54950: ST_TO_ADDR
// if not tmp then
54951: LD_VAR 0 2
54955: NOT
54956: IFFALSE 54960
// exit ;
54958: GO 55043
// p := 0 ;
54960: LD_ADDR_VAR 0 3
54964: PUSH
54965: LD_INT 0
54967: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54968: LD_INT 35
54970: PPUSH
54971: CALL_OW 67
// p := p + 1 ;
54975: LD_ADDR_VAR 0 3
54979: PUSH
54980: LD_VAR 0 3
54984: PUSH
54985: LD_INT 1
54987: PLUS
54988: ST_TO_ADDR
// for i in tmp do
54989: LD_ADDR_VAR 0 1
54993: PUSH
54994: LD_VAR 0 2
54998: PUSH
54999: FOR_IN
55000: IFFALSE 55031
// if GetLives ( i ) < 1000 then
55002: LD_VAR 0 1
55006: PPUSH
55007: CALL_OW 256
55011: PUSH
55012: LD_INT 1000
55014: LESS
55015: IFFALSE 55029
// SetLives ( i , 1000 ) ;
55017: LD_VAR 0 1
55021: PPUSH
55022: LD_INT 1000
55024: PPUSH
55025: CALL_OW 234
55029: GO 54999
55031: POP
55032: POP
// until p > 20 ;
55033: LD_VAR 0 3
55037: PUSH
55038: LD_INT 20
55040: GREATER
55041: IFFALSE 54968
// end ;
55043: PPOPN 3
55045: END
// every 0 0$1 trigger StreamModeActive and sTime do
55046: LD_EXP 92
55050: PUSH
55051: LD_EXP 143
55055: AND
55056: IFFALSE 55091
55058: GO 55060
55060: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55061: LD_INT 28
55063: PPUSH
55064: LD_OWVAR 2
55068: PPUSH
55069: LD_INT 2
55071: PPUSH
55072: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55076: LD_INT 30
55078: PPUSH
55079: LD_OWVAR 2
55083: PPUSH
55084: LD_INT 2
55086: PPUSH
55087: CALL_OW 322
// end ;
55091: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55092: LD_EXP 92
55096: PUSH
55097: LD_EXP 144
55101: AND
55102: IFFALSE 55223
55104: GO 55106
55106: DISABLE
55107: LD_INT 0
55109: PPUSH
55110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55111: LD_ADDR_VAR 0 2
55115: PUSH
55116: LD_INT 22
55118: PUSH
55119: LD_OWVAR 2
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: PUSH
55128: LD_INT 21
55130: PUSH
55131: LD_INT 1
55133: PUSH
55134: EMPTY
55135: LIST
55136: LIST
55137: PUSH
55138: LD_INT 3
55140: PUSH
55141: LD_INT 23
55143: PUSH
55144: LD_INT 0
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: PUSH
55151: EMPTY
55152: LIST
55153: LIST
55154: PUSH
55155: EMPTY
55156: LIST
55157: LIST
55158: LIST
55159: PPUSH
55160: CALL_OW 69
55164: ST_TO_ADDR
// if not tmp then
55165: LD_VAR 0 2
55169: NOT
55170: IFFALSE 55174
// exit ;
55172: GO 55223
// for i in tmp do
55174: LD_ADDR_VAR 0 1
55178: PUSH
55179: LD_VAR 0 2
55183: PUSH
55184: FOR_IN
55185: IFFALSE 55221
// begin if Crawls ( i ) then
55187: LD_VAR 0 1
55191: PPUSH
55192: CALL_OW 318
55196: IFFALSE 55207
// ComWalk ( i ) ;
55198: LD_VAR 0 1
55202: PPUSH
55203: CALL_OW 138
// SetClass ( i , 2 ) ;
55207: LD_VAR 0 1
55211: PPUSH
55212: LD_INT 2
55214: PPUSH
55215: CALL_OW 336
// end ;
55219: GO 55184
55221: POP
55222: POP
// end ;
55223: PPOPN 2
55225: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55226: LD_EXP 92
55230: PUSH
55231: LD_EXP 145
55235: AND
55236: IFFALSE 55524
55238: GO 55240
55240: DISABLE
55241: LD_INT 0
55243: PPUSH
55244: PPUSH
55245: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55246: LD_OWVAR 2
55250: PPUSH
55251: LD_INT 9
55253: PPUSH
55254: LD_INT 1
55256: PPUSH
55257: LD_INT 1
55259: PPUSH
55260: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55264: LD_INT 9
55266: PPUSH
55267: LD_OWVAR 2
55271: PPUSH
55272: CALL_OW 343
// uc_side := 9 ;
55276: LD_ADDR_OWVAR 20
55280: PUSH
55281: LD_INT 9
55283: ST_TO_ADDR
// uc_nation := 2 ;
55284: LD_ADDR_OWVAR 21
55288: PUSH
55289: LD_INT 2
55291: ST_TO_ADDR
// hc_name := Dark Warrior ;
55292: LD_ADDR_OWVAR 26
55296: PUSH
55297: LD_STRING Dark Warrior
55299: ST_TO_ADDR
// hc_gallery :=  ;
55300: LD_ADDR_OWVAR 33
55304: PUSH
55305: LD_STRING 
55307: ST_TO_ADDR
// hc_noskilllimit := true ;
55308: LD_ADDR_OWVAR 76
55312: PUSH
55313: LD_INT 1
55315: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55316: LD_ADDR_OWVAR 31
55320: PUSH
55321: LD_INT 30
55323: PUSH
55324: LD_INT 30
55326: PUSH
55327: LD_INT 30
55329: PUSH
55330: LD_INT 30
55332: PUSH
55333: EMPTY
55334: LIST
55335: LIST
55336: LIST
55337: LIST
55338: ST_TO_ADDR
// un := CreateHuman ;
55339: LD_ADDR_VAR 0 3
55343: PUSH
55344: CALL_OW 44
55348: ST_TO_ADDR
// hc_noskilllimit := false ;
55349: LD_ADDR_OWVAR 76
55353: PUSH
55354: LD_INT 0
55356: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55357: LD_VAR 0 3
55361: PPUSH
55362: LD_INT 1
55364: PPUSH
55365: CALL_OW 51
// ToLua ( playRanger() ) ;
55369: LD_STRING playRanger()
55371: PPUSH
55372: CALL_OW 559
// p := 0 ;
55376: LD_ADDR_VAR 0 2
55380: PUSH
55381: LD_INT 0
55383: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55384: LD_INT 35
55386: PPUSH
55387: CALL_OW 67
// p := p + 1 ;
55391: LD_ADDR_VAR 0 2
55395: PUSH
55396: LD_VAR 0 2
55400: PUSH
55401: LD_INT 1
55403: PLUS
55404: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55405: LD_VAR 0 3
55409: PPUSH
55410: CALL_OW 256
55414: PUSH
55415: LD_INT 1000
55417: LESS
55418: IFFALSE 55432
// SetLives ( un , 1000 ) ;
55420: LD_VAR 0 3
55424: PPUSH
55425: LD_INT 1000
55427: PPUSH
55428: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55432: LD_VAR 0 3
55436: PPUSH
55437: LD_INT 81
55439: PUSH
55440: LD_OWVAR 2
55444: PUSH
55445: EMPTY
55446: LIST
55447: LIST
55448: PUSH
55449: LD_INT 91
55451: PUSH
55452: LD_VAR 0 3
55456: PUSH
55457: LD_INT 30
55459: PUSH
55460: EMPTY
55461: LIST
55462: LIST
55463: LIST
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PPUSH
55469: CALL_OW 69
55473: PPUSH
55474: LD_VAR 0 3
55478: PPUSH
55479: CALL_OW 74
55483: PPUSH
55484: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55488: LD_VAR 0 2
55492: PUSH
55493: LD_INT 80
55495: GREATER
55496: PUSH
55497: LD_VAR 0 3
55501: PPUSH
55502: CALL_OW 301
55506: OR
55507: IFFALSE 55384
// if un then
55509: LD_VAR 0 3
55513: IFFALSE 55524
// RemoveUnit ( un ) ;
55515: LD_VAR 0 3
55519: PPUSH
55520: CALL_OW 64
// end ;
55524: PPOPN 3
55526: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55527: LD_EXP 146
55531: IFFALSE 55647
55533: GO 55535
55535: DISABLE
55536: LD_INT 0
55538: PPUSH
55539: PPUSH
55540: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55541: LD_ADDR_VAR 0 2
55545: PUSH
55546: LD_INT 81
55548: PUSH
55549: LD_OWVAR 2
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: PUSH
55558: LD_INT 21
55560: PUSH
55561: LD_INT 1
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: PUSH
55568: EMPTY
55569: LIST
55570: LIST
55571: PPUSH
55572: CALL_OW 69
55576: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55577: LD_STRING playComputer()
55579: PPUSH
55580: CALL_OW 559
// if not tmp then
55584: LD_VAR 0 2
55588: NOT
55589: IFFALSE 55593
// exit ;
55591: GO 55647
// for i in tmp do
55593: LD_ADDR_VAR 0 1
55597: PUSH
55598: LD_VAR 0 2
55602: PUSH
55603: FOR_IN
55604: IFFALSE 55645
// for j := 1 to 4 do
55606: LD_ADDR_VAR 0 3
55610: PUSH
55611: DOUBLE
55612: LD_INT 1
55614: DEC
55615: ST_TO_ADDR
55616: LD_INT 4
55618: PUSH
55619: FOR_TO
55620: IFFALSE 55641
// SetSkill ( i , j , 10 ) ;
55622: LD_VAR 0 1
55626: PPUSH
55627: LD_VAR 0 3
55631: PPUSH
55632: LD_INT 10
55634: PPUSH
55635: CALL_OW 237
55639: GO 55619
55641: POP
55642: POP
55643: GO 55603
55645: POP
55646: POP
// end ;
55647: PPOPN 3
55649: END
// every 0 0$1 trigger s30 do var i , tmp ;
55650: LD_EXP 147
55654: IFFALSE 55723
55656: GO 55658
55658: DISABLE
55659: LD_INT 0
55661: PPUSH
55662: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55663: LD_ADDR_VAR 0 2
55667: PUSH
55668: LD_INT 22
55670: PUSH
55671: LD_OWVAR 2
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: PPUSH
55680: CALL_OW 69
55684: ST_TO_ADDR
// if not tmp then
55685: LD_VAR 0 2
55689: NOT
55690: IFFALSE 55694
// exit ;
55692: GO 55723
// for i in tmp do
55694: LD_ADDR_VAR 0 1
55698: PUSH
55699: LD_VAR 0 2
55703: PUSH
55704: FOR_IN
55705: IFFALSE 55721
// SetLives ( i , 300 ) ;
55707: LD_VAR 0 1
55711: PPUSH
55712: LD_INT 300
55714: PPUSH
55715: CALL_OW 234
55719: GO 55704
55721: POP
55722: POP
// end ;
55723: PPOPN 2
55725: END
// every 0 0$1 trigger s60 do var i , tmp ;
55726: LD_EXP 148
55730: IFFALSE 55799
55732: GO 55734
55734: DISABLE
55735: LD_INT 0
55737: PPUSH
55738: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55739: LD_ADDR_VAR 0 2
55743: PUSH
55744: LD_INT 22
55746: PUSH
55747: LD_OWVAR 2
55751: PUSH
55752: EMPTY
55753: LIST
55754: LIST
55755: PPUSH
55756: CALL_OW 69
55760: ST_TO_ADDR
// if not tmp then
55761: LD_VAR 0 2
55765: NOT
55766: IFFALSE 55770
// exit ;
55768: GO 55799
// for i in tmp do
55770: LD_ADDR_VAR 0 1
55774: PUSH
55775: LD_VAR 0 2
55779: PUSH
55780: FOR_IN
55781: IFFALSE 55797
// SetLives ( i , 600 ) ;
55783: LD_VAR 0 1
55787: PPUSH
55788: LD_INT 600
55790: PPUSH
55791: CALL_OW 234
55795: GO 55780
55797: POP
55798: POP
// end ;
55799: PPOPN 2
55801: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55802: LD_INT 0
55804: PPUSH
// case cmd of 301 :
55805: LD_VAR 0 1
55809: PUSH
55810: LD_INT 301
55812: DOUBLE
55813: EQUAL
55814: IFTRUE 55818
55816: GO 55850
55818: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55819: LD_VAR 0 6
55823: PPUSH
55824: LD_VAR 0 7
55828: PPUSH
55829: LD_VAR 0 8
55833: PPUSH
55834: LD_VAR 0 4
55838: PPUSH
55839: LD_VAR 0 5
55843: PPUSH
55844: CALL 57051 0 5
55848: GO 55971
55850: LD_INT 302
55852: DOUBLE
55853: EQUAL
55854: IFTRUE 55858
55856: GO 55895
55858: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55859: LD_VAR 0 6
55863: PPUSH
55864: LD_VAR 0 7
55868: PPUSH
55869: LD_VAR 0 8
55873: PPUSH
55874: LD_VAR 0 9
55878: PPUSH
55879: LD_VAR 0 4
55883: PPUSH
55884: LD_VAR 0 5
55888: PPUSH
55889: CALL 57142 0 6
55893: GO 55971
55895: LD_INT 303
55897: DOUBLE
55898: EQUAL
55899: IFTRUE 55903
55901: GO 55940
55903: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55904: LD_VAR 0 6
55908: PPUSH
55909: LD_VAR 0 7
55913: PPUSH
55914: LD_VAR 0 8
55918: PPUSH
55919: LD_VAR 0 9
55923: PPUSH
55924: LD_VAR 0 4
55928: PPUSH
55929: LD_VAR 0 5
55933: PPUSH
55934: CALL 55976 0 6
55938: GO 55971
55940: LD_INT 304
55942: DOUBLE
55943: EQUAL
55944: IFTRUE 55948
55946: GO 55970
55948: POP
// hHackTeleport ( unit , x , y ) ; end ;
55949: LD_VAR 0 2
55953: PPUSH
55954: LD_VAR 0 4
55958: PPUSH
55959: LD_VAR 0 5
55963: PPUSH
55964: CALL 57735 0 3
55968: GO 55971
55970: POP
// end ;
55971: LD_VAR 0 12
55975: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55976: LD_INT 0
55978: PPUSH
55979: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55980: LD_VAR 0 1
55984: PUSH
55985: LD_INT 1
55987: LESS
55988: PUSH
55989: LD_VAR 0 1
55993: PUSH
55994: LD_INT 3
55996: GREATER
55997: OR
55998: PUSH
55999: LD_VAR 0 5
56003: PPUSH
56004: LD_VAR 0 6
56008: PPUSH
56009: CALL_OW 428
56013: OR
56014: IFFALSE 56018
// exit ;
56016: GO 56738
// uc_side := your_side ;
56018: LD_ADDR_OWVAR 20
56022: PUSH
56023: LD_OWVAR 2
56027: ST_TO_ADDR
// uc_nation := nation ;
56028: LD_ADDR_OWVAR 21
56032: PUSH
56033: LD_VAR 0 1
56037: ST_TO_ADDR
// bc_level = 1 ;
56038: LD_ADDR_OWVAR 43
56042: PUSH
56043: LD_INT 1
56045: ST_TO_ADDR
// case btype of 1 :
56046: LD_VAR 0 2
56050: PUSH
56051: LD_INT 1
56053: DOUBLE
56054: EQUAL
56055: IFTRUE 56059
56057: GO 56070
56059: POP
// bc_type := b_depot ; 2 :
56060: LD_ADDR_OWVAR 42
56064: PUSH
56065: LD_INT 0
56067: ST_TO_ADDR
56068: GO 56682
56070: LD_INT 2
56072: DOUBLE
56073: EQUAL
56074: IFTRUE 56078
56076: GO 56089
56078: POP
// bc_type := b_warehouse ; 3 :
56079: LD_ADDR_OWVAR 42
56083: PUSH
56084: LD_INT 1
56086: ST_TO_ADDR
56087: GO 56682
56089: LD_INT 3
56091: DOUBLE
56092: EQUAL
56093: IFTRUE 56097
56095: GO 56108
56097: POP
// bc_type := b_lab ; 4 .. 9 :
56098: LD_ADDR_OWVAR 42
56102: PUSH
56103: LD_INT 6
56105: ST_TO_ADDR
56106: GO 56682
56108: LD_INT 4
56110: DOUBLE
56111: GREATEREQUAL
56112: IFFALSE 56120
56114: LD_INT 9
56116: DOUBLE
56117: LESSEQUAL
56118: IFTRUE 56122
56120: GO 56174
56122: POP
// begin bc_type := b_lab_half ;
56123: LD_ADDR_OWVAR 42
56127: PUSH
56128: LD_INT 7
56130: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56131: LD_ADDR_OWVAR 44
56135: PUSH
56136: LD_INT 10
56138: PUSH
56139: LD_INT 11
56141: PUSH
56142: LD_INT 12
56144: PUSH
56145: LD_INT 15
56147: PUSH
56148: LD_INT 14
56150: PUSH
56151: LD_INT 13
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: LIST
56158: LIST
56159: LIST
56160: LIST
56161: PUSH
56162: LD_VAR 0 2
56166: PUSH
56167: LD_INT 3
56169: MINUS
56170: ARRAY
56171: ST_TO_ADDR
// end ; 10 .. 13 :
56172: GO 56682
56174: LD_INT 10
56176: DOUBLE
56177: GREATEREQUAL
56178: IFFALSE 56186
56180: LD_INT 13
56182: DOUBLE
56183: LESSEQUAL
56184: IFTRUE 56188
56186: GO 56265
56188: POP
// begin bc_type := b_lab_full ;
56189: LD_ADDR_OWVAR 42
56193: PUSH
56194: LD_INT 8
56196: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56197: LD_ADDR_OWVAR 44
56201: PUSH
56202: LD_INT 10
56204: PUSH
56205: LD_INT 12
56207: PUSH
56208: LD_INT 14
56210: PUSH
56211: LD_INT 13
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: LIST
56218: LIST
56219: PUSH
56220: LD_VAR 0 2
56224: PUSH
56225: LD_INT 9
56227: MINUS
56228: ARRAY
56229: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56230: LD_ADDR_OWVAR 45
56234: PUSH
56235: LD_INT 11
56237: PUSH
56238: LD_INT 15
56240: PUSH
56241: LD_INT 12
56243: PUSH
56244: LD_INT 15
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: LIST
56251: LIST
56252: PUSH
56253: LD_VAR 0 2
56257: PUSH
56258: LD_INT 9
56260: MINUS
56261: ARRAY
56262: ST_TO_ADDR
// end ; 14 :
56263: GO 56682
56265: LD_INT 14
56267: DOUBLE
56268: EQUAL
56269: IFTRUE 56273
56271: GO 56284
56273: POP
// bc_type := b_workshop ; 15 :
56274: LD_ADDR_OWVAR 42
56278: PUSH
56279: LD_INT 2
56281: ST_TO_ADDR
56282: GO 56682
56284: LD_INT 15
56286: DOUBLE
56287: EQUAL
56288: IFTRUE 56292
56290: GO 56303
56292: POP
// bc_type := b_factory ; 16 :
56293: LD_ADDR_OWVAR 42
56297: PUSH
56298: LD_INT 3
56300: ST_TO_ADDR
56301: GO 56682
56303: LD_INT 16
56305: DOUBLE
56306: EQUAL
56307: IFTRUE 56311
56309: GO 56322
56311: POP
// bc_type := b_ext_gun ; 17 :
56312: LD_ADDR_OWVAR 42
56316: PUSH
56317: LD_INT 17
56319: ST_TO_ADDR
56320: GO 56682
56322: LD_INT 17
56324: DOUBLE
56325: EQUAL
56326: IFTRUE 56330
56328: GO 56358
56330: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56331: LD_ADDR_OWVAR 42
56335: PUSH
56336: LD_INT 19
56338: PUSH
56339: LD_INT 23
56341: PUSH
56342: LD_INT 19
56344: PUSH
56345: EMPTY
56346: LIST
56347: LIST
56348: LIST
56349: PUSH
56350: LD_VAR 0 1
56354: ARRAY
56355: ST_TO_ADDR
56356: GO 56682
56358: LD_INT 18
56360: DOUBLE
56361: EQUAL
56362: IFTRUE 56366
56364: GO 56377
56366: POP
// bc_type := b_ext_radar ; 19 :
56367: LD_ADDR_OWVAR 42
56371: PUSH
56372: LD_INT 20
56374: ST_TO_ADDR
56375: GO 56682
56377: LD_INT 19
56379: DOUBLE
56380: EQUAL
56381: IFTRUE 56385
56383: GO 56396
56385: POP
// bc_type := b_ext_radio ; 20 :
56386: LD_ADDR_OWVAR 42
56390: PUSH
56391: LD_INT 22
56393: ST_TO_ADDR
56394: GO 56682
56396: LD_INT 20
56398: DOUBLE
56399: EQUAL
56400: IFTRUE 56404
56402: GO 56415
56404: POP
// bc_type := b_ext_siberium ; 21 :
56405: LD_ADDR_OWVAR 42
56409: PUSH
56410: LD_INT 21
56412: ST_TO_ADDR
56413: GO 56682
56415: LD_INT 21
56417: DOUBLE
56418: EQUAL
56419: IFTRUE 56423
56421: GO 56434
56423: POP
// bc_type := b_ext_computer ; 22 :
56424: LD_ADDR_OWVAR 42
56428: PUSH
56429: LD_INT 24
56431: ST_TO_ADDR
56432: GO 56682
56434: LD_INT 22
56436: DOUBLE
56437: EQUAL
56438: IFTRUE 56442
56440: GO 56453
56442: POP
// bc_type := b_ext_track ; 23 :
56443: LD_ADDR_OWVAR 42
56447: PUSH
56448: LD_INT 16
56450: ST_TO_ADDR
56451: GO 56682
56453: LD_INT 23
56455: DOUBLE
56456: EQUAL
56457: IFTRUE 56461
56459: GO 56472
56461: POP
// bc_type := b_ext_laser ; 24 :
56462: LD_ADDR_OWVAR 42
56466: PUSH
56467: LD_INT 25
56469: ST_TO_ADDR
56470: GO 56682
56472: LD_INT 24
56474: DOUBLE
56475: EQUAL
56476: IFTRUE 56480
56478: GO 56491
56480: POP
// bc_type := b_control_tower ; 25 :
56481: LD_ADDR_OWVAR 42
56485: PUSH
56486: LD_INT 36
56488: ST_TO_ADDR
56489: GO 56682
56491: LD_INT 25
56493: DOUBLE
56494: EQUAL
56495: IFTRUE 56499
56497: GO 56510
56499: POP
// bc_type := b_breastwork ; 26 :
56500: LD_ADDR_OWVAR 42
56504: PUSH
56505: LD_INT 31
56507: ST_TO_ADDR
56508: GO 56682
56510: LD_INT 26
56512: DOUBLE
56513: EQUAL
56514: IFTRUE 56518
56516: GO 56529
56518: POP
// bc_type := b_bunker ; 27 :
56519: LD_ADDR_OWVAR 42
56523: PUSH
56524: LD_INT 32
56526: ST_TO_ADDR
56527: GO 56682
56529: LD_INT 27
56531: DOUBLE
56532: EQUAL
56533: IFTRUE 56537
56535: GO 56548
56537: POP
// bc_type := b_turret ; 28 :
56538: LD_ADDR_OWVAR 42
56542: PUSH
56543: LD_INT 33
56545: ST_TO_ADDR
56546: GO 56682
56548: LD_INT 28
56550: DOUBLE
56551: EQUAL
56552: IFTRUE 56556
56554: GO 56567
56556: POP
// bc_type := b_armoury ; 29 :
56557: LD_ADDR_OWVAR 42
56561: PUSH
56562: LD_INT 4
56564: ST_TO_ADDR
56565: GO 56682
56567: LD_INT 29
56569: DOUBLE
56570: EQUAL
56571: IFTRUE 56575
56573: GO 56586
56575: POP
// bc_type := b_barracks ; 30 :
56576: LD_ADDR_OWVAR 42
56580: PUSH
56581: LD_INT 5
56583: ST_TO_ADDR
56584: GO 56682
56586: LD_INT 30
56588: DOUBLE
56589: EQUAL
56590: IFTRUE 56594
56592: GO 56605
56594: POP
// bc_type := b_solar_power ; 31 :
56595: LD_ADDR_OWVAR 42
56599: PUSH
56600: LD_INT 27
56602: ST_TO_ADDR
56603: GO 56682
56605: LD_INT 31
56607: DOUBLE
56608: EQUAL
56609: IFTRUE 56613
56611: GO 56624
56613: POP
// bc_type := b_oil_power ; 32 :
56614: LD_ADDR_OWVAR 42
56618: PUSH
56619: LD_INT 26
56621: ST_TO_ADDR
56622: GO 56682
56624: LD_INT 32
56626: DOUBLE
56627: EQUAL
56628: IFTRUE 56632
56630: GO 56643
56632: POP
// bc_type := b_siberite_power ; 33 :
56633: LD_ADDR_OWVAR 42
56637: PUSH
56638: LD_INT 28
56640: ST_TO_ADDR
56641: GO 56682
56643: LD_INT 33
56645: DOUBLE
56646: EQUAL
56647: IFTRUE 56651
56649: GO 56662
56651: POP
// bc_type := b_oil_mine ; 34 :
56652: LD_ADDR_OWVAR 42
56656: PUSH
56657: LD_INT 29
56659: ST_TO_ADDR
56660: GO 56682
56662: LD_INT 34
56664: DOUBLE
56665: EQUAL
56666: IFTRUE 56670
56668: GO 56681
56670: POP
// bc_type := b_siberite_mine ; end ;
56671: LD_ADDR_OWVAR 42
56675: PUSH
56676: LD_INT 30
56678: ST_TO_ADDR
56679: GO 56682
56681: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56682: LD_ADDR_VAR 0 8
56686: PUSH
56687: LD_VAR 0 5
56691: PPUSH
56692: LD_VAR 0 6
56696: PPUSH
56697: LD_VAR 0 3
56701: PPUSH
56702: CALL_OW 47
56706: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56707: LD_OWVAR 42
56711: PUSH
56712: LD_INT 32
56714: PUSH
56715: LD_INT 33
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: IN
56722: IFFALSE 56738
// PlaceWeaponTurret ( b , weapon ) ;
56724: LD_VAR 0 8
56728: PPUSH
56729: LD_VAR 0 4
56733: PPUSH
56734: CALL_OW 431
// end ;
56738: LD_VAR 0 7
56742: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56743: LD_INT 0
56745: PPUSH
56746: PPUSH
56747: PPUSH
56748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56749: LD_ADDR_VAR 0 4
56753: PUSH
56754: LD_INT 22
56756: PUSH
56757: LD_OWVAR 2
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: PUSH
56766: LD_INT 2
56768: PUSH
56769: LD_INT 30
56771: PUSH
56772: LD_INT 0
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PUSH
56779: LD_INT 30
56781: PUSH
56782: LD_INT 1
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: LIST
56793: PUSH
56794: EMPTY
56795: LIST
56796: LIST
56797: PPUSH
56798: CALL_OW 69
56802: ST_TO_ADDR
// if not tmp then
56803: LD_VAR 0 4
56807: NOT
56808: IFFALSE 56812
// exit ;
56810: GO 56871
// for i in tmp do
56812: LD_ADDR_VAR 0 2
56816: PUSH
56817: LD_VAR 0 4
56821: PUSH
56822: FOR_IN
56823: IFFALSE 56869
// for j = 1 to 3 do
56825: LD_ADDR_VAR 0 3
56829: PUSH
56830: DOUBLE
56831: LD_INT 1
56833: DEC
56834: ST_TO_ADDR
56835: LD_INT 3
56837: PUSH
56838: FOR_TO
56839: IFFALSE 56865
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56841: LD_VAR 0 2
56845: PPUSH
56846: CALL_OW 274
56850: PPUSH
56851: LD_VAR 0 3
56855: PPUSH
56856: LD_INT 99999
56858: PPUSH
56859: CALL_OW 277
56863: GO 56838
56865: POP
56866: POP
56867: GO 56822
56869: POP
56870: POP
// end ;
56871: LD_VAR 0 1
56875: RET
// export function hHackSetLevel10 ; var i , j ; begin
56876: LD_INT 0
56878: PPUSH
56879: PPUSH
56880: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56881: LD_ADDR_VAR 0 2
56885: PUSH
56886: LD_INT 21
56888: PUSH
56889: LD_INT 1
56891: PUSH
56892: EMPTY
56893: LIST
56894: LIST
56895: PPUSH
56896: CALL_OW 69
56900: PUSH
56901: FOR_IN
56902: IFFALSE 56954
// if IsSelected ( i ) then
56904: LD_VAR 0 2
56908: PPUSH
56909: CALL_OW 306
56913: IFFALSE 56952
// begin for j := 1 to 4 do
56915: LD_ADDR_VAR 0 3
56919: PUSH
56920: DOUBLE
56921: LD_INT 1
56923: DEC
56924: ST_TO_ADDR
56925: LD_INT 4
56927: PUSH
56928: FOR_TO
56929: IFFALSE 56950
// SetSkill ( i , j , 10 ) ;
56931: LD_VAR 0 2
56935: PPUSH
56936: LD_VAR 0 3
56940: PPUSH
56941: LD_INT 10
56943: PPUSH
56944: CALL_OW 237
56948: GO 56928
56950: POP
56951: POP
// end ;
56952: GO 56901
56954: POP
56955: POP
// end ;
56956: LD_VAR 0 1
56960: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56961: LD_INT 0
56963: PPUSH
56964: PPUSH
56965: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56966: LD_ADDR_VAR 0 2
56970: PUSH
56971: LD_INT 22
56973: PUSH
56974: LD_OWVAR 2
56978: PUSH
56979: EMPTY
56980: LIST
56981: LIST
56982: PUSH
56983: LD_INT 21
56985: PUSH
56986: LD_INT 1
56988: PUSH
56989: EMPTY
56990: LIST
56991: LIST
56992: PUSH
56993: EMPTY
56994: LIST
56995: LIST
56996: PPUSH
56997: CALL_OW 69
57001: PUSH
57002: FOR_IN
57003: IFFALSE 57044
// begin for j := 1 to 4 do
57005: LD_ADDR_VAR 0 3
57009: PUSH
57010: DOUBLE
57011: LD_INT 1
57013: DEC
57014: ST_TO_ADDR
57015: LD_INT 4
57017: PUSH
57018: FOR_TO
57019: IFFALSE 57040
// SetSkill ( i , j , 10 ) ;
57021: LD_VAR 0 2
57025: PPUSH
57026: LD_VAR 0 3
57030: PPUSH
57031: LD_INT 10
57033: PPUSH
57034: CALL_OW 237
57038: GO 57018
57040: POP
57041: POP
// end ;
57042: GO 57002
57044: POP
57045: POP
// end ;
57046: LD_VAR 0 1
57050: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57051: LD_INT 0
57053: PPUSH
// uc_side := your_side ;
57054: LD_ADDR_OWVAR 20
57058: PUSH
57059: LD_OWVAR 2
57063: ST_TO_ADDR
// uc_nation := nation ;
57064: LD_ADDR_OWVAR 21
57068: PUSH
57069: LD_VAR 0 1
57073: ST_TO_ADDR
// InitHc ;
57074: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57078: LD_INT 0
57080: PPUSH
57081: LD_VAR 0 2
57085: PPUSH
57086: LD_VAR 0 3
57090: PPUSH
57091: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57095: LD_VAR 0 4
57099: PPUSH
57100: LD_VAR 0 5
57104: PPUSH
57105: CALL_OW 428
57109: PUSH
57110: LD_INT 0
57112: EQUAL
57113: IFFALSE 57137
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57115: CALL_OW 44
57119: PPUSH
57120: LD_VAR 0 4
57124: PPUSH
57125: LD_VAR 0 5
57129: PPUSH
57130: LD_INT 1
57132: PPUSH
57133: CALL_OW 48
// end ;
57137: LD_VAR 0 6
57141: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57142: LD_INT 0
57144: PPUSH
57145: PPUSH
// uc_side := your_side ;
57146: LD_ADDR_OWVAR 20
57150: PUSH
57151: LD_OWVAR 2
57155: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57156: LD_VAR 0 1
57160: PUSH
57161: LD_INT 1
57163: PUSH
57164: LD_INT 2
57166: PUSH
57167: LD_INT 3
57169: PUSH
57170: LD_INT 4
57172: PUSH
57173: LD_INT 5
57175: PUSH
57176: EMPTY
57177: LIST
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: IN
57183: IFFALSE 57195
// uc_nation := nation_american else
57185: LD_ADDR_OWVAR 21
57189: PUSH
57190: LD_INT 1
57192: ST_TO_ADDR
57193: GO 57238
// if chassis in [ 11 , 12 , 13 , 14 ] then
57195: LD_VAR 0 1
57199: PUSH
57200: LD_INT 11
57202: PUSH
57203: LD_INT 12
57205: PUSH
57206: LD_INT 13
57208: PUSH
57209: LD_INT 14
57211: PUSH
57212: EMPTY
57213: LIST
57214: LIST
57215: LIST
57216: LIST
57217: IN
57218: IFFALSE 57230
// uc_nation := nation_arabian else
57220: LD_ADDR_OWVAR 21
57224: PUSH
57225: LD_INT 2
57227: ST_TO_ADDR
57228: GO 57238
// uc_nation := nation_russian ;
57230: LD_ADDR_OWVAR 21
57234: PUSH
57235: LD_INT 3
57237: ST_TO_ADDR
// vc_chassis := chassis ;
57238: LD_ADDR_OWVAR 37
57242: PUSH
57243: LD_VAR 0 1
57247: ST_TO_ADDR
// vc_engine := engine ;
57248: LD_ADDR_OWVAR 39
57252: PUSH
57253: LD_VAR 0 2
57257: ST_TO_ADDR
// vc_control := control ;
57258: LD_ADDR_OWVAR 38
57262: PUSH
57263: LD_VAR 0 3
57267: ST_TO_ADDR
// vc_weapon := weapon ;
57268: LD_ADDR_OWVAR 40
57272: PUSH
57273: LD_VAR 0 4
57277: ST_TO_ADDR
// un := CreateVehicle ;
57278: LD_ADDR_VAR 0 8
57282: PUSH
57283: CALL_OW 45
57287: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57288: LD_VAR 0 8
57292: PPUSH
57293: LD_INT 0
57295: PPUSH
57296: LD_INT 5
57298: PPUSH
57299: CALL_OW 12
57303: PPUSH
57304: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57308: LD_VAR 0 8
57312: PPUSH
57313: LD_VAR 0 5
57317: PPUSH
57318: LD_VAR 0 6
57322: PPUSH
57323: LD_INT 1
57325: PPUSH
57326: CALL_OW 48
// end ;
57330: LD_VAR 0 7
57334: RET
// export hInvincible ; every 1 do
57335: GO 57337
57337: DISABLE
// hInvincible := [ ] ;
57338: LD_ADDR_EXP 149
57342: PUSH
57343: EMPTY
57344: ST_TO_ADDR
57345: END
// every 10 do var i ;
57346: GO 57348
57348: DISABLE
57349: LD_INT 0
57351: PPUSH
// begin enable ;
57352: ENABLE
// if not hInvincible then
57353: LD_EXP 149
57357: NOT
57358: IFFALSE 57362
// exit ;
57360: GO 57406
// for i in hInvincible do
57362: LD_ADDR_VAR 0 1
57366: PUSH
57367: LD_EXP 149
57371: PUSH
57372: FOR_IN
57373: IFFALSE 57404
// if GetLives ( i ) < 1000 then
57375: LD_VAR 0 1
57379: PPUSH
57380: CALL_OW 256
57384: PUSH
57385: LD_INT 1000
57387: LESS
57388: IFFALSE 57402
// SetLives ( i , 1000 ) ;
57390: LD_VAR 0 1
57394: PPUSH
57395: LD_INT 1000
57397: PPUSH
57398: CALL_OW 234
57402: GO 57372
57404: POP
57405: POP
// end ;
57406: PPOPN 1
57408: END
// export function hHackInvincible ; var i ; begin
57409: LD_INT 0
57411: PPUSH
57412: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57413: LD_ADDR_VAR 0 2
57417: PUSH
57418: LD_INT 2
57420: PUSH
57421: LD_INT 21
57423: PUSH
57424: LD_INT 1
57426: PUSH
57427: EMPTY
57428: LIST
57429: LIST
57430: PUSH
57431: LD_INT 21
57433: PUSH
57434: LD_INT 2
57436: PUSH
57437: EMPTY
57438: LIST
57439: LIST
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: LIST
57445: PPUSH
57446: CALL_OW 69
57450: PUSH
57451: FOR_IN
57452: IFFALSE 57513
// if IsSelected ( i ) then
57454: LD_VAR 0 2
57458: PPUSH
57459: CALL_OW 306
57463: IFFALSE 57511
// begin if i in hInvincible then
57465: LD_VAR 0 2
57469: PUSH
57470: LD_EXP 149
57474: IN
57475: IFFALSE 57495
// hInvincible := hInvincible diff i else
57477: LD_ADDR_EXP 149
57481: PUSH
57482: LD_EXP 149
57486: PUSH
57487: LD_VAR 0 2
57491: DIFF
57492: ST_TO_ADDR
57493: GO 57511
// hInvincible := hInvincible union i ;
57495: LD_ADDR_EXP 149
57499: PUSH
57500: LD_EXP 149
57504: PUSH
57505: LD_VAR 0 2
57509: UNION
57510: ST_TO_ADDR
// end ;
57511: GO 57451
57513: POP
57514: POP
// end ;
57515: LD_VAR 0 1
57519: RET
// export function hHackInvisible ; var i , j ; begin
57520: LD_INT 0
57522: PPUSH
57523: PPUSH
57524: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57525: LD_ADDR_VAR 0 2
57529: PUSH
57530: LD_INT 21
57532: PUSH
57533: LD_INT 1
57535: PUSH
57536: EMPTY
57537: LIST
57538: LIST
57539: PPUSH
57540: CALL_OW 69
57544: PUSH
57545: FOR_IN
57546: IFFALSE 57570
// if IsSelected ( i ) then
57548: LD_VAR 0 2
57552: PPUSH
57553: CALL_OW 306
57557: IFFALSE 57568
// ComForceInvisible ( i ) ;
57559: LD_VAR 0 2
57563: PPUSH
57564: CALL_OW 496
57568: GO 57545
57570: POP
57571: POP
// end ;
57572: LD_VAR 0 1
57576: RET
// export function hHackChangeYourSide ; begin
57577: LD_INT 0
57579: PPUSH
// if your_side = 8 then
57580: LD_OWVAR 2
57584: PUSH
57585: LD_INT 8
57587: EQUAL
57588: IFFALSE 57600
// your_side := 0 else
57590: LD_ADDR_OWVAR 2
57594: PUSH
57595: LD_INT 0
57597: ST_TO_ADDR
57598: GO 57614
// your_side := your_side + 1 ;
57600: LD_ADDR_OWVAR 2
57604: PUSH
57605: LD_OWVAR 2
57609: PUSH
57610: LD_INT 1
57612: PLUS
57613: ST_TO_ADDR
// end ;
57614: LD_VAR 0 1
57618: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57619: LD_INT 0
57621: PPUSH
57622: PPUSH
57623: PPUSH
// for i in all_units do
57624: LD_ADDR_VAR 0 2
57628: PUSH
57629: LD_OWVAR 3
57633: PUSH
57634: FOR_IN
57635: IFFALSE 57713
// if IsSelected ( i ) then
57637: LD_VAR 0 2
57641: PPUSH
57642: CALL_OW 306
57646: IFFALSE 57711
// begin j := GetSide ( i ) ;
57648: LD_ADDR_VAR 0 3
57652: PUSH
57653: LD_VAR 0 2
57657: PPUSH
57658: CALL_OW 255
57662: ST_TO_ADDR
// if j = 8 then
57663: LD_VAR 0 3
57667: PUSH
57668: LD_INT 8
57670: EQUAL
57671: IFFALSE 57683
// j := 0 else
57673: LD_ADDR_VAR 0 3
57677: PUSH
57678: LD_INT 0
57680: ST_TO_ADDR
57681: GO 57697
// j := j + 1 ;
57683: LD_ADDR_VAR 0 3
57687: PUSH
57688: LD_VAR 0 3
57692: PUSH
57693: LD_INT 1
57695: PLUS
57696: ST_TO_ADDR
// SetSide ( i , j ) ;
57697: LD_VAR 0 2
57701: PPUSH
57702: LD_VAR 0 3
57706: PPUSH
57707: CALL_OW 235
// end ;
57711: GO 57634
57713: POP
57714: POP
// end ;
57715: LD_VAR 0 1
57719: RET
// export function hHackFog ; begin
57720: LD_INT 0
57722: PPUSH
// FogOff ( true ) ;
57723: LD_INT 1
57725: PPUSH
57726: CALL_OW 344
// end ;
57730: LD_VAR 0 1
57734: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57735: LD_INT 0
57737: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57738: LD_VAR 0 1
57742: PPUSH
57743: LD_VAR 0 2
57747: PPUSH
57748: LD_VAR 0 3
57752: PPUSH
57753: LD_INT 1
57755: PPUSH
57756: LD_INT 1
57758: PPUSH
57759: CALL_OW 483
// CenterOnXY ( x , y ) ;
57763: LD_VAR 0 2
57767: PPUSH
57768: LD_VAR 0 3
57772: PPUSH
57773: CALL_OW 84
// end ; end_of_file
57777: LD_VAR 0 4
57781: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
57782: LD_INT 0
57784: PPUSH
57785: PPUSH
57786: PPUSH
57787: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
57788: LD_VAR 0 1
57792: PPUSH
57793: CALL_OW 264
57797: PUSH
57798: LD_EXP 77
57802: EQUAL
57803: IFFALSE 57875
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
57805: LD_INT 68
57807: PPUSH
57808: LD_VAR 0 1
57812: PPUSH
57813: CALL_OW 255
57817: PPUSH
57818: CALL_OW 321
57822: PUSH
57823: LD_INT 2
57825: EQUAL
57826: IFFALSE 57838
// eff := 70 else
57828: LD_ADDR_VAR 0 4
57832: PUSH
57833: LD_INT 70
57835: ST_TO_ADDR
57836: GO 57846
// eff := 30 ;
57838: LD_ADDR_VAR 0 4
57842: PUSH
57843: LD_INT 30
57845: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
57846: LD_VAR 0 1
57850: PPUSH
57851: CALL_OW 250
57855: PPUSH
57856: LD_VAR 0 1
57860: PPUSH
57861: CALL_OW 251
57865: PPUSH
57866: LD_VAR 0 4
57870: PPUSH
57871: CALL_OW 495
// end ; end ;
57875: LD_VAR 0 2
57879: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
57880: LD_INT 0
57882: PPUSH
// end ;
57883: LD_VAR 0 4
57887: RET
// export function SOS_Command ( cmd ) ; begin
57888: LD_INT 0
57890: PPUSH
// end ;
57891: LD_VAR 0 2
57895: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
57896: LD_INT 0
57898: PPUSH
// end ;
57899: LD_VAR 0 6
57903: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
57904: LD_INT 0
57906: PPUSH
57907: PPUSH
// if not vehicle or not factory then
57908: LD_VAR 0 1
57912: NOT
57913: PUSH
57914: LD_VAR 0 2
57918: NOT
57919: OR
57920: IFFALSE 57924
// exit ;
57922: GO 58155
// if factoryWaypoints >= factory then
57924: LD_EXP 150
57928: PUSH
57929: LD_VAR 0 2
57933: GREATEREQUAL
57934: IFFALSE 58155
// if factoryWaypoints [ factory ] then
57936: LD_EXP 150
57940: PUSH
57941: LD_VAR 0 2
57945: ARRAY
57946: IFFALSE 58155
// begin if GetControl ( vehicle ) = control_manual then
57948: LD_VAR 0 1
57952: PPUSH
57953: CALL_OW 263
57957: PUSH
57958: LD_INT 1
57960: EQUAL
57961: IFFALSE 58042
// begin driver := IsDrivenBy ( vehicle ) ;
57963: LD_ADDR_VAR 0 4
57967: PUSH
57968: LD_VAR 0 1
57972: PPUSH
57973: CALL_OW 311
57977: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
57978: LD_VAR 0 4
57982: PPUSH
57983: LD_EXP 150
57987: PUSH
57988: LD_VAR 0 2
57992: ARRAY
57993: PUSH
57994: LD_INT 3
57996: ARRAY
57997: PPUSH
57998: LD_EXP 150
58002: PUSH
58003: LD_VAR 0 2
58007: ARRAY
58008: PUSH
58009: LD_INT 4
58011: ARRAY
58012: PPUSH
58013: CALL_OW 171
// AddComExitVehicle ( driver ) ;
58017: LD_VAR 0 4
58021: PPUSH
58022: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
58026: LD_VAR 0 4
58030: PPUSH
58031: LD_VAR 0 2
58035: PPUSH
58036: CALL_OW 180
// end else
58040: GO 58155
// if GetControl ( vehicle ) = control_remote then
58042: LD_VAR 0 1
58046: PPUSH
58047: CALL_OW 263
58051: PUSH
58052: LD_INT 2
58054: EQUAL
58055: IFFALSE 58116
// begin wait ( 0 0$2 ) ;
58057: LD_INT 70
58059: PPUSH
58060: CALL_OW 67
// if Connect ( vehicle ) then
58064: LD_VAR 0 1
58068: PPUSH
58069: CALL 70379 0 1
58073: IFFALSE 58114
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
58075: LD_VAR 0 1
58079: PPUSH
58080: LD_EXP 150
58084: PUSH
58085: LD_VAR 0 2
58089: ARRAY
58090: PUSH
58091: LD_INT 3
58093: ARRAY
58094: PPUSH
58095: LD_EXP 150
58099: PUSH
58100: LD_VAR 0 2
58104: ARRAY
58105: PUSH
58106: LD_INT 4
58108: ARRAY
58109: PPUSH
58110: CALL_OW 171
// end else
58114: GO 58155
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
58116: LD_VAR 0 1
58120: PPUSH
58121: LD_EXP 150
58125: PUSH
58126: LD_VAR 0 2
58130: ARRAY
58131: PUSH
58132: LD_INT 3
58134: ARRAY
58135: PPUSH
58136: LD_EXP 150
58140: PUSH
58141: LD_VAR 0 2
58145: ARRAY
58146: PUSH
58147: LD_INT 4
58149: ARRAY
58150: PPUSH
58151: CALL_OW 171
// end ; end ;
58155: LD_VAR 0 3
58159: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
58160: LD_INT 0
58162: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
58163: LD_VAR 0 1
58167: PUSH
58168: LD_INT 250
58170: EQUAL
58171: PUSH
58172: LD_VAR 0 2
58176: PPUSH
58177: CALL_OW 264
58181: PUSH
58182: LD_EXP 80
58186: EQUAL
58187: AND
58188: IFFALSE 58209
// MinerPlaceMine ( unit , x , y ) ;
58190: LD_VAR 0 2
58194: PPUSH
58195: LD_VAR 0 4
58199: PPUSH
58200: LD_VAR 0 5
58204: PPUSH
58205: CALL 60937 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
58209: LD_VAR 0 1
58213: PUSH
58214: LD_INT 251
58216: EQUAL
58217: PUSH
58218: LD_VAR 0 2
58222: PPUSH
58223: CALL_OW 264
58227: PUSH
58228: LD_EXP 80
58232: EQUAL
58233: AND
58234: IFFALSE 58255
// MinerDetonateMine ( unit , x , y ) ;
58236: LD_VAR 0 2
58240: PPUSH
58241: LD_VAR 0 4
58245: PPUSH
58246: LD_VAR 0 5
58250: PPUSH
58251: CALL 61214 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
58255: LD_VAR 0 1
58259: PUSH
58260: LD_INT 252
58262: EQUAL
58263: PUSH
58264: LD_VAR 0 2
58268: PPUSH
58269: CALL_OW 264
58273: PUSH
58274: LD_EXP 80
58278: EQUAL
58279: AND
58280: IFFALSE 58301
// MinerCreateMinefield ( unit , x , y ) ;
58282: LD_VAR 0 2
58286: PPUSH
58287: LD_VAR 0 4
58291: PPUSH
58292: LD_VAR 0 5
58296: PPUSH
58297: CALL 61631 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
58301: LD_VAR 0 1
58305: PUSH
58306: LD_INT 253
58308: EQUAL
58309: PUSH
58310: LD_VAR 0 2
58314: PPUSH
58315: CALL_OW 257
58319: PUSH
58320: LD_INT 5
58322: EQUAL
58323: AND
58324: IFFALSE 58345
// ComBinocular ( unit , x , y ) ;
58326: LD_VAR 0 2
58330: PPUSH
58331: LD_VAR 0 4
58335: PPUSH
58336: LD_VAR 0 5
58340: PPUSH
58341: CALL 62002 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
58345: LD_VAR 0 1
58349: PUSH
58350: LD_INT 254
58352: EQUAL
58353: PUSH
58354: LD_VAR 0 2
58358: PPUSH
58359: CALL_OW 264
58363: PUSH
58364: LD_EXP 75
58368: EQUAL
58369: AND
58370: PUSH
58371: LD_VAR 0 3
58375: PPUSH
58376: CALL_OW 263
58380: PUSH
58381: LD_INT 3
58383: EQUAL
58384: AND
58385: IFFALSE 58401
// HackDestroyVehicle ( unit , selectedUnit ) ;
58387: LD_VAR 0 2
58391: PPUSH
58392: LD_VAR 0 3
58396: PPUSH
58397: CALL 60297 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
58401: LD_VAR 0 1
58405: PUSH
58406: LD_INT 255
58408: EQUAL
58409: PUSH
58410: LD_VAR 0 2
58414: PPUSH
58415: CALL_OW 264
58419: PUSH
58420: LD_INT 14
58422: PUSH
58423: LD_INT 53
58425: PUSH
58426: EMPTY
58427: LIST
58428: LIST
58429: IN
58430: AND
58431: PUSH
58432: LD_VAR 0 4
58436: PPUSH
58437: LD_VAR 0 5
58441: PPUSH
58442: CALL_OW 488
58446: AND
58447: IFFALSE 58471
// CutTreeXYR ( unit , x , y , 12 ) ;
58449: LD_VAR 0 2
58453: PPUSH
58454: LD_VAR 0 4
58458: PPUSH
58459: LD_VAR 0 5
58463: PPUSH
58464: LD_INT 12
58466: PPUSH
58467: CALL 58863 0 4
// if cmd = 256 then
58471: LD_VAR 0 1
58475: PUSH
58476: LD_INT 256
58478: EQUAL
58479: IFFALSE 58500
// SetFactoryWaypoint ( unit , x , y ) ;
58481: LD_VAR 0 2
58485: PPUSH
58486: LD_VAR 0 4
58490: PPUSH
58491: LD_VAR 0 5
58495: PPUSH
58496: CALL 58505 0 3
// end ;
58500: LD_VAR 0 6
58504: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
58505: LD_INT 0
58507: PPUSH
58508: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
58509: LD_VAR 0 1
58513: NOT
58514: PUSH
58515: LD_VAR 0 2
58519: PPUSH
58520: LD_VAR 0 3
58524: PPUSH
58525: CALL_OW 488
58529: NOT
58530: OR
58531: PUSH
58532: LD_VAR 0 1
58536: PPUSH
58537: CALL_OW 266
58541: PUSH
58542: LD_INT 3
58544: NONEQUAL
58545: PUSH
58546: LD_VAR 0 1
58550: PPUSH
58551: CALL_OW 247
58555: PUSH
58556: LD_INT 1
58558: EQUAL
58559: NOT
58560: AND
58561: OR
58562: IFFALSE 58566
// exit ;
58564: GO 58715
// if GetType ( factory ) = unit_human then
58566: LD_VAR 0 1
58570: PPUSH
58571: CALL_OW 247
58575: PUSH
58576: LD_INT 1
58578: EQUAL
58579: IFFALSE 58596
// factory := IsInUnit ( factory ) ;
58581: LD_ADDR_VAR 0 1
58585: PUSH
58586: LD_VAR 0 1
58590: PPUSH
58591: CALL_OW 310
58595: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
58596: LD_VAR 0 1
58600: PPUSH
58601: CALL_OW 266
58605: PUSH
58606: LD_INT 3
58608: NONEQUAL
58609: IFFALSE 58613
// exit ;
58611: GO 58715
// if HexInfo ( x , y ) = factory then
58613: LD_VAR 0 2
58617: PPUSH
58618: LD_VAR 0 3
58622: PPUSH
58623: CALL_OW 428
58627: PUSH
58628: LD_VAR 0 1
58632: EQUAL
58633: IFFALSE 58660
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
58635: LD_ADDR_EXP 150
58639: PUSH
58640: LD_EXP 150
58644: PPUSH
58645: LD_VAR 0 1
58649: PPUSH
58650: LD_INT 0
58652: PPUSH
58653: CALL_OW 1
58657: ST_TO_ADDR
58658: GO 58711
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
58660: LD_ADDR_EXP 150
58664: PUSH
58665: LD_EXP 150
58669: PPUSH
58670: LD_VAR 0 1
58674: PPUSH
58675: LD_VAR 0 1
58679: PPUSH
58680: CALL_OW 255
58684: PUSH
58685: LD_VAR 0 1
58689: PUSH
58690: LD_VAR 0 2
58694: PUSH
58695: LD_VAR 0 3
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: LIST
58704: LIST
58705: PPUSH
58706: CALL_OW 1
58710: ST_TO_ADDR
// UpdateFactoryWaypoints ;
58711: CALL 58720 0 0
// end ;
58715: LD_VAR 0 4
58719: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
58720: LD_INT 0
58722: PPUSH
58723: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
58724: LD_STRING resetFactoryWaypoint();
58726: PPUSH
58727: CALL_OW 559
// if factoryWaypoints then
58731: LD_EXP 150
58735: IFFALSE 58858
// begin for i := 1 to factoryWaypoints do
58737: LD_ADDR_VAR 0 2
58741: PUSH
58742: DOUBLE
58743: LD_INT 1
58745: DEC
58746: ST_TO_ADDR
58747: LD_EXP 150
58751: PUSH
58752: FOR_TO
58753: IFFALSE 58856
// if factoryWaypoints [ i ] then
58755: LD_EXP 150
58759: PUSH
58760: LD_VAR 0 2
58764: ARRAY
58765: IFFALSE 58854
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
58767: LD_STRING setFactoryWaypointXY(
58769: PUSH
58770: LD_EXP 150
58774: PUSH
58775: LD_VAR 0 2
58779: ARRAY
58780: PUSH
58781: LD_INT 1
58783: ARRAY
58784: STR
58785: PUSH
58786: LD_STRING ,
58788: STR
58789: PUSH
58790: LD_EXP 150
58794: PUSH
58795: LD_VAR 0 2
58799: ARRAY
58800: PUSH
58801: LD_INT 2
58803: ARRAY
58804: STR
58805: PUSH
58806: LD_STRING ,
58808: STR
58809: PUSH
58810: LD_EXP 150
58814: PUSH
58815: LD_VAR 0 2
58819: ARRAY
58820: PUSH
58821: LD_INT 3
58823: ARRAY
58824: STR
58825: PUSH
58826: LD_STRING ,
58828: STR
58829: PUSH
58830: LD_EXP 150
58834: PUSH
58835: LD_VAR 0 2
58839: ARRAY
58840: PUSH
58841: LD_INT 4
58843: ARRAY
58844: STR
58845: PUSH
58846: LD_STRING )
58848: STR
58849: PPUSH
58850: CALL_OW 559
58854: GO 58752
58856: POP
58857: POP
// end ; end ;
58858: LD_VAR 0 1
58862: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
58863: LD_INT 0
58865: PPUSH
58866: PPUSH
58867: PPUSH
58868: PPUSH
58869: PPUSH
58870: PPUSH
58871: PPUSH
58872: PPUSH
58873: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
58874: LD_VAR 0 1
58878: NOT
58879: PUSH
58880: LD_VAR 0 2
58884: PPUSH
58885: LD_VAR 0 3
58889: PPUSH
58890: CALL_OW 488
58894: NOT
58895: OR
58896: PUSH
58897: LD_VAR 0 4
58901: NOT
58902: OR
58903: IFFALSE 58907
// exit ;
58905: GO 59247
// list := [ ] ;
58907: LD_ADDR_VAR 0 13
58911: PUSH
58912: EMPTY
58913: ST_TO_ADDR
// if x - r < 0 then
58914: LD_VAR 0 2
58918: PUSH
58919: LD_VAR 0 4
58923: MINUS
58924: PUSH
58925: LD_INT 0
58927: LESS
58928: IFFALSE 58940
// min_x := 0 else
58930: LD_ADDR_VAR 0 7
58934: PUSH
58935: LD_INT 0
58937: ST_TO_ADDR
58938: GO 58956
// min_x := x - r ;
58940: LD_ADDR_VAR 0 7
58944: PUSH
58945: LD_VAR 0 2
58949: PUSH
58950: LD_VAR 0 4
58954: MINUS
58955: ST_TO_ADDR
// if y - r < 0 then
58956: LD_VAR 0 3
58960: PUSH
58961: LD_VAR 0 4
58965: MINUS
58966: PUSH
58967: LD_INT 0
58969: LESS
58970: IFFALSE 58982
// min_y := 0 else
58972: LD_ADDR_VAR 0 8
58976: PUSH
58977: LD_INT 0
58979: ST_TO_ADDR
58980: GO 58998
// min_y := y - r ;
58982: LD_ADDR_VAR 0 8
58986: PUSH
58987: LD_VAR 0 3
58991: PUSH
58992: LD_VAR 0 4
58996: MINUS
58997: ST_TO_ADDR
// max_x := x + r ;
58998: LD_ADDR_VAR 0 9
59002: PUSH
59003: LD_VAR 0 2
59007: PUSH
59008: LD_VAR 0 4
59012: PLUS
59013: ST_TO_ADDR
// max_y := y + r ;
59014: LD_ADDR_VAR 0 10
59018: PUSH
59019: LD_VAR 0 3
59023: PUSH
59024: LD_VAR 0 4
59028: PLUS
59029: ST_TO_ADDR
// for _x = min_x to max_x do
59030: LD_ADDR_VAR 0 11
59034: PUSH
59035: DOUBLE
59036: LD_VAR 0 7
59040: DEC
59041: ST_TO_ADDR
59042: LD_VAR 0 9
59046: PUSH
59047: FOR_TO
59048: IFFALSE 59165
// for _y = min_y to max_y do
59050: LD_ADDR_VAR 0 12
59054: PUSH
59055: DOUBLE
59056: LD_VAR 0 8
59060: DEC
59061: ST_TO_ADDR
59062: LD_VAR 0 10
59066: PUSH
59067: FOR_TO
59068: IFFALSE 59161
// begin if not ValidHex ( _x , _y ) then
59070: LD_VAR 0 11
59074: PPUSH
59075: LD_VAR 0 12
59079: PPUSH
59080: CALL_OW 488
59084: NOT
59085: IFFALSE 59089
// continue ;
59087: GO 59067
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59089: LD_VAR 0 11
59093: PPUSH
59094: LD_VAR 0 12
59098: PPUSH
59099: CALL_OW 351
59103: PUSH
59104: LD_VAR 0 11
59108: PPUSH
59109: LD_VAR 0 12
59113: PPUSH
59114: CALL_OW 554
59118: AND
59119: IFFALSE 59159
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
59121: LD_ADDR_VAR 0 13
59125: PUSH
59126: LD_VAR 0 13
59130: PPUSH
59131: LD_VAR 0 13
59135: PUSH
59136: LD_INT 1
59138: PLUS
59139: PPUSH
59140: LD_VAR 0 11
59144: PUSH
59145: LD_VAR 0 12
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: PPUSH
59154: CALL_OW 2
59158: ST_TO_ADDR
// end ;
59159: GO 59067
59161: POP
59162: POP
59163: GO 59047
59165: POP
59166: POP
// if not list then
59167: LD_VAR 0 13
59171: NOT
59172: IFFALSE 59176
// exit ;
59174: GO 59247
// for i in list do
59176: LD_ADDR_VAR 0 6
59180: PUSH
59181: LD_VAR 0 13
59185: PUSH
59186: FOR_IN
59187: IFFALSE 59245
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
59189: LD_VAR 0 1
59193: PPUSH
59194: LD_STRING M
59196: PUSH
59197: LD_VAR 0 6
59201: PUSH
59202: LD_INT 1
59204: ARRAY
59205: PUSH
59206: LD_VAR 0 6
59210: PUSH
59211: LD_INT 2
59213: ARRAY
59214: PUSH
59215: LD_INT 0
59217: PUSH
59218: LD_INT 0
59220: PUSH
59221: LD_INT 0
59223: PUSH
59224: LD_INT 0
59226: PUSH
59227: EMPTY
59228: LIST
59229: LIST
59230: LIST
59231: LIST
59232: LIST
59233: LIST
59234: LIST
59235: PUSH
59236: EMPTY
59237: LIST
59238: PPUSH
59239: CALL_OW 447
59243: GO 59186
59245: POP
59246: POP
// end ;
59247: LD_VAR 0 5
59251: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
59252: LD_EXP 151
59256: NOT
59257: IFFALSE 59307
59259: GO 59261
59261: DISABLE
// begin initHack := true ;
59262: LD_ADDR_EXP 151
59266: PUSH
59267: LD_INT 1
59269: ST_TO_ADDR
// hackTanks := [ ] ;
59270: LD_ADDR_EXP 152
59274: PUSH
59275: EMPTY
59276: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
59277: LD_ADDR_EXP 153
59281: PUSH
59282: EMPTY
59283: ST_TO_ADDR
// hackLimit := 3 ;
59284: LD_ADDR_EXP 154
59288: PUSH
59289: LD_INT 3
59291: ST_TO_ADDR
// hackDist := 12 ;
59292: LD_ADDR_EXP 155
59296: PUSH
59297: LD_INT 12
59299: ST_TO_ADDR
// hackCounter := [ ] ;
59300: LD_ADDR_EXP 156
59304: PUSH
59305: EMPTY
59306: ST_TO_ADDR
// end ;
59307: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
59308: LD_EXP 151
59312: PUSH
59313: LD_INT 34
59315: PUSH
59316: LD_EXP 75
59320: PUSH
59321: EMPTY
59322: LIST
59323: LIST
59324: PPUSH
59325: CALL_OW 69
59329: AND
59330: IFFALSE 59585
59332: GO 59334
59334: DISABLE
59335: LD_INT 0
59337: PPUSH
59338: PPUSH
// begin enable ;
59339: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
59340: LD_ADDR_VAR 0 1
59344: PUSH
59345: LD_INT 34
59347: PUSH
59348: LD_EXP 75
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PPUSH
59357: CALL_OW 69
59361: PUSH
59362: FOR_IN
59363: IFFALSE 59583
// begin if not i in hackTanks then
59365: LD_VAR 0 1
59369: PUSH
59370: LD_EXP 152
59374: IN
59375: NOT
59376: IFFALSE 59459
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
59378: LD_ADDR_EXP 152
59382: PUSH
59383: LD_EXP 152
59387: PPUSH
59388: LD_EXP 152
59392: PUSH
59393: LD_INT 1
59395: PLUS
59396: PPUSH
59397: LD_VAR 0 1
59401: PPUSH
59402: CALL_OW 1
59406: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
59407: LD_ADDR_EXP 153
59411: PUSH
59412: LD_EXP 153
59416: PPUSH
59417: LD_EXP 153
59421: PUSH
59422: LD_INT 1
59424: PLUS
59425: PPUSH
59426: EMPTY
59427: PPUSH
59428: CALL_OW 1
59432: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
59433: LD_ADDR_EXP 156
59437: PUSH
59438: LD_EXP 156
59442: PPUSH
59443: LD_EXP 156
59447: PUSH
59448: LD_INT 1
59450: PLUS
59451: PPUSH
59452: EMPTY
59453: PPUSH
59454: CALL_OW 1
59458: ST_TO_ADDR
// end ; if not IsOk ( i ) then
59459: LD_VAR 0 1
59463: PPUSH
59464: CALL_OW 302
59468: NOT
59469: IFFALSE 59482
// begin HackUnlinkAll ( i ) ;
59471: LD_VAR 0 1
59475: PPUSH
59476: CALL 59588 0 1
// continue ;
59480: GO 59362
// end ; HackCheckCapturedStatus ( i ) ;
59482: LD_VAR 0 1
59486: PPUSH
59487: CALL 60031 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
59491: LD_ADDR_VAR 0 2
59495: PUSH
59496: LD_INT 81
59498: PUSH
59499: LD_VAR 0 1
59503: PPUSH
59504: CALL_OW 255
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 33
59515: PUSH
59516: LD_INT 3
59518: PUSH
59519: EMPTY
59520: LIST
59521: LIST
59522: PUSH
59523: LD_INT 91
59525: PUSH
59526: LD_VAR 0 1
59530: PUSH
59531: LD_EXP 155
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: PUSH
59541: LD_INT 50
59543: PUSH
59544: EMPTY
59545: LIST
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: LIST
59551: LIST
59552: PPUSH
59553: CALL_OW 69
59557: ST_TO_ADDR
// if not tmp then
59558: LD_VAR 0 2
59562: NOT
59563: IFFALSE 59567
// continue ;
59565: GO 59362
// HackLink ( i , tmp ) ;
59567: LD_VAR 0 1
59571: PPUSH
59572: LD_VAR 0 2
59576: PPUSH
59577: CALL 59724 0 2
// end ;
59581: GO 59362
59583: POP
59584: POP
// end ;
59585: PPOPN 2
59587: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
59588: LD_INT 0
59590: PPUSH
59591: PPUSH
59592: PPUSH
// if not hack in hackTanks then
59593: LD_VAR 0 1
59597: PUSH
59598: LD_EXP 152
59602: IN
59603: NOT
59604: IFFALSE 59608
// exit ;
59606: GO 59719
// index := GetElementIndex ( hackTanks , hack ) ;
59608: LD_ADDR_VAR 0 4
59612: PUSH
59613: LD_EXP 152
59617: PPUSH
59618: LD_VAR 0 1
59622: PPUSH
59623: CALL 67193 0 2
59627: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
59628: LD_EXP 153
59632: PUSH
59633: LD_VAR 0 4
59637: ARRAY
59638: IFFALSE 59719
// begin for i in hackTanksCaptured [ index ] do
59640: LD_ADDR_VAR 0 3
59644: PUSH
59645: LD_EXP 153
59649: PUSH
59650: LD_VAR 0 4
59654: ARRAY
59655: PUSH
59656: FOR_IN
59657: IFFALSE 59683
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
59659: LD_VAR 0 3
59663: PUSH
59664: LD_INT 1
59666: ARRAY
59667: PPUSH
59668: LD_VAR 0 3
59672: PUSH
59673: LD_INT 2
59675: ARRAY
59676: PPUSH
59677: CALL_OW 235
59681: GO 59656
59683: POP
59684: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
59685: LD_ADDR_EXP 153
59689: PUSH
59690: LD_EXP 153
59694: PPUSH
59695: LD_VAR 0 4
59699: PPUSH
59700: EMPTY
59701: PPUSH
59702: CALL_OW 1
59706: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
59707: LD_VAR 0 1
59711: PPUSH
59712: LD_INT 0
59714: PPUSH
59715: CALL_OW 505
// end ; end ;
59719: LD_VAR 0 2
59723: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
59724: LD_INT 0
59726: PPUSH
59727: PPUSH
59728: PPUSH
// if not hack in hackTanks or not vehicles then
59729: LD_VAR 0 1
59733: PUSH
59734: LD_EXP 152
59738: IN
59739: NOT
59740: PUSH
59741: LD_VAR 0 2
59745: NOT
59746: OR
59747: IFFALSE 59751
// exit ;
59749: GO 60026
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
59751: LD_ADDR_VAR 0 2
59755: PUSH
59756: LD_VAR 0 1
59760: PPUSH
59761: LD_VAR 0 2
59765: PPUSH
59766: LD_INT 1
59768: PPUSH
59769: LD_INT 1
59771: PPUSH
59772: CALL 67843 0 4
59776: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
59777: LD_ADDR_VAR 0 5
59781: PUSH
59782: LD_EXP 152
59786: PPUSH
59787: LD_VAR 0 1
59791: PPUSH
59792: CALL 67193 0 2
59796: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
59797: LD_EXP 153
59801: PUSH
59802: LD_VAR 0 5
59806: ARRAY
59807: PUSH
59808: LD_EXP 154
59812: LESS
59813: IFFALSE 60002
// begin for i := 1 to vehicles do
59815: LD_ADDR_VAR 0 4
59819: PUSH
59820: DOUBLE
59821: LD_INT 1
59823: DEC
59824: ST_TO_ADDR
59825: LD_VAR 0 2
59829: PUSH
59830: FOR_TO
59831: IFFALSE 60000
// begin if hackTanksCaptured [ index ] = hackLimit then
59833: LD_EXP 153
59837: PUSH
59838: LD_VAR 0 5
59842: ARRAY
59843: PUSH
59844: LD_EXP 154
59848: EQUAL
59849: IFFALSE 59853
// break ;
59851: GO 60000
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
59853: LD_ADDR_EXP 156
59857: PUSH
59858: LD_EXP 156
59862: PPUSH
59863: LD_VAR 0 5
59867: PPUSH
59868: LD_EXP 156
59872: PUSH
59873: LD_VAR 0 5
59877: ARRAY
59878: PUSH
59879: LD_INT 1
59881: PLUS
59882: PPUSH
59883: CALL_OW 1
59887: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
59888: LD_ADDR_EXP 153
59892: PUSH
59893: LD_EXP 153
59897: PPUSH
59898: LD_VAR 0 5
59902: PUSH
59903: LD_EXP 153
59907: PUSH
59908: LD_VAR 0 5
59912: ARRAY
59913: PUSH
59914: LD_INT 1
59916: PLUS
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: PPUSH
59922: LD_VAR 0 2
59926: PUSH
59927: LD_VAR 0 4
59931: ARRAY
59932: PUSH
59933: LD_VAR 0 2
59937: PUSH
59938: LD_VAR 0 4
59942: ARRAY
59943: PPUSH
59944: CALL_OW 255
59948: PUSH
59949: EMPTY
59950: LIST
59951: LIST
59952: PPUSH
59953: CALL 67408 0 3
59957: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
59958: LD_VAR 0 2
59962: PUSH
59963: LD_VAR 0 4
59967: ARRAY
59968: PPUSH
59969: LD_VAR 0 1
59973: PPUSH
59974: CALL_OW 255
59978: PPUSH
59979: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
59983: LD_VAR 0 2
59987: PUSH
59988: LD_VAR 0 4
59992: ARRAY
59993: PPUSH
59994: CALL_OW 141
// end ;
59998: GO 59830
60000: POP
60001: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60002: LD_VAR 0 1
60006: PPUSH
60007: LD_EXP 153
60011: PUSH
60012: LD_VAR 0 5
60016: ARRAY
60017: PUSH
60018: LD_INT 0
60020: PLUS
60021: PPUSH
60022: CALL_OW 505
// end ;
60026: LD_VAR 0 3
60030: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60031: LD_INT 0
60033: PPUSH
60034: PPUSH
60035: PPUSH
60036: PPUSH
// if not hack in hackTanks then
60037: LD_VAR 0 1
60041: PUSH
60042: LD_EXP 152
60046: IN
60047: NOT
60048: IFFALSE 60052
// exit ;
60050: GO 60292
// index := GetElementIndex ( hackTanks , hack ) ;
60052: LD_ADDR_VAR 0 4
60056: PUSH
60057: LD_EXP 152
60061: PPUSH
60062: LD_VAR 0 1
60066: PPUSH
60067: CALL 67193 0 2
60071: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60072: LD_ADDR_VAR 0 3
60076: PUSH
60077: DOUBLE
60078: LD_EXP 153
60082: PUSH
60083: LD_VAR 0 4
60087: ARRAY
60088: INC
60089: ST_TO_ADDR
60090: LD_INT 1
60092: PUSH
60093: FOR_DOWNTO
60094: IFFALSE 60266
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60096: LD_ADDR_VAR 0 5
60100: PUSH
60101: LD_EXP 153
60105: PUSH
60106: LD_VAR 0 4
60110: ARRAY
60111: PUSH
60112: LD_VAR 0 3
60116: ARRAY
60117: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
60118: LD_VAR 0 5
60122: PUSH
60123: LD_INT 1
60125: ARRAY
60126: PPUSH
60127: CALL_OW 302
60131: NOT
60132: PUSH
60133: LD_VAR 0 5
60137: PUSH
60138: LD_INT 1
60140: ARRAY
60141: PPUSH
60142: CALL_OW 255
60146: PUSH
60147: LD_VAR 0 1
60151: PPUSH
60152: CALL_OW 255
60156: NONEQUAL
60157: OR
60158: IFFALSE 60264
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
60160: LD_VAR 0 5
60164: PUSH
60165: LD_INT 1
60167: ARRAY
60168: PPUSH
60169: CALL_OW 305
60173: PUSH
60174: LD_VAR 0 5
60178: PUSH
60179: LD_INT 1
60181: ARRAY
60182: PPUSH
60183: CALL_OW 255
60187: PUSH
60188: LD_VAR 0 1
60192: PPUSH
60193: CALL_OW 255
60197: EQUAL
60198: AND
60199: IFFALSE 60223
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
60201: LD_VAR 0 5
60205: PUSH
60206: LD_INT 1
60208: ARRAY
60209: PPUSH
60210: LD_VAR 0 5
60214: PUSH
60215: LD_INT 2
60217: ARRAY
60218: PPUSH
60219: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
60223: LD_ADDR_EXP 153
60227: PUSH
60228: LD_EXP 153
60232: PPUSH
60233: LD_VAR 0 4
60237: PPUSH
60238: LD_EXP 153
60242: PUSH
60243: LD_VAR 0 4
60247: ARRAY
60248: PPUSH
60249: LD_VAR 0 3
60253: PPUSH
60254: CALL_OW 3
60258: PPUSH
60259: CALL_OW 1
60263: ST_TO_ADDR
// end ; end ;
60264: GO 60093
60266: POP
60267: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60268: LD_VAR 0 1
60272: PPUSH
60273: LD_EXP 153
60277: PUSH
60278: LD_VAR 0 4
60282: ARRAY
60283: PUSH
60284: LD_INT 0
60286: PLUS
60287: PPUSH
60288: CALL_OW 505
// end ;
60292: LD_VAR 0 2
60296: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
60297: LD_INT 0
60299: PPUSH
60300: PPUSH
60301: PPUSH
60302: PPUSH
// if not hack in hackTanks then
60303: LD_VAR 0 1
60307: PUSH
60308: LD_EXP 152
60312: IN
60313: NOT
60314: IFFALSE 60318
// exit ;
60316: GO 60403
// index := GetElementIndex ( hackTanks , hack ) ;
60318: LD_ADDR_VAR 0 5
60322: PUSH
60323: LD_EXP 152
60327: PPUSH
60328: LD_VAR 0 1
60332: PPUSH
60333: CALL 67193 0 2
60337: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
60338: LD_ADDR_VAR 0 4
60342: PUSH
60343: DOUBLE
60344: LD_INT 1
60346: DEC
60347: ST_TO_ADDR
60348: LD_EXP 153
60352: PUSH
60353: LD_VAR 0 5
60357: ARRAY
60358: PUSH
60359: FOR_TO
60360: IFFALSE 60401
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
60362: LD_EXP 153
60366: PUSH
60367: LD_VAR 0 5
60371: ARRAY
60372: PUSH
60373: LD_VAR 0 4
60377: ARRAY
60378: PUSH
60379: LD_INT 1
60381: ARRAY
60382: PUSH
60383: LD_VAR 0 2
60387: EQUAL
60388: IFFALSE 60399
// KillUnit ( vehicle ) ;
60390: LD_VAR 0 2
60394: PPUSH
60395: CALL_OW 66
60399: GO 60359
60401: POP
60402: POP
// end ;
60403: LD_VAR 0 3
60407: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
60408: LD_EXP 157
60412: NOT
60413: IFFALSE 60448
60415: GO 60417
60417: DISABLE
// begin initMiner := true ;
60418: LD_ADDR_EXP 157
60422: PUSH
60423: LD_INT 1
60425: ST_TO_ADDR
// minersList := [ ] ;
60426: LD_ADDR_EXP 158
60430: PUSH
60431: EMPTY
60432: ST_TO_ADDR
// minerMinesList := [ ] ;
60433: LD_ADDR_EXP 159
60437: PUSH
60438: EMPTY
60439: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
60440: LD_ADDR_EXP 160
60444: PUSH
60445: LD_INT 5
60447: ST_TO_ADDR
// end ;
60448: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
60449: LD_EXP 157
60453: PUSH
60454: LD_INT 34
60456: PUSH
60457: LD_EXP 80
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: PPUSH
60466: CALL_OW 69
60470: AND
60471: IFFALSE 60934
60473: GO 60475
60475: DISABLE
60476: LD_INT 0
60478: PPUSH
60479: PPUSH
60480: PPUSH
60481: PPUSH
// begin enable ;
60482: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
60483: LD_ADDR_VAR 0 1
60487: PUSH
60488: LD_INT 34
60490: PUSH
60491: LD_EXP 80
60495: PUSH
60496: EMPTY
60497: LIST
60498: LIST
60499: PPUSH
60500: CALL_OW 69
60504: PUSH
60505: FOR_IN
60506: IFFALSE 60578
// begin if not i in minersList then
60508: LD_VAR 0 1
60512: PUSH
60513: LD_EXP 158
60517: IN
60518: NOT
60519: IFFALSE 60576
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
60521: LD_ADDR_EXP 158
60525: PUSH
60526: LD_EXP 158
60530: PPUSH
60531: LD_EXP 158
60535: PUSH
60536: LD_INT 1
60538: PLUS
60539: PPUSH
60540: LD_VAR 0 1
60544: PPUSH
60545: CALL_OW 1
60549: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
60550: LD_ADDR_EXP 159
60554: PUSH
60555: LD_EXP 159
60559: PPUSH
60560: LD_EXP 159
60564: PUSH
60565: LD_INT 1
60567: PLUS
60568: PPUSH
60569: EMPTY
60570: PPUSH
60571: CALL_OW 1
60575: ST_TO_ADDR
// end end ;
60576: GO 60505
60578: POP
60579: POP
// for i := minerMinesList downto 1 do
60580: LD_ADDR_VAR 0 1
60584: PUSH
60585: DOUBLE
60586: LD_EXP 159
60590: INC
60591: ST_TO_ADDR
60592: LD_INT 1
60594: PUSH
60595: FOR_DOWNTO
60596: IFFALSE 60932
// begin if IsLive ( minersList [ i ] ) then
60598: LD_EXP 158
60602: PUSH
60603: LD_VAR 0 1
60607: ARRAY
60608: PPUSH
60609: CALL_OW 300
60613: IFFALSE 60641
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
60615: LD_EXP 158
60619: PUSH
60620: LD_VAR 0 1
60624: ARRAY
60625: PPUSH
60626: LD_EXP 159
60630: PUSH
60631: LD_VAR 0 1
60635: ARRAY
60636: PPUSH
60637: CALL_OW 505
// if not minerMinesList [ i ] then
60641: LD_EXP 159
60645: PUSH
60646: LD_VAR 0 1
60650: ARRAY
60651: NOT
60652: IFFALSE 60656
// continue ;
60654: GO 60595
// for j := minerMinesList [ i ] downto 1 do
60656: LD_ADDR_VAR 0 2
60660: PUSH
60661: DOUBLE
60662: LD_EXP 159
60666: PUSH
60667: LD_VAR 0 1
60671: ARRAY
60672: INC
60673: ST_TO_ADDR
60674: LD_INT 1
60676: PUSH
60677: FOR_DOWNTO
60678: IFFALSE 60928
// begin side := GetSide ( minersList [ i ] ) ;
60680: LD_ADDR_VAR 0 3
60684: PUSH
60685: LD_EXP 158
60689: PUSH
60690: LD_VAR 0 1
60694: ARRAY
60695: PPUSH
60696: CALL_OW 255
60700: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
60701: LD_ADDR_VAR 0 4
60705: PUSH
60706: LD_EXP 159
60710: PUSH
60711: LD_VAR 0 1
60715: ARRAY
60716: PUSH
60717: LD_VAR 0 2
60721: ARRAY
60722: PUSH
60723: LD_INT 1
60725: ARRAY
60726: PPUSH
60727: LD_EXP 159
60731: PUSH
60732: LD_VAR 0 1
60736: ARRAY
60737: PUSH
60738: LD_VAR 0 2
60742: ARRAY
60743: PUSH
60744: LD_INT 2
60746: ARRAY
60747: PPUSH
60748: CALL_OW 428
60752: ST_TO_ADDR
// if not tmp then
60753: LD_VAR 0 4
60757: NOT
60758: IFFALSE 60762
// continue ;
60760: GO 60677
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
60762: LD_VAR 0 4
60766: PUSH
60767: LD_INT 81
60769: PUSH
60770: LD_VAR 0 3
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: PPUSH
60779: CALL_OW 69
60783: IN
60784: PUSH
60785: LD_EXP 159
60789: PUSH
60790: LD_VAR 0 1
60794: ARRAY
60795: PUSH
60796: LD_VAR 0 2
60800: ARRAY
60801: PUSH
60802: LD_INT 1
60804: ARRAY
60805: PPUSH
60806: LD_EXP 159
60810: PUSH
60811: LD_VAR 0 1
60815: ARRAY
60816: PUSH
60817: LD_VAR 0 2
60821: ARRAY
60822: PUSH
60823: LD_INT 2
60825: ARRAY
60826: PPUSH
60827: CALL_OW 458
60831: AND
60832: IFFALSE 60926
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
60834: LD_EXP 159
60838: PUSH
60839: LD_VAR 0 1
60843: ARRAY
60844: PUSH
60845: LD_VAR 0 2
60849: ARRAY
60850: PUSH
60851: LD_INT 1
60853: ARRAY
60854: PPUSH
60855: LD_EXP 159
60859: PUSH
60860: LD_VAR 0 1
60864: ARRAY
60865: PUSH
60866: LD_VAR 0 2
60870: ARRAY
60871: PUSH
60872: LD_INT 2
60874: ARRAY
60875: PPUSH
60876: LD_VAR 0 3
60880: PPUSH
60881: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
60885: LD_ADDR_EXP 159
60889: PUSH
60890: LD_EXP 159
60894: PPUSH
60895: LD_VAR 0 1
60899: PPUSH
60900: LD_EXP 159
60904: PUSH
60905: LD_VAR 0 1
60909: ARRAY
60910: PPUSH
60911: LD_VAR 0 2
60915: PPUSH
60916: CALL_OW 3
60920: PPUSH
60921: CALL_OW 1
60925: ST_TO_ADDR
// end ; end ;
60926: GO 60677
60928: POP
60929: POP
// end ;
60930: GO 60595
60932: POP
60933: POP
// end ;
60934: PPOPN 4
60936: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
60937: LD_INT 0
60939: PPUSH
60940: PPUSH
// result := false ;
60941: LD_ADDR_VAR 0 4
60945: PUSH
60946: LD_INT 0
60948: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
60949: LD_VAR 0 1
60953: PPUSH
60954: CALL_OW 264
60958: PUSH
60959: LD_EXP 80
60963: EQUAL
60964: NOT
60965: IFFALSE 60969
// exit ;
60967: GO 61209
// index := GetElementIndex ( minersList , unit ) ;
60969: LD_ADDR_VAR 0 5
60973: PUSH
60974: LD_EXP 158
60978: PPUSH
60979: LD_VAR 0 1
60983: PPUSH
60984: CALL 67193 0 2
60988: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
60989: LD_EXP 159
60993: PUSH
60994: LD_VAR 0 5
60998: ARRAY
60999: PUSH
61000: LD_EXP 160
61004: GREATEREQUAL
61005: IFFALSE 61009
// exit ;
61007: GO 61209
// ComMoveXY ( unit , x , y ) ;
61009: LD_VAR 0 1
61013: PPUSH
61014: LD_VAR 0 2
61018: PPUSH
61019: LD_VAR 0 3
61023: PPUSH
61024: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61028: LD_INT 35
61030: PPUSH
61031: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61035: LD_VAR 0 1
61039: PPUSH
61040: LD_VAR 0 2
61044: PPUSH
61045: LD_VAR 0 3
61049: PPUSH
61050: CALL 97912 0 3
61054: NOT
61055: PUSH
61056: LD_VAR 0 1
61060: PPUSH
61061: CALL_OW 314
61065: AND
61066: IFFALSE 61070
// exit ;
61068: GO 61209
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61070: LD_VAR 0 2
61074: PPUSH
61075: LD_VAR 0 3
61079: PPUSH
61080: CALL_OW 428
61084: PUSH
61085: LD_VAR 0 1
61089: EQUAL
61090: PUSH
61091: LD_VAR 0 1
61095: PPUSH
61096: CALL_OW 314
61100: NOT
61101: AND
61102: IFFALSE 61028
// PlaySoundXY ( x , y , PlantMine ) ;
61104: LD_VAR 0 2
61108: PPUSH
61109: LD_VAR 0 3
61113: PPUSH
61114: LD_STRING PlantMine
61116: PPUSH
61117: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
61121: LD_VAR 0 2
61125: PPUSH
61126: LD_VAR 0 3
61130: PPUSH
61131: LD_VAR 0 1
61135: PPUSH
61136: CALL_OW 255
61140: PPUSH
61141: LD_INT 0
61143: PPUSH
61144: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
61148: LD_ADDR_EXP 159
61152: PUSH
61153: LD_EXP 159
61157: PPUSH
61158: LD_VAR 0 5
61162: PUSH
61163: LD_EXP 159
61167: PUSH
61168: LD_VAR 0 5
61172: ARRAY
61173: PUSH
61174: LD_INT 1
61176: PLUS
61177: PUSH
61178: EMPTY
61179: LIST
61180: LIST
61181: PPUSH
61182: LD_VAR 0 2
61186: PUSH
61187: LD_VAR 0 3
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: PPUSH
61196: CALL 67408 0 3
61200: ST_TO_ADDR
// result := true ;
61201: LD_ADDR_VAR 0 4
61205: PUSH
61206: LD_INT 1
61208: ST_TO_ADDR
// end ;
61209: LD_VAR 0 4
61213: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
61214: LD_INT 0
61216: PPUSH
61217: PPUSH
61218: PPUSH
// if not unit in minersList then
61219: LD_VAR 0 1
61223: PUSH
61224: LD_EXP 158
61228: IN
61229: NOT
61230: IFFALSE 61234
// exit ;
61232: GO 61626
// index := GetElementIndex ( minersList , unit ) ;
61234: LD_ADDR_VAR 0 6
61238: PUSH
61239: LD_EXP 158
61243: PPUSH
61244: LD_VAR 0 1
61248: PPUSH
61249: CALL 67193 0 2
61253: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
61254: LD_ADDR_VAR 0 5
61258: PUSH
61259: DOUBLE
61260: LD_EXP 159
61264: PUSH
61265: LD_VAR 0 6
61269: ARRAY
61270: INC
61271: ST_TO_ADDR
61272: LD_INT 1
61274: PUSH
61275: FOR_DOWNTO
61276: IFFALSE 61437
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
61278: LD_EXP 159
61282: PUSH
61283: LD_VAR 0 6
61287: ARRAY
61288: PUSH
61289: LD_VAR 0 5
61293: ARRAY
61294: PUSH
61295: LD_INT 1
61297: ARRAY
61298: PUSH
61299: LD_VAR 0 2
61303: EQUAL
61304: PUSH
61305: LD_EXP 159
61309: PUSH
61310: LD_VAR 0 6
61314: ARRAY
61315: PUSH
61316: LD_VAR 0 5
61320: ARRAY
61321: PUSH
61322: LD_INT 2
61324: ARRAY
61325: PUSH
61326: LD_VAR 0 3
61330: EQUAL
61331: AND
61332: IFFALSE 61435
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61334: LD_EXP 159
61338: PUSH
61339: LD_VAR 0 6
61343: ARRAY
61344: PUSH
61345: LD_VAR 0 5
61349: ARRAY
61350: PUSH
61351: LD_INT 1
61353: ARRAY
61354: PPUSH
61355: LD_EXP 159
61359: PUSH
61360: LD_VAR 0 6
61364: ARRAY
61365: PUSH
61366: LD_VAR 0 5
61370: ARRAY
61371: PUSH
61372: LD_INT 2
61374: ARRAY
61375: PPUSH
61376: LD_VAR 0 1
61380: PPUSH
61381: CALL_OW 255
61385: PPUSH
61386: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61390: LD_ADDR_EXP 159
61394: PUSH
61395: LD_EXP 159
61399: PPUSH
61400: LD_VAR 0 6
61404: PPUSH
61405: LD_EXP 159
61409: PUSH
61410: LD_VAR 0 6
61414: ARRAY
61415: PPUSH
61416: LD_VAR 0 5
61420: PPUSH
61421: CALL_OW 3
61425: PPUSH
61426: CALL_OW 1
61430: ST_TO_ADDR
// exit ;
61431: POP
61432: POP
61433: GO 61626
// end ; end ;
61435: GO 61275
61437: POP
61438: POP
// for i := minerMinesList [ index ] downto 1 do
61439: LD_ADDR_VAR 0 5
61443: PUSH
61444: DOUBLE
61445: LD_EXP 159
61449: PUSH
61450: LD_VAR 0 6
61454: ARRAY
61455: INC
61456: ST_TO_ADDR
61457: LD_INT 1
61459: PUSH
61460: FOR_DOWNTO
61461: IFFALSE 61624
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
61463: LD_EXP 159
61467: PUSH
61468: LD_VAR 0 6
61472: ARRAY
61473: PUSH
61474: LD_VAR 0 5
61478: ARRAY
61479: PUSH
61480: LD_INT 1
61482: ARRAY
61483: PPUSH
61484: LD_EXP 159
61488: PUSH
61489: LD_VAR 0 6
61493: ARRAY
61494: PUSH
61495: LD_VAR 0 5
61499: ARRAY
61500: PUSH
61501: LD_INT 2
61503: ARRAY
61504: PPUSH
61505: LD_VAR 0 2
61509: PPUSH
61510: LD_VAR 0 3
61514: PPUSH
61515: CALL_OW 298
61519: PUSH
61520: LD_INT 6
61522: LESS
61523: IFFALSE 61622
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61525: LD_EXP 159
61529: PUSH
61530: LD_VAR 0 6
61534: ARRAY
61535: PUSH
61536: LD_VAR 0 5
61540: ARRAY
61541: PUSH
61542: LD_INT 1
61544: ARRAY
61545: PPUSH
61546: LD_EXP 159
61550: PUSH
61551: LD_VAR 0 6
61555: ARRAY
61556: PUSH
61557: LD_VAR 0 5
61561: ARRAY
61562: PUSH
61563: LD_INT 2
61565: ARRAY
61566: PPUSH
61567: LD_VAR 0 1
61571: PPUSH
61572: CALL_OW 255
61576: PPUSH
61577: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61581: LD_ADDR_EXP 159
61585: PUSH
61586: LD_EXP 159
61590: PPUSH
61591: LD_VAR 0 6
61595: PPUSH
61596: LD_EXP 159
61600: PUSH
61601: LD_VAR 0 6
61605: ARRAY
61606: PPUSH
61607: LD_VAR 0 5
61611: PPUSH
61612: CALL_OW 3
61616: PPUSH
61617: CALL_OW 1
61621: ST_TO_ADDR
// end ; end ;
61622: GO 61460
61624: POP
61625: POP
// end ;
61626: LD_VAR 0 4
61630: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
61631: LD_INT 0
61633: PPUSH
61634: PPUSH
61635: PPUSH
61636: PPUSH
61637: PPUSH
61638: PPUSH
61639: PPUSH
61640: PPUSH
61641: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
61642: LD_VAR 0 1
61646: PPUSH
61647: CALL_OW 264
61651: PUSH
61652: LD_EXP 80
61656: EQUAL
61657: NOT
61658: PUSH
61659: LD_VAR 0 1
61663: PUSH
61664: LD_EXP 158
61668: IN
61669: NOT
61670: OR
61671: IFFALSE 61675
// exit ;
61673: GO 61997
// index := GetElementIndex ( minersList , unit ) ;
61675: LD_ADDR_VAR 0 6
61679: PUSH
61680: LD_EXP 158
61684: PPUSH
61685: LD_VAR 0 1
61689: PPUSH
61690: CALL 67193 0 2
61694: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
61695: LD_ADDR_VAR 0 8
61699: PUSH
61700: LD_EXP 160
61704: PUSH
61705: LD_EXP 159
61709: PUSH
61710: LD_VAR 0 6
61714: ARRAY
61715: MINUS
61716: ST_TO_ADDR
// if not minesFreeAmount then
61717: LD_VAR 0 8
61721: NOT
61722: IFFALSE 61726
// exit ;
61724: GO 61997
// tmp := [ ] ;
61726: LD_ADDR_VAR 0 7
61730: PUSH
61731: EMPTY
61732: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
61733: LD_ADDR_VAR 0 5
61737: PUSH
61738: DOUBLE
61739: LD_INT 1
61741: DEC
61742: ST_TO_ADDR
61743: LD_VAR 0 8
61747: PUSH
61748: FOR_TO
61749: IFFALSE 61944
// begin _d := rand ( 0 , 5 ) ;
61751: LD_ADDR_VAR 0 11
61755: PUSH
61756: LD_INT 0
61758: PPUSH
61759: LD_INT 5
61761: PPUSH
61762: CALL_OW 12
61766: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
61767: LD_ADDR_VAR 0 12
61771: PUSH
61772: LD_INT 2
61774: PPUSH
61775: LD_INT 6
61777: PPUSH
61778: CALL_OW 12
61782: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
61783: LD_ADDR_VAR 0 9
61787: PUSH
61788: LD_VAR 0 2
61792: PPUSH
61793: LD_VAR 0 11
61797: PPUSH
61798: LD_VAR 0 12
61802: PPUSH
61803: CALL_OW 272
61807: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
61808: LD_ADDR_VAR 0 10
61812: PUSH
61813: LD_VAR 0 3
61817: PPUSH
61818: LD_VAR 0 11
61822: PPUSH
61823: LD_VAR 0 12
61827: PPUSH
61828: CALL_OW 273
61832: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
61833: LD_VAR 0 9
61837: PPUSH
61838: LD_VAR 0 10
61842: PPUSH
61843: CALL_OW 488
61847: PUSH
61848: LD_VAR 0 9
61852: PUSH
61853: LD_VAR 0 10
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: PUSH
61862: LD_VAR 0 7
61866: IN
61867: NOT
61868: AND
61869: PUSH
61870: LD_VAR 0 9
61874: PPUSH
61875: LD_VAR 0 10
61879: PPUSH
61880: CALL_OW 458
61884: NOT
61885: AND
61886: IFFALSE 61928
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
61888: LD_ADDR_VAR 0 7
61892: PUSH
61893: LD_VAR 0 7
61897: PPUSH
61898: LD_VAR 0 7
61902: PUSH
61903: LD_INT 1
61905: PLUS
61906: PPUSH
61907: LD_VAR 0 9
61911: PUSH
61912: LD_VAR 0 10
61916: PUSH
61917: EMPTY
61918: LIST
61919: LIST
61920: PPUSH
61921: CALL_OW 1
61925: ST_TO_ADDR
61926: GO 61942
// i := i - 1 ;
61928: LD_ADDR_VAR 0 5
61932: PUSH
61933: LD_VAR 0 5
61937: PUSH
61938: LD_INT 1
61940: MINUS
61941: ST_TO_ADDR
// end ;
61942: GO 61748
61944: POP
61945: POP
// for i in tmp do
61946: LD_ADDR_VAR 0 5
61950: PUSH
61951: LD_VAR 0 7
61955: PUSH
61956: FOR_IN
61957: IFFALSE 61995
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
61959: LD_VAR 0 1
61963: PPUSH
61964: LD_VAR 0 5
61968: PUSH
61969: LD_INT 1
61971: ARRAY
61972: PPUSH
61973: LD_VAR 0 5
61977: PUSH
61978: LD_INT 2
61980: ARRAY
61981: PPUSH
61982: CALL 60937 0 3
61986: NOT
61987: IFFALSE 61993
// exit ;
61989: POP
61990: POP
61991: GO 61997
61993: GO 61956
61995: POP
61996: POP
// end ;
61997: LD_VAR 0 4
62001: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62002: LD_INT 0
62004: PPUSH
62005: PPUSH
62006: PPUSH
62007: PPUSH
62008: PPUSH
62009: PPUSH
62010: PPUSH
// if not GetClass ( unit ) = class_sniper then
62011: LD_VAR 0 1
62015: PPUSH
62016: CALL_OW 257
62020: PUSH
62021: LD_INT 5
62023: EQUAL
62024: NOT
62025: IFFALSE 62029
// exit ;
62027: GO 62417
// dist := 8 ;
62029: LD_ADDR_VAR 0 5
62033: PUSH
62034: LD_INT 8
62036: ST_TO_ADDR
// viewRange := 12 ;
62037: LD_ADDR_VAR 0 7
62041: PUSH
62042: LD_INT 12
62044: ST_TO_ADDR
// side := GetSide ( unit ) ;
62045: LD_ADDR_VAR 0 6
62049: PUSH
62050: LD_VAR 0 1
62054: PPUSH
62055: CALL_OW 255
62059: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62060: LD_INT 61
62062: PPUSH
62063: LD_VAR 0 6
62067: PPUSH
62068: CALL_OW 321
62072: PUSH
62073: LD_INT 2
62075: EQUAL
62076: IFFALSE 62086
// viewRange := 16 ;
62078: LD_ADDR_VAR 0 7
62082: PUSH
62083: LD_INT 16
62085: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62086: LD_VAR 0 1
62090: PPUSH
62091: LD_VAR 0 2
62095: PPUSH
62096: LD_VAR 0 3
62100: PPUSH
62101: CALL_OW 297
62105: PUSH
62106: LD_VAR 0 5
62110: GREATER
62111: IFFALSE 62190
// begin ComMoveXY ( unit , x , y ) ;
62113: LD_VAR 0 1
62117: PPUSH
62118: LD_VAR 0 2
62122: PPUSH
62123: LD_VAR 0 3
62127: PPUSH
62128: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62132: LD_INT 35
62134: PPUSH
62135: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
62139: LD_VAR 0 1
62143: PPUSH
62144: LD_VAR 0 2
62148: PPUSH
62149: LD_VAR 0 3
62153: PPUSH
62154: CALL 97912 0 3
62158: NOT
62159: IFFALSE 62163
// exit ;
62161: GO 62417
// until GetDistUnitXY ( unit , x , y ) < dist ;
62163: LD_VAR 0 1
62167: PPUSH
62168: LD_VAR 0 2
62172: PPUSH
62173: LD_VAR 0 3
62177: PPUSH
62178: CALL_OW 297
62182: PUSH
62183: LD_VAR 0 5
62187: LESS
62188: IFFALSE 62132
// end ; ComTurnXY ( unit , x , y ) ;
62190: LD_VAR 0 1
62194: PPUSH
62195: LD_VAR 0 2
62199: PPUSH
62200: LD_VAR 0 3
62204: PPUSH
62205: CALL_OW 118
// wait ( 5 ) ;
62209: LD_INT 5
62211: PPUSH
62212: CALL_OW 67
// _d := GetDir ( unit ) ;
62216: LD_ADDR_VAR 0 10
62220: PUSH
62221: LD_VAR 0 1
62225: PPUSH
62226: CALL_OW 254
62230: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
62231: LD_ADDR_VAR 0 8
62235: PUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: CALL_OW 250
62245: PPUSH
62246: LD_VAR 0 10
62250: PPUSH
62251: LD_VAR 0 5
62255: PPUSH
62256: CALL_OW 272
62260: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
62261: LD_ADDR_VAR 0 9
62265: PUSH
62266: LD_VAR 0 1
62270: PPUSH
62271: CALL_OW 251
62275: PPUSH
62276: LD_VAR 0 10
62280: PPUSH
62281: LD_VAR 0 5
62285: PPUSH
62286: CALL_OW 273
62290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62291: LD_VAR 0 8
62295: PPUSH
62296: LD_VAR 0 9
62300: PPUSH
62301: CALL_OW 488
62305: NOT
62306: IFFALSE 62310
// exit ;
62308: GO 62417
// ComAnimCustom ( unit , 1 ) ;
62310: LD_VAR 0 1
62314: PPUSH
62315: LD_INT 1
62317: PPUSH
62318: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
62322: LD_VAR 0 8
62326: PPUSH
62327: LD_VAR 0 9
62331: PPUSH
62332: LD_VAR 0 6
62336: PPUSH
62337: LD_VAR 0 7
62341: PPUSH
62342: CALL_OW 330
// repeat wait ( 1 ) ;
62346: LD_INT 1
62348: PPUSH
62349: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
62353: LD_VAR 0 1
62357: PPUSH
62358: CALL_OW 316
62362: PUSH
62363: LD_VAR 0 1
62367: PPUSH
62368: CALL_OW 314
62372: OR
62373: PUSH
62374: LD_VAR 0 1
62378: PPUSH
62379: CALL_OW 302
62383: NOT
62384: OR
62385: PUSH
62386: LD_VAR 0 1
62390: PPUSH
62391: CALL_OW 301
62395: OR
62396: IFFALSE 62346
// RemoveSeeing ( _x , _y , side ) ;
62398: LD_VAR 0 8
62402: PPUSH
62403: LD_VAR 0 9
62407: PPUSH
62408: LD_VAR 0 6
62412: PPUSH
62413: CALL_OW 331
// end ; end_of_file
62417: LD_VAR 0 4
62421: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62422: LD_INT 0
62424: PPUSH
62425: PPUSH
// if exist_mode then
62426: LD_VAR 0 2
62430: IFFALSE 62455
// unit := CreateCharacter ( prefix & ident ) else
62432: LD_ADDR_VAR 0 5
62436: PUSH
62437: LD_VAR 0 3
62441: PUSH
62442: LD_VAR 0 1
62446: STR
62447: PPUSH
62448: CALL_OW 34
62452: ST_TO_ADDR
62453: GO 62470
// unit := NewCharacter ( ident ) ;
62455: LD_ADDR_VAR 0 5
62459: PUSH
62460: LD_VAR 0 1
62464: PPUSH
62465: CALL_OW 25
62469: ST_TO_ADDR
// result := unit ;
62470: LD_ADDR_VAR 0 4
62474: PUSH
62475: LD_VAR 0 5
62479: ST_TO_ADDR
// end ;
62480: LD_VAR 0 4
62484: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
62485: LD_INT 0
62487: PPUSH
62488: PPUSH
// if not side or not nation then
62489: LD_VAR 0 1
62493: NOT
62494: PUSH
62495: LD_VAR 0 2
62499: NOT
62500: OR
62501: IFFALSE 62505
// exit ;
62503: GO 63273
// case nation of nation_american :
62505: LD_VAR 0 2
62509: PUSH
62510: LD_INT 1
62512: DOUBLE
62513: EQUAL
62514: IFTRUE 62518
62516: GO 62732
62518: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
62519: LD_ADDR_VAR 0 4
62523: PUSH
62524: LD_INT 35
62526: PUSH
62527: LD_INT 45
62529: PUSH
62530: LD_INT 46
62532: PUSH
62533: LD_INT 47
62535: PUSH
62536: LD_INT 82
62538: PUSH
62539: LD_INT 83
62541: PUSH
62542: LD_INT 84
62544: PUSH
62545: LD_INT 85
62547: PUSH
62548: LD_INT 86
62550: PUSH
62551: LD_INT 1
62553: PUSH
62554: LD_INT 2
62556: PUSH
62557: LD_INT 6
62559: PUSH
62560: LD_INT 15
62562: PUSH
62563: LD_INT 16
62565: PUSH
62566: LD_INT 7
62568: PUSH
62569: LD_INT 12
62571: PUSH
62572: LD_INT 13
62574: PUSH
62575: LD_INT 10
62577: PUSH
62578: LD_INT 14
62580: PUSH
62581: LD_INT 20
62583: PUSH
62584: LD_INT 21
62586: PUSH
62587: LD_INT 22
62589: PUSH
62590: LD_INT 25
62592: PUSH
62593: LD_INT 32
62595: PUSH
62596: LD_INT 27
62598: PUSH
62599: LD_INT 36
62601: PUSH
62602: LD_INT 69
62604: PUSH
62605: LD_INT 39
62607: PUSH
62608: LD_INT 34
62610: PUSH
62611: LD_INT 40
62613: PUSH
62614: LD_INT 48
62616: PUSH
62617: LD_INT 49
62619: PUSH
62620: LD_INT 50
62622: PUSH
62623: LD_INT 51
62625: PUSH
62626: LD_INT 52
62628: PUSH
62629: LD_INT 53
62631: PUSH
62632: LD_INT 54
62634: PUSH
62635: LD_INT 55
62637: PUSH
62638: LD_INT 56
62640: PUSH
62641: LD_INT 57
62643: PUSH
62644: LD_INT 58
62646: PUSH
62647: LD_INT 59
62649: PUSH
62650: LD_INT 60
62652: PUSH
62653: LD_INT 61
62655: PUSH
62656: LD_INT 62
62658: PUSH
62659: LD_INT 80
62661: PUSH
62662: LD_INT 82
62664: PUSH
62665: LD_INT 83
62667: PUSH
62668: LD_INT 84
62670: PUSH
62671: LD_INT 85
62673: PUSH
62674: LD_INT 86
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: LIST
62691: LIST
62692: LIST
62693: LIST
62694: LIST
62695: LIST
62696: LIST
62697: LIST
62698: LIST
62699: LIST
62700: LIST
62701: LIST
62702: LIST
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: LIST
62708: LIST
62709: LIST
62710: LIST
62711: LIST
62712: LIST
62713: LIST
62714: LIST
62715: LIST
62716: LIST
62717: LIST
62718: LIST
62719: LIST
62720: LIST
62721: LIST
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: LIST
62727: LIST
62728: LIST
62729: ST_TO_ADDR
62730: GO 63197
62732: LD_INT 2
62734: DOUBLE
62735: EQUAL
62736: IFTRUE 62740
62738: GO 62966
62740: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
62741: LD_ADDR_VAR 0 4
62745: PUSH
62746: LD_INT 35
62748: PUSH
62749: LD_INT 45
62751: PUSH
62752: LD_INT 46
62754: PUSH
62755: LD_INT 47
62757: PUSH
62758: LD_INT 82
62760: PUSH
62761: LD_INT 83
62763: PUSH
62764: LD_INT 84
62766: PUSH
62767: LD_INT 85
62769: PUSH
62770: LD_INT 87
62772: PUSH
62773: LD_INT 70
62775: PUSH
62776: LD_INT 1
62778: PUSH
62779: LD_INT 11
62781: PUSH
62782: LD_INT 3
62784: PUSH
62785: LD_INT 4
62787: PUSH
62788: LD_INT 5
62790: PUSH
62791: LD_INT 6
62793: PUSH
62794: LD_INT 15
62796: PUSH
62797: LD_INT 18
62799: PUSH
62800: LD_INT 7
62802: PUSH
62803: LD_INT 17
62805: PUSH
62806: LD_INT 8
62808: PUSH
62809: LD_INT 20
62811: PUSH
62812: LD_INT 21
62814: PUSH
62815: LD_INT 22
62817: PUSH
62818: LD_INT 72
62820: PUSH
62821: LD_INT 26
62823: PUSH
62824: LD_INT 69
62826: PUSH
62827: LD_INT 39
62829: PUSH
62830: LD_INT 40
62832: PUSH
62833: LD_INT 41
62835: PUSH
62836: LD_INT 42
62838: PUSH
62839: LD_INT 43
62841: PUSH
62842: LD_INT 48
62844: PUSH
62845: LD_INT 49
62847: PUSH
62848: LD_INT 50
62850: PUSH
62851: LD_INT 51
62853: PUSH
62854: LD_INT 52
62856: PUSH
62857: LD_INT 53
62859: PUSH
62860: LD_INT 54
62862: PUSH
62863: LD_INT 55
62865: PUSH
62866: LD_INT 56
62868: PUSH
62869: LD_INT 60
62871: PUSH
62872: LD_INT 61
62874: PUSH
62875: LD_INT 62
62877: PUSH
62878: LD_INT 66
62880: PUSH
62881: LD_INT 67
62883: PUSH
62884: LD_INT 68
62886: PUSH
62887: LD_INT 81
62889: PUSH
62890: LD_INT 82
62892: PUSH
62893: LD_INT 83
62895: PUSH
62896: LD_INT 84
62898: PUSH
62899: LD_INT 85
62901: PUSH
62902: LD_INT 87
62904: PUSH
62905: LD_INT 88
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: LIST
62912: LIST
62913: LIST
62914: LIST
62915: LIST
62916: LIST
62917: LIST
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: LIST
62930: LIST
62931: LIST
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: LIST
62942: LIST
62943: LIST
62944: LIST
62945: LIST
62946: LIST
62947: LIST
62948: LIST
62949: LIST
62950: LIST
62951: LIST
62952: LIST
62953: LIST
62954: LIST
62955: LIST
62956: LIST
62957: LIST
62958: LIST
62959: LIST
62960: LIST
62961: LIST
62962: LIST
62963: ST_TO_ADDR
62964: GO 63197
62966: LD_INT 3
62968: DOUBLE
62969: EQUAL
62970: IFTRUE 62974
62972: GO 63196
62974: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
62975: LD_ADDR_VAR 0 4
62979: PUSH
62980: LD_INT 46
62982: PUSH
62983: LD_INT 47
62985: PUSH
62986: LD_INT 1
62988: PUSH
62989: LD_INT 2
62991: PUSH
62992: LD_INT 82
62994: PUSH
62995: LD_INT 83
62997: PUSH
62998: LD_INT 84
63000: PUSH
63001: LD_INT 85
63003: PUSH
63004: LD_INT 86
63006: PUSH
63007: LD_INT 11
63009: PUSH
63010: LD_INT 9
63012: PUSH
63013: LD_INT 20
63015: PUSH
63016: LD_INT 19
63018: PUSH
63019: LD_INT 21
63021: PUSH
63022: LD_INT 24
63024: PUSH
63025: LD_INT 22
63027: PUSH
63028: LD_INT 25
63030: PUSH
63031: LD_INT 28
63033: PUSH
63034: LD_INT 29
63036: PUSH
63037: LD_INT 30
63039: PUSH
63040: LD_INT 31
63042: PUSH
63043: LD_INT 37
63045: PUSH
63046: LD_INT 38
63048: PUSH
63049: LD_INT 32
63051: PUSH
63052: LD_INT 27
63054: PUSH
63055: LD_INT 33
63057: PUSH
63058: LD_INT 69
63060: PUSH
63061: LD_INT 39
63063: PUSH
63064: LD_INT 34
63066: PUSH
63067: LD_INT 40
63069: PUSH
63070: LD_INT 71
63072: PUSH
63073: LD_INT 23
63075: PUSH
63076: LD_INT 44
63078: PUSH
63079: LD_INT 48
63081: PUSH
63082: LD_INT 49
63084: PUSH
63085: LD_INT 50
63087: PUSH
63088: LD_INT 51
63090: PUSH
63091: LD_INT 52
63093: PUSH
63094: LD_INT 53
63096: PUSH
63097: LD_INT 54
63099: PUSH
63100: LD_INT 55
63102: PUSH
63103: LD_INT 56
63105: PUSH
63106: LD_INT 57
63108: PUSH
63109: LD_INT 58
63111: PUSH
63112: LD_INT 59
63114: PUSH
63115: LD_INT 63
63117: PUSH
63118: LD_INT 64
63120: PUSH
63121: LD_INT 65
63123: PUSH
63124: LD_INT 82
63126: PUSH
63127: LD_INT 83
63129: PUSH
63130: LD_INT 84
63132: PUSH
63133: LD_INT 85
63135: PUSH
63136: LD_INT 86
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: LIST
63168: LIST
63169: LIST
63170: LIST
63171: LIST
63172: LIST
63173: LIST
63174: LIST
63175: LIST
63176: LIST
63177: LIST
63178: LIST
63179: LIST
63180: LIST
63181: LIST
63182: LIST
63183: LIST
63184: LIST
63185: LIST
63186: LIST
63187: LIST
63188: LIST
63189: LIST
63190: LIST
63191: LIST
63192: LIST
63193: ST_TO_ADDR
63194: GO 63197
63196: POP
// if state > - 1 and state < 3 then
63197: LD_VAR 0 3
63201: PUSH
63202: LD_INT 1
63204: NEG
63205: GREATER
63206: PUSH
63207: LD_VAR 0 3
63211: PUSH
63212: LD_INT 3
63214: LESS
63215: AND
63216: IFFALSE 63273
// for i in result do
63218: LD_ADDR_VAR 0 5
63222: PUSH
63223: LD_VAR 0 4
63227: PUSH
63228: FOR_IN
63229: IFFALSE 63271
// if GetTech ( i , side ) <> state then
63231: LD_VAR 0 5
63235: PPUSH
63236: LD_VAR 0 1
63240: PPUSH
63241: CALL_OW 321
63245: PUSH
63246: LD_VAR 0 3
63250: NONEQUAL
63251: IFFALSE 63269
// result := result diff i ;
63253: LD_ADDR_VAR 0 4
63257: PUSH
63258: LD_VAR 0 4
63262: PUSH
63263: LD_VAR 0 5
63267: DIFF
63268: ST_TO_ADDR
63269: GO 63228
63271: POP
63272: POP
// end ;
63273: LD_VAR 0 4
63277: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63278: LD_INT 0
63280: PPUSH
63281: PPUSH
63282: PPUSH
// result := true ;
63283: LD_ADDR_VAR 0 3
63287: PUSH
63288: LD_INT 1
63290: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63291: LD_ADDR_VAR 0 5
63295: PUSH
63296: LD_VAR 0 2
63300: PPUSH
63301: CALL_OW 480
63305: ST_TO_ADDR
// if not tmp then
63306: LD_VAR 0 5
63310: NOT
63311: IFFALSE 63315
// exit ;
63313: GO 63364
// for i in tmp do
63315: LD_ADDR_VAR 0 4
63319: PUSH
63320: LD_VAR 0 5
63324: PUSH
63325: FOR_IN
63326: IFFALSE 63362
// if GetTech ( i , side ) <> state_researched then
63328: LD_VAR 0 4
63332: PPUSH
63333: LD_VAR 0 1
63337: PPUSH
63338: CALL_OW 321
63342: PUSH
63343: LD_INT 2
63345: NONEQUAL
63346: IFFALSE 63360
// begin result := false ;
63348: LD_ADDR_VAR 0 3
63352: PUSH
63353: LD_INT 0
63355: ST_TO_ADDR
// exit ;
63356: POP
63357: POP
63358: GO 63364
// end ;
63360: GO 63325
63362: POP
63363: POP
// end ;
63364: LD_VAR 0 3
63368: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63369: LD_INT 0
63371: PPUSH
63372: PPUSH
63373: PPUSH
63374: PPUSH
63375: PPUSH
63376: PPUSH
63377: PPUSH
63378: PPUSH
63379: PPUSH
63380: PPUSH
63381: PPUSH
63382: PPUSH
63383: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63384: LD_VAR 0 1
63388: NOT
63389: PUSH
63390: LD_VAR 0 1
63394: PPUSH
63395: CALL_OW 257
63399: PUSH
63400: LD_INT 9
63402: NONEQUAL
63403: OR
63404: IFFALSE 63408
// exit ;
63406: GO 63981
// side := GetSide ( unit ) ;
63408: LD_ADDR_VAR 0 9
63412: PUSH
63413: LD_VAR 0 1
63417: PPUSH
63418: CALL_OW 255
63422: ST_TO_ADDR
// tech_space := tech_spacanom ;
63423: LD_ADDR_VAR 0 12
63427: PUSH
63428: LD_INT 29
63430: ST_TO_ADDR
// tech_time := tech_taurad ;
63431: LD_ADDR_VAR 0 13
63435: PUSH
63436: LD_INT 28
63438: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63439: LD_ADDR_VAR 0 11
63443: PUSH
63444: LD_VAR 0 1
63448: PPUSH
63449: CALL_OW 310
63453: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63454: LD_VAR 0 11
63458: PPUSH
63459: CALL_OW 247
63463: PUSH
63464: LD_INT 2
63466: EQUAL
63467: IFFALSE 63471
// exit ;
63469: GO 63981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63471: LD_ADDR_VAR 0 8
63475: PUSH
63476: LD_INT 81
63478: PUSH
63479: LD_VAR 0 9
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: PUSH
63488: LD_INT 3
63490: PUSH
63491: LD_INT 21
63493: PUSH
63494: LD_INT 3
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: EMPTY
63502: LIST
63503: LIST
63504: PUSH
63505: EMPTY
63506: LIST
63507: LIST
63508: PPUSH
63509: CALL_OW 69
63513: ST_TO_ADDR
// if not tmp then
63514: LD_VAR 0 8
63518: NOT
63519: IFFALSE 63523
// exit ;
63521: GO 63981
// if in_unit then
63523: LD_VAR 0 11
63527: IFFALSE 63551
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63529: LD_ADDR_VAR 0 10
63533: PUSH
63534: LD_VAR 0 8
63538: PPUSH
63539: LD_VAR 0 11
63543: PPUSH
63544: CALL_OW 74
63548: ST_TO_ADDR
63549: GO 63571
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63551: LD_ADDR_VAR 0 10
63555: PUSH
63556: LD_VAR 0 8
63560: PPUSH
63561: LD_VAR 0 1
63565: PPUSH
63566: CALL_OW 74
63570: ST_TO_ADDR
// if not enemy then
63571: LD_VAR 0 10
63575: NOT
63576: IFFALSE 63580
// exit ;
63578: GO 63981
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
63580: LD_VAR 0 11
63584: PUSH
63585: LD_VAR 0 11
63589: PPUSH
63590: LD_VAR 0 10
63594: PPUSH
63595: CALL_OW 296
63599: PUSH
63600: LD_INT 13
63602: GREATER
63603: AND
63604: PUSH
63605: LD_VAR 0 1
63609: PPUSH
63610: LD_VAR 0 10
63614: PPUSH
63615: CALL_OW 296
63619: PUSH
63620: LD_INT 12
63622: GREATER
63623: OR
63624: IFFALSE 63628
// exit ;
63626: GO 63981
// missile := [ 1 ] ;
63628: LD_ADDR_VAR 0 14
63632: PUSH
63633: LD_INT 1
63635: PUSH
63636: EMPTY
63637: LIST
63638: ST_TO_ADDR
// if Researched ( side , tech_space ) then
63639: LD_VAR 0 9
63643: PPUSH
63644: LD_VAR 0 12
63648: PPUSH
63649: CALL_OW 325
63653: IFFALSE 63682
// missile := Replace ( missile , missile + 1 , 2 ) ;
63655: LD_ADDR_VAR 0 14
63659: PUSH
63660: LD_VAR 0 14
63664: PPUSH
63665: LD_VAR 0 14
63669: PUSH
63670: LD_INT 1
63672: PLUS
63673: PPUSH
63674: LD_INT 2
63676: PPUSH
63677: CALL_OW 1
63681: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
63682: LD_VAR 0 9
63686: PPUSH
63687: LD_VAR 0 13
63691: PPUSH
63692: CALL_OW 325
63696: PUSH
63697: LD_VAR 0 10
63701: PPUSH
63702: CALL_OW 255
63706: PPUSH
63707: LD_VAR 0 13
63711: PPUSH
63712: CALL_OW 325
63716: NOT
63717: AND
63718: IFFALSE 63747
// missile := Replace ( missile , missile + 1 , 3 ) ;
63720: LD_ADDR_VAR 0 14
63724: PUSH
63725: LD_VAR 0 14
63729: PPUSH
63730: LD_VAR 0 14
63734: PUSH
63735: LD_INT 1
63737: PLUS
63738: PPUSH
63739: LD_INT 3
63741: PPUSH
63742: CALL_OW 1
63746: ST_TO_ADDR
// if missile < 2 then
63747: LD_VAR 0 14
63751: PUSH
63752: LD_INT 2
63754: LESS
63755: IFFALSE 63759
// exit ;
63757: GO 63981
// x := GetX ( enemy ) ;
63759: LD_ADDR_VAR 0 4
63763: PUSH
63764: LD_VAR 0 10
63768: PPUSH
63769: CALL_OW 250
63773: ST_TO_ADDR
// y := GetY ( enemy ) ;
63774: LD_ADDR_VAR 0 5
63778: PUSH
63779: LD_VAR 0 10
63783: PPUSH
63784: CALL_OW 251
63788: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
63789: LD_ADDR_VAR 0 6
63793: PUSH
63794: LD_VAR 0 4
63798: PUSH
63799: LD_INT 1
63801: NEG
63802: PPUSH
63803: LD_INT 1
63805: PPUSH
63806: CALL_OW 12
63810: PLUS
63811: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
63812: LD_ADDR_VAR 0 7
63816: PUSH
63817: LD_VAR 0 5
63821: PUSH
63822: LD_INT 1
63824: NEG
63825: PPUSH
63826: LD_INT 1
63828: PPUSH
63829: CALL_OW 12
63833: PLUS
63834: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63835: LD_VAR 0 6
63839: PPUSH
63840: LD_VAR 0 7
63844: PPUSH
63845: CALL_OW 488
63849: NOT
63850: IFFALSE 63872
// begin _x := x ;
63852: LD_ADDR_VAR 0 6
63856: PUSH
63857: LD_VAR 0 4
63861: ST_TO_ADDR
// _y := y ;
63862: LD_ADDR_VAR 0 7
63866: PUSH
63867: LD_VAR 0 5
63871: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
63872: LD_ADDR_VAR 0 3
63876: PUSH
63877: LD_INT 1
63879: PPUSH
63880: LD_VAR 0 14
63884: PPUSH
63885: CALL_OW 12
63889: ST_TO_ADDR
// case i of 1 :
63890: LD_VAR 0 3
63894: PUSH
63895: LD_INT 1
63897: DOUBLE
63898: EQUAL
63899: IFTRUE 63903
63901: GO 63920
63903: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
63904: LD_VAR 0 1
63908: PPUSH
63909: LD_VAR 0 10
63913: PPUSH
63914: CALL_OW 115
63918: GO 63981
63920: LD_INT 2
63922: DOUBLE
63923: EQUAL
63924: IFTRUE 63928
63926: GO 63950
63928: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
63929: LD_VAR 0 1
63933: PPUSH
63934: LD_VAR 0 6
63938: PPUSH
63939: LD_VAR 0 7
63943: PPUSH
63944: CALL_OW 153
63948: GO 63981
63950: LD_INT 3
63952: DOUBLE
63953: EQUAL
63954: IFTRUE 63958
63956: GO 63980
63958: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
63959: LD_VAR 0 1
63963: PPUSH
63964: LD_VAR 0 6
63968: PPUSH
63969: LD_VAR 0 7
63973: PPUSH
63974: CALL_OW 154
63978: GO 63981
63980: POP
// end ;
63981: LD_VAR 0 2
63985: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
63986: LD_INT 0
63988: PPUSH
63989: PPUSH
63990: PPUSH
63991: PPUSH
63992: PPUSH
63993: PPUSH
// if not unit or not building then
63994: LD_VAR 0 1
63998: NOT
63999: PUSH
64000: LD_VAR 0 2
64004: NOT
64005: OR
64006: IFFALSE 64010
// exit ;
64008: GO 64168
// x := GetX ( building ) ;
64010: LD_ADDR_VAR 0 5
64014: PUSH
64015: LD_VAR 0 2
64019: PPUSH
64020: CALL_OW 250
64024: ST_TO_ADDR
// y := GetY ( building ) ;
64025: LD_ADDR_VAR 0 6
64029: PUSH
64030: LD_VAR 0 2
64034: PPUSH
64035: CALL_OW 251
64039: ST_TO_ADDR
// for i = 0 to 5 do
64040: LD_ADDR_VAR 0 4
64044: PUSH
64045: DOUBLE
64046: LD_INT 0
64048: DEC
64049: ST_TO_ADDR
64050: LD_INT 5
64052: PUSH
64053: FOR_TO
64054: IFFALSE 64166
// begin _x := ShiftX ( x , i , 3 ) ;
64056: LD_ADDR_VAR 0 7
64060: PUSH
64061: LD_VAR 0 5
64065: PPUSH
64066: LD_VAR 0 4
64070: PPUSH
64071: LD_INT 3
64073: PPUSH
64074: CALL_OW 272
64078: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64079: LD_ADDR_VAR 0 8
64083: PUSH
64084: LD_VAR 0 6
64088: PPUSH
64089: LD_VAR 0 4
64093: PPUSH
64094: LD_INT 3
64096: PPUSH
64097: CALL_OW 273
64101: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64102: LD_VAR 0 7
64106: PPUSH
64107: LD_VAR 0 8
64111: PPUSH
64112: CALL_OW 488
64116: NOT
64117: IFFALSE 64121
// continue ;
64119: GO 64053
// if HexInfo ( _x , _y ) = 0 then
64121: LD_VAR 0 7
64125: PPUSH
64126: LD_VAR 0 8
64130: PPUSH
64131: CALL_OW 428
64135: PUSH
64136: LD_INT 0
64138: EQUAL
64139: IFFALSE 64164
// begin ComMoveXY ( unit , _x , _y ) ;
64141: LD_VAR 0 1
64145: PPUSH
64146: LD_VAR 0 7
64150: PPUSH
64151: LD_VAR 0 8
64155: PPUSH
64156: CALL_OW 111
// exit ;
64160: POP
64161: POP
64162: GO 64168
// end ; end ;
64164: GO 64053
64166: POP
64167: POP
// end ;
64168: LD_VAR 0 3
64172: RET
// export function ScanBase ( side , base_area ) ; begin
64173: LD_INT 0
64175: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64176: LD_ADDR_VAR 0 3
64180: PUSH
64181: LD_VAR 0 2
64185: PPUSH
64186: LD_INT 81
64188: PUSH
64189: LD_VAR 0 1
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PPUSH
64198: CALL_OW 70
64202: ST_TO_ADDR
// end ;
64203: LD_VAR 0 3
64207: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
64208: LD_INT 0
64210: PPUSH
64211: PPUSH
64212: PPUSH
64213: PPUSH
// result := false ;
64214: LD_ADDR_VAR 0 2
64218: PUSH
64219: LD_INT 0
64221: ST_TO_ADDR
// side := GetSide ( unit ) ;
64222: LD_ADDR_VAR 0 3
64226: PUSH
64227: LD_VAR 0 1
64231: PPUSH
64232: CALL_OW 255
64236: ST_TO_ADDR
// nat := GetNation ( unit ) ;
64237: LD_ADDR_VAR 0 4
64241: PUSH
64242: LD_VAR 0 1
64246: PPUSH
64247: CALL_OW 248
64251: ST_TO_ADDR
// case nat of 1 :
64252: LD_VAR 0 4
64256: PUSH
64257: LD_INT 1
64259: DOUBLE
64260: EQUAL
64261: IFTRUE 64265
64263: GO 64276
64265: POP
// tech := tech_lassight ; 2 :
64266: LD_ADDR_VAR 0 5
64270: PUSH
64271: LD_INT 12
64273: ST_TO_ADDR
64274: GO 64315
64276: LD_INT 2
64278: DOUBLE
64279: EQUAL
64280: IFTRUE 64284
64282: GO 64295
64284: POP
// tech := tech_mortar ; 3 :
64285: LD_ADDR_VAR 0 5
64289: PUSH
64290: LD_INT 41
64292: ST_TO_ADDR
64293: GO 64315
64295: LD_INT 3
64297: DOUBLE
64298: EQUAL
64299: IFTRUE 64303
64301: GO 64314
64303: POP
// tech := tech_bazooka ; end ;
64304: LD_ADDR_VAR 0 5
64308: PUSH
64309: LD_INT 44
64311: ST_TO_ADDR
64312: GO 64315
64314: POP
// if Researched ( side , tech ) then
64315: LD_VAR 0 3
64319: PPUSH
64320: LD_VAR 0 5
64324: PPUSH
64325: CALL_OW 325
64329: IFFALSE 64356
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
64331: LD_ADDR_VAR 0 2
64335: PUSH
64336: LD_INT 5
64338: PUSH
64339: LD_INT 8
64341: PUSH
64342: LD_INT 9
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: LIST
64349: PUSH
64350: LD_VAR 0 4
64354: ARRAY
64355: ST_TO_ADDR
// end ;
64356: LD_VAR 0 2
64360: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
64361: LD_INT 0
64363: PPUSH
64364: PPUSH
64365: PPUSH
// if not mines then
64366: LD_VAR 0 2
64370: NOT
64371: IFFALSE 64375
// exit ;
64373: GO 64519
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64375: LD_ADDR_VAR 0 5
64379: PUSH
64380: LD_INT 81
64382: PUSH
64383: LD_VAR 0 1
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: LD_INT 3
64394: PUSH
64395: LD_INT 21
64397: PUSH
64398: LD_INT 3
64400: PUSH
64401: EMPTY
64402: LIST
64403: LIST
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: EMPTY
64410: LIST
64411: LIST
64412: PPUSH
64413: CALL_OW 69
64417: ST_TO_ADDR
// for i in mines do
64418: LD_ADDR_VAR 0 4
64422: PUSH
64423: LD_VAR 0 2
64427: PUSH
64428: FOR_IN
64429: IFFALSE 64517
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
64431: LD_VAR 0 4
64435: PUSH
64436: LD_INT 1
64438: ARRAY
64439: PPUSH
64440: LD_VAR 0 4
64444: PUSH
64445: LD_INT 2
64447: ARRAY
64448: PPUSH
64449: CALL_OW 458
64453: NOT
64454: IFFALSE 64458
// continue ;
64456: GO 64428
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
64458: LD_VAR 0 4
64462: PUSH
64463: LD_INT 1
64465: ARRAY
64466: PPUSH
64467: LD_VAR 0 4
64471: PUSH
64472: LD_INT 2
64474: ARRAY
64475: PPUSH
64476: CALL_OW 428
64480: PUSH
64481: LD_VAR 0 5
64485: IN
64486: IFFALSE 64515
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
64488: LD_VAR 0 4
64492: PUSH
64493: LD_INT 1
64495: ARRAY
64496: PPUSH
64497: LD_VAR 0 4
64501: PUSH
64502: LD_INT 2
64504: ARRAY
64505: PPUSH
64506: LD_VAR 0 1
64510: PPUSH
64511: CALL_OW 456
// end ;
64515: GO 64428
64517: POP
64518: POP
// end ;
64519: LD_VAR 0 3
64523: RET
// export function Count ( array ) ; var i ; begin
64524: LD_INT 0
64526: PPUSH
64527: PPUSH
// result := 0 ;
64528: LD_ADDR_VAR 0 2
64532: PUSH
64533: LD_INT 0
64535: ST_TO_ADDR
// for i in array do
64536: LD_ADDR_VAR 0 3
64540: PUSH
64541: LD_VAR 0 1
64545: PUSH
64546: FOR_IN
64547: IFFALSE 64571
// if i then
64549: LD_VAR 0 3
64553: IFFALSE 64569
// result := result + 1 ;
64555: LD_ADDR_VAR 0 2
64559: PUSH
64560: LD_VAR 0 2
64564: PUSH
64565: LD_INT 1
64567: PLUS
64568: ST_TO_ADDR
64569: GO 64546
64571: POP
64572: POP
// end ;
64573: LD_VAR 0 2
64577: RET
// export function IsEmpty ( building ) ; begin
64578: LD_INT 0
64580: PPUSH
// if not building then
64581: LD_VAR 0 1
64585: NOT
64586: IFFALSE 64590
// exit ;
64588: GO 64633
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
64590: LD_ADDR_VAR 0 2
64594: PUSH
64595: LD_VAR 0 1
64599: PUSH
64600: LD_INT 22
64602: PUSH
64603: LD_VAR 0 1
64607: PPUSH
64608: CALL_OW 255
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 58
64619: PUSH
64620: EMPTY
64621: LIST
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PPUSH
64627: CALL_OW 69
64631: IN
64632: ST_TO_ADDR
// end ;
64633: LD_VAR 0 2
64637: RET
// export function IsNotFull ( building ) ; begin
64638: LD_INT 0
64640: PPUSH
// if not building then
64641: LD_VAR 0 1
64645: NOT
64646: IFFALSE 64650
// exit ;
64648: GO 64669
// result := UnitsInside ( building ) < 6 ;
64650: LD_ADDR_VAR 0 2
64654: PUSH
64655: LD_VAR 0 1
64659: PPUSH
64660: CALL_OW 313
64664: PUSH
64665: LD_INT 6
64667: LESS
64668: ST_TO_ADDR
// end ;
64669: LD_VAR 0 2
64673: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
64674: LD_INT 0
64676: PPUSH
64677: PPUSH
64678: PPUSH
64679: PPUSH
// tmp := [ ] ;
64680: LD_ADDR_VAR 0 3
64684: PUSH
64685: EMPTY
64686: ST_TO_ADDR
// list := [ ] ;
64687: LD_ADDR_VAR 0 5
64691: PUSH
64692: EMPTY
64693: ST_TO_ADDR
// for i = 16 to 25 do
64694: LD_ADDR_VAR 0 4
64698: PUSH
64699: DOUBLE
64700: LD_INT 16
64702: DEC
64703: ST_TO_ADDR
64704: LD_INT 25
64706: PUSH
64707: FOR_TO
64708: IFFALSE 64781
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
64710: LD_ADDR_VAR 0 3
64714: PUSH
64715: LD_VAR 0 3
64719: PUSH
64720: LD_INT 22
64722: PUSH
64723: LD_VAR 0 1
64727: PPUSH
64728: CALL_OW 255
64732: PUSH
64733: EMPTY
64734: LIST
64735: LIST
64736: PUSH
64737: LD_INT 91
64739: PUSH
64740: LD_VAR 0 1
64744: PUSH
64745: LD_INT 6
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: LIST
64752: PUSH
64753: LD_INT 30
64755: PUSH
64756: LD_VAR 0 4
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: LIST
64769: PUSH
64770: EMPTY
64771: LIST
64772: PPUSH
64773: CALL_OW 69
64777: ADD
64778: ST_TO_ADDR
64779: GO 64707
64781: POP
64782: POP
// for i = 1 to tmp do
64783: LD_ADDR_VAR 0 4
64787: PUSH
64788: DOUBLE
64789: LD_INT 1
64791: DEC
64792: ST_TO_ADDR
64793: LD_VAR 0 3
64797: PUSH
64798: FOR_TO
64799: IFFALSE 64887
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
64801: LD_ADDR_VAR 0 5
64805: PUSH
64806: LD_VAR 0 5
64810: PUSH
64811: LD_VAR 0 3
64815: PUSH
64816: LD_VAR 0 4
64820: ARRAY
64821: PPUSH
64822: CALL_OW 266
64826: PUSH
64827: LD_VAR 0 3
64831: PUSH
64832: LD_VAR 0 4
64836: ARRAY
64837: PPUSH
64838: CALL_OW 250
64842: PUSH
64843: LD_VAR 0 3
64847: PUSH
64848: LD_VAR 0 4
64852: ARRAY
64853: PPUSH
64854: CALL_OW 251
64858: PUSH
64859: LD_VAR 0 3
64863: PUSH
64864: LD_VAR 0 4
64868: ARRAY
64869: PPUSH
64870: CALL_OW 254
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: LIST
64879: LIST
64880: PUSH
64881: EMPTY
64882: LIST
64883: ADD
64884: ST_TO_ADDR
64885: GO 64798
64887: POP
64888: POP
// result := list ;
64889: LD_ADDR_VAR 0 2
64893: PUSH
64894: LD_VAR 0 5
64898: ST_TO_ADDR
// end ;
64899: LD_VAR 0 2
64903: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
64904: LD_INT 0
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
64910: PPUSH
64911: PPUSH
64912: PPUSH
// if not factory then
64913: LD_VAR 0 1
64917: NOT
64918: IFFALSE 64922
// exit ;
64920: GO 65515
// if control = control_apeman then
64922: LD_VAR 0 4
64926: PUSH
64927: LD_INT 5
64929: EQUAL
64930: IFFALSE 65039
// begin tmp := UnitsInside ( factory ) ;
64932: LD_ADDR_VAR 0 8
64936: PUSH
64937: LD_VAR 0 1
64941: PPUSH
64942: CALL_OW 313
64946: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
64947: LD_VAR 0 8
64951: PPUSH
64952: LD_INT 25
64954: PUSH
64955: LD_INT 12
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PPUSH
64962: CALL_OW 72
64966: NOT
64967: IFFALSE 64977
// control := control_manual ;
64969: LD_ADDR_VAR 0 4
64973: PUSH
64974: LD_INT 1
64976: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
64977: LD_ADDR_VAR 0 8
64981: PUSH
64982: LD_VAR 0 1
64986: PPUSH
64987: CALL 64674 0 1
64991: ST_TO_ADDR
// if tmp then
64992: LD_VAR 0 8
64996: IFFALSE 65039
// begin for i in tmp do
64998: LD_ADDR_VAR 0 7
65002: PUSH
65003: LD_VAR 0 8
65007: PUSH
65008: FOR_IN
65009: IFFALSE 65037
// if i [ 1 ] = b_ext_radio then
65011: LD_VAR 0 7
65015: PUSH
65016: LD_INT 1
65018: ARRAY
65019: PUSH
65020: LD_INT 22
65022: EQUAL
65023: IFFALSE 65035
// begin control := control_remote ;
65025: LD_ADDR_VAR 0 4
65029: PUSH
65030: LD_INT 2
65032: ST_TO_ADDR
// break ;
65033: GO 65037
// end ;
65035: GO 65008
65037: POP
65038: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65039: LD_VAR 0 1
65043: PPUSH
65044: LD_VAR 0 2
65048: PPUSH
65049: LD_VAR 0 3
65053: PPUSH
65054: LD_VAR 0 4
65058: PPUSH
65059: LD_VAR 0 5
65063: PPUSH
65064: CALL_OW 448
65068: IFFALSE 65103
// begin result := [ chassis , engine , control , weapon ] ;
65070: LD_ADDR_VAR 0 6
65074: PUSH
65075: LD_VAR 0 2
65079: PUSH
65080: LD_VAR 0 3
65084: PUSH
65085: LD_VAR 0 4
65089: PUSH
65090: LD_VAR 0 5
65094: PUSH
65095: EMPTY
65096: LIST
65097: LIST
65098: LIST
65099: LIST
65100: ST_TO_ADDR
// exit ;
65101: GO 65515
// end ; _chassis := AvailableChassisList ( factory ) ;
65103: LD_ADDR_VAR 0 9
65107: PUSH
65108: LD_VAR 0 1
65112: PPUSH
65113: CALL_OW 475
65117: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
65118: LD_ADDR_VAR 0 11
65122: PUSH
65123: LD_VAR 0 1
65127: PPUSH
65128: CALL_OW 476
65132: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
65133: LD_ADDR_VAR 0 12
65137: PUSH
65138: LD_VAR 0 1
65142: PPUSH
65143: CALL_OW 477
65147: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
65148: LD_ADDR_VAR 0 10
65152: PUSH
65153: LD_VAR 0 1
65157: PPUSH
65158: CALL_OW 478
65162: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
65163: LD_VAR 0 9
65167: NOT
65168: PUSH
65169: LD_VAR 0 11
65173: NOT
65174: OR
65175: PUSH
65176: LD_VAR 0 12
65180: NOT
65181: OR
65182: PUSH
65183: LD_VAR 0 10
65187: NOT
65188: OR
65189: IFFALSE 65224
// begin result := [ chassis , engine , control , weapon ] ;
65191: LD_ADDR_VAR 0 6
65195: PUSH
65196: LD_VAR 0 2
65200: PUSH
65201: LD_VAR 0 3
65205: PUSH
65206: LD_VAR 0 4
65210: PUSH
65211: LD_VAR 0 5
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: ST_TO_ADDR
// exit ;
65222: GO 65515
// end ; if not chassis in _chassis then
65224: LD_VAR 0 2
65228: PUSH
65229: LD_VAR 0 9
65233: IN
65234: NOT
65235: IFFALSE 65261
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
65237: LD_ADDR_VAR 0 2
65241: PUSH
65242: LD_VAR 0 9
65246: PUSH
65247: LD_INT 1
65249: PPUSH
65250: LD_VAR 0 9
65254: PPUSH
65255: CALL_OW 12
65259: ARRAY
65260: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
65261: LD_VAR 0 2
65265: PPUSH
65266: LD_VAR 0 3
65270: PPUSH
65271: CALL 65520 0 2
65275: NOT
65276: IFFALSE 65335
// repeat engine := _engine [ 1 ] ;
65278: LD_ADDR_VAR 0 3
65282: PUSH
65283: LD_VAR 0 11
65287: PUSH
65288: LD_INT 1
65290: ARRAY
65291: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
65292: LD_ADDR_VAR 0 11
65296: PUSH
65297: LD_VAR 0 11
65301: PPUSH
65302: LD_INT 1
65304: PPUSH
65305: CALL_OW 3
65309: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
65310: LD_VAR 0 2
65314: PPUSH
65315: LD_VAR 0 3
65319: PPUSH
65320: CALL 65520 0 2
65324: PUSH
65325: LD_VAR 0 11
65329: PUSH
65330: EMPTY
65331: EQUAL
65332: OR
65333: IFFALSE 65278
// if not control in _control then
65335: LD_VAR 0 4
65339: PUSH
65340: LD_VAR 0 12
65344: IN
65345: NOT
65346: IFFALSE 65372
// control := _control [ rand ( 1 , _control ) ] ;
65348: LD_ADDR_VAR 0 4
65352: PUSH
65353: LD_VAR 0 12
65357: PUSH
65358: LD_INT 1
65360: PPUSH
65361: LD_VAR 0 12
65365: PPUSH
65366: CALL_OW 12
65370: ARRAY
65371: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
65372: LD_VAR 0 2
65376: PPUSH
65377: LD_VAR 0 5
65381: PPUSH
65382: CALL 65740 0 2
65386: NOT
65387: IFFALSE 65446
// repeat weapon := _weapon [ 1 ] ;
65389: LD_ADDR_VAR 0 5
65393: PUSH
65394: LD_VAR 0 10
65398: PUSH
65399: LD_INT 1
65401: ARRAY
65402: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
65403: LD_ADDR_VAR 0 10
65407: PUSH
65408: LD_VAR 0 10
65412: PPUSH
65413: LD_INT 1
65415: PPUSH
65416: CALL_OW 3
65420: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
65421: LD_VAR 0 2
65425: PPUSH
65426: LD_VAR 0 5
65430: PPUSH
65431: CALL 65740 0 2
65435: PUSH
65436: LD_VAR 0 10
65440: PUSH
65441: EMPTY
65442: EQUAL
65443: OR
65444: IFFALSE 65389
// result := [ ] ;
65446: LD_ADDR_VAR 0 6
65450: PUSH
65451: EMPTY
65452: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65453: LD_VAR 0 1
65457: PPUSH
65458: LD_VAR 0 2
65462: PPUSH
65463: LD_VAR 0 3
65467: PPUSH
65468: LD_VAR 0 4
65472: PPUSH
65473: LD_VAR 0 5
65477: PPUSH
65478: CALL_OW 448
65482: IFFALSE 65515
// result := [ chassis , engine , control , weapon ] ;
65484: LD_ADDR_VAR 0 6
65488: PUSH
65489: LD_VAR 0 2
65493: PUSH
65494: LD_VAR 0 3
65498: PUSH
65499: LD_VAR 0 4
65503: PUSH
65504: LD_VAR 0 5
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: ST_TO_ADDR
// end ;
65515: LD_VAR 0 6
65519: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
65520: LD_INT 0
65522: PPUSH
// if not chassis or not engine then
65523: LD_VAR 0 1
65527: NOT
65528: PUSH
65529: LD_VAR 0 2
65533: NOT
65534: OR
65535: IFFALSE 65539
// exit ;
65537: GO 65735
// case engine of engine_solar :
65539: LD_VAR 0 2
65543: PUSH
65544: LD_INT 2
65546: DOUBLE
65547: EQUAL
65548: IFTRUE 65552
65550: GO 65590
65552: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
65553: LD_ADDR_VAR 0 3
65557: PUSH
65558: LD_INT 11
65560: PUSH
65561: LD_INT 12
65563: PUSH
65564: LD_INT 13
65566: PUSH
65567: LD_INT 14
65569: PUSH
65570: LD_INT 1
65572: PUSH
65573: LD_INT 2
65575: PUSH
65576: LD_INT 3
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: ST_TO_ADDR
65588: GO 65719
65590: LD_INT 1
65592: DOUBLE
65593: EQUAL
65594: IFTRUE 65598
65596: GO 65660
65598: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
65599: LD_ADDR_VAR 0 3
65603: PUSH
65604: LD_INT 11
65606: PUSH
65607: LD_INT 12
65609: PUSH
65610: LD_INT 13
65612: PUSH
65613: LD_INT 14
65615: PUSH
65616: LD_INT 1
65618: PUSH
65619: LD_INT 2
65621: PUSH
65622: LD_INT 3
65624: PUSH
65625: LD_INT 4
65627: PUSH
65628: LD_INT 5
65630: PUSH
65631: LD_INT 21
65633: PUSH
65634: LD_INT 23
65636: PUSH
65637: LD_INT 22
65639: PUSH
65640: LD_INT 24
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: LIST
65647: LIST
65648: LIST
65649: LIST
65650: LIST
65651: LIST
65652: LIST
65653: LIST
65654: LIST
65655: LIST
65656: LIST
65657: ST_TO_ADDR
65658: GO 65719
65660: LD_INT 3
65662: DOUBLE
65663: EQUAL
65664: IFTRUE 65668
65666: GO 65718
65668: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
65669: LD_ADDR_VAR 0 3
65673: PUSH
65674: LD_INT 13
65676: PUSH
65677: LD_INT 14
65679: PUSH
65680: LD_INT 2
65682: PUSH
65683: LD_INT 3
65685: PUSH
65686: LD_INT 4
65688: PUSH
65689: LD_INT 5
65691: PUSH
65692: LD_INT 21
65694: PUSH
65695: LD_INT 22
65697: PUSH
65698: LD_INT 23
65700: PUSH
65701: LD_INT 24
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: ST_TO_ADDR
65716: GO 65719
65718: POP
// result := ( chassis in result ) ;
65719: LD_ADDR_VAR 0 3
65723: PUSH
65724: LD_VAR 0 1
65728: PUSH
65729: LD_VAR 0 3
65733: IN
65734: ST_TO_ADDR
// end ;
65735: LD_VAR 0 3
65739: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
65740: LD_INT 0
65742: PPUSH
// if not chassis or not weapon then
65743: LD_VAR 0 1
65747: NOT
65748: PUSH
65749: LD_VAR 0 2
65753: NOT
65754: OR
65755: IFFALSE 65759
// exit ;
65757: GO 66821
// case weapon of us_machine_gun :
65759: LD_VAR 0 2
65763: PUSH
65764: LD_INT 2
65766: DOUBLE
65767: EQUAL
65768: IFTRUE 65772
65770: GO 65802
65772: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
65773: LD_ADDR_VAR 0 3
65777: PUSH
65778: LD_INT 1
65780: PUSH
65781: LD_INT 2
65783: PUSH
65784: LD_INT 3
65786: PUSH
65787: LD_INT 4
65789: PUSH
65790: LD_INT 5
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: ST_TO_ADDR
65800: GO 66805
65802: LD_INT 3
65804: DOUBLE
65805: EQUAL
65806: IFTRUE 65810
65808: GO 65840
65810: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
65811: LD_ADDR_VAR 0 3
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: LD_INT 2
65821: PUSH
65822: LD_INT 3
65824: PUSH
65825: LD_INT 4
65827: PUSH
65828: LD_INT 5
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: ST_TO_ADDR
65838: GO 66805
65840: LD_INT 11
65842: DOUBLE
65843: EQUAL
65844: IFTRUE 65848
65846: GO 65878
65848: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
65849: LD_ADDR_VAR 0 3
65853: PUSH
65854: LD_INT 1
65856: PUSH
65857: LD_INT 2
65859: PUSH
65860: LD_INT 3
65862: PUSH
65863: LD_INT 4
65865: PUSH
65866: LD_INT 5
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: ST_TO_ADDR
65876: GO 66805
65878: LD_INT 4
65880: DOUBLE
65881: EQUAL
65882: IFTRUE 65886
65884: GO 65912
65886: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
65887: LD_ADDR_VAR 0 3
65891: PUSH
65892: LD_INT 2
65894: PUSH
65895: LD_INT 3
65897: PUSH
65898: LD_INT 4
65900: PUSH
65901: LD_INT 5
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: ST_TO_ADDR
65910: GO 66805
65912: LD_INT 5
65914: DOUBLE
65915: EQUAL
65916: IFTRUE 65920
65918: GO 65946
65920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
65921: LD_ADDR_VAR 0 3
65925: PUSH
65926: LD_INT 2
65928: PUSH
65929: LD_INT 3
65931: PUSH
65932: LD_INT 4
65934: PUSH
65935: LD_INT 5
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: ST_TO_ADDR
65944: GO 66805
65946: LD_INT 9
65948: DOUBLE
65949: EQUAL
65950: IFTRUE 65954
65952: GO 65980
65954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
65955: LD_ADDR_VAR 0 3
65959: PUSH
65960: LD_INT 2
65962: PUSH
65963: LD_INT 3
65965: PUSH
65966: LD_INT 4
65968: PUSH
65969: LD_INT 5
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: ST_TO_ADDR
65978: GO 66805
65980: LD_INT 7
65982: DOUBLE
65983: EQUAL
65984: IFTRUE 65988
65986: GO 66014
65988: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
65989: LD_ADDR_VAR 0 3
65993: PUSH
65994: LD_INT 2
65996: PUSH
65997: LD_INT 3
65999: PUSH
66000: LD_INT 4
66002: PUSH
66003: LD_INT 5
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: ST_TO_ADDR
66012: GO 66805
66014: LD_INT 12
66016: DOUBLE
66017: EQUAL
66018: IFTRUE 66022
66020: GO 66048
66022: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66023: LD_ADDR_VAR 0 3
66027: PUSH
66028: LD_INT 2
66030: PUSH
66031: LD_INT 3
66033: PUSH
66034: LD_INT 4
66036: PUSH
66037: LD_INT 5
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: LIST
66044: LIST
66045: ST_TO_ADDR
66046: GO 66805
66048: LD_INT 13
66050: DOUBLE
66051: EQUAL
66052: IFTRUE 66056
66054: GO 66082
66056: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
66057: LD_ADDR_VAR 0 3
66061: PUSH
66062: LD_INT 2
66064: PUSH
66065: LD_INT 3
66067: PUSH
66068: LD_INT 4
66070: PUSH
66071: LD_INT 5
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: ST_TO_ADDR
66080: GO 66805
66082: LD_INT 14
66084: DOUBLE
66085: EQUAL
66086: IFTRUE 66090
66088: GO 66108
66090: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
66091: LD_ADDR_VAR 0 3
66095: PUSH
66096: LD_INT 4
66098: PUSH
66099: LD_INT 5
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: ST_TO_ADDR
66106: GO 66805
66108: LD_INT 6
66110: DOUBLE
66111: EQUAL
66112: IFTRUE 66116
66114: GO 66134
66116: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
66117: LD_ADDR_VAR 0 3
66121: PUSH
66122: LD_INT 4
66124: PUSH
66125: LD_INT 5
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: ST_TO_ADDR
66132: GO 66805
66134: LD_INT 10
66136: DOUBLE
66137: EQUAL
66138: IFTRUE 66142
66140: GO 66160
66142: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
66143: LD_ADDR_VAR 0 3
66147: PUSH
66148: LD_INT 4
66150: PUSH
66151: LD_INT 5
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: ST_TO_ADDR
66158: GO 66805
66160: LD_INT 22
66162: DOUBLE
66163: EQUAL
66164: IFTRUE 66168
66166: GO 66194
66168: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
66169: LD_ADDR_VAR 0 3
66173: PUSH
66174: LD_INT 11
66176: PUSH
66177: LD_INT 12
66179: PUSH
66180: LD_INT 13
66182: PUSH
66183: LD_INT 14
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: ST_TO_ADDR
66192: GO 66805
66194: LD_INT 23
66196: DOUBLE
66197: EQUAL
66198: IFTRUE 66202
66200: GO 66228
66202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
66203: LD_ADDR_VAR 0 3
66207: PUSH
66208: LD_INT 11
66210: PUSH
66211: LD_INT 12
66213: PUSH
66214: LD_INT 13
66216: PUSH
66217: LD_INT 14
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: ST_TO_ADDR
66226: GO 66805
66228: LD_INT 24
66230: DOUBLE
66231: EQUAL
66232: IFTRUE 66236
66234: GO 66262
66236: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
66237: LD_ADDR_VAR 0 3
66241: PUSH
66242: LD_INT 11
66244: PUSH
66245: LD_INT 12
66247: PUSH
66248: LD_INT 13
66250: PUSH
66251: LD_INT 14
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: ST_TO_ADDR
66260: GO 66805
66262: LD_INT 30
66264: DOUBLE
66265: EQUAL
66266: IFTRUE 66270
66268: GO 66296
66270: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
66271: LD_ADDR_VAR 0 3
66275: PUSH
66276: LD_INT 11
66278: PUSH
66279: LD_INT 12
66281: PUSH
66282: LD_INT 13
66284: PUSH
66285: LD_INT 14
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: ST_TO_ADDR
66294: GO 66805
66296: LD_INT 25
66298: DOUBLE
66299: EQUAL
66300: IFTRUE 66304
66302: GO 66322
66304: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
66305: LD_ADDR_VAR 0 3
66309: PUSH
66310: LD_INT 13
66312: PUSH
66313: LD_INT 14
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: ST_TO_ADDR
66320: GO 66805
66322: LD_INT 27
66324: DOUBLE
66325: EQUAL
66326: IFTRUE 66330
66328: GO 66348
66330: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
66331: LD_ADDR_VAR 0 3
66335: PUSH
66336: LD_INT 13
66338: PUSH
66339: LD_INT 14
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: ST_TO_ADDR
66346: GO 66805
66348: LD_EXP 78
66352: DOUBLE
66353: EQUAL
66354: IFTRUE 66358
66356: GO 66384
66358: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
66359: LD_ADDR_VAR 0 3
66363: PUSH
66364: LD_INT 11
66366: PUSH
66367: LD_INT 12
66369: PUSH
66370: LD_INT 13
66372: PUSH
66373: LD_INT 14
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: ST_TO_ADDR
66382: GO 66805
66384: LD_INT 28
66386: DOUBLE
66387: EQUAL
66388: IFTRUE 66392
66390: GO 66410
66392: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
66393: LD_ADDR_VAR 0 3
66397: PUSH
66398: LD_INT 13
66400: PUSH
66401: LD_INT 14
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: ST_TO_ADDR
66408: GO 66805
66410: LD_INT 29
66412: DOUBLE
66413: EQUAL
66414: IFTRUE 66418
66416: GO 66436
66418: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
66419: LD_ADDR_VAR 0 3
66423: PUSH
66424: LD_INT 13
66426: PUSH
66427: LD_INT 14
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: ST_TO_ADDR
66434: GO 66805
66436: LD_INT 31
66438: DOUBLE
66439: EQUAL
66440: IFTRUE 66444
66442: GO 66462
66444: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
66445: LD_ADDR_VAR 0 3
66449: PUSH
66450: LD_INT 13
66452: PUSH
66453: LD_INT 14
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: ST_TO_ADDR
66460: GO 66805
66462: LD_INT 26
66464: DOUBLE
66465: EQUAL
66466: IFTRUE 66470
66468: GO 66488
66470: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
66471: LD_ADDR_VAR 0 3
66475: PUSH
66476: LD_INT 13
66478: PUSH
66479: LD_INT 14
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: ST_TO_ADDR
66486: GO 66805
66488: LD_INT 42
66490: DOUBLE
66491: EQUAL
66492: IFTRUE 66496
66494: GO 66522
66496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
66497: LD_ADDR_VAR 0 3
66501: PUSH
66502: LD_INT 21
66504: PUSH
66505: LD_INT 22
66507: PUSH
66508: LD_INT 23
66510: PUSH
66511: LD_INT 24
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: ST_TO_ADDR
66520: GO 66805
66522: LD_INT 43
66524: DOUBLE
66525: EQUAL
66526: IFTRUE 66530
66528: GO 66556
66530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
66531: LD_ADDR_VAR 0 3
66535: PUSH
66536: LD_INT 21
66538: PUSH
66539: LD_INT 22
66541: PUSH
66542: LD_INT 23
66544: PUSH
66545: LD_INT 24
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: ST_TO_ADDR
66554: GO 66805
66556: LD_INT 44
66558: DOUBLE
66559: EQUAL
66560: IFTRUE 66564
66562: GO 66590
66564: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
66565: LD_ADDR_VAR 0 3
66569: PUSH
66570: LD_INT 21
66572: PUSH
66573: LD_INT 22
66575: PUSH
66576: LD_INT 23
66578: PUSH
66579: LD_INT 24
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: ST_TO_ADDR
66588: GO 66805
66590: LD_INT 45
66592: DOUBLE
66593: EQUAL
66594: IFTRUE 66598
66596: GO 66624
66598: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
66599: LD_ADDR_VAR 0 3
66603: PUSH
66604: LD_INT 21
66606: PUSH
66607: LD_INT 22
66609: PUSH
66610: LD_INT 23
66612: PUSH
66613: LD_INT 24
66615: PUSH
66616: EMPTY
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: ST_TO_ADDR
66622: GO 66805
66624: LD_INT 49
66626: DOUBLE
66627: EQUAL
66628: IFTRUE 66632
66630: GO 66658
66632: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
66633: LD_ADDR_VAR 0 3
66637: PUSH
66638: LD_INT 21
66640: PUSH
66641: LD_INT 22
66643: PUSH
66644: LD_INT 23
66646: PUSH
66647: LD_INT 24
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: ST_TO_ADDR
66656: GO 66805
66658: LD_INT 51
66660: DOUBLE
66661: EQUAL
66662: IFTRUE 66666
66664: GO 66692
66666: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
66667: LD_ADDR_VAR 0 3
66671: PUSH
66672: LD_INT 21
66674: PUSH
66675: LD_INT 22
66677: PUSH
66678: LD_INT 23
66680: PUSH
66681: LD_INT 24
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: ST_TO_ADDR
66690: GO 66805
66692: LD_INT 52
66694: DOUBLE
66695: EQUAL
66696: IFTRUE 66700
66698: GO 66726
66700: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
66701: LD_ADDR_VAR 0 3
66705: PUSH
66706: LD_INT 21
66708: PUSH
66709: LD_INT 22
66711: PUSH
66712: LD_INT 23
66714: PUSH
66715: LD_INT 24
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: ST_TO_ADDR
66724: GO 66805
66726: LD_INT 53
66728: DOUBLE
66729: EQUAL
66730: IFTRUE 66734
66732: GO 66752
66734: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
66735: LD_ADDR_VAR 0 3
66739: PUSH
66740: LD_INT 23
66742: PUSH
66743: LD_INT 24
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: ST_TO_ADDR
66750: GO 66805
66752: LD_INT 46
66754: DOUBLE
66755: EQUAL
66756: IFTRUE 66760
66758: GO 66778
66760: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
66761: LD_ADDR_VAR 0 3
66765: PUSH
66766: LD_INT 23
66768: PUSH
66769: LD_INT 24
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: ST_TO_ADDR
66776: GO 66805
66778: LD_INT 47
66780: DOUBLE
66781: EQUAL
66782: IFTRUE 66786
66784: GO 66804
66786: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66787: LD_ADDR_VAR 0 3
66791: PUSH
66792: LD_INT 23
66794: PUSH
66795: LD_INT 24
66797: PUSH
66798: EMPTY
66799: LIST
66800: LIST
66801: ST_TO_ADDR
66802: GO 66805
66804: POP
// result := ( chassis in result ) ;
66805: LD_ADDR_VAR 0 3
66809: PUSH
66810: LD_VAR 0 1
66814: PUSH
66815: LD_VAR 0 3
66819: IN
66820: ST_TO_ADDR
// end ;
66821: LD_VAR 0 3
66825: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
66826: LD_INT 0
66828: PPUSH
66829: PPUSH
66830: PPUSH
66831: PPUSH
66832: PPUSH
66833: PPUSH
66834: PPUSH
// result := array ;
66835: LD_ADDR_VAR 0 5
66839: PUSH
66840: LD_VAR 0 1
66844: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
66845: LD_VAR 0 1
66849: NOT
66850: PUSH
66851: LD_VAR 0 2
66855: NOT
66856: OR
66857: PUSH
66858: LD_VAR 0 3
66862: NOT
66863: OR
66864: PUSH
66865: LD_VAR 0 2
66869: PUSH
66870: LD_VAR 0 1
66874: GREATER
66875: OR
66876: PUSH
66877: LD_VAR 0 3
66881: PUSH
66882: LD_VAR 0 1
66886: GREATER
66887: OR
66888: IFFALSE 66892
// exit ;
66890: GO 67188
// if direction then
66892: LD_VAR 0 4
66896: IFFALSE 66960
// begin d := 1 ;
66898: LD_ADDR_VAR 0 9
66902: PUSH
66903: LD_INT 1
66905: ST_TO_ADDR
// if i_from > i_to then
66906: LD_VAR 0 2
66910: PUSH
66911: LD_VAR 0 3
66915: GREATER
66916: IFFALSE 66942
// length := ( array - i_from ) + i_to else
66918: LD_ADDR_VAR 0 11
66922: PUSH
66923: LD_VAR 0 1
66927: PUSH
66928: LD_VAR 0 2
66932: MINUS
66933: PUSH
66934: LD_VAR 0 3
66938: PLUS
66939: ST_TO_ADDR
66940: GO 66958
// length := i_to - i_from ;
66942: LD_ADDR_VAR 0 11
66946: PUSH
66947: LD_VAR 0 3
66951: PUSH
66952: LD_VAR 0 2
66956: MINUS
66957: ST_TO_ADDR
// end else
66958: GO 67021
// begin d := - 1 ;
66960: LD_ADDR_VAR 0 9
66964: PUSH
66965: LD_INT 1
66967: NEG
66968: ST_TO_ADDR
// if i_from > i_to then
66969: LD_VAR 0 2
66973: PUSH
66974: LD_VAR 0 3
66978: GREATER
66979: IFFALSE 66999
// length := i_from - i_to else
66981: LD_ADDR_VAR 0 11
66985: PUSH
66986: LD_VAR 0 2
66990: PUSH
66991: LD_VAR 0 3
66995: MINUS
66996: ST_TO_ADDR
66997: GO 67021
// length := ( array - i_to ) + i_from ;
66999: LD_ADDR_VAR 0 11
67003: PUSH
67004: LD_VAR 0 1
67008: PUSH
67009: LD_VAR 0 3
67013: MINUS
67014: PUSH
67015: LD_VAR 0 2
67019: PLUS
67020: ST_TO_ADDR
// end ; if not length then
67021: LD_VAR 0 11
67025: NOT
67026: IFFALSE 67030
// exit ;
67028: GO 67188
// tmp := array ;
67030: LD_ADDR_VAR 0 10
67034: PUSH
67035: LD_VAR 0 1
67039: ST_TO_ADDR
// for i = 1 to length do
67040: LD_ADDR_VAR 0 6
67044: PUSH
67045: DOUBLE
67046: LD_INT 1
67048: DEC
67049: ST_TO_ADDR
67050: LD_VAR 0 11
67054: PUSH
67055: FOR_TO
67056: IFFALSE 67176
// begin for j = 1 to array do
67058: LD_ADDR_VAR 0 7
67062: PUSH
67063: DOUBLE
67064: LD_INT 1
67066: DEC
67067: ST_TO_ADDR
67068: LD_VAR 0 1
67072: PUSH
67073: FOR_TO
67074: IFFALSE 67162
// begin k := j + d ;
67076: LD_ADDR_VAR 0 8
67080: PUSH
67081: LD_VAR 0 7
67085: PUSH
67086: LD_VAR 0 9
67090: PLUS
67091: ST_TO_ADDR
// if k > array then
67092: LD_VAR 0 8
67096: PUSH
67097: LD_VAR 0 1
67101: GREATER
67102: IFFALSE 67112
// k := 1 ;
67104: LD_ADDR_VAR 0 8
67108: PUSH
67109: LD_INT 1
67111: ST_TO_ADDR
// if not k then
67112: LD_VAR 0 8
67116: NOT
67117: IFFALSE 67129
// k := array ;
67119: LD_ADDR_VAR 0 8
67123: PUSH
67124: LD_VAR 0 1
67128: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
67129: LD_ADDR_VAR 0 10
67133: PUSH
67134: LD_VAR 0 10
67138: PPUSH
67139: LD_VAR 0 8
67143: PPUSH
67144: LD_VAR 0 1
67148: PUSH
67149: LD_VAR 0 7
67153: ARRAY
67154: PPUSH
67155: CALL_OW 1
67159: ST_TO_ADDR
// end ;
67160: GO 67073
67162: POP
67163: POP
// array := tmp ;
67164: LD_ADDR_VAR 0 1
67168: PUSH
67169: LD_VAR 0 10
67173: ST_TO_ADDR
// end ;
67174: GO 67055
67176: POP
67177: POP
// result := array ;
67178: LD_ADDR_VAR 0 5
67182: PUSH
67183: LD_VAR 0 1
67187: ST_TO_ADDR
// end ;
67188: LD_VAR 0 5
67192: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
67193: LD_INT 0
67195: PPUSH
67196: PPUSH
// result := 0 ;
67197: LD_ADDR_VAR 0 3
67201: PUSH
67202: LD_INT 0
67204: ST_TO_ADDR
// if not array or not value in array then
67205: LD_VAR 0 1
67209: NOT
67210: PUSH
67211: LD_VAR 0 2
67215: PUSH
67216: LD_VAR 0 1
67220: IN
67221: NOT
67222: OR
67223: IFFALSE 67227
// exit ;
67225: GO 67281
// for i = 1 to array do
67227: LD_ADDR_VAR 0 4
67231: PUSH
67232: DOUBLE
67233: LD_INT 1
67235: DEC
67236: ST_TO_ADDR
67237: LD_VAR 0 1
67241: PUSH
67242: FOR_TO
67243: IFFALSE 67279
// if value = array [ i ] then
67245: LD_VAR 0 2
67249: PUSH
67250: LD_VAR 0 1
67254: PUSH
67255: LD_VAR 0 4
67259: ARRAY
67260: EQUAL
67261: IFFALSE 67277
// begin result := i ;
67263: LD_ADDR_VAR 0 3
67267: PUSH
67268: LD_VAR 0 4
67272: ST_TO_ADDR
// exit ;
67273: POP
67274: POP
67275: GO 67281
// end ;
67277: GO 67242
67279: POP
67280: POP
// end ;
67281: LD_VAR 0 3
67285: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
67286: LD_INT 0
67288: PPUSH
// vc_chassis := chassis ;
67289: LD_ADDR_OWVAR 37
67293: PUSH
67294: LD_VAR 0 1
67298: ST_TO_ADDR
// vc_engine := engine ;
67299: LD_ADDR_OWVAR 39
67303: PUSH
67304: LD_VAR 0 2
67308: ST_TO_ADDR
// vc_control := control ;
67309: LD_ADDR_OWVAR 38
67313: PUSH
67314: LD_VAR 0 3
67318: ST_TO_ADDR
// vc_weapon := weapon ;
67319: LD_ADDR_OWVAR 40
67323: PUSH
67324: LD_VAR 0 4
67328: ST_TO_ADDR
// vc_fuel_battery := fuel ;
67329: LD_ADDR_OWVAR 41
67333: PUSH
67334: LD_VAR 0 5
67338: ST_TO_ADDR
// end ;
67339: LD_VAR 0 6
67343: RET
// export function WantPlant ( unit ) ; var task ; begin
67344: LD_INT 0
67346: PPUSH
67347: PPUSH
// result := false ;
67348: LD_ADDR_VAR 0 2
67352: PUSH
67353: LD_INT 0
67355: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
67356: LD_ADDR_VAR 0 3
67360: PUSH
67361: LD_VAR 0 1
67365: PPUSH
67366: CALL_OW 437
67370: ST_TO_ADDR
// if task then
67371: LD_VAR 0 3
67375: IFFALSE 67403
// if task [ 1 ] [ 1 ] = p then
67377: LD_VAR 0 3
67381: PUSH
67382: LD_INT 1
67384: ARRAY
67385: PUSH
67386: LD_INT 1
67388: ARRAY
67389: PUSH
67390: LD_STRING p
67392: EQUAL
67393: IFFALSE 67403
// result := true ;
67395: LD_ADDR_VAR 0 2
67399: PUSH
67400: LD_INT 1
67402: ST_TO_ADDR
// end ;
67403: LD_VAR 0 2
67407: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
67408: LD_INT 0
67410: PPUSH
67411: PPUSH
67412: PPUSH
67413: PPUSH
// if pos < 1 then
67414: LD_VAR 0 2
67418: PUSH
67419: LD_INT 1
67421: LESS
67422: IFFALSE 67426
// exit ;
67424: GO 67729
// if pos = 1 then
67426: LD_VAR 0 2
67430: PUSH
67431: LD_INT 1
67433: EQUAL
67434: IFFALSE 67467
// result := Replace ( arr , pos [ 1 ] , value ) else
67436: LD_ADDR_VAR 0 4
67440: PUSH
67441: LD_VAR 0 1
67445: PPUSH
67446: LD_VAR 0 2
67450: PUSH
67451: LD_INT 1
67453: ARRAY
67454: PPUSH
67455: LD_VAR 0 3
67459: PPUSH
67460: CALL_OW 1
67464: ST_TO_ADDR
67465: GO 67729
// begin tmp := arr ;
67467: LD_ADDR_VAR 0 6
67471: PUSH
67472: LD_VAR 0 1
67476: ST_TO_ADDR
// s_arr := [ tmp ] ;
67477: LD_ADDR_VAR 0 7
67481: PUSH
67482: LD_VAR 0 6
67486: PUSH
67487: EMPTY
67488: LIST
67489: ST_TO_ADDR
// for i = 1 to pos - 1 do
67490: LD_ADDR_VAR 0 5
67494: PUSH
67495: DOUBLE
67496: LD_INT 1
67498: DEC
67499: ST_TO_ADDR
67500: LD_VAR 0 2
67504: PUSH
67505: LD_INT 1
67507: MINUS
67508: PUSH
67509: FOR_TO
67510: IFFALSE 67555
// begin tmp := tmp [ pos [ i ] ] ;
67512: LD_ADDR_VAR 0 6
67516: PUSH
67517: LD_VAR 0 6
67521: PUSH
67522: LD_VAR 0 2
67526: PUSH
67527: LD_VAR 0 5
67531: ARRAY
67532: ARRAY
67533: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
67534: LD_ADDR_VAR 0 7
67538: PUSH
67539: LD_VAR 0 7
67543: PUSH
67544: LD_VAR 0 6
67548: PUSH
67549: EMPTY
67550: LIST
67551: ADD
67552: ST_TO_ADDR
// end ;
67553: GO 67509
67555: POP
67556: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
67557: LD_ADDR_VAR 0 6
67561: PUSH
67562: LD_VAR 0 6
67566: PPUSH
67567: LD_VAR 0 2
67571: PUSH
67572: LD_VAR 0 2
67576: ARRAY
67577: PPUSH
67578: LD_VAR 0 3
67582: PPUSH
67583: CALL_OW 1
67587: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
67588: LD_ADDR_VAR 0 7
67592: PUSH
67593: LD_VAR 0 7
67597: PPUSH
67598: LD_VAR 0 7
67602: PPUSH
67603: LD_VAR 0 6
67607: PPUSH
67608: CALL_OW 1
67612: ST_TO_ADDR
// for i = s_arr downto 2 do
67613: LD_ADDR_VAR 0 5
67617: PUSH
67618: DOUBLE
67619: LD_VAR 0 7
67623: INC
67624: ST_TO_ADDR
67625: LD_INT 2
67627: PUSH
67628: FOR_DOWNTO
67629: IFFALSE 67713
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
67631: LD_ADDR_VAR 0 6
67635: PUSH
67636: LD_VAR 0 7
67640: PUSH
67641: LD_VAR 0 5
67645: PUSH
67646: LD_INT 1
67648: MINUS
67649: ARRAY
67650: PPUSH
67651: LD_VAR 0 2
67655: PUSH
67656: LD_VAR 0 5
67660: PUSH
67661: LD_INT 1
67663: MINUS
67664: ARRAY
67665: PPUSH
67666: LD_VAR 0 7
67670: PUSH
67671: LD_VAR 0 5
67675: ARRAY
67676: PPUSH
67677: CALL_OW 1
67681: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
67682: LD_ADDR_VAR 0 7
67686: PUSH
67687: LD_VAR 0 7
67691: PPUSH
67692: LD_VAR 0 5
67696: PUSH
67697: LD_INT 1
67699: MINUS
67700: PPUSH
67701: LD_VAR 0 6
67705: PPUSH
67706: CALL_OW 1
67710: ST_TO_ADDR
// end ;
67711: GO 67628
67713: POP
67714: POP
// result := s_arr [ 1 ] ;
67715: LD_ADDR_VAR 0 4
67719: PUSH
67720: LD_VAR 0 7
67724: PUSH
67725: LD_INT 1
67727: ARRAY
67728: ST_TO_ADDR
// end ; end ;
67729: LD_VAR 0 4
67733: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
67734: LD_INT 0
67736: PPUSH
67737: PPUSH
// if not list then
67738: LD_VAR 0 1
67742: NOT
67743: IFFALSE 67747
// exit ;
67745: GO 67838
// i := list [ pos1 ] ;
67747: LD_ADDR_VAR 0 5
67751: PUSH
67752: LD_VAR 0 1
67756: PUSH
67757: LD_VAR 0 2
67761: ARRAY
67762: ST_TO_ADDR
// if not i then
67763: LD_VAR 0 5
67767: NOT
67768: IFFALSE 67772
// exit ;
67770: GO 67838
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
67772: LD_ADDR_VAR 0 1
67776: PUSH
67777: LD_VAR 0 1
67781: PPUSH
67782: LD_VAR 0 2
67786: PPUSH
67787: LD_VAR 0 1
67791: PUSH
67792: LD_VAR 0 3
67796: ARRAY
67797: PPUSH
67798: CALL_OW 1
67802: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
67803: LD_ADDR_VAR 0 1
67807: PUSH
67808: LD_VAR 0 1
67812: PPUSH
67813: LD_VAR 0 3
67817: PPUSH
67818: LD_VAR 0 5
67822: PPUSH
67823: CALL_OW 1
67827: ST_TO_ADDR
// result := list ;
67828: LD_ADDR_VAR 0 4
67832: PUSH
67833: LD_VAR 0 1
67837: ST_TO_ADDR
// end ;
67838: LD_VAR 0 4
67842: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
67843: LD_INT 0
67845: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
67846: LD_ADDR_VAR 0 5
67850: PUSH
67851: LD_VAR 0 1
67855: PPUSH
67856: CALL_OW 250
67860: PPUSH
67861: LD_VAR 0 1
67865: PPUSH
67866: CALL_OW 251
67870: PPUSH
67871: LD_VAR 0 2
67875: PPUSH
67876: LD_VAR 0 3
67880: PPUSH
67881: LD_VAR 0 4
67885: PPUSH
67886: CALL 67896 0 5
67890: ST_TO_ADDR
// end ;
67891: LD_VAR 0 5
67895: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
67896: LD_INT 0
67898: PPUSH
67899: PPUSH
67900: PPUSH
67901: PPUSH
// if not list then
67902: LD_VAR 0 3
67906: NOT
67907: IFFALSE 67911
// exit ;
67909: GO 68299
// result := [ ] ;
67911: LD_ADDR_VAR 0 6
67915: PUSH
67916: EMPTY
67917: ST_TO_ADDR
// for i in list do
67918: LD_ADDR_VAR 0 7
67922: PUSH
67923: LD_VAR 0 3
67927: PUSH
67928: FOR_IN
67929: IFFALSE 68131
// begin tmp := GetDistUnitXY ( i , x , y ) ;
67931: LD_ADDR_VAR 0 9
67935: PUSH
67936: LD_VAR 0 7
67940: PPUSH
67941: LD_VAR 0 1
67945: PPUSH
67946: LD_VAR 0 2
67950: PPUSH
67951: CALL_OW 297
67955: ST_TO_ADDR
// if not result then
67956: LD_VAR 0 6
67960: NOT
67961: IFFALSE 67987
// result := [ [ i , tmp ] ] else
67963: LD_ADDR_VAR 0 6
67967: PUSH
67968: LD_VAR 0 7
67972: PUSH
67973: LD_VAR 0 9
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: EMPTY
67983: LIST
67984: ST_TO_ADDR
67985: GO 68129
// begin if result [ result ] [ 2 ] < tmp then
67987: LD_VAR 0 6
67991: PUSH
67992: LD_VAR 0 6
67996: ARRAY
67997: PUSH
67998: LD_INT 2
68000: ARRAY
68001: PUSH
68002: LD_VAR 0 9
68006: LESS
68007: IFFALSE 68049
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
68009: LD_ADDR_VAR 0 6
68013: PUSH
68014: LD_VAR 0 6
68018: PPUSH
68019: LD_VAR 0 6
68023: PUSH
68024: LD_INT 1
68026: PLUS
68027: PPUSH
68028: LD_VAR 0 7
68032: PUSH
68033: LD_VAR 0 9
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PPUSH
68042: CALL_OW 2
68046: ST_TO_ADDR
68047: GO 68129
// for j = 1 to result do
68049: LD_ADDR_VAR 0 8
68053: PUSH
68054: DOUBLE
68055: LD_INT 1
68057: DEC
68058: ST_TO_ADDR
68059: LD_VAR 0 6
68063: PUSH
68064: FOR_TO
68065: IFFALSE 68127
// begin if tmp < result [ j ] [ 2 ] then
68067: LD_VAR 0 9
68071: PUSH
68072: LD_VAR 0 6
68076: PUSH
68077: LD_VAR 0 8
68081: ARRAY
68082: PUSH
68083: LD_INT 2
68085: ARRAY
68086: LESS
68087: IFFALSE 68125
// begin result := Insert ( result , j , [ i , tmp ] ) ;
68089: LD_ADDR_VAR 0 6
68093: PUSH
68094: LD_VAR 0 6
68098: PPUSH
68099: LD_VAR 0 8
68103: PPUSH
68104: LD_VAR 0 7
68108: PUSH
68109: LD_VAR 0 9
68113: PUSH
68114: EMPTY
68115: LIST
68116: LIST
68117: PPUSH
68118: CALL_OW 2
68122: ST_TO_ADDR
// break ;
68123: GO 68127
// end ; end ;
68125: GO 68064
68127: POP
68128: POP
// end ; end ;
68129: GO 67928
68131: POP
68132: POP
// if result and not asc then
68133: LD_VAR 0 6
68137: PUSH
68138: LD_VAR 0 4
68142: NOT
68143: AND
68144: IFFALSE 68219
// begin tmp := result ;
68146: LD_ADDR_VAR 0 9
68150: PUSH
68151: LD_VAR 0 6
68155: ST_TO_ADDR
// for i = tmp downto 1 do
68156: LD_ADDR_VAR 0 7
68160: PUSH
68161: DOUBLE
68162: LD_VAR 0 9
68166: INC
68167: ST_TO_ADDR
68168: LD_INT 1
68170: PUSH
68171: FOR_DOWNTO
68172: IFFALSE 68217
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
68174: LD_ADDR_VAR 0 6
68178: PUSH
68179: LD_VAR 0 6
68183: PPUSH
68184: LD_VAR 0 9
68188: PUSH
68189: LD_VAR 0 7
68193: MINUS
68194: PUSH
68195: LD_INT 1
68197: PLUS
68198: PPUSH
68199: LD_VAR 0 9
68203: PUSH
68204: LD_VAR 0 7
68208: ARRAY
68209: PPUSH
68210: CALL_OW 1
68214: ST_TO_ADDR
68215: GO 68171
68217: POP
68218: POP
// end ; tmp := [ ] ;
68219: LD_ADDR_VAR 0 9
68223: PUSH
68224: EMPTY
68225: ST_TO_ADDR
// if mode then
68226: LD_VAR 0 5
68230: IFFALSE 68299
// begin for i = 1 to result do
68232: LD_ADDR_VAR 0 7
68236: PUSH
68237: DOUBLE
68238: LD_INT 1
68240: DEC
68241: ST_TO_ADDR
68242: LD_VAR 0 6
68246: PUSH
68247: FOR_TO
68248: IFFALSE 68287
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
68250: LD_ADDR_VAR 0 9
68254: PUSH
68255: LD_VAR 0 9
68259: PPUSH
68260: LD_VAR 0 7
68264: PPUSH
68265: LD_VAR 0 6
68269: PUSH
68270: LD_VAR 0 7
68274: ARRAY
68275: PUSH
68276: LD_INT 1
68278: ARRAY
68279: PPUSH
68280: CALL_OW 1
68284: ST_TO_ADDR
68285: GO 68247
68287: POP
68288: POP
// result := tmp ;
68289: LD_ADDR_VAR 0 6
68293: PUSH
68294: LD_VAR 0 9
68298: ST_TO_ADDR
// end ; end ;
68299: LD_VAR 0 6
68303: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
68304: LD_INT 0
68306: PPUSH
68307: PPUSH
68308: PPUSH
68309: PPUSH
68310: PPUSH
68311: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
68312: LD_ADDR_VAR 0 5
68316: PUSH
68317: LD_INT 0
68319: PUSH
68320: LD_INT 0
68322: PUSH
68323: LD_INT 0
68325: PUSH
68326: EMPTY
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: ST_TO_ADDR
// if not x or not y then
68334: LD_VAR 0 2
68338: NOT
68339: PUSH
68340: LD_VAR 0 3
68344: NOT
68345: OR
68346: IFFALSE 68350
// exit ;
68348: GO 70002
// if not range then
68350: LD_VAR 0 4
68354: NOT
68355: IFFALSE 68365
// range := 10 ;
68357: LD_ADDR_VAR 0 4
68361: PUSH
68362: LD_INT 10
68364: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68365: LD_ADDR_VAR 0 8
68369: PUSH
68370: LD_INT 81
68372: PUSH
68373: LD_VAR 0 1
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 92
68384: PUSH
68385: LD_VAR 0 2
68389: PUSH
68390: LD_VAR 0 3
68394: PUSH
68395: LD_VAR 0 4
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: PUSH
68406: LD_INT 3
68408: PUSH
68409: LD_INT 21
68411: PUSH
68412: LD_INT 3
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: LIST
68427: PPUSH
68428: CALL_OW 69
68432: ST_TO_ADDR
// if not tmp then
68433: LD_VAR 0 8
68437: NOT
68438: IFFALSE 68442
// exit ;
68440: GO 70002
// for i in tmp do
68442: LD_ADDR_VAR 0 6
68446: PUSH
68447: LD_VAR 0 8
68451: PUSH
68452: FOR_IN
68453: IFFALSE 69977
// begin points := [ 0 , 0 , 0 ] ;
68455: LD_ADDR_VAR 0 9
68459: PUSH
68460: LD_INT 0
68462: PUSH
68463: LD_INT 0
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: LIST
68473: ST_TO_ADDR
// bpoints := 1 ;
68474: LD_ADDR_VAR 0 10
68478: PUSH
68479: LD_INT 1
68481: ST_TO_ADDR
// case GetType ( i ) of unit_human :
68482: LD_VAR 0 6
68486: PPUSH
68487: CALL_OW 247
68491: PUSH
68492: LD_INT 1
68494: DOUBLE
68495: EQUAL
68496: IFTRUE 68500
68498: GO 69078
68500: POP
// begin if GetClass ( i ) = 1 then
68501: LD_VAR 0 6
68505: PPUSH
68506: CALL_OW 257
68510: PUSH
68511: LD_INT 1
68513: EQUAL
68514: IFFALSE 68535
// points := [ 10 , 5 , 3 ] ;
68516: LD_ADDR_VAR 0 9
68520: PUSH
68521: LD_INT 10
68523: PUSH
68524: LD_INT 5
68526: PUSH
68527: LD_INT 3
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: LIST
68534: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
68535: LD_VAR 0 6
68539: PPUSH
68540: CALL_OW 257
68544: PUSH
68545: LD_INT 2
68547: PUSH
68548: LD_INT 3
68550: PUSH
68551: LD_INT 4
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: LIST
68558: IN
68559: IFFALSE 68580
// points := [ 3 , 2 , 1 ] ;
68561: LD_ADDR_VAR 0 9
68565: PUSH
68566: LD_INT 3
68568: PUSH
68569: LD_INT 2
68571: PUSH
68572: LD_INT 1
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: LIST
68579: ST_TO_ADDR
// if GetClass ( i ) = 5 then
68580: LD_VAR 0 6
68584: PPUSH
68585: CALL_OW 257
68589: PUSH
68590: LD_INT 5
68592: EQUAL
68593: IFFALSE 68614
// points := [ 130 , 5 , 2 ] ;
68595: LD_ADDR_VAR 0 9
68599: PUSH
68600: LD_INT 130
68602: PUSH
68603: LD_INT 5
68605: PUSH
68606: LD_INT 2
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: LIST
68613: ST_TO_ADDR
// if GetClass ( i ) = 8 then
68614: LD_VAR 0 6
68618: PPUSH
68619: CALL_OW 257
68623: PUSH
68624: LD_INT 8
68626: EQUAL
68627: IFFALSE 68648
// points := [ 35 , 35 , 30 ] ;
68629: LD_ADDR_VAR 0 9
68633: PUSH
68634: LD_INT 35
68636: PUSH
68637: LD_INT 35
68639: PUSH
68640: LD_INT 30
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: LIST
68647: ST_TO_ADDR
// if GetClass ( i ) = 9 then
68648: LD_VAR 0 6
68652: PPUSH
68653: CALL_OW 257
68657: PUSH
68658: LD_INT 9
68660: EQUAL
68661: IFFALSE 68682
// points := [ 20 , 55 , 40 ] ;
68663: LD_ADDR_VAR 0 9
68667: PUSH
68668: LD_INT 20
68670: PUSH
68671: LD_INT 55
68673: PUSH
68674: LD_INT 40
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: LIST
68681: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
68682: LD_VAR 0 6
68686: PPUSH
68687: CALL_OW 257
68691: PUSH
68692: LD_INT 12
68694: PUSH
68695: LD_INT 16
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: IN
68702: IFFALSE 68723
// points := [ 5 , 3 , 2 ] ;
68704: LD_ADDR_VAR 0 9
68708: PUSH
68709: LD_INT 5
68711: PUSH
68712: LD_INT 3
68714: PUSH
68715: LD_INT 2
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: LIST
68722: ST_TO_ADDR
// if GetClass ( i ) = 17 then
68723: LD_VAR 0 6
68727: PPUSH
68728: CALL_OW 257
68732: PUSH
68733: LD_INT 17
68735: EQUAL
68736: IFFALSE 68757
// points := [ 100 , 50 , 75 ] ;
68738: LD_ADDR_VAR 0 9
68742: PUSH
68743: LD_INT 100
68745: PUSH
68746: LD_INT 50
68748: PUSH
68749: LD_INT 75
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: LIST
68756: ST_TO_ADDR
// if GetClass ( i ) = 15 then
68757: LD_VAR 0 6
68761: PPUSH
68762: CALL_OW 257
68766: PUSH
68767: LD_INT 15
68769: EQUAL
68770: IFFALSE 68791
// points := [ 10 , 5 , 3 ] ;
68772: LD_ADDR_VAR 0 9
68776: PUSH
68777: LD_INT 10
68779: PUSH
68780: LD_INT 5
68782: PUSH
68783: LD_INT 3
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: LIST
68790: ST_TO_ADDR
// if GetClass ( i ) = 14 then
68791: LD_VAR 0 6
68795: PPUSH
68796: CALL_OW 257
68800: PUSH
68801: LD_INT 14
68803: EQUAL
68804: IFFALSE 68825
// points := [ 10 , 0 , 0 ] ;
68806: LD_ADDR_VAR 0 9
68810: PUSH
68811: LD_INT 10
68813: PUSH
68814: LD_INT 0
68816: PUSH
68817: LD_INT 0
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: LIST
68824: ST_TO_ADDR
// if GetClass ( i ) = 11 then
68825: LD_VAR 0 6
68829: PPUSH
68830: CALL_OW 257
68834: PUSH
68835: LD_INT 11
68837: EQUAL
68838: IFFALSE 68859
// points := [ 30 , 10 , 5 ] ;
68840: LD_ADDR_VAR 0 9
68844: PUSH
68845: LD_INT 30
68847: PUSH
68848: LD_INT 10
68850: PUSH
68851: LD_INT 5
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: LIST
68858: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
68859: LD_VAR 0 1
68863: PPUSH
68864: LD_INT 5
68866: PPUSH
68867: CALL_OW 321
68871: PUSH
68872: LD_INT 2
68874: EQUAL
68875: IFFALSE 68892
// bpoints := bpoints * 1.8 ;
68877: LD_ADDR_VAR 0 10
68881: PUSH
68882: LD_VAR 0 10
68886: PUSH
68887: LD_REAL  1.80000000000000E+0000
68890: MUL
68891: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
68892: LD_VAR 0 6
68896: PPUSH
68897: CALL_OW 257
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: LD_INT 2
68907: PUSH
68908: LD_INT 3
68910: PUSH
68911: LD_INT 4
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: IN
68920: PUSH
68921: LD_VAR 0 1
68925: PPUSH
68926: LD_INT 51
68928: PPUSH
68929: CALL_OW 321
68933: PUSH
68934: LD_INT 2
68936: EQUAL
68937: AND
68938: IFFALSE 68955
// bpoints := bpoints * 1.2 ;
68940: LD_ADDR_VAR 0 10
68944: PUSH
68945: LD_VAR 0 10
68949: PUSH
68950: LD_REAL  1.20000000000000E+0000
68953: MUL
68954: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
68955: LD_VAR 0 6
68959: PPUSH
68960: CALL_OW 257
68964: PUSH
68965: LD_INT 5
68967: PUSH
68968: LD_INT 7
68970: PUSH
68971: LD_INT 9
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: LIST
68978: IN
68979: PUSH
68980: LD_VAR 0 1
68984: PPUSH
68985: LD_INT 52
68987: PPUSH
68988: CALL_OW 321
68992: PUSH
68993: LD_INT 2
68995: EQUAL
68996: AND
68997: IFFALSE 69014
// bpoints := bpoints * 1.5 ;
68999: LD_ADDR_VAR 0 10
69003: PUSH
69004: LD_VAR 0 10
69008: PUSH
69009: LD_REAL  1.50000000000000E+0000
69012: MUL
69013: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
69014: LD_VAR 0 1
69018: PPUSH
69019: LD_INT 66
69021: PPUSH
69022: CALL_OW 321
69026: PUSH
69027: LD_INT 2
69029: EQUAL
69030: IFFALSE 69047
// bpoints := bpoints * 1.1 ;
69032: LD_ADDR_VAR 0 10
69036: PUSH
69037: LD_VAR 0 10
69041: PUSH
69042: LD_REAL  1.10000000000000E+0000
69045: MUL
69046: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69047: LD_ADDR_VAR 0 10
69051: PUSH
69052: LD_VAR 0 10
69056: PUSH
69057: LD_VAR 0 6
69061: PPUSH
69062: LD_INT 1
69064: PPUSH
69065: CALL_OW 259
69069: PUSH
69070: LD_REAL  1.15000000000000E+0000
69073: MUL
69074: MUL
69075: ST_TO_ADDR
// end ; unit_vehicle :
69076: GO 69906
69078: LD_INT 2
69080: DOUBLE
69081: EQUAL
69082: IFTRUE 69086
69084: GO 69894
69086: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
69087: LD_VAR 0 6
69091: PPUSH
69092: CALL_OW 264
69096: PUSH
69097: LD_INT 2
69099: PUSH
69100: LD_INT 42
69102: PUSH
69103: LD_INT 24
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: LIST
69110: IN
69111: IFFALSE 69132
// points := [ 25 , 5 , 3 ] ;
69113: LD_ADDR_VAR 0 9
69117: PUSH
69118: LD_INT 25
69120: PUSH
69121: LD_INT 5
69123: PUSH
69124: LD_INT 3
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: LIST
69131: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
69132: LD_VAR 0 6
69136: PPUSH
69137: CALL_OW 264
69141: PUSH
69142: LD_INT 4
69144: PUSH
69145: LD_INT 43
69147: PUSH
69148: LD_INT 25
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: LIST
69155: IN
69156: IFFALSE 69177
// points := [ 40 , 15 , 5 ] ;
69158: LD_ADDR_VAR 0 9
69162: PUSH
69163: LD_INT 40
69165: PUSH
69166: LD_INT 15
69168: PUSH
69169: LD_INT 5
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: LIST
69176: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
69177: LD_VAR 0 6
69181: PPUSH
69182: CALL_OW 264
69186: PUSH
69187: LD_INT 3
69189: PUSH
69190: LD_INT 23
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: IN
69197: IFFALSE 69218
// points := [ 7 , 25 , 8 ] ;
69199: LD_ADDR_VAR 0 9
69203: PUSH
69204: LD_INT 7
69206: PUSH
69207: LD_INT 25
69209: PUSH
69210: LD_INT 8
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: LIST
69217: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
69218: LD_VAR 0 6
69222: PPUSH
69223: CALL_OW 264
69227: PUSH
69228: LD_INT 5
69230: PUSH
69231: LD_INT 27
69233: PUSH
69234: LD_INT 44
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: LIST
69241: IN
69242: IFFALSE 69263
// points := [ 14 , 50 , 16 ] ;
69244: LD_ADDR_VAR 0 9
69248: PUSH
69249: LD_INT 14
69251: PUSH
69252: LD_INT 50
69254: PUSH
69255: LD_INT 16
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: LIST
69262: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
69263: LD_VAR 0 6
69267: PPUSH
69268: CALL_OW 264
69272: PUSH
69273: LD_INT 6
69275: PUSH
69276: LD_INT 46
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: IN
69283: IFFALSE 69304
// points := [ 32 , 120 , 70 ] ;
69285: LD_ADDR_VAR 0 9
69289: PUSH
69290: LD_INT 32
69292: PUSH
69293: LD_INT 120
69295: PUSH
69296: LD_INT 70
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: LIST
69303: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
69304: LD_VAR 0 6
69308: PPUSH
69309: CALL_OW 264
69313: PUSH
69314: LD_INT 7
69316: PUSH
69317: LD_INT 28
69319: PUSH
69320: LD_INT 45
69322: PUSH
69323: LD_EXP 78
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: IN
69334: IFFALSE 69355
// points := [ 35 , 20 , 45 ] ;
69336: LD_ADDR_VAR 0 9
69340: PUSH
69341: LD_INT 35
69343: PUSH
69344: LD_INT 20
69346: PUSH
69347: LD_INT 45
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: LIST
69354: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
69355: LD_VAR 0 6
69359: PPUSH
69360: CALL_OW 264
69364: PUSH
69365: LD_INT 47
69367: PUSH
69368: EMPTY
69369: LIST
69370: IN
69371: IFFALSE 69392
// points := [ 67 , 45 , 75 ] ;
69373: LD_ADDR_VAR 0 9
69377: PUSH
69378: LD_INT 67
69380: PUSH
69381: LD_INT 45
69383: PUSH
69384: LD_INT 75
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: LIST
69391: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
69392: LD_VAR 0 6
69396: PPUSH
69397: CALL_OW 264
69401: PUSH
69402: LD_INT 26
69404: PUSH
69405: EMPTY
69406: LIST
69407: IN
69408: IFFALSE 69429
// points := [ 120 , 30 , 80 ] ;
69410: LD_ADDR_VAR 0 9
69414: PUSH
69415: LD_INT 120
69417: PUSH
69418: LD_INT 30
69420: PUSH
69421: LD_INT 80
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: LIST
69428: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
69429: LD_VAR 0 6
69433: PPUSH
69434: CALL_OW 264
69438: PUSH
69439: LD_INT 22
69441: PUSH
69442: EMPTY
69443: LIST
69444: IN
69445: IFFALSE 69466
// points := [ 40 , 1 , 1 ] ;
69447: LD_ADDR_VAR 0 9
69451: PUSH
69452: LD_INT 40
69454: PUSH
69455: LD_INT 1
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: LIST
69465: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
69466: LD_VAR 0 6
69470: PPUSH
69471: CALL_OW 264
69475: PUSH
69476: LD_INT 29
69478: PUSH
69479: EMPTY
69480: LIST
69481: IN
69482: IFFALSE 69503
// points := [ 70 , 200 , 400 ] ;
69484: LD_ADDR_VAR 0 9
69488: PUSH
69489: LD_INT 70
69491: PUSH
69492: LD_INT 200
69494: PUSH
69495: LD_INT 400
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: LIST
69502: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
69503: LD_VAR 0 6
69507: PPUSH
69508: CALL_OW 264
69512: PUSH
69513: LD_INT 14
69515: PUSH
69516: LD_INT 53
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: IN
69523: IFFALSE 69544
// points := [ 40 , 10 , 20 ] ;
69525: LD_ADDR_VAR 0 9
69529: PUSH
69530: LD_INT 40
69532: PUSH
69533: LD_INT 10
69535: PUSH
69536: LD_INT 20
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: LIST
69543: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
69544: LD_VAR 0 6
69548: PPUSH
69549: CALL_OW 264
69553: PUSH
69554: LD_INT 9
69556: PUSH
69557: EMPTY
69558: LIST
69559: IN
69560: IFFALSE 69581
// points := [ 5 , 70 , 20 ] ;
69562: LD_ADDR_VAR 0 9
69566: PUSH
69567: LD_INT 5
69569: PUSH
69570: LD_INT 70
69572: PUSH
69573: LD_INT 20
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: LIST
69580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
69581: LD_VAR 0 6
69585: PPUSH
69586: CALL_OW 264
69590: PUSH
69591: LD_INT 10
69593: PUSH
69594: EMPTY
69595: LIST
69596: IN
69597: IFFALSE 69618
// points := [ 35 , 110 , 70 ] ;
69599: LD_ADDR_VAR 0 9
69603: PUSH
69604: LD_INT 35
69606: PUSH
69607: LD_INT 110
69609: PUSH
69610: LD_INT 70
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: LIST
69617: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
69618: LD_VAR 0 6
69622: PPUSH
69623: CALL_OW 265
69627: PUSH
69628: LD_INT 25
69630: EQUAL
69631: IFFALSE 69652
// points := [ 80 , 65 , 100 ] ;
69633: LD_ADDR_VAR 0 9
69637: PUSH
69638: LD_INT 80
69640: PUSH
69641: LD_INT 65
69643: PUSH
69644: LD_INT 100
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: LIST
69651: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
69652: LD_VAR 0 6
69656: PPUSH
69657: CALL_OW 263
69661: PUSH
69662: LD_INT 1
69664: EQUAL
69665: IFFALSE 69700
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
69667: LD_ADDR_VAR 0 10
69671: PUSH
69672: LD_VAR 0 10
69676: PUSH
69677: LD_VAR 0 6
69681: PPUSH
69682: CALL_OW 311
69686: PPUSH
69687: LD_INT 3
69689: PPUSH
69690: CALL_OW 259
69694: PUSH
69695: LD_INT 4
69697: MUL
69698: MUL
69699: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
69700: LD_VAR 0 6
69704: PPUSH
69705: CALL_OW 263
69709: PUSH
69710: LD_INT 2
69712: EQUAL
69713: IFFALSE 69764
// begin j := IsControledBy ( i ) ;
69715: LD_ADDR_VAR 0 7
69719: PUSH
69720: LD_VAR 0 6
69724: PPUSH
69725: CALL_OW 312
69729: ST_TO_ADDR
// if j then
69730: LD_VAR 0 7
69734: IFFALSE 69764
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
69736: LD_ADDR_VAR 0 10
69740: PUSH
69741: LD_VAR 0 10
69745: PUSH
69746: LD_VAR 0 7
69750: PPUSH
69751: LD_INT 3
69753: PPUSH
69754: CALL_OW 259
69758: PUSH
69759: LD_INT 3
69761: MUL
69762: MUL
69763: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
69764: LD_VAR 0 6
69768: PPUSH
69769: CALL_OW 264
69773: PUSH
69774: LD_INT 5
69776: PUSH
69777: LD_INT 6
69779: PUSH
69780: LD_INT 46
69782: PUSH
69783: LD_INT 44
69785: PUSH
69786: LD_INT 47
69788: PUSH
69789: LD_INT 45
69791: PUSH
69792: LD_INT 28
69794: PUSH
69795: LD_INT 7
69797: PUSH
69798: LD_INT 27
69800: PUSH
69801: LD_INT 29
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: LIST
69808: LIST
69809: LIST
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: IN
69816: PUSH
69817: LD_VAR 0 1
69821: PPUSH
69822: LD_INT 52
69824: PPUSH
69825: CALL_OW 321
69829: PUSH
69830: LD_INT 2
69832: EQUAL
69833: AND
69834: IFFALSE 69851
// bpoints := bpoints * 1.2 ;
69836: LD_ADDR_VAR 0 10
69840: PUSH
69841: LD_VAR 0 10
69845: PUSH
69846: LD_REAL  1.20000000000000E+0000
69849: MUL
69850: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
69851: LD_VAR 0 6
69855: PPUSH
69856: CALL_OW 264
69860: PUSH
69861: LD_INT 6
69863: PUSH
69864: LD_INT 46
69866: PUSH
69867: LD_INT 47
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: LIST
69874: IN
69875: IFFALSE 69892
// bpoints := bpoints * 1.2 ;
69877: LD_ADDR_VAR 0 10
69881: PUSH
69882: LD_VAR 0 10
69886: PUSH
69887: LD_REAL  1.20000000000000E+0000
69890: MUL
69891: ST_TO_ADDR
// end ; unit_building :
69892: GO 69906
69894: LD_INT 3
69896: DOUBLE
69897: EQUAL
69898: IFTRUE 69902
69900: GO 69905
69902: POP
// ; end ;
69903: GO 69906
69905: POP
// for j = 1 to 3 do
69906: LD_ADDR_VAR 0 7
69910: PUSH
69911: DOUBLE
69912: LD_INT 1
69914: DEC
69915: ST_TO_ADDR
69916: LD_INT 3
69918: PUSH
69919: FOR_TO
69920: IFFALSE 69973
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
69922: LD_ADDR_VAR 0 5
69926: PUSH
69927: LD_VAR 0 5
69931: PPUSH
69932: LD_VAR 0 7
69936: PPUSH
69937: LD_VAR 0 5
69941: PUSH
69942: LD_VAR 0 7
69946: ARRAY
69947: PUSH
69948: LD_VAR 0 9
69952: PUSH
69953: LD_VAR 0 7
69957: ARRAY
69958: PUSH
69959: LD_VAR 0 10
69963: MUL
69964: PLUS
69965: PPUSH
69966: CALL_OW 1
69970: ST_TO_ADDR
69971: GO 69919
69973: POP
69974: POP
// end ;
69975: GO 68452
69977: POP
69978: POP
// result := Replace ( result , 4 , tmp ) ;
69979: LD_ADDR_VAR 0 5
69983: PUSH
69984: LD_VAR 0 5
69988: PPUSH
69989: LD_INT 4
69991: PPUSH
69992: LD_VAR 0 8
69996: PPUSH
69997: CALL_OW 1
70001: ST_TO_ADDR
// end ;
70002: LD_VAR 0 5
70006: RET
// export function DangerAtRange ( unit , range ) ; begin
70007: LD_INT 0
70009: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
70010: LD_ADDR_VAR 0 3
70014: PUSH
70015: LD_VAR 0 1
70019: PPUSH
70020: CALL_OW 255
70024: PPUSH
70025: LD_VAR 0 1
70029: PPUSH
70030: CALL_OW 250
70034: PPUSH
70035: LD_VAR 0 1
70039: PPUSH
70040: CALL_OW 251
70044: PPUSH
70045: LD_VAR 0 2
70049: PPUSH
70050: CALL 68304 0 4
70054: ST_TO_ADDR
// end ;
70055: LD_VAR 0 3
70059: RET
// export function DangerInArea ( side , area ) ; begin
70060: LD_INT 0
70062: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
70063: LD_ADDR_VAR 0 3
70067: PUSH
70068: LD_VAR 0 2
70072: PPUSH
70073: LD_INT 81
70075: PUSH
70076: LD_VAR 0 1
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PPUSH
70085: CALL_OW 70
70089: ST_TO_ADDR
// end ;
70090: LD_VAR 0 3
70094: RET
// export function IsExtension ( b ) ; begin
70095: LD_INT 0
70097: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
70098: LD_ADDR_VAR 0 2
70102: PUSH
70103: LD_VAR 0 1
70107: PUSH
70108: LD_INT 23
70110: PUSH
70111: LD_INT 20
70113: PUSH
70114: LD_INT 22
70116: PUSH
70117: LD_INT 17
70119: PUSH
70120: LD_INT 24
70122: PUSH
70123: LD_INT 21
70125: PUSH
70126: LD_INT 19
70128: PUSH
70129: LD_INT 16
70131: PUSH
70132: LD_INT 25
70134: PUSH
70135: LD_INT 18
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: IN
70150: ST_TO_ADDR
// end ;
70151: LD_VAR 0 2
70155: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
70156: LD_INT 0
70158: PPUSH
70159: PPUSH
70160: PPUSH
// result := [ ] ;
70161: LD_ADDR_VAR 0 4
70165: PUSH
70166: EMPTY
70167: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
70168: LD_ADDR_VAR 0 5
70172: PUSH
70173: LD_VAR 0 2
70177: PPUSH
70178: LD_INT 21
70180: PUSH
70181: LD_INT 3
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PPUSH
70188: CALL_OW 70
70192: ST_TO_ADDR
// if not tmp then
70193: LD_VAR 0 5
70197: NOT
70198: IFFALSE 70202
// exit ;
70200: GO 70266
// if checkLink then
70202: LD_VAR 0 3
70206: IFFALSE 70256
// begin for i in tmp do
70208: LD_ADDR_VAR 0 6
70212: PUSH
70213: LD_VAR 0 5
70217: PUSH
70218: FOR_IN
70219: IFFALSE 70254
// if GetBase ( i ) <> base then
70221: LD_VAR 0 6
70225: PPUSH
70226: CALL_OW 274
70230: PUSH
70231: LD_VAR 0 1
70235: NONEQUAL
70236: IFFALSE 70252
// ComLinkToBase ( base , i ) ;
70238: LD_VAR 0 1
70242: PPUSH
70243: LD_VAR 0 6
70247: PPUSH
70248: CALL_OW 169
70252: GO 70218
70254: POP
70255: POP
// end ; result := tmp ;
70256: LD_ADDR_VAR 0 4
70260: PUSH
70261: LD_VAR 0 5
70265: ST_TO_ADDR
// end ;
70266: LD_VAR 0 4
70270: RET
// export function ComComplete ( units , b ) ; var i ; begin
70271: LD_INT 0
70273: PPUSH
70274: PPUSH
// if not units then
70275: LD_VAR 0 1
70279: NOT
70280: IFFALSE 70284
// exit ;
70282: GO 70374
// for i in units do
70284: LD_ADDR_VAR 0 4
70288: PUSH
70289: LD_VAR 0 1
70293: PUSH
70294: FOR_IN
70295: IFFALSE 70372
// if BuildingStatus ( b ) = bs_build then
70297: LD_VAR 0 2
70301: PPUSH
70302: CALL_OW 461
70306: PUSH
70307: LD_INT 1
70309: EQUAL
70310: IFFALSE 70370
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
70312: LD_VAR 0 4
70316: PPUSH
70317: LD_STRING h
70319: PUSH
70320: LD_VAR 0 2
70324: PPUSH
70325: CALL_OW 250
70329: PUSH
70330: LD_VAR 0 2
70334: PPUSH
70335: CALL_OW 251
70339: PUSH
70340: LD_VAR 0 2
70344: PUSH
70345: LD_INT 0
70347: PUSH
70348: LD_INT 0
70350: PUSH
70351: LD_INT 0
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: PUSH
70363: EMPTY
70364: LIST
70365: PPUSH
70366: CALL_OW 446
70370: GO 70294
70372: POP
70373: POP
// end ;
70374: LD_VAR 0 3
70378: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
70379: LD_INT 0
70381: PPUSH
70382: PPUSH
70383: PPUSH
70384: PPUSH
70385: PPUSH
70386: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
70387: LD_VAR 0 1
70391: NOT
70392: PUSH
70393: LD_VAR 0 1
70397: PPUSH
70398: CALL_OW 263
70402: PUSH
70403: LD_INT 2
70405: NONEQUAL
70406: OR
70407: IFFALSE 70411
// exit ;
70409: GO 70727
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
70411: LD_ADDR_VAR 0 6
70415: PUSH
70416: LD_INT 22
70418: PUSH
70419: LD_VAR 0 1
70423: PPUSH
70424: CALL_OW 255
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 2
70435: PUSH
70436: LD_INT 30
70438: PUSH
70439: LD_INT 36
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 34
70448: PUSH
70449: LD_INT 31
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: LIST
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PPUSH
70465: CALL_OW 69
70469: ST_TO_ADDR
// if not tmp then
70470: LD_VAR 0 6
70474: NOT
70475: IFFALSE 70479
// exit ;
70477: GO 70727
// result := [ ] ;
70479: LD_ADDR_VAR 0 2
70483: PUSH
70484: EMPTY
70485: ST_TO_ADDR
// for i in tmp do
70486: LD_ADDR_VAR 0 3
70490: PUSH
70491: LD_VAR 0 6
70495: PUSH
70496: FOR_IN
70497: IFFALSE 70568
// begin t := UnitsInside ( i ) ;
70499: LD_ADDR_VAR 0 4
70503: PUSH
70504: LD_VAR 0 3
70508: PPUSH
70509: CALL_OW 313
70513: ST_TO_ADDR
// if t then
70514: LD_VAR 0 4
70518: IFFALSE 70566
// for j in t do
70520: LD_ADDR_VAR 0 7
70524: PUSH
70525: LD_VAR 0 4
70529: PUSH
70530: FOR_IN
70531: IFFALSE 70564
// result := Replace ( result , result + 1 , j ) ;
70533: LD_ADDR_VAR 0 2
70537: PUSH
70538: LD_VAR 0 2
70542: PPUSH
70543: LD_VAR 0 2
70547: PUSH
70548: LD_INT 1
70550: PLUS
70551: PPUSH
70552: LD_VAR 0 7
70556: PPUSH
70557: CALL_OW 1
70561: ST_TO_ADDR
70562: GO 70530
70564: POP
70565: POP
// end ;
70566: GO 70496
70568: POP
70569: POP
// if not result then
70570: LD_VAR 0 2
70574: NOT
70575: IFFALSE 70579
// exit ;
70577: GO 70727
// mech := result [ 1 ] ;
70579: LD_ADDR_VAR 0 5
70583: PUSH
70584: LD_VAR 0 2
70588: PUSH
70589: LD_INT 1
70591: ARRAY
70592: ST_TO_ADDR
// if result > 1 then
70593: LD_VAR 0 2
70597: PUSH
70598: LD_INT 1
70600: GREATER
70601: IFFALSE 70713
// begin for i = 2 to result do
70603: LD_ADDR_VAR 0 3
70607: PUSH
70608: DOUBLE
70609: LD_INT 2
70611: DEC
70612: ST_TO_ADDR
70613: LD_VAR 0 2
70617: PUSH
70618: FOR_TO
70619: IFFALSE 70711
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
70621: LD_ADDR_VAR 0 4
70625: PUSH
70626: LD_VAR 0 2
70630: PUSH
70631: LD_VAR 0 3
70635: ARRAY
70636: PPUSH
70637: LD_INT 3
70639: PPUSH
70640: CALL_OW 259
70644: PUSH
70645: LD_VAR 0 2
70649: PUSH
70650: LD_VAR 0 3
70654: ARRAY
70655: PPUSH
70656: CALL_OW 432
70660: MINUS
70661: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
70662: LD_VAR 0 4
70666: PUSH
70667: LD_VAR 0 5
70671: PPUSH
70672: LD_INT 3
70674: PPUSH
70675: CALL_OW 259
70679: PUSH
70680: LD_VAR 0 5
70684: PPUSH
70685: CALL_OW 432
70689: MINUS
70690: GREATEREQUAL
70691: IFFALSE 70709
// mech := result [ i ] ;
70693: LD_ADDR_VAR 0 5
70697: PUSH
70698: LD_VAR 0 2
70702: PUSH
70703: LD_VAR 0 3
70707: ARRAY
70708: ST_TO_ADDR
// end ;
70709: GO 70618
70711: POP
70712: POP
// end ; ComLinkTo ( vehicle , mech ) ;
70713: LD_VAR 0 1
70717: PPUSH
70718: LD_VAR 0 5
70722: PPUSH
70723: CALL_OW 135
// end ;
70727: LD_VAR 0 2
70731: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
70732: LD_INT 0
70734: PPUSH
70735: PPUSH
70736: PPUSH
70737: PPUSH
70738: PPUSH
70739: PPUSH
70740: PPUSH
70741: PPUSH
70742: PPUSH
70743: PPUSH
70744: PPUSH
70745: PPUSH
70746: PPUSH
// result := [ ] ;
70747: LD_ADDR_VAR 0 7
70751: PUSH
70752: EMPTY
70753: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
70754: LD_VAR 0 1
70758: PPUSH
70759: CALL_OW 266
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: IN
70774: NOT
70775: IFFALSE 70779
// exit ;
70777: GO 72413
// if name then
70779: LD_VAR 0 3
70783: IFFALSE 70799
// SetBName ( base_dep , name ) ;
70785: LD_VAR 0 1
70789: PPUSH
70790: LD_VAR 0 3
70794: PPUSH
70795: CALL_OW 500
// base := GetBase ( base_dep ) ;
70799: LD_ADDR_VAR 0 15
70803: PUSH
70804: LD_VAR 0 1
70808: PPUSH
70809: CALL_OW 274
70813: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
70814: LD_ADDR_VAR 0 16
70818: PUSH
70819: LD_VAR 0 1
70823: PPUSH
70824: CALL_OW 255
70828: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
70829: LD_ADDR_VAR 0 17
70833: PUSH
70834: LD_VAR 0 1
70838: PPUSH
70839: CALL_OW 248
70843: ST_TO_ADDR
// if sources then
70844: LD_VAR 0 5
70848: IFFALSE 70895
// for i = 1 to 3 do
70850: LD_ADDR_VAR 0 8
70854: PUSH
70855: DOUBLE
70856: LD_INT 1
70858: DEC
70859: ST_TO_ADDR
70860: LD_INT 3
70862: PUSH
70863: FOR_TO
70864: IFFALSE 70893
// AddResourceType ( base , i , sources [ i ] ) ;
70866: LD_VAR 0 15
70870: PPUSH
70871: LD_VAR 0 8
70875: PPUSH
70876: LD_VAR 0 5
70880: PUSH
70881: LD_VAR 0 8
70885: ARRAY
70886: PPUSH
70887: CALL_OW 276
70891: GO 70863
70893: POP
70894: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
70895: LD_ADDR_VAR 0 18
70899: PUSH
70900: LD_VAR 0 15
70904: PPUSH
70905: LD_VAR 0 2
70909: PPUSH
70910: LD_INT 1
70912: PPUSH
70913: CALL 70156 0 3
70917: ST_TO_ADDR
// InitHc ;
70918: CALL_OW 19
// InitUc ;
70922: CALL_OW 18
// uc_side := side ;
70926: LD_ADDR_OWVAR 20
70930: PUSH
70931: LD_VAR 0 16
70935: ST_TO_ADDR
// uc_nation := nation ;
70936: LD_ADDR_OWVAR 21
70940: PUSH
70941: LD_VAR 0 17
70945: ST_TO_ADDR
// if buildings then
70946: LD_VAR 0 18
70950: IFFALSE 72272
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
70952: LD_ADDR_VAR 0 19
70956: PUSH
70957: LD_VAR 0 18
70961: PPUSH
70962: LD_INT 2
70964: PUSH
70965: LD_INT 30
70967: PUSH
70968: LD_INT 29
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 30
70977: PUSH
70978: LD_INT 30
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: LIST
70989: PPUSH
70990: CALL_OW 72
70994: ST_TO_ADDR
// if tmp then
70995: LD_VAR 0 19
70999: IFFALSE 71047
// for i in tmp do
71001: LD_ADDR_VAR 0 8
71005: PUSH
71006: LD_VAR 0 19
71010: PUSH
71011: FOR_IN
71012: IFFALSE 71045
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71014: LD_VAR 0 8
71018: PPUSH
71019: CALL_OW 250
71023: PPUSH
71024: LD_VAR 0 8
71028: PPUSH
71029: CALL_OW 251
71033: PPUSH
71034: LD_VAR 0 16
71038: PPUSH
71039: CALL_OW 441
71043: GO 71011
71045: POP
71046: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71047: LD_VAR 0 18
71051: PPUSH
71052: LD_INT 2
71054: PUSH
71055: LD_INT 30
71057: PUSH
71058: LD_INT 32
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 30
71067: PUSH
71068: LD_INT 33
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: LIST
71079: PPUSH
71080: CALL_OW 72
71084: IFFALSE 71172
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
71086: LD_ADDR_VAR 0 8
71090: PUSH
71091: LD_VAR 0 18
71095: PPUSH
71096: LD_INT 2
71098: PUSH
71099: LD_INT 30
71101: PUSH
71102: LD_INT 32
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 30
71111: PUSH
71112: LD_INT 33
71114: PUSH
71115: EMPTY
71116: LIST
71117: LIST
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: LIST
71123: PPUSH
71124: CALL_OW 72
71128: PUSH
71129: FOR_IN
71130: IFFALSE 71170
// begin if not GetBWeapon ( i ) then
71132: LD_VAR 0 8
71136: PPUSH
71137: CALL_OW 269
71141: NOT
71142: IFFALSE 71168
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
71144: LD_VAR 0 8
71148: PPUSH
71149: LD_VAR 0 8
71153: PPUSH
71154: LD_VAR 0 2
71158: PPUSH
71159: CALL 72418 0 2
71163: PPUSH
71164: CALL_OW 431
// end ;
71168: GO 71129
71170: POP
71171: POP
// end ; for i = 1 to personel do
71172: LD_ADDR_VAR 0 8
71176: PUSH
71177: DOUBLE
71178: LD_INT 1
71180: DEC
71181: ST_TO_ADDR
71182: LD_VAR 0 6
71186: PUSH
71187: FOR_TO
71188: IFFALSE 72252
// begin if i > 4 then
71190: LD_VAR 0 8
71194: PUSH
71195: LD_INT 4
71197: GREATER
71198: IFFALSE 71202
// break ;
71200: GO 72252
// case i of 1 :
71202: LD_VAR 0 8
71206: PUSH
71207: LD_INT 1
71209: DOUBLE
71210: EQUAL
71211: IFTRUE 71215
71213: GO 71295
71215: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
71216: LD_ADDR_VAR 0 12
71220: PUSH
71221: LD_VAR 0 18
71225: PPUSH
71226: LD_INT 22
71228: PUSH
71229: LD_VAR 0 16
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 58
71240: PUSH
71241: EMPTY
71242: LIST
71243: PUSH
71244: LD_INT 2
71246: PUSH
71247: LD_INT 30
71249: PUSH
71250: LD_INT 32
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 30
71259: PUSH
71260: LD_INT 4
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 30
71269: PUSH
71270: LD_INT 5
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: LIST
71287: PPUSH
71288: CALL_OW 72
71292: ST_TO_ADDR
71293: GO 71517
71295: LD_INT 2
71297: DOUBLE
71298: EQUAL
71299: IFTRUE 71303
71301: GO 71365
71303: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
71304: LD_ADDR_VAR 0 12
71308: PUSH
71309: LD_VAR 0 18
71313: PPUSH
71314: LD_INT 22
71316: PUSH
71317: LD_VAR 0 16
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: PUSH
71326: LD_INT 2
71328: PUSH
71329: LD_INT 30
71331: PUSH
71332: LD_INT 0
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: LD_INT 30
71341: PUSH
71342: LD_INT 1
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: LIST
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PPUSH
71358: CALL_OW 72
71362: ST_TO_ADDR
71363: GO 71517
71365: LD_INT 3
71367: DOUBLE
71368: EQUAL
71369: IFTRUE 71373
71371: GO 71435
71373: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
71374: LD_ADDR_VAR 0 12
71378: PUSH
71379: LD_VAR 0 18
71383: PPUSH
71384: LD_INT 22
71386: PUSH
71387: LD_VAR 0 16
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 2
71398: PUSH
71399: LD_INT 30
71401: PUSH
71402: LD_INT 2
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 30
71411: PUSH
71412: LD_INT 3
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PPUSH
71428: CALL_OW 72
71432: ST_TO_ADDR
71433: GO 71517
71435: LD_INT 4
71437: DOUBLE
71438: EQUAL
71439: IFTRUE 71443
71441: GO 71516
71443: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
71444: LD_ADDR_VAR 0 12
71448: PUSH
71449: LD_VAR 0 18
71453: PPUSH
71454: LD_INT 22
71456: PUSH
71457: LD_VAR 0 16
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: LD_INT 2
71468: PUSH
71469: LD_INT 30
71471: PUSH
71472: LD_INT 6
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 30
71481: PUSH
71482: LD_INT 7
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 30
71491: PUSH
71492: LD_INT 8
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PPUSH
71509: CALL_OW 72
71513: ST_TO_ADDR
71514: GO 71517
71516: POP
// if i = 1 then
71517: LD_VAR 0 8
71521: PUSH
71522: LD_INT 1
71524: EQUAL
71525: IFFALSE 71636
// begin tmp := [ ] ;
71527: LD_ADDR_VAR 0 19
71531: PUSH
71532: EMPTY
71533: ST_TO_ADDR
// for j in f do
71534: LD_ADDR_VAR 0 9
71538: PUSH
71539: LD_VAR 0 12
71543: PUSH
71544: FOR_IN
71545: IFFALSE 71618
// if GetBType ( j ) = b_bunker then
71547: LD_VAR 0 9
71551: PPUSH
71552: CALL_OW 266
71556: PUSH
71557: LD_INT 32
71559: EQUAL
71560: IFFALSE 71587
// tmp := Insert ( tmp , 1 , j ) else
71562: LD_ADDR_VAR 0 19
71566: PUSH
71567: LD_VAR 0 19
71571: PPUSH
71572: LD_INT 1
71574: PPUSH
71575: LD_VAR 0 9
71579: PPUSH
71580: CALL_OW 2
71584: ST_TO_ADDR
71585: GO 71616
// tmp := Insert ( tmp , tmp + 1 , j ) ;
71587: LD_ADDR_VAR 0 19
71591: PUSH
71592: LD_VAR 0 19
71596: PPUSH
71597: LD_VAR 0 19
71601: PUSH
71602: LD_INT 1
71604: PLUS
71605: PPUSH
71606: LD_VAR 0 9
71610: PPUSH
71611: CALL_OW 2
71615: ST_TO_ADDR
71616: GO 71544
71618: POP
71619: POP
// if tmp then
71620: LD_VAR 0 19
71624: IFFALSE 71636
// f := tmp ;
71626: LD_ADDR_VAR 0 12
71630: PUSH
71631: LD_VAR 0 19
71635: ST_TO_ADDR
// end ; x := personel [ i ] ;
71636: LD_ADDR_VAR 0 13
71640: PUSH
71641: LD_VAR 0 6
71645: PUSH
71646: LD_VAR 0 8
71650: ARRAY
71651: ST_TO_ADDR
// if x = - 1 then
71652: LD_VAR 0 13
71656: PUSH
71657: LD_INT 1
71659: NEG
71660: EQUAL
71661: IFFALSE 71870
// begin for j in f do
71663: LD_ADDR_VAR 0 9
71667: PUSH
71668: LD_VAR 0 12
71672: PUSH
71673: FOR_IN
71674: IFFALSE 71866
// repeat InitHc ;
71676: CALL_OW 19
// if GetBType ( j ) = b_barracks then
71680: LD_VAR 0 9
71684: PPUSH
71685: CALL_OW 266
71689: PUSH
71690: LD_INT 5
71692: EQUAL
71693: IFFALSE 71763
// begin if UnitsInside ( j ) < 3 then
71695: LD_VAR 0 9
71699: PPUSH
71700: CALL_OW 313
71704: PUSH
71705: LD_INT 3
71707: LESS
71708: IFFALSE 71744
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
71710: LD_INT 0
71712: PPUSH
71713: LD_INT 5
71715: PUSH
71716: LD_INT 8
71718: PUSH
71719: LD_INT 9
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: LIST
71726: PUSH
71727: LD_VAR 0 17
71731: ARRAY
71732: PPUSH
71733: LD_VAR 0 4
71737: PPUSH
71738: CALL_OW 380
71742: GO 71761
// PrepareHuman ( false , i , skill ) ;
71744: LD_INT 0
71746: PPUSH
71747: LD_VAR 0 8
71751: PPUSH
71752: LD_VAR 0 4
71756: PPUSH
71757: CALL_OW 380
// end else
71761: GO 71780
// PrepareHuman ( false , i , skill ) ;
71763: LD_INT 0
71765: PPUSH
71766: LD_VAR 0 8
71770: PPUSH
71771: LD_VAR 0 4
71775: PPUSH
71776: CALL_OW 380
// un := CreateHuman ;
71780: LD_ADDR_VAR 0 14
71784: PUSH
71785: CALL_OW 44
71789: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
71790: LD_ADDR_VAR 0 7
71794: PUSH
71795: LD_VAR 0 7
71799: PPUSH
71800: LD_INT 1
71802: PPUSH
71803: LD_VAR 0 14
71807: PPUSH
71808: CALL_OW 2
71812: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
71813: LD_VAR 0 14
71817: PPUSH
71818: LD_VAR 0 9
71822: PPUSH
71823: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
71827: LD_VAR 0 9
71831: PPUSH
71832: CALL_OW 313
71836: PUSH
71837: LD_INT 6
71839: EQUAL
71840: PUSH
71841: LD_VAR 0 9
71845: PPUSH
71846: CALL_OW 266
71850: PUSH
71851: LD_INT 32
71853: PUSH
71854: LD_INT 31
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: IN
71861: OR
71862: IFFALSE 71676
71864: GO 71673
71866: POP
71867: POP
// end else
71868: GO 72250
// for j = 1 to x do
71870: LD_ADDR_VAR 0 9
71874: PUSH
71875: DOUBLE
71876: LD_INT 1
71878: DEC
71879: ST_TO_ADDR
71880: LD_VAR 0 13
71884: PUSH
71885: FOR_TO
71886: IFFALSE 72248
// begin InitHc ;
71888: CALL_OW 19
// if not f then
71892: LD_VAR 0 12
71896: NOT
71897: IFFALSE 71986
// begin PrepareHuman ( false , i , skill ) ;
71899: LD_INT 0
71901: PPUSH
71902: LD_VAR 0 8
71906: PPUSH
71907: LD_VAR 0 4
71911: PPUSH
71912: CALL_OW 380
// un := CreateHuman ;
71916: LD_ADDR_VAR 0 14
71920: PUSH
71921: CALL_OW 44
71925: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
71926: LD_ADDR_VAR 0 7
71930: PUSH
71931: LD_VAR 0 7
71935: PPUSH
71936: LD_INT 1
71938: PPUSH
71939: LD_VAR 0 14
71943: PPUSH
71944: CALL_OW 2
71948: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
71949: LD_VAR 0 14
71953: PPUSH
71954: LD_VAR 0 1
71958: PPUSH
71959: CALL_OW 250
71963: PPUSH
71964: LD_VAR 0 1
71968: PPUSH
71969: CALL_OW 251
71973: PPUSH
71974: LD_INT 10
71976: PPUSH
71977: LD_INT 0
71979: PPUSH
71980: CALL_OW 50
// continue ;
71984: GO 71885
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
71986: LD_VAR 0 12
71990: PUSH
71991: LD_INT 1
71993: ARRAY
71994: PPUSH
71995: CALL_OW 313
71999: PUSH
72000: LD_VAR 0 12
72004: PUSH
72005: LD_INT 1
72007: ARRAY
72008: PPUSH
72009: CALL_OW 266
72013: PUSH
72014: LD_INT 32
72016: PUSH
72017: LD_INT 31
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: IN
72024: AND
72025: PUSH
72026: LD_VAR 0 12
72030: PUSH
72031: LD_INT 1
72033: ARRAY
72034: PPUSH
72035: CALL_OW 313
72039: PUSH
72040: LD_INT 6
72042: EQUAL
72043: OR
72044: IFFALSE 72064
// f := Delete ( f , 1 ) ;
72046: LD_ADDR_VAR 0 12
72050: PUSH
72051: LD_VAR 0 12
72055: PPUSH
72056: LD_INT 1
72058: PPUSH
72059: CALL_OW 3
72063: ST_TO_ADDR
// if not f then
72064: LD_VAR 0 12
72068: NOT
72069: IFFALSE 72087
// begin x := x + 2 ;
72071: LD_ADDR_VAR 0 13
72075: PUSH
72076: LD_VAR 0 13
72080: PUSH
72081: LD_INT 2
72083: PLUS
72084: ST_TO_ADDR
// continue ;
72085: GO 71885
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
72087: LD_VAR 0 12
72091: PUSH
72092: LD_INT 1
72094: ARRAY
72095: PPUSH
72096: CALL_OW 266
72100: PUSH
72101: LD_INT 5
72103: EQUAL
72104: IFFALSE 72178
// begin if UnitsInside ( f [ 1 ] ) < 3 then
72106: LD_VAR 0 12
72110: PUSH
72111: LD_INT 1
72113: ARRAY
72114: PPUSH
72115: CALL_OW 313
72119: PUSH
72120: LD_INT 3
72122: LESS
72123: IFFALSE 72159
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72125: LD_INT 0
72127: PPUSH
72128: LD_INT 5
72130: PUSH
72131: LD_INT 8
72133: PUSH
72134: LD_INT 9
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: LIST
72141: PUSH
72142: LD_VAR 0 17
72146: ARRAY
72147: PPUSH
72148: LD_VAR 0 4
72152: PPUSH
72153: CALL_OW 380
72157: GO 72176
// PrepareHuman ( false , i , skill ) ;
72159: LD_INT 0
72161: PPUSH
72162: LD_VAR 0 8
72166: PPUSH
72167: LD_VAR 0 4
72171: PPUSH
72172: CALL_OW 380
// end else
72176: GO 72195
// PrepareHuman ( false , i , skill ) ;
72178: LD_INT 0
72180: PPUSH
72181: LD_VAR 0 8
72185: PPUSH
72186: LD_VAR 0 4
72190: PPUSH
72191: CALL_OW 380
// un := CreateHuman ;
72195: LD_ADDR_VAR 0 14
72199: PUSH
72200: CALL_OW 44
72204: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72205: LD_ADDR_VAR 0 7
72209: PUSH
72210: LD_VAR 0 7
72214: PPUSH
72215: LD_INT 1
72217: PPUSH
72218: LD_VAR 0 14
72222: PPUSH
72223: CALL_OW 2
72227: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
72228: LD_VAR 0 14
72232: PPUSH
72233: LD_VAR 0 12
72237: PUSH
72238: LD_INT 1
72240: ARRAY
72241: PPUSH
72242: CALL_OW 52
// end ;
72246: GO 71885
72248: POP
72249: POP
// end ;
72250: GO 71187
72252: POP
72253: POP
// result := result ^ buildings ;
72254: LD_ADDR_VAR 0 7
72258: PUSH
72259: LD_VAR 0 7
72263: PUSH
72264: LD_VAR 0 18
72268: ADD
72269: ST_TO_ADDR
// end else
72270: GO 72413
// begin for i = 1 to personel do
72272: LD_ADDR_VAR 0 8
72276: PUSH
72277: DOUBLE
72278: LD_INT 1
72280: DEC
72281: ST_TO_ADDR
72282: LD_VAR 0 6
72286: PUSH
72287: FOR_TO
72288: IFFALSE 72411
// begin if i > 4 then
72290: LD_VAR 0 8
72294: PUSH
72295: LD_INT 4
72297: GREATER
72298: IFFALSE 72302
// break ;
72300: GO 72411
// x := personel [ i ] ;
72302: LD_ADDR_VAR 0 13
72306: PUSH
72307: LD_VAR 0 6
72311: PUSH
72312: LD_VAR 0 8
72316: ARRAY
72317: ST_TO_ADDR
// if x = - 1 then
72318: LD_VAR 0 13
72322: PUSH
72323: LD_INT 1
72325: NEG
72326: EQUAL
72327: IFFALSE 72331
// continue ;
72329: GO 72287
// PrepareHuman ( false , i , skill ) ;
72331: LD_INT 0
72333: PPUSH
72334: LD_VAR 0 8
72338: PPUSH
72339: LD_VAR 0 4
72343: PPUSH
72344: CALL_OW 380
// un := CreateHuman ;
72348: LD_ADDR_VAR 0 14
72352: PUSH
72353: CALL_OW 44
72357: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72358: LD_VAR 0 14
72362: PPUSH
72363: LD_VAR 0 1
72367: PPUSH
72368: CALL_OW 250
72372: PPUSH
72373: LD_VAR 0 1
72377: PPUSH
72378: CALL_OW 251
72382: PPUSH
72383: LD_INT 10
72385: PPUSH
72386: LD_INT 0
72388: PPUSH
72389: CALL_OW 50
// result := result ^ un ;
72393: LD_ADDR_VAR 0 7
72397: PUSH
72398: LD_VAR 0 7
72402: PUSH
72403: LD_VAR 0 14
72407: ADD
72408: ST_TO_ADDR
// end ;
72409: GO 72287
72411: POP
72412: POP
// end ; end ;
72413: LD_VAR 0 7
72417: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
72418: LD_INT 0
72420: PPUSH
72421: PPUSH
72422: PPUSH
72423: PPUSH
72424: PPUSH
72425: PPUSH
72426: PPUSH
72427: PPUSH
72428: PPUSH
72429: PPUSH
72430: PPUSH
72431: PPUSH
72432: PPUSH
72433: PPUSH
72434: PPUSH
72435: PPUSH
// result := false ;
72436: LD_ADDR_VAR 0 3
72440: PUSH
72441: LD_INT 0
72443: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
72444: LD_VAR 0 1
72448: NOT
72449: PUSH
72450: LD_VAR 0 1
72454: PPUSH
72455: CALL_OW 266
72459: PUSH
72460: LD_INT 32
72462: PUSH
72463: LD_INT 33
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: IN
72470: NOT
72471: OR
72472: IFFALSE 72476
// exit ;
72474: GO 73585
// nat := GetNation ( tower ) ;
72476: LD_ADDR_VAR 0 12
72480: PUSH
72481: LD_VAR 0 1
72485: PPUSH
72486: CALL_OW 248
72490: ST_TO_ADDR
// side := GetSide ( tower ) ;
72491: LD_ADDR_VAR 0 16
72495: PUSH
72496: LD_VAR 0 1
72500: PPUSH
72501: CALL_OW 255
72505: ST_TO_ADDR
// x := GetX ( tower ) ;
72506: LD_ADDR_VAR 0 10
72510: PUSH
72511: LD_VAR 0 1
72515: PPUSH
72516: CALL_OW 250
72520: ST_TO_ADDR
// y := GetY ( tower ) ;
72521: LD_ADDR_VAR 0 11
72525: PUSH
72526: LD_VAR 0 1
72530: PPUSH
72531: CALL_OW 251
72535: ST_TO_ADDR
// if not x or not y then
72536: LD_VAR 0 10
72540: NOT
72541: PUSH
72542: LD_VAR 0 11
72546: NOT
72547: OR
72548: IFFALSE 72552
// exit ;
72550: GO 73585
// weapon := 0 ;
72552: LD_ADDR_VAR 0 18
72556: PUSH
72557: LD_INT 0
72559: ST_TO_ADDR
// fac_list := [ ] ;
72560: LD_ADDR_VAR 0 17
72564: PUSH
72565: EMPTY
72566: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
72567: LD_ADDR_VAR 0 6
72571: PUSH
72572: LD_VAR 0 1
72576: PPUSH
72577: CALL_OW 274
72581: PPUSH
72582: LD_VAR 0 2
72586: PPUSH
72587: LD_INT 0
72589: PPUSH
72590: CALL 70156 0 3
72594: PPUSH
72595: LD_INT 30
72597: PUSH
72598: LD_INT 3
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PPUSH
72605: CALL_OW 72
72609: ST_TO_ADDR
// if not factories then
72610: LD_VAR 0 6
72614: NOT
72615: IFFALSE 72619
// exit ;
72617: GO 73585
// for i in factories do
72619: LD_ADDR_VAR 0 8
72623: PUSH
72624: LD_VAR 0 6
72628: PUSH
72629: FOR_IN
72630: IFFALSE 72655
// fac_list := fac_list union AvailableWeaponList ( i ) ;
72632: LD_ADDR_VAR 0 17
72636: PUSH
72637: LD_VAR 0 17
72641: PUSH
72642: LD_VAR 0 8
72646: PPUSH
72647: CALL_OW 478
72651: UNION
72652: ST_TO_ADDR
72653: GO 72629
72655: POP
72656: POP
// if not fac_list then
72657: LD_VAR 0 17
72661: NOT
72662: IFFALSE 72666
// exit ;
72664: GO 73585
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
72666: LD_ADDR_VAR 0 5
72670: PUSH
72671: LD_INT 4
72673: PUSH
72674: LD_INT 5
72676: PUSH
72677: LD_INT 9
72679: PUSH
72680: LD_INT 10
72682: PUSH
72683: LD_INT 6
72685: PUSH
72686: LD_INT 7
72688: PUSH
72689: LD_INT 11
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 27
72703: PUSH
72704: LD_INT 28
72706: PUSH
72707: LD_INT 26
72709: PUSH
72710: LD_INT 30
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 43
72721: PUSH
72722: LD_INT 44
72724: PUSH
72725: LD_INT 46
72727: PUSH
72728: LD_INT 45
72730: PUSH
72731: LD_INT 47
72733: PUSH
72734: LD_INT 49
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: LIST
72749: PUSH
72750: LD_VAR 0 12
72754: ARRAY
72755: ST_TO_ADDR
// list := list isect fac_list ;
72756: LD_ADDR_VAR 0 5
72760: PUSH
72761: LD_VAR 0 5
72765: PUSH
72766: LD_VAR 0 17
72770: ISECT
72771: ST_TO_ADDR
// if not list then
72772: LD_VAR 0 5
72776: NOT
72777: IFFALSE 72781
// exit ;
72779: GO 73585
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
72781: LD_VAR 0 12
72785: PUSH
72786: LD_INT 3
72788: EQUAL
72789: PUSH
72790: LD_INT 49
72792: PUSH
72793: LD_VAR 0 5
72797: IN
72798: AND
72799: PUSH
72800: LD_INT 31
72802: PPUSH
72803: LD_VAR 0 16
72807: PPUSH
72808: CALL_OW 321
72812: PUSH
72813: LD_INT 2
72815: EQUAL
72816: AND
72817: IFFALSE 72877
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
72819: LD_INT 22
72821: PUSH
72822: LD_VAR 0 16
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PUSH
72831: LD_INT 35
72833: PUSH
72834: LD_INT 49
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 91
72843: PUSH
72844: LD_VAR 0 1
72848: PUSH
72849: LD_INT 10
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: LIST
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: LIST
72861: PPUSH
72862: CALL_OW 69
72866: NOT
72867: IFFALSE 72877
// weapon := ru_time_lapser ;
72869: LD_ADDR_VAR 0 18
72873: PUSH
72874: LD_INT 49
72876: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
72877: LD_VAR 0 12
72881: PUSH
72882: LD_INT 1
72884: PUSH
72885: LD_INT 2
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: IN
72892: PUSH
72893: LD_INT 11
72895: PUSH
72896: LD_VAR 0 5
72900: IN
72901: PUSH
72902: LD_INT 30
72904: PUSH
72905: LD_VAR 0 5
72909: IN
72910: OR
72911: AND
72912: PUSH
72913: LD_INT 6
72915: PPUSH
72916: LD_VAR 0 16
72920: PPUSH
72921: CALL_OW 321
72925: PUSH
72926: LD_INT 2
72928: EQUAL
72929: AND
72930: IFFALSE 73095
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
72932: LD_INT 22
72934: PUSH
72935: LD_VAR 0 16
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 2
72946: PUSH
72947: LD_INT 35
72949: PUSH
72950: LD_INT 11
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 35
72959: PUSH
72960: LD_INT 30
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 91
72974: PUSH
72975: LD_VAR 0 1
72979: PUSH
72980: LD_INT 18
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: LIST
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: LIST
72992: PPUSH
72993: CALL_OW 69
72997: NOT
72998: PUSH
72999: LD_INT 22
73001: PUSH
73002: LD_VAR 0 16
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 2
73013: PUSH
73014: LD_INT 30
73016: PUSH
73017: LD_INT 32
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 30
73026: PUSH
73027: LD_INT 33
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 91
73041: PUSH
73042: LD_VAR 0 1
73046: PUSH
73047: LD_INT 12
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: LIST
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: LIST
73059: PUSH
73060: EMPTY
73061: LIST
73062: PPUSH
73063: CALL_OW 69
73067: PUSH
73068: LD_INT 2
73070: GREATER
73071: AND
73072: IFFALSE 73095
// weapon := [ us_radar , ar_radar ] [ nat ] ;
73074: LD_ADDR_VAR 0 18
73078: PUSH
73079: LD_INT 11
73081: PUSH
73082: LD_INT 30
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_VAR 0 12
73093: ARRAY
73094: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
73095: LD_VAR 0 18
73099: NOT
73100: PUSH
73101: LD_INT 40
73103: PPUSH
73104: LD_VAR 0 16
73108: PPUSH
73109: CALL_OW 321
73113: PUSH
73114: LD_INT 2
73116: EQUAL
73117: AND
73118: PUSH
73119: LD_INT 7
73121: PUSH
73122: LD_VAR 0 5
73126: IN
73127: PUSH
73128: LD_INT 28
73130: PUSH
73131: LD_VAR 0 5
73135: IN
73136: OR
73137: PUSH
73138: LD_INT 45
73140: PUSH
73141: LD_VAR 0 5
73145: IN
73146: OR
73147: AND
73148: IFFALSE 73402
// begin hex := GetHexInfo ( x , y ) ;
73150: LD_ADDR_VAR 0 4
73154: PUSH
73155: LD_VAR 0 10
73159: PPUSH
73160: LD_VAR 0 11
73164: PPUSH
73165: CALL_OW 546
73169: ST_TO_ADDR
// if hex [ 1 ] then
73170: LD_VAR 0 4
73174: PUSH
73175: LD_INT 1
73177: ARRAY
73178: IFFALSE 73182
// exit ;
73180: GO 73585
// height := hex [ 2 ] ;
73182: LD_ADDR_VAR 0 15
73186: PUSH
73187: LD_VAR 0 4
73191: PUSH
73192: LD_INT 2
73194: ARRAY
73195: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
73196: LD_ADDR_VAR 0 14
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: LD_INT 2
73206: PUSH
73207: LD_INT 3
73209: PUSH
73210: LD_INT 5
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: ST_TO_ADDR
// for i in tmp do
73219: LD_ADDR_VAR 0 8
73223: PUSH
73224: LD_VAR 0 14
73228: PUSH
73229: FOR_IN
73230: IFFALSE 73400
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
73232: LD_ADDR_VAR 0 9
73236: PUSH
73237: LD_VAR 0 10
73241: PPUSH
73242: LD_VAR 0 8
73246: PPUSH
73247: LD_INT 5
73249: PPUSH
73250: CALL_OW 272
73254: PUSH
73255: LD_VAR 0 11
73259: PPUSH
73260: LD_VAR 0 8
73264: PPUSH
73265: LD_INT 5
73267: PPUSH
73268: CALL_OW 273
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
73277: LD_VAR 0 9
73281: PUSH
73282: LD_INT 1
73284: ARRAY
73285: PPUSH
73286: LD_VAR 0 9
73290: PUSH
73291: LD_INT 2
73293: ARRAY
73294: PPUSH
73295: CALL_OW 488
73299: IFFALSE 73398
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
73301: LD_ADDR_VAR 0 4
73305: PUSH
73306: LD_VAR 0 9
73310: PUSH
73311: LD_INT 1
73313: ARRAY
73314: PPUSH
73315: LD_VAR 0 9
73319: PUSH
73320: LD_INT 2
73322: ARRAY
73323: PPUSH
73324: CALL_OW 546
73328: ST_TO_ADDR
// if hex [ 1 ] then
73329: LD_VAR 0 4
73333: PUSH
73334: LD_INT 1
73336: ARRAY
73337: IFFALSE 73341
// continue ;
73339: GO 73229
// h := hex [ 2 ] ;
73341: LD_ADDR_VAR 0 13
73345: PUSH
73346: LD_VAR 0 4
73350: PUSH
73351: LD_INT 2
73353: ARRAY
73354: ST_TO_ADDR
// if h + 7 < height then
73355: LD_VAR 0 13
73359: PUSH
73360: LD_INT 7
73362: PLUS
73363: PUSH
73364: LD_VAR 0 15
73368: LESS
73369: IFFALSE 73398
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
73371: LD_ADDR_VAR 0 18
73375: PUSH
73376: LD_INT 7
73378: PUSH
73379: LD_INT 28
73381: PUSH
73382: LD_INT 45
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: LIST
73389: PUSH
73390: LD_VAR 0 12
73394: ARRAY
73395: ST_TO_ADDR
// break ;
73396: GO 73400
// end ; end ; end ;
73398: GO 73229
73400: POP
73401: POP
// end ; if not weapon then
73402: LD_VAR 0 18
73406: NOT
73407: IFFALSE 73467
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
73409: LD_ADDR_VAR 0 5
73413: PUSH
73414: LD_VAR 0 5
73418: PUSH
73419: LD_INT 11
73421: PUSH
73422: LD_INT 30
73424: PUSH
73425: LD_INT 49
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: LIST
73432: DIFF
73433: ST_TO_ADDR
// if not list then
73434: LD_VAR 0 5
73438: NOT
73439: IFFALSE 73443
// exit ;
73441: GO 73585
// weapon := list [ rand ( 1 , list ) ] ;
73443: LD_ADDR_VAR 0 18
73447: PUSH
73448: LD_VAR 0 5
73452: PUSH
73453: LD_INT 1
73455: PPUSH
73456: LD_VAR 0 5
73460: PPUSH
73461: CALL_OW 12
73465: ARRAY
73466: ST_TO_ADDR
// end ; if weapon then
73467: LD_VAR 0 18
73471: IFFALSE 73585
// begin tmp := CostOfWeapon ( weapon ) ;
73473: LD_ADDR_VAR 0 14
73477: PUSH
73478: LD_VAR 0 18
73482: PPUSH
73483: CALL_OW 451
73487: ST_TO_ADDR
// j := GetBase ( tower ) ;
73488: LD_ADDR_VAR 0 9
73492: PUSH
73493: LD_VAR 0 1
73497: PPUSH
73498: CALL_OW 274
73502: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
73503: LD_VAR 0 9
73507: PPUSH
73508: LD_INT 1
73510: PPUSH
73511: CALL_OW 275
73515: PUSH
73516: LD_VAR 0 14
73520: PUSH
73521: LD_INT 1
73523: ARRAY
73524: GREATEREQUAL
73525: PUSH
73526: LD_VAR 0 9
73530: PPUSH
73531: LD_INT 2
73533: PPUSH
73534: CALL_OW 275
73538: PUSH
73539: LD_VAR 0 14
73543: PUSH
73544: LD_INT 2
73546: ARRAY
73547: GREATEREQUAL
73548: AND
73549: PUSH
73550: LD_VAR 0 9
73554: PPUSH
73555: LD_INT 3
73557: PPUSH
73558: CALL_OW 275
73562: PUSH
73563: LD_VAR 0 14
73567: PUSH
73568: LD_INT 3
73570: ARRAY
73571: GREATEREQUAL
73572: AND
73573: IFFALSE 73585
// result := weapon ;
73575: LD_ADDR_VAR 0 3
73579: PUSH
73580: LD_VAR 0 18
73584: ST_TO_ADDR
// end ; end ;
73585: LD_VAR 0 3
73589: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
73590: LD_INT 0
73592: PPUSH
73593: PPUSH
// result := true ;
73594: LD_ADDR_VAR 0 3
73598: PUSH
73599: LD_INT 1
73601: ST_TO_ADDR
// if array1 = array2 then
73602: LD_VAR 0 1
73606: PUSH
73607: LD_VAR 0 2
73611: EQUAL
73612: IFFALSE 73672
// begin for i = 1 to array1 do
73614: LD_ADDR_VAR 0 4
73618: PUSH
73619: DOUBLE
73620: LD_INT 1
73622: DEC
73623: ST_TO_ADDR
73624: LD_VAR 0 1
73628: PUSH
73629: FOR_TO
73630: IFFALSE 73668
// if array1 [ i ] <> array2 [ i ] then
73632: LD_VAR 0 1
73636: PUSH
73637: LD_VAR 0 4
73641: ARRAY
73642: PUSH
73643: LD_VAR 0 2
73647: PUSH
73648: LD_VAR 0 4
73652: ARRAY
73653: NONEQUAL
73654: IFFALSE 73666
// begin result := false ;
73656: LD_ADDR_VAR 0 3
73660: PUSH
73661: LD_INT 0
73663: ST_TO_ADDR
// break ;
73664: GO 73668
// end ;
73666: GO 73629
73668: POP
73669: POP
// end else
73670: GO 73680
// result := false ;
73672: LD_ADDR_VAR 0 3
73676: PUSH
73677: LD_INT 0
73679: ST_TO_ADDR
// end ;
73680: LD_VAR 0 3
73684: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
73685: LD_INT 0
73687: PPUSH
73688: PPUSH
// if not array1 or not array2 then
73689: LD_VAR 0 1
73693: NOT
73694: PUSH
73695: LD_VAR 0 2
73699: NOT
73700: OR
73701: IFFALSE 73705
// exit ;
73703: GO 73769
// result := true ;
73705: LD_ADDR_VAR 0 3
73709: PUSH
73710: LD_INT 1
73712: ST_TO_ADDR
// for i = 1 to array1 do
73713: LD_ADDR_VAR 0 4
73717: PUSH
73718: DOUBLE
73719: LD_INT 1
73721: DEC
73722: ST_TO_ADDR
73723: LD_VAR 0 1
73727: PUSH
73728: FOR_TO
73729: IFFALSE 73767
// if array1 [ i ] <> array2 [ i ] then
73731: LD_VAR 0 1
73735: PUSH
73736: LD_VAR 0 4
73740: ARRAY
73741: PUSH
73742: LD_VAR 0 2
73746: PUSH
73747: LD_VAR 0 4
73751: ARRAY
73752: NONEQUAL
73753: IFFALSE 73765
// begin result := false ;
73755: LD_ADDR_VAR 0 3
73759: PUSH
73760: LD_INT 0
73762: ST_TO_ADDR
// break ;
73763: GO 73767
// end ;
73765: GO 73728
73767: POP
73768: POP
// end ;
73769: LD_VAR 0 3
73773: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
73774: LD_INT 0
73776: PPUSH
73777: PPUSH
73778: PPUSH
// pom := GetBase ( fac ) ;
73779: LD_ADDR_VAR 0 5
73783: PUSH
73784: LD_VAR 0 1
73788: PPUSH
73789: CALL_OW 274
73793: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
73794: LD_ADDR_VAR 0 4
73798: PUSH
73799: LD_VAR 0 2
73803: PUSH
73804: LD_INT 1
73806: ARRAY
73807: PPUSH
73808: LD_VAR 0 2
73812: PUSH
73813: LD_INT 2
73815: ARRAY
73816: PPUSH
73817: LD_VAR 0 2
73821: PUSH
73822: LD_INT 3
73824: ARRAY
73825: PPUSH
73826: LD_VAR 0 2
73830: PUSH
73831: LD_INT 4
73833: ARRAY
73834: PPUSH
73835: CALL_OW 449
73839: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
73840: LD_ADDR_VAR 0 3
73844: PUSH
73845: LD_VAR 0 5
73849: PPUSH
73850: LD_INT 1
73852: PPUSH
73853: CALL_OW 275
73857: PUSH
73858: LD_VAR 0 4
73862: PUSH
73863: LD_INT 1
73865: ARRAY
73866: GREATEREQUAL
73867: PUSH
73868: LD_VAR 0 5
73872: PPUSH
73873: LD_INT 2
73875: PPUSH
73876: CALL_OW 275
73880: PUSH
73881: LD_VAR 0 4
73885: PUSH
73886: LD_INT 2
73888: ARRAY
73889: GREATEREQUAL
73890: AND
73891: PUSH
73892: LD_VAR 0 5
73896: PPUSH
73897: LD_INT 3
73899: PPUSH
73900: CALL_OW 275
73904: PUSH
73905: LD_VAR 0 4
73909: PUSH
73910: LD_INT 3
73912: ARRAY
73913: GREATEREQUAL
73914: AND
73915: ST_TO_ADDR
// end ;
73916: LD_VAR 0 3
73920: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
73921: LD_INT 0
73923: PPUSH
73924: PPUSH
73925: PPUSH
73926: PPUSH
// pom := GetBase ( building ) ;
73927: LD_ADDR_VAR 0 3
73931: PUSH
73932: LD_VAR 0 1
73936: PPUSH
73937: CALL_OW 274
73941: ST_TO_ADDR
// if not pom then
73942: LD_VAR 0 3
73946: NOT
73947: IFFALSE 73951
// exit ;
73949: GO 74121
// btype := GetBType ( building ) ;
73951: LD_ADDR_VAR 0 5
73955: PUSH
73956: LD_VAR 0 1
73960: PPUSH
73961: CALL_OW 266
73965: ST_TO_ADDR
// if btype = b_armoury then
73966: LD_VAR 0 5
73970: PUSH
73971: LD_INT 4
73973: EQUAL
73974: IFFALSE 73984
// btype := b_barracks ;
73976: LD_ADDR_VAR 0 5
73980: PUSH
73981: LD_INT 5
73983: ST_TO_ADDR
// if btype = b_depot then
73984: LD_VAR 0 5
73988: PUSH
73989: LD_INT 0
73991: EQUAL
73992: IFFALSE 74002
// btype := b_warehouse ;
73994: LD_ADDR_VAR 0 5
73998: PUSH
73999: LD_INT 1
74001: ST_TO_ADDR
// if btype = b_workshop then
74002: LD_VAR 0 5
74006: PUSH
74007: LD_INT 2
74009: EQUAL
74010: IFFALSE 74020
// btype := b_factory ;
74012: LD_ADDR_VAR 0 5
74016: PUSH
74017: LD_INT 3
74019: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74020: LD_ADDR_VAR 0 4
74024: PUSH
74025: LD_VAR 0 5
74029: PPUSH
74030: LD_VAR 0 1
74034: PPUSH
74035: CALL_OW 248
74039: PPUSH
74040: CALL_OW 450
74044: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74045: LD_ADDR_VAR 0 2
74049: PUSH
74050: LD_VAR 0 3
74054: PPUSH
74055: LD_INT 1
74057: PPUSH
74058: CALL_OW 275
74062: PUSH
74063: LD_VAR 0 4
74067: PUSH
74068: LD_INT 1
74070: ARRAY
74071: GREATEREQUAL
74072: PUSH
74073: LD_VAR 0 3
74077: PPUSH
74078: LD_INT 2
74080: PPUSH
74081: CALL_OW 275
74085: PUSH
74086: LD_VAR 0 4
74090: PUSH
74091: LD_INT 2
74093: ARRAY
74094: GREATEREQUAL
74095: AND
74096: PUSH
74097: LD_VAR 0 3
74101: PPUSH
74102: LD_INT 3
74104: PPUSH
74105: CALL_OW 275
74109: PUSH
74110: LD_VAR 0 4
74114: PUSH
74115: LD_INT 3
74117: ARRAY
74118: GREATEREQUAL
74119: AND
74120: ST_TO_ADDR
// end ;
74121: LD_VAR 0 2
74125: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
74126: LD_INT 0
74128: PPUSH
74129: PPUSH
74130: PPUSH
// pom := GetBase ( building ) ;
74131: LD_ADDR_VAR 0 4
74135: PUSH
74136: LD_VAR 0 1
74140: PPUSH
74141: CALL_OW 274
74145: ST_TO_ADDR
// if not pom then
74146: LD_VAR 0 4
74150: NOT
74151: IFFALSE 74155
// exit ;
74153: GO 74256
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74155: LD_ADDR_VAR 0 5
74159: PUSH
74160: LD_VAR 0 2
74164: PPUSH
74165: LD_VAR 0 1
74169: PPUSH
74170: CALL_OW 248
74174: PPUSH
74175: CALL_OW 450
74179: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74180: LD_ADDR_VAR 0 3
74184: PUSH
74185: LD_VAR 0 4
74189: PPUSH
74190: LD_INT 1
74192: PPUSH
74193: CALL_OW 275
74197: PUSH
74198: LD_VAR 0 5
74202: PUSH
74203: LD_INT 1
74205: ARRAY
74206: GREATEREQUAL
74207: PUSH
74208: LD_VAR 0 4
74212: PPUSH
74213: LD_INT 2
74215: PPUSH
74216: CALL_OW 275
74220: PUSH
74221: LD_VAR 0 5
74225: PUSH
74226: LD_INT 2
74228: ARRAY
74229: GREATEREQUAL
74230: AND
74231: PUSH
74232: LD_VAR 0 4
74236: PPUSH
74237: LD_INT 3
74239: PPUSH
74240: CALL_OW 275
74244: PUSH
74245: LD_VAR 0 5
74249: PUSH
74250: LD_INT 3
74252: ARRAY
74253: GREATEREQUAL
74254: AND
74255: ST_TO_ADDR
// end ;
74256: LD_VAR 0 3
74260: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
74261: LD_INT 0
74263: PPUSH
74264: PPUSH
74265: PPUSH
74266: PPUSH
74267: PPUSH
74268: PPUSH
74269: PPUSH
74270: PPUSH
74271: PPUSH
74272: PPUSH
74273: PPUSH
// result := false ;
74274: LD_ADDR_VAR 0 8
74278: PUSH
74279: LD_INT 0
74281: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
74282: LD_VAR 0 5
74286: NOT
74287: PUSH
74288: LD_VAR 0 1
74292: NOT
74293: OR
74294: PUSH
74295: LD_VAR 0 2
74299: NOT
74300: OR
74301: PUSH
74302: LD_VAR 0 3
74306: NOT
74307: OR
74308: IFFALSE 74312
// exit ;
74310: GO 75126
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
74312: LD_ADDR_VAR 0 14
74316: PUSH
74317: LD_VAR 0 1
74321: PPUSH
74322: LD_VAR 0 2
74326: PPUSH
74327: LD_VAR 0 3
74331: PPUSH
74332: LD_VAR 0 4
74336: PPUSH
74337: LD_VAR 0 5
74341: PUSH
74342: LD_INT 1
74344: ARRAY
74345: PPUSH
74346: CALL_OW 248
74350: PPUSH
74351: LD_INT 0
74353: PPUSH
74354: CALL 76363 0 6
74358: ST_TO_ADDR
// if not hexes then
74359: LD_VAR 0 14
74363: NOT
74364: IFFALSE 74368
// exit ;
74366: GO 75126
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74368: LD_ADDR_VAR 0 17
74372: PUSH
74373: LD_VAR 0 5
74377: PPUSH
74378: LD_INT 22
74380: PUSH
74381: LD_VAR 0 13
74385: PPUSH
74386: CALL_OW 255
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 2
74397: PUSH
74398: LD_INT 30
74400: PUSH
74401: LD_INT 0
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 30
74410: PUSH
74411: LD_INT 1
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: EMPTY
74419: LIST
74420: LIST
74421: LIST
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PPUSH
74427: CALL_OW 72
74431: ST_TO_ADDR
// for i = 1 to hexes do
74432: LD_ADDR_VAR 0 9
74436: PUSH
74437: DOUBLE
74438: LD_INT 1
74440: DEC
74441: ST_TO_ADDR
74442: LD_VAR 0 14
74446: PUSH
74447: FOR_TO
74448: IFFALSE 75124
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74450: LD_ADDR_VAR 0 13
74454: PUSH
74455: LD_VAR 0 14
74459: PUSH
74460: LD_VAR 0 9
74464: ARRAY
74465: PUSH
74466: LD_INT 1
74468: ARRAY
74469: PPUSH
74470: LD_VAR 0 14
74474: PUSH
74475: LD_VAR 0 9
74479: ARRAY
74480: PUSH
74481: LD_INT 2
74483: ARRAY
74484: PPUSH
74485: CALL_OW 428
74489: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
74490: LD_VAR 0 14
74494: PUSH
74495: LD_VAR 0 9
74499: ARRAY
74500: PUSH
74501: LD_INT 1
74503: ARRAY
74504: PPUSH
74505: LD_VAR 0 14
74509: PUSH
74510: LD_VAR 0 9
74514: ARRAY
74515: PUSH
74516: LD_INT 2
74518: ARRAY
74519: PPUSH
74520: CALL_OW 351
74524: PUSH
74525: LD_VAR 0 14
74529: PUSH
74530: LD_VAR 0 9
74534: ARRAY
74535: PUSH
74536: LD_INT 1
74538: ARRAY
74539: PPUSH
74540: LD_VAR 0 14
74544: PUSH
74545: LD_VAR 0 9
74549: ARRAY
74550: PUSH
74551: LD_INT 2
74553: ARRAY
74554: PPUSH
74555: CALL_OW 488
74559: NOT
74560: OR
74561: PUSH
74562: LD_VAR 0 13
74566: PPUSH
74567: CALL_OW 247
74571: PUSH
74572: LD_INT 3
74574: EQUAL
74575: OR
74576: IFFALSE 74582
// exit ;
74578: POP
74579: POP
74580: GO 75126
// if not tmp then
74582: LD_VAR 0 13
74586: NOT
74587: IFFALSE 74591
// continue ;
74589: GO 74447
// result := true ;
74591: LD_ADDR_VAR 0 8
74595: PUSH
74596: LD_INT 1
74598: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
74599: LD_VAR 0 6
74603: PUSH
74604: LD_VAR 0 13
74608: PPUSH
74609: CALL_OW 247
74613: PUSH
74614: LD_INT 2
74616: EQUAL
74617: AND
74618: PUSH
74619: LD_VAR 0 13
74623: PPUSH
74624: CALL_OW 263
74628: PUSH
74629: LD_INT 1
74631: EQUAL
74632: AND
74633: IFFALSE 74797
// begin if IsDrivenBy ( tmp ) then
74635: LD_VAR 0 13
74639: PPUSH
74640: CALL_OW 311
74644: IFFALSE 74648
// continue ;
74646: GO 74447
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
74648: LD_VAR 0 6
74652: PPUSH
74653: LD_INT 3
74655: PUSH
74656: LD_INT 60
74658: PUSH
74659: EMPTY
74660: LIST
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 3
74668: PUSH
74669: LD_INT 55
74671: PUSH
74672: EMPTY
74673: LIST
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PPUSH
74683: CALL_OW 72
74687: IFFALSE 74795
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
74689: LD_ADDR_VAR 0 18
74693: PUSH
74694: LD_VAR 0 6
74698: PPUSH
74699: LD_INT 3
74701: PUSH
74702: LD_INT 60
74704: PUSH
74705: EMPTY
74706: LIST
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 3
74714: PUSH
74715: LD_INT 55
74717: PUSH
74718: EMPTY
74719: LIST
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PPUSH
74729: CALL_OW 72
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: ST_TO_ADDR
// if IsInUnit ( driver ) then
74738: LD_VAR 0 18
74742: PPUSH
74743: CALL_OW 310
74747: IFFALSE 74758
// ComExit ( driver ) ;
74749: LD_VAR 0 18
74753: PPUSH
74754: CALL 99491 0 1
// AddComEnterUnit ( driver , tmp ) ;
74758: LD_VAR 0 18
74762: PPUSH
74763: LD_VAR 0 13
74767: PPUSH
74768: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
74772: LD_VAR 0 18
74776: PPUSH
74777: LD_VAR 0 7
74781: PPUSH
74782: CALL_OW 173
// AddComExitVehicle ( driver ) ;
74786: LD_VAR 0 18
74790: PPUSH
74791: CALL_OW 181
// end ; continue ;
74795: GO 74447
// end ; if not cleaners or not tmp in cleaners then
74797: LD_VAR 0 6
74801: NOT
74802: PUSH
74803: LD_VAR 0 13
74807: PUSH
74808: LD_VAR 0 6
74812: IN
74813: NOT
74814: OR
74815: IFFALSE 75122
// begin if dep then
74817: LD_VAR 0 17
74821: IFFALSE 74957
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
74823: LD_ADDR_VAR 0 16
74827: PUSH
74828: LD_VAR 0 17
74832: PUSH
74833: LD_INT 1
74835: ARRAY
74836: PPUSH
74837: CALL_OW 250
74841: PPUSH
74842: LD_VAR 0 17
74846: PUSH
74847: LD_INT 1
74849: ARRAY
74850: PPUSH
74851: CALL_OW 254
74855: PPUSH
74856: LD_INT 5
74858: PPUSH
74859: CALL_OW 272
74863: PUSH
74864: LD_VAR 0 17
74868: PUSH
74869: LD_INT 1
74871: ARRAY
74872: PPUSH
74873: CALL_OW 251
74877: PPUSH
74878: LD_VAR 0 17
74882: PUSH
74883: LD_INT 1
74885: ARRAY
74886: PPUSH
74887: CALL_OW 254
74891: PPUSH
74892: LD_INT 5
74894: PPUSH
74895: CALL_OW 273
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
74904: LD_VAR 0 16
74908: PUSH
74909: LD_INT 1
74911: ARRAY
74912: PPUSH
74913: LD_VAR 0 16
74917: PUSH
74918: LD_INT 2
74920: ARRAY
74921: PPUSH
74922: CALL_OW 488
74926: IFFALSE 74957
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
74928: LD_VAR 0 13
74932: PPUSH
74933: LD_VAR 0 16
74937: PUSH
74938: LD_INT 1
74940: ARRAY
74941: PPUSH
74942: LD_VAR 0 16
74946: PUSH
74947: LD_INT 2
74949: ARRAY
74950: PPUSH
74951: CALL_OW 111
// continue ;
74955: GO 74447
// end ; end ; r := GetDir ( tmp ) ;
74957: LD_ADDR_VAR 0 15
74961: PUSH
74962: LD_VAR 0 13
74966: PPUSH
74967: CALL_OW 254
74971: ST_TO_ADDR
// if r = 5 then
74972: LD_VAR 0 15
74976: PUSH
74977: LD_INT 5
74979: EQUAL
74980: IFFALSE 74990
// r := 0 ;
74982: LD_ADDR_VAR 0 15
74986: PUSH
74987: LD_INT 0
74989: ST_TO_ADDR
// for j = r to 5 do
74990: LD_ADDR_VAR 0 10
74994: PUSH
74995: DOUBLE
74996: LD_VAR 0 15
75000: DEC
75001: ST_TO_ADDR
75002: LD_INT 5
75004: PUSH
75005: FOR_TO
75006: IFFALSE 75120
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75008: LD_ADDR_VAR 0 11
75012: PUSH
75013: LD_VAR 0 13
75017: PPUSH
75018: CALL_OW 250
75022: PPUSH
75023: LD_VAR 0 10
75027: PPUSH
75028: LD_INT 2
75030: PPUSH
75031: CALL_OW 272
75035: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75036: LD_ADDR_VAR 0 12
75040: PUSH
75041: LD_VAR 0 13
75045: PPUSH
75046: CALL_OW 251
75050: PPUSH
75051: LD_VAR 0 10
75055: PPUSH
75056: LD_INT 2
75058: PPUSH
75059: CALL_OW 273
75063: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75064: LD_VAR 0 11
75068: PPUSH
75069: LD_VAR 0 12
75073: PPUSH
75074: CALL_OW 488
75078: PUSH
75079: LD_VAR 0 11
75083: PPUSH
75084: LD_VAR 0 12
75088: PPUSH
75089: CALL_OW 428
75093: NOT
75094: AND
75095: IFFALSE 75118
// begin ComMoveXY ( tmp , _x , _y ) ;
75097: LD_VAR 0 13
75101: PPUSH
75102: LD_VAR 0 11
75106: PPUSH
75107: LD_VAR 0 12
75111: PPUSH
75112: CALL_OW 111
// break ;
75116: GO 75120
// end ; end ;
75118: GO 75005
75120: POP
75121: POP
// end ; end ;
75122: GO 74447
75124: POP
75125: POP
// end ;
75126: LD_VAR 0 8
75130: RET
// export function BuildingTechInvented ( side , btype ) ; begin
75131: LD_INT 0
75133: PPUSH
// result := true ;
75134: LD_ADDR_VAR 0 3
75138: PUSH
75139: LD_INT 1
75141: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
75142: LD_VAR 0 2
75146: PUSH
75147: LD_INT 24
75149: DOUBLE
75150: EQUAL
75151: IFTRUE 75161
75153: LD_INT 33
75155: DOUBLE
75156: EQUAL
75157: IFTRUE 75161
75159: GO 75186
75161: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
75162: LD_ADDR_VAR 0 3
75166: PUSH
75167: LD_INT 32
75169: PPUSH
75170: LD_VAR 0 1
75174: PPUSH
75175: CALL_OW 321
75179: PUSH
75180: LD_INT 2
75182: EQUAL
75183: ST_TO_ADDR
75184: GO 75506
75186: LD_INT 20
75188: DOUBLE
75189: EQUAL
75190: IFTRUE 75194
75192: GO 75219
75194: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
75195: LD_ADDR_VAR 0 3
75199: PUSH
75200: LD_INT 6
75202: PPUSH
75203: LD_VAR 0 1
75207: PPUSH
75208: CALL_OW 321
75212: PUSH
75213: LD_INT 2
75215: EQUAL
75216: ST_TO_ADDR
75217: GO 75506
75219: LD_INT 22
75221: DOUBLE
75222: EQUAL
75223: IFTRUE 75233
75225: LD_INT 36
75227: DOUBLE
75228: EQUAL
75229: IFTRUE 75233
75231: GO 75258
75233: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
75234: LD_ADDR_VAR 0 3
75238: PUSH
75239: LD_INT 15
75241: PPUSH
75242: LD_VAR 0 1
75246: PPUSH
75247: CALL_OW 321
75251: PUSH
75252: LD_INT 2
75254: EQUAL
75255: ST_TO_ADDR
75256: GO 75506
75258: LD_INT 30
75260: DOUBLE
75261: EQUAL
75262: IFTRUE 75266
75264: GO 75291
75266: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
75267: LD_ADDR_VAR 0 3
75271: PUSH
75272: LD_INT 20
75274: PPUSH
75275: LD_VAR 0 1
75279: PPUSH
75280: CALL_OW 321
75284: PUSH
75285: LD_INT 2
75287: EQUAL
75288: ST_TO_ADDR
75289: GO 75506
75291: LD_INT 28
75293: DOUBLE
75294: EQUAL
75295: IFTRUE 75305
75297: LD_INT 21
75299: DOUBLE
75300: EQUAL
75301: IFTRUE 75305
75303: GO 75330
75305: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
75306: LD_ADDR_VAR 0 3
75310: PUSH
75311: LD_INT 21
75313: PPUSH
75314: LD_VAR 0 1
75318: PPUSH
75319: CALL_OW 321
75323: PUSH
75324: LD_INT 2
75326: EQUAL
75327: ST_TO_ADDR
75328: GO 75506
75330: LD_INT 16
75332: DOUBLE
75333: EQUAL
75334: IFTRUE 75338
75336: GO 75365
75338: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
75339: LD_ADDR_VAR 0 3
75343: PUSH
75344: LD_EXP 85
75348: PPUSH
75349: LD_VAR 0 1
75353: PPUSH
75354: CALL_OW 321
75358: PUSH
75359: LD_INT 2
75361: EQUAL
75362: ST_TO_ADDR
75363: GO 75506
75365: LD_INT 19
75367: DOUBLE
75368: EQUAL
75369: IFTRUE 75379
75371: LD_INT 23
75373: DOUBLE
75374: EQUAL
75375: IFTRUE 75379
75377: GO 75406
75379: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
75380: LD_ADDR_VAR 0 3
75384: PUSH
75385: LD_EXP 84
75389: PPUSH
75390: LD_VAR 0 1
75394: PPUSH
75395: CALL_OW 321
75399: PUSH
75400: LD_INT 2
75402: EQUAL
75403: ST_TO_ADDR
75404: GO 75506
75406: LD_INT 17
75408: DOUBLE
75409: EQUAL
75410: IFTRUE 75414
75412: GO 75439
75414: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
75415: LD_ADDR_VAR 0 3
75419: PUSH
75420: LD_INT 39
75422: PPUSH
75423: LD_VAR 0 1
75427: PPUSH
75428: CALL_OW 321
75432: PUSH
75433: LD_INT 2
75435: EQUAL
75436: ST_TO_ADDR
75437: GO 75506
75439: LD_INT 18
75441: DOUBLE
75442: EQUAL
75443: IFTRUE 75447
75445: GO 75472
75447: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
75448: LD_ADDR_VAR 0 3
75452: PUSH
75453: LD_INT 40
75455: PPUSH
75456: LD_VAR 0 1
75460: PPUSH
75461: CALL_OW 321
75465: PUSH
75466: LD_INT 2
75468: EQUAL
75469: ST_TO_ADDR
75470: GO 75506
75472: LD_INT 27
75474: DOUBLE
75475: EQUAL
75476: IFTRUE 75480
75478: GO 75505
75480: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
75481: LD_ADDR_VAR 0 3
75485: PUSH
75486: LD_INT 35
75488: PPUSH
75489: LD_VAR 0 1
75493: PPUSH
75494: CALL_OW 321
75498: PUSH
75499: LD_INT 2
75501: EQUAL
75502: ST_TO_ADDR
75503: GO 75506
75505: POP
// end ;
75506: LD_VAR 0 3
75510: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
75511: LD_INT 0
75513: PPUSH
75514: PPUSH
75515: PPUSH
75516: PPUSH
75517: PPUSH
75518: PPUSH
75519: PPUSH
75520: PPUSH
75521: PPUSH
75522: PPUSH
75523: PPUSH
// result := false ;
75524: LD_ADDR_VAR 0 6
75528: PUSH
75529: LD_INT 0
75531: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
75532: LD_VAR 0 1
75536: NOT
75537: PUSH
75538: LD_VAR 0 1
75542: PPUSH
75543: CALL_OW 266
75547: PUSH
75548: LD_INT 0
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: IN
75558: NOT
75559: OR
75560: PUSH
75561: LD_VAR 0 2
75565: NOT
75566: OR
75567: PUSH
75568: LD_VAR 0 5
75572: PUSH
75573: LD_INT 0
75575: PUSH
75576: LD_INT 1
75578: PUSH
75579: LD_INT 2
75581: PUSH
75582: LD_INT 3
75584: PUSH
75585: LD_INT 4
75587: PUSH
75588: LD_INT 5
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: IN
75599: NOT
75600: OR
75601: PUSH
75602: LD_VAR 0 3
75606: PPUSH
75607: LD_VAR 0 4
75611: PPUSH
75612: CALL_OW 488
75616: NOT
75617: OR
75618: IFFALSE 75622
// exit ;
75620: GO 76358
// side := GetSide ( depot ) ;
75622: LD_ADDR_VAR 0 9
75626: PUSH
75627: LD_VAR 0 1
75631: PPUSH
75632: CALL_OW 255
75636: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
75637: LD_VAR 0 9
75641: PPUSH
75642: LD_VAR 0 2
75646: PPUSH
75647: CALL 75131 0 2
75651: NOT
75652: IFFALSE 75656
// exit ;
75654: GO 76358
// pom := GetBase ( depot ) ;
75656: LD_ADDR_VAR 0 10
75660: PUSH
75661: LD_VAR 0 1
75665: PPUSH
75666: CALL_OW 274
75670: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
75671: LD_ADDR_VAR 0 11
75675: PUSH
75676: LD_VAR 0 2
75680: PPUSH
75681: LD_VAR 0 1
75685: PPUSH
75686: CALL_OW 248
75690: PPUSH
75691: CALL_OW 450
75695: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
75696: LD_VAR 0 10
75700: PPUSH
75701: LD_INT 1
75703: PPUSH
75704: CALL_OW 275
75708: PUSH
75709: LD_VAR 0 11
75713: PUSH
75714: LD_INT 1
75716: ARRAY
75717: GREATEREQUAL
75718: PUSH
75719: LD_VAR 0 10
75723: PPUSH
75724: LD_INT 2
75726: PPUSH
75727: CALL_OW 275
75731: PUSH
75732: LD_VAR 0 11
75736: PUSH
75737: LD_INT 2
75739: ARRAY
75740: GREATEREQUAL
75741: AND
75742: PUSH
75743: LD_VAR 0 10
75747: PPUSH
75748: LD_INT 3
75750: PPUSH
75751: CALL_OW 275
75755: PUSH
75756: LD_VAR 0 11
75760: PUSH
75761: LD_INT 3
75763: ARRAY
75764: GREATEREQUAL
75765: AND
75766: NOT
75767: IFFALSE 75771
// exit ;
75769: GO 76358
// if GetBType ( depot ) = b_depot then
75771: LD_VAR 0 1
75775: PPUSH
75776: CALL_OW 266
75780: PUSH
75781: LD_INT 0
75783: EQUAL
75784: IFFALSE 75796
// dist := 28 else
75786: LD_ADDR_VAR 0 14
75790: PUSH
75791: LD_INT 28
75793: ST_TO_ADDR
75794: GO 75804
// dist := 36 ;
75796: LD_ADDR_VAR 0 14
75800: PUSH
75801: LD_INT 36
75803: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
75804: LD_VAR 0 1
75808: PPUSH
75809: LD_VAR 0 3
75813: PPUSH
75814: LD_VAR 0 4
75818: PPUSH
75819: CALL_OW 297
75823: PUSH
75824: LD_VAR 0 14
75828: GREATER
75829: IFFALSE 75833
// exit ;
75831: GO 76358
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
75833: LD_ADDR_VAR 0 12
75837: PUSH
75838: LD_VAR 0 2
75842: PPUSH
75843: LD_VAR 0 3
75847: PPUSH
75848: LD_VAR 0 4
75852: PPUSH
75853: LD_VAR 0 5
75857: PPUSH
75858: LD_VAR 0 1
75862: PPUSH
75863: CALL_OW 248
75867: PPUSH
75868: LD_INT 0
75870: PPUSH
75871: CALL 76363 0 6
75875: ST_TO_ADDR
// if not hexes then
75876: LD_VAR 0 12
75880: NOT
75881: IFFALSE 75885
// exit ;
75883: GO 76358
// hex := GetHexInfo ( x , y ) ;
75885: LD_ADDR_VAR 0 15
75889: PUSH
75890: LD_VAR 0 3
75894: PPUSH
75895: LD_VAR 0 4
75899: PPUSH
75900: CALL_OW 546
75904: ST_TO_ADDR
// if hex [ 1 ] then
75905: LD_VAR 0 15
75909: PUSH
75910: LD_INT 1
75912: ARRAY
75913: IFFALSE 75917
// exit ;
75915: GO 76358
// height := hex [ 2 ] ;
75917: LD_ADDR_VAR 0 13
75921: PUSH
75922: LD_VAR 0 15
75926: PUSH
75927: LD_INT 2
75929: ARRAY
75930: ST_TO_ADDR
// for i = 1 to hexes do
75931: LD_ADDR_VAR 0 7
75935: PUSH
75936: DOUBLE
75937: LD_INT 1
75939: DEC
75940: ST_TO_ADDR
75941: LD_VAR 0 12
75945: PUSH
75946: FOR_TO
75947: IFFALSE 76277
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
75949: LD_VAR 0 12
75953: PUSH
75954: LD_VAR 0 7
75958: ARRAY
75959: PUSH
75960: LD_INT 1
75962: ARRAY
75963: PPUSH
75964: LD_VAR 0 12
75968: PUSH
75969: LD_VAR 0 7
75973: ARRAY
75974: PUSH
75975: LD_INT 2
75977: ARRAY
75978: PPUSH
75979: CALL_OW 488
75983: NOT
75984: PUSH
75985: LD_VAR 0 12
75989: PUSH
75990: LD_VAR 0 7
75994: ARRAY
75995: PUSH
75996: LD_INT 1
75998: ARRAY
75999: PPUSH
76000: LD_VAR 0 12
76004: PUSH
76005: LD_VAR 0 7
76009: ARRAY
76010: PUSH
76011: LD_INT 2
76013: ARRAY
76014: PPUSH
76015: CALL_OW 428
76019: PUSH
76020: LD_INT 0
76022: GREATER
76023: OR
76024: PUSH
76025: LD_VAR 0 12
76029: PUSH
76030: LD_VAR 0 7
76034: ARRAY
76035: PUSH
76036: LD_INT 1
76038: ARRAY
76039: PPUSH
76040: LD_VAR 0 12
76044: PUSH
76045: LD_VAR 0 7
76049: ARRAY
76050: PUSH
76051: LD_INT 2
76053: ARRAY
76054: PPUSH
76055: CALL_OW 351
76059: OR
76060: IFFALSE 76066
// exit ;
76062: POP
76063: POP
76064: GO 76358
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76066: LD_ADDR_VAR 0 8
76070: PUSH
76071: LD_VAR 0 12
76075: PUSH
76076: LD_VAR 0 7
76080: ARRAY
76081: PUSH
76082: LD_INT 1
76084: ARRAY
76085: PPUSH
76086: LD_VAR 0 12
76090: PUSH
76091: LD_VAR 0 7
76095: ARRAY
76096: PUSH
76097: LD_INT 2
76099: ARRAY
76100: PPUSH
76101: CALL_OW 546
76105: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
76106: LD_VAR 0 8
76110: PUSH
76111: LD_INT 1
76113: ARRAY
76114: PUSH
76115: LD_VAR 0 8
76119: PUSH
76120: LD_INT 2
76122: ARRAY
76123: PUSH
76124: LD_VAR 0 13
76128: PUSH
76129: LD_INT 2
76131: PLUS
76132: GREATER
76133: OR
76134: PUSH
76135: LD_VAR 0 8
76139: PUSH
76140: LD_INT 2
76142: ARRAY
76143: PUSH
76144: LD_VAR 0 13
76148: PUSH
76149: LD_INT 2
76151: MINUS
76152: LESS
76153: OR
76154: PUSH
76155: LD_VAR 0 8
76159: PUSH
76160: LD_INT 3
76162: ARRAY
76163: PUSH
76164: LD_INT 0
76166: PUSH
76167: LD_INT 8
76169: PUSH
76170: LD_INT 9
76172: PUSH
76173: LD_INT 10
76175: PUSH
76176: LD_INT 11
76178: PUSH
76179: LD_INT 12
76181: PUSH
76182: LD_INT 13
76184: PUSH
76185: LD_INT 16
76187: PUSH
76188: LD_INT 17
76190: PUSH
76191: LD_INT 18
76193: PUSH
76194: LD_INT 19
76196: PUSH
76197: LD_INT 20
76199: PUSH
76200: LD_INT 21
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: IN
76218: NOT
76219: OR
76220: PUSH
76221: LD_VAR 0 8
76225: PUSH
76226: LD_INT 5
76228: ARRAY
76229: NOT
76230: OR
76231: PUSH
76232: LD_VAR 0 8
76236: PUSH
76237: LD_INT 6
76239: ARRAY
76240: PUSH
76241: LD_INT 1
76243: PUSH
76244: LD_INT 2
76246: PUSH
76247: LD_INT 7
76249: PUSH
76250: LD_INT 9
76252: PUSH
76253: LD_INT 10
76255: PUSH
76256: LD_INT 11
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: IN
76267: NOT
76268: OR
76269: IFFALSE 76275
// exit ;
76271: POP
76272: POP
76273: GO 76358
// end ;
76275: GO 75946
76277: POP
76278: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76279: LD_VAR 0 9
76283: PPUSH
76284: LD_VAR 0 3
76288: PPUSH
76289: LD_VAR 0 4
76293: PPUSH
76294: LD_INT 20
76296: PPUSH
76297: CALL 68304 0 4
76301: PUSH
76302: LD_INT 4
76304: ARRAY
76305: IFFALSE 76309
// exit ;
76307: GO 76358
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
76309: LD_VAR 0 2
76313: PUSH
76314: LD_INT 29
76316: PUSH
76317: LD_INT 30
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: IN
76324: PUSH
76325: LD_VAR 0 3
76329: PPUSH
76330: LD_VAR 0 4
76334: PPUSH
76335: LD_VAR 0 9
76339: PPUSH
76340: CALL_OW 440
76344: NOT
76345: AND
76346: IFFALSE 76350
// exit ;
76348: GO 76358
// result := true ;
76350: LD_ADDR_VAR 0 6
76354: PUSH
76355: LD_INT 1
76357: ST_TO_ADDR
// end ;
76358: LD_VAR 0 6
76362: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
76363: LD_INT 0
76365: PPUSH
76366: PPUSH
76367: PPUSH
76368: PPUSH
76369: PPUSH
76370: PPUSH
76371: PPUSH
76372: PPUSH
76373: PPUSH
76374: PPUSH
76375: PPUSH
76376: PPUSH
76377: PPUSH
76378: PPUSH
76379: PPUSH
76380: PPUSH
76381: PPUSH
76382: PPUSH
76383: PPUSH
76384: PPUSH
76385: PPUSH
76386: PPUSH
76387: PPUSH
76388: PPUSH
76389: PPUSH
76390: PPUSH
76391: PPUSH
76392: PPUSH
76393: PPUSH
76394: PPUSH
76395: PPUSH
76396: PPUSH
76397: PPUSH
76398: PPUSH
76399: PPUSH
76400: PPUSH
76401: PPUSH
76402: PPUSH
76403: PPUSH
76404: PPUSH
76405: PPUSH
76406: PPUSH
76407: PPUSH
76408: PPUSH
76409: PPUSH
76410: PPUSH
76411: PPUSH
76412: PPUSH
76413: PPUSH
76414: PPUSH
76415: PPUSH
76416: PPUSH
76417: PPUSH
76418: PPUSH
76419: PPUSH
76420: PPUSH
76421: PPUSH
76422: PPUSH
// result = [ ] ;
76423: LD_ADDR_VAR 0 7
76427: PUSH
76428: EMPTY
76429: ST_TO_ADDR
// temp_list = [ ] ;
76430: LD_ADDR_VAR 0 9
76434: PUSH
76435: EMPTY
76436: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
76437: LD_VAR 0 4
76441: PUSH
76442: LD_INT 0
76444: PUSH
76445: LD_INT 1
76447: PUSH
76448: LD_INT 2
76450: PUSH
76451: LD_INT 3
76453: PUSH
76454: LD_INT 4
76456: PUSH
76457: LD_INT 5
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: LIST
76464: LIST
76465: LIST
76466: LIST
76467: IN
76468: NOT
76469: PUSH
76470: LD_VAR 0 1
76474: PUSH
76475: LD_INT 0
76477: PUSH
76478: LD_INT 1
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: IN
76485: PUSH
76486: LD_VAR 0 5
76490: PUSH
76491: LD_INT 1
76493: PUSH
76494: LD_INT 2
76496: PUSH
76497: LD_INT 3
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: LIST
76504: IN
76505: NOT
76506: AND
76507: OR
76508: IFFALSE 76512
// exit ;
76510: GO 94903
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
76512: LD_VAR 0 1
76516: PUSH
76517: LD_INT 6
76519: PUSH
76520: LD_INT 7
76522: PUSH
76523: LD_INT 8
76525: PUSH
76526: LD_INT 13
76528: PUSH
76529: LD_INT 12
76531: PUSH
76532: LD_INT 15
76534: PUSH
76535: LD_INT 11
76537: PUSH
76538: LD_INT 14
76540: PUSH
76541: LD_INT 10
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: IN
76555: IFFALSE 76565
// btype = b_lab ;
76557: LD_ADDR_VAR 0 1
76561: PUSH
76562: LD_INT 6
76564: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
76565: LD_VAR 0 6
76569: PUSH
76570: LD_INT 0
76572: PUSH
76573: LD_INT 1
76575: PUSH
76576: LD_INT 2
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: LIST
76583: IN
76584: NOT
76585: PUSH
76586: LD_VAR 0 1
76590: PUSH
76591: LD_INT 0
76593: PUSH
76594: LD_INT 1
76596: PUSH
76597: LD_INT 2
76599: PUSH
76600: LD_INT 3
76602: PUSH
76603: LD_INT 6
76605: PUSH
76606: LD_INT 36
76608: PUSH
76609: LD_INT 4
76611: PUSH
76612: LD_INT 5
76614: PUSH
76615: LD_INT 31
76617: PUSH
76618: LD_INT 32
76620: PUSH
76621: LD_INT 33
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: IN
76637: NOT
76638: PUSH
76639: LD_VAR 0 6
76643: PUSH
76644: LD_INT 1
76646: EQUAL
76647: AND
76648: OR
76649: PUSH
76650: LD_VAR 0 1
76654: PUSH
76655: LD_INT 2
76657: PUSH
76658: LD_INT 3
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: IN
76665: NOT
76666: PUSH
76667: LD_VAR 0 6
76671: PUSH
76672: LD_INT 2
76674: EQUAL
76675: AND
76676: OR
76677: IFFALSE 76687
// mode = 0 ;
76679: LD_ADDR_VAR 0 6
76683: PUSH
76684: LD_INT 0
76686: ST_TO_ADDR
// case mode of 0 :
76687: LD_VAR 0 6
76691: PUSH
76692: LD_INT 0
76694: DOUBLE
76695: EQUAL
76696: IFTRUE 76700
76698: GO 88153
76700: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76701: LD_ADDR_VAR 0 11
76705: PUSH
76706: LD_INT 0
76708: PUSH
76709: LD_INT 0
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 0
76718: PUSH
76719: LD_INT 1
76721: NEG
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 1
76729: PUSH
76730: LD_INT 0
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 1
76739: PUSH
76740: LD_INT 1
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 0
76749: PUSH
76750: LD_INT 1
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 1
76759: NEG
76760: PUSH
76761: LD_INT 0
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 1
76770: NEG
76771: PUSH
76772: LD_INT 1
76774: NEG
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 1
76782: NEG
76783: PUSH
76784: LD_INT 2
76786: NEG
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: LD_INT 2
76797: NEG
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: LD_INT 1
76808: NEG
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: LD_INT 1
76816: PUSH
76817: LD_INT 2
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 0
76826: PUSH
76827: LD_INT 2
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 1
76836: NEG
76837: PUSH
76838: LD_INT 1
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 1
76847: PUSH
76848: LD_INT 3
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 0
76857: PUSH
76858: LD_INT 3
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 1
76867: NEG
76868: PUSH
76869: LD_INT 2
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: LIST
76880: LIST
76881: LIST
76882: LIST
76883: LIST
76884: LIST
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76894: LD_ADDR_VAR 0 12
76898: PUSH
76899: LD_INT 0
76901: PUSH
76902: LD_INT 0
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 0
76911: PUSH
76912: LD_INT 1
76914: NEG
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: LD_INT 0
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 1
76932: PUSH
76933: LD_INT 1
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 0
76942: PUSH
76943: LD_INT 1
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 1
76952: NEG
76953: PUSH
76954: LD_INT 0
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: LD_INT 1
76967: NEG
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 1
76975: PUSH
76976: LD_INT 1
76978: NEG
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 2
76986: PUSH
76987: LD_INT 0
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 2
76996: PUSH
76997: LD_INT 1
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: LD_INT 1
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 2
77017: NEG
77018: PUSH
77019: LD_INT 0
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 2
77028: NEG
77029: PUSH
77030: LD_INT 1
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 2
77040: NEG
77041: PUSH
77042: LD_INT 1
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 3
77051: NEG
77052: PUSH
77053: LD_INT 0
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 3
77062: NEG
77063: PUSH
77064: LD_INT 1
77066: NEG
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77090: LD_ADDR_VAR 0 13
77094: PUSH
77095: LD_INT 0
77097: PUSH
77098: LD_INT 0
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: LD_INT 1
77110: NEG
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: LD_INT 0
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 1
77128: PUSH
77129: LD_INT 1
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 0
77138: PUSH
77139: LD_INT 1
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PUSH
77146: LD_INT 1
77148: NEG
77149: PUSH
77150: LD_INT 0
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 1
77159: NEG
77160: PUSH
77161: LD_INT 1
77163: NEG
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 1
77171: NEG
77172: PUSH
77173: LD_INT 2
77175: NEG
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 2
77183: PUSH
77184: LD_INT 1
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 2
77193: PUSH
77194: LD_INT 2
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: LD_INT 1
77203: PUSH
77204: LD_INT 2
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 2
77213: NEG
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 2
77225: NEG
77226: PUSH
77227: LD_INT 2
77229: NEG
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 2
77237: NEG
77238: PUSH
77239: LD_INT 3
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 3
77249: NEG
77250: PUSH
77251: LD_INT 2
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 3
77261: NEG
77262: PUSH
77263: LD_INT 3
77265: NEG
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77289: LD_ADDR_VAR 0 14
77293: PUSH
77294: LD_INT 0
77296: PUSH
77297: LD_INT 0
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 0
77306: PUSH
77307: LD_INT 1
77309: NEG
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 1
77317: PUSH
77318: LD_INT 0
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 1
77327: PUSH
77328: LD_INT 1
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: LD_INT 1
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 1
77347: NEG
77348: PUSH
77349: LD_INT 0
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 1
77358: NEG
77359: PUSH
77360: LD_INT 1
77362: NEG
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 1
77370: NEG
77371: PUSH
77372: LD_INT 2
77374: NEG
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 0
77382: PUSH
77383: LD_INT 2
77385: NEG
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 1
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 1
77404: PUSH
77405: LD_INT 2
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 0
77414: PUSH
77415: LD_INT 2
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 1
77424: NEG
77425: PUSH
77426: LD_INT 1
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 1
77435: NEG
77436: PUSH
77437: LD_INT 3
77439: NEG
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 0
77447: PUSH
77448: LD_INT 3
77450: NEG
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 1
77458: PUSH
77459: LD_INT 2
77461: NEG
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77485: LD_ADDR_VAR 0 15
77489: PUSH
77490: LD_INT 0
77492: PUSH
77493: LD_INT 0
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 0
77502: PUSH
77503: LD_INT 1
77505: NEG
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 1
77513: PUSH
77514: LD_INT 0
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 1
77523: PUSH
77524: LD_INT 1
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 0
77533: PUSH
77534: LD_INT 1
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 1
77543: NEG
77544: PUSH
77545: LD_INT 0
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 1
77554: NEG
77555: PUSH
77556: LD_INT 1
77558: NEG
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 1
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 2
77577: PUSH
77578: LD_INT 0
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 2
77587: PUSH
77588: LD_INT 1
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 1
77597: NEG
77598: PUSH
77599: LD_INT 1
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 2
77608: NEG
77609: PUSH
77610: LD_INT 0
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 2
77619: NEG
77620: PUSH
77621: LD_INT 1
77623: NEG
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 2
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 3
77642: PUSH
77643: LD_INT 0
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 3
77652: PUSH
77653: LD_INT 1
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77678: LD_ADDR_VAR 0 16
77682: PUSH
77683: LD_INT 0
77685: PUSH
77686: LD_INT 0
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 0
77695: PUSH
77696: LD_INT 1
77698: NEG
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PUSH
77704: LD_INT 1
77706: PUSH
77707: LD_INT 0
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 1
77716: PUSH
77717: LD_INT 1
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 0
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 1
77736: NEG
77737: PUSH
77738: LD_INT 0
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 1
77747: NEG
77748: PUSH
77749: LD_INT 1
77751: NEG
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 1
77759: NEG
77760: PUSH
77761: LD_INT 2
77763: NEG
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 2
77771: PUSH
77772: LD_INT 1
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 2
77781: PUSH
77782: LD_INT 2
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 1
77791: PUSH
77792: LD_INT 2
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 2
77801: NEG
77802: PUSH
77803: LD_INT 1
77805: NEG
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 2
77813: NEG
77814: PUSH
77815: LD_INT 2
77817: NEG
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 3
77825: PUSH
77826: LD_INT 2
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: LD_INT 3
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 2
77845: PUSH
77846: LD_INT 3
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: LIST
77860: LIST
77861: LIST
77862: LIST
77863: LIST
77864: LIST
77865: LIST
77866: LIST
77867: LIST
77868: LIST
77869: LIST
77870: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77871: LD_ADDR_VAR 0 17
77875: PUSH
77876: LD_INT 0
77878: PUSH
77879: LD_INT 0
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: LD_INT 1
77891: NEG
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 1
77899: PUSH
77900: LD_INT 0
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: PUSH
77907: LD_INT 1
77909: PUSH
77910: LD_INT 1
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 0
77919: PUSH
77920: LD_INT 1
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 1
77929: NEG
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 1
77940: NEG
77941: PUSH
77942: LD_INT 1
77944: NEG
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 1
77952: NEG
77953: PUSH
77954: LD_INT 2
77956: NEG
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 0
77964: PUSH
77965: LD_INT 2
77967: NEG
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 1
77975: PUSH
77976: LD_INT 1
77978: NEG
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 2
77986: PUSH
77987: LD_INT 0
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: LD_INT 2
77996: PUSH
77997: LD_INT 1
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 2
78006: PUSH
78007: LD_INT 2
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: LD_INT 1
78016: PUSH
78017: LD_INT 2
78019: PUSH
78020: EMPTY
78021: LIST
78022: LIST
78023: PUSH
78024: LD_INT 0
78026: PUSH
78027: LD_INT 2
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: PUSH
78034: LD_INT 1
78036: NEG
78037: PUSH
78038: LD_INT 1
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: PUSH
78045: LD_INT 2
78047: NEG
78048: PUSH
78049: LD_INT 0
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 2
78058: NEG
78059: PUSH
78060: LD_INT 1
78062: NEG
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 2
78070: NEG
78071: PUSH
78072: LD_INT 2
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: LIST
78084: LIST
78085: LIST
78086: LIST
78087: LIST
78088: LIST
78089: LIST
78090: LIST
78091: LIST
78092: LIST
78093: LIST
78094: LIST
78095: LIST
78096: LIST
78097: LIST
78098: LIST
78099: LIST
78100: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78101: LD_ADDR_VAR 0 18
78105: PUSH
78106: LD_INT 0
78108: PUSH
78109: LD_INT 0
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: LD_INT 1
78121: NEG
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 1
78129: PUSH
78130: LD_INT 0
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: LD_INT 1
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 0
78149: PUSH
78150: LD_INT 1
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: PUSH
78157: LD_INT 1
78159: NEG
78160: PUSH
78161: LD_INT 0
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 1
78170: NEG
78171: PUSH
78172: LD_INT 1
78174: NEG
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 1
78182: NEG
78183: PUSH
78184: LD_INT 2
78186: NEG
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 0
78194: PUSH
78195: LD_INT 2
78197: NEG
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 1
78205: PUSH
78206: LD_INT 1
78208: NEG
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 2
78216: PUSH
78217: LD_INT 0
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 2
78226: PUSH
78227: LD_INT 1
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PUSH
78234: LD_INT 2
78236: PUSH
78237: LD_INT 2
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 1
78246: PUSH
78247: LD_INT 2
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 0
78256: PUSH
78257: LD_INT 2
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 1
78266: NEG
78267: PUSH
78268: LD_INT 1
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: PUSH
78275: LD_INT 2
78277: NEG
78278: PUSH
78279: LD_INT 0
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 2
78288: NEG
78289: PUSH
78290: LD_INT 1
78292: NEG
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 2
78300: NEG
78301: PUSH
78302: LD_INT 2
78304: NEG
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: LIST
78317: LIST
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: LIST
78323: LIST
78324: LIST
78325: LIST
78326: LIST
78327: LIST
78328: LIST
78329: LIST
78330: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78331: LD_ADDR_VAR 0 19
78335: PUSH
78336: LD_INT 0
78338: PUSH
78339: LD_INT 0
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: LD_INT 1
78351: NEG
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 1
78359: PUSH
78360: LD_INT 0
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: LD_INT 1
78369: PUSH
78370: LD_INT 1
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 0
78379: PUSH
78380: LD_INT 1
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 1
78389: NEG
78390: PUSH
78391: LD_INT 0
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 1
78400: NEG
78401: PUSH
78402: LD_INT 1
78404: NEG
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 1
78412: NEG
78413: PUSH
78414: LD_INT 2
78416: NEG
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: LD_INT 2
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 1
78435: PUSH
78436: LD_INT 1
78438: NEG
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 2
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 2
78456: PUSH
78457: LD_INT 1
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: PUSH
78464: LD_INT 2
78466: PUSH
78467: LD_INT 2
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 1
78476: PUSH
78477: LD_INT 2
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: LD_INT 2
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 1
78496: NEG
78497: PUSH
78498: LD_INT 1
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 2
78507: NEG
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 2
78518: NEG
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 2
78530: NEG
78531: PUSH
78532: LD_INT 2
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78561: LD_ADDR_VAR 0 20
78565: PUSH
78566: LD_INT 0
78568: PUSH
78569: LD_INT 0
78571: PUSH
78572: EMPTY
78573: LIST
78574: LIST
78575: PUSH
78576: LD_INT 0
78578: PUSH
78579: LD_INT 1
78581: NEG
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 1
78589: PUSH
78590: LD_INT 0
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: LD_INT 1
78599: PUSH
78600: LD_INT 1
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 0
78609: PUSH
78610: LD_INT 1
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 1
78619: NEG
78620: PUSH
78621: LD_INT 0
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 1
78630: NEG
78631: PUSH
78632: LD_INT 1
78634: NEG
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 1
78642: NEG
78643: PUSH
78644: LD_INT 2
78646: NEG
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: LD_INT 2
78657: NEG
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 1
78665: PUSH
78666: LD_INT 1
78668: NEG
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 2
78676: PUSH
78677: LD_INT 0
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 2
78686: PUSH
78687: LD_INT 1
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 2
78696: PUSH
78697: LD_INT 2
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 1
78706: PUSH
78707: LD_INT 2
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 0
78716: PUSH
78717: LD_INT 2
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 1
78726: NEG
78727: PUSH
78728: LD_INT 1
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: PUSH
78735: LD_INT 2
78737: NEG
78738: PUSH
78739: LD_INT 0
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 2
78748: NEG
78749: PUSH
78750: LD_INT 1
78752: NEG
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 2
78760: NEG
78761: PUSH
78762: LD_INT 2
78764: NEG
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78791: LD_ADDR_VAR 0 21
78795: PUSH
78796: LD_INT 0
78798: PUSH
78799: LD_INT 0
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: LD_INT 1
78811: NEG
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 1
78819: PUSH
78820: LD_INT 0
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 1
78829: PUSH
78830: LD_INT 1
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 0
78839: PUSH
78840: LD_INT 1
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 1
78849: NEG
78850: PUSH
78851: LD_INT 0
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 1
78860: NEG
78861: PUSH
78862: LD_INT 1
78864: NEG
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 1
78872: NEG
78873: PUSH
78874: LD_INT 2
78876: NEG
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 0
78884: PUSH
78885: LD_INT 2
78887: NEG
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 1
78895: PUSH
78896: LD_INT 1
78898: NEG
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 2
78906: PUSH
78907: LD_INT 0
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 2
78916: PUSH
78917: LD_INT 1
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 2
78926: PUSH
78927: LD_INT 2
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 1
78936: PUSH
78937: LD_INT 2
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 0
78946: PUSH
78947: LD_INT 2
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 1
78956: NEG
78957: PUSH
78958: LD_INT 1
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 2
78967: NEG
78968: PUSH
78969: LD_INT 0
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 2
78978: NEG
78979: PUSH
78980: LD_INT 1
78982: NEG
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: LD_INT 2
78990: NEG
78991: PUSH
78992: LD_INT 2
78994: NEG
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79021: LD_ADDR_VAR 0 22
79025: PUSH
79026: LD_INT 0
79028: PUSH
79029: LD_INT 0
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: LD_INT 1
79041: NEG
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 1
79049: PUSH
79050: LD_INT 0
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 1
79059: PUSH
79060: LD_INT 1
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 0
79069: PUSH
79070: LD_INT 1
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 1
79079: NEG
79080: PUSH
79081: LD_INT 0
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: LD_INT 1
79094: NEG
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 1
79102: NEG
79103: PUSH
79104: LD_INT 2
79106: NEG
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 0
79114: PUSH
79115: LD_INT 2
79117: NEG
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 1
79125: PUSH
79126: LD_INT 1
79128: NEG
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 2
79136: PUSH
79137: LD_INT 0
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 2
79146: PUSH
79147: LD_INT 1
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 2
79156: PUSH
79157: LD_INT 2
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: LD_INT 2
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 1
79186: NEG
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 2
79197: NEG
79198: PUSH
79199: LD_INT 0
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 2
79208: NEG
79209: PUSH
79210: LD_INT 1
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 2
79220: NEG
79221: PUSH
79222: LD_INT 2
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79251: LD_ADDR_VAR 0 23
79255: PUSH
79256: LD_INT 0
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 0
79268: PUSH
79269: LD_INT 1
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 1
79279: PUSH
79280: LD_INT 0
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 1
79289: PUSH
79290: LD_INT 1
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 0
79299: PUSH
79300: LD_INT 1
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 1
79309: NEG
79310: PUSH
79311: LD_INT 0
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 1
79320: NEG
79321: PUSH
79322: LD_INT 1
79324: NEG
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 1
79332: NEG
79333: PUSH
79334: LD_INT 2
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: LD_INT 0
79344: PUSH
79345: LD_INT 2
79347: NEG
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 1
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 2
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 2
79376: PUSH
79377: LD_INT 1
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 2
79386: PUSH
79387: LD_INT 2
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 1
79396: PUSH
79397: LD_INT 2
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 0
79406: PUSH
79407: LD_INT 2
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 1
79416: NEG
79417: PUSH
79418: LD_INT 1
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 2
79427: NEG
79428: PUSH
79429: LD_INT 0
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 2
79438: NEG
79439: PUSH
79440: LD_INT 1
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 2
79450: NEG
79451: PUSH
79452: LD_INT 2
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 2
79462: NEG
79463: PUSH
79464: LD_INT 3
79466: NEG
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: LD_INT 1
79474: NEG
79475: PUSH
79476: LD_INT 3
79478: NEG
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: LD_INT 1
79486: PUSH
79487: LD_INT 2
79489: NEG
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 2
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
79531: LD_ADDR_VAR 0 24
79535: PUSH
79536: LD_INT 0
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 0
79548: PUSH
79549: LD_INT 1
79551: NEG
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 1
79559: PUSH
79560: LD_INT 0
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 1
79569: PUSH
79570: LD_INT 1
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 0
79579: PUSH
79580: LD_INT 1
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 1
79589: NEG
79590: PUSH
79591: LD_INT 0
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 1
79600: NEG
79601: PUSH
79602: LD_INT 1
79604: NEG
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: LD_INT 1
79612: NEG
79613: PUSH
79614: LD_INT 2
79616: NEG
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 0
79624: PUSH
79625: LD_INT 2
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: LD_INT 1
79638: NEG
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PUSH
79644: LD_INT 2
79646: PUSH
79647: LD_INT 0
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PUSH
79654: LD_INT 2
79656: PUSH
79657: LD_INT 1
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 2
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 1
79676: PUSH
79677: LD_INT 2
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: LD_INT 2
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 1
79696: NEG
79697: PUSH
79698: LD_INT 1
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 2
79707: NEG
79708: PUSH
79709: LD_INT 0
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 2
79718: NEG
79719: PUSH
79720: LD_INT 1
79722: NEG
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 2
79730: NEG
79731: PUSH
79732: LD_INT 2
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 1
79742: PUSH
79743: LD_INT 2
79745: NEG
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: LD_INT 2
79753: PUSH
79754: LD_INT 1
79756: NEG
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 3
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 3
79774: PUSH
79775: LD_INT 2
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: LIST
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
79807: LD_ADDR_VAR 0 25
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: LD_INT 1
79827: NEG
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: LD_INT 0
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: LD_INT 1
79845: PUSH
79846: LD_INT 1
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 0
79855: PUSH
79856: LD_INT 1
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 1
79865: NEG
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 1
79876: NEG
79877: PUSH
79878: LD_INT 1
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: LD_INT 2
79892: NEG
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 2
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: LD_INT 1
79914: NEG
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 2
79922: PUSH
79923: LD_INT 0
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 2
79932: PUSH
79933: LD_INT 1
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 2
79942: PUSH
79943: LD_INT 2
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: LD_INT 2
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 1
79972: NEG
79973: PUSH
79974: LD_INT 1
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 2
79983: NEG
79984: PUSH
79985: LD_INT 0
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: LD_INT 2
79994: NEG
79995: PUSH
79996: LD_INT 1
79998: NEG
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: PUSH
80004: LD_INT 2
80006: NEG
80007: PUSH
80008: LD_INT 2
80010: NEG
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 3
80018: PUSH
80019: LD_INT 1
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 3
80028: PUSH
80029: LD_INT 2
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 2
80038: PUSH
80039: LD_INT 3
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 1
80048: PUSH
80049: LD_INT 3
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80081: LD_ADDR_VAR 0 26
80085: PUSH
80086: LD_INT 0
80088: PUSH
80089: LD_INT 0
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 0
80098: PUSH
80099: LD_INT 1
80101: NEG
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 1
80109: PUSH
80110: LD_INT 0
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: PUSH
80117: LD_INT 1
80119: PUSH
80120: LD_INT 1
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 0
80129: PUSH
80130: LD_INT 1
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 1
80139: NEG
80140: PUSH
80141: LD_INT 0
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 1
80150: NEG
80151: PUSH
80152: LD_INT 1
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 1
80162: NEG
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 0
80174: PUSH
80175: LD_INT 2
80177: NEG
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 1
80185: PUSH
80186: LD_INT 1
80188: NEG
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 2
80196: PUSH
80197: LD_INT 0
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 2
80206: PUSH
80207: LD_INT 1
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 2
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 1
80226: PUSH
80227: LD_INT 2
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: PUSH
80234: LD_INT 0
80236: PUSH
80237: LD_INT 2
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 1
80246: NEG
80247: PUSH
80248: LD_INT 1
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 2
80257: NEG
80258: PUSH
80259: LD_INT 0
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 2
80268: NEG
80269: PUSH
80270: LD_INT 1
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 2
80280: NEG
80281: PUSH
80282: LD_INT 2
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: LD_INT 3
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 1
80302: PUSH
80303: LD_INT 3
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 1
80312: NEG
80313: PUSH
80314: LD_INT 2
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 2
80323: NEG
80324: PUSH
80325: LD_INT 1
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80357: LD_ADDR_VAR 0 27
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: LD_INT 0
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: LD_INT 1
80377: NEG
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 1
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 1
80395: PUSH
80396: LD_INT 1
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: NEG
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 1
80426: NEG
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: LD_INT 2
80442: NEG
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: PUSH
80448: LD_INT 0
80450: PUSH
80451: LD_INT 2
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 1
80461: PUSH
80462: LD_INT 1
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 2
80472: PUSH
80473: LD_INT 0
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 2
80482: PUSH
80483: LD_INT 1
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 2
80492: PUSH
80493: LD_INT 2
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: LD_INT 1
80502: PUSH
80503: LD_INT 2
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 0
80512: PUSH
80513: LD_INT 2
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 1
80522: NEG
80523: PUSH
80524: LD_INT 1
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 2
80533: NEG
80534: PUSH
80535: LD_INT 0
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 2
80544: NEG
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 2
80556: NEG
80557: PUSH
80558: LD_INT 2
80560: NEG
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 1
80568: NEG
80569: PUSH
80570: LD_INT 2
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 2
80579: NEG
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 3
80590: NEG
80591: PUSH
80592: LD_INT 1
80594: NEG
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 3
80602: NEG
80603: PUSH
80604: LD_INT 2
80606: NEG
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80637: LD_ADDR_VAR 0 28
80641: PUSH
80642: LD_INT 0
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 1
80665: PUSH
80666: LD_INT 0
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: PUSH
80676: LD_INT 1
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 0
80685: PUSH
80686: LD_INT 1
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 1
80695: NEG
80696: PUSH
80697: LD_INT 0
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 1
80706: NEG
80707: PUSH
80708: LD_INT 1
80710: NEG
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 1
80718: NEG
80719: PUSH
80720: LD_INT 2
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 0
80730: PUSH
80731: LD_INT 2
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 1
80741: PUSH
80742: LD_INT 1
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 2
80752: PUSH
80753: LD_INT 0
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: PUSH
80760: LD_INT 2
80762: PUSH
80763: LD_INT 1
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 2
80772: PUSH
80773: LD_INT 2
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: LD_INT 2
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: LD_INT 2
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: LD_INT 1
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 2
80813: NEG
80814: PUSH
80815: LD_INT 0
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 2
80824: NEG
80825: PUSH
80826: LD_INT 1
80828: NEG
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 2
80836: NEG
80837: PUSH
80838: LD_INT 2
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: LD_INT 3
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 1
80860: NEG
80861: PUSH
80862: LD_INT 3
80864: NEG
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 3
80872: NEG
80873: PUSH
80874: LD_INT 1
80876: NEG
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 3
80884: NEG
80885: PUSH
80886: LD_INT 2
80888: NEG
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80919: LD_ADDR_VAR 0 29
80923: PUSH
80924: LD_INT 0
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 0
80936: PUSH
80937: LD_INT 1
80939: NEG
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 1
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 1
80957: PUSH
80958: LD_INT 1
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 0
80967: PUSH
80968: LD_INT 1
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 1
80977: NEG
80978: PUSH
80979: LD_INT 0
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 1
80988: NEG
80989: PUSH
80990: LD_INT 1
80992: NEG
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PUSH
80998: LD_INT 1
81000: NEG
81001: PUSH
81002: LD_INT 2
81004: NEG
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 0
81012: PUSH
81013: LD_INT 2
81015: NEG
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 1
81023: PUSH
81024: LD_INT 1
81026: NEG
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 2
81034: PUSH
81035: LD_INT 0
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 2
81044: PUSH
81045: LD_INT 1
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 1
81054: PUSH
81055: LD_INT 2
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 0
81064: PUSH
81065: LD_INT 2
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 1
81074: NEG
81075: PUSH
81076: LD_INT 1
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 2
81085: NEG
81086: PUSH
81087: LD_INT 1
81089: NEG
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 2
81097: NEG
81098: PUSH
81099: LD_INT 2
81101: NEG
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: LD_INT 3
81113: NEG
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 2
81121: PUSH
81122: LD_INT 1
81124: NEG
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 3
81132: PUSH
81133: LD_INT 1
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 1
81142: PUSH
81143: LD_INT 3
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 1
81152: NEG
81153: PUSH
81154: LD_INT 2
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 3
81163: NEG
81164: PUSH
81165: LD_INT 2
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81198: LD_ADDR_VAR 0 30
81202: PUSH
81203: LD_INT 0
81205: PUSH
81206: LD_INT 0
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 0
81215: PUSH
81216: LD_INT 1
81218: NEG
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 1
81226: PUSH
81227: LD_INT 0
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 1
81236: PUSH
81237: LD_INT 1
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 0
81246: PUSH
81247: LD_INT 1
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 1
81256: NEG
81257: PUSH
81258: LD_INT 0
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 1
81267: NEG
81268: PUSH
81269: LD_INT 1
81271: NEG
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 1
81279: NEG
81280: PUSH
81281: LD_INT 2
81283: NEG
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 0
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 1
81302: PUSH
81303: LD_INT 1
81305: NEG
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 2
81313: PUSH
81314: LD_INT 0
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 2
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: LD_INT 2
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 1
81343: PUSH
81344: LD_INT 2
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PUSH
81351: LD_INT 1
81353: NEG
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 2
81364: NEG
81365: PUSH
81366: LD_INT 0
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PUSH
81373: LD_INT 2
81375: NEG
81376: PUSH
81377: LD_INT 1
81379: NEG
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 1
81387: NEG
81388: PUSH
81389: LD_INT 3
81391: NEG
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 1
81399: PUSH
81400: LD_INT 2
81402: NEG
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 3
81410: PUSH
81411: LD_INT 2
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: LD_INT 3
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 2
81430: NEG
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 3
81441: NEG
81442: PUSH
81443: LD_INT 1
81445: NEG
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81476: LD_ADDR_VAR 0 31
81480: PUSH
81481: LD_INT 0
81483: PUSH
81484: LD_INT 0
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 0
81493: PUSH
81494: LD_INT 1
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 1
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: LD_INT 1
81514: PUSH
81515: LD_INT 1
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 0
81524: PUSH
81525: LD_INT 1
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 1
81534: NEG
81535: PUSH
81536: LD_INT 0
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: LD_INT 1
81545: NEG
81546: PUSH
81547: LD_INT 1
81549: NEG
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 1
81557: NEG
81558: PUSH
81559: LD_INT 2
81561: NEG
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 1
81572: NEG
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 2
81580: PUSH
81581: LD_INT 0
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 2
81590: PUSH
81591: LD_INT 1
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 2
81600: PUSH
81601: LD_INT 2
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 1
81610: PUSH
81611: LD_INT 2
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 0
81620: PUSH
81621: LD_INT 2
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 1
81630: NEG
81631: PUSH
81632: LD_INT 1
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 2
81653: NEG
81654: PUSH
81655: LD_INT 2
81657: NEG
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 2
81665: NEG
81666: PUSH
81667: LD_INT 3
81669: NEG
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 2
81677: PUSH
81678: LD_INT 1
81680: NEG
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 3
81688: PUSH
81689: LD_INT 1
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 1
81698: PUSH
81699: LD_INT 3
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 1
81708: NEG
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 3
81719: NEG
81720: PUSH
81721: LD_INT 2
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81754: LD_ADDR_VAR 0 32
81758: PUSH
81759: LD_INT 0
81761: PUSH
81762: LD_INT 0
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 0
81771: PUSH
81772: LD_INT 1
81774: NEG
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: PUSH
81783: LD_INT 0
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 1
81792: PUSH
81793: LD_INT 1
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 0
81802: PUSH
81803: LD_INT 1
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: PUSH
81810: LD_INT 1
81812: NEG
81813: PUSH
81814: LD_INT 0
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 1
81823: NEG
81824: PUSH
81825: LD_INT 1
81827: NEG
81828: PUSH
81829: EMPTY
81830: LIST
81831: LIST
81832: PUSH
81833: LD_INT 1
81835: NEG
81836: PUSH
81837: LD_INT 2
81839: NEG
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 0
81847: PUSH
81848: LD_INT 2
81850: NEG
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: LD_INT 1
81861: NEG
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 2
81869: PUSH
81870: LD_INT 1
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 2
81879: PUSH
81880: LD_INT 2
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 1
81889: PUSH
81890: LD_INT 2
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 0
81899: PUSH
81900: LD_INT 2
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 1
81909: NEG
81910: PUSH
81911: LD_INT 1
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 2
81920: NEG
81921: PUSH
81922: LD_INT 0
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 2
81931: NEG
81932: PUSH
81933: LD_INT 1
81935: NEG
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 1
81943: NEG
81944: PUSH
81945: LD_INT 3
81947: NEG
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: LD_INT 2
81958: NEG
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 3
81966: PUSH
81967: LD_INT 2
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 2
81976: PUSH
81977: LD_INT 3
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 2
81986: NEG
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 3
81997: NEG
81998: PUSH
81999: LD_INT 1
82001: NEG
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82032: LD_ADDR_VAR 0 33
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: LD_INT 0
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 0
82049: PUSH
82050: LD_INT 1
82052: NEG
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: LD_INT 0
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 1
82070: PUSH
82071: LD_INT 1
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 0
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 1
82090: NEG
82091: PUSH
82092: LD_INT 0
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 1
82101: NEG
82102: PUSH
82103: LD_INT 1
82105: NEG
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 1
82113: NEG
82114: PUSH
82115: LD_INT 2
82117: NEG
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 1
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 2
82136: PUSH
82137: LD_INT 0
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 2
82146: PUSH
82147: LD_INT 1
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: LD_INT 2
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_INT 0
82166: PUSH
82167: LD_INT 2
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 1
82176: NEG
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 2
82187: NEG
82188: PUSH
82189: LD_INT 0
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 2
82198: NEG
82199: PUSH
82200: LD_INT 1
82202: NEG
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: PUSH
82208: LD_INT 2
82210: NEG
82211: PUSH
82212: LD_INT 2
82214: NEG
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 2
82222: NEG
82223: PUSH
82224: LD_INT 3
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 2
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 3
82245: PUSH
82246: LD_INT 1
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 1
82255: PUSH
82256: LD_INT 3
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: LD_INT 2
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 3
82276: NEG
82277: PUSH
82278: LD_INT 2
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82311: LD_ADDR_VAR 0 34
82315: PUSH
82316: LD_INT 0
82318: PUSH
82319: LD_INT 0
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 0
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 1
82339: PUSH
82340: LD_INT 0
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 1
82349: PUSH
82350: LD_INT 1
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: LD_INT 1
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 1
82369: NEG
82370: PUSH
82371: LD_INT 0
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 1
82380: NEG
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 1
82392: NEG
82393: PUSH
82394: LD_INT 2
82396: NEG
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 0
82404: PUSH
82405: LD_INT 2
82407: NEG
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: LD_INT 1
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 2
82426: PUSH
82427: LD_INT 1
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 2
82436: PUSH
82437: LD_INT 2
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 1
82446: PUSH
82447: LD_INT 2
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: NEG
82457: PUSH
82458: LD_INT 1
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 2
82467: NEG
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: NEG
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 2
82490: NEG
82491: PUSH
82492: LD_INT 2
82494: NEG
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 1
82502: NEG
82503: PUSH
82504: LD_INT 3
82506: NEG
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 1
82514: PUSH
82515: LD_INT 2
82517: NEG
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 3
82525: PUSH
82526: LD_INT 2
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 2
82535: PUSH
82536: LD_INT 3
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 2
82545: NEG
82546: PUSH
82547: LD_INT 1
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 3
82556: NEG
82557: PUSH
82558: LD_INT 1
82560: NEG
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82591: LD_ADDR_VAR 0 35
82595: PUSH
82596: LD_INT 0
82598: PUSH
82599: LD_INT 0
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 0
82608: PUSH
82609: LD_INT 1
82611: NEG
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 1
82619: PUSH
82620: LD_INT 0
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 0
82639: PUSH
82640: LD_INT 1
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 1
82649: NEG
82650: PUSH
82651: LD_INT 0
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 1
82660: NEG
82661: PUSH
82662: LD_INT 1
82664: NEG
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 2
82672: PUSH
82673: LD_INT 1
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 2
82682: NEG
82683: PUSH
82684: LD_INT 1
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
82703: LD_ADDR_VAR 0 36
82707: PUSH
82708: LD_INT 0
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: LD_INT 1
82723: NEG
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 1
82731: PUSH
82732: LD_INT 0
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 1
82741: PUSH
82742: LD_INT 1
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 1
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 1
82761: NEG
82762: PUSH
82763: LD_INT 0
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: NEG
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 1
82784: NEG
82785: PUSH
82786: LD_INT 2
82788: NEG
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 1
82796: PUSH
82797: LD_INT 2
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
82815: LD_ADDR_VAR 0 37
82819: PUSH
82820: LD_INT 0
82822: PUSH
82823: LD_INT 0
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 0
82832: PUSH
82833: LD_INT 1
82835: NEG
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 1
82843: PUSH
82844: LD_INT 0
82846: PUSH
82847: EMPTY
82848: LIST
82849: LIST
82850: PUSH
82851: LD_INT 1
82853: PUSH
82854: LD_INT 1
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 0
82863: PUSH
82864: LD_INT 1
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 1
82873: NEG
82874: PUSH
82875: LD_INT 0
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: LD_INT 1
82888: NEG
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 1
82896: PUSH
82897: LD_INT 1
82899: NEG
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 1
82907: NEG
82908: PUSH
82909: LD_INT 1
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
82927: LD_ADDR_VAR 0 38
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: LD_INT 0
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: LD_INT 1
82947: NEG
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: LD_INT 1
82955: PUSH
82956: LD_INT 0
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 1
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 0
82975: PUSH
82976: LD_INT 1
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 1
82985: NEG
82986: PUSH
82987: LD_INT 0
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: LD_INT 1
83000: NEG
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 2
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 2
83018: NEG
83019: PUSH
83020: LD_INT 1
83022: NEG
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: LIST
83032: LIST
83033: LIST
83034: LIST
83035: LIST
83036: LIST
83037: LIST
83038: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83039: LD_ADDR_VAR 0 39
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: LD_INT 0
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 0
83056: PUSH
83057: LD_INT 1
83059: NEG
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 1
83077: PUSH
83078: LD_INT 1
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 0
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 1
83097: NEG
83098: PUSH
83099: LD_INT 0
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: NEG
83109: PUSH
83110: LD_INT 1
83112: NEG
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PUSH
83118: LD_INT 1
83120: NEG
83121: PUSH
83122: LD_INT 2
83124: NEG
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 1
83132: PUSH
83133: LD_INT 2
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83151: LD_ADDR_VAR 0 40
83155: PUSH
83156: LD_INT 0
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 1
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 1
83189: PUSH
83190: LD_INT 1
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 0
83199: PUSH
83200: LD_INT 1
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 1
83209: NEG
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 1
83220: NEG
83221: PUSH
83222: LD_INT 1
83224: NEG
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: PUSH
83230: LD_INT 1
83232: PUSH
83233: LD_INT 1
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 1
83243: NEG
83244: PUSH
83245: LD_INT 1
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83263: LD_ADDR_VAR 0 41
83267: PUSH
83268: LD_INT 0
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 1
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 1
83301: PUSH
83302: LD_INT 1
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 0
83311: PUSH
83312: LD_INT 1
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: LD_INT 0
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 1
83332: NEG
83333: PUSH
83334: LD_INT 1
83336: NEG
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 1
83344: NEG
83345: PUSH
83346: LD_INT 2
83348: NEG
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 1
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 0
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: LD_INT 1
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 2
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 1
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 2
83418: NEG
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 2
83429: NEG
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 2
83441: NEG
83442: PUSH
83443: LD_INT 2
83445: NEG
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 2
83453: NEG
83454: PUSH
83455: LD_INT 3
83457: NEG
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 2
83465: PUSH
83466: LD_INT 1
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 3
83476: PUSH
83477: LD_INT 0
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 3
83486: PUSH
83487: LD_INT 1
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 3
83496: PUSH
83497: LD_INT 2
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 3
83506: PUSH
83507: LD_INT 3
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 2
83516: PUSH
83517: LD_INT 3
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 2
83526: NEG
83527: PUSH
83528: LD_INT 1
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 3
83537: NEG
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 3
83548: NEG
83549: PUSH
83550: LD_INT 1
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 3
83560: NEG
83561: PUSH
83562: LD_INT 2
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 3
83572: NEG
83573: PUSH
83574: LD_INT 3
83576: NEG
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83613: LD_ADDR_VAR 0 42
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: LD_INT 0
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 1
83633: NEG
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: LD_INT 0
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: PUSH
83652: LD_INT 1
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 0
83661: PUSH
83662: LD_INT 1
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: LD_INT 0
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: NEG
83695: PUSH
83696: LD_INT 2
83698: NEG
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 0
83706: PUSH
83707: LD_INT 2
83709: NEG
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: LD_INT 1
83720: NEG
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: LD_INT 1
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 2
83738: PUSH
83739: LD_INT 2
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: LD_INT 2
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: LD_INT 2
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: LD_INT 1
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 2
83779: NEG
83780: PUSH
83781: LD_INT 1
83783: NEG
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 2
83791: NEG
83792: PUSH
83793: LD_INT 2
83795: NEG
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: LD_INT 2
83803: NEG
83804: PUSH
83805: LD_INT 3
83807: NEG
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 1
83815: NEG
83816: PUSH
83817: LD_INT 3
83819: NEG
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: LD_INT 3
83830: NEG
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: PUSH
83836: LD_INT 1
83838: PUSH
83839: LD_INT 2
83841: NEG
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 3
83849: PUSH
83850: LD_INT 2
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: LD_INT 3
83859: PUSH
83860: LD_INT 3
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 2
83869: PUSH
83870: LD_INT 3
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: LD_INT 3
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 0
83889: PUSH
83890: LD_INT 3
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 1
83899: NEG
83900: PUSH
83901: LD_INT 2
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 3
83910: NEG
83911: PUSH
83912: LD_INT 2
83914: NEG
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: PUSH
83920: LD_INT 3
83922: NEG
83923: PUSH
83924: LD_INT 3
83926: NEG
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83963: LD_ADDR_VAR 0 43
83967: PUSH
83968: LD_INT 0
83970: PUSH
83971: LD_INT 0
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: LD_INT 1
83983: NEG
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 1
83991: PUSH
83992: LD_INT 0
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 1
84001: PUSH
84002: LD_INT 1
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: LD_INT 1
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: LD_INT 1
84021: NEG
84022: PUSH
84023: LD_INT 0
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 1
84032: NEG
84033: PUSH
84034: LD_INT 1
84036: NEG
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 1
84044: NEG
84045: PUSH
84046: LD_INT 2
84048: NEG
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 0
84056: PUSH
84057: LD_INT 2
84059: NEG
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 1
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 2
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 2
84088: PUSH
84089: LD_INT 1
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 1
84098: PUSH
84099: LD_INT 2
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 0
84108: PUSH
84109: LD_INT 2
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: PUSH
84116: LD_INT 1
84118: NEG
84119: PUSH
84120: LD_INT 1
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 2
84129: NEG
84130: PUSH
84131: LD_INT 0
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 2
84140: NEG
84141: PUSH
84142: LD_INT 1
84144: NEG
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: LD_INT 3
84156: NEG
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 0
84164: PUSH
84165: LD_INT 3
84167: NEG
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 1
84175: PUSH
84176: LD_INT 2
84178: NEG
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 2
84186: PUSH
84187: LD_INT 1
84189: NEG
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 3
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 3
84207: PUSH
84208: LD_INT 1
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 1
84217: PUSH
84218: LD_INT 3
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 0
84227: PUSH
84228: LD_INT 3
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 1
84237: NEG
84238: PUSH
84239: LD_INT 2
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: PUSH
84246: LD_INT 2
84248: NEG
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 3
84259: NEG
84260: PUSH
84261: LD_INT 0
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: PUSH
84268: LD_INT 3
84270: NEG
84271: PUSH
84272: LD_INT 1
84274: NEG
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84311: LD_ADDR_VAR 0 44
84315: PUSH
84316: LD_INT 0
84318: PUSH
84319: LD_INT 0
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 0
84328: PUSH
84329: LD_INT 1
84331: NEG
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 1
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 1
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 0
84359: PUSH
84360: LD_INT 1
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 1
84369: NEG
84370: PUSH
84371: LD_INT 0
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: PUSH
84378: LD_INT 1
84380: NEG
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: NEG
84393: PUSH
84394: LD_INT 2
84396: NEG
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 1
84404: PUSH
84405: LD_INT 1
84407: NEG
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: PUSH
84416: LD_INT 0
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: LD_INT 2
84425: PUSH
84426: LD_INT 1
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 2
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 1
84445: PUSH
84446: LD_INT 2
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: LD_INT 1
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: PUSH
84464: LD_INT 2
84466: NEG
84467: PUSH
84468: LD_INT 0
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 2
84477: NEG
84478: PUSH
84479: LD_INT 1
84481: NEG
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 2
84489: NEG
84490: PUSH
84491: LD_INT 2
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: NEG
84502: PUSH
84503: LD_INT 3
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: PUSH
84514: LD_INT 1
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 3
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 3
84534: PUSH
84535: LD_INT 1
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 3
84544: PUSH
84545: LD_INT 2
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: LD_INT 3
84554: PUSH
84555: LD_INT 3
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 2
84564: PUSH
84565: LD_INT 3
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 2
84574: NEG
84575: PUSH
84576: LD_INT 1
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 3
84585: NEG
84586: PUSH
84587: LD_INT 0
84589: PUSH
84590: EMPTY
84591: LIST
84592: LIST
84593: PUSH
84594: LD_INT 3
84596: NEG
84597: PUSH
84598: LD_INT 1
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 3
84608: NEG
84609: PUSH
84610: LD_INT 2
84612: NEG
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 3
84620: NEG
84621: PUSH
84622: LD_INT 3
84624: NEG
84625: PUSH
84626: EMPTY
84627: LIST
84628: LIST
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84661: LD_ADDR_VAR 0 45
84665: PUSH
84666: LD_INT 0
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 0
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: PUSH
84690: LD_INT 0
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 1
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: NEG
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: NEG
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: NEG
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 2
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 1
84768: NEG
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 2
84776: PUSH
84777: LD_INT 1
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 2
84786: PUSH
84787: LD_INT 2
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 1
84796: PUSH
84797: LD_INT 2
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 0
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: NEG
84828: PUSH
84829: LD_INT 1
84831: NEG
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 2
84839: NEG
84840: PUSH
84841: LD_INT 2
84843: NEG
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PUSH
84849: LD_INT 2
84851: NEG
84852: PUSH
84853: LD_INT 3
84855: NEG
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 1
84863: NEG
84864: PUSH
84865: LD_INT 3
84867: NEG
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: LD_INT 3
84878: NEG
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: LD_INT 2
84889: NEG
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 3
84897: PUSH
84898: LD_INT 2
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 3
84907: PUSH
84908: LD_INT 3
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 2
84917: PUSH
84918: LD_INT 3
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: PUSH
84928: LD_INT 3
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 0
84937: PUSH
84938: LD_INT 3
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 1
84947: NEG
84948: PUSH
84949: LD_INT 2
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 3
84958: NEG
84959: PUSH
84960: LD_INT 2
84962: NEG
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PUSH
84968: LD_INT 3
84970: NEG
84971: PUSH
84972: LD_INT 3
84974: NEG
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85011: LD_ADDR_VAR 0 46
85015: PUSH
85016: LD_INT 0
85018: PUSH
85019: LD_INT 0
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PUSH
85026: LD_INT 0
85028: PUSH
85029: LD_INT 1
85031: NEG
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 1
85039: PUSH
85040: LD_INT 0
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 1
85049: PUSH
85050: LD_INT 1
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 0
85059: PUSH
85060: LD_INT 1
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 1
85069: NEG
85070: PUSH
85071: LD_INT 0
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 1
85080: NEG
85081: PUSH
85082: LD_INT 1
85084: NEG
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 1
85092: NEG
85093: PUSH
85094: LD_INT 2
85096: NEG
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: LD_INT 2
85107: NEG
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 1
85115: PUSH
85116: LD_INT 1
85118: NEG
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 2
85126: PUSH
85127: LD_INT 0
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: LD_INT 2
85136: PUSH
85137: LD_INT 1
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 1
85146: PUSH
85147: LD_INT 2
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: LD_INT 2
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 1
85166: NEG
85167: PUSH
85168: LD_INT 1
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 2
85177: NEG
85178: PUSH
85179: LD_INT 0
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 2
85188: NEG
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 1
85200: NEG
85201: PUSH
85202: LD_INT 3
85204: NEG
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 0
85212: PUSH
85213: LD_INT 3
85215: NEG
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 1
85223: PUSH
85224: LD_INT 2
85226: NEG
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 2
85234: PUSH
85235: LD_INT 1
85237: NEG
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 3
85245: PUSH
85246: LD_INT 0
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 3
85255: PUSH
85256: LD_INT 1
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 1
85265: PUSH
85266: LD_INT 3
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 0
85275: PUSH
85276: LD_INT 3
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 1
85285: NEG
85286: PUSH
85287: LD_INT 2
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 2
85296: NEG
85297: PUSH
85298: LD_INT 1
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 3
85307: NEG
85308: PUSH
85309: LD_INT 0
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 3
85318: NEG
85319: PUSH
85320: LD_INT 1
85322: NEG
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85359: LD_ADDR_VAR 0 47
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: LD_INT 0
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 0
85376: PUSH
85377: LD_INT 1
85379: NEG
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: PUSH
85388: LD_INT 0
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PUSH
85395: LD_INT 1
85397: PUSH
85398: LD_INT 1
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 0
85407: PUSH
85408: LD_INT 1
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: PUSH
85415: LD_INT 1
85417: NEG
85418: PUSH
85419: LD_INT 0
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 1
85428: NEG
85429: PUSH
85430: LD_INT 1
85432: NEG
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 1
85440: NEG
85441: PUSH
85442: LD_INT 2
85444: NEG
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 0
85452: PUSH
85453: LD_INT 2
85455: NEG
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 1
85463: PUSH
85464: LD_INT 1
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 2
85474: NEG
85475: PUSH
85476: LD_INT 1
85478: NEG
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 2
85486: NEG
85487: PUSH
85488: LD_INT 2
85490: NEG
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85510: LD_ADDR_VAR 0 48
85514: PUSH
85515: LD_INT 0
85517: PUSH
85518: LD_INT 0
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 0
85527: PUSH
85528: LD_INT 1
85530: NEG
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: LD_INT 0
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 1
85548: PUSH
85549: LD_INT 1
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: LD_INT 1
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: LD_INT 0
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 1
85579: NEG
85580: PUSH
85581: LD_INT 1
85583: NEG
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: LD_INT 2
85595: NEG
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: LD_INT 2
85606: NEG
85607: PUSH
85608: EMPTY
85609: LIST
85610: LIST
85611: PUSH
85612: LD_INT 1
85614: PUSH
85615: LD_INT 1
85617: NEG
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 2
85625: PUSH
85626: LD_INT 0
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PUSH
85633: LD_INT 2
85635: PUSH
85636: LD_INT 1
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85657: LD_ADDR_VAR 0 49
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 0
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 0
85674: PUSH
85675: LD_INT 1
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: LD_INT 0
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 0
85705: PUSH
85706: LD_INT 1
85708: PUSH
85709: EMPTY
85710: LIST
85711: LIST
85712: PUSH
85713: LD_INT 1
85715: NEG
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 1
85726: NEG
85727: PUSH
85728: LD_INT 1
85730: NEG
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: LD_INT 1
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 2
85749: PUSH
85750: LD_INT 0
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 2
85759: PUSH
85760: LD_INT 1
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 2
85769: PUSH
85770: LD_INT 2
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PUSH
85777: LD_INT 1
85779: PUSH
85780: LD_INT 2
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
85801: LD_ADDR_VAR 0 50
85805: PUSH
85806: LD_INT 0
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: EMPTY
85813: LIST
85814: LIST
85815: PUSH
85816: LD_INT 0
85818: PUSH
85819: LD_INT 1
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 1
85829: PUSH
85830: LD_INT 0
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: PUSH
85837: LD_INT 1
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 0
85849: PUSH
85850: LD_INT 1
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 1
85859: NEG
85860: PUSH
85861: LD_INT 0
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 1
85870: NEG
85871: PUSH
85872: LD_INT 1
85874: NEG
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 2
85882: PUSH
85883: LD_INT 1
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 2
85892: PUSH
85893: LD_INT 2
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: PUSH
85903: LD_INT 2
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 2
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 1
85922: NEG
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
85945: LD_ADDR_VAR 0 51
85949: PUSH
85950: LD_INT 0
85952: PUSH
85953: LD_INT 0
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: LD_INT 0
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 1
85973: PUSH
85974: LD_INT 0
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 1
85983: PUSH
85984: LD_INT 1
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 0
85993: PUSH
85994: LD_INT 1
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 1
86003: NEG
86004: PUSH
86005: LD_INT 0
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 1
86014: NEG
86015: PUSH
86016: LD_INT 1
86018: NEG
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: PUSH
86024: LD_INT 1
86026: PUSH
86027: LD_INT 2
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PUSH
86034: LD_INT 0
86036: PUSH
86037: LD_INT 2
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: LD_INT 1
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 2
86057: NEG
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 2
86068: NEG
86069: PUSH
86070: LD_INT 1
86072: NEG
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86092: LD_ADDR_VAR 0 52
86096: PUSH
86097: LD_INT 0
86099: PUSH
86100: LD_INT 0
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 0
86109: PUSH
86110: LD_INT 1
86112: NEG
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 1
86120: PUSH
86121: LD_INT 0
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: PUSH
86128: LD_INT 1
86130: PUSH
86131: LD_INT 1
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: PUSH
86138: LD_INT 0
86140: PUSH
86141: LD_INT 1
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 1
86150: NEG
86151: PUSH
86152: LD_INT 0
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 1
86161: NEG
86162: PUSH
86163: LD_INT 1
86165: NEG
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: LD_INT 1
86173: NEG
86174: PUSH
86175: LD_INT 2
86177: NEG
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: LD_INT 1
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 2
86196: NEG
86197: PUSH
86198: LD_INT 0
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: PUSH
86205: LD_INT 2
86207: NEG
86208: PUSH
86209: LD_INT 1
86211: NEG
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 2
86219: NEG
86220: PUSH
86221: LD_INT 2
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86243: LD_ADDR_VAR 0 53
86247: PUSH
86248: LD_INT 0
86250: PUSH
86251: LD_INT 0
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: LD_INT 1
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: PUSH
86272: LD_INT 0
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 1
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 0
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 1
86301: NEG
86302: PUSH
86303: LD_INT 0
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 1
86312: NEG
86313: PUSH
86314: LD_INT 1
86316: NEG
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: PUSH
86322: LD_INT 1
86324: NEG
86325: PUSH
86326: LD_INT 2
86328: NEG
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: PUSH
86334: LD_INT 0
86336: PUSH
86337: LD_INT 2
86339: NEG
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 1
86347: PUSH
86348: LD_INT 1
86350: NEG
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: PUSH
86356: LD_INT 2
86358: PUSH
86359: LD_INT 0
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 2
86368: PUSH
86369: LD_INT 1
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 2
86378: PUSH
86379: LD_INT 2
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 1
86388: PUSH
86389: LD_INT 2
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 0
86398: PUSH
86399: LD_INT 2
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: LD_INT 1
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 2
86419: NEG
86420: PUSH
86421: LD_INT 0
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 2
86430: NEG
86431: PUSH
86432: LD_INT 1
86434: NEG
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 2
86442: NEG
86443: PUSH
86444: LD_INT 2
86446: NEG
86447: PUSH
86448: EMPTY
86449: LIST
86450: LIST
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86473: LD_ADDR_VAR 0 54
86477: PUSH
86478: LD_INT 0
86480: PUSH
86481: LD_INT 0
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 0
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 1
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 1
86511: PUSH
86512: LD_INT 1
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 0
86521: PUSH
86522: LD_INT 1
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: LD_INT 1
86531: NEG
86532: PUSH
86533: LD_INT 0
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 1
86542: NEG
86543: PUSH
86544: LD_INT 1
86546: NEG
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: LD_INT 1
86554: NEG
86555: PUSH
86556: LD_INT 2
86558: NEG
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 0
86566: PUSH
86567: LD_INT 2
86569: NEG
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 1
86577: PUSH
86578: LD_INT 1
86580: NEG
86581: PUSH
86582: EMPTY
86583: LIST
86584: LIST
86585: PUSH
86586: LD_INT 2
86588: PUSH
86589: LD_INT 0
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 2
86598: PUSH
86599: LD_INT 1
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 2
86608: PUSH
86609: LD_INT 2
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 1
86618: PUSH
86619: LD_INT 2
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 0
86628: PUSH
86629: LD_INT 2
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: LD_INT 1
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 2
86649: NEG
86650: PUSH
86651: LD_INT 0
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 2
86660: NEG
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 2
86672: NEG
86673: PUSH
86674: LD_INT 2
86676: NEG
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86703: LD_ADDR_VAR 0 55
86707: PUSH
86708: LD_INT 0
86710: PUSH
86711: LD_INT 0
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 0
86720: PUSH
86721: LD_INT 1
86723: NEG
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 1
86731: PUSH
86732: LD_INT 0
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PUSH
86739: LD_INT 1
86741: PUSH
86742: LD_INT 1
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 0
86751: PUSH
86752: LD_INT 1
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 1
86761: NEG
86762: PUSH
86763: LD_INT 0
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: PUSH
86770: LD_INT 1
86772: NEG
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: LD_INT 2
86788: NEG
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: PUSH
86794: LD_INT 0
86796: PUSH
86797: LD_INT 2
86799: NEG
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 1
86807: PUSH
86808: LD_INT 1
86810: NEG
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 2
86818: PUSH
86819: LD_INT 0
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 2
86828: PUSH
86829: LD_INT 1
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 2
86838: PUSH
86839: LD_INT 2
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 1
86848: PUSH
86849: LD_INT 2
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 0
86858: PUSH
86859: LD_INT 2
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: NEG
86869: PUSH
86870: LD_INT 1
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 2
86879: NEG
86880: PUSH
86881: LD_INT 0
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 2
86890: NEG
86891: PUSH
86892: LD_INT 1
86894: NEG
86895: PUSH
86896: EMPTY
86897: LIST
86898: LIST
86899: PUSH
86900: LD_INT 2
86902: NEG
86903: PUSH
86904: LD_INT 2
86906: NEG
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86933: LD_ADDR_VAR 0 56
86937: PUSH
86938: LD_INT 0
86940: PUSH
86941: LD_INT 0
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 0
86950: PUSH
86951: LD_INT 1
86953: NEG
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: PUSH
86962: LD_INT 0
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 1
86971: PUSH
86972: LD_INT 1
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 0
86981: PUSH
86982: LD_INT 1
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 1
86991: NEG
86992: PUSH
86993: LD_INT 0
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 1
87002: NEG
87003: PUSH
87004: LD_INT 1
87006: NEG
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 1
87014: NEG
87015: PUSH
87016: LD_INT 2
87018: NEG
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 0
87026: PUSH
87027: LD_INT 2
87029: NEG
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 1
87037: PUSH
87038: LD_INT 1
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 2
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 2
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 2
87068: PUSH
87069: LD_INT 2
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 1
87078: PUSH
87079: LD_INT 2
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 0
87088: PUSH
87089: LD_INT 2
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 1
87098: NEG
87099: PUSH
87100: LD_INT 1
87102: PUSH
87103: EMPTY
87104: LIST
87105: LIST
87106: PUSH
87107: LD_INT 2
87109: NEG
87110: PUSH
87111: LD_INT 0
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: PUSH
87118: LD_INT 2
87120: NEG
87121: PUSH
87122: LD_INT 1
87124: NEG
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 2
87132: NEG
87133: PUSH
87134: LD_INT 2
87136: NEG
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: LIST
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87163: LD_ADDR_VAR 0 57
87167: PUSH
87168: LD_INT 0
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 0
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 1
87191: PUSH
87192: LD_INT 0
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 1
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 0
87211: PUSH
87212: LD_INT 1
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 1
87221: NEG
87222: PUSH
87223: LD_INT 0
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: NEG
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 1
87244: NEG
87245: PUSH
87246: LD_INT 2
87248: NEG
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: LD_INT 2
87259: NEG
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: LD_INT 1
87270: NEG
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 2
87278: PUSH
87279: LD_INT 0
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 2
87288: PUSH
87289: LD_INT 1
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 2
87298: PUSH
87299: LD_INT 2
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 1
87308: PUSH
87309: LD_INT 2
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 0
87318: PUSH
87319: LD_INT 2
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 1
87328: NEG
87329: PUSH
87330: LD_INT 1
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 2
87339: NEG
87340: PUSH
87341: LD_INT 0
87343: PUSH
87344: EMPTY
87345: LIST
87346: LIST
87347: PUSH
87348: LD_INT 2
87350: NEG
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 2
87362: NEG
87363: PUSH
87364: LD_INT 2
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87393: LD_ADDR_VAR 0 58
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: LD_INT 1
87413: NEG
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: PUSH
87432: LD_INT 1
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 0
87441: PUSH
87442: LD_INT 1
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 1
87451: NEG
87452: PUSH
87453: LD_INT 0
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 2
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 0
87486: PUSH
87487: LD_INT 2
87489: NEG
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: LD_INT 1
87500: NEG
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 2
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: LD_INT 2
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 1
87538: PUSH
87539: LD_INT 2
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 0
87548: PUSH
87549: LD_INT 2
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 1
87558: NEG
87559: PUSH
87560: LD_INT 1
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 2
87569: NEG
87570: PUSH
87571: LD_INT 0
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 2
87580: NEG
87581: PUSH
87582: LD_INT 1
87584: NEG
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 2
87592: NEG
87593: PUSH
87594: LD_INT 2
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87623: LD_ADDR_VAR 0 59
87627: PUSH
87628: LD_INT 0
87630: PUSH
87631: LD_INT 0
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: PUSH
87638: LD_INT 0
87640: PUSH
87641: LD_INT 1
87643: NEG
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 1
87651: PUSH
87652: LD_INT 0
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 1
87661: PUSH
87662: LD_INT 1
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 0
87671: PUSH
87672: LD_INT 1
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 1
87681: NEG
87682: PUSH
87683: LD_INT 0
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: PUSH
87690: LD_INT 1
87692: NEG
87693: PUSH
87694: LD_INT 1
87696: NEG
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87711: LD_ADDR_VAR 0 60
87715: PUSH
87716: LD_INT 0
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 0
87728: PUSH
87729: LD_INT 1
87731: NEG
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 1
87739: PUSH
87740: LD_INT 0
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 1
87749: PUSH
87750: LD_INT 1
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: PUSH
87757: LD_INT 0
87759: PUSH
87760: LD_INT 1
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 1
87769: NEG
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: EMPTY
87775: LIST
87776: LIST
87777: PUSH
87778: LD_INT 1
87780: NEG
87781: PUSH
87782: LD_INT 1
87784: NEG
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87799: LD_ADDR_VAR 0 61
87803: PUSH
87804: LD_INT 0
87806: PUSH
87807: LD_INT 0
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 0
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 1
87827: PUSH
87828: LD_INT 0
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 1
87837: PUSH
87838: LD_INT 1
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 0
87847: PUSH
87848: LD_INT 1
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 1
87857: NEG
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 1
87868: NEG
87869: PUSH
87870: LD_INT 1
87872: NEG
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87887: LD_ADDR_VAR 0 62
87891: PUSH
87892: LD_INT 0
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: LD_INT 1
87907: NEG
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 1
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: LD_INT 1
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: PUSH
87933: LD_INT 0
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 1
87945: NEG
87946: PUSH
87947: LD_INT 0
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: LD_INT 1
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
87975: LD_ADDR_VAR 0 63
87979: PUSH
87980: LD_INT 0
87982: PUSH
87983: LD_INT 0
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: LD_INT 1
88003: PUSH
88004: LD_INT 0
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: LD_INT 1
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 0
88023: PUSH
88024: LD_INT 1
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: LD_INT 1
88033: NEG
88034: PUSH
88035: LD_INT 0
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 1
88044: NEG
88045: PUSH
88046: LD_INT 1
88048: NEG
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88063: LD_ADDR_VAR 0 64
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: LD_INT 0
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 0
88080: PUSH
88081: LD_INT 1
88083: NEG
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 1
88091: PUSH
88092: LD_INT 0
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 1
88101: PUSH
88102: LD_INT 1
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: LD_INT 1
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 1
88121: NEG
88122: PUSH
88123: LD_INT 0
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: NEG
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: ST_TO_ADDR
// end ; 1 :
88151: GO 94048
88153: LD_INT 1
88155: DOUBLE
88156: EQUAL
88157: IFTRUE 88161
88159: GO 90784
88161: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88162: LD_ADDR_VAR 0 11
88166: PUSH
88167: LD_INT 1
88169: NEG
88170: PUSH
88171: LD_INT 3
88173: NEG
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 0
88181: PUSH
88182: LD_INT 3
88184: NEG
88185: PUSH
88186: EMPTY
88187: LIST
88188: LIST
88189: PUSH
88190: LD_INT 1
88192: PUSH
88193: LD_INT 2
88195: NEG
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: LIST
88205: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88206: LD_ADDR_VAR 0 12
88210: PUSH
88211: LD_INT 2
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 3
88224: PUSH
88225: LD_INT 0
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 3
88234: PUSH
88235: LD_INT 1
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: LIST
88246: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88247: LD_ADDR_VAR 0 13
88251: PUSH
88252: LD_INT 3
88254: PUSH
88255: LD_INT 2
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 3
88264: PUSH
88265: LD_INT 3
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 2
88274: PUSH
88275: LD_INT 3
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: LIST
88286: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88287: LD_ADDR_VAR 0 14
88291: PUSH
88292: LD_INT 1
88294: PUSH
88295: LD_INT 3
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 0
88304: PUSH
88305: LD_INT 3
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 1
88314: NEG
88315: PUSH
88316: LD_INT 2
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: LIST
88327: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88328: LD_ADDR_VAR 0 15
88332: PUSH
88333: LD_INT 2
88335: NEG
88336: PUSH
88337: LD_INT 1
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 3
88346: NEG
88347: PUSH
88348: LD_INT 0
88350: PUSH
88351: EMPTY
88352: LIST
88353: LIST
88354: PUSH
88355: LD_INT 3
88357: NEG
88358: PUSH
88359: LD_INT 1
88361: NEG
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: LIST
88371: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88372: LD_ADDR_VAR 0 16
88376: PUSH
88377: LD_INT 2
88379: NEG
88380: PUSH
88381: LD_INT 3
88383: NEG
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 3
88391: NEG
88392: PUSH
88393: LD_INT 2
88395: NEG
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 3
88403: NEG
88404: PUSH
88405: LD_INT 3
88407: NEG
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: PUSH
88413: EMPTY
88414: LIST
88415: LIST
88416: LIST
88417: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88418: LD_ADDR_VAR 0 17
88422: PUSH
88423: LD_INT 1
88425: NEG
88426: PUSH
88427: LD_INT 3
88429: NEG
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 0
88437: PUSH
88438: LD_INT 3
88440: NEG
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: LD_INT 2
88451: NEG
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: LIST
88461: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88462: LD_ADDR_VAR 0 18
88466: PUSH
88467: LD_INT 2
88469: PUSH
88470: LD_INT 1
88472: NEG
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 3
88480: PUSH
88481: LD_INT 0
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 3
88490: PUSH
88491: LD_INT 1
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: LIST
88502: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88503: LD_ADDR_VAR 0 19
88507: PUSH
88508: LD_INT 3
88510: PUSH
88511: LD_INT 2
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 3
88520: PUSH
88521: LD_INT 3
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: PUSH
88531: LD_INT 3
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: LIST
88542: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88543: LD_ADDR_VAR 0 20
88547: PUSH
88548: LD_INT 1
88550: PUSH
88551: LD_INT 3
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 0
88560: PUSH
88561: LD_INT 3
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 1
88570: NEG
88571: PUSH
88572: LD_INT 2
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: LIST
88583: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88584: LD_ADDR_VAR 0 21
88588: PUSH
88589: LD_INT 2
88591: NEG
88592: PUSH
88593: LD_INT 1
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 3
88602: NEG
88603: PUSH
88604: LD_INT 0
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 3
88613: NEG
88614: PUSH
88615: LD_INT 1
88617: NEG
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: LIST
88627: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88628: LD_ADDR_VAR 0 22
88632: PUSH
88633: LD_INT 2
88635: NEG
88636: PUSH
88637: LD_INT 3
88639: NEG
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: PUSH
88645: LD_INT 3
88647: NEG
88648: PUSH
88649: LD_INT 2
88651: NEG
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 3
88659: NEG
88660: PUSH
88661: LD_INT 3
88663: NEG
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: LIST
88673: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
88674: LD_ADDR_VAR 0 23
88678: PUSH
88679: LD_INT 0
88681: PUSH
88682: LD_INT 3
88684: NEG
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: LD_INT 4
88696: NEG
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: PUSH
88702: LD_INT 1
88704: PUSH
88705: LD_INT 3
88707: NEG
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: LIST
88717: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
88718: LD_ADDR_VAR 0 24
88722: PUSH
88723: LD_INT 3
88725: PUSH
88726: LD_INT 0
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 3
88735: PUSH
88736: LD_INT 1
88738: NEG
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 4
88746: PUSH
88747: LD_INT 1
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: LIST
88758: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
88759: LD_ADDR_VAR 0 25
88763: PUSH
88764: LD_INT 3
88766: PUSH
88767: LD_INT 3
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 4
88776: PUSH
88777: LD_INT 3
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 3
88786: PUSH
88787: LD_INT 4
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: LIST
88798: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
88799: LD_ADDR_VAR 0 26
88803: PUSH
88804: LD_INT 0
88806: PUSH
88807: LD_INT 3
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 1
88816: PUSH
88817: LD_INT 4
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: PUSH
88828: LD_INT 3
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: LIST
88839: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
88840: LD_ADDR_VAR 0 27
88844: PUSH
88845: LD_INT 3
88847: NEG
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: LD_INT 3
88858: NEG
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 4
88869: NEG
88870: PUSH
88871: LD_INT 1
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: LIST
88883: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
88884: LD_ADDR_VAR 0 28
88888: PUSH
88889: LD_INT 3
88891: NEG
88892: PUSH
88893: LD_INT 3
88895: NEG
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 3
88903: NEG
88904: PUSH
88905: LD_INT 4
88907: NEG
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 4
88915: NEG
88916: PUSH
88917: LD_INT 3
88919: NEG
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: LIST
88929: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
88930: LD_ADDR_VAR 0 29
88934: PUSH
88935: LD_INT 1
88937: NEG
88938: PUSH
88939: LD_INT 3
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 0
88949: PUSH
88950: LD_INT 3
88952: NEG
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 1
88960: PUSH
88961: LD_INT 2
88963: NEG
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 1
88971: NEG
88972: PUSH
88973: LD_INT 4
88975: NEG
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: LD_INT 4
88986: NEG
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PUSH
88992: LD_INT 1
88994: PUSH
88995: LD_INT 3
88997: NEG
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 1
89005: NEG
89006: PUSH
89007: LD_INT 5
89009: NEG
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 0
89017: PUSH
89018: LD_INT 5
89020: NEG
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 1
89028: PUSH
89029: LD_INT 4
89031: NEG
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 1
89039: NEG
89040: PUSH
89041: LD_INT 6
89043: NEG
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 0
89051: PUSH
89052: LD_INT 6
89054: NEG
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: PUSH
89063: LD_INT 5
89065: NEG
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
89085: LD_ADDR_VAR 0 30
89089: PUSH
89090: LD_INT 2
89092: PUSH
89093: LD_INT 1
89095: NEG
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 3
89103: PUSH
89104: LD_INT 0
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 3
89113: PUSH
89114: LD_INT 1
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 3
89123: PUSH
89124: LD_INT 1
89126: NEG
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 4
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 4
89144: PUSH
89145: LD_INT 1
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 4
89154: PUSH
89155: LD_INT 1
89157: NEG
89158: PUSH
89159: EMPTY
89160: LIST
89161: LIST
89162: PUSH
89163: LD_INT 5
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: LD_INT 5
89175: PUSH
89176: LD_INT 1
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 5
89185: PUSH
89186: LD_INT 1
89188: NEG
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 6
89196: PUSH
89197: LD_INT 0
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 6
89206: PUSH
89207: LD_INT 1
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
89228: LD_ADDR_VAR 0 31
89232: PUSH
89233: LD_INT 3
89235: PUSH
89236: LD_INT 2
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 3
89245: PUSH
89246: LD_INT 3
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 2
89255: PUSH
89256: LD_INT 3
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 4
89265: PUSH
89266: LD_INT 3
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: LD_INT 4
89275: PUSH
89276: LD_INT 4
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 3
89285: PUSH
89286: LD_INT 4
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 5
89295: PUSH
89296: LD_INT 4
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 5
89305: PUSH
89306: LD_INT 5
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 4
89315: PUSH
89316: LD_INT 5
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 6
89325: PUSH
89326: LD_INT 5
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 6
89335: PUSH
89336: LD_INT 6
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 5
89345: PUSH
89346: LD_INT 6
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
89367: LD_ADDR_VAR 0 32
89371: PUSH
89372: LD_INT 1
89374: PUSH
89375: LD_INT 3
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 0
89384: PUSH
89385: LD_INT 3
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: LD_INT 1
89394: NEG
89395: PUSH
89396: LD_INT 2
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 1
89405: PUSH
89406: LD_INT 4
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: LD_INT 4
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 1
89425: NEG
89426: PUSH
89427: LD_INT 3
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: LD_INT 5
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 0
89446: PUSH
89447: LD_INT 5
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 1
89456: NEG
89457: PUSH
89458: LD_INT 4
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 1
89467: PUSH
89468: LD_INT 6
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 0
89477: PUSH
89478: LD_INT 6
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 1
89487: NEG
89488: PUSH
89489: LD_INT 5
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
89510: LD_ADDR_VAR 0 33
89514: PUSH
89515: LD_INT 2
89517: NEG
89518: PUSH
89519: LD_INT 1
89521: PUSH
89522: EMPTY
89523: LIST
89524: LIST
89525: PUSH
89526: LD_INT 3
89528: NEG
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: PUSH
89537: LD_INT 3
89539: NEG
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 3
89551: NEG
89552: PUSH
89553: LD_INT 1
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 4
89562: NEG
89563: PUSH
89564: LD_INT 0
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 4
89573: NEG
89574: PUSH
89575: LD_INT 1
89577: NEG
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 4
89585: NEG
89586: PUSH
89587: LD_INT 1
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 5
89596: NEG
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: PUSH
89605: LD_INT 5
89607: NEG
89608: PUSH
89609: LD_INT 1
89611: NEG
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: PUSH
89617: LD_INT 5
89619: NEG
89620: PUSH
89621: LD_INT 1
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 6
89630: NEG
89631: PUSH
89632: LD_INT 0
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: LD_INT 6
89641: NEG
89642: PUSH
89643: LD_INT 1
89645: NEG
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: EMPTY
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
89665: LD_ADDR_VAR 0 34
89669: PUSH
89670: LD_INT 2
89672: NEG
89673: PUSH
89674: LD_INT 3
89676: NEG
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 3
89684: NEG
89685: PUSH
89686: LD_INT 2
89688: NEG
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 3
89696: NEG
89697: PUSH
89698: LD_INT 3
89700: NEG
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 3
89708: NEG
89709: PUSH
89710: LD_INT 4
89712: NEG
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 4
89720: NEG
89721: PUSH
89722: LD_INT 3
89724: NEG
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 4
89732: NEG
89733: PUSH
89734: LD_INT 4
89736: NEG
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 4
89744: NEG
89745: PUSH
89746: LD_INT 5
89748: NEG
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 5
89756: NEG
89757: PUSH
89758: LD_INT 4
89760: NEG
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: PUSH
89766: LD_INT 5
89768: NEG
89769: PUSH
89770: LD_INT 5
89772: NEG
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 5
89780: NEG
89781: PUSH
89782: LD_INT 6
89784: NEG
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 6
89792: NEG
89793: PUSH
89794: LD_INT 5
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 6
89804: NEG
89805: PUSH
89806: LD_INT 6
89808: NEG
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
89828: LD_ADDR_VAR 0 41
89832: PUSH
89833: LD_INT 0
89835: PUSH
89836: LD_INT 2
89838: NEG
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 1
89846: NEG
89847: PUSH
89848: LD_INT 3
89850: NEG
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 1
89858: PUSH
89859: LD_INT 2
89861: NEG
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: EMPTY
89868: LIST
89869: LIST
89870: LIST
89871: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
89872: LD_ADDR_VAR 0 42
89876: PUSH
89877: LD_INT 2
89879: PUSH
89880: LD_INT 0
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 2
89889: PUSH
89890: LD_INT 1
89892: NEG
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 3
89900: PUSH
89901: LD_INT 1
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: LIST
89912: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
89913: LD_ADDR_VAR 0 43
89917: PUSH
89918: LD_INT 2
89920: PUSH
89921: LD_INT 2
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 3
89930: PUSH
89931: LD_INT 2
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: PUSH
89938: LD_INT 2
89940: PUSH
89941: LD_INT 3
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: LIST
89952: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
89953: LD_ADDR_VAR 0 44
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: LD_INT 2
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: LD_INT 1
89970: PUSH
89971: LD_INT 3
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 1
89980: NEG
89981: PUSH
89982: LD_INT 2
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: LIST
89993: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89994: LD_ADDR_VAR 0 45
89998: PUSH
89999: LD_INT 2
90001: NEG
90002: PUSH
90003: LD_INT 0
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 2
90012: NEG
90013: PUSH
90014: LD_INT 1
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 3
90023: NEG
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: LIST
90037: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90038: LD_ADDR_VAR 0 46
90042: PUSH
90043: LD_INT 2
90045: NEG
90046: PUSH
90047: LD_INT 2
90049: NEG
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 2
90057: NEG
90058: PUSH
90059: LD_INT 3
90061: NEG
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 3
90069: NEG
90070: PUSH
90071: LD_INT 2
90073: NEG
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: LIST
90083: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
90084: LD_ADDR_VAR 0 47
90088: PUSH
90089: LD_INT 2
90091: NEG
90092: PUSH
90093: LD_INT 3
90095: NEG
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 1
90103: NEG
90104: PUSH
90105: LD_INT 3
90107: NEG
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
90117: LD_ADDR_VAR 0 48
90121: PUSH
90122: LD_INT 1
90124: PUSH
90125: LD_INT 2
90127: NEG
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 2
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
90148: LD_ADDR_VAR 0 49
90152: PUSH
90153: LD_INT 3
90155: PUSH
90156: LD_INT 1
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 3
90165: PUSH
90166: LD_INT 2
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
90177: LD_ADDR_VAR 0 50
90181: PUSH
90182: LD_INT 2
90184: PUSH
90185: LD_INT 3
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 1
90194: PUSH
90195: LD_INT 3
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
90206: LD_ADDR_VAR 0 51
90210: PUSH
90211: LD_INT 1
90213: NEG
90214: PUSH
90215: LD_INT 2
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 2
90224: NEG
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
90237: LD_ADDR_VAR 0 52
90241: PUSH
90242: LD_INT 3
90244: NEG
90245: PUSH
90246: LD_INT 1
90248: NEG
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 3
90256: NEG
90257: PUSH
90258: LD_INT 2
90260: NEG
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90270: LD_ADDR_VAR 0 53
90274: PUSH
90275: LD_INT 1
90277: NEG
90278: PUSH
90279: LD_INT 3
90281: NEG
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 0
90289: PUSH
90290: LD_INT 3
90292: NEG
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: LD_INT 1
90300: PUSH
90301: LD_INT 2
90303: NEG
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: LIST
90313: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90314: LD_ADDR_VAR 0 54
90318: PUSH
90319: LD_INT 2
90321: PUSH
90322: LD_INT 1
90324: NEG
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 3
90332: PUSH
90333: LD_INT 0
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 3
90342: PUSH
90343: LD_INT 1
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: LIST
90354: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90355: LD_ADDR_VAR 0 55
90359: PUSH
90360: LD_INT 3
90362: PUSH
90363: LD_INT 2
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: PUSH
90370: LD_INT 3
90372: PUSH
90373: LD_INT 3
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: LD_INT 2
90382: PUSH
90383: LD_INT 3
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: LIST
90394: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90395: LD_ADDR_VAR 0 56
90399: PUSH
90400: LD_INT 1
90402: PUSH
90403: LD_INT 3
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 0
90412: PUSH
90413: LD_INT 3
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 1
90422: NEG
90423: PUSH
90424: LD_INT 2
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: LIST
90435: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90436: LD_ADDR_VAR 0 57
90440: PUSH
90441: LD_INT 2
90443: NEG
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 3
90454: NEG
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 3
90465: NEG
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: LIST
90479: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90480: LD_ADDR_VAR 0 58
90484: PUSH
90485: LD_INT 2
90487: NEG
90488: PUSH
90489: LD_INT 3
90491: NEG
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: LD_INT 3
90499: NEG
90500: PUSH
90501: LD_INT 2
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 3
90511: NEG
90512: PUSH
90513: LD_INT 3
90515: NEG
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: LIST
90525: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
90526: LD_ADDR_VAR 0 59
90530: PUSH
90531: LD_INT 1
90533: NEG
90534: PUSH
90535: LD_INT 2
90537: NEG
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: LD_INT 2
90548: NEG
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 1
90556: PUSH
90557: LD_INT 1
90559: NEG
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: LIST
90569: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90570: LD_ADDR_VAR 0 60
90574: PUSH
90575: LD_INT 1
90577: PUSH
90578: LD_INT 1
90580: NEG
90581: PUSH
90582: EMPTY
90583: LIST
90584: LIST
90585: PUSH
90586: LD_INT 2
90588: PUSH
90589: LD_INT 0
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 2
90598: PUSH
90599: LD_INT 1
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: LIST
90610: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90611: LD_ADDR_VAR 0 61
90615: PUSH
90616: LD_INT 2
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 2
90628: PUSH
90629: LD_INT 2
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 1
90638: PUSH
90639: LD_INT 2
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: LIST
90650: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90651: LD_ADDR_VAR 0 62
90655: PUSH
90656: LD_INT 1
90658: PUSH
90659: LD_INT 2
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 0
90668: PUSH
90669: LD_INT 2
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: LD_INT 1
90678: NEG
90679: PUSH
90680: LD_INT 1
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: LIST
90691: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90692: LD_ADDR_VAR 0 63
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 1
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 2
90710: NEG
90711: PUSH
90712: LD_INT 0
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 2
90721: NEG
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: LIST
90735: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90736: LD_ADDR_VAR 0 64
90740: PUSH
90741: LD_INT 1
90743: NEG
90744: PUSH
90745: LD_INT 2
90747: NEG
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: PUSH
90753: LD_INT 2
90755: NEG
90756: PUSH
90757: LD_INT 1
90759: NEG
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 2
90767: NEG
90768: PUSH
90769: LD_INT 2
90771: NEG
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: LIST
90781: ST_TO_ADDR
// end ; 2 :
90782: GO 94048
90784: LD_INT 2
90786: DOUBLE
90787: EQUAL
90788: IFTRUE 90792
90790: GO 94047
90792: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
90793: LD_ADDR_VAR 0 29
90797: PUSH
90798: LD_INT 4
90800: PUSH
90801: LD_INT 0
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 4
90810: PUSH
90811: LD_INT 1
90813: NEG
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 5
90821: PUSH
90822: LD_INT 0
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 5
90831: PUSH
90832: LD_INT 1
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: LD_INT 4
90841: PUSH
90842: LD_INT 1
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: PUSH
90849: LD_INT 3
90851: PUSH
90852: LD_INT 0
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 3
90861: PUSH
90862: LD_INT 1
90864: NEG
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 3
90872: PUSH
90873: LD_INT 2
90875: NEG
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 5
90883: PUSH
90884: LD_INT 2
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 3
90893: PUSH
90894: LD_INT 3
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 3
90903: PUSH
90904: LD_INT 2
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 4
90913: PUSH
90914: LD_INT 3
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 4
90923: PUSH
90924: LD_INT 4
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 3
90933: PUSH
90934: LD_INT 4
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 2
90943: PUSH
90944: LD_INT 3
90946: PUSH
90947: EMPTY
90948: LIST
90949: LIST
90950: PUSH
90951: LD_INT 2
90953: PUSH
90954: LD_INT 2
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 4
90963: PUSH
90964: LD_INT 2
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 2
90973: PUSH
90974: LD_INT 4
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 0
90983: PUSH
90984: LD_INT 4
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 0
90993: PUSH
90994: LD_INT 3
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: PUSH
91001: LD_INT 1
91003: PUSH
91004: LD_INT 4
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 1
91013: PUSH
91014: LD_INT 5
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PUSH
91021: LD_INT 0
91023: PUSH
91024: LD_INT 5
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PUSH
91031: LD_INT 1
91033: NEG
91034: PUSH
91035: LD_INT 4
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 1
91044: NEG
91045: PUSH
91046: LD_INT 3
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 2
91055: PUSH
91056: LD_INT 5
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: PUSH
91063: LD_INT 2
91065: NEG
91066: PUSH
91067: LD_INT 3
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: PUSH
91074: LD_INT 3
91076: NEG
91077: PUSH
91078: LD_INT 0
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: LD_INT 3
91087: NEG
91088: PUSH
91089: LD_INT 1
91091: NEG
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 2
91099: NEG
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 2
91110: NEG
91111: PUSH
91112: LD_INT 1
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 3
91121: NEG
91122: PUSH
91123: LD_INT 1
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: LD_INT 4
91132: NEG
91133: PUSH
91134: LD_INT 0
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 4
91143: NEG
91144: PUSH
91145: LD_INT 1
91147: NEG
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 4
91155: NEG
91156: PUSH
91157: LD_INT 2
91159: NEG
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 2
91167: NEG
91168: PUSH
91169: LD_INT 2
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 4
91178: NEG
91179: PUSH
91180: LD_INT 4
91182: NEG
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: LD_INT 4
91190: NEG
91191: PUSH
91192: LD_INT 5
91194: NEG
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 3
91202: NEG
91203: PUSH
91204: LD_INT 4
91206: NEG
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 3
91214: NEG
91215: PUSH
91216: LD_INT 3
91218: NEG
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 4
91226: NEG
91227: PUSH
91228: LD_INT 3
91230: NEG
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 5
91238: NEG
91239: PUSH
91240: LD_INT 4
91242: NEG
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 5
91250: NEG
91251: PUSH
91252: LD_INT 5
91254: NEG
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 3
91262: NEG
91263: PUSH
91264: LD_INT 5
91266: NEG
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 5
91274: NEG
91275: PUSH
91276: LD_INT 3
91278: NEG
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
91331: LD_ADDR_VAR 0 30
91335: PUSH
91336: LD_INT 4
91338: PUSH
91339: LD_INT 4
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 4
91348: PUSH
91349: LD_INT 3
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 5
91358: PUSH
91359: LD_INT 4
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 5
91368: PUSH
91369: LD_INT 5
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 4
91378: PUSH
91379: LD_INT 5
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 3
91388: PUSH
91389: LD_INT 4
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 3
91398: PUSH
91399: LD_INT 3
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 5
91408: PUSH
91409: LD_INT 3
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 3
91418: PUSH
91419: LD_INT 5
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 0
91428: PUSH
91429: LD_INT 3
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 0
91438: PUSH
91439: LD_INT 2
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: LD_INT 3
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: PUSH
91459: LD_INT 4
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 0
91468: PUSH
91469: LD_INT 4
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 1
91478: NEG
91479: PUSH
91480: LD_INT 3
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 1
91489: NEG
91490: PUSH
91491: LD_INT 2
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 2
91500: PUSH
91501: LD_INT 4
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: LD_INT 2
91510: NEG
91511: PUSH
91512: LD_INT 2
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 4
91521: NEG
91522: PUSH
91523: LD_INT 0
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: LD_INT 4
91532: NEG
91533: PUSH
91534: LD_INT 1
91536: NEG
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: PUSH
91542: LD_INT 3
91544: NEG
91545: PUSH
91546: LD_INT 0
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 3
91555: NEG
91556: PUSH
91557: LD_INT 1
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 4
91566: NEG
91567: PUSH
91568: LD_INT 1
91570: PUSH
91571: EMPTY
91572: LIST
91573: LIST
91574: PUSH
91575: LD_INT 5
91577: NEG
91578: PUSH
91579: LD_INT 0
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 5
91588: NEG
91589: PUSH
91590: LD_INT 1
91592: NEG
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: LD_INT 5
91600: NEG
91601: PUSH
91602: LD_INT 2
91604: NEG
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: PUSH
91610: LD_INT 3
91612: NEG
91613: PUSH
91614: LD_INT 2
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: LD_INT 3
91623: NEG
91624: PUSH
91625: LD_INT 3
91627: NEG
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 3
91635: NEG
91636: PUSH
91637: LD_INT 4
91639: NEG
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 2
91647: NEG
91648: PUSH
91649: LD_INT 3
91651: NEG
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: LD_INT 2
91659: NEG
91660: PUSH
91661: LD_INT 2
91663: NEG
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PUSH
91669: LD_INT 3
91671: NEG
91672: PUSH
91673: LD_INT 2
91675: NEG
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 4
91683: NEG
91684: PUSH
91685: LD_INT 3
91687: NEG
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 4
91695: NEG
91696: PUSH
91697: LD_INT 4
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 2
91707: NEG
91708: PUSH
91709: LD_INT 4
91711: NEG
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 4
91719: NEG
91720: PUSH
91721: LD_INT 2
91723: NEG
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 0
91731: PUSH
91732: LD_INT 4
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 0
91742: PUSH
91743: LD_INT 5
91745: NEG
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: LD_INT 4
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 1
91764: PUSH
91765: LD_INT 3
91767: NEG
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 0
91775: PUSH
91776: LD_INT 3
91778: NEG
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 1
91786: NEG
91787: PUSH
91788: LD_INT 4
91790: NEG
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 1
91798: NEG
91799: PUSH
91800: LD_INT 5
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 2
91810: PUSH
91811: LD_INT 3
91813: NEG
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 2
91821: NEG
91822: PUSH
91823: LD_INT 5
91825: NEG
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: PUSH
91831: EMPTY
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
91878: LD_ADDR_VAR 0 31
91882: PUSH
91883: LD_INT 0
91885: PUSH
91886: LD_INT 4
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: LD_INT 0
91895: PUSH
91896: LD_INT 3
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 1
91905: PUSH
91906: LD_INT 4
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 1
91915: PUSH
91916: LD_INT 5
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 0
91925: PUSH
91926: LD_INT 5
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 1
91935: NEG
91936: PUSH
91937: LD_INT 4
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: PUSH
91944: LD_INT 1
91946: NEG
91947: PUSH
91948: LD_INT 3
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: LD_INT 2
91957: PUSH
91958: LD_INT 5
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: PUSH
91965: LD_INT 2
91967: NEG
91968: PUSH
91969: LD_INT 3
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 3
91978: NEG
91979: PUSH
91980: LD_INT 0
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: PUSH
91987: LD_INT 3
91989: NEG
91990: PUSH
91991: LD_INT 1
91993: NEG
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 2
92001: NEG
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: PUSH
92010: LD_INT 2
92012: NEG
92013: PUSH
92014: LD_INT 1
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 3
92023: NEG
92024: PUSH
92025: LD_INT 1
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: PUSH
92032: LD_INT 4
92034: NEG
92035: PUSH
92036: LD_INT 0
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 4
92045: NEG
92046: PUSH
92047: LD_INT 1
92049: NEG
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 4
92057: NEG
92058: PUSH
92059: LD_INT 2
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: LD_INT 2
92069: NEG
92070: PUSH
92071: LD_INT 2
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: LD_INT 4
92080: NEG
92081: PUSH
92082: LD_INT 4
92084: NEG
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PUSH
92090: LD_INT 4
92092: NEG
92093: PUSH
92094: LD_INT 5
92096: NEG
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: PUSH
92102: LD_INT 3
92104: NEG
92105: PUSH
92106: LD_INT 4
92108: NEG
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 3
92116: NEG
92117: PUSH
92118: LD_INT 3
92120: NEG
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: PUSH
92126: LD_INT 4
92128: NEG
92129: PUSH
92130: LD_INT 3
92132: NEG
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 5
92140: NEG
92141: PUSH
92142: LD_INT 4
92144: NEG
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 5
92152: NEG
92153: PUSH
92154: LD_INT 5
92156: NEG
92157: PUSH
92158: EMPTY
92159: LIST
92160: LIST
92161: PUSH
92162: LD_INT 3
92164: NEG
92165: PUSH
92166: LD_INT 5
92168: NEG
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 5
92176: NEG
92177: PUSH
92178: LD_INT 3
92180: NEG
92181: PUSH
92182: EMPTY
92183: LIST
92184: LIST
92185: PUSH
92186: LD_INT 0
92188: PUSH
92189: LD_INT 3
92191: NEG
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: LD_INT 4
92202: NEG
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: LD_INT 1
92210: PUSH
92211: LD_INT 3
92213: NEG
92214: PUSH
92215: EMPTY
92216: LIST
92217: LIST
92218: PUSH
92219: LD_INT 1
92221: PUSH
92222: LD_INT 2
92224: NEG
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 0
92232: PUSH
92233: LD_INT 2
92235: NEG
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: LD_INT 1
92243: NEG
92244: PUSH
92245: LD_INT 3
92247: NEG
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 1
92255: NEG
92256: PUSH
92257: LD_INT 4
92259: NEG
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 2
92267: PUSH
92268: LD_INT 2
92270: NEG
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 2
92278: NEG
92279: PUSH
92280: LD_INT 4
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 4
92290: PUSH
92291: LD_INT 0
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: LD_INT 4
92300: PUSH
92301: LD_INT 1
92303: NEG
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 5
92311: PUSH
92312: LD_INT 0
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 5
92321: PUSH
92322: LD_INT 1
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 4
92331: PUSH
92332: LD_INT 1
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: LD_INT 3
92341: PUSH
92342: LD_INT 0
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: PUSH
92349: LD_INT 3
92351: PUSH
92352: LD_INT 1
92354: NEG
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 3
92362: PUSH
92363: LD_INT 2
92365: NEG
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: LD_INT 5
92373: PUSH
92374: LD_INT 2
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
92428: LD_ADDR_VAR 0 32
92432: PUSH
92433: LD_INT 4
92435: NEG
92436: PUSH
92437: LD_INT 0
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 4
92446: NEG
92447: PUSH
92448: LD_INT 1
92450: NEG
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 3
92458: NEG
92459: PUSH
92460: LD_INT 0
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 3
92469: NEG
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 4
92480: NEG
92481: PUSH
92482: LD_INT 1
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 5
92491: NEG
92492: PUSH
92493: LD_INT 0
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 5
92502: NEG
92503: PUSH
92504: LD_INT 1
92506: NEG
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 5
92514: NEG
92515: PUSH
92516: LD_INT 2
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 3
92526: NEG
92527: PUSH
92528: LD_INT 2
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 3
92537: NEG
92538: PUSH
92539: LD_INT 3
92541: NEG
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 3
92549: NEG
92550: PUSH
92551: LD_INT 4
92553: NEG
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 2
92561: NEG
92562: PUSH
92563: LD_INT 3
92565: NEG
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 2
92573: NEG
92574: PUSH
92575: LD_INT 2
92577: NEG
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 3
92585: NEG
92586: PUSH
92587: LD_INT 2
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 4
92597: NEG
92598: PUSH
92599: LD_INT 3
92601: NEG
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 4
92609: NEG
92610: PUSH
92611: LD_INT 4
92613: NEG
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 2
92621: NEG
92622: PUSH
92623: LD_INT 4
92625: NEG
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: LD_INT 4
92633: NEG
92634: PUSH
92635: LD_INT 2
92637: NEG
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: PUSH
92643: LD_INT 0
92645: PUSH
92646: LD_INT 4
92648: NEG
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 0
92656: PUSH
92657: LD_INT 5
92659: NEG
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: PUSH
92668: LD_INT 4
92670: NEG
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 1
92678: PUSH
92679: LD_INT 3
92681: NEG
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 0
92689: PUSH
92690: LD_INT 3
92692: NEG
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 1
92700: NEG
92701: PUSH
92702: LD_INT 4
92704: NEG
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 1
92712: NEG
92713: PUSH
92714: LD_INT 5
92716: NEG
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 2
92724: PUSH
92725: LD_INT 3
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 2
92735: NEG
92736: PUSH
92737: LD_INT 5
92739: NEG
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 3
92747: PUSH
92748: LD_INT 0
92750: PUSH
92751: EMPTY
92752: LIST
92753: LIST
92754: PUSH
92755: LD_INT 3
92757: PUSH
92758: LD_INT 1
92760: NEG
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: LD_INT 4
92768: PUSH
92769: LD_INT 0
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 4
92778: PUSH
92779: LD_INT 1
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 3
92788: PUSH
92789: LD_INT 1
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PUSH
92796: LD_INT 2
92798: PUSH
92799: LD_INT 0
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 2
92808: PUSH
92809: LD_INT 1
92811: NEG
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 2
92819: PUSH
92820: LD_INT 2
92822: NEG
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 4
92830: PUSH
92831: LD_INT 2
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 4
92840: PUSH
92841: LD_INT 4
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 4
92850: PUSH
92851: LD_INT 3
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 5
92860: PUSH
92861: LD_INT 4
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 5
92870: PUSH
92871: LD_INT 5
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 4
92880: PUSH
92881: LD_INT 5
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 3
92890: PUSH
92891: LD_INT 4
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 3
92900: PUSH
92901: LD_INT 3
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 5
92910: PUSH
92911: LD_INT 3
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 3
92920: PUSH
92921: LD_INT 5
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
92975: LD_ADDR_VAR 0 33
92979: PUSH
92980: LD_INT 4
92982: NEG
92983: PUSH
92984: LD_INT 4
92986: NEG
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 4
92994: NEG
92995: PUSH
92996: LD_INT 5
92998: NEG
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 3
93006: NEG
93007: PUSH
93008: LD_INT 4
93010: NEG
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: LD_INT 3
93018: NEG
93019: PUSH
93020: LD_INT 3
93022: NEG
93023: PUSH
93024: EMPTY
93025: LIST
93026: LIST
93027: PUSH
93028: LD_INT 4
93030: NEG
93031: PUSH
93032: LD_INT 3
93034: NEG
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 5
93042: NEG
93043: PUSH
93044: LD_INT 4
93046: NEG
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 5
93054: NEG
93055: PUSH
93056: LD_INT 5
93058: NEG
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 3
93066: NEG
93067: PUSH
93068: LD_INT 5
93070: NEG
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 5
93078: NEG
93079: PUSH
93080: LD_INT 3
93082: NEG
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 0
93090: PUSH
93091: LD_INT 3
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 0
93101: PUSH
93102: LD_INT 4
93104: NEG
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 1
93112: PUSH
93113: LD_INT 3
93115: NEG
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: PUSH
93121: LD_INT 1
93123: PUSH
93124: LD_INT 2
93126: NEG
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 0
93134: PUSH
93135: LD_INT 2
93137: NEG
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: PUSH
93143: LD_INT 1
93145: NEG
93146: PUSH
93147: LD_INT 3
93149: NEG
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PUSH
93155: LD_INT 1
93157: NEG
93158: PUSH
93159: LD_INT 4
93161: NEG
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: PUSH
93167: LD_INT 2
93169: PUSH
93170: LD_INT 2
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 2
93180: NEG
93181: PUSH
93182: LD_INT 4
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 4
93192: PUSH
93193: LD_INT 0
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 4
93202: PUSH
93203: LD_INT 1
93205: NEG
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 5
93213: PUSH
93214: LD_INT 0
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: LD_INT 5
93223: PUSH
93224: LD_INT 1
93226: PUSH
93227: EMPTY
93228: LIST
93229: LIST
93230: PUSH
93231: LD_INT 4
93233: PUSH
93234: LD_INT 1
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: LD_INT 3
93243: PUSH
93244: LD_INT 0
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: PUSH
93251: LD_INT 3
93253: PUSH
93254: LD_INT 1
93256: NEG
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 3
93264: PUSH
93265: LD_INT 2
93267: NEG
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 5
93275: PUSH
93276: LD_INT 2
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 3
93285: PUSH
93286: LD_INT 3
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: PUSH
93293: LD_INT 3
93295: PUSH
93296: LD_INT 2
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: PUSH
93303: LD_INT 4
93305: PUSH
93306: LD_INT 3
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 4
93315: PUSH
93316: LD_INT 4
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: LD_INT 3
93325: PUSH
93326: LD_INT 4
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: PUSH
93333: LD_INT 2
93335: PUSH
93336: LD_INT 3
93338: PUSH
93339: EMPTY
93340: LIST
93341: LIST
93342: PUSH
93343: LD_INT 2
93345: PUSH
93346: LD_INT 2
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 4
93355: PUSH
93356: LD_INT 2
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 2
93365: PUSH
93366: LD_INT 4
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: PUSH
93373: LD_INT 0
93375: PUSH
93376: LD_INT 4
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: PUSH
93383: LD_INT 0
93385: PUSH
93386: LD_INT 3
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 1
93395: PUSH
93396: LD_INT 4
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 1
93405: PUSH
93406: LD_INT 5
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 0
93415: PUSH
93416: LD_INT 5
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 1
93425: NEG
93426: PUSH
93427: LD_INT 4
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: PUSH
93434: LD_INT 1
93436: NEG
93437: PUSH
93438: LD_INT 3
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 2
93447: PUSH
93448: LD_INT 5
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 2
93457: NEG
93458: PUSH
93459: LD_INT 3
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
93513: LD_ADDR_VAR 0 34
93517: PUSH
93518: LD_INT 0
93520: PUSH
93521: LD_INT 4
93523: NEG
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: PUSH
93529: LD_INT 0
93531: PUSH
93532: LD_INT 5
93534: NEG
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 1
93542: PUSH
93543: LD_INT 4
93545: NEG
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 1
93553: PUSH
93554: LD_INT 3
93556: NEG
93557: PUSH
93558: EMPTY
93559: LIST
93560: LIST
93561: PUSH
93562: LD_INT 0
93564: PUSH
93565: LD_INT 3
93567: NEG
93568: PUSH
93569: EMPTY
93570: LIST
93571: LIST
93572: PUSH
93573: LD_INT 1
93575: NEG
93576: PUSH
93577: LD_INT 4
93579: NEG
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PUSH
93585: LD_INT 1
93587: NEG
93588: PUSH
93589: LD_INT 5
93591: NEG
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 2
93599: PUSH
93600: LD_INT 3
93602: NEG
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 2
93610: NEG
93611: PUSH
93612: LD_INT 5
93614: NEG
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 3
93622: PUSH
93623: LD_INT 0
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: PUSH
93630: LD_INT 3
93632: PUSH
93633: LD_INT 1
93635: NEG
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 4
93643: PUSH
93644: LD_INT 0
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 4
93653: PUSH
93654: LD_INT 1
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 3
93663: PUSH
93664: LD_INT 1
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 2
93673: PUSH
93674: LD_INT 0
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 2
93683: PUSH
93684: LD_INT 1
93686: NEG
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 2
93694: PUSH
93695: LD_INT 2
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 4
93705: PUSH
93706: LD_INT 2
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: PUSH
93713: LD_INT 4
93715: PUSH
93716: LD_INT 4
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 4
93725: PUSH
93726: LD_INT 3
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: PUSH
93733: LD_INT 5
93735: PUSH
93736: LD_INT 4
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 5
93745: PUSH
93746: LD_INT 5
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 4
93755: PUSH
93756: LD_INT 5
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 3
93765: PUSH
93766: LD_INT 4
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 3
93775: PUSH
93776: LD_INT 3
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 5
93785: PUSH
93786: LD_INT 3
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 3
93795: PUSH
93796: LD_INT 5
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 0
93805: PUSH
93806: LD_INT 3
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: LD_INT 0
93815: PUSH
93816: LD_INT 2
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: PUSH
93823: LD_INT 1
93825: PUSH
93826: LD_INT 3
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 1
93835: PUSH
93836: LD_INT 4
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 0
93845: PUSH
93846: LD_INT 4
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 1
93855: NEG
93856: PUSH
93857: LD_INT 3
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: PUSH
93864: LD_INT 1
93866: NEG
93867: PUSH
93868: LD_INT 2
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 2
93877: PUSH
93878: LD_INT 4
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: PUSH
93885: LD_INT 2
93887: NEG
93888: PUSH
93889: LD_INT 2
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: PUSH
93896: LD_INT 4
93898: NEG
93899: PUSH
93900: LD_INT 0
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: PUSH
93907: LD_INT 4
93909: NEG
93910: PUSH
93911: LD_INT 1
93913: NEG
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: LD_INT 3
93921: NEG
93922: PUSH
93923: LD_INT 0
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: LD_INT 3
93932: NEG
93933: PUSH
93934: LD_INT 1
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 4
93943: NEG
93944: PUSH
93945: LD_INT 1
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 5
93954: NEG
93955: PUSH
93956: LD_INT 0
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 5
93965: NEG
93966: PUSH
93967: LD_INT 1
93969: NEG
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: PUSH
93975: LD_INT 5
93977: NEG
93978: PUSH
93979: LD_INT 2
93981: NEG
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: PUSH
93987: LD_INT 3
93989: NEG
93990: PUSH
93991: LD_INT 2
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: ST_TO_ADDR
// end ; end ;
94045: GO 94048
94047: POP
// case btype of b_depot , b_warehouse :
94048: LD_VAR 0 1
94052: PUSH
94053: LD_INT 0
94055: DOUBLE
94056: EQUAL
94057: IFTRUE 94067
94059: LD_INT 1
94061: DOUBLE
94062: EQUAL
94063: IFTRUE 94067
94065: GO 94268
94067: POP
// case nation of nation_american :
94068: LD_VAR 0 5
94072: PUSH
94073: LD_INT 1
94075: DOUBLE
94076: EQUAL
94077: IFTRUE 94081
94079: GO 94137
94081: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
94082: LD_ADDR_VAR 0 9
94086: PUSH
94087: LD_VAR 0 11
94091: PUSH
94092: LD_VAR 0 12
94096: PUSH
94097: LD_VAR 0 13
94101: PUSH
94102: LD_VAR 0 14
94106: PUSH
94107: LD_VAR 0 15
94111: PUSH
94112: LD_VAR 0 16
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: PUSH
94125: LD_VAR 0 4
94129: PUSH
94130: LD_INT 1
94132: PLUS
94133: ARRAY
94134: ST_TO_ADDR
94135: GO 94266
94137: LD_INT 2
94139: DOUBLE
94140: EQUAL
94141: IFTRUE 94145
94143: GO 94201
94145: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
94146: LD_ADDR_VAR 0 9
94150: PUSH
94151: LD_VAR 0 17
94155: PUSH
94156: LD_VAR 0 18
94160: PUSH
94161: LD_VAR 0 19
94165: PUSH
94166: LD_VAR 0 20
94170: PUSH
94171: LD_VAR 0 21
94175: PUSH
94176: LD_VAR 0 22
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: PUSH
94189: LD_VAR 0 4
94193: PUSH
94194: LD_INT 1
94196: PLUS
94197: ARRAY
94198: ST_TO_ADDR
94199: GO 94266
94201: LD_INT 3
94203: DOUBLE
94204: EQUAL
94205: IFTRUE 94209
94207: GO 94265
94209: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
94210: LD_ADDR_VAR 0 9
94214: PUSH
94215: LD_VAR 0 23
94219: PUSH
94220: LD_VAR 0 24
94224: PUSH
94225: LD_VAR 0 25
94229: PUSH
94230: LD_VAR 0 26
94234: PUSH
94235: LD_VAR 0 27
94239: PUSH
94240: LD_VAR 0 28
94244: PUSH
94245: EMPTY
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: PUSH
94253: LD_VAR 0 4
94257: PUSH
94258: LD_INT 1
94260: PLUS
94261: ARRAY
94262: ST_TO_ADDR
94263: GO 94266
94265: POP
94266: GO 94821
94268: LD_INT 2
94270: DOUBLE
94271: EQUAL
94272: IFTRUE 94282
94274: LD_INT 3
94276: DOUBLE
94277: EQUAL
94278: IFTRUE 94282
94280: GO 94338
94282: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
94283: LD_ADDR_VAR 0 9
94287: PUSH
94288: LD_VAR 0 29
94292: PUSH
94293: LD_VAR 0 30
94297: PUSH
94298: LD_VAR 0 31
94302: PUSH
94303: LD_VAR 0 32
94307: PUSH
94308: LD_VAR 0 33
94312: PUSH
94313: LD_VAR 0 34
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: PUSH
94326: LD_VAR 0 4
94330: PUSH
94331: LD_INT 1
94333: PLUS
94334: ARRAY
94335: ST_TO_ADDR
94336: GO 94821
94338: LD_INT 16
94340: DOUBLE
94341: EQUAL
94342: IFTRUE 94400
94344: LD_INT 17
94346: DOUBLE
94347: EQUAL
94348: IFTRUE 94400
94350: LD_INT 18
94352: DOUBLE
94353: EQUAL
94354: IFTRUE 94400
94356: LD_INT 19
94358: DOUBLE
94359: EQUAL
94360: IFTRUE 94400
94362: LD_INT 22
94364: DOUBLE
94365: EQUAL
94366: IFTRUE 94400
94368: LD_INT 20
94370: DOUBLE
94371: EQUAL
94372: IFTRUE 94400
94374: LD_INT 21
94376: DOUBLE
94377: EQUAL
94378: IFTRUE 94400
94380: LD_INT 23
94382: DOUBLE
94383: EQUAL
94384: IFTRUE 94400
94386: LD_INT 24
94388: DOUBLE
94389: EQUAL
94390: IFTRUE 94400
94392: LD_INT 25
94394: DOUBLE
94395: EQUAL
94396: IFTRUE 94400
94398: GO 94456
94400: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
94401: LD_ADDR_VAR 0 9
94405: PUSH
94406: LD_VAR 0 35
94410: PUSH
94411: LD_VAR 0 36
94415: PUSH
94416: LD_VAR 0 37
94420: PUSH
94421: LD_VAR 0 38
94425: PUSH
94426: LD_VAR 0 39
94430: PUSH
94431: LD_VAR 0 40
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: PUSH
94444: LD_VAR 0 4
94448: PUSH
94449: LD_INT 1
94451: PLUS
94452: ARRAY
94453: ST_TO_ADDR
94454: GO 94821
94456: LD_INT 6
94458: DOUBLE
94459: EQUAL
94460: IFTRUE 94512
94462: LD_INT 7
94464: DOUBLE
94465: EQUAL
94466: IFTRUE 94512
94468: LD_INT 8
94470: DOUBLE
94471: EQUAL
94472: IFTRUE 94512
94474: LD_INT 13
94476: DOUBLE
94477: EQUAL
94478: IFTRUE 94512
94480: LD_INT 12
94482: DOUBLE
94483: EQUAL
94484: IFTRUE 94512
94486: LD_INT 15
94488: DOUBLE
94489: EQUAL
94490: IFTRUE 94512
94492: LD_INT 11
94494: DOUBLE
94495: EQUAL
94496: IFTRUE 94512
94498: LD_INT 14
94500: DOUBLE
94501: EQUAL
94502: IFTRUE 94512
94504: LD_INT 10
94506: DOUBLE
94507: EQUAL
94508: IFTRUE 94512
94510: GO 94568
94512: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
94513: LD_ADDR_VAR 0 9
94517: PUSH
94518: LD_VAR 0 41
94522: PUSH
94523: LD_VAR 0 42
94527: PUSH
94528: LD_VAR 0 43
94532: PUSH
94533: LD_VAR 0 44
94537: PUSH
94538: LD_VAR 0 45
94542: PUSH
94543: LD_VAR 0 46
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: PUSH
94556: LD_VAR 0 4
94560: PUSH
94561: LD_INT 1
94563: PLUS
94564: ARRAY
94565: ST_TO_ADDR
94566: GO 94821
94568: LD_INT 36
94570: DOUBLE
94571: EQUAL
94572: IFTRUE 94576
94574: GO 94632
94576: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
94577: LD_ADDR_VAR 0 9
94581: PUSH
94582: LD_VAR 0 47
94586: PUSH
94587: LD_VAR 0 48
94591: PUSH
94592: LD_VAR 0 49
94596: PUSH
94597: LD_VAR 0 50
94601: PUSH
94602: LD_VAR 0 51
94606: PUSH
94607: LD_VAR 0 52
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: PUSH
94620: LD_VAR 0 4
94624: PUSH
94625: LD_INT 1
94627: PLUS
94628: ARRAY
94629: ST_TO_ADDR
94630: GO 94821
94632: LD_INT 4
94634: DOUBLE
94635: EQUAL
94636: IFTRUE 94658
94638: LD_INT 5
94640: DOUBLE
94641: EQUAL
94642: IFTRUE 94658
94644: LD_INT 34
94646: DOUBLE
94647: EQUAL
94648: IFTRUE 94658
94650: LD_INT 37
94652: DOUBLE
94653: EQUAL
94654: IFTRUE 94658
94656: GO 94714
94658: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
94659: LD_ADDR_VAR 0 9
94663: PUSH
94664: LD_VAR 0 53
94668: PUSH
94669: LD_VAR 0 54
94673: PUSH
94674: LD_VAR 0 55
94678: PUSH
94679: LD_VAR 0 56
94683: PUSH
94684: LD_VAR 0 57
94688: PUSH
94689: LD_VAR 0 58
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: PUSH
94702: LD_VAR 0 4
94706: PUSH
94707: LD_INT 1
94709: PLUS
94710: ARRAY
94711: ST_TO_ADDR
94712: GO 94821
94714: LD_INT 31
94716: DOUBLE
94717: EQUAL
94718: IFTRUE 94764
94720: LD_INT 32
94722: DOUBLE
94723: EQUAL
94724: IFTRUE 94764
94726: LD_INT 33
94728: DOUBLE
94729: EQUAL
94730: IFTRUE 94764
94732: LD_INT 27
94734: DOUBLE
94735: EQUAL
94736: IFTRUE 94764
94738: LD_INT 26
94740: DOUBLE
94741: EQUAL
94742: IFTRUE 94764
94744: LD_INT 28
94746: DOUBLE
94747: EQUAL
94748: IFTRUE 94764
94750: LD_INT 29
94752: DOUBLE
94753: EQUAL
94754: IFTRUE 94764
94756: LD_INT 30
94758: DOUBLE
94759: EQUAL
94760: IFTRUE 94764
94762: GO 94820
94764: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
94765: LD_ADDR_VAR 0 9
94769: PUSH
94770: LD_VAR 0 59
94774: PUSH
94775: LD_VAR 0 60
94779: PUSH
94780: LD_VAR 0 61
94784: PUSH
94785: LD_VAR 0 62
94789: PUSH
94790: LD_VAR 0 63
94794: PUSH
94795: LD_VAR 0 64
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: PUSH
94808: LD_VAR 0 4
94812: PUSH
94813: LD_INT 1
94815: PLUS
94816: ARRAY
94817: ST_TO_ADDR
94818: GO 94821
94820: POP
// temp_list2 = [ ] ;
94821: LD_ADDR_VAR 0 10
94825: PUSH
94826: EMPTY
94827: ST_TO_ADDR
// for i in temp_list do
94828: LD_ADDR_VAR 0 8
94832: PUSH
94833: LD_VAR 0 9
94837: PUSH
94838: FOR_IN
94839: IFFALSE 94891
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
94841: LD_ADDR_VAR 0 10
94845: PUSH
94846: LD_VAR 0 10
94850: PUSH
94851: LD_VAR 0 8
94855: PUSH
94856: LD_INT 1
94858: ARRAY
94859: PUSH
94860: LD_VAR 0 2
94864: PLUS
94865: PUSH
94866: LD_VAR 0 8
94870: PUSH
94871: LD_INT 2
94873: ARRAY
94874: PUSH
94875: LD_VAR 0 3
94879: PLUS
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: EMPTY
94886: LIST
94887: ADD
94888: ST_TO_ADDR
94889: GO 94838
94891: POP
94892: POP
// result = temp_list2 ;
94893: LD_ADDR_VAR 0 7
94897: PUSH
94898: LD_VAR 0 10
94902: ST_TO_ADDR
// end ;
94903: LD_VAR 0 7
94907: RET
// export function EnemyInRange ( unit , dist ) ; begin
94908: LD_INT 0
94910: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
94911: LD_ADDR_VAR 0 3
94915: PUSH
94916: LD_VAR 0 1
94920: PPUSH
94921: CALL_OW 255
94925: PPUSH
94926: LD_VAR 0 1
94930: PPUSH
94931: CALL_OW 250
94935: PPUSH
94936: LD_VAR 0 1
94940: PPUSH
94941: CALL_OW 251
94945: PPUSH
94946: LD_VAR 0 2
94950: PPUSH
94951: CALL 68304 0 4
94955: PUSH
94956: LD_INT 4
94958: ARRAY
94959: ST_TO_ADDR
// end ;
94960: LD_VAR 0 3
94964: RET
// export function PlayerSeeMe ( unit ) ; begin
94965: LD_INT 0
94967: PPUSH
// result := See ( your_side , unit ) ;
94968: LD_ADDR_VAR 0 2
94972: PUSH
94973: LD_OWVAR 2
94977: PPUSH
94978: LD_VAR 0 1
94982: PPUSH
94983: CALL_OW 292
94987: ST_TO_ADDR
// end ;
94988: LD_VAR 0 2
94992: RET
// export function ReverseDir ( unit ) ; begin
94993: LD_INT 0
94995: PPUSH
// if not unit then
94996: LD_VAR 0 1
95000: NOT
95001: IFFALSE 95005
// exit ;
95003: GO 95028
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
95005: LD_ADDR_VAR 0 2
95009: PUSH
95010: LD_VAR 0 1
95014: PPUSH
95015: CALL_OW 254
95019: PUSH
95020: LD_INT 3
95022: PLUS
95023: PUSH
95024: LD_INT 6
95026: MOD
95027: ST_TO_ADDR
// end ;
95028: LD_VAR 0 2
95032: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
95033: LD_INT 0
95035: PPUSH
95036: PPUSH
95037: PPUSH
95038: PPUSH
95039: PPUSH
// if not hexes then
95040: LD_VAR 0 2
95044: NOT
95045: IFFALSE 95049
// exit ;
95047: GO 95197
// dist := 9999 ;
95049: LD_ADDR_VAR 0 5
95053: PUSH
95054: LD_INT 9999
95056: ST_TO_ADDR
// for i = 1 to hexes do
95057: LD_ADDR_VAR 0 4
95061: PUSH
95062: DOUBLE
95063: LD_INT 1
95065: DEC
95066: ST_TO_ADDR
95067: LD_VAR 0 2
95071: PUSH
95072: FOR_TO
95073: IFFALSE 95185
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
95075: LD_VAR 0 1
95079: PPUSH
95080: LD_VAR 0 2
95084: PUSH
95085: LD_VAR 0 4
95089: ARRAY
95090: PUSH
95091: LD_INT 1
95093: ARRAY
95094: PPUSH
95095: LD_VAR 0 2
95099: PUSH
95100: LD_VAR 0 4
95104: ARRAY
95105: PUSH
95106: LD_INT 2
95108: ARRAY
95109: PPUSH
95110: CALL_OW 297
95114: PUSH
95115: LD_VAR 0 5
95119: LESS
95120: IFFALSE 95183
// begin hex := hexes [ i ] ;
95122: LD_ADDR_VAR 0 7
95126: PUSH
95127: LD_VAR 0 2
95131: PUSH
95132: LD_VAR 0 4
95136: ARRAY
95137: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
95138: LD_ADDR_VAR 0 5
95142: PUSH
95143: LD_VAR 0 1
95147: PPUSH
95148: LD_VAR 0 2
95152: PUSH
95153: LD_VAR 0 4
95157: ARRAY
95158: PUSH
95159: LD_INT 1
95161: ARRAY
95162: PPUSH
95163: LD_VAR 0 2
95167: PUSH
95168: LD_VAR 0 4
95172: ARRAY
95173: PUSH
95174: LD_INT 2
95176: ARRAY
95177: PPUSH
95178: CALL_OW 297
95182: ST_TO_ADDR
// end ; end ;
95183: GO 95072
95185: POP
95186: POP
// result := hex ;
95187: LD_ADDR_VAR 0 3
95191: PUSH
95192: LD_VAR 0 7
95196: ST_TO_ADDR
// end ;
95197: LD_VAR 0 3
95201: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
95202: LD_INT 0
95204: PPUSH
95205: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
95206: LD_VAR 0 1
95210: NOT
95211: PUSH
95212: LD_VAR 0 1
95216: PUSH
95217: LD_INT 21
95219: PUSH
95220: LD_INT 2
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 23
95229: PUSH
95230: LD_INT 2
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: PPUSH
95241: CALL_OW 69
95245: IN
95246: NOT
95247: OR
95248: IFFALSE 95252
// exit ;
95250: GO 95299
// for i = 1 to 3 do
95252: LD_ADDR_VAR 0 3
95256: PUSH
95257: DOUBLE
95258: LD_INT 1
95260: DEC
95261: ST_TO_ADDR
95262: LD_INT 3
95264: PUSH
95265: FOR_TO
95266: IFFALSE 95297
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
95268: LD_VAR 0 1
95272: PPUSH
95273: CALL_OW 250
95277: PPUSH
95278: LD_VAR 0 1
95282: PPUSH
95283: CALL_OW 251
95287: PPUSH
95288: LD_INT 1
95290: PPUSH
95291: CALL_OW 453
95295: GO 95265
95297: POP
95298: POP
// end ;
95299: LD_VAR 0 2
95303: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
95304: LD_INT 0
95306: PPUSH
95307: PPUSH
95308: PPUSH
95309: PPUSH
95310: PPUSH
95311: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
95312: LD_VAR 0 1
95316: NOT
95317: PUSH
95318: LD_VAR 0 2
95322: NOT
95323: OR
95324: PUSH
95325: LD_VAR 0 1
95329: PPUSH
95330: CALL_OW 314
95334: OR
95335: IFFALSE 95339
// exit ;
95337: GO 95780
// x := GetX ( enemy_unit ) ;
95339: LD_ADDR_VAR 0 7
95343: PUSH
95344: LD_VAR 0 2
95348: PPUSH
95349: CALL_OW 250
95353: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
95354: LD_ADDR_VAR 0 8
95358: PUSH
95359: LD_VAR 0 2
95363: PPUSH
95364: CALL_OW 251
95368: ST_TO_ADDR
// if not x or not y then
95369: LD_VAR 0 7
95373: NOT
95374: PUSH
95375: LD_VAR 0 8
95379: NOT
95380: OR
95381: IFFALSE 95385
// exit ;
95383: GO 95780
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
95385: LD_ADDR_VAR 0 6
95389: PUSH
95390: LD_VAR 0 7
95394: PPUSH
95395: LD_INT 0
95397: PPUSH
95398: LD_INT 4
95400: PPUSH
95401: CALL_OW 272
95405: PUSH
95406: LD_VAR 0 8
95410: PPUSH
95411: LD_INT 0
95413: PPUSH
95414: LD_INT 4
95416: PPUSH
95417: CALL_OW 273
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_VAR 0 7
95430: PPUSH
95431: LD_INT 1
95433: PPUSH
95434: LD_INT 4
95436: PPUSH
95437: CALL_OW 272
95441: PUSH
95442: LD_VAR 0 8
95446: PPUSH
95447: LD_INT 1
95449: PPUSH
95450: LD_INT 4
95452: PPUSH
95453: CALL_OW 273
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_VAR 0 7
95466: PPUSH
95467: LD_INT 2
95469: PPUSH
95470: LD_INT 4
95472: PPUSH
95473: CALL_OW 272
95477: PUSH
95478: LD_VAR 0 8
95482: PPUSH
95483: LD_INT 2
95485: PPUSH
95486: LD_INT 4
95488: PPUSH
95489: CALL_OW 273
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_VAR 0 7
95502: PPUSH
95503: LD_INT 3
95505: PPUSH
95506: LD_INT 4
95508: PPUSH
95509: CALL_OW 272
95513: PUSH
95514: LD_VAR 0 8
95518: PPUSH
95519: LD_INT 3
95521: PPUSH
95522: LD_INT 4
95524: PPUSH
95525: CALL_OW 273
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_VAR 0 7
95538: PPUSH
95539: LD_INT 4
95541: PPUSH
95542: LD_INT 4
95544: PPUSH
95545: CALL_OW 272
95549: PUSH
95550: LD_VAR 0 8
95554: PPUSH
95555: LD_INT 4
95557: PPUSH
95558: LD_INT 4
95560: PPUSH
95561: CALL_OW 273
95565: PUSH
95566: EMPTY
95567: LIST
95568: LIST
95569: PUSH
95570: LD_VAR 0 7
95574: PPUSH
95575: LD_INT 5
95577: PPUSH
95578: LD_INT 4
95580: PPUSH
95581: CALL_OW 272
95585: PUSH
95586: LD_VAR 0 8
95590: PPUSH
95591: LD_INT 5
95593: PPUSH
95594: LD_INT 4
95596: PPUSH
95597: CALL_OW 273
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: PUSH
95606: EMPTY
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: ST_TO_ADDR
// for i = tmp downto 1 do
95614: LD_ADDR_VAR 0 4
95618: PUSH
95619: DOUBLE
95620: LD_VAR 0 6
95624: INC
95625: ST_TO_ADDR
95626: LD_INT 1
95628: PUSH
95629: FOR_DOWNTO
95630: IFFALSE 95731
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
95632: LD_VAR 0 6
95636: PUSH
95637: LD_VAR 0 4
95641: ARRAY
95642: PUSH
95643: LD_INT 1
95645: ARRAY
95646: PPUSH
95647: LD_VAR 0 6
95651: PUSH
95652: LD_VAR 0 4
95656: ARRAY
95657: PUSH
95658: LD_INT 2
95660: ARRAY
95661: PPUSH
95662: CALL_OW 488
95666: NOT
95667: PUSH
95668: LD_VAR 0 6
95672: PUSH
95673: LD_VAR 0 4
95677: ARRAY
95678: PUSH
95679: LD_INT 1
95681: ARRAY
95682: PPUSH
95683: LD_VAR 0 6
95687: PUSH
95688: LD_VAR 0 4
95692: ARRAY
95693: PUSH
95694: LD_INT 2
95696: ARRAY
95697: PPUSH
95698: CALL_OW 428
95702: PUSH
95703: LD_INT 0
95705: NONEQUAL
95706: OR
95707: IFFALSE 95729
// tmp := Delete ( tmp , i ) ;
95709: LD_ADDR_VAR 0 6
95713: PUSH
95714: LD_VAR 0 6
95718: PPUSH
95719: LD_VAR 0 4
95723: PPUSH
95724: CALL_OW 3
95728: ST_TO_ADDR
95729: GO 95629
95731: POP
95732: POP
// j := GetClosestHex ( unit , tmp ) ;
95733: LD_ADDR_VAR 0 5
95737: PUSH
95738: LD_VAR 0 1
95742: PPUSH
95743: LD_VAR 0 6
95747: PPUSH
95748: CALL 95033 0 2
95752: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
95753: LD_VAR 0 1
95757: PPUSH
95758: LD_VAR 0 5
95762: PUSH
95763: LD_INT 1
95765: ARRAY
95766: PPUSH
95767: LD_VAR 0 5
95771: PUSH
95772: LD_INT 2
95774: ARRAY
95775: PPUSH
95776: CALL_OW 111
// end ;
95780: LD_VAR 0 3
95784: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
95785: LD_INT 0
95787: PPUSH
95788: PPUSH
95789: PPUSH
// uc_side = 0 ;
95790: LD_ADDR_OWVAR 20
95794: PUSH
95795: LD_INT 0
95797: ST_TO_ADDR
// uc_nation = 0 ;
95798: LD_ADDR_OWVAR 21
95802: PUSH
95803: LD_INT 0
95805: ST_TO_ADDR
// InitHc_All ( ) ;
95806: CALL_OW 584
// InitVc ;
95810: CALL_OW 20
// if mastodonts then
95814: LD_VAR 0 6
95818: IFFALSE 95885
// for i = 1 to mastodonts do
95820: LD_ADDR_VAR 0 11
95824: PUSH
95825: DOUBLE
95826: LD_INT 1
95828: DEC
95829: ST_TO_ADDR
95830: LD_VAR 0 6
95834: PUSH
95835: FOR_TO
95836: IFFALSE 95883
// begin vc_chassis := 31 ;
95838: LD_ADDR_OWVAR 37
95842: PUSH
95843: LD_INT 31
95845: ST_TO_ADDR
// vc_control := control_rider ;
95846: LD_ADDR_OWVAR 38
95850: PUSH
95851: LD_INT 4
95853: ST_TO_ADDR
// animal := CreateVehicle ;
95854: LD_ADDR_VAR 0 12
95858: PUSH
95859: CALL_OW 45
95863: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95864: LD_VAR 0 12
95868: PPUSH
95869: LD_VAR 0 8
95873: PPUSH
95874: LD_INT 0
95876: PPUSH
95877: CALL 98020 0 3
// end ;
95881: GO 95835
95883: POP
95884: POP
// if horses then
95885: LD_VAR 0 5
95889: IFFALSE 95956
// for i = 1 to horses do
95891: LD_ADDR_VAR 0 11
95895: PUSH
95896: DOUBLE
95897: LD_INT 1
95899: DEC
95900: ST_TO_ADDR
95901: LD_VAR 0 5
95905: PUSH
95906: FOR_TO
95907: IFFALSE 95954
// begin hc_class := 21 ;
95909: LD_ADDR_OWVAR 28
95913: PUSH
95914: LD_INT 21
95916: ST_TO_ADDR
// hc_gallery :=  ;
95917: LD_ADDR_OWVAR 33
95921: PUSH
95922: LD_STRING 
95924: ST_TO_ADDR
// animal := CreateHuman ;
95925: LD_ADDR_VAR 0 12
95929: PUSH
95930: CALL_OW 44
95934: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95935: LD_VAR 0 12
95939: PPUSH
95940: LD_VAR 0 8
95944: PPUSH
95945: LD_INT 0
95947: PPUSH
95948: CALL 98020 0 3
// end ;
95952: GO 95906
95954: POP
95955: POP
// if birds then
95956: LD_VAR 0 1
95960: IFFALSE 96027
// for i = 1 to birds do
95962: LD_ADDR_VAR 0 11
95966: PUSH
95967: DOUBLE
95968: LD_INT 1
95970: DEC
95971: ST_TO_ADDR
95972: LD_VAR 0 1
95976: PUSH
95977: FOR_TO
95978: IFFALSE 96025
// begin hc_class = 18 ;
95980: LD_ADDR_OWVAR 28
95984: PUSH
95985: LD_INT 18
95987: ST_TO_ADDR
// hc_gallery =  ;
95988: LD_ADDR_OWVAR 33
95992: PUSH
95993: LD_STRING 
95995: ST_TO_ADDR
// animal := CreateHuman ;
95996: LD_ADDR_VAR 0 12
96000: PUSH
96001: CALL_OW 44
96005: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96006: LD_VAR 0 12
96010: PPUSH
96011: LD_VAR 0 8
96015: PPUSH
96016: LD_INT 0
96018: PPUSH
96019: CALL 98020 0 3
// end ;
96023: GO 95977
96025: POP
96026: POP
// if tigers then
96027: LD_VAR 0 2
96031: IFFALSE 96115
// for i = 1 to tigers do
96033: LD_ADDR_VAR 0 11
96037: PUSH
96038: DOUBLE
96039: LD_INT 1
96041: DEC
96042: ST_TO_ADDR
96043: LD_VAR 0 2
96047: PUSH
96048: FOR_TO
96049: IFFALSE 96113
// begin hc_class = class_tiger ;
96051: LD_ADDR_OWVAR 28
96055: PUSH
96056: LD_INT 14
96058: ST_TO_ADDR
// hc_gallery =  ;
96059: LD_ADDR_OWVAR 33
96063: PUSH
96064: LD_STRING 
96066: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
96067: LD_ADDR_OWVAR 35
96071: PUSH
96072: LD_INT 7
96074: NEG
96075: PPUSH
96076: LD_INT 7
96078: PPUSH
96079: CALL_OW 12
96083: ST_TO_ADDR
// animal := CreateHuman ;
96084: LD_ADDR_VAR 0 12
96088: PUSH
96089: CALL_OW 44
96093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96094: LD_VAR 0 12
96098: PPUSH
96099: LD_VAR 0 8
96103: PPUSH
96104: LD_INT 0
96106: PPUSH
96107: CALL 98020 0 3
// end ;
96111: GO 96048
96113: POP
96114: POP
// if apemans then
96115: LD_VAR 0 3
96119: IFFALSE 96242
// for i = 1 to apemans do
96121: LD_ADDR_VAR 0 11
96125: PUSH
96126: DOUBLE
96127: LD_INT 1
96129: DEC
96130: ST_TO_ADDR
96131: LD_VAR 0 3
96135: PUSH
96136: FOR_TO
96137: IFFALSE 96240
// begin hc_class = class_apeman ;
96139: LD_ADDR_OWVAR 28
96143: PUSH
96144: LD_INT 12
96146: ST_TO_ADDR
// hc_gallery =  ;
96147: LD_ADDR_OWVAR 33
96151: PUSH
96152: LD_STRING 
96154: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
96155: LD_ADDR_OWVAR 35
96159: PUSH
96160: LD_INT 2
96162: NEG
96163: PPUSH
96164: LD_INT 2
96166: PPUSH
96167: CALL_OW 12
96171: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
96172: LD_ADDR_OWVAR 31
96176: PUSH
96177: LD_INT 1
96179: PPUSH
96180: LD_INT 3
96182: PPUSH
96183: CALL_OW 12
96187: PUSH
96188: LD_INT 1
96190: PPUSH
96191: LD_INT 3
96193: PPUSH
96194: CALL_OW 12
96198: PUSH
96199: LD_INT 0
96201: PUSH
96202: LD_INT 0
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: ST_TO_ADDR
// animal := CreateHuman ;
96211: LD_ADDR_VAR 0 12
96215: PUSH
96216: CALL_OW 44
96220: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96221: LD_VAR 0 12
96225: PPUSH
96226: LD_VAR 0 8
96230: PPUSH
96231: LD_INT 0
96233: PPUSH
96234: CALL 98020 0 3
// end ;
96238: GO 96136
96240: POP
96241: POP
// if enchidnas then
96242: LD_VAR 0 4
96246: IFFALSE 96313
// for i = 1 to enchidnas do
96248: LD_ADDR_VAR 0 11
96252: PUSH
96253: DOUBLE
96254: LD_INT 1
96256: DEC
96257: ST_TO_ADDR
96258: LD_VAR 0 4
96262: PUSH
96263: FOR_TO
96264: IFFALSE 96311
// begin hc_class = 13 ;
96266: LD_ADDR_OWVAR 28
96270: PUSH
96271: LD_INT 13
96273: ST_TO_ADDR
// hc_gallery =  ;
96274: LD_ADDR_OWVAR 33
96278: PUSH
96279: LD_STRING 
96281: ST_TO_ADDR
// animal := CreateHuman ;
96282: LD_ADDR_VAR 0 12
96286: PUSH
96287: CALL_OW 44
96291: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
96292: LD_VAR 0 12
96296: PPUSH
96297: LD_VAR 0 8
96301: PPUSH
96302: LD_INT 0
96304: PPUSH
96305: CALL 98020 0 3
// end ;
96309: GO 96263
96311: POP
96312: POP
// if fishes then
96313: LD_VAR 0 7
96317: IFFALSE 96384
// for i = 1 to fishes do
96319: LD_ADDR_VAR 0 11
96323: PUSH
96324: DOUBLE
96325: LD_INT 1
96327: DEC
96328: ST_TO_ADDR
96329: LD_VAR 0 7
96333: PUSH
96334: FOR_TO
96335: IFFALSE 96382
// begin hc_class = 20 ;
96337: LD_ADDR_OWVAR 28
96341: PUSH
96342: LD_INT 20
96344: ST_TO_ADDR
// hc_gallery =  ;
96345: LD_ADDR_OWVAR 33
96349: PUSH
96350: LD_STRING 
96352: ST_TO_ADDR
// animal := CreateHuman ;
96353: LD_ADDR_VAR 0 12
96357: PUSH
96358: CALL_OW 44
96362: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
96363: LD_VAR 0 12
96367: PPUSH
96368: LD_VAR 0 9
96372: PPUSH
96373: LD_INT 0
96375: PPUSH
96376: CALL 98020 0 3
// end ;
96380: GO 96334
96382: POP
96383: POP
// end ;
96384: LD_VAR 0 10
96388: RET
// export function WantHeal ( sci , unit ) ; begin
96389: LD_INT 0
96391: PPUSH
// if GetTaskList ( sci ) > 0 then
96392: LD_VAR 0 1
96396: PPUSH
96397: CALL_OW 437
96401: PUSH
96402: LD_INT 0
96404: GREATER
96405: IFFALSE 96475
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
96407: LD_VAR 0 1
96411: PPUSH
96412: CALL_OW 437
96416: PUSH
96417: LD_INT 1
96419: ARRAY
96420: PUSH
96421: LD_INT 1
96423: ARRAY
96424: PUSH
96425: LD_STRING l
96427: EQUAL
96428: PUSH
96429: LD_VAR 0 1
96433: PPUSH
96434: CALL_OW 437
96438: PUSH
96439: LD_INT 1
96441: ARRAY
96442: PUSH
96443: LD_INT 4
96445: ARRAY
96446: PUSH
96447: LD_VAR 0 2
96451: EQUAL
96452: AND
96453: IFFALSE 96465
// result := true else
96455: LD_ADDR_VAR 0 3
96459: PUSH
96460: LD_INT 1
96462: ST_TO_ADDR
96463: GO 96473
// result := false ;
96465: LD_ADDR_VAR 0 3
96469: PUSH
96470: LD_INT 0
96472: ST_TO_ADDR
// end else
96473: GO 96483
// result := false ;
96475: LD_ADDR_VAR 0 3
96479: PUSH
96480: LD_INT 0
96482: ST_TO_ADDR
// end ;
96483: LD_VAR 0 3
96487: RET
// export function HealTarget ( sci ) ; begin
96488: LD_INT 0
96490: PPUSH
// if not sci then
96491: LD_VAR 0 1
96495: NOT
96496: IFFALSE 96500
// exit ;
96498: GO 96565
// result := 0 ;
96500: LD_ADDR_VAR 0 2
96504: PUSH
96505: LD_INT 0
96507: ST_TO_ADDR
// if GetTaskList ( sci ) then
96508: LD_VAR 0 1
96512: PPUSH
96513: CALL_OW 437
96517: IFFALSE 96565
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
96519: LD_VAR 0 1
96523: PPUSH
96524: CALL_OW 437
96528: PUSH
96529: LD_INT 1
96531: ARRAY
96532: PUSH
96533: LD_INT 1
96535: ARRAY
96536: PUSH
96537: LD_STRING l
96539: EQUAL
96540: IFFALSE 96565
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
96542: LD_ADDR_VAR 0 2
96546: PUSH
96547: LD_VAR 0 1
96551: PPUSH
96552: CALL_OW 437
96556: PUSH
96557: LD_INT 1
96559: ARRAY
96560: PUSH
96561: LD_INT 4
96563: ARRAY
96564: ST_TO_ADDR
// end ;
96565: LD_VAR 0 2
96569: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
96570: LD_INT 0
96572: PPUSH
96573: PPUSH
96574: PPUSH
96575: PPUSH
// if not base_units then
96576: LD_VAR 0 1
96580: NOT
96581: IFFALSE 96585
// exit ;
96583: GO 96672
// result := false ;
96585: LD_ADDR_VAR 0 2
96589: PUSH
96590: LD_INT 0
96592: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
96593: LD_ADDR_VAR 0 5
96597: PUSH
96598: LD_VAR 0 1
96602: PPUSH
96603: LD_INT 21
96605: PUSH
96606: LD_INT 3
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PPUSH
96613: CALL_OW 72
96617: ST_TO_ADDR
// if not tmp then
96618: LD_VAR 0 5
96622: NOT
96623: IFFALSE 96627
// exit ;
96625: GO 96672
// for i in tmp do
96627: LD_ADDR_VAR 0 3
96631: PUSH
96632: LD_VAR 0 5
96636: PUSH
96637: FOR_IN
96638: IFFALSE 96670
// begin result := EnemyInRange ( i , 22 ) ;
96640: LD_ADDR_VAR 0 2
96644: PUSH
96645: LD_VAR 0 3
96649: PPUSH
96650: LD_INT 22
96652: PPUSH
96653: CALL 94908 0 2
96657: ST_TO_ADDR
// if result then
96658: LD_VAR 0 2
96662: IFFALSE 96668
// exit ;
96664: POP
96665: POP
96666: GO 96672
// end ;
96668: GO 96637
96670: POP
96671: POP
// end ;
96672: LD_VAR 0 2
96676: RET
// export function FilterByTag ( units , tag ) ; begin
96677: LD_INT 0
96679: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
96680: LD_ADDR_VAR 0 3
96684: PUSH
96685: LD_VAR 0 1
96689: PPUSH
96690: LD_INT 120
96692: PUSH
96693: LD_VAR 0 2
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PPUSH
96702: CALL_OW 72
96706: ST_TO_ADDR
// end ;
96707: LD_VAR 0 3
96711: RET
// export function IsDriver ( un ) ; begin
96712: LD_INT 0
96714: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
96715: LD_ADDR_VAR 0 2
96719: PUSH
96720: LD_VAR 0 1
96724: PUSH
96725: LD_INT 55
96727: PUSH
96728: EMPTY
96729: LIST
96730: PPUSH
96731: CALL_OW 69
96735: IN
96736: ST_TO_ADDR
// end ;
96737: LD_VAR 0 2
96741: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
96742: LD_INT 0
96744: PPUSH
96745: PPUSH
// list := [ ] ;
96746: LD_ADDR_VAR 0 5
96750: PUSH
96751: EMPTY
96752: ST_TO_ADDR
// case d of 0 :
96753: LD_VAR 0 3
96757: PUSH
96758: LD_INT 0
96760: DOUBLE
96761: EQUAL
96762: IFTRUE 96766
96764: GO 96899
96766: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
96767: LD_ADDR_VAR 0 5
96771: PUSH
96772: LD_VAR 0 1
96776: PUSH
96777: LD_INT 4
96779: MINUS
96780: PUSH
96781: LD_VAR 0 2
96785: PUSH
96786: LD_INT 4
96788: MINUS
96789: PUSH
96790: LD_INT 2
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: LIST
96797: PUSH
96798: LD_VAR 0 1
96802: PUSH
96803: LD_INT 3
96805: MINUS
96806: PUSH
96807: LD_VAR 0 2
96811: PUSH
96812: LD_INT 1
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: LIST
96819: PUSH
96820: LD_VAR 0 1
96824: PUSH
96825: LD_INT 4
96827: PLUS
96828: PUSH
96829: LD_VAR 0 2
96833: PUSH
96834: LD_INT 4
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: LIST
96841: PUSH
96842: LD_VAR 0 1
96846: PUSH
96847: LD_INT 3
96849: PLUS
96850: PUSH
96851: LD_VAR 0 2
96855: PUSH
96856: LD_INT 3
96858: PLUS
96859: PUSH
96860: LD_INT 5
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: LIST
96867: PUSH
96868: LD_VAR 0 1
96872: PUSH
96873: LD_VAR 0 2
96877: PUSH
96878: LD_INT 4
96880: PLUS
96881: PUSH
96882: LD_INT 0
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: LIST
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: ST_TO_ADDR
// end ; 1 :
96897: GO 97597
96899: LD_INT 1
96901: DOUBLE
96902: EQUAL
96903: IFTRUE 96907
96905: GO 97040
96907: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
96908: LD_ADDR_VAR 0 5
96912: PUSH
96913: LD_VAR 0 1
96917: PUSH
96918: LD_VAR 0 2
96922: PUSH
96923: LD_INT 4
96925: MINUS
96926: PUSH
96927: LD_INT 3
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: LIST
96934: PUSH
96935: LD_VAR 0 1
96939: PUSH
96940: LD_INT 3
96942: MINUS
96943: PUSH
96944: LD_VAR 0 2
96948: PUSH
96949: LD_INT 3
96951: MINUS
96952: PUSH
96953: LD_INT 2
96955: PUSH
96956: EMPTY
96957: LIST
96958: LIST
96959: LIST
96960: PUSH
96961: LD_VAR 0 1
96965: PUSH
96966: LD_INT 4
96968: MINUS
96969: PUSH
96970: LD_VAR 0 2
96974: PUSH
96975: LD_INT 1
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: LIST
96982: PUSH
96983: LD_VAR 0 1
96987: PUSH
96988: LD_VAR 0 2
96992: PUSH
96993: LD_INT 3
96995: PLUS
96996: PUSH
96997: LD_INT 0
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: LIST
97004: PUSH
97005: LD_VAR 0 1
97009: PUSH
97010: LD_INT 4
97012: PLUS
97013: PUSH
97014: LD_VAR 0 2
97018: PUSH
97019: LD_INT 4
97021: PLUS
97022: PUSH
97023: LD_INT 5
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: LIST
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: ST_TO_ADDR
// end ; 2 :
97038: GO 97597
97040: LD_INT 2
97042: DOUBLE
97043: EQUAL
97044: IFTRUE 97048
97046: GO 97177
97048: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
97049: LD_ADDR_VAR 0 5
97053: PUSH
97054: LD_VAR 0 1
97058: PUSH
97059: LD_VAR 0 2
97063: PUSH
97064: LD_INT 3
97066: MINUS
97067: PUSH
97068: LD_INT 3
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: LIST
97075: PUSH
97076: LD_VAR 0 1
97080: PUSH
97081: LD_INT 4
97083: PLUS
97084: PUSH
97085: LD_VAR 0 2
97089: PUSH
97090: LD_INT 4
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: LIST
97097: PUSH
97098: LD_VAR 0 1
97102: PUSH
97103: LD_VAR 0 2
97107: PUSH
97108: LD_INT 4
97110: PLUS
97111: PUSH
97112: LD_INT 0
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: LIST
97119: PUSH
97120: LD_VAR 0 1
97124: PUSH
97125: LD_INT 3
97127: MINUS
97128: PUSH
97129: LD_VAR 0 2
97133: PUSH
97134: LD_INT 1
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: LIST
97141: PUSH
97142: LD_VAR 0 1
97146: PUSH
97147: LD_INT 4
97149: MINUS
97150: PUSH
97151: LD_VAR 0 2
97155: PUSH
97156: LD_INT 4
97158: MINUS
97159: PUSH
97160: LD_INT 2
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: LIST
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: ST_TO_ADDR
// end ; 3 :
97175: GO 97597
97177: LD_INT 3
97179: DOUBLE
97180: EQUAL
97181: IFTRUE 97185
97183: GO 97318
97185: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
97186: LD_ADDR_VAR 0 5
97190: PUSH
97191: LD_VAR 0 1
97195: PUSH
97196: LD_INT 3
97198: PLUS
97199: PUSH
97200: LD_VAR 0 2
97204: PUSH
97205: LD_INT 4
97207: PUSH
97208: EMPTY
97209: LIST
97210: LIST
97211: LIST
97212: PUSH
97213: LD_VAR 0 1
97217: PUSH
97218: LD_INT 4
97220: PLUS
97221: PUSH
97222: LD_VAR 0 2
97226: PUSH
97227: LD_INT 4
97229: PLUS
97230: PUSH
97231: LD_INT 5
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: LIST
97238: PUSH
97239: LD_VAR 0 1
97243: PUSH
97244: LD_INT 4
97246: MINUS
97247: PUSH
97248: LD_VAR 0 2
97252: PUSH
97253: LD_INT 1
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: LIST
97260: PUSH
97261: LD_VAR 0 1
97265: PUSH
97266: LD_VAR 0 2
97270: PUSH
97271: LD_INT 4
97273: MINUS
97274: PUSH
97275: LD_INT 3
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: LIST
97282: PUSH
97283: LD_VAR 0 1
97287: PUSH
97288: LD_INT 3
97290: MINUS
97291: PUSH
97292: LD_VAR 0 2
97296: PUSH
97297: LD_INT 3
97299: MINUS
97300: PUSH
97301: LD_INT 2
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: LIST
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: ST_TO_ADDR
// end ; 4 :
97316: GO 97597
97318: LD_INT 4
97320: DOUBLE
97321: EQUAL
97322: IFTRUE 97326
97324: GO 97459
97326: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
97327: LD_ADDR_VAR 0 5
97331: PUSH
97332: LD_VAR 0 1
97336: PUSH
97337: LD_VAR 0 2
97341: PUSH
97342: LD_INT 4
97344: PLUS
97345: PUSH
97346: LD_INT 0
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: LIST
97353: PUSH
97354: LD_VAR 0 1
97358: PUSH
97359: LD_INT 3
97361: PLUS
97362: PUSH
97363: LD_VAR 0 2
97367: PUSH
97368: LD_INT 3
97370: PLUS
97371: PUSH
97372: LD_INT 5
97374: PUSH
97375: EMPTY
97376: LIST
97377: LIST
97378: LIST
97379: PUSH
97380: LD_VAR 0 1
97384: PUSH
97385: LD_INT 4
97387: PLUS
97388: PUSH
97389: LD_VAR 0 2
97393: PUSH
97394: LD_INT 4
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: LIST
97401: PUSH
97402: LD_VAR 0 1
97406: PUSH
97407: LD_VAR 0 2
97411: PUSH
97412: LD_INT 3
97414: MINUS
97415: PUSH
97416: LD_INT 3
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: LIST
97423: PUSH
97424: LD_VAR 0 1
97428: PUSH
97429: LD_INT 4
97431: MINUS
97432: PUSH
97433: LD_VAR 0 2
97437: PUSH
97438: LD_INT 4
97440: MINUS
97441: PUSH
97442: LD_INT 2
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: LIST
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: ST_TO_ADDR
// end ; 5 :
97457: GO 97597
97459: LD_INT 5
97461: DOUBLE
97462: EQUAL
97463: IFTRUE 97467
97465: GO 97596
97467: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
97468: LD_ADDR_VAR 0 5
97472: PUSH
97473: LD_VAR 0 1
97477: PUSH
97478: LD_INT 4
97480: MINUS
97481: PUSH
97482: LD_VAR 0 2
97486: PUSH
97487: LD_INT 1
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: LIST
97494: PUSH
97495: LD_VAR 0 1
97499: PUSH
97500: LD_VAR 0 2
97504: PUSH
97505: LD_INT 4
97507: MINUS
97508: PUSH
97509: LD_INT 3
97511: PUSH
97512: EMPTY
97513: LIST
97514: LIST
97515: LIST
97516: PUSH
97517: LD_VAR 0 1
97521: PUSH
97522: LD_INT 4
97524: PLUS
97525: PUSH
97526: LD_VAR 0 2
97530: PUSH
97531: LD_INT 4
97533: PLUS
97534: PUSH
97535: LD_INT 5
97537: PUSH
97538: EMPTY
97539: LIST
97540: LIST
97541: LIST
97542: PUSH
97543: LD_VAR 0 1
97547: PUSH
97548: LD_INT 3
97550: PLUS
97551: PUSH
97552: LD_VAR 0 2
97556: PUSH
97557: LD_INT 4
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: LIST
97564: PUSH
97565: LD_VAR 0 1
97569: PUSH
97570: LD_VAR 0 2
97574: PUSH
97575: LD_INT 3
97577: PLUS
97578: PUSH
97579: LD_INT 0
97581: PUSH
97582: EMPTY
97583: LIST
97584: LIST
97585: LIST
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: ST_TO_ADDR
// end ; end ;
97594: GO 97597
97596: POP
// result := list ;
97597: LD_ADDR_VAR 0 4
97601: PUSH
97602: LD_VAR 0 5
97606: ST_TO_ADDR
// end ;
97607: LD_VAR 0 4
97611: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
97612: LD_INT 0
97614: PPUSH
97615: PPUSH
97616: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
97617: LD_VAR 0 1
97621: NOT
97622: PUSH
97623: LD_VAR 0 2
97627: PUSH
97628: LD_INT 1
97630: PUSH
97631: LD_INT 2
97633: PUSH
97634: LD_INT 3
97636: PUSH
97637: LD_INT 4
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: IN
97646: NOT
97647: OR
97648: IFFALSE 97652
// exit ;
97650: GO 97744
// tmp := [ ] ;
97652: LD_ADDR_VAR 0 5
97656: PUSH
97657: EMPTY
97658: ST_TO_ADDR
// for i in units do
97659: LD_ADDR_VAR 0 4
97663: PUSH
97664: LD_VAR 0 1
97668: PUSH
97669: FOR_IN
97670: IFFALSE 97713
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
97672: LD_ADDR_VAR 0 5
97676: PUSH
97677: LD_VAR 0 5
97681: PPUSH
97682: LD_VAR 0 5
97686: PUSH
97687: LD_INT 1
97689: PLUS
97690: PPUSH
97691: LD_VAR 0 4
97695: PPUSH
97696: LD_VAR 0 2
97700: PPUSH
97701: CALL_OW 259
97705: PPUSH
97706: CALL_OW 2
97710: ST_TO_ADDR
97711: GO 97669
97713: POP
97714: POP
// if not tmp then
97715: LD_VAR 0 5
97719: NOT
97720: IFFALSE 97724
// exit ;
97722: GO 97744
// result := SortListByListDesc ( units , tmp ) ;
97724: LD_ADDR_VAR 0 3
97728: PUSH
97729: LD_VAR 0 1
97733: PPUSH
97734: LD_VAR 0 5
97738: PPUSH
97739: CALL_OW 77
97743: ST_TO_ADDR
// end ;
97744: LD_VAR 0 3
97748: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
97749: LD_INT 0
97751: PPUSH
97752: PPUSH
97753: PPUSH
// result := false ;
97754: LD_ADDR_VAR 0 3
97758: PUSH
97759: LD_INT 0
97761: ST_TO_ADDR
// x := GetX ( building ) ;
97762: LD_ADDR_VAR 0 4
97766: PUSH
97767: LD_VAR 0 2
97771: PPUSH
97772: CALL_OW 250
97776: ST_TO_ADDR
// y := GetY ( building ) ;
97777: LD_ADDR_VAR 0 5
97781: PUSH
97782: LD_VAR 0 2
97786: PPUSH
97787: CALL_OW 251
97791: ST_TO_ADDR
// if not building or not x or not y then
97792: LD_VAR 0 2
97796: NOT
97797: PUSH
97798: LD_VAR 0 4
97802: NOT
97803: OR
97804: PUSH
97805: LD_VAR 0 5
97809: NOT
97810: OR
97811: IFFALSE 97815
// exit ;
97813: GO 97907
// if GetTaskList ( unit ) then
97815: LD_VAR 0 1
97819: PPUSH
97820: CALL_OW 437
97824: IFFALSE 97907
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
97826: LD_STRING e
97828: PUSH
97829: LD_VAR 0 1
97833: PPUSH
97834: CALL_OW 437
97838: PUSH
97839: LD_INT 1
97841: ARRAY
97842: PUSH
97843: LD_INT 1
97845: ARRAY
97846: EQUAL
97847: PUSH
97848: LD_VAR 0 4
97852: PUSH
97853: LD_VAR 0 1
97857: PPUSH
97858: CALL_OW 437
97862: PUSH
97863: LD_INT 1
97865: ARRAY
97866: PUSH
97867: LD_INT 2
97869: ARRAY
97870: EQUAL
97871: AND
97872: PUSH
97873: LD_VAR 0 5
97877: PUSH
97878: LD_VAR 0 1
97882: PPUSH
97883: CALL_OW 437
97887: PUSH
97888: LD_INT 1
97890: ARRAY
97891: PUSH
97892: LD_INT 3
97894: ARRAY
97895: EQUAL
97896: AND
97897: IFFALSE 97907
// result := true end ;
97899: LD_ADDR_VAR 0 3
97903: PUSH
97904: LD_INT 1
97906: ST_TO_ADDR
// end ;
97907: LD_VAR 0 3
97911: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
97912: LD_INT 0
97914: PPUSH
// result := false ;
97915: LD_ADDR_VAR 0 4
97919: PUSH
97920: LD_INT 0
97922: ST_TO_ADDR
// if GetTaskList ( unit ) then
97923: LD_VAR 0 1
97927: PPUSH
97928: CALL_OW 437
97932: IFFALSE 98015
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
97934: LD_STRING M
97936: PUSH
97937: LD_VAR 0 1
97941: PPUSH
97942: CALL_OW 437
97946: PUSH
97947: LD_INT 1
97949: ARRAY
97950: PUSH
97951: LD_INT 1
97953: ARRAY
97954: EQUAL
97955: PUSH
97956: LD_VAR 0 2
97960: PUSH
97961: LD_VAR 0 1
97965: PPUSH
97966: CALL_OW 437
97970: PUSH
97971: LD_INT 1
97973: ARRAY
97974: PUSH
97975: LD_INT 2
97977: ARRAY
97978: EQUAL
97979: AND
97980: PUSH
97981: LD_VAR 0 3
97985: PUSH
97986: LD_VAR 0 1
97990: PPUSH
97991: CALL_OW 437
97995: PUSH
97996: LD_INT 1
97998: ARRAY
97999: PUSH
98000: LD_INT 3
98002: ARRAY
98003: EQUAL
98004: AND
98005: IFFALSE 98015
// result := true ;
98007: LD_ADDR_VAR 0 4
98011: PUSH
98012: LD_INT 1
98014: ST_TO_ADDR
// end ; end ;
98015: LD_VAR 0 4
98019: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
98020: LD_INT 0
98022: PPUSH
98023: PPUSH
98024: PPUSH
98025: PPUSH
// if not unit or not area then
98026: LD_VAR 0 1
98030: NOT
98031: PUSH
98032: LD_VAR 0 2
98036: NOT
98037: OR
98038: IFFALSE 98042
// exit ;
98040: GO 98206
// tmp := AreaToList ( area , i ) ;
98042: LD_ADDR_VAR 0 6
98046: PUSH
98047: LD_VAR 0 2
98051: PPUSH
98052: LD_VAR 0 5
98056: PPUSH
98057: CALL_OW 517
98061: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
98062: LD_ADDR_VAR 0 5
98066: PUSH
98067: DOUBLE
98068: LD_INT 1
98070: DEC
98071: ST_TO_ADDR
98072: LD_VAR 0 6
98076: PUSH
98077: LD_INT 1
98079: ARRAY
98080: PUSH
98081: FOR_TO
98082: IFFALSE 98204
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
98084: LD_ADDR_VAR 0 7
98088: PUSH
98089: LD_VAR 0 6
98093: PUSH
98094: LD_INT 1
98096: ARRAY
98097: PUSH
98098: LD_VAR 0 5
98102: ARRAY
98103: PUSH
98104: LD_VAR 0 6
98108: PUSH
98109: LD_INT 2
98111: ARRAY
98112: PUSH
98113: LD_VAR 0 5
98117: ARRAY
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
98123: LD_VAR 0 7
98127: PUSH
98128: LD_INT 1
98130: ARRAY
98131: PPUSH
98132: LD_VAR 0 7
98136: PUSH
98137: LD_INT 2
98139: ARRAY
98140: PPUSH
98141: CALL_OW 428
98145: PUSH
98146: LD_INT 0
98148: EQUAL
98149: IFFALSE 98202
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
98151: LD_VAR 0 1
98155: PPUSH
98156: LD_VAR 0 7
98160: PUSH
98161: LD_INT 1
98163: ARRAY
98164: PPUSH
98165: LD_VAR 0 7
98169: PUSH
98170: LD_INT 2
98172: ARRAY
98173: PPUSH
98174: LD_VAR 0 3
98178: PPUSH
98179: CALL_OW 48
// result := IsPlaced ( unit ) ;
98183: LD_ADDR_VAR 0 4
98187: PUSH
98188: LD_VAR 0 1
98192: PPUSH
98193: CALL_OW 305
98197: ST_TO_ADDR
// exit ;
98198: POP
98199: POP
98200: GO 98206
// end ; end ;
98202: GO 98081
98204: POP
98205: POP
// end ;
98206: LD_VAR 0 4
98210: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
98211: LD_INT 0
98213: PPUSH
98214: PPUSH
98215: PPUSH
// if not side or side > 8 then
98216: LD_VAR 0 1
98220: NOT
98221: PUSH
98222: LD_VAR 0 1
98226: PUSH
98227: LD_INT 8
98229: GREATER
98230: OR
98231: IFFALSE 98235
// exit ;
98233: GO 98422
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
98235: LD_ADDR_VAR 0 4
98239: PUSH
98240: LD_INT 22
98242: PUSH
98243: LD_VAR 0 1
98247: PUSH
98248: EMPTY
98249: LIST
98250: LIST
98251: PUSH
98252: LD_INT 21
98254: PUSH
98255: LD_INT 3
98257: PUSH
98258: EMPTY
98259: LIST
98260: LIST
98261: PUSH
98262: EMPTY
98263: LIST
98264: LIST
98265: PPUSH
98266: CALL_OW 69
98270: ST_TO_ADDR
// if not tmp then
98271: LD_VAR 0 4
98275: NOT
98276: IFFALSE 98280
// exit ;
98278: GO 98422
// enable_addtolog := true ;
98280: LD_ADDR_OWVAR 81
98284: PUSH
98285: LD_INT 1
98287: ST_TO_ADDR
// AddToLog ( [ ) ;
98288: LD_STRING [
98290: PPUSH
98291: CALL_OW 561
// for i in tmp do
98295: LD_ADDR_VAR 0 3
98299: PUSH
98300: LD_VAR 0 4
98304: PUSH
98305: FOR_IN
98306: IFFALSE 98413
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
98308: LD_STRING [
98310: PUSH
98311: LD_VAR 0 3
98315: PPUSH
98316: CALL_OW 266
98320: STR
98321: PUSH
98322: LD_STRING , 
98324: STR
98325: PUSH
98326: LD_VAR 0 3
98330: PPUSH
98331: CALL_OW 250
98335: STR
98336: PUSH
98337: LD_STRING , 
98339: STR
98340: PUSH
98341: LD_VAR 0 3
98345: PPUSH
98346: CALL_OW 251
98350: STR
98351: PUSH
98352: LD_STRING , 
98354: STR
98355: PUSH
98356: LD_VAR 0 3
98360: PPUSH
98361: CALL_OW 254
98365: STR
98366: PUSH
98367: LD_STRING , 
98369: STR
98370: PUSH
98371: LD_VAR 0 3
98375: PPUSH
98376: LD_INT 1
98378: PPUSH
98379: CALL_OW 268
98383: STR
98384: PUSH
98385: LD_STRING , 
98387: STR
98388: PUSH
98389: LD_VAR 0 3
98393: PPUSH
98394: LD_INT 2
98396: PPUSH
98397: CALL_OW 268
98401: STR
98402: PUSH
98403: LD_STRING ],
98405: STR
98406: PPUSH
98407: CALL_OW 561
// end ;
98411: GO 98305
98413: POP
98414: POP
// AddToLog ( ]; ) ;
98415: LD_STRING ];
98417: PPUSH
98418: CALL_OW 561
// end ;
98422: LD_VAR 0 2
98426: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
98427: LD_INT 0
98429: PPUSH
98430: PPUSH
98431: PPUSH
98432: PPUSH
98433: PPUSH
// if not area or not rate or not max then
98434: LD_VAR 0 1
98438: NOT
98439: PUSH
98440: LD_VAR 0 2
98444: NOT
98445: OR
98446: PUSH
98447: LD_VAR 0 4
98451: NOT
98452: OR
98453: IFFALSE 98457
// exit ;
98455: GO 98646
// while 1 do
98457: LD_INT 1
98459: IFFALSE 98646
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
98461: LD_ADDR_VAR 0 9
98465: PUSH
98466: LD_VAR 0 1
98470: PPUSH
98471: LD_INT 1
98473: PPUSH
98474: CALL_OW 287
98478: PUSH
98479: LD_INT 10
98481: MUL
98482: ST_TO_ADDR
// r := rate / 10 ;
98483: LD_ADDR_VAR 0 7
98487: PUSH
98488: LD_VAR 0 2
98492: PUSH
98493: LD_INT 10
98495: DIVREAL
98496: ST_TO_ADDR
// time := 1 1$00 ;
98497: LD_ADDR_VAR 0 8
98501: PUSH
98502: LD_INT 2100
98504: ST_TO_ADDR
// if amount < min then
98505: LD_VAR 0 9
98509: PUSH
98510: LD_VAR 0 3
98514: LESS
98515: IFFALSE 98533
// r := r * 2 else
98517: LD_ADDR_VAR 0 7
98521: PUSH
98522: LD_VAR 0 7
98526: PUSH
98527: LD_INT 2
98529: MUL
98530: ST_TO_ADDR
98531: GO 98559
// if amount > max then
98533: LD_VAR 0 9
98537: PUSH
98538: LD_VAR 0 4
98542: GREATER
98543: IFFALSE 98559
// r := r / 2 ;
98545: LD_ADDR_VAR 0 7
98549: PUSH
98550: LD_VAR 0 7
98554: PUSH
98555: LD_INT 2
98557: DIVREAL
98558: ST_TO_ADDR
// time := time / r ;
98559: LD_ADDR_VAR 0 8
98563: PUSH
98564: LD_VAR 0 8
98568: PUSH
98569: LD_VAR 0 7
98573: DIVREAL
98574: ST_TO_ADDR
// if time < 0 then
98575: LD_VAR 0 8
98579: PUSH
98580: LD_INT 0
98582: LESS
98583: IFFALSE 98600
// time := time * - 1 ;
98585: LD_ADDR_VAR 0 8
98589: PUSH
98590: LD_VAR 0 8
98594: PUSH
98595: LD_INT 1
98597: NEG
98598: MUL
98599: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
98600: LD_VAR 0 8
98604: PUSH
98605: LD_INT 35
98607: PPUSH
98608: LD_INT 875
98610: PPUSH
98611: CALL_OW 12
98615: PLUS
98616: PPUSH
98617: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
98621: LD_INT 1
98623: PPUSH
98624: LD_INT 5
98626: PPUSH
98627: CALL_OW 12
98631: PPUSH
98632: LD_VAR 0 1
98636: PPUSH
98637: LD_INT 1
98639: PPUSH
98640: CALL_OW 55
// end ;
98644: GO 98457
// end ;
98646: LD_VAR 0 5
98650: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
98651: LD_INT 0
98653: PPUSH
98654: PPUSH
98655: PPUSH
98656: PPUSH
98657: PPUSH
98658: PPUSH
98659: PPUSH
98660: PPUSH
// if not turrets or not factories then
98661: LD_VAR 0 1
98665: NOT
98666: PUSH
98667: LD_VAR 0 2
98671: NOT
98672: OR
98673: IFFALSE 98677
// exit ;
98675: GO 98984
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
98677: LD_ADDR_VAR 0 10
98681: PUSH
98682: LD_INT 5
98684: PUSH
98685: LD_INT 6
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: PUSH
98692: LD_INT 2
98694: PUSH
98695: LD_INT 4
98697: PUSH
98698: EMPTY
98699: LIST
98700: LIST
98701: PUSH
98702: LD_INT 3
98704: PUSH
98705: LD_INT 5
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: EMPTY
98713: LIST
98714: LIST
98715: LIST
98716: PUSH
98717: LD_INT 24
98719: PUSH
98720: LD_INT 25
98722: PUSH
98723: EMPTY
98724: LIST
98725: LIST
98726: PUSH
98727: LD_INT 23
98729: PUSH
98730: LD_INT 27
98732: PUSH
98733: EMPTY
98734: LIST
98735: LIST
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: PUSH
98741: LD_INT 42
98743: PUSH
98744: LD_INT 43
98746: PUSH
98747: EMPTY
98748: LIST
98749: LIST
98750: PUSH
98751: LD_INT 44
98753: PUSH
98754: LD_INT 46
98756: PUSH
98757: EMPTY
98758: LIST
98759: LIST
98760: PUSH
98761: LD_INT 45
98763: PUSH
98764: LD_INT 47
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: LIST
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: LIST
98780: ST_TO_ADDR
// result := [ ] ;
98781: LD_ADDR_VAR 0 3
98785: PUSH
98786: EMPTY
98787: ST_TO_ADDR
// for i in turrets do
98788: LD_ADDR_VAR 0 4
98792: PUSH
98793: LD_VAR 0 1
98797: PUSH
98798: FOR_IN
98799: IFFALSE 98982
// begin nat := GetNation ( i ) ;
98801: LD_ADDR_VAR 0 7
98805: PUSH
98806: LD_VAR 0 4
98810: PPUSH
98811: CALL_OW 248
98815: ST_TO_ADDR
// weapon := 0 ;
98816: LD_ADDR_VAR 0 8
98820: PUSH
98821: LD_INT 0
98823: ST_TO_ADDR
// if not nat then
98824: LD_VAR 0 7
98828: NOT
98829: IFFALSE 98833
// continue ;
98831: GO 98798
// for j in list [ nat ] do
98833: LD_ADDR_VAR 0 5
98837: PUSH
98838: LD_VAR 0 10
98842: PUSH
98843: LD_VAR 0 7
98847: ARRAY
98848: PUSH
98849: FOR_IN
98850: IFFALSE 98891
// if GetBWeapon ( i ) = j [ 1 ] then
98852: LD_VAR 0 4
98856: PPUSH
98857: CALL_OW 269
98861: PUSH
98862: LD_VAR 0 5
98866: PUSH
98867: LD_INT 1
98869: ARRAY
98870: EQUAL
98871: IFFALSE 98889
// begin weapon := j [ 2 ] ;
98873: LD_ADDR_VAR 0 8
98877: PUSH
98878: LD_VAR 0 5
98882: PUSH
98883: LD_INT 2
98885: ARRAY
98886: ST_TO_ADDR
// break ;
98887: GO 98891
// end ;
98889: GO 98849
98891: POP
98892: POP
// if not weapon then
98893: LD_VAR 0 8
98897: NOT
98898: IFFALSE 98902
// continue ;
98900: GO 98798
// for k in factories do
98902: LD_ADDR_VAR 0 6
98906: PUSH
98907: LD_VAR 0 2
98911: PUSH
98912: FOR_IN
98913: IFFALSE 98978
// begin weapons := AvailableWeaponList ( k ) ;
98915: LD_ADDR_VAR 0 9
98919: PUSH
98920: LD_VAR 0 6
98924: PPUSH
98925: CALL_OW 478
98929: ST_TO_ADDR
// if not weapons then
98930: LD_VAR 0 9
98934: NOT
98935: IFFALSE 98939
// continue ;
98937: GO 98912
// if weapon in weapons then
98939: LD_VAR 0 8
98943: PUSH
98944: LD_VAR 0 9
98948: IN
98949: IFFALSE 98976
// begin result := [ i , weapon ] ;
98951: LD_ADDR_VAR 0 3
98955: PUSH
98956: LD_VAR 0 4
98960: PUSH
98961: LD_VAR 0 8
98965: PUSH
98966: EMPTY
98967: LIST
98968: LIST
98969: ST_TO_ADDR
// exit ;
98970: POP
98971: POP
98972: POP
98973: POP
98974: GO 98984
// end ; end ;
98976: GO 98912
98978: POP
98979: POP
// end ;
98980: GO 98798
98982: POP
98983: POP
// end ;
98984: LD_VAR 0 3
98988: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
98989: LD_INT 0
98991: PPUSH
// if not side or side > 8 then
98992: LD_VAR 0 3
98996: NOT
98997: PUSH
98998: LD_VAR 0 3
99002: PUSH
99003: LD_INT 8
99005: GREATER
99006: OR
99007: IFFALSE 99011
// exit ;
99009: GO 99070
// if not range then
99011: LD_VAR 0 4
99015: NOT
99016: IFFALSE 99027
// range := - 12 ;
99018: LD_ADDR_VAR 0 4
99022: PUSH
99023: LD_INT 12
99025: NEG
99026: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
99027: LD_VAR 0 1
99031: PPUSH
99032: LD_VAR 0 2
99036: PPUSH
99037: LD_VAR 0 3
99041: PPUSH
99042: LD_VAR 0 4
99046: PPUSH
99047: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
99051: LD_VAR 0 1
99055: PPUSH
99056: LD_VAR 0 2
99060: PPUSH
99061: LD_VAR 0 3
99065: PPUSH
99066: CALL_OW 331
// end ;
99070: LD_VAR 0 5
99074: RET
// export function Video ( mode ) ; begin
99075: LD_INT 0
99077: PPUSH
// ingame_video = mode ;
99078: LD_ADDR_OWVAR 52
99082: PUSH
99083: LD_VAR 0 1
99087: ST_TO_ADDR
// interface_hidden = mode ;
99088: LD_ADDR_OWVAR 54
99092: PUSH
99093: LD_VAR 0 1
99097: ST_TO_ADDR
// end ;
99098: LD_VAR 0 2
99102: RET
// export function Join ( array , element ) ; begin
99103: LD_INT 0
99105: PPUSH
// result := Replace ( array , array + 1 , element ) ;
99106: LD_ADDR_VAR 0 3
99110: PUSH
99111: LD_VAR 0 1
99115: PPUSH
99116: LD_VAR 0 1
99120: PUSH
99121: LD_INT 1
99123: PLUS
99124: PPUSH
99125: LD_VAR 0 2
99129: PPUSH
99130: CALL_OW 1
99134: ST_TO_ADDR
// end ;
99135: LD_VAR 0 3
99139: RET
// export function JoinUnion ( array , element ) ; begin
99140: LD_INT 0
99142: PPUSH
// result := array union element ;
99143: LD_ADDR_VAR 0 3
99147: PUSH
99148: LD_VAR 0 1
99152: PUSH
99153: LD_VAR 0 2
99157: UNION
99158: ST_TO_ADDR
// end ;
99159: LD_VAR 0 3
99163: RET
// export function GetBehemoths ( side ) ; begin
99164: LD_INT 0
99166: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
99167: LD_ADDR_VAR 0 2
99171: PUSH
99172: LD_INT 22
99174: PUSH
99175: LD_VAR 0 1
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: PUSH
99184: LD_INT 31
99186: PUSH
99187: LD_INT 25
99189: PUSH
99190: EMPTY
99191: LIST
99192: LIST
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PPUSH
99198: CALL_OW 69
99202: ST_TO_ADDR
// end ;
99203: LD_VAR 0 2
99207: RET
// export function Shuffle ( array ) ; var i , index ; begin
99208: LD_INT 0
99210: PPUSH
99211: PPUSH
99212: PPUSH
// result := [ ] ;
99213: LD_ADDR_VAR 0 2
99217: PUSH
99218: EMPTY
99219: ST_TO_ADDR
// if not array then
99220: LD_VAR 0 1
99224: NOT
99225: IFFALSE 99229
// exit ;
99227: GO 99328
// Randomize ;
99229: CALL_OW 10
// for i = array downto 1 do
99233: LD_ADDR_VAR 0 3
99237: PUSH
99238: DOUBLE
99239: LD_VAR 0 1
99243: INC
99244: ST_TO_ADDR
99245: LD_INT 1
99247: PUSH
99248: FOR_DOWNTO
99249: IFFALSE 99326
// begin index := rand ( 1 , array ) ;
99251: LD_ADDR_VAR 0 4
99255: PUSH
99256: LD_INT 1
99258: PPUSH
99259: LD_VAR 0 1
99263: PPUSH
99264: CALL_OW 12
99268: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
99269: LD_ADDR_VAR 0 2
99273: PUSH
99274: LD_VAR 0 2
99278: PPUSH
99279: LD_VAR 0 2
99283: PUSH
99284: LD_INT 1
99286: PLUS
99287: PPUSH
99288: LD_VAR 0 1
99292: PUSH
99293: LD_VAR 0 4
99297: ARRAY
99298: PPUSH
99299: CALL_OW 2
99303: ST_TO_ADDR
// array := Delete ( array , index ) ;
99304: LD_ADDR_VAR 0 1
99308: PUSH
99309: LD_VAR 0 1
99313: PPUSH
99314: LD_VAR 0 4
99318: PPUSH
99319: CALL_OW 3
99323: ST_TO_ADDR
// end ;
99324: GO 99248
99326: POP
99327: POP
// end ;
99328: LD_VAR 0 2
99332: RET
// export function GetBaseMaterials ( base ) ; begin
99333: LD_INT 0
99335: PPUSH
// result := [ 0 , 0 , 0 ] ;
99336: LD_ADDR_VAR 0 2
99340: PUSH
99341: LD_INT 0
99343: PUSH
99344: LD_INT 0
99346: PUSH
99347: LD_INT 0
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: LIST
99354: ST_TO_ADDR
// if not base then
99355: LD_VAR 0 1
99359: NOT
99360: IFFALSE 99364
// exit ;
99362: GO 99413
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
99364: LD_ADDR_VAR 0 2
99368: PUSH
99369: LD_VAR 0 1
99373: PPUSH
99374: LD_INT 1
99376: PPUSH
99377: CALL_OW 275
99381: PUSH
99382: LD_VAR 0 1
99386: PPUSH
99387: LD_INT 2
99389: PPUSH
99390: CALL_OW 275
99394: PUSH
99395: LD_VAR 0 1
99399: PPUSH
99400: LD_INT 3
99402: PPUSH
99403: CALL_OW 275
99407: PUSH
99408: EMPTY
99409: LIST
99410: LIST
99411: LIST
99412: ST_TO_ADDR
// end ;
99413: LD_VAR 0 2
99417: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
99418: LD_INT 0
99420: PPUSH
99421: PPUSH
// result := array ;
99422: LD_ADDR_VAR 0 3
99426: PUSH
99427: LD_VAR 0 1
99431: ST_TO_ADDR
// if size > 0 then
99432: LD_VAR 0 2
99436: PUSH
99437: LD_INT 0
99439: GREATER
99440: IFFALSE 99486
// for i := array downto size do
99442: LD_ADDR_VAR 0 4
99446: PUSH
99447: DOUBLE
99448: LD_VAR 0 1
99452: INC
99453: ST_TO_ADDR
99454: LD_VAR 0 2
99458: PUSH
99459: FOR_DOWNTO
99460: IFFALSE 99484
// result := Delete ( result , result ) ;
99462: LD_ADDR_VAR 0 3
99466: PUSH
99467: LD_VAR 0 3
99471: PPUSH
99472: LD_VAR 0 3
99476: PPUSH
99477: CALL_OW 3
99481: ST_TO_ADDR
99482: GO 99459
99484: POP
99485: POP
// end ;
99486: LD_VAR 0 3
99490: RET
// export function ComExit ( unit ) ; var tmp ; begin
99491: LD_INT 0
99493: PPUSH
99494: PPUSH
// if not IsInUnit ( unit ) then
99495: LD_VAR 0 1
99499: PPUSH
99500: CALL_OW 310
99504: NOT
99505: IFFALSE 99509
// exit ;
99507: GO 99569
// tmp := IsInUnit ( unit ) ;
99509: LD_ADDR_VAR 0 3
99513: PUSH
99514: LD_VAR 0 1
99518: PPUSH
99519: CALL_OW 310
99523: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
99524: LD_VAR 0 3
99528: PPUSH
99529: CALL_OW 247
99533: PUSH
99534: LD_INT 2
99536: EQUAL
99537: IFFALSE 99550
// ComExitVehicle ( unit ) else
99539: LD_VAR 0 1
99543: PPUSH
99544: CALL_OW 121
99548: GO 99559
// ComExitBuilding ( unit ) ;
99550: LD_VAR 0 1
99554: PPUSH
99555: CALL_OW 122
// result := tmp ;
99559: LD_ADDR_VAR 0 2
99563: PUSH
99564: LD_VAR 0 3
99568: ST_TO_ADDR
// end ;
99569: LD_VAR 0 2
99573: RET
// export function ComExitAll ( units ) ; var i ; begin
99574: LD_INT 0
99576: PPUSH
99577: PPUSH
// if not units then
99578: LD_VAR 0 1
99582: NOT
99583: IFFALSE 99587
// exit ;
99585: GO 99613
// for i in units do
99587: LD_ADDR_VAR 0 3
99591: PUSH
99592: LD_VAR 0 1
99596: PUSH
99597: FOR_IN
99598: IFFALSE 99611
// ComExit ( i ) ;
99600: LD_VAR 0 3
99604: PPUSH
99605: CALL 99491 0 1
99609: GO 99597
99611: POP
99612: POP
// end ;
99613: LD_VAR 0 2
99617: RET
// export function ResetHc ; begin
99618: LD_INT 0
99620: PPUSH
// InitHc ;
99621: CALL_OW 19
// hc_importance := 0 ;
99625: LD_ADDR_OWVAR 32
99629: PUSH
99630: LD_INT 0
99632: ST_TO_ADDR
// end ;
99633: LD_VAR 0 1
99637: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
99638: LD_INT 0
99640: PPUSH
99641: PPUSH
99642: PPUSH
// _x := ( x1 + x2 ) div 2 ;
99643: LD_ADDR_VAR 0 6
99647: PUSH
99648: LD_VAR 0 1
99652: PUSH
99653: LD_VAR 0 3
99657: PLUS
99658: PUSH
99659: LD_INT 2
99661: DIV
99662: ST_TO_ADDR
// if _x < 0 then
99663: LD_VAR 0 6
99667: PUSH
99668: LD_INT 0
99670: LESS
99671: IFFALSE 99688
// _x := _x * - 1 ;
99673: LD_ADDR_VAR 0 6
99677: PUSH
99678: LD_VAR 0 6
99682: PUSH
99683: LD_INT 1
99685: NEG
99686: MUL
99687: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
99688: LD_ADDR_VAR 0 7
99692: PUSH
99693: LD_VAR 0 2
99697: PUSH
99698: LD_VAR 0 4
99702: PLUS
99703: PUSH
99704: LD_INT 2
99706: DIV
99707: ST_TO_ADDR
// if _y < 0 then
99708: LD_VAR 0 7
99712: PUSH
99713: LD_INT 0
99715: LESS
99716: IFFALSE 99733
// _y := _y * - 1 ;
99718: LD_ADDR_VAR 0 7
99722: PUSH
99723: LD_VAR 0 7
99727: PUSH
99728: LD_INT 1
99730: NEG
99731: MUL
99732: ST_TO_ADDR
// result := [ _x , _y ] ;
99733: LD_ADDR_VAR 0 5
99737: PUSH
99738: LD_VAR 0 6
99742: PUSH
99743: LD_VAR 0 7
99747: PUSH
99748: EMPTY
99749: LIST
99750: LIST
99751: ST_TO_ADDR
// end ;
99752: LD_VAR 0 5
99756: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
99757: LD_INT 0
99759: PPUSH
99760: PPUSH
99761: PPUSH
99762: PPUSH
// task := GetTaskList ( unit ) ;
99763: LD_ADDR_VAR 0 7
99767: PUSH
99768: LD_VAR 0 1
99772: PPUSH
99773: CALL_OW 437
99777: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
99778: LD_VAR 0 7
99782: NOT
99783: PUSH
99784: LD_VAR 0 1
99788: PPUSH
99789: LD_VAR 0 2
99793: PPUSH
99794: CALL_OW 308
99798: NOT
99799: AND
99800: IFFALSE 99804
// exit ;
99802: GO 99922
// if IsInArea ( unit , area ) then
99804: LD_VAR 0 1
99808: PPUSH
99809: LD_VAR 0 2
99813: PPUSH
99814: CALL_OW 308
99818: IFFALSE 99836
// begin ComMoveToArea ( unit , goAway ) ;
99820: LD_VAR 0 1
99824: PPUSH
99825: LD_VAR 0 3
99829: PPUSH
99830: CALL_OW 113
// exit ;
99834: GO 99922
// end ; if task [ 1 ] [ 1 ] <> M then
99836: LD_VAR 0 7
99840: PUSH
99841: LD_INT 1
99843: ARRAY
99844: PUSH
99845: LD_INT 1
99847: ARRAY
99848: PUSH
99849: LD_STRING M
99851: NONEQUAL
99852: IFFALSE 99856
// exit ;
99854: GO 99922
// x := task [ 1 ] [ 2 ] ;
99856: LD_ADDR_VAR 0 5
99860: PUSH
99861: LD_VAR 0 7
99865: PUSH
99866: LD_INT 1
99868: ARRAY
99869: PUSH
99870: LD_INT 2
99872: ARRAY
99873: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
99874: LD_ADDR_VAR 0 6
99878: PUSH
99879: LD_VAR 0 7
99883: PUSH
99884: LD_INT 1
99886: ARRAY
99887: PUSH
99888: LD_INT 3
99890: ARRAY
99891: ST_TO_ADDR
// if InArea ( x , y , area ) then
99892: LD_VAR 0 5
99896: PPUSH
99897: LD_VAR 0 6
99901: PPUSH
99902: LD_VAR 0 2
99906: PPUSH
99907: CALL_OW 309
99911: IFFALSE 99922
// ComStop ( unit ) ;
99913: LD_VAR 0 1
99917: PPUSH
99918: CALL_OW 141
// end ;
99922: LD_VAR 0 4
99926: RET
// export function Abs ( value ) ; begin
99927: LD_INT 0
99929: PPUSH
// result := value ;
99930: LD_ADDR_VAR 0 2
99934: PUSH
99935: LD_VAR 0 1
99939: ST_TO_ADDR
// if value < 0 then
99940: LD_VAR 0 1
99944: PUSH
99945: LD_INT 0
99947: LESS
99948: IFFALSE 99965
// result := value * - 1 ;
99950: LD_ADDR_VAR 0 2
99954: PUSH
99955: LD_VAR 0 1
99959: PUSH
99960: LD_INT 1
99962: NEG
99963: MUL
99964: ST_TO_ADDR
// end ;
99965: LD_VAR 0 2
99969: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
99970: LD_INT 0
99972: PPUSH
99973: PPUSH
99974: PPUSH
99975: PPUSH
99976: PPUSH
99977: PPUSH
99978: PPUSH
99979: PPUSH
// if not unit or not building then
99980: LD_VAR 0 1
99984: NOT
99985: PUSH
99986: LD_VAR 0 2
99990: NOT
99991: OR
99992: IFFALSE 99996
// exit ;
99994: GO 100222
// x := GetX ( building ) ;
99996: LD_ADDR_VAR 0 4
100000: PUSH
100001: LD_VAR 0 2
100005: PPUSH
100006: CALL_OW 250
100010: ST_TO_ADDR
// y := GetY ( building ) ;
100011: LD_ADDR_VAR 0 6
100015: PUSH
100016: LD_VAR 0 2
100020: PPUSH
100021: CALL_OW 251
100025: ST_TO_ADDR
// d := GetDir ( building ) ;
100026: LD_ADDR_VAR 0 8
100030: PUSH
100031: LD_VAR 0 2
100035: PPUSH
100036: CALL_OW 254
100040: ST_TO_ADDR
// r := 4 ;
100041: LD_ADDR_VAR 0 9
100045: PUSH
100046: LD_INT 4
100048: ST_TO_ADDR
// for i := 1 to 5 do
100049: LD_ADDR_VAR 0 10
100053: PUSH
100054: DOUBLE
100055: LD_INT 1
100057: DEC
100058: ST_TO_ADDR
100059: LD_INT 5
100061: PUSH
100062: FOR_TO
100063: IFFALSE 100220
// begin _x := ShiftX ( x , d , r + i ) ;
100065: LD_ADDR_VAR 0 5
100069: PUSH
100070: LD_VAR 0 4
100074: PPUSH
100075: LD_VAR 0 8
100079: PPUSH
100080: LD_VAR 0 9
100084: PUSH
100085: LD_VAR 0 10
100089: PLUS
100090: PPUSH
100091: CALL_OW 272
100095: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
100096: LD_ADDR_VAR 0 7
100100: PUSH
100101: LD_VAR 0 6
100105: PPUSH
100106: LD_VAR 0 8
100110: PPUSH
100111: LD_VAR 0 9
100115: PUSH
100116: LD_VAR 0 10
100120: PLUS
100121: PPUSH
100122: CALL_OW 273
100126: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
100127: LD_VAR 0 5
100131: PPUSH
100132: LD_VAR 0 7
100136: PPUSH
100137: CALL_OW 488
100141: PUSH
100142: LD_VAR 0 5
100146: PPUSH
100147: LD_VAR 0 7
100151: PPUSH
100152: CALL_OW 428
100156: PPUSH
100157: CALL_OW 247
100161: PUSH
100162: LD_INT 3
100164: PUSH
100165: LD_INT 2
100167: PUSH
100168: EMPTY
100169: LIST
100170: LIST
100171: IN
100172: NOT
100173: AND
100174: IFFALSE 100218
// begin ComMoveXY ( unit , _x , _y ) ;
100176: LD_VAR 0 1
100180: PPUSH
100181: LD_VAR 0 5
100185: PPUSH
100186: LD_VAR 0 7
100190: PPUSH
100191: CALL_OW 111
// result := [ _x , _y ] ;
100195: LD_ADDR_VAR 0 3
100199: PUSH
100200: LD_VAR 0 5
100204: PUSH
100205: LD_VAR 0 7
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: ST_TO_ADDR
// exit ;
100214: POP
100215: POP
100216: GO 100222
// end ; end ;
100218: GO 100062
100220: POP
100221: POP
// end ;
100222: LD_VAR 0 3
100226: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
100227: LD_INT 0
100229: PPUSH
100230: PPUSH
100231: PPUSH
// result := 0 ;
100232: LD_ADDR_VAR 0 3
100236: PUSH
100237: LD_INT 0
100239: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
100240: LD_VAR 0 1
100244: PUSH
100245: LD_INT 0
100247: LESS
100248: PUSH
100249: LD_VAR 0 1
100253: PUSH
100254: LD_INT 8
100256: GREATER
100257: OR
100258: PUSH
100259: LD_VAR 0 2
100263: PUSH
100264: LD_INT 0
100266: LESS
100267: OR
100268: PUSH
100269: LD_VAR 0 2
100273: PUSH
100274: LD_INT 8
100276: GREATER
100277: OR
100278: IFFALSE 100282
// exit ;
100280: GO 100357
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
100282: LD_ADDR_VAR 0 4
100286: PUSH
100287: LD_INT 22
100289: PUSH
100290: LD_VAR 0 2
100294: PUSH
100295: EMPTY
100296: LIST
100297: LIST
100298: PPUSH
100299: CALL_OW 69
100303: PUSH
100304: FOR_IN
100305: IFFALSE 100355
// begin un := UnitShoot ( i ) ;
100307: LD_ADDR_VAR 0 5
100311: PUSH
100312: LD_VAR 0 4
100316: PPUSH
100317: CALL_OW 504
100321: ST_TO_ADDR
// if GetSide ( un ) = side1 then
100322: LD_VAR 0 5
100326: PPUSH
100327: CALL_OW 255
100331: PUSH
100332: LD_VAR 0 1
100336: EQUAL
100337: IFFALSE 100353
// begin result := un ;
100339: LD_ADDR_VAR 0 3
100343: PUSH
100344: LD_VAR 0 5
100348: ST_TO_ADDR
// exit ;
100349: POP
100350: POP
100351: GO 100357
// end ; end ;
100353: GO 100304
100355: POP
100356: POP
// end ;
100357: LD_VAR 0 3
100361: RET
// export function GetCargoBay ( units ) ; begin
100362: LD_INT 0
100364: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
100365: LD_ADDR_VAR 0 2
100369: PUSH
100370: LD_VAR 0 1
100374: PPUSH
100375: LD_INT 2
100377: PUSH
100378: LD_INT 34
100380: PUSH
100381: LD_INT 12
100383: PUSH
100384: EMPTY
100385: LIST
100386: LIST
100387: PUSH
100388: LD_INT 34
100390: PUSH
100391: LD_INT 51
100393: PUSH
100394: EMPTY
100395: LIST
100396: LIST
100397: PUSH
100398: LD_INT 34
100400: PUSH
100401: LD_INT 32
100403: PUSH
100404: EMPTY
100405: LIST
100406: LIST
100407: PUSH
100408: LD_INT 34
100410: PUSH
100411: LD_EXP 74
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: PPUSH
100427: CALL_OW 72
100431: ST_TO_ADDR
// end ;
100432: LD_VAR 0 2
100436: RET
// export function Negate ( value ) ; begin
100437: LD_INT 0
100439: PPUSH
// result := not value ;
100440: LD_ADDR_VAR 0 2
100444: PUSH
100445: LD_VAR 0 1
100449: NOT
100450: ST_TO_ADDR
// end ;
100451: LD_VAR 0 2
100455: RET
// export function Inc ( value ) ; begin
100456: LD_INT 0
100458: PPUSH
// result := value + 1 ;
100459: LD_ADDR_VAR 0 2
100463: PUSH
100464: LD_VAR 0 1
100468: PUSH
100469: LD_INT 1
100471: PLUS
100472: ST_TO_ADDR
// end ;
100473: LD_VAR 0 2
100477: RET
// export function Dec ( value ) ; begin
100478: LD_INT 0
100480: PPUSH
// result := value - 1 ;
100481: LD_ADDR_VAR 0 2
100485: PUSH
100486: LD_VAR 0 1
100490: PUSH
100491: LD_INT 1
100493: MINUS
100494: ST_TO_ADDR
// end ;
100495: LD_VAR 0 2
100499: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
100500: LD_INT 0
100502: PPUSH
100503: PPUSH
100504: PPUSH
100505: PPUSH
100506: PPUSH
100507: PPUSH
100508: PPUSH
100509: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
100510: LD_VAR 0 1
100514: PPUSH
100515: LD_VAR 0 2
100519: PPUSH
100520: CALL_OW 488
100524: NOT
100525: PUSH
100526: LD_VAR 0 3
100530: PPUSH
100531: LD_VAR 0 4
100535: PPUSH
100536: CALL_OW 488
100540: NOT
100541: OR
100542: IFFALSE 100555
// begin result := - 1 ;
100544: LD_ADDR_VAR 0 5
100548: PUSH
100549: LD_INT 1
100551: NEG
100552: ST_TO_ADDR
// exit ;
100553: GO 100790
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
100555: LD_ADDR_VAR 0 12
100559: PUSH
100560: LD_VAR 0 1
100564: PPUSH
100565: LD_VAR 0 2
100569: PPUSH
100570: LD_VAR 0 3
100574: PPUSH
100575: LD_VAR 0 4
100579: PPUSH
100580: CALL 99638 0 4
100584: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
100585: LD_ADDR_VAR 0 11
100589: PUSH
100590: LD_VAR 0 1
100594: PPUSH
100595: LD_VAR 0 2
100599: PPUSH
100600: LD_VAR 0 12
100604: PUSH
100605: LD_INT 1
100607: ARRAY
100608: PPUSH
100609: LD_VAR 0 12
100613: PUSH
100614: LD_INT 2
100616: ARRAY
100617: PPUSH
100618: CALL_OW 298
100622: ST_TO_ADDR
// distance := 9999 ;
100623: LD_ADDR_VAR 0 10
100627: PUSH
100628: LD_INT 9999
100630: ST_TO_ADDR
// for i := 0 to 5 do
100631: LD_ADDR_VAR 0 6
100635: PUSH
100636: DOUBLE
100637: LD_INT 0
100639: DEC
100640: ST_TO_ADDR
100641: LD_INT 5
100643: PUSH
100644: FOR_TO
100645: IFFALSE 100788
// begin _x := ShiftX ( x1 , i , centerDist ) ;
100647: LD_ADDR_VAR 0 7
100651: PUSH
100652: LD_VAR 0 1
100656: PPUSH
100657: LD_VAR 0 6
100661: PPUSH
100662: LD_VAR 0 11
100666: PPUSH
100667: CALL_OW 272
100671: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
100672: LD_ADDR_VAR 0 8
100676: PUSH
100677: LD_VAR 0 2
100681: PPUSH
100682: LD_VAR 0 6
100686: PPUSH
100687: LD_VAR 0 11
100691: PPUSH
100692: CALL_OW 273
100696: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
100697: LD_VAR 0 7
100701: PPUSH
100702: LD_VAR 0 8
100706: PPUSH
100707: CALL_OW 488
100711: NOT
100712: IFFALSE 100716
// continue ;
100714: GO 100644
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
100716: LD_ADDR_VAR 0 9
100720: PUSH
100721: LD_VAR 0 12
100725: PUSH
100726: LD_INT 1
100728: ARRAY
100729: PPUSH
100730: LD_VAR 0 12
100734: PUSH
100735: LD_INT 2
100737: ARRAY
100738: PPUSH
100739: LD_VAR 0 7
100743: PPUSH
100744: LD_VAR 0 8
100748: PPUSH
100749: CALL_OW 298
100753: ST_TO_ADDR
// if tmp < distance then
100754: LD_VAR 0 9
100758: PUSH
100759: LD_VAR 0 10
100763: LESS
100764: IFFALSE 100786
// begin result := i ;
100766: LD_ADDR_VAR 0 5
100770: PUSH
100771: LD_VAR 0 6
100775: ST_TO_ADDR
// distance := tmp ;
100776: LD_ADDR_VAR 0 10
100780: PUSH
100781: LD_VAR 0 9
100785: ST_TO_ADDR
// end ; end ;
100786: GO 100644
100788: POP
100789: POP
// end ;
100790: LD_VAR 0 5
100794: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
100795: LD_INT 0
100797: PPUSH
100798: PPUSH
// if not driver or not IsInUnit ( driver ) then
100799: LD_VAR 0 1
100803: NOT
100804: PUSH
100805: LD_VAR 0 1
100809: PPUSH
100810: CALL_OW 310
100814: NOT
100815: OR
100816: IFFALSE 100820
// exit ;
100818: GO 100910
// vehicle := IsInUnit ( driver ) ;
100820: LD_ADDR_VAR 0 3
100824: PUSH
100825: LD_VAR 0 1
100829: PPUSH
100830: CALL_OW 310
100834: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
100835: LD_VAR 0 1
100839: PPUSH
100840: LD_STRING \
100842: PUSH
100843: LD_INT 0
100845: PUSH
100846: LD_INT 0
100848: PUSH
100849: LD_INT 0
100851: PUSH
100852: LD_INT 0
100854: PUSH
100855: LD_INT 0
100857: PUSH
100858: LD_INT 0
100860: PUSH
100861: EMPTY
100862: LIST
100863: LIST
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: PUSH
100870: LD_STRING E
100872: PUSH
100873: LD_INT 0
100875: PUSH
100876: LD_INT 0
100878: PUSH
100879: LD_VAR 0 3
100883: PUSH
100884: LD_INT 0
100886: PUSH
100887: LD_INT 0
100889: PUSH
100890: LD_INT 0
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PPUSH
100906: CALL_OW 446
// end ;
100910: LD_VAR 0 2
100914: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
100915: LD_INT 0
100917: PPUSH
100918: PPUSH
// if not driver or not IsInUnit ( driver ) then
100919: LD_VAR 0 1
100923: NOT
100924: PUSH
100925: LD_VAR 0 1
100929: PPUSH
100930: CALL_OW 310
100934: NOT
100935: OR
100936: IFFALSE 100940
// exit ;
100938: GO 101030
// vehicle := IsInUnit ( driver ) ;
100940: LD_ADDR_VAR 0 3
100944: PUSH
100945: LD_VAR 0 1
100949: PPUSH
100950: CALL_OW 310
100954: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
100955: LD_VAR 0 1
100959: PPUSH
100960: LD_STRING \
100962: PUSH
100963: LD_INT 0
100965: PUSH
100966: LD_INT 0
100968: PUSH
100969: LD_INT 0
100971: PUSH
100972: LD_INT 0
100974: PUSH
100975: LD_INT 0
100977: PUSH
100978: LD_INT 0
100980: PUSH
100981: EMPTY
100982: LIST
100983: LIST
100984: LIST
100985: LIST
100986: LIST
100987: LIST
100988: LIST
100989: PUSH
100990: LD_STRING E
100992: PUSH
100993: LD_INT 0
100995: PUSH
100996: LD_INT 0
100998: PUSH
100999: LD_VAR 0 3
101003: PUSH
101004: LD_INT 0
101006: PUSH
101007: LD_INT 0
101009: PUSH
101010: LD_INT 0
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: PUSH
101022: EMPTY
101023: LIST
101024: LIST
101025: PPUSH
101026: CALL_OW 447
// end ;
101030: LD_VAR 0 2
101034: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
101035: LD_INT 0
101037: PPUSH
101038: PPUSH
101039: PPUSH
// tmp := [ ] ;
101040: LD_ADDR_VAR 0 5
101044: PUSH
101045: EMPTY
101046: ST_TO_ADDR
// for i in units do
101047: LD_ADDR_VAR 0 4
101051: PUSH
101052: LD_VAR 0 1
101056: PUSH
101057: FOR_IN
101058: IFFALSE 101096
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
101060: LD_ADDR_VAR 0 5
101064: PUSH
101065: LD_VAR 0 5
101069: PPUSH
101070: LD_VAR 0 5
101074: PUSH
101075: LD_INT 1
101077: PLUS
101078: PPUSH
101079: LD_VAR 0 4
101083: PPUSH
101084: CALL_OW 256
101088: PPUSH
101089: CALL_OW 2
101093: ST_TO_ADDR
101094: GO 101057
101096: POP
101097: POP
// if not tmp then
101098: LD_VAR 0 5
101102: NOT
101103: IFFALSE 101107
// exit ;
101105: GO 101155
// if asc then
101107: LD_VAR 0 2
101111: IFFALSE 101135
// result := SortListByListAsc ( units , tmp ) else
101113: LD_ADDR_VAR 0 3
101117: PUSH
101118: LD_VAR 0 1
101122: PPUSH
101123: LD_VAR 0 5
101127: PPUSH
101128: CALL_OW 76
101132: ST_TO_ADDR
101133: GO 101155
// result := SortListByListDesc ( units , tmp ) ;
101135: LD_ADDR_VAR 0 3
101139: PUSH
101140: LD_VAR 0 1
101144: PPUSH
101145: LD_VAR 0 5
101149: PPUSH
101150: CALL_OW 77
101154: ST_TO_ADDR
// end ;
101155: LD_VAR 0 3
101159: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
101160: LD_INT 0
101162: PPUSH
101163: PPUSH
// task := GetTaskList ( mech ) ;
101164: LD_ADDR_VAR 0 4
101168: PUSH
101169: LD_VAR 0 1
101173: PPUSH
101174: CALL_OW 437
101178: ST_TO_ADDR
// if not task then
101179: LD_VAR 0 4
101183: NOT
101184: IFFALSE 101188
// exit ;
101186: GO 101230
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
101188: LD_ADDR_VAR 0 3
101192: PUSH
101193: LD_VAR 0 4
101197: PUSH
101198: LD_INT 1
101200: ARRAY
101201: PUSH
101202: LD_INT 1
101204: ARRAY
101205: PUSH
101206: LD_STRING r
101208: EQUAL
101209: PUSH
101210: LD_VAR 0 4
101214: PUSH
101215: LD_INT 1
101217: ARRAY
101218: PUSH
101219: LD_INT 4
101221: ARRAY
101222: PUSH
101223: LD_VAR 0 2
101227: EQUAL
101228: AND
101229: ST_TO_ADDR
// end ;
101230: LD_VAR 0 3
101234: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
101235: LD_INT 0
101237: PPUSH
// SetDir ( unit , d ) ;
101238: LD_VAR 0 1
101242: PPUSH
101243: LD_VAR 0 4
101247: PPUSH
101248: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
101252: LD_VAR 0 1
101256: PPUSH
101257: LD_VAR 0 2
101261: PPUSH
101262: LD_VAR 0 3
101266: PPUSH
101267: LD_VAR 0 5
101271: PPUSH
101272: CALL_OW 48
// end ;
101276: LD_VAR 0 6
101280: RET
// export function ToNaturalNumber ( number ) ; begin
101281: LD_INT 0
101283: PPUSH
// result := number div 1 ;
101284: LD_ADDR_VAR 0 2
101288: PUSH
101289: LD_VAR 0 1
101293: PUSH
101294: LD_INT 1
101296: DIV
101297: ST_TO_ADDR
// if number < 0 then
101298: LD_VAR 0 1
101302: PUSH
101303: LD_INT 0
101305: LESS
101306: IFFALSE 101316
// result := 0 ;
101308: LD_ADDR_VAR 0 2
101312: PUSH
101313: LD_INT 0
101315: ST_TO_ADDR
// end ;
101316: LD_VAR 0 2
101320: RET
// export function SortByClass ( units , class ) ; var un ; begin
101321: LD_INT 0
101323: PPUSH
101324: PPUSH
// if not units or not class then
101325: LD_VAR 0 1
101329: NOT
101330: PUSH
101331: LD_VAR 0 2
101335: NOT
101336: OR
101337: IFFALSE 101341
// exit ;
101339: GO 101436
// result := [ ] ;
101341: LD_ADDR_VAR 0 3
101345: PUSH
101346: EMPTY
101347: ST_TO_ADDR
// for un in units do
101348: LD_ADDR_VAR 0 4
101352: PUSH
101353: LD_VAR 0 1
101357: PUSH
101358: FOR_IN
101359: IFFALSE 101434
// if GetClass ( un ) = class then
101361: LD_VAR 0 4
101365: PPUSH
101366: CALL_OW 257
101370: PUSH
101371: LD_VAR 0 2
101375: EQUAL
101376: IFFALSE 101403
// result := Insert ( result , 1 , un ) else
101378: LD_ADDR_VAR 0 3
101382: PUSH
101383: LD_VAR 0 3
101387: PPUSH
101388: LD_INT 1
101390: PPUSH
101391: LD_VAR 0 4
101395: PPUSH
101396: CALL_OW 2
101400: ST_TO_ADDR
101401: GO 101432
// result := Replace ( result , result + 1 , un ) ;
101403: LD_ADDR_VAR 0 3
101407: PUSH
101408: LD_VAR 0 3
101412: PPUSH
101413: LD_VAR 0 3
101417: PUSH
101418: LD_INT 1
101420: PLUS
101421: PPUSH
101422: LD_VAR 0 4
101426: PPUSH
101427: CALL_OW 1
101431: ST_TO_ADDR
101432: GO 101358
101434: POP
101435: POP
// end ;
101436: LD_VAR 0 3
101440: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
101441: LD_INT 0
101443: PPUSH
101444: PPUSH
101445: PPUSH
101446: PPUSH
101447: PPUSH
101448: PPUSH
101449: PPUSH
// result := [ ] ;
101450: LD_ADDR_VAR 0 4
101454: PUSH
101455: EMPTY
101456: ST_TO_ADDR
// if x - r < 0 then
101457: LD_VAR 0 1
101461: PUSH
101462: LD_VAR 0 3
101466: MINUS
101467: PUSH
101468: LD_INT 0
101470: LESS
101471: IFFALSE 101483
// min_x := 0 else
101473: LD_ADDR_VAR 0 8
101477: PUSH
101478: LD_INT 0
101480: ST_TO_ADDR
101481: GO 101499
// min_x := x - r ;
101483: LD_ADDR_VAR 0 8
101487: PUSH
101488: LD_VAR 0 1
101492: PUSH
101493: LD_VAR 0 3
101497: MINUS
101498: ST_TO_ADDR
// if y - r < 0 then
101499: LD_VAR 0 2
101503: PUSH
101504: LD_VAR 0 3
101508: MINUS
101509: PUSH
101510: LD_INT 0
101512: LESS
101513: IFFALSE 101525
// min_y := 0 else
101515: LD_ADDR_VAR 0 7
101519: PUSH
101520: LD_INT 0
101522: ST_TO_ADDR
101523: GO 101541
// min_y := y - r ;
101525: LD_ADDR_VAR 0 7
101529: PUSH
101530: LD_VAR 0 2
101534: PUSH
101535: LD_VAR 0 3
101539: MINUS
101540: ST_TO_ADDR
// max_x := x + r ;
101541: LD_ADDR_VAR 0 9
101545: PUSH
101546: LD_VAR 0 1
101550: PUSH
101551: LD_VAR 0 3
101555: PLUS
101556: ST_TO_ADDR
// max_y := y + r ;
101557: LD_ADDR_VAR 0 10
101561: PUSH
101562: LD_VAR 0 2
101566: PUSH
101567: LD_VAR 0 3
101571: PLUS
101572: ST_TO_ADDR
// for _x = min_x to max_x do
101573: LD_ADDR_VAR 0 5
101577: PUSH
101578: DOUBLE
101579: LD_VAR 0 8
101583: DEC
101584: ST_TO_ADDR
101585: LD_VAR 0 9
101589: PUSH
101590: FOR_TO
101591: IFFALSE 101692
// for _y = min_y to max_y do
101593: LD_ADDR_VAR 0 6
101597: PUSH
101598: DOUBLE
101599: LD_VAR 0 7
101603: DEC
101604: ST_TO_ADDR
101605: LD_VAR 0 10
101609: PUSH
101610: FOR_TO
101611: IFFALSE 101688
// begin if not ValidHex ( _x , _y ) then
101613: LD_VAR 0 5
101617: PPUSH
101618: LD_VAR 0 6
101622: PPUSH
101623: CALL_OW 488
101627: NOT
101628: IFFALSE 101632
// continue ;
101630: GO 101610
// if GetResourceTypeXY ( _x , _y ) then
101632: LD_VAR 0 5
101636: PPUSH
101637: LD_VAR 0 6
101641: PPUSH
101642: CALL_OW 283
101646: IFFALSE 101686
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
101648: LD_ADDR_VAR 0 4
101652: PUSH
101653: LD_VAR 0 4
101657: PPUSH
101658: LD_VAR 0 4
101662: PUSH
101663: LD_INT 1
101665: PLUS
101666: PPUSH
101667: LD_VAR 0 5
101671: PUSH
101672: LD_VAR 0 6
101676: PUSH
101677: EMPTY
101678: LIST
101679: LIST
101680: PPUSH
101681: CALL_OW 1
101685: ST_TO_ADDR
// end ;
101686: GO 101610
101688: POP
101689: POP
101690: GO 101590
101692: POP
101693: POP
// end ;
101694: LD_VAR 0 4
101698: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
101699: LD_INT 0
101701: PPUSH
101702: PPUSH
101703: PPUSH
101704: PPUSH
101705: PPUSH
101706: PPUSH
101707: PPUSH
101708: PPUSH
// if not units then
101709: LD_VAR 0 1
101713: NOT
101714: IFFALSE 101718
// exit ;
101716: GO 102143
// result := UnitFilter ( units , [ f_ok ] ) ;
101718: LD_ADDR_VAR 0 3
101722: PUSH
101723: LD_VAR 0 1
101727: PPUSH
101728: LD_INT 50
101730: PUSH
101731: EMPTY
101732: LIST
101733: PPUSH
101734: CALL_OW 72
101738: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
101739: LD_ADDR_VAR 0 8
101743: PUSH
101744: LD_VAR 0 1
101748: PUSH
101749: LD_INT 1
101751: ARRAY
101752: PPUSH
101753: CALL_OW 255
101757: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
101758: LD_ADDR_VAR 0 10
101762: PUSH
101763: LD_INT 29
101765: PUSH
101766: LD_EXP 77
101770: PUSH
101771: EMPTY
101772: LIST
101773: LIST
101774: ST_TO_ADDR
// if not result then
101775: LD_VAR 0 3
101779: NOT
101780: IFFALSE 101784
// exit ;
101782: GO 102143
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
101784: LD_ADDR_VAR 0 5
101788: PUSH
101789: LD_INT 81
101791: PUSH
101792: LD_VAR 0 8
101796: PUSH
101797: EMPTY
101798: LIST
101799: LIST
101800: PPUSH
101801: CALL_OW 69
101805: ST_TO_ADDR
// for i in result do
101806: LD_ADDR_VAR 0 4
101810: PUSH
101811: LD_VAR 0 3
101815: PUSH
101816: FOR_IN
101817: IFFALSE 102141
// begin tag := GetTag ( i ) + 1 ;
101819: LD_ADDR_VAR 0 9
101823: PUSH
101824: LD_VAR 0 4
101828: PPUSH
101829: CALL_OW 110
101833: PUSH
101834: LD_INT 1
101836: PLUS
101837: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
101838: LD_ADDR_VAR 0 7
101842: PUSH
101843: LD_VAR 0 4
101847: PPUSH
101848: CALL_OW 250
101852: PPUSH
101853: LD_VAR 0 4
101857: PPUSH
101858: CALL_OW 251
101862: PPUSH
101863: LD_INT 6
101865: PPUSH
101866: CALL 101441 0 3
101870: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
101871: LD_VAR 0 7
101875: PUSH
101876: LD_VAR 0 4
101880: PPUSH
101881: CALL_OW 264
101885: PUSH
101886: LD_VAR 0 10
101890: IN
101891: NOT
101892: AND
101893: IFFALSE 101932
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
101895: LD_VAR 0 4
101899: PPUSH
101900: LD_VAR 0 7
101904: PUSH
101905: LD_INT 1
101907: ARRAY
101908: PUSH
101909: LD_INT 1
101911: ARRAY
101912: PPUSH
101913: LD_VAR 0 7
101917: PUSH
101918: LD_INT 1
101920: ARRAY
101921: PUSH
101922: LD_INT 2
101924: ARRAY
101925: PPUSH
101926: CALL_OW 116
101930: GO 102139
// if path > tag then
101932: LD_VAR 0 2
101936: PUSH
101937: LD_VAR 0 9
101941: GREATER
101942: IFFALSE 102109
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
101944: LD_ADDR_VAR 0 6
101948: PUSH
101949: LD_VAR 0 5
101953: PPUSH
101954: LD_INT 91
101956: PUSH
101957: LD_VAR 0 4
101961: PUSH
101962: LD_INT 12
101964: PUSH
101965: EMPTY
101966: LIST
101967: LIST
101968: LIST
101969: PPUSH
101970: CALL_OW 72
101974: ST_TO_ADDR
// if nearEnemy then
101975: LD_VAR 0 6
101979: IFFALSE 102007
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
101981: LD_VAR 0 4
101985: PPUSH
101986: LD_VAR 0 6
101990: PPUSH
101991: LD_VAR 0 4
101995: PPUSH
101996: CALL_OW 74
102000: PPUSH
102001: CALL_OW 115
102005: GO 102107
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
102007: LD_VAR 0 4
102011: PPUSH
102012: LD_VAR 0 2
102016: PUSH
102017: LD_VAR 0 9
102021: ARRAY
102022: PUSH
102023: LD_INT 1
102025: ARRAY
102026: PPUSH
102027: LD_VAR 0 2
102031: PUSH
102032: LD_VAR 0 9
102036: ARRAY
102037: PUSH
102038: LD_INT 2
102040: ARRAY
102041: PPUSH
102042: CALL_OW 297
102046: PUSH
102047: LD_INT 6
102049: GREATER
102050: IFFALSE 102093
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
102052: LD_VAR 0 4
102056: PPUSH
102057: LD_VAR 0 2
102061: PUSH
102062: LD_VAR 0 9
102066: ARRAY
102067: PUSH
102068: LD_INT 1
102070: ARRAY
102071: PPUSH
102072: LD_VAR 0 2
102076: PUSH
102077: LD_VAR 0 9
102081: ARRAY
102082: PUSH
102083: LD_INT 2
102085: ARRAY
102086: PPUSH
102087: CALL_OW 114
102091: GO 102107
// SetTag ( i , tag ) ;
102093: LD_VAR 0 4
102097: PPUSH
102098: LD_VAR 0 9
102102: PPUSH
102103: CALL_OW 109
// end else
102107: GO 102139
// if enemy then
102109: LD_VAR 0 5
102113: IFFALSE 102139
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
102115: LD_VAR 0 4
102119: PPUSH
102120: LD_VAR 0 5
102124: PPUSH
102125: LD_VAR 0 4
102129: PPUSH
102130: CALL_OW 74
102134: PPUSH
102135: CALL_OW 115
// end ;
102139: GO 101816
102141: POP
102142: POP
// end ;
102143: LD_VAR 0 3
102147: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
102148: LD_INT 0
102150: PPUSH
102151: PPUSH
102152: PPUSH
// if not unit or IsInUnit ( unit ) then
102153: LD_VAR 0 1
102157: NOT
102158: PUSH
102159: LD_VAR 0 1
102163: PPUSH
102164: CALL_OW 310
102168: OR
102169: IFFALSE 102173
// exit ;
102171: GO 102264
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
102173: LD_ADDR_VAR 0 4
102177: PUSH
102178: LD_VAR 0 1
102182: PPUSH
102183: CALL_OW 250
102187: PPUSH
102188: LD_VAR 0 2
102192: PPUSH
102193: LD_INT 1
102195: PPUSH
102196: CALL_OW 272
102200: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
102201: LD_ADDR_VAR 0 5
102205: PUSH
102206: LD_VAR 0 1
102210: PPUSH
102211: CALL_OW 251
102215: PPUSH
102216: LD_VAR 0 2
102220: PPUSH
102221: LD_INT 1
102223: PPUSH
102224: CALL_OW 273
102228: ST_TO_ADDR
// if ValidHex ( x , y ) then
102229: LD_VAR 0 4
102233: PPUSH
102234: LD_VAR 0 5
102238: PPUSH
102239: CALL_OW 488
102243: IFFALSE 102264
// ComTurnXY ( unit , x , y ) ;
102245: LD_VAR 0 1
102249: PPUSH
102250: LD_VAR 0 4
102254: PPUSH
102255: LD_VAR 0 5
102259: PPUSH
102260: CALL_OW 118
// end ;
102264: LD_VAR 0 3
102268: RET
// export function SeeUnits ( side , units ) ; var i ; begin
102269: LD_INT 0
102271: PPUSH
102272: PPUSH
// result := false ;
102273: LD_ADDR_VAR 0 3
102277: PUSH
102278: LD_INT 0
102280: ST_TO_ADDR
// if not units then
102281: LD_VAR 0 2
102285: NOT
102286: IFFALSE 102290
// exit ;
102288: GO 102335
// for i in units do
102290: LD_ADDR_VAR 0 4
102294: PUSH
102295: LD_VAR 0 2
102299: PUSH
102300: FOR_IN
102301: IFFALSE 102333
// if See ( side , i ) then
102303: LD_VAR 0 1
102307: PPUSH
102308: LD_VAR 0 4
102312: PPUSH
102313: CALL_OW 292
102317: IFFALSE 102331
// begin result := true ;
102319: LD_ADDR_VAR 0 3
102323: PUSH
102324: LD_INT 1
102326: ST_TO_ADDR
// exit ;
102327: POP
102328: POP
102329: GO 102335
// end ;
102331: GO 102300
102333: POP
102334: POP
// end ;
102335: LD_VAR 0 3
102339: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
102340: LD_INT 0
102342: PPUSH
102343: PPUSH
102344: PPUSH
102345: PPUSH
// if not unit or not points then
102346: LD_VAR 0 1
102350: NOT
102351: PUSH
102352: LD_VAR 0 2
102356: NOT
102357: OR
102358: IFFALSE 102362
// exit ;
102360: GO 102452
// dist := 99999 ;
102362: LD_ADDR_VAR 0 5
102366: PUSH
102367: LD_INT 99999
102369: ST_TO_ADDR
// for i in points do
102370: LD_ADDR_VAR 0 4
102374: PUSH
102375: LD_VAR 0 2
102379: PUSH
102380: FOR_IN
102381: IFFALSE 102450
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
102383: LD_ADDR_VAR 0 6
102387: PUSH
102388: LD_VAR 0 1
102392: PPUSH
102393: LD_VAR 0 4
102397: PUSH
102398: LD_INT 1
102400: ARRAY
102401: PPUSH
102402: LD_VAR 0 4
102406: PUSH
102407: LD_INT 2
102409: ARRAY
102410: PPUSH
102411: CALL_OW 297
102415: ST_TO_ADDR
// if tmpDist < dist then
102416: LD_VAR 0 6
102420: PUSH
102421: LD_VAR 0 5
102425: LESS
102426: IFFALSE 102448
// begin result := i ;
102428: LD_ADDR_VAR 0 3
102432: PUSH
102433: LD_VAR 0 4
102437: ST_TO_ADDR
// dist := tmpDist ;
102438: LD_ADDR_VAR 0 5
102442: PUSH
102443: LD_VAR 0 6
102447: ST_TO_ADDR
// end ; end ;
102448: GO 102380
102450: POP
102451: POP
// end ; end_of_file
102452: LD_VAR 0 3
102456: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
102457: LD_VAR 0 1
102461: PUSH
102462: LD_INT 200
102464: DOUBLE
102465: GREATEREQUAL
102466: IFFALSE 102474
102468: LD_INT 299
102470: DOUBLE
102471: LESSEQUAL
102472: IFTRUE 102476
102474: GO 102508
102476: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
102477: LD_VAR 0 1
102481: PPUSH
102482: LD_VAR 0 2
102486: PPUSH
102487: LD_VAR 0 3
102491: PPUSH
102492: LD_VAR 0 4
102496: PPUSH
102497: LD_VAR 0 5
102501: PPUSH
102502: CALL 58160 0 5
102506: GO 102585
102508: LD_INT 300
102510: DOUBLE
102511: GREATEREQUAL
102512: IFFALSE 102520
102514: LD_INT 399
102516: DOUBLE
102517: LESSEQUAL
102518: IFTRUE 102522
102520: GO 102584
102522: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
102523: LD_VAR 0 1
102527: PPUSH
102528: LD_VAR 0 2
102532: PPUSH
102533: LD_VAR 0 3
102537: PPUSH
102538: LD_VAR 0 4
102542: PPUSH
102543: LD_VAR 0 5
102547: PPUSH
102548: LD_VAR 0 6
102552: PPUSH
102553: LD_VAR 0 7
102557: PPUSH
102558: LD_VAR 0 8
102562: PPUSH
102563: LD_VAR 0 9
102567: PPUSH
102568: LD_VAR 0 10
102572: PPUSH
102573: LD_VAR 0 11
102577: PPUSH
102578: CALL 55802 0 11
102582: GO 102585
102584: POP
// end ;
102585: PPOPN 11
102587: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
102588: LD_VAR 0 1
102592: PPUSH
102593: LD_VAR 0 2
102597: PPUSH
102598: LD_VAR 0 3
102602: PPUSH
102603: LD_VAR 0 4
102607: PPUSH
102608: LD_VAR 0 5
102612: PPUSH
102613: CALL 57896 0 5
// end ; end_of_file
102617: PPOPN 5
102619: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
102620: LD_VAR 0 1
102624: PPUSH
102625: LD_VAR 0 2
102629: PPUSH
102630: LD_VAR 0 3
102634: PPUSH
102635: LD_VAR 0 4
102639: PPUSH
102640: LD_VAR 0 5
102644: PPUSH
102645: LD_VAR 0 6
102649: PPUSH
102650: CALL 43495 0 6
// end ;
102654: PPOPN 6
102656: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
102657: CALL 43470 0 0
// end ;
102661: PPOPN 1
102663: END
