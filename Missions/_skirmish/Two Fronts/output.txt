// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7695 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4864 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41681 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42132 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21435 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21371 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18364 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21271 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22285 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21512 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21305 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21338 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18143 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22193 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20450 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21025 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21025 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20822 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20486 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20662 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19946 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20560 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21061 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21801 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21371 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18364 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21271 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21512 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18143 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22193 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20450 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21025 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21025 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20822 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20486 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20662 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19946 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20560 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21061 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21801 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19946 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11651 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22019 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11651 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22019 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11651 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22019 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11651 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22019 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7914 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7914 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7914 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7914 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7914 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18364 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4861
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4859
// begin PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4785: LD_EXP 22
4789: PUSH
4790: LD_INT 1
4792: ARRAY
4793: PPUSH
4794: LD_INT 18
4796: PPUSH
4797: LD_INT 0
4799: PPUSH
4800: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4804: LD_EXP 22
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 107
4815: PPUSH
4816: LD_INT 88
4818: PPUSH
4819: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4823: LD_EXP 22
4827: PUSH
4828: LD_INT 1
4830: ARRAY
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4839: LD_ADDR_EXP 22
4843: PUSH
4844: LD_EXP 22
4848: PPUSH
4849: LD_INT 1
4851: PPUSH
4852: CALL_OW 3
4856: ST_TO_ADDR
// end ;
4857: GO 4782
4859: POP
4860: POP
// end ;
4861: PPOPN 1
4863: END
// export function Dialog ; var i ; begin
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
// if not isTest then
4868: LD_EXP 1
4872: NOT
4873: IFFALSE 4895
// case query ( task ) of 1 :
4875: LD_STRING task
4877: PPUSH
4878: CALL_OW 97
4882: PUSH
4883: LD_INT 1
4885: DOUBLE
4886: EQUAL
4887: IFTRUE 4891
4889: GO 4894
4891: POP
// ; end ;
4892: GO 4895
4894: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4895: LD_INT 105
4897: PPUSH
4898: LD_INT 84
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 30
4906: NEG
4907: PPUSH
4908: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4912: LD_INT 105
4914: PPUSH
4915: LD_INT 84
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: CALL_OW 331
// InGameOn ;
4925: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4929: LD_INT 128
4931: PPUSH
4932: LD_INT 64
4934: PPUSH
4935: CALL_OW 86
// if isTest then
4939: LD_EXP 1
4943: IFFALSE 4953
// dialogue_skipped := true ;
4945: LD_ADDR_OWVAR 59
4949: PUSH
4950: LD_INT 1
4952: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4965: LD_EXP 24
4969: PPUSH
4970: LD_STRING DR2
4972: PPUSH
4973: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4977: LD_EXP 24
4981: PPUSH
4982: LD_STRING DR3
4984: PPUSH
4985: CALL_OW 94
// InGameOff ;
4989: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4993: LD_STRING C1
4995: PPUSH
4996: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5000: LD_INT 35
5002: PPUSH
5003: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5007: LD_INT 9
5009: PPUSH
5010: LD_INT 22
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 70
5024: IFFALSE 5000
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 9
5033: PPUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 6
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 70
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5066
// SetSide ( i , 3 ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 3
5059: PPUSH
5060: CALL_OW 235
5064: GO 5049
5066: POP
5067: POP
// if not isTest then
5068: LD_EXP 1
5072: NOT
5073: IFFALSE 5095
// case query ( support ) of 1 :
5075: LD_STRING support
5077: PPUSH
5078: CALL_OW 97
5082: PUSH
5083: LD_INT 1
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5094
5091: POP
// ; end ;
5092: GO 5095
5094: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 12
5100: PPUSH
5101: LD_INT 2
5103: PPUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 0
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 468
// if player_com = stolypin then
5141: LD_EXP 23
5145: PUSH
5146: LD_EXP 21
5150: EQUAL
5151: IFFALSE 5180
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5153: LD_INT 18
5155: PPUSH
5156: LD_INT 3
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_OWVAR 67
5174: ARRAY
5175: PPUSH
5176: CALL 6592 0 2
// end ;
5180: LD_VAR 0 1
5184: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5185: LD_EXP 11
5189: PUSH
5190: LD_OWVAR 1
5194: PUSH
5195: LD_INT 31500
5197: LESS
5198: AND
5199: IFFALSE 5367
// case query ( call1 ) of 1 :
5201: LD_STRING call1
5203: PPUSH
5204: CALL_OW 97
5208: PUSH
5209: LD_INT 1
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5355
5217: POP
// begin callUsed := true ;
5218: LD_ADDR_EXP 3
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 12
5231: PPUSH
5232: LD_INT 1
5234: PPUSH
5235: LD_INT 1
5237: PPUSH
5238: CALL_OW 468
// call := false ;
5242: LD_ADDR_EXP 11
5246: PUSH
5247: LD_INT 0
5249: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5250: LD_EXP 24
5254: PPUSH
5255: LD_STRING DR6
5257: PPUSH
5258: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5262: LD_INT 6300
5264: PPUSH
5265: LD_INT 8400
5267: PPUSH
5268: CALL_OW 12
5272: PPUSH
5273: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5277: LD_INT 18
5279: PUSH
5280: LD_INT 19
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 1
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: CALL_OW 12
5297: ARRAY
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: PPUSH
5310: CALL 6592 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5314: LD_INT 25200
5316: PPUSH
5317: LD_INT 35700
5319: PPUSH
5320: CALL_OW 12
5324: PPUSH
5325: CALL_OW 67
// call := true ;
5329: LD_ADDR_EXP 11
5333: PUSH
5334: LD_INT 1
5336: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 12
5342: PPUSH
5343: LD_INT 2
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 468
// end ; 2 :
5353: GO 5367
5355: LD_INT 2
5357: DOUBLE
5358: EQUAL
5359: IFTRUE 5363
5361: GO 5366
5363: POP
// ; end ;
5364: GO 5367
5366: POP
// if call and tick >= 15 15$00 then
5367: LD_EXP 11
5371: PUSH
5372: LD_OWVAR 1
5376: PUSH
5377: LD_INT 31500
5379: GREATEREQUAL
5380: AND
5381: IFFALSE 5820
// case query ( call2 ) of 1 :
5383: LD_STRING call2
5385: PPUSH
5386: CALL_OW 97
5390: PUSH
5391: LD_INT 1
5393: DOUBLE
5394: EQUAL
5395: IFTRUE 5399
5397: GO 5641
5399: POP
// begin callUsed := true ;
5400: LD_ADDR_EXP 3
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// call := false ;
5408: LD_ADDR_EXP 11
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5416: LD_INT 1
5418: PPUSH
5419: LD_INT 21
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL 11651 0 2
5433: PUSH
5434: LD_INT 4
5436: PPUSH
5437: LD_INT 21
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PPUSH
5447: CALL 11651 0 2
5451: AND
5452: IFFALSE 5500
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5454: LD_INT 18
5456: PUSH
5457: LD_INT 19
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 1
5466: PPUSH
5467: LD_INT 2
5469: PPUSH
5470: CALL_OW 12
5474: ARRAY
5475: PPUSH
5476: LD_INT 5
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PPUSH
5496: CALL 6353 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5500: LD_INT 1
5502: PPUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PPUSH
5513: CALL 11651 0 2
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5550
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5523: LD_INT 19
5525: PPUSH
5526: LD_INT 5
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: CALL 6353 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5550: LD_INT 4
5552: PPUSH
5553: LD_INT 21
5555: PUSH
5556: LD_INT 3
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 11651 0 2
5567: PUSH
5568: LD_INT 0
5570: EQUAL
5571: IFFALSE 5600
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5573: LD_INT 18
5575: PPUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 4
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_OWVAR 67
5594: ARRAY
5595: PPUSH
5596: CALL 6353 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5600: LD_INT 10500
5602: PPUSH
5603: LD_INT 23100
5605: PPUSH
5606: CALL_OW 12
5610: PPUSH
5611: CALL_OW 67
// call := true ;
5615: LD_ADDR_EXP 11
5619: PUSH
5620: LD_INT 1
5622: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_INT 12
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: LD_INT 1
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5820
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5808
5649: POP
// begin callUsed := true ;
5650: LD_ADDR_EXP 3
5654: PUSH
5655: LD_INT 1
5657: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 1
5669: PPUSH
5670: CALL_OW 468
// call := false ;
5674: LD_ADDR_EXP 11
5678: PUSH
5679: LD_INT 0
5681: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5682: LD_EXP 24
5686: PPUSH
5687: LD_STRING DR6
5689: PPUSH
5690: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5694: LD_INT 6300
5696: PPUSH
5697: LD_INT 8400
5699: PPUSH
5700: CALL_OW 12
5704: PPUSH
5705: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5709: LD_INT 18
5711: PUSH
5712: LD_INT 19
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 1
5721: PPUSH
5722: LD_INT 2
5724: PPUSH
5725: CALL_OW 12
5729: ARRAY
5730: PPUSH
5731: LD_INT 3
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 2
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_OWVAR 67
5749: ARRAY
5750: PUSH
5751: LD_INT 0
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 12
5761: MINUS
5762: PPUSH
5763: CALL 6592 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5767: LD_INT 35700
5769: PPUSH
5770: LD_INT 44100
5772: PPUSH
5773: CALL_OW 12
5777: PPUSH
5778: CALL_OW 67
// call := true ;
5782: LD_ADDR_EXP 11
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 12
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 468
// end ; 3 :
5806: GO 5820
5808: LD_INT 3
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5819
5816: POP
// ; end ;
5817: GO 5820
5819: POP
// end ;
5820: PPOPN 4
5822: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_INT 0
5854: EQUAL
5855: PUSH
5856: LD_INT 22
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 21
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: AND
5889: IFFALSE 6193
5891: GO 5893
5893: DISABLE
// begin DialogueOn ;
5894: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5898: LD_EXP 24
5902: PPUSH
5903: LD_STRING DR7
5905: PPUSH
5906: CALL_OW 94
// case player_com of Gorki :
5910: LD_EXP 23
5914: PUSH
5915: LD_EXP 20
5919: DOUBLE
5920: EQUAL
5921: IFTRUE 5925
5923: GO 5935
5925: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5926: LD_STRING ACH_GORKI
5928: PPUSH
5929: CALL_OW 543
5933: GO 5996
5935: LD_EXP 21
5939: DOUBLE
5940: EQUAL
5941: IFTRUE 5945
5943: GO 5955
5945: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5946: LD_STRING ACH_STOLYP
5948: PPUSH
5949: CALL_OW 543
5953: GO 5996
5955: LD_EXP 19
5959: DOUBLE
5960: EQUAL
5961: IFTRUE 5965
5963: GO 5975
5965: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5966: LD_STRING ACH_DAVIDOV
5968: PPUSH
5969: CALL_OW 543
5973: GO 5996
5975: LD_EXP 18
5979: DOUBLE
5980: EQUAL
5981: IFTRUE 5985
5983: GO 5995
5985: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5986: LD_STRING ACH_GLADKOV
5988: PPUSH
5989: CALL_OW 543
5993: GO 5996
5995: POP
// if not callUsed then
5996: LD_EXP 3
6000: NOT
6001: IFFALSE 6010
// SetAchievement ( ACH_NOSUPP ) ;
6003: LD_STRING ACH_NOSUPP
6005: PPUSH
6006: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6010: LD_OWVAR 1
6014: PUSH
6015: LD_INT 116550
6017: PUSH
6018: LD_INT 95550
6020: PUSH
6021: LD_INT 89250
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_OWVAR 67
6033: ARRAY
6034: LESS
6035: IFFALSE 6049
// AddMedal ( med1 , 1 ) else
6037: LD_STRING med1
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med1 , - 1 ) ;
6049: LD_STRING med1
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6060: LD_INT 81
6062: PUSH
6063: LD_INT 3
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 21
6072: PUSH
6073: LD_INT 3
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PUSH
6089: LD_INT 0
6091: EQUAL
6092: IFFALSE 6106
// AddMedal ( med3 , 1 ) else
6094: LD_STRING med3
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 101
6104: GO 6117
// AddMedal ( med3 , - 1 ) ;
6106: LD_STRING med3
6108: PPUSH
6109: LD_INT 1
6111: NEG
6112: PPUSH
6113: CALL_OW 101
// if player_loss = 0 then
6117: LD_EXP 10
6121: PUSH
6122: LD_INT 0
6124: EQUAL
6125: IFFALSE 6139
// AddMedal ( med2 , 1 ) else
6127: LD_STRING med2
6129: PPUSH
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 101
6137: GO 6182
// if player_loss > 0 and player_loss < 3 then
6139: LD_EXP 10
6143: PUSH
6144: LD_INT 0
6146: GREATER
6147: PUSH
6148: LD_EXP 10
6152: PUSH
6153: LD_INT 3
6155: LESS
6156: AND
6157: IFFALSE 6171
// AddMedal ( med2 , 2 ) else
6159: LD_STRING med2
6161: PPUSH
6162: LD_INT 2
6164: PPUSH
6165: CALL_OW 101
6169: GO 6182
// AddMedal ( med2 , - 1 ) ;
6171: LD_STRING med2
6173: PPUSH
6174: LD_INT 1
6176: NEG
6177: PPUSH
6178: CALL_OW 101
// GiveMedals ( MAIN ) ;
6182: LD_STRING MAIN
6184: PPUSH
6185: CALL_OW 102
// YouWin ;
6189: CALL_OW 103
// end ;
6193: END
// every 0 0$01 trigger IsDead ( player_com ) do
6194: LD_EXP 23
6198: PPUSH
6199: CALL_OW 301
6203: IFFALSE 6270
6205: GO 6207
6207: DISABLE
// begin if IsLive ( Houten ) then
6208: LD_EXP 4
6212: PPUSH
6213: CALL_OW 300
6217: IFFALSE 6233
// SayRadio ( Houten , DJ5 ) else
6219: LD_EXP 4
6223: PPUSH
6224: LD_STRING DJ5
6226: PPUSH
6227: CALL_OW 94
6231: GO 6256
// if IsLive ( Brown ) then
6233: LD_EXP 5
6237: PPUSH
6238: CALL_OW 300
6242: IFFALSE 6256
// SayRadio ( Brown , DS5 ) ;
6244: LD_EXP 5
6248: PPUSH
6249: LD_STRING DS5
6251: PPUSH
6252: CALL_OW 94
// Wait ( 0 0$01 ) ;
6256: LD_INT 35
6258: PPUSH
6259: CALL_OW 67
// YouLost ( dead ) ;
6263: LD_STRING dead
6265: PPUSH
6266: CALL_OW 104
// end ;
6270: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 301
6278: PUSH
6279: LD_EXP 1
6283: NOT
6284: AND
6285: IFFALSE 6352
6287: GO 6289
6289: DISABLE
// begin if IsLive ( Brown ) then
6290: LD_EXP 5
6294: PPUSH
6295: CALL_OW 300
6299: IFFALSE 6315
// SayRadio ( Brown , DS5 ) else
6301: LD_EXP 5
6305: PPUSH
6306: LD_STRING DS5
6308: PPUSH
6309: CALL_OW 94
6313: GO 6338
// if IsLive ( Houten ) then
6315: LD_EXP 4
6319: PPUSH
6320: CALL_OW 300
6324: IFFALSE 6338
// SayRadio ( Houten , DJ5 ) ;
6326: LD_EXP 4
6330: PPUSH
6331: LD_STRING DJ5
6333: PPUSH
6334: CALL_OW 94
// Wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// YouLost ( depot ) ;
6345: LD_STRING depot
6347: PPUSH
6348: CALL_OW 104
// end ;
6352: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
// for i = 1 to n do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6577
// begin uc_side := 6 ;
6376: LD_ADDR_OWVAR 20
6380: PUSH
6381: LD_INT 6
6383: ST_TO_ADDR
// uc_nation := 3 ;
6384: LD_ADDR_OWVAR 21
6388: PUSH
6389: LD_INT 3
6391: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6392: LD_ADDR_OWVAR 37
6396: PUSH
6397: LD_INT 23
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: ST_TO_ADDR
// vc_control := control_computer ;
6419: LD_ADDR_OWVAR 38
6423: PUSH
6424: LD_INT 3
6426: ST_TO_ADDR
// vc_engine := engine_siberite ;
6427: LD_ADDR_OWVAR 39
6431: PUSH
6432: LD_INT 3
6434: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6435: LD_ADDR_OWVAR 40
6439: PUSH
6440: LD_INT 43
6442: PUSH
6443: LD_INT 44
6445: PUSH
6446: LD_INT 44
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: CALL_OW 12
6464: ARRAY
6465: ST_TO_ADDR
// un := CreateVehicle ;
6466: LD_ADDR_VAR 0 5
6470: PUSH
6471: CALL_OW 45
6475: ST_TO_ADDR
// case area of east_arr :
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 18
6483: DOUBLE
6484: EQUAL
6485: IFTRUE 6489
6487: GO 6524
6489: POP
// begin PlaceUnitArea ( un , area , false ) ;
6490: LD_VAR 0 5
6494: PPUSH
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_INT 0
6502: PPUSH
6503: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6507: LD_VAR 0 5
6511: PPUSH
6512: LD_INT 79
6514: PPUSH
6515: LD_INT 33
6517: PPUSH
6518: CALL_OW 111
// end ; south_arr :
6522: GO 6568
6524: LD_INT 19
6526: DOUBLE
6527: EQUAL
6528: IFTRUE 6532
6530: GO 6567
6532: POP
// begin PlaceUnitArea ( un , area , false ) ;
6533: LD_VAR 0 5
6537: PPUSH
6538: LD_VAR 0 1
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_INT 131
6557: PPUSH
6558: LD_INT 148
6560: PPUSH
6561: CALL_OW 111
// end ; end ;
6565: GO 6568
6567: POP
// Wait ( 0 0$02 ) ;
6568: LD_INT 70
6570: PPUSH
6571: CALL_OW 67
// end ;
6575: GO 6373
6577: POP
6578: POP
// pink_attack := true ;
6579: LD_ADDR_EXP 12
6583: PUSH
6584: LD_INT 1
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 3
6591: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// for i = 1 to n do
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: DOUBLE
6603: LD_INT 1
6605: DEC
6606: ST_TO_ADDR
6607: LD_VAR 0 2
6611: PUSH
6612: FOR_TO
6613: IFFALSE 6839
// begin uc_side := 6 ;
6615: LD_ADDR_OWVAR 20
6619: PUSH
6620: LD_INT 6
6622: ST_TO_ADDR
// uc_nation := 3 ;
6623: LD_ADDR_OWVAR 21
6627: PUSH
6628: LD_INT 3
6630: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6631: LD_INT 0
6633: PPUSH
6634: LD_INT 3
6636: PPUSH
6637: LD_INT 4
6639: PPUSH
6640: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6644: LD_ADDR_OWVAR 37
6648: PUSH
6649: LD_INT 22
6651: ST_TO_ADDR
// vc_control := control_manual ;
6652: LD_ADDR_OWVAR 38
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// vc_engine := engine_combustion ;
6660: LD_ADDR_OWVAR 39
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6668: LD_ADDR_OWVAR 40
6672: PUSH
6673: LD_INT 51
6675: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6676: LD_ADDR_OWVAR 41
6680: PUSH
6681: LD_INT 50
6683: ST_TO_ADDR
// un := CreateVehicle ;
6684: LD_ADDR_VAR 0 5
6688: PUSH
6689: CALL_OW 45
6693: ST_TO_ADDR
// case area of east_arr :
6694: LD_VAR 0 1
6698: PUSH
6699: LD_INT 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6722
6707: POP
// SetDir ( un , 4 ) ; south_arr :
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: CALL_OW 233
6720: GO 6746
6722: LD_INT 19
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6745
6730: POP
// SetDir ( un , 5 ) ; end ;
6731: LD_VAR 0 5
6735: PPUSH
6736: LD_INT 5
6738: PPUSH
6739: CALL_OW 233
6743: GO 6746
6745: POP
// PlaceUnitArea ( un , area , false ) ;
6746: LD_VAR 0 5
6750: PPUSH
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6763: CALL_OW 44
6767: PPUSH
6768: LD_VAR 0 5
6772: PPUSH
6773: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6777: LD_VAR 0 5
6781: PPUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 100
6787: PPUSH
6788: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6792: LD_VAR 0 5
6796: PPUSH
6797: LD_INT 106
6799: PPUSH
6800: LD_INT 88
6802: PPUSH
6803: CALL_OW 111
// AddComUnload ( un ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 173
// Wait ( 0 0$02 ) ;
6830: LD_INT 70
6832: PPUSH
6833: CALL_OW 67
// end ;
6837: GO 6612
6839: POP
6840: POP
// Wait ( 0 0$05 ) ;
6841: LD_INT 175
6843: PPUSH
6844: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6848: LD_INT 6
6850: PPUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 51
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL 11651 0 2
6865: IFFALSE 7053
// begin wait ( 0 0$01 ) ;
6867: LD_INT 35
6869: PPUSH
6870: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6874: LD_ADDR_VAR 0 4
6878: PUSH
6879: LD_INT 6
6881: PPUSH
6882: LD_INT 34
6884: PUSH
6885: LD_INT 51
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL 11651 0 2
6896: PUSH
6897: FOR_IN
6898: IFFALSE 7049
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6900: LD_VAR 0 4
6904: PPUSH
6905: LD_INT 9
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 4
6917: PPUSH
6918: CALL 31773 0 1
6922: PPUSH
6923: CALL_OW 258
6927: PUSH
6928: LD_INT 1
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 9
6937: AND
6938: IFFALSE 6965
// begin Say ( GetDriver ( i ) , Dtran ) ;
6940: LD_VAR 0 4
6944: PPUSH
6945: CALL 31773 0 1
6949: PPUSH
6950: LD_STRING Dtran
6952: PPUSH
6953: CALL_OW 88
// dialog_trans := false ;
6957: LD_ADDR_EXP 9
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6965: LD_VAR 0 4
6969: PPUSH
6970: CALL_OW 316
6974: IFFALSE 6990
// ComMoveToArea ( i , area ) ;
6976: LD_VAR 0 4
6980: PPUSH
6981: LD_VAR 0 1
6985: PPUSH
6986: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6990: LD_VAR 0 4
6994: PPUSH
6995: LD_VAR 0 1
6999: PPUSH
7000: CALL_OW 308
7004: PUSH
7005: LD_VAR 0 4
7009: PPUSH
7010: LD_INT 1
7012: PPUSH
7013: CALL_OW 289
7017: PUSH
7018: LD_INT 0
7020: EQUAL
7021: AND
7022: IFFALSE 7047
// begin RemoveUnit ( GetDriver ( i ) ) ;
7024: LD_VAR 0 4
7028: PPUSH
7029: CALL 31773 0 1
7033: PPUSH
7034: CALL_OW 64
// RemoveUnit ( i ) ;
7038: LD_VAR 0 4
7042: PPUSH
7043: CALL_OW 64
// end ; end ;
7047: GO 6897
7049: POP
7050: POP
// end ;
7051: GO 6848
// end ;
7053: LD_VAR 0 3
7057: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7058: LD_INT 0
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
// if isTest then
7064: LD_EXP 1
7068: IFFALSE 7072
// exit ;
7070: GO 7517
// for i = 1 to n do
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: DOUBLE
7078: LD_INT 1
7080: DEC
7081: ST_TO_ADDR
7082: LD_VAR 0 2
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7376
// begin uc_side := 8 ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_INT 8
7097: ST_TO_ADDR
// uc_nation := 1 ;
7098: LD_ADDR_OWVAR 21
7102: PUSH
7103: LD_INT 1
7105: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7106: LD_ADDR_VAR 0 6
7110: PUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: LD_INT 4
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 1
7127: PPUSH
7128: LD_OWVAR 67
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// vc_chassis := ch ;
7139: LD_ADDR_OWVAR 37
7143: PUSH
7144: LD_VAR 0 6
7148: ST_TO_ADDR
// vc_control := control_computer ;
7149: LD_ADDR_OWVAR 38
7153: PUSH
7154: LD_INT 3
7156: ST_TO_ADDR
// vc_engine := engine_combustion ;
7157: LD_ADDR_OWVAR 39
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7165: LD_OWVAR 1
7169: PUSH
7170: LD_INT 42000
7172: PUSH
7173: LD_INT 33600
7175: PUSH
7176: LD_INT 29400
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_OWVAR 67
7188: ARRAY
7189: LESS
7190: IFFALSE 7221
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7192: LD_ADDR_OWVAR 40
7196: PUSH
7197: LD_INT 3
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 1
7209: PPUSH
7210: LD_INT 2
7212: PPUSH
7213: CALL_OW 12
7217: ARRAY
7218: ST_TO_ADDR
7219: GO 7317
// if ch = us_medium_tracked then
7221: LD_VAR 0 6
7225: PUSH
7226: LD_INT 3
7228: EQUAL
7229: IFFALSE 7276
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7231: LD_ADDR_OWVAR 40
7235: PUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 4
7241: PUSH
7242: LD_INT 5
7244: PUSH
7245: LD_INT 7
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_OWVAR 67
7258: PPUSH
7259: LD_OWVAR 67
7263: PUSH
7264: LD_INT 1
7266: PLUS
7267: PPUSH
7268: CALL_OW 12
7272: ARRAY
7273: ST_TO_ADDR
7274: GO 7317
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7276: LD_ADDR_OWVAR 40
7280: PUSH
7281: LD_INT 5
7283: PUSH
7284: LD_INT 6
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 7
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_OWVAR 67
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PPUSH
7311: CALL_OW 12
7315: ARRAY
7316: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7317: LD_ADDR_OWVAR 41
7321: PUSH
7322: LD_INT 70
7324: ST_TO_ADDR
// un := CreateVehicle ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: CALL_OW 45
7334: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7335: LD_VAR 0 5
7339: PPUSH
7340: LD_VAR 0 1
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7352: LD_VAR 0 5
7356: PPUSH
7357: LD_INT 65
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL_OW 111
// Wait ( 0 0$02 ) ;
7367: LD_INT 70
7369: PPUSH
7370: CALL_OW 67
// end ;
7374: GO 7087
7376: POP
7377: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7378: LD_INT 90
7380: PUSH
7381: LD_INT 80
7383: PUSH
7384: LD_INT 70
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: PUSH
7392: LD_OWVAR 67
7396: ARRAY
7397: PPUSH
7398: CALL_OW 13
7402: IFFALSE 7509
// begin uc_side := 8 ;
7404: LD_ADDR_OWVAR 20
7408: PUSH
7409: LD_INT 8
7411: ST_TO_ADDR
// uc_nation := 1 ;
7412: LD_ADDR_OWVAR 21
7416: PUSH
7417: LD_INT 1
7419: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7420: LD_ADDR_OWVAR 37
7424: PUSH
7425: LD_INT 4
7427: ST_TO_ADDR
// vc_control := control_computer ;
7428: LD_ADDR_OWVAR 38
7432: PUSH
7433: LD_INT 3
7435: ST_TO_ADDR
// vc_engine := engine_combustion ;
7436: LD_ADDR_OWVAR 39
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7444: LD_ADDR_OWVAR 40
7448: PUSH
7449: LD_INT 14
7451: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7452: LD_ADDR_OWVAR 41
7456: PUSH
7457: LD_INT 70
7459: ST_TO_ADDR
// un := CreateVehicle ;
7460: LD_ADDR_VAR 0 5
7464: PUSH
7465: CALL_OW 45
7469: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7470: LD_VAR 0 5
7474: PPUSH
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7487: LD_VAR 0 5
7491: PPUSH
7492: LD_INT 65
7494: PPUSH
7495: LD_INT 9
7497: PPUSH
7498: CALL_OW 111
// Wait ( 0 0$02 ) ;
7502: LD_INT 70
7504: PPUSH
7505: CALL_OW 67
// end ; alfa_support := true ;
7509: LD_ADDR_EXP 13
7513: PUSH
7514: LD_INT 1
7516: ST_TO_ADDR
// end ;
7517: LD_VAR 0 3
7521: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7522: LD_OWVAR 1
7526: PUSH
7527: LD_INT 25200
7529: PUSH
7530: LD_INT 23100
7532: PUSH
7533: LD_INT 21000
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_OWVAR 67
7545: ARRAY
7546: GREATER
7547: IFFALSE 7692
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 3
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: LD_INT 5
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7580: LD_INT 1050
7582: PPUSH
7583: LD_INT 4200
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7595: LD_INT 20
7597: PPUSH
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL 7058 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7607: LD_INT 22
7609: PUSH
7610: LD_INT 8
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: IFFALSE 7635
// SayRadio ( Popov , DR5 ) ;
7623: LD_EXP 24
7627: PPUSH
7628: LD_STRING DR5
7630: PPUSH
7631: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7635: LD_INT 8400
7637: PPUSH
7638: LD_INT 12600
7640: PPUSH
7641: CALL_OW 12
7645: PPUSH
7646: CALL_OW 67
// n := n + 1 ;
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 1
7659: PUSH
7660: LD_INT 1
7662: PLUS
7663: ST_TO_ADDR
// if n > 9 then
7664: LD_VAR 0 1
7668: PUSH
7669: LD_INT 9
7671: GREATER
7672: IFFALSE 7682
// n := 9 ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 9
7681: ST_TO_ADDR
// until tick >= 120 120$00 ;
7682: LD_OWVAR 1
7686: PUSH
7687: LD_INT 252000
7689: GREATEREQUAL
7690: IFFALSE 7580
// end ; end_of_file
7692: PPOPN 1
7694: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7695: LD_INT 0
7697: PPUSH
// enable_addtolog := isTest ;
7698: LD_ADDR_OWVAR 81
7702: PUSH
7703: LD_EXP 1
7707: ST_TO_ADDR
// lines_break_limit := 5 ;
7708: LD_ADDR_EXP 26
7712: PUSH
7713: LD_INT 5
7715: ST_TO_ADDR
// lines_break_type := --- ;
7716: LD_ADDR_EXP 27
7720: PUSH
7721: LD_STRING ---
7723: ST_TO_ADDR
// lines_counter := 0 ;
7724: LD_ADDR_EXP 25
7728: PUSH
7729: LD_INT 0
7731: ST_TO_ADDR
// show_line_index := true ;
7732: LD_ADDR_EXP 28
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// tick_log := true ;
7740: LD_ADDR_EXP 29
7744: PUSH
7745: LD_INT 1
7747: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7748: LD_STRING ----------SAND OF SIBERIA LOG----------
7750: PPUSH
7751: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7755: LD_STRING Map Name: 
7757: PUSH
7758: LD_OWVAR 68
7762: STR
7763: PPUSH
7764: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7768: LD_STRING Map Number: 
7770: PUSH
7771: LD_OWVAR 70
7775: STR
7776: PPUSH
7777: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7781: LD_STRING Difficulty: 
7783: PUSH
7784: LD_OWVAR 67
7788: STR
7789: PPUSH
7790: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7794: LD_STRING ---------------------------------------
7796: PPUSH
7797: CALL_OW 561
// end ;
7801: LD_VAR 0 1
7805: RET
// function Log ( text ) ; begin
7806: LD_INT 0
7808: PPUSH
// if show_line_index then
7809: LD_EXP 28
7813: IFFALSE 7825
// result := lines_counter ;
7815: LD_ADDR_VAR 0 2
7819: PUSH
7820: LD_EXP 25
7824: ST_TO_ADDR
// if tick_log then
7825: LD_EXP 29
7829: IFFALSE 7855
// result := result &  T:  & tick &   ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_VAR 0 2
7840: PUSH
7841: LD_STRING  T: 
7843: STR
7844: PUSH
7845: LD_OWVAR 1
7849: STR
7850: PUSH
7851: LD_STRING  
7853: STR
7854: ST_TO_ADDR
// AddToLog ( result & text ) ;
7855: LD_VAR 0 2
7859: PUSH
7860: LD_VAR 0 1
7864: STR
7865: PPUSH
7866: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7870: LD_ADDR_EXP 25
7874: PUSH
7875: LD_EXP 25
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7884: LD_EXP 25
7888: PUSH
7889: LD_EXP 26
7893: MOD
7894: PUSH
7895: LD_INT 0
7897: EQUAL
7898: IFFALSE 7909
// AddToLog ( lines_break_type ) ;
7900: LD_EXP 27
7904: PPUSH
7905: CALL_OW 561
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogHuman ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7917: LD_STRING Human Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; class: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 257
7954: STR
7955: PUSH
7956: LD_STRING ; 
7958: STR
7959: PPUSH
7960: CALL 7806 0 1
// end ;
7964: LD_VAR 0 2
7968: RET
// export function LogVeh ( id ) ; begin
7969: LD_INT 0
7971: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7972: LD_STRING Vehicle Created. id: 
7974: PUSH
7975: LD_VAR 0 1
7979: STR
7980: PUSH
7981: LD_STRING ; side: 
7983: STR
7984: PUSH
7985: LD_VAR 0 1
7989: PPUSH
7990: CALL_OW 255
7994: STR
7995: PUSH
7996: LD_STRING ; nation: 
7998: STR
7999: PUSH
8000: LD_VAR 0 1
8004: PPUSH
8005: CALL_OW 248
8009: STR
8010: PUSH
8011: LD_STRING ; weapon: 
8013: STR
8014: PUSH
8015: LD_VAR 0 1
8019: PPUSH
8020: CALL_OW 264
8024: STR
8025: PUSH
8026: LD_STRING ; 
8028: STR
8029: PPUSH
8030: CALL 7806 0 1
// end ;
8034: LD_VAR 0 2
8038: RET
// export function LogEvent ( event ) ; begin
8039: LD_INT 0
8041: PPUSH
// Log ( Event Executed. id:  & event ) ;
8042: LD_STRING Event Executed. id: 
8044: PUSH
8045: LD_VAR 0 1
8049: STR
8050: PPUSH
8051: CALL 7806 0 1
// end ; end_of_file
8055: LD_VAR 0 2
8059: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
8068: PPUSH
8069: PPUSH
// if unit then
8070: LD_VAR 0 1
8074: IFFALSE 8474
// begin if mode = 0 then
8076: LD_VAR 0 3
8080: PUSH
8081: LD_INT 0
8083: EQUAL
8084: IFFALSE 8232
// begin if coords then
8086: LD_VAR 0 2
8090: IFFALSE 8230
// while ( coords > 1 ) do
8092: LD_VAR 0 2
8096: PUSH
8097: LD_INT 1
8099: GREATER
8100: IFFALSE 8230
// if not HasTask ( unit ) then
8102: LD_VAR 0 1
8106: PPUSH
8107: CALL_OW 314
8111: NOT
8112: IFFALSE 8228
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_VAR 0 2
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PPUSH
8137: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 250
8157: PUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: EQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 251
8177: PUSH
8178: LD_VAR 0 2
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: EQUAL
8187: AND
8188: IFFALSE 8141
// for i = 1 to 2 do
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_INT 2
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8226
// coords := Delete ( coords , 1 ) ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_VAR 0 2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 3
8223: ST_TO_ADDR
8224: GO 8203
8226: POP
8227: POP
// end ;
8228: GO 8092
// end else
8230: GO 8474
// begin if coords then
8232: LD_VAR 0 2
8236: IFFALSE 8474
// begin x := GetX ( unit ) ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 250
8252: ST_TO_ADDR
// y := GetY ( unit ) ;
8253: LD_ADDR_VAR 0 7
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 251
8267: ST_TO_ADDR
// while ( coords > 1 ) do
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8474
// begin Wait ( 0 0$0.3 ) ;
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 250
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 251
8314: PPUSH
8315: LD_INT 14
8317: PPUSH
8318: CALL 22821 0 4
8322: IFFALSE 8353
// begin ComMoveXY ( unit , x , y ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: LD_VAR 0 6
8333: PPUSH
8334: LD_VAR 0 7
8338: PPUSH
8339: CALL_OW 111
// result := false ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_INT 0
8350: ST_TO_ADDR
// end else
8351: GO 8392
// if not HasTask ( unit ) then
8353: LD_VAR 0 1
8357: PPUSH
8358: CALL_OW 314
8362: NOT
8363: IFFALSE 8392
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8365: LD_VAR 0 1
8369: PPUSH
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 1
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 2
8386: ARRAY
8387: PPUSH
8388: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8392: LD_VAR 0 1
8396: PPUSH
8397: CALL_OW 250
8401: PUSH
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: EQUAL
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 251
8421: PUSH
8422: LD_VAR 0 2
8426: PUSH
8427: LD_INT 2
8429: ARRAY
8430: EQUAL
8431: AND
8432: IFFALSE 8472
// for i = 1 to 2 do
8434: LD_ADDR_VAR 0 5
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_INT 2
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8470
// coords := Delete ( coords , 1 ) ;
8450: LD_ADDR_VAR 0 2
8454: PUSH
8455: LD_VAR 0 2
8459: PPUSH
8460: LD_INT 1
8462: PPUSH
8463: CALL_OW 3
8467: ST_TO_ADDR
8468: GO 8447
8470: POP
8471: POP
// end ;
8472: GO 8268
// end ; end ; end ; result := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// end ;
8482: LD_VAR 0 4
8486: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
// if not units then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8564
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8501: LD_ADDR_VAR 0 5
8505: PUSH
8506: LD_INT 81
8508: PUSH
8509: LD_VAR 0 1
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// for i in units do
8523: LD_ADDR_VAR 0 4
8527: PUSH
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_IN
8534: IFFALSE 8562
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8536: LD_VAR 0 4
8540: PPUSH
8541: LD_VAR 0 5
8545: PPUSH
8546: LD_VAR 0 4
8550: PPUSH
8551: CALL_OW 74
8555: PPUSH
8556: CALL_OW 115
// end ;
8560: GO 8533
8562: POP
8563: POP
// end ;
8564: LD_VAR 0 3
8568: RET
// export function MC_Show ( string ) ; begin
8569: LD_INT 0
8571: PPUSH
// display_strings := string ;
8572: LD_ADDR_OWVAR 47
8576: PUSH
8577: LD_VAR 0 1
8581: ST_TO_ADDR
// end ; end_of_file
8582: LD_VAR 0 2
8586: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8587: LD_INT 0
8589: PPUSH
8590: PPUSH
8591: PPUSH
8592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8593: LD_ADDR_VAR 0 8
8597: PUSH
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 2
8605: PPUSH
8606: EMPTY
8607: PPUSH
8608: CALL 11734 0 3
8612: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8613: LD_VAR 0 8
8617: PUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 428
8632: PUSH
8633: LD_INT 0
8635: EQUAL
8636: AND
8637: IFFALSE 8711
// for i = 1 to plist do
8639: LD_ADDR_VAR 0 6
8643: PUSH
8644: DOUBLE
8645: LD_INT 1
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 8
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8709
// if NotTask ( plist [ i ] ) then
8657: LD_VAR 0 8
8661: PUSH
8662: LD_VAR 0 6
8666: ARRAY
8667: PPUSH
8668: CALL 32236 0 1
8672: IFFALSE 8707
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8674: LD_VAR 0 8
8678: PUSH
8679: LD_VAR 0 6
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: LD_VAR 0 3
8697: PPUSH
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 145
// end ;
8707: GO 8654
8709: POP
8710: POP
// end ;
8711: LD_VAR 0 5
8715: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8716: LD_INT 0
8718: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8719: LD_VAR 0 1
8723: PPUSH
8724: LD_INT 6
8726: PPUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: LD_VAR 0 4
8741: PPUSH
8742: CALL 10220 0 5
// end ;
8746: LD_VAR 0 5
8750: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8751: LD_INT 0
8753: PPUSH
8754: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8755: LD_ADDR_VAR 0 4
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_VAR 0 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 0
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 1
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: PPUSH
8807: CALL_OW 69
8811: PPUSH
8812: LD_VAR 0 2
8816: PPUSH
8817: CALL_OW 250
8821: PPUSH
8822: LD_VAR 0 2
8826: PPUSH
8827: CALL_OW 251
8831: PPUSH
8832: CALL_OW 73
8836: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8837: LD_VAR 0 4
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: CALL 10509 0 2
8851: IFFALSE 8910
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8853: LD_VAR 0 1
8857: PPUSH
8858: LD_INT 30
8860: PUSH
8861: LD_VAR 0 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: PPUSH
8870: CALL 11651 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8883: LD_ADDR_EXP 48
8887: PUSH
8888: LD_EXP 48
8892: PPUSH
8893: LD_VAR 0 1
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: EMPTY
8904: PPUSH
8905: CALL 42051 0 4
8909: ST_TO_ADDR
// end ; end ;
8910: LD_VAR 0 3
8914: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// result := false ;
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: LD_INT 0
8930: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8931: LD_VAR 0 1
8935: PPUSH
8936: LD_EXP 40
8940: PPUSH
8941: CALL 42999 0 2
8945: IFFALSE 9158
// for i = 1 to MREG_LabList do
8947: LD_ADDR_VAR 0 5
8951: PUSH
8952: DOUBLE
8953: LD_INT 1
8955: DEC
8956: ST_TO_ADDR
8957: LD_EXP 40
8961: PUSH
8962: FOR_TO
8963: IFFALSE 9156
// begin if MREG_LabList [ i ] [ 1 ] = side then
8965: LD_EXP 40
8969: PUSH
8970: LD_VAR 0 5
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PUSH
8980: LD_VAR 0 1
8984: EQUAL
8985: IFFALSE 9154
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8987: LD_ADDR_VAR 0 7
8991: PUSH
8992: LD_EXP 40
8996: PUSH
8997: LD_VAR 0 5
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9007: LD_ADDR_VAR 0 9
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_VAR 0 1
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 0
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 30
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PUSH
9056: EMPTY
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PPUSH
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 250
9073: PPUSH
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 251
9083: PPUSH
9084: CALL_OW 73
9088: ST_TO_ADDR
// if dep then
9089: LD_VAR 0 9
9093: IFFALSE 9152
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9095: LD_VAR 0 9
9099: PPUSH
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 3
9109: PPUSH
9110: CALL 10625 0 3
9114: IFFALSE 9152
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9116: LD_VAR 0 7
9120: PPUSH
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9130: LD_VAR 0 7
9134: PPUSH
9135: LD_VAR 0 3
9139: PPUSH
9140: CALL_OW 207
// result := true ;
9144: LD_ADDR_VAR 0 4
9148: PUSH
9149: LD_INT 1
9151: ST_TO_ADDR
// end ; end ; break ;
9152: GO 9156
// end ; end ;
9154: GO 8962
9156: POP
9157: POP
// end ;
9158: LD_VAR 0 4
9162: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9168: LD_ADDR_VAR 0 7
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: LD_VAR 0 3
9182: PPUSH
9183: LD_VAR 0 4
9187: PPUSH
9188: CALL 9350 0 3
9192: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9193: LD_ADDR_EXP 46
9197: PUSH
9198: LD_EXP 46
9202: PPUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: LD_VAR 0 2
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 4
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41960 0 4
9235: ST_TO_ADDR
// if ext_list then
9236: LD_VAR 0 5
9240: IFFALSE 9345
// for i = 1 to ext_list do
9242: LD_ADDR_VAR 0 8
9246: PUSH
9247: DOUBLE
9248: LD_INT 1
9250: DEC
9251: ST_TO_ADDR
9252: LD_VAR 0 5
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9343
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9260: LD_ADDR_EXP 46
9264: PUSH
9265: LD_EXP 46
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_VAR 0 5
9279: PUSH
9280: LD_VAR 0 8
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 7
9290: PUSH
9291: LD_VAR 0 8
9295: ARRAY
9296: PUSH
9297: LD_INT 1
9299: ARRAY
9300: PUSH
9301: LD_VAR 0 7
9305: PUSH
9306: LD_VAR 0 8
9310: ARRAY
9311: PUSH
9312: LD_INT 2
9314: ARRAY
9315: PUSH
9316: LD_VAR 0 7
9320: PUSH
9321: LD_VAR 0 8
9325: ARRAY
9326: PUSH
9327: LD_INT 3
9329: ARRAY
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL 41960 0 4
9340: ST_TO_ADDR
9341: GO 9257
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 6
9349: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9350: LD_INT 0
9352: PPUSH
9353: PPUSH
// list := [ ] ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: EMPTY
9360: ST_TO_ADDR
// case d of 0 :
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 0
9368: DOUBLE
9369: EQUAL
9370: IFTRUE 9374
9372: GO 9507
9374: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 4
9387: MINUS
9388: PUSH
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 4
9396: MINUS
9397: PUSH
9398: LD_INT 2
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 3
9413: MINUS
9414: PUSH
9415: LD_VAR 0 2
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 4
9435: PLUS
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 4
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 3
9457: PLUS
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: PLUS
9467: PUSH
9468: LD_INT 5
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: ST_TO_ADDR
// end ; 1 :
9505: GO 10205
9507: LD_INT 1
9509: DOUBLE
9510: EQUAL
9511: IFTRUE 9515
9513: GO 9648
9515: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9516: LD_ADDR_VAR 0 5
9520: PUSH
9521: LD_VAR 0 1
9525: PUSH
9526: LD_VAR 0 2
9530: PUSH
9531: LD_INT 4
9533: MINUS
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: PUSH
9543: LD_VAR 0 1
9547: PUSH
9548: LD_INT 3
9550: MINUS
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: LD_INT 3
9559: MINUS
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 4
9576: MINUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 1
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 4
9629: PLUS
9630: PUSH
9631: LD_INT 5
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: ST_TO_ADDR
// end ; 2 :
9646: GO 10205
9648: LD_INT 2
9650: DOUBLE
9651: EQUAL
9652: IFTRUE 9656
9654: GO 9785
9656: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: MINUS
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: PUSH
9684: LD_VAR 0 1
9688: PUSH
9689: LD_INT 4
9691: PLUS
9692: PUSH
9693: LD_VAR 0 2
9697: PUSH
9698: LD_INT 4
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 4
9718: PLUS
9719: PUSH
9720: LD_INT 0
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_VAR 0 1
9732: PUSH
9733: LD_INT 3
9735: MINUS
9736: PUSH
9737: LD_VAR 0 2
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 4
9757: MINUS
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: LD_INT 4
9766: MINUS
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: ST_TO_ADDR
// end ; 3 :
9783: GO 10205
9785: LD_INT 3
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9926
9793: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9794: LD_ADDR_VAR 0 5
9798: PUSH
9799: LD_VAR 0 1
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: LD_INT 4
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: PUSH
9821: LD_VAR 0 1
9825: PUSH
9826: LD_INT 4
9828: PLUS
9829: PUSH
9830: LD_VAR 0 2
9834: PUSH
9835: LD_INT 4
9837: PLUS
9838: PUSH
9839: LD_INT 5
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_INT 4
9854: MINUS
9855: PUSH
9856: LD_VAR 0 2
9860: PUSH
9861: LD_INT 1
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: LD_INT 4
9881: MINUS
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: MINUS
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 3
9907: MINUS
9908: PUSH
9909: LD_INT 2
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
// end ; 4 :
9924: GO 10205
9926: LD_INT 4
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10067
9934: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9935: LD_ADDR_VAR 0 5
9939: PUSH
9940: LD_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 4
9952: PLUS
9953: PUSH
9954: LD_INT 0
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: PUSH
9962: LD_VAR 0 1
9966: PUSH
9967: LD_INT 3
9969: PLUS
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 3
9978: PLUS
9979: PUSH
9980: LD_INT 5
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_INT 3
9995: PLUS
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: LD_INT 4
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 3
10022: MINUS
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_VAR 0 1
10036: PUSH
10037: LD_INT 4
10039: MINUS
10040: PUSH
10041: LD_VAR 0 2
10045: PUSH
10046: LD_INT 4
10048: MINUS
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: ST_TO_ADDR
// end ; 5 :
10065: GO 10205
10067: LD_INT 5
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10204
10075: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10076: LD_ADDR_VAR 0 5
10080: PUSH
10081: LD_VAR 0 1
10085: PUSH
10086: LD_INT 4
10088: MINUS
10089: PUSH
10090: LD_VAR 0 2
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_VAR 0 1
10107: PUSH
10108: LD_VAR 0 2
10112: PUSH
10113: LD_INT 4
10115: MINUS
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_VAR 0 1
10129: PUSH
10130: LD_INT 4
10132: PLUS
10133: PUSH
10134: LD_VAR 0 2
10138: PUSH
10139: LD_INT 4
10141: PLUS
10142: PUSH
10143: LD_INT 5
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: PUSH
10151: LD_VAR 0 1
10155: PUSH
10156: LD_INT 3
10158: PLUS
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_INT 4
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 1
10177: PUSH
10178: LD_VAR 0 2
10182: PUSH
10183: LD_INT 3
10185: PLUS
10186: PUSH
10187: LD_INT 0
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: ST_TO_ADDR
// end ; end ;
10202: GO 10205
10204: POP
// result := list ;
10205: LD_ADDR_VAR 0 4
10209: PUSH
10210: LD_VAR 0 5
10214: ST_TO_ADDR
// end ;
10215: LD_VAR 0 4
10219: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10227: LD_ADDR_VAR 0 10
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: LD_INT 2
10239: PPUSH
10240: EMPTY
10241: PPUSH
10242: CALL 11734 0 3
10246: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10247: LD_ADDR_VAR 0 9
10251: PUSH
10252: LD_INT 22
10254: PUSH
10255: LD_VAR 0 1
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_INT 30
10269: PUSH
10270: LD_INT 0
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 30
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PPUSH
10304: LD_VAR 0 3
10308: PPUSH
10309: LD_VAR 0 4
10313: PPUSH
10314: CALL_OW 73
10318: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10319: LD_ADDR_VAR 0 8
10323: PUSH
10324: LD_VAR 0 9
10328: PPUSH
10329: LD_VAR 0 2
10333: PPUSH
10334: CALL 10509 0 2
10338: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10339: LD_VAR 0 10
10343: PUSH
10344: LD_VAR 0 8
10348: AND
10349: PUSH
10350: LD_VAR 0 9
10354: PPUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_VAR 0 4
10364: PPUSH
10365: CALL_OW 297
10369: PUSH
10370: LD_INT 26
10372: LESSEQUAL
10373: AND
10374: PUSH
10375: LD_VAR 0 3
10379: PPUSH
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 428
10389: PUSH
10390: LD_INT 0
10392: EQUAL
10393: AND
10394: IFFALSE 10504
// for i = 1 to plist do
10396: LD_ADDR_VAR 0 7
10400: PUSH
10401: DOUBLE
10402: LD_INT 1
10404: DEC
10405: ST_TO_ADDR
10406: LD_VAR 0 10
10410: PUSH
10411: FOR_TO
10412: IFFALSE 10502
// if IsInUnit ( plist [ i ] ) then
10414: LD_VAR 0 10
10418: PUSH
10419: LD_VAR 0 7
10423: ARRAY
10424: PPUSH
10425: CALL_OW 310
10429: IFFALSE 10448
// ComExitBuilding ( plist [ i ] ) else
10431: LD_VAR 0 10
10435: PUSH
10436: LD_VAR 0 7
10440: ARRAY
10441: PPUSH
10442: CALL_OW 122
10446: GO 10500
// if NotTask ( plist [ i ] ) then
10448: LD_VAR 0 10
10452: PUSH
10453: LD_VAR 0 7
10457: ARRAY
10458: PPUSH
10459: CALL 32236 0 1
10463: IFFALSE 10500
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10465: LD_VAR 0 10
10469: PUSH
10470: LD_VAR 0 7
10474: ARRAY
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL_OW 145
// end ;
10500: GO 10411
10502: POP
10503: POP
// end ;
10504: LD_VAR 0 6
10508: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10509: LD_INT 0
10511: PPUSH
10512: PPUSH
10513: PPUSH
// pom := GetBase ( bdepot ) ;
10514: LD_ADDR_VAR 0 4
10518: PUSH
10519: LD_VAR 0 1
10523: PPUSH
10524: CALL_OW 274
10528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10529: LD_ADDR_VAR 0 5
10533: PUSH
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 248
10548: PPUSH
10549: CALL_OW 450
10553: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: CALL_OW 275
10566: PUSH
10567: LD_VAR 0 5
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: GREATEREQUAL
10576: PUSH
10577: LD_VAR 0 4
10581: PPUSH
10582: LD_INT 3
10584: PPUSH
10585: CALL_OW 275
10589: PUSH
10590: LD_VAR 0 5
10594: PUSH
10595: LD_INT 3
10597: ARRAY
10598: GREATEREQUAL
10599: AND
10600: IFFALSE 10612
// result := true else
10602: LD_ADDR_VAR 0 3
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
10610: GO 10620
// result := false ;
10612: LD_ADDR_VAR 0 3
10616: PUSH
10617: LD_INT 0
10619: ST_TO_ADDR
// end ;
10620: LD_VAR 0 3
10624: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
10629: PPUSH
10630: PPUSH
10631: PPUSH
// pom := GetBase ( bdepot ) ;
10632: LD_ADDR_VAR 0 5
10636: PUSH
10637: LD_VAR 0 1
10641: PPUSH
10642: CALL_OW 274
10646: ST_TO_ADDR
// cost := [ ] ;
10647: LD_ADDR_VAR 0 8
10651: PUSH
10652: EMPTY
10653: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 248
10673: PPUSH
10674: CALL_OW 450
10678: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10679: LD_ADDR_VAR 0 7
10683: PUSH
10684: LD_VAR 0 3
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 248
10698: PPUSH
10699: CALL_OW 450
10703: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10704: LD_ADDR_VAR 0 8
10708: PUSH
10709: LD_VAR 0 8
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: LD_VAR 0 6
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PUSH
10726: LD_VAR 0 7
10730: PUSH
10731: LD_INT 1
10733: ARRAY
10734: PLUS
10735: PPUSH
10736: CALL_OW 1
10740: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: LD_VAR 0 8
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_VAR 0 6
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PUSH
10763: LD_VAR 0 7
10767: PUSH
10768: LD_INT 2
10770: ARRAY
10771: PLUS
10772: PPUSH
10773: CALL_OW 1
10777: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10778: LD_ADDR_VAR 0 8
10782: PUSH
10783: LD_VAR 0 8
10787: PPUSH
10788: LD_INT 3
10790: PPUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_INT 3
10798: ARRAY
10799: PUSH
10800: LD_VAR 0 7
10804: PUSH
10805: LD_INT 3
10807: ARRAY
10808: PLUS
10809: PPUSH
10810: CALL_OW 1
10814: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10815: LD_VAR 0 5
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 275
10827: PUSH
10828: LD_VAR 0 8
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: GREATEREQUAL
10837: PUSH
10838: LD_VAR 0 5
10842: PPUSH
10843: LD_INT 3
10845: PPUSH
10846: CALL_OW 275
10850: PUSH
10851: LD_VAR 0 8
10855: PUSH
10856: LD_INT 3
10858: ARRAY
10859: GREATEREQUAL
10860: AND
10861: IFFALSE 10873
// result := true else
10863: LD_ADDR_VAR 0 4
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
10871: GO 10881
// result := false ;
10873: LD_ADDR_VAR 0 4
10877: PUSH
10878: LD_INT 0
10880: ST_TO_ADDR
// end ;
10881: LD_VAR 0 4
10885: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10886: LD_INT 0
10888: PPUSH
10889: PPUSH
10890: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 2
10903: PPUSH
10904: EMPTY
10905: PPUSH
10906: CALL 11734 0 3
10910: ST_TO_ADDR
// if unit and plist then
10911: LD_VAR 0 2
10915: PUSH
10916: LD_VAR 0 5
10920: AND
10921: IFFALSE 10982
// for i = 1 to plist do
10923: LD_ADDR_VAR 0 4
10927: PUSH
10928: DOUBLE
10929: LD_INT 1
10931: DEC
10932: ST_TO_ADDR
10933: LD_VAR 0 5
10937: PUSH
10938: FOR_TO
10939: IFFALSE 10980
// if NotTask ( plist [ i ] ) then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_VAR 0 4
10950: ARRAY
10951: PPUSH
10952: CALL 32236 0 1
10956: IFFALSE 10978
// ComDismantle ( plist [ i ] , unit ) ;
10958: LD_VAR 0 5
10962: PUSH
10963: LD_VAR 0 4
10967: ARRAY
10968: PPUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 167
10978: GO 10938
10980: POP
10981: POP
// result := true ;
10982: LD_ADDR_VAR 0 3
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// end ;
10990: LD_VAR 0 3
10994: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10995: LD_INT 0
10997: PPUSH
10998: PPUSH
10999: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11000: LD_ADDR_VAR 0 5
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: LD_INT 2
11012: PPUSH
11013: EMPTY
11014: PPUSH
11015: CALL 11734 0 3
11019: ST_TO_ADDR
// if unit and plist then
11020: LD_VAR 0 2
11024: PUSH
11025: LD_VAR 0 5
11029: AND
11030: IFFALSE 11091
// for i = 1 to plist do
11032: LD_ADDR_VAR 0 4
11036: PUSH
11037: DOUBLE
11038: LD_INT 1
11040: DEC
11041: ST_TO_ADDR
11042: LD_VAR 0 5
11046: PUSH
11047: FOR_TO
11048: IFFALSE 11089
// if NotTask ( plist [ i ] ) then
11050: LD_VAR 0 5
11054: PUSH
11055: LD_VAR 0 4
11059: ARRAY
11060: PPUSH
11061: CALL 32236 0 1
11065: IFFALSE 11087
// ComComplete ( plist [ i ] , unit ) ;
11067: LD_VAR 0 5
11071: PUSH
11072: LD_VAR 0 4
11076: ARRAY
11077: PPUSH
11078: LD_VAR 0 2
11082: PPUSH
11083: CALL 71994 0 2
11087: GO 11047
11089: POP
11090: POP
// result := true ;
11091: LD_ADDR_VAR 0 3
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// end ;
11099: LD_VAR 0 3
11103: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11104: LD_INT 0
11106: PPUSH
11107: PPUSH
11108: PPUSH
11109: PPUSH
11110: PPUSH
11111: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11112: LD_ADDR_VAR 0 5
11116: PUSH
11117: LD_INT 22
11119: PUSH
11120: LD_VAR 0 1
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 21
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 3
11141: PUSH
11142: LD_INT 57
11144: PUSH
11145: EMPTY
11146: LIST
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 24
11157: PUSH
11158: LD_INT 1000
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: PPUSH
11175: CALL_OW 69
11179: ST_TO_ADDR
// r := [ ] ;
11180: LD_ADDR_VAR 0 6
11184: PUSH
11185: EMPTY
11186: ST_TO_ADDR
// if not tmp then
11187: LD_VAR 0 5
11191: NOT
11192: IFFALSE 11198
// exit else
11194: GO 11386
11196: GO 11366
// begin r := [ tmp [ 1 ] ] ;
11198: LD_ADDR_VAR 0 6
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: LD_INT 1
11210: ARRAY
11211: PUSH
11212: EMPTY
11213: LIST
11214: ST_TO_ADDR
// for i = 2 to tmp do
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: DOUBLE
11221: LD_INT 2
11223: DEC
11224: ST_TO_ADDR
11225: LD_VAR 0 5
11229: PUSH
11230: FOR_TO
11231: IFFALSE 11364
// begin m := false ;
11233: LD_ADDR_VAR 0 7
11237: PUSH
11238: LD_INT 0
11240: ST_TO_ADDR
// for j = 1 to r do
11241: LD_ADDR_VAR 0 4
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_VAR 0 6
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11331
// if GetLives ( tmp [ i ] ) < r [ j ] then
11259: LD_VAR 0 5
11263: PUSH
11264: LD_VAR 0 3
11268: ARRAY
11269: PPUSH
11270: CALL_OW 256
11274: PUSH
11275: LD_VAR 0 6
11279: PUSH
11280: LD_VAR 0 4
11284: ARRAY
11285: LESS
11286: IFFALSE 11329
// begin r := Insert ( r , j , tmp [ i ] ) ;
11288: LD_ADDR_VAR 0 6
11292: PUSH
11293: LD_VAR 0 6
11297: PPUSH
11298: LD_VAR 0 4
11302: PPUSH
11303: LD_VAR 0 5
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: CALL_OW 2
11318: ST_TO_ADDR
// m := true ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// break ;
11327: GO 11331
// end ;
11329: GO 11256
11331: POP
11332: POP
// if not m then
11333: LD_VAR 0 7
11337: NOT
11338: IFFALSE 11362
// r := r ^ tmp [ i ] ;
11340: LD_ADDR_VAR 0 6
11344: PUSH
11345: LD_VAR 0 6
11349: PUSH
11350: LD_VAR 0 5
11354: PUSH
11355: LD_VAR 0 3
11359: ARRAY
11360: ADD
11361: ST_TO_ADDR
// end ;
11362: GO 11230
11364: POP
11365: POP
// end ; if r then
11366: LD_VAR 0 6
11370: IFFALSE 11384
// result := r else
11372: LD_ADDR_VAR 0 2
11376: PUSH
11377: LD_VAR 0 6
11381: ST_TO_ADDR
11382: GO 11386
// exit ;
11384: GO 11386
// end ;
11386: LD_VAR 0 2
11390: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11391: LD_INT 0
11393: PPUSH
11394: PPUSH
11395: PPUSH
11396: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11397: LD_ADDR_VAR 0 5
11401: PUSH
11402: LD_INT 22
11404: PUSH
11405: LD_VAR 0 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: LD_INT 25
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 25
11429: PUSH
11430: LD_INT 16
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 34
11439: PUSH
11440: LD_INT 13
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 34
11449: PUSH
11450: LD_INT 52
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 24
11466: PUSH
11467: LD_INT 650
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: ST_TO_ADDR
// p := 1 ;
11484: LD_ADDR_VAR 0 4
11488: PUSH
11489: LD_INT 1
11491: ST_TO_ADDR
// for i = 1 to repairs do
11492: LD_ADDR_VAR 0 3
11496: PUSH
11497: DOUBLE
11498: LD_INT 1
11500: DEC
11501: ST_TO_ADDR
11502: LD_VAR 0 5
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// begin if IsInUnit ( repairs [ i ] ) then
11510: LD_VAR 0 5
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: PPUSH
11521: CALL_OW 310
11525: IFFALSE 11544
// ComExitBuilding ( repairs [ i ] ) else
11527: LD_VAR 0 5
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: PPUSH
11538: CALL_OW 122
11542: GO 11642
// if not HasTask ( repairs [ i ] ) then
11544: LD_VAR 0 5
11548: PUSH
11549: LD_VAR 0 3
11553: ARRAY
11554: PPUSH
11555: CALL_OW 314
11559: NOT
11560: IFFALSE 11642
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11562: LD_VAR 0 5
11566: PUSH
11567: LD_VAR 0 3
11571: ARRAY
11572: PPUSH
11573: LD_EXP 47
11577: PUSH
11578: LD_VAR 0 1
11582: ARRAY
11583: PUSH
11584: LD_VAR 0 4
11588: ARRAY
11589: PPUSH
11590: CALL_OW 130
// if i mod 3 = 0 then
11594: LD_VAR 0 3
11598: PUSH
11599: LD_INT 3
11601: MOD
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11622
// p := p + 1 ;
11608: LD_ADDR_VAR 0 4
11612: PUSH
11613: LD_VAR 0 4
11617: PUSH
11618: LD_INT 1
11620: PLUS
11621: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11622: LD_EXP 47
11626: PUSH
11627: LD_VAR 0 1
11631: ARRAY
11632: PUSH
11633: LD_VAR 0 4
11637: LESS
11638: IFFALSE 11642
// break ;
11640: GO 11644
// end ; end ;
11642: GO 11507
11644: POP
11645: POP
// end ; end_of_file
11646: LD_VAR 0 2
11650: RET
// export function MCF_Get ( side , filter ) ; begin
11651: LD_INT 0
11653: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_INT 22
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PPUSH
11680: CALL_OW 69
11684: ST_TO_ADDR
// end ;
11685: LD_VAR 0 3
11689: RET
// export function MCF_Lab ( side ) ; begin
11690: LD_INT 0
11692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11693: LD_ADDR_VAR 0 2
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: LD_INT 30
11712: PUSH
11713: LD_INT 8
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 69
11728: ST_TO_ADDR
// end ;
11729: LD_VAR 0 2
11733: RET
// export function MCF_Class ( side , class , filter ) ; begin
11734: LD_INT 0
11736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_INT 22
11744: PUSH
11745: LD_VAR 0 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 25
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 4
11785: RET
// export function MCF_All ( side , filter ) ; begin
11786: LD_INT 0
11788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 25
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 25
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 4
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: ST_TO_ADDR
// end ;
11871: LD_VAR 0 3
11875: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11876: LD_INT 0
11878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11879: LD_ADDR_VAR 0 4
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 92
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_INT 1
11906: ARRAY
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: LD_INT 2
11915: ARRAY
11916: PUSH
11917: LD_VAR 0 2
11921: PUSH
11922: LD_INT 3
11924: ARRAY
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: PUSH
11932: LD_VAR 0 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// end ;
11947: LD_VAR 0 4
11951: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11952: LD_INT 0
11954: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11955: LD_ADDR_VAR 0 3
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_VAR 0 1
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 21
11974: PUSH
11975: LD_INT 2
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 3
12001: RET
// export function MCF_Cargo ( side ) ; begin
12002: LD_INT 0
12004: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_INT 2
12017: PUSH
12018: LD_INT 34
12020: PUSH
12021: LD_INT 12
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 34
12030: PUSH
12031: LD_INT 32
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 34
12040: PUSH
12041: LD_INT 51
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PPUSH
12054: CALL 11952 0 2
12058: ST_TO_ADDR
// end ;
12059: LD_VAR 0 2
12063: RET
// export function MCF_Ape ( side ) ; begin
12064: LD_INT 0
12066: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_VAR 0 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 2
12086: PUSH
12087: LD_INT 25
12089: PUSH
12090: LD_INT 12
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 15
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 25
12109: PUSH
12110: LD_INT 16
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 17
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// end ;
12143: LD_VAR 0 2
12147: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
12153: PPUSH
// result := [ ] ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: EMPTY
12160: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL 12064 0 1
12175: ST_TO_ADDR
// case type of 0 , normal :
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12195
12187: LD_STRING normal
12189: DOUBLE
12190: EQUAL
12191: IFTRUE 12195
12193: GO 12206
12195: POP
// cl := class_apeman ; 1 , soldier :
12196: LD_ADDR_VAR 0 5
12200: PUSH
12201: LD_INT 12
12203: ST_TO_ADDR
12204: GO 12282
12206: LD_INT 1
12208: DOUBLE
12209: EQUAL
12210: IFTRUE 12220
12212: LD_STRING soldier
12214: DOUBLE
12215: EQUAL
12216: IFTRUE 12220
12218: GO 12231
12220: POP
// cl := class_apeman_soldier ; 2 , engineer :
12221: LD_ADDR_VAR 0 5
12225: PUSH
12226: LD_INT 15
12228: ST_TO_ADDR
12229: GO 12282
12231: LD_INT 2
12233: DOUBLE
12234: EQUAL
12235: IFTRUE 12245
12237: LD_STRING engineer
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12256
12245: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12246: LD_ADDR_VAR 0 5
12250: PUSH
12251: LD_INT 16
12253: ST_TO_ADDR
12254: GO 12282
12256: LD_INT 3
12258: DOUBLE
12259: EQUAL
12260: IFTRUE 12270
12262: LD_STRING kamikaze
12264: DOUBLE
12265: EQUAL
12266: IFTRUE 12270
12268: GO 12281
12270: POP
// cl := class_apeman_kamikaze ; end ;
12271: LD_ADDR_VAR 0 5
12275: PUSH
12276: LD_INT 17
12278: ST_TO_ADDR
12279: GO 12282
12281: POP
// for i = 1 to tmp do
12282: LD_ADDR_VAR 0 6
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 4
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12347
// if GetClass ( tmp [ i ] ) = cl then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_VAR 0 6
12309: ARRAY
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_VAR 0 5
12320: EQUAL
12321: IFFALSE 12345
// result := result ^ tmp [ i ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 3
12332: PUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_VAR 0 6
12342: ARRAY
12343: ADD
12344: ST_TO_ADDR
12345: GO 12297
12347: POP
12348: POP
// end ;
12349: LD_VAR 0 3
12353: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12354: LD_INT 0
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12360: LD_ADDR_VAR 0 5
12364: PUSH
12365: LD_INT 22
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: ST_TO_ADDR
// r := [ ] ;
12391: LD_ADDR_VAR 0 6
12395: PUSH
12396: EMPTY
12397: ST_TO_ADDR
// if tmp then
12398: LD_VAR 0 5
12402: IFFALSE 12471
// for i = 1 to tmp do
12404: LD_ADDR_VAR 0 7
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_VAR 0 5
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12469
// if GetTag ( tmp [ i ] ) = tag then
12422: LD_VAR 0 5
12426: PUSH
12427: LD_VAR 0 7
12431: ARRAY
12432: PPUSH
12433: CALL_OW 110
12437: PUSH
12438: LD_VAR 0 2
12442: EQUAL
12443: IFFALSE 12467
// r := r ^ tmp [ i ] ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 6
12454: PUSH
12455: LD_VAR 0 5
12459: PUSH
12460: LD_VAR 0 7
12464: ARRAY
12465: ADD
12466: ST_TO_ADDR
12467: GO 12419
12469: POP
12470: POP
// result := r ;
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: LD_VAR 0 6
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 4
12485: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
// tmp := plist ;
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 2
12500: ST_TO_ADDR
// if tmp then
12501: LD_VAR 0 5
12505: IFFALSE 12582
// begin for i = 1 to tmp do
12507: LD_ADDR_VAR 0 6
12511: PUSH
12512: DOUBLE
12513: LD_INT 1
12515: DEC
12516: ST_TO_ADDR
12517: LD_VAR 0 5
12521: PUSH
12522: FOR_TO
12523: IFFALSE 12570
// if GetTag ( tmp [ i ] ) <> tag then
12525: LD_VAR 0 5
12529: PUSH
12530: LD_VAR 0 6
12534: ARRAY
12535: PPUSH
12536: CALL_OW 110
12540: PUSH
12541: LD_VAR 0 3
12545: NONEQUAL
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , tag ) ;
12548: LD_VAR 0 5
12552: PUSH
12553: LD_VAR 0 6
12557: ARRAY
12558: PPUSH
12559: LD_VAR 0 3
12563: PPUSH
12564: CALL_OW 109
12568: GO 12522
12570: POP
12571: POP
// result := true ;
12572: LD_ADDR_VAR 0 4
12576: PUSH
12577: LD_INT 1
12579: ST_TO_ADDR
// end else
12580: GO 12590
// result := false ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 0
12589: ST_TO_ADDR
// end ;
12590: LD_VAR 0 4
12594: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12595: LD_INT 0
12597: PPUSH
12598: PPUSH
12599: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_VAR 0 2
12614: PPUSH
12615: EMPTY
12616: PPUSH
12617: CALL 12354 0 3
12621: ST_TO_ADDR
// if tmp then
12622: LD_VAR 0 4
12626: IFFALSE 12678
// begin for i = 1 to tmp do
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: DOUBLE
12634: LD_INT 1
12636: DEC
12637: ST_TO_ADDR
12638: LD_VAR 0 4
12642: PUSH
12643: FOR_TO
12644: IFFALSE 12666
// SetTag ( tmp [ i ] , 0 ) ;
12646: LD_VAR 0 4
12650: PUSH
12651: LD_VAR 0 5
12655: ARRAY
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 109
12664: GO 12643
12666: POP
12667: POP
// result := true ;
12668: LD_ADDR_VAR 0 3
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end else
12676: GO 12686
// result := false ;
12678: LD_ADDR_VAR 0 3
12682: PUSH
12683: LD_INT 0
12685: ST_TO_ADDR
// end ;
12686: LD_VAR 0 3
12690: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12691: LD_INT 0
12693: PPUSH
12694: PPUSH
12695: PPUSH
12696: PPUSH
12697: PPUSH
// sort_list := [ ] ;
12698: LD_ADDR_VAR 0 5
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// for i = 1 to list do
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: DOUBLE
12711: LD_INT 1
12713: DEC
12714: ST_TO_ADDR
12715: LD_VAR 0 1
12719: PUSH
12720: FOR_TO
12721: IFFALSE 12883
// begin if i = 1 then
12723: LD_VAR 0 3
12727: PUSH
12728: LD_INT 1
12730: EQUAL
12731: IFFALSE 12757
// sort_list := sort_list ^ list [ i ] else
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PUSH
12743: LD_VAR 0 1
12747: PUSH
12748: LD_VAR 0 3
12752: ARRAY
12753: ADD
12754: ST_TO_ADDR
12755: GO 12881
// begin for j = 1 to sort_list do
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: DOUBLE
12763: LD_INT 1
12765: DEC
12766: ST_TO_ADDR
12767: LD_VAR 0 5
12771: PUSH
12772: FOR_TO
12773: IFFALSE 12850
// begin add := false ;
12775: LD_ADDR_VAR 0 6
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12783: LD_VAR 0 1
12787: PUSH
12788: LD_VAR 0 3
12792: ARRAY
12793: PUSH
12794: LD_VAR 0 5
12798: PUSH
12799: LD_VAR 0 4
12803: ARRAY
12804: LESS
12805: IFFALSE 12848
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12807: LD_ADDR_VAR 0 5
12811: PUSH
12812: LD_VAR 0 5
12816: PPUSH
12817: LD_VAR 0 4
12821: PPUSH
12822: LD_VAR 0 1
12826: PUSH
12827: LD_VAR 0 3
12831: ARRAY
12832: PPUSH
12833: CALL_OW 2
12837: ST_TO_ADDR
// add := true ;
12838: LD_ADDR_VAR 0 6
12842: PUSH
12843: LD_INT 1
12845: ST_TO_ADDR
// break ;
12846: GO 12850
// end ; end ;
12848: GO 12772
12850: POP
12851: POP
// if not add then
12852: LD_VAR 0 6
12856: NOT
12857: IFFALSE 12881
// sort_list := sort_list ^ list [ i ] ;
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_VAR 0 5
12868: PUSH
12869: LD_VAR 0 1
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: ADD
12880: ST_TO_ADDR
// end ; end ;
12881: GO 12720
12883: POP
12884: POP
// result := sort_list ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_VAR 0 5
12894: ST_TO_ADDR
// end ;
12895: LD_VAR 0 2
12899: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// sort_list := [ ] ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// for i = 1 to list do
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: DOUBLE
12920: LD_INT 1
12922: DEC
12923: ST_TO_ADDR
12924: LD_VAR 0 1
12928: PUSH
12929: FOR_TO
12930: IFFALSE 13092
// begin if i = 1 then
12932: LD_VAR 0 3
12936: PUSH
12937: LD_INT 1
12939: EQUAL
12940: IFFALSE 12966
// sort_list := sort_list ^ list [ i ] else
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: LD_VAR 0 5
12951: PUSH
12952: LD_VAR 0 1
12956: PUSH
12957: LD_VAR 0 3
12961: ARRAY
12962: ADD
12963: ST_TO_ADDR
12964: GO 13090
// begin for j = 1 to sort_list do
12966: LD_ADDR_VAR 0 4
12970: PUSH
12971: DOUBLE
12972: LD_INT 1
12974: DEC
12975: ST_TO_ADDR
12976: LD_VAR 0 5
12980: PUSH
12981: FOR_TO
12982: IFFALSE 13059
// begin add := false ;
12984: LD_ADDR_VAR 0 6
12988: PUSH
12989: LD_INT 0
12991: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_VAR 0 3
13001: ARRAY
13002: PUSH
13003: LD_VAR 0 5
13007: PUSH
13008: LD_VAR 0 4
13012: ARRAY
13013: GREATER
13014: IFFALSE 13057
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13016: LD_ADDR_VAR 0 5
13020: PUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: LD_VAR 0 4
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_VAR 0 3
13040: ARRAY
13041: PPUSH
13042: CALL_OW 2
13046: ST_TO_ADDR
// add := true ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// break ;
13055: GO 13059
// end ; end ;
13057: GO 12981
13059: POP
13060: POP
// if not add then
13061: LD_VAR 0 6
13065: NOT
13066: IFFALSE 13090
// sort_list := sort_list ^ list [ i ] ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_VAR 0 5
13077: PUSH
13078: LD_VAR 0 1
13082: PUSH
13083: LD_VAR 0 3
13087: ARRAY
13088: ADD
13089: ST_TO_ADDR
// end ; end ;
13090: GO 12929
13092: POP
13093: POP
// result := sort_list ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 5
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 2
13108: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: LESS
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
13427: PPUSH
// tmp := [ ] ;
13428: LD_ADDR_VAR 0 8
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// r := [ ] ;
13435: LD_ADDR_VAR 0 7
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// add := false ;
13442: LD_ADDR_VAR 0 9
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// if plist then
13450: LD_VAR 0 2
13454: IFFALSE 13530
// begin for i = 1 to plist do
13456: LD_ADDR_VAR 0 5
13460: PUSH
13461: DOUBLE
13462: LD_INT 1
13464: DEC
13465: ST_TO_ADDR
13466: LD_VAR 0 2
13470: PUSH
13471: FOR_TO
13472: IFFALSE 13526
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13474: LD_ADDR_VAR 0 8
13478: PUSH
13479: LD_VAR 0 8
13483: PUSH
13484: LD_VAR 0 2
13488: PUSH
13489: LD_VAR 0 5
13493: ARRAY
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ARRAY
13505: PPUSH
13506: LD_VAR 0 3
13510: PPUSH
13511: CALL_OW 259
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: ADD
13523: ST_TO_ADDR
// end ;
13524: GO 13471
13526: POP
13527: POP
// end else
13528: GO 13538
// result := false ;
13530: LD_ADDR_VAR 0 4
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// if tmp then
13538: LD_VAR 0 8
13542: IFFALSE 13716
// begin r := r ^ [ tmp [ 1 ] ] ;
13544: LD_ADDR_VAR 0 7
13548: PUSH
13549: LD_VAR 0 7
13553: PUSH
13554: LD_VAR 0 8
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PUSH
13563: EMPTY
13564: LIST
13565: ADD
13566: ST_TO_ADDR
// for i = 2 to tmp do
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: DOUBLE
13573: LD_INT 2
13575: DEC
13576: ST_TO_ADDR
13577: LD_VAR 0 8
13581: PUSH
13582: FOR_TO
13583: IFFALSE 13714
// begin for j = 1 to r do
13585: LD_ADDR_VAR 0 6
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 7
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13678
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13603: LD_VAR 0 8
13607: PUSH
13608: LD_VAR 0 5
13612: ARRAY
13613: PUSH
13614: LD_INT 2
13616: ARRAY
13617: PUSH
13618: LD_VAR 0 7
13622: PUSH
13623: LD_VAR 0 6
13627: ARRAY
13628: PUSH
13629: LD_INT 2
13631: ARRAY
13632: GREATER
13633: IFFALSE 13676
// begin r := Insert ( r , j , tmp [ i ] ) ;
13635: LD_ADDR_VAR 0 7
13639: PUSH
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 8
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 2
13665: ST_TO_ADDR
// add := true ;
13666: LD_ADDR_VAR 0 9
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// break ;
13674: GO 13678
// end ; end ;
13676: GO 13600
13678: POP
13679: POP
// if not add then
13680: LD_VAR 0 9
13684: NOT
13685: IFFALSE 13712
// r := r ^ [ tmp [ i ] ] ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_VAR 0 7
13696: PUSH
13697: LD_VAR 0 8
13701: PUSH
13702: LD_VAR 0 5
13706: ARRAY
13707: PUSH
13708: EMPTY
13709: LIST
13710: ADD
13711: ST_TO_ADDR
// end ;
13712: GO 13582
13714: POP
13715: POP
// end ; result := r ;
13716: LD_ADDR_VAR 0 4
13720: PUSH
13721: LD_VAR 0 7
13725: ST_TO_ADDR
// end ;
13726: LD_VAR 0 4
13730: RET
// export function MCF_Clear ( side ) ; var i ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
// for i = 1 to 100 do
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: DOUBLE
13741: LD_INT 1
13743: DEC
13744: ST_TO_ADDR
13745: LD_INT 100
13747: PUSH
13748: FOR_TO
13749: IFFALSE 13785
// if MCF_Tag ( side , i , [ ] ) then
13751: LD_VAR 0 1
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: EMPTY
13762: PPUSH
13763: CALL 12354 0 3
13767: IFFALSE 13783
// MCF_ClearTag ( side , i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL 12595 0 2
13783: GO 13748
13785: POP
13786: POP
// result := true ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 1
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
// for i = 1 to plist do
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: DOUBLE
13811: LD_INT 1
13813: DEC
13814: ST_TO_ADDR
13815: LD_VAR 0 1
13819: PUSH
13820: FOR_TO
13821: IFFALSE 13870
// if MCF_HasClass ( plist [ i ] ) = n then
13823: LD_VAR 0 1
13827: PUSH
13828: LD_VAR 0 4
13832: ARRAY
13833: PPUSH
13834: CALL 14357 0 1
13838: PUSH
13839: LD_VAR 0 2
13843: EQUAL
13844: IFFALSE 13868
// tmp := tmp ^ plist [ i ] ;
13846: LD_ADDR_VAR 0 5
13850: PUSH
13851: LD_VAR 0 5
13855: PUSH
13856: LD_VAR 0 1
13860: PUSH
13861: LD_VAR 0 4
13865: ARRAY
13866: ADD
13867: ST_TO_ADDR
13868: GO 13820
13870: POP
13871: POP
// result := tmp ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_VAR 0 5
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 3
13886: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
13891: PPUSH
// if mreg = ToArm then
13892: LD_VAR 0 2
13896: PUSH
13897: LD_STRING ToArm
13899: EQUAL
13900: IFFALSE 14005
// begin tmp := MREG_ToArm [ side ] ;
13902: LD_ADDR_VAR 0 6
13906: PUSH
13907: LD_EXP 56
13911: PUSH
13912: LD_VAR 0 1
13916: ARRAY
13917: ST_TO_ADDR
// if tmp = 0 then
13918: LD_VAR 0 6
13922: PUSH
13923: LD_INT 0
13925: EQUAL
13926: IFFALSE 13932
// exit else
13928: GO 14352
13930: GO 14005
// begin for i = MREG_ToArm [ side ] downto n do
13932: LD_ADDR_VAR 0 5
13936: PUSH
13937: DOUBLE
13938: LD_EXP 56
13942: PUSH
13943: LD_VAR 0 1
13947: ARRAY
13948: INC
13949: ST_TO_ADDR
13950: LD_VAR 0 3
13954: PUSH
13955: FOR_DOWNTO
13956: IFFALSE 13978
// tmp := Delete ( tmp , 1 ) ;
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: LD_INT 1
13970: PPUSH
13971: CALL_OW 3
13975: ST_TO_ADDR
13976: GO 13955
13978: POP
13979: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13980: LD_ADDR_EXP 56
13984: PUSH
13985: LD_EXP 56
13989: PPUSH
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 6
13999: PPUSH
14000: CALL_OW 1
14004: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14005: LD_VAR 0 2
14009: PUSH
14010: LD_STRING ToDep
14012: EQUAL
14013: IFFALSE 14118
// begin tmp := MREG_ToDep [ side ] ;
14015: LD_ADDR_VAR 0 6
14019: PUSH
14020: LD_EXP 57
14024: PUSH
14025: LD_VAR 0 1
14029: ARRAY
14030: ST_TO_ADDR
// if tmp = 0 then
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 0
14038: EQUAL
14039: IFFALSE 14045
// exit else
14041: GO 14352
14043: GO 14118
// begin for i = MREG_ToDep [ side ] downto n do
14045: LD_ADDR_VAR 0 5
14049: PUSH
14050: DOUBLE
14051: LD_EXP 57
14055: PUSH
14056: LD_VAR 0 1
14060: ARRAY
14061: INC
14062: ST_TO_ADDR
14063: LD_VAR 0 3
14067: PUSH
14068: FOR_DOWNTO
14069: IFFALSE 14091
// tmp := Delete ( tmp , 1 ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 3
14088: ST_TO_ADDR
14089: GO 14068
14091: POP
14092: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14093: LD_ADDR_EXP 57
14097: PUSH
14098: LD_EXP 57
14102: PPUSH
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 6
14112: PPUSH
14113: CALL_OW 1
14117: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14118: LD_VAR 0 2
14122: PUSH
14123: LD_STRING ToFac
14125: EQUAL
14126: IFFALSE 14231
// begin tmp := MREG_ToFac [ side ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_EXP 55
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: ST_TO_ADDR
// if tmp = 0 then
14144: LD_VAR 0 6
14148: PUSH
14149: LD_INT 0
14151: EQUAL
14152: IFFALSE 14158
// exit else
14154: GO 14352
14156: GO 14231
// begin for i = MREG_ToFac [ side ] downto n do
14158: LD_ADDR_VAR 0 5
14162: PUSH
14163: DOUBLE
14164: LD_EXP 55
14168: PUSH
14169: LD_VAR 0 1
14173: ARRAY
14174: INC
14175: ST_TO_ADDR
14176: LD_VAR 0 3
14180: PUSH
14181: FOR_DOWNTO
14182: IFFALSE 14204
// tmp := Delete ( tmp , 1 ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 6
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 3
14201: ST_TO_ADDR
14202: GO 14181
14204: POP
14205: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14206: LD_ADDR_EXP 55
14210: PUSH
14211: LD_EXP 55
14215: PPUSH
14216: LD_VAR 0 1
14220: PPUSH
14221: LD_VAR 0 6
14225: PPUSH
14226: CALL_OW 1
14230: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14231: LD_VAR 0 2
14235: PUSH
14236: LD_STRING ToLab
14238: EQUAL
14239: IFFALSE 14344
// begin tmp := MREG_ToLab [ side ] ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_EXP 54
14250: PUSH
14251: LD_VAR 0 1
14255: ARRAY
14256: ST_TO_ADDR
// if tmp = 0 then
14257: LD_VAR 0 6
14261: PUSH
14262: LD_INT 0
14264: EQUAL
14265: IFFALSE 14271
// exit else
14267: GO 14352
14269: GO 14344
// begin for i = MREG_ToLab [ side ] downto n do
14271: LD_ADDR_VAR 0 5
14275: PUSH
14276: DOUBLE
14277: LD_EXP 54
14281: PUSH
14282: LD_VAR 0 1
14286: ARRAY
14287: INC
14288: ST_TO_ADDR
14289: LD_VAR 0 3
14293: PUSH
14294: FOR_DOWNTO
14295: IFFALSE 14317
// tmp := Delete ( tmp , 1 ) ;
14297: LD_ADDR_VAR 0 6
14301: PUSH
14302: LD_VAR 0 6
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 3
14314: ST_TO_ADDR
14315: GO 14294
14317: POP
14318: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14319: LD_ADDR_EXP 54
14323: PUSH
14324: LD_EXP 54
14328: PPUSH
14329: LD_VAR 0 1
14333: PPUSH
14334: LD_VAR 0 6
14338: PPUSH
14339: CALL_OW 1
14343: ST_TO_ADDR
// end ; end ; result := true ;
14344: LD_ADDR_VAR 0 4
14348: PUSH
14349: LD_INT 1
14351: ST_TO_ADDR
// end ;
14352: LD_VAR 0 4
14356: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
// side := GetSide ( unit ) ;
14362: LD_ADDR_VAR 0 4
14366: PUSH
14367: LD_VAR 0 1
14371: PPUSH
14372: CALL_OW 255
14376: ST_TO_ADDR
// tmp := 0 ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14385: LD_VAR 0 1
14389: PUSH
14390: LD_EXP 56
14394: PUSH
14395: LD_VAR 0 4
14399: ARRAY
14400: IN
14401: IFFALSE 14411
// tmp := 1 ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14411: LD_VAR 0 1
14415: PUSH
14416: LD_EXP 57
14420: PUSH
14421: LD_VAR 0 4
14425: ARRAY
14426: IN
14427: IFFALSE 14437
// tmp := 2 ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_INT 2
14436: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14437: LD_VAR 0 1
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: LD_VAR 0 4
14451: ARRAY
14452: IN
14453: IFFALSE 14463
// tmp := 3 ;
14455: LD_ADDR_VAR 0 3
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_EXP 54
14472: PUSH
14473: LD_VAR 0 4
14477: ARRAY
14478: IN
14479: IFFALSE 14489
// tmp := 4 ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: LD_INT 4
14488: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 68
14498: PUSH
14499: LD_VAR 0 4
14503: ARRAY
14504: IN
14505: IFFALSE 14515
// tmp := 5 ;
14507: LD_ADDR_VAR 0 3
14511: PUSH
14512: LD_INT 5
14514: ST_TO_ADDR
// result := tmp ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 3
14524: ST_TO_ADDR
// end ;
14525: LD_VAR 0 2
14529: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
// if mreg = ToArm then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_STRING ToArm
14541: EQUAL
14542: IFFALSE 14631
// for i = MREG_ToArm [ side ] downto 1 do
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: DOUBLE
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: INC
14561: ST_TO_ADDR
14562: LD_INT 1
14564: PUSH
14565: FOR_DOWNTO
14566: IFFALSE 14629
// if MREG_ToArm [ side ] [ i ] = unit then
14568: LD_EXP 56
14572: PUSH
14573: LD_VAR 0 1
14577: ARRAY
14578: PUSH
14579: LD_VAR 0 5
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: EQUAL
14590: IFFALSE 14627
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14592: LD_ADDR_EXP 56
14596: PUSH
14597: LD_EXP 56
14601: PPUSH
14602: LD_EXP 56
14606: PUSH
14607: LD_VAR 0 1
14611: ARRAY
14612: PUSH
14613: LD_VAR 0 5
14617: ARRAY
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 31289 0 3
14626: ST_TO_ADDR
// end ;
14627: GO 14565
14629: POP
14630: POP
// if mreg = ToDep then
14631: LD_VAR 0 2
14635: PUSH
14636: LD_STRING ToDep
14638: EQUAL
14639: IFFALSE 14728
// for i = MREG_ToDep [ side ] downto 1 do
14641: LD_ADDR_VAR 0 5
14645: PUSH
14646: DOUBLE
14647: LD_EXP 57
14651: PUSH
14652: LD_VAR 0 1
14656: ARRAY
14657: INC
14658: ST_TO_ADDR
14659: LD_INT 1
14661: PUSH
14662: FOR_DOWNTO
14663: IFFALSE 14726
// if MREG_ToDep [ side ] [ i ] = unit then
14665: LD_EXP 57
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PUSH
14676: LD_VAR 0 5
14680: ARRAY
14681: PUSH
14682: LD_VAR 0 3
14686: EQUAL
14687: IFFALSE 14724
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14689: LD_ADDR_EXP 57
14693: PUSH
14694: LD_EXP 57
14698: PPUSH
14699: LD_EXP 57
14703: PUSH
14704: LD_VAR 0 1
14708: ARRAY
14709: PUSH
14710: LD_VAR 0 5
14714: ARRAY
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: CALL 31289 0 3
14723: ST_TO_ADDR
// end ;
14724: GO 14662
14726: POP
14727: POP
// if mreg = ToFac then
14728: LD_VAR 0 2
14732: PUSH
14733: LD_STRING ToFac
14735: EQUAL
14736: IFFALSE 14825
// for i = MREG_ToFac [ side ] downto 1 do
14738: LD_ADDR_VAR 0 5
14742: PUSH
14743: DOUBLE
14744: LD_EXP 55
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: INC
14755: ST_TO_ADDR
14756: LD_INT 1
14758: PUSH
14759: FOR_DOWNTO
14760: IFFALSE 14823
// if MREG_ToFac [ side ] [ i ] = unit then
14762: LD_EXP 55
14766: PUSH
14767: LD_VAR 0 1
14771: ARRAY
14772: PUSH
14773: LD_VAR 0 5
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 3
14783: EQUAL
14784: IFFALSE 14821
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14786: LD_ADDR_EXP 55
14790: PUSH
14791: LD_EXP 55
14795: PPUSH
14796: LD_EXP 55
14800: PUSH
14801: LD_VAR 0 1
14805: ARRAY
14806: PUSH
14807: LD_VAR 0 5
14811: ARRAY
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL 31289 0 3
14820: ST_TO_ADDR
// end ;
14821: GO 14759
14823: POP
14824: POP
// if mreg = ToLab then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_STRING ToLab
14832: EQUAL
14833: IFFALSE 14922
// for i = MREG_ToLab [ side ] downto 1 do
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: DOUBLE
14841: LD_EXP 54
14845: PUSH
14846: LD_VAR 0 1
14850: ARRAY
14851: INC
14852: ST_TO_ADDR
14853: LD_INT 1
14855: PUSH
14856: FOR_DOWNTO
14857: IFFALSE 14920
// if MREG_ToLab [ side ] [ i ] = unit then
14859: LD_EXP 54
14863: PUSH
14864: LD_VAR 0 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 5
14874: ARRAY
14875: PUSH
14876: LD_VAR 0 3
14880: EQUAL
14881: IFFALSE 14918
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14883: LD_ADDR_EXP 54
14887: PUSH
14888: LD_EXP 54
14892: PPUSH
14893: LD_EXP 54
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PUSH
14904: LD_VAR 0 5
14908: ARRAY
14909: PPUSH
14910: LD_INT 1
14912: PPUSH
14913: CALL 31289 0 3
14917: ST_TO_ADDR
// end ;
14918: GO 14856
14920: POP
14921: POP
// end ;
14922: LD_VAR 0 4
14926: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// result := false ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: DOUBLE
14945: LD_INT 1
14947: DEC
14948: ST_TO_ADDR
14949: LD_EXP 46
14953: PUSH
14954: FOR_TO
14955: IFFALSE 15019
// if MREG_ToBuild [ i ] [ 1 ] = side then
14957: LD_EXP 46
14961: PUSH
14962: LD_VAR 0 3
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_VAR 0 1
14976: EQUAL
14977: IFFALSE 15017
// begin if MREG_ToBuild [ i ] [ 1 ] then
14979: LD_EXP 46
14983: PUSH
14984: LD_VAR 0 3
14988: ARRAY
14989: PUSH
14990: LD_INT 1
14992: ARRAY
14993: IFFALSE 15017
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14995: LD_ADDR_VAR 0 2
14999: PUSH
15000: LD_EXP 46
15004: PUSH
15005: LD_VAR 0 3
15009: ARRAY
15010: PUSH
15011: LD_INT 1
15013: ARRAY
15014: ST_TO_ADDR
// break ;
15015: GO 15019
// end ; end ;
15017: GO 14954
15019: POP
15020: POP
// for i = 1 to MREG_ToRepair do
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: DOUBLE
15027: LD_INT 1
15029: DEC
15030: ST_TO_ADDR
15031: LD_EXP 47
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15101
// if MREG_ToRepair [ i ] [ 1 ] = side then
15039: LD_EXP 47
15043: PUSH
15044: LD_VAR 0 3
15048: ARRAY
15049: PUSH
15050: LD_INT 1
15052: ARRAY
15053: PUSH
15054: LD_VAR 0 1
15058: EQUAL
15059: IFFALSE 15099
// begin if MREG_ToRepair [ i ] [ 1 ] then
15061: LD_EXP 47
15065: PUSH
15066: LD_VAR 0 3
15070: ARRAY
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: IFFALSE 15099
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15077: LD_ADDR_VAR 0 2
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: LD_VAR 0 3
15091: ARRAY
15092: PUSH
15093: LD_INT 1
15095: ARRAY
15096: ST_TO_ADDR
// break ;
15097: GO 15101
// end ; end ;
15099: GO 15036
15101: POP
15102: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_INT 57
15110: PUSH
15111: EMPTY
15112: LIST
15113: PPUSH
15114: CALL 11651 0 2
15118: IFFALSE 15145
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 57
15132: PUSH
15133: EMPTY
15134: LIST
15135: PPUSH
15136: CALL 11651 0 2
15140: PUSH
15141: LD_INT 1
15143: ARRAY
15144: ST_TO_ADDR
// end ;
15145: LD_VAR 0 2
15149: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL 11651 0 2
15181: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15182: LD_ADDR_VAR 0 7
15186: PUSH
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 81
15194: PUSH
15195: LD_VAR 0 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL 11651 0 2
15208: ST_TO_ADDR
// if not enemy then
15209: LD_VAR 0 7
15213: NOT
15214: IFFALSE 15226
// result := false else
15216: LD_ADDR_VAR 0 3
15220: PUSH
15221: LD_INT 0
15223: ST_TO_ADDR
15224: GO 15280
// begin scan := NearestUnit ( b , enemy ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 6
15235: PPUSH
15236: LD_VAR 0 7
15240: PPUSH
15241: CALL 32282 0 2
15245: ST_TO_ADDR
// if scan [ 2 ] < dist then
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 2
15259: LESS
15260: IFFALSE 15272
// result := true else
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
15270: GO 15280
// result := false ;
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 0
15279: ST_TO_ADDR
// end ; end ;
15280: LD_VAR 0 3
15284: RET
// export function MCF_Info ( ) ; begin
15285: LD_INT 0
15287: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15288: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15290: PUSH
15291: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15293: ADD
15294: PUSH
15295: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15297: ADD
15298: PUSH
15299: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15301: ADD
15302: PUSH
15303: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15305: ADD
15306: PUSH
15307: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15325: ADD
15326: PPUSH
15327: CALL 8569 0 1
// end ; end_of_file
15331: LD_VAR 0 1
15335: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 2
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11651 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13800 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 13420 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 1
15529: PPUSH
15530: CALL 41960 0 4
15534: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 56
15539: PUSH
15540: LD_EXP 56
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 56
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 31130 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 3
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11651 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13800 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 13420 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 2
15787: PPUSH
15788: CALL 41960 0 4
15792: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 57
15797: PUSH
15798: LD_EXP 57
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 57
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 31130 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 25
15893: PUSH
15894: LD_INT 4
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL 11651 0 2
15911: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15912: LD_ADDR_VAR 0 5
15916: PUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: LD_INT 0
15924: PPUSH
15925: CALL 13800 0 2
15929: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_VAR 0 5
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 13420 0 3
15952: ST_TO_ADDR
// if n > sk then
15953: LD_VAR 0 2
15957: PUSH
15958: LD_VAR 0 6
15962: GREATER
15963: IFFALSE 15975
// n := sk ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_VAR 0 6
15974: ST_TO_ADDR
// for i = 1 to n do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 2
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16103
// if ( sk [ i ] [ 1 ] ) <> 0 then
15993: LD_VAR 0 6
15997: PUSH
15998: LD_VAR 0 4
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PUSH
16008: LD_INT 0
16010: NONEQUAL
16011: IFFALSE 16101
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16013: LD_ADDR_EXP 53
16017: PUSH
16018: LD_EXP 53
16022: PPUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 6
16032: PUSH
16033: LD_VAR 0 4
16037: ARRAY
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_INT 3
16045: PPUSH
16046: CALL 41960 0 4
16050: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16051: LD_ADDR_EXP 55
16055: PUSH
16056: LD_EXP 55
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: LD_EXP 55
16070: PUSH
16071: LD_VAR 0 1
16075: ARRAY
16076: PUSH
16077: LD_INT 1
16079: PLUS
16080: PPUSH
16081: LD_VAR 0 6
16085: PUSH
16086: LD_VAR 0 4
16090: ARRAY
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL 31130 0 4
16100: ST_TO_ADDR
// end ;
16101: GO 15990
16103: POP
16104: POP
// end ;
16105: LD_VAR 0 3
16109: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16116: LD_ADDR_VAR 0 5
16120: PUSH
16121: LD_VAR 0 1
16125: PPUSH
16126: LD_INT 2
16128: PUSH
16129: LD_INT 25
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL 11651 0 2
16158: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: LD_VAR 0 5
16168: PPUSH
16169: LD_INT 0
16171: PPUSH
16172: CALL 13800 0 2
16176: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16177: LD_ADDR_VAR 0 6
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 13420 0 3
16199: ST_TO_ADDR
// if n > sk then
16200: LD_VAR 0 2
16204: PUSH
16205: LD_VAR 0 6
16209: GREATER
16210: IFFALSE 16222
// n := sk ;
16212: LD_ADDR_VAR 0 2
16216: PUSH
16217: LD_VAR 0 6
16221: ST_TO_ADDR
// for i = 1 to n do
16222: LD_ADDR_VAR 0 4
16226: PUSH
16227: DOUBLE
16228: LD_INT 1
16230: DEC
16231: ST_TO_ADDR
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_TO
16238: IFFALSE 16350
// if ( sk [ i ] [ 1 ] ) <> 0 then
16240: LD_VAR 0 6
16244: PUSH
16245: LD_VAR 0 4
16249: ARRAY
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: PUSH
16255: LD_INT 0
16257: NONEQUAL
16258: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 4
16284: ARRAY
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: PPUSH
16290: LD_INT 4
16292: PPUSH
16293: CALL 41960 0 4
16297: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16298: LD_ADDR_EXP 54
16302: PUSH
16303: LD_EXP 54
16307: PPUSH
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_EXP 54
16317: PUSH
16318: LD_VAR 0 1
16322: ARRAY
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: LD_VAR 0 6
16332: PUSH
16333: LD_VAR 0 4
16337: ARRAY
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 31130 0 4
16347: ST_TO_ADDR
// end ;
16348: GO 16237
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 3
16356: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 25
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 25
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 25
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL 11651 0 2
16427: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16428: LD_ADDR_VAR 0 6
16432: PUSH
16433: LD_VAR 0 6
16437: PPUSH
16438: LD_INT 0
16440: PPUSH
16441: CALL 13800 0 2
16445: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16446: LD_ADDR_VAR 0 7
16450: PUSH
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_VAR 0 6
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL 13420 0 3
16468: ST_TO_ADDR
// if n > sk then
16469: LD_VAR 0 2
16473: PUSH
16474: LD_VAR 0 7
16478: GREATER
16479: IFFALSE 16491
// n := sk ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 7
16490: ST_TO_ADDR
// for i = 1 to n do
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: DOUBLE
16497: LD_INT 1
16499: DEC
16500: ST_TO_ADDR
16501: LD_VAR 0 2
16505: PUSH
16506: FOR_TO
16507: IFFALSE 16551
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_EXP 53
16518: PPUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_VAR 0 7
16528: PUSH
16529: LD_VAR 0 5
16533: ARRAY
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 3
16543: PPUSH
16544: CALL 41960 0 4
16548: ST_TO_ADDR
// end ;
16549: GO 16506
16551: POP
16552: POP
// end ;
16553: LD_VAR 0 4
16557: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16558: LD_INT 0
16560: PPUSH
16561: PPUSH
16562: PPUSH
// b := false ;
16563: LD_ADDR_VAR 0 6
16567: PUSH
16568: LD_INT 0
16570: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: LD_INT 9
16581: PUSH
16582: LD_INT 5
16584: PUSH
16585: LD_INT 8
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: IN
16594: IFFALSE 16682
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16596: LD_VAR 0 1
16600: PPUSH
16601: LD_INT 2
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL 11651 0 2
16633: IFFALSE 16682
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 30
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL 11651 0 2
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: ST_TO_ADDR
// if class = class_engineer then
16682: LD_VAR 0 3
16686: PUSH
16687: LD_INT 2
16689: EQUAL
16690: IFFALSE 16778
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16692: LD_VAR 0 1
16696: PPUSH
16697: LD_INT 2
16699: PUSH
16700: LD_INT 30
16702: PUSH
16703: LD_INT 0
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 30
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL 11651 0 2
16729: IFFALSE 16778
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16731: LD_ADDR_VAR 0 6
16735: PUSH
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 30
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL 11651 0 2
16773: PUSH
16774: LD_INT 1
16776: ARRAY
16777: ST_TO_ADDR
// if class = class_mechanic then
16778: LD_VAR 0 3
16782: PUSH
16783: LD_INT 3
16785: EQUAL
16786: IFFALSE 16856
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 30
16795: PUSH
16796: LD_INT 3
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PPUSH
16803: CALL 11651 0 2
16807: IFFALSE 16856
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16809: LD_ADDR_VAR 0 6
16813: PUSH
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_INT 2
16821: PUSH
16822: LD_INT 30
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 30
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PPUSH
16847: CALL 11651 0 2
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: ST_TO_ADDR
// if class = class_scientistic then
16856: LD_VAR 0 3
16860: PUSH
16861: LD_INT 4
16863: EQUAL
16864: IFFALSE 16974
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16866: LD_VAR 0 1
16870: PPUSH
16871: LD_INT 2
16873: PUSH
16874: LD_INT 30
16876: PUSH
16877: LD_INT 6
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PUSH
16884: LD_INT 30
16886: PUSH
16887: LD_INT 7
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 30
16896: PUSH
16897: LD_INT 8
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PPUSH
16910: CALL 11651 0 2
16914: IFFALSE 16974
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16916: LD_ADDR_VAR 0 6
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: LD_INT 2
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 6
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 30
16941: PUSH
16942: LD_INT 7
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 30
16951: PUSH
16952: LD_INT 8
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL 11651 0 2
16969: PUSH
16970: LD_INT 1
16972: ARRAY
16973: ST_TO_ADDR
// if GetClass ( unit ) = class then
16974: LD_VAR 0 2
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_VAR 0 3
16988: EQUAL
16989: IFFALSE 17023
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16991: LD_ADDR_EXP 53
16995: PUSH
16996: LD_EXP 53
17000: PPUSH
17001: LD_VAR 0 1
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: LD_VAR 0 3
17015: PPUSH
17016: CALL 42051 0 4
17020: ST_TO_ADDR
// end else
17021: GO 17116
// if b then
17023: LD_VAR 0 6
17027: IFFALSE 17108
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17029: LD_VAR 0 2
17033: PPUSH
17034: CALL_OW 310
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: CALL_OW 310
17048: PUSH
17049: LD_VAR 0 6
17053: NONEQUAL
17054: AND
17055: IFFALSE 17066
// ComExitBuilding ( unit ) ;
17057: LD_VAR 0 2
17061: PPUSH
17062: CALL_OW 122
// if not IsInUnit ( unit ) then
17066: LD_VAR 0 2
17070: PPUSH
17071: CALL_OW 310
17075: NOT
17076: IFFALSE 17092
// ComEnterUnit ( unit , b ) ;
17078: LD_VAR 0 2
17082: PPUSH
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_VAR 0 3
17101: PPUSH
17102: CALL_OW 183
// end else
17106: GO 17116
// result := false ;
17108: LD_ADDR_VAR 0 4
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// end ; end_of_file
17116: LD_VAR 0 4
17120: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17121: LD_INT 0
17123: PPUSH
17124: PPUSH
17125: PPUSH
17126: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17127: LD_ADDR_VAR 0 5
17131: PUSH
17132: LD_INT 35
17134: PUSH
17135: LD_INT 45
17137: PUSH
17138: LD_INT 46
17140: PUSH
17141: LD_INT 47
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 48
17152: PUSH
17153: LD_INT 49
17155: PUSH
17156: LD_INT 50
17158: PUSH
17159: LD_INT 20
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// if MCF_Lab ( side ) then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL 11690 0 1
17183: IFFALSE 17422
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL 11690 0 1
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: CALL_OW 461
17203: PUSH
17204: LD_INT 2
17206: EQUAL
17207: IFFALSE 17346
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17209: LD_VAR 0 1
17213: PPUSH
17214: CALL 11690 0 1
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PPUSH
17223: LD_VAR 0 2
17227: PPUSH
17228: CALL 17518 0 2
17232: IFFALSE 17259
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11690 0 1
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 124
17257: GO 17346
// if MCF_Lab ( side ) > 1 then
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11690 0 1
17268: PUSH
17269: LD_INT 1
17271: GREATER
17272: IFFALSE 17346
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17274: LD_VAR 0 1
17278: PPUSH
17279: CALL 11690 0 1
17283: PUSH
17284: LD_INT 2
17286: ARRAY
17287: PPUSH
17288: CALL_OW 461
17292: PUSH
17293: LD_INT 2
17295: EQUAL
17296: IFFALSE 17346
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17298: LD_VAR 0 1
17302: PPUSH
17303: CALL 11690 0 1
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_VAR 0 2
17316: PPUSH
17317: CALL 17518 0 2
17321: IFFALSE 17346
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17323: LD_VAR 0 1
17327: PPUSH
17328: CALL 11690 0 1
17332: PUSH
17333: LD_INT 2
17335: ARRAY
17336: PPUSH
17337: LD_VAR 0 2
17341: PPUSH
17342: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 4
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: LIST
17367: LIST
17368: IN
17369: IFFALSE 17422
// begin for lab in MCF_Lab ( side ) do
17371: LD_ADDR_VAR 0 6
17375: PUSH
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 11690 0 1
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17420
// if BuildingStatus ( lab ) = bs_need_ape then
17389: LD_VAR 0 6
17393: PPUSH
17394: CALL_OW 461
17398: PUSH
17399: LD_INT 10
17401: EQUAL
17402: IFFALSE 17418
// MCL_ResTame ( side , lab ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL 17643 0 2
17418: GO 17386
17420: POP
17421: POP
// end ; end ; end ;
17422: LD_VAR 0 3
17426: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17427: LD_INT 0
17429: PPUSH
17430: PPUSH
// tmp := [ ] ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// if not lab then
17438: LD_VAR 0 1
17442: NOT
17443: IFFALSE 17455
// result := false else
17445: LD_ADDR_VAR 0 2
17449: PUSH
17450: LD_INT 0
17452: ST_TO_ADDR
17453: GO 17513
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17455: LD_ADDR_VAR 0 3
17459: PUSH
17460: LD_VAR 0 3
17464: PUSH
17465: LD_VAR 0 1
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 268
17477: ADD
17478: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_VAR 0 3
17488: PUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: LD_INT 2
17496: PPUSH
17497: CALL_OW 268
17501: ADD
17502: ST_TO_ADDR
// result := tmp ;
17503: LD_ADDR_VAR 0 2
17507: PUSH
17508: LD_VAR 0 3
17512: ST_TO_ADDR
// end ; end ;
17513: LD_VAR 0 2
17517: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 35
17530: PUSH
17531: LD_INT 45
17533: PUSH
17534: LD_INT 46
17536: PUSH
17537: LD_INT 47
17539: PUSH
17540: LD_INT 1
17542: PUSH
17543: LD_INT 2
17545: PUSH
17546: LD_INT 48
17548: PUSH
17549: LD_INT 49
17551: PUSH
17552: LD_INT 50
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: ST_TO_ADDR
// if lab then
17570: LD_VAR 0 1
17574: IFFALSE 17630
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17576: LD_VAR 0 2
17580: PUSH
17581: LD_VAR 0 5
17585: IN
17586: PUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: CALL_OW 481
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: CALL 17427 0 1
17606: IN
17607: OR
17608: IFFALSE 17620
// result := true else
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
17618: GO 17628
// result := false ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 0
17627: ST_TO_ADDR
// end else
17628: GO 17638
// result := false ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_INT 0
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 3
17642: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17643: LD_INT 0
17645: PPUSH
17646: PPUSH
17647: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17648: LD_ADDR_VAR 0 4
17652: PUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_INT 171
17660: PPUSH
17661: EMPTY
17662: PPUSH
17663: CALL 12354 0 3
17667: ST_TO_ADDR
// if not ape then
17668: LD_VAR 0 4
17672: NOT
17673: IFFALSE 17705
// if MCF_Ape ( side ) then
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 12064 0 1
17684: IFFALSE 17705
// ape := MCF_Ape ( side ) [ 1 ] ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12064 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: ST_TO_ADDR
// if ape then
17705: LD_VAR 0 4
17709: IFFALSE 17760
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17711: LD_VAR 0 4
17715: PUSH
17716: LD_INT 1
17718: ARRAY
17719: PPUSH
17720: CALL_OW 310
17724: PUSH
17725: LD_VAR 0 4
17729: PUSH
17730: LD_INT 1
17732: ARRAY
17733: PPUSH
17734: CALL_OW 310
17738: PUSH
17739: LD_VAR 0 2
17743: NONEQUAL
17744: AND
17745: IFFALSE 17760
// ComExitBuilding ( ape [ 1 ] ) ;
17747: LD_VAR 0 4
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 122
// if not lab then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17771
// exit else
17767: GO 17919
17769: GO 17879
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 4
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL 12354 0 3
17793: PUSH
17794: LD_INT 0
17796: EQUAL
17797: PUSH
17798: LD_VAR 0 2
17802: PPUSH
17803: CALL_OW 313
17807: PUSH
17808: LD_INT 6
17810: EQUAL
17811: AND
17812: IFFALSE 17879
// begin tmp := UnitsInside ( lab ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 313
17828: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17829: LD_VAR 0 5
17833: PUSH
17834: LD_VAR 0 5
17838: ARRAY
17839: PPUSH
17840: LD_INT 16
17842: PPUSH
17843: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17847: LD_VAR 0 5
17851: PUSH
17852: LD_VAR 0 5
17856: ARRAY
17857: PPUSH
17858: CALL_OW 310
17862: IFFALSE 17879
// ComExitBuilding ( tmp [ tmp ] ) ;
17864: LD_VAR 0 5
17868: PUSH
17869: LD_VAR 0 5
17873: ARRAY
17874: PPUSH
17875: CALL_OW 122
// end ; if ape then
17879: LD_VAR 0 4
17883: IFFALSE 17919
// if not IsInUnit ( ape [ 1 ] ) then
17885: LD_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: ARRAY
17893: PPUSH
17894: CALL_OW 310
17898: NOT
17899: IFFALSE 17919
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: LD_VAR 0 2
17914: PPUSH
17915: CALL_OW 120
// end ;
17919: LD_VAR 0 3
17923: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17924: LD_INT 0
17926: PPUSH
17927: PPUSH
17928: PPUSH
// result := false ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: LD_INT 0
17936: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PPUSH
17947: CALL 18034 0 1
17951: ST_TO_ADDR
// if techs then
17952: LD_VAR 0 3
17956: IFFALSE 17986
// if techs [ 2 ] then
17958: LD_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: ARRAY
17966: IFFALSE 17978
// result := true else
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ST_TO_ADDR
17976: GO 17986
// result := false ;
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 2
17990: RET
// export function MCL_Start ( side ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// if MCL_GetTechList ( side ) then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL 18034 0 1
18004: IFFALSE 18029
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18034 0 1
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL 17121 0 2
// end ;
18029: LD_VAR 0 2
18033: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18034: LD_INT 0
18036: PPUSH
18037: PPUSH
18038: PPUSH
// if MREG_ToRes then
18039: LD_EXP 50
18043: IFFALSE 18128
// for i = 1 to MREG_ToRes do
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_EXP 50
18059: PUSH
18060: FOR_TO
18061: IFFALSE 18126
// if MREG_ToRes [ i ] [ 1 ] = side then
18063: LD_EXP 50
18067: PUSH
18068: LD_VAR 0 3
18072: ARRAY
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PUSH
18078: LD_VAR 0 1
18082: EQUAL
18083: IFFALSE 18124
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18085: LD_ADDR_VAR 0 4
18089: PUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: LD_VAR 0 4
18099: PUSH
18100: LD_INT 1
18102: PLUS
18103: PPUSH
18104: LD_EXP 50
18108: PUSH
18109: LD_VAR 0 3
18113: ARRAY
18114: PUSH
18115: LD_INT 2
18117: ARRAY
18118: PPUSH
18119: CALL_OW 1
18123: ST_TO_ADDR
// end ;
18124: GO 18060
18126: POP
18127: POP
// result := techs ;
18128: LD_ADDR_VAR 0 2
18132: PUSH
18133: LD_VAR 0 4
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18143: LD_INT 0
18145: PPUSH
18146: PPUSH
// for i = 1 to tech_list do
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: DOUBLE
18153: LD_INT 1
18155: DEC
18156: ST_TO_ADDR
18157: LD_VAR 0 2
18161: PUSH
18162: FOR_TO
18163: IFFALSE 18217
// if not tech_list [ i ] = 20 then
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 4
18174: ARRAY
18175: PUSH
18176: LD_INT 20
18178: EQUAL
18179: NOT
18180: IFFALSE 18215
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: LD_VAR 0 2
18201: PUSH
18202: LD_VAR 0 4
18206: ARRAY
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL 41960 0 4
18214: ST_TO_ADDR
18215: GO 18162
18217: POP
18218: POP
// result := true ;
18219: LD_ADDR_VAR 0 3
18223: PUSH
18224: LD_INT 1
18226: ST_TO_ADDR
// end ;
18227: LD_VAR 0 3
18231: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// for i = MREG_ToRes downto 1 do
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: DOUBLE
18242: LD_EXP 50
18246: INC
18247: ST_TO_ADDR
18248: LD_INT 1
18250: PUSH
18251: FOR_DOWNTO
18252: IFFALSE 18298
// if MREG_ToRes [ i ] [ 1 ] = side then
18254: LD_EXP 50
18258: PUSH
18259: LD_VAR 0 3
18263: ARRAY
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_VAR 0 1
18273: EQUAL
18274: IFFALSE 18296
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18276: LD_ADDR_EXP 50
18280: PUSH
18281: LD_EXP 50
18285: PPUSH
18286: LD_VAR 0 3
18290: PPUSH
18291: CALL_OW 3
18295: ST_TO_ADDR
18296: GO 18251
18298: POP
18299: POP
// result := true ;
18300: LD_ADDR_VAR 0 2
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// end ;
18308: LD_VAR 0 2
18312: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18313: LD_INT 0
18315: PPUSH
// result := GetTechProgress ( side , tech ) ;
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 326
18335: ST_TO_ADDR
// end ;
18336: LD_VAR 0 3
18340: RET
// export function MCL_Require ( tech ) ; begin
18341: LD_INT 0
18343: PPUSH
// result := GetTechTechsReq ( tech ) ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL_OW 480
18358: ST_TO_ADDR
// end ; end_of_file
18359: LD_VAR 0 2
18363: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
18368: PPUSH
// uc_side := 0 ;
18369: LD_ADDR_OWVAR 20
18373: PUSH
18374: LD_INT 0
18376: ST_TO_ADDR
// uc_nation := 0 ;
18377: LD_ADDR_OWVAR 21
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// for i = 1 to n do
18385: LD_ADDR_VAR 0 5
18389: PUSH
18390: DOUBLE
18391: LD_INT 1
18393: DEC
18394: ST_TO_ADDR
18395: LD_VAR 0 2
18399: PUSH
18400: FOR_TO
18401: IFFALSE 18546
// begin hc_importance := 0 ;
18403: LD_ADDR_OWVAR 32
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// hc_gallery :=  ;
18411: LD_ADDR_OWVAR 33
18415: PUSH
18416: LD_STRING 
18418: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18419: LD_ADDR_OWVAR 35
18423: PUSH
18424: LD_VAR 0 3
18428: PUSH
18429: LD_INT 20
18431: MINUS
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_INT 20
18440: PLUS
18441: PPUSH
18442: CALL_OW 12
18446: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18447: LD_ADDR_OWVAR 31
18451: PUSH
18452: LD_INT 0
18454: PPUSH
18455: LD_INT 2
18457: PPUSH
18458: CALL_OW 12
18462: PUSH
18463: LD_INT 0
18465: PUSH
18466: LD_INT 0
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18478: LD_ADDR_OWVAR 30
18482: PUSH
18483: LD_INT 0
18485: PUSH
18486: LD_INT 0
18488: PUSH
18489: LD_INT 0
18491: PUSH
18492: LD_INT 0
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// hc_name :=  ;
18501: LD_ADDR_OWVAR 26
18505: PUSH
18506: LD_STRING 
18508: ST_TO_ADDR
// hc_class := class_apeman ;
18509: LD_ADDR_OWVAR 28
18513: PUSH
18514: LD_INT 12
18516: ST_TO_ADDR
// ape := CreateHuman ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: CALL_OW 44
18526: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18527: LD_VAR 0 6
18531: PPUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: LD_INT 0
18539: PPUSH
18540: CALL_OW 49
// end ;
18544: GO 18400
18546: POP
18547: POP
// end ;
18548: LD_VAR 0 4
18552: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18553: LD_INT 0
18555: PPUSH
18556: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 12064 0 1
18566: PUSH
18567: LD_EXP 37
18571: PUSH
18572: LD_VAR 0 1
18576: ARRAY
18577: GREATEREQUAL
18578: IFFALSE 18755
// begin if GetTag ( unit ) = 17 then
18580: LD_VAR 0 2
18584: PPUSH
18585: CALL_OW 110
18589: PUSH
18590: LD_INT 17
18592: EQUAL
18593: IFFALSE 18753
// begin SetTag ( unit , 0 ) ;
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_INT 0
18602: PPUSH
18603: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL 11690 0 1
18616: PUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL 18034 0 1
18626: NOT
18627: AND
18628: IFFALSE 18653
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18630: LD_VAR 0 2
18634: PPUSH
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 11690 0 1
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18653: LD_VAR 0 1
18657: PPUSH
18658: CALL 11690 0 1
18662: NOT
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 30
18671: PUSH
18672: LD_INT 1
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL 11651 0 2
18683: AND
18684: IFFALSE 18753
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18686: LD_VAR 0 2
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL 11651 0 2
18710: PUSH
18711: LD_INT 1
18713: ARRAY
18714: PPUSH
18715: CALL_OW 250
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 11651 0 2
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: CALL_OW 251
18748: PPUSH
18749: CALL_OW 111
// end ; end else
18753: GO 18939
// if GetClass ( unit ) <> 4 then
18755: LD_VAR 0 2
18759: PPUSH
18760: CALL_OW 257
18764: PUSH
18765: LD_INT 4
18767: NONEQUAL
18768: IFFALSE 18774
// exit else
18770: GO 18939
18772: GO 18939
// if GetTag ( unit ) = 0 then
18774: LD_VAR 0 2
18778: PPUSH
18779: CALL_OW 110
18783: PUSH
18784: LD_INT 0
18786: EQUAL
18787: IFFALSE 18803
// SetTag ( unit , 17 ) else
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 17
18796: PPUSH
18797: CALL_OW 109
18801: GO 18939
// begin if IsInUnit ( unit ) then
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18823
// ComExitBuilding ( unit ) ;
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 122
// Wait ( 1 ) ;
18823: LD_INT 1
18825: PPUSH
18826: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18830: LD_ADDR_VAR 0 4
18834: PUSH
18835: LD_INT 22
18837: PUSH
18838: LD_INT 0
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 25
18847: PUSH
18848: LD_INT 12
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PPUSH
18859: CALL_OW 69
18863: PPUSH
18864: LD_VAR 0 2
18868: PPUSH
18869: CALL_OW 74
18873: ST_TO_ADDR
// if not ape then
18874: LD_VAR 0 4
18878: NOT
18879: IFFALSE 18885
// exit else
18881: GO 18939
18883: GO 18894
// ComHold ( ape ) ;
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 140
// if not HasTask ( unit ) then
18894: LD_VAR 0 2
18898: PPUSH
18899: CALL_OW 314
18903: NOT
18904: IFFALSE 18937
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18906: LD_VAR 0 2
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: CALL_OW 250
18920: PPUSH
18921: LD_VAR 0 4
18925: PPUSH
18926: CALL_OW 251
18930: PPUSH
18931: CALL_OW 131
18935: GO 18939
// exit ;
18937: GO 18939
// end ; end ;
18939: LD_VAR 0 3
18943: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18944: LD_INT 0
18946: PPUSH
18947: PPUSH
18948: PPUSH
18949: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18950: LD_ADDR_VAR 0 4
18954: PUSH
18955: LD_EXP 38
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18966: LD_ADDR_VAR 0 5
18970: PUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: LD_STRING normal
18978: PPUSH
18979: CALL 12148 0 2
18983: ST_TO_ADDR
// if apes then
18984: LD_VAR 0 5
18988: IFFALSE 19216
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18990: LD_INT 2
18992: PPUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 321
19002: PUSH
19003: LD_INT 2
19005: EQUAL
19006: PUSH
19007: LD_VAR 0 4
19011: PUSH
19012: LD_INT 2
19014: ARRAY
19015: PUSH
19016: LD_INT 1
19018: EQUAL
19019: AND
19020: PUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: LD_STRING engineer
19028: PPUSH
19029: CALL 12148 0 2
19033: PUSH
19034: LD_INT 3
19036: LESS
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 1
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11651 0 2
19058: AND
19059: IFFALSE 19113
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 1
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11651 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end else
19111: GO 19216
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19113: LD_INT 11
19115: PPUSH
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 321
19125: PUSH
19126: LD_INT 2
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: LD_INT 1
19137: ARRAY
19138: PUSH
19139: LD_INT 1
19141: EQUAL
19142: AND
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_INT 30
19151: PUSH
19152: LD_INT 5
19154: PUSH
19155: EMPTY
19156: LIST
19157: LIST
19158: PPUSH
19159: CALL 11651 0 2
19163: AND
19164: IFFALSE 19216
// begin for i in apes do
19166: LD_ADDR_VAR 0 3
19170: PUSH
19171: LD_VAR 0 5
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19214
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 5
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11651 0 2
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: CALL_OW 120
// end ;
19212: GO 19176
19214: POP
19215: POP
// end ; end ; end ; end_of_file
19216: LD_VAR 0 2
19220: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 257
19234: PUSH
19235: LD_INT 4
19237: EQUAL
19238: NOT
19239: PUSH
19240: LD_VAR 0 2
19244: NOT
19245: OR
19246: IFFALSE 19252
// exit else
19248: GO 19286
19250: GO 19286
// if not GetTag ( unit ) = 4 then
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 110
19261: PUSH
19262: LD_INT 4
19264: EQUAL
19265: NOT
19266: IFFALSE 19272
// exit else
19268: GO 19286
19270: GO 19286
// ComHeal ( unit , target ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL_OW 128
// end ;
19286: LD_VAR 0 3
19290: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19291: LD_INT 0
19293: PPUSH
19294: PPUSH
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
19299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19300: LD_ADDR_VAR 0 5
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_VAR 0 1
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 1
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 55
19332: PUSH
19333: EMPTY
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 3
19342: PUSH
19343: LD_INT 54
19345: PUSH
19346: EMPTY
19347: LIST
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 3
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 1000
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_INT 30
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 11651 0 2
19406: ST_TO_ADDR
// r := [ ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: EMPTY
19413: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19414: LD_VAR 0 1
19418: PPUSH
19419: LD_INT 5
19421: PPUSH
19422: EMPTY
19423: PPUSH
19424: CALL 12354 0 3
19428: IFFALSE 19484
// for j in MCF_Tag ( side , 5 , [ ] ) do
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: LD_INT 5
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL 12354 0 3
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19482
// if GetLives ( j ) = 1000 then
19453: LD_VAR 0 4
19457: PPUSH
19458: CALL_OW 256
19462: PUSH
19463: LD_INT 1000
19465: EQUAL
19466: IFFALSE 19480
// SetTag ( j , 0 ) ;
19468: LD_VAR 0 4
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL_OW 109
19480: GO 19450
19482: POP
19483: POP
// if tmp then
19484: LD_VAR 0 5
19488: IFFALSE 19817
// begin r := [ tmp [ 1 ] ] ;
19490: LD_ADDR_VAR 0 6
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_INT 1
19502: ARRAY
19503: PUSH
19504: EMPTY
19505: LIST
19506: ST_TO_ADDR
// for i = 2 to tmp do
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: DOUBLE
19513: LD_INT 2
19515: DEC
19516: ST_TO_ADDR
19517: LD_VAR 0 5
19521: PUSH
19522: FOR_TO
19523: IFFALSE 19815
// begin m := false ;
19525: LD_ADDR_VAR 0 7
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// if d then
19533: LD_VAR 0 8
19537: IFFALSE 19692
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19539: LD_VAR 0 5
19543: PUSH
19544: LD_VAR 0 3
19548: ARRAY
19549: PPUSH
19550: CALL_OW 256
19554: PUSH
19555: LD_INT 650
19557: LESS
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: PPUSH
19570: LD_VAR 0 8
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: CALL_OW 250
19583: PPUSH
19584: LD_VAR 0 8
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: CALL_OW 251
19597: PPUSH
19598: CALL_OW 297
19602: PUSH
19603: LD_INT 10
19605: GREATER
19606: AND
19607: IFFALSE 19692
// begin if not GetTag ( tmp [ i ] ) = 5 then
19609: LD_VAR 0 5
19613: PUSH
19614: LD_VAR 0 3
19618: ARRAY
19619: PPUSH
19620: CALL_OW 110
19624: PUSH
19625: LD_INT 5
19627: EQUAL
19628: NOT
19629: IFFALSE 19649
// SetTag ( tmp [ i ] , 5 ) ;
19631: LD_VAR 0 5
19635: PUSH
19636: LD_VAR 0 3
19640: ARRAY
19641: PPUSH
19642: LD_INT 5
19644: PPUSH
19645: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: LD_VAR 0 8
19664: PUSH
19665: LD_INT 1
19667: ARRAY
19668: PPUSH
19669: CALL_OW 250
19673: PPUSH
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 1
19681: ARRAY
19682: PPUSH
19683: CALL_OW 251
19687: PPUSH
19688: CALL_OW 111
// end ; for j = 1 to r do
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_VAR 0 6
19706: PUSH
19707: FOR_TO
19708: IFFALSE 19782
// if GetLives ( tmp [ i ] ) < r [ j ] then
19710: LD_VAR 0 5
19714: PUSH
19715: LD_VAR 0 3
19719: ARRAY
19720: PPUSH
19721: CALL_OW 256
19725: PUSH
19726: LD_VAR 0 6
19730: PUSH
19731: LD_VAR 0 4
19735: ARRAY
19736: LESS
19737: IFFALSE 19780
// begin r := Insert ( r , j , tmp [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 6
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 5
19758: PUSH
19759: LD_VAR 0 3
19763: ARRAY
19764: PPUSH
19765: CALL_OW 2
19769: ST_TO_ADDR
// m := true ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// break ;
19778: GO 19782
// end ;
19780: GO 19707
19782: POP
19783: POP
// if not m then
19784: LD_VAR 0 7
19788: NOT
19789: IFFALSE 19813
// r := r ^ tmp [ i ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_VAR 0 6
19800: PUSH
19801: LD_VAR 0 5
19805: PUSH
19806: LD_VAR 0 3
19810: ARRAY
19811: ADD
19812: ST_TO_ADDR
// end ;
19813: GO 19522
19815: POP
19816: POP
// end ; result := r end ; end_of_file
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: LD_VAR 0 6
19826: ST_TO_ADDR
19827: LD_VAR 0 2
19831: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19832: LD_INT 0
19834: PPUSH
19835: PPUSH
19836: PPUSH
// pom := GetBase ( bdepot ) ;
19837: LD_ADDR_VAR 0 3
19841: PUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: CALL_OW 274
19851: ST_TO_ADDR
// sor := [ ] ;
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: EMPTY
19858: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 4
19868: PUSH
19869: LD_VAR 0 3
19873: PPUSH
19874: LD_INT 1
19876: PPUSH
19877: CALL_OW 275
19881: ADD
19882: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_VAR 0 4
19892: PUSH
19893: LD_VAR 0 3
19897: PPUSH
19898: LD_INT 2
19900: PPUSH
19901: CALL_OW 275
19905: ADD
19906: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19907: LD_ADDR_VAR 0 4
19911: PUSH
19912: LD_VAR 0 4
19916: PUSH
19917: LD_VAR 0 3
19921: PPUSH
19922: LD_INT 3
19924: PPUSH
19925: CALL_OW 275
19929: ADD
19930: ST_TO_ADDR
// result := sor ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_VAR 0 4
19940: ST_TO_ADDR
// end ;
19941: LD_VAR 0 2
19945: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19946: LD_INT 0
19948: PPUSH
19949: PPUSH
// while ( coord_list ) do
19950: LD_VAR 0 3
19954: IFFALSE 20128
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19956: LD_ADDR_EXP 46
19960: PUSH
19961: LD_EXP 46
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_VAR 0 3
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 3
20001: ARRAY
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PPUSH
20008: CALL 41960 0 4
20012: ST_TO_ADDR
// if weapon_list then
20013: LD_VAR 0 4
20017: IFFALSE 20088
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20019: LD_ADDR_EXP 43
20023: PUSH
20024: LD_EXP 43
20028: PPUSH
20029: LD_VAR 0 1
20033: PPUSH
20034: LD_VAR 0 4
20038: PUSH
20039: LD_INT 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 3
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_VAR 0 3
20056: PUSH
20057: LD_INT 2
20059: ARRAY
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL 41960 0 4
20069: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20070: LD_ADDR_VAR 0 4
20074: PUSH
20075: LD_VAR 0 4
20079: PPUSH
20080: LD_INT 1
20082: PPUSH
20083: CALL_OW 3
20087: ST_TO_ADDR
// end ; for i = 1 to 3 do
20088: LD_ADDR_VAR 0 6
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20124
// coord_list := Delete ( coord_list , 1 ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_VAR 0 3
20113: PPUSH
20114: LD_INT 1
20116: PPUSH
20117: CALL_OW 3
20121: ST_TO_ADDR
20122: GO 20101
20124: POP
20125: POP
// end ;
20126: GO 19950
// result := true ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// end ;
20136: LD_VAR 0 5
20140: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20141: LD_INT 0
20143: PPUSH
20144: PPUSH
// if not weapon_list then
20145: LD_VAR 0 3
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20269
// while ( coord_list ) do
20154: LD_VAR 0 2
20158: IFFALSE 20269
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20160: LD_ADDR_EXP 43
20164: PUSH
20165: LD_EXP 43
20169: PPUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 1
20182: ARRAY
20183: PPUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: PUSH
20193: LD_VAR 0 2
20197: PUSH
20198: LD_INT 2
20200: ARRAY
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL 41960 0 4
20210: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_VAR 0 3
20220: PPUSH
20221: LD_INT 1
20223: PPUSH
20224: CALL_OW 3
20228: ST_TO_ADDR
// for i = 1 to 2 do
20229: LD_ADDR_VAR 0 5
20233: PUSH
20234: DOUBLE
20235: LD_INT 1
20237: DEC
20238: ST_TO_ADDR
20239: LD_INT 2
20241: PUSH
20242: FOR_TO
20243: IFFALSE 20265
// coord_list := Delete ( coord_list , 1 ) ;
20245: LD_ADDR_VAR 0 2
20249: PUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: LD_INT 1
20257: PPUSH
20258: CALL_OW 3
20262: ST_TO_ADDR
20263: GO 20242
20265: POP
20266: POP
// end ;
20267: GO 20154
// end ;
20269: LD_VAR 0 4
20273: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// while ( coord_list ) do
20278: LD_VAR 0 2
20282: IFFALSE 20437
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: PPUSH
20293: LD_VAR 0 2
20297: PUSH
20298: LD_INT 2
20300: ARRAY
20301: PPUSH
20302: CALL_OW 428
20306: IFFALSE 20397
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 2
20321: PUSH
20322: LD_INT 2
20324: ARRAY
20325: PPUSH
20326: CALL_OW 428
20330: PPUSH
20331: CALL_OW 266
20335: PUSH
20336: LD_INT 31
20338: PUSH
20339: LD_INT 32
20341: PUSH
20342: LD_INT 33
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: LIST
20349: IN
20350: IFFALSE 20397
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20352: LD_ADDR_EXP 52
20356: PUSH
20357: LD_EXP 52
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: LD_VAR 0 2
20371: PUSH
20372: LD_INT 1
20374: ARRAY
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 2
20383: ARRAY
20384: PPUSH
20385: CALL_OW 428
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL 41960 0 4
20396: ST_TO_ADDR
// for i = 1 to 3 do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_INT 3
20409: PUSH
20410: FOR_TO
20411: IFFALSE 20433
// coord_list := Delete ( coord_list , 1 ) ;
20413: LD_ADDR_VAR 0 2
20417: PUSH
20418: LD_VAR 0 2
20422: PPUSH
20423: LD_INT 1
20425: PPUSH
20426: CALL_OW 3
20430: ST_TO_ADDR
20431: GO 20410
20433: POP
20434: POP
// end ;
20435: GO 20278
// result := true ;
20437: LD_ADDR_VAR 0 3
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 3
20449: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20450: LD_INT 0
20452: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20453: LD_ADDR_EXP 46
20457: PUSH
20458: LD_EXP 46
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_INT 0
20470: PPUSH
20471: LD_VAR 0 2
20475: PPUSH
20476: CALL 41960 0 4
20480: ST_TO_ADDR
// end ;
20481: LD_VAR 0 3
20485: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20486: LD_INT 0
20488: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20489: LD_ADDR_EXP 46
20493: PUSH
20494: LD_EXP 46
20498: PPUSH
20499: LD_VAR 0 1
20503: PPUSH
20504: LD_INT 6
20506: PPUSH
20507: LD_VAR 0 2
20511: PPUSH
20512: CALL 41960 0 4
20516: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20517: LD_ADDR_EXP 49
20521: PUSH
20522: LD_EXP 49
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 3
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL 41960 0 4
20554: ST_TO_ADDR
// end ;
20555: LD_VAR 0 4
20559: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// if ext_list > 5 then
20564: LD_VAR 0 3
20568: PUSH
20569: LD_INT 5
20571: GREATER
20572: IFFALSE 20616
// for i = 6 to ext_list do
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: DOUBLE
20580: LD_INT 6
20582: DEC
20583: ST_TO_ADDR
20584: LD_VAR 0 3
20588: PUSH
20589: FOR_TO
20590: IFFALSE 20614
// ext_list := Delete ( ext_list , ext_list ) ;
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: CALL_OW 3
20611: ST_TO_ADDR
20612: GO 20589
20614: POP
20615: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 3
20652: PPUSH
20653: CALL 9163 0 5
// end ;
20657: LD_VAR 0 4
20661: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
// p := 1 ;
20667: LD_ADDR_VAR 0 6
20671: PUSH
20672: LD_INT 1
20674: ST_TO_ADDR
// if type_list = [ ] then
20675: LD_VAR 0 3
20679: PUSH
20680: EMPTY
20681: EQUAL
20682: IFFALSE 20692
// type_list := b_oil_power ;
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 26
20691: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20692: LD_ADDR_VAR 0 5
20696: PUSH
20697: DOUBLE
20698: LD_INT 1
20700: DEC
20701: ST_TO_ADDR
20702: LD_VAR 0 2
20706: PUSH
20707: LD_INT 3
20709: DIVREAL
20710: PUSH
20711: FOR_TO
20712: IFFALSE 20815
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20714: LD_ADDR_EXP 46
20718: PUSH
20719: LD_EXP 46
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_VAR 0 3
20733: PUSH
20734: LD_INT 1
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 12
20746: ARRAY
20747: PPUSH
20748: LD_VAR 0 2
20752: PUSH
20753: LD_VAR 0 6
20757: ARRAY
20758: PUSH
20759: LD_VAR 0 2
20763: PUSH
20764: LD_VAR 0 6
20768: PUSH
20769: LD_INT 1
20771: PLUS
20772: ARRAY
20773: PUSH
20774: LD_VAR 0 2
20778: PUSH
20779: LD_VAR 0 6
20783: PUSH
20784: LD_INT 2
20786: PLUS
20787: ARRAY
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 41960 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_VAR 0 6
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20711
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 4
20821: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
// if not MREG_Deposit [ side ] then
20828: LD_EXP 61
20832: PUSH
20833: LD_VAR 0 1
20837: ARRAY
20838: NOT
20839: IFFALSE 20843
// exit ;
20841: GO 21020
// p := 1 ;
20843: LD_ADDR_VAR 0 4
20847: PUSH
20848: LD_INT 1
20850: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20851: LD_ADDR_VAR 0 3
20855: PUSH
20856: DOUBLE
20857: LD_INT 1
20859: DEC
20860: ST_TO_ADDR
20861: LD_EXP 61
20865: PUSH
20866: LD_VAR 0 1
20870: ARRAY
20871: PUSH
20872: LD_INT 3
20874: DIVREAL
20875: PUSH
20876: FOR_TO
20877: IFFALSE 21018
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20879: LD_EXP 61
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: PUSH
20895: LD_INT 2
20897: PLUS
20898: ARRAY
20899: PUSH
20900: LD_INT 2
20902: EQUAL
20903: IFFALSE 20915
// b := b_oil_mine else
20905: LD_ADDR_VAR 0 5
20909: PUSH
20910: LD_INT 29
20912: ST_TO_ADDR
20913: GO 20923
// b := b_siberite_mine ;
20915: LD_ADDR_VAR 0 5
20919: PUSH
20920: LD_INT 30
20922: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: LD_EXP 61
20947: PUSH
20948: LD_VAR 0 1
20952: ARRAY
20953: PUSH
20954: LD_VAR 0 4
20958: ARRAY
20959: PUSH
20960: LD_EXP 61
20964: PUSH
20965: LD_VAR 0 1
20969: ARRAY
20970: PUSH
20971: LD_VAR 0 4
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: ARRAY
20980: PUSH
20981: LD_INT 0
20983: PPUSH
20984: LD_INT 5
20986: PPUSH
20987: CALL_OW 12
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL 41960 0 4
21001: ST_TO_ADDR
// p := p + 3 ;
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: LD_VAR 0 4
21011: PUSH
21012: LD_INT 3
21014: PLUS
21015: ST_TO_ADDR
// end ;
21016: GO 20876
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 2
21024: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21025: LD_INT 0
21027: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21028: LD_ADDR_EXP 46
21032: PUSH
21033: LD_EXP 46
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 4
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: CALL 41960 0 4
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21061: LD_INT 0
21063: PPUSH
// case nation of 1 , us :
21064: LD_VAR 0 2
21068: PUSH
21069: LD_INT 1
21071: DOUBLE
21072: EQUAL
21073: IFTRUE 21083
21075: LD_STRING us
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21114
21083: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21084: LD_ADDR_EXP 46
21088: PUSH
21089: LD_EXP 46
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: LD_INT 36
21101: PPUSH
21102: LD_VAR 0 3
21106: PPUSH
21107: CALL 41960 0 4
21111: ST_TO_ADDR
21112: GO 21165
21114: LD_INT 2
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21128
21120: LD_STRING ar
21122: DOUBLE
21123: EQUAL
21124: IFTRUE 21128
21126: GO 21164
21128: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21129: LD_ADDR_EXP 46
21133: PUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 14
21141: PUSH
21142: LD_INT 2
21144: PUSH
21145: LD_INT 1
21147: PUSH
21148: LD_INT 31
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL 21170 0 2
21161: ST_TO_ADDR
21162: GO 21165
21164: POP
// end ;
21165: LD_VAR 0 4
21169: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21170: LD_INT 0
21172: PPUSH
21173: PPUSH
// for i = 1 to list do
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: DOUBLE
21180: LD_INT 1
21182: DEC
21183: ST_TO_ADDR
21184: LD_VAR 0 2
21188: PUSH
21189: FOR_TO
21190: IFFALSE 21240
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21192: LD_ADDR_EXP 51
21196: PUSH
21197: LD_EXP 51
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_EXP 51
21211: PUSH
21212: LD_VAR 0 1
21216: ARRAY
21217: PUSH
21218: LD_INT 1
21220: PLUS
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_VAR 0 4
21231: ARRAY
21232: PPUSH
21233: CALL 31130 0 4
21237: ST_TO_ADDR
21238: GO 21189
21240: POP
21241: POP
// end ;
21242: LD_VAR 0 3
21246: RET
// export function MCS_GetVehicleList ( side ) ; begin
21247: LD_INT 0
21249: PPUSH
// result := MREG_ToConstruct [ side ] ;
21250: LD_ADDR_VAR 0 2
21254: PUSH
21255: LD_EXP 51
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: ST_TO_ADDR
// end ;
21266: LD_VAR 0 2
21270: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21271: LD_INT 0
21273: PPUSH
21274: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21275: LD_ADDR_EXP 58
21279: PUSH
21280: LD_EXP 58
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: LD_VAR 0 2
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// end ;
21300: LD_VAR 0 3
21304: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21305: LD_INT 0
21307: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21308: LD_ADDR_EXP 37
21312: PUSH
21313: LD_EXP 37
21317: PPUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// end ;
21333: LD_VAR 0 3
21337: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21338: LD_INT 0
21340: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21341: LD_ADDR_EXP 38
21345: PUSH
21346: LD_EXP 38
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 3
21370: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21374: LD_ADDR_EXP 60
21378: PUSH
21379: LD_EXP 60
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL 31130 0 4
21401: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21402: LD_ADDR_EXP 60
21406: PUSH
21407: LD_EXP 60
21411: PPUSH
21412: LD_VAR 0 1
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: LD_VAR 0 3
21424: PPUSH
21425: CALL 31130 0 4
21429: ST_TO_ADDR
// end ;
21430: LD_VAR 0 4
21434: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21435: LD_INT 0
21437: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21438: LD_ADDR_EXP 72
21442: PUSH
21443: LD_EXP 72
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21461: LD_ADDR_EXP 72
21465: PUSH
21466: LD_EXP 72
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: LD_VAR 0 2
21478: PPUSH
21479: CALL_OW 1
21483: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21484: LD_ADDR_EXP 72
21488: PUSH
21489: LD_EXP 72
21493: PPUSH
21494: LD_INT 3
21496: PPUSH
21497: LD_VAR 0 3
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// end ;
21507: LD_VAR 0 4
21511: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
// if not side or not list then
21517: LD_VAR 0 1
21521: NOT
21522: PUSH
21523: LD_VAR 0 2
21527: NOT
21528: OR
21529: IFFALSE 21533
// exit ;
21531: GO 21701
// SetTech ( 20 , side , state_researched ) ;
21533: LD_INT 20
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_INT 2
21543: PPUSH
21544: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21548: LD_ADDR_EXP 61
21552: PUSH
21553: LD_EXP 61
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: CALL_OW 2
21572: ST_TO_ADDR
// p := 1 ;
21573: LD_ADDR_VAR 0 5
21577: PUSH
21578: LD_INT 1
21580: ST_TO_ADDR
// for i = 1 to list / 3 do
21581: LD_ADDR_VAR 0 4
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_VAR 0 2
21595: PUSH
21596: LD_INT 3
21598: DIVREAL
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21699
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21603: LD_VAR 0 2
21607: PUSH
21608: LD_VAR 0 5
21612: ARRAY
21613: PPUSH
21614: LD_VAR 0 2
21618: PUSH
21619: LD_VAR 0 5
21623: PUSH
21624: LD_INT 1
21626: PLUS
21627: ARRAY
21628: PPUSH
21629: LD_VAR 0 2
21633: PUSH
21634: LD_VAR 0 5
21638: PUSH
21639: LD_INT 2
21641: PLUS
21642: ARRAY
21643: PPUSH
21644: CALL 22403 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21648: LD_VAR 0 2
21652: PUSH
21653: LD_VAR 0 5
21657: ARRAY
21658: PPUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 5
21668: PUSH
21669: LD_INT 1
21671: PLUS
21672: ARRAY
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL_OW 441
// p := p + 3 ;
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: PLUS
21696: ST_TO_ADDR
// end ;
21697: GO 21600
21699: POP
21700: POP
// end ;
21701: LD_VAR 0 3
21705: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
// if nat = nation_arabian then
21710: LD_VAR 0 2
21714: PUSH
21715: LD_INT 2
21717: EQUAL
21718: IFFALSE 21724
// exit else
21720: GO 21796
21722: GO 21782
// if nat = nation_american then
21724: LD_VAR 0 2
21728: PUSH
21729: LD_INT 1
21731: EQUAL
21732: IFFALSE 21759
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21734: LD_ADDR_VAR 0 4
21738: PUSH
21739: LD_INT 4
21741: PUSH
21742: LD_INT 3
21744: PUSH
21745: LD_INT 1
21747: PUSH
21748: LD_INT 8
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
21757: GO 21782
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21759: LD_ADDR_VAR 0 4
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 48
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21782: LD_VAR 0 1
21786: PPUSH
21787: LD_VAR 0 4
21791: PPUSH
21792: CALL 21170 0 2
// end ;
21796: LD_VAR 0 3
21800: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21801: LD_INT 0
21803: PPUSH
21804: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21805: LD_ADDR_EXP 63
21809: PUSH
21810: LD_EXP 63
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: LD_INT 1
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: CALL 31130 0 4
21832: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21833: LD_ADDR_EXP 64
21837: PUSH
21838: LD_EXP 64
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: LD_INT 1
21850: PPUSH
21851: LD_VAR 0 2
21855: PPUSH
21856: CALL 31130 0 4
21860: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21861: LD_ADDR_EXP 65
21865: PUSH
21866: LD_EXP 65
21870: PPUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_VAR 0 3
21883: PPUSH
21884: CALL 31130 0 4
21888: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21889: LD_ADDR_EXP 66
21893: PUSH
21894: LD_EXP 66
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_INT 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL 31130 0 4
21916: ST_TO_ADDR
// while squad do
21917: LD_VAR 0 5
21921: IFFALSE 22014
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_VAR 0 5
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PUSH
21937: LD_VAR 0 5
21941: PUSH
21942: LD_INT 2
21944: ARRAY
21945: PUSH
21946: LD_VAR 0 5
21950: PUSH
21951: LD_INT 3
21953: ARRAY
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: PPUSH
21970: CALL 21170 0 2
// for i = 1 to 4 do
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: DOUBLE
21980: LD_INT 1
21982: DEC
21983: ST_TO_ADDR
21984: LD_INT 4
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22010
// squad := Delete ( squad , 1 ) ;
21990: LD_ADDR_VAR 0 5
21994: PUSH
21995: LD_VAR 0 5
21999: PPUSH
22000: LD_INT 1
22002: PPUSH
22003: CALL_OW 3
22007: ST_TO_ADDR
22008: GO 21987
22010: POP
22011: POP
// end ;
22012: GO 21917
// end ;
22014: LD_VAR 0 6
22018: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22019: LD_INT 0
22021: PPUSH
22022: PPUSH
// for i = 1 to squad do
22023: LD_ADDR_VAR 0 4
22027: PUSH
22028: DOUBLE
22029: LD_INT 1
22031: DEC
22032: ST_TO_ADDR
22033: LD_VAR 0 2
22037: PUSH
22038: FOR_TO
22039: IFFALSE 22089
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22041: LD_ADDR_EXP 69
22045: PUSH
22046: LD_EXP 69
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_EXP 69
22060: PUSH
22061: LD_VAR 0 1
22065: ARRAY
22066: PUSH
22067: LD_INT 1
22069: PLUS
22070: PPUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 4
22080: ARRAY
22081: PPUSH
22082: CALL 31130 0 4
22086: ST_TO_ADDR
22087: GO 22038
22089: POP
22090: POP
// while squad do
22091: LD_VAR 0 2
22095: IFFALSE 22188
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22097: LD_VAR 0 1
22101: PPUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: PUSH
22111: LD_VAR 0 2
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PUSH
22120: LD_VAR 0 2
22124: PUSH
22125: LD_INT 3
22127: ARRAY
22128: PUSH
22129: LD_VAR 0 2
22133: PUSH
22134: LD_INT 4
22136: ARRAY
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL 21170 0 2
// for i = 1 to 4 do
22148: LD_ADDR_VAR 0 4
22152: PUSH
22153: DOUBLE
22154: LD_INT 1
22156: DEC
22157: ST_TO_ADDR
22158: LD_INT 4
22160: PUSH
22161: FOR_TO
22162: IFFALSE 22184
// squad := Delete ( squad , 1 ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_INT 1
22176: PPUSH
22177: CALL_OW 3
22181: ST_TO_ADDR
22182: GO 22161
22184: POP
22185: POP
// end ;
22186: GO 22091
// end ;
22188: LD_VAR 0 3
22192: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22193: LD_INT 0
22195: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22196: LD_ADDR_EXP 62
22200: PUSH
22201: LD_EXP 62
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 2
22218: PPUSH
22219: CALL 31130 0 4
22223: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22224: LD_ADDR_EXP 62
22228: PUSH
22229: LD_EXP 62
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: LD_VAR 0 3
22246: PPUSH
22247: CALL 31130 0 4
22251: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22252: LD_ADDR_EXP 62
22256: PUSH
22257: LD_EXP 62
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: LD_INT 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: CALL 31130 0 4
22279: ST_TO_ADDR
// end ; end_of_file
22280: LD_VAR 0 5
22284: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22285: LD_INT 0
22287: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22288: LD_ADDR_EXP 42
22292: PUSH
22293: LD_EXP 42
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_INT 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: CALL 31130 0 4
22315: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL 11786 0 2
22327: PUSH
22328: LD_INT 1
22330: ARRAY
22331: PPUSH
22332: CALL_OW 248
22336: PUSH
22337: LD_INT 1
22339: EQUAL
22340: IFFALSE 22371
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: PUSH
22356: LD_INT 14
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL 21170 0 2
22369: GO 22398
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 24
22378: PUSH
22379: LD_INT 1
22381: PUSH
22382: LD_INT 1
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: PPUSH
22394: CALL 21170 0 2
// end ;
22398: LD_VAR 0 3
22402: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22403: LD_INT 0
22405: PPUSH
// CreateDepositXY ( x , y , t ) ;
22406: LD_VAR 0 1
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: LD_VAR 0 3
22420: PPUSH
22421: CALL_OW 62
// end ;
22425: LD_VAR 0 4
22429: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22430: LD_INT 0
22432: PPUSH
22433: PPUSH
// c := 1 ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 1
22441: ST_TO_ADDR
// case color of red :
22442: LD_VAR 0 3
22446: PUSH
22447: LD_STRING red
22449: DOUBLE
22450: EQUAL
22451: IFTRUE 22455
22453: GO 22466
22455: POP
// c = 1 ; dark-green :
22456: LD_ADDR_VAR 0 5
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
22464: GO 22752
22466: LD_STRING dark-green
22468: DOUBLE
22469: EQUAL
22470: IFTRUE 22474
22472: GO 22485
22474: POP
// c = 2 ; purple :
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
22483: GO 22752
22485: LD_STRING purple
22487: DOUBLE
22488: EQUAL
22489: IFTRUE 22493
22491: GO 22504
22493: POP
// c = 3 ; aqua :
22494: LD_ADDR_VAR 0 5
22498: PUSH
22499: LD_INT 3
22501: ST_TO_ADDR
22502: GO 22752
22504: LD_STRING aqua
22506: DOUBLE
22507: EQUAL
22508: IFTRUE 22512
22510: GO 22523
22512: POP
// c = 4 ; grey :
22513: LD_ADDR_VAR 0 5
22517: PUSH
22518: LD_INT 4
22520: ST_TO_ADDR
22521: GO 22752
22523: LD_STRING grey
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22542
22531: POP
// c = 5 ; lime :
22532: LD_ADDR_VAR 0 5
22536: PUSH
22537: LD_INT 5
22539: ST_TO_ADDR
22540: GO 22752
22542: LD_STRING lime
22544: DOUBLE
22545: EQUAL
22546: IFTRUE 22550
22548: GO 22561
22550: POP
// c = 6 ; tan :
22551: LD_ADDR_VAR 0 5
22555: PUSH
22556: LD_INT 6
22558: ST_TO_ADDR
22559: GO 22752
22561: LD_STRING tan
22563: DOUBLE
22564: EQUAL
22565: IFTRUE 22569
22567: GO 22580
22569: POP
// c = 7 ; pink :
22570: LD_ADDR_VAR 0 5
22574: PUSH
22575: LD_INT 7
22577: ST_TO_ADDR
22578: GO 22752
22580: LD_STRING pink
22582: DOUBLE
22583: EQUAL
22584: IFTRUE 22588
22586: GO 22599
22588: POP
// c = 8 ; green :
22589: LD_ADDR_VAR 0 5
22593: PUSH
22594: LD_INT 8
22596: ST_TO_ADDR
22597: GO 22752
22599: LD_STRING green
22601: DOUBLE
22602: EQUAL
22603: IFTRUE 22607
22605: GO 22618
22607: POP
// c = 9 ; blue :
22608: LD_ADDR_VAR 0 5
22612: PUSH
22613: LD_INT 9
22615: ST_TO_ADDR
22616: GO 22752
22618: LD_STRING blue
22620: DOUBLE
22621: EQUAL
22622: IFTRUE 22626
22624: GO 22637
22626: POP
// c = 10 ; yellow :
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_INT 10
22634: ST_TO_ADDR
22635: GO 22752
22637: LD_STRING yellow
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22656
22645: POP
// c = 11 ; brown :
22646: LD_ADDR_VAR 0 5
22650: PUSH
22651: LD_INT 11
22653: ST_TO_ADDR
22654: GO 22752
22656: LD_STRING brown
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22675
22664: POP
// c = 12 ; black :
22665: LD_ADDR_VAR 0 5
22669: PUSH
22670: LD_INT 12
22672: ST_TO_ADDR
22673: GO 22752
22675: LD_STRING black
22677: DOUBLE
22678: EQUAL
22679: IFTRUE 22683
22681: GO 22694
22683: POP
// c = 13 ; aqua2 :
22684: LD_ADDR_VAR 0 5
22688: PUSH
22689: LD_INT 13
22691: ST_TO_ADDR
22692: GO 22752
22694: LD_STRING aqua2
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22713
22702: POP
// c = 14 ; orange :
22703: LD_ADDR_VAR 0 5
22707: PUSH
22708: LD_INT 14
22710: ST_TO_ADDR
22711: GO 22752
22713: LD_STRING orange
22715: DOUBLE
22716: EQUAL
22717: IFTRUE 22721
22719: GO 22732
22721: POP
// c = 15 ; white :
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 15
22729: ST_TO_ADDR
22730: GO 22752
22732: LD_STRING white
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22751
22740: POP
// c = 16 ; end ;
22741: LD_ADDR_VAR 0 5
22745: PUSH
22746: LD_INT 16
22748: ST_TO_ADDR
22749: GO 22752
22751: POP
// if HexInfo ( x , y ) = 0 then
22752: LD_VAR 0 1
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: CALL_OW 428
22766: PUSH
22767: LD_INT 0
22769: EQUAL
22770: IFFALSE 22794
// PlaceEnvironment ( x , y , 58 , c ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: LD_INT 58
22784: PPUSH
22785: LD_VAR 0 5
22789: PPUSH
22790: CALL_OW 349
// end ;
22794: LD_VAR 0 4
22798: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22799: LD_INT 0
22801: PPUSH
// RemoveEnvironment ( x , y ) ;
22802: LD_VAR 0 1
22806: PPUSH
22807: LD_VAR 0 2
22811: PPUSH
22812: CALL_OW 347
// end ;
22816: LD_VAR 0 3
22820: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22821: LD_INT 0
22823: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22824: LD_ADDR_VAR 0 5
22828: PUSH
22829: LD_INT 81
22831: PUSH
22832: LD_VAR 0 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 92
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: LD_VAR 0 3
22853: PUSH
22854: LD_VAR 0 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PPUSH
22869: CALL_OW 69
22873: ST_TO_ADDR
// end ;
22874: LD_VAR 0 5
22878: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22879: LD_INT 0
22881: PPUSH
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22886: LD_VAR 0 1
22890: PPUSH
22891: LD_INT 81
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 255
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PPUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 74
22922: PPUSH
22923: CALL_OW 119
// dir := GetDir ( un ) ;
22927: LD_ADDR_VAR 0 4
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: CALL_OW 254
22941: ST_TO_ADDR
// dir := dir - 3 ;
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: LD_VAR 0 4
22951: PUSH
22952: LD_INT 3
22954: MINUS
22955: ST_TO_ADDR
// if dir < 0 then
22956: LD_VAR 0 4
22960: PUSH
22961: LD_INT 0
22963: LESS
22964: IFFALSE 22980
// dir := dir + 6 ;
22966: LD_ADDR_VAR 0 4
22970: PUSH
22971: LD_VAR 0 4
22975: PUSH
22976: LD_INT 6
22978: PLUS
22979: ST_TO_ADDR
// while true do
22980: LD_INT 1
22982: IFFALSE 23479
// begin coord_dist := 3 ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 3
22991: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: LD_VAR 0 3
23016: PPUSH
23017: CALL_OW 272
23021: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23022: LD_ADDR_VAR 0 6
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 251
23036: PPUSH
23037: LD_VAR 0 4
23041: PPUSH
23042: LD_VAR 0 3
23046: PPUSH
23047: CALL_OW 273
23051: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23052: LD_VAR 0 1
23056: PPUSH
23057: CALL_OW 255
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: CALL_OW 250
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 251
23081: PPUSH
23082: LD_INT 14
23084: PPUSH
23085: CALL 22821 0 4
23089: PUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: LD_VAR 0 6
23099: PPUSH
23100: CALL_OW 351
23104: OR
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 488
23120: PUSH
23121: LD_INT 0
23123: EQUAL
23124: OR
23125: PUSH
23126: LD_VAR 0 5
23130: PPUSH
23131: LD_VAR 0 6
23135: PPUSH
23136: CALL_OW 546
23140: PUSH
23141: LD_INT 1
23143: EQUAL
23144: OR
23145: PUSH
23146: LD_VAR 0 5
23150: PPUSH
23151: LD_VAR 0 6
23155: PPUSH
23156: CALL_OW 428
23160: PUSH
23161: LD_INT 0
23163: NONEQUAL
23164: OR
23165: IFFALSE 23393
// begin repeat begin Wait ( 0 0$0.3 ) ;
23167: LD_INT 10
23169: PPUSH
23170: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: LD_VAR 0 3
23183: PUSH
23184: LD_INT 1
23186: PLUS
23187: ST_TO_ADDR
// dir := dir + 1 ;
23188: LD_ADDR_VAR 0 4
23192: PUSH
23193: LD_VAR 0 4
23197: PUSH
23198: LD_INT 1
23200: PLUS
23201: ST_TO_ADDR
// if dir > 5 then
23202: LD_VAR 0 4
23206: PUSH
23207: LD_INT 5
23209: GREATER
23210: IFFALSE 23220
// dir = 0 ;
23212: LD_ADDR_VAR 0 4
23216: PUSH
23217: LD_INT 0
23219: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23220: LD_ADDR_VAR 0 5
23224: PUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: CALL_OW 250
23234: PPUSH
23235: LD_VAR 0 4
23239: PPUSH
23240: LD_VAR 0 3
23244: PPUSH
23245: CALL_OW 272
23249: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23250: LD_ADDR_VAR 0 6
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 251
23264: PPUSH
23265: LD_VAR 0 4
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: CALL_OW 273
23279: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 255
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: CALL_OW 250
23299: PPUSH
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 251
23309: PPUSH
23310: LD_INT 14
23312: PPUSH
23313: CALL 22821 0 4
23317: NOT
23318: PUSH
23319: LD_VAR 0 5
23323: PPUSH
23324: LD_VAR 0 6
23328: PPUSH
23329: CALL_OW 351
23333: NOT
23334: AND
23335: PUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 488
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 546
23366: PUSH
23367: LD_INT 0
23369: EQUAL
23370: AND
23371: PUSH
23372: LD_VAR 0 5
23376: PPUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 428
23386: PUSH
23387: LD_INT 0
23389: EQUAL
23390: AND
23391: IFFALSE 23167
// end ; ComMoveXY ( un , x , y ) ;
23393: LD_VAR 0 1
23397: PPUSH
23398: LD_VAR 0 5
23402: PPUSH
23403: LD_VAR 0 6
23407: PPUSH
23408: CALL_OW 111
// Wait ( 0 0$1 ) ;
23412: LD_INT 35
23414: PPUSH
23415: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23419: LD_VAR 0 1
23423: PPUSH
23424: LD_INT 81
23426: PUSH
23427: LD_VAR 0 1
23431: PPUSH
23432: CALL_OW 255
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_VAR 0 1
23450: PPUSH
23451: CALL_OW 74
23455: PPUSH
23456: CALL_OW 296
23460: PUSH
23461: LD_INT 14
23463: GREATEREQUAL
23464: IFFALSE 23477
// begin ComStop ( un ) ;
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 141
// break ;
23475: GO 23479
// end ; end ;
23477: GO 22980
// end ;
23479: LD_VAR 0 2
23483: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// x := GetX ( unit ) ;
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 250
23508: ST_TO_ADDR
// y := GetY ( unit ) ;
23509: LD_ADDR_VAR 0 4
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 251
23523: ST_TO_ADDR
// i := 0 ;
23524: LD_ADDR_VAR 0 8
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 81
23539: PUSH
23540: LD_VAR 0 1
23544: PPUSH
23545: CALL_OW 255
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 69
23558: PPUSH
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 74
23568: PPUSH
23569: CALL_OW 119
// dir := GetDir ( unit ) ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: CALL_OW 254
23587: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23588: LD_ADDR_VAR 0 9
23592: PUSH
23593: LD_INT 0
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 12
23603: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23604: LD_INT 10
23606: PPUSH
23607: CALL_OW 67
// if mode then
23611: LD_VAR 0 9
23615: IFFALSE 23633
// dir := dir + 1 else
23617: LD_ADDR_VAR 0 7
23621: PUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_INT 1
23629: PLUS
23630: ST_TO_ADDR
23631: GO 23647
// dir := dir - 1 ;
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: MINUS
23646: ST_TO_ADDR
// if ( dir < 0 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 0
23654: LESS
23655: IFFALSE 23665
// dir := 5 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 5
23664: ST_TO_ADDR
// if ( dir > 5 ) then
23665: LD_VAR 0 7
23669: PUSH
23670: LD_INT 5
23672: GREATER
23673: IFFALSE 23683
// dir := 0 ;
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: LD_INT 0
23682: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23683: LD_ADDR_VAR 0 5
23687: PUSH
23688: LD_VAR 0 3
23692: PPUSH
23693: LD_VAR 0 7
23697: PPUSH
23698: LD_INT 4
23700: PPUSH
23701: CALL_OW 272
23705: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23706: LD_ADDR_VAR 0 6
23710: PUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: LD_VAR 0 7
23720: PPUSH
23721: LD_INT 4
23723: PPUSH
23724: CALL_OW 273
23728: ST_TO_ADDR
// i := i + 1 ;
23729: LD_ADDR_VAR 0 8
23733: PUSH
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 1
23741: PLUS
23742: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23743: LD_VAR 0 1
23747: PPUSH
23748: CALL_OW 255
23752: PPUSH
23753: LD_VAR 0 5
23757: PPUSH
23758: LD_VAR 0 6
23762: PPUSH
23763: LD_INT 14
23765: PPUSH
23766: CALL 22821 0 4
23770: PUSH
23771: LD_INT 0
23773: EQUAL
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_VAR 0 6
23784: PPUSH
23785: CALL_OW 546
23789: PUSH
23790: LD_INT 0
23792: EQUAL
23793: AND
23794: PUSH
23795: LD_VAR 0 5
23799: PPUSH
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 428
23809: PUSH
23810: LD_INT 0
23812: EQUAL
23813: AND
23814: IFFALSE 23818
// break ;
23816: GO 23828
// end until i > 4 ;
23818: LD_VAR 0 8
23822: PUSH
23823: LD_INT 4
23825: GREATER
23826: IFFALSE 23604
// if x2 and y2 then
23828: LD_VAR 0 5
23832: PUSH
23833: LD_VAR 0 6
23837: AND
23838: IFFALSE 23861
// result := [ x2 , y2 ] else
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 5
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: ST_TO_ADDR
23859: GO 23890
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 250
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: CALL_OW 251
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// end ;
23890: LD_VAR 0 2
23894: RET
// export function MCT_Hex ( x , y ) ; begin
23895: LD_INT 0
23897: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL_OW 546
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 428
23932: PUSH
23933: EMPTY
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 3
23944: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23960: LD_ADDR_VAR 0 10
23964: PUSH
23965: LD_EXP 60
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PUSH
23976: LD_INT 1
23978: ARRAY
23979: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: LD_EXP 60
23989: PUSH
23990: LD_VAR 0 1
23994: ARRAY
23995: PUSH
23996: LD_INT 2
23998: ARRAY
23999: ST_TO_ADDR
// collectors := [ ] ;
24000: LD_ADDR_VAR 0 12
24004: PUSH
24005: EMPTY
24006: ST_TO_ADDR
// is_cargo := false ;
24007: LD_ADDR_VAR 0 13
24011: PUSH
24012: LD_INT 0
24014: ST_TO_ADDR
// if isTest then
24015: LD_EXP 1
24019: IFFALSE 24025
// TimerStart ( ) ;
24021: CALL_OW 548
// if MCF_Cargo ( side ) then
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL 12002 0 1
24034: IFFALSE 24061
// begin collectors := MCF_Cargo ( side ) ;
24036: LD_ADDR_VAR 0 12
24040: PUSH
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12002 0 1
24050: ST_TO_ADDR
// is_cargo := true ;
24051: LD_ADDR_VAR 0 13
24055: PUSH
24056: LD_INT 1
24058: ST_TO_ADDR
// end else
24059: GO 24210
// begin if MCF_ApeSpec ( side , engineer ) then
24061: LD_VAR 0 1
24065: PPUSH
24066: LD_STRING engineer
24068: PPUSH
24069: CALL 12148 0 2
24073: IFFALSE 24093
// collectors := MCF_ApeSpec ( side , engineer ) ;
24075: LD_ADDR_VAR 0 12
24079: PUSH
24080: LD_VAR 0 1
24084: PPUSH
24085: LD_STRING engineer
24087: PPUSH
24088: CALL 12148 0 2
24092: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24093: LD_VAR 0 1
24097: PPUSH
24098: LD_INT 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL 11734 0 3
24107: IFFALSE 24210
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL 11734 0 3
24128: ST_TO_ADDR
// if z > 5 then
24129: LD_VAR 0 7
24133: PUSH
24134: LD_INT 5
24136: GREATER
24137: IFFALSE 24149
// t1 := 5 else
24139: LD_ADDR_VAR 0 8
24143: PUSH
24144: LD_INT 5
24146: ST_TO_ADDR
24147: GO 24159
// t1 := z ;
24149: LD_ADDR_VAR 0 8
24153: PUSH
24154: LD_VAR 0 7
24158: ST_TO_ADDR
// for t2 = 1 to t1 do
24159: LD_ADDR_VAR 0 9
24163: PUSH
24164: DOUBLE
24165: LD_INT 1
24167: DEC
24168: ST_TO_ADDR
24169: LD_VAR 0 8
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24208
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24177: LD_ADDR_VAR 0 12
24181: PUSH
24182: LD_VAR 0 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: LD_VAR 0 7
24194: PUSH
24195: LD_VAR 0 9
24199: ARRAY
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
24206: GO 24174
24208: POP
24209: POP
// end ; end ; if not mode then
24210: LD_VAR 0 10
24214: NOT
24215: IFFALSE 24221
// exit else
24217: GO 24480
24219: GO 24480
// begin if collectors then
24221: LD_VAR 0 12
24225: IFFALSE 24480
// for i in areas do
24227: LD_ADDR_VAR 0 3
24231: PUSH
24232: LD_VAR 0 11
24236: PUSH
24237: FOR_IN
24238: IFFALSE 24478
// if GetListOfCratesInArea ( i ) then
24240: LD_VAR 0 3
24244: PPUSH
24245: CALL_OW 435
24249: IFFALSE 24476
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24251: LD_ADDR_VAR 0 5
24255: PUSH
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24270: LD_ADDR_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: PPUSH
24280: CALL_OW 435
24284: PUSH
24285: LD_INT 2
24287: ARRAY
24288: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24289: LD_VAR 0 13
24293: PUSH
24294: LD_VAR 0 12
24298: PUSH
24299: LD_INT 1
24301: ARRAY
24302: PPUSH
24303: CALL_OW 110
24307: PUSH
24308: LD_INT 0
24310: EQUAL
24311: AND
24312: IFFALSE 24374
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24314: LD_VAR 0 12
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 314
24327: NOT
24328: PUSH
24329: LD_VAR 0 12
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: CALL_OW 110
24342: PUSH
24343: LD_INT 0
24345: EQUAL
24346: AND
24347: IFFALSE 24372
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24349: LD_VAR 0 12
24353: PUSH
24354: LD_INT 1
24356: ARRAY
24357: PPUSH
24358: LD_VAR 0 5
24362: PPUSH
24363: LD_VAR 0 6
24367: PPUSH
24368: CALL_OW 117
// end ; end else
24372: GO 24460
// begin for j = 1 to collectors do
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: DOUBLE
24380: LD_INT 1
24382: DEC
24383: ST_TO_ADDR
24384: LD_VAR 0 12
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24458
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24392: LD_VAR 0 12
24396: PUSH
24397: LD_VAR 0 4
24401: ARRAY
24402: PPUSH
24403: CALL_OW 314
24407: NOT
24408: PUSH
24409: LD_VAR 0 12
24413: PUSH
24414: LD_VAR 0 4
24418: ARRAY
24419: PPUSH
24420: CALL_OW 110
24424: PUSH
24425: LD_INT 0
24427: EQUAL
24428: AND
24429: IFFALSE 24456
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24431: LD_VAR 0 12
24435: PUSH
24436: LD_VAR 0 4
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 5
24446: PPUSH
24447: LD_VAR 0 6
24451: PPUSH
24452: CALL 24851 0 3
// end ;
24456: GO 24389
24458: POP
24459: POP
// end ; if isTest then
24460: LD_EXP 1
24464: IFFALSE 24476
// begin debug_time := TimerEnd ( ) ;
24466: LD_ADDR_VAR 0 14
24470: PUSH
24471: CALL_OW 549
24475: ST_TO_ADDR
// end ; end ;
24476: GO 24237
24478: POP
24479: POP
// end ; end ;
24480: LD_VAR 0 2
24484: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24485: LD_INT 0
24487: PPUSH
24488: PPUSH
24489: PPUSH
24490: PPUSH
24491: PPUSH
24492: PPUSH
// if not area then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24504
// exit else
24500: GO 24766
24502: GO 24766
// if tick mod interval = 0 and Prob ( percent ) then
24504: LD_OWVAR 1
24508: PUSH
24509: LD_VAR 0 4
24513: MOD
24514: PUSH
24515: LD_INT 0
24517: EQUAL
24518: PUSH
24519: LD_VAR 0 3
24523: PPUSH
24524: CALL_OW 13
24528: AND
24529: IFFALSE 24766
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24531: LD_VAR 0 1
24535: PPUSH
24536: CALL_OW 435
24540: PUSH
24541: LD_VAR 0 5
24545: LESS
24546: PUSH
24547: LD_VAR 0 5
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: OR
24556: IFFALSE 24766
// begin Randomize ;
24558: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24562: LD_ADDR_VAR 0 7
24566: PUSH
24567: LD_INT 1
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 12
24579: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24580: LD_ADDR_VAR 0 9
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 517
24597: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24598: LD_ADDR_VAR 0 8
24602: PUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PUSH
24611: LD_INT 1
24613: ARRAY
24614: PPUSH
24615: CALL_OW 12
24619: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24620: LD_VAR 0 9
24624: PUSH
24625: LD_INT 1
24627: ARRAY
24628: PUSH
24629: LD_VAR 0 8
24633: ARRAY
24634: PPUSH
24635: LD_VAR 0 9
24639: PUSH
24640: LD_INT 2
24642: ARRAY
24643: PUSH
24644: LD_VAR 0 8
24648: ARRAY
24649: PPUSH
24650: CALL_OW 428
24654: PUSH
24655: LD_INT 0
24657: GREATER
24658: PUSH
24659: LD_VAR 0 9
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PUSH
24668: LD_VAR 0 8
24672: ARRAY
24673: PPUSH
24674: LD_VAR 0 9
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PUSH
24683: LD_VAR 0 8
24687: ARRAY
24688: PPUSH
24689: CALL_OW 284
24693: PUSH
24694: LD_INT 0
24696: GREATER
24697: AND
24698: IFFALSE 24724
// c := Rand ( 1 , tmp [ 1 ] ) ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 1
24707: PPUSH
24708: LD_VAR 0 9
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: CALL_OW 12
24721: ST_TO_ADDR
24722: GO 24620
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24724: LD_VAR 0 7
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PUSH
24738: LD_VAR 0 8
24742: ARRAY
24743: PPUSH
24744: LD_VAR 0 9
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PUSH
24753: LD_VAR 0 8
24757: ARRAY
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 54
// end ; end ; end ;
24766: LD_VAR 0 6
24770: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24771: LD_INT 0
24773: PPUSH
24774: PPUSH
// if not MREG_Crates then
24775: LD_EXP 34
24779: NOT
24780: IFFALSE 24784
// exit ;
24782: GO 24846
// for i = MREG_Crates downto 1 do
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: DOUBLE
24790: LD_EXP 34
24794: INC
24795: ST_TO_ADDR
24796: LD_INT 1
24798: PUSH
24799: FOR_DOWNTO
24800: IFFALSE 24844
// if MREG_Crates [ i ] [ 3 ] = 0 then
24802: LD_EXP 34
24806: PUSH
24807: LD_VAR 0 2
24811: ARRAY
24812: PUSH
24813: LD_INT 3
24815: ARRAY
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24842
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24822: LD_ADDR_EXP 34
24826: PUSH
24827: LD_EXP 34
24831: PPUSH
24832: LD_VAR 0 2
24836: PPUSH
24837: CALL_OW 3
24841: ST_TO_ADDR
24842: GO 24799
24844: POP
24845: POP
// end ;
24846: LD_VAR 0 1
24850: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not unit then
24857: LD_VAR 0 1
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25001
// if HasTask ( unit ) or not CanCarry ( unit ) then
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 314
24875: PUSH
24876: LD_VAR 0 1
24880: PPUSH
24881: CALL_OW 280
24885: NOT
24886: OR
24887: IFFALSE 24891
// exit ;
24889: GO 25001
// side := GetSide ( unit ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: CALL_OW 255
24905: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24906: LD_ADDR_VAR 0 7
24910: PUSH
24911: LD_VAR 0 6
24915: PPUSH
24916: LD_INT 30
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PPUSH
24926: CALL 11651 0 2
24930: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24931: LD_VAR 0 1
24935: PPUSH
24936: CALL_OW 281
24940: PUSH
24941: LD_VAR 0 7
24945: NOT
24946: OR
24947: IFFALSE 24953
// exit else
24949: GO 25001
24951: GO 25001
// if GetResourceAmountXY ( x , y ) then
24953: LD_VAR 0 2
24957: PPUSH
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 284
24967: IFFALSE 24999
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_VAR 0 2
24978: PPUSH
24979: LD_VAR 0 3
24983: PPUSH
24984: LD_VAR 0 7
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: CALL 32061 0 4
// end else
24997: GO 25001
// exit ;
24999: GO 25001
// end ;
25001: LD_VAR 0 4
25005: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25006: LD_INT 0
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
// result := [ ] ;
25013: LD_ADDR_VAR 0 2
25017: PUSH
25018: EMPTY
25019: ST_TO_ADDR
// p := 1 ;
25020: LD_ADDR_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_EXP 63
25042: PUSH
25043: LD_VAR 0 1
25047: ARRAY
25048: PUSH
25049: LD_INT 1
25051: ARRAY
25052: PUSH
25053: LD_INT 2
25055: DIVREAL
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25182
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25060: LD_ADDR_VAR 0 5
25064: PUSH
25065: LD_INT 81
25067: PUSH
25068: LD_VAR 0 1
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 92
25079: PUSH
25080: LD_EXP 63
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PUSH
25095: LD_VAR 0 4
25099: ARRAY
25100: PUSH
25101: LD_EXP 63
25105: PUSH
25106: LD_VAR 0 1
25110: ARRAY
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_INT 1
25123: PLUS
25124: ARRAY
25125: PUSH
25126: LD_INT 12
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: ST_TO_ADDR
// if tmp then
25144: LD_VAR 0 5
25148: IFFALSE 25166
// result := result union tmp ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_VAR 0 5
25164: UNION
25165: ST_TO_ADDR
// p := p + 2 ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 2
25178: PLUS
25179: ST_TO_ADDR
// end ;
25180: GO 25057
25182: POP
25183: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25184: LD_EXP 64
25188: PUSH
25189: LD_VAR 0 1
25193: ARRAY
25194: PPUSH
25195: LD_INT 81
25197: PUSH
25198: LD_VAR 0 1
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PPUSH
25207: CALL_OW 70
25211: IFFALSE 25252
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25213: LD_ADDR_VAR 0 2
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_EXP 64
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_INT 81
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PPUSH
25246: CALL_OW 70
25250: UNION
25251: ST_TO_ADDR
// end ; end_of_file
25252: LD_VAR 0 2
25256: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
// pom := GetBase ( fac ) ;
25262: LD_ADDR_VAR 0 5
25266: PUSH
25267: LD_VAR 0 1
25271: PPUSH
25272: CALL_OW 274
25276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25277: LD_ADDR_VAR 0 4
25281: PUSH
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: LD_VAR 0 2
25295: PUSH
25296: LD_INT 2
25298: ARRAY
25299: PPUSH
25300: LD_VAR 0 2
25304: PUSH
25305: LD_INT 3
25307: ARRAY
25308: PPUSH
25309: LD_VAR 0 2
25313: PUSH
25314: LD_INT 4
25316: ARRAY
25317: PPUSH
25318: CALL_OW 449
25322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25323: LD_ADDR_VAR 0 3
25327: PUSH
25328: LD_VAR 0 5
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: CALL_OW 275
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: GREATEREQUAL
25350: PUSH
25351: LD_VAR 0 5
25355: PPUSH
25356: LD_INT 2
25358: PPUSH
25359: CALL_OW 275
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_INT 2
25371: ARRAY
25372: GREATEREQUAL
25373: AND
25374: PUSH
25375: LD_VAR 0 5
25379: PPUSH
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 275
25387: PUSH
25388: LD_VAR 0 4
25392: PUSH
25393: LD_INT 3
25395: ARRAY
25396: GREATEREQUAL
25397: AND
25398: ST_TO_ADDR
// end ;
25399: LD_VAR 0 3
25403: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25404: LD_INT 0
25406: PPUSH
25407: PPUSH
25408: PPUSH
// result := false ;
25409: LD_ADDR_VAR 0 3
25413: PUSH
25414: LD_INT 0
25416: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25417: LD_ADDR_VAR 0 4
25421: PUSH
25422: LD_EXP 51
25426: PUSH
25427: LD_VAR 0 1
25431: ARRAY
25432: ST_TO_ADDR
// if tmp then
25433: LD_VAR 0 4
25437: IFFALSE 25491
// for i = 1 to tmp do
25439: LD_ADDR_VAR 0 5
25443: PUSH
25444: DOUBLE
25445: LD_INT 1
25447: DEC
25448: ST_TO_ADDR
25449: LD_VAR 0 4
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25489
// if component = tmp [ i ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 4
25466: PUSH
25467: LD_VAR 0 5
25471: ARRAY
25472: EQUAL
25473: IFFALSE 25487
// begin result := true ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_INT 1
25482: ST_TO_ADDR
// exit ;
25483: POP
25484: POP
25485: GO 25491
// end ;
25487: GO 25454
25489: POP
25490: POP
// end ;
25491: LD_VAR 0 3
25495: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25496: LD_INT 0
25498: PPUSH
25499: PPUSH
25500: PPUSH
// result := false ;
25501: LD_ADDR_VAR 0 4
25505: PUSH
25506: LD_INT 0
25508: ST_TO_ADDR
// if fac then
25509: LD_VAR 0 2
25513: IFFALSE 25736
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25515: LD_VAR 0 2
25519: PPUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL 25257 0 2
25529: PUSH
25530: LD_VAR 0 2
25534: PPUSH
25535: CALL_OW 461
25539: PUSH
25540: LD_INT 2
25542: EQUAL
25543: AND
25544: PUSH
25545: LD_VAR 0 2
25549: PPUSH
25550: LD_VAR 0 3
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 3
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: LD_VAR 0 3
25572: PUSH
25573: LD_INT 3
25575: ARRAY
25576: PPUSH
25577: LD_VAR 0 3
25581: PUSH
25582: LD_INT 4
25584: ARRAY
25585: PPUSH
25586: CALL_OW 448
25590: AND
25591: IFFALSE 25736
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25593: LD_VAR 0 2
25597: PPUSH
25598: LD_VAR 0 3
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 3
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_INT 3
25623: ARRAY
25624: PPUSH
25625: LD_VAR 0 3
25629: PUSH
25630: LD_INT 4
25632: ARRAY
25633: PPUSH
25634: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_EXP 51
25647: PUSH
25648: LD_VAR 0 1
25652: ARRAY
25653: ST_TO_ADDR
// for i = 4 downto 1 do
25654: LD_ADDR_VAR 0 5
25658: PUSH
25659: DOUBLE
25660: LD_INT 4
25662: INC
25663: ST_TO_ADDR
25664: LD_INT 1
25666: PUSH
25667: FOR_DOWNTO
25668: IFFALSE 25701
// tab := Remove ( tab , list [ i ] , true ) ;
25670: LD_ADDR_VAR 0 6
25674: PUSH
25675: LD_VAR 0 6
25679: PPUSH
25680: LD_VAR 0 3
25684: PUSH
25685: LD_VAR 0 5
25689: ARRAY
25690: PPUSH
25691: LD_INT 1
25693: PPUSH
25694: CALL 31289 0 3
25698: ST_TO_ADDR
25699: GO 25667
25701: POP
25702: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25703: LD_ADDR_EXP 51
25707: PUSH
25708: LD_EXP 51
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_VAR 0 6
25722: PPUSH
25723: CALL_OW 1
25727: ST_TO_ADDR
// result := true ;
25728: LD_ADDR_VAR 0 4
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// end ; end ; end ;
25736: LD_VAR 0 4
25740: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25741: LD_INT 0
25743: PPUSH
25744: PPUSH
// if not veh then
25745: LD_VAR 0 2
25749: NOT
25750: IFFALSE 25754
// exit ;
25752: GO 25928
// if MREG_Parking [ side ] then
25754: LD_EXP 58
25758: PUSH
25759: LD_VAR 0 1
25763: ARRAY
25764: IFFALSE 25928
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25766: LD_VAR 0 2
25770: PPUSH
25771: LD_EXP 58
25775: PUSH
25776: LD_VAR 0 1
25780: ARRAY
25781: PPUSH
25782: CALL_OW 308
25786: NOT
25787: IFFALSE 25928
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_EXP 58
25798: PUSH
25799: LD_VAR 0 1
25803: ARRAY
25804: PPUSH
25805: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25809: LD_VAR 0 2
25813: PPUSH
25814: CALL_OW 263
25818: PUSH
25819: LD_INT 1
25821: EQUAL
25822: IFFALSE 25928
// begin i := GetDriver ( veh ) ;
25824: LD_ADDR_VAR 0 4
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: CALL 31773 0 1
25838: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25846: LD_VAR 0 2
25850: PPUSH
25851: LD_EXP 58
25855: PUSH
25856: LD_VAR 0 1
25860: ARRAY
25861: PPUSH
25862: CALL_OW 308
25866: PUSH
25867: LD_VAR 0 2
25871: PPUSH
25872: CALL_OW 301
25876: OR
25877: IFFALSE 25839
// ComExitVehicle ( i ) ;
25879: LD_VAR 0 4
25883: PPUSH
25884: CALL_OW 121
// Wait ( 1 ) ;
25888: LD_INT 1
25890: PPUSH
25891: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL 11651 0 2
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PPUSH
25924: CALL_OW 180
// end ; end ; end ;
25928: LD_VAR 0 3
25932: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
25937: PPUSH
25938: PPUSH
25939: PPUSH
25940: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25941: LD_VAR 0 1
25945: PPUSH
25946: LD_INT 30
25948: PUSH
25949: LD_INT 3
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL 11651 0 2
25960: IFFALSE 26144
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25962: LD_VAR 0 1
25966: PPUSH
25967: LD_INT 30
25969: PUSH
25970: LD_INT 3
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL 11651 0 2
25981: PUSH
25982: LD_INT 1
25984: ARRAY
25985: PPUSH
25986: CALL_OW 461
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 26144
// begin for i = 1 to MREG_TurretWeapon do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_EXP 43
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26142
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26014: LD_EXP 43
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 1
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 1
26033: EQUAL
26034: IFFALSE 26140
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_EXP 43
26045: PUSH
26046: LD_VAR 0 3
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26056: LD_ADDR_VAR 0 6
26060: PUSH
26061: LD_EXP 43
26065: PUSH
26066: LD_VAR 0 3
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26080: LD_ADDR_VAR 0 7
26084: PUSH
26085: LD_EXP 43
26089: PUSH
26090: LD_VAR 0 3
26094: ARRAY
26095: PUSH
26096: LD_INT 3
26098: ARRAY
26099: PUSH
26100: LD_INT 2
26102: ARRAY
26103: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26104: LD_ADDR_VAR 0 4
26108: PUSH
26109: LD_VAR 0 6
26113: PPUSH
26114: LD_VAR 0 7
26118: PPUSH
26119: CALL_OW 428
26123: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26124: LD_VAR 0 4
26128: PPUSH
26129: LD_VAR 0 5
26133: PPUSH
26134: CALL_OW 148
// break ;
26138: GO 26142
// end ;
26140: GO 26011
26142: POP
26143: POP
// end ; end ;
26144: LD_VAR 0 2
26148: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26149: LD_INT 0
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_INT 32
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL 11651 0 2
26179: ST_TO_ADDR
// if not tmp then
26180: LD_VAR 0 4
26184: NOT
26185: IFFALSE 26191
// exit else
26187: GO 26273
26189: GO 26273
// begin for i = 1 to tmp do
26191: LD_ADDR_VAR 0 3
26195: PUSH
26196: DOUBLE
26197: LD_INT 1
26199: DEC
26200: ST_TO_ADDR
26201: LD_VAR 0 4
26205: PUSH
26206: FOR_TO
26207: IFFALSE 26271
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26209: LD_VAR 0 4
26213: PUSH
26214: LD_VAR 0 3
26218: ARRAY
26219: PPUSH
26220: CALL_OW 261
26224: PUSH
26225: LD_INT 20
26227: LESS
26228: PUSH
26229: LD_VAR 0 4
26233: PUSH
26234: LD_VAR 0 3
26238: ARRAY
26239: PPUSH
26240: CALL_OW 110
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: AND
26249: IFFALSE 26269
// begin SetTag ( tmp [ i ] , 21 ) ;
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 3
26260: ARRAY
26261: PPUSH
26262: LD_INT 21
26264: PPUSH
26265: CALL_OW 109
// end ;
26269: GO 26206
26271: POP
26272: POP
// end ; end ;
26273: LD_VAR 0 2
26277: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26278: LD_INT 0
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
26284: PPUSH
// if not unit then
26285: LD_VAR 0 1
26289: NOT
26290: IFFALSE 26294
// exit ;
26292: GO 26482
// side := GetSide ( unit ) ;
26294: LD_ADDR_VAR 0 3
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 255
26308: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26309: LD_ADDR_VAR 0 5
26313: PUSH
26314: LD_VAR 0 3
26318: PPUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 3
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 30
26344: PUSH
26345: LD_INT 29
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL 11651 0 2
26362: ST_TO_ADDR
// if not b then
26363: LD_VAR 0 5
26367: NOT
26368: IFFALSE 26372
// exit ;
26370: GO 26482
// if GetTag ( unit ) = 21 then
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 110
26381: PUSH
26382: LD_INT 21
26384: EQUAL
26385: IFFALSE 26482
// begin c := NearestUnitToUnit ( b , unit ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_VAR 0 5
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 74
26406: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26407: LD_VAR 0 1
26411: PPUSH
26412: LD_VAR 0 6
26416: PPUSH
26417: CALL_OW 250
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: CALL_OW 251
26431: PPUSH
26432: CALL_OW 297
26436: PUSH
26437: LD_INT 6
26439: GREATER
26440: IFFALSE 26458
// ComMoveUnit ( unit , c ) else
26442: LD_VAR 0 1
26446: PPUSH
26447: LD_VAR 0 6
26451: PPUSH
26452: CALL_OW 112
26456: GO 26482
// begin SetFuel ( unit , 100 ) ;
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_INT 100
26465: PPUSH
26466: CALL_OW 240
// SetTag ( unit , 0 ) ;
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 0
26477: PPUSH
26478: CALL_OW 109
// end ; end ; end ;
26482: LD_VAR 0 2
26486: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26487: LD_INT 0
26489: PPUSH
26490: PPUSH
26491: PPUSH
26492: PPUSH
26493: PPUSH
26494: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26495: LD_ADDR_VAR 0 7
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 33
26507: PUSH
26508: LD_INT 2
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 61
26520: PUSH
26521: EMPTY
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PPUSH
26532: CALL 11651 0 2
26536: ST_TO_ADDR
// if not vehs then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26831
// if nation = 1 then
26546: LD_VAR 0 2
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26724
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26556: LD_VAR 0 1
26560: PPUSH
26561: LD_INT 30
26563: PUSH
26564: LD_INT 36
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PPUSH
26571: CALL 11651 0 2
26575: NOT
26576: IFFALSE 26582
// exit else
26578: GO 26831
26580: GO 26722
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26582: LD_ADDR_VAR 0 5
26586: PUSH
26587: LD_VAR 0 1
26591: PPUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 36
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PPUSH
26602: CALL 11651 0 2
26606: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26607: LD_ADDR_VAR 0 6
26611: PUSH
26612: LD_VAR 0 5
26616: PUSH
26617: LD_INT 1
26619: ARRAY
26620: PPUSH
26621: CALL_OW 313
26625: ST_TO_ADDR
// for i = vehs downto 1 do
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: DOUBLE
26632: LD_VAR 0 7
26636: INC
26637: ST_TO_ADDR
26638: LD_INT 1
26640: PUSH
26641: FOR_DOWNTO
26642: IFFALSE 26720
// begin if not IsControledBy ( vehs [ i ] ) then
26644: LD_VAR 0 7
26648: PUSH
26649: LD_VAR 0 4
26653: ARRAY
26654: PPUSH
26655: CALL_OW 312
26659: NOT
26660: IFFALSE 26718
// begin tmp := MCV_RemoteDriver ( oper ) ;
26662: LD_ADDR_VAR 0 8
26666: PUSH
26667: LD_VAR 0 6
26671: PPUSH
26672: CALL 26836 0 1
26676: ST_TO_ADDR
// if not tmp then
26677: LD_VAR 0 8
26681: NOT
26682: IFFALSE 26690
// exit else
26684: POP
26685: POP
26686: GO 26831
26688: GO 26718
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26690: LD_VAR 0 7
26694: PUSH
26695: LD_VAR 0 4
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: CALL_OW 135
// end ; end ;
26718: GO 26641
26720: POP
26721: POP
// end ; end else
26722: GO 26831
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_INT 34
26731: PUSH
26732: LD_INT 31
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL 11651 0 2
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 26831
26748: GO 26831
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 1
26759: PPUSH
26760: LD_INT 34
26762: PUSH
26763: LD_INT 31
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PPUSH
26770: CALL 11651 0 2
26774: ST_TO_ADDR
// oper := [ ] ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: EMPTY
26781: ST_TO_ADDR
// for i = 1 to ct do
26782: LD_ADDR_VAR 0 4
26786: PUSH
26787: DOUBLE
26788: LD_INT 1
26790: DEC
26791: ST_TO_ADDR
26792: LD_VAR 0 5
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26829
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26800: LD_ADDR_VAR 0 6
26804: PUSH
26805: LD_VAR 0 6
26809: PUSH
26810: LD_VAR 0 5
26814: PUSH
26815: LD_VAR 0 4
26819: ARRAY
26820: PPUSH
26821: CALL 31773 0 1
26825: ADD
26826: ST_TO_ADDR
26827: GO 26797
26829: POP
26830: POP
// end ; end ; end ;
26831: LD_VAR 0 3
26835: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
// if not drivers then
26844: LD_VAR 0 1
26848: NOT
26849: IFFALSE 26855
// exit else
26851: GO 27135
26853: GO 27135
// begin linked := [ ] ;
26855: LD_ADDR_VAR 0 5
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// for i = 1 to drivers do
26862: LD_ADDR_VAR 0 3
26866: PUSH
26867: DOUBLE
26868: LD_INT 1
26870: DEC
26871: ST_TO_ADDR
26872: LD_VAR 0 1
26876: PUSH
26877: FOR_TO
26878: IFFALSE 27123
// begin if CanControl ( drivers [ i ] ) then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_VAR 0 3
26889: ARRAY
26890: PPUSH
26891: CALL 32163 0 1
26895: IFFALSE 27121
// if i > 1 then
26897: LD_VAR 0 3
26901: PUSH
26902: LD_INT 1
26904: GREATER
26905: IFFALSE 27082
// begin m := false ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26915: LD_ADDR_VAR 0 7
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_VAR 0 3
26929: ARRAY
26930: PPUSH
26931: CALL_OW 432
26935: ST_TO_ADDR
// for j = 1 to linked do
26936: LD_ADDR_VAR 0 4
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_VAR 0 5
26950: PUSH
26951: FOR_TO
26952: IFFALSE 27026
// begin if l < linked [ j ] [ 2 ] then
26954: LD_VAR 0 7
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: LD_VAR 0 4
26968: ARRAY
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: LESS
26974: IFFALSE 27024
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: LD_VAR 0 1
26993: PUSH
26994: LD_VAR 0 3
26998: ARRAY
26999: PUSH
27000: LD_VAR 0 7
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 2
27013: ST_TO_ADDR
// m := true ;
27014: LD_ADDR_VAR 0 6
27018: PUSH
27019: LD_INT 1
27021: ST_TO_ADDR
// break ;
27022: GO 27026
// end ; end ;
27024: GO 26951
27026: POP
27027: POP
// if not m then
27028: LD_VAR 0 6
27032: NOT
27033: IFFALSE 27080
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27035: LD_ADDR_VAR 0 5
27039: PUSH
27040: LD_VAR 0 5
27044: PUSH
27045: LD_VAR 0 1
27049: PUSH
27050: LD_VAR 0 3
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: ARRAY
27066: PPUSH
27067: CALL_OW 432
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: EMPTY
27077: LIST
27078: ADD
27079: ST_TO_ADDR
// end else
27080: GO 27121
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27082: LD_ADDR_VAR 0 5
27086: PUSH
27087: LD_VAR 0 1
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: PUSH
27098: LD_VAR 0 1
27102: PUSH
27103: LD_VAR 0 3
27107: ARRAY
27108: PPUSH
27109: CALL_OW 432
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: ST_TO_ADDR
// end ;
27121: GO 26877
27123: POP
27124: POP
// result := linked ;
27125: LD_ADDR_VAR 0 2
27129: PUSH
27130: LD_VAR 0 5
27134: ST_TO_ADDR
// end ; end ;
27135: LD_VAR 0 2
27139: RET
// export function MCV_ToRepair ( unit ) ; begin
27140: LD_INT 0
27142: PPUSH
// if not unit then
27143: LD_VAR 0 1
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27183
// SetTag ( unit , 6 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 6
27159: PPUSH
27160: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27164: LD_VAR 0 1
27168: PPUSH
27169: CALL_OW 255
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL 25741 0 2
// end ;
27183: LD_VAR 0 2
27187: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27192: LD_VAR 0 1
27196: PPUSH
27197: LD_INT 6
27199: PPUSH
27200: EMPTY
27201: PPUSH
27202: CALL 12354 0 3
27206: IFFALSE 27299
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: DOUBLE
27214: LD_VAR 0 1
27218: PPUSH
27219: LD_INT 6
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 12354 0 3
27228: INC
27229: ST_TO_ADDR
27230: LD_INT 1
27232: PUSH
27233: FOR_DOWNTO
27234: IFFALSE 27297
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27236: LD_VAR 0 1
27240: PPUSH
27241: LD_INT 6
27243: PPUSH
27244: EMPTY
27245: PPUSH
27246: CALL 12354 0 3
27250: PUSH
27251: LD_VAR 0 3
27255: ARRAY
27256: PPUSH
27257: CALL_OW 256
27261: PUSH
27262: LD_INT 1000
27264: EQUAL
27265: IFFALSE 27295
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 6
27274: PPUSH
27275: EMPTY
27276: PPUSH
27277: CALL 12354 0 3
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 0
27290: PPUSH
27291: CALL_OW 109
27295: GO 27233
27297: POP
27298: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27299: LD_VAR 0 1
27303: PPUSH
27304: LD_INT 10
27306: PPUSH
27307: EMPTY
27308: PPUSH
27309: CALL 12354 0 3
27313: IFFALSE 27430
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: DOUBLE
27321: LD_VAR 0 1
27325: PPUSH
27326: LD_INT 10
27328: PPUSH
27329: EMPTY
27330: PPUSH
27331: CALL 12354 0 3
27335: INC
27336: ST_TO_ADDR
27337: LD_INT 1
27339: PUSH
27340: FOR_DOWNTO
27341: IFFALSE 27428
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27343: LD_VAR 0 1
27347: PPUSH
27348: LD_INT 10
27350: PPUSH
27351: EMPTY
27352: PPUSH
27353: CALL 12354 0 3
27357: PUSH
27358: LD_VAR 0 3
27362: ARRAY
27363: PPUSH
27364: CALL_OW 302
27368: NOT
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: LD_INT 10
27377: PPUSH
27378: EMPTY
27379: PPUSH
27380: CALL 12354 0 3
27384: PUSH
27385: LD_VAR 0 3
27389: ARRAY
27390: PPUSH
27391: CALL_OW 301
27395: OR
27396: IFFALSE 27426
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27398: LD_VAR 0 1
27402: PPUSH
27403: LD_INT 10
27405: PPUSH
27406: EMPTY
27407: PPUSH
27408: CALL 12354 0 3
27412: PUSH
27413: LD_VAR 0 3
27417: ARRAY
27418: PPUSH
27419: LD_INT 0
27421: PPUSH
27422: CALL_OW 109
27426: GO 27340
27428: POP
27429: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27430: LD_ADDR_VAR 0 3
27434: PUSH
27435: LD_VAR 0 1
27439: PPUSH
27440: EMPTY
27441: PPUSH
27442: CALL 11952 0 2
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 7
27454: PPUSH
27455: EMPTY
27456: PPUSH
27457: CALL 12354 0 3
27461: DIFF
27462: PUSH
27463: FOR_IN
27464: IFFALSE 27508
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27466: LD_VAR 0 3
27470: PPUSH
27471: CALL_OW 256
27475: PUSH
27476: LD_INT 650
27478: LESS
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 110
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: NOT
27494: AND
27495: IFFALSE 27506
// MCV_ToRepair ( i ) ;
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL 27140 0 1
27506: GO 27463
27508: POP
27509: POP
// end ; end_of_file end_of_file
27510: LD_VAR 0 2
27514: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27515: LD_STRING SAILEvent [
27517: PUSH
27518: LD_VAR 0 1
27522: STR
27523: PUSH
27524: LD_STRING ]
27526: STR
27527: PPUSH
27528: CALL 8039 0 1
// if event = 101 and dialog_north then
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 101
27539: EQUAL
27540: PUSH
27541: LD_EXP 6
27545: AND
27546: IFFALSE 27610
// begin dialog_north := false ;
27548: LD_ADDR_EXP 6
27552: PUSH
27553: LD_INT 0
27555: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27556: LD_EXP 5
27560: PPUSH
27561: LD_STRING DS1
27563: PUSH
27564: LD_STRING DS2
27566: PUSH
27567: LD_STRING DS3
27569: PUSH
27570: LD_STRING DS6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PPUSH
27582: LD_INT 4
27584: PPUSH
27585: CALL_OW 12
27589: ARRAY
27590: PPUSH
27591: CALL_OW 94
// Wait ( 4 4$00 ) ;
27595: LD_INT 8400
27597: PPUSH
27598: CALL_OW 67
// dialog_north := true ;
27602: LD_ADDR_EXP 6
27606: PUSH
27607: LD_INT 1
27609: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27610: LD_VAR 0 1
27614: PUSH
27615: LD_INT 102
27617: EQUAL
27618: PUSH
27619: LD_EXP 7
27623: AND
27624: IFFALSE 27684
// begin dialog_south := false ;
27626: LD_ADDR_EXP 7
27630: PUSH
27631: LD_INT 0
27633: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27634: LD_EXP 4
27638: PPUSH
27639: LD_STRING DJ1
27641: PUSH
27642: LD_STRING DJ4
27644: PUSH
27645: LD_STRING DJ6
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PPUSH
27656: LD_INT 3
27658: PPUSH
27659: CALL_OW 12
27663: ARRAY
27664: PPUSH
27665: CALL_OW 94
// Wait ( 4 4$00 ) ;
27669: LD_INT 8400
27671: PPUSH
27672: CALL_OW 67
// dialog_south := true ;
27676: LD_ADDR_EXP 7
27680: PUSH
27681: LD_INT 1
27683: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27684: LD_VAR 0 1
27688: PUSH
27689: LD_INT 104
27691: EQUAL
27692: PUSH
27693: LD_EXP 8
27697: AND
27698: IFFALSE 27720
// begin dialog_popov := false ;
27700: LD_ADDR_EXP 8
27704: PUSH
27705: LD_INT 0
27707: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27708: LD_EXP 24
27712: PPUSH
27713: LD_STRING DR4
27715: PPUSH
27716: CALL_OW 94
// end ; end ;
27720: PPOPN 1
27722: END
// on BuildingStarted ( b , unit ) do var side , i ;
27723: LD_INT 0
27725: PPUSH
27726: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27727: LD_EXP 39
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ARRAY
27742: IFFALSE 27920
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27744: LD_STRING BuildingStarted [side: 
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: CALL_OW 255
27756: STR
27757: PUSH
27758: LD_STRING ; btype: 
27760: STR
27761: PUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 266
27771: STR
27772: PUSH
27773: LD_STRING ; unit: 
27775: STR
27776: PUSH
27777: LD_VAR 0 2
27781: STR
27782: PUSH
27783: LD_STRING ]
27785: STR
27786: PPUSH
27787: CALL 8039 0 1
// side := GetSide ( b ) ;
27791: LD_ADDR_VAR 0 3
27795: PUSH
27796: LD_VAR 0 1
27800: PPUSH
27801: CALL_OW 255
27805: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 21
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PPUSH
27821: CALL 11651 0 2
27825: PUSH
27826: LD_INT 1
27828: EQUAL
27829: IFFALSE 27920
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27831: LD_ADDR_VAR 0 4
27835: PUSH
27836: LD_VAR 0 3
27840: PPUSH
27841: LD_INT 21
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PPUSH
27851: CALL 11651 0 2
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: EMPTY
27865: PPUSH
27866: CALL 11734 0 3
27870: DIFF
27871: PUSH
27872: FOR_IN
27873: IFFALSE 27918
// if not HasTask ( i ) then
27875: LD_VAR 0 4
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: IFFALSE 27916
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27887: LD_VAR 0 4
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 250
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 251
27911: PPUSH
27912: CALL_OW 111
27916: GO 27872
27918: POP
27919: POP
// end ;
27920: PPOPN 4
27922: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27923: LD_EXP 39
27927: PUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 255
27937: ARRAY
27938: IFFALSE 28307
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27940: LD_STRING BuildingComplete [side: 
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 255
27952: STR
27953: PUSH
27954: LD_STRING ; btype: 
27956: STR
27957: PUSH
27958: LD_VAR 0 1
27962: PPUSH
27963: CALL_OW 266
27967: STR
27968: PUSH
27969: LD_STRING ]
27971: STR
27972: PPUSH
27973: CALL 8039 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27977: LD_ADDR_EXP 46
27981: PUSH
27982: LD_EXP 46
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 255
27996: PPUSH
27997: LD_VAR 0 1
28001: PPUSH
28002: CALL_OW 266
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 250
28016: PUSH
28017: LD_VAR 0 1
28021: PPUSH
28022: CALL_OW 251
28026: PUSH
28027: LD_VAR 0 1
28031: PPUSH
28032: CALL_OW 254
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL 42051 0 4
28046: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 266
28056: PUSH
28057: LD_INT 6
28059: EQUAL
28060: IFFALSE 28094
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28062: LD_ADDR_EXP 40
28066: PUSH
28067: LD_EXP 40
28071: PPUSH
28072: LD_VAR 0 1
28076: PPUSH
28077: CALL_OW 255
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: EMPTY
28088: PPUSH
28089: CALL 41960 0 4
28093: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 266
28103: PUSH
28104: LD_INT 0
28106: EQUAL
28107: IFFALSE 28217
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28109: LD_ADDR_EXP 48
28113: PUSH
28114: LD_EXP 48
28118: PPUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 255
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: EMPTY
28133: PPUSH
28134: CALL 41960 0 4
28138: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 274
28148: PPUSH
28149: LD_INT 1
28151: PPUSH
28152: LD_EXP 72
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: CALL_OW 274
28174: PPUSH
28175: LD_INT 2
28177: PPUSH
28178: LD_EXP 72
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28191: LD_VAR 0 1
28195: PPUSH
28196: CALL_OW 274
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 72
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PPUSH
28213: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 266
28226: PUSH
28227: LD_INT 2
28229: EQUAL
28230: IFFALSE 28262
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28232: LD_ADDR_EXP 48
28236: PUSH
28237: LD_EXP 48
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: CALL_OW 255
28251: PPUSH
28252: LD_INT 2
28254: PPUSH
28255: EMPTY
28256: PPUSH
28257: CALL 41960 0 4
28261: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 4
28274: EQUAL
28275: IFFALSE 28307
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28277: LD_ADDR_EXP 48
28281: PUSH
28282: LD_EXP 48
28286: PPUSH
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_INT 4
28299: PPUSH
28300: EMPTY
28301: PPUSH
28302: CALL 41960 0 4
28306: ST_TO_ADDR
// end ;
28307: PPOPN 1
28309: END
// on ResearchComplete ( tech , lab ) do var i ;
28310: LD_INT 0
28312: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28313: LD_EXP 39
28317: PUSH
28318: LD_VAR 0 2
28322: PPUSH
28323: CALL_OW 255
28327: ARRAY
28328: IFFALSE 28612
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28330: LD_STRING ResearchComplete [side: 
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: CALL_OW 255
28347: STR
28348: PUSH
28349: LD_STRING ; tech:
28351: STR
28352: PUSH
28353: LD_VAR 0 1
28357: STR
28358: PUSH
28359: LD_STRING ]
28361: STR
28362: PPUSH
28363: CALL 8039 0 1
// for i = 1 to MREG_ToRes do
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: DOUBLE
28373: LD_INT 1
28375: DEC
28376: ST_TO_ADDR
28377: LD_EXP 50
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28470
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28385: LD_EXP 50
28389: PUSH
28390: LD_VAR 0 3
28394: ARRAY
28395: PUSH
28396: LD_INT 1
28398: ARRAY
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: EQUAL
28410: PUSH
28411: LD_EXP 50
28415: PUSH
28416: LD_VAR 0 3
28420: ARRAY
28421: PUSH
28422: LD_INT 2
28424: ARRAY
28425: PUSH
28426: LD_VAR 0 1
28430: EQUAL
28431: AND
28432: IFFALSE 28468
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28434: LD_ADDR_EXP 50
28438: PUSH
28439: LD_EXP 50
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: PPUSH
28454: LD_VAR 0 1
28458: PPUSH
28459: EMPTY
28460: PPUSH
28461: CALL 42051 0 4
28465: ST_TO_ADDR
// break ;
28466: GO 28470
// end ;
28468: GO 28382
28470: POP
28471: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28472: LD_VAR 0 1
28476: PUSH
28477: LD_INT 2
28479: PUSH
28480: LD_INT 11
28482: PUSH
28483: LD_INT 4
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: IN
28495: IFFALSE 28612
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28497: LD_ADDR_VAR 0 3
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: CALL_OW 255
28511: PPUSH
28512: LD_INT 16
28514: PPUSH
28515: LD_INT 25
28517: PUSH
28518: LD_INT 4
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL 12354 0 3
28529: ST_TO_ADDR
// if i then
28530: LD_VAR 0 3
28534: IFFALSE 28552
// SetTag ( i [ 1 ] , 0 ) ;
28536: LD_VAR 0 3
28540: PUSH
28541: LD_INT 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 0
28547: PPUSH
28548: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28552: LD_ADDR_VAR 0 3
28556: PUSH
28557: LD_VAR 0 2
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: LD_INT 171
28569: PPUSH
28570: EMPTY
28571: PPUSH
28572: CALL 12354 0 3
28576: ST_TO_ADDR
// if i then
28577: LD_VAR 0 3
28581: IFFALSE 28612
// begin SetTag ( i [ 1 ] , 0 ) ;
28583: LD_VAR 0 3
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_INT 0
28594: PPUSH
28595: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: CALL_OW 122
// end ; end ; end ;
28612: PPOPN 3
28614: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28615: LD_INT 0
28617: PPUSH
28618: PPUSH
28619: PPUSH
28620: PPUSH
28621: PPUSH
28622: PPUSH
28623: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28624: LD_VAR 0 1
28628: PPUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: CALL 59186 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28638: LD_EXP 39
28642: PUSH
28643: LD_VAR 0 2
28647: PPUSH
28648: CALL_OW 255
28652: ARRAY
28653: IFFALSE 29380
// begin side := GetSide ( veh ) ;
28655: LD_ADDR_VAR 0 4
28659: PUSH
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 255
28669: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 265
28684: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28685: LD_ADDR_VAR 0 7
28689: PUSH
28690: LD_VAR 0 1
28694: PPUSH
28695: CALL_OW 262
28699: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28700: LD_ADDR_VAR 0 8
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 263
28714: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 1
28724: PPUSH
28725: CALL_OW 264
28729: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28730: LD_STRING VehicleConstructed [side: 
28732: PUSH
28733: LD_VAR 0 4
28737: STR
28738: PUSH
28739: LD_STRING ; id:
28741: STR
28742: PUSH
28743: LD_VAR 0 1
28747: STR
28748: PUSH
28749: LD_STRING ; components: [
28751: STR
28752: PUSH
28753: LD_VAR 0 6
28757: STR
28758: PUSH
28759: LD_STRING , 
28761: STR
28762: PUSH
28763: LD_VAR 0 7
28767: STR
28768: PUSH
28769: LD_STRING , 
28771: STR
28772: PUSH
28773: LD_VAR 0 8
28777: STR
28778: PUSH
28779: LD_STRING , 
28781: STR
28782: PUSH
28783: LD_VAR 0 9
28787: STR
28788: PUSH
28789: LD_STRING ]]
28791: STR
28792: PPUSH
28793: CALL 8039 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_INT 13
28809: PUSH
28810: LD_INT 12
28812: PUSH
28813: LD_INT 14
28815: PUSH
28816: LD_INT 51
28818: PUSH
28819: LD_INT 53
28821: PUSH
28822: LD_INT 52
28824: PUSH
28825: LD_INT 32
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: IN
28837: NOT
28838: IFFALSE 28880
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28840: LD_ADDR_EXP 59
28844: PUSH
28845: LD_EXP 59
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: LD_EXP 59
28859: PUSH
28860: LD_VAR 0 4
28864: ARRAY
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 1
28874: PPUSH
28875: CALL 31130 0 4
28879: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 264
28889: PUSH
28890: LD_INT 31
28892: EQUAL
28893: IFFALSE 28912
// SetTag ( GetDriver ( veh ) , 9 ) ;
28895: LD_VAR 0 1
28899: PPUSH
28900: CALL 31773 0 1
28904: PPUSH
28905: LD_INT 9
28907: PPUSH
28908: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28912: LD_VAR 0 1
28916: PPUSH
28917: CALL_OW 264
28921: PUSH
28922: LD_INT 14
28924: PUSH
28925: LD_INT 53
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: IN
28932: IFFALSE 28969
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28934: LD_ADDR_EXP 42
28938: PUSH
28939: LD_EXP 42
28943: PPUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 255
28953: PPUSH
28954: LD_INT 2
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: CALL 31130 0 4
28966: ST_TO_ADDR
// exit ;
28967: GO 29380
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28969: LD_VAR 0 1
28973: PPUSH
28974: CALL_OW 265
28978: PUSH
28979: LD_EXP 66
28983: PUSH
28984: LD_VAR 0 4
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IN
28994: PUSH
28995: LD_VAR 0 1
28999: PPUSH
29000: CALL_OW 262
29004: PUSH
29005: LD_EXP 66
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: IN
29020: AND
29021: PUSH
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 263
29031: PUSH
29032: LD_EXP 66
29036: PUSH
29037: LD_VAR 0 4
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: IN
29047: AND
29048: PUSH
29049: LD_VAR 0 1
29053: PPUSH
29054: CALL_OW 264
29058: PUSH
29059: LD_EXP 66
29063: PUSH
29064: LD_VAR 0 4
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: IN
29074: AND
29075: IFFALSE 29119
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29077: LD_ADDR_EXP 67
29081: PUSH
29082: LD_EXP 67
29086: PPUSH
29087: LD_VAR 0 4
29091: PPUSH
29092: LD_EXP 67
29096: PUSH
29097: LD_VAR 0 4
29101: ARRAY
29102: PUSH
29103: LD_INT 1
29105: PLUS
29106: PPUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL 31130 0 4
29116: ST_TO_ADDR
// exit ;
29117: GO 29380
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29119: LD_VAR 0 6
29123: PUSH
29124: LD_EXP 69
29128: PUSH
29129: LD_VAR 0 4
29133: ARRAY
29134: PUSH
29135: LD_INT 1
29137: ARRAY
29138: EQUAL
29139: PUSH
29140: LD_VAR 0 7
29144: PUSH
29145: LD_EXP 69
29149: PUSH
29150: LD_VAR 0 4
29154: ARRAY
29155: PUSH
29156: LD_INT 2
29158: ARRAY
29159: EQUAL
29160: AND
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_EXP 69
29171: PUSH
29172: LD_VAR 0 4
29176: ARRAY
29177: PUSH
29178: LD_INT 3
29180: ARRAY
29181: EQUAL
29182: AND
29183: PUSH
29184: LD_VAR 0 9
29188: PUSH
29189: LD_EXP 69
29193: PUSH
29194: LD_VAR 0 4
29198: ARRAY
29199: PUSH
29200: LD_INT 4
29202: ARRAY
29203: EQUAL
29204: AND
29205: IFFALSE 29361
// begin tmp := MREG_ToAttack [ side ] ;
29207: LD_ADDR_VAR 0 5
29211: PUSH
29212: LD_EXP 69
29216: PUSH
29217: LD_VAR 0 4
29221: ARRAY
29222: ST_TO_ADDR
// for i = 1 to 4 do
29223: LD_ADDR_VAR 0 3
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_INT 4
29235: PUSH
29236: FOR_TO
29237: IFFALSE 29259
// tmp := Delete ( tmp , 1 ) ;
29239: LD_ADDR_VAR 0 5
29243: PUSH
29244: LD_VAR 0 5
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 3
29256: ST_TO_ADDR
29257: GO 29236
29259: POP
29260: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29261: LD_ADDR_EXP 69
29265: PUSH
29266: LD_EXP 69
29270: PPUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_VAR 0 5
29280: PPUSH
29281: CALL_OW 1
29285: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29286: LD_ADDR_EXP 71
29290: PUSH
29291: LD_EXP 71
29295: PPUSH
29296: LD_VAR 0 4
29300: PPUSH
29301: LD_EXP 71
29305: PUSH
29306: LD_VAR 0 4
29310: ARRAY
29311: PUSH
29312: LD_INT 1
29314: PLUS
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL 31130 0 4
29325: ST_TO_ADDR
// if tmp = 0 then
29326: LD_VAR 0 5
29330: PUSH
29331: LD_INT 0
29333: EQUAL
29334: IFFALSE 29359
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29336: LD_ADDR_EXP 69
29340: PUSH
29341: LD_EXP 69
29345: PPUSH
29346: LD_VAR 0 4
29350: PPUSH
29351: LD_INT 0
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// exit ;
29359: GO 29380
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29361: LD_VAR 0 1
29365: PPUSH
29366: CALL_OW 255
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL 25741 0 2
// end ; end ;
29380: PPOPN 9
29382: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29383: LD_EXP 39
29387: PUSH
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 255
29397: ARRAY
29398: IFFALSE 29630
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29400: LD_STRING ApemanTamed [side: 
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: STR
29413: PUSH
29414: LD_STRING ; sci: 
29416: STR
29417: PUSH
29418: LD_VAR 0 2
29422: STR
29423: PUSH
29424: LD_STRING ; ape: 
29426: STR
29427: PUSH
29428: LD_VAR 0 1
29432: STR
29433: PUSH
29434: LD_STRING ]
29436: STR
29437: PPUSH
29438: CALL 8039 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29442: LD_INT 11
29444: PPUSH
29445: LD_VAR 0 2
29449: PPUSH
29450: CALL_OW 255
29454: PPUSH
29455: CALL_OW 321
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: NOT
29464: PUSH
29465: LD_INT 2
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: CALL_OW 255
29477: PPUSH
29478: CALL_OW 321
29482: PUSH
29483: LD_INT 2
29485: EQUAL
29486: NOT
29487: OR
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: CALL_OW 255
29498: PPUSH
29499: LD_INT 171
29501: PPUSH
29502: EMPTY
29503: PPUSH
29504: CALL 12354 0 3
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: AND
29513: IFFALSE 29527
// begin SetTag ( ape , 171 ) ;
29515: LD_VAR 0 1
29519: PPUSH
29520: LD_INT 171
29522: PPUSH
29523: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29527: LD_VAR 0 2
29531: PPUSH
29532: CALL_OW 255
29536: PPUSH
29537: LD_INT 30
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL 11651 0 2
29551: IFFALSE 29630
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29553: LD_VAR 0 1
29557: PPUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: CALL_OW 255
29567: PPUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL 11651 0 2
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: CALL_OW 250
29591: PPUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 255
29601: PPUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL 11651 0 2
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: CALL_OW 251
29625: PPUSH
29626: CALL_OW 111
// end ;
29630: PPOPN 2
29632: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29633: LD_EXP 39
29637: PUSH
29638: LD_VAR 0 1
29642: PPUSH
29643: CALL_OW 255
29647: ARRAY
29648: IFFALSE 29926
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29650: LD_VAR 0 2
29654: PUSH
29655: LD_VAR 0 2
29659: PPUSH
29660: CALL_OW 255
29664: PPUSH
29665: CALL 12064 0 1
29669: IN
29670: IFFALSE 29811
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29672: LD_VAR 0 1
29676: PPUSH
29677: CALL_OW 266
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: IFFALSE 29722
// begin Wait ( 0 0$0.3 ) ;
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 16
29708: PPUSH
29709: CALL_OW 336
// ComExitBuilding ( un ) ;
29713: LD_VAR 0 2
29717: PPUSH
29718: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 266
29731: PUSH
29732: LD_INT 4
29734: PUSH
29735: LD_INT 5
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: IN
29742: IFFALSE 29811
// begin Wait ( 0 0$0.3 ) ;
29744: LD_INT 10
29746: PPUSH
29747: CALL_OW 67
// if GetTag ( un ) = 0 then
29751: LD_VAR 0 2
29755: PPUSH
29756: CALL_OW 110
29760: PUSH
29761: LD_INT 0
29763: EQUAL
29764: IFFALSE 29780
// SetClass ( un , class_apeman_soldier ) else
29766: LD_VAR 0 2
29770: PPUSH
29771: LD_INT 15
29773: PPUSH
29774: CALL_OW 336
29778: GO 29811
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29780: LD_INT 3
29782: PPUSH
29783: LD_VAR 0 2
29787: PPUSH
29788: CALL_OW 255
29792: PPUSH
29793: CALL_OW 321
29797: IFFALSE 29811
// SetClass ( un , class_apeman_kamikaze ) ;
29799: LD_VAR 0 2
29803: PPUSH
29804: LD_INT 17
29806: PPUSH
29807: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 266
29820: PUSH
29821: LD_INT 32
29823: EQUAL
29824: IFFALSE 29926
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29826: LD_ADDR_EXP 68
29830: PUSH
29831: LD_EXP 68
29835: PPUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: CALL_OW 255
29845: PPUSH
29846: LD_EXP 68
29850: PUSH
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL_OW 255
29860: ARRAY
29861: PUSH
29862: LD_INT 1
29864: PLUS
29865: PPUSH
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL 31130 0 4
29875: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29876: LD_ADDR_EXP 68
29880: PUSH
29881: LD_EXP 68
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 255
29895: PPUSH
29896: LD_EXP 68
29900: PUSH
29901: LD_VAR 0 1
29905: PPUSH
29906: CALL_OW 255
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: PLUS
29915: PPUSH
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL 31130 0 4
29925: ST_TO_ADDR
// end ; end ;
29926: PPOPN 2
29928: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL 59066 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29938: LD_VAR 0 1
29942: PUSH
29943: LD_INT 22
29945: PUSH
29946: LD_INT 3
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 23
29955: PUSH
29956: LD_INT 3
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 21
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: PPUSH
29978: CALL_OW 69
29982: IN
29983: IFFALSE 29999
// player_loss := player_loss + 1 ;
29985: LD_ADDR_EXP 10
29989: PUSH
29990: LD_EXP 10
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 22
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 21
30016: PUSH
30017: LD_INT 3
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 69
30032: IN
30033: PUSH
30034: LD_EXP 14
30038: NOT
30039: AND
30040: IFFALSE 30103
// begin alfa_north_triggered := true ;
30042: LD_ADDR_EXP 14
30046: PUSH
30047: LD_INT 1
30049: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30050: LD_EXP 5
30054: PPUSH
30055: LD_STRING DS4
30057: PPUSH
30058: CALL_OW 94
// Wait ( 1 1$25 ) ;
30062: LD_INT 2975
30064: PPUSH
30065: CALL_OW 67
// if not isTest then
30069: LD_EXP 1
30073: NOT
30074: IFFALSE 30103
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30076: LD_INT 20
30078: PPUSH
30079: LD_INT 5
30081: PUSH
30082: LD_INT 6
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PUSH
30093: LD_OWVAR 67
30097: ARRAY
30098: PPUSH
30099: CALL 7058 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30103: LD_VAR 0 1
30107: PUSH
30108: LD_INT 22
30110: PUSH
30111: LD_INT 4
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 21
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PPUSH
30132: CALL_OW 69
30136: IN
30137: PUSH
30138: LD_EXP 15
30142: NOT
30143: AND
30144: IFFALSE 30207
// begin alfa_south_triggered := true ;
30146: LD_ADDR_EXP 15
30150: PUSH
30151: LD_INT 1
30153: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30154: LD_EXP 4
30158: PPUSH
30159: LD_STRING DJ3
30161: PPUSH
30162: CALL_OW 94
// Wait ( 0 0$45 ) ;
30166: LD_INT 1575
30168: PPUSH
30169: CALL_OW 67
// if not isTest then
30173: LD_EXP 1
30177: NOT
30178: IFFALSE 30207
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30180: LD_INT 20
30182: PPUSH
30183: LD_INT 5
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: LD_INT 7
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: LIST
30196: PUSH
30197: LD_OWVAR 67
30201: ARRAY
30202: PPUSH
30203: CALL 7058 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 266
30216: PUSH
30217: LD_INT 1
30219: EQUAL
30220: PUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 255
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 4
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: IN
30241: AND
30242: IFFALSE 30251
// RaiseSailEvent ( 104 ) ;
30244: LD_INT 104
30246: PPUSH
30247: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30251: LD_EXP 39
30255: PUSH
30256: LD_VAR 0 1
30260: PPUSH
30261: CALL_OW 255
30265: ARRAY
30266: IFFALSE 30653
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30268: LD_STRING UnitDestroyed [side 
30270: PUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL_OW 255
30280: STR
30281: PUSH
30282: LD_STRING ; id: 
30284: STR
30285: PUSH
30286: LD_VAR 0 1
30290: STR
30291: PUSH
30292: LD_STRING ; type: 
30294: STR
30295: PUSH
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 247
30305: STR
30306: PUSH
30307: LD_STRING ]
30309: STR
30310: PPUSH
30311: CALL 8039 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: CALL_OW 255
30329: PPUSH
30330: LD_INT 21
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL 11651 0 2
30344: IN
30345: IFFALSE 30501
// begin if MCF_HasClass ( un ) then
30347: LD_VAR 0 1
30351: PPUSH
30352: CALL 14357 0 1
30356: IFFALSE 30501
// case MCF_HasClass ( un ) of 1 :
30358: LD_VAR 0 1
30362: PPUSH
30363: CALL 14357 0 1
30367: PUSH
30368: LD_INT 1
30370: DOUBLE
30371: EQUAL
30372: IFTRUE 30376
30374: GO 30401
30376: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 255
30386: PPUSH
30387: LD_STRING ToArm
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL 14530 0 3
30399: GO 30501
30401: LD_INT 2
30403: DOUBLE
30404: EQUAL
30405: IFTRUE 30409
30407: GO 30434
30409: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30410: LD_VAR 0 1
30414: PPUSH
30415: CALL_OW 255
30419: PPUSH
30420: LD_STRING ToDep
30422: PPUSH
30423: LD_VAR 0 1
30427: PPUSH
30428: CALL 14530 0 3
30432: GO 30501
30434: LD_INT 3
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30467
30442: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30443: LD_VAR 0 1
30447: PPUSH
30448: CALL_OW 255
30452: PPUSH
30453: LD_STRING ToFac
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: CALL 14530 0 3
30465: GO 30501
30467: LD_INT 4
30469: DOUBLE
30470: EQUAL
30471: IFTRUE 30475
30473: GO 30500
30475: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30476: LD_VAR 0 1
30480: PPUSH
30481: CALL_OW 255
30485: PPUSH
30486: LD_STRING ToLab
30488: PPUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL 14530 0 3
30498: GO 30501
30500: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30501: LD_VAR 0 1
30505: PUSH
30506: LD_EXP 67
30510: PUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 255
30520: ARRAY
30521: IN
30522: IFFALSE 30607
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30524: LD_ADDR_EXP 67
30528: PUSH
30529: LD_EXP 67
30533: PPUSH
30534: LD_VAR 0 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 31289 0 3
30546: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 255
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: CALL_OW 265
30566: PUSH
30567: LD_VAR 0 1
30571: PPUSH
30572: CALL_OW 262
30576: PUSH
30577: LD_VAR 0 1
30581: PPUSH
30582: CALL_OW 263
30586: PUSH
30587: LD_VAR 0 1
30591: PPUSH
30592: CALL_OW 264
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PPUSH
30603: CALL 21170 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30607: LD_VAR 0 1
30611: PUSH
30612: LD_EXP 71
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 255
30626: ARRAY
30627: IN
30628: IFFALSE 30653
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30630: LD_ADDR_EXP 71
30634: PUSH
30635: LD_EXP 71
30639: PPUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: LD_INT 0
30647: PPUSH
30648: CALL 31289 0 3
30652: ST_TO_ADDR
// end ; end ;
30653: PPOPN 1
30655: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30656: LD_EXP 39
30660: PUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL_OW 255
30670: ARRAY
30671: IFFALSE 30843
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30673: LD_VAR 0 2
30677: PUSH
30678: LD_EXP 68
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 255
30692: ARRAY
30693: IN
30694: PUSH
30695: LD_VAR 0 1
30699: PPUSH
30700: CALL_OW 266
30704: PUSH
30705: LD_INT 32
30707: PUSH
30708: LD_INT 31
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: IN
30715: AND
30716: IFFALSE 30816
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30718: LD_ADDR_EXP 68
30722: PUSH
30723: LD_EXP 68
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: LD_INT 0
30735: PPUSH
30736: CALL 31289 0 3
30740: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30741: LD_ADDR_EXP 68
30745: PUSH
30746: LD_EXP 68
30750: PPUSH
30751: LD_VAR 0 2
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL 31289 0 3
30763: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30764: LD_EXP 68
30768: PUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: CALL_OW 255
30778: ARRAY
30779: PUSH
30780: LD_STRING 
30782: EQUAL
30783: IFFALSE 30816
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30785: LD_ADDR_EXP 68
30789: PUSH
30790: LD_EXP 68
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: CALL_OW 255
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL 31130 0 4
30815: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30816: LD_VAR 0 1
30820: PPUSH
30821: CALL_OW 266
30825: PUSH
30826: LD_INT 36
30828: IN
30829: IFFALSE 30843
// SetTag ( un , 0 ) ;
30831: LD_VAR 0 2
30835: PPUSH
30836: LD_INT 0
30838: PPUSH
30839: CALL_OW 109
// end ;
30843: PPOPN 2
30845: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30846: LD_EXP 39
30850: PUSH
30851: LD_VAR 0 1
30855: PPUSH
30856: CALL_OW 255
30860: ARRAY
30861: IFFALSE 30887
// begin if GetControl ( un ) = control_remote then
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 263
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: IFFALSE 30887
// ComUnlink ( un ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 136
// end ;
30887: PPOPN 1
30889: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30890: LD_EXP 39
30894: PUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 255
30904: ARRAY
30905: IFFALSE 30934
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30907: LD_VAR 0 2
30911: PPUSH
30912: CALL_OW 264
30916: PUSH
30917: LD_INT 31
30919: IN
30920: IFFALSE 30934
// SetTag ( driver , 0 ) ;
30922: LD_VAR 0 1
30926: PPUSH
30927: LD_INT 0
30929: PPUSH
30930: CALL_OW 109
// end ;
30934: PPOPN 4
30936: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 269
30956: ST_TO_ADDR
// x := GetX ( building ) ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_VAR 0 1
30966: PPUSH
30967: CALL_OW 250
30971: ST_TO_ADDR
// y := GetY ( building ) ;
30972: LD_ADDR_VAR 0 5
30976: PUSH
30977: LD_VAR 0 1
30981: PPUSH
30982: CALL_OW 251
30986: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30987: LD_ADDR_EXP 43
30991: PUSH
30992: LD_EXP 43
30996: PPUSH
30997: LD_VAR 0 1
31001: PPUSH
31002: CALL_OW 255
31006: PPUSH
31007: LD_VAR 0 3
31011: PPUSH
31012: LD_VAR 0 4
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PPUSH
31026: CALL 42051 0 4
31030: ST_TO_ADDR
// end ;
31031: PPOPN 5
31033: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 30
31043: IN
31044: NOT
31045: IFFALSE 31093
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31047: LD_ADDR_EXP 30
31051: PUSH
31052: LD_EXP 30
31056: PPUSH
31057: LD_EXP 30
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 1
31070: PPUSH
31071: CALL_OW 2
31075: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31076: LD_STRING DestinationUnrechable. [unit: 
31078: PUSH
31079: LD_VAR 0 1
31083: STR
31084: PUSH
31085: LD_STRING ]
31087: STR
31088: PPUSH
31089: CALL 8039 0 1
// end ; end ;
31093: PPOPN 1
31095: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL 59162 0 3
// end ;
31115: PPOPN 3
31117: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL 59170 0 1
// end ; end_of_file
31127: PPOPN 1
31129: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
31134: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31135: LD_ADDR_VAR 0 7
31139: PUSH
31140: LD_VAR 0 1
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PPUSH
31151: LD_VAR 0 3
31155: PPUSH
31156: LD_VAR 0 4
31160: PPUSH
31161: CALL_OW 1
31165: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31166: LD_ADDR_VAR 0 1
31170: PUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: LD_VAR 0 2
31180: PPUSH
31181: LD_VAR 0 7
31185: PPUSH
31186: CALL_OW 1
31190: ST_TO_ADDR
// result := tab ;
31191: LD_ADDR_VAR 0 5
31195: PUSH
31196: LD_VAR 0 1
31200: ST_TO_ADDR
// end ;
31201: LD_VAR 0 5
31205: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31206: LD_INT 0
31208: PPUSH
31209: PPUSH
31210: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31211: LD_ADDR_VAR 0 5
31215: PUSH
31216: LD_VAR 0 1
31220: PUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: ARRAY
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_INT 2
31238: ARRAY
31239: PPUSH
31240: CALL_OW 3
31244: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31245: LD_ADDR_VAR 0 1
31249: PUSH
31250: LD_VAR 0 1
31254: PPUSH
31255: LD_VAR 0 2
31259: PUSH
31260: LD_INT 1
31262: ARRAY
31263: PPUSH
31264: LD_VAR 0 5
31268: PPUSH
31269: CALL_OW 1
31273: ST_TO_ADDR
// result := tab ;
31274: LD_ADDR_VAR 0 3
31278: PUSH
31279: LD_VAR 0 1
31283: ST_TO_ADDR
// end ;
31284: LD_VAR 0 3
31288: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31289: LD_INT 0
31291: PPUSH
31292: PPUSH
31293: PPUSH
31294: PPUSH
// i := 1 ;
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// while ( i <= tab ) do
31303: LD_VAR 0 5
31307: PUSH
31308: LD_VAR 0 1
31312: LESSEQUAL
31313: IFFALSE 31688
// begin if not tab [ i ] then
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: NOT
31326: IFFALSE 31330
// break ;
31328: GO 31688
// if value in tab then
31330: LD_VAR 0 2
31334: PUSH
31335: LD_VAR 0 1
31339: IN
31340: IFFALSE 31453
// begin if not mode then
31342: LD_VAR 0 3
31346: NOT
31347: IFFALSE 31367
// tab := tab diff value else
31349: LD_ADDR_VAR 0 1
31353: PUSH
31354: LD_VAR 0 1
31358: PUSH
31359: LD_VAR 0 2
31363: DIFF
31364: ST_TO_ADDR
31365: GO 31429
// for j = 1 to tab do
31367: LD_ADDR_VAR 0 6
31371: PUSH
31372: DOUBLE
31373: LD_INT 1
31375: DEC
31376: ST_TO_ADDR
31377: LD_VAR 0 1
31381: PUSH
31382: FOR_TO
31383: IFFALSE 31427
// if tab [ j ] = value then
31385: LD_VAR 0 1
31389: PUSH
31390: LD_VAR 0 6
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 2
31400: EQUAL
31401: IFFALSE 31425
// begin tab := Delete ( tab , j ) ;
31403: LD_ADDR_VAR 0 1
31407: PUSH
31408: LD_VAR 0 1
31412: PPUSH
31413: LD_VAR 0 6
31417: PPUSH
31418: CALL_OW 3
31422: ST_TO_ADDR
// break ;
31423: GO 31427
// end ;
31425: GO 31382
31427: POP
31428: POP
// i := i - 1 ;
31429: LD_ADDR_VAR 0 5
31433: PUSH
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 1
31441: MINUS
31442: ST_TO_ADDR
// if mode then
31443: LD_VAR 0 3
31447: IFFALSE 31451
// break ;
31449: GO 31688
// end else
31451: GO 31672
// if tab [ i ] and value in tab [ i ] then
31453: LD_VAR 0 1
31457: PUSH
31458: LD_VAR 0 5
31462: ARRAY
31463: PUSH
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: IN
31480: AND
31481: IFFALSE 31672
// begin if not mode then
31483: LD_VAR 0 3
31487: NOT
31488: IFFALSE 31514
// tmp := tab [ i ] diff value else
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: LD_VAR 0 1
31499: PUSH
31500: LD_VAR 0 5
31504: ARRAY
31505: PUSH
31506: LD_VAR 0 2
31510: DIFF
31511: ST_TO_ADDR
31512: GO 31594
// for j = 1 to tab [ i ] do
31514: LD_ADDR_VAR 0 6
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 1
31528: PUSH
31529: LD_VAR 0 5
31533: ARRAY
31534: PUSH
31535: FOR_TO
31536: IFFALSE 31592
// if value = tab [ i ] [ j ] then
31538: LD_VAR 0 2
31542: PUSH
31543: LD_VAR 0 1
31547: PUSH
31548: LD_VAR 0 5
31552: ARRAY
31553: PUSH
31554: LD_VAR 0 6
31558: ARRAY
31559: EQUAL
31560: IFFALSE 31590
// begin tmp := Delete ( tab [ i ] , j ) ;
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: LD_VAR 0 1
31571: PUSH
31572: LD_VAR 0 5
31576: ARRAY
31577: PPUSH
31578: LD_VAR 0 6
31582: PPUSH
31583: CALL_OW 3
31587: ST_TO_ADDR
// break ;
31588: GO 31592
// end ;
31590: GO 31535
31592: POP
31593: POP
// if tmp = [ ] then
31594: LD_VAR 0 7
31598: PUSH
31599: EMPTY
31600: EQUAL
31601: IFFALSE 31625
// begin tab := Delete ( tab , i ) ;
31603: LD_ADDR_VAR 0 1
31607: PUSH
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: CALL_OW 3
31622: ST_TO_ADDR
// end else
31623: GO 31650
// tab := Replace ( tab , i , tmp ) ;
31625: LD_ADDR_VAR 0 1
31629: PUSH
31630: LD_VAR 0 1
31634: PPUSH
31635: LD_VAR 0 5
31639: PPUSH
31640: LD_VAR 0 7
31644: PPUSH
31645: CALL_OW 1
31649: ST_TO_ADDR
// i := i - 1 ;
31650: LD_ADDR_VAR 0 5
31654: PUSH
31655: LD_VAR 0 5
31659: PUSH
31660: LD_INT 1
31662: MINUS
31663: ST_TO_ADDR
// if mode then
31664: LD_VAR 0 3
31668: IFFALSE 31672
// break ;
31670: GO 31688
// end ; i := i + 1 ;
31672: LD_ADDR_VAR 0 5
31676: PUSH
31677: LD_VAR 0 5
31681: PUSH
31682: LD_INT 1
31684: PLUS
31685: ST_TO_ADDR
// end ;
31686: GO 31303
// result := tab ;
31688: LD_ADDR_VAR 0 4
31692: PUSH
31693: LD_VAR 0 1
31697: ST_TO_ADDR
// end ;
31698: LD_VAR 0 4
31702: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31703: LD_INT 0
31705: PPUSH
31706: PPUSH
// for i = 1 to values do
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: DOUBLE
31713: LD_INT 1
31715: DEC
31716: ST_TO_ADDR
31717: LD_VAR 0 2
31721: PUSH
31722: FOR_TO
31723: IFFALSE 31756
// tab := Remove ( tab , values [ i ] , false ) ;
31725: LD_ADDR_VAR 0 1
31729: PUSH
31730: LD_VAR 0 1
31734: PPUSH
31735: LD_VAR 0 2
31739: PUSH
31740: LD_VAR 0 4
31744: ARRAY
31745: PPUSH
31746: LD_INT 0
31748: PPUSH
31749: CALL 31289 0 3
31753: ST_TO_ADDR
31754: GO 31722
31756: POP
31757: POP
// result := tab ;
31758: LD_ADDR_VAR 0 3
31762: PUSH
31763: LD_VAR 0 1
31767: ST_TO_ADDR
// end ;
31768: LD_VAR 0 3
31772: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31773: LD_INT 0
31775: PPUSH
31776: PPUSH
31777: PPUSH
// if not GetControl ( veh ) = control_manual then
31778: LD_VAR 0 1
31782: PPUSH
31783: CALL_OW 263
31787: PUSH
31788: LD_INT 1
31790: EQUAL
31791: NOT
31792: IFFALSE 31804
// result := false else
31794: LD_ADDR_VAR 0 2
31798: PUSH
31799: LD_INT 0
31801: ST_TO_ADDR
31802: GO 31949
// if veh in FilterAllUnits ( [ f_empty ] ) then
31804: LD_VAR 0 1
31808: PUSH
31809: LD_INT 58
31811: PUSH
31812: EMPTY
31813: LIST
31814: PPUSH
31815: CALL_OW 69
31819: IN
31820: IFFALSE 31832
// result := false else
31822: LD_ADDR_VAR 0 2
31826: PUSH
31827: LD_INT 0
31829: ST_TO_ADDR
31830: GO 31949
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31832: LD_ADDR_VAR 0 4
31836: PUSH
31837: LD_INT 22
31839: PUSH
31840: LD_VAR 0 1
31844: PPUSH
31845: CALL_OW 255
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 55
31856: PUSH
31857: EMPTY
31858: LIST
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 69
31868: ST_TO_ADDR
// if not filter then
31869: LD_VAR 0 4
31873: NOT
31874: IFFALSE 31886
// result := false else
31876: LD_ADDR_VAR 0 2
31880: PUSH
31881: LD_INT 0
31883: ST_TO_ADDR
31884: GO 31949
// for i = 1 to filter do
31886: LD_ADDR_VAR 0 3
31890: PUSH
31891: DOUBLE
31892: LD_INT 1
31894: DEC
31895: ST_TO_ADDR
31896: LD_VAR 0 4
31900: PUSH
31901: FOR_TO
31902: IFFALSE 31947
// if IsDriver ( filter [ i ] ) = veh then
31904: LD_VAR 0 4
31908: PUSH
31909: LD_VAR 0 3
31913: ARRAY
31914: PPUSH
31915: CALL 99100 0 1
31919: PUSH
31920: LD_VAR 0 1
31924: EQUAL
31925: IFFALSE 31945
// begin result := filter [ i ] ;
31927: LD_ADDR_VAR 0 2
31931: PUSH
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 3
31941: ARRAY
31942: ST_TO_ADDR
// break ;
31943: GO 31947
// end ;
31945: GO 31901
31947: POP
31948: POP
// end ; end ;
31949: LD_VAR 0 2
31953: RET
// export function Compare ( val1 , val2 ) ; begin
31954: LD_INT 0
31956: PPUSH
// if val1 = val2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 31979
// result := true else
31969: LD_ADDR_VAR 0 3
31973: PUSH
31974: LD_INT 1
31976: ST_TO_ADDR
31977: GO 31987
// result := false ;
31979: LD_ADDR_VAR 0 3
31983: PUSH
31984: LD_INT 0
31986: ST_TO_ADDR
// end ;
31987: LD_VAR 0 3
31991: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31992: LD_INT 0
31994: PPUSH
31995: PPUSH
// result := false ;
31996: LD_ADDR_VAR 0 3
32000: PUSH
32001: LD_INT 0
32003: ST_TO_ADDR
// for j = 1 to e2 do
32004: LD_ADDR_VAR 0 4
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_VAR 0 2
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32054
// if Compare ( e1 , e2 [ j ] ) then
32022: LD_VAR 0 1
32026: PPUSH
32027: LD_VAR 0 2
32031: PUSH
32032: LD_VAR 0 4
32036: ARRAY
32037: PPUSH
32038: CALL 31954 0 2
32042: IFFALSE 32052
// result := true ;
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_INT 1
32051: ST_TO_ADDR
32052: GO 32019
32054: POP
32055: POP
// end ;
32056: LD_VAR 0 3
32060: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32061: LD_INT 0
32063: PPUSH
32064: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_STRING C
32072: PUSH
32073: LD_VAR 0 2
32077: PUSH
32078: LD_VAR 0 3
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: PUSH
32104: LD_STRING v
32106: PUSH
32107: LD_VAR 0 4
32111: PPUSH
32112: CALL_OW 250
32116: PUSH
32117: LD_VAR 0 4
32121: PPUSH
32122: CALL_OW 251
32126: PUSH
32127: LD_VAR 0 4
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 0
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: CALL_OW 446
// end ;
32158: LD_VAR 0 5
32162: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
// linked := UnitsLinked ( unit ) ;
32168: LD_ADDR_VAR 0 4
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 432
32182: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32183: LD_ADDR_VAR 0 3
32187: PUSH
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_INT 3
32195: PPUSH
32196: CALL_OW 259
32200: ST_TO_ADDR
// if sk > linked then
32201: LD_VAR 0 3
32205: PUSH
32206: LD_VAR 0 4
32210: GREATER
32211: IFFALSE 32223
// result := true else
32213: LD_ADDR_VAR 0 2
32217: PUSH
32218: LD_INT 1
32220: ST_TO_ADDR
32221: GO 32231
// result := false ;
32223: LD_ADDR_VAR 0 2
32227: PUSH
32228: LD_INT 0
32230: ST_TO_ADDR
// end ;
32231: LD_VAR 0 2
32235: RET
// export function NotTask ( unit ) ; begin
32236: LD_INT 0
32238: PPUSH
// result := true ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32247: LD_VAR 0 1
32251: PPUSH
32252: CALL_OW 437
32256: PUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: CALL_OW 314
32266: OR
32267: IFFALSE 32277
// result := false ;
32269: LD_ADDR_VAR 0 2
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// end ;
32277: LD_VAR 0 2
32281: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32282: LD_INT 0
32284: PPUSH
32285: PPUSH
32286: PPUSH
32287: PPUSH
32288: PPUSH
// dist := 99999 ;
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_INT 99999
32296: ST_TO_ADDR
// un := - 1 ;
32297: LD_ADDR_VAR 0 6
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: ST_TO_ADDR
// if units1 and units2 then
32306: LD_VAR 0 1
32310: PUSH
32311: LD_VAR 0 2
32315: AND
32316: IFFALSE 32404
// for i in units1 do
32318: LD_ADDR_VAR 0 4
32322: PUSH
32323: LD_VAR 0 1
32327: PUSH
32328: FOR_IN
32329: IFFALSE 32402
// for j in units2 do
32331: LD_ADDR_VAR 0 5
32335: PUSH
32336: LD_VAR 0 2
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32398
// if GetDistUnits ( i , j ) < dist then
32344: LD_VAR 0 4
32348: PPUSH
32349: LD_VAR 0 5
32353: PPUSH
32354: CALL_OW 296
32358: PUSH
32359: LD_VAR 0 7
32363: LESS
32364: IFFALSE 32396
// begin un := i ;
32366: LD_ADDR_VAR 0 6
32370: PUSH
32371: LD_VAR 0 4
32375: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32376: LD_ADDR_VAR 0 7
32380: PUSH
32381: LD_VAR 0 4
32385: PPUSH
32386: LD_VAR 0 5
32390: PPUSH
32391: CALL_OW 296
32395: ST_TO_ADDR
// end ;
32396: GO 32341
32398: POP
32399: POP
32400: GO 32328
32402: POP
32403: POP
// result := [ un , dist ] ;
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_VAR 0 6
32413: PUSH
32414: LD_VAR 0 7
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: ST_TO_ADDR
// end ;
32423: LD_VAR 0 3
32427: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32428: LD_INT 0
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32435: LD_VAR 0 1
32439: NOT
32440: PUSH
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 256
32450: PUSH
32451: LD_INT 250
32453: LESS
32454: OR
32455: PUSH
32456: LD_VAR 0 1
32460: PPUSH
32461: CALL_OW 314
32465: PUSH
32466: LD_VAR 0 1
32470: PPUSH
32471: CALL_OW 261
32475: PUSH
32476: LD_INT 20
32478: GREATER
32479: AND
32480: OR
32481: IFFALSE 32485
// exit ;
32483: GO 32859
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 261
32494: PUSH
32495: LD_INT 20
32497: LESS
32498: PUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 21
32511: EQUAL
32512: NOT
32513: AND
32514: IFFALSE 32550
// begin ComStop ( bulldozer ) ;
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32525: LD_VAR 0 1
32529: PPUSH
32530: LD_INT 21
32532: PPUSH
32533: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32537: LD_VAR 0 1
32541: PPUSH
32542: CALL 26278 0 1
// exit ;
32546: GO 32859
// end else
32548: GO 32577
// if GetFuel ( bulldozer ) > 20 then
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: IFFALSE 32577
// SetTag ( bulldozer , 0 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 0
32572: PPUSH
32573: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_VAR 0 2
32586: PPUSH
32587: CALL_OW 353
32591: ST_TO_ADDR
// tmp := [ ] ;
32592: LD_ADDR_VAR 0 6
32596: PUSH
32597: EMPTY
32598: ST_TO_ADDR
// for i = 1 to list do
32599: LD_ADDR_VAR 0 4
32603: PUSH
32604: DOUBLE
32605: LD_INT 1
32607: DEC
32608: ST_TO_ADDR
32609: LD_VAR 0 5
32613: PUSH
32614: FOR_TO
32615: IFFALSE 32713
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32617: LD_VAR 0 5
32621: PUSH
32622: LD_VAR 0 4
32626: ARRAY
32627: PUSH
32628: LD_INT 1
32630: ARRAY
32631: PPUSH
32632: LD_VAR 0 5
32636: PUSH
32637: LD_VAR 0 4
32641: ARRAY
32642: PUSH
32643: LD_INT 2
32645: ARRAY
32646: PPUSH
32647: CALL_OW 554
32651: IFFALSE 32711
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32653: LD_ADDR_VAR 0 6
32657: PUSH
32658: LD_VAR 0 6
32662: PPUSH
32663: LD_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PPUSH
32672: LD_VAR 0 5
32676: PUSH
32677: LD_VAR 0 4
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 5
32691: PUSH
32692: LD_VAR 0 4
32696: ARRAY
32697: PUSH
32698: LD_INT 2
32700: ARRAY
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 1
32710: ST_TO_ADDR
// end ;
32711: GO 32614
32713: POP
32714: POP
// ComStop ( bulldozer ) ;
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32724: LD_ADDR_VAR 0 7
32728: PUSH
32729: LD_VAR 0 1
32733: PPUSH
32734: CALL_OW 250
32738: PUSH
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 251
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: ST_TO_ADDR
// for i = tmp downto 1 do
32753: LD_ADDR_VAR 0 4
32757: PUSH
32758: DOUBLE
32759: LD_VAR 0 6
32763: INC
32764: ST_TO_ADDR
32765: LD_INT 1
32767: PUSH
32768: FOR_DOWNTO
32769: IFFALSE 32857
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32771: LD_ADDR_VAR 0 7
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 2
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 6
32798: PPUSH
32799: CALL 32960 0 3
32803: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32804: LD_VAR 0 1
32808: PPUSH
32809: LD_VAR 0 7
32813: PUSH
32814: LD_INT 1
32816: ARRAY
32817: PPUSH
32818: LD_VAR 0 7
32822: PUSH
32823: LD_INT 2
32825: ARRAY
32826: PPUSH
32827: CALL 32864 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32831: LD_ADDR_VAR 0 6
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_VAR 0 7
32845: PUSH
32846: LD_INT 3
32848: ARRAY
32849: PPUSH
32850: CALL_OW 3
32854: ST_TO_ADDR
// end ;
32855: GO 32768
32857: POP
32858: POP
// end ;
32859: LD_VAR 0 3
32863: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32864: LD_INT 0
32866: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32867: LD_VAR 0 2
32871: PPUSH
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 351
32881: PUSH
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 554
32896: AND
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 488
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 428
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: EQUAL
32933: AND
32934: IFFALSE 32955
// AddComMoveXY ( bulldozer , x , y ) ;
32936: LD_VAR 0 1
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 171
// end ;
32955: LD_VAR 0 4
32959: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32960: LD_INT 0
32962: PPUSH
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
// dist := 99999 ;
32969: LD_ADDR_VAR 0 6
32973: PUSH
32974: LD_INT 99999
32976: ST_TO_ADDR
// for i = 1 to list do
32977: LD_ADDR_VAR 0 5
32981: PUSH
32982: DOUBLE
32983: LD_INT 1
32985: DEC
32986: ST_TO_ADDR
32987: LD_VAR 0 3
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33131
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32995: LD_ADDR_VAR 0 7
32999: PUSH
33000: LD_VAR 0 1
33004: PPUSH
33005: LD_VAR 0 2
33009: PPUSH
33010: LD_VAR 0 3
33014: PUSH
33015: LD_VAR 0 5
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PPUSH
33025: LD_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: ARRAY
33035: PUSH
33036: LD_INT 2
33038: ARRAY
33039: PPUSH
33040: CALL_OW 298
33044: ST_TO_ADDR
// if d = 0 then
33045: LD_VAR 0 7
33049: PUSH
33050: LD_INT 0
33052: EQUAL
33053: IFFALSE 33057
// continue ;
33055: GO 32992
// if d < dist then
33057: LD_VAR 0 7
33061: PUSH
33062: LD_VAR 0 6
33066: LESS
33067: IFFALSE 33129
// begin _x := list [ i ] [ 1 ] ;
33069: LD_ADDR_VAR 0 8
33073: PUSH
33074: LD_VAR 0 3
33078: PUSH
33079: LD_VAR 0 5
33083: ARRAY
33084: PUSH
33085: LD_INT 1
33087: ARRAY
33088: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33089: LD_ADDR_VAR 0 9
33093: PUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 2
33107: ARRAY
33108: ST_TO_ADDR
// _i := i ;
33109: LD_ADDR_VAR 0 10
33113: PUSH
33114: LD_VAR 0 5
33118: ST_TO_ADDR
// dist := d ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_VAR 0 7
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32992
33131: POP
33132: POP
// result := [ _x , _y , _i , dist ] ;
33133: LD_ADDR_VAR 0 4
33137: PUSH
33138: LD_VAR 0 8
33142: PUSH
33143: LD_VAR 0 9
33147: PUSH
33148: LD_VAR 0 10
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: ST_TO_ADDR
// end ;
33164: LD_VAR 0 4
33168: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
// for i = 1 to list do
33176: LD_ADDR_VAR 0 5
33180: PUSH
33181: DOUBLE
33182: LD_INT 1
33184: DEC
33185: ST_TO_ADDR
33186: LD_VAR 0 1
33190: PUSH
33191: FOR_TO
33192: IFFALSE 33506
// begin for j = list downto 2 do
33194: LD_ADDR_VAR 0 6
33198: PUSH
33199: DOUBLE
33200: LD_VAR 0 1
33204: INC
33205: ST_TO_ADDR
33206: LD_INT 2
33208: PUSH
33209: FOR_DOWNTO
33210: IFFALSE 33502
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33212: LD_VAR 0 2
33216: PPUSH
33217: LD_VAR 0 3
33221: PPUSH
33222: LD_VAR 0 1
33226: PUSH
33227: LD_VAR 0 6
33231: ARRAY
33232: PUSH
33233: LD_INT 1
33235: ARRAY
33236: PPUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_VAR 0 6
33246: ARRAY
33247: PUSH
33248: LD_INT 2
33250: ARRAY
33251: PPUSH
33252: CALL_OW 298
33256: PUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_INT 1
33279: MINUS
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PPUSH
33286: LD_VAR 0 1
33290: PUSH
33291: LD_VAR 0 6
33295: PUSH
33296: LD_INT 1
33298: MINUS
33299: ARRAY
33300: PUSH
33301: LD_INT 2
33303: ARRAY
33304: PPUSH
33305: CALL_OW 298
33309: LESS
33310: IFFALSE 33500
// begin _x := list [ j ] [ 1 ] ;
33312: LD_ADDR_VAR 0 7
33316: PUSH
33317: LD_VAR 0 1
33321: PUSH
33322: LD_VAR 0 6
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33332: LD_ADDR_VAR 0 8
33336: PUSH
33337: LD_VAR 0 1
33341: PUSH
33342: LD_VAR 0 6
33346: ARRAY
33347: PUSH
33348: LD_INT 2
33350: ARRAY
33351: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_VAR 0 1
33361: PPUSH
33362: LD_VAR 0 6
33366: PPUSH
33367: LD_INT 1
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: CALL 31130 0 4
33393: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_VAR 0 1
33403: PPUSH
33404: LD_VAR 0 6
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 1
33416: PUSH
33417: LD_VAR 0 6
33421: PUSH
33422: LD_INT 1
33424: MINUS
33425: ARRAY
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: CALL 31130 0 4
33435: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PUSH
33451: LD_INT 1
33453: MINUS
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: LD_VAR 0 7
33462: PPUSH
33463: CALL 31130 0 4
33467: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33468: LD_ADDR_VAR 0 1
33472: PUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 6
33482: PUSH
33483: LD_INT 1
33485: MINUS
33486: PPUSH
33487: LD_INT 2
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: CALL 31130 0 4
33499: ST_TO_ADDR
// end ; end ;
33500: GO 33209
33502: POP
33503: POP
// end ;
33504: GO 33191
33506: POP
33507: POP
// result := list ;
33508: LD_ADDR_VAR 0 4
33512: PUSH
33513: LD_VAR 0 1
33517: ST_TO_ADDR
// end ;
33518: LD_VAR 0 4
33522: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33523: LD_INT 0
33525: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33526: LD_ADDR_VAR 0 5
33530: PUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: LD_VAR 0 2
33540: PPUSH
33541: CALL_OW 546
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PUSH
33550: LD_VAR 0 3
33554: PPUSH
33555: LD_VAR 0 4
33559: PPUSH
33560: CALL_OW 546
33564: PUSH
33565: LD_INT 2
33567: ARRAY
33568: MINUS
33569: ST_TO_ADDR
// if result < 0 then
33570: LD_VAR 0 5
33574: PUSH
33575: LD_INT 0
33577: LESS
33578: IFFALSE 33595
// result := result * - 1 ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_VAR 0 5
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: MUL
33594: ST_TO_ADDR
// end ;
33595: LD_VAR 0 5
33599: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
// area = ListEnvironmentArea ( area ) ;
33604: LD_ADDR_VAR 0 2
33608: PUSH
33609: LD_VAR 0 2
33613: PPUSH
33614: CALL_OW 353
33618: ST_TO_ADDR
// if bulldozer > 0 then
33619: LD_VAR 0 1
33623: PUSH
33624: LD_INT 0
33626: GREATER
33627: IFFALSE 33738
// for i = area downto 1 do
33629: LD_ADDR_VAR 0 4
33633: PUSH
33634: DOUBLE
33635: LD_VAR 0 2
33639: INC
33640: ST_TO_ADDR
33641: LD_INT 1
33643: PUSH
33644: FOR_DOWNTO
33645: IFFALSE 33736
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33647: LD_VAR 0 2
33651: PUSH
33652: LD_VAR 0 4
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_VAR 0 2
33666: PUSH
33667: LD_VAR 0 4
33671: ARRAY
33672: PUSH
33673: LD_INT 2
33675: ARRAY
33676: PPUSH
33677: CALL_OW 351
33681: IFFALSE 33734
// if not HasTask ( bulldozer ) then
33683: LD_VAR 0 1
33687: PPUSH
33688: CALL_OW 314
33692: NOT
33693: IFFALSE 33734
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33695: LD_VAR 0 1
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_VAR 0 4
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PPUSH
33715: LD_VAR 0 2
33719: PUSH
33720: LD_VAR 0 4
33724: ARRAY
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: PPUSH
33730: CALL_OW 171
33734: GO 33644
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 3
33742: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33749: LD_ADDR_VAR 0 6
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_VAR 0 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 21
33768: PUSH
33769: LD_VAR 0 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PPUSH
33782: CALL_OW 69
33786: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33787: LD_ADDR_VAR 0 7
33791: PUSH
33792: LD_VAR 0 3
33796: PPUSH
33797: LD_INT 22
33799: PUSH
33800: LD_VAR 0 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 21
33811: PUSH
33812: LD_VAR 0 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PPUSH
33825: CALL_OW 70
33829: ST_TO_ADDR
// if tmp and pom then
33830: LD_VAR 0 6
33834: PUSH
33835: LD_VAR 0 7
33839: AND
33840: IFFALSE 33860
// result := tmp diff pom else
33842: LD_ADDR_VAR 0 4
33846: PUSH
33847: LD_VAR 0 6
33851: PUSH
33852: LD_VAR 0 7
33856: DIFF
33857: ST_TO_ADDR
33858: GO 33868
// result := false ;
33860: LD_ADDR_VAR 0 4
33864: PUSH
33865: LD_INT 0
33867: ST_TO_ADDR
// end ;
33868: LD_VAR 0 4
33872: RET
// export function SavePosition ( unit ) ; begin
33873: LD_INT 0
33875: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: LD_VAR 0 1
33885: PPUSH
33886: CALL_OW 250
33890: PPUSH
33891: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 251
33909: PPUSH
33910: CALL_OW 232
// end ;
33914: LD_VAR 0 2
33918: RET
// export function GetPosition ( unit ) ; begin
33919: LD_INT 0
33921: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33922: LD_ADDR_VAR 0 2
33926: PUSH
33927: LD_VAR 0 1
33931: PPUSH
33932: CALL_OW 252
33936: PUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL_OW 253
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: ST_TO_ADDR
// end ;
33951: LD_VAR 0 2
33955: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33956: LD_INT 0
33958: PPUSH
// if unit in unreachableList then
33959: LD_VAR 0 1
33963: PUSH
33964: LD_EXP 30
33968: IN
33969: IFFALSE 33987
// unreachableList := unreachableList diff unit ;
33971: LD_ADDR_EXP 30
33975: PUSH
33976: LD_EXP 30
33980: PUSH
33981: LD_VAR 0 1
33985: DIFF
33986: ST_TO_ADDR
// if ValidHex ( x , y ) then
33987: LD_VAR 0 2
33991: PPUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: CALL_OW 488
34001: IFFALSE 34027
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_VAR 0 2
34012: PPUSH
34013: LD_VAR 0 3
34017: PPUSH
34018: CALL_OW 428
34022: PPUSH
34023: CALL_OW 115
// Wait ( 3 ) ;
34027: LD_INT 3
34029: PPUSH
34030: CALL_OW 67
// if unit in unreachableList then
34034: LD_VAR 0 1
34038: PUSH
34039: LD_EXP 30
34043: IN
34044: IFFALSE 34056
// result := false else
34046: LD_ADDR_VAR 0 4
34050: PUSH
34051: LD_INT 0
34053: ST_TO_ADDR
34054: GO 34064
// result := true ;
34056: LD_ADDR_VAR 0 4
34060: PUSH
34061: LD_INT 1
34063: ST_TO_ADDR
// end ; end_of_file
34064: LD_VAR 0 4
34068: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34069: LD_EXP 31
34073: IFFALSE 34135
34075: GO 34077
34077: DISABLE
34078: LD_INT 0
34080: PPUSH
// begin enable ;
34081: ENABLE
// for i = 1 to mc_crates_list do
34082: LD_ADDR_VAR 0 1
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 32
34096: PUSH
34097: FOR_TO
34098: IFFALSE 34129
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34100: LD_EXP 32
34104: PUSH
34105: LD_VAR 0 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 5
34113: PPUSH
34114: LD_INT 50
34116: PPUSH
34117: LD_INT 700
34119: PPUSH
34120: LD_INT 20
34122: PPUSH
34123: CALL 24485 0 5
34127: GO 34097
34129: POP
34130: POP
// MC_Game ( ) ;
34131: CALL 34138 0 0
// end ;
34135: PPOPN 1
34137: END
// export function MC_Game ( ) ; var i , side , un ; begin
34138: LD_INT 0
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not isTest then
34144: LD_EXP 1
34148: NOT
34149: IFFALSE 34169
// MC_Show ( [ #tick , tick ] ) else
34151: LD_STRING #tick
34153: PUSH
34154: LD_OWVAR 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PPUSH
34163: CALL 8569 0 1
34167: GO 34178
// MC_Show ( debug_string ) ;
34169: LD_EXP 2
34173: PPUSH
34174: CALL 8569 0 1
// for side = 1 to 8 do
34178: LD_ADDR_VAR 0 3
34182: PUSH
34183: DOUBLE
34184: LD_INT 1
34186: DEC
34187: ST_TO_ADDR
34188: LD_INT 8
34190: PUSH
34191: FOR_TO
34192: IFFALSE 36192
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34194: LD_EXP 39
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PUSH
34205: LD_INT 0
34207: EQUAL
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: EMPTY
34215: PPUSH
34216: CALL 11786 0 2
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: OR
34225: IFFALSE 34229
// continue ;
34227: GO 34191
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34229: LD_VAR 0 3
34233: PPUSH
34234: LD_VAR 0 3
34238: PPUSH
34239: CALL 25006 0 1
34243: PPUSH
34244: CALL 36199 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34248: LD_EXP 71
34252: PUSH
34253: LD_VAR 0 3
34257: ARRAY
34258: PUSH
34259: LD_INT 1
34261: ARRAY
34262: PUSH
34263: LD_INT 0
34265: GREATER
34266: PUSH
34267: LD_EXP 69
34271: PUSH
34272: LD_VAR 0 3
34276: ARRAY
34277: PUSH
34278: LD_INT 1
34280: ARRAY
34281: PUSH
34282: LD_INT 0
34284: EQUAL
34285: AND
34286: PUSH
34287: LD_VAR 0 3
34291: PPUSH
34292: LD_INT 7
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL 12354 0 3
34301: NOT
34302: AND
34303: IFFALSE 34340
// begin for i in MREG_Attackers [ side ] do
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_EXP 71
34314: PUSH
34315: LD_VAR 0 3
34319: ARRAY
34320: PUSH
34321: FOR_IN
34322: IFFALSE 34338
// SetTag ( i , 7 ) ;
34324: LD_VAR 0 2
34328: PPUSH
34329: LD_INT 7
34331: PPUSH
34332: CALL_OW 109
34336: GO 34321
34338: POP
34339: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34340: LD_VAR 0 3
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: EMPTY
34349: PPUSH
34350: CALL 12354 0 3
34354: IFFALSE 34414
// begin if side = 1 then
34356: LD_VAR 0 3
34360: PUSH
34361: LD_INT 1
34363: EQUAL
34364: IFFALSE 34373
// RaiseSailEvent ( 101 ) ;
34366: LD_INT 101
34368: PPUSH
34369: CALL_OW 427
// if side = 4 then
34373: LD_VAR 0 3
34377: PUSH
34378: LD_INT 4
34380: EQUAL
34381: IFFALSE 34390
// RaiseSailEvent ( 102 ) ;
34383: LD_INT 102
34385: PPUSH
34386: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: LD_INT 7
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL 12354 0 3
34409: PPUSH
34410: CALL 8487 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 18034 0 1
34423: PUSH
34424: LD_VAR 0 3
34428: PPUSH
34429: CALL 11690 0 1
34433: AND
34434: IFFALSE 34445
// MCL_Start ( side ) ;
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 17991 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34445: LD_ADDR_EXP 35
34449: PUSH
34450: LD_EXP 35
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL 19291 0 1
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34475: LD_ADDR_EXP 47
34479: PUSH
34480: LD_EXP 47
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL 11104 0 1
34499: PPUSH
34500: CALL_OW 1
34504: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34505: LD_VAR 0 3
34509: PPUSH
34510: LD_INT 21
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PPUSH
34520: CALL 11651 0 2
34524: IFFALSE 34535
// MCV_CheckStatus ( side ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL 27188 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 53
34544: PPUSH
34545: CALL 42999 0 2
34549: IFFALSE 34634
// begin for i = MREG_ToChangeClass downto 1 do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_EXP 53
34561: INC
34562: ST_TO_ADDR
34563: LD_INT 1
34565: PUSH
34566: FOR_DOWNTO
34567: IFFALSE 34632
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34569: LD_EXP 53
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 1
34582: ARRAY
34583: PUSH
34584: LD_VAR 0 3
34588: EQUAL
34589: IFFALSE 34630
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34591: LD_VAR 0 3
34595: PPUSH
34596: LD_EXP 53
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_INT 2
34609: ARRAY
34610: PPUSH
34611: LD_EXP 53
34615: PUSH
34616: LD_VAR 0 2
34620: ARRAY
34621: PUSH
34622: LD_INT 3
34624: ARRAY
34625: PPUSH
34626: CALL 16558 0 3
// end ; end ;
34630: GO 34566
34632: POP
34633: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34634: LD_INT 1
34636: PUSH
34637: LD_EXP 38
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: IN
34648: IFFALSE 34659
// begin MCN_TrainApe ( side ) ;
34650: LD_VAR 0 3
34654: PPUSH
34655: CALL 18944 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34659: LD_VAR 0 3
34663: PPUSH
34664: LD_INT 30
34666: PUSH
34667: LD_INT 3
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PPUSH
34674: CALL 11651 0 2
34678: IFFALSE 34852
// begin if MCF_Tag ( side , 10 , [ ] ) then
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 10
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL 12354 0 3
34694: IFFALSE 34741
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12354 0 3
34710: PPUSH
34711: LD_VAR 0 3
34715: PPUSH
34716: LD_INT 30
34718: PUSH
34719: LD_INT 3
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PPUSH
34726: CALL 11651 0 2
34730: PUSH
34731: LD_INT 1
34733: ARRAY
34734: PPUSH
34735: CALL_OW 168
// end else
34739: GO 34852
// if MREG_ToConstruct [ side ] then
34741: LD_EXP 51
34745: PUSH
34746: LD_VAR 0 3
34750: ARRAY
34751: IFFALSE 34852
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_VAR 0 3
34762: PPUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 3
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PPUSH
34773: CALL 11651 0 2
34777: PUSH
34778: LD_INT 1
34780: ARRAY
34781: PPUSH
34782: LD_EXP 51
34786: PUSH
34787: LD_VAR 0 3
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_EXP 51
34801: PUSH
34802: LD_VAR 0 3
34806: ARRAY
34807: PUSH
34808: LD_INT 2
34810: ARRAY
34811: PUSH
34812: LD_EXP 51
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 3
34825: ARRAY
34826: PUSH
34827: LD_EXP 51
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 4
34840: ARRAY
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL 25496 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34852: LD_VAR 0 3
34856: PPUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL 11651 0 2
34871: PUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_EXP 43
34881: PPUSH
34882: CALL 42999 0 2
34886: AND
34887: PUSH
34888: LD_INT 22
34890: PUSH
34891: LD_VAR 0 3
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 33
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 32
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 35
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL_OW 69
34947: AND
34948: IFFALSE 34959
// MCV_Turret ( side ) ;
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 25933 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34959: LD_EXP 42
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: GREATER
34973: PUSH
34974: LD_VAR 0 3
34978: PPUSH
34979: CALL 25006 0 1
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: AND
34988: IFFALSE 35150
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34990: LD_EXP 42
34994: PUSH
34995: LD_VAR 0 3
34999: ARRAY
35000: PUSH
35001: LD_INT 1
35003: ARRAY
35004: PPUSH
35005: CALL_OW 353
35009: IFFALSE 35047
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35011: LD_EXP 42
35015: PUSH
35016: LD_VAR 0 3
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: PPUSH
35026: LD_EXP 42
35030: PUSH
35031: LD_VAR 0 3
35035: ARRAY
35036: PUSH
35037: LD_INT 1
35039: ARRAY
35040: PPUSH
35041: CALL 32428 0 2
35045: GO 35150
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PPUSH
35062: CALL 11651 0 2
35066: IFFALSE 35150
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35068: LD_VAR 0 3
35072: PPUSH
35073: LD_INT 30
35075: PUSH
35076: LD_INT 3
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PPUSH
35083: CALL 11651 0 2
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 2
35099: EQUAL
35100: IFFALSE 35150
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35102: LD_EXP 42
35106: PUSH
35107: LD_VAR 0 3
35111: ARRAY
35112: PUSH
35113: LD_INT 2
35115: ARRAY
35116: PPUSH
35117: LD_INT 10
35119: PPUSH
35120: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35124: LD_ADDR_EXP 42
35128: PUSH
35129: LD_EXP 42
35133: PPUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PPUSH
35165: CALL 11651 0 2
35169: IFFALSE 35209
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PPUSH
35191: CALL 11651 0 2
35195: PUSH
35196: LD_INT 1
35198: ARRAY
35199: PPUSH
35200: CALL_OW 248
35204: PPUSH
35205: CALL 26487 0 2
// if MREG_ToRepair [ side ] then
35209: LD_EXP 47
35213: PUSH
35214: LD_VAR 0 3
35218: ARRAY
35219: IFFALSE 35232
// begin MCB_Repair ( side ) ;
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL 11391 0 1
// end else
35230: GO 36145
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35232: LD_VAR 0 3
35236: PPUSH
35237: LD_EXP 49
35241: PPUSH
35242: CALL 42999 0 2
35246: PUSH
35247: LD_VAR 0 3
35251: PPUSH
35252: LD_EXP 40
35256: PPUSH
35257: CALL 42999 0 2
35261: AND
35262: IFFALSE 35470
// begin for i = 1 to MREG_ToUpLab do
35264: LD_ADDR_VAR 0 2
35268: PUSH
35269: DOUBLE
35270: LD_INT 1
35272: DEC
35273: ST_TO_ADDR
35274: LD_EXP 49
35278: PUSH
35279: FOR_TO
35280: IFFALSE 35466
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35282: LD_EXP 49
35286: PUSH
35287: LD_VAR 0 2
35291: ARRAY
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PUSH
35297: LD_VAR 0 3
35301: EQUAL
35302: IFFALSE 35464
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35304: LD_EXP 49
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PUSH
35319: LD_EXP 49
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: PUSH
35330: LD_INT 3
35332: ARRAY
35333: AND
35334: IFFALSE 35462
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: LD_EXP 49
35345: PUSH
35346: LD_VAR 0 2
35350: ARRAY
35351: PUSH
35352: LD_INT 2
35354: ARRAY
35355: PPUSH
35356: LD_EXP 49
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 3
35369: ARRAY
35370: PPUSH
35371: CALL 8915 0 3
35375: IFFALSE 35462
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35377: LD_ADDR_EXP 49
35381: PUSH
35382: LD_EXP 49
35386: PPUSH
35387: LD_VAR 0 3
35391: PPUSH
35392: LD_EXP 49
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: PUSH
35403: LD_INT 2
35405: ARRAY
35406: PPUSH
35407: LD_EXP 49
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 3
35420: ARRAY
35421: PPUSH
35422: CALL 42051 0 4
35426: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35427: LD_ADDR_EXP 40
35431: PUSH
35432: LD_EXP 40
35436: PPUSH
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_EXP 40
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL 42051 0 4
35461: ST_TO_ADDR
// end ; break ;
35462: GO 35466
// end ;
35464: GO 35279
35466: POP
35467: POP
// end else
35468: GO 36145
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: LD_EXP 48
35479: PPUSH
35480: CALL 42999 0 2
35484: IFFALSE 35558
// begin for i = 1 to MREG_ToUpdate do
35486: LD_ADDR_VAR 0 2
35490: PUSH
35491: DOUBLE
35492: LD_INT 1
35494: DEC
35495: ST_TO_ADDR
35496: LD_EXP 48
35500: PUSH
35501: FOR_TO
35502: IFFALSE 35554
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35504: LD_EXP 48
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PUSH
35519: LD_VAR 0 3
35523: EQUAL
35524: IFFALSE 35552
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_EXP 48
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_INT 2
35544: ARRAY
35545: PPUSH
35546: CALL 8751 0 2
// break ;
35550: GO 35554
// end ;
35552: GO 35501
35554: POP
35555: POP
// end else
35556: GO 36145
// if MCF_Get ( side , [ f_constructed ] ) then
35558: LD_VAR 0 3
35562: PPUSH
35563: LD_INT 57
35565: PUSH
35566: EMPTY
35567: LIST
35568: PPUSH
35569: CALL 11651 0 2
35573: IFFALSE 35606
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_INT 57
35587: PUSH
35588: EMPTY
35589: LIST
35590: PPUSH
35591: CALL 11651 0 2
35595: PUSH
35596: LD_INT 1
35598: ARRAY
35599: PPUSH
35600: CALL 10995 0 2
35604: GO 36145
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_EXP 46
35615: PPUSH
35616: CALL 42999 0 2
35620: PUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 345
35630: NOT
35631: AND
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL 25006 0 1
35642: PUSH
35643: LD_INT 0
35645: EQUAL
35646: AND
35647: IFFALSE 36046
// begin for i = 1 to MREG_ToBuild do
35649: LD_ADDR_VAR 0 2
35653: PUSH
35654: DOUBLE
35655: LD_INT 1
35657: DEC
35658: ST_TO_ADDR
35659: LD_EXP 46
35663: PUSH
35664: FOR_TO
35665: IFFALSE 36042
// if MREG_ToBuild [ i ] [ 1 ] = side then
35667: LD_EXP 46
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 1
35680: ARRAY
35681: PUSH
35682: LD_VAR 0 3
35686: EQUAL
35687: IFFALSE 36040
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35689: LD_OWVAR 84
35693: PUSH
35694: LD_EXP 46
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 3
35707: ARRAY
35708: PUSH
35709: LD_INT 1
35711: ARRAY
35712: PPUSH
35713: LD_EXP 46
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PUSH
35728: LD_INT 2
35730: ARRAY
35731: PPUSH
35732: CALL_OW 351
35736: AND
35737: IFFALSE 35781
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35739: LD_EXP 46
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 46
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL 22799 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35781: LD_EXP 46
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 2
35794: ARRAY
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: IFFALSE 35869
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35801: LD_VAR 0 3
35805: PPUSH
35806: LD_EXP 46
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PUSH
35821: LD_INT 1
35823: ARRAY
35824: PPUSH
35825: LD_EXP 46
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 3
35838: ARRAY
35839: PUSH
35840: LD_INT 2
35842: ARRAY
35843: PPUSH
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 3
35857: ARRAY
35858: PUSH
35859: LD_INT 3
35861: ARRAY
35862: PPUSH
35863: CALL 8587 0 4
35867: GO 36038
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PUSH
35884: LD_INT 6
35886: EQUAL
35887: IFFALSE 35957
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35889: LD_VAR 0 3
35893: PPUSH
35894: LD_EXP 46
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 3
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PPUSH
35913: LD_EXP 46
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 3
35926: ARRAY
35927: PUSH
35928: LD_INT 2
35930: ARRAY
35931: PPUSH
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL 8716 0 4
35955: GO 36038
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35957: LD_VAR 0 3
35961: PPUSH
35962: LD_EXP 46
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 46
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PPUSH
35996: LD_EXP 46
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 2
36013: ARRAY
36014: PPUSH
36015: LD_EXP 46
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 3
36028: ARRAY
36029: PUSH
36030: LD_INT 3
36032: ARRAY
36033: PPUSH
36034: CALL 10220 0 5
// break ;
36038: GO 36042
// end ;
36040: GO 35664
36042: POP
36043: POP
// end else
36044: GO 36145
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36046: LD_VAR 0 3
36050: PPUSH
36051: LD_EXP 52
36055: PPUSH
36056: CALL 42999 0 2
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL 25006 0 1
36070: PUSH
36071: LD_INT 0
36073: EQUAL
36074: AND
36075: IFFALSE 36145
// begin for i = 1 to MREG_ToDismantle do
36077: LD_ADDR_VAR 0 2
36081: PUSH
36082: DOUBLE
36083: LD_INT 1
36085: DEC
36086: ST_TO_ADDR
36087: LD_EXP 52
36091: PUSH
36092: FOR_TO
36093: IFFALSE 36143
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36095: LD_EXP 52
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PUSH
36106: LD_INT 1
36108: ARRAY
36109: PUSH
36110: LD_VAR 0 3
36114: EQUAL
36115: IFFALSE 36141
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36117: LD_VAR 0 3
36121: PPUSH
36122: LD_EXP 52
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: CALL 10886 0 2
// end ;
36141: GO 36092
36143: POP
36144: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36145: LD_VAR 0 3
36149: PPUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PPUSH
36160: CALL 11651 0 2
36164: PUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL 25006 0 1
36174: PUSH
36175: LD_INT 0
36177: EQUAL
36178: AND
36179: IFFALSE 36190
// MCT_CollectCrates ( side ) ;
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 23945 0 1
// end ;
36190: GO 34191
36192: POP
36193: POP
// end ;
36194: LD_VAR 0 1
36198: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36199: LD_INT 0
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
// all := MCF_All ( side , [ ] ) ;
36216: LD_ADDR_VAR 0 17
36220: PUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL 11786 0 2
36232: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36233: LD_ADDR_VAR 0 13
36237: PUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_INT 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL 11734 0 3
36252: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36253: LD_ADDR_VAR 0 14
36257: PUSH
36258: LD_VAR 0 1
36262: PPUSH
36263: LD_INT 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL 11734 0 3
36272: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36273: LD_ADDR_VAR 0 15
36277: PUSH
36278: LD_VAR 0 1
36282: PPUSH
36283: LD_INT 3
36285: PPUSH
36286: EMPTY
36287: PPUSH
36288: CALL 11734 0 3
36292: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36293: LD_ADDR_VAR 0 16
36297: PUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_INT 4
36305: PPUSH
36306: EMPTY
36307: PPUSH
36308: CALL 11734 0 3
36312: ST_TO_ADDR
// if mech then
36313: LD_VAR 0 15
36317: IFFALSE 36334
// mech := MCF_SortListDesc ( mech ) ;
36319: LD_ADDR_VAR 0 15
36323: PUSH
36324: LD_VAR 0 15
36328: PPUSH
36329: CALL 12900 0 1
36333: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36334: LD_EXP 56
36338: PUSH
36339: LD_VAR 0 1
36343: ARRAY
36344: PUSH
36345: LD_STRING 
36347: EQUAL
36348: NOT
36349: IFFALSE 36405
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36351: LD_EXP 56
36355: PUSH
36356: LD_VAR 0 1
36360: ARRAY
36361: PUSH
36362: LD_INT 1
36364: ARRAY
36365: PPUSH
36366: CALL_OW 257
36370: PUSH
36371: LD_INT 1
36373: EQUAL
36374: IFFALSE 36403
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36376: LD_VAR 0 1
36380: PPUSH
36381: LD_STRING ToArm
36383: PPUSH
36384: LD_EXP 56
36388: PUSH
36389: LD_VAR 0 1
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL 14530 0 3
// end else
36403: GO 36431
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36405: LD_ADDR_EXP 56
36409: PUSH
36410: LD_EXP 56
36414: PPUSH
36415: LD_VAR 0 1
36419: PPUSH
36420: LD_INT 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL 31130 0 4
36430: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36431: LD_EXP 57
36435: PUSH
36436: LD_VAR 0 1
36440: ARRAY
36441: PUSH
36442: LD_STRING 
36444: EQUAL
36445: NOT
36446: IFFALSE 36502
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36448: LD_EXP 57
36452: PUSH
36453: LD_VAR 0 1
36457: ARRAY
36458: PUSH
36459: LD_INT 1
36461: ARRAY
36462: PPUSH
36463: CALL_OW 257
36467: PUSH
36468: LD_INT 2
36470: EQUAL
36471: IFFALSE 36500
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36473: LD_VAR 0 1
36477: PPUSH
36478: LD_STRING ToDep
36480: PPUSH
36481: LD_EXP 57
36485: PUSH
36486: LD_VAR 0 1
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: CALL 14530 0 3
// end else
36500: GO 36528
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36502: LD_ADDR_EXP 57
36506: PUSH
36507: LD_EXP 57
36511: PPUSH
36512: LD_VAR 0 1
36516: PPUSH
36517: LD_INT 1
36519: PPUSH
36520: LD_INT 0
36522: PPUSH
36523: CALL 31130 0 4
36527: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36528: LD_EXP 55
36532: PUSH
36533: LD_VAR 0 1
36537: ARRAY
36538: PUSH
36539: LD_STRING 
36541: EQUAL
36542: NOT
36543: IFFALSE 36599
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36545: LD_EXP 55
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: EQUAL
36568: IFFALSE 36597
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: LD_STRING ToFac
36577: PPUSH
36578: LD_EXP 55
36582: PUSH
36583: LD_VAR 0 1
36587: ARRAY
36588: PUSH
36589: LD_INT 1
36591: ARRAY
36592: PPUSH
36593: CALL 14530 0 3
// end else
36597: GO 36625
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36599: LD_ADDR_EXP 55
36603: PUSH
36604: LD_EXP 55
36608: PPUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: LD_INT 0
36619: PPUSH
36620: CALL 31130 0 4
36624: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36625: LD_EXP 54
36629: PUSH
36630: LD_VAR 0 1
36634: ARRAY
36635: PUSH
36636: LD_STRING 
36638: EQUAL
36639: NOT
36640: IFFALSE 36696
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36642: LD_EXP 54
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL_OW 257
36661: PUSH
36662: LD_INT 4
36664: EQUAL
36665: IFFALSE 36694
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36667: LD_VAR 0 1
36671: PPUSH
36672: LD_STRING ToLab
36674: PPUSH
36675: LD_EXP 54
36679: PUSH
36680: LD_VAR 0 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: CALL 14530 0 3
// end else
36694: GO 36722
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36696: LD_ADDR_EXP 54
36700: PUSH
36701: LD_EXP 54
36705: PPUSH
36706: LD_VAR 0 1
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: LD_INT 0
36716: PPUSH
36717: CALL 31130 0 4
36721: ST_TO_ADDR
// if mode = 0 then
36722: LD_VAR 0 2
36726: PUSH
36727: LD_INT 0
36729: EQUAL
36730: IFFALSE 38568
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36732: LD_VAR 0 1
36736: PPUSH
36737: LD_INT 30
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL 11651 0 2
36751: PUSH
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 21
36759: PUSH
36760: LD_INT 3
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PPUSH
36767: CALL 11651 0 2
36771: PUSH
36772: LD_INT 1
36774: EQUAL
36775: AND
36776: IFFALSE 36841
// begin if all then
36778: LD_VAR 0 17
36782: IFFALSE 36839
// for i in ( all diff eng ) do
36784: LD_ADDR_VAR 0 4
36788: PUSH
36789: LD_VAR 0 17
36793: PUSH
36794: LD_VAR 0 14
36798: DIFF
36799: PUSH
36800: FOR_IN
36801: IFFALSE 36837
// if GetTag ( i ) = 0 then
36803: LD_VAR 0 4
36807: PPUSH
36808: CALL_OW 110
36812: PUSH
36813: LD_INT 0
36815: EQUAL
36816: IFFALSE 36835
// MCH_ChangeClass ( side , i , 2 ) ;
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 2
36830: PPUSH
36831: CALL 16558 0 3
36835: GO 36800
36837: POP
36838: POP
// end else
36839: GO 37160
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36841: LD_VAR 0 13
36845: PUSH
36846: LD_EXP 56
36850: PUSH
36851: LD_VAR 0 1
36855: ARRAY
36856: PLUS
36857: PUSH
36858: LD_INT 22
36860: PUSH
36861: LD_VAR 0 1
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 32
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 69
36888: LESS
36889: IFFALSE 36914
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_VAR 0 14
36900: PUSH
36901: LD_INT 1
36903: ARRAY
36904: PPUSH
36905: LD_INT 1
36907: PPUSH
36908: CALL 16558 0 3
// end else
36912: GO 37160
// if sci < 6 and MCF_Lab ( side ) then
36914: LD_VAR 0 16
36918: PUSH
36919: LD_INT 6
36921: LESS
36922: PUSH
36923: LD_VAR 0 1
36927: PPUSH
36928: CALL 11690 0 1
36932: AND
36933: IFFALSE 37038
// begin if MREG_ToBunker [ side ] then
36935: LD_EXP 68
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: IFFALSE 36971
// tmp := sol diff MREG_ToBunker [ side ] else
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: PUSH
36957: LD_EXP 68
36961: PUSH
36962: LD_VAR 0 1
36966: ARRAY
36967: DIFF
36968: ST_TO_ADDR
36969: GO 36981
// tmp := sol ;
36971: LD_ADDR_VAR 0 12
36975: PUSH
36976: LD_VAR 0 13
36980: ST_TO_ADDR
// if tmp then
36981: LD_VAR 0 12
36985: IFFALSE 37036
// for i in tmp do
36987: LD_ADDR_VAR 0 4
36991: PUSH
36992: LD_VAR 0 12
36996: PUSH
36997: FOR_IN
36998: IFFALSE 37034
// if GetTag ( i ) = 0 then
37000: LD_VAR 0 4
37004: PPUSH
37005: CALL_OW 110
37009: PUSH
37010: LD_INT 0
37012: EQUAL
37013: IFFALSE 37032
// MCH_ChangeClass ( side , i , 4 ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: LD_INT 4
37027: PPUSH
37028: CALL 16558 0 3
37032: GO 36997
37034: POP
37035: POP
// end else
37036: GO 37160
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37038: LD_VAR 0 1
37042: PPUSH
37043: LD_INT 30
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL 11651 0 2
37057: IFFALSE 37160
// begin if MREG_ToBunker [ side ] then
37059: LD_EXP 68
37063: PUSH
37064: LD_VAR 0 1
37068: ARRAY
37069: IFFALSE 37095
// tmp := sol diff MREG_ToBunker [ side ] else
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: PUSH
37081: LD_EXP 68
37085: PUSH
37086: LD_VAR 0 1
37090: ARRAY
37091: DIFF
37092: ST_TO_ADDR
37093: GO 37105
// tmp := sol ;
37095: LD_ADDR_VAR 0 12
37099: PUSH
37100: LD_VAR 0 13
37104: ST_TO_ADDR
// if tmp then
37105: LD_VAR 0 12
37109: IFFALSE 37160
// for i in tmp do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 12
37120: PUSH
37121: FOR_IN
37122: IFFALSE 37158
// if GetTag ( i ) = 0 then
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL_OW 110
37133: PUSH
37134: LD_INT 0
37136: EQUAL
37137: IFFALSE 37156
// MCH_ChangeClass ( side , i , 2 ) ;
37139: LD_VAR 0 1
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: LD_INT 2
37151: PPUSH
37152: CALL 16558 0 3
37156: GO 37121
37158: POP
37159: POP
// end ; if MCF_Lab ( side ) then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL 11690 0 1
37169: IFFALSE 37709
// begin if MCL_GetTechList ( side ) then
37171: LD_VAR 0 1
37175: PPUSH
37176: CALL 18034 0 1
37180: IFFALSE 37306
// begin if MREG_ToLab [ side ] then
37182: LD_EXP 54
37186: PUSH
37187: LD_VAR 0 1
37191: ARRAY
37192: IFFALSE 37212
// k := MREG_ToLab [ side ] else
37194: LD_ADDR_VAR 0 8
37198: PUSH
37199: LD_EXP 54
37203: PUSH
37204: LD_VAR 0 1
37208: ARRAY
37209: ST_TO_ADDR
37210: GO 37220
// k := 0 ;
37212: LD_ADDR_VAR 0 8
37216: PUSH
37217: LD_INT 0
37219: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37220: LD_VAR 0 16
37224: PUSH
37225: LD_VAR 0 8
37229: PLUS
37230: PUSH
37231: LD_INT 6
37233: LESSEQUAL
37234: PUSH
37235: LD_VAR 0 17
37239: PUSH
37240: LD_INT 6
37242: GREATER
37243: AND
37244: IFFALSE 37260
// MCH_TrainScientist ( side , 1 ) else
37246: LD_VAR 0 1
37250: PPUSH
37251: LD_INT 1
37253: PPUSH
37254: CALL 16110 0 2
37258: GO 37304
// if all < 6 then
37260: LD_VAR 0 17
37264: PUSH
37265: LD_INT 6
37267: LESS
37268: IFFALSE 37304
// if sci + k < all / 2 then
37270: LD_VAR 0 16
37274: PUSH
37275: LD_VAR 0 8
37279: PLUS
37280: PUSH
37281: LD_VAR 0 17
37285: PUSH
37286: LD_INT 2
37288: DIVREAL
37289: LESS
37290: IFFALSE 37304
// MCH_TrainScientist ( side , 1 ) ;
37292: LD_VAR 0 1
37296: PPUSH
37297: LD_INT 1
37299: PPUSH
37300: CALL 16110 0 2
// end else
37304: GO 37382
// begin if sci > 2 then
37306: LD_VAR 0 16
37310: PUSH
37311: LD_INT 2
37313: GREATER
37314: IFFALSE 37382
// for i = sci downto 2 do
37316: LD_ADDR_VAR 0 4
37320: PUSH
37321: DOUBLE
37322: LD_VAR 0 16
37326: INC
37327: ST_TO_ADDR
37328: LD_INT 2
37330: PUSH
37331: FOR_DOWNTO
37332: IFFALSE 37380
// if GetTag ( sci [ i ] ) = 0 then
37334: LD_VAR 0 16
37338: PUSH
37339: LD_VAR 0 4
37343: ARRAY
37344: PPUSH
37345: CALL_OW 110
37349: PUSH
37350: LD_INT 0
37352: EQUAL
37353: IFFALSE 37378
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_VAR 0 16
37364: PUSH
37365: LD_VAR 0 4
37369: ARRAY
37370: PPUSH
37371: LD_INT 2
37373: PPUSH
37374: CALL 16558 0 3
37378: GO 37331
37380: POP
37381: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37382: LD_VAR 0 1
37386: PPUSH
37387: CALL 18034 0 1
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL 11690 0 1
37401: AND
37402: PUSH
37403: LD_EXP 35
37407: PUSH
37408: LD_VAR 0 1
37412: ARRAY
37413: NOT
37414: AND
37415: IFFALSE 37709
// begin for j = 1 to MCF_Lab ( side ) do
37417: LD_ADDR_VAR 0 5
37421: PUSH
37422: DOUBLE
37423: LD_INT 1
37425: DEC
37426: ST_TO_ADDR
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 11690 0 1
37436: PUSH
37437: FOR_TO
37438: IFFALSE 37498
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37440: LD_VAR 0 1
37444: PPUSH
37445: CALL 11690 0 1
37449: PUSH
37450: LD_VAR 0 5
37454: ARRAY
37455: PPUSH
37456: CALL_OW 461
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 6
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: IN
37471: IFFALSE 37496
// begin b := MCF_Lab ( side ) [ j ] ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: CALL 11690 0 1
37487: PUSH
37488: LD_VAR 0 5
37492: ARRAY
37493: ST_TO_ADDR
// break ;
37494: GO 37498
// end ;
37496: GO 37437
37498: POP
37499: POP
// if MCF_Class ( side , 4 , [ ] ) then
37500: LD_VAR 0 1
37504: PPUSH
37505: LD_INT 4
37507: PPUSH
37508: EMPTY
37509: PPUSH
37510: CALL 11734 0 3
37514: IFFALSE 37709
// for j in MCF_Class ( side , 4 , [ ] ) do
37516: LD_ADDR_VAR 0 5
37520: PUSH
37521: LD_VAR 0 1
37525: PPUSH
37526: LD_INT 4
37528: PPUSH
37529: EMPTY
37530: PPUSH
37531: CALL 11734 0 3
37535: PUSH
37536: FOR_IN
37537: IFFALSE 37707
// begin if GetTag ( j ) = 0 then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 110
37548: PUSH
37549: LD_INT 0
37551: EQUAL
37552: IFFALSE 37643
// begin if IsInUnit ( j ) and b then
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 310
37563: PUSH
37564: LD_VAR 0 11
37568: AND
37569: IFFALSE 37617
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37571: LD_VAR 0 5
37575: PPUSH
37576: CALL_OW 310
37580: PPUSH
37581: CALL_OW 461
37585: PUSH
37586: LD_INT 2
37588: EQUAL
37589: PUSH
37590: LD_VAR 0 5
37594: PPUSH
37595: CALL_OW 310
37599: PUSH
37600: LD_VAR 0 11
37604: NONEQUAL
37605: AND
37606: IFFALSE 37617
// ComExitBuilding ( j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 122
// if not IsInUnit ( j ) then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: NOT
37627: IFFALSE 37643
// ComEnterUnit ( j , b ) ;
37629: LD_VAR 0 5
37633: PPUSH
37634: LD_VAR 0 11
37638: PPUSH
37639: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37643: LD_INT 1
37645: PPUSH
37646: LD_VAR 0 5
37650: PPUSH
37651: CALL_OW 255
37655: PPUSH
37656: CALL_OW 321
37660: PUSH
37661: LD_INT 2
37663: EQUAL
37664: PUSH
37665: LD_VAR 0 5
37669: PPUSH
37670: CALL_OW 255
37674: PPUSH
37675: CALL 25006 0 1
37679: PUSH
37680: LD_INT 0
37682: EQUAL
37683: AND
37684: IFFALSE 37705
// MCN_Tame ( GetSide ( j ) , j ) ;
37686: LD_VAR 0 5
37690: PPUSH
37691: CALL_OW 255
37695: PPUSH
37696: LD_VAR 0 5
37700: PPUSH
37701: CALL 18553 0 2
// end ;
37705: GO 37536
37707: POP
37708: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37709: LD_VAR 0 1
37713: PPUSH
37714: LD_INT 30
37716: PUSH
37717: LD_INT 3
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PPUSH
37724: CALL 11651 0 2
37728: IFFALSE 37987
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37730: LD_ADDR_VAR 0 11
37734: PUSH
37735: LD_VAR 0 1
37739: PPUSH
37740: LD_INT 30
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PPUSH
37750: CALL 11651 0 2
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37759: LD_ADDR_VAR 0 12
37763: PUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: LD_INT 0
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 3
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL 12354 0 3
37786: ST_TO_ADDR
// for i = 1 to tmp do
37787: LD_ADDR_VAR 0 4
37791: PUSH
37792: DOUBLE
37793: LD_INT 1
37795: DEC
37796: ST_TO_ADDR
37797: LD_VAR 0 12
37801: PUSH
37802: FOR_TO
37803: IFFALSE 37863
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37805: LD_VAR 0 12
37809: PUSH
37810: LD_VAR 0 4
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: NOT
37821: PUSH
37822: LD_VAR 0 12
37826: PUSH
37827: LD_VAR 0 4
37831: ARRAY
37832: PPUSH
37833: CALL_OW 314
37837: NOT
37838: AND
37839: IFFALSE 37861
// ComEnterUnit ( tmp [ i ] , b ) ;
37841: LD_VAR 0 12
37845: PUSH
37846: LD_VAR 0 4
37850: ARRAY
37851: PPUSH
37852: LD_VAR 0 11
37856: PPUSH
37857: CALL_OW 120
37861: GO 37802
37863: POP
37864: POP
// if MREG_ToFac [ side ] then
37865: LD_EXP 55
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: IFFALSE 37895
// k := MREG_ToFac [ side ] else
37877: LD_ADDR_VAR 0 8
37881: PUSH
37882: LD_EXP 55
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: ST_TO_ADDR
37893: GO 37903
// k := 0 ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_INT 0
37902: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37903: LD_VAR 0 15
37907: PUSH
37908: LD_VAR 0 8
37912: PLUS
37913: PUSH
37914: LD_INT 6
37916: LESSEQUAL
37917: PUSH
37918: LD_VAR 0 17
37922: PUSH
37923: LD_INT 6
37925: GREATER
37926: AND
37927: IFFALSE 37943
// MCH_TrainMechanic ( side , 1 ) else
37929: LD_VAR 0 1
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL 15852 0 2
37941: GO 37987
// if all < 6 then
37943: LD_VAR 0 17
37947: PUSH
37948: LD_INT 6
37950: LESS
37951: IFFALSE 37987
// if mech + k < all / 2 then
37953: LD_VAR 0 15
37957: PUSH
37958: LD_VAR 0 8
37962: PLUS
37963: PUSH
37964: LD_VAR 0 17
37968: PUSH
37969: LD_INT 2
37971: DIVREAL
37972: LESS
37973: IFFALSE 37987
// MCH_TrainMechanic ( side , 1 ) ;
37975: LD_VAR 0 1
37979: PPUSH
37980: LD_INT 1
37982: PPUSH
37983: CALL 15852 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37987: LD_ADDR_VAR 0 10
37991: PUSH
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 30
37999: PUSH
38000: LD_INT 36
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL 11651 0 2
38011: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38012: LD_VAR 0 10
38016: PUSH
38017: LD_VAR 0 15
38021: AND
38022: PUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 3
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL 11734 0 3
38037: AND
38038: IFFALSE 38196
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38040: LD_VAR 0 1
38044: PPUSH
38045: LD_INT 9
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL 12354 0 3
38054: PUSH
38055: LD_INT 3
38057: LESS
38058: IFFALSE 38196
// begin if mech < 3 then
38060: LD_VAR 0 15
38064: PUSH
38065: LD_INT 3
38067: LESS
38068: IFFALSE 38082
// k := mech else
38070: LD_ADDR_VAR 0 8
38074: PUSH
38075: LD_VAR 0 15
38079: ST_TO_ADDR
38080: GO 38090
// k := 3 ;
38082: LD_ADDR_VAR 0 8
38086: PUSH
38087: LD_INT 3
38089: ST_TO_ADDR
// for j = 1 to k do
38090: LD_ADDR_VAR 0 5
38094: PUSH
38095: DOUBLE
38096: LD_INT 1
38098: DEC
38099: ST_TO_ADDR
38100: LD_VAR 0 8
38104: PUSH
38105: FOR_TO
38106: IFFALSE 38164
// if GetClass ( mech [ j ] ) = 3 then
38108: LD_VAR 0 15
38112: PUSH
38113: LD_VAR 0 5
38117: ARRAY
38118: PPUSH
38119: CALL_OW 257
38123: PUSH
38124: LD_INT 3
38126: EQUAL
38127: IFFALSE 38162
// begin SetTag ( mech [ j ] , 9 ) ;
38129: LD_VAR 0 15
38133: PUSH
38134: LD_VAR 0 5
38138: ARRAY
38139: PPUSH
38140: LD_INT 9
38142: PPUSH
38143: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38147: LD_VAR 0 15
38151: PUSH
38152: LD_VAR 0 5
38156: ARRAY
38157: PPUSH
38158: CALL_OW 122
// end ;
38162: GO 38105
38164: POP
38165: POP
// if mech < 6 + k then
38166: LD_VAR 0 15
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_VAR 0 8
38178: PLUS
38179: LESS
38180: IFFALSE 38196
// MCH_TrainMechanic ( side , k ) ;
38182: LD_VAR 0 1
38186: PPUSH
38187: LD_VAR 0 8
38191: PPUSH
38192: CALL 15852 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38196: LD_VAR 0 1
38200: PPUSH
38201: LD_INT 9
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL 12354 0 3
38210: IFFALSE 38301
// for j in MCF_Tag ( side , 9 , [ ] ) do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_VAR 0 1
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL 12354 0 3
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38299
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38235: LD_VAR 0 5
38239: PPUSH
38240: CALL_OW 310
38244: NOT
38245: PUSH
38246: LD_VAR 0 5
38250: PPUSH
38251: CALL 99100 0 1
38255: NOT
38256: AND
38257: IFFALSE 38297
// if ct then
38259: LD_VAR 0 10
38263: IFFALSE 38285
// ComEnterUnit ( j , ct [ 1 ] ) else
38265: LD_VAR 0 5
38269: PPUSH
38270: LD_VAR 0 10
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: PPUSH
38279: CALL_OW 120
38283: GO 38297
// SetTag ( j , 0 ) ;
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_INT 0
38292: PPUSH
38293: CALL_OW 109
38297: GO 38232
38299: POP
38300: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38301: LD_INT 1
38303: PPUSH
38304: LD_VAR 0 1
38308: PPUSH
38309: CALL_OW 321
38313: PUSH
38314: LD_INT 2
38316: EQUAL
38317: PUSH
38318: LD_EXP 35
38322: PUSH
38323: LD_VAR 0 1
38327: ARRAY
38328: NOT
38329: AND
38330: PUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: LD_INT 4
38338: PPUSH
38339: EMPTY
38340: PPUSH
38341: CALL 11734 0 3
38345: AND
38346: IFFALSE 38394
// for j in MCF_Class ( side , 4 , [ ] ) do
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: LD_INT 4
38360: PPUSH
38361: EMPTY
38362: PPUSH
38363: CALL 11734 0 3
38367: PUSH
38368: FOR_IN
38369: IFFALSE 38392
// MCN_Tame ( GetSide ( j ) , j ) ;
38371: LD_VAR 0 5
38375: PPUSH
38376: CALL_OW 255
38380: PPUSH
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL 18553 0 2
38390: GO 38368
38392: POP
38393: POP
// if MREG_DefVeh [ side ] then
38394: LD_EXP 67
38398: PUSH
38399: LD_VAR 0 1
38403: ARRAY
38404: IFFALSE 38568
// begin for i in MREG_DefVeh [ side ] do
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 67
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: PUSH
38422: FOR_IN
38423: IFFALSE 38476
// begin SetTag ( i , 0 ) ;
38425: LD_VAR 0 4
38429: PPUSH
38430: LD_INT 0
38432: PPUSH
38433: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38437: LD_VAR 0 4
38441: PPUSH
38442: LD_EXP 64
38446: PUSH
38447: LD_VAR 0 1
38451: ARRAY
38452: PPUSH
38453: CALL_OW 308
38457: NOT
38458: IFFALSE 38474
// MCV_Parking ( side , i ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: CALL 25741 0 2
// end ;
38474: GO 38422
38476: POP
38477: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38478: LD_VAR 0 1
38482: PPUSH
38483: LD_INT 36
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL 12354 0 3
38492: IFFALSE 38533
// for i in MCF_Tag ( side , 36 , [ ] ) do
38494: LD_ADDR_VAR 0 4
38498: PUSH
38499: LD_VAR 0 1
38503: PPUSH
38504: LD_INT 36
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL 12354 0 3
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38531
// SetTag ( i , 0 ) ;
38517: LD_VAR 0 4
38521: PPUSH
38522: LD_INT 0
38524: PPUSH
38525: CALL_OW 109
38529: GO 38514
38531: POP
38532: POP
// if MREG_DefMobActive [ side ] then
38533: LD_EXP 70
38537: PUSH
38538: LD_VAR 0 1
38542: ARRAY
38543: IFFALSE 38568
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38545: LD_ADDR_EXP 70
38549: PUSH
38550: LD_EXP 70
38554: PPUSH
38555: LD_VAR 0 1
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// end ; end ; if mode > 0 then
38568: LD_VAR 0 2
38572: PUSH
38573: LD_INT 0
38575: GREATER
38576: IFFALSE 40471
// begin if tick <= 15 15$00 then
38578: LD_OWVAR 1
38582: PUSH
38583: LD_INT 31500
38585: LESSEQUAL
38586: IFFALSE 38890
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38588: LD_VAR 0 13
38592: PUSH
38593: LD_VAR 0 1
38597: PPUSH
38598: CALL 25006 0 1
38602: PUSH
38603: LD_INT 4
38605: LESS
38606: AND
38607: IFFALSE 38718
// begin for i in sol do
38609: LD_ADDR_VAR 0 4
38613: PUSH
38614: LD_VAR 0 13
38618: PUSH
38619: FOR_IN
38620: IFFALSE 38716
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38622: LD_ADDR_VAR 0 8
38626: PUSH
38627: LD_VAR 0 1
38631: PPUSH
38632: CALL 25006 0 1
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: CALL_OW 74
38646: ST_TO_ADDR
// if IsInUnit ( i ) then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 310
38656: IFFALSE 38667
// ComExitBuilding ( i ) ;
38658: LD_VAR 0 4
38662: PPUSH
38663: CALL_OW 122
// if not HasTask ( i ) and k then
38667: LD_VAR 0 4
38671: PPUSH
38672: CALL_OW 314
38676: NOT
38677: PUSH
38678: LD_VAR 0 8
38682: AND
38683: IFFALSE 38714
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38685: LD_VAR 0 4
38689: PPUSH
38690: LD_VAR 0 8
38694: PPUSH
38695: CALL_OW 250
38699: PPUSH
38700: LD_VAR 0 8
38704: PPUSH
38705: CALL_OW 251
38709: PPUSH
38710: CALL_OW 174
// end ;
38714: GO 38619
38716: POP
38717: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38718: LD_VAR 0 1
38722: PPUSH
38723: LD_INT 30
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PPUSH
38733: CALL 11651 0 2
38737: IFFALSE 38888
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38739: LD_ADDR_VAR 0 11
38743: PUSH
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 30
38751: PUSH
38752: LD_INT 5
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL 11651 0 2
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: ST_TO_ADDR
// if mech then
38768: LD_VAR 0 15
38772: IFFALSE 38808
// for i in mech do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 15
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38806
// MCH_ChangeClass ( side , i , 1 ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: CALL 16558 0 3
38804: GO 38784
38806: POP
38807: POP
// if eng > 1 then
38808: LD_VAR 0 14
38812: PUSH
38813: LD_INT 1
38815: GREATER
38816: IFFALSE 38863
// for i = eng downto 2 do
38818: LD_ADDR_VAR 0 4
38822: PUSH
38823: DOUBLE
38824: LD_VAR 0 14
38828: INC
38829: ST_TO_ADDR
38830: LD_INT 2
38832: PUSH
38833: FOR_DOWNTO
38834: IFFALSE 38861
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 14
38845: PUSH
38846: LD_VAR 0 4
38850: ARRAY
38851: PPUSH
38852: LD_INT 1
38854: PPUSH
38855: CALL 16558 0 3
38859: GO 38833
38861: POP
38862: POP
// if UnitsInside ( b ) then
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: IFFALSE 38888
// ComExitBuilding ( UnitsInside ( b ) ) ;
38874: LD_VAR 0 11
38878: PPUSH
38879: CALL_OW 313
38883: PPUSH
38884: CALL_OW 122
// end ; end else
38888: GO 40471
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38890: LD_VAR 0 1
38894: PPUSH
38895: LD_INT 1
38897: PPUSH
38898: LD_EXP 65
38902: PUSH
38903: LD_VAR 0 1
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: PPUSH
38913: CALL 33743 0 3
38917: IFFALSE 39056
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38919: LD_ADDR_VAR 0 12
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: LD_INT 21
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL 11651 0 2
38943: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38944: LD_ADDR_VAR 0 11
38948: PUSH
38949: LD_VAR 0 1
38953: PPUSH
38954: LD_INT 30
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL 11651 0 2
38968: ST_TO_ADDR
// if b then
38969: LD_VAR 0 11
38973: IFFALSE 39056
// for i in tmp do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 12
38984: PUSH
38985: FOR_IN
38986: IFFALSE 39054
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38988: LD_VAR 0 4
38992: PPUSH
38993: LD_EXP 65
38997: PUSH
38998: LD_VAR 0 1
39002: ARRAY
39003: PUSH
39004: LD_INT 1
39006: ARRAY
39007: PPUSH
39008: CALL_OW 308
39012: NOT
39013: IFFALSE 39052
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39015: LD_VAR 0 4
39019: PPUSH
39020: LD_VAR 0 11
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 250
39033: PPUSH
39034: LD_VAR 0 11
39038: PUSH
39039: LD_INT 1
39041: ARRAY
39042: PPUSH
39043: CALL_OW 251
39047: PPUSH
39048: CALL_OW 111
39052: GO 38985
39054: POP
39055: POP
// end ; if MREG_DefVeh [ side ] then
39056: LD_EXP 67
39060: PUSH
39061: LD_VAR 0 1
39065: ARRAY
39066: IFFALSE 39634
// begin tmp := [ ] ;
39068: LD_ADDR_VAR 0 12
39072: PUSH
39073: EMPTY
39074: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39075: LD_EXP 70
39079: PUSH
39080: LD_VAR 0 1
39084: ARRAY
39085: PUSH
39086: LD_INT 0
39088: EQUAL
39089: IFFALSE 39229
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39091: LD_ADDR_VAR 0 8
39095: PUSH
39096: LD_VAR 0 1
39100: PPUSH
39101: LD_INT 0
39103: PPUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 3
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL 12354 0 3
39118: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39119: LD_VAR 0 8
39123: PUSH
39124: LD_EXP 67
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: GREATER
39135: IFFALSE 39196
// begin for i = 1 to MREG_DefVeh [ side ] do
39137: LD_ADDR_VAR 0 4
39141: PUSH
39142: DOUBLE
39143: LD_INT 1
39145: DEC
39146: ST_TO_ADDR
39147: LD_EXP 67
39151: PUSH
39152: LD_VAR 0 1
39156: ARRAY
39157: PUSH
39158: FOR_TO
39159: IFFALSE 39192
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39161: LD_ADDR_VAR 0 12
39165: PUSH
39166: LD_VAR 0 12
39170: PPUSH
39171: LD_INT 1
39173: PPUSH
39174: LD_VAR 0 8
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PPUSH
39185: CALL_OW 2
39189: ST_TO_ADDR
39190: GO 39158
39192: POP
39193: POP
// end else
39194: GO 39206
// tmp := k ;
39196: LD_ADDR_VAR 0 12
39200: PUSH
39201: LD_VAR 0 8
39205: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39206: LD_ADDR_EXP 70
39210: PUSH
39211: LD_EXP 70
39215: PPUSH
39216: LD_VAR 0 1
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39229: LD_ADDR_VAR 0 4
39233: PUSH
39234: LD_EXP 67
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: PUSH
39245: FOR_IN
39246: IFFALSE 39632
// begin if not GetDriver ( i ) then
39248: LD_VAR 0 4
39252: PPUSH
39253: CALL 31773 0 1
39257: NOT
39258: IFFALSE 39333
// begin if tmp then
39260: LD_VAR 0 12
39264: IFFALSE 39331
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39266: LD_VAR 0 12
39270: PUSH
39271: LD_INT 1
39273: ARRAY
39274: PPUSH
39275: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39279: LD_VAR 0 12
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: LD_VAR 0 4
39292: PPUSH
39293: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39297: LD_VAR 0 12
39301: PUSH
39302: LD_INT 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 36
39308: PPUSH
39309: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39313: LD_ADDR_VAR 0 12
39317: PUSH
39318: LD_VAR 0 12
39322: PPUSH
39323: LD_INT 1
39325: PPUSH
39326: CALL_OW 3
39330: ST_TO_ADDR
// end ; end else
39331: GO 39630
// begin if GetTag ( i ) = 0 then
39333: LD_VAR 0 4
39337: PPUSH
39338: CALL_OW 110
39342: PUSH
39343: LD_INT 0
39345: EQUAL
39346: IFFALSE 39362
// SetTag ( i , 31 ) else
39348: LD_VAR 0 4
39352: PPUSH
39353: LD_INT 31
39355: PPUSH
39356: CALL_OW 109
39360: GO 39630
// if GetTag ( i ) = 31 then
39362: LD_VAR 0 4
39366: PPUSH
39367: CALL_OW 110
39371: PUSH
39372: LD_INT 31
39374: EQUAL
39375: IFFALSE 39630
// begin if GetFuel ( i ) < 20 then
39377: LD_VAR 0 4
39381: PPUSH
39382: CALL_OW 261
39386: PUSH
39387: LD_INT 20
39389: LESS
39390: IFFALSE 39415
// begin SetTag ( i , 21 ) ;
39392: LD_VAR 0 4
39396: PPUSH
39397: LD_INT 21
39399: PPUSH
39400: CALL_OW 109
// MCV_Refuel ( i ) ;
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL 26278 0 1
// continue ;
39413: GO 39245
// end ; if GetLives ( i ) < 700 then
39415: LD_VAR 0 4
39419: PPUSH
39420: CALL_OW 256
39424: PUSH
39425: LD_INT 700
39427: LESS
39428: IFFALSE 39540
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39430: LD_VAR 0 4
39434: PPUSH
39435: LD_EXP 58
39439: PUSH
39440: LD_VAR 0 1
39444: ARRAY
39445: PPUSH
39446: CALL_OW 308
39450: NOT
39451: IFFALSE 39475
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39453: LD_VAR 0 4
39457: PPUSH
39458: LD_EXP 58
39462: PUSH
39463: LD_VAR 0 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 113
39473: GO 39538
// if GetDriver ( i ) then
39475: LD_VAR 0 4
39479: PPUSH
39480: CALL 31773 0 1
39484: IFFALSE 39538
// begin k := GetDriver ( i ) ;
39486: LD_ADDR_VAR 0 8
39490: PUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31773 0 1
39500: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39501: LD_VAR 0 8
39505: PPUSH
39506: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39510: LD_VAR 0 8
39514: PPUSH
39515: LD_VAR 0 4
39519: PPUSH
39520: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39524: LD_VAR 0 8
39528: PPUSH
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL_OW 180
// end ; end else
39538: GO 39630
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39540: LD_ADDR_VAR 0 8
39544: PUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: CALL 25006 0 1
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: CALL_OW 74
39564: ST_TO_ADDR
// if k then
39565: LD_VAR 0 8
39569: IFFALSE 39587
// ComAttackUnit ( i , k ) else
39571: LD_VAR 0 4
39575: PPUSH
39576: LD_VAR 0 8
39580: PPUSH
39581: CALL_OW 115
39585: GO 39630
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_EXP 58
39596: PUSH
39597: LD_VAR 0 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 308
39607: NOT
39608: IFFALSE 39630
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39610: LD_VAR 0 4
39614: PPUSH
39615: LD_EXP 58
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: CALL_OW 113
// end ; end ; end ; end ;
39630: GO 39245
39632: POP
39633: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_INT 30
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PPUSH
39649: CALL 11651 0 2
39653: IFFALSE 40471
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39655: LD_ADDR_VAR 0 11
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: LD_INT 30
39667: PUSH
39668: LD_INT 5
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PPUSH
39675: CALL 11651 0 2
39679: PUSH
39680: LD_INT 1
39682: ARRAY
39683: ST_TO_ADDR
// if eng > 1 then
39684: LD_VAR 0 14
39688: PUSH
39689: LD_INT 1
39691: GREATER
39692: IFFALSE 39739
// for i = eng downto 2 do
39694: LD_ADDR_VAR 0 4
39698: PUSH
39699: DOUBLE
39700: LD_VAR 0 14
39704: INC
39705: ST_TO_ADDR
39706: LD_INT 2
39708: PUSH
39709: FOR_DOWNTO
39710: IFFALSE 39737
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39712: LD_VAR 0 1
39716: PPUSH
39717: LD_VAR 0 14
39721: PUSH
39722: LD_VAR 0 4
39726: ARRAY
39727: PPUSH
39728: LD_INT 1
39730: PPUSH
39731: CALL 16558 0 3
39735: GO 39709
39737: POP
39738: POP
// if sci > 1 then
39739: LD_VAR 0 16
39743: PUSH
39744: LD_INT 1
39746: GREATER
39747: IFFALSE 39794
// for i = sci downto 2 do
39749: LD_ADDR_VAR 0 4
39753: PUSH
39754: DOUBLE
39755: LD_VAR 0 16
39759: INC
39760: ST_TO_ADDR
39761: LD_INT 2
39763: PUSH
39764: FOR_DOWNTO
39765: IFFALSE 39792
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39767: LD_VAR 0 1
39771: PPUSH
39772: LD_VAR 0 16
39776: PUSH
39777: LD_VAR 0 4
39781: ARRAY
39782: PPUSH
39783: LD_INT 1
39785: PPUSH
39786: CALL 16558 0 3
39790: GO 39764
39792: POP
39793: POP
// if sol then
39794: LD_VAR 0 13
39798: IFFALSE 40471
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39800: LD_VAR 0 13
39804: PUSH
39805: LD_EXP 68
39809: PUSH
39810: LD_VAR 0 1
39814: ARRAY
39815: DIFF
39816: PUSH
39817: LD_INT 22
39819: PUSH
39820: LD_VAR 0 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 58
39831: PUSH
39832: EMPTY
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 32
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 31
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: PUSH
39873: LD_INT 0
39875: EQUAL
39876: AND
39877: IFFALSE 40471
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39879: LD_ADDR_VAR 0 12
39883: PUSH
39884: LD_VAR 0 13
39888: PUSH
39889: LD_EXP 68
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: DIFF
39900: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39901: LD_VAR 0 1
39905: PPUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PPUSH
39916: CALL 11651 0 2
39920: PUSH
39921: LD_INT 1
39923: GREATER
39924: IFFALSE 39955
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39926: LD_ADDR_VAR 0 8
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 30
39938: PUSH
39939: LD_INT 5
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL 11651 0 2
39950: PUSH
39951: LD_INT 2
39953: ARRAY
39954: ST_TO_ADDR
// for j in tmp do
39955: LD_ADDR_VAR 0 5
39959: PUSH
39960: LD_VAR 0 12
39964: PUSH
39965: FOR_IN
39966: IFFALSE 40469
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39968: LD_VAR 0 5
39972: PUSH
39973: LD_VAR 0 11
39977: PPUSH
39978: CALL_OW 313
39982: IN
39983: PUSH
39984: LD_VAR 0 11
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: EQUAL
39997: AND
39998: PUSH
39999: LD_VAR 0 8
40003: AND
40004: PUSH
40005: LD_VAR 0 8
40009: PPUSH
40010: CALL_OW 313
40014: PUSH
40015: LD_INT 6
40017: LESS
40018: AND
40019: IFFALSE 40046
// begin ComExitBuilding ( j ) ;
40021: LD_VAR 0 5
40025: PPUSH
40026: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40030: LD_VAR 0 5
40034: PPUSH
40035: LD_VAR 0 8
40039: PPUSH
40040: CALL_OW 180
// continue ;
40044: GO 39965
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40046: LD_VAR 0 5
40050: PPUSH
40051: CALL_OW 314
40055: NOT
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: CALL_OW 110
40066: PUSH
40067: LD_INT 0
40069: EQUAL
40070: AND
40071: PUSH
40072: LD_VAR 0 5
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: AND
40083: IFFALSE 40189
// begin if k then
40085: LD_VAR 0 8
40089: IFFALSE 40160
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40091: LD_VAR 0 8
40095: PPUSH
40096: CALL_OW 313
40100: PUSH
40101: LD_VAR 0 11
40105: PPUSH
40106: CALL_OW 313
40110: LESS
40111: IFFALSE 40129
// ComEnterUnit ( j , k ) else
40113: LD_VAR 0 5
40117: PPUSH
40118: LD_VAR 0 8
40122: PPUSH
40123: CALL_OW 120
40127: GO 40158
// if UnitsInside ( b ) < 6 then
40129: LD_VAR 0 11
40133: PPUSH
40134: CALL_OW 313
40138: PUSH
40139: LD_INT 6
40141: LESS
40142: IFFALSE 40158
// ComEnterUnit ( j , b ) ;
40144: LD_VAR 0 5
40148: PPUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 120
// end else
40158: GO 40189
// if UnitsInside ( b ) < 6 then
40160: LD_VAR 0 11
40164: PPUSH
40165: CALL_OW 313
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: IFFALSE 40189
// ComEnterUnit ( j , b ) ;
40175: LD_VAR 0 5
40179: PPUSH
40180: LD_VAR 0 11
40184: PPUSH
40185: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40189: LD_VAR 0 5
40193: PUSH
40194: LD_VAR 0 1
40198: PPUSH
40199: LD_INT 54
40201: PUSH
40202: EMPTY
40203: LIST
40204: PPUSH
40205: CALL 11651 0 2
40209: IN
40210: PUSH
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 257
40220: PUSH
40221: LD_INT 1
40223: EQUAL
40224: AND
40225: IFFALSE 40467
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40227: LD_EXP 62
40231: PUSH
40232: LD_VAR 0 1
40236: ARRAY
40237: PUSH
40238: LD_INT 1
40240: ARRAY
40241: PUSH
40242: LD_INT 12
40244: PPUSH
40245: LD_VAR 0 1
40249: PPUSH
40250: CALL_OW 321
40254: PUSH
40255: LD_INT 2
40257: EQUAL
40258: AND
40259: IFFALSE 40307
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40261: LD_VAR 0 1
40265: PPUSH
40266: LD_INT 5
40268: PPUSH
40269: EMPTY
40270: PPUSH
40271: CALL 11734 0 3
40275: PUSH
40276: LD_EXP 62
40280: PUSH
40281: LD_VAR 0 1
40285: ARRAY
40286: PUSH
40287: LD_INT 1
40289: ARRAY
40290: LESS
40291: IFFALSE 40307
// begin SetClass ( j , class_sniper ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: LD_INT 5
40300: PPUSH
40301: CALL_OW 336
// continue ;
40305: GO 39965
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40307: LD_EXP 62
40311: PUSH
40312: LD_VAR 0 1
40316: ARRAY
40317: PUSH
40318: LD_INT 2
40320: ARRAY
40321: PUSH
40322: LD_INT 41
40324: PPUSH
40325: LD_VAR 0 1
40329: PPUSH
40330: CALL_OW 321
40334: PUSH
40335: LD_INT 2
40337: EQUAL
40338: AND
40339: IFFALSE 40387
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40341: LD_VAR 0 1
40345: PPUSH
40346: LD_INT 8
40348: PPUSH
40349: EMPTY
40350: PPUSH
40351: CALL 11734 0 3
40355: PUSH
40356: LD_EXP 62
40360: PUSH
40361: LD_VAR 0 1
40365: ARRAY
40366: PUSH
40367: LD_INT 2
40369: ARRAY
40370: LESS
40371: IFFALSE 40387
// begin SetClass ( j , class_mortar ) ;
40373: LD_VAR 0 5
40377: PPUSH
40378: LD_INT 8
40380: PPUSH
40381: CALL_OW 336
// continue ;
40385: GO 39965
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40387: LD_EXP 62
40391: PUSH
40392: LD_VAR 0 1
40396: ARRAY
40397: PUSH
40398: LD_INT 3
40400: ARRAY
40401: PUSH
40402: LD_INT 44
40404: PPUSH
40405: LD_VAR 0 1
40409: PPUSH
40410: CALL_OW 321
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: AND
40419: IFFALSE 40467
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40421: LD_VAR 0 1
40425: PPUSH
40426: LD_INT 9
40428: PPUSH
40429: EMPTY
40430: PPUSH
40431: CALL 11734 0 3
40435: PUSH
40436: LD_EXP 62
40440: PUSH
40441: LD_VAR 0 1
40445: ARRAY
40446: PUSH
40447: LD_INT 3
40449: ARRAY
40450: LESS
40451: IFFALSE 40467
// begin SetClass ( j , class_bazooker ) ;
40453: LD_VAR 0 5
40457: PPUSH
40458: LD_INT 9
40460: PPUSH
40461: CALL_OW 336
// continue ;
40465: GO 39965
// end ; end ; end ;
40467: GO 39965
40469: POP
40470: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40471: LD_INT 22
40473: PUSH
40474: LD_VAR 0 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 58
40485: PUSH
40486: EMPTY
40487: LIST
40488: PUSH
40489: LD_INT 30
40491: PUSH
40492: LD_INT 32
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: PPUSH
40504: CALL_OW 69
40508: IFFALSE 40658
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40510: LD_ADDR_VAR 0 12
40514: PUSH
40515: LD_INT 22
40517: PUSH
40518: LD_VAR 0 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 58
40529: PUSH
40530: EMPTY
40531: LIST
40532: PUSH
40533: LD_INT 30
40535: PUSH
40536: LD_INT 32
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: PPUSH
40548: CALL_OW 69
40552: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40553: LD_ADDR_VAR 0 8
40557: PUSH
40558: LD_VAR 0 13
40562: PUSH
40563: LD_EXP 68
40567: PUSH
40568: LD_VAR 0 1
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40575: LD_VAR 0 12
40579: PUSH
40580: LD_INT 1
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 2
40591: EQUAL
40592: PUSH
40593: LD_VAR 0 12
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_EXP 68
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: IN
40613: NOT
40614: AND
40615: PUSH
40616: LD_VAR 0 8
40620: AND
40621: IFFALSE 40658
// begin ComExitBuilding ( k [ 1 ] ) ;
40623: LD_VAR 0 8
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: PPUSH
40632: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40636: LD_VAR 0 8
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_VAR 0 12
40649: PUSH
40650: LD_INT 1
40652: ARRAY
40653: PPUSH
40654: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40658: LD_EXP 35
40662: PUSH
40663: LD_VAR 0 1
40667: ARRAY
40668: IFFALSE 40816
// begin if MCF_Class ( side , 4 , [ ] ) then
40670: LD_VAR 0 1
40674: PPUSH
40675: LD_INT 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL 11734 0 3
40684: IFFALSE 40814
// for j in MCF_Class ( side , 4 , [ ] ) do
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_VAR 0 1
40695: PPUSH
40696: LD_INT 4
40698: PPUSH
40699: EMPTY
40700: PPUSH
40701: CALL 11734 0 3
40705: PUSH
40706: FOR_IN
40707: IFFALSE 40812
// begin if not GetTag ( j ) = 4 then
40709: LD_VAR 0 5
40713: PPUSH
40714: CALL_OW 110
40718: PUSH
40719: LD_INT 4
40721: EQUAL
40722: NOT
40723: IFFALSE 40759
// begin SetTag ( j , 4 ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 4
40732: PPUSH
40733: CALL_OW 109
// if IsInUnit ( j ) then
40737: LD_VAR 0 5
40741: PPUSH
40742: CALL_OW 310
40746: IFFALSE 40757
// ComExitBuilding ( j ) ;
40748: LD_VAR 0 5
40752: PPUSH
40753: CALL_OW 122
// end else
40757: GO 40810
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40759: LD_VAR 0 5
40763: PPUSH
40764: LD_EXP 35
40768: PUSH
40769: LD_VAR 0 1
40773: ARRAY
40774: PUSH
40775: LD_INT 1
40777: ARRAY
40778: PPUSH
40779: CALL 98777 0 2
40783: NOT
40784: IFFALSE 40810
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_EXP 35
40795: PUSH
40796: LD_VAR 0 1
40800: ARRAY
40801: PUSH
40802: LD_INT 1
40804: ARRAY
40805: PPUSH
40806: CALL 19221 0 2
// end ;
40810: GO 40706
40812: POP
40813: POP
// end else
40814: GO 41048
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40816: LD_VAR 0 1
40820: PPUSH
40821: LD_INT 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL 11734 0 3
40830: PUSH
40831: LD_VAR 0 1
40835: PPUSH
40836: LD_INT 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL 12354 0 3
40845: AND
40846: IFFALSE 41048
// for j in MCF_Class ( side , 4 , [ ] ) do
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11734 0 3
40867: PUSH
40868: FOR_IN
40869: IFFALSE 41046
// begin if GetTag ( j ) = 4 then
40871: LD_VAR 0 5
40875: PPUSH
40876: CALL_OW 110
40880: PUSH
40881: LD_INT 4
40883: EQUAL
40884: IFFALSE 41044
// begin SetTag ( j , 0 ) ;
40886: LD_VAR 0 5
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40898: LD_VAR 0 1
40902: PPUSH
40903: CALL 11690 0 1
40907: PUSH
40908: LD_VAR 0 1
40912: PPUSH
40913: CALL 18034 0 1
40917: NOT
40918: AND
40919: IFFALSE 40944
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40921: LD_VAR 0 5
40925: PPUSH
40926: LD_VAR 0 1
40930: PPUSH
40931: CALL 11690 0 1
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: PPUSH
40940: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40944: LD_VAR 0 1
40948: PPUSH
40949: CALL 11690 0 1
40953: NOT
40954: PUSH
40955: LD_VAR 0 1
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL 11651 0 2
40974: AND
40975: IFFALSE 41044
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40977: LD_VAR 0 5
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 30
40989: PUSH
40990: LD_INT 1
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PPUSH
40997: CALL 11651 0 2
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 250
41010: PPUSH
41011: LD_VAR 0 1
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL 11651 0 2
41030: PUSH
41031: LD_INT 1
41033: ARRAY
41034: PPUSH
41035: CALL_OW 251
41039: PPUSH
41040: CALL_OW 111
// end ; end ;
41044: GO 40868
41046: POP
41047: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41048: LD_VAR 0 1
41052: PPUSH
41053: LD_INT 3
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL 11734 0 3
41062: PUSH
41063: LD_EXP 58
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: AND
41074: PUSH
41075: LD_VAR 0 1
41079: PPUSH
41080: LD_INT 6
41082: PPUSH
41083: EMPTY
41084: PPUSH
41085: CALL 12354 0 3
41089: AND
41090: IFFALSE 41621
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41092: LD_ADDR_VAR 0 6
41096: PUSH
41097: LD_EXP 58
41101: PUSH
41102: LD_VAR 0 1
41106: ARRAY
41107: PPUSH
41108: LD_INT 0
41110: PPUSH
41111: CALL_OW 517
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 1
41122: ARRAY
41123: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41124: LD_ADDR_VAR 0 7
41128: PUSH
41129: LD_EXP 58
41133: PUSH
41134: LD_VAR 0 1
41138: ARRAY
41139: PPUSH
41140: LD_INT 0
41142: PPUSH
41143: CALL_OW 517
41147: PUSH
41148: LD_INT 2
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 6
41163: PPUSH
41164: EMPTY
41165: PPUSH
41166: CALL 12354 0 3
41170: IFFALSE 41619
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 1
41181: PPUSH
41182: LD_INT 6
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL 12354 0 3
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41224
// if GetLives ( k ) = 1000 then
41195: LD_VAR 0 8
41199: PPUSH
41200: CALL_OW 256
41204: PUSH
41205: LD_INT 1000
41207: EQUAL
41208: IFFALSE 41222
// SetTag ( k , 0 ) ;
41210: LD_VAR 0 8
41214: PPUSH
41215: LD_INT 0
41217: PPUSH
41218: CALL_OW 109
41222: GO 41192
41224: POP
41225: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: LD_INT 25
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PPUSH
41244: CALL 12354 0 3
41248: IFFALSE 41312
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41250: LD_ADDR_VAR 0 8
41254: PUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: LD_INT 0
41262: PPUSH
41263: LD_INT 25
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: CALL 12354 0 3
41277: PUSH
41278: FOR_IN
41279: IFFALSE 41310
// if GetTag ( k ) = 0 then
41281: LD_VAR 0 8
41285: PPUSH
41286: CALL_OW 110
41290: PUSH
41291: LD_INT 0
41293: EQUAL
41294: IFFALSE 41308
// begin SetTag ( k , 8 ) ;
41296: LD_VAR 0 8
41300: PPUSH
41301: LD_INT 8
41303: PPUSH
41304: CALL_OW 109
// end ;
41308: GO 41278
41310: POP
41311: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41312: LD_VAR 0 1
41316: PPUSH
41317: LD_INT 6
41319: PPUSH
41320: LD_INT 92
41322: PUSH
41323: LD_VAR 0 6
41327: PUSH
41328: LD_VAR 0 7
41332: PUSH
41333: LD_INT 10
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL 12354 0 3
41346: IFFALSE 41470
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_VAR 0 4
41357: PPUSH
41358: LD_INT 6
41360: PPUSH
41361: LD_INT 92
41363: PUSH
41364: LD_VAR 0 6
41368: PUSH
41369: LD_VAR 0 7
41373: PUSH
41374: LD_INT 10
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 12354 0 3
41387: PUSH
41388: FOR_IN
41389: IFFALSE 41468
// begin if not HasTask ( j ) and GetDriver ( j ) then
41391: LD_VAR 0 5
41395: PPUSH
41396: CALL_OW 314
41400: NOT
41401: PUSH
41402: LD_VAR 0 5
41406: PPUSH
41407: CALL 31773 0 1
41411: AND
41412: IFFALSE 41466
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41414: LD_VAR 0 5
41418: PPUSH
41419: CALL 31773 0 1
41423: PPUSH
41424: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41428: LD_VAR 0 5
41432: PPUSH
41433: CALL 31773 0 1
41437: PPUSH
41438: LD_VAR 0 5
41442: PPUSH
41443: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41447: LD_VAR 0 5
41451: PPUSH
41452: CALL 31773 0 1
41456: PPUSH
41457: LD_VAR 0 5
41461: PPUSH
41462: CALL_OW 180
// end ; end ;
41466: GO 41388
41468: POP
41469: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41470: LD_VAR 0 1
41474: PPUSH
41475: LD_INT 6
41477: PPUSH
41478: LD_INT 92
41480: PUSH
41481: LD_VAR 0 6
41485: PUSH
41486: LD_VAR 0 7
41490: PUSH
41491: LD_INT 10
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL 12354 0 3
41504: PUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 8
41512: PPUSH
41513: EMPTY
41514: PPUSH
41515: CALL 12354 0 3
41519: AND
41520: IFFALSE 41619
// for j in MCF_Tag ( side , 8 , [ ] ) do
41522: LD_ADDR_VAR 0 5
41526: PUSH
41527: LD_VAR 0 1
41531: PPUSH
41532: LD_INT 8
41534: PPUSH
41535: EMPTY
41536: PPUSH
41537: CALL 12354 0 3
41541: PUSH
41542: FOR_IN
41543: IFFALSE 41617
// begin if IsInUnit ( j ) then
41545: LD_VAR 0 5
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41567
// ComExitBuilding ( j ) else
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 122
41565: GO 41615
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41567: LD_VAR 0 5
41571: PPUSH
41572: LD_VAR 0 1
41576: PPUSH
41577: LD_INT 6
41579: PPUSH
41580: LD_INT 92
41582: PUSH
41583: LD_VAR 0 6
41587: PUSH
41588: LD_VAR 0 7
41592: PUSH
41593: LD_INT 10
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: PPUSH
41602: CALL 12354 0 3
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: CALL_OW 129
// end ;
41615: GO 41542
41617: POP
41618: POP
// end ; end else
41619: GO 41676
// if MCF_Tag ( side , 8 , [ ] ) then
41621: LD_VAR 0 1
41625: PPUSH
41626: LD_INT 8
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL 12354 0 3
41635: IFFALSE 41676
// for k in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 8
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12354 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41674
// SetTag ( k , 0 ) ;
41660: LD_VAR 0 8
41664: PPUSH
41665: LD_INT 0
41667: PPUSH
41668: CALL_OW 109
41672: GO 41657
41674: POP
41675: POP
// end ; end_of_file
41676: LD_VAR 0 3
41680: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41681: LD_INT 0
41683: PPUSH
// MREG_Game := [ ] ;
41684: LD_ADDR_EXP 33
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_Crates := [ ] ;
41691: LD_ADDR_EXP 34
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_Heal := [ ] ;
41698: LD_ADDR_EXP 35
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_Tame := [ ] ;
41705: LD_ADDR_EXP 37
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41712: LD_ADDR_EXP 38
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41719: LD_ADDR_EXP 39
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_LabList := [ ] ;
41726: LD_ADDR_EXP 40
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41733: LD_ADDR_EXP 41
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41740: LD_ADDR_EXP 42
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41747: LD_ADDR_EXP 43
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41754: LD_ADDR_EXP 44
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_Status := [ ] ;
41761: LD_ADDR_EXP 45
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41768: LD_ADDR_EXP 46
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41775: LD_ADDR_EXP 47
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41782: LD_ADDR_EXP 48
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41789: LD_ADDR_EXP 49
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41796: LD_ADDR_EXP 50
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41803: LD_ADDR_EXP 51
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41810: LD_ADDR_EXP 52
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41817: LD_ADDR_EXP 53
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41824: LD_ADDR_EXP 54
41828: PUSH
41829: EMPTY
41830: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41831: LD_ADDR_EXP 55
41835: PUSH
41836: EMPTY
41837: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41838: LD_ADDR_EXP 56
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41845: LD_ADDR_EXP 57
41849: PUSH
41850: EMPTY
41851: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41852: LD_ADDR_EXP 61
41856: PUSH
41857: EMPTY
41858: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41859: LD_ADDR_EXP 62
41863: PUSH
41864: EMPTY
41865: ST_TO_ADDR
// MREG_Parking := [ ] ;
41866: LD_ADDR_EXP 58
41870: PUSH
41871: EMPTY
41872: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41873: LD_ADDR_EXP 59
41877: PUSH
41878: EMPTY
41879: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41880: LD_ADDR_EXP 63
41884: PUSH
41885: EMPTY
41886: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41887: LD_ADDR_EXP 64
41891: PUSH
41892: EMPTY
41893: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41894: LD_ADDR_EXP 65
41898: PUSH
41899: EMPTY
41900: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41901: LD_ADDR_EXP 67
41905: PUSH
41906: EMPTY
41907: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41908: LD_ADDR_EXP 68
41912: PUSH
41913: EMPTY
41914: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41915: LD_ADDR_EXP 69
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41922: LD_ADDR_EXP 71
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41929: LD_ADDR_EXP 70
41933: PUSH
41934: EMPTY
41935: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41936: LD_ADDR_EXP 72
41940: PUSH
41941: LD_INT 300
41943: PUSH
41944: LD_INT 100
41946: PUSH
41947: LD_INT 25
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 1
41959: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41960: LD_INT 0
41962: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41963: LD_VAR 0 2
41967: PUSH
41968: LD_VAR 0 3
41972: PUSH
41973: LD_VAR 0 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: LIST
41982: PUSH
41983: LD_VAR 0 1
41987: IN
41988: IFFALSE 42002
// result := mreg_list else
41990: LD_ADDR_VAR 0 5
41994: PUSH
41995: LD_VAR 0 1
41999: ST_TO_ADDR
42000: GO 42036
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42002: LD_ADDR_VAR 0 1
42006: PUSH
42007: LD_VAR 0 1
42011: PUSH
42012: LD_VAR 0 2
42016: PUSH
42017: LD_VAR 0 3
42021: PUSH
42022: LD_VAR 0 4
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: ADD
42035: ST_TO_ADDR
// result := mreg_list ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_VAR 0 1
42045: ST_TO_ADDR
// end ;
42046: LD_VAR 0 5
42050: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42051: LD_INT 0
42053: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42054: LD_VAR 0 2
42058: PUSH
42059: LD_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PUSH
42074: LD_VAR 0 1
42078: IN
42079: IFFALSE 42117
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_VAR 0 1
42090: PUSH
42091: LD_VAR 0 2
42095: PUSH
42096: LD_VAR 0 3
42100: PUSH
42101: LD_VAR 0 4
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: DIFF
42114: ST_TO_ADDR
42115: GO 42127
// result := mreg_list ;
42117: LD_ADDR_VAR 0 5
42121: PUSH
42122: LD_VAR 0 1
42126: ST_TO_ADDR
// end ;
42127: LD_VAR 0 5
42131: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42132: LD_INT 0
42134: PPUSH
42135: PPUSH
42136: PPUSH
// for j = 1 to 8 do
42137: LD_ADDR_VAR 0 3
42141: PUSH
42142: DOUBLE
42143: LD_INT 1
42145: DEC
42146: ST_TO_ADDR
42147: LD_INT 8
42149: PUSH
42150: FOR_TO
42151: IFFALSE 42992
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42153: LD_VAR 0 3
42157: PPUSH
42158: LD_INT 51
42160: PUSH
42161: EMPTY
42162: LIST
42163: PPUSH
42164: CALL 11651 0 2
42168: PUSH
42169: LD_OWVAR 2
42173: PUSH
42174: LD_VAR 0 3
42178: EQUAL
42179: NOT
42180: AND
42181: IFFALSE 42199
// MREG_SidesList := MREG_SidesList ^ 1 else
42183: LD_ADDR_EXP 39
42187: PUSH
42188: LD_EXP 39
42192: PUSH
42193: LD_INT 1
42195: ADD
42196: ST_TO_ADDR
42197: GO 42213
// MREG_SidesList := MREG_SidesList ^ 0 ;
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 0
42211: ADD
42212: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42213: LD_VAR 0 3
42217: PPUSH
42218: LD_INT 2
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 34
42233: PUSH
42234: LD_INT 32
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 34
42243: PUSH
42244: LD_INT 51
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11952 0 2
42264: IFFALSE 42365
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42266: LD_ADDR_VAR 0 2
42270: PUSH
42271: LD_VAR 0 3
42275: PPUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 34
42281: PUSH
42282: LD_INT 12
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 34
42291: PUSH
42292: LD_INT 32
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 34
42301: PUSH
42302: LD_INT 51
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: CALL 11952 0 2
42322: PUSH
42323: FOR_IN
42324: IFFALSE 42363
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42326: LD_ADDR_EXP 41
42330: PUSH
42331: LD_EXP 41
42335: PPUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_VAR 0 2
42345: PPUSH
42346: LD_VAR 0 2
42350: PPUSH
42351: CALL_OW 264
42355: PPUSH
42356: CALL 41960 0 4
42360: ST_TO_ADDR
42361: GO 42323
42363: POP
42364: POP
// if MCF_Class ( j , 4 , [ ] ) then
42365: LD_VAR 0 3
42369: PPUSH
42370: LD_INT 4
42372: PPUSH
42373: EMPTY
42374: PPUSH
42375: CALL 11734 0 3
42379: IFFALSE 42412
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42381: LD_ADDR_EXP 54
42385: PUSH
42386: LD_EXP 54
42390: PUSH
42391: LD_VAR 0 3
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: EMPTY
42400: PPUSH
42401: CALL 11734 0 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: ADD
42409: ST_TO_ADDR
42410: GO 42429
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42412: LD_ADDR_EXP 54
42416: PUSH
42417: LD_EXP 54
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: ADD
42428: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42429: LD_VAR 0 3
42433: PPUSH
42434: LD_INT 3
42436: PPUSH
42437: EMPTY
42438: PPUSH
42439: CALL 11734 0 3
42443: IFFALSE 42476
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42445: LD_ADDR_EXP 55
42449: PUSH
42450: LD_EXP 55
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_INT 3
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL 11734 0 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: ADD
42473: ST_TO_ADDR
42474: GO 42493
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42476: LD_ADDR_EXP 55
42480: PUSH
42481: LD_EXP 55
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: ADD
42492: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42493: LD_VAR 0 3
42497: PPUSH
42498: LD_INT 1
42500: PPUSH
42501: EMPTY
42502: PPUSH
42503: CALL 11734 0 3
42507: IFFALSE 42540
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42509: LD_ADDR_EXP 56
42513: PUSH
42514: LD_EXP 56
42518: PUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_INT 1
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 11734 0 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: ADD
42537: ST_TO_ADDR
42538: GO 42557
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42540: LD_ADDR_EXP 56
42544: PUSH
42545: LD_EXP 56
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: ADD
42556: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_INT 2
42564: PPUSH
42565: EMPTY
42566: PPUSH
42567: CALL 11734 0 3
42571: IFFALSE 42604
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42573: LD_ADDR_EXP 57
42577: PUSH
42578: LD_EXP 57
42582: PUSH
42583: LD_VAR 0 3
42587: PPUSH
42588: LD_INT 2
42590: PPUSH
42591: EMPTY
42592: PPUSH
42593: CALL 11734 0 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: ADD
42601: ST_TO_ADDR
42602: GO 42621
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42604: LD_ADDR_EXP 57
42608: PUSH
42609: LD_EXP 57
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: EMPTY
42618: LIST
42619: ADD
42620: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42621: LD_ADDR_EXP 47
42625: PUSH
42626: LD_EXP 47
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: ADD
42637: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42638: LD_ADDR_EXP 35
42642: PUSH
42643: LD_EXP 35
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: ADD
42654: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42655: LD_ADDR_EXP 37
42659: PUSH
42660: LD_EXP 37
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42672: LD_ADDR_EXP 58
42676: PUSH
42677: LD_EXP 58
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: EMPTY
42686: LIST
42687: ADD
42688: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42689: LD_ADDR_EXP 59
42693: PUSH
42694: LD_EXP 59
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: ADD
42705: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42706: LD_ADDR_EXP 51
42710: PUSH
42711: LD_EXP 51
42715: PUSH
42716: LD_INT 0
42718: PUSH
42719: EMPTY
42720: LIST
42721: ADD
42722: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42723: LD_ADDR_EXP 38
42727: PUSH
42728: LD_EXP 38
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: LD_INT 0
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42755: LD_ADDR_EXP 60
42759: PUSH
42760: LD_EXP 60
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: ADD
42777: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42778: LD_ADDR_EXP 61
42782: PUSH
42783: LD_EXP 61
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: EMPTY
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42798: LD_ADDR_EXP 42
42802: PUSH
42803: LD_EXP 42
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42815: LD_ADDR_EXP 63
42819: PUSH
42820: LD_EXP 63
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42832: LD_ADDR_EXP 64
42836: PUSH
42837: LD_EXP 64
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: ADD
42848: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42849: LD_ADDR_EXP 65
42853: PUSH
42854: LD_EXP 65
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: ADD
42865: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42866: LD_ADDR_EXP 66
42870: PUSH
42871: LD_EXP 66
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42883: LD_ADDR_EXP 67
42887: PUSH
42888: LD_EXP 67
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: ADD
42899: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42900: LD_ADDR_EXP 68
42904: PUSH
42905: LD_EXP 68
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: ADD
42916: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42917: LD_ADDR_EXP 69
42921: PUSH
42922: LD_EXP 69
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: EMPTY
42931: LIST
42932: ADD
42933: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42934: LD_ADDR_EXP 71
42938: PUSH
42939: LD_EXP 71
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42951: LD_ADDR_EXP 70
42955: PUSH
42956: LD_EXP 70
42960: PUSH
42961: LD_INT 0
42963: ADD
42964: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42965: LD_ADDR_EXP 62
42969: PUSH
42970: LD_EXP 62
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ADD
42989: ST_TO_ADDR
// end ;
42990: GO 42150
42992: POP
42993: POP
// end ;
42994: LD_VAR 0 1
42998: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42999: LD_INT 0
43001: PPUSH
43002: PPUSH
43003: PPUSH
// m := false ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_INT 0
43011: ST_TO_ADDR
// for i = 1 to mreg do
43012: LD_ADDR_VAR 0 4
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 2
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43064
// if mreg [ i ] [ 1 ] = side then
43030: LD_VAR 0 2
43034: PUSH
43035: LD_VAR 0 4
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_VAR 0 1
43049: EQUAL
43050: IFFALSE 43062
// begin m := true ;
43052: LD_ADDR_VAR 0 5
43056: PUSH
43057: LD_INT 1
43059: ST_TO_ADDR
// break ;
43060: GO 43064
// end ;
43062: GO 43027
43064: POP
43065: POP
// result := m ;
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// m := 0 ;
43086: LD_ADDR_VAR 0 5
43090: PUSH
43091: LD_INT 0
43093: ST_TO_ADDR
// for i = 1 to mreg do
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_VAR 0 2
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43150
// if mreg [ i ] [ 1 ] = side then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_VAR 0 4
43121: ARRAY
43122: PUSH
43123: LD_INT 1
43125: ARRAY
43126: PUSH
43127: LD_VAR 0 1
43131: EQUAL
43132: IFFALSE 43148
// begin m := m + 1 ;
43134: LD_ADDR_VAR 0 5
43138: PUSH
43139: LD_VAR 0 5
43143: PUSH
43144: LD_INT 1
43146: PLUS
43147: ST_TO_ADDR
// end ;
43148: GO 43109
43150: POP
43151: POP
// result := m ;
43152: LD_ADDR_VAR 0 3
43156: PUSH
43157: LD_VAR 0 5
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
// result := 0 ;
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: LD_INT 0
43178: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43179: LD_ADDR_VAR 0 4
43183: PUSH
43184: DOUBLE
43185: LD_INT 1
43187: DEC
43188: ST_TO_ADDR
43189: LD_EXP 53
43193: PUSH
43194: FOR_TO
43195: IFFALSE 43257
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43197: LD_EXP 53
43201: PUSH
43202: LD_VAR 0 4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PUSH
43212: LD_VAR 0 1
43216: EQUAL
43217: PUSH
43218: LD_EXP 53
43222: PUSH
43223: LD_VAR 0 4
43227: ARRAY
43228: PUSH
43229: LD_INT 2
43231: ARRAY
43232: PUSH
43233: LD_VAR 0 2
43237: EQUAL
43238: AND
43239: IFFALSE 43255
// begin result := result + 1 ;
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 3
43250: PUSH
43251: LD_INT 1
43253: PLUS
43254: ST_TO_ADDR
// end ;
43255: GO 43194
43257: POP
43258: POP
// end ; end_of_file end_of_file
43259: LD_VAR 0 3
43263: RET
// export globalGameSaveCounter ; every 0 0$1 do
43264: GO 43266
43266: DISABLE
// begin enable ;
43267: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43268: LD_STRING updateTimer(
43270: PUSH
43271: LD_OWVAR 1
43275: STR
43276: PUSH
43277: LD_STRING );
43279: STR
43280: PPUSH
43281: CALL_OW 559
// end ;
43285: END
// every 0 0$1 do
43286: GO 43288
43288: DISABLE
// begin globalGameSaveCounter := 0 ;
43289: LD_ADDR_EXP 73
43293: PUSH
43294: LD_INT 0
43296: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
43297: LD_STRING setGameSaveCounter(0)
43299: PPUSH
43300: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
43304: LD_STRING initStreamRollete();
43306: PPUSH
43307: CALL_OW 559
// InitStreamMode ;
43311: CALL 44637 0 0
// DefineStreamItems ( false ) ;
43315: LD_INT 0
43317: PPUSH
43318: CALL 45101 0 1
// end ;
43322: END
// export function SOS_MapStart ( ) ; begin
43323: LD_INT 0
43325: PPUSH
// if streamModeActive then
43326: LD_EXP 74
43330: IFFALSE 43339
// DefineStreamItems ( true ) ;
43332: LD_INT 1
43334: PPUSH
43335: CALL 45101 0 1
// UpdateLuaVariables ( ) ;
43339: CALL 43356 0 0
// UpdateFactoryWaypoints ( ) ;
43343: CALL 57970 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43347: CALL 58227 0 0
// end ;
43351: LD_VAR 0 1
43355: RET
// function UpdateLuaVariables ( ) ; begin
43356: LD_INT 0
43358: PPUSH
// if globalGameSaveCounter then
43359: LD_EXP 73
43363: IFFALSE 43397
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
43365: LD_ADDR_EXP 73
43369: PUSH
43370: LD_EXP 73
43374: PPUSH
43375: CALL 102857 0 1
43379: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
43380: LD_STRING setGameSaveCounter(
43382: PUSH
43383: LD_EXP 73
43387: STR
43388: PUSH
43389: LD_STRING )
43391: STR
43392: PPUSH
43393: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
43397: LD_STRING setGameDifficulty(
43399: PUSH
43400: LD_OWVAR 67
43404: STR
43405: PUSH
43406: LD_STRING )
43408: STR
43409: PPUSH
43410: CALL_OW 559
// end ;
43414: LD_VAR 0 1
43418: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43419: LD_INT 0
43421: PPUSH
// if p2 = stream_mode then
43422: LD_VAR 0 2
43426: PUSH
43427: LD_INT 100
43429: EQUAL
43430: IFFALSE 44433
// begin if not StreamModeActive then
43432: LD_EXP 74
43436: NOT
43437: IFFALSE 43447
// StreamModeActive := true ;
43439: LD_ADDR_EXP 74
43443: PUSH
43444: LD_INT 1
43446: ST_TO_ADDR
// if p3 = 0 then
43447: LD_VAR 0 3
43451: PUSH
43452: LD_INT 0
43454: EQUAL
43455: IFFALSE 43461
// InitStreamMode ;
43457: CALL 44637 0 0
// if p3 = 1 then
43461: LD_VAR 0 3
43465: PUSH
43466: LD_INT 1
43468: EQUAL
43469: IFFALSE 43479
// sRocket := true ;
43471: LD_ADDR_EXP 79
43475: PUSH
43476: LD_INT 1
43478: ST_TO_ADDR
// if p3 = 2 then
43479: LD_VAR 0 3
43483: PUSH
43484: LD_INT 2
43486: EQUAL
43487: IFFALSE 43497
// sSpeed := true ;
43489: LD_ADDR_EXP 78
43493: PUSH
43494: LD_INT 1
43496: ST_TO_ADDR
// if p3 = 3 then
43497: LD_VAR 0 3
43501: PUSH
43502: LD_INT 3
43504: EQUAL
43505: IFFALSE 43515
// sEngine := true ;
43507: LD_ADDR_EXP 80
43511: PUSH
43512: LD_INT 1
43514: ST_TO_ADDR
// if p3 = 4 then
43515: LD_VAR 0 3
43519: PUSH
43520: LD_INT 4
43522: EQUAL
43523: IFFALSE 43533
// sSpec := true ;
43525: LD_ADDR_EXP 77
43529: PUSH
43530: LD_INT 1
43532: ST_TO_ADDR
// if p3 = 5 then
43533: LD_VAR 0 3
43537: PUSH
43538: LD_INT 5
43540: EQUAL
43541: IFFALSE 43551
// sLevel := true ;
43543: LD_ADDR_EXP 81
43547: PUSH
43548: LD_INT 1
43550: ST_TO_ADDR
// if p3 = 6 then
43551: LD_VAR 0 3
43555: PUSH
43556: LD_INT 6
43558: EQUAL
43559: IFFALSE 43569
// sArmoury := true ;
43561: LD_ADDR_EXP 82
43565: PUSH
43566: LD_INT 1
43568: ST_TO_ADDR
// if p3 = 7 then
43569: LD_VAR 0 3
43573: PUSH
43574: LD_INT 7
43576: EQUAL
43577: IFFALSE 43587
// sRadar := true ;
43579: LD_ADDR_EXP 83
43583: PUSH
43584: LD_INT 1
43586: ST_TO_ADDR
// if p3 = 8 then
43587: LD_VAR 0 3
43591: PUSH
43592: LD_INT 8
43594: EQUAL
43595: IFFALSE 43605
// sBunker := true ;
43597: LD_ADDR_EXP 84
43601: PUSH
43602: LD_INT 1
43604: ST_TO_ADDR
// if p3 = 9 then
43605: LD_VAR 0 3
43609: PUSH
43610: LD_INT 9
43612: EQUAL
43613: IFFALSE 43623
// sHack := true ;
43615: LD_ADDR_EXP 85
43619: PUSH
43620: LD_INT 1
43622: ST_TO_ADDR
// if p3 = 10 then
43623: LD_VAR 0 3
43627: PUSH
43628: LD_INT 10
43630: EQUAL
43631: IFFALSE 43641
// sFire := true ;
43633: LD_ADDR_EXP 86
43637: PUSH
43638: LD_INT 1
43640: ST_TO_ADDR
// if p3 = 11 then
43641: LD_VAR 0 3
43645: PUSH
43646: LD_INT 11
43648: EQUAL
43649: IFFALSE 43659
// sRefresh := true ;
43651: LD_ADDR_EXP 87
43655: PUSH
43656: LD_INT 1
43658: ST_TO_ADDR
// if p3 = 12 then
43659: LD_VAR 0 3
43663: PUSH
43664: LD_INT 12
43666: EQUAL
43667: IFFALSE 43677
// sExp := true ;
43669: LD_ADDR_EXP 88
43673: PUSH
43674: LD_INT 1
43676: ST_TO_ADDR
// if p3 = 13 then
43677: LD_VAR 0 3
43681: PUSH
43682: LD_INT 13
43684: EQUAL
43685: IFFALSE 43695
// sDepot := true ;
43687: LD_ADDR_EXP 89
43691: PUSH
43692: LD_INT 1
43694: ST_TO_ADDR
// if p3 = 14 then
43695: LD_VAR 0 3
43699: PUSH
43700: LD_INT 14
43702: EQUAL
43703: IFFALSE 43713
// sFlag := true ;
43705: LD_ADDR_EXP 90
43709: PUSH
43710: LD_INT 1
43712: ST_TO_ADDR
// if p3 = 15 then
43713: LD_VAR 0 3
43717: PUSH
43718: LD_INT 15
43720: EQUAL
43721: IFFALSE 43731
// sKamikadze := true ;
43723: LD_ADDR_EXP 98
43727: PUSH
43728: LD_INT 1
43730: ST_TO_ADDR
// if p3 = 16 then
43731: LD_VAR 0 3
43735: PUSH
43736: LD_INT 16
43738: EQUAL
43739: IFFALSE 43749
// sTroll := true ;
43741: LD_ADDR_EXP 99
43745: PUSH
43746: LD_INT 1
43748: ST_TO_ADDR
// if p3 = 17 then
43749: LD_VAR 0 3
43753: PUSH
43754: LD_INT 17
43756: EQUAL
43757: IFFALSE 43767
// sSlow := true ;
43759: LD_ADDR_EXP 100
43763: PUSH
43764: LD_INT 1
43766: ST_TO_ADDR
// if p3 = 18 then
43767: LD_VAR 0 3
43771: PUSH
43772: LD_INT 18
43774: EQUAL
43775: IFFALSE 43785
// sLack := true ;
43777: LD_ADDR_EXP 101
43781: PUSH
43782: LD_INT 1
43784: ST_TO_ADDR
// if p3 = 19 then
43785: LD_VAR 0 3
43789: PUSH
43790: LD_INT 19
43792: EQUAL
43793: IFFALSE 43803
// sTank := true ;
43795: LD_ADDR_EXP 103
43799: PUSH
43800: LD_INT 1
43802: ST_TO_ADDR
// if p3 = 20 then
43803: LD_VAR 0 3
43807: PUSH
43808: LD_INT 20
43810: EQUAL
43811: IFFALSE 43821
// sRemote := true ;
43813: LD_ADDR_EXP 104
43817: PUSH
43818: LD_INT 1
43820: ST_TO_ADDR
// if p3 = 21 then
43821: LD_VAR 0 3
43825: PUSH
43826: LD_INT 21
43828: EQUAL
43829: IFFALSE 43839
// sPowell := true ;
43831: LD_ADDR_EXP 105
43835: PUSH
43836: LD_INT 1
43838: ST_TO_ADDR
// if p3 = 22 then
43839: LD_VAR 0 3
43843: PUSH
43844: LD_INT 22
43846: EQUAL
43847: IFFALSE 43857
// sTeleport := true ;
43849: LD_ADDR_EXP 108
43853: PUSH
43854: LD_INT 1
43856: ST_TO_ADDR
// if p3 = 23 then
43857: LD_VAR 0 3
43861: PUSH
43862: LD_INT 23
43864: EQUAL
43865: IFFALSE 43875
// sOilTower := true ;
43867: LD_ADDR_EXP 110
43871: PUSH
43872: LD_INT 1
43874: ST_TO_ADDR
// if p3 = 24 then
43875: LD_VAR 0 3
43879: PUSH
43880: LD_INT 24
43882: EQUAL
43883: IFFALSE 43893
// sShovel := true ;
43885: LD_ADDR_EXP 111
43889: PUSH
43890: LD_INT 1
43892: ST_TO_ADDR
// if p3 = 25 then
43893: LD_VAR 0 3
43897: PUSH
43898: LD_INT 25
43900: EQUAL
43901: IFFALSE 43911
// sSheik := true ;
43903: LD_ADDR_EXP 112
43907: PUSH
43908: LD_INT 1
43910: ST_TO_ADDR
// if p3 = 26 then
43911: LD_VAR 0 3
43915: PUSH
43916: LD_INT 26
43918: EQUAL
43919: IFFALSE 43929
// sEarthquake := true ;
43921: LD_ADDR_EXP 114
43925: PUSH
43926: LD_INT 1
43928: ST_TO_ADDR
// if p3 = 27 then
43929: LD_VAR 0 3
43933: PUSH
43934: LD_INT 27
43936: EQUAL
43937: IFFALSE 43947
// sAI := true ;
43939: LD_ADDR_EXP 115
43943: PUSH
43944: LD_INT 1
43946: ST_TO_ADDR
// if p3 = 28 then
43947: LD_VAR 0 3
43951: PUSH
43952: LD_INT 28
43954: EQUAL
43955: IFFALSE 43965
// sCargo := true ;
43957: LD_ADDR_EXP 118
43961: PUSH
43962: LD_INT 1
43964: ST_TO_ADDR
// if p3 = 29 then
43965: LD_VAR 0 3
43969: PUSH
43970: LD_INT 29
43972: EQUAL
43973: IFFALSE 43983
// sDLaser := true ;
43975: LD_ADDR_EXP 119
43979: PUSH
43980: LD_INT 1
43982: ST_TO_ADDR
// if p3 = 30 then
43983: LD_VAR 0 3
43987: PUSH
43988: LD_INT 30
43990: EQUAL
43991: IFFALSE 44001
// sExchange := true ;
43993: LD_ADDR_EXP 120
43997: PUSH
43998: LD_INT 1
44000: ST_TO_ADDR
// if p3 = 31 then
44001: LD_VAR 0 3
44005: PUSH
44006: LD_INT 31
44008: EQUAL
44009: IFFALSE 44019
// sFac := true ;
44011: LD_ADDR_EXP 121
44015: PUSH
44016: LD_INT 1
44018: ST_TO_ADDR
// if p3 = 32 then
44019: LD_VAR 0 3
44023: PUSH
44024: LD_INT 32
44026: EQUAL
44027: IFFALSE 44037
// sPower := true ;
44029: LD_ADDR_EXP 122
44033: PUSH
44034: LD_INT 1
44036: ST_TO_ADDR
// if p3 = 33 then
44037: LD_VAR 0 3
44041: PUSH
44042: LD_INT 33
44044: EQUAL
44045: IFFALSE 44055
// sRandom := true ;
44047: LD_ADDR_EXP 123
44051: PUSH
44052: LD_INT 1
44054: ST_TO_ADDR
// if p3 = 34 then
44055: LD_VAR 0 3
44059: PUSH
44060: LD_INT 34
44062: EQUAL
44063: IFFALSE 44073
// sShield := true ;
44065: LD_ADDR_EXP 124
44069: PUSH
44070: LD_INT 1
44072: ST_TO_ADDR
// if p3 = 35 then
44073: LD_VAR 0 3
44077: PUSH
44078: LD_INT 35
44080: EQUAL
44081: IFFALSE 44091
// sTime := true ;
44083: LD_ADDR_EXP 125
44087: PUSH
44088: LD_INT 1
44090: ST_TO_ADDR
// if p3 = 36 then
44091: LD_VAR 0 3
44095: PUSH
44096: LD_INT 36
44098: EQUAL
44099: IFFALSE 44109
// sTools := true ;
44101: LD_ADDR_EXP 126
44105: PUSH
44106: LD_INT 1
44108: ST_TO_ADDR
// if p3 = 101 then
44109: LD_VAR 0 3
44113: PUSH
44114: LD_INT 101
44116: EQUAL
44117: IFFALSE 44127
// sSold := true ;
44119: LD_ADDR_EXP 91
44123: PUSH
44124: LD_INT 1
44126: ST_TO_ADDR
// if p3 = 102 then
44127: LD_VAR 0 3
44131: PUSH
44132: LD_INT 102
44134: EQUAL
44135: IFFALSE 44145
// sDiff := true ;
44137: LD_ADDR_EXP 92
44141: PUSH
44142: LD_INT 1
44144: ST_TO_ADDR
// if p3 = 103 then
44145: LD_VAR 0 3
44149: PUSH
44150: LD_INT 103
44152: EQUAL
44153: IFFALSE 44163
// sFog := true ;
44155: LD_ADDR_EXP 95
44159: PUSH
44160: LD_INT 1
44162: ST_TO_ADDR
// if p3 = 104 then
44163: LD_VAR 0 3
44167: PUSH
44168: LD_INT 104
44170: EQUAL
44171: IFFALSE 44181
// sReset := true ;
44173: LD_ADDR_EXP 96
44177: PUSH
44178: LD_INT 1
44180: ST_TO_ADDR
// if p3 = 105 then
44181: LD_VAR 0 3
44185: PUSH
44186: LD_INT 105
44188: EQUAL
44189: IFFALSE 44199
// sSun := true ;
44191: LD_ADDR_EXP 97
44195: PUSH
44196: LD_INT 1
44198: ST_TO_ADDR
// if p3 = 106 then
44199: LD_VAR 0 3
44203: PUSH
44204: LD_INT 106
44206: EQUAL
44207: IFFALSE 44217
// sTiger := true ;
44209: LD_ADDR_EXP 93
44213: PUSH
44214: LD_INT 1
44216: ST_TO_ADDR
// if p3 = 107 then
44217: LD_VAR 0 3
44221: PUSH
44222: LD_INT 107
44224: EQUAL
44225: IFFALSE 44235
// sBomb := true ;
44227: LD_ADDR_EXP 94
44231: PUSH
44232: LD_INT 1
44234: ST_TO_ADDR
// if p3 = 108 then
44235: LD_VAR 0 3
44239: PUSH
44240: LD_INT 108
44242: EQUAL
44243: IFFALSE 44253
// sWound := true ;
44245: LD_ADDR_EXP 102
44249: PUSH
44250: LD_INT 1
44252: ST_TO_ADDR
// if p3 = 109 then
44253: LD_VAR 0 3
44257: PUSH
44258: LD_INT 109
44260: EQUAL
44261: IFFALSE 44271
// sBetray := true ;
44263: LD_ADDR_EXP 106
44267: PUSH
44268: LD_INT 1
44270: ST_TO_ADDR
// if p3 = 110 then
44271: LD_VAR 0 3
44275: PUSH
44276: LD_INT 110
44278: EQUAL
44279: IFFALSE 44289
// sContamin := true ;
44281: LD_ADDR_EXP 107
44285: PUSH
44286: LD_INT 1
44288: ST_TO_ADDR
// if p3 = 111 then
44289: LD_VAR 0 3
44293: PUSH
44294: LD_INT 111
44296: EQUAL
44297: IFFALSE 44307
// sOil := true ;
44299: LD_ADDR_EXP 109
44303: PUSH
44304: LD_INT 1
44306: ST_TO_ADDR
// if p3 = 112 then
44307: LD_VAR 0 3
44311: PUSH
44312: LD_INT 112
44314: EQUAL
44315: IFFALSE 44325
// sStu := true ;
44317: LD_ADDR_EXP 113
44321: PUSH
44322: LD_INT 1
44324: ST_TO_ADDR
// if p3 = 113 then
44325: LD_VAR 0 3
44329: PUSH
44330: LD_INT 113
44332: EQUAL
44333: IFFALSE 44343
// sBazooka := true ;
44335: LD_ADDR_EXP 116
44339: PUSH
44340: LD_INT 1
44342: ST_TO_ADDR
// if p3 = 114 then
44343: LD_VAR 0 3
44347: PUSH
44348: LD_INT 114
44350: EQUAL
44351: IFFALSE 44361
// sMortar := true ;
44353: LD_ADDR_EXP 117
44357: PUSH
44358: LD_INT 1
44360: ST_TO_ADDR
// if p3 = 115 then
44361: LD_VAR 0 3
44365: PUSH
44366: LD_INT 115
44368: EQUAL
44369: IFFALSE 44379
// sRanger := true ;
44371: LD_ADDR_EXP 127
44375: PUSH
44376: LD_INT 1
44378: ST_TO_ADDR
// if p3 = 116 then
44379: LD_VAR 0 3
44383: PUSH
44384: LD_INT 116
44386: EQUAL
44387: IFFALSE 44397
// sComputer := true ;
44389: LD_ADDR_EXP 128
44393: PUSH
44394: LD_INT 1
44396: ST_TO_ADDR
// if p3 = 117 then
44397: LD_VAR 0 3
44401: PUSH
44402: LD_INT 117
44404: EQUAL
44405: IFFALSE 44415
// s30 := true ;
44407: LD_ADDR_EXP 129
44411: PUSH
44412: LD_INT 1
44414: ST_TO_ADDR
// if p3 = 118 then
44415: LD_VAR 0 3
44419: PUSH
44420: LD_INT 118
44422: EQUAL
44423: IFFALSE 44433
// s60 := true ;
44425: LD_ADDR_EXP 130
44429: PUSH
44430: LD_INT 1
44432: ST_TO_ADDR
// end ; if p2 = hack_mode then
44433: LD_VAR 0 2
44437: PUSH
44438: LD_INT 101
44440: EQUAL
44441: IFFALSE 44569
// begin case p3 of 1 :
44443: LD_VAR 0 3
44447: PUSH
44448: LD_INT 1
44450: DOUBLE
44451: EQUAL
44452: IFTRUE 44456
44454: GO 44463
44456: POP
// hHackUnlimitedResources ; 2 :
44457: CALL 56716 0 0
44461: GO 44569
44463: LD_INT 2
44465: DOUBLE
44466: EQUAL
44467: IFTRUE 44471
44469: GO 44478
44471: POP
// hHackSetLevel10 ; 3 :
44472: CALL 56849 0 0
44476: GO 44569
44478: LD_INT 3
44480: DOUBLE
44481: EQUAL
44482: IFTRUE 44486
44484: GO 44493
44486: POP
// hHackSetLevel10YourUnits ; 4 :
44487: CALL 56934 0 0
44491: GO 44569
44493: LD_INT 4
44495: DOUBLE
44496: EQUAL
44497: IFTRUE 44501
44499: GO 44508
44501: POP
// hHackInvincible ; 5 :
44502: CALL 57382 0 0
44506: GO 44569
44508: LD_INT 5
44510: DOUBLE
44511: EQUAL
44512: IFTRUE 44516
44514: GO 44523
44516: POP
// hHackInvisible ; 6 :
44517: CALL 57493 0 0
44521: GO 44569
44523: LD_INT 6
44525: DOUBLE
44526: EQUAL
44527: IFTRUE 44531
44529: GO 44538
44531: POP
// hHackChangeYourSide ; 7 :
44532: CALL 57550 0 0
44536: GO 44569
44538: LD_INT 7
44540: DOUBLE
44541: EQUAL
44542: IFTRUE 44546
44544: GO 44553
44546: POP
// hHackChangeUnitSide ; 8 :
44547: CALL 57592 0 0
44551: GO 44569
44553: LD_INT 8
44555: DOUBLE
44556: EQUAL
44557: IFTRUE 44561
44559: GO 44568
44561: POP
// hHackFog ; end ;
44562: CALL 57693 0 0
44566: GO 44569
44568: POP
// end ; if p2 = game_save_mode then
44569: LD_VAR 0 2
44573: PUSH
44574: LD_INT 102
44576: EQUAL
44577: IFFALSE 44632
// begin if p3 = 1 then
44579: LD_VAR 0 3
44583: PUSH
44584: LD_INT 1
44586: EQUAL
44587: IFFALSE 44599
// globalGameSaveCounter := p4 ;
44589: LD_ADDR_EXP 73
44593: PUSH
44594: LD_VAR 0 4
44598: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
44599: LD_VAR 0 3
44603: PUSH
44604: LD_INT 2
44606: EQUAL
44607: PUSH
44608: LD_EXP 73
44612: AND
44613: IFFALSE 44632
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
44615: LD_STRING setGameSaveCounter(
44617: PUSH
44618: LD_EXP 73
44622: STR
44623: PUSH
44624: LD_STRING )
44626: STR
44627: PPUSH
44628: CALL_OW 559
// end ; end ;
44632: LD_VAR 0 7
44636: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
44637: LD_INT 0
44639: PPUSH
// streamModeActive := false ;
44640: LD_ADDR_EXP 74
44644: PUSH
44645: LD_INT 0
44647: ST_TO_ADDR
// normalCounter := 36 ;
44648: LD_ADDR_EXP 75
44652: PUSH
44653: LD_INT 36
44655: ST_TO_ADDR
// hardcoreCounter := 18 ;
44656: LD_ADDR_EXP 76
44660: PUSH
44661: LD_INT 18
44663: ST_TO_ADDR
// sRocket := false ;
44664: LD_ADDR_EXP 79
44668: PUSH
44669: LD_INT 0
44671: ST_TO_ADDR
// sSpeed := false ;
44672: LD_ADDR_EXP 78
44676: PUSH
44677: LD_INT 0
44679: ST_TO_ADDR
// sEngine := false ;
44680: LD_ADDR_EXP 80
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sSpec := false ;
44688: LD_ADDR_EXP 77
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sLevel := false ;
44696: LD_ADDR_EXP 81
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sArmoury := false ;
44704: LD_ADDR_EXP 82
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sRadar := false ;
44712: LD_ADDR_EXP 83
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sBunker := false ;
44720: LD_ADDR_EXP 84
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sHack := false ;
44728: LD_ADDR_EXP 85
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sFire := false ;
44736: LD_ADDR_EXP 86
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sRefresh := false ;
44744: LD_ADDR_EXP 87
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sExp := false ;
44752: LD_ADDR_EXP 88
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sDepot := false ;
44760: LD_ADDR_EXP 89
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sFlag := false ;
44768: LD_ADDR_EXP 90
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sKamikadze := false ;
44776: LD_ADDR_EXP 98
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sTroll := false ;
44784: LD_ADDR_EXP 99
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sSlow := false ;
44792: LD_ADDR_EXP 100
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sLack := false ;
44800: LD_ADDR_EXP 101
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sTank := false ;
44808: LD_ADDR_EXP 103
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sRemote := false ;
44816: LD_ADDR_EXP 104
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sPowell := false ;
44824: LD_ADDR_EXP 105
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sTeleport := false ;
44832: LD_ADDR_EXP 108
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sOilTower := false ;
44840: LD_ADDR_EXP 110
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sShovel := false ;
44848: LD_ADDR_EXP 111
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sSheik := false ;
44856: LD_ADDR_EXP 112
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sEarthquake := false ;
44864: LD_ADDR_EXP 114
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// sAI := false ;
44872: LD_ADDR_EXP 115
44876: PUSH
44877: LD_INT 0
44879: ST_TO_ADDR
// sCargo := false ;
44880: LD_ADDR_EXP 118
44884: PUSH
44885: LD_INT 0
44887: ST_TO_ADDR
// sDLaser := false ;
44888: LD_ADDR_EXP 119
44892: PUSH
44893: LD_INT 0
44895: ST_TO_ADDR
// sExchange := false ;
44896: LD_ADDR_EXP 120
44900: PUSH
44901: LD_INT 0
44903: ST_TO_ADDR
// sFac := false ;
44904: LD_ADDR_EXP 121
44908: PUSH
44909: LD_INT 0
44911: ST_TO_ADDR
// sPower := false ;
44912: LD_ADDR_EXP 122
44916: PUSH
44917: LD_INT 0
44919: ST_TO_ADDR
// sRandom := false ;
44920: LD_ADDR_EXP 123
44924: PUSH
44925: LD_INT 0
44927: ST_TO_ADDR
// sShield := false ;
44928: LD_ADDR_EXP 124
44932: PUSH
44933: LD_INT 0
44935: ST_TO_ADDR
// sTime := false ;
44936: LD_ADDR_EXP 125
44940: PUSH
44941: LD_INT 0
44943: ST_TO_ADDR
// sTools := false ;
44944: LD_ADDR_EXP 126
44948: PUSH
44949: LD_INT 0
44951: ST_TO_ADDR
// sSold := false ;
44952: LD_ADDR_EXP 91
44956: PUSH
44957: LD_INT 0
44959: ST_TO_ADDR
// sDiff := false ;
44960: LD_ADDR_EXP 92
44964: PUSH
44965: LD_INT 0
44967: ST_TO_ADDR
// sFog := false ;
44968: LD_ADDR_EXP 95
44972: PUSH
44973: LD_INT 0
44975: ST_TO_ADDR
// sReset := false ;
44976: LD_ADDR_EXP 96
44980: PUSH
44981: LD_INT 0
44983: ST_TO_ADDR
// sSun := false ;
44984: LD_ADDR_EXP 97
44988: PUSH
44989: LD_INT 0
44991: ST_TO_ADDR
// sTiger := false ;
44992: LD_ADDR_EXP 93
44996: PUSH
44997: LD_INT 0
44999: ST_TO_ADDR
// sBomb := false ;
45000: LD_ADDR_EXP 94
45004: PUSH
45005: LD_INT 0
45007: ST_TO_ADDR
// sWound := false ;
45008: LD_ADDR_EXP 102
45012: PUSH
45013: LD_INT 0
45015: ST_TO_ADDR
// sBetray := false ;
45016: LD_ADDR_EXP 106
45020: PUSH
45021: LD_INT 0
45023: ST_TO_ADDR
// sContamin := false ;
45024: LD_ADDR_EXP 107
45028: PUSH
45029: LD_INT 0
45031: ST_TO_ADDR
// sOil := false ;
45032: LD_ADDR_EXP 109
45036: PUSH
45037: LD_INT 0
45039: ST_TO_ADDR
// sStu := false ;
45040: LD_ADDR_EXP 113
45044: PUSH
45045: LD_INT 0
45047: ST_TO_ADDR
// sBazooka := false ;
45048: LD_ADDR_EXP 116
45052: PUSH
45053: LD_INT 0
45055: ST_TO_ADDR
// sMortar := false ;
45056: LD_ADDR_EXP 117
45060: PUSH
45061: LD_INT 0
45063: ST_TO_ADDR
// sRanger := false ;
45064: LD_ADDR_EXP 127
45068: PUSH
45069: LD_INT 0
45071: ST_TO_ADDR
// sComputer := false ;
45072: LD_ADDR_EXP 128
45076: PUSH
45077: LD_INT 0
45079: ST_TO_ADDR
// s30 := false ;
45080: LD_ADDR_EXP 129
45084: PUSH
45085: LD_INT 0
45087: ST_TO_ADDR
// s60 := false ;
45088: LD_ADDR_EXP 130
45092: PUSH
45093: LD_INT 0
45095: ST_TO_ADDR
// end ;
45096: LD_VAR 0 1
45100: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45101: LD_INT 0
45103: PPUSH
45104: PPUSH
45105: PPUSH
45106: PPUSH
45107: PPUSH
45108: PPUSH
45109: PPUSH
// result := [ ] ;
45110: LD_ADDR_VAR 0 2
45114: PUSH
45115: EMPTY
45116: ST_TO_ADDR
// if campaign_id = 1 then
45117: LD_OWVAR 69
45121: PUSH
45122: LD_INT 1
45124: EQUAL
45125: IFFALSE 48291
// begin case mission_number of 1 :
45127: LD_OWVAR 70
45131: PUSH
45132: LD_INT 1
45134: DOUBLE
45135: EQUAL
45136: IFTRUE 45140
45138: GO 45216
45140: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45141: LD_ADDR_VAR 0 2
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: LD_INT 4
45151: PUSH
45152: LD_INT 11
45154: PUSH
45155: LD_INT 12
45157: PUSH
45158: LD_INT 15
45160: PUSH
45161: LD_INT 16
45163: PUSH
45164: LD_INT 22
45166: PUSH
45167: LD_INT 23
45169: PUSH
45170: LD_INT 26
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 101
45186: PUSH
45187: LD_INT 102
45189: PUSH
45190: LD_INT 106
45192: PUSH
45193: LD_INT 116
45195: PUSH
45196: LD_INT 117
45198: PUSH
45199: LD_INT 118
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: ST_TO_ADDR
45214: GO 48289
45216: LD_INT 2
45218: DOUBLE
45219: EQUAL
45220: IFTRUE 45224
45222: GO 45308
45224: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45225: LD_ADDR_VAR 0 2
45229: PUSH
45230: LD_INT 2
45232: PUSH
45233: LD_INT 4
45235: PUSH
45236: LD_INT 11
45238: PUSH
45239: LD_INT 12
45241: PUSH
45242: LD_INT 15
45244: PUSH
45245: LD_INT 16
45247: PUSH
45248: LD_INT 22
45250: PUSH
45251: LD_INT 23
45253: PUSH
45254: LD_INT 26
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 101
45270: PUSH
45271: LD_INT 102
45273: PUSH
45274: LD_INT 105
45276: PUSH
45277: LD_INT 106
45279: PUSH
45280: LD_INT 108
45282: PUSH
45283: LD_INT 116
45285: PUSH
45286: LD_INT 117
45288: PUSH
45289: LD_INT 118
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: ST_TO_ADDR
45306: GO 48289
45308: LD_INT 3
45310: DOUBLE
45311: EQUAL
45312: IFTRUE 45316
45314: GO 45404
45316: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45317: LD_ADDR_VAR 0 2
45321: PUSH
45322: LD_INT 2
45324: PUSH
45325: LD_INT 4
45327: PUSH
45328: LD_INT 5
45330: PUSH
45331: LD_INT 11
45333: PUSH
45334: LD_INT 12
45336: PUSH
45337: LD_INT 15
45339: PUSH
45340: LD_INT 16
45342: PUSH
45343: LD_INT 22
45345: PUSH
45346: LD_INT 26
45348: PUSH
45349: LD_INT 36
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 101
45366: PUSH
45367: LD_INT 102
45369: PUSH
45370: LD_INT 105
45372: PUSH
45373: LD_INT 106
45375: PUSH
45376: LD_INT 108
45378: PUSH
45379: LD_INT 116
45381: PUSH
45382: LD_INT 117
45384: PUSH
45385: LD_INT 118
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: ST_TO_ADDR
45402: GO 48289
45404: LD_INT 4
45406: DOUBLE
45407: EQUAL
45408: IFTRUE 45412
45410: GO 45508
45412: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45413: LD_ADDR_VAR 0 2
45417: PUSH
45418: LD_INT 2
45420: PUSH
45421: LD_INT 4
45423: PUSH
45424: LD_INT 5
45426: PUSH
45427: LD_INT 8
45429: PUSH
45430: LD_INT 11
45432: PUSH
45433: LD_INT 12
45435: PUSH
45436: LD_INT 15
45438: PUSH
45439: LD_INT 16
45441: PUSH
45442: LD_INT 22
45444: PUSH
45445: LD_INT 23
45447: PUSH
45448: LD_INT 26
45450: PUSH
45451: LD_INT 36
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 101
45470: PUSH
45471: LD_INT 102
45473: PUSH
45474: LD_INT 105
45476: PUSH
45477: LD_INT 106
45479: PUSH
45480: LD_INT 108
45482: PUSH
45483: LD_INT 116
45485: PUSH
45486: LD_INT 117
45488: PUSH
45489: LD_INT 118
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: ST_TO_ADDR
45506: GO 48289
45508: LD_INT 5
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45516
45514: GO 45628
45516: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45517: LD_ADDR_VAR 0 2
45521: PUSH
45522: LD_INT 2
45524: PUSH
45525: LD_INT 4
45527: PUSH
45528: LD_INT 5
45530: PUSH
45531: LD_INT 6
45533: PUSH
45534: LD_INT 8
45536: PUSH
45537: LD_INT 11
45539: PUSH
45540: LD_INT 12
45542: PUSH
45543: LD_INT 15
45545: PUSH
45546: LD_INT 16
45548: PUSH
45549: LD_INT 22
45551: PUSH
45552: LD_INT 23
45554: PUSH
45555: LD_INT 25
45557: PUSH
45558: LD_INT 26
45560: PUSH
45561: LD_INT 36
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 101
45582: PUSH
45583: LD_INT 102
45585: PUSH
45586: LD_INT 105
45588: PUSH
45589: LD_INT 106
45591: PUSH
45592: LD_INT 108
45594: PUSH
45595: LD_INT 109
45597: PUSH
45598: LD_INT 112
45600: PUSH
45601: LD_INT 116
45603: PUSH
45604: LD_INT 117
45606: PUSH
45607: LD_INT 118
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: ST_TO_ADDR
45626: GO 48289
45628: LD_INT 6
45630: DOUBLE
45631: EQUAL
45632: IFTRUE 45636
45634: GO 45768
45636: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45637: LD_ADDR_VAR 0 2
45641: PUSH
45642: LD_INT 2
45644: PUSH
45645: LD_INT 4
45647: PUSH
45648: LD_INT 5
45650: PUSH
45651: LD_INT 6
45653: PUSH
45654: LD_INT 8
45656: PUSH
45657: LD_INT 11
45659: PUSH
45660: LD_INT 12
45662: PUSH
45663: LD_INT 15
45665: PUSH
45666: LD_INT 16
45668: PUSH
45669: LD_INT 20
45671: PUSH
45672: LD_INT 21
45674: PUSH
45675: LD_INT 22
45677: PUSH
45678: LD_INT 23
45680: PUSH
45681: LD_INT 25
45683: PUSH
45684: LD_INT 26
45686: PUSH
45687: LD_INT 30
45689: PUSH
45690: LD_INT 31
45692: PUSH
45693: LD_INT 32
45695: PUSH
45696: LD_INT 36
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: LIST
45716: LIST
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 101
45722: PUSH
45723: LD_INT 102
45725: PUSH
45726: LD_INT 105
45728: PUSH
45729: LD_INT 106
45731: PUSH
45732: LD_INT 108
45734: PUSH
45735: LD_INT 109
45737: PUSH
45738: LD_INT 112
45740: PUSH
45741: LD_INT 116
45743: PUSH
45744: LD_INT 117
45746: PUSH
45747: LD_INT 118
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: ST_TO_ADDR
45766: GO 48289
45768: LD_INT 7
45770: DOUBLE
45771: EQUAL
45772: IFTRUE 45776
45774: GO 45888
45776: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45777: LD_ADDR_VAR 0 2
45781: PUSH
45782: LD_INT 2
45784: PUSH
45785: LD_INT 4
45787: PUSH
45788: LD_INT 5
45790: PUSH
45791: LD_INT 7
45793: PUSH
45794: LD_INT 11
45796: PUSH
45797: LD_INT 12
45799: PUSH
45800: LD_INT 15
45802: PUSH
45803: LD_INT 16
45805: PUSH
45806: LD_INT 20
45808: PUSH
45809: LD_INT 21
45811: PUSH
45812: LD_INT 22
45814: PUSH
45815: LD_INT 23
45817: PUSH
45818: LD_INT 25
45820: PUSH
45821: LD_INT 26
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 101
45842: PUSH
45843: LD_INT 102
45845: PUSH
45846: LD_INT 103
45848: PUSH
45849: LD_INT 105
45851: PUSH
45852: LD_INT 106
45854: PUSH
45855: LD_INT 108
45857: PUSH
45858: LD_INT 112
45860: PUSH
45861: LD_INT 116
45863: PUSH
45864: LD_INT 117
45866: PUSH
45867: LD_INT 118
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: ST_TO_ADDR
45886: GO 48289
45888: LD_INT 8
45890: DOUBLE
45891: EQUAL
45892: IFTRUE 45896
45894: GO 46036
45896: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45897: LD_ADDR_VAR 0 2
45901: PUSH
45902: LD_INT 2
45904: PUSH
45905: LD_INT 4
45907: PUSH
45908: LD_INT 5
45910: PUSH
45911: LD_INT 6
45913: PUSH
45914: LD_INT 7
45916: PUSH
45917: LD_INT 8
45919: PUSH
45920: LD_INT 11
45922: PUSH
45923: LD_INT 12
45925: PUSH
45926: LD_INT 15
45928: PUSH
45929: LD_INT 16
45931: PUSH
45932: LD_INT 20
45934: PUSH
45935: LD_INT 21
45937: PUSH
45938: LD_INT 22
45940: PUSH
45941: LD_INT 23
45943: PUSH
45944: LD_INT 25
45946: PUSH
45947: LD_INT 26
45949: PUSH
45950: LD_INT 30
45952: PUSH
45953: LD_INT 31
45955: PUSH
45956: LD_INT 32
45958: PUSH
45959: LD_INT 36
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 101
45986: PUSH
45987: LD_INT 102
45989: PUSH
45990: LD_INT 103
45992: PUSH
45993: LD_INT 105
45995: PUSH
45996: LD_INT 106
45998: PUSH
45999: LD_INT 108
46001: PUSH
46002: LD_INT 109
46004: PUSH
46005: LD_INT 112
46007: PUSH
46008: LD_INT 116
46010: PUSH
46011: LD_INT 117
46013: PUSH
46014: LD_INT 118
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: ST_TO_ADDR
46034: GO 48289
46036: LD_INT 9
46038: DOUBLE
46039: EQUAL
46040: IFTRUE 46044
46042: GO 46192
46044: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46045: LD_ADDR_VAR 0 2
46049: PUSH
46050: LD_INT 2
46052: PUSH
46053: LD_INT 4
46055: PUSH
46056: LD_INT 5
46058: PUSH
46059: LD_INT 6
46061: PUSH
46062: LD_INT 7
46064: PUSH
46065: LD_INT 8
46067: PUSH
46068: LD_INT 11
46070: PUSH
46071: LD_INT 12
46073: PUSH
46074: LD_INT 15
46076: PUSH
46077: LD_INT 16
46079: PUSH
46080: LD_INT 20
46082: PUSH
46083: LD_INT 21
46085: PUSH
46086: LD_INT 22
46088: PUSH
46089: LD_INT 23
46091: PUSH
46092: LD_INT 25
46094: PUSH
46095: LD_INT 26
46097: PUSH
46098: LD_INT 28
46100: PUSH
46101: LD_INT 30
46103: PUSH
46104: LD_INT 31
46106: PUSH
46107: LD_INT 32
46109: PUSH
46110: LD_INT 36
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 101
46138: PUSH
46139: LD_INT 102
46141: PUSH
46142: LD_INT 103
46144: PUSH
46145: LD_INT 105
46147: PUSH
46148: LD_INT 106
46150: PUSH
46151: LD_INT 108
46153: PUSH
46154: LD_INT 109
46156: PUSH
46157: LD_INT 112
46159: PUSH
46160: LD_INT 114
46162: PUSH
46163: LD_INT 116
46165: PUSH
46166: LD_INT 117
46168: PUSH
46169: LD_INT 118
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: ST_TO_ADDR
46190: GO 48289
46192: LD_INT 10
46194: DOUBLE
46195: EQUAL
46196: IFTRUE 46200
46198: GO 46396
46200: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46201: LD_ADDR_VAR 0 2
46205: PUSH
46206: LD_INT 2
46208: PUSH
46209: LD_INT 4
46211: PUSH
46212: LD_INT 5
46214: PUSH
46215: LD_INT 6
46217: PUSH
46218: LD_INT 7
46220: PUSH
46221: LD_INT 8
46223: PUSH
46224: LD_INT 9
46226: PUSH
46227: LD_INT 10
46229: PUSH
46230: LD_INT 11
46232: PUSH
46233: LD_INT 12
46235: PUSH
46236: LD_INT 13
46238: PUSH
46239: LD_INT 14
46241: PUSH
46242: LD_INT 15
46244: PUSH
46245: LD_INT 16
46247: PUSH
46248: LD_INT 17
46250: PUSH
46251: LD_INT 18
46253: PUSH
46254: LD_INT 19
46256: PUSH
46257: LD_INT 20
46259: PUSH
46260: LD_INT 21
46262: PUSH
46263: LD_INT 22
46265: PUSH
46266: LD_INT 23
46268: PUSH
46269: LD_INT 24
46271: PUSH
46272: LD_INT 25
46274: PUSH
46275: LD_INT 26
46277: PUSH
46278: LD_INT 28
46280: PUSH
46281: LD_INT 30
46283: PUSH
46284: LD_INT 31
46286: PUSH
46287: LD_INT 32
46289: PUSH
46290: LD_INT 36
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 101
46326: PUSH
46327: LD_INT 102
46329: PUSH
46330: LD_INT 103
46332: PUSH
46333: LD_INT 104
46335: PUSH
46336: LD_INT 105
46338: PUSH
46339: LD_INT 106
46341: PUSH
46342: LD_INT 107
46344: PUSH
46345: LD_INT 108
46347: PUSH
46348: LD_INT 109
46350: PUSH
46351: LD_INT 110
46353: PUSH
46354: LD_INT 111
46356: PUSH
46357: LD_INT 112
46359: PUSH
46360: LD_INT 114
46362: PUSH
46363: LD_INT 116
46365: PUSH
46366: LD_INT 117
46368: PUSH
46369: LD_INT 118
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: ST_TO_ADDR
46394: GO 48289
46396: LD_INT 11
46398: DOUBLE
46399: EQUAL
46400: IFTRUE 46404
46402: GO 46608
46404: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46405: LD_ADDR_VAR 0 2
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: LD_INT 3
46415: PUSH
46416: LD_INT 4
46418: PUSH
46419: LD_INT 5
46421: PUSH
46422: LD_INT 6
46424: PUSH
46425: LD_INT 7
46427: PUSH
46428: LD_INT 8
46430: PUSH
46431: LD_INT 9
46433: PUSH
46434: LD_INT 10
46436: PUSH
46437: LD_INT 11
46439: PUSH
46440: LD_INT 12
46442: PUSH
46443: LD_INT 13
46445: PUSH
46446: LD_INT 14
46448: PUSH
46449: LD_INT 15
46451: PUSH
46452: LD_INT 16
46454: PUSH
46455: LD_INT 17
46457: PUSH
46458: LD_INT 18
46460: PUSH
46461: LD_INT 19
46463: PUSH
46464: LD_INT 20
46466: PUSH
46467: LD_INT 21
46469: PUSH
46470: LD_INT 22
46472: PUSH
46473: LD_INT 23
46475: PUSH
46476: LD_INT 24
46478: PUSH
46479: LD_INT 25
46481: PUSH
46482: LD_INT 26
46484: PUSH
46485: LD_INT 28
46487: PUSH
46488: LD_INT 30
46490: PUSH
46491: LD_INT 31
46493: PUSH
46494: LD_INT 32
46496: PUSH
46497: LD_INT 34
46499: PUSH
46500: LD_INT 36
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: PUSH
46536: LD_INT 101
46538: PUSH
46539: LD_INT 102
46541: PUSH
46542: LD_INT 103
46544: PUSH
46545: LD_INT 104
46547: PUSH
46548: LD_INT 105
46550: PUSH
46551: LD_INT 106
46553: PUSH
46554: LD_INT 107
46556: PUSH
46557: LD_INT 108
46559: PUSH
46560: LD_INT 109
46562: PUSH
46563: LD_INT 110
46565: PUSH
46566: LD_INT 111
46568: PUSH
46569: LD_INT 112
46571: PUSH
46572: LD_INT 114
46574: PUSH
46575: LD_INT 116
46577: PUSH
46578: LD_INT 117
46580: PUSH
46581: LD_INT 118
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: ST_TO_ADDR
46606: GO 48289
46608: LD_INT 12
46610: DOUBLE
46611: EQUAL
46612: IFTRUE 46616
46614: GO 46836
46616: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46617: LD_ADDR_VAR 0 2
46621: PUSH
46622: LD_INT 1
46624: PUSH
46625: LD_INT 2
46627: PUSH
46628: LD_INT 3
46630: PUSH
46631: LD_INT 4
46633: PUSH
46634: LD_INT 5
46636: PUSH
46637: LD_INT 6
46639: PUSH
46640: LD_INT 7
46642: PUSH
46643: LD_INT 8
46645: PUSH
46646: LD_INT 9
46648: PUSH
46649: LD_INT 10
46651: PUSH
46652: LD_INT 11
46654: PUSH
46655: LD_INT 12
46657: PUSH
46658: LD_INT 13
46660: PUSH
46661: LD_INT 14
46663: PUSH
46664: LD_INT 15
46666: PUSH
46667: LD_INT 16
46669: PUSH
46670: LD_INT 17
46672: PUSH
46673: LD_INT 18
46675: PUSH
46676: LD_INT 19
46678: PUSH
46679: LD_INT 20
46681: PUSH
46682: LD_INT 21
46684: PUSH
46685: LD_INT 22
46687: PUSH
46688: LD_INT 23
46690: PUSH
46691: LD_INT 24
46693: PUSH
46694: LD_INT 25
46696: PUSH
46697: LD_INT 26
46699: PUSH
46700: LD_INT 27
46702: PUSH
46703: LD_INT 28
46705: PUSH
46706: LD_INT 30
46708: PUSH
46709: LD_INT 31
46711: PUSH
46712: LD_INT 32
46714: PUSH
46715: LD_INT 33
46717: PUSH
46718: LD_INT 34
46720: PUSH
46721: LD_INT 36
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: PUSH
46760: LD_INT 101
46762: PUSH
46763: LD_INT 102
46765: PUSH
46766: LD_INT 103
46768: PUSH
46769: LD_INT 104
46771: PUSH
46772: LD_INT 105
46774: PUSH
46775: LD_INT 106
46777: PUSH
46778: LD_INT 107
46780: PUSH
46781: LD_INT 108
46783: PUSH
46784: LD_INT 109
46786: PUSH
46787: LD_INT 110
46789: PUSH
46790: LD_INT 111
46792: PUSH
46793: LD_INT 112
46795: PUSH
46796: LD_INT 113
46798: PUSH
46799: LD_INT 114
46801: PUSH
46802: LD_INT 116
46804: PUSH
46805: LD_INT 117
46807: PUSH
46808: LD_INT 118
46810: PUSH
46811: EMPTY
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: ST_TO_ADDR
46834: GO 48289
46836: LD_INT 13
46838: DOUBLE
46839: EQUAL
46840: IFTRUE 46844
46842: GO 47052
46844: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46845: LD_ADDR_VAR 0 2
46849: PUSH
46850: LD_INT 1
46852: PUSH
46853: LD_INT 2
46855: PUSH
46856: LD_INT 3
46858: PUSH
46859: LD_INT 4
46861: PUSH
46862: LD_INT 5
46864: PUSH
46865: LD_INT 8
46867: PUSH
46868: LD_INT 9
46870: PUSH
46871: LD_INT 10
46873: PUSH
46874: LD_INT 11
46876: PUSH
46877: LD_INT 12
46879: PUSH
46880: LD_INT 14
46882: PUSH
46883: LD_INT 15
46885: PUSH
46886: LD_INT 16
46888: PUSH
46889: LD_INT 17
46891: PUSH
46892: LD_INT 18
46894: PUSH
46895: LD_INT 19
46897: PUSH
46898: LD_INT 20
46900: PUSH
46901: LD_INT 21
46903: PUSH
46904: LD_INT 22
46906: PUSH
46907: LD_INT 23
46909: PUSH
46910: LD_INT 24
46912: PUSH
46913: LD_INT 25
46915: PUSH
46916: LD_INT 26
46918: PUSH
46919: LD_INT 27
46921: PUSH
46922: LD_INT 28
46924: PUSH
46925: LD_INT 30
46927: PUSH
46928: LD_INT 31
46930: PUSH
46931: LD_INT 32
46933: PUSH
46934: LD_INT 33
46936: PUSH
46937: LD_INT 34
46939: PUSH
46940: LD_INT 36
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 101
46978: PUSH
46979: LD_INT 102
46981: PUSH
46982: LD_INT 103
46984: PUSH
46985: LD_INT 104
46987: PUSH
46988: LD_INT 105
46990: PUSH
46991: LD_INT 106
46993: PUSH
46994: LD_INT 107
46996: PUSH
46997: LD_INT 108
46999: PUSH
47000: LD_INT 109
47002: PUSH
47003: LD_INT 110
47005: PUSH
47006: LD_INT 111
47008: PUSH
47009: LD_INT 112
47011: PUSH
47012: LD_INT 113
47014: PUSH
47015: LD_INT 114
47017: PUSH
47018: LD_INT 116
47020: PUSH
47021: LD_INT 117
47023: PUSH
47024: LD_INT 118
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: ST_TO_ADDR
47050: GO 48289
47052: LD_INT 14
47054: DOUBLE
47055: EQUAL
47056: IFTRUE 47060
47058: GO 47284
47060: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47061: LD_ADDR_VAR 0 2
47065: PUSH
47066: LD_INT 1
47068: PUSH
47069: LD_INT 2
47071: PUSH
47072: LD_INT 3
47074: PUSH
47075: LD_INT 4
47077: PUSH
47078: LD_INT 5
47080: PUSH
47081: LD_INT 6
47083: PUSH
47084: LD_INT 7
47086: PUSH
47087: LD_INT 8
47089: PUSH
47090: LD_INT 9
47092: PUSH
47093: LD_INT 10
47095: PUSH
47096: LD_INT 11
47098: PUSH
47099: LD_INT 12
47101: PUSH
47102: LD_INT 13
47104: PUSH
47105: LD_INT 14
47107: PUSH
47108: LD_INT 15
47110: PUSH
47111: LD_INT 16
47113: PUSH
47114: LD_INT 17
47116: PUSH
47117: LD_INT 18
47119: PUSH
47120: LD_INT 19
47122: PUSH
47123: LD_INT 20
47125: PUSH
47126: LD_INT 21
47128: PUSH
47129: LD_INT 22
47131: PUSH
47132: LD_INT 23
47134: PUSH
47135: LD_INT 24
47137: PUSH
47138: LD_INT 25
47140: PUSH
47141: LD_INT 26
47143: PUSH
47144: LD_INT 27
47146: PUSH
47147: LD_INT 28
47149: PUSH
47150: LD_INT 29
47152: PUSH
47153: LD_INT 30
47155: PUSH
47156: LD_INT 31
47158: PUSH
47159: LD_INT 32
47161: PUSH
47162: LD_INT 33
47164: PUSH
47165: LD_INT 34
47167: PUSH
47168: LD_INT 36
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 101
47210: PUSH
47211: LD_INT 102
47213: PUSH
47214: LD_INT 103
47216: PUSH
47217: LD_INT 104
47219: PUSH
47220: LD_INT 105
47222: PUSH
47223: LD_INT 106
47225: PUSH
47226: LD_INT 107
47228: PUSH
47229: LD_INT 108
47231: PUSH
47232: LD_INT 109
47234: PUSH
47235: LD_INT 110
47237: PUSH
47238: LD_INT 111
47240: PUSH
47241: LD_INT 112
47243: PUSH
47244: LD_INT 113
47246: PUSH
47247: LD_INT 114
47249: PUSH
47250: LD_INT 116
47252: PUSH
47253: LD_INT 117
47255: PUSH
47256: LD_INT 118
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: ST_TO_ADDR
47282: GO 48289
47284: LD_INT 15
47286: DOUBLE
47287: EQUAL
47288: IFTRUE 47292
47290: GO 47516
47292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47293: LD_ADDR_VAR 0 2
47297: PUSH
47298: LD_INT 1
47300: PUSH
47301: LD_INT 2
47303: PUSH
47304: LD_INT 3
47306: PUSH
47307: LD_INT 4
47309: PUSH
47310: LD_INT 5
47312: PUSH
47313: LD_INT 6
47315: PUSH
47316: LD_INT 7
47318: PUSH
47319: LD_INT 8
47321: PUSH
47322: LD_INT 9
47324: PUSH
47325: LD_INT 10
47327: PUSH
47328: LD_INT 11
47330: PUSH
47331: LD_INT 12
47333: PUSH
47334: LD_INT 13
47336: PUSH
47337: LD_INT 14
47339: PUSH
47340: LD_INT 15
47342: PUSH
47343: LD_INT 16
47345: PUSH
47346: LD_INT 17
47348: PUSH
47349: LD_INT 18
47351: PUSH
47352: LD_INT 19
47354: PUSH
47355: LD_INT 20
47357: PUSH
47358: LD_INT 21
47360: PUSH
47361: LD_INT 22
47363: PUSH
47364: LD_INT 23
47366: PUSH
47367: LD_INT 24
47369: PUSH
47370: LD_INT 25
47372: PUSH
47373: LD_INT 26
47375: PUSH
47376: LD_INT 27
47378: PUSH
47379: LD_INT 28
47381: PUSH
47382: LD_INT 29
47384: PUSH
47385: LD_INT 30
47387: PUSH
47388: LD_INT 31
47390: PUSH
47391: LD_INT 32
47393: PUSH
47394: LD_INT 33
47396: PUSH
47397: LD_INT 34
47399: PUSH
47400: LD_INT 36
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 101
47442: PUSH
47443: LD_INT 102
47445: PUSH
47446: LD_INT 103
47448: PUSH
47449: LD_INT 104
47451: PUSH
47452: LD_INT 105
47454: PUSH
47455: LD_INT 106
47457: PUSH
47458: LD_INT 107
47460: PUSH
47461: LD_INT 108
47463: PUSH
47464: LD_INT 109
47466: PUSH
47467: LD_INT 110
47469: PUSH
47470: LD_INT 111
47472: PUSH
47473: LD_INT 112
47475: PUSH
47476: LD_INT 113
47478: PUSH
47479: LD_INT 114
47481: PUSH
47482: LD_INT 116
47484: PUSH
47485: LD_INT 117
47487: PUSH
47488: LD_INT 118
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: ST_TO_ADDR
47514: GO 48289
47516: LD_INT 16
47518: DOUBLE
47519: EQUAL
47520: IFTRUE 47524
47522: GO 47660
47524: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47525: LD_ADDR_VAR 0 2
47529: PUSH
47530: LD_INT 2
47532: PUSH
47533: LD_INT 4
47535: PUSH
47536: LD_INT 5
47538: PUSH
47539: LD_INT 7
47541: PUSH
47542: LD_INT 11
47544: PUSH
47545: LD_INT 12
47547: PUSH
47548: LD_INT 15
47550: PUSH
47551: LD_INT 16
47553: PUSH
47554: LD_INT 20
47556: PUSH
47557: LD_INT 21
47559: PUSH
47560: LD_INT 22
47562: PUSH
47563: LD_INT 23
47565: PUSH
47566: LD_INT 25
47568: PUSH
47569: LD_INT 26
47571: PUSH
47572: LD_INT 30
47574: PUSH
47575: LD_INT 31
47577: PUSH
47578: LD_INT 32
47580: PUSH
47581: LD_INT 33
47583: PUSH
47584: LD_INT 34
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: PUSH
47608: LD_INT 101
47610: PUSH
47611: LD_INT 102
47613: PUSH
47614: LD_INT 103
47616: PUSH
47617: LD_INT 106
47619: PUSH
47620: LD_INT 108
47622: PUSH
47623: LD_INT 112
47625: PUSH
47626: LD_INT 113
47628: PUSH
47629: LD_INT 114
47631: PUSH
47632: LD_INT 116
47634: PUSH
47635: LD_INT 117
47637: PUSH
47638: LD_INT 118
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: ST_TO_ADDR
47658: GO 48289
47660: LD_INT 17
47662: DOUBLE
47663: EQUAL
47664: IFTRUE 47668
47666: GO 47892
47668: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47669: LD_ADDR_VAR 0 2
47673: PUSH
47674: LD_INT 1
47676: PUSH
47677: LD_INT 2
47679: PUSH
47680: LD_INT 3
47682: PUSH
47683: LD_INT 4
47685: PUSH
47686: LD_INT 5
47688: PUSH
47689: LD_INT 6
47691: PUSH
47692: LD_INT 7
47694: PUSH
47695: LD_INT 8
47697: PUSH
47698: LD_INT 9
47700: PUSH
47701: LD_INT 10
47703: PUSH
47704: LD_INT 11
47706: PUSH
47707: LD_INT 12
47709: PUSH
47710: LD_INT 13
47712: PUSH
47713: LD_INT 14
47715: PUSH
47716: LD_INT 15
47718: PUSH
47719: LD_INT 16
47721: PUSH
47722: LD_INT 17
47724: PUSH
47725: LD_INT 18
47727: PUSH
47728: LD_INT 19
47730: PUSH
47731: LD_INT 20
47733: PUSH
47734: LD_INT 21
47736: PUSH
47737: LD_INT 22
47739: PUSH
47740: LD_INT 23
47742: PUSH
47743: LD_INT 24
47745: PUSH
47746: LD_INT 25
47748: PUSH
47749: LD_INT 26
47751: PUSH
47752: LD_INT 27
47754: PUSH
47755: LD_INT 28
47757: PUSH
47758: LD_INT 29
47760: PUSH
47761: LD_INT 30
47763: PUSH
47764: LD_INT 31
47766: PUSH
47767: LD_INT 32
47769: PUSH
47770: LD_INT 33
47772: PUSH
47773: LD_INT 34
47775: PUSH
47776: LD_INT 36
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 101
47818: PUSH
47819: LD_INT 102
47821: PUSH
47822: LD_INT 103
47824: PUSH
47825: LD_INT 104
47827: PUSH
47828: LD_INT 105
47830: PUSH
47831: LD_INT 106
47833: PUSH
47834: LD_INT 107
47836: PUSH
47837: LD_INT 108
47839: PUSH
47840: LD_INT 109
47842: PUSH
47843: LD_INT 110
47845: PUSH
47846: LD_INT 111
47848: PUSH
47849: LD_INT 112
47851: PUSH
47852: LD_INT 113
47854: PUSH
47855: LD_INT 114
47857: PUSH
47858: LD_INT 116
47860: PUSH
47861: LD_INT 117
47863: PUSH
47864: LD_INT 118
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: ST_TO_ADDR
47890: GO 48289
47892: LD_INT 18
47894: DOUBLE
47895: EQUAL
47896: IFTRUE 47900
47898: GO 48048
47900: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47901: LD_ADDR_VAR 0 2
47905: PUSH
47906: LD_INT 2
47908: PUSH
47909: LD_INT 4
47911: PUSH
47912: LD_INT 5
47914: PUSH
47915: LD_INT 7
47917: PUSH
47918: LD_INT 11
47920: PUSH
47921: LD_INT 12
47923: PUSH
47924: LD_INT 15
47926: PUSH
47927: LD_INT 16
47929: PUSH
47930: LD_INT 20
47932: PUSH
47933: LD_INT 21
47935: PUSH
47936: LD_INT 22
47938: PUSH
47939: LD_INT 23
47941: PUSH
47942: LD_INT 25
47944: PUSH
47945: LD_INT 26
47947: PUSH
47948: LD_INT 30
47950: PUSH
47951: LD_INT 31
47953: PUSH
47954: LD_INT 32
47956: PUSH
47957: LD_INT 33
47959: PUSH
47960: LD_INT 34
47962: PUSH
47963: LD_INT 35
47965: PUSH
47966: LD_INT 36
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 101
47994: PUSH
47995: LD_INT 102
47997: PUSH
47998: LD_INT 103
48000: PUSH
48001: LD_INT 106
48003: PUSH
48004: LD_INT 108
48006: PUSH
48007: LD_INT 112
48009: PUSH
48010: LD_INT 113
48012: PUSH
48013: LD_INT 114
48015: PUSH
48016: LD_INT 115
48018: PUSH
48019: LD_INT 116
48021: PUSH
48022: LD_INT 117
48024: PUSH
48025: LD_INT 118
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: ST_TO_ADDR
48046: GO 48289
48048: LD_INT 19
48050: DOUBLE
48051: EQUAL
48052: IFTRUE 48056
48054: GO 48288
48056: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48057: LD_ADDR_VAR 0 2
48061: PUSH
48062: LD_INT 1
48064: PUSH
48065: LD_INT 2
48067: PUSH
48068: LD_INT 3
48070: PUSH
48071: LD_INT 4
48073: PUSH
48074: LD_INT 5
48076: PUSH
48077: LD_INT 6
48079: PUSH
48080: LD_INT 7
48082: PUSH
48083: LD_INT 8
48085: PUSH
48086: LD_INT 9
48088: PUSH
48089: LD_INT 10
48091: PUSH
48092: LD_INT 11
48094: PUSH
48095: LD_INT 12
48097: PUSH
48098: LD_INT 13
48100: PUSH
48101: LD_INT 14
48103: PUSH
48104: LD_INT 15
48106: PUSH
48107: LD_INT 16
48109: PUSH
48110: LD_INT 17
48112: PUSH
48113: LD_INT 18
48115: PUSH
48116: LD_INT 19
48118: PUSH
48119: LD_INT 20
48121: PUSH
48122: LD_INT 21
48124: PUSH
48125: LD_INT 22
48127: PUSH
48128: LD_INT 23
48130: PUSH
48131: LD_INT 24
48133: PUSH
48134: LD_INT 25
48136: PUSH
48137: LD_INT 26
48139: PUSH
48140: LD_INT 27
48142: PUSH
48143: LD_INT 28
48145: PUSH
48146: LD_INT 29
48148: PUSH
48149: LD_INT 30
48151: PUSH
48152: LD_INT 31
48154: PUSH
48155: LD_INT 32
48157: PUSH
48158: LD_INT 33
48160: PUSH
48161: LD_INT 34
48163: PUSH
48164: LD_INT 35
48166: PUSH
48167: LD_INT 36
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 101
48210: PUSH
48211: LD_INT 102
48213: PUSH
48214: LD_INT 103
48216: PUSH
48217: LD_INT 104
48219: PUSH
48220: LD_INT 105
48222: PUSH
48223: LD_INT 106
48225: PUSH
48226: LD_INT 107
48228: PUSH
48229: LD_INT 108
48231: PUSH
48232: LD_INT 109
48234: PUSH
48235: LD_INT 110
48237: PUSH
48238: LD_INT 111
48240: PUSH
48241: LD_INT 112
48243: PUSH
48244: LD_INT 113
48246: PUSH
48247: LD_INT 114
48249: PUSH
48250: LD_INT 115
48252: PUSH
48253: LD_INT 116
48255: PUSH
48256: LD_INT 117
48258: PUSH
48259: LD_INT 118
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: PUSH
48282: EMPTY
48283: LIST
48284: LIST
48285: ST_TO_ADDR
48286: GO 48289
48288: POP
// end else
48289: GO 48520
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48291: LD_ADDR_VAR 0 2
48295: PUSH
48296: LD_INT 1
48298: PUSH
48299: LD_INT 2
48301: PUSH
48302: LD_INT 3
48304: PUSH
48305: LD_INT 4
48307: PUSH
48308: LD_INT 5
48310: PUSH
48311: LD_INT 6
48313: PUSH
48314: LD_INT 7
48316: PUSH
48317: LD_INT 8
48319: PUSH
48320: LD_INT 9
48322: PUSH
48323: LD_INT 10
48325: PUSH
48326: LD_INT 11
48328: PUSH
48329: LD_INT 12
48331: PUSH
48332: LD_INT 13
48334: PUSH
48335: LD_INT 14
48337: PUSH
48338: LD_INT 15
48340: PUSH
48341: LD_INT 16
48343: PUSH
48344: LD_INT 17
48346: PUSH
48347: LD_INT 18
48349: PUSH
48350: LD_INT 19
48352: PUSH
48353: LD_INT 20
48355: PUSH
48356: LD_INT 21
48358: PUSH
48359: LD_INT 22
48361: PUSH
48362: LD_INT 23
48364: PUSH
48365: LD_INT 24
48367: PUSH
48368: LD_INT 25
48370: PUSH
48371: LD_INT 26
48373: PUSH
48374: LD_INT 27
48376: PUSH
48377: LD_INT 28
48379: PUSH
48380: LD_INT 29
48382: PUSH
48383: LD_INT 30
48385: PUSH
48386: LD_INT 31
48388: PUSH
48389: LD_INT 32
48391: PUSH
48392: LD_INT 33
48394: PUSH
48395: LD_INT 34
48397: PUSH
48398: LD_INT 35
48400: PUSH
48401: LD_INT 36
48403: PUSH
48404: EMPTY
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 101
48444: PUSH
48445: LD_INT 102
48447: PUSH
48448: LD_INT 103
48450: PUSH
48451: LD_INT 104
48453: PUSH
48454: LD_INT 105
48456: PUSH
48457: LD_INT 106
48459: PUSH
48460: LD_INT 107
48462: PUSH
48463: LD_INT 108
48465: PUSH
48466: LD_INT 109
48468: PUSH
48469: LD_INT 110
48471: PUSH
48472: LD_INT 111
48474: PUSH
48475: LD_INT 112
48477: PUSH
48478: LD_INT 113
48480: PUSH
48481: LD_INT 114
48483: PUSH
48484: LD_INT 115
48486: PUSH
48487: LD_INT 116
48489: PUSH
48490: LD_INT 117
48492: PUSH
48493: LD_INT 118
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: LIST
48507: LIST
48508: LIST
48509: LIST
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: ST_TO_ADDR
// if result then
48520: LD_VAR 0 2
48524: IFFALSE 49310
// begin normal :=  ;
48526: LD_ADDR_VAR 0 5
48530: PUSH
48531: LD_STRING 
48533: ST_TO_ADDR
// hardcore :=  ;
48534: LD_ADDR_VAR 0 6
48538: PUSH
48539: LD_STRING 
48541: ST_TO_ADDR
// active :=  ;
48542: LD_ADDR_VAR 0 7
48546: PUSH
48547: LD_STRING 
48549: ST_TO_ADDR
// for i = 1 to normalCounter do
48550: LD_ADDR_VAR 0 8
48554: PUSH
48555: DOUBLE
48556: LD_INT 1
48558: DEC
48559: ST_TO_ADDR
48560: LD_EXP 75
48564: PUSH
48565: FOR_TO
48566: IFFALSE 48667
// begin tmp := 0 ;
48568: LD_ADDR_VAR 0 3
48572: PUSH
48573: LD_STRING 0
48575: ST_TO_ADDR
// if result [ 1 ] then
48576: LD_VAR 0 2
48580: PUSH
48581: LD_INT 1
48583: ARRAY
48584: IFFALSE 48649
// if result [ 1 ] [ 1 ] = i then
48586: LD_VAR 0 2
48590: PUSH
48591: LD_INT 1
48593: ARRAY
48594: PUSH
48595: LD_INT 1
48597: ARRAY
48598: PUSH
48599: LD_VAR 0 8
48603: EQUAL
48604: IFFALSE 48649
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48606: LD_ADDR_VAR 0 2
48610: PUSH
48611: LD_VAR 0 2
48615: PPUSH
48616: LD_INT 1
48618: PPUSH
48619: LD_VAR 0 2
48623: PUSH
48624: LD_INT 1
48626: ARRAY
48627: PPUSH
48628: LD_INT 1
48630: PPUSH
48631: CALL_OW 3
48635: PPUSH
48636: CALL_OW 1
48640: ST_TO_ADDR
// tmp := 1 ;
48641: LD_ADDR_VAR 0 3
48645: PUSH
48646: LD_STRING 1
48648: ST_TO_ADDR
// end ; normal := normal & tmp ;
48649: LD_ADDR_VAR 0 5
48653: PUSH
48654: LD_VAR 0 5
48658: PUSH
48659: LD_VAR 0 3
48663: STR
48664: ST_TO_ADDR
// end ;
48665: GO 48565
48667: POP
48668: POP
// for i = 1 to hardcoreCounter do
48669: LD_ADDR_VAR 0 8
48673: PUSH
48674: DOUBLE
48675: LD_INT 1
48677: DEC
48678: ST_TO_ADDR
48679: LD_EXP 76
48683: PUSH
48684: FOR_TO
48685: IFFALSE 48790
// begin tmp := 0 ;
48687: LD_ADDR_VAR 0 3
48691: PUSH
48692: LD_STRING 0
48694: ST_TO_ADDR
// if result [ 2 ] then
48695: LD_VAR 0 2
48699: PUSH
48700: LD_INT 2
48702: ARRAY
48703: IFFALSE 48772
// if result [ 2 ] [ 1 ] = 100 + i then
48705: LD_VAR 0 2
48709: PUSH
48710: LD_INT 2
48712: ARRAY
48713: PUSH
48714: LD_INT 1
48716: ARRAY
48717: PUSH
48718: LD_INT 100
48720: PUSH
48721: LD_VAR 0 8
48725: PLUS
48726: EQUAL
48727: IFFALSE 48772
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48729: LD_ADDR_VAR 0 2
48733: PUSH
48734: LD_VAR 0 2
48738: PPUSH
48739: LD_INT 2
48741: PPUSH
48742: LD_VAR 0 2
48746: PUSH
48747: LD_INT 2
48749: ARRAY
48750: PPUSH
48751: LD_INT 1
48753: PPUSH
48754: CALL_OW 3
48758: PPUSH
48759: CALL_OW 1
48763: ST_TO_ADDR
// tmp := 1 ;
48764: LD_ADDR_VAR 0 3
48768: PUSH
48769: LD_STRING 1
48771: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48772: LD_ADDR_VAR 0 6
48776: PUSH
48777: LD_VAR 0 6
48781: PUSH
48782: LD_VAR 0 3
48786: STR
48787: ST_TO_ADDR
// end ;
48788: GO 48684
48790: POP
48791: POP
// if isGameLoad then
48792: LD_VAR 0 1
48796: IFFALSE 49271
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48798: LD_ADDR_VAR 0 4
48802: PUSH
48803: LD_EXP 79
48807: PUSH
48808: LD_EXP 78
48812: PUSH
48813: LD_EXP 80
48817: PUSH
48818: LD_EXP 77
48822: PUSH
48823: LD_EXP 81
48827: PUSH
48828: LD_EXP 82
48832: PUSH
48833: LD_EXP 83
48837: PUSH
48838: LD_EXP 84
48842: PUSH
48843: LD_EXP 85
48847: PUSH
48848: LD_EXP 86
48852: PUSH
48853: LD_EXP 87
48857: PUSH
48858: LD_EXP 88
48862: PUSH
48863: LD_EXP 89
48867: PUSH
48868: LD_EXP 90
48872: PUSH
48873: LD_EXP 98
48877: PUSH
48878: LD_EXP 99
48882: PUSH
48883: LD_EXP 100
48887: PUSH
48888: LD_EXP 101
48892: PUSH
48893: LD_EXP 103
48897: PUSH
48898: LD_EXP 104
48902: PUSH
48903: LD_EXP 105
48907: PUSH
48908: LD_EXP 108
48912: PUSH
48913: LD_EXP 110
48917: PUSH
48918: LD_EXP 111
48922: PUSH
48923: LD_EXP 112
48927: PUSH
48928: LD_EXP 114
48932: PUSH
48933: LD_EXP 115
48937: PUSH
48938: LD_EXP 118
48942: PUSH
48943: LD_EXP 119
48947: PUSH
48948: LD_EXP 120
48952: PUSH
48953: LD_EXP 121
48957: PUSH
48958: LD_EXP 122
48962: PUSH
48963: LD_EXP 123
48967: PUSH
48968: LD_EXP 124
48972: PUSH
48973: LD_EXP 125
48977: PUSH
48978: LD_EXP 126
48982: PUSH
48983: LD_EXP 91
48987: PUSH
48988: LD_EXP 92
48992: PUSH
48993: LD_EXP 95
48997: PUSH
48998: LD_EXP 96
49002: PUSH
49003: LD_EXP 97
49007: PUSH
49008: LD_EXP 93
49012: PUSH
49013: LD_EXP 94
49017: PUSH
49018: LD_EXP 102
49022: PUSH
49023: LD_EXP 106
49027: PUSH
49028: LD_EXP 107
49032: PUSH
49033: LD_EXP 109
49037: PUSH
49038: LD_EXP 113
49042: PUSH
49043: LD_EXP 116
49047: PUSH
49048: LD_EXP 117
49052: PUSH
49053: LD_EXP 127
49057: PUSH
49058: LD_EXP 128
49062: PUSH
49063: LD_EXP 129
49067: PUSH
49068: LD_EXP 130
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: ST_TO_ADDR
// tmp :=  ;
49129: LD_ADDR_VAR 0 3
49133: PUSH
49134: LD_STRING 
49136: ST_TO_ADDR
// for i = 1 to normalCounter do
49137: LD_ADDR_VAR 0 8
49141: PUSH
49142: DOUBLE
49143: LD_INT 1
49145: DEC
49146: ST_TO_ADDR
49147: LD_EXP 75
49151: PUSH
49152: FOR_TO
49153: IFFALSE 49189
// begin if flags [ i ] then
49155: LD_VAR 0 4
49159: PUSH
49160: LD_VAR 0 8
49164: ARRAY
49165: IFFALSE 49187
// tmp := tmp & i & ; ;
49167: LD_ADDR_VAR 0 3
49171: PUSH
49172: LD_VAR 0 3
49176: PUSH
49177: LD_VAR 0 8
49181: STR
49182: PUSH
49183: LD_STRING ;
49185: STR
49186: ST_TO_ADDR
// end ;
49187: GO 49152
49189: POP
49190: POP
// for i = 1 to hardcoreCounter do
49191: LD_ADDR_VAR 0 8
49195: PUSH
49196: DOUBLE
49197: LD_INT 1
49199: DEC
49200: ST_TO_ADDR
49201: LD_EXP 76
49205: PUSH
49206: FOR_TO
49207: IFFALSE 49253
// begin if flags [ normalCounter + i ] then
49209: LD_VAR 0 4
49213: PUSH
49214: LD_EXP 75
49218: PUSH
49219: LD_VAR 0 8
49223: PLUS
49224: ARRAY
49225: IFFALSE 49251
// tmp := tmp & ( 100 + i ) & ; ;
49227: LD_ADDR_VAR 0 3
49231: PUSH
49232: LD_VAR 0 3
49236: PUSH
49237: LD_INT 100
49239: PUSH
49240: LD_VAR 0 8
49244: PLUS
49245: STR
49246: PUSH
49247: LD_STRING ;
49249: STR
49250: ST_TO_ADDR
// end ;
49251: GO 49206
49253: POP
49254: POP
// if tmp then
49255: LD_VAR 0 3
49259: IFFALSE 49271
// active := tmp ;
49261: LD_ADDR_VAR 0 7
49265: PUSH
49266: LD_VAR 0 3
49270: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49271: LD_STRING getStreamItemsFromMission("
49273: PUSH
49274: LD_VAR 0 5
49278: STR
49279: PUSH
49280: LD_STRING ","
49282: STR
49283: PUSH
49284: LD_VAR 0 6
49288: STR
49289: PUSH
49290: LD_STRING ","
49292: STR
49293: PUSH
49294: LD_VAR 0 7
49298: STR
49299: PUSH
49300: LD_STRING ")
49302: STR
49303: PPUSH
49304: CALL_OW 559
// end else
49308: GO 49317
// ToLua ( getStreamItemsFromMission("","","") ) ;
49310: LD_STRING getStreamItemsFromMission("","","")
49312: PPUSH
49313: CALL_OW 559
// end ;
49317: LD_VAR 0 2
49321: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49322: LD_EXP 74
49326: PUSH
49327: LD_EXP 79
49331: AND
49332: IFFALSE 49456
49334: GO 49336
49336: DISABLE
49337: LD_INT 0
49339: PPUSH
49340: PPUSH
// begin enable ;
49341: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49342: LD_ADDR_VAR 0 2
49346: PUSH
49347: LD_INT 22
49349: PUSH
49350: LD_OWVAR 2
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PUSH
49359: LD_INT 2
49361: PUSH
49362: LD_INT 34
49364: PUSH
49365: LD_INT 7
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PUSH
49372: LD_INT 34
49374: PUSH
49375: LD_INT 45
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 34
49384: PUSH
49385: LD_INT 28
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 34
49394: PUSH
49395: LD_INT 47
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PPUSH
49413: CALL_OW 69
49417: ST_TO_ADDR
// if not tmp then
49418: LD_VAR 0 2
49422: NOT
49423: IFFALSE 49427
// exit ;
49425: GO 49456
// for i in tmp do
49427: LD_ADDR_VAR 0 1
49431: PUSH
49432: LD_VAR 0 2
49436: PUSH
49437: FOR_IN
49438: IFFALSE 49454
// begin SetLives ( i , 0 ) ;
49440: LD_VAR 0 1
49444: PPUSH
49445: LD_INT 0
49447: PPUSH
49448: CALL_OW 234
// end ;
49452: GO 49437
49454: POP
49455: POP
// end ;
49456: PPOPN 2
49458: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49459: LD_EXP 74
49463: PUSH
49464: LD_EXP 80
49468: AND
49469: IFFALSE 49553
49471: GO 49473
49473: DISABLE
49474: LD_INT 0
49476: PPUSH
49477: PPUSH
// begin enable ;
49478: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49479: LD_ADDR_VAR 0 2
49483: PUSH
49484: LD_INT 22
49486: PUSH
49487: LD_OWVAR 2
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 32
49498: PUSH
49499: LD_INT 3
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PPUSH
49510: CALL_OW 69
49514: ST_TO_ADDR
// if not tmp then
49515: LD_VAR 0 2
49519: NOT
49520: IFFALSE 49524
// exit ;
49522: GO 49553
// for i in tmp do
49524: LD_ADDR_VAR 0 1
49528: PUSH
49529: LD_VAR 0 2
49533: PUSH
49534: FOR_IN
49535: IFFALSE 49551
// begin SetLives ( i , 0 ) ;
49537: LD_VAR 0 1
49541: PPUSH
49542: LD_INT 0
49544: PPUSH
49545: CALL_OW 234
// end ;
49549: GO 49534
49551: POP
49552: POP
// end ;
49553: PPOPN 2
49555: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49556: LD_EXP 74
49560: PUSH
49561: LD_EXP 77
49565: AND
49566: IFFALSE 49659
49568: GO 49570
49570: DISABLE
49571: LD_INT 0
49573: PPUSH
// begin enable ;
49574: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49575: LD_ADDR_VAR 0 1
49579: PUSH
49580: LD_INT 22
49582: PUSH
49583: LD_OWVAR 2
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: PUSH
49592: LD_INT 2
49594: PUSH
49595: LD_INT 25
49597: PUSH
49598: LD_INT 5
49600: PUSH
49601: EMPTY
49602: LIST
49603: LIST
49604: PUSH
49605: LD_INT 25
49607: PUSH
49608: LD_INT 9
49610: PUSH
49611: EMPTY
49612: LIST
49613: LIST
49614: PUSH
49615: LD_INT 25
49617: PUSH
49618: LD_INT 8
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: PPUSH
49635: CALL_OW 69
49639: PUSH
49640: FOR_IN
49641: IFFALSE 49657
// begin SetClass ( i , 1 ) ;
49643: LD_VAR 0 1
49647: PPUSH
49648: LD_INT 1
49650: PPUSH
49651: CALL_OW 336
// end ;
49655: GO 49640
49657: POP
49658: POP
// end ;
49659: PPOPN 1
49661: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49662: LD_EXP 74
49666: PUSH
49667: LD_EXP 78
49671: AND
49672: PUSH
49673: LD_OWVAR 65
49677: PUSH
49678: LD_INT 7
49680: LESS
49681: AND
49682: IFFALSE 49696
49684: GO 49686
49686: DISABLE
// begin enable ;
49687: ENABLE
// game_speed := 7 ;
49688: LD_ADDR_OWVAR 65
49692: PUSH
49693: LD_INT 7
49695: ST_TO_ADDR
// end ;
49696: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49697: LD_EXP 74
49701: PUSH
49702: LD_EXP 81
49706: AND
49707: IFFALSE 49909
49709: GO 49711
49711: DISABLE
49712: LD_INT 0
49714: PPUSH
49715: PPUSH
49716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49717: LD_ADDR_VAR 0 3
49721: PUSH
49722: LD_INT 81
49724: PUSH
49725: LD_OWVAR 2
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: PUSH
49734: LD_INT 21
49736: PUSH
49737: LD_INT 1
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: CALL_OW 69
49752: ST_TO_ADDR
// if not tmp then
49753: LD_VAR 0 3
49757: NOT
49758: IFFALSE 49762
// exit ;
49760: GO 49909
// if tmp > 5 then
49762: LD_VAR 0 3
49766: PUSH
49767: LD_INT 5
49769: GREATER
49770: IFFALSE 49782
// k := 5 else
49772: LD_ADDR_VAR 0 2
49776: PUSH
49777: LD_INT 5
49779: ST_TO_ADDR
49780: GO 49792
// k := tmp ;
49782: LD_ADDR_VAR 0 2
49786: PUSH
49787: LD_VAR 0 3
49791: ST_TO_ADDR
// for i := 1 to k do
49792: LD_ADDR_VAR 0 1
49796: PUSH
49797: DOUBLE
49798: LD_INT 1
49800: DEC
49801: ST_TO_ADDR
49802: LD_VAR 0 2
49806: PUSH
49807: FOR_TO
49808: IFFALSE 49907
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49810: LD_VAR 0 3
49814: PUSH
49815: LD_VAR 0 1
49819: ARRAY
49820: PPUSH
49821: LD_VAR 0 1
49825: PUSH
49826: LD_INT 4
49828: MOD
49829: PUSH
49830: LD_INT 1
49832: PLUS
49833: PPUSH
49834: CALL_OW 259
49838: PUSH
49839: LD_INT 10
49841: LESS
49842: IFFALSE 49905
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49844: LD_VAR 0 3
49848: PUSH
49849: LD_VAR 0 1
49853: ARRAY
49854: PPUSH
49855: LD_VAR 0 1
49859: PUSH
49860: LD_INT 4
49862: MOD
49863: PUSH
49864: LD_INT 1
49866: PLUS
49867: PPUSH
49868: LD_VAR 0 3
49872: PUSH
49873: LD_VAR 0 1
49877: ARRAY
49878: PPUSH
49879: LD_VAR 0 1
49883: PUSH
49884: LD_INT 4
49886: MOD
49887: PUSH
49888: LD_INT 1
49890: PLUS
49891: PPUSH
49892: CALL_OW 259
49896: PUSH
49897: LD_INT 1
49899: PLUS
49900: PPUSH
49901: CALL_OW 237
49905: GO 49807
49907: POP
49908: POP
// end ;
49909: PPOPN 3
49911: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49912: LD_EXP 74
49916: PUSH
49917: LD_EXP 82
49921: AND
49922: IFFALSE 49942
49924: GO 49926
49926: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49927: LD_INT 4
49929: PPUSH
49930: LD_OWVAR 2
49934: PPUSH
49935: LD_INT 0
49937: PPUSH
49938: CALL_OW 324
49942: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49943: LD_EXP 74
49947: PUSH
49948: LD_EXP 111
49952: AND
49953: IFFALSE 49973
49955: GO 49957
49957: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49958: LD_INT 19
49960: PPUSH
49961: LD_OWVAR 2
49965: PPUSH
49966: LD_INT 0
49968: PPUSH
49969: CALL_OW 324
49973: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49974: LD_EXP 74
49978: PUSH
49979: LD_EXP 83
49983: AND
49984: IFFALSE 50086
49986: GO 49988
49988: DISABLE
49989: LD_INT 0
49991: PPUSH
49992: PPUSH
// begin enable ;
49993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49994: LD_ADDR_VAR 0 2
49998: PUSH
49999: LD_INT 22
50001: PUSH
50002: LD_OWVAR 2
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: PUSH
50011: LD_INT 2
50013: PUSH
50014: LD_INT 34
50016: PUSH
50017: LD_INT 11
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: PUSH
50024: LD_INT 34
50026: PUSH
50027: LD_INT 30
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: LIST
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PPUSH
50043: CALL_OW 69
50047: ST_TO_ADDR
// if not tmp then
50048: LD_VAR 0 2
50052: NOT
50053: IFFALSE 50057
// exit ;
50055: GO 50086
// for i in tmp do
50057: LD_ADDR_VAR 0 1
50061: PUSH
50062: LD_VAR 0 2
50066: PUSH
50067: FOR_IN
50068: IFFALSE 50084
// begin SetLives ( i , 0 ) ;
50070: LD_VAR 0 1
50074: PPUSH
50075: LD_INT 0
50077: PPUSH
50078: CALL_OW 234
// end ;
50082: GO 50067
50084: POP
50085: POP
// end ;
50086: PPOPN 2
50088: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50089: LD_EXP 74
50093: PUSH
50094: LD_EXP 84
50098: AND
50099: IFFALSE 50119
50101: GO 50103
50103: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50104: LD_INT 32
50106: PPUSH
50107: LD_OWVAR 2
50111: PPUSH
50112: LD_INT 0
50114: PPUSH
50115: CALL_OW 324
50119: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50120: LD_EXP 74
50124: PUSH
50125: LD_EXP 85
50129: AND
50130: IFFALSE 50311
50132: GO 50134
50134: DISABLE
50135: LD_INT 0
50137: PPUSH
50138: PPUSH
50139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50140: LD_ADDR_VAR 0 2
50144: PUSH
50145: LD_INT 22
50147: PUSH
50148: LD_OWVAR 2
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PUSH
50157: LD_INT 33
50159: PUSH
50160: LD_INT 3
50162: PUSH
50163: EMPTY
50164: LIST
50165: LIST
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PPUSH
50171: CALL_OW 69
50175: ST_TO_ADDR
// if not tmp then
50176: LD_VAR 0 2
50180: NOT
50181: IFFALSE 50185
// exit ;
50183: GO 50311
// side := 0 ;
50185: LD_ADDR_VAR 0 3
50189: PUSH
50190: LD_INT 0
50192: ST_TO_ADDR
// for i := 1 to 8 do
50193: LD_ADDR_VAR 0 1
50197: PUSH
50198: DOUBLE
50199: LD_INT 1
50201: DEC
50202: ST_TO_ADDR
50203: LD_INT 8
50205: PUSH
50206: FOR_TO
50207: IFFALSE 50255
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50209: LD_OWVAR 2
50213: PUSH
50214: LD_VAR 0 1
50218: NONEQUAL
50219: PUSH
50220: LD_OWVAR 2
50224: PPUSH
50225: LD_VAR 0 1
50229: PPUSH
50230: CALL_OW 81
50234: PUSH
50235: LD_INT 2
50237: EQUAL
50238: AND
50239: IFFALSE 50253
// begin side := i ;
50241: LD_ADDR_VAR 0 3
50245: PUSH
50246: LD_VAR 0 1
50250: ST_TO_ADDR
// break ;
50251: GO 50255
// end ;
50253: GO 50206
50255: POP
50256: POP
// if not side then
50257: LD_VAR 0 3
50261: NOT
50262: IFFALSE 50266
// exit ;
50264: GO 50311
// for i := 1 to tmp do
50266: LD_ADDR_VAR 0 1
50270: PUSH
50271: DOUBLE
50272: LD_INT 1
50274: DEC
50275: ST_TO_ADDR
50276: LD_VAR 0 2
50280: PUSH
50281: FOR_TO
50282: IFFALSE 50309
// if Prob ( 60 ) then
50284: LD_INT 60
50286: PPUSH
50287: CALL_OW 13
50291: IFFALSE 50307
// SetSide ( i , side ) ;
50293: LD_VAR 0 1
50297: PPUSH
50298: LD_VAR 0 3
50302: PPUSH
50303: CALL_OW 235
50307: GO 50281
50309: POP
50310: POP
// end ;
50311: PPOPN 3
50313: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50314: LD_EXP 74
50318: PUSH
50319: LD_EXP 87
50323: AND
50324: IFFALSE 50443
50326: GO 50328
50328: DISABLE
50329: LD_INT 0
50331: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50332: LD_ADDR_VAR 0 1
50336: PUSH
50337: LD_INT 22
50339: PUSH
50340: LD_OWVAR 2
50344: PUSH
50345: EMPTY
50346: LIST
50347: LIST
50348: PUSH
50349: LD_INT 21
50351: PUSH
50352: LD_INT 1
50354: PUSH
50355: EMPTY
50356: LIST
50357: LIST
50358: PUSH
50359: LD_INT 3
50361: PUSH
50362: LD_INT 23
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: LIST
50380: PPUSH
50381: CALL_OW 69
50385: PUSH
50386: FOR_IN
50387: IFFALSE 50441
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50389: LD_VAR 0 1
50393: PPUSH
50394: CALL_OW 257
50398: PUSH
50399: LD_INT 1
50401: PUSH
50402: LD_INT 2
50404: PUSH
50405: LD_INT 3
50407: PUSH
50408: LD_INT 4
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: LIST
50415: LIST
50416: IN
50417: IFFALSE 50439
// SetClass ( un , rand ( 1 , 4 ) ) ;
50419: LD_VAR 0 1
50423: PPUSH
50424: LD_INT 1
50426: PPUSH
50427: LD_INT 4
50429: PPUSH
50430: CALL_OW 12
50434: PPUSH
50435: CALL_OW 336
50439: GO 50386
50441: POP
50442: POP
// end ;
50443: PPOPN 1
50445: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50446: LD_EXP 74
50450: PUSH
50451: LD_EXP 86
50455: AND
50456: IFFALSE 50535
50458: GO 50460
50460: DISABLE
50461: LD_INT 0
50463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50464: LD_ADDR_VAR 0 1
50468: PUSH
50469: LD_INT 22
50471: PUSH
50472: LD_OWVAR 2
50476: PUSH
50477: EMPTY
50478: LIST
50479: LIST
50480: PUSH
50481: LD_INT 21
50483: PUSH
50484: LD_INT 3
50486: PUSH
50487: EMPTY
50488: LIST
50489: LIST
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PPUSH
50495: CALL_OW 69
50499: ST_TO_ADDR
// if not tmp then
50500: LD_VAR 0 1
50504: NOT
50505: IFFALSE 50509
// exit ;
50507: GO 50535
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50509: LD_VAR 0 1
50513: PUSH
50514: LD_INT 1
50516: PPUSH
50517: LD_VAR 0 1
50521: PPUSH
50522: CALL_OW 12
50526: ARRAY
50527: PPUSH
50528: LD_INT 100
50530: PPUSH
50531: CALL_OW 234
// end ;
50535: PPOPN 1
50537: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50538: LD_EXP 74
50542: PUSH
50543: LD_EXP 88
50547: AND
50548: IFFALSE 50646
50550: GO 50552
50552: DISABLE
50553: LD_INT 0
50555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50556: LD_ADDR_VAR 0 1
50560: PUSH
50561: LD_INT 22
50563: PUSH
50564: LD_OWVAR 2
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PUSH
50573: LD_INT 21
50575: PUSH
50576: LD_INT 1
50578: PUSH
50579: EMPTY
50580: LIST
50581: LIST
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: PPUSH
50587: CALL_OW 69
50591: ST_TO_ADDR
// if not tmp then
50592: LD_VAR 0 1
50596: NOT
50597: IFFALSE 50601
// exit ;
50599: GO 50646
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50601: LD_VAR 0 1
50605: PUSH
50606: LD_INT 1
50608: PPUSH
50609: LD_VAR 0 1
50613: PPUSH
50614: CALL_OW 12
50618: ARRAY
50619: PPUSH
50620: LD_INT 1
50622: PPUSH
50623: LD_INT 4
50625: PPUSH
50626: CALL_OW 12
50630: PPUSH
50631: LD_INT 3000
50633: PPUSH
50634: LD_INT 9000
50636: PPUSH
50637: CALL_OW 12
50641: PPUSH
50642: CALL_OW 492
// end ;
50646: PPOPN 1
50648: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50649: LD_EXP 74
50653: PUSH
50654: LD_EXP 89
50658: AND
50659: IFFALSE 50679
50661: GO 50663
50663: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50664: LD_INT 1
50666: PPUSH
50667: LD_OWVAR 2
50671: PPUSH
50672: LD_INT 0
50674: PPUSH
50675: CALL_OW 324
50679: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50680: LD_EXP 74
50684: PUSH
50685: LD_EXP 90
50689: AND
50690: IFFALSE 50773
50692: GO 50694
50694: DISABLE
50695: LD_INT 0
50697: PPUSH
50698: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50699: LD_ADDR_VAR 0 2
50703: PUSH
50704: LD_INT 22
50706: PUSH
50707: LD_OWVAR 2
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: PUSH
50716: LD_INT 21
50718: PUSH
50719: LD_INT 3
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PPUSH
50730: CALL_OW 69
50734: ST_TO_ADDR
// if not tmp then
50735: LD_VAR 0 2
50739: NOT
50740: IFFALSE 50744
// exit ;
50742: GO 50773
// for i in tmp do
50744: LD_ADDR_VAR 0 1
50748: PUSH
50749: LD_VAR 0 2
50753: PUSH
50754: FOR_IN
50755: IFFALSE 50771
// SetBLevel ( i , 10 ) ;
50757: LD_VAR 0 1
50761: PPUSH
50762: LD_INT 10
50764: PPUSH
50765: CALL_OW 241
50769: GO 50754
50771: POP
50772: POP
// end ;
50773: PPOPN 2
50775: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50776: LD_EXP 74
50780: PUSH
50781: LD_EXP 91
50785: AND
50786: IFFALSE 50897
50788: GO 50790
50790: DISABLE
50791: LD_INT 0
50793: PPUSH
50794: PPUSH
50795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50796: LD_ADDR_VAR 0 3
50800: PUSH
50801: LD_INT 22
50803: PUSH
50804: LD_OWVAR 2
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: PUSH
50813: LD_INT 25
50815: PUSH
50816: LD_INT 1
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: PPUSH
50827: CALL_OW 69
50831: ST_TO_ADDR
// if not tmp then
50832: LD_VAR 0 3
50836: NOT
50837: IFFALSE 50841
// exit ;
50839: GO 50897
// un := tmp [ rand ( 1 , tmp ) ] ;
50841: LD_ADDR_VAR 0 2
50845: PUSH
50846: LD_VAR 0 3
50850: PUSH
50851: LD_INT 1
50853: PPUSH
50854: LD_VAR 0 3
50858: PPUSH
50859: CALL_OW 12
50863: ARRAY
50864: ST_TO_ADDR
// if Crawls ( un ) then
50865: LD_VAR 0 2
50869: PPUSH
50870: CALL_OW 318
50874: IFFALSE 50885
// ComWalk ( un ) ;
50876: LD_VAR 0 2
50880: PPUSH
50881: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50885: LD_VAR 0 2
50889: PPUSH
50890: LD_INT 5
50892: PPUSH
50893: CALL_OW 336
// end ;
50897: PPOPN 3
50899: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50900: LD_EXP 74
50904: PUSH
50905: LD_EXP 92
50909: AND
50910: PUSH
50911: LD_OWVAR 67
50915: PUSH
50916: LD_INT 4
50918: LESS
50919: AND
50920: IFFALSE 50939
50922: GO 50924
50924: DISABLE
// begin Difficulty := Difficulty + 1 ;
50925: LD_ADDR_OWVAR 67
50929: PUSH
50930: LD_OWVAR 67
50934: PUSH
50935: LD_INT 1
50937: PLUS
50938: ST_TO_ADDR
// end ;
50939: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50940: LD_EXP 74
50944: PUSH
50945: LD_EXP 93
50949: AND
50950: IFFALSE 51053
50952: GO 50954
50954: DISABLE
50955: LD_INT 0
50957: PPUSH
// begin for i := 1 to 5 do
50958: LD_ADDR_VAR 0 1
50962: PUSH
50963: DOUBLE
50964: LD_INT 1
50966: DEC
50967: ST_TO_ADDR
50968: LD_INT 5
50970: PUSH
50971: FOR_TO
50972: IFFALSE 51051
// begin uc_nation := nation_nature ;
50974: LD_ADDR_OWVAR 21
50978: PUSH
50979: LD_INT 0
50981: ST_TO_ADDR
// uc_side := 0 ;
50982: LD_ADDR_OWVAR 20
50986: PUSH
50987: LD_INT 0
50989: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50990: LD_ADDR_OWVAR 29
50994: PUSH
50995: LD_INT 12
50997: PUSH
50998: LD_INT 12
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: ST_TO_ADDR
// hc_agressivity := 20 ;
51005: LD_ADDR_OWVAR 35
51009: PUSH
51010: LD_INT 20
51012: ST_TO_ADDR
// hc_class := class_tiger ;
51013: LD_ADDR_OWVAR 28
51017: PUSH
51018: LD_INT 14
51020: ST_TO_ADDR
// hc_gallery :=  ;
51021: LD_ADDR_OWVAR 33
51025: PUSH
51026: LD_STRING 
51028: ST_TO_ADDR
// hc_name :=  ;
51029: LD_ADDR_OWVAR 26
51033: PUSH
51034: LD_STRING 
51036: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51037: CALL_OW 44
51041: PPUSH
51042: LD_INT 0
51044: PPUSH
51045: CALL_OW 51
// end ;
51049: GO 50971
51051: POP
51052: POP
// end ;
51053: PPOPN 1
51055: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51056: LD_EXP 74
51060: PUSH
51061: LD_EXP 94
51065: AND
51066: IFFALSE 51075
51068: GO 51070
51070: DISABLE
// StreamSibBomb ;
51071: CALL 51076 0 0
51075: END
// export function StreamSibBomb ; var i , x , y ; begin
51076: LD_INT 0
51078: PPUSH
51079: PPUSH
51080: PPUSH
51081: PPUSH
// result := false ;
51082: LD_ADDR_VAR 0 1
51086: PUSH
51087: LD_INT 0
51089: ST_TO_ADDR
// for i := 1 to 16 do
51090: LD_ADDR_VAR 0 2
51094: PUSH
51095: DOUBLE
51096: LD_INT 1
51098: DEC
51099: ST_TO_ADDR
51100: LD_INT 16
51102: PUSH
51103: FOR_TO
51104: IFFALSE 51303
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51106: LD_ADDR_VAR 0 3
51110: PUSH
51111: LD_INT 10
51113: PUSH
51114: LD_INT 20
51116: PUSH
51117: LD_INT 30
51119: PUSH
51120: LD_INT 40
51122: PUSH
51123: LD_INT 50
51125: PUSH
51126: LD_INT 60
51128: PUSH
51129: LD_INT 70
51131: PUSH
51132: LD_INT 80
51134: PUSH
51135: LD_INT 90
51137: PUSH
51138: LD_INT 100
51140: PUSH
51141: LD_INT 110
51143: PUSH
51144: LD_INT 120
51146: PUSH
51147: LD_INT 130
51149: PUSH
51150: LD_INT 140
51152: PUSH
51153: LD_INT 150
51155: PUSH
51156: EMPTY
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: PUSH
51173: LD_INT 1
51175: PPUSH
51176: LD_INT 15
51178: PPUSH
51179: CALL_OW 12
51183: ARRAY
51184: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51185: LD_ADDR_VAR 0 4
51189: PUSH
51190: LD_INT 10
51192: PUSH
51193: LD_INT 20
51195: PUSH
51196: LD_INT 30
51198: PUSH
51199: LD_INT 40
51201: PUSH
51202: LD_INT 50
51204: PUSH
51205: LD_INT 60
51207: PUSH
51208: LD_INT 70
51210: PUSH
51211: LD_INT 80
51213: PUSH
51214: LD_INT 90
51216: PUSH
51217: LD_INT 100
51219: PUSH
51220: LD_INT 110
51222: PUSH
51223: LD_INT 120
51225: PUSH
51226: LD_INT 130
51228: PUSH
51229: LD_INT 140
51231: PUSH
51232: LD_INT 150
51234: PUSH
51235: EMPTY
51236: LIST
51237: LIST
51238: LIST
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: PUSH
51252: LD_INT 1
51254: PPUSH
51255: LD_INT 15
51257: PPUSH
51258: CALL_OW 12
51262: ARRAY
51263: ST_TO_ADDR
// if ValidHex ( x , y ) then
51264: LD_VAR 0 3
51268: PPUSH
51269: LD_VAR 0 4
51273: PPUSH
51274: CALL_OW 488
51278: IFFALSE 51301
// begin result := [ x , y ] ;
51280: LD_ADDR_VAR 0 1
51284: PUSH
51285: LD_VAR 0 3
51289: PUSH
51290: LD_VAR 0 4
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: ST_TO_ADDR
// break ;
51299: GO 51303
// end ; end ;
51301: GO 51103
51303: POP
51304: POP
// if result then
51305: LD_VAR 0 1
51309: IFFALSE 51369
// begin ToLua ( playSibBomb() ) ;
51311: LD_STRING playSibBomb()
51313: PPUSH
51314: CALL_OW 559
// wait ( 0 0$14 ) ;
51318: LD_INT 490
51320: PPUSH
51321: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51325: LD_VAR 0 1
51329: PUSH
51330: LD_INT 1
51332: ARRAY
51333: PPUSH
51334: LD_VAR 0 1
51338: PUSH
51339: LD_INT 2
51341: ARRAY
51342: PPUSH
51343: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51347: LD_VAR 0 1
51351: PUSH
51352: LD_INT 1
51354: ARRAY
51355: PPUSH
51356: LD_VAR 0 1
51360: PUSH
51361: LD_INT 2
51363: ARRAY
51364: PPUSH
51365: CALL_OW 429
// end ; end ;
51369: LD_VAR 0 1
51373: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51374: LD_EXP 74
51378: PUSH
51379: LD_EXP 96
51383: AND
51384: IFFALSE 51396
51386: GO 51388
51388: DISABLE
// YouLost (  ) ;
51389: LD_STRING 
51391: PPUSH
51392: CALL_OW 104
51396: END
// every 0 0$1 trigger StreamModeActive and sFog do
51397: LD_EXP 74
51401: PUSH
51402: LD_EXP 95
51406: AND
51407: IFFALSE 51421
51409: GO 51411
51411: DISABLE
// FogOff ( your_side ) ;
51412: LD_OWVAR 2
51416: PPUSH
51417: CALL_OW 344
51421: END
// every 0 0$1 trigger StreamModeActive and sSun do
51422: LD_EXP 74
51426: PUSH
51427: LD_EXP 97
51431: AND
51432: IFFALSE 51460
51434: GO 51436
51436: DISABLE
// begin solar_recharge_percent := 0 ;
51437: LD_ADDR_OWVAR 79
51441: PUSH
51442: LD_INT 0
51444: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51445: LD_INT 10500
51447: PPUSH
51448: CALL_OW 67
// solar_recharge_percent := 100 ;
51452: LD_ADDR_OWVAR 79
51456: PUSH
51457: LD_INT 100
51459: ST_TO_ADDR
// end ;
51460: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51461: LD_EXP 74
51465: PUSH
51466: LD_EXP 98
51470: AND
51471: IFFALSE 51710
51473: GO 51475
51475: DISABLE
51476: LD_INT 0
51478: PPUSH
51479: PPUSH
51480: PPUSH
// begin tmp := [ ] ;
51481: LD_ADDR_VAR 0 3
51485: PUSH
51486: EMPTY
51487: ST_TO_ADDR
// for i := 1 to 6 do
51488: LD_ADDR_VAR 0 1
51492: PUSH
51493: DOUBLE
51494: LD_INT 1
51496: DEC
51497: ST_TO_ADDR
51498: LD_INT 6
51500: PUSH
51501: FOR_TO
51502: IFFALSE 51607
// begin uc_nation := nation_nature ;
51504: LD_ADDR_OWVAR 21
51508: PUSH
51509: LD_INT 0
51511: ST_TO_ADDR
// uc_side := 0 ;
51512: LD_ADDR_OWVAR 20
51516: PUSH
51517: LD_INT 0
51519: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51520: LD_ADDR_OWVAR 29
51524: PUSH
51525: LD_INT 12
51527: PUSH
51528: LD_INT 12
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: ST_TO_ADDR
// hc_agressivity := 20 ;
51535: LD_ADDR_OWVAR 35
51539: PUSH
51540: LD_INT 20
51542: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51543: LD_ADDR_OWVAR 28
51547: PUSH
51548: LD_INT 17
51550: ST_TO_ADDR
// hc_gallery :=  ;
51551: LD_ADDR_OWVAR 33
51555: PUSH
51556: LD_STRING 
51558: ST_TO_ADDR
// hc_name :=  ;
51559: LD_ADDR_OWVAR 26
51563: PUSH
51564: LD_STRING 
51566: ST_TO_ADDR
// un := CreateHuman ;
51567: LD_ADDR_VAR 0 2
51571: PUSH
51572: CALL_OW 44
51576: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51577: LD_VAR 0 2
51581: PPUSH
51582: LD_INT 1
51584: PPUSH
51585: CALL_OW 51
// tmp := tmp ^ un ;
51589: LD_ADDR_VAR 0 3
51593: PUSH
51594: LD_VAR 0 3
51598: PUSH
51599: LD_VAR 0 2
51603: ADD
51604: ST_TO_ADDR
// end ;
51605: GO 51501
51607: POP
51608: POP
// repeat wait ( 0 0$1 ) ;
51609: LD_INT 35
51611: PPUSH
51612: CALL_OW 67
// for un in tmp do
51616: LD_ADDR_VAR 0 2
51620: PUSH
51621: LD_VAR 0 3
51625: PUSH
51626: FOR_IN
51627: IFFALSE 51701
// begin if IsDead ( un ) then
51629: LD_VAR 0 2
51633: PPUSH
51634: CALL_OW 301
51638: IFFALSE 51658
// begin tmp := tmp diff un ;
51640: LD_ADDR_VAR 0 3
51644: PUSH
51645: LD_VAR 0 3
51649: PUSH
51650: LD_VAR 0 2
51654: DIFF
51655: ST_TO_ADDR
// continue ;
51656: GO 51626
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51658: LD_VAR 0 2
51662: PPUSH
51663: LD_INT 3
51665: PUSH
51666: LD_INT 22
51668: PUSH
51669: LD_INT 0
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PPUSH
51680: CALL_OW 69
51684: PPUSH
51685: LD_VAR 0 2
51689: PPUSH
51690: CALL_OW 74
51694: PPUSH
51695: CALL_OW 115
// end ;
51699: GO 51626
51701: POP
51702: POP
// until not tmp ;
51703: LD_VAR 0 3
51707: NOT
51708: IFFALSE 51609
// end ;
51710: PPOPN 3
51712: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51713: LD_EXP 74
51717: PUSH
51718: LD_EXP 99
51722: AND
51723: IFFALSE 51777
51725: GO 51727
51727: DISABLE
// begin ToLua ( displayTroll(); ) ;
51728: LD_STRING displayTroll();
51730: PPUSH
51731: CALL_OW 559
// wait ( 3 3$00 ) ;
51735: LD_INT 6300
51737: PPUSH
51738: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51742: LD_STRING hideTroll();
51744: PPUSH
51745: CALL_OW 559
// wait ( 1 1$00 ) ;
51749: LD_INT 2100
51751: PPUSH
51752: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51756: LD_STRING displayTroll();
51758: PPUSH
51759: CALL_OW 559
// wait ( 1 1$00 ) ;
51763: LD_INT 2100
51765: PPUSH
51766: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51770: LD_STRING hideTroll();
51772: PPUSH
51773: CALL_OW 559
// end ;
51777: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51778: LD_EXP 74
51782: PUSH
51783: LD_EXP 100
51787: AND
51788: IFFALSE 51851
51790: GO 51792
51792: DISABLE
51793: LD_INT 0
51795: PPUSH
// begin p := 0 ;
51796: LD_ADDR_VAR 0 1
51800: PUSH
51801: LD_INT 0
51803: ST_TO_ADDR
// repeat game_speed := 1 ;
51804: LD_ADDR_OWVAR 65
51808: PUSH
51809: LD_INT 1
51811: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51812: LD_INT 35
51814: PPUSH
51815: CALL_OW 67
// p := p + 1 ;
51819: LD_ADDR_VAR 0 1
51823: PUSH
51824: LD_VAR 0 1
51828: PUSH
51829: LD_INT 1
51831: PLUS
51832: ST_TO_ADDR
// until p >= 60 ;
51833: LD_VAR 0 1
51837: PUSH
51838: LD_INT 60
51840: GREATEREQUAL
51841: IFFALSE 51804
// game_speed := 4 ;
51843: LD_ADDR_OWVAR 65
51847: PUSH
51848: LD_INT 4
51850: ST_TO_ADDR
// end ;
51851: PPOPN 1
51853: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51854: LD_EXP 74
51858: PUSH
51859: LD_EXP 101
51863: AND
51864: IFFALSE 52010
51866: GO 51868
51868: DISABLE
51869: LD_INT 0
51871: PPUSH
51872: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51873: LD_ADDR_VAR 0 1
51877: PUSH
51878: LD_INT 22
51880: PUSH
51881: LD_OWVAR 2
51885: PUSH
51886: EMPTY
51887: LIST
51888: LIST
51889: PUSH
51890: LD_INT 2
51892: PUSH
51893: LD_INT 30
51895: PUSH
51896: LD_INT 0
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: PUSH
51903: LD_INT 30
51905: PUSH
51906: LD_INT 1
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: LIST
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: PPUSH
51922: CALL_OW 69
51926: ST_TO_ADDR
// if not depot then
51927: LD_VAR 0 1
51931: NOT
51932: IFFALSE 51936
// exit ;
51934: GO 52010
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51936: LD_ADDR_VAR 0 2
51940: PUSH
51941: LD_VAR 0 1
51945: PUSH
51946: LD_INT 1
51948: PPUSH
51949: LD_VAR 0 1
51953: PPUSH
51954: CALL_OW 12
51958: ARRAY
51959: PPUSH
51960: CALL_OW 274
51964: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51965: LD_VAR 0 2
51969: PPUSH
51970: LD_INT 1
51972: PPUSH
51973: LD_INT 0
51975: PPUSH
51976: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51980: LD_VAR 0 2
51984: PPUSH
51985: LD_INT 2
51987: PPUSH
51988: LD_INT 0
51990: PPUSH
51991: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51995: LD_VAR 0 2
51999: PPUSH
52000: LD_INT 3
52002: PPUSH
52003: LD_INT 0
52005: PPUSH
52006: CALL_OW 277
// end ;
52010: PPOPN 2
52012: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52013: LD_EXP 74
52017: PUSH
52018: LD_EXP 102
52022: AND
52023: IFFALSE 52120
52025: GO 52027
52027: DISABLE
52028: LD_INT 0
52030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52031: LD_ADDR_VAR 0 1
52035: PUSH
52036: LD_INT 22
52038: PUSH
52039: LD_OWVAR 2
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: PUSH
52048: LD_INT 21
52050: PUSH
52051: LD_INT 1
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: PUSH
52058: LD_INT 3
52060: PUSH
52061: LD_INT 23
52063: PUSH
52064: LD_INT 0
52066: PUSH
52067: EMPTY
52068: LIST
52069: LIST
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: PUSH
52075: EMPTY
52076: LIST
52077: LIST
52078: LIST
52079: PPUSH
52080: CALL_OW 69
52084: ST_TO_ADDR
// if not tmp then
52085: LD_VAR 0 1
52089: NOT
52090: IFFALSE 52094
// exit ;
52092: GO 52120
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52094: LD_VAR 0 1
52098: PUSH
52099: LD_INT 1
52101: PPUSH
52102: LD_VAR 0 1
52106: PPUSH
52107: CALL_OW 12
52111: ARRAY
52112: PPUSH
52113: LD_INT 200
52115: PPUSH
52116: CALL_OW 234
// end ;
52120: PPOPN 1
52122: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52123: LD_EXP 74
52127: PUSH
52128: LD_EXP 103
52132: AND
52133: IFFALSE 52212
52135: GO 52137
52137: DISABLE
52138: LD_INT 0
52140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52141: LD_ADDR_VAR 0 1
52145: PUSH
52146: LD_INT 22
52148: PUSH
52149: LD_OWVAR 2
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: PUSH
52158: LD_INT 21
52160: PUSH
52161: LD_INT 2
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: PUSH
52168: EMPTY
52169: LIST
52170: LIST
52171: PPUSH
52172: CALL_OW 69
52176: ST_TO_ADDR
// if not tmp then
52177: LD_VAR 0 1
52181: NOT
52182: IFFALSE 52186
// exit ;
52184: GO 52212
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52186: LD_VAR 0 1
52190: PUSH
52191: LD_INT 1
52193: PPUSH
52194: LD_VAR 0 1
52198: PPUSH
52199: CALL_OW 12
52203: ARRAY
52204: PPUSH
52205: LD_INT 60
52207: PPUSH
52208: CALL_OW 234
// end ;
52212: PPOPN 1
52214: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52215: LD_EXP 74
52219: PUSH
52220: LD_EXP 104
52224: AND
52225: IFFALSE 52324
52227: GO 52229
52229: DISABLE
52230: LD_INT 0
52232: PPUSH
52233: PPUSH
// begin enable ;
52234: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52235: LD_ADDR_VAR 0 1
52239: PUSH
52240: LD_INT 22
52242: PUSH
52243: LD_OWVAR 2
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: PUSH
52252: LD_INT 61
52254: PUSH
52255: EMPTY
52256: LIST
52257: PUSH
52258: LD_INT 33
52260: PUSH
52261: LD_INT 2
52263: PUSH
52264: EMPTY
52265: LIST
52266: LIST
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: LIST
52272: PPUSH
52273: CALL_OW 69
52277: ST_TO_ADDR
// if not tmp then
52278: LD_VAR 0 1
52282: NOT
52283: IFFALSE 52287
// exit ;
52285: GO 52324
// for i in tmp do
52287: LD_ADDR_VAR 0 2
52291: PUSH
52292: LD_VAR 0 1
52296: PUSH
52297: FOR_IN
52298: IFFALSE 52322
// if IsControledBy ( i ) then
52300: LD_VAR 0 2
52304: PPUSH
52305: CALL_OW 312
52309: IFFALSE 52320
// ComUnlink ( i ) ;
52311: LD_VAR 0 2
52315: PPUSH
52316: CALL_OW 136
52320: GO 52297
52322: POP
52323: POP
// end ;
52324: PPOPN 2
52326: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52327: LD_EXP 74
52331: PUSH
52332: LD_EXP 105
52336: AND
52337: IFFALSE 52477
52339: GO 52341
52341: DISABLE
52342: LD_INT 0
52344: PPUSH
52345: PPUSH
// begin ToLua ( displayPowell(); ) ;
52346: LD_STRING displayPowell();
52348: PPUSH
52349: CALL_OW 559
// uc_side := 0 ;
52353: LD_ADDR_OWVAR 20
52357: PUSH
52358: LD_INT 0
52360: ST_TO_ADDR
// uc_nation := 2 ;
52361: LD_ADDR_OWVAR 21
52365: PUSH
52366: LD_INT 2
52368: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52369: LD_ADDR_OWVAR 37
52373: PUSH
52374: LD_INT 14
52376: ST_TO_ADDR
// vc_engine := engine_siberite ;
52377: LD_ADDR_OWVAR 39
52381: PUSH
52382: LD_INT 3
52384: ST_TO_ADDR
// vc_control := control_apeman ;
52385: LD_ADDR_OWVAR 38
52389: PUSH
52390: LD_INT 5
52392: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52393: LD_ADDR_OWVAR 40
52397: PUSH
52398: LD_INT 29
52400: ST_TO_ADDR
// un := CreateVehicle ;
52401: LD_ADDR_VAR 0 2
52405: PUSH
52406: CALL_OW 45
52410: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52411: LD_VAR 0 2
52415: PPUSH
52416: LD_INT 1
52418: PPUSH
52419: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52423: LD_INT 35
52425: PPUSH
52426: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52430: LD_VAR 0 2
52434: PPUSH
52435: LD_INT 22
52437: PUSH
52438: LD_OWVAR 2
52442: PUSH
52443: EMPTY
52444: LIST
52445: LIST
52446: PPUSH
52447: CALL_OW 69
52451: PPUSH
52452: LD_VAR 0 2
52456: PPUSH
52457: CALL_OW 74
52461: PPUSH
52462: CALL_OW 115
// until IsDead ( un ) ;
52466: LD_VAR 0 2
52470: PPUSH
52471: CALL_OW 301
52475: IFFALSE 52423
// end ;
52477: PPOPN 2
52479: END
// every 0 0$1 trigger StreamModeActive and sStu do
52480: LD_EXP 74
52484: PUSH
52485: LD_EXP 113
52489: AND
52490: IFFALSE 52506
52492: GO 52494
52494: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52495: LD_STRING displayStucuk();
52497: PPUSH
52498: CALL_OW 559
// ResetFog ;
52502: CALL_OW 335
// end ;
52506: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52507: LD_EXP 74
52511: PUSH
52512: LD_EXP 106
52516: AND
52517: IFFALSE 52658
52519: GO 52521
52521: DISABLE
52522: LD_INT 0
52524: PPUSH
52525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52526: LD_ADDR_VAR 0 2
52530: PUSH
52531: LD_INT 22
52533: PUSH
52534: LD_OWVAR 2
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: PUSH
52543: LD_INT 21
52545: PUSH
52546: LD_INT 1
52548: PUSH
52549: EMPTY
52550: LIST
52551: LIST
52552: PUSH
52553: EMPTY
52554: LIST
52555: LIST
52556: PPUSH
52557: CALL_OW 69
52561: ST_TO_ADDR
// if not tmp then
52562: LD_VAR 0 2
52566: NOT
52567: IFFALSE 52571
// exit ;
52569: GO 52658
// un := tmp [ rand ( 1 , tmp ) ] ;
52571: LD_ADDR_VAR 0 1
52575: PUSH
52576: LD_VAR 0 2
52580: PUSH
52581: LD_INT 1
52583: PPUSH
52584: LD_VAR 0 2
52588: PPUSH
52589: CALL_OW 12
52593: ARRAY
52594: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52595: LD_VAR 0 1
52599: PPUSH
52600: LD_INT 0
52602: PPUSH
52603: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52607: LD_VAR 0 1
52611: PPUSH
52612: LD_OWVAR 3
52616: PUSH
52617: LD_VAR 0 1
52621: DIFF
52622: PPUSH
52623: LD_VAR 0 1
52627: PPUSH
52628: CALL_OW 74
52632: PPUSH
52633: CALL_OW 115
// wait ( 0 0$20 ) ;
52637: LD_INT 700
52639: PPUSH
52640: CALL_OW 67
// SetSide ( un , your_side ) ;
52644: LD_VAR 0 1
52648: PPUSH
52649: LD_OWVAR 2
52653: PPUSH
52654: CALL_OW 235
// end ;
52658: PPOPN 2
52660: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52661: LD_EXP 74
52665: PUSH
52666: LD_EXP 107
52670: AND
52671: IFFALSE 52777
52673: GO 52675
52675: DISABLE
52676: LD_INT 0
52678: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52679: LD_ADDR_VAR 0 1
52683: PUSH
52684: LD_INT 22
52686: PUSH
52687: LD_OWVAR 2
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: PUSH
52696: LD_INT 2
52698: PUSH
52699: LD_INT 30
52701: PUSH
52702: LD_INT 0
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PUSH
52709: LD_INT 30
52711: PUSH
52712: LD_INT 1
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: LIST
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PPUSH
52728: CALL_OW 69
52732: ST_TO_ADDR
// if not depot then
52733: LD_VAR 0 1
52737: NOT
52738: IFFALSE 52742
// exit ;
52740: GO 52777
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52742: LD_VAR 0 1
52746: PUSH
52747: LD_INT 1
52749: ARRAY
52750: PPUSH
52751: CALL_OW 250
52755: PPUSH
52756: LD_VAR 0 1
52760: PUSH
52761: LD_INT 1
52763: ARRAY
52764: PPUSH
52765: CALL_OW 251
52769: PPUSH
52770: LD_INT 70
52772: PPUSH
52773: CALL_OW 495
// end ;
52777: PPOPN 1
52779: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52780: LD_EXP 74
52784: PUSH
52785: LD_EXP 108
52789: AND
52790: IFFALSE 53001
52792: GO 52794
52794: DISABLE
52795: LD_INT 0
52797: PPUSH
52798: PPUSH
52799: PPUSH
52800: PPUSH
52801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52802: LD_ADDR_VAR 0 5
52806: PUSH
52807: LD_INT 22
52809: PUSH
52810: LD_OWVAR 2
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: LD_INT 21
52821: PUSH
52822: LD_INT 1
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PPUSH
52833: CALL_OW 69
52837: ST_TO_ADDR
// if not tmp then
52838: LD_VAR 0 5
52842: NOT
52843: IFFALSE 52847
// exit ;
52845: GO 53001
// for i in tmp do
52847: LD_ADDR_VAR 0 1
52851: PUSH
52852: LD_VAR 0 5
52856: PUSH
52857: FOR_IN
52858: IFFALSE 52999
// begin d := rand ( 0 , 5 ) ;
52860: LD_ADDR_VAR 0 4
52864: PUSH
52865: LD_INT 0
52867: PPUSH
52868: LD_INT 5
52870: PPUSH
52871: CALL_OW 12
52875: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52876: LD_ADDR_VAR 0 2
52880: PUSH
52881: LD_VAR 0 1
52885: PPUSH
52886: CALL_OW 250
52890: PPUSH
52891: LD_VAR 0 4
52895: PPUSH
52896: LD_INT 3
52898: PPUSH
52899: LD_INT 12
52901: PPUSH
52902: CALL_OW 12
52906: PPUSH
52907: CALL_OW 272
52911: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_VAR 0 1
52921: PPUSH
52922: CALL_OW 251
52926: PPUSH
52927: LD_VAR 0 4
52931: PPUSH
52932: LD_INT 3
52934: PPUSH
52935: LD_INT 12
52937: PPUSH
52938: CALL_OW 12
52942: PPUSH
52943: CALL_OW 273
52947: ST_TO_ADDR
// if ValidHex ( x , y ) then
52948: LD_VAR 0 2
52952: PPUSH
52953: LD_VAR 0 3
52957: PPUSH
52958: CALL_OW 488
52962: IFFALSE 52997
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52964: LD_VAR 0 1
52968: PPUSH
52969: LD_VAR 0 2
52973: PPUSH
52974: LD_VAR 0 3
52978: PPUSH
52979: LD_INT 3
52981: PPUSH
52982: LD_INT 6
52984: PPUSH
52985: CALL_OW 12
52989: PPUSH
52990: LD_INT 1
52992: PPUSH
52993: CALL_OW 483
// end ;
52997: GO 52857
52999: POP
53000: POP
// end ;
53001: PPOPN 5
53003: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53004: LD_EXP 74
53008: PUSH
53009: LD_EXP 109
53013: AND
53014: IFFALSE 53108
53016: GO 53018
53018: DISABLE
53019: LD_INT 0
53021: PPUSH
53022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53023: LD_ADDR_VAR 0 2
53027: PUSH
53028: LD_INT 22
53030: PUSH
53031: LD_OWVAR 2
53035: PUSH
53036: EMPTY
53037: LIST
53038: LIST
53039: PUSH
53040: LD_INT 32
53042: PUSH
53043: LD_INT 1
53045: PUSH
53046: EMPTY
53047: LIST
53048: LIST
53049: PUSH
53050: LD_INT 21
53052: PUSH
53053: LD_INT 2
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: PUSH
53060: EMPTY
53061: LIST
53062: LIST
53063: LIST
53064: PPUSH
53065: CALL_OW 69
53069: ST_TO_ADDR
// if not tmp then
53070: LD_VAR 0 2
53074: NOT
53075: IFFALSE 53079
// exit ;
53077: GO 53108
// for i in tmp do
53079: LD_ADDR_VAR 0 1
53083: PUSH
53084: LD_VAR 0 2
53088: PUSH
53089: FOR_IN
53090: IFFALSE 53106
// SetFuel ( i , 0 ) ;
53092: LD_VAR 0 1
53096: PPUSH
53097: LD_INT 0
53099: PPUSH
53100: CALL_OW 240
53104: GO 53089
53106: POP
53107: POP
// end ;
53108: PPOPN 2
53110: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53111: LD_EXP 74
53115: PUSH
53116: LD_EXP 110
53120: AND
53121: IFFALSE 53187
53123: GO 53125
53125: DISABLE
53126: LD_INT 0
53128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53129: LD_ADDR_VAR 0 1
53133: PUSH
53134: LD_INT 22
53136: PUSH
53137: LD_OWVAR 2
53141: PUSH
53142: EMPTY
53143: LIST
53144: LIST
53145: PUSH
53146: LD_INT 30
53148: PUSH
53149: LD_INT 29
53151: PUSH
53152: EMPTY
53153: LIST
53154: LIST
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PPUSH
53160: CALL_OW 69
53164: ST_TO_ADDR
// if not tmp then
53165: LD_VAR 0 1
53169: NOT
53170: IFFALSE 53174
// exit ;
53172: GO 53187
// DestroyUnit ( tmp [ 1 ] ) ;
53174: LD_VAR 0 1
53178: PUSH
53179: LD_INT 1
53181: ARRAY
53182: PPUSH
53183: CALL_OW 65
// end ;
53187: PPOPN 1
53189: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53190: LD_EXP 74
53194: PUSH
53195: LD_EXP 112
53199: AND
53200: IFFALSE 53329
53202: GO 53204
53204: DISABLE
53205: LD_INT 0
53207: PPUSH
// begin uc_side := 0 ;
53208: LD_ADDR_OWVAR 20
53212: PUSH
53213: LD_INT 0
53215: ST_TO_ADDR
// uc_nation := nation_arabian ;
53216: LD_ADDR_OWVAR 21
53220: PUSH
53221: LD_INT 2
53223: ST_TO_ADDR
// hc_gallery :=  ;
53224: LD_ADDR_OWVAR 33
53228: PUSH
53229: LD_STRING 
53231: ST_TO_ADDR
// hc_name :=  ;
53232: LD_ADDR_OWVAR 26
53236: PUSH
53237: LD_STRING 
53239: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53240: LD_INT 1
53242: PPUSH
53243: LD_INT 11
53245: PPUSH
53246: LD_INT 10
53248: PPUSH
53249: CALL_OW 380
// un := CreateHuman ;
53253: LD_ADDR_VAR 0 1
53257: PUSH
53258: CALL_OW 44
53262: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53263: LD_VAR 0 1
53267: PPUSH
53268: LD_INT 1
53270: PPUSH
53271: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53275: LD_INT 35
53277: PPUSH
53278: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53282: LD_VAR 0 1
53286: PPUSH
53287: LD_INT 22
53289: PUSH
53290: LD_OWVAR 2
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: PPUSH
53299: CALL_OW 69
53303: PPUSH
53304: LD_VAR 0 1
53308: PPUSH
53309: CALL_OW 74
53313: PPUSH
53314: CALL_OW 115
// until IsDead ( un ) ;
53318: LD_VAR 0 1
53322: PPUSH
53323: CALL_OW 301
53327: IFFALSE 53275
// end ;
53329: PPOPN 1
53331: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53332: LD_EXP 74
53336: PUSH
53337: LD_EXP 114
53341: AND
53342: IFFALSE 53354
53344: GO 53346
53346: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53347: LD_STRING earthquake(getX(game), 0, 32)
53349: PPUSH
53350: CALL_OW 559
53354: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53355: LD_EXP 74
53359: PUSH
53360: LD_EXP 115
53364: AND
53365: IFFALSE 53456
53367: GO 53369
53369: DISABLE
53370: LD_INT 0
53372: PPUSH
// begin enable ;
53373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53374: LD_ADDR_VAR 0 1
53378: PUSH
53379: LD_INT 22
53381: PUSH
53382: LD_OWVAR 2
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PUSH
53391: LD_INT 21
53393: PUSH
53394: LD_INT 2
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: PUSH
53401: LD_INT 33
53403: PUSH
53404: LD_INT 3
53406: PUSH
53407: EMPTY
53408: LIST
53409: LIST
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: LIST
53415: PPUSH
53416: CALL_OW 69
53420: ST_TO_ADDR
// if not tmp then
53421: LD_VAR 0 1
53425: NOT
53426: IFFALSE 53430
// exit ;
53428: GO 53456
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53430: LD_VAR 0 1
53434: PUSH
53435: LD_INT 1
53437: PPUSH
53438: LD_VAR 0 1
53442: PPUSH
53443: CALL_OW 12
53447: ARRAY
53448: PPUSH
53449: LD_INT 1
53451: PPUSH
53452: CALL_OW 234
// end ;
53456: PPOPN 1
53458: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53459: LD_EXP 74
53463: PUSH
53464: LD_EXP 116
53468: AND
53469: IFFALSE 53610
53471: GO 53473
53473: DISABLE
53474: LD_INT 0
53476: PPUSH
53477: PPUSH
53478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53479: LD_ADDR_VAR 0 3
53483: PUSH
53484: LD_INT 22
53486: PUSH
53487: LD_OWVAR 2
53491: PUSH
53492: EMPTY
53493: LIST
53494: LIST
53495: PUSH
53496: LD_INT 25
53498: PUSH
53499: LD_INT 1
53501: PUSH
53502: EMPTY
53503: LIST
53504: LIST
53505: PUSH
53506: EMPTY
53507: LIST
53508: LIST
53509: PPUSH
53510: CALL_OW 69
53514: ST_TO_ADDR
// if not tmp then
53515: LD_VAR 0 3
53519: NOT
53520: IFFALSE 53524
// exit ;
53522: GO 53610
// un := tmp [ rand ( 1 , tmp ) ] ;
53524: LD_ADDR_VAR 0 2
53528: PUSH
53529: LD_VAR 0 3
53533: PUSH
53534: LD_INT 1
53536: PPUSH
53537: LD_VAR 0 3
53541: PPUSH
53542: CALL_OW 12
53546: ARRAY
53547: ST_TO_ADDR
// if Crawls ( un ) then
53548: LD_VAR 0 2
53552: PPUSH
53553: CALL_OW 318
53557: IFFALSE 53568
// ComWalk ( un ) ;
53559: LD_VAR 0 2
53563: PPUSH
53564: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53568: LD_VAR 0 2
53572: PPUSH
53573: LD_INT 9
53575: PPUSH
53576: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53580: LD_INT 28
53582: PPUSH
53583: LD_OWVAR 2
53587: PPUSH
53588: LD_INT 2
53590: PPUSH
53591: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53595: LD_INT 29
53597: PPUSH
53598: LD_OWVAR 2
53602: PPUSH
53603: LD_INT 2
53605: PPUSH
53606: CALL_OW 322
// end ;
53610: PPOPN 3
53612: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53613: LD_EXP 74
53617: PUSH
53618: LD_EXP 117
53622: AND
53623: IFFALSE 53734
53625: GO 53627
53627: DISABLE
53628: LD_INT 0
53630: PPUSH
53631: PPUSH
53632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53633: LD_ADDR_VAR 0 3
53637: PUSH
53638: LD_INT 22
53640: PUSH
53641: LD_OWVAR 2
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: PUSH
53650: LD_INT 25
53652: PUSH
53653: LD_INT 1
53655: PUSH
53656: EMPTY
53657: LIST
53658: LIST
53659: PUSH
53660: EMPTY
53661: LIST
53662: LIST
53663: PPUSH
53664: CALL_OW 69
53668: ST_TO_ADDR
// if not tmp then
53669: LD_VAR 0 3
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53734
// un := tmp [ rand ( 1 , tmp ) ] ;
53678: LD_ADDR_VAR 0 2
53682: PUSH
53683: LD_VAR 0 3
53687: PUSH
53688: LD_INT 1
53690: PPUSH
53691: LD_VAR 0 3
53695: PPUSH
53696: CALL_OW 12
53700: ARRAY
53701: ST_TO_ADDR
// if Crawls ( un ) then
53702: LD_VAR 0 2
53706: PPUSH
53707: CALL_OW 318
53711: IFFALSE 53722
// ComWalk ( un ) ;
53713: LD_VAR 0 2
53717: PPUSH
53718: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53722: LD_VAR 0 2
53726: PPUSH
53727: LD_INT 8
53729: PPUSH
53730: CALL_OW 336
// end ;
53734: PPOPN 3
53736: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53737: LD_EXP 74
53741: PUSH
53742: LD_EXP 118
53746: AND
53747: IFFALSE 53891
53749: GO 53751
53751: DISABLE
53752: LD_INT 0
53754: PPUSH
53755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53756: LD_ADDR_VAR 0 2
53760: PUSH
53761: LD_INT 22
53763: PUSH
53764: LD_OWVAR 2
53768: PUSH
53769: EMPTY
53770: LIST
53771: LIST
53772: PUSH
53773: LD_INT 21
53775: PUSH
53776: LD_INT 2
53778: PUSH
53779: EMPTY
53780: LIST
53781: LIST
53782: PUSH
53783: LD_INT 2
53785: PUSH
53786: LD_INT 34
53788: PUSH
53789: LD_INT 12
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PUSH
53796: LD_INT 34
53798: PUSH
53799: LD_INT 51
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: PUSH
53806: LD_INT 34
53808: PUSH
53809: LD_INT 32
53811: PUSH
53812: EMPTY
53813: LIST
53814: LIST
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: LIST
53820: LIST
53821: PUSH
53822: EMPTY
53823: LIST
53824: LIST
53825: LIST
53826: PPUSH
53827: CALL_OW 69
53831: ST_TO_ADDR
// if not tmp then
53832: LD_VAR 0 2
53836: NOT
53837: IFFALSE 53841
// exit ;
53839: GO 53891
// for i in tmp do
53841: LD_ADDR_VAR 0 1
53845: PUSH
53846: LD_VAR 0 2
53850: PUSH
53851: FOR_IN
53852: IFFALSE 53889
// if GetCargo ( i , mat_artifact ) = 0 then
53854: LD_VAR 0 1
53858: PPUSH
53859: LD_INT 4
53861: PPUSH
53862: CALL_OW 289
53866: PUSH
53867: LD_INT 0
53869: EQUAL
53870: IFFALSE 53887
// SetCargo ( i , mat_siberit , 100 ) ;
53872: LD_VAR 0 1
53876: PPUSH
53877: LD_INT 3
53879: PPUSH
53880: LD_INT 100
53882: PPUSH
53883: CALL_OW 290
53887: GO 53851
53889: POP
53890: POP
// end ;
53891: PPOPN 2
53893: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53894: LD_EXP 74
53898: PUSH
53899: LD_EXP 119
53903: AND
53904: IFFALSE 54087
53906: GO 53908
53908: DISABLE
53909: LD_INT 0
53911: PPUSH
53912: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53913: LD_ADDR_VAR 0 2
53917: PUSH
53918: LD_INT 22
53920: PUSH
53921: LD_OWVAR 2
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: PPUSH
53930: CALL_OW 69
53934: ST_TO_ADDR
// if not tmp then
53935: LD_VAR 0 2
53939: NOT
53940: IFFALSE 53944
// exit ;
53942: GO 54087
// for i := 1 to 2 do
53944: LD_ADDR_VAR 0 1
53948: PUSH
53949: DOUBLE
53950: LD_INT 1
53952: DEC
53953: ST_TO_ADDR
53954: LD_INT 2
53956: PUSH
53957: FOR_TO
53958: IFFALSE 54085
// begin uc_side := your_side ;
53960: LD_ADDR_OWVAR 20
53964: PUSH
53965: LD_OWVAR 2
53969: ST_TO_ADDR
// uc_nation := nation_american ;
53970: LD_ADDR_OWVAR 21
53974: PUSH
53975: LD_INT 1
53977: ST_TO_ADDR
// vc_chassis := us_morphling ;
53978: LD_ADDR_OWVAR 37
53982: PUSH
53983: LD_INT 5
53985: ST_TO_ADDR
// vc_engine := engine_siberite ;
53986: LD_ADDR_OWVAR 39
53990: PUSH
53991: LD_INT 3
53993: ST_TO_ADDR
// vc_control := control_computer ;
53994: LD_ADDR_OWVAR 38
53998: PUSH
53999: LD_INT 3
54001: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54002: LD_ADDR_OWVAR 40
54006: PUSH
54007: LD_INT 10
54009: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54010: LD_VAR 0 2
54014: PUSH
54015: LD_INT 1
54017: ARRAY
54018: PPUSH
54019: CALL_OW 310
54023: NOT
54024: IFFALSE 54071
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54026: CALL_OW 45
54030: PPUSH
54031: LD_VAR 0 2
54035: PUSH
54036: LD_INT 1
54038: ARRAY
54039: PPUSH
54040: CALL_OW 250
54044: PPUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: PPUSH
54054: CALL_OW 251
54058: PPUSH
54059: LD_INT 12
54061: PPUSH
54062: LD_INT 1
54064: PPUSH
54065: CALL_OW 50
54069: GO 54083
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54071: CALL_OW 45
54075: PPUSH
54076: LD_INT 1
54078: PPUSH
54079: CALL_OW 51
// end ;
54083: GO 53957
54085: POP
54086: POP
// end ;
54087: PPOPN 2
54089: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54090: LD_EXP 74
54094: PUSH
54095: LD_EXP 120
54099: AND
54100: IFFALSE 54322
54102: GO 54104
54104: DISABLE
54105: LD_INT 0
54107: PPUSH
54108: PPUSH
54109: PPUSH
54110: PPUSH
54111: PPUSH
54112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54113: LD_ADDR_VAR 0 6
54117: PUSH
54118: LD_INT 22
54120: PUSH
54121: LD_OWVAR 2
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PUSH
54130: LD_INT 21
54132: PUSH
54133: LD_INT 1
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: LD_INT 3
54142: PUSH
54143: LD_INT 23
54145: PUSH
54146: LD_INT 0
54148: PUSH
54149: EMPTY
54150: LIST
54151: LIST
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: LIST
54161: PPUSH
54162: CALL_OW 69
54166: ST_TO_ADDR
// if not tmp then
54167: LD_VAR 0 6
54171: NOT
54172: IFFALSE 54176
// exit ;
54174: GO 54322
// s1 := rand ( 1 , 4 ) ;
54176: LD_ADDR_VAR 0 2
54180: PUSH
54181: LD_INT 1
54183: PPUSH
54184: LD_INT 4
54186: PPUSH
54187: CALL_OW 12
54191: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54192: LD_ADDR_VAR 0 4
54196: PUSH
54197: LD_VAR 0 6
54201: PUSH
54202: LD_INT 1
54204: ARRAY
54205: PPUSH
54206: LD_VAR 0 2
54210: PPUSH
54211: CALL_OW 259
54215: ST_TO_ADDR
// if s1 = 1 then
54216: LD_VAR 0 2
54220: PUSH
54221: LD_INT 1
54223: EQUAL
54224: IFFALSE 54244
// s2 := rand ( 2 , 4 ) else
54226: LD_ADDR_VAR 0 3
54230: PUSH
54231: LD_INT 2
54233: PPUSH
54234: LD_INT 4
54236: PPUSH
54237: CALL_OW 12
54241: ST_TO_ADDR
54242: GO 54252
// s2 := 1 ;
54244: LD_ADDR_VAR 0 3
54248: PUSH
54249: LD_INT 1
54251: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54252: LD_ADDR_VAR 0 5
54256: PUSH
54257: LD_VAR 0 6
54261: PUSH
54262: LD_INT 1
54264: ARRAY
54265: PPUSH
54266: LD_VAR 0 3
54270: PPUSH
54271: CALL_OW 259
54275: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54276: LD_VAR 0 6
54280: PUSH
54281: LD_INT 1
54283: ARRAY
54284: PPUSH
54285: LD_VAR 0 2
54289: PPUSH
54290: LD_VAR 0 5
54294: PPUSH
54295: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54299: LD_VAR 0 6
54303: PUSH
54304: LD_INT 1
54306: ARRAY
54307: PPUSH
54308: LD_VAR 0 3
54312: PPUSH
54313: LD_VAR 0 4
54317: PPUSH
54318: CALL_OW 237
// end ;
54322: PPOPN 6
54324: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54325: LD_EXP 74
54329: PUSH
54330: LD_EXP 121
54334: AND
54335: IFFALSE 54414
54337: GO 54339
54339: DISABLE
54340: LD_INT 0
54342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54343: LD_ADDR_VAR 0 1
54347: PUSH
54348: LD_INT 22
54350: PUSH
54351: LD_OWVAR 2
54355: PUSH
54356: EMPTY
54357: LIST
54358: LIST
54359: PUSH
54360: LD_INT 30
54362: PUSH
54363: LD_INT 3
54365: PUSH
54366: EMPTY
54367: LIST
54368: LIST
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PPUSH
54374: CALL_OW 69
54378: ST_TO_ADDR
// if not tmp then
54379: LD_VAR 0 1
54383: NOT
54384: IFFALSE 54388
// exit ;
54386: GO 54414
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54388: LD_VAR 0 1
54392: PUSH
54393: LD_INT 1
54395: PPUSH
54396: LD_VAR 0 1
54400: PPUSH
54401: CALL_OW 12
54405: ARRAY
54406: PPUSH
54407: LD_INT 1
54409: PPUSH
54410: CALL_OW 234
// end ;
54414: PPOPN 1
54416: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54417: LD_EXP 74
54421: PUSH
54422: LD_EXP 122
54426: AND
54427: IFFALSE 54539
54429: GO 54431
54431: DISABLE
54432: LD_INT 0
54434: PPUSH
54435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54436: LD_ADDR_VAR 0 2
54440: PUSH
54441: LD_INT 22
54443: PUSH
54444: LD_OWVAR 2
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PUSH
54453: LD_INT 2
54455: PUSH
54456: LD_INT 30
54458: PUSH
54459: LD_INT 27
54461: PUSH
54462: EMPTY
54463: LIST
54464: LIST
54465: PUSH
54466: LD_INT 30
54468: PUSH
54469: LD_INT 26
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: PUSH
54476: LD_INT 30
54478: PUSH
54479: LD_INT 28
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: LIST
54490: LIST
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PPUSH
54496: CALL_OW 69
54500: ST_TO_ADDR
// if not tmp then
54501: LD_VAR 0 2
54505: NOT
54506: IFFALSE 54510
// exit ;
54508: GO 54539
// for i in tmp do
54510: LD_ADDR_VAR 0 1
54514: PUSH
54515: LD_VAR 0 2
54519: PUSH
54520: FOR_IN
54521: IFFALSE 54537
// SetLives ( i , 1 ) ;
54523: LD_VAR 0 1
54527: PPUSH
54528: LD_INT 1
54530: PPUSH
54531: CALL_OW 234
54535: GO 54520
54537: POP
54538: POP
// end ;
54539: PPOPN 2
54541: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54542: LD_EXP 74
54546: PUSH
54547: LD_EXP 123
54551: AND
54552: IFFALSE 54839
54554: GO 54556
54556: DISABLE
54557: LD_INT 0
54559: PPUSH
54560: PPUSH
54561: PPUSH
// begin i := rand ( 1 , 7 ) ;
54562: LD_ADDR_VAR 0 1
54566: PUSH
54567: LD_INT 1
54569: PPUSH
54570: LD_INT 7
54572: PPUSH
54573: CALL_OW 12
54577: ST_TO_ADDR
// case i of 1 :
54578: LD_VAR 0 1
54582: PUSH
54583: LD_INT 1
54585: DOUBLE
54586: EQUAL
54587: IFTRUE 54591
54589: GO 54601
54591: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54592: LD_STRING earthquake(getX(game), 0, 32)
54594: PPUSH
54595: CALL_OW 559
54599: GO 54839
54601: LD_INT 2
54603: DOUBLE
54604: EQUAL
54605: IFTRUE 54609
54607: GO 54623
54609: POP
// begin ToLua ( displayStucuk(); ) ;
54610: LD_STRING displayStucuk();
54612: PPUSH
54613: CALL_OW 559
// ResetFog ;
54617: CALL_OW 335
// end ; 3 :
54621: GO 54839
54623: LD_INT 3
54625: DOUBLE
54626: EQUAL
54627: IFTRUE 54631
54629: GO 54735
54631: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54632: LD_ADDR_VAR 0 2
54636: PUSH
54637: LD_INT 22
54639: PUSH
54640: LD_OWVAR 2
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: PUSH
54649: LD_INT 25
54651: PUSH
54652: LD_INT 1
54654: PUSH
54655: EMPTY
54656: LIST
54657: LIST
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: PPUSH
54663: CALL_OW 69
54667: ST_TO_ADDR
// if not tmp then
54668: LD_VAR 0 2
54672: NOT
54673: IFFALSE 54677
// exit ;
54675: GO 54839
// un := tmp [ rand ( 1 , tmp ) ] ;
54677: LD_ADDR_VAR 0 3
54681: PUSH
54682: LD_VAR 0 2
54686: PUSH
54687: LD_INT 1
54689: PPUSH
54690: LD_VAR 0 2
54694: PPUSH
54695: CALL_OW 12
54699: ARRAY
54700: ST_TO_ADDR
// if Crawls ( un ) then
54701: LD_VAR 0 3
54705: PPUSH
54706: CALL_OW 318
54710: IFFALSE 54721
// ComWalk ( un ) ;
54712: LD_VAR 0 3
54716: PPUSH
54717: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54721: LD_VAR 0 3
54725: PPUSH
54726: LD_INT 8
54728: PPUSH
54729: CALL_OW 336
// end ; 4 :
54733: GO 54839
54735: LD_INT 4
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54817
54743: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: LD_INT 22
54751: PUSH
54752: LD_OWVAR 2
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: PUSH
54761: LD_INT 30
54763: PUSH
54764: LD_INT 29
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PPUSH
54775: CALL_OW 69
54779: ST_TO_ADDR
// if not tmp then
54780: LD_VAR 0 2
54784: NOT
54785: IFFALSE 54789
// exit ;
54787: GO 54839
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54789: LD_VAR 0 2
54793: PUSH
54794: LD_INT 1
54796: ARRAY
54797: PPUSH
54798: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54802: LD_VAR 0 2
54806: PUSH
54807: LD_INT 1
54809: ARRAY
54810: PPUSH
54811: CALL_OW 65
// end ; 5 .. 7 :
54815: GO 54839
54817: LD_INT 5
54819: DOUBLE
54820: GREATEREQUAL
54821: IFFALSE 54829
54823: LD_INT 7
54825: DOUBLE
54826: LESSEQUAL
54827: IFTRUE 54831
54829: GO 54838
54831: POP
// StreamSibBomb ; end ;
54832: CALL 51076 0 0
54836: GO 54839
54838: POP
// end ;
54839: PPOPN 3
54841: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54842: LD_EXP 74
54846: PUSH
54847: LD_EXP 124
54851: AND
54852: IFFALSE 55008
54854: GO 54856
54856: DISABLE
54857: LD_INT 0
54859: PPUSH
54860: PPUSH
54861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54862: LD_ADDR_VAR 0 2
54866: PUSH
54867: LD_INT 81
54869: PUSH
54870: LD_OWVAR 2
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: PUSH
54879: LD_INT 2
54881: PUSH
54882: LD_INT 21
54884: PUSH
54885: LD_INT 1
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: PUSH
54892: LD_INT 21
54894: PUSH
54895: LD_INT 2
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: PPUSH
54911: CALL_OW 69
54915: ST_TO_ADDR
// if not tmp then
54916: LD_VAR 0 2
54920: NOT
54921: IFFALSE 54925
// exit ;
54923: GO 55008
// p := 0 ;
54925: LD_ADDR_VAR 0 3
54929: PUSH
54930: LD_INT 0
54932: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54933: LD_INT 35
54935: PPUSH
54936: CALL_OW 67
// p := p + 1 ;
54940: LD_ADDR_VAR 0 3
54944: PUSH
54945: LD_VAR 0 3
54949: PUSH
54950: LD_INT 1
54952: PLUS
54953: ST_TO_ADDR
// for i in tmp do
54954: LD_ADDR_VAR 0 1
54958: PUSH
54959: LD_VAR 0 2
54963: PUSH
54964: FOR_IN
54965: IFFALSE 54996
// if GetLives ( i ) < 1000 then
54967: LD_VAR 0 1
54971: PPUSH
54972: CALL_OW 256
54976: PUSH
54977: LD_INT 1000
54979: LESS
54980: IFFALSE 54994
// SetLives ( i , 1000 ) ;
54982: LD_VAR 0 1
54986: PPUSH
54987: LD_INT 1000
54989: PPUSH
54990: CALL_OW 234
54994: GO 54964
54996: POP
54997: POP
// until p > 20 ;
54998: LD_VAR 0 3
55002: PUSH
55003: LD_INT 20
55005: GREATER
55006: IFFALSE 54933
// end ;
55008: PPOPN 3
55010: END
// every 0 0$1 trigger StreamModeActive and sTime do
55011: LD_EXP 74
55015: PUSH
55016: LD_EXP 125
55020: AND
55021: IFFALSE 55056
55023: GO 55025
55025: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55026: LD_INT 28
55028: PPUSH
55029: LD_OWVAR 2
55033: PPUSH
55034: LD_INT 2
55036: PPUSH
55037: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55041: LD_INT 30
55043: PPUSH
55044: LD_OWVAR 2
55048: PPUSH
55049: LD_INT 2
55051: PPUSH
55052: CALL_OW 322
// end ;
55056: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55057: LD_EXP 74
55061: PUSH
55062: LD_EXP 126
55066: AND
55067: IFFALSE 55188
55069: GO 55071
55071: DISABLE
55072: LD_INT 0
55074: PPUSH
55075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55076: LD_ADDR_VAR 0 2
55080: PUSH
55081: LD_INT 22
55083: PUSH
55084: LD_OWVAR 2
55088: PUSH
55089: EMPTY
55090: LIST
55091: LIST
55092: PUSH
55093: LD_INT 21
55095: PUSH
55096: LD_INT 1
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: PUSH
55103: LD_INT 3
55105: PUSH
55106: LD_INT 23
55108: PUSH
55109: LD_INT 0
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: PPUSH
55125: CALL_OW 69
55129: ST_TO_ADDR
// if not tmp then
55130: LD_VAR 0 2
55134: NOT
55135: IFFALSE 55139
// exit ;
55137: GO 55188
// for i in tmp do
55139: LD_ADDR_VAR 0 1
55143: PUSH
55144: LD_VAR 0 2
55148: PUSH
55149: FOR_IN
55150: IFFALSE 55186
// begin if Crawls ( i ) then
55152: LD_VAR 0 1
55156: PPUSH
55157: CALL_OW 318
55161: IFFALSE 55172
// ComWalk ( i ) ;
55163: LD_VAR 0 1
55167: PPUSH
55168: CALL_OW 138
// SetClass ( i , 2 ) ;
55172: LD_VAR 0 1
55176: PPUSH
55177: LD_INT 2
55179: PPUSH
55180: CALL_OW 336
// end ;
55184: GO 55149
55186: POP
55187: POP
// end ;
55188: PPOPN 2
55190: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55191: LD_EXP 74
55195: PUSH
55196: LD_EXP 127
55200: AND
55201: IFFALSE 55489
55203: GO 55205
55205: DISABLE
55206: LD_INT 0
55208: PPUSH
55209: PPUSH
55210: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55211: LD_OWVAR 2
55215: PPUSH
55216: LD_INT 9
55218: PPUSH
55219: LD_INT 1
55221: PPUSH
55222: LD_INT 1
55224: PPUSH
55225: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55229: LD_INT 9
55231: PPUSH
55232: LD_OWVAR 2
55236: PPUSH
55237: CALL_OW 343
// uc_side := 9 ;
55241: LD_ADDR_OWVAR 20
55245: PUSH
55246: LD_INT 9
55248: ST_TO_ADDR
// uc_nation := 2 ;
55249: LD_ADDR_OWVAR 21
55253: PUSH
55254: LD_INT 2
55256: ST_TO_ADDR
// hc_name := Dark Warrior ;
55257: LD_ADDR_OWVAR 26
55261: PUSH
55262: LD_STRING Dark Warrior
55264: ST_TO_ADDR
// hc_gallery :=  ;
55265: LD_ADDR_OWVAR 33
55269: PUSH
55270: LD_STRING 
55272: ST_TO_ADDR
// hc_noskilllimit := true ;
55273: LD_ADDR_OWVAR 76
55277: PUSH
55278: LD_INT 1
55280: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55281: LD_ADDR_OWVAR 31
55285: PUSH
55286: LD_INT 30
55288: PUSH
55289: LD_INT 30
55291: PUSH
55292: LD_INT 30
55294: PUSH
55295: LD_INT 30
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: ST_TO_ADDR
// un := CreateHuman ;
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: CALL_OW 44
55313: ST_TO_ADDR
// hc_noskilllimit := false ;
55314: LD_ADDR_OWVAR 76
55318: PUSH
55319: LD_INT 0
55321: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55322: LD_VAR 0 3
55326: PPUSH
55327: LD_INT 1
55329: PPUSH
55330: CALL_OW 51
// ToLua ( playRanger() ) ;
55334: LD_STRING playRanger()
55336: PPUSH
55337: CALL_OW 559
// p := 0 ;
55341: LD_ADDR_VAR 0 2
55345: PUSH
55346: LD_INT 0
55348: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55349: LD_INT 35
55351: PPUSH
55352: CALL_OW 67
// p := p + 1 ;
55356: LD_ADDR_VAR 0 2
55360: PUSH
55361: LD_VAR 0 2
55365: PUSH
55366: LD_INT 1
55368: PLUS
55369: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55370: LD_VAR 0 3
55374: PPUSH
55375: CALL_OW 256
55379: PUSH
55380: LD_INT 1000
55382: LESS
55383: IFFALSE 55397
// SetLives ( un , 1000 ) ;
55385: LD_VAR 0 3
55389: PPUSH
55390: LD_INT 1000
55392: PPUSH
55393: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55397: LD_VAR 0 3
55401: PPUSH
55402: LD_INT 81
55404: PUSH
55405: LD_OWVAR 2
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: PUSH
55414: LD_INT 91
55416: PUSH
55417: LD_VAR 0 3
55421: PUSH
55422: LD_INT 30
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: LIST
55429: PUSH
55430: EMPTY
55431: LIST
55432: LIST
55433: PPUSH
55434: CALL_OW 69
55438: PPUSH
55439: LD_VAR 0 3
55443: PPUSH
55444: CALL_OW 74
55448: PPUSH
55449: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55453: LD_VAR 0 2
55457: PUSH
55458: LD_INT 80
55460: GREATER
55461: PUSH
55462: LD_VAR 0 3
55466: PPUSH
55467: CALL_OW 301
55471: OR
55472: IFFALSE 55349
// if un then
55474: LD_VAR 0 3
55478: IFFALSE 55489
// RemoveUnit ( un ) ;
55480: LD_VAR 0 3
55484: PPUSH
55485: CALL_OW 64
// end ;
55489: PPOPN 3
55491: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55492: LD_EXP 128
55496: IFFALSE 55612
55498: GO 55500
55500: DISABLE
55501: LD_INT 0
55503: PPUSH
55504: PPUSH
55505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55506: LD_ADDR_VAR 0 2
55510: PUSH
55511: LD_INT 81
55513: PUSH
55514: LD_OWVAR 2
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: PUSH
55523: LD_INT 21
55525: PUSH
55526: LD_INT 1
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: PPUSH
55537: CALL_OW 69
55541: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55542: LD_STRING playComputer()
55544: PPUSH
55545: CALL_OW 559
// if not tmp then
55549: LD_VAR 0 2
55553: NOT
55554: IFFALSE 55558
// exit ;
55556: GO 55612
// for i in tmp do
55558: LD_ADDR_VAR 0 1
55562: PUSH
55563: LD_VAR 0 2
55567: PUSH
55568: FOR_IN
55569: IFFALSE 55610
// for j := 1 to 4 do
55571: LD_ADDR_VAR 0 3
55575: PUSH
55576: DOUBLE
55577: LD_INT 1
55579: DEC
55580: ST_TO_ADDR
55581: LD_INT 4
55583: PUSH
55584: FOR_TO
55585: IFFALSE 55606
// SetSkill ( i , j , 10 ) ;
55587: LD_VAR 0 1
55591: PPUSH
55592: LD_VAR 0 3
55596: PPUSH
55597: LD_INT 10
55599: PPUSH
55600: CALL_OW 237
55604: GO 55584
55606: POP
55607: POP
55608: GO 55568
55610: POP
55611: POP
// end ;
55612: PPOPN 3
55614: END
// every 0 0$1 trigger s30 do var i , tmp ;
55615: LD_EXP 129
55619: IFFALSE 55688
55621: GO 55623
55623: DISABLE
55624: LD_INT 0
55626: PPUSH
55627: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55628: LD_ADDR_VAR 0 2
55632: PUSH
55633: LD_INT 22
55635: PUSH
55636: LD_OWVAR 2
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: PPUSH
55645: CALL_OW 69
55649: ST_TO_ADDR
// if not tmp then
55650: LD_VAR 0 2
55654: NOT
55655: IFFALSE 55659
// exit ;
55657: GO 55688
// for i in tmp do
55659: LD_ADDR_VAR 0 1
55663: PUSH
55664: LD_VAR 0 2
55668: PUSH
55669: FOR_IN
55670: IFFALSE 55686
// SetLives ( i , 300 ) ;
55672: LD_VAR 0 1
55676: PPUSH
55677: LD_INT 300
55679: PPUSH
55680: CALL_OW 234
55684: GO 55669
55686: POP
55687: POP
// end ;
55688: PPOPN 2
55690: END
// every 0 0$1 trigger s60 do var i , tmp ;
55691: LD_EXP 130
55695: IFFALSE 55764
55697: GO 55699
55699: DISABLE
55700: LD_INT 0
55702: PPUSH
55703: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55704: LD_ADDR_VAR 0 2
55708: PUSH
55709: LD_INT 22
55711: PUSH
55712: LD_OWVAR 2
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: PPUSH
55721: CALL_OW 69
55725: ST_TO_ADDR
// if not tmp then
55726: LD_VAR 0 2
55730: NOT
55731: IFFALSE 55735
// exit ;
55733: GO 55764
// for i in tmp do
55735: LD_ADDR_VAR 0 1
55739: PUSH
55740: LD_VAR 0 2
55744: PUSH
55745: FOR_IN
55746: IFFALSE 55762
// SetLives ( i , 600 ) ;
55748: LD_VAR 0 1
55752: PPUSH
55753: LD_INT 600
55755: PPUSH
55756: CALL_OW 234
55760: GO 55745
55762: POP
55763: POP
// end ;
55764: PPOPN 2
55766: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55767: LD_INT 0
55769: PPUSH
// case cmd of 301 :
55770: LD_VAR 0 1
55774: PUSH
55775: LD_INT 301
55777: DOUBLE
55778: EQUAL
55779: IFTRUE 55783
55781: GO 55815
55783: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55784: LD_VAR 0 6
55788: PPUSH
55789: LD_VAR 0 7
55793: PPUSH
55794: LD_VAR 0 8
55798: PPUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: LD_VAR 0 5
55808: PPUSH
55809: CALL 57024 0 5
55813: GO 55936
55815: LD_INT 302
55817: DOUBLE
55818: EQUAL
55819: IFTRUE 55823
55821: GO 55860
55823: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55824: LD_VAR 0 6
55828: PPUSH
55829: LD_VAR 0 7
55833: PPUSH
55834: LD_VAR 0 8
55838: PPUSH
55839: LD_VAR 0 9
55843: PPUSH
55844: LD_VAR 0 4
55848: PPUSH
55849: LD_VAR 0 5
55853: PPUSH
55854: CALL 57115 0 6
55858: GO 55936
55860: LD_INT 303
55862: DOUBLE
55863: EQUAL
55864: IFTRUE 55868
55866: GO 55905
55868: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55869: LD_VAR 0 6
55873: PPUSH
55874: LD_VAR 0 7
55878: PPUSH
55879: LD_VAR 0 8
55883: PPUSH
55884: LD_VAR 0 9
55888: PPUSH
55889: LD_VAR 0 4
55893: PPUSH
55894: LD_VAR 0 5
55898: PPUSH
55899: CALL 55941 0 6
55903: GO 55936
55905: LD_INT 304
55907: DOUBLE
55908: EQUAL
55909: IFTRUE 55913
55911: GO 55935
55913: POP
// hHackTeleport ( unit , x , y ) ; end ;
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 4
55923: PPUSH
55924: LD_VAR 0 5
55928: PPUSH
55929: CALL 57708 0 3
55933: GO 55936
55935: POP
// end ;
55936: LD_VAR 0 12
55940: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55941: LD_INT 0
55943: PPUSH
55944: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55945: LD_VAR 0 1
55949: PUSH
55950: LD_INT 1
55952: LESS
55953: PUSH
55954: LD_VAR 0 1
55958: PUSH
55959: LD_INT 3
55961: GREATER
55962: OR
55963: PUSH
55964: LD_VAR 0 5
55968: PPUSH
55969: LD_VAR 0 6
55973: PPUSH
55974: CALL_OW 428
55978: OR
55979: IFFALSE 55983
// exit ;
55981: GO 56711
// uc_side := your_side ;
55983: LD_ADDR_OWVAR 20
55987: PUSH
55988: LD_OWVAR 2
55992: ST_TO_ADDR
// uc_nation := nation ;
55993: LD_ADDR_OWVAR 21
55997: PUSH
55998: LD_VAR 0 1
56002: ST_TO_ADDR
// bc_level = 1 ;
56003: LD_ADDR_OWVAR 43
56007: PUSH
56008: LD_INT 1
56010: ST_TO_ADDR
// case btype of 1 :
56011: LD_VAR 0 2
56015: PUSH
56016: LD_INT 1
56018: DOUBLE
56019: EQUAL
56020: IFTRUE 56024
56022: GO 56035
56024: POP
// bc_type := b_depot ; 2 :
56025: LD_ADDR_OWVAR 42
56029: PUSH
56030: LD_INT 0
56032: ST_TO_ADDR
56033: GO 56655
56035: LD_INT 2
56037: DOUBLE
56038: EQUAL
56039: IFTRUE 56043
56041: GO 56054
56043: POP
// bc_type := b_warehouse ; 3 :
56044: LD_ADDR_OWVAR 42
56048: PUSH
56049: LD_INT 1
56051: ST_TO_ADDR
56052: GO 56655
56054: LD_INT 3
56056: DOUBLE
56057: EQUAL
56058: IFTRUE 56062
56060: GO 56073
56062: POP
// bc_type := b_lab ; 4 .. 9 :
56063: LD_ADDR_OWVAR 42
56067: PUSH
56068: LD_INT 6
56070: ST_TO_ADDR
56071: GO 56655
56073: LD_INT 4
56075: DOUBLE
56076: GREATEREQUAL
56077: IFFALSE 56085
56079: LD_INT 9
56081: DOUBLE
56082: LESSEQUAL
56083: IFTRUE 56087
56085: GO 56147
56087: POP
// begin bc_type := b_lab_half ;
56088: LD_ADDR_OWVAR 42
56092: PUSH
56093: LD_INT 7
56095: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56096: LD_ADDR_OWVAR 44
56100: PUSH
56101: LD_INT 10
56103: PUSH
56104: LD_INT 11
56106: PUSH
56107: LD_INT 12
56109: PUSH
56110: LD_INT 15
56112: PUSH
56113: LD_INT 14
56115: PUSH
56116: LD_INT 13
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: LIST
56123: LIST
56124: LIST
56125: LIST
56126: PUSH
56127: LD_VAR 0 2
56131: PUSH
56132: LD_INT 3
56134: MINUS
56135: ARRAY
56136: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
56137: LD_ADDR_OWVAR 45
56141: PUSH
56142: LD_INT 9
56144: ST_TO_ADDR
// end ; 10 .. 13 :
56145: GO 56655
56147: LD_INT 10
56149: DOUBLE
56150: GREATEREQUAL
56151: IFFALSE 56159
56153: LD_INT 13
56155: DOUBLE
56156: LESSEQUAL
56157: IFTRUE 56161
56159: GO 56238
56161: POP
// begin bc_type := b_lab_full ;
56162: LD_ADDR_OWVAR 42
56166: PUSH
56167: LD_INT 8
56169: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56170: LD_ADDR_OWVAR 44
56174: PUSH
56175: LD_INT 10
56177: PUSH
56178: LD_INT 12
56180: PUSH
56181: LD_INT 14
56183: PUSH
56184: LD_INT 13
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: PUSH
56193: LD_VAR 0 2
56197: PUSH
56198: LD_INT 9
56200: MINUS
56201: ARRAY
56202: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56203: LD_ADDR_OWVAR 45
56207: PUSH
56208: LD_INT 11
56210: PUSH
56211: LD_INT 15
56213: PUSH
56214: LD_INT 12
56216: PUSH
56217: LD_INT 15
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: LIST
56224: LIST
56225: PUSH
56226: LD_VAR 0 2
56230: PUSH
56231: LD_INT 9
56233: MINUS
56234: ARRAY
56235: ST_TO_ADDR
// end ; 14 :
56236: GO 56655
56238: LD_INT 14
56240: DOUBLE
56241: EQUAL
56242: IFTRUE 56246
56244: GO 56257
56246: POP
// bc_type := b_workshop ; 15 :
56247: LD_ADDR_OWVAR 42
56251: PUSH
56252: LD_INT 2
56254: ST_TO_ADDR
56255: GO 56655
56257: LD_INT 15
56259: DOUBLE
56260: EQUAL
56261: IFTRUE 56265
56263: GO 56276
56265: POP
// bc_type := b_factory ; 16 :
56266: LD_ADDR_OWVAR 42
56270: PUSH
56271: LD_INT 3
56273: ST_TO_ADDR
56274: GO 56655
56276: LD_INT 16
56278: DOUBLE
56279: EQUAL
56280: IFTRUE 56284
56282: GO 56295
56284: POP
// bc_type := b_ext_gun ; 17 :
56285: LD_ADDR_OWVAR 42
56289: PUSH
56290: LD_INT 17
56292: ST_TO_ADDR
56293: GO 56655
56295: LD_INT 17
56297: DOUBLE
56298: EQUAL
56299: IFTRUE 56303
56301: GO 56331
56303: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56304: LD_ADDR_OWVAR 42
56308: PUSH
56309: LD_INT 19
56311: PUSH
56312: LD_INT 23
56314: PUSH
56315: LD_INT 19
56317: PUSH
56318: EMPTY
56319: LIST
56320: LIST
56321: LIST
56322: PUSH
56323: LD_VAR 0 1
56327: ARRAY
56328: ST_TO_ADDR
56329: GO 56655
56331: LD_INT 18
56333: DOUBLE
56334: EQUAL
56335: IFTRUE 56339
56337: GO 56350
56339: POP
// bc_type := b_ext_radar ; 19 :
56340: LD_ADDR_OWVAR 42
56344: PUSH
56345: LD_INT 20
56347: ST_TO_ADDR
56348: GO 56655
56350: LD_INT 19
56352: DOUBLE
56353: EQUAL
56354: IFTRUE 56358
56356: GO 56369
56358: POP
// bc_type := b_ext_radio ; 20 :
56359: LD_ADDR_OWVAR 42
56363: PUSH
56364: LD_INT 22
56366: ST_TO_ADDR
56367: GO 56655
56369: LD_INT 20
56371: DOUBLE
56372: EQUAL
56373: IFTRUE 56377
56375: GO 56388
56377: POP
// bc_type := b_ext_siberium ; 21 :
56378: LD_ADDR_OWVAR 42
56382: PUSH
56383: LD_INT 21
56385: ST_TO_ADDR
56386: GO 56655
56388: LD_INT 21
56390: DOUBLE
56391: EQUAL
56392: IFTRUE 56396
56394: GO 56407
56396: POP
// bc_type := b_ext_computer ; 22 :
56397: LD_ADDR_OWVAR 42
56401: PUSH
56402: LD_INT 24
56404: ST_TO_ADDR
56405: GO 56655
56407: LD_INT 22
56409: DOUBLE
56410: EQUAL
56411: IFTRUE 56415
56413: GO 56426
56415: POP
// bc_type := b_ext_track ; 23 :
56416: LD_ADDR_OWVAR 42
56420: PUSH
56421: LD_INT 16
56423: ST_TO_ADDR
56424: GO 56655
56426: LD_INT 23
56428: DOUBLE
56429: EQUAL
56430: IFTRUE 56434
56432: GO 56445
56434: POP
// bc_type := b_ext_laser ; 24 :
56435: LD_ADDR_OWVAR 42
56439: PUSH
56440: LD_INT 25
56442: ST_TO_ADDR
56443: GO 56655
56445: LD_INT 24
56447: DOUBLE
56448: EQUAL
56449: IFTRUE 56453
56451: GO 56464
56453: POP
// bc_type := b_control_tower ; 25 :
56454: LD_ADDR_OWVAR 42
56458: PUSH
56459: LD_INT 36
56461: ST_TO_ADDR
56462: GO 56655
56464: LD_INT 25
56466: DOUBLE
56467: EQUAL
56468: IFTRUE 56472
56470: GO 56483
56472: POP
// bc_type := b_breastwork ; 26 :
56473: LD_ADDR_OWVAR 42
56477: PUSH
56478: LD_INT 31
56480: ST_TO_ADDR
56481: GO 56655
56483: LD_INT 26
56485: DOUBLE
56486: EQUAL
56487: IFTRUE 56491
56489: GO 56502
56491: POP
// bc_type := b_bunker ; 27 :
56492: LD_ADDR_OWVAR 42
56496: PUSH
56497: LD_INT 32
56499: ST_TO_ADDR
56500: GO 56655
56502: LD_INT 27
56504: DOUBLE
56505: EQUAL
56506: IFTRUE 56510
56508: GO 56521
56510: POP
// bc_type := b_turret ; 28 :
56511: LD_ADDR_OWVAR 42
56515: PUSH
56516: LD_INT 33
56518: ST_TO_ADDR
56519: GO 56655
56521: LD_INT 28
56523: DOUBLE
56524: EQUAL
56525: IFTRUE 56529
56527: GO 56540
56529: POP
// bc_type := b_armoury ; 29 :
56530: LD_ADDR_OWVAR 42
56534: PUSH
56535: LD_INT 4
56537: ST_TO_ADDR
56538: GO 56655
56540: LD_INT 29
56542: DOUBLE
56543: EQUAL
56544: IFTRUE 56548
56546: GO 56559
56548: POP
// bc_type := b_barracks ; 30 :
56549: LD_ADDR_OWVAR 42
56553: PUSH
56554: LD_INT 5
56556: ST_TO_ADDR
56557: GO 56655
56559: LD_INT 30
56561: DOUBLE
56562: EQUAL
56563: IFTRUE 56567
56565: GO 56578
56567: POP
// bc_type := b_solar_power ; 31 :
56568: LD_ADDR_OWVAR 42
56572: PUSH
56573: LD_INT 27
56575: ST_TO_ADDR
56576: GO 56655
56578: LD_INT 31
56580: DOUBLE
56581: EQUAL
56582: IFTRUE 56586
56584: GO 56597
56586: POP
// bc_type := b_oil_power ; 32 :
56587: LD_ADDR_OWVAR 42
56591: PUSH
56592: LD_INT 26
56594: ST_TO_ADDR
56595: GO 56655
56597: LD_INT 32
56599: DOUBLE
56600: EQUAL
56601: IFTRUE 56605
56603: GO 56616
56605: POP
// bc_type := b_siberite_power ; 33 :
56606: LD_ADDR_OWVAR 42
56610: PUSH
56611: LD_INT 28
56613: ST_TO_ADDR
56614: GO 56655
56616: LD_INT 33
56618: DOUBLE
56619: EQUAL
56620: IFTRUE 56624
56622: GO 56635
56624: POP
// bc_type := b_oil_mine ; 34 :
56625: LD_ADDR_OWVAR 42
56629: PUSH
56630: LD_INT 29
56632: ST_TO_ADDR
56633: GO 56655
56635: LD_INT 34
56637: DOUBLE
56638: EQUAL
56639: IFTRUE 56643
56641: GO 56654
56643: POP
// bc_type := b_siberite_mine ; end ;
56644: LD_ADDR_OWVAR 42
56648: PUSH
56649: LD_INT 30
56651: ST_TO_ADDR
56652: GO 56655
56654: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56655: LD_ADDR_VAR 0 8
56659: PUSH
56660: LD_VAR 0 5
56664: PPUSH
56665: LD_VAR 0 6
56669: PPUSH
56670: LD_VAR 0 3
56674: PPUSH
56675: CALL_OW 47
56679: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56680: LD_OWVAR 42
56684: PUSH
56685: LD_INT 32
56687: PUSH
56688: LD_INT 33
56690: PUSH
56691: EMPTY
56692: LIST
56693: LIST
56694: IN
56695: IFFALSE 56711
// PlaceWeaponTurret ( b , weapon ) ;
56697: LD_VAR 0 8
56701: PPUSH
56702: LD_VAR 0 4
56706: PPUSH
56707: CALL_OW 431
// end ;
56711: LD_VAR 0 7
56715: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56716: LD_INT 0
56718: PPUSH
56719: PPUSH
56720: PPUSH
56721: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56722: LD_ADDR_VAR 0 4
56726: PUSH
56727: LD_INT 22
56729: PUSH
56730: LD_OWVAR 2
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: PUSH
56739: LD_INT 2
56741: PUSH
56742: LD_INT 30
56744: PUSH
56745: LD_INT 0
56747: PUSH
56748: EMPTY
56749: LIST
56750: LIST
56751: PUSH
56752: LD_INT 30
56754: PUSH
56755: LD_INT 1
56757: PUSH
56758: EMPTY
56759: LIST
56760: LIST
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: LIST
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: PPUSH
56771: CALL_OW 69
56775: ST_TO_ADDR
// if not tmp then
56776: LD_VAR 0 4
56780: NOT
56781: IFFALSE 56785
// exit ;
56783: GO 56844
// for i in tmp do
56785: LD_ADDR_VAR 0 2
56789: PUSH
56790: LD_VAR 0 4
56794: PUSH
56795: FOR_IN
56796: IFFALSE 56842
// for j = 1 to 3 do
56798: LD_ADDR_VAR 0 3
56802: PUSH
56803: DOUBLE
56804: LD_INT 1
56806: DEC
56807: ST_TO_ADDR
56808: LD_INT 3
56810: PUSH
56811: FOR_TO
56812: IFFALSE 56838
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56814: LD_VAR 0 2
56818: PPUSH
56819: CALL_OW 274
56823: PPUSH
56824: LD_VAR 0 3
56828: PPUSH
56829: LD_INT 99999
56831: PPUSH
56832: CALL_OW 277
56836: GO 56811
56838: POP
56839: POP
56840: GO 56795
56842: POP
56843: POP
// end ;
56844: LD_VAR 0 1
56848: RET
// export function hHackSetLevel10 ; var i , j ; begin
56849: LD_INT 0
56851: PPUSH
56852: PPUSH
56853: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56854: LD_ADDR_VAR 0 2
56858: PUSH
56859: LD_INT 21
56861: PUSH
56862: LD_INT 1
56864: PUSH
56865: EMPTY
56866: LIST
56867: LIST
56868: PPUSH
56869: CALL_OW 69
56873: PUSH
56874: FOR_IN
56875: IFFALSE 56927
// if IsSelected ( i ) then
56877: LD_VAR 0 2
56881: PPUSH
56882: CALL_OW 306
56886: IFFALSE 56925
// begin for j := 1 to 4 do
56888: LD_ADDR_VAR 0 3
56892: PUSH
56893: DOUBLE
56894: LD_INT 1
56896: DEC
56897: ST_TO_ADDR
56898: LD_INT 4
56900: PUSH
56901: FOR_TO
56902: IFFALSE 56923
// SetSkill ( i , j , 10 ) ;
56904: LD_VAR 0 2
56908: PPUSH
56909: LD_VAR 0 3
56913: PPUSH
56914: LD_INT 10
56916: PPUSH
56917: CALL_OW 237
56921: GO 56901
56923: POP
56924: POP
// end ;
56925: GO 56874
56927: POP
56928: POP
// end ;
56929: LD_VAR 0 1
56933: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56934: LD_INT 0
56936: PPUSH
56937: PPUSH
56938: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56939: LD_ADDR_VAR 0 2
56943: PUSH
56944: LD_INT 22
56946: PUSH
56947: LD_OWVAR 2
56951: PUSH
56952: EMPTY
56953: LIST
56954: LIST
56955: PUSH
56956: LD_INT 21
56958: PUSH
56959: LD_INT 1
56961: PUSH
56962: EMPTY
56963: LIST
56964: LIST
56965: PUSH
56966: EMPTY
56967: LIST
56968: LIST
56969: PPUSH
56970: CALL_OW 69
56974: PUSH
56975: FOR_IN
56976: IFFALSE 57017
// begin for j := 1 to 4 do
56978: LD_ADDR_VAR 0 3
56982: PUSH
56983: DOUBLE
56984: LD_INT 1
56986: DEC
56987: ST_TO_ADDR
56988: LD_INT 4
56990: PUSH
56991: FOR_TO
56992: IFFALSE 57013
// SetSkill ( i , j , 10 ) ;
56994: LD_VAR 0 2
56998: PPUSH
56999: LD_VAR 0 3
57003: PPUSH
57004: LD_INT 10
57006: PPUSH
57007: CALL_OW 237
57011: GO 56991
57013: POP
57014: POP
// end ;
57015: GO 56975
57017: POP
57018: POP
// end ;
57019: LD_VAR 0 1
57023: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57024: LD_INT 0
57026: PPUSH
// uc_side := your_side ;
57027: LD_ADDR_OWVAR 20
57031: PUSH
57032: LD_OWVAR 2
57036: ST_TO_ADDR
// uc_nation := nation ;
57037: LD_ADDR_OWVAR 21
57041: PUSH
57042: LD_VAR 0 1
57046: ST_TO_ADDR
// InitHc ;
57047: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57051: LD_INT 0
57053: PPUSH
57054: LD_VAR 0 2
57058: PPUSH
57059: LD_VAR 0 3
57063: PPUSH
57064: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57068: LD_VAR 0 4
57072: PPUSH
57073: LD_VAR 0 5
57077: PPUSH
57078: CALL_OW 428
57082: PUSH
57083: LD_INT 0
57085: EQUAL
57086: IFFALSE 57110
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57088: CALL_OW 44
57092: PPUSH
57093: LD_VAR 0 4
57097: PPUSH
57098: LD_VAR 0 5
57102: PPUSH
57103: LD_INT 1
57105: PPUSH
57106: CALL_OW 48
// end ;
57110: LD_VAR 0 6
57114: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57115: LD_INT 0
57117: PPUSH
57118: PPUSH
// uc_side := your_side ;
57119: LD_ADDR_OWVAR 20
57123: PUSH
57124: LD_OWVAR 2
57128: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57129: LD_VAR 0 1
57133: PUSH
57134: LD_INT 1
57136: PUSH
57137: LD_INT 2
57139: PUSH
57140: LD_INT 3
57142: PUSH
57143: LD_INT 4
57145: PUSH
57146: LD_INT 5
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: LIST
57153: LIST
57154: LIST
57155: IN
57156: IFFALSE 57168
// uc_nation := nation_american else
57158: LD_ADDR_OWVAR 21
57162: PUSH
57163: LD_INT 1
57165: ST_TO_ADDR
57166: GO 57211
// if chassis in [ 11 , 12 , 13 , 14 ] then
57168: LD_VAR 0 1
57172: PUSH
57173: LD_INT 11
57175: PUSH
57176: LD_INT 12
57178: PUSH
57179: LD_INT 13
57181: PUSH
57182: LD_INT 14
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: LIST
57189: LIST
57190: IN
57191: IFFALSE 57203
// uc_nation := nation_arabian else
57193: LD_ADDR_OWVAR 21
57197: PUSH
57198: LD_INT 2
57200: ST_TO_ADDR
57201: GO 57211
// uc_nation := nation_russian ;
57203: LD_ADDR_OWVAR 21
57207: PUSH
57208: LD_INT 3
57210: ST_TO_ADDR
// vc_chassis := chassis ;
57211: LD_ADDR_OWVAR 37
57215: PUSH
57216: LD_VAR 0 1
57220: ST_TO_ADDR
// vc_engine := engine ;
57221: LD_ADDR_OWVAR 39
57225: PUSH
57226: LD_VAR 0 2
57230: ST_TO_ADDR
// vc_control := control ;
57231: LD_ADDR_OWVAR 38
57235: PUSH
57236: LD_VAR 0 3
57240: ST_TO_ADDR
// vc_weapon := weapon ;
57241: LD_ADDR_OWVAR 40
57245: PUSH
57246: LD_VAR 0 4
57250: ST_TO_ADDR
// un := CreateVehicle ;
57251: LD_ADDR_VAR 0 8
57255: PUSH
57256: CALL_OW 45
57260: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57261: LD_VAR 0 8
57265: PPUSH
57266: LD_INT 0
57268: PPUSH
57269: LD_INT 5
57271: PPUSH
57272: CALL_OW 12
57276: PPUSH
57277: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57281: LD_VAR 0 8
57285: PPUSH
57286: LD_VAR 0 5
57290: PPUSH
57291: LD_VAR 0 6
57295: PPUSH
57296: LD_INT 1
57298: PPUSH
57299: CALL_OW 48
// end ;
57303: LD_VAR 0 7
57307: RET
// export hInvincible ; every 1 do
57308: GO 57310
57310: DISABLE
// hInvincible := [ ] ;
57311: LD_ADDR_EXP 131
57315: PUSH
57316: EMPTY
57317: ST_TO_ADDR
57318: END
// every 10 do var i ;
57319: GO 57321
57321: DISABLE
57322: LD_INT 0
57324: PPUSH
// begin enable ;
57325: ENABLE
// if not hInvincible then
57326: LD_EXP 131
57330: NOT
57331: IFFALSE 57335
// exit ;
57333: GO 57379
// for i in hInvincible do
57335: LD_ADDR_VAR 0 1
57339: PUSH
57340: LD_EXP 131
57344: PUSH
57345: FOR_IN
57346: IFFALSE 57377
// if GetLives ( i ) < 1000 then
57348: LD_VAR 0 1
57352: PPUSH
57353: CALL_OW 256
57357: PUSH
57358: LD_INT 1000
57360: LESS
57361: IFFALSE 57375
// SetLives ( i , 1000 ) ;
57363: LD_VAR 0 1
57367: PPUSH
57368: LD_INT 1000
57370: PPUSH
57371: CALL_OW 234
57375: GO 57345
57377: POP
57378: POP
// end ;
57379: PPOPN 1
57381: END
// export function hHackInvincible ; var i ; begin
57382: LD_INT 0
57384: PPUSH
57385: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57386: LD_ADDR_VAR 0 2
57390: PUSH
57391: LD_INT 2
57393: PUSH
57394: LD_INT 21
57396: PUSH
57397: LD_INT 1
57399: PUSH
57400: EMPTY
57401: LIST
57402: LIST
57403: PUSH
57404: LD_INT 21
57406: PUSH
57407: LD_INT 2
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: LIST
57418: PPUSH
57419: CALL_OW 69
57423: PUSH
57424: FOR_IN
57425: IFFALSE 57486
// if IsSelected ( i ) then
57427: LD_VAR 0 2
57431: PPUSH
57432: CALL_OW 306
57436: IFFALSE 57484
// begin if i in hInvincible then
57438: LD_VAR 0 2
57442: PUSH
57443: LD_EXP 131
57447: IN
57448: IFFALSE 57468
// hInvincible := hInvincible diff i else
57450: LD_ADDR_EXP 131
57454: PUSH
57455: LD_EXP 131
57459: PUSH
57460: LD_VAR 0 2
57464: DIFF
57465: ST_TO_ADDR
57466: GO 57484
// hInvincible := hInvincible union i ;
57468: LD_ADDR_EXP 131
57472: PUSH
57473: LD_EXP 131
57477: PUSH
57478: LD_VAR 0 2
57482: UNION
57483: ST_TO_ADDR
// end ;
57484: GO 57424
57486: POP
57487: POP
// end ;
57488: LD_VAR 0 1
57492: RET
// export function hHackInvisible ; var i , j ; begin
57493: LD_INT 0
57495: PPUSH
57496: PPUSH
57497: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57498: LD_ADDR_VAR 0 2
57502: PUSH
57503: LD_INT 21
57505: PUSH
57506: LD_INT 1
57508: PUSH
57509: EMPTY
57510: LIST
57511: LIST
57512: PPUSH
57513: CALL_OW 69
57517: PUSH
57518: FOR_IN
57519: IFFALSE 57543
// if IsSelected ( i ) then
57521: LD_VAR 0 2
57525: PPUSH
57526: CALL_OW 306
57530: IFFALSE 57541
// ComForceInvisible ( i ) ;
57532: LD_VAR 0 2
57536: PPUSH
57537: CALL_OW 496
57541: GO 57518
57543: POP
57544: POP
// end ;
57545: LD_VAR 0 1
57549: RET
// export function hHackChangeYourSide ; begin
57550: LD_INT 0
57552: PPUSH
// if your_side = 8 then
57553: LD_OWVAR 2
57557: PUSH
57558: LD_INT 8
57560: EQUAL
57561: IFFALSE 57573
// your_side := 0 else
57563: LD_ADDR_OWVAR 2
57567: PUSH
57568: LD_INT 0
57570: ST_TO_ADDR
57571: GO 57587
// your_side := your_side + 1 ;
57573: LD_ADDR_OWVAR 2
57577: PUSH
57578: LD_OWVAR 2
57582: PUSH
57583: LD_INT 1
57585: PLUS
57586: ST_TO_ADDR
// end ;
57587: LD_VAR 0 1
57591: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57592: LD_INT 0
57594: PPUSH
57595: PPUSH
57596: PPUSH
// for i in all_units do
57597: LD_ADDR_VAR 0 2
57601: PUSH
57602: LD_OWVAR 3
57606: PUSH
57607: FOR_IN
57608: IFFALSE 57686
// if IsSelected ( i ) then
57610: LD_VAR 0 2
57614: PPUSH
57615: CALL_OW 306
57619: IFFALSE 57684
// begin j := GetSide ( i ) ;
57621: LD_ADDR_VAR 0 3
57625: PUSH
57626: LD_VAR 0 2
57630: PPUSH
57631: CALL_OW 255
57635: ST_TO_ADDR
// if j = 8 then
57636: LD_VAR 0 3
57640: PUSH
57641: LD_INT 8
57643: EQUAL
57644: IFFALSE 57656
// j := 0 else
57646: LD_ADDR_VAR 0 3
57650: PUSH
57651: LD_INT 0
57653: ST_TO_ADDR
57654: GO 57670
// j := j + 1 ;
57656: LD_ADDR_VAR 0 3
57660: PUSH
57661: LD_VAR 0 3
57665: PUSH
57666: LD_INT 1
57668: PLUS
57669: ST_TO_ADDR
// SetSide ( i , j ) ;
57670: LD_VAR 0 2
57674: PPUSH
57675: LD_VAR 0 3
57679: PPUSH
57680: CALL_OW 235
// end ;
57684: GO 57607
57686: POP
57687: POP
// end ;
57688: LD_VAR 0 1
57692: RET
// export function hHackFog ; begin
57693: LD_INT 0
57695: PPUSH
// FogOff ( true ) ;
57696: LD_INT 1
57698: PPUSH
57699: CALL_OW 344
// end ;
57703: LD_VAR 0 1
57707: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57708: LD_INT 0
57710: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57711: LD_VAR 0 1
57715: PPUSH
57716: LD_VAR 0 2
57720: PPUSH
57721: LD_VAR 0 3
57725: PPUSH
57726: LD_INT 1
57728: PPUSH
57729: LD_INT 1
57731: PPUSH
57732: CALL_OW 483
// CenterOnXY ( x , y ) ;
57736: LD_VAR 0 2
57740: PPUSH
57741: LD_VAR 0 3
57745: PPUSH
57746: CALL_OW 84
// end ;
57750: LD_VAR 0 4
57754: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57755: LD_INT 0
57757: PPUSH
57758: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57759: LD_VAR 0 1
57763: NOT
57764: PUSH
57765: LD_VAR 0 2
57769: PPUSH
57770: LD_VAR 0 3
57774: PPUSH
57775: CALL_OW 488
57779: NOT
57780: OR
57781: PUSH
57782: LD_VAR 0 1
57786: PPUSH
57787: CALL_OW 266
57791: PUSH
57792: LD_INT 3
57794: NONEQUAL
57795: PUSH
57796: LD_VAR 0 1
57800: PPUSH
57801: CALL_OW 247
57805: PUSH
57806: LD_INT 1
57808: EQUAL
57809: NOT
57810: AND
57811: OR
57812: IFFALSE 57816
// exit ;
57814: GO 57965
// if GetType ( factory ) = unit_human then
57816: LD_VAR 0 1
57820: PPUSH
57821: CALL_OW 247
57825: PUSH
57826: LD_INT 1
57828: EQUAL
57829: IFFALSE 57846
// factory := IsInUnit ( factory ) ;
57831: LD_ADDR_VAR 0 1
57835: PUSH
57836: LD_VAR 0 1
57840: PPUSH
57841: CALL_OW 310
57845: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57846: LD_VAR 0 1
57850: PPUSH
57851: CALL_OW 266
57855: PUSH
57856: LD_INT 3
57858: NONEQUAL
57859: IFFALSE 57863
// exit ;
57861: GO 57965
// if HexInfo ( x , y ) = factory then
57863: LD_VAR 0 2
57867: PPUSH
57868: LD_VAR 0 3
57872: PPUSH
57873: CALL_OW 428
57877: PUSH
57878: LD_VAR 0 1
57882: EQUAL
57883: IFFALSE 57910
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57885: LD_ADDR_EXP 132
57889: PUSH
57890: LD_EXP 132
57894: PPUSH
57895: LD_VAR 0 1
57899: PPUSH
57900: LD_INT 0
57902: PPUSH
57903: CALL_OW 1
57907: ST_TO_ADDR
57908: GO 57961
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57910: LD_ADDR_EXP 132
57914: PUSH
57915: LD_EXP 132
57919: PPUSH
57920: LD_VAR 0 1
57924: PPUSH
57925: LD_VAR 0 1
57929: PPUSH
57930: CALL_OW 255
57934: PUSH
57935: LD_VAR 0 1
57939: PUSH
57940: LD_VAR 0 2
57944: PUSH
57945: LD_VAR 0 3
57949: PUSH
57950: EMPTY
57951: LIST
57952: LIST
57953: LIST
57954: LIST
57955: PPUSH
57956: CALL_OW 1
57960: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57961: CALL 57970 0 0
// end ;
57965: LD_VAR 0 4
57969: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57970: LD_INT 0
57972: PPUSH
57973: PPUSH
57974: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57975: LD_STRING resetFactoryWaypoint();
57977: PPUSH
57978: CALL_OW 559
// if factoryWaypoints then
57982: LD_EXP 132
57986: IFFALSE 58112
// begin list := PrepareArray ( factoryWaypoints ) ;
57988: LD_ADDR_VAR 0 3
57992: PUSH
57993: LD_EXP 132
57997: PPUSH
57998: CALL 105254 0 1
58002: ST_TO_ADDR
// for i := 1 to list do
58003: LD_ADDR_VAR 0 2
58007: PUSH
58008: DOUBLE
58009: LD_INT 1
58011: DEC
58012: ST_TO_ADDR
58013: LD_VAR 0 3
58017: PUSH
58018: FOR_TO
58019: IFFALSE 58110
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58021: LD_STRING setFactoryWaypointXY(
58023: PUSH
58024: LD_VAR 0 3
58028: PUSH
58029: LD_VAR 0 2
58033: ARRAY
58034: PUSH
58035: LD_INT 1
58037: ARRAY
58038: STR
58039: PUSH
58040: LD_STRING ,
58042: STR
58043: PUSH
58044: LD_VAR 0 3
58048: PUSH
58049: LD_VAR 0 2
58053: ARRAY
58054: PUSH
58055: LD_INT 2
58057: ARRAY
58058: STR
58059: PUSH
58060: LD_STRING ,
58062: STR
58063: PUSH
58064: LD_VAR 0 3
58068: PUSH
58069: LD_VAR 0 2
58073: ARRAY
58074: PUSH
58075: LD_INT 3
58077: ARRAY
58078: STR
58079: PUSH
58080: LD_STRING ,
58082: STR
58083: PUSH
58084: LD_VAR 0 3
58088: PUSH
58089: LD_VAR 0 2
58093: ARRAY
58094: PUSH
58095: LD_INT 4
58097: ARRAY
58098: STR
58099: PUSH
58100: LD_STRING )
58102: STR
58103: PPUSH
58104: CALL_OW 559
58108: GO 58018
58110: POP
58111: POP
// end ; end ;
58112: LD_VAR 0 1
58116: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
58117: LD_INT 0
58119: PPUSH
// if HexInfo ( x , y ) = warehouse then
58120: LD_VAR 0 2
58124: PPUSH
58125: LD_VAR 0 3
58129: PPUSH
58130: CALL_OW 428
58134: PUSH
58135: LD_VAR 0 1
58139: EQUAL
58140: IFFALSE 58167
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58142: LD_ADDR_EXP 133
58146: PUSH
58147: LD_EXP 133
58151: PPUSH
58152: LD_VAR 0 1
58156: PPUSH
58157: LD_INT 0
58159: PPUSH
58160: CALL_OW 1
58164: ST_TO_ADDR
58165: GO 58218
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58167: LD_ADDR_EXP 133
58171: PUSH
58172: LD_EXP 133
58176: PPUSH
58177: LD_VAR 0 1
58181: PPUSH
58182: LD_VAR 0 1
58186: PPUSH
58187: CALL_OW 255
58191: PUSH
58192: LD_VAR 0 1
58196: PUSH
58197: LD_VAR 0 2
58201: PUSH
58202: LD_VAR 0 3
58206: PUSH
58207: EMPTY
58208: LIST
58209: LIST
58210: LIST
58211: LIST
58212: PPUSH
58213: CALL_OW 1
58217: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58218: CALL 58227 0 0
// end ;
58222: LD_VAR 0 4
58226: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58227: LD_INT 0
58229: PPUSH
58230: PPUSH
58231: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58232: LD_STRING resetWarehouseGatheringPoints();
58234: PPUSH
58235: CALL_OW 559
// if warehouseGatheringPoints then
58239: LD_EXP 133
58243: IFFALSE 58369
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58245: LD_ADDR_VAR 0 3
58249: PUSH
58250: LD_EXP 133
58254: PPUSH
58255: CALL 105254 0 1
58259: ST_TO_ADDR
// for i := 1 to list do
58260: LD_ADDR_VAR 0 2
58264: PUSH
58265: DOUBLE
58266: LD_INT 1
58268: DEC
58269: ST_TO_ADDR
58270: LD_VAR 0 3
58274: PUSH
58275: FOR_TO
58276: IFFALSE 58367
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58278: LD_STRING setWarehouseGatheringPointXY(
58280: PUSH
58281: LD_VAR 0 3
58285: PUSH
58286: LD_VAR 0 2
58290: ARRAY
58291: PUSH
58292: LD_INT 1
58294: ARRAY
58295: STR
58296: PUSH
58297: LD_STRING ,
58299: STR
58300: PUSH
58301: LD_VAR 0 3
58305: PUSH
58306: LD_VAR 0 2
58310: ARRAY
58311: PUSH
58312: LD_INT 2
58314: ARRAY
58315: STR
58316: PUSH
58317: LD_STRING ,
58319: STR
58320: PUSH
58321: LD_VAR 0 3
58325: PUSH
58326: LD_VAR 0 2
58330: ARRAY
58331: PUSH
58332: LD_INT 3
58334: ARRAY
58335: STR
58336: PUSH
58337: LD_STRING ,
58339: STR
58340: PUSH
58341: LD_VAR 0 3
58345: PUSH
58346: LD_VAR 0 2
58350: ARRAY
58351: PUSH
58352: LD_INT 4
58354: ARRAY
58355: STR
58356: PUSH
58357: LD_STRING )
58359: STR
58360: PPUSH
58361: CALL_OW 559
58365: GO 58275
58367: POP
58368: POP
// end ; end ;
58369: LD_VAR 0 1
58373: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58374: LD_EXP 133
58378: IFFALSE 59063
58380: GO 58382
58382: DISABLE
58383: LD_INT 0
58385: PPUSH
58386: PPUSH
58387: PPUSH
58388: PPUSH
58389: PPUSH
58390: PPUSH
58391: PPUSH
58392: PPUSH
58393: PPUSH
// begin enable ;
58394: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58395: LD_ADDR_VAR 0 3
58399: PUSH
58400: LD_EXP 133
58404: PPUSH
58405: CALL 105254 0 1
58409: ST_TO_ADDR
// if not list then
58410: LD_VAR 0 3
58414: NOT
58415: IFFALSE 58419
// exit ;
58417: GO 59063
// for i := 1 to list do
58419: LD_ADDR_VAR 0 1
58423: PUSH
58424: DOUBLE
58425: LD_INT 1
58427: DEC
58428: ST_TO_ADDR
58429: LD_VAR 0 3
58433: PUSH
58434: FOR_TO
58435: IFFALSE 59061
// begin depot := list [ i ] [ 2 ] ;
58437: LD_ADDR_VAR 0 8
58441: PUSH
58442: LD_VAR 0 3
58446: PUSH
58447: LD_VAR 0 1
58451: ARRAY
58452: PUSH
58453: LD_INT 2
58455: ARRAY
58456: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58457: LD_ADDR_VAR 0 5
58461: PUSH
58462: LD_VAR 0 3
58466: PUSH
58467: LD_VAR 0 1
58471: ARRAY
58472: PUSH
58473: LD_INT 1
58475: ARRAY
58476: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58477: LD_VAR 0 8
58481: PPUSH
58482: CALL_OW 301
58486: PUSH
58487: LD_VAR 0 5
58491: PUSH
58492: LD_VAR 0 8
58496: PPUSH
58497: CALL_OW 255
58501: NONEQUAL
58502: OR
58503: IFFALSE 58532
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58505: LD_ADDR_EXP 133
58509: PUSH
58510: LD_EXP 133
58514: PPUSH
58515: LD_VAR 0 8
58519: PPUSH
58520: LD_INT 0
58522: PPUSH
58523: CALL_OW 1
58527: ST_TO_ADDR
// exit ;
58528: POP
58529: POP
58530: GO 59063
// end ; x := list [ i ] [ 3 ] ;
58532: LD_ADDR_VAR 0 6
58536: PUSH
58537: LD_VAR 0 3
58541: PUSH
58542: LD_VAR 0 1
58546: ARRAY
58547: PUSH
58548: LD_INT 3
58550: ARRAY
58551: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58552: LD_ADDR_VAR 0 7
58556: PUSH
58557: LD_VAR 0 3
58561: PUSH
58562: LD_VAR 0 1
58566: ARRAY
58567: PUSH
58568: LD_INT 4
58570: ARRAY
58571: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58572: LD_ADDR_VAR 0 9
58576: PUSH
58577: LD_VAR 0 6
58581: PPUSH
58582: LD_VAR 0 7
58586: PPUSH
58587: LD_INT 16
58589: PPUSH
58590: CALL 103842 0 3
58594: ST_TO_ADDR
// if not cratesNearbyPoint then
58595: LD_VAR 0 9
58599: NOT
58600: IFFALSE 58606
// exit ;
58602: POP
58603: POP
58604: GO 59063
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58606: LD_ADDR_VAR 0 4
58610: PUSH
58611: LD_INT 22
58613: PUSH
58614: LD_VAR 0 5
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PUSH
58623: LD_INT 3
58625: PUSH
58626: LD_INT 60
58628: PUSH
58629: EMPTY
58630: LIST
58631: PUSH
58632: EMPTY
58633: LIST
58634: LIST
58635: PUSH
58636: LD_INT 91
58638: PUSH
58639: LD_VAR 0 8
58643: PUSH
58644: LD_INT 6
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: LIST
58651: PUSH
58652: LD_INT 2
58654: PUSH
58655: LD_INT 25
58657: PUSH
58658: LD_INT 2
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: PUSH
58665: LD_INT 25
58667: PUSH
58668: LD_INT 16
58670: PUSH
58671: EMPTY
58672: LIST
58673: LIST
58674: PUSH
58675: EMPTY
58676: LIST
58677: LIST
58678: LIST
58679: PUSH
58680: EMPTY
58681: LIST
58682: LIST
58683: LIST
58684: LIST
58685: PPUSH
58686: CALL_OW 69
58690: PUSH
58691: LD_VAR 0 8
58695: PPUSH
58696: CALL_OW 313
58700: PPUSH
58701: LD_INT 3
58703: PUSH
58704: LD_INT 60
58706: PUSH
58707: EMPTY
58708: LIST
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: PUSH
58714: LD_INT 2
58716: PUSH
58717: LD_INT 25
58719: PUSH
58720: LD_INT 2
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: PUSH
58727: LD_INT 25
58729: PUSH
58730: LD_INT 16
58732: PUSH
58733: EMPTY
58734: LIST
58735: LIST
58736: PUSH
58737: EMPTY
58738: LIST
58739: LIST
58740: LIST
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: PPUSH
58746: CALL_OW 72
58750: UNION
58751: ST_TO_ADDR
// if tmp then
58752: LD_VAR 0 4
58756: IFFALSE 58836
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58758: LD_ADDR_VAR 0 4
58762: PUSH
58763: LD_VAR 0 4
58767: PPUSH
58768: LD_INT 3
58770: PPUSH
58771: CALL 101811 0 2
58775: ST_TO_ADDR
// for j in tmp do
58776: LD_ADDR_VAR 0 2
58780: PUSH
58781: LD_VAR 0 4
58785: PUSH
58786: FOR_IN
58787: IFFALSE 58830
// begin if IsInUnit ( j ) then
58789: LD_VAR 0 2
58793: PPUSH
58794: CALL_OW 310
58798: IFFALSE 58809
// ComExit ( j ) ;
58800: LD_VAR 0 2
58804: PPUSH
58805: CALL 101894 0 1
// AddComCollect ( j , x , y ) ;
58809: LD_VAR 0 2
58813: PPUSH
58814: LD_VAR 0 6
58818: PPUSH
58819: LD_VAR 0 7
58823: PPUSH
58824: CALL_OW 177
// end ;
58828: GO 58786
58830: POP
58831: POP
// exit ;
58832: POP
58833: POP
58834: GO 59063
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58836: LD_ADDR_VAR 0 4
58840: PUSH
58841: LD_INT 22
58843: PUSH
58844: LD_VAR 0 5
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: PUSH
58853: LD_INT 91
58855: PUSH
58856: LD_VAR 0 8
58860: PUSH
58861: LD_INT 8
58863: PUSH
58864: EMPTY
58865: LIST
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 2
58871: PUSH
58872: LD_INT 34
58874: PUSH
58875: LD_INT 12
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: PUSH
58882: LD_INT 34
58884: PUSH
58885: LD_INT 51
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: PUSH
58892: LD_INT 34
58894: PUSH
58895: LD_INT 32
58897: PUSH
58898: EMPTY
58899: LIST
58900: LIST
58901: PUSH
58902: LD_INT 34
58904: PUSH
58905: LD_INT 89
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: PUSH
58912: EMPTY
58913: LIST
58914: LIST
58915: LIST
58916: LIST
58917: LIST
58918: PUSH
58919: EMPTY
58920: LIST
58921: LIST
58922: LIST
58923: PPUSH
58924: CALL_OW 69
58928: ST_TO_ADDR
// if tmp then
58929: LD_VAR 0 4
58933: IFFALSE 59059
// begin for j in tmp do
58935: LD_ADDR_VAR 0 2
58939: PUSH
58940: LD_VAR 0 4
58944: PUSH
58945: FOR_IN
58946: IFFALSE 59057
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58948: LD_VAR 0 2
58952: PPUSH
58953: CALL_OW 262
58957: PUSH
58958: LD_INT 3
58960: EQUAL
58961: PUSH
58962: LD_VAR 0 2
58966: PPUSH
58967: CALL_OW 261
58971: PUSH
58972: LD_INT 20
58974: GREATER
58975: OR
58976: PUSH
58977: LD_VAR 0 2
58981: PPUSH
58982: CALL_OW 314
58986: NOT
58987: AND
58988: PUSH
58989: LD_VAR 0 2
58993: PPUSH
58994: CALL_OW 263
58998: PUSH
58999: LD_INT 1
59001: NONEQUAL
59002: PUSH
59003: LD_VAR 0 2
59007: PPUSH
59008: CALL_OW 311
59012: OR
59013: AND
59014: IFFALSE 59055
// begin ComCollect ( j , x , y ) ;
59016: LD_VAR 0 2
59020: PPUSH
59021: LD_VAR 0 6
59025: PPUSH
59026: LD_VAR 0 7
59030: PPUSH
59031: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
59035: LD_VAR 0 2
59039: PPUSH
59040: LD_VAR 0 8
59044: PPUSH
59045: CALL_OW 172
// exit ;
59049: POP
59050: POP
59051: POP
59052: POP
59053: GO 59063
// end ;
59055: GO 58945
59057: POP
59058: POP
// end ; end ;
59059: GO 58434
59061: POP
59062: POP
// end ; end_of_file
59063: PPOPN 9
59065: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59066: LD_INT 0
59068: PPUSH
59069: PPUSH
59070: PPUSH
59071: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59072: LD_VAR 0 1
59076: PPUSH
59077: CALL_OW 264
59081: PUSH
59082: LD_INT 91
59084: EQUAL
59085: IFFALSE 59157
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59087: LD_INT 68
59089: PPUSH
59090: LD_VAR 0 1
59094: PPUSH
59095: CALL_OW 255
59099: PPUSH
59100: CALL_OW 321
59104: PUSH
59105: LD_INT 2
59107: EQUAL
59108: IFFALSE 59120
// eff := 70 else
59110: LD_ADDR_VAR 0 4
59114: PUSH
59115: LD_INT 70
59117: ST_TO_ADDR
59118: GO 59128
// eff := 30 ;
59120: LD_ADDR_VAR 0 4
59124: PUSH
59125: LD_INT 30
59127: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59128: LD_VAR 0 1
59132: PPUSH
59133: CALL_OW 250
59137: PPUSH
59138: LD_VAR 0 1
59142: PPUSH
59143: CALL_OW 251
59147: PPUSH
59148: LD_VAR 0 4
59152: PPUSH
59153: CALL_OW 495
// end ; end ;
59157: LD_VAR 0 2
59161: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59162: LD_INT 0
59164: PPUSH
// end ;
59165: LD_VAR 0 4
59169: RET
// export function SOS_Command ( cmd ) ; begin
59170: LD_INT 0
59172: PPUSH
// end ;
59173: LD_VAR 0 2
59177: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59178: LD_INT 0
59180: PPUSH
// end ;
59181: LD_VAR 0 6
59185: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59186: LD_INT 0
59188: PPUSH
59189: PPUSH
// if not vehicle or not factory then
59190: LD_VAR 0 1
59194: NOT
59195: PUSH
59196: LD_VAR 0 2
59200: NOT
59201: OR
59202: IFFALSE 59206
// exit ;
59204: GO 59437
// if factoryWaypoints >= factory then
59206: LD_EXP 132
59210: PUSH
59211: LD_VAR 0 2
59215: GREATEREQUAL
59216: IFFALSE 59437
// if factoryWaypoints [ factory ] then
59218: LD_EXP 132
59222: PUSH
59223: LD_VAR 0 2
59227: ARRAY
59228: IFFALSE 59437
// begin if GetControl ( vehicle ) = control_manual then
59230: LD_VAR 0 1
59234: PPUSH
59235: CALL_OW 263
59239: PUSH
59240: LD_INT 1
59242: EQUAL
59243: IFFALSE 59324
// begin driver := IsDrivenBy ( vehicle ) ;
59245: LD_ADDR_VAR 0 4
59249: PUSH
59250: LD_VAR 0 1
59254: PPUSH
59255: CALL_OW 311
59259: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59260: LD_VAR 0 4
59264: PPUSH
59265: LD_EXP 132
59269: PUSH
59270: LD_VAR 0 2
59274: ARRAY
59275: PUSH
59276: LD_INT 3
59278: ARRAY
59279: PPUSH
59280: LD_EXP 132
59284: PUSH
59285: LD_VAR 0 2
59289: ARRAY
59290: PUSH
59291: LD_INT 4
59293: ARRAY
59294: PPUSH
59295: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59299: LD_VAR 0 4
59303: PPUSH
59304: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59308: LD_VAR 0 4
59312: PPUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: CALL_OW 180
// end else
59322: GO 59437
// if GetControl ( vehicle ) = control_remote then
59324: LD_VAR 0 1
59328: PPUSH
59329: CALL_OW 263
59333: PUSH
59334: LD_INT 2
59336: EQUAL
59337: IFFALSE 59398
// begin wait ( 0 0$2 ) ;
59339: LD_INT 70
59341: PPUSH
59342: CALL_OW 67
// if Connect ( vehicle ) then
59346: LD_VAR 0 1
59350: PPUSH
59351: CALL 72102 0 1
59355: IFFALSE 59396
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59357: LD_VAR 0 1
59361: PPUSH
59362: LD_EXP 132
59366: PUSH
59367: LD_VAR 0 2
59371: ARRAY
59372: PUSH
59373: LD_INT 3
59375: ARRAY
59376: PPUSH
59377: LD_EXP 132
59381: PUSH
59382: LD_VAR 0 2
59386: ARRAY
59387: PUSH
59388: LD_INT 4
59390: ARRAY
59391: PPUSH
59392: CALL_OW 171
// end else
59396: GO 59437
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59398: LD_VAR 0 1
59402: PPUSH
59403: LD_EXP 132
59407: PUSH
59408: LD_VAR 0 2
59412: ARRAY
59413: PUSH
59414: LD_INT 3
59416: ARRAY
59417: PPUSH
59418: LD_EXP 132
59422: PUSH
59423: LD_VAR 0 2
59427: ARRAY
59428: PUSH
59429: LD_INT 4
59431: ARRAY
59432: PPUSH
59433: CALL_OW 171
// end ; end ;
59437: LD_VAR 0 3
59441: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59442: LD_INT 0
59444: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59445: LD_VAR 0 1
59449: PUSH
59450: LD_INT 250
59452: EQUAL
59453: PUSH
59454: LD_VAR 0 2
59458: PPUSH
59459: CALL_OW 264
59463: PUSH
59464: LD_INT 81
59466: EQUAL
59467: AND
59468: IFFALSE 59489
// MinerPlaceMine ( unit , x , y ) ;
59470: LD_VAR 0 2
59474: PPUSH
59475: LD_VAR 0 4
59479: PPUSH
59480: LD_VAR 0 5
59484: PPUSH
59485: CALL 62313 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59489: LD_VAR 0 1
59493: PUSH
59494: LD_INT 251
59496: EQUAL
59497: PUSH
59498: LD_VAR 0 2
59502: PPUSH
59503: CALL_OW 264
59507: PUSH
59508: LD_INT 81
59510: EQUAL
59511: AND
59512: IFFALSE 59533
// MinerDetonateMine ( unit , x , y ) ;
59514: LD_VAR 0 2
59518: PPUSH
59519: LD_VAR 0 4
59523: PPUSH
59524: LD_VAR 0 5
59528: PPUSH
59529: CALL 62588 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59533: LD_VAR 0 1
59537: PUSH
59538: LD_INT 252
59540: EQUAL
59541: PUSH
59542: LD_VAR 0 2
59546: PPUSH
59547: CALL_OW 264
59551: PUSH
59552: LD_INT 81
59554: EQUAL
59555: AND
59556: IFFALSE 59577
// MinerCreateMinefield ( unit , x , y ) ;
59558: LD_VAR 0 2
59562: PPUSH
59563: LD_VAR 0 4
59567: PPUSH
59568: LD_VAR 0 5
59572: PPUSH
59573: CALL 63005 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59577: LD_VAR 0 1
59581: PUSH
59582: LD_INT 253
59584: EQUAL
59585: PUSH
59586: LD_VAR 0 2
59590: PPUSH
59591: CALL_OW 257
59595: PUSH
59596: LD_INT 5
59598: EQUAL
59599: AND
59600: IFFALSE 59621
// ComBinocular ( unit , x , y ) ;
59602: LD_VAR 0 2
59606: PPUSH
59607: LD_VAR 0 4
59611: PPUSH
59612: LD_VAR 0 5
59616: PPUSH
59617: CALL 63374 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59621: LD_VAR 0 1
59625: PUSH
59626: LD_INT 254
59628: EQUAL
59629: PUSH
59630: LD_VAR 0 2
59634: PPUSH
59635: CALL_OW 264
59639: PUSH
59640: LD_INT 99
59642: EQUAL
59643: AND
59644: PUSH
59645: LD_VAR 0 3
59649: PPUSH
59650: CALL_OW 263
59654: PUSH
59655: LD_INT 3
59657: EQUAL
59658: AND
59659: IFFALSE 59675
// HackDestroyVehicle ( unit , selectedUnit ) ;
59661: LD_VAR 0 2
59665: PPUSH
59666: LD_VAR 0 3
59670: PPUSH
59671: CALL 61677 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59675: LD_VAR 0 1
59679: PUSH
59680: LD_INT 255
59682: EQUAL
59683: PUSH
59684: LD_VAR 0 2
59688: PPUSH
59689: CALL_OW 264
59693: PUSH
59694: LD_INT 14
59696: PUSH
59697: LD_INT 53
59699: PUSH
59700: EMPTY
59701: LIST
59702: LIST
59703: IN
59704: AND
59705: PUSH
59706: LD_VAR 0 4
59710: PPUSH
59711: LD_VAR 0 5
59715: PPUSH
59716: CALL_OW 488
59720: AND
59721: IFFALSE 59745
// CutTreeXYR ( unit , x , y , 12 ) ;
59723: LD_VAR 0 2
59727: PPUSH
59728: LD_VAR 0 4
59732: PPUSH
59733: LD_VAR 0 5
59737: PPUSH
59738: LD_INT 12
59740: PPUSH
59741: CALL 59840 0 4
// if cmd = 256 then
59745: LD_VAR 0 1
59749: PUSH
59750: LD_INT 256
59752: EQUAL
59753: IFFALSE 59774
// SetFactoryWaypoint ( unit , x , y ) ;
59755: LD_VAR 0 2
59759: PPUSH
59760: LD_VAR 0 4
59764: PPUSH
59765: LD_VAR 0 5
59769: PPUSH
59770: CALL 57755 0 3
// if cmd = 257 then
59774: LD_VAR 0 1
59778: PUSH
59779: LD_INT 257
59781: EQUAL
59782: IFFALSE 59803
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59784: LD_VAR 0 2
59788: PPUSH
59789: LD_VAR 0 4
59793: PPUSH
59794: LD_VAR 0 5
59798: PPUSH
59799: CALL 58117 0 3
// if cmd = 258 then
59803: LD_VAR 0 1
59807: PUSH
59808: LD_INT 258
59810: EQUAL
59811: IFFALSE 59835
// BurnTreeXYR ( unit , x , y , 8 ) ;
59813: LD_VAR 0 2
59817: PPUSH
59818: LD_VAR 0 4
59822: PPUSH
59823: LD_VAR 0 5
59827: PPUSH
59828: LD_INT 8
59830: PPUSH
59831: CALL 60234 0 4
// end ;
59835: LD_VAR 0 6
59839: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59840: LD_INT 0
59842: PPUSH
59843: PPUSH
59844: PPUSH
59845: PPUSH
59846: PPUSH
59847: PPUSH
59848: PPUSH
59849: PPUSH
59850: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
59851: LD_VAR 0 1
59855: PPUSH
59856: CALL_OW 302
59860: NOT
59861: PUSH
59862: LD_VAR 0 2
59866: PPUSH
59867: LD_VAR 0 3
59871: PPUSH
59872: CALL_OW 488
59876: NOT
59877: OR
59878: PUSH
59879: LD_VAR 0 4
59883: NOT
59884: OR
59885: IFFALSE 59889
// exit ;
59887: GO 60229
// list := [ ] ;
59889: LD_ADDR_VAR 0 13
59893: PUSH
59894: EMPTY
59895: ST_TO_ADDR
// if x - r < 0 then
59896: LD_VAR 0 2
59900: PUSH
59901: LD_VAR 0 4
59905: MINUS
59906: PUSH
59907: LD_INT 0
59909: LESS
59910: IFFALSE 59922
// min_x := 0 else
59912: LD_ADDR_VAR 0 7
59916: PUSH
59917: LD_INT 0
59919: ST_TO_ADDR
59920: GO 59938
// min_x := x - r ;
59922: LD_ADDR_VAR 0 7
59926: PUSH
59927: LD_VAR 0 2
59931: PUSH
59932: LD_VAR 0 4
59936: MINUS
59937: ST_TO_ADDR
// if y - r < 0 then
59938: LD_VAR 0 3
59942: PUSH
59943: LD_VAR 0 4
59947: MINUS
59948: PUSH
59949: LD_INT 0
59951: LESS
59952: IFFALSE 59964
// min_y := 0 else
59954: LD_ADDR_VAR 0 8
59958: PUSH
59959: LD_INT 0
59961: ST_TO_ADDR
59962: GO 59980
// min_y := y - r ;
59964: LD_ADDR_VAR 0 8
59968: PUSH
59969: LD_VAR 0 3
59973: PUSH
59974: LD_VAR 0 4
59978: MINUS
59979: ST_TO_ADDR
// max_x := x + r ;
59980: LD_ADDR_VAR 0 9
59984: PUSH
59985: LD_VAR 0 2
59989: PUSH
59990: LD_VAR 0 4
59994: PLUS
59995: ST_TO_ADDR
// max_y := y + r ;
59996: LD_ADDR_VAR 0 10
60000: PUSH
60001: LD_VAR 0 3
60005: PUSH
60006: LD_VAR 0 4
60010: PLUS
60011: ST_TO_ADDR
// for _x = min_x to max_x do
60012: LD_ADDR_VAR 0 11
60016: PUSH
60017: DOUBLE
60018: LD_VAR 0 7
60022: DEC
60023: ST_TO_ADDR
60024: LD_VAR 0 9
60028: PUSH
60029: FOR_TO
60030: IFFALSE 60147
// for _y = min_y to max_y do
60032: LD_ADDR_VAR 0 12
60036: PUSH
60037: DOUBLE
60038: LD_VAR 0 8
60042: DEC
60043: ST_TO_ADDR
60044: LD_VAR 0 10
60048: PUSH
60049: FOR_TO
60050: IFFALSE 60143
// begin if not ValidHex ( _x , _y ) then
60052: LD_VAR 0 11
60056: PPUSH
60057: LD_VAR 0 12
60061: PPUSH
60062: CALL_OW 488
60066: NOT
60067: IFFALSE 60071
// continue ;
60069: GO 60049
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60071: LD_VAR 0 11
60075: PPUSH
60076: LD_VAR 0 12
60080: PPUSH
60081: CALL_OW 351
60085: PUSH
60086: LD_VAR 0 11
60090: PPUSH
60091: LD_VAR 0 12
60095: PPUSH
60096: CALL_OW 554
60100: AND
60101: IFFALSE 60141
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60103: LD_ADDR_VAR 0 13
60107: PUSH
60108: LD_VAR 0 13
60112: PPUSH
60113: LD_VAR 0 13
60117: PUSH
60118: LD_INT 1
60120: PLUS
60121: PPUSH
60122: LD_VAR 0 11
60126: PUSH
60127: LD_VAR 0 12
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PPUSH
60136: CALL_OW 2
60140: ST_TO_ADDR
// end ;
60141: GO 60049
60143: POP
60144: POP
60145: GO 60029
60147: POP
60148: POP
// if not list then
60149: LD_VAR 0 13
60153: NOT
60154: IFFALSE 60158
// exit ;
60156: GO 60229
// for i in list do
60158: LD_ADDR_VAR 0 6
60162: PUSH
60163: LD_VAR 0 13
60167: PUSH
60168: FOR_IN
60169: IFFALSE 60227
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60171: LD_VAR 0 1
60175: PPUSH
60176: LD_STRING M
60178: PUSH
60179: LD_VAR 0 6
60183: PUSH
60184: LD_INT 1
60186: ARRAY
60187: PUSH
60188: LD_VAR 0 6
60192: PUSH
60193: LD_INT 2
60195: ARRAY
60196: PUSH
60197: LD_INT 0
60199: PUSH
60200: LD_INT 0
60202: PUSH
60203: LD_INT 0
60205: PUSH
60206: LD_INT 0
60208: PUSH
60209: EMPTY
60210: LIST
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: LIST
60216: LIST
60217: PUSH
60218: EMPTY
60219: LIST
60220: PPUSH
60221: CALL_OW 447
60225: GO 60168
60227: POP
60228: POP
// end ;
60229: LD_VAR 0 5
60233: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
60234: LD_INT 0
60236: PPUSH
60237: PPUSH
60238: PPUSH
60239: PPUSH
60240: PPUSH
60241: PPUSH
60242: PPUSH
60243: PPUSH
60244: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
60245: LD_VAR 0 1
60249: PPUSH
60250: CALL_OW 302
60254: NOT
60255: PUSH
60256: LD_VAR 0 2
60260: PPUSH
60261: LD_VAR 0 3
60265: PPUSH
60266: CALL_OW 488
60270: NOT
60271: OR
60272: PUSH
60273: LD_VAR 0 4
60277: NOT
60278: OR
60279: IFFALSE 60283
// exit ;
60281: GO 60631
// list := [ ] ;
60283: LD_ADDR_VAR 0 13
60287: PUSH
60288: EMPTY
60289: ST_TO_ADDR
// if x - r < 0 then
60290: LD_VAR 0 2
60294: PUSH
60295: LD_VAR 0 4
60299: MINUS
60300: PUSH
60301: LD_INT 0
60303: LESS
60304: IFFALSE 60316
// min_x := 0 else
60306: LD_ADDR_VAR 0 7
60310: PUSH
60311: LD_INT 0
60313: ST_TO_ADDR
60314: GO 60332
// min_x := x - r ;
60316: LD_ADDR_VAR 0 7
60320: PUSH
60321: LD_VAR 0 2
60325: PUSH
60326: LD_VAR 0 4
60330: MINUS
60331: ST_TO_ADDR
// if y - r < 0 then
60332: LD_VAR 0 3
60336: PUSH
60337: LD_VAR 0 4
60341: MINUS
60342: PUSH
60343: LD_INT 0
60345: LESS
60346: IFFALSE 60358
// min_y := 0 else
60348: LD_ADDR_VAR 0 8
60352: PUSH
60353: LD_INT 0
60355: ST_TO_ADDR
60356: GO 60374
// min_y := y - r ;
60358: LD_ADDR_VAR 0 8
60362: PUSH
60363: LD_VAR 0 3
60367: PUSH
60368: LD_VAR 0 4
60372: MINUS
60373: ST_TO_ADDR
// max_x := x + r ;
60374: LD_ADDR_VAR 0 9
60378: PUSH
60379: LD_VAR 0 2
60383: PUSH
60384: LD_VAR 0 4
60388: PLUS
60389: ST_TO_ADDR
// max_y := y + r ;
60390: LD_ADDR_VAR 0 10
60394: PUSH
60395: LD_VAR 0 3
60399: PUSH
60400: LD_VAR 0 4
60404: PLUS
60405: ST_TO_ADDR
// for _x = min_x to max_x do
60406: LD_ADDR_VAR 0 11
60410: PUSH
60411: DOUBLE
60412: LD_VAR 0 7
60416: DEC
60417: ST_TO_ADDR
60418: LD_VAR 0 9
60422: PUSH
60423: FOR_TO
60424: IFFALSE 60541
// for _y = min_y to max_y do
60426: LD_ADDR_VAR 0 12
60430: PUSH
60431: DOUBLE
60432: LD_VAR 0 8
60436: DEC
60437: ST_TO_ADDR
60438: LD_VAR 0 10
60442: PUSH
60443: FOR_TO
60444: IFFALSE 60537
// begin if not ValidHex ( _x , _y ) then
60446: LD_VAR 0 11
60450: PPUSH
60451: LD_VAR 0 12
60455: PPUSH
60456: CALL_OW 488
60460: NOT
60461: IFFALSE 60465
// continue ;
60463: GO 60443
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60465: LD_VAR 0 11
60469: PPUSH
60470: LD_VAR 0 12
60474: PPUSH
60475: CALL_OW 351
60479: PUSH
60480: LD_VAR 0 11
60484: PPUSH
60485: LD_VAR 0 12
60489: PPUSH
60490: CALL_OW 554
60494: AND
60495: IFFALSE 60535
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60497: LD_ADDR_VAR 0 13
60501: PUSH
60502: LD_VAR 0 13
60506: PPUSH
60507: LD_VAR 0 13
60511: PUSH
60512: LD_INT 1
60514: PLUS
60515: PPUSH
60516: LD_VAR 0 11
60520: PUSH
60521: LD_VAR 0 12
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: PPUSH
60530: CALL_OW 2
60534: ST_TO_ADDR
// end ;
60535: GO 60443
60537: POP
60538: POP
60539: GO 60423
60541: POP
60542: POP
// if not list then
60543: LD_VAR 0 13
60547: NOT
60548: IFFALSE 60552
// exit ;
60550: GO 60631
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
60552: LD_ADDR_VAR 0 13
60556: PUSH
60557: LD_VAR 0 1
60561: PPUSH
60562: LD_VAR 0 13
60566: PPUSH
60567: LD_INT 1
60569: PPUSH
60570: LD_INT 1
60572: PPUSH
60573: CALL 69244 0 4
60577: ST_TO_ADDR
// ComStop ( flame ) ;
60578: LD_VAR 0 1
60582: PPUSH
60583: CALL_OW 141
// for i in list do
60587: LD_ADDR_VAR 0 6
60591: PUSH
60592: LD_VAR 0 13
60596: PUSH
60597: FOR_IN
60598: IFFALSE 60629
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
60600: LD_VAR 0 1
60604: PPUSH
60605: LD_VAR 0 6
60609: PUSH
60610: LD_INT 1
60612: ARRAY
60613: PPUSH
60614: LD_VAR 0 6
60618: PUSH
60619: LD_INT 2
60621: ARRAY
60622: PPUSH
60623: CALL_OW 176
60627: GO 60597
60629: POP
60630: POP
// end ;
60631: LD_VAR 0 5
60635: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60636: LD_EXP 135
60640: NOT
60641: IFFALSE 60691
60643: GO 60645
60645: DISABLE
// begin initHack := true ;
60646: LD_ADDR_EXP 135
60650: PUSH
60651: LD_INT 1
60653: ST_TO_ADDR
// hackTanks := [ ] ;
60654: LD_ADDR_EXP 136
60658: PUSH
60659: EMPTY
60660: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60661: LD_ADDR_EXP 137
60665: PUSH
60666: EMPTY
60667: ST_TO_ADDR
// hackLimit := 3 ;
60668: LD_ADDR_EXP 138
60672: PUSH
60673: LD_INT 3
60675: ST_TO_ADDR
// hackDist := 12 ;
60676: LD_ADDR_EXP 139
60680: PUSH
60681: LD_INT 12
60683: ST_TO_ADDR
// hackCounter := [ ] ;
60684: LD_ADDR_EXP 140
60688: PUSH
60689: EMPTY
60690: ST_TO_ADDR
// end ;
60691: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60692: LD_EXP 135
60696: PUSH
60697: LD_INT 34
60699: PUSH
60700: LD_INT 99
60702: PUSH
60703: EMPTY
60704: LIST
60705: LIST
60706: PPUSH
60707: CALL_OW 69
60711: AND
60712: IFFALSE 60965
60714: GO 60716
60716: DISABLE
60717: LD_INT 0
60719: PPUSH
60720: PPUSH
// begin enable ;
60721: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60722: LD_ADDR_VAR 0 1
60726: PUSH
60727: LD_INT 34
60729: PUSH
60730: LD_INT 99
60732: PUSH
60733: EMPTY
60734: LIST
60735: LIST
60736: PPUSH
60737: CALL_OW 69
60741: PUSH
60742: FOR_IN
60743: IFFALSE 60963
// begin if not i in hackTanks then
60745: LD_VAR 0 1
60749: PUSH
60750: LD_EXP 136
60754: IN
60755: NOT
60756: IFFALSE 60839
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60758: LD_ADDR_EXP 136
60762: PUSH
60763: LD_EXP 136
60767: PPUSH
60768: LD_EXP 136
60772: PUSH
60773: LD_INT 1
60775: PLUS
60776: PPUSH
60777: LD_VAR 0 1
60781: PPUSH
60782: CALL_OW 1
60786: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60787: LD_ADDR_EXP 137
60791: PUSH
60792: LD_EXP 137
60796: PPUSH
60797: LD_EXP 137
60801: PUSH
60802: LD_INT 1
60804: PLUS
60805: PPUSH
60806: EMPTY
60807: PPUSH
60808: CALL_OW 1
60812: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60813: LD_ADDR_EXP 140
60817: PUSH
60818: LD_EXP 140
60822: PPUSH
60823: LD_EXP 140
60827: PUSH
60828: LD_INT 1
60830: PLUS
60831: PPUSH
60832: EMPTY
60833: PPUSH
60834: CALL_OW 1
60838: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60839: LD_VAR 0 1
60843: PPUSH
60844: CALL_OW 302
60848: NOT
60849: IFFALSE 60862
// begin HackUnlinkAll ( i ) ;
60851: LD_VAR 0 1
60855: PPUSH
60856: CALL 60968 0 1
// continue ;
60860: GO 60742
// end ; HackCheckCapturedStatus ( i ) ;
60862: LD_VAR 0 1
60866: PPUSH
60867: CALL 61411 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60871: LD_ADDR_VAR 0 2
60875: PUSH
60876: LD_INT 81
60878: PUSH
60879: LD_VAR 0 1
60883: PPUSH
60884: CALL_OW 255
60888: PUSH
60889: EMPTY
60890: LIST
60891: LIST
60892: PUSH
60893: LD_INT 33
60895: PUSH
60896: LD_INT 3
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PUSH
60903: LD_INT 91
60905: PUSH
60906: LD_VAR 0 1
60910: PUSH
60911: LD_EXP 139
60915: PUSH
60916: EMPTY
60917: LIST
60918: LIST
60919: LIST
60920: PUSH
60921: LD_INT 50
60923: PUSH
60924: EMPTY
60925: LIST
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: LIST
60931: LIST
60932: PPUSH
60933: CALL_OW 69
60937: ST_TO_ADDR
// if not tmp then
60938: LD_VAR 0 2
60942: NOT
60943: IFFALSE 60947
// continue ;
60945: GO 60742
// HackLink ( i , tmp ) ;
60947: LD_VAR 0 1
60951: PPUSH
60952: LD_VAR 0 2
60956: PPUSH
60957: CALL 61104 0 2
// end ;
60961: GO 60742
60963: POP
60964: POP
// end ;
60965: PPOPN 2
60967: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60968: LD_INT 0
60970: PPUSH
60971: PPUSH
60972: PPUSH
// if not hack in hackTanks then
60973: LD_VAR 0 1
60977: PUSH
60978: LD_EXP 136
60982: IN
60983: NOT
60984: IFFALSE 60988
// exit ;
60986: GO 61099
// index := GetElementIndex ( hackTanks , hack ) ;
60988: LD_ADDR_VAR 0 4
60992: PUSH
60993: LD_EXP 136
60997: PPUSH
60998: LD_VAR 0 1
61002: PPUSH
61003: CALL 68541 0 2
61007: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
61008: LD_EXP 137
61012: PUSH
61013: LD_VAR 0 4
61017: ARRAY
61018: IFFALSE 61099
// begin for i in hackTanksCaptured [ index ] do
61020: LD_ADDR_VAR 0 3
61024: PUSH
61025: LD_EXP 137
61029: PUSH
61030: LD_VAR 0 4
61034: ARRAY
61035: PUSH
61036: FOR_IN
61037: IFFALSE 61063
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
61039: LD_VAR 0 3
61043: PUSH
61044: LD_INT 1
61046: ARRAY
61047: PPUSH
61048: LD_VAR 0 3
61052: PUSH
61053: LD_INT 2
61055: ARRAY
61056: PPUSH
61057: CALL_OW 235
61061: GO 61036
61063: POP
61064: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
61065: LD_ADDR_EXP 137
61069: PUSH
61070: LD_EXP 137
61074: PPUSH
61075: LD_VAR 0 4
61079: PPUSH
61080: EMPTY
61081: PPUSH
61082: CALL_OW 1
61086: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
61087: LD_VAR 0 1
61091: PPUSH
61092: LD_INT 0
61094: PPUSH
61095: CALL_OW 505
// end ; end ;
61099: LD_VAR 0 2
61103: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
61104: LD_INT 0
61106: PPUSH
61107: PPUSH
61108: PPUSH
// if not hack in hackTanks or not vehicles then
61109: LD_VAR 0 1
61113: PUSH
61114: LD_EXP 136
61118: IN
61119: NOT
61120: PUSH
61121: LD_VAR 0 2
61125: NOT
61126: OR
61127: IFFALSE 61131
// exit ;
61129: GO 61406
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
61131: LD_ADDR_VAR 0 2
61135: PUSH
61136: LD_VAR 0 1
61140: PPUSH
61141: LD_VAR 0 2
61145: PPUSH
61146: LD_INT 1
61148: PPUSH
61149: LD_INT 1
61151: PPUSH
61152: CALL 69191 0 4
61156: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
61157: LD_ADDR_VAR 0 5
61161: PUSH
61162: LD_EXP 136
61166: PPUSH
61167: LD_VAR 0 1
61171: PPUSH
61172: CALL 68541 0 2
61176: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
61177: LD_EXP 137
61181: PUSH
61182: LD_VAR 0 5
61186: ARRAY
61187: PUSH
61188: LD_EXP 138
61192: LESS
61193: IFFALSE 61382
// begin for i := 1 to vehicles do
61195: LD_ADDR_VAR 0 4
61199: PUSH
61200: DOUBLE
61201: LD_INT 1
61203: DEC
61204: ST_TO_ADDR
61205: LD_VAR 0 2
61209: PUSH
61210: FOR_TO
61211: IFFALSE 61380
// begin if hackTanksCaptured [ index ] = hackLimit then
61213: LD_EXP 137
61217: PUSH
61218: LD_VAR 0 5
61222: ARRAY
61223: PUSH
61224: LD_EXP 138
61228: EQUAL
61229: IFFALSE 61233
// break ;
61231: GO 61380
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
61233: LD_ADDR_EXP 140
61237: PUSH
61238: LD_EXP 140
61242: PPUSH
61243: LD_VAR 0 5
61247: PPUSH
61248: LD_EXP 140
61252: PUSH
61253: LD_VAR 0 5
61257: ARRAY
61258: PUSH
61259: LD_INT 1
61261: PLUS
61262: PPUSH
61263: CALL_OW 1
61267: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
61268: LD_ADDR_EXP 137
61272: PUSH
61273: LD_EXP 137
61277: PPUSH
61278: LD_VAR 0 5
61282: PUSH
61283: LD_EXP 137
61287: PUSH
61288: LD_VAR 0 5
61292: ARRAY
61293: PUSH
61294: LD_INT 1
61296: PLUS
61297: PUSH
61298: EMPTY
61299: LIST
61300: LIST
61301: PPUSH
61302: LD_VAR 0 2
61306: PUSH
61307: LD_VAR 0 4
61311: ARRAY
61312: PUSH
61313: LD_VAR 0 2
61317: PUSH
61318: LD_VAR 0 4
61322: ARRAY
61323: PPUSH
61324: CALL_OW 255
61328: PUSH
61329: EMPTY
61330: LIST
61331: LIST
61332: PPUSH
61333: CALL 68756 0 3
61337: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
61338: LD_VAR 0 2
61342: PUSH
61343: LD_VAR 0 4
61347: ARRAY
61348: PPUSH
61349: LD_VAR 0 1
61353: PPUSH
61354: CALL_OW 255
61358: PPUSH
61359: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
61363: LD_VAR 0 2
61367: PUSH
61368: LD_VAR 0 4
61372: ARRAY
61373: PPUSH
61374: CALL_OW 141
// end ;
61378: GO 61210
61380: POP
61381: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61382: LD_VAR 0 1
61386: PPUSH
61387: LD_EXP 137
61391: PUSH
61392: LD_VAR 0 5
61396: ARRAY
61397: PUSH
61398: LD_INT 0
61400: PLUS
61401: PPUSH
61402: CALL_OW 505
// end ;
61406: LD_VAR 0 3
61410: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
61411: LD_INT 0
61413: PPUSH
61414: PPUSH
61415: PPUSH
61416: PPUSH
// if not hack in hackTanks then
61417: LD_VAR 0 1
61421: PUSH
61422: LD_EXP 136
61426: IN
61427: NOT
61428: IFFALSE 61432
// exit ;
61430: GO 61672
// index := GetElementIndex ( hackTanks , hack ) ;
61432: LD_ADDR_VAR 0 4
61436: PUSH
61437: LD_EXP 136
61441: PPUSH
61442: LD_VAR 0 1
61446: PPUSH
61447: CALL 68541 0 2
61451: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61452: LD_ADDR_VAR 0 3
61456: PUSH
61457: DOUBLE
61458: LD_EXP 137
61462: PUSH
61463: LD_VAR 0 4
61467: ARRAY
61468: INC
61469: ST_TO_ADDR
61470: LD_INT 1
61472: PUSH
61473: FOR_DOWNTO
61474: IFFALSE 61646
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61476: LD_ADDR_VAR 0 5
61480: PUSH
61481: LD_EXP 137
61485: PUSH
61486: LD_VAR 0 4
61490: ARRAY
61491: PUSH
61492: LD_VAR 0 3
61496: ARRAY
61497: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61498: LD_VAR 0 5
61502: PUSH
61503: LD_INT 1
61505: ARRAY
61506: PPUSH
61507: CALL_OW 302
61511: NOT
61512: PUSH
61513: LD_VAR 0 5
61517: PUSH
61518: LD_INT 1
61520: ARRAY
61521: PPUSH
61522: CALL_OW 255
61526: PUSH
61527: LD_VAR 0 1
61531: PPUSH
61532: CALL_OW 255
61536: NONEQUAL
61537: OR
61538: IFFALSE 61644
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61540: LD_VAR 0 5
61544: PUSH
61545: LD_INT 1
61547: ARRAY
61548: PPUSH
61549: CALL_OW 305
61553: PUSH
61554: LD_VAR 0 5
61558: PUSH
61559: LD_INT 1
61561: ARRAY
61562: PPUSH
61563: CALL_OW 255
61567: PUSH
61568: LD_VAR 0 1
61572: PPUSH
61573: CALL_OW 255
61577: EQUAL
61578: AND
61579: IFFALSE 61603
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61581: LD_VAR 0 5
61585: PUSH
61586: LD_INT 1
61588: ARRAY
61589: PPUSH
61590: LD_VAR 0 5
61594: PUSH
61595: LD_INT 2
61597: ARRAY
61598: PPUSH
61599: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61603: LD_ADDR_EXP 137
61607: PUSH
61608: LD_EXP 137
61612: PPUSH
61613: LD_VAR 0 4
61617: PPUSH
61618: LD_EXP 137
61622: PUSH
61623: LD_VAR 0 4
61627: ARRAY
61628: PPUSH
61629: LD_VAR 0 3
61633: PPUSH
61634: CALL_OW 3
61638: PPUSH
61639: CALL_OW 1
61643: ST_TO_ADDR
// end ; end ;
61644: GO 61473
61646: POP
61647: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61648: LD_VAR 0 1
61652: PPUSH
61653: LD_EXP 137
61657: PUSH
61658: LD_VAR 0 4
61662: ARRAY
61663: PUSH
61664: LD_INT 0
61666: PLUS
61667: PPUSH
61668: CALL_OW 505
// end ;
61672: LD_VAR 0 2
61676: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61677: LD_INT 0
61679: PPUSH
61680: PPUSH
61681: PPUSH
61682: PPUSH
// if not hack in hackTanks then
61683: LD_VAR 0 1
61687: PUSH
61688: LD_EXP 136
61692: IN
61693: NOT
61694: IFFALSE 61698
// exit ;
61696: GO 61783
// index := GetElementIndex ( hackTanks , hack ) ;
61698: LD_ADDR_VAR 0 5
61702: PUSH
61703: LD_EXP 136
61707: PPUSH
61708: LD_VAR 0 1
61712: PPUSH
61713: CALL 68541 0 2
61717: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61718: LD_ADDR_VAR 0 4
61722: PUSH
61723: DOUBLE
61724: LD_INT 1
61726: DEC
61727: ST_TO_ADDR
61728: LD_EXP 137
61732: PUSH
61733: LD_VAR 0 5
61737: ARRAY
61738: PUSH
61739: FOR_TO
61740: IFFALSE 61781
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61742: LD_EXP 137
61746: PUSH
61747: LD_VAR 0 5
61751: ARRAY
61752: PUSH
61753: LD_VAR 0 4
61757: ARRAY
61758: PUSH
61759: LD_INT 1
61761: ARRAY
61762: PUSH
61763: LD_VAR 0 2
61767: EQUAL
61768: IFFALSE 61779
// KillUnit ( vehicle ) ;
61770: LD_VAR 0 2
61774: PPUSH
61775: CALL_OW 66
61779: GO 61739
61781: POP
61782: POP
// end ;
61783: LD_VAR 0 3
61787: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61788: LD_EXP 141
61792: NOT
61793: IFFALSE 61828
61795: GO 61797
61797: DISABLE
// begin initMiner := true ;
61798: LD_ADDR_EXP 141
61802: PUSH
61803: LD_INT 1
61805: ST_TO_ADDR
// minersList := [ ] ;
61806: LD_ADDR_EXP 142
61810: PUSH
61811: EMPTY
61812: ST_TO_ADDR
// minerMinesList := [ ] ;
61813: LD_ADDR_EXP 143
61817: PUSH
61818: EMPTY
61819: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61820: LD_ADDR_EXP 144
61824: PUSH
61825: LD_INT 5
61827: ST_TO_ADDR
// end ;
61828: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61829: LD_EXP 141
61833: PUSH
61834: LD_INT 34
61836: PUSH
61837: LD_INT 81
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PPUSH
61844: CALL_OW 69
61848: AND
61849: IFFALSE 62310
61851: GO 61853
61853: DISABLE
61854: LD_INT 0
61856: PPUSH
61857: PPUSH
61858: PPUSH
61859: PPUSH
// begin enable ;
61860: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61861: LD_ADDR_VAR 0 1
61865: PUSH
61866: LD_INT 34
61868: PUSH
61869: LD_INT 81
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: PPUSH
61876: CALL_OW 69
61880: PUSH
61881: FOR_IN
61882: IFFALSE 61954
// begin if not i in minersList then
61884: LD_VAR 0 1
61888: PUSH
61889: LD_EXP 142
61893: IN
61894: NOT
61895: IFFALSE 61952
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61897: LD_ADDR_EXP 142
61901: PUSH
61902: LD_EXP 142
61906: PPUSH
61907: LD_EXP 142
61911: PUSH
61912: LD_INT 1
61914: PLUS
61915: PPUSH
61916: LD_VAR 0 1
61920: PPUSH
61921: CALL_OW 1
61925: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61926: LD_ADDR_EXP 143
61930: PUSH
61931: LD_EXP 143
61935: PPUSH
61936: LD_EXP 143
61940: PUSH
61941: LD_INT 1
61943: PLUS
61944: PPUSH
61945: EMPTY
61946: PPUSH
61947: CALL_OW 1
61951: ST_TO_ADDR
// end end ;
61952: GO 61881
61954: POP
61955: POP
// for i := minerMinesList downto 1 do
61956: LD_ADDR_VAR 0 1
61960: PUSH
61961: DOUBLE
61962: LD_EXP 143
61966: INC
61967: ST_TO_ADDR
61968: LD_INT 1
61970: PUSH
61971: FOR_DOWNTO
61972: IFFALSE 62308
// begin if IsLive ( minersList [ i ] ) then
61974: LD_EXP 142
61978: PUSH
61979: LD_VAR 0 1
61983: ARRAY
61984: PPUSH
61985: CALL_OW 300
61989: IFFALSE 62017
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61991: LD_EXP 142
61995: PUSH
61996: LD_VAR 0 1
62000: ARRAY
62001: PPUSH
62002: LD_EXP 143
62006: PUSH
62007: LD_VAR 0 1
62011: ARRAY
62012: PPUSH
62013: CALL_OW 505
// if not minerMinesList [ i ] then
62017: LD_EXP 143
62021: PUSH
62022: LD_VAR 0 1
62026: ARRAY
62027: NOT
62028: IFFALSE 62032
// continue ;
62030: GO 61971
// for j := minerMinesList [ i ] downto 1 do
62032: LD_ADDR_VAR 0 2
62036: PUSH
62037: DOUBLE
62038: LD_EXP 143
62042: PUSH
62043: LD_VAR 0 1
62047: ARRAY
62048: INC
62049: ST_TO_ADDR
62050: LD_INT 1
62052: PUSH
62053: FOR_DOWNTO
62054: IFFALSE 62304
// begin side := GetSide ( minersList [ i ] ) ;
62056: LD_ADDR_VAR 0 3
62060: PUSH
62061: LD_EXP 142
62065: PUSH
62066: LD_VAR 0 1
62070: ARRAY
62071: PPUSH
62072: CALL_OW 255
62076: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
62077: LD_ADDR_VAR 0 4
62081: PUSH
62082: LD_EXP 143
62086: PUSH
62087: LD_VAR 0 1
62091: ARRAY
62092: PUSH
62093: LD_VAR 0 2
62097: ARRAY
62098: PUSH
62099: LD_INT 1
62101: ARRAY
62102: PPUSH
62103: LD_EXP 143
62107: PUSH
62108: LD_VAR 0 1
62112: ARRAY
62113: PUSH
62114: LD_VAR 0 2
62118: ARRAY
62119: PUSH
62120: LD_INT 2
62122: ARRAY
62123: PPUSH
62124: CALL_OW 428
62128: ST_TO_ADDR
// if not tmp then
62129: LD_VAR 0 4
62133: NOT
62134: IFFALSE 62138
// continue ;
62136: GO 62053
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
62138: LD_VAR 0 4
62142: PUSH
62143: LD_INT 81
62145: PUSH
62146: LD_VAR 0 3
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PPUSH
62155: CALL_OW 69
62159: IN
62160: PUSH
62161: LD_EXP 143
62165: PUSH
62166: LD_VAR 0 1
62170: ARRAY
62171: PUSH
62172: LD_VAR 0 2
62176: ARRAY
62177: PUSH
62178: LD_INT 1
62180: ARRAY
62181: PPUSH
62182: LD_EXP 143
62186: PUSH
62187: LD_VAR 0 1
62191: ARRAY
62192: PUSH
62193: LD_VAR 0 2
62197: ARRAY
62198: PUSH
62199: LD_INT 2
62201: ARRAY
62202: PPUSH
62203: CALL_OW 458
62207: AND
62208: IFFALSE 62302
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
62210: LD_EXP 143
62214: PUSH
62215: LD_VAR 0 1
62219: ARRAY
62220: PUSH
62221: LD_VAR 0 2
62225: ARRAY
62226: PUSH
62227: LD_INT 1
62229: ARRAY
62230: PPUSH
62231: LD_EXP 143
62235: PUSH
62236: LD_VAR 0 1
62240: ARRAY
62241: PUSH
62242: LD_VAR 0 2
62246: ARRAY
62247: PUSH
62248: LD_INT 2
62250: ARRAY
62251: PPUSH
62252: LD_VAR 0 3
62256: PPUSH
62257: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
62261: LD_ADDR_EXP 143
62265: PUSH
62266: LD_EXP 143
62270: PPUSH
62271: LD_VAR 0 1
62275: PPUSH
62276: LD_EXP 143
62280: PUSH
62281: LD_VAR 0 1
62285: ARRAY
62286: PPUSH
62287: LD_VAR 0 2
62291: PPUSH
62292: CALL_OW 3
62296: PPUSH
62297: CALL_OW 1
62301: ST_TO_ADDR
// end ; end ;
62302: GO 62053
62304: POP
62305: POP
// end ;
62306: GO 61971
62308: POP
62309: POP
// end ;
62310: PPOPN 4
62312: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
62313: LD_INT 0
62315: PPUSH
62316: PPUSH
// result := false ;
62317: LD_ADDR_VAR 0 4
62321: PUSH
62322: LD_INT 0
62324: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
62325: LD_VAR 0 1
62329: PPUSH
62330: CALL_OW 264
62334: PUSH
62335: LD_INT 81
62337: EQUAL
62338: NOT
62339: IFFALSE 62343
// exit ;
62341: GO 62583
// index := GetElementIndex ( minersList , unit ) ;
62343: LD_ADDR_VAR 0 5
62347: PUSH
62348: LD_EXP 142
62352: PPUSH
62353: LD_VAR 0 1
62357: PPUSH
62358: CALL 68541 0 2
62362: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
62363: LD_EXP 143
62367: PUSH
62368: LD_VAR 0 5
62372: ARRAY
62373: PUSH
62374: LD_EXP 144
62378: GREATEREQUAL
62379: IFFALSE 62383
// exit ;
62381: GO 62583
// ComMoveXY ( unit , x , y ) ;
62383: LD_VAR 0 1
62387: PPUSH
62388: LD_VAR 0 2
62392: PPUSH
62393: LD_VAR 0 3
62397: PPUSH
62398: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62402: LD_INT 35
62404: PPUSH
62405: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
62409: LD_VAR 0 1
62413: PPUSH
62414: LD_VAR 0 2
62418: PPUSH
62419: LD_VAR 0 3
62423: PPUSH
62424: CALL 100293 0 3
62428: NOT
62429: PUSH
62430: LD_VAR 0 1
62434: PPUSH
62435: CALL_OW 314
62439: AND
62440: IFFALSE 62444
// exit ;
62442: GO 62583
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
62444: LD_VAR 0 2
62448: PPUSH
62449: LD_VAR 0 3
62453: PPUSH
62454: CALL_OW 428
62458: PUSH
62459: LD_VAR 0 1
62463: EQUAL
62464: PUSH
62465: LD_VAR 0 1
62469: PPUSH
62470: CALL_OW 314
62474: NOT
62475: AND
62476: IFFALSE 62402
// PlaySoundXY ( x , y , PlantMine ) ;
62478: LD_VAR 0 2
62482: PPUSH
62483: LD_VAR 0 3
62487: PPUSH
62488: LD_STRING PlantMine
62490: PPUSH
62491: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62495: LD_VAR 0 2
62499: PPUSH
62500: LD_VAR 0 3
62504: PPUSH
62505: LD_VAR 0 1
62509: PPUSH
62510: CALL_OW 255
62514: PPUSH
62515: LD_INT 0
62517: PPUSH
62518: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62522: LD_ADDR_EXP 143
62526: PUSH
62527: LD_EXP 143
62531: PPUSH
62532: LD_VAR 0 5
62536: PUSH
62537: LD_EXP 143
62541: PUSH
62542: LD_VAR 0 5
62546: ARRAY
62547: PUSH
62548: LD_INT 1
62550: PLUS
62551: PUSH
62552: EMPTY
62553: LIST
62554: LIST
62555: PPUSH
62556: LD_VAR 0 2
62560: PUSH
62561: LD_VAR 0 3
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: PPUSH
62570: CALL 68756 0 3
62574: ST_TO_ADDR
// result := true ;
62575: LD_ADDR_VAR 0 4
62579: PUSH
62580: LD_INT 1
62582: ST_TO_ADDR
// end ;
62583: LD_VAR 0 4
62587: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62588: LD_INT 0
62590: PPUSH
62591: PPUSH
62592: PPUSH
// if not unit in minersList then
62593: LD_VAR 0 1
62597: PUSH
62598: LD_EXP 142
62602: IN
62603: NOT
62604: IFFALSE 62608
// exit ;
62606: GO 63000
// index := GetElementIndex ( minersList , unit ) ;
62608: LD_ADDR_VAR 0 6
62612: PUSH
62613: LD_EXP 142
62617: PPUSH
62618: LD_VAR 0 1
62622: PPUSH
62623: CALL 68541 0 2
62627: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62628: LD_ADDR_VAR 0 5
62632: PUSH
62633: DOUBLE
62634: LD_EXP 143
62638: PUSH
62639: LD_VAR 0 6
62643: ARRAY
62644: INC
62645: ST_TO_ADDR
62646: LD_INT 1
62648: PUSH
62649: FOR_DOWNTO
62650: IFFALSE 62811
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62652: LD_EXP 143
62656: PUSH
62657: LD_VAR 0 6
62661: ARRAY
62662: PUSH
62663: LD_VAR 0 5
62667: ARRAY
62668: PUSH
62669: LD_INT 1
62671: ARRAY
62672: PUSH
62673: LD_VAR 0 2
62677: EQUAL
62678: PUSH
62679: LD_EXP 143
62683: PUSH
62684: LD_VAR 0 6
62688: ARRAY
62689: PUSH
62690: LD_VAR 0 5
62694: ARRAY
62695: PUSH
62696: LD_INT 2
62698: ARRAY
62699: PUSH
62700: LD_VAR 0 3
62704: EQUAL
62705: AND
62706: IFFALSE 62809
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62708: LD_EXP 143
62712: PUSH
62713: LD_VAR 0 6
62717: ARRAY
62718: PUSH
62719: LD_VAR 0 5
62723: ARRAY
62724: PUSH
62725: LD_INT 1
62727: ARRAY
62728: PPUSH
62729: LD_EXP 143
62733: PUSH
62734: LD_VAR 0 6
62738: ARRAY
62739: PUSH
62740: LD_VAR 0 5
62744: ARRAY
62745: PUSH
62746: LD_INT 2
62748: ARRAY
62749: PPUSH
62750: LD_VAR 0 1
62754: PPUSH
62755: CALL_OW 255
62759: PPUSH
62760: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62764: LD_ADDR_EXP 143
62768: PUSH
62769: LD_EXP 143
62773: PPUSH
62774: LD_VAR 0 6
62778: PPUSH
62779: LD_EXP 143
62783: PUSH
62784: LD_VAR 0 6
62788: ARRAY
62789: PPUSH
62790: LD_VAR 0 5
62794: PPUSH
62795: CALL_OW 3
62799: PPUSH
62800: CALL_OW 1
62804: ST_TO_ADDR
// exit ;
62805: POP
62806: POP
62807: GO 63000
// end ; end ;
62809: GO 62649
62811: POP
62812: POP
// for i := minerMinesList [ index ] downto 1 do
62813: LD_ADDR_VAR 0 5
62817: PUSH
62818: DOUBLE
62819: LD_EXP 143
62823: PUSH
62824: LD_VAR 0 6
62828: ARRAY
62829: INC
62830: ST_TO_ADDR
62831: LD_INT 1
62833: PUSH
62834: FOR_DOWNTO
62835: IFFALSE 62998
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62837: LD_EXP 143
62841: PUSH
62842: LD_VAR 0 6
62846: ARRAY
62847: PUSH
62848: LD_VAR 0 5
62852: ARRAY
62853: PUSH
62854: LD_INT 1
62856: ARRAY
62857: PPUSH
62858: LD_EXP 143
62862: PUSH
62863: LD_VAR 0 6
62867: ARRAY
62868: PUSH
62869: LD_VAR 0 5
62873: ARRAY
62874: PUSH
62875: LD_INT 2
62877: ARRAY
62878: PPUSH
62879: LD_VAR 0 2
62883: PPUSH
62884: LD_VAR 0 3
62888: PPUSH
62889: CALL_OW 298
62893: PUSH
62894: LD_INT 6
62896: LESS
62897: IFFALSE 62996
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62899: LD_EXP 143
62903: PUSH
62904: LD_VAR 0 6
62908: ARRAY
62909: PUSH
62910: LD_VAR 0 5
62914: ARRAY
62915: PUSH
62916: LD_INT 1
62918: ARRAY
62919: PPUSH
62920: LD_EXP 143
62924: PUSH
62925: LD_VAR 0 6
62929: ARRAY
62930: PUSH
62931: LD_VAR 0 5
62935: ARRAY
62936: PUSH
62937: LD_INT 2
62939: ARRAY
62940: PPUSH
62941: LD_VAR 0 1
62945: PPUSH
62946: CALL_OW 255
62950: PPUSH
62951: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62955: LD_ADDR_EXP 143
62959: PUSH
62960: LD_EXP 143
62964: PPUSH
62965: LD_VAR 0 6
62969: PPUSH
62970: LD_EXP 143
62974: PUSH
62975: LD_VAR 0 6
62979: ARRAY
62980: PPUSH
62981: LD_VAR 0 5
62985: PPUSH
62986: CALL_OW 3
62990: PPUSH
62991: CALL_OW 1
62995: ST_TO_ADDR
// end ; end ;
62996: GO 62834
62998: POP
62999: POP
// end ;
63000: LD_VAR 0 4
63004: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
63005: LD_INT 0
63007: PPUSH
63008: PPUSH
63009: PPUSH
63010: PPUSH
63011: PPUSH
63012: PPUSH
63013: PPUSH
63014: PPUSH
63015: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
63016: LD_VAR 0 1
63020: PPUSH
63021: CALL_OW 264
63025: PUSH
63026: LD_INT 81
63028: EQUAL
63029: NOT
63030: PUSH
63031: LD_VAR 0 1
63035: PUSH
63036: LD_EXP 142
63040: IN
63041: NOT
63042: OR
63043: IFFALSE 63047
// exit ;
63045: GO 63369
// index := GetElementIndex ( minersList , unit ) ;
63047: LD_ADDR_VAR 0 6
63051: PUSH
63052: LD_EXP 142
63056: PPUSH
63057: LD_VAR 0 1
63061: PPUSH
63062: CALL 68541 0 2
63066: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
63067: LD_ADDR_VAR 0 8
63071: PUSH
63072: LD_EXP 144
63076: PUSH
63077: LD_EXP 143
63081: PUSH
63082: LD_VAR 0 6
63086: ARRAY
63087: MINUS
63088: ST_TO_ADDR
// if not minesFreeAmount then
63089: LD_VAR 0 8
63093: NOT
63094: IFFALSE 63098
// exit ;
63096: GO 63369
// tmp := [ ] ;
63098: LD_ADDR_VAR 0 7
63102: PUSH
63103: EMPTY
63104: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
63105: LD_ADDR_VAR 0 5
63109: PUSH
63110: DOUBLE
63111: LD_INT 1
63113: DEC
63114: ST_TO_ADDR
63115: LD_VAR 0 8
63119: PUSH
63120: FOR_TO
63121: IFFALSE 63316
// begin _d := rand ( 0 , 5 ) ;
63123: LD_ADDR_VAR 0 11
63127: PUSH
63128: LD_INT 0
63130: PPUSH
63131: LD_INT 5
63133: PPUSH
63134: CALL_OW 12
63138: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
63139: LD_ADDR_VAR 0 12
63143: PUSH
63144: LD_INT 2
63146: PPUSH
63147: LD_INT 6
63149: PPUSH
63150: CALL_OW 12
63154: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
63155: LD_ADDR_VAR 0 9
63159: PUSH
63160: LD_VAR 0 2
63164: PPUSH
63165: LD_VAR 0 11
63169: PPUSH
63170: LD_VAR 0 12
63174: PPUSH
63175: CALL_OW 272
63179: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
63180: LD_ADDR_VAR 0 10
63184: PUSH
63185: LD_VAR 0 3
63189: PPUSH
63190: LD_VAR 0 11
63194: PPUSH
63195: LD_VAR 0 12
63199: PPUSH
63200: CALL_OW 273
63204: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
63205: LD_VAR 0 9
63209: PPUSH
63210: LD_VAR 0 10
63214: PPUSH
63215: CALL_OW 488
63219: PUSH
63220: LD_VAR 0 9
63224: PUSH
63225: LD_VAR 0 10
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PUSH
63234: LD_VAR 0 7
63238: IN
63239: NOT
63240: AND
63241: PUSH
63242: LD_VAR 0 9
63246: PPUSH
63247: LD_VAR 0 10
63251: PPUSH
63252: CALL_OW 458
63256: NOT
63257: AND
63258: IFFALSE 63300
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
63260: LD_ADDR_VAR 0 7
63264: PUSH
63265: LD_VAR 0 7
63269: PPUSH
63270: LD_VAR 0 7
63274: PUSH
63275: LD_INT 1
63277: PLUS
63278: PPUSH
63279: LD_VAR 0 9
63283: PUSH
63284: LD_VAR 0 10
63288: PUSH
63289: EMPTY
63290: LIST
63291: LIST
63292: PPUSH
63293: CALL_OW 1
63297: ST_TO_ADDR
63298: GO 63314
// i := i - 1 ;
63300: LD_ADDR_VAR 0 5
63304: PUSH
63305: LD_VAR 0 5
63309: PUSH
63310: LD_INT 1
63312: MINUS
63313: ST_TO_ADDR
// end ;
63314: GO 63120
63316: POP
63317: POP
// for i in tmp do
63318: LD_ADDR_VAR 0 5
63322: PUSH
63323: LD_VAR 0 7
63327: PUSH
63328: FOR_IN
63329: IFFALSE 63367
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
63331: LD_VAR 0 1
63335: PPUSH
63336: LD_VAR 0 5
63340: PUSH
63341: LD_INT 1
63343: ARRAY
63344: PPUSH
63345: LD_VAR 0 5
63349: PUSH
63350: LD_INT 2
63352: ARRAY
63353: PPUSH
63354: CALL 62313 0 3
63358: NOT
63359: IFFALSE 63365
// exit ;
63361: POP
63362: POP
63363: GO 63369
63365: GO 63328
63367: POP
63368: POP
// end ;
63369: LD_VAR 0 4
63373: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
63374: LD_INT 0
63376: PPUSH
63377: PPUSH
63378: PPUSH
63379: PPUSH
63380: PPUSH
63381: PPUSH
63382: PPUSH
// if not GetClass ( unit ) = class_sniper then
63383: LD_VAR 0 1
63387: PPUSH
63388: CALL_OW 257
63392: PUSH
63393: LD_INT 5
63395: EQUAL
63396: NOT
63397: IFFALSE 63401
// exit ;
63399: GO 63789
// dist := 8 ;
63401: LD_ADDR_VAR 0 5
63405: PUSH
63406: LD_INT 8
63408: ST_TO_ADDR
// viewRange := 12 ;
63409: LD_ADDR_VAR 0 7
63413: PUSH
63414: LD_INT 12
63416: ST_TO_ADDR
// side := GetSide ( unit ) ;
63417: LD_ADDR_VAR 0 6
63421: PUSH
63422: LD_VAR 0 1
63426: PPUSH
63427: CALL_OW 255
63431: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
63432: LD_INT 61
63434: PPUSH
63435: LD_VAR 0 6
63439: PPUSH
63440: CALL_OW 321
63444: PUSH
63445: LD_INT 2
63447: EQUAL
63448: IFFALSE 63458
// viewRange := 16 ;
63450: LD_ADDR_VAR 0 7
63454: PUSH
63455: LD_INT 16
63457: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63458: LD_VAR 0 1
63462: PPUSH
63463: LD_VAR 0 2
63467: PPUSH
63468: LD_VAR 0 3
63472: PPUSH
63473: CALL_OW 297
63477: PUSH
63478: LD_VAR 0 5
63482: GREATER
63483: IFFALSE 63562
// begin ComMoveXY ( unit , x , y ) ;
63485: LD_VAR 0 1
63489: PPUSH
63490: LD_VAR 0 2
63494: PPUSH
63495: LD_VAR 0 3
63499: PPUSH
63500: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63504: LD_INT 35
63506: PPUSH
63507: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63511: LD_VAR 0 1
63515: PPUSH
63516: LD_VAR 0 2
63520: PPUSH
63521: LD_VAR 0 3
63525: PPUSH
63526: CALL 100293 0 3
63530: NOT
63531: IFFALSE 63535
// exit ;
63533: GO 63789
// until GetDistUnitXY ( unit , x , y ) < dist ;
63535: LD_VAR 0 1
63539: PPUSH
63540: LD_VAR 0 2
63544: PPUSH
63545: LD_VAR 0 3
63549: PPUSH
63550: CALL_OW 297
63554: PUSH
63555: LD_VAR 0 5
63559: LESS
63560: IFFALSE 63504
// end ; ComTurnXY ( unit , x , y ) ;
63562: LD_VAR 0 1
63566: PPUSH
63567: LD_VAR 0 2
63571: PPUSH
63572: LD_VAR 0 3
63576: PPUSH
63577: CALL_OW 118
// wait ( 5 ) ;
63581: LD_INT 5
63583: PPUSH
63584: CALL_OW 67
// _d := GetDir ( unit ) ;
63588: LD_ADDR_VAR 0 10
63592: PUSH
63593: LD_VAR 0 1
63597: PPUSH
63598: CALL_OW 254
63602: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63603: LD_ADDR_VAR 0 8
63607: PUSH
63608: LD_VAR 0 1
63612: PPUSH
63613: CALL_OW 250
63617: PPUSH
63618: LD_VAR 0 10
63622: PPUSH
63623: LD_VAR 0 5
63627: PPUSH
63628: CALL_OW 272
63632: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63633: LD_ADDR_VAR 0 9
63637: PUSH
63638: LD_VAR 0 1
63642: PPUSH
63643: CALL_OW 251
63647: PPUSH
63648: LD_VAR 0 10
63652: PPUSH
63653: LD_VAR 0 5
63657: PPUSH
63658: CALL_OW 273
63662: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63663: LD_VAR 0 8
63667: PPUSH
63668: LD_VAR 0 9
63672: PPUSH
63673: CALL_OW 488
63677: NOT
63678: IFFALSE 63682
// exit ;
63680: GO 63789
// ComAnimCustom ( unit , 1 ) ;
63682: LD_VAR 0 1
63686: PPUSH
63687: LD_INT 1
63689: PPUSH
63690: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63694: LD_VAR 0 8
63698: PPUSH
63699: LD_VAR 0 9
63703: PPUSH
63704: LD_VAR 0 6
63708: PPUSH
63709: LD_VAR 0 7
63713: PPUSH
63714: CALL_OW 330
// repeat wait ( 1 ) ;
63718: LD_INT 1
63720: PPUSH
63721: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63725: LD_VAR 0 1
63729: PPUSH
63730: CALL_OW 316
63734: PUSH
63735: LD_VAR 0 1
63739: PPUSH
63740: CALL_OW 314
63744: OR
63745: PUSH
63746: LD_VAR 0 1
63750: PPUSH
63751: CALL_OW 302
63755: NOT
63756: OR
63757: PUSH
63758: LD_VAR 0 1
63762: PPUSH
63763: CALL_OW 301
63767: OR
63768: IFFALSE 63718
// RemoveSeeing ( _x , _y , side ) ;
63770: LD_VAR 0 8
63774: PPUSH
63775: LD_VAR 0 9
63779: PPUSH
63780: LD_VAR 0 6
63784: PPUSH
63785: CALL_OW 331
// end ; end_of_file
63789: LD_VAR 0 4
63793: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63794: LD_INT 0
63796: PPUSH
63797: PPUSH
// if exist_mode then
63798: LD_VAR 0 2
63802: IFFALSE 63827
// unit := CreateCharacter ( prefix & ident ) else
63804: LD_ADDR_VAR 0 5
63808: PUSH
63809: LD_VAR 0 3
63813: PUSH
63814: LD_VAR 0 1
63818: STR
63819: PPUSH
63820: CALL_OW 34
63824: ST_TO_ADDR
63825: GO 63842
// unit := NewCharacter ( ident ) ;
63827: LD_ADDR_VAR 0 5
63831: PUSH
63832: LD_VAR 0 1
63836: PPUSH
63837: CALL_OW 25
63841: ST_TO_ADDR
// result := unit ;
63842: LD_ADDR_VAR 0 4
63846: PUSH
63847: LD_VAR 0 5
63851: ST_TO_ADDR
// end ;
63852: LD_VAR 0 4
63856: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63857: LD_INT 0
63859: PPUSH
63860: PPUSH
// if not side or not nation then
63861: LD_VAR 0 1
63865: NOT
63866: PUSH
63867: LD_VAR 0 2
63871: NOT
63872: OR
63873: IFFALSE 63877
// exit ;
63875: GO 64645
// case nation of nation_american :
63877: LD_VAR 0 2
63881: PUSH
63882: LD_INT 1
63884: DOUBLE
63885: EQUAL
63886: IFTRUE 63890
63888: GO 64104
63890: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63891: LD_ADDR_VAR 0 4
63895: PUSH
63896: LD_INT 35
63898: PUSH
63899: LD_INT 45
63901: PUSH
63902: LD_INT 46
63904: PUSH
63905: LD_INT 47
63907: PUSH
63908: LD_INT 82
63910: PUSH
63911: LD_INT 83
63913: PUSH
63914: LD_INT 84
63916: PUSH
63917: LD_INT 85
63919: PUSH
63920: LD_INT 86
63922: PUSH
63923: LD_INT 1
63925: PUSH
63926: LD_INT 2
63928: PUSH
63929: LD_INT 6
63931: PUSH
63932: LD_INT 15
63934: PUSH
63935: LD_INT 16
63937: PUSH
63938: LD_INT 7
63940: PUSH
63941: LD_INT 12
63943: PUSH
63944: LD_INT 13
63946: PUSH
63947: LD_INT 10
63949: PUSH
63950: LD_INT 14
63952: PUSH
63953: LD_INT 20
63955: PUSH
63956: LD_INT 21
63958: PUSH
63959: LD_INT 22
63961: PUSH
63962: LD_INT 25
63964: PUSH
63965: LD_INT 32
63967: PUSH
63968: LD_INT 27
63970: PUSH
63971: LD_INT 36
63973: PUSH
63974: LD_INT 69
63976: PUSH
63977: LD_INT 39
63979: PUSH
63980: LD_INT 34
63982: PUSH
63983: LD_INT 40
63985: PUSH
63986: LD_INT 48
63988: PUSH
63989: LD_INT 49
63991: PUSH
63992: LD_INT 50
63994: PUSH
63995: LD_INT 51
63997: PUSH
63998: LD_INT 52
64000: PUSH
64001: LD_INT 53
64003: PUSH
64004: LD_INT 54
64006: PUSH
64007: LD_INT 55
64009: PUSH
64010: LD_INT 56
64012: PUSH
64013: LD_INT 57
64015: PUSH
64016: LD_INT 58
64018: PUSH
64019: LD_INT 59
64021: PUSH
64022: LD_INT 60
64024: PUSH
64025: LD_INT 61
64027: PUSH
64028: LD_INT 62
64030: PUSH
64031: LD_INT 80
64033: PUSH
64034: LD_INT 82
64036: PUSH
64037: LD_INT 83
64039: PUSH
64040: LD_INT 84
64042: PUSH
64043: LD_INT 85
64045: PUSH
64046: LD_INT 86
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: LIST
64065: LIST
64066: LIST
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: ST_TO_ADDR
64102: GO 64569
64104: LD_INT 2
64106: DOUBLE
64107: EQUAL
64108: IFTRUE 64112
64110: GO 64338
64112: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
64113: LD_ADDR_VAR 0 4
64117: PUSH
64118: LD_INT 35
64120: PUSH
64121: LD_INT 45
64123: PUSH
64124: LD_INT 46
64126: PUSH
64127: LD_INT 47
64129: PUSH
64130: LD_INT 82
64132: PUSH
64133: LD_INT 83
64135: PUSH
64136: LD_INT 84
64138: PUSH
64139: LD_INT 85
64141: PUSH
64142: LD_INT 87
64144: PUSH
64145: LD_INT 70
64147: PUSH
64148: LD_INT 1
64150: PUSH
64151: LD_INT 11
64153: PUSH
64154: LD_INT 3
64156: PUSH
64157: LD_INT 4
64159: PUSH
64160: LD_INT 5
64162: PUSH
64163: LD_INT 6
64165: PUSH
64166: LD_INT 15
64168: PUSH
64169: LD_INT 18
64171: PUSH
64172: LD_INT 7
64174: PUSH
64175: LD_INT 17
64177: PUSH
64178: LD_INT 8
64180: PUSH
64181: LD_INT 20
64183: PUSH
64184: LD_INT 21
64186: PUSH
64187: LD_INT 22
64189: PUSH
64190: LD_INT 72
64192: PUSH
64193: LD_INT 26
64195: PUSH
64196: LD_INT 69
64198: PUSH
64199: LD_INT 39
64201: PUSH
64202: LD_INT 40
64204: PUSH
64205: LD_INT 41
64207: PUSH
64208: LD_INT 42
64210: PUSH
64211: LD_INT 43
64213: PUSH
64214: LD_INT 48
64216: PUSH
64217: LD_INT 49
64219: PUSH
64220: LD_INT 50
64222: PUSH
64223: LD_INT 51
64225: PUSH
64226: LD_INT 52
64228: PUSH
64229: LD_INT 53
64231: PUSH
64232: LD_INT 54
64234: PUSH
64235: LD_INT 55
64237: PUSH
64238: LD_INT 56
64240: PUSH
64241: LD_INT 60
64243: PUSH
64244: LD_INT 61
64246: PUSH
64247: LD_INT 62
64249: PUSH
64250: LD_INT 66
64252: PUSH
64253: LD_INT 67
64255: PUSH
64256: LD_INT 68
64258: PUSH
64259: LD_INT 81
64261: PUSH
64262: LD_INT 82
64264: PUSH
64265: LD_INT 83
64267: PUSH
64268: LD_INT 84
64270: PUSH
64271: LD_INT 85
64273: PUSH
64274: LD_INT 87
64276: PUSH
64277: LD_INT 88
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: LIST
64335: ST_TO_ADDR
64336: GO 64569
64338: LD_INT 3
64340: DOUBLE
64341: EQUAL
64342: IFTRUE 64346
64344: GO 64568
64346: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
64347: LD_ADDR_VAR 0 4
64351: PUSH
64352: LD_INT 46
64354: PUSH
64355: LD_INT 47
64357: PUSH
64358: LD_INT 1
64360: PUSH
64361: LD_INT 2
64363: PUSH
64364: LD_INT 82
64366: PUSH
64367: LD_INT 83
64369: PUSH
64370: LD_INT 84
64372: PUSH
64373: LD_INT 85
64375: PUSH
64376: LD_INT 86
64378: PUSH
64379: LD_INT 11
64381: PUSH
64382: LD_INT 9
64384: PUSH
64385: LD_INT 20
64387: PUSH
64388: LD_INT 19
64390: PUSH
64391: LD_INT 21
64393: PUSH
64394: LD_INT 24
64396: PUSH
64397: LD_INT 22
64399: PUSH
64400: LD_INT 25
64402: PUSH
64403: LD_INT 28
64405: PUSH
64406: LD_INT 29
64408: PUSH
64409: LD_INT 30
64411: PUSH
64412: LD_INT 31
64414: PUSH
64415: LD_INT 37
64417: PUSH
64418: LD_INT 38
64420: PUSH
64421: LD_INT 32
64423: PUSH
64424: LD_INT 27
64426: PUSH
64427: LD_INT 33
64429: PUSH
64430: LD_INT 69
64432: PUSH
64433: LD_INT 39
64435: PUSH
64436: LD_INT 34
64438: PUSH
64439: LD_INT 40
64441: PUSH
64442: LD_INT 71
64444: PUSH
64445: LD_INT 23
64447: PUSH
64448: LD_INT 44
64450: PUSH
64451: LD_INT 48
64453: PUSH
64454: LD_INT 49
64456: PUSH
64457: LD_INT 50
64459: PUSH
64460: LD_INT 51
64462: PUSH
64463: LD_INT 52
64465: PUSH
64466: LD_INT 53
64468: PUSH
64469: LD_INT 54
64471: PUSH
64472: LD_INT 55
64474: PUSH
64475: LD_INT 56
64477: PUSH
64478: LD_INT 57
64480: PUSH
64481: LD_INT 58
64483: PUSH
64484: LD_INT 59
64486: PUSH
64487: LD_INT 63
64489: PUSH
64490: LD_INT 64
64492: PUSH
64493: LD_INT 65
64495: PUSH
64496: LD_INT 82
64498: PUSH
64499: LD_INT 83
64501: PUSH
64502: LD_INT 84
64504: PUSH
64505: LD_INT 85
64507: PUSH
64508: LD_INT 86
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: LIST
64553: LIST
64554: LIST
64555: LIST
64556: LIST
64557: LIST
64558: LIST
64559: LIST
64560: LIST
64561: LIST
64562: LIST
64563: LIST
64564: LIST
64565: ST_TO_ADDR
64566: GO 64569
64568: POP
// if state > - 1 and state < 3 then
64569: LD_VAR 0 3
64573: PUSH
64574: LD_INT 1
64576: NEG
64577: GREATER
64578: PUSH
64579: LD_VAR 0 3
64583: PUSH
64584: LD_INT 3
64586: LESS
64587: AND
64588: IFFALSE 64645
// for i in result do
64590: LD_ADDR_VAR 0 5
64594: PUSH
64595: LD_VAR 0 4
64599: PUSH
64600: FOR_IN
64601: IFFALSE 64643
// if GetTech ( i , side ) <> state then
64603: LD_VAR 0 5
64607: PPUSH
64608: LD_VAR 0 1
64612: PPUSH
64613: CALL_OW 321
64617: PUSH
64618: LD_VAR 0 3
64622: NONEQUAL
64623: IFFALSE 64641
// result := result diff i ;
64625: LD_ADDR_VAR 0 4
64629: PUSH
64630: LD_VAR 0 4
64634: PUSH
64635: LD_VAR 0 5
64639: DIFF
64640: ST_TO_ADDR
64641: GO 64600
64643: POP
64644: POP
// end ;
64645: LD_VAR 0 4
64649: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64650: LD_INT 0
64652: PPUSH
64653: PPUSH
64654: PPUSH
// result := true ;
64655: LD_ADDR_VAR 0 3
64659: PUSH
64660: LD_INT 1
64662: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64663: LD_ADDR_VAR 0 5
64667: PUSH
64668: LD_VAR 0 2
64672: PPUSH
64673: CALL_OW 480
64677: ST_TO_ADDR
// if not tmp then
64678: LD_VAR 0 5
64682: NOT
64683: IFFALSE 64687
// exit ;
64685: GO 64736
// for i in tmp do
64687: LD_ADDR_VAR 0 4
64691: PUSH
64692: LD_VAR 0 5
64696: PUSH
64697: FOR_IN
64698: IFFALSE 64734
// if GetTech ( i , side ) <> state_researched then
64700: LD_VAR 0 4
64704: PPUSH
64705: LD_VAR 0 1
64709: PPUSH
64710: CALL_OW 321
64714: PUSH
64715: LD_INT 2
64717: NONEQUAL
64718: IFFALSE 64732
// begin result := false ;
64720: LD_ADDR_VAR 0 3
64724: PUSH
64725: LD_INT 0
64727: ST_TO_ADDR
// exit ;
64728: POP
64729: POP
64730: GO 64736
// end ;
64732: GO 64697
64734: POP
64735: POP
// end ;
64736: LD_VAR 0 3
64740: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64741: LD_INT 0
64743: PPUSH
64744: PPUSH
64745: PPUSH
64746: PPUSH
64747: PPUSH
64748: PPUSH
64749: PPUSH
64750: PPUSH
64751: PPUSH
64752: PPUSH
64753: PPUSH
64754: PPUSH
64755: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64756: LD_VAR 0 1
64760: NOT
64761: PUSH
64762: LD_VAR 0 1
64766: PPUSH
64767: CALL_OW 257
64771: PUSH
64772: LD_INT 9
64774: NONEQUAL
64775: OR
64776: IFFALSE 64780
// exit ;
64778: GO 65353
// side := GetSide ( unit ) ;
64780: LD_ADDR_VAR 0 9
64784: PUSH
64785: LD_VAR 0 1
64789: PPUSH
64790: CALL_OW 255
64794: ST_TO_ADDR
// tech_space := tech_spacanom ;
64795: LD_ADDR_VAR 0 12
64799: PUSH
64800: LD_INT 29
64802: ST_TO_ADDR
// tech_time := tech_taurad ;
64803: LD_ADDR_VAR 0 13
64807: PUSH
64808: LD_INT 28
64810: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64811: LD_ADDR_VAR 0 11
64815: PUSH
64816: LD_VAR 0 1
64820: PPUSH
64821: CALL_OW 310
64825: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64826: LD_VAR 0 11
64830: PPUSH
64831: CALL_OW 247
64835: PUSH
64836: LD_INT 2
64838: EQUAL
64839: IFFALSE 64843
// exit ;
64841: GO 65353
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64843: LD_ADDR_VAR 0 8
64847: PUSH
64848: LD_INT 81
64850: PUSH
64851: LD_VAR 0 9
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 3
64862: PUSH
64863: LD_INT 21
64865: PUSH
64866: LD_INT 3
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PPUSH
64881: CALL_OW 69
64885: ST_TO_ADDR
// if not tmp then
64886: LD_VAR 0 8
64890: NOT
64891: IFFALSE 64895
// exit ;
64893: GO 65353
// if in_unit then
64895: LD_VAR 0 11
64899: IFFALSE 64923
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64901: LD_ADDR_VAR 0 10
64905: PUSH
64906: LD_VAR 0 8
64910: PPUSH
64911: LD_VAR 0 11
64915: PPUSH
64916: CALL_OW 74
64920: ST_TO_ADDR
64921: GO 64943
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64923: LD_ADDR_VAR 0 10
64927: PUSH
64928: LD_VAR 0 8
64932: PPUSH
64933: LD_VAR 0 1
64937: PPUSH
64938: CALL_OW 74
64942: ST_TO_ADDR
// if not enemy then
64943: LD_VAR 0 10
64947: NOT
64948: IFFALSE 64952
// exit ;
64950: GO 65353
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64952: LD_VAR 0 11
64956: PUSH
64957: LD_VAR 0 11
64961: PPUSH
64962: LD_VAR 0 10
64966: PPUSH
64967: CALL_OW 296
64971: PUSH
64972: LD_INT 13
64974: GREATER
64975: AND
64976: PUSH
64977: LD_VAR 0 1
64981: PPUSH
64982: LD_VAR 0 10
64986: PPUSH
64987: CALL_OW 296
64991: PUSH
64992: LD_INT 12
64994: GREATER
64995: OR
64996: IFFALSE 65000
// exit ;
64998: GO 65353
// missile := [ 1 ] ;
65000: LD_ADDR_VAR 0 14
65004: PUSH
65005: LD_INT 1
65007: PUSH
65008: EMPTY
65009: LIST
65010: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65011: LD_VAR 0 9
65015: PPUSH
65016: LD_VAR 0 12
65020: PPUSH
65021: CALL_OW 325
65025: IFFALSE 65054
// missile := Replace ( missile , missile + 1 , 2 ) ;
65027: LD_ADDR_VAR 0 14
65031: PUSH
65032: LD_VAR 0 14
65036: PPUSH
65037: LD_VAR 0 14
65041: PUSH
65042: LD_INT 1
65044: PLUS
65045: PPUSH
65046: LD_INT 2
65048: PPUSH
65049: CALL_OW 1
65053: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65054: LD_VAR 0 9
65058: PPUSH
65059: LD_VAR 0 13
65063: PPUSH
65064: CALL_OW 325
65068: PUSH
65069: LD_VAR 0 10
65073: PPUSH
65074: CALL_OW 255
65078: PPUSH
65079: LD_VAR 0 13
65083: PPUSH
65084: CALL_OW 325
65088: NOT
65089: AND
65090: IFFALSE 65119
// missile := Replace ( missile , missile + 1 , 3 ) ;
65092: LD_ADDR_VAR 0 14
65096: PUSH
65097: LD_VAR 0 14
65101: PPUSH
65102: LD_VAR 0 14
65106: PUSH
65107: LD_INT 1
65109: PLUS
65110: PPUSH
65111: LD_INT 3
65113: PPUSH
65114: CALL_OW 1
65118: ST_TO_ADDR
// if missile < 2 then
65119: LD_VAR 0 14
65123: PUSH
65124: LD_INT 2
65126: LESS
65127: IFFALSE 65131
// exit ;
65129: GO 65353
// x := GetX ( enemy ) ;
65131: LD_ADDR_VAR 0 4
65135: PUSH
65136: LD_VAR 0 10
65140: PPUSH
65141: CALL_OW 250
65145: ST_TO_ADDR
// y := GetY ( enemy ) ;
65146: LD_ADDR_VAR 0 5
65150: PUSH
65151: LD_VAR 0 10
65155: PPUSH
65156: CALL_OW 251
65160: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65161: LD_ADDR_VAR 0 6
65165: PUSH
65166: LD_VAR 0 4
65170: PUSH
65171: LD_INT 1
65173: NEG
65174: PPUSH
65175: LD_INT 1
65177: PPUSH
65178: CALL_OW 12
65182: PLUS
65183: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65184: LD_ADDR_VAR 0 7
65188: PUSH
65189: LD_VAR 0 5
65193: PUSH
65194: LD_INT 1
65196: NEG
65197: PPUSH
65198: LD_INT 1
65200: PPUSH
65201: CALL_OW 12
65205: PLUS
65206: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65207: LD_VAR 0 6
65211: PPUSH
65212: LD_VAR 0 7
65216: PPUSH
65217: CALL_OW 488
65221: NOT
65222: IFFALSE 65244
// begin _x := x ;
65224: LD_ADDR_VAR 0 6
65228: PUSH
65229: LD_VAR 0 4
65233: ST_TO_ADDR
// _y := y ;
65234: LD_ADDR_VAR 0 7
65238: PUSH
65239: LD_VAR 0 5
65243: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65244: LD_ADDR_VAR 0 3
65248: PUSH
65249: LD_INT 1
65251: PPUSH
65252: LD_VAR 0 14
65256: PPUSH
65257: CALL_OW 12
65261: ST_TO_ADDR
// case i of 1 :
65262: LD_VAR 0 3
65266: PUSH
65267: LD_INT 1
65269: DOUBLE
65270: EQUAL
65271: IFTRUE 65275
65273: GO 65292
65275: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65276: LD_VAR 0 1
65280: PPUSH
65281: LD_VAR 0 10
65285: PPUSH
65286: CALL_OW 115
65290: GO 65353
65292: LD_INT 2
65294: DOUBLE
65295: EQUAL
65296: IFTRUE 65300
65298: GO 65322
65300: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65301: LD_VAR 0 1
65305: PPUSH
65306: LD_VAR 0 6
65310: PPUSH
65311: LD_VAR 0 7
65315: PPUSH
65316: CALL_OW 153
65320: GO 65353
65322: LD_INT 3
65324: DOUBLE
65325: EQUAL
65326: IFTRUE 65330
65328: GO 65352
65330: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65331: LD_VAR 0 1
65335: PPUSH
65336: LD_VAR 0 6
65340: PPUSH
65341: LD_VAR 0 7
65345: PPUSH
65346: CALL_OW 154
65350: GO 65353
65352: POP
// end ;
65353: LD_VAR 0 2
65357: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65358: LD_INT 0
65360: PPUSH
65361: PPUSH
65362: PPUSH
65363: PPUSH
65364: PPUSH
65365: PPUSH
// if not unit or not building then
65366: LD_VAR 0 1
65370: NOT
65371: PUSH
65372: LD_VAR 0 2
65376: NOT
65377: OR
65378: IFFALSE 65382
// exit ;
65380: GO 65540
// x := GetX ( building ) ;
65382: LD_ADDR_VAR 0 5
65386: PUSH
65387: LD_VAR 0 2
65391: PPUSH
65392: CALL_OW 250
65396: ST_TO_ADDR
// y := GetY ( building ) ;
65397: LD_ADDR_VAR 0 6
65401: PUSH
65402: LD_VAR 0 2
65406: PPUSH
65407: CALL_OW 251
65411: ST_TO_ADDR
// for i = 0 to 5 do
65412: LD_ADDR_VAR 0 4
65416: PUSH
65417: DOUBLE
65418: LD_INT 0
65420: DEC
65421: ST_TO_ADDR
65422: LD_INT 5
65424: PUSH
65425: FOR_TO
65426: IFFALSE 65538
// begin _x := ShiftX ( x , i , 3 ) ;
65428: LD_ADDR_VAR 0 7
65432: PUSH
65433: LD_VAR 0 5
65437: PPUSH
65438: LD_VAR 0 4
65442: PPUSH
65443: LD_INT 3
65445: PPUSH
65446: CALL_OW 272
65450: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65451: LD_ADDR_VAR 0 8
65455: PUSH
65456: LD_VAR 0 6
65460: PPUSH
65461: LD_VAR 0 4
65465: PPUSH
65466: LD_INT 3
65468: PPUSH
65469: CALL_OW 273
65473: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65474: LD_VAR 0 7
65478: PPUSH
65479: LD_VAR 0 8
65483: PPUSH
65484: CALL_OW 488
65488: NOT
65489: IFFALSE 65493
// continue ;
65491: GO 65425
// if HexInfo ( _x , _y ) = 0 then
65493: LD_VAR 0 7
65497: PPUSH
65498: LD_VAR 0 8
65502: PPUSH
65503: CALL_OW 428
65507: PUSH
65508: LD_INT 0
65510: EQUAL
65511: IFFALSE 65536
// begin ComMoveXY ( unit , _x , _y ) ;
65513: LD_VAR 0 1
65517: PPUSH
65518: LD_VAR 0 7
65522: PPUSH
65523: LD_VAR 0 8
65527: PPUSH
65528: CALL_OW 111
// exit ;
65532: POP
65533: POP
65534: GO 65540
// end ; end ;
65536: GO 65425
65538: POP
65539: POP
// end ;
65540: LD_VAR 0 3
65544: RET
// export function ScanBase ( side , base_area ) ; begin
65545: LD_INT 0
65547: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65548: LD_ADDR_VAR 0 3
65552: PUSH
65553: LD_VAR 0 2
65557: PPUSH
65558: LD_INT 81
65560: PUSH
65561: LD_VAR 0 1
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PPUSH
65570: CALL_OW 70
65574: ST_TO_ADDR
// end ;
65575: LD_VAR 0 3
65579: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65580: LD_INT 0
65582: PPUSH
65583: PPUSH
65584: PPUSH
65585: PPUSH
// result := false ;
65586: LD_ADDR_VAR 0 2
65590: PUSH
65591: LD_INT 0
65593: ST_TO_ADDR
// side := GetSide ( unit ) ;
65594: LD_ADDR_VAR 0 3
65598: PUSH
65599: LD_VAR 0 1
65603: PPUSH
65604: CALL_OW 255
65608: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65609: LD_ADDR_VAR 0 4
65613: PUSH
65614: LD_VAR 0 1
65618: PPUSH
65619: CALL_OW 248
65623: ST_TO_ADDR
// case nat of 1 :
65624: LD_VAR 0 4
65628: PUSH
65629: LD_INT 1
65631: DOUBLE
65632: EQUAL
65633: IFTRUE 65637
65635: GO 65648
65637: POP
// tech := tech_lassight ; 2 :
65638: LD_ADDR_VAR 0 5
65642: PUSH
65643: LD_INT 12
65645: ST_TO_ADDR
65646: GO 65687
65648: LD_INT 2
65650: DOUBLE
65651: EQUAL
65652: IFTRUE 65656
65654: GO 65667
65656: POP
// tech := tech_mortar ; 3 :
65657: LD_ADDR_VAR 0 5
65661: PUSH
65662: LD_INT 41
65664: ST_TO_ADDR
65665: GO 65687
65667: LD_INT 3
65669: DOUBLE
65670: EQUAL
65671: IFTRUE 65675
65673: GO 65686
65675: POP
// tech := tech_bazooka ; end ;
65676: LD_ADDR_VAR 0 5
65680: PUSH
65681: LD_INT 44
65683: ST_TO_ADDR
65684: GO 65687
65686: POP
// if Researched ( side , tech ) then
65687: LD_VAR 0 3
65691: PPUSH
65692: LD_VAR 0 5
65696: PPUSH
65697: CALL_OW 325
65701: IFFALSE 65728
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65703: LD_ADDR_VAR 0 2
65707: PUSH
65708: LD_INT 5
65710: PUSH
65711: LD_INT 8
65713: PUSH
65714: LD_INT 9
65716: PUSH
65717: EMPTY
65718: LIST
65719: LIST
65720: LIST
65721: PUSH
65722: LD_VAR 0 4
65726: ARRAY
65727: ST_TO_ADDR
// end ;
65728: LD_VAR 0 2
65732: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65733: LD_INT 0
65735: PPUSH
65736: PPUSH
65737: PPUSH
// if not mines then
65738: LD_VAR 0 2
65742: NOT
65743: IFFALSE 65747
// exit ;
65745: GO 65891
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65747: LD_ADDR_VAR 0 5
65751: PUSH
65752: LD_INT 81
65754: PUSH
65755: LD_VAR 0 1
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 3
65766: PUSH
65767: LD_INT 21
65769: PUSH
65770: LD_INT 3
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PPUSH
65785: CALL_OW 69
65789: ST_TO_ADDR
// for i in mines do
65790: LD_ADDR_VAR 0 4
65794: PUSH
65795: LD_VAR 0 2
65799: PUSH
65800: FOR_IN
65801: IFFALSE 65889
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65803: LD_VAR 0 4
65807: PUSH
65808: LD_INT 1
65810: ARRAY
65811: PPUSH
65812: LD_VAR 0 4
65816: PUSH
65817: LD_INT 2
65819: ARRAY
65820: PPUSH
65821: CALL_OW 458
65825: NOT
65826: IFFALSE 65830
// continue ;
65828: GO 65800
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65830: LD_VAR 0 4
65834: PUSH
65835: LD_INT 1
65837: ARRAY
65838: PPUSH
65839: LD_VAR 0 4
65843: PUSH
65844: LD_INT 2
65846: ARRAY
65847: PPUSH
65848: CALL_OW 428
65852: PUSH
65853: LD_VAR 0 5
65857: IN
65858: IFFALSE 65887
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65860: LD_VAR 0 4
65864: PUSH
65865: LD_INT 1
65867: ARRAY
65868: PPUSH
65869: LD_VAR 0 4
65873: PUSH
65874: LD_INT 2
65876: ARRAY
65877: PPUSH
65878: LD_VAR 0 1
65882: PPUSH
65883: CALL_OW 456
// end ;
65887: GO 65800
65889: POP
65890: POP
// end ;
65891: LD_VAR 0 3
65895: RET
// export function Count ( array ) ; begin
65896: LD_INT 0
65898: PPUSH
// result := array + 0 ;
65899: LD_ADDR_VAR 0 2
65903: PUSH
65904: LD_VAR 0 1
65908: PUSH
65909: LD_INT 0
65911: PLUS
65912: ST_TO_ADDR
// end ;
65913: LD_VAR 0 2
65917: RET
// export function IsEmpty ( building ) ; begin
65918: LD_INT 0
65920: PPUSH
// if not building then
65921: LD_VAR 0 1
65925: NOT
65926: IFFALSE 65930
// exit ;
65928: GO 65973
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65930: LD_ADDR_VAR 0 2
65934: PUSH
65935: LD_VAR 0 1
65939: PUSH
65940: LD_INT 22
65942: PUSH
65943: LD_VAR 0 1
65947: PPUSH
65948: CALL_OW 255
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 58
65959: PUSH
65960: EMPTY
65961: LIST
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PPUSH
65967: CALL_OW 69
65971: IN
65972: ST_TO_ADDR
// end ;
65973: LD_VAR 0 2
65977: RET
// export function IsNotFull ( building ) ; var places ; begin
65978: LD_INT 0
65980: PPUSH
65981: PPUSH
// if not building then
65982: LD_VAR 0 1
65986: NOT
65987: IFFALSE 65991
// exit ;
65989: GO 66019
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
65991: LD_ADDR_VAR 0 2
65995: PUSH
65996: LD_VAR 0 1
66000: PPUSH
66001: LD_INT 3
66003: PUSH
66004: LD_INT 62
66006: PUSH
66007: EMPTY
66008: LIST
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PPUSH
66014: CALL_OW 72
66018: ST_TO_ADDR
// end ;
66019: LD_VAR 0 2
66023: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
66024: LD_INT 0
66026: PPUSH
66027: PPUSH
66028: PPUSH
66029: PPUSH
// tmp := [ ] ;
66030: LD_ADDR_VAR 0 3
66034: PUSH
66035: EMPTY
66036: ST_TO_ADDR
// list := [ ] ;
66037: LD_ADDR_VAR 0 5
66041: PUSH
66042: EMPTY
66043: ST_TO_ADDR
// for i = 16 to 25 do
66044: LD_ADDR_VAR 0 4
66048: PUSH
66049: DOUBLE
66050: LD_INT 16
66052: DEC
66053: ST_TO_ADDR
66054: LD_INT 25
66056: PUSH
66057: FOR_TO
66058: IFFALSE 66131
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
66060: LD_ADDR_VAR 0 3
66064: PUSH
66065: LD_VAR 0 3
66069: PUSH
66070: LD_INT 22
66072: PUSH
66073: LD_VAR 0 1
66077: PPUSH
66078: CALL_OW 255
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: PUSH
66087: LD_INT 91
66089: PUSH
66090: LD_VAR 0 1
66094: PUSH
66095: LD_INT 6
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 30
66105: PUSH
66106: LD_VAR 0 4
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: LIST
66119: PUSH
66120: EMPTY
66121: LIST
66122: PPUSH
66123: CALL_OW 69
66127: ADD
66128: ST_TO_ADDR
66129: GO 66057
66131: POP
66132: POP
// for i = 1 to tmp do
66133: LD_ADDR_VAR 0 4
66137: PUSH
66138: DOUBLE
66139: LD_INT 1
66141: DEC
66142: ST_TO_ADDR
66143: LD_VAR 0 3
66147: PUSH
66148: FOR_TO
66149: IFFALSE 66237
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
66151: LD_ADDR_VAR 0 5
66155: PUSH
66156: LD_VAR 0 5
66160: PUSH
66161: LD_VAR 0 3
66165: PUSH
66166: LD_VAR 0 4
66170: ARRAY
66171: PPUSH
66172: CALL_OW 266
66176: PUSH
66177: LD_VAR 0 3
66181: PUSH
66182: LD_VAR 0 4
66186: ARRAY
66187: PPUSH
66188: CALL_OW 250
66192: PUSH
66193: LD_VAR 0 3
66197: PUSH
66198: LD_VAR 0 4
66202: ARRAY
66203: PPUSH
66204: CALL_OW 251
66208: PUSH
66209: LD_VAR 0 3
66213: PUSH
66214: LD_VAR 0 4
66218: ARRAY
66219: PPUSH
66220: CALL_OW 254
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: PUSH
66231: EMPTY
66232: LIST
66233: ADD
66234: ST_TO_ADDR
66235: GO 66148
66237: POP
66238: POP
// result := list ;
66239: LD_ADDR_VAR 0 2
66243: PUSH
66244: LD_VAR 0 5
66248: ST_TO_ADDR
// end ;
66249: LD_VAR 0 2
66253: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
66254: LD_INT 0
66256: PPUSH
66257: PPUSH
66258: PPUSH
66259: PPUSH
66260: PPUSH
66261: PPUSH
66262: PPUSH
// if not factory then
66263: LD_VAR 0 1
66267: NOT
66268: IFFALSE 66272
// exit ;
66270: GO 66865
// if control = control_apeman then
66272: LD_VAR 0 4
66276: PUSH
66277: LD_INT 5
66279: EQUAL
66280: IFFALSE 66389
// begin tmp := UnitsInside ( factory ) ;
66282: LD_ADDR_VAR 0 8
66286: PUSH
66287: LD_VAR 0 1
66291: PPUSH
66292: CALL_OW 313
66296: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66297: LD_VAR 0 8
66301: PPUSH
66302: LD_INT 25
66304: PUSH
66305: LD_INT 12
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PPUSH
66312: CALL_OW 72
66316: NOT
66317: IFFALSE 66327
// control := control_manual ;
66319: LD_ADDR_VAR 0 4
66323: PUSH
66324: LD_INT 1
66326: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66327: LD_ADDR_VAR 0 8
66331: PUSH
66332: LD_VAR 0 1
66336: PPUSH
66337: CALL 66024 0 1
66341: ST_TO_ADDR
// if tmp then
66342: LD_VAR 0 8
66346: IFFALSE 66389
// begin for i in tmp do
66348: LD_ADDR_VAR 0 7
66352: PUSH
66353: LD_VAR 0 8
66357: PUSH
66358: FOR_IN
66359: IFFALSE 66387
// if i [ 1 ] = b_ext_radio then
66361: LD_VAR 0 7
66365: PUSH
66366: LD_INT 1
66368: ARRAY
66369: PUSH
66370: LD_INT 22
66372: EQUAL
66373: IFFALSE 66385
// begin control := control_remote ;
66375: LD_ADDR_VAR 0 4
66379: PUSH
66380: LD_INT 2
66382: ST_TO_ADDR
// break ;
66383: GO 66387
// end ;
66385: GO 66358
66387: POP
66388: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66389: LD_VAR 0 1
66393: PPUSH
66394: LD_VAR 0 2
66398: PPUSH
66399: LD_VAR 0 3
66403: PPUSH
66404: LD_VAR 0 4
66408: PPUSH
66409: LD_VAR 0 5
66413: PPUSH
66414: CALL_OW 448
66418: IFFALSE 66453
// begin result := [ chassis , engine , control , weapon ] ;
66420: LD_ADDR_VAR 0 6
66424: PUSH
66425: LD_VAR 0 2
66429: PUSH
66430: LD_VAR 0 3
66434: PUSH
66435: LD_VAR 0 4
66439: PUSH
66440: LD_VAR 0 5
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: ST_TO_ADDR
// exit ;
66451: GO 66865
// end ; _chassis := AvailableChassisList ( factory ) ;
66453: LD_ADDR_VAR 0 9
66457: PUSH
66458: LD_VAR 0 1
66462: PPUSH
66463: CALL_OW 475
66467: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66468: LD_ADDR_VAR 0 11
66472: PUSH
66473: LD_VAR 0 1
66477: PPUSH
66478: CALL_OW 476
66482: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66483: LD_ADDR_VAR 0 12
66487: PUSH
66488: LD_VAR 0 1
66492: PPUSH
66493: CALL_OW 477
66497: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66498: LD_ADDR_VAR 0 10
66502: PUSH
66503: LD_VAR 0 1
66507: PPUSH
66508: CALL_OW 478
66512: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66513: LD_VAR 0 9
66517: NOT
66518: PUSH
66519: LD_VAR 0 11
66523: NOT
66524: OR
66525: PUSH
66526: LD_VAR 0 12
66530: NOT
66531: OR
66532: PUSH
66533: LD_VAR 0 10
66537: NOT
66538: OR
66539: IFFALSE 66574
// begin result := [ chassis , engine , control , weapon ] ;
66541: LD_ADDR_VAR 0 6
66545: PUSH
66546: LD_VAR 0 2
66550: PUSH
66551: LD_VAR 0 3
66555: PUSH
66556: LD_VAR 0 4
66560: PUSH
66561: LD_VAR 0 5
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: ST_TO_ADDR
// exit ;
66572: GO 66865
// end ; if not chassis in _chassis then
66574: LD_VAR 0 2
66578: PUSH
66579: LD_VAR 0 9
66583: IN
66584: NOT
66585: IFFALSE 66611
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66587: LD_ADDR_VAR 0 2
66591: PUSH
66592: LD_VAR 0 9
66596: PUSH
66597: LD_INT 1
66599: PPUSH
66600: LD_VAR 0 9
66604: PPUSH
66605: CALL_OW 12
66609: ARRAY
66610: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66611: LD_VAR 0 2
66615: PPUSH
66616: LD_VAR 0 3
66620: PPUSH
66621: CALL 66870 0 2
66625: NOT
66626: IFFALSE 66685
// repeat engine := _engine [ 1 ] ;
66628: LD_ADDR_VAR 0 3
66632: PUSH
66633: LD_VAR 0 11
66637: PUSH
66638: LD_INT 1
66640: ARRAY
66641: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66642: LD_ADDR_VAR 0 11
66646: PUSH
66647: LD_VAR 0 11
66651: PPUSH
66652: LD_INT 1
66654: PPUSH
66655: CALL_OW 3
66659: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66660: LD_VAR 0 2
66664: PPUSH
66665: LD_VAR 0 3
66669: PPUSH
66670: CALL 66870 0 2
66674: PUSH
66675: LD_VAR 0 11
66679: PUSH
66680: EMPTY
66681: EQUAL
66682: OR
66683: IFFALSE 66628
// if not control in _control then
66685: LD_VAR 0 4
66689: PUSH
66690: LD_VAR 0 12
66694: IN
66695: NOT
66696: IFFALSE 66722
// control := _control [ rand ( 1 , _control ) ] ;
66698: LD_ADDR_VAR 0 4
66702: PUSH
66703: LD_VAR 0 12
66707: PUSH
66708: LD_INT 1
66710: PPUSH
66711: LD_VAR 0 12
66715: PPUSH
66716: CALL_OW 12
66720: ARRAY
66721: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66722: LD_VAR 0 2
66726: PPUSH
66727: LD_VAR 0 5
66731: PPUSH
66732: CALL 67090 0 2
66736: NOT
66737: IFFALSE 66796
// repeat weapon := _weapon [ 1 ] ;
66739: LD_ADDR_VAR 0 5
66743: PUSH
66744: LD_VAR 0 10
66748: PUSH
66749: LD_INT 1
66751: ARRAY
66752: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66753: LD_ADDR_VAR 0 10
66757: PUSH
66758: LD_VAR 0 10
66762: PPUSH
66763: LD_INT 1
66765: PPUSH
66766: CALL_OW 3
66770: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66771: LD_VAR 0 2
66775: PPUSH
66776: LD_VAR 0 5
66780: PPUSH
66781: CALL 67090 0 2
66785: PUSH
66786: LD_VAR 0 10
66790: PUSH
66791: EMPTY
66792: EQUAL
66793: OR
66794: IFFALSE 66739
// result := [ ] ;
66796: LD_ADDR_VAR 0 6
66800: PUSH
66801: EMPTY
66802: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66803: LD_VAR 0 1
66807: PPUSH
66808: LD_VAR 0 2
66812: PPUSH
66813: LD_VAR 0 3
66817: PPUSH
66818: LD_VAR 0 4
66822: PPUSH
66823: LD_VAR 0 5
66827: PPUSH
66828: CALL_OW 448
66832: IFFALSE 66865
// result := [ chassis , engine , control , weapon ] ;
66834: LD_ADDR_VAR 0 6
66838: PUSH
66839: LD_VAR 0 2
66843: PUSH
66844: LD_VAR 0 3
66848: PUSH
66849: LD_VAR 0 4
66853: PUSH
66854: LD_VAR 0 5
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: ST_TO_ADDR
// end ;
66865: LD_VAR 0 6
66869: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66870: LD_INT 0
66872: PPUSH
// if not chassis or not engine then
66873: LD_VAR 0 1
66877: NOT
66878: PUSH
66879: LD_VAR 0 2
66883: NOT
66884: OR
66885: IFFALSE 66889
// exit ;
66887: GO 67085
// case engine of engine_solar :
66889: LD_VAR 0 2
66893: PUSH
66894: LD_INT 2
66896: DOUBLE
66897: EQUAL
66898: IFTRUE 66902
66900: GO 66940
66902: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66903: LD_ADDR_VAR 0 3
66907: PUSH
66908: LD_INT 11
66910: PUSH
66911: LD_INT 12
66913: PUSH
66914: LD_INT 13
66916: PUSH
66917: LD_INT 14
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: LD_INT 2
66925: PUSH
66926: LD_INT 3
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: ST_TO_ADDR
66938: GO 67069
66940: LD_INT 1
66942: DOUBLE
66943: EQUAL
66944: IFTRUE 66948
66946: GO 67010
66948: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66949: LD_ADDR_VAR 0 3
66953: PUSH
66954: LD_INT 11
66956: PUSH
66957: LD_INT 12
66959: PUSH
66960: LD_INT 13
66962: PUSH
66963: LD_INT 14
66965: PUSH
66966: LD_INT 1
66968: PUSH
66969: LD_INT 2
66971: PUSH
66972: LD_INT 3
66974: PUSH
66975: LD_INT 4
66977: PUSH
66978: LD_INT 5
66980: PUSH
66981: LD_INT 21
66983: PUSH
66984: LD_INT 23
66986: PUSH
66987: LD_INT 22
66989: PUSH
66990: LD_INT 24
66992: PUSH
66993: EMPTY
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: ST_TO_ADDR
67008: GO 67069
67010: LD_INT 3
67012: DOUBLE
67013: EQUAL
67014: IFTRUE 67018
67016: GO 67068
67018: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67019: LD_ADDR_VAR 0 3
67023: PUSH
67024: LD_INT 13
67026: PUSH
67027: LD_INT 14
67029: PUSH
67030: LD_INT 2
67032: PUSH
67033: LD_INT 3
67035: PUSH
67036: LD_INT 4
67038: PUSH
67039: LD_INT 5
67041: PUSH
67042: LD_INT 21
67044: PUSH
67045: LD_INT 22
67047: PUSH
67048: LD_INT 23
67050: PUSH
67051: LD_INT 24
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: ST_TO_ADDR
67066: GO 67069
67068: POP
// result := ( chassis in result ) ;
67069: LD_ADDR_VAR 0 3
67073: PUSH
67074: LD_VAR 0 1
67078: PUSH
67079: LD_VAR 0 3
67083: IN
67084: ST_TO_ADDR
// end ;
67085: LD_VAR 0 3
67089: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
67090: LD_INT 0
67092: PPUSH
// if not chassis or not weapon then
67093: LD_VAR 0 1
67097: NOT
67098: PUSH
67099: LD_VAR 0 2
67103: NOT
67104: OR
67105: IFFALSE 67109
// exit ;
67107: GO 68169
// case weapon of us_machine_gun :
67109: LD_VAR 0 2
67113: PUSH
67114: LD_INT 2
67116: DOUBLE
67117: EQUAL
67118: IFTRUE 67122
67120: GO 67152
67122: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
67123: LD_ADDR_VAR 0 3
67127: PUSH
67128: LD_INT 1
67130: PUSH
67131: LD_INT 2
67133: PUSH
67134: LD_INT 3
67136: PUSH
67137: LD_INT 4
67139: PUSH
67140: LD_INT 5
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: ST_TO_ADDR
67150: GO 68153
67152: LD_INT 3
67154: DOUBLE
67155: EQUAL
67156: IFTRUE 67160
67158: GO 67190
67160: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
67161: LD_ADDR_VAR 0 3
67165: PUSH
67166: LD_INT 1
67168: PUSH
67169: LD_INT 2
67171: PUSH
67172: LD_INT 3
67174: PUSH
67175: LD_INT 4
67177: PUSH
67178: LD_INT 5
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: ST_TO_ADDR
67188: GO 68153
67190: LD_INT 11
67192: DOUBLE
67193: EQUAL
67194: IFTRUE 67198
67196: GO 67228
67198: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
67199: LD_ADDR_VAR 0 3
67203: PUSH
67204: LD_INT 1
67206: PUSH
67207: LD_INT 2
67209: PUSH
67210: LD_INT 3
67212: PUSH
67213: LD_INT 4
67215: PUSH
67216: LD_INT 5
67218: PUSH
67219: EMPTY
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: ST_TO_ADDR
67226: GO 68153
67228: LD_INT 4
67230: DOUBLE
67231: EQUAL
67232: IFTRUE 67236
67234: GO 67262
67236: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
67237: LD_ADDR_VAR 0 3
67241: PUSH
67242: LD_INT 2
67244: PUSH
67245: LD_INT 3
67247: PUSH
67248: LD_INT 4
67250: PUSH
67251: LD_INT 5
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: LIST
67258: LIST
67259: ST_TO_ADDR
67260: GO 68153
67262: LD_INT 5
67264: DOUBLE
67265: EQUAL
67266: IFTRUE 67270
67268: GO 67296
67270: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
67271: LD_ADDR_VAR 0 3
67275: PUSH
67276: LD_INT 2
67278: PUSH
67279: LD_INT 3
67281: PUSH
67282: LD_INT 4
67284: PUSH
67285: LD_INT 5
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: ST_TO_ADDR
67294: GO 68153
67296: LD_INT 9
67298: DOUBLE
67299: EQUAL
67300: IFTRUE 67304
67302: GO 67330
67304: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67305: LD_ADDR_VAR 0 3
67309: PUSH
67310: LD_INT 2
67312: PUSH
67313: LD_INT 3
67315: PUSH
67316: LD_INT 4
67318: PUSH
67319: LD_INT 5
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: ST_TO_ADDR
67328: GO 68153
67330: LD_INT 7
67332: DOUBLE
67333: EQUAL
67334: IFTRUE 67338
67336: GO 67364
67338: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67339: LD_ADDR_VAR 0 3
67343: PUSH
67344: LD_INT 2
67346: PUSH
67347: LD_INT 3
67349: PUSH
67350: LD_INT 4
67352: PUSH
67353: LD_INT 5
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: ST_TO_ADDR
67362: GO 68153
67364: LD_INT 12
67366: DOUBLE
67367: EQUAL
67368: IFTRUE 67372
67370: GO 67398
67372: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67373: LD_ADDR_VAR 0 3
67377: PUSH
67378: LD_INT 2
67380: PUSH
67381: LD_INT 3
67383: PUSH
67384: LD_INT 4
67386: PUSH
67387: LD_INT 5
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: ST_TO_ADDR
67396: GO 68153
67398: LD_INT 13
67400: DOUBLE
67401: EQUAL
67402: IFTRUE 67406
67404: GO 67432
67406: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67407: LD_ADDR_VAR 0 3
67411: PUSH
67412: LD_INT 2
67414: PUSH
67415: LD_INT 3
67417: PUSH
67418: LD_INT 4
67420: PUSH
67421: LD_INT 5
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: ST_TO_ADDR
67430: GO 68153
67432: LD_INT 14
67434: DOUBLE
67435: EQUAL
67436: IFTRUE 67440
67438: GO 67458
67440: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67441: LD_ADDR_VAR 0 3
67445: PUSH
67446: LD_INT 4
67448: PUSH
67449: LD_INT 5
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: ST_TO_ADDR
67456: GO 68153
67458: LD_INT 6
67460: DOUBLE
67461: EQUAL
67462: IFTRUE 67466
67464: GO 67484
67466: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67467: LD_ADDR_VAR 0 3
67471: PUSH
67472: LD_INT 4
67474: PUSH
67475: LD_INT 5
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: ST_TO_ADDR
67482: GO 68153
67484: LD_INT 10
67486: DOUBLE
67487: EQUAL
67488: IFTRUE 67492
67490: GO 67510
67492: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67493: LD_ADDR_VAR 0 3
67497: PUSH
67498: LD_INT 4
67500: PUSH
67501: LD_INT 5
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: ST_TO_ADDR
67508: GO 68153
67510: LD_INT 22
67512: DOUBLE
67513: EQUAL
67514: IFTRUE 67518
67516: GO 67544
67518: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67519: LD_ADDR_VAR 0 3
67523: PUSH
67524: LD_INT 11
67526: PUSH
67527: LD_INT 12
67529: PUSH
67530: LD_INT 13
67532: PUSH
67533: LD_INT 14
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: LIST
67540: LIST
67541: ST_TO_ADDR
67542: GO 68153
67544: LD_INT 23
67546: DOUBLE
67547: EQUAL
67548: IFTRUE 67552
67550: GO 67578
67552: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67553: LD_ADDR_VAR 0 3
67557: PUSH
67558: LD_INT 11
67560: PUSH
67561: LD_INT 12
67563: PUSH
67564: LD_INT 13
67566: PUSH
67567: LD_INT 14
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: ST_TO_ADDR
67576: GO 68153
67578: LD_INT 24
67580: DOUBLE
67581: EQUAL
67582: IFTRUE 67586
67584: GO 67612
67586: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67587: LD_ADDR_VAR 0 3
67591: PUSH
67592: LD_INT 11
67594: PUSH
67595: LD_INT 12
67597: PUSH
67598: LD_INT 13
67600: PUSH
67601: LD_INT 14
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: ST_TO_ADDR
67610: GO 68153
67612: LD_INT 30
67614: DOUBLE
67615: EQUAL
67616: IFTRUE 67620
67618: GO 67646
67620: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67621: LD_ADDR_VAR 0 3
67625: PUSH
67626: LD_INT 11
67628: PUSH
67629: LD_INT 12
67631: PUSH
67632: LD_INT 13
67634: PUSH
67635: LD_INT 14
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: ST_TO_ADDR
67644: GO 68153
67646: LD_INT 25
67648: DOUBLE
67649: EQUAL
67650: IFTRUE 67654
67652: GO 67672
67654: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67655: LD_ADDR_VAR 0 3
67659: PUSH
67660: LD_INT 13
67662: PUSH
67663: LD_INT 14
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: ST_TO_ADDR
67670: GO 68153
67672: LD_INT 27
67674: DOUBLE
67675: EQUAL
67676: IFTRUE 67680
67678: GO 67698
67680: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67681: LD_ADDR_VAR 0 3
67685: PUSH
67686: LD_INT 13
67688: PUSH
67689: LD_INT 14
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: ST_TO_ADDR
67696: GO 68153
67698: LD_INT 92
67700: DOUBLE
67701: EQUAL
67702: IFTRUE 67706
67704: GO 67732
67706: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67707: LD_ADDR_VAR 0 3
67711: PUSH
67712: LD_INT 11
67714: PUSH
67715: LD_INT 12
67717: PUSH
67718: LD_INT 13
67720: PUSH
67721: LD_INT 14
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: ST_TO_ADDR
67730: GO 68153
67732: LD_INT 28
67734: DOUBLE
67735: EQUAL
67736: IFTRUE 67740
67738: GO 67758
67740: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67741: LD_ADDR_VAR 0 3
67745: PUSH
67746: LD_INT 13
67748: PUSH
67749: LD_INT 14
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: ST_TO_ADDR
67756: GO 68153
67758: LD_INT 29
67760: DOUBLE
67761: EQUAL
67762: IFTRUE 67766
67764: GO 67784
67766: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67767: LD_ADDR_VAR 0 3
67771: PUSH
67772: LD_INT 13
67774: PUSH
67775: LD_INT 14
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: ST_TO_ADDR
67782: GO 68153
67784: LD_INT 31
67786: DOUBLE
67787: EQUAL
67788: IFTRUE 67792
67790: GO 67810
67792: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67793: LD_ADDR_VAR 0 3
67797: PUSH
67798: LD_INT 13
67800: PUSH
67801: LD_INT 14
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: ST_TO_ADDR
67808: GO 68153
67810: LD_INT 26
67812: DOUBLE
67813: EQUAL
67814: IFTRUE 67818
67816: GO 67836
67818: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67819: LD_ADDR_VAR 0 3
67823: PUSH
67824: LD_INT 13
67826: PUSH
67827: LD_INT 14
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: ST_TO_ADDR
67834: GO 68153
67836: LD_INT 42
67838: DOUBLE
67839: EQUAL
67840: IFTRUE 67844
67842: GO 67870
67844: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67845: LD_ADDR_VAR 0 3
67849: PUSH
67850: LD_INT 21
67852: PUSH
67853: LD_INT 22
67855: PUSH
67856: LD_INT 23
67858: PUSH
67859: LD_INT 24
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: ST_TO_ADDR
67868: GO 68153
67870: LD_INT 43
67872: DOUBLE
67873: EQUAL
67874: IFTRUE 67878
67876: GO 67904
67878: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67879: LD_ADDR_VAR 0 3
67883: PUSH
67884: LD_INT 21
67886: PUSH
67887: LD_INT 22
67889: PUSH
67890: LD_INT 23
67892: PUSH
67893: LD_INT 24
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: ST_TO_ADDR
67902: GO 68153
67904: LD_INT 44
67906: DOUBLE
67907: EQUAL
67908: IFTRUE 67912
67910: GO 67938
67912: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67913: LD_ADDR_VAR 0 3
67917: PUSH
67918: LD_INT 21
67920: PUSH
67921: LD_INT 22
67923: PUSH
67924: LD_INT 23
67926: PUSH
67927: LD_INT 24
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: ST_TO_ADDR
67936: GO 68153
67938: LD_INT 45
67940: DOUBLE
67941: EQUAL
67942: IFTRUE 67946
67944: GO 67972
67946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67947: LD_ADDR_VAR 0 3
67951: PUSH
67952: LD_INT 21
67954: PUSH
67955: LD_INT 22
67957: PUSH
67958: LD_INT 23
67960: PUSH
67961: LD_INT 24
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: ST_TO_ADDR
67970: GO 68153
67972: LD_INT 49
67974: DOUBLE
67975: EQUAL
67976: IFTRUE 67980
67978: GO 68006
67980: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67981: LD_ADDR_VAR 0 3
67985: PUSH
67986: LD_INT 21
67988: PUSH
67989: LD_INT 22
67991: PUSH
67992: LD_INT 23
67994: PUSH
67995: LD_INT 24
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: ST_TO_ADDR
68004: GO 68153
68006: LD_INT 51
68008: DOUBLE
68009: EQUAL
68010: IFTRUE 68014
68012: GO 68040
68014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68015: LD_ADDR_VAR 0 3
68019: PUSH
68020: LD_INT 21
68022: PUSH
68023: LD_INT 22
68025: PUSH
68026: LD_INT 23
68028: PUSH
68029: LD_INT 24
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: ST_TO_ADDR
68038: GO 68153
68040: LD_INT 52
68042: DOUBLE
68043: EQUAL
68044: IFTRUE 68048
68046: GO 68074
68048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
68049: LD_ADDR_VAR 0 3
68053: PUSH
68054: LD_INT 21
68056: PUSH
68057: LD_INT 22
68059: PUSH
68060: LD_INT 23
68062: PUSH
68063: LD_INT 24
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: ST_TO_ADDR
68072: GO 68153
68074: LD_INT 53
68076: DOUBLE
68077: EQUAL
68078: IFTRUE 68082
68080: GO 68100
68082: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
68083: LD_ADDR_VAR 0 3
68087: PUSH
68088: LD_INT 23
68090: PUSH
68091: LD_INT 24
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: ST_TO_ADDR
68098: GO 68153
68100: LD_INT 46
68102: DOUBLE
68103: EQUAL
68104: IFTRUE 68108
68106: GO 68126
68108: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
68109: LD_ADDR_VAR 0 3
68113: PUSH
68114: LD_INT 23
68116: PUSH
68117: LD_INT 24
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: ST_TO_ADDR
68124: GO 68153
68126: LD_INT 47
68128: DOUBLE
68129: EQUAL
68130: IFTRUE 68134
68132: GO 68152
68134: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68135: LD_ADDR_VAR 0 3
68139: PUSH
68140: LD_INT 23
68142: PUSH
68143: LD_INT 24
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: ST_TO_ADDR
68150: GO 68153
68152: POP
// result := ( chassis in result ) ;
68153: LD_ADDR_VAR 0 3
68157: PUSH
68158: LD_VAR 0 1
68162: PUSH
68163: LD_VAR 0 3
68167: IN
68168: ST_TO_ADDR
// end ;
68169: LD_VAR 0 3
68173: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
68174: LD_INT 0
68176: PPUSH
68177: PPUSH
68178: PPUSH
68179: PPUSH
68180: PPUSH
68181: PPUSH
68182: PPUSH
// result := array ;
68183: LD_ADDR_VAR 0 5
68187: PUSH
68188: LD_VAR 0 1
68192: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
68193: LD_VAR 0 1
68197: NOT
68198: PUSH
68199: LD_VAR 0 2
68203: NOT
68204: OR
68205: PUSH
68206: LD_VAR 0 3
68210: NOT
68211: OR
68212: PUSH
68213: LD_VAR 0 2
68217: PUSH
68218: LD_VAR 0 1
68222: GREATER
68223: OR
68224: PUSH
68225: LD_VAR 0 3
68229: PUSH
68230: LD_VAR 0 1
68234: GREATER
68235: OR
68236: IFFALSE 68240
// exit ;
68238: GO 68536
// if direction then
68240: LD_VAR 0 4
68244: IFFALSE 68308
// begin d := 1 ;
68246: LD_ADDR_VAR 0 9
68250: PUSH
68251: LD_INT 1
68253: ST_TO_ADDR
// if i_from > i_to then
68254: LD_VAR 0 2
68258: PUSH
68259: LD_VAR 0 3
68263: GREATER
68264: IFFALSE 68290
// length := ( array - i_from ) + i_to else
68266: LD_ADDR_VAR 0 11
68270: PUSH
68271: LD_VAR 0 1
68275: PUSH
68276: LD_VAR 0 2
68280: MINUS
68281: PUSH
68282: LD_VAR 0 3
68286: PLUS
68287: ST_TO_ADDR
68288: GO 68306
// length := i_to - i_from ;
68290: LD_ADDR_VAR 0 11
68294: PUSH
68295: LD_VAR 0 3
68299: PUSH
68300: LD_VAR 0 2
68304: MINUS
68305: ST_TO_ADDR
// end else
68306: GO 68369
// begin d := - 1 ;
68308: LD_ADDR_VAR 0 9
68312: PUSH
68313: LD_INT 1
68315: NEG
68316: ST_TO_ADDR
// if i_from > i_to then
68317: LD_VAR 0 2
68321: PUSH
68322: LD_VAR 0 3
68326: GREATER
68327: IFFALSE 68347
// length := i_from - i_to else
68329: LD_ADDR_VAR 0 11
68333: PUSH
68334: LD_VAR 0 2
68338: PUSH
68339: LD_VAR 0 3
68343: MINUS
68344: ST_TO_ADDR
68345: GO 68369
// length := ( array - i_to ) + i_from ;
68347: LD_ADDR_VAR 0 11
68351: PUSH
68352: LD_VAR 0 1
68356: PUSH
68357: LD_VAR 0 3
68361: MINUS
68362: PUSH
68363: LD_VAR 0 2
68367: PLUS
68368: ST_TO_ADDR
// end ; if not length then
68369: LD_VAR 0 11
68373: NOT
68374: IFFALSE 68378
// exit ;
68376: GO 68536
// tmp := array ;
68378: LD_ADDR_VAR 0 10
68382: PUSH
68383: LD_VAR 0 1
68387: ST_TO_ADDR
// for i = 1 to length do
68388: LD_ADDR_VAR 0 6
68392: PUSH
68393: DOUBLE
68394: LD_INT 1
68396: DEC
68397: ST_TO_ADDR
68398: LD_VAR 0 11
68402: PUSH
68403: FOR_TO
68404: IFFALSE 68524
// begin for j = 1 to array do
68406: LD_ADDR_VAR 0 7
68410: PUSH
68411: DOUBLE
68412: LD_INT 1
68414: DEC
68415: ST_TO_ADDR
68416: LD_VAR 0 1
68420: PUSH
68421: FOR_TO
68422: IFFALSE 68510
// begin k := j + d ;
68424: LD_ADDR_VAR 0 8
68428: PUSH
68429: LD_VAR 0 7
68433: PUSH
68434: LD_VAR 0 9
68438: PLUS
68439: ST_TO_ADDR
// if k > array then
68440: LD_VAR 0 8
68444: PUSH
68445: LD_VAR 0 1
68449: GREATER
68450: IFFALSE 68460
// k := 1 ;
68452: LD_ADDR_VAR 0 8
68456: PUSH
68457: LD_INT 1
68459: ST_TO_ADDR
// if not k then
68460: LD_VAR 0 8
68464: NOT
68465: IFFALSE 68477
// k := array ;
68467: LD_ADDR_VAR 0 8
68471: PUSH
68472: LD_VAR 0 1
68476: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68477: LD_ADDR_VAR 0 10
68481: PUSH
68482: LD_VAR 0 10
68486: PPUSH
68487: LD_VAR 0 8
68491: PPUSH
68492: LD_VAR 0 1
68496: PUSH
68497: LD_VAR 0 7
68501: ARRAY
68502: PPUSH
68503: CALL_OW 1
68507: ST_TO_ADDR
// end ;
68508: GO 68421
68510: POP
68511: POP
// array := tmp ;
68512: LD_ADDR_VAR 0 1
68516: PUSH
68517: LD_VAR 0 10
68521: ST_TO_ADDR
// end ;
68522: GO 68403
68524: POP
68525: POP
// result := array ;
68526: LD_ADDR_VAR 0 5
68530: PUSH
68531: LD_VAR 0 1
68535: ST_TO_ADDR
// end ;
68536: LD_VAR 0 5
68540: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68541: LD_INT 0
68543: PPUSH
68544: PPUSH
// result := 0 ;
68545: LD_ADDR_VAR 0 3
68549: PUSH
68550: LD_INT 0
68552: ST_TO_ADDR
// if not array or not value in array then
68553: LD_VAR 0 1
68557: NOT
68558: PUSH
68559: LD_VAR 0 2
68563: PUSH
68564: LD_VAR 0 1
68568: IN
68569: NOT
68570: OR
68571: IFFALSE 68575
// exit ;
68573: GO 68629
// for i = 1 to array do
68575: LD_ADDR_VAR 0 4
68579: PUSH
68580: DOUBLE
68581: LD_INT 1
68583: DEC
68584: ST_TO_ADDR
68585: LD_VAR 0 1
68589: PUSH
68590: FOR_TO
68591: IFFALSE 68627
// if value = array [ i ] then
68593: LD_VAR 0 2
68597: PUSH
68598: LD_VAR 0 1
68602: PUSH
68603: LD_VAR 0 4
68607: ARRAY
68608: EQUAL
68609: IFFALSE 68625
// begin result := i ;
68611: LD_ADDR_VAR 0 3
68615: PUSH
68616: LD_VAR 0 4
68620: ST_TO_ADDR
// exit ;
68621: POP
68622: POP
68623: GO 68629
// end ;
68625: GO 68590
68627: POP
68628: POP
// end ;
68629: LD_VAR 0 3
68633: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68634: LD_INT 0
68636: PPUSH
// vc_chassis := chassis ;
68637: LD_ADDR_OWVAR 37
68641: PUSH
68642: LD_VAR 0 1
68646: ST_TO_ADDR
// vc_engine := engine ;
68647: LD_ADDR_OWVAR 39
68651: PUSH
68652: LD_VAR 0 2
68656: ST_TO_ADDR
// vc_control := control ;
68657: LD_ADDR_OWVAR 38
68661: PUSH
68662: LD_VAR 0 3
68666: ST_TO_ADDR
// vc_weapon := weapon ;
68667: LD_ADDR_OWVAR 40
68671: PUSH
68672: LD_VAR 0 4
68676: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68677: LD_ADDR_OWVAR 41
68681: PUSH
68682: LD_VAR 0 5
68686: ST_TO_ADDR
// end ;
68687: LD_VAR 0 6
68691: RET
// export function WantPlant ( unit ) ; var task ; begin
68692: LD_INT 0
68694: PPUSH
68695: PPUSH
// result := false ;
68696: LD_ADDR_VAR 0 2
68700: PUSH
68701: LD_INT 0
68703: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68704: LD_ADDR_VAR 0 3
68708: PUSH
68709: LD_VAR 0 1
68713: PPUSH
68714: CALL_OW 437
68718: ST_TO_ADDR
// if task then
68719: LD_VAR 0 3
68723: IFFALSE 68751
// if task [ 1 ] [ 1 ] = p then
68725: LD_VAR 0 3
68729: PUSH
68730: LD_INT 1
68732: ARRAY
68733: PUSH
68734: LD_INT 1
68736: ARRAY
68737: PUSH
68738: LD_STRING p
68740: EQUAL
68741: IFFALSE 68751
// result := true ;
68743: LD_ADDR_VAR 0 2
68747: PUSH
68748: LD_INT 1
68750: ST_TO_ADDR
// end ;
68751: LD_VAR 0 2
68755: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68756: LD_INT 0
68758: PPUSH
68759: PPUSH
68760: PPUSH
68761: PPUSH
// if pos < 1 then
68762: LD_VAR 0 2
68766: PUSH
68767: LD_INT 1
68769: LESS
68770: IFFALSE 68774
// exit ;
68772: GO 69077
// if pos = 1 then
68774: LD_VAR 0 2
68778: PUSH
68779: LD_INT 1
68781: EQUAL
68782: IFFALSE 68815
// result := Replace ( arr , pos [ 1 ] , value ) else
68784: LD_ADDR_VAR 0 4
68788: PUSH
68789: LD_VAR 0 1
68793: PPUSH
68794: LD_VAR 0 2
68798: PUSH
68799: LD_INT 1
68801: ARRAY
68802: PPUSH
68803: LD_VAR 0 3
68807: PPUSH
68808: CALL_OW 1
68812: ST_TO_ADDR
68813: GO 69077
// begin tmp := arr ;
68815: LD_ADDR_VAR 0 6
68819: PUSH
68820: LD_VAR 0 1
68824: ST_TO_ADDR
// s_arr := [ tmp ] ;
68825: LD_ADDR_VAR 0 7
68829: PUSH
68830: LD_VAR 0 6
68834: PUSH
68835: EMPTY
68836: LIST
68837: ST_TO_ADDR
// for i = 1 to pos - 1 do
68838: LD_ADDR_VAR 0 5
68842: PUSH
68843: DOUBLE
68844: LD_INT 1
68846: DEC
68847: ST_TO_ADDR
68848: LD_VAR 0 2
68852: PUSH
68853: LD_INT 1
68855: MINUS
68856: PUSH
68857: FOR_TO
68858: IFFALSE 68903
// begin tmp := tmp [ pos [ i ] ] ;
68860: LD_ADDR_VAR 0 6
68864: PUSH
68865: LD_VAR 0 6
68869: PUSH
68870: LD_VAR 0 2
68874: PUSH
68875: LD_VAR 0 5
68879: ARRAY
68880: ARRAY
68881: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68882: LD_ADDR_VAR 0 7
68886: PUSH
68887: LD_VAR 0 7
68891: PUSH
68892: LD_VAR 0 6
68896: PUSH
68897: EMPTY
68898: LIST
68899: ADD
68900: ST_TO_ADDR
// end ;
68901: GO 68857
68903: POP
68904: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68905: LD_ADDR_VAR 0 6
68909: PUSH
68910: LD_VAR 0 6
68914: PPUSH
68915: LD_VAR 0 2
68919: PUSH
68920: LD_VAR 0 2
68924: ARRAY
68925: PPUSH
68926: LD_VAR 0 3
68930: PPUSH
68931: CALL_OW 1
68935: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68936: LD_ADDR_VAR 0 7
68940: PUSH
68941: LD_VAR 0 7
68945: PPUSH
68946: LD_VAR 0 7
68950: PPUSH
68951: LD_VAR 0 6
68955: PPUSH
68956: CALL_OW 1
68960: ST_TO_ADDR
// for i = s_arr downto 2 do
68961: LD_ADDR_VAR 0 5
68965: PUSH
68966: DOUBLE
68967: LD_VAR 0 7
68971: INC
68972: ST_TO_ADDR
68973: LD_INT 2
68975: PUSH
68976: FOR_DOWNTO
68977: IFFALSE 69061
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68979: LD_ADDR_VAR 0 6
68983: PUSH
68984: LD_VAR 0 7
68988: PUSH
68989: LD_VAR 0 5
68993: PUSH
68994: LD_INT 1
68996: MINUS
68997: ARRAY
68998: PPUSH
68999: LD_VAR 0 2
69003: PUSH
69004: LD_VAR 0 5
69008: PUSH
69009: LD_INT 1
69011: MINUS
69012: ARRAY
69013: PPUSH
69014: LD_VAR 0 7
69018: PUSH
69019: LD_VAR 0 5
69023: ARRAY
69024: PPUSH
69025: CALL_OW 1
69029: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69030: LD_ADDR_VAR 0 7
69034: PUSH
69035: LD_VAR 0 7
69039: PPUSH
69040: LD_VAR 0 5
69044: PUSH
69045: LD_INT 1
69047: MINUS
69048: PPUSH
69049: LD_VAR 0 6
69053: PPUSH
69054: CALL_OW 1
69058: ST_TO_ADDR
// end ;
69059: GO 68976
69061: POP
69062: POP
// result := s_arr [ 1 ] ;
69063: LD_ADDR_VAR 0 4
69067: PUSH
69068: LD_VAR 0 7
69072: PUSH
69073: LD_INT 1
69075: ARRAY
69076: ST_TO_ADDR
// end ; end ;
69077: LD_VAR 0 4
69081: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
69082: LD_INT 0
69084: PPUSH
69085: PPUSH
// if not list then
69086: LD_VAR 0 1
69090: NOT
69091: IFFALSE 69095
// exit ;
69093: GO 69186
// i := list [ pos1 ] ;
69095: LD_ADDR_VAR 0 5
69099: PUSH
69100: LD_VAR 0 1
69104: PUSH
69105: LD_VAR 0 2
69109: ARRAY
69110: ST_TO_ADDR
// if not i then
69111: LD_VAR 0 5
69115: NOT
69116: IFFALSE 69120
// exit ;
69118: GO 69186
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
69120: LD_ADDR_VAR 0 1
69124: PUSH
69125: LD_VAR 0 1
69129: PPUSH
69130: LD_VAR 0 2
69134: PPUSH
69135: LD_VAR 0 1
69139: PUSH
69140: LD_VAR 0 3
69144: ARRAY
69145: PPUSH
69146: CALL_OW 1
69150: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
69151: LD_ADDR_VAR 0 1
69155: PUSH
69156: LD_VAR 0 1
69160: PPUSH
69161: LD_VAR 0 3
69165: PPUSH
69166: LD_VAR 0 5
69170: PPUSH
69171: CALL_OW 1
69175: ST_TO_ADDR
// result := list ;
69176: LD_ADDR_VAR 0 4
69180: PUSH
69181: LD_VAR 0 1
69185: ST_TO_ADDR
// end ;
69186: LD_VAR 0 4
69190: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
69191: LD_INT 0
69193: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
69194: LD_ADDR_VAR 0 5
69198: PUSH
69199: LD_VAR 0 1
69203: PPUSH
69204: CALL_OW 250
69208: PPUSH
69209: LD_VAR 0 1
69213: PPUSH
69214: CALL_OW 251
69218: PPUSH
69219: LD_VAR 0 2
69223: PPUSH
69224: LD_VAR 0 3
69228: PPUSH
69229: LD_VAR 0 4
69233: PPUSH
69234: CALL 69612 0 5
69238: ST_TO_ADDR
// end ;
69239: LD_VAR 0 5
69243: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
69244: LD_INT 0
69246: PPUSH
69247: PPUSH
69248: PPUSH
69249: PPUSH
// if not list or not unit then
69250: LD_VAR 0 2
69254: NOT
69255: PUSH
69256: LD_VAR 0 1
69260: NOT
69261: OR
69262: IFFALSE 69266
// exit ;
69264: GO 69607
// result := [ ] ;
69266: LD_ADDR_VAR 0 5
69270: PUSH
69271: EMPTY
69272: ST_TO_ADDR
// for i in list do
69273: LD_ADDR_VAR 0 6
69277: PUSH
69278: LD_VAR 0 2
69282: PUSH
69283: FOR_IN
69284: IFFALSE 69502
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
69286: LD_ADDR_VAR 0 8
69290: PUSH
69291: LD_VAR 0 1
69295: PPUSH
69296: LD_VAR 0 6
69300: PUSH
69301: LD_INT 1
69303: ARRAY
69304: PPUSH
69305: LD_VAR 0 6
69309: PUSH
69310: LD_INT 2
69312: ARRAY
69313: PPUSH
69314: CALL_OW 297
69318: ST_TO_ADDR
// if not Count ( result ) then
69319: LD_VAR 0 5
69323: PPUSH
69324: CALL 65896 0 1
69328: NOT
69329: IFFALSE 69362
// begin result := Join ( result , [ i , tmp ] ) ;
69331: LD_ADDR_VAR 0 5
69335: PUSH
69336: LD_VAR 0 5
69340: PPUSH
69341: LD_VAR 0 6
69345: PUSH
69346: LD_VAR 0 8
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PPUSH
69355: CALL 101496 0 2
69359: ST_TO_ADDR
// continue ;
69360: GO 69283
// end ; if result [ result ] [ 2 ] <= tmp then
69362: LD_VAR 0 5
69366: PUSH
69367: LD_VAR 0 5
69371: ARRAY
69372: PUSH
69373: LD_INT 2
69375: ARRAY
69376: PUSH
69377: LD_VAR 0 8
69381: LESSEQUAL
69382: IFFALSE 69415
// result := Join ( result , [ i , tmp ] ) else
69384: LD_ADDR_VAR 0 5
69388: PUSH
69389: LD_VAR 0 5
69393: PPUSH
69394: LD_VAR 0 6
69398: PUSH
69399: LD_VAR 0 8
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PPUSH
69408: CALL 101496 0 2
69412: ST_TO_ADDR
69413: GO 69500
// begin for j := 1 to Count ( result ) do
69415: LD_ADDR_VAR 0 7
69419: PUSH
69420: DOUBLE
69421: LD_INT 1
69423: DEC
69424: ST_TO_ADDR
69425: LD_VAR 0 5
69429: PPUSH
69430: CALL 65896 0 1
69434: PUSH
69435: FOR_TO
69436: IFFALSE 69498
// begin if tmp < result [ j ] [ 2 ] then
69438: LD_VAR 0 8
69442: PUSH
69443: LD_VAR 0 5
69447: PUSH
69448: LD_VAR 0 7
69452: ARRAY
69453: PUSH
69454: LD_INT 2
69456: ARRAY
69457: LESS
69458: IFFALSE 69496
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69460: LD_ADDR_VAR 0 5
69464: PUSH
69465: LD_VAR 0 5
69469: PPUSH
69470: LD_VAR 0 7
69474: PPUSH
69475: LD_VAR 0 6
69479: PUSH
69480: LD_VAR 0 8
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PPUSH
69489: CALL_OW 2
69493: ST_TO_ADDR
// break ;
69494: GO 69498
// end ; end ;
69496: GO 69435
69498: POP
69499: POP
// end ; end ;
69500: GO 69283
69502: POP
69503: POP
// if result and not asc then
69504: LD_VAR 0 5
69508: PUSH
69509: LD_VAR 0 3
69513: NOT
69514: AND
69515: IFFALSE 69532
// result := ReverseArray ( result ) ;
69517: LD_ADDR_VAR 0 5
69521: PUSH
69522: LD_VAR 0 5
69526: PPUSH
69527: CALL 96772 0 1
69531: ST_TO_ADDR
// tmp := [ ] ;
69532: LD_ADDR_VAR 0 8
69536: PUSH
69537: EMPTY
69538: ST_TO_ADDR
// if mode then
69539: LD_VAR 0 4
69543: IFFALSE 69607
// begin for i := 1 to result do
69545: LD_ADDR_VAR 0 6
69549: PUSH
69550: DOUBLE
69551: LD_INT 1
69553: DEC
69554: ST_TO_ADDR
69555: LD_VAR 0 5
69559: PUSH
69560: FOR_TO
69561: IFFALSE 69595
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
69563: LD_ADDR_VAR 0 8
69567: PUSH
69568: LD_VAR 0 8
69572: PPUSH
69573: LD_VAR 0 5
69577: PUSH
69578: LD_VAR 0 6
69582: ARRAY
69583: PUSH
69584: LD_INT 1
69586: ARRAY
69587: PPUSH
69588: CALL 101496 0 2
69592: ST_TO_ADDR
69593: GO 69560
69595: POP
69596: POP
// result := tmp ;
69597: LD_ADDR_VAR 0 5
69601: PUSH
69602: LD_VAR 0 8
69606: ST_TO_ADDR
// end ; end ;
69607: LD_VAR 0 5
69611: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
69612: LD_INT 0
69614: PPUSH
69615: PPUSH
69616: PPUSH
69617: PPUSH
// if not list then
69618: LD_VAR 0 3
69622: NOT
69623: IFFALSE 69627
// exit ;
69625: GO 70015
// result := [ ] ;
69627: LD_ADDR_VAR 0 6
69631: PUSH
69632: EMPTY
69633: ST_TO_ADDR
// for i in list do
69634: LD_ADDR_VAR 0 7
69638: PUSH
69639: LD_VAR 0 3
69643: PUSH
69644: FOR_IN
69645: IFFALSE 69847
// begin tmp := GetDistUnitXY ( i , x , y ) ;
69647: LD_ADDR_VAR 0 9
69651: PUSH
69652: LD_VAR 0 7
69656: PPUSH
69657: LD_VAR 0 1
69661: PPUSH
69662: LD_VAR 0 2
69666: PPUSH
69667: CALL_OW 297
69671: ST_TO_ADDR
// if not result then
69672: LD_VAR 0 6
69676: NOT
69677: IFFALSE 69703
// result := [ [ i , tmp ] ] else
69679: LD_ADDR_VAR 0 6
69683: PUSH
69684: LD_VAR 0 7
69688: PUSH
69689: LD_VAR 0 9
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: EMPTY
69699: LIST
69700: ST_TO_ADDR
69701: GO 69845
// begin if result [ result ] [ 2 ] < tmp then
69703: LD_VAR 0 6
69707: PUSH
69708: LD_VAR 0 6
69712: ARRAY
69713: PUSH
69714: LD_INT 2
69716: ARRAY
69717: PUSH
69718: LD_VAR 0 9
69722: LESS
69723: IFFALSE 69765
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69725: LD_ADDR_VAR 0 6
69729: PUSH
69730: LD_VAR 0 6
69734: PPUSH
69735: LD_VAR 0 6
69739: PUSH
69740: LD_INT 1
69742: PLUS
69743: PPUSH
69744: LD_VAR 0 7
69748: PUSH
69749: LD_VAR 0 9
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PPUSH
69758: CALL_OW 2
69762: ST_TO_ADDR
69763: GO 69845
// for j = 1 to result do
69765: LD_ADDR_VAR 0 8
69769: PUSH
69770: DOUBLE
69771: LD_INT 1
69773: DEC
69774: ST_TO_ADDR
69775: LD_VAR 0 6
69779: PUSH
69780: FOR_TO
69781: IFFALSE 69843
// begin if tmp < result [ j ] [ 2 ] then
69783: LD_VAR 0 9
69787: PUSH
69788: LD_VAR 0 6
69792: PUSH
69793: LD_VAR 0 8
69797: ARRAY
69798: PUSH
69799: LD_INT 2
69801: ARRAY
69802: LESS
69803: IFFALSE 69841
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69805: LD_ADDR_VAR 0 6
69809: PUSH
69810: LD_VAR 0 6
69814: PPUSH
69815: LD_VAR 0 8
69819: PPUSH
69820: LD_VAR 0 7
69824: PUSH
69825: LD_VAR 0 9
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PPUSH
69834: CALL_OW 2
69838: ST_TO_ADDR
// break ;
69839: GO 69843
// end ; end ;
69841: GO 69780
69843: POP
69844: POP
// end ; end ;
69845: GO 69644
69847: POP
69848: POP
// if result and not asc then
69849: LD_VAR 0 6
69853: PUSH
69854: LD_VAR 0 4
69858: NOT
69859: AND
69860: IFFALSE 69935
// begin tmp := result ;
69862: LD_ADDR_VAR 0 9
69866: PUSH
69867: LD_VAR 0 6
69871: ST_TO_ADDR
// for i = tmp downto 1 do
69872: LD_ADDR_VAR 0 7
69876: PUSH
69877: DOUBLE
69878: LD_VAR 0 9
69882: INC
69883: ST_TO_ADDR
69884: LD_INT 1
69886: PUSH
69887: FOR_DOWNTO
69888: IFFALSE 69933
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69890: LD_ADDR_VAR 0 6
69894: PUSH
69895: LD_VAR 0 6
69899: PPUSH
69900: LD_VAR 0 9
69904: PUSH
69905: LD_VAR 0 7
69909: MINUS
69910: PUSH
69911: LD_INT 1
69913: PLUS
69914: PPUSH
69915: LD_VAR 0 9
69919: PUSH
69920: LD_VAR 0 7
69924: ARRAY
69925: PPUSH
69926: CALL_OW 1
69930: ST_TO_ADDR
69931: GO 69887
69933: POP
69934: POP
// end ; tmp := [ ] ;
69935: LD_ADDR_VAR 0 9
69939: PUSH
69940: EMPTY
69941: ST_TO_ADDR
// if mode then
69942: LD_VAR 0 5
69946: IFFALSE 70015
// begin for i = 1 to result do
69948: LD_ADDR_VAR 0 7
69952: PUSH
69953: DOUBLE
69954: LD_INT 1
69956: DEC
69957: ST_TO_ADDR
69958: LD_VAR 0 6
69962: PUSH
69963: FOR_TO
69964: IFFALSE 70003
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69966: LD_ADDR_VAR 0 9
69970: PUSH
69971: LD_VAR 0 9
69975: PPUSH
69976: LD_VAR 0 7
69980: PPUSH
69981: LD_VAR 0 6
69985: PUSH
69986: LD_VAR 0 7
69990: ARRAY
69991: PUSH
69992: LD_INT 1
69994: ARRAY
69995: PPUSH
69996: CALL_OW 1
70000: ST_TO_ADDR
70001: GO 69963
70003: POP
70004: POP
// result := tmp ;
70005: LD_ADDR_VAR 0 6
70009: PUSH
70010: LD_VAR 0 9
70014: ST_TO_ADDR
// end ; end ;
70015: LD_VAR 0 6
70019: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70020: LD_INT 0
70022: PPUSH
70023: PPUSH
70024: PPUSH
70025: PPUSH
70026: PPUSH
70027: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70028: LD_ADDR_VAR 0 5
70032: PUSH
70033: LD_INT 0
70035: PUSH
70036: LD_INT 0
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: EMPTY
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: ST_TO_ADDR
// if not x or not y then
70050: LD_VAR 0 2
70054: NOT
70055: PUSH
70056: LD_VAR 0 3
70060: NOT
70061: OR
70062: IFFALSE 70066
// exit ;
70064: GO 71716
// if not range then
70066: LD_VAR 0 4
70070: NOT
70071: IFFALSE 70081
// range := 10 ;
70073: LD_ADDR_VAR 0 4
70077: PUSH
70078: LD_INT 10
70080: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70081: LD_ADDR_VAR 0 8
70085: PUSH
70086: LD_INT 81
70088: PUSH
70089: LD_VAR 0 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 92
70100: PUSH
70101: LD_VAR 0 2
70105: PUSH
70106: LD_VAR 0 3
70110: PUSH
70111: LD_VAR 0 4
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 3
70124: PUSH
70125: LD_INT 21
70127: PUSH
70128: LD_INT 3
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: LIST
70143: PPUSH
70144: CALL_OW 69
70148: ST_TO_ADDR
// if not tmp then
70149: LD_VAR 0 8
70153: NOT
70154: IFFALSE 70158
// exit ;
70156: GO 71716
// for i in tmp do
70158: LD_ADDR_VAR 0 6
70162: PUSH
70163: LD_VAR 0 8
70167: PUSH
70168: FOR_IN
70169: IFFALSE 71691
// begin points := [ 0 , 0 , 0 ] ;
70171: LD_ADDR_VAR 0 9
70175: PUSH
70176: LD_INT 0
70178: PUSH
70179: LD_INT 0
70181: PUSH
70182: LD_INT 0
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: LIST
70189: ST_TO_ADDR
// bpoints := 1 ;
70190: LD_ADDR_VAR 0 10
70194: PUSH
70195: LD_INT 1
70197: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70198: LD_VAR 0 6
70202: PPUSH
70203: CALL_OW 247
70207: PUSH
70208: LD_INT 1
70210: DOUBLE
70211: EQUAL
70212: IFTRUE 70216
70214: GO 70794
70216: POP
// begin if GetClass ( i ) = 1 then
70217: LD_VAR 0 6
70221: PPUSH
70222: CALL_OW 257
70226: PUSH
70227: LD_INT 1
70229: EQUAL
70230: IFFALSE 70251
// points := [ 10 , 5 , 3 ] ;
70232: LD_ADDR_VAR 0 9
70236: PUSH
70237: LD_INT 10
70239: PUSH
70240: LD_INT 5
70242: PUSH
70243: LD_INT 3
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: LIST
70250: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70251: LD_VAR 0 6
70255: PPUSH
70256: CALL_OW 257
70260: PUSH
70261: LD_INT 2
70263: PUSH
70264: LD_INT 3
70266: PUSH
70267: LD_INT 4
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: LIST
70274: IN
70275: IFFALSE 70296
// points := [ 3 , 2 , 1 ] ;
70277: LD_ADDR_VAR 0 9
70281: PUSH
70282: LD_INT 3
70284: PUSH
70285: LD_INT 2
70287: PUSH
70288: LD_INT 1
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: LIST
70295: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70296: LD_VAR 0 6
70300: PPUSH
70301: CALL_OW 257
70305: PUSH
70306: LD_INT 5
70308: EQUAL
70309: IFFALSE 70330
// points := [ 130 , 5 , 2 ] ;
70311: LD_ADDR_VAR 0 9
70315: PUSH
70316: LD_INT 130
70318: PUSH
70319: LD_INT 5
70321: PUSH
70322: LD_INT 2
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: LIST
70329: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70330: LD_VAR 0 6
70334: PPUSH
70335: CALL_OW 257
70339: PUSH
70340: LD_INT 8
70342: EQUAL
70343: IFFALSE 70364
// points := [ 35 , 35 , 30 ] ;
70345: LD_ADDR_VAR 0 9
70349: PUSH
70350: LD_INT 35
70352: PUSH
70353: LD_INT 35
70355: PUSH
70356: LD_INT 30
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: LIST
70363: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70364: LD_VAR 0 6
70368: PPUSH
70369: CALL_OW 257
70373: PUSH
70374: LD_INT 9
70376: EQUAL
70377: IFFALSE 70398
// points := [ 20 , 55 , 40 ] ;
70379: LD_ADDR_VAR 0 9
70383: PUSH
70384: LD_INT 20
70386: PUSH
70387: LD_INT 55
70389: PUSH
70390: LD_INT 40
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: LIST
70397: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70398: LD_VAR 0 6
70402: PPUSH
70403: CALL_OW 257
70407: PUSH
70408: LD_INT 12
70410: PUSH
70411: LD_INT 16
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: IN
70418: IFFALSE 70439
// points := [ 5 , 3 , 2 ] ;
70420: LD_ADDR_VAR 0 9
70424: PUSH
70425: LD_INT 5
70427: PUSH
70428: LD_INT 3
70430: PUSH
70431: LD_INT 2
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: LIST
70438: ST_TO_ADDR
// if GetClass ( i ) = 17 then
70439: LD_VAR 0 6
70443: PPUSH
70444: CALL_OW 257
70448: PUSH
70449: LD_INT 17
70451: EQUAL
70452: IFFALSE 70473
// points := [ 100 , 50 , 75 ] ;
70454: LD_ADDR_VAR 0 9
70458: PUSH
70459: LD_INT 100
70461: PUSH
70462: LD_INT 50
70464: PUSH
70465: LD_INT 75
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: LIST
70472: ST_TO_ADDR
// if GetClass ( i ) = 15 then
70473: LD_VAR 0 6
70477: PPUSH
70478: CALL_OW 257
70482: PUSH
70483: LD_INT 15
70485: EQUAL
70486: IFFALSE 70507
// points := [ 10 , 5 , 3 ] ;
70488: LD_ADDR_VAR 0 9
70492: PUSH
70493: LD_INT 10
70495: PUSH
70496: LD_INT 5
70498: PUSH
70499: LD_INT 3
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: LIST
70506: ST_TO_ADDR
// if GetClass ( i ) = 14 then
70507: LD_VAR 0 6
70511: PPUSH
70512: CALL_OW 257
70516: PUSH
70517: LD_INT 14
70519: EQUAL
70520: IFFALSE 70541
// points := [ 10 , 0 , 0 ] ;
70522: LD_ADDR_VAR 0 9
70526: PUSH
70527: LD_INT 10
70529: PUSH
70530: LD_INT 0
70532: PUSH
70533: LD_INT 0
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: LIST
70540: ST_TO_ADDR
// if GetClass ( i ) = 11 then
70541: LD_VAR 0 6
70545: PPUSH
70546: CALL_OW 257
70550: PUSH
70551: LD_INT 11
70553: EQUAL
70554: IFFALSE 70575
// points := [ 30 , 10 , 5 ] ;
70556: LD_ADDR_VAR 0 9
70560: PUSH
70561: LD_INT 30
70563: PUSH
70564: LD_INT 10
70566: PUSH
70567: LD_INT 5
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: LIST
70574: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
70575: LD_VAR 0 1
70579: PPUSH
70580: LD_INT 5
70582: PPUSH
70583: CALL_OW 321
70587: PUSH
70588: LD_INT 2
70590: EQUAL
70591: IFFALSE 70608
// bpoints := bpoints * 1.8 ;
70593: LD_ADDR_VAR 0 10
70597: PUSH
70598: LD_VAR 0 10
70602: PUSH
70603: LD_REAL  1.80000000000000E+0000
70606: MUL
70607: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
70608: LD_VAR 0 6
70612: PPUSH
70613: CALL_OW 257
70617: PUSH
70618: LD_INT 1
70620: PUSH
70621: LD_INT 2
70623: PUSH
70624: LD_INT 3
70626: PUSH
70627: LD_INT 4
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: IN
70636: PUSH
70637: LD_VAR 0 1
70641: PPUSH
70642: LD_INT 51
70644: PPUSH
70645: CALL_OW 321
70649: PUSH
70650: LD_INT 2
70652: EQUAL
70653: AND
70654: IFFALSE 70671
// bpoints := bpoints * 1.2 ;
70656: LD_ADDR_VAR 0 10
70660: PUSH
70661: LD_VAR 0 10
70665: PUSH
70666: LD_REAL  1.20000000000000E+0000
70669: MUL
70670: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
70671: LD_VAR 0 6
70675: PPUSH
70676: CALL_OW 257
70680: PUSH
70681: LD_INT 5
70683: PUSH
70684: LD_INT 7
70686: PUSH
70687: LD_INT 9
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: LIST
70694: IN
70695: PUSH
70696: LD_VAR 0 1
70700: PPUSH
70701: LD_INT 52
70703: PPUSH
70704: CALL_OW 321
70708: PUSH
70709: LD_INT 2
70711: EQUAL
70712: AND
70713: IFFALSE 70730
// bpoints := bpoints * 1.5 ;
70715: LD_ADDR_VAR 0 10
70719: PUSH
70720: LD_VAR 0 10
70724: PUSH
70725: LD_REAL  1.50000000000000E+0000
70728: MUL
70729: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70730: LD_VAR 0 1
70734: PPUSH
70735: LD_INT 66
70737: PPUSH
70738: CALL_OW 321
70742: PUSH
70743: LD_INT 2
70745: EQUAL
70746: IFFALSE 70763
// bpoints := bpoints * 1.1 ;
70748: LD_ADDR_VAR 0 10
70752: PUSH
70753: LD_VAR 0 10
70757: PUSH
70758: LD_REAL  1.10000000000000E+0000
70761: MUL
70762: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70763: LD_ADDR_VAR 0 10
70767: PUSH
70768: LD_VAR 0 10
70772: PUSH
70773: LD_VAR 0 6
70777: PPUSH
70778: LD_INT 1
70780: PPUSH
70781: CALL_OW 259
70785: PUSH
70786: LD_REAL  1.15000000000000E+0000
70789: MUL
70790: MUL
70791: ST_TO_ADDR
// end ; unit_vehicle :
70792: GO 71620
70794: LD_INT 2
70796: DOUBLE
70797: EQUAL
70798: IFTRUE 70802
70800: GO 71608
70802: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70803: LD_VAR 0 6
70807: PPUSH
70808: CALL_OW 264
70812: PUSH
70813: LD_INT 2
70815: PUSH
70816: LD_INT 42
70818: PUSH
70819: LD_INT 24
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: LIST
70826: IN
70827: IFFALSE 70848
// points := [ 25 , 5 , 3 ] ;
70829: LD_ADDR_VAR 0 9
70833: PUSH
70834: LD_INT 25
70836: PUSH
70837: LD_INT 5
70839: PUSH
70840: LD_INT 3
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: LIST
70847: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70848: LD_VAR 0 6
70852: PPUSH
70853: CALL_OW 264
70857: PUSH
70858: LD_INT 4
70860: PUSH
70861: LD_INT 43
70863: PUSH
70864: LD_INT 25
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: LIST
70871: IN
70872: IFFALSE 70893
// points := [ 40 , 15 , 5 ] ;
70874: LD_ADDR_VAR 0 9
70878: PUSH
70879: LD_INT 40
70881: PUSH
70882: LD_INT 15
70884: PUSH
70885: LD_INT 5
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: LIST
70892: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70893: LD_VAR 0 6
70897: PPUSH
70898: CALL_OW 264
70902: PUSH
70903: LD_INT 3
70905: PUSH
70906: LD_INT 23
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: IN
70913: IFFALSE 70934
// points := [ 7 , 25 , 8 ] ;
70915: LD_ADDR_VAR 0 9
70919: PUSH
70920: LD_INT 7
70922: PUSH
70923: LD_INT 25
70925: PUSH
70926: LD_INT 8
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: LIST
70933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70934: LD_VAR 0 6
70938: PPUSH
70939: CALL_OW 264
70943: PUSH
70944: LD_INT 5
70946: PUSH
70947: LD_INT 27
70949: PUSH
70950: LD_INT 44
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: LIST
70957: IN
70958: IFFALSE 70979
// points := [ 14 , 50 , 16 ] ;
70960: LD_ADDR_VAR 0 9
70964: PUSH
70965: LD_INT 14
70967: PUSH
70968: LD_INT 50
70970: PUSH
70971: LD_INT 16
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: LIST
70978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70979: LD_VAR 0 6
70983: PPUSH
70984: CALL_OW 264
70988: PUSH
70989: LD_INT 6
70991: PUSH
70992: LD_INT 46
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: IN
70999: IFFALSE 71020
// points := [ 32 , 120 , 70 ] ;
71001: LD_ADDR_VAR 0 9
71005: PUSH
71006: LD_INT 32
71008: PUSH
71009: LD_INT 120
71011: PUSH
71012: LD_INT 70
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: LIST
71019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
71020: LD_VAR 0 6
71024: PPUSH
71025: CALL_OW 264
71029: PUSH
71030: LD_INT 7
71032: PUSH
71033: LD_INT 28
71035: PUSH
71036: LD_INT 45
71038: PUSH
71039: LD_INT 92
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: IN
71048: IFFALSE 71069
// points := [ 35 , 20 , 45 ] ;
71050: LD_ADDR_VAR 0 9
71054: PUSH
71055: LD_INT 35
71057: PUSH
71058: LD_INT 20
71060: PUSH
71061: LD_INT 45
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: LIST
71068: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71069: LD_VAR 0 6
71073: PPUSH
71074: CALL_OW 264
71078: PUSH
71079: LD_INT 47
71081: PUSH
71082: EMPTY
71083: LIST
71084: IN
71085: IFFALSE 71106
// points := [ 67 , 45 , 75 ] ;
71087: LD_ADDR_VAR 0 9
71091: PUSH
71092: LD_INT 67
71094: PUSH
71095: LD_INT 45
71097: PUSH
71098: LD_INT 75
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: LIST
71105: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71106: LD_VAR 0 6
71110: PPUSH
71111: CALL_OW 264
71115: PUSH
71116: LD_INT 26
71118: PUSH
71119: EMPTY
71120: LIST
71121: IN
71122: IFFALSE 71143
// points := [ 120 , 30 , 80 ] ;
71124: LD_ADDR_VAR 0 9
71128: PUSH
71129: LD_INT 120
71131: PUSH
71132: LD_INT 30
71134: PUSH
71135: LD_INT 80
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: LIST
71142: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71143: LD_VAR 0 6
71147: PPUSH
71148: CALL_OW 264
71152: PUSH
71153: LD_INT 22
71155: PUSH
71156: EMPTY
71157: LIST
71158: IN
71159: IFFALSE 71180
// points := [ 40 , 1 , 1 ] ;
71161: LD_ADDR_VAR 0 9
71165: PUSH
71166: LD_INT 40
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 1
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: LIST
71179: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71180: LD_VAR 0 6
71184: PPUSH
71185: CALL_OW 264
71189: PUSH
71190: LD_INT 29
71192: PUSH
71193: EMPTY
71194: LIST
71195: IN
71196: IFFALSE 71217
// points := [ 70 , 200 , 400 ] ;
71198: LD_ADDR_VAR 0 9
71202: PUSH
71203: LD_INT 70
71205: PUSH
71206: LD_INT 200
71208: PUSH
71209: LD_INT 400
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: LIST
71216: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71217: LD_VAR 0 6
71221: PPUSH
71222: CALL_OW 264
71226: PUSH
71227: LD_INT 14
71229: PUSH
71230: LD_INT 53
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: IN
71237: IFFALSE 71258
// points := [ 40 , 10 , 20 ] ;
71239: LD_ADDR_VAR 0 9
71243: PUSH
71244: LD_INT 40
71246: PUSH
71247: LD_INT 10
71249: PUSH
71250: LD_INT 20
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: LIST
71257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71258: LD_VAR 0 6
71262: PPUSH
71263: CALL_OW 264
71267: PUSH
71268: LD_INT 9
71270: PUSH
71271: EMPTY
71272: LIST
71273: IN
71274: IFFALSE 71295
// points := [ 5 , 70 , 20 ] ;
71276: LD_ADDR_VAR 0 9
71280: PUSH
71281: LD_INT 5
71283: PUSH
71284: LD_INT 70
71286: PUSH
71287: LD_INT 20
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: LIST
71294: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71295: LD_VAR 0 6
71299: PPUSH
71300: CALL_OW 264
71304: PUSH
71305: LD_INT 10
71307: PUSH
71308: EMPTY
71309: LIST
71310: IN
71311: IFFALSE 71332
// points := [ 35 , 110 , 70 ] ;
71313: LD_ADDR_VAR 0 9
71317: PUSH
71318: LD_INT 35
71320: PUSH
71321: LD_INT 110
71323: PUSH
71324: LD_INT 70
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: LIST
71331: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71332: LD_VAR 0 6
71336: PPUSH
71337: CALL_OW 265
71341: PUSH
71342: LD_INT 25
71344: EQUAL
71345: IFFALSE 71366
// points := [ 80 , 65 , 100 ] ;
71347: LD_ADDR_VAR 0 9
71351: PUSH
71352: LD_INT 80
71354: PUSH
71355: LD_INT 65
71357: PUSH
71358: LD_INT 100
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: LIST
71365: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71366: LD_VAR 0 6
71370: PPUSH
71371: CALL_OW 263
71375: PUSH
71376: LD_INT 1
71378: EQUAL
71379: IFFALSE 71414
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71381: LD_ADDR_VAR 0 10
71385: PUSH
71386: LD_VAR 0 10
71390: PUSH
71391: LD_VAR 0 6
71395: PPUSH
71396: CALL_OW 311
71400: PPUSH
71401: LD_INT 3
71403: PPUSH
71404: CALL_OW 259
71408: PUSH
71409: LD_INT 4
71411: MUL
71412: MUL
71413: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71414: LD_VAR 0 6
71418: PPUSH
71419: CALL_OW 263
71423: PUSH
71424: LD_INT 2
71426: EQUAL
71427: IFFALSE 71478
// begin j := IsControledBy ( i ) ;
71429: LD_ADDR_VAR 0 7
71433: PUSH
71434: LD_VAR 0 6
71438: PPUSH
71439: CALL_OW 312
71443: ST_TO_ADDR
// if j then
71444: LD_VAR 0 7
71448: IFFALSE 71478
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
71450: LD_ADDR_VAR 0 10
71454: PUSH
71455: LD_VAR 0 10
71459: PUSH
71460: LD_VAR 0 7
71464: PPUSH
71465: LD_INT 3
71467: PPUSH
71468: CALL_OW 259
71472: PUSH
71473: LD_INT 3
71475: MUL
71476: MUL
71477: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
71478: LD_VAR 0 6
71482: PPUSH
71483: CALL_OW 264
71487: PUSH
71488: LD_INT 5
71490: PUSH
71491: LD_INT 6
71493: PUSH
71494: LD_INT 46
71496: PUSH
71497: LD_INT 44
71499: PUSH
71500: LD_INT 47
71502: PUSH
71503: LD_INT 45
71505: PUSH
71506: LD_INT 28
71508: PUSH
71509: LD_INT 7
71511: PUSH
71512: LD_INT 27
71514: PUSH
71515: LD_INT 29
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: LIST
71529: IN
71530: PUSH
71531: LD_VAR 0 1
71535: PPUSH
71536: LD_INT 52
71538: PPUSH
71539: CALL_OW 321
71543: PUSH
71544: LD_INT 2
71546: EQUAL
71547: AND
71548: IFFALSE 71565
// bpoints := bpoints * 1.2 ;
71550: LD_ADDR_VAR 0 10
71554: PUSH
71555: LD_VAR 0 10
71559: PUSH
71560: LD_REAL  1.20000000000000E+0000
71563: MUL
71564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
71565: LD_VAR 0 6
71569: PPUSH
71570: CALL_OW 264
71574: PUSH
71575: LD_INT 6
71577: PUSH
71578: LD_INT 46
71580: PUSH
71581: LD_INT 47
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: LIST
71588: IN
71589: IFFALSE 71606
// bpoints := bpoints * 1.2 ;
71591: LD_ADDR_VAR 0 10
71595: PUSH
71596: LD_VAR 0 10
71600: PUSH
71601: LD_REAL  1.20000000000000E+0000
71604: MUL
71605: ST_TO_ADDR
// end ; unit_building :
71606: GO 71620
71608: LD_INT 3
71610: DOUBLE
71611: EQUAL
71612: IFTRUE 71616
71614: GO 71619
71616: POP
// ; end ;
71617: GO 71620
71619: POP
// for j = 1 to 3 do
71620: LD_ADDR_VAR 0 7
71624: PUSH
71625: DOUBLE
71626: LD_INT 1
71628: DEC
71629: ST_TO_ADDR
71630: LD_INT 3
71632: PUSH
71633: FOR_TO
71634: IFFALSE 71687
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
71636: LD_ADDR_VAR 0 5
71640: PUSH
71641: LD_VAR 0 5
71645: PPUSH
71646: LD_VAR 0 7
71650: PPUSH
71651: LD_VAR 0 5
71655: PUSH
71656: LD_VAR 0 7
71660: ARRAY
71661: PUSH
71662: LD_VAR 0 9
71666: PUSH
71667: LD_VAR 0 7
71671: ARRAY
71672: PUSH
71673: LD_VAR 0 10
71677: MUL
71678: PLUS
71679: PPUSH
71680: CALL_OW 1
71684: ST_TO_ADDR
71685: GO 71633
71687: POP
71688: POP
// end ;
71689: GO 70168
71691: POP
71692: POP
// result := Replace ( result , 4 , tmp ) ;
71693: LD_ADDR_VAR 0 5
71697: PUSH
71698: LD_VAR 0 5
71702: PPUSH
71703: LD_INT 4
71705: PPUSH
71706: LD_VAR 0 8
71710: PPUSH
71711: CALL_OW 1
71715: ST_TO_ADDR
// end ;
71716: LD_VAR 0 5
71720: RET
// export function DangerAtRange ( unit , range ) ; begin
71721: LD_INT 0
71723: PPUSH
// if not unit then
71724: LD_VAR 0 1
71728: NOT
71729: IFFALSE 71733
// exit ;
71731: GO 71778
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71733: LD_ADDR_VAR 0 3
71737: PUSH
71738: LD_VAR 0 1
71742: PPUSH
71743: CALL_OW 255
71747: PPUSH
71748: LD_VAR 0 1
71752: PPUSH
71753: CALL_OW 250
71757: PPUSH
71758: LD_VAR 0 1
71762: PPUSH
71763: CALL_OW 251
71767: PPUSH
71768: LD_VAR 0 2
71772: PPUSH
71773: CALL 70020 0 4
71777: ST_TO_ADDR
// end ;
71778: LD_VAR 0 3
71782: RET
// export function DangerInArea ( side , area ) ; begin
71783: LD_INT 0
71785: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71786: LD_ADDR_VAR 0 3
71790: PUSH
71791: LD_VAR 0 2
71795: PPUSH
71796: LD_INT 81
71798: PUSH
71799: LD_VAR 0 1
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PPUSH
71808: CALL_OW 70
71812: ST_TO_ADDR
// end ;
71813: LD_VAR 0 3
71817: RET
// export function IsExtension ( b ) ; begin
71818: LD_INT 0
71820: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71821: LD_ADDR_VAR 0 2
71825: PUSH
71826: LD_VAR 0 1
71830: PUSH
71831: LD_INT 23
71833: PUSH
71834: LD_INT 20
71836: PUSH
71837: LD_INT 22
71839: PUSH
71840: LD_INT 17
71842: PUSH
71843: LD_INT 24
71845: PUSH
71846: LD_INT 21
71848: PUSH
71849: LD_INT 19
71851: PUSH
71852: LD_INT 16
71854: PUSH
71855: LD_INT 25
71857: PUSH
71858: LD_INT 18
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: IN
71873: ST_TO_ADDR
// end ;
71874: LD_VAR 0 2
71878: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71879: LD_INT 0
71881: PPUSH
71882: PPUSH
71883: PPUSH
// result := [ ] ;
71884: LD_ADDR_VAR 0 4
71888: PUSH
71889: EMPTY
71890: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71891: LD_ADDR_VAR 0 5
71895: PUSH
71896: LD_VAR 0 2
71900: PPUSH
71901: LD_INT 21
71903: PUSH
71904: LD_INT 3
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PPUSH
71911: CALL_OW 70
71915: ST_TO_ADDR
// if not tmp then
71916: LD_VAR 0 5
71920: NOT
71921: IFFALSE 71925
// exit ;
71923: GO 71989
// if checkLink then
71925: LD_VAR 0 3
71929: IFFALSE 71979
// begin for i in tmp do
71931: LD_ADDR_VAR 0 6
71935: PUSH
71936: LD_VAR 0 5
71940: PUSH
71941: FOR_IN
71942: IFFALSE 71977
// if GetBase ( i ) <> base then
71944: LD_VAR 0 6
71948: PPUSH
71949: CALL_OW 274
71953: PUSH
71954: LD_VAR 0 1
71958: NONEQUAL
71959: IFFALSE 71975
// ComLinkToBase ( base , i ) ;
71961: LD_VAR 0 1
71965: PPUSH
71966: LD_VAR 0 6
71970: PPUSH
71971: CALL_OW 169
71975: GO 71941
71977: POP
71978: POP
// end ; result := tmp ;
71979: LD_ADDR_VAR 0 4
71983: PUSH
71984: LD_VAR 0 5
71988: ST_TO_ADDR
// end ;
71989: LD_VAR 0 4
71993: RET
// export function ComComplete ( units , b ) ; var i ; begin
71994: LD_INT 0
71996: PPUSH
71997: PPUSH
// if not units then
71998: LD_VAR 0 1
72002: NOT
72003: IFFALSE 72007
// exit ;
72005: GO 72097
// for i in units do
72007: LD_ADDR_VAR 0 4
72011: PUSH
72012: LD_VAR 0 1
72016: PUSH
72017: FOR_IN
72018: IFFALSE 72095
// if BuildingStatus ( b ) = bs_build then
72020: LD_VAR 0 2
72024: PPUSH
72025: CALL_OW 461
72029: PUSH
72030: LD_INT 1
72032: EQUAL
72033: IFFALSE 72093
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72035: LD_VAR 0 4
72039: PPUSH
72040: LD_STRING h
72042: PUSH
72043: LD_VAR 0 2
72047: PPUSH
72048: CALL_OW 250
72052: PUSH
72053: LD_VAR 0 2
72057: PPUSH
72058: CALL_OW 251
72062: PUSH
72063: LD_VAR 0 2
72067: PUSH
72068: LD_INT 0
72070: PUSH
72071: LD_INT 0
72073: PUSH
72074: LD_INT 0
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: PUSH
72086: EMPTY
72087: LIST
72088: PPUSH
72089: CALL_OW 446
72093: GO 72017
72095: POP
72096: POP
// end ;
72097: LD_VAR 0 3
72101: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72102: LD_INT 0
72104: PPUSH
72105: PPUSH
72106: PPUSH
72107: PPUSH
72108: PPUSH
72109: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
72110: LD_VAR 0 1
72114: NOT
72115: PUSH
72116: LD_VAR 0 1
72120: PPUSH
72121: CALL_OW 263
72125: PUSH
72126: LD_INT 2
72128: NONEQUAL
72129: OR
72130: IFFALSE 72134
// exit ;
72132: GO 72450
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72134: LD_ADDR_VAR 0 6
72138: PUSH
72139: LD_INT 22
72141: PUSH
72142: LD_VAR 0 1
72146: PPUSH
72147: CALL_OW 255
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 2
72158: PUSH
72159: LD_INT 30
72161: PUSH
72162: LD_INT 36
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 34
72171: PUSH
72172: LD_INT 31
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: LIST
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PPUSH
72188: CALL_OW 69
72192: ST_TO_ADDR
// if not tmp then
72193: LD_VAR 0 6
72197: NOT
72198: IFFALSE 72202
// exit ;
72200: GO 72450
// result := [ ] ;
72202: LD_ADDR_VAR 0 2
72206: PUSH
72207: EMPTY
72208: ST_TO_ADDR
// for i in tmp do
72209: LD_ADDR_VAR 0 3
72213: PUSH
72214: LD_VAR 0 6
72218: PUSH
72219: FOR_IN
72220: IFFALSE 72291
// begin t := UnitsInside ( i ) ;
72222: LD_ADDR_VAR 0 4
72226: PUSH
72227: LD_VAR 0 3
72231: PPUSH
72232: CALL_OW 313
72236: ST_TO_ADDR
// if t then
72237: LD_VAR 0 4
72241: IFFALSE 72289
// for j in t do
72243: LD_ADDR_VAR 0 7
72247: PUSH
72248: LD_VAR 0 4
72252: PUSH
72253: FOR_IN
72254: IFFALSE 72287
// result := Replace ( result , result + 1 , j ) ;
72256: LD_ADDR_VAR 0 2
72260: PUSH
72261: LD_VAR 0 2
72265: PPUSH
72266: LD_VAR 0 2
72270: PUSH
72271: LD_INT 1
72273: PLUS
72274: PPUSH
72275: LD_VAR 0 7
72279: PPUSH
72280: CALL_OW 1
72284: ST_TO_ADDR
72285: GO 72253
72287: POP
72288: POP
// end ;
72289: GO 72219
72291: POP
72292: POP
// if not result then
72293: LD_VAR 0 2
72297: NOT
72298: IFFALSE 72302
// exit ;
72300: GO 72450
// mech := result [ 1 ] ;
72302: LD_ADDR_VAR 0 5
72306: PUSH
72307: LD_VAR 0 2
72311: PUSH
72312: LD_INT 1
72314: ARRAY
72315: ST_TO_ADDR
// if result > 1 then
72316: LD_VAR 0 2
72320: PUSH
72321: LD_INT 1
72323: GREATER
72324: IFFALSE 72436
// begin for i = 2 to result do
72326: LD_ADDR_VAR 0 3
72330: PUSH
72331: DOUBLE
72332: LD_INT 2
72334: DEC
72335: ST_TO_ADDR
72336: LD_VAR 0 2
72340: PUSH
72341: FOR_TO
72342: IFFALSE 72434
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72344: LD_ADDR_VAR 0 4
72348: PUSH
72349: LD_VAR 0 2
72353: PUSH
72354: LD_VAR 0 3
72358: ARRAY
72359: PPUSH
72360: LD_INT 3
72362: PPUSH
72363: CALL_OW 259
72367: PUSH
72368: LD_VAR 0 2
72372: PUSH
72373: LD_VAR 0 3
72377: ARRAY
72378: PPUSH
72379: CALL_OW 432
72383: MINUS
72384: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72385: LD_VAR 0 4
72389: PUSH
72390: LD_VAR 0 5
72394: PPUSH
72395: LD_INT 3
72397: PPUSH
72398: CALL_OW 259
72402: PUSH
72403: LD_VAR 0 5
72407: PPUSH
72408: CALL_OW 432
72412: MINUS
72413: GREATEREQUAL
72414: IFFALSE 72432
// mech := result [ i ] ;
72416: LD_ADDR_VAR 0 5
72420: PUSH
72421: LD_VAR 0 2
72425: PUSH
72426: LD_VAR 0 3
72430: ARRAY
72431: ST_TO_ADDR
// end ;
72432: GO 72341
72434: POP
72435: POP
// end ; ComLinkTo ( vehicle , mech ) ;
72436: LD_VAR 0 1
72440: PPUSH
72441: LD_VAR 0 5
72445: PPUSH
72446: CALL_OW 135
// end ;
72450: LD_VAR 0 2
72454: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72455: LD_INT 0
72457: PPUSH
72458: PPUSH
72459: PPUSH
72460: PPUSH
72461: PPUSH
72462: PPUSH
72463: PPUSH
72464: PPUSH
72465: PPUSH
72466: PPUSH
72467: PPUSH
72468: PPUSH
72469: PPUSH
// result := [ ] ;
72470: LD_ADDR_VAR 0 7
72474: PUSH
72475: EMPTY
72476: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
72477: LD_VAR 0 1
72481: PPUSH
72482: CALL_OW 266
72486: PUSH
72487: LD_INT 0
72489: PUSH
72490: LD_INT 1
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: IN
72497: NOT
72498: IFFALSE 72502
// exit ;
72500: GO 74136
// if name then
72502: LD_VAR 0 3
72506: IFFALSE 72522
// SetBName ( base_dep , name ) ;
72508: LD_VAR 0 1
72512: PPUSH
72513: LD_VAR 0 3
72517: PPUSH
72518: CALL_OW 500
// base := GetBase ( base_dep ) ;
72522: LD_ADDR_VAR 0 15
72526: PUSH
72527: LD_VAR 0 1
72531: PPUSH
72532: CALL_OW 274
72536: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
72537: LD_ADDR_VAR 0 16
72541: PUSH
72542: LD_VAR 0 1
72546: PPUSH
72547: CALL_OW 255
72551: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
72552: LD_ADDR_VAR 0 17
72556: PUSH
72557: LD_VAR 0 1
72561: PPUSH
72562: CALL_OW 248
72566: ST_TO_ADDR
// if sources then
72567: LD_VAR 0 5
72571: IFFALSE 72618
// for i = 1 to 3 do
72573: LD_ADDR_VAR 0 8
72577: PUSH
72578: DOUBLE
72579: LD_INT 1
72581: DEC
72582: ST_TO_ADDR
72583: LD_INT 3
72585: PUSH
72586: FOR_TO
72587: IFFALSE 72616
// AddResourceType ( base , i , sources [ i ] ) ;
72589: LD_VAR 0 15
72593: PPUSH
72594: LD_VAR 0 8
72598: PPUSH
72599: LD_VAR 0 5
72603: PUSH
72604: LD_VAR 0 8
72608: ARRAY
72609: PPUSH
72610: CALL_OW 276
72614: GO 72586
72616: POP
72617: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
72618: LD_ADDR_VAR 0 18
72622: PUSH
72623: LD_VAR 0 15
72627: PPUSH
72628: LD_VAR 0 2
72632: PPUSH
72633: LD_INT 1
72635: PPUSH
72636: CALL 71879 0 3
72640: ST_TO_ADDR
// InitHc ;
72641: CALL_OW 19
// InitUc ;
72645: CALL_OW 18
// uc_side := side ;
72649: LD_ADDR_OWVAR 20
72653: PUSH
72654: LD_VAR 0 16
72658: ST_TO_ADDR
// uc_nation := nation ;
72659: LD_ADDR_OWVAR 21
72663: PUSH
72664: LD_VAR 0 17
72668: ST_TO_ADDR
// if buildings then
72669: LD_VAR 0 18
72673: IFFALSE 73995
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
72675: LD_ADDR_VAR 0 19
72679: PUSH
72680: LD_VAR 0 18
72684: PPUSH
72685: LD_INT 2
72687: PUSH
72688: LD_INT 30
72690: PUSH
72691: LD_INT 29
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: LD_INT 30
72700: PUSH
72701: LD_INT 30
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: LIST
72712: PPUSH
72713: CALL_OW 72
72717: ST_TO_ADDR
// if tmp then
72718: LD_VAR 0 19
72722: IFFALSE 72770
// for i in tmp do
72724: LD_ADDR_VAR 0 8
72728: PUSH
72729: LD_VAR 0 19
72733: PUSH
72734: FOR_IN
72735: IFFALSE 72768
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
72737: LD_VAR 0 8
72741: PPUSH
72742: CALL_OW 250
72746: PPUSH
72747: LD_VAR 0 8
72751: PPUSH
72752: CALL_OW 251
72756: PPUSH
72757: LD_VAR 0 16
72761: PPUSH
72762: CALL_OW 441
72766: GO 72734
72768: POP
72769: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72770: LD_VAR 0 18
72774: PPUSH
72775: LD_INT 2
72777: PUSH
72778: LD_INT 30
72780: PUSH
72781: LD_INT 32
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 30
72790: PUSH
72791: LD_INT 33
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: LIST
72802: PPUSH
72803: CALL_OW 72
72807: IFFALSE 72895
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72809: LD_ADDR_VAR 0 8
72813: PUSH
72814: LD_VAR 0 18
72818: PPUSH
72819: LD_INT 2
72821: PUSH
72822: LD_INT 30
72824: PUSH
72825: LD_INT 32
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 30
72834: PUSH
72835: LD_INT 33
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: LIST
72846: PPUSH
72847: CALL_OW 72
72851: PUSH
72852: FOR_IN
72853: IFFALSE 72893
// begin if not GetBWeapon ( i ) then
72855: LD_VAR 0 8
72859: PPUSH
72860: CALL_OW 269
72864: NOT
72865: IFFALSE 72891
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72867: LD_VAR 0 8
72871: PPUSH
72872: LD_VAR 0 8
72876: PPUSH
72877: LD_VAR 0 2
72881: PPUSH
72882: CALL 74141 0 2
72886: PPUSH
72887: CALL_OW 431
// end ;
72891: GO 72852
72893: POP
72894: POP
// end ; for i = 1 to personel do
72895: LD_ADDR_VAR 0 8
72899: PUSH
72900: DOUBLE
72901: LD_INT 1
72903: DEC
72904: ST_TO_ADDR
72905: LD_VAR 0 6
72909: PUSH
72910: FOR_TO
72911: IFFALSE 73975
// begin if i > 4 then
72913: LD_VAR 0 8
72917: PUSH
72918: LD_INT 4
72920: GREATER
72921: IFFALSE 72925
// break ;
72923: GO 73975
// case i of 1 :
72925: LD_VAR 0 8
72929: PUSH
72930: LD_INT 1
72932: DOUBLE
72933: EQUAL
72934: IFTRUE 72938
72936: GO 73018
72938: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72939: LD_ADDR_VAR 0 12
72943: PUSH
72944: LD_VAR 0 18
72948: PPUSH
72949: LD_INT 22
72951: PUSH
72952: LD_VAR 0 16
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 58
72963: PUSH
72964: EMPTY
72965: LIST
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: LD_INT 30
72972: PUSH
72973: LD_INT 32
72975: PUSH
72976: EMPTY
72977: LIST
72978: LIST
72979: PUSH
72980: LD_INT 30
72982: PUSH
72983: LD_INT 4
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 30
72992: PUSH
72993: LD_INT 5
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: LIST
73010: PPUSH
73011: CALL_OW 72
73015: ST_TO_ADDR
73016: GO 73240
73018: LD_INT 2
73020: DOUBLE
73021: EQUAL
73022: IFTRUE 73026
73024: GO 73088
73026: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73027: LD_ADDR_VAR 0 12
73031: PUSH
73032: LD_VAR 0 18
73036: PPUSH
73037: LD_INT 22
73039: PUSH
73040: LD_VAR 0 16
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 2
73051: PUSH
73052: LD_INT 30
73054: PUSH
73055: LD_INT 0
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 30
73064: PUSH
73065: LD_INT 1
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: LIST
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PPUSH
73081: CALL_OW 72
73085: ST_TO_ADDR
73086: GO 73240
73088: LD_INT 3
73090: DOUBLE
73091: EQUAL
73092: IFTRUE 73096
73094: GO 73158
73096: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73097: LD_ADDR_VAR 0 12
73101: PUSH
73102: LD_VAR 0 18
73106: PPUSH
73107: LD_INT 22
73109: PUSH
73110: LD_VAR 0 16
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 2
73121: PUSH
73122: LD_INT 30
73124: PUSH
73125: LD_INT 2
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PUSH
73132: LD_INT 30
73134: PUSH
73135: LD_INT 3
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: LIST
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PPUSH
73151: CALL_OW 72
73155: ST_TO_ADDR
73156: GO 73240
73158: LD_INT 4
73160: DOUBLE
73161: EQUAL
73162: IFTRUE 73166
73164: GO 73239
73166: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73167: LD_ADDR_VAR 0 12
73171: PUSH
73172: LD_VAR 0 18
73176: PPUSH
73177: LD_INT 22
73179: PUSH
73180: LD_VAR 0 16
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 2
73191: PUSH
73192: LD_INT 30
73194: PUSH
73195: LD_INT 6
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: LD_INT 30
73204: PUSH
73205: LD_INT 7
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 30
73214: PUSH
73215: LD_INT 8
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PPUSH
73232: CALL_OW 72
73236: ST_TO_ADDR
73237: GO 73240
73239: POP
// if i = 1 then
73240: LD_VAR 0 8
73244: PUSH
73245: LD_INT 1
73247: EQUAL
73248: IFFALSE 73359
// begin tmp := [ ] ;
73250: LD_ADDR_VAR 0 19
73254: PUSH
73255: EMPTY
73256: ST_TO_ADDR
// for j in f do
73257: LD_ADDR_VAR 0 9
73261: PUSH
73262: LD_VAR 0 12
73266: PUSH
73267: FOR_IN
73268: IFFALSE 73341
// if GetBType ( j ) = b_bunker then
73270: LD_VAR 0 9
73274: PPUSH
73275: CALL_OW 266
73279: PUSH
73280: LD_INT 32
73282: EQUAL
73283: IFFALSE 73310
// tmp := Insert ( tmp , 1 , j ) else
73285: LD_ADDR_VAR 0 19
73289: PUSH
73290: LD_VAR 0 19
73294: PPUSH
73295: LD_INT 1
73297: PPUSH
73298: LD_VAR 0 9
73302: PPUSH
73303: CALL_OW 2
73307: ST_TO_ADDR
73308: GO 73339
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73310: LD_ADDR_VAR 0 19
73314: PUSH
73315: LD_VAR 0 19
73319: PPUSH
73320: LD_VAR 0 19
73324: PUSH
73325: LD_INT 1
73327: PLUS
73328: PPUSH
73329: LD_VAR 0 9
73333: PPUSH
73334: CALL_OW 2
73338: ST_TO_ADDR
73339: GO 73267
73341: POP
73342: POP
// if tmp then
73343: LD_VAR 0 19
73347: IFFALSE 73359
// f := tmp ;
73349: LD_ADDR_VAR 0 12
73353: PUSH
73354: LD_VAR 0 19
73358: ST_TO_ADDR
// end ; x := personel [ i ] ;
73359: LD_ADDR_VAR 0 13
73363: PUSH
73364: LD_VAR 0 6
73368: PUSH
73369: LD_VAR 0 8
73373: ARRAY
73374: ST_TO_ADDR
// if x = - 1 then
73375: LD_VAR 0 13
73379: PUSH
73380: LD_INT 1
73382: NEG
73383: EQUAL
73384: IFFALSE 73593
// begin for j in f do
73386: LD_ADDR_VAR 0 9
73390: PUSH
73391: LD_VAR 0 12
73395: PUSH
73396: FOR_IN
73397: IFFALSE 73589
// repeat InitHc ;
73399: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73403: LD_VAR 0 9
73407: PPUSH
73408: CALL_OW 266
73412: PUSH
73413: LD_INT 5
73415: EQUAL
73416: IFFALSE 73486
// begin if UnitsInside ( j ) < 3 then
73418: LD_VAR 0 9
73422: PPUSH
73423: CALL_OW 313
73427: PUSH
73428: LD_INT 3
73430: LESS
73431: IFFALSE 73467
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73433: LD_INT 0
73435: PPUSH
73436: LD_INT 5
73438: PUSH
73439: LD_INT 8
73441: PUSH
73442: LD_INT 9
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: LIST
73449: PUSH
73450: LD_VAR 0 17
73454: ARRAY
73455: PPUSH
73456: LD_VAR 0 4
73460: PPUSH
73461: CALL_OW 380
73465: GO 73484
// PrepareHuman ( false , i , skill ) ;
73467: LD_INT 0
73469: PPUSH
73470: LD_VAR 0 8
73474: PPUSH
73475: LD_VAR 0 4
73479: PPUSH
73480: CALL_OW 380
// end else
73484: GO 73503
// PrepareHuman ( false , i , skill ) ;
73486: LD_INT 0
73488: PPUSH
73489: LD_VAR 0 8
73493: PPUSH
73494: LD_VAR 0 4
73498: PPUSH
73499: CALL_OW 380
// un := CreateHuman ;
73503: LD_ADDR_VAR 0 14
73507: PUSH
73508: CALL_OW 44
73512: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73513: LD_ADDR_VAR 0 7
73517: PUSH
73518: LD_VAR 0 7
73522: PPUSH
73523: LD_INT 1
73525: PPUSH
73526: LD_VAR 0 14
73530: PPUSH
73531: CALL_OW 2
73535: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
73536: LD_VAR 0 14
73540: PPUSH
73541: LD_VAR 0 9
73545: PPUSH
73546: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
73550: LD_VAR 0 9
73554: PPUSH
73555: CALL_OW 313
73559: PUSH
73560: LD_INT 6
73562: EQUAL
73563: PUSH
73564: LD_VAR 0 9
73568: PPUSH
73569: CALL_OW 266
73573: PUSH
73574: LD_INT 32
73576: PUSH
73577: LD_INT 31
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: IN
73584: OR
73585: IFFALSE 73399
73587: GO 73396
73589: POP
73590: POP
// end else
73591: GO 73973
// for j = 1 to x do
73593: LD_ADDR_VAR 0 9
73597: PUSH
73598: DOUBLE
73599: LD_INT 1
73601: DEC
73602: ST_TO_ADDR
73603: LD_VAR 0 13
73607: PUSH
73608: FOR_TO
73609: IFFALSE 73971
// begin InitHc ;
73611: CALL_OW 19
// if not f then
73615: LD_VAR 0 12
73619: NOT
73620: IFFALSE 73709
// begin PrepareHuman ( false , i , skill ) ;
73622: LD_INT 0
73624: PPUSH
73625: LD_VAR 0 8
73629: PPUSH
73630: LD_VAR 0 4
73634: PPUSH
73635: CALL_OW 380
// un := CreateHuman ;
73639: LD_ADDR_VAR 0 14
73643: PUSH
73644: CALL_OW 44
73648: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73649: LD_ADDR_VAR 0 7
73653: PUSH
73654: LD_VAR 0 7
73658: PPUSH
73659: LD_INT 1
73661: PPUSH
73662: LD_VAR 0 14
73666: PPUSH
73667: CALL_OW 2
73671: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73672: LD_VAR 0 14
73676: PPUSH
73677: LD_VAR 0 1
73681: PPUSH
73682: CALL_OW 250
73686: PPUSH
73687: LD_VAR 0 1
73691: PPUSH
73692: CALL_OW 251
73696: PPUSH
73697: LD_INT 10
73699: PPUSH
73700: LD_INT 0
73702: PPUSH
73703: CALL_OW 50
// continue ;
73707: GO 73608
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
73709: LD_VAR 0 12
73713: PUSH
73714: LD_INT 1
73716: ARRAY
73717: PPUSH
73718: CALL_OW 313
73722: PUSH
73723: LD_VAR 0 12
73727: PUSH
73728: LD_INT 1
73730: ARRAY
73731: PPUSH
73732: CALL_OW 266
73736: PUSH
73737: LD_INT 32
73739: PUSH
73740: LD_INT 31
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: IN
73747: AND
73748: PUSH
73749: LD_VAR 0 12
73753: PUSH
73754: LD_INT 1
73756: ARRAY
73757: PPUSH
73758: CALL_OW 313
73762: PUSH
73763: LD_INT 6
73765: EQUAL
73766: OR
73767: IFFALSE 73787
// f := Delete ( f , 1 ) ;
73769: LD_ADDR_VAR 0 12
73773: PUSH
73774: LD_VAR 0 12
73778: PPUSH
73779: LD_INT 1
73781: PPUSH
73782: CALL_OW 3
73786: ST_TO_ADDR
// if not f then
73787: LD_VAR 0 12
73791: NOT
73792: IFFALSE 73810
// begin x := x + 2 ;
73794: LD_ADDR_VAR 0 13
73798: PUSH
73799: LD_VAR 0 13
73803: PUSH
73804: LD_INT 2
73806: PLUS
73807: ST_TO_ADDR
// continue ;
73808: GO 73608
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73810: LD_VAR 0 12
73814: PUSH
73815: LD_INT 1
73817: ARRAY
73818: PPUSH
73819: CALL_OW 266
73823: PUSH
73824: LD_INT 5
73826: EQUAL
73827: IFFALSE 73901
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73829: LD_VAR 0 12
73833: PUSH
73834: LD_INT 1
73836: ARRAY
73837: PPUSH
73838: CALL_OW 313
73842: PUSH
73843: LD_INT 3
73845: LESS
73846: IFFALSE 73882
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73848: LD_INT 0
73850: PPUSH
73851: LD_INT 5
73853: PUSH
73854: LD_INT 8
73856: PUSH
73857: LD_INT 9
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: LIST
73864: PUSH
73865: LD_VAR 0 17
73869: ARRAY
73870: PPUSH
73871: LD_VAR 0 4
73875: PPUSH
73876: CALL_OW 380
73880: GO 73899
// PrepareHuman ( false , i , skill ) ;
73882: LD_INT 0
73884: PPUSH
73885: LD_VAR 0 8
73889: PPUSH
73890: LD_VAR 0 4
73894: PPUSH
73895: CALL_OW 380
// end else
73899: GO 73918
// PrepareHuman ( false , i , skill ) ;
73901: LD_INT 0
73903: PPUSH
73904: LD_VAR 0 8
73908: PPUSH
73909: LD_VAR 0 4
73913: PPUSH
73914: CALL_OW 380
// un := CreateHuman ;
73918: LD_ADDR_VAR 0 14
73922: PUSH
73923: CALL_OW 44
73927: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73928: LD_ADDR_VAR 0 7
73932: PUSH
73933: LD_VAR 0 7
73937: PPUSH
73938: LD_INT 1
73940: PPUSH
73941: LD_VAR 0 14
73945: PPUSH
73946: CALL_OW 2
73950: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73951: LD_VAR 0 14
73955: PPUSH
73956: LD_VAR 0 12
73960: PUSH
73961: LD_INT 1
73963: ARRAY
73964: PPUSH
73965: CALL_OW 52
// end ;
73969: GO 73608
73971: POP
73972: POP
// end ;
73973: GO 72910
73975: POP
73976: POP
// result := result ^ buildings ;
73977: LD_ADDR_VAR 0 7
73981: PUSH
73982: LD_VAR 0 7
73986: PUSH
73987: LD_VAR 0 18
73991: ADD
73992: ST_TO_ADDR
// end else
73993: GO 74136
// begin for i = 1 to personel do
73995: LD_ADDR_VAR 0 8
73999: PUSH
74000: DOUBLE
74001: LD_INT 1
74003: DEC
74004: ST_TO_ADDR
74005: LD_VAR 0 6
74009: PUSH
74010: FOR_TO
74011: IFFALSE 74134
// begin if i > 4 then
74013: LD_VAR 0 8
74017: PUSH
74018: LD_INT 4
74020: GREATER
74021: IFFALSE 74025
// break ;
74023: GO 74134
// x := personel [ i ] ;
74025: LD_ADDR_VAR 0 13
74029: PUSH
74030: LD_VAR 0 6
74034: PUSH
74035: LD_VAR 0 8
74039: ARRAY
74040: ST_TO_ADDR
// if x = - 1 then
74041: LD_VAR 0 13
74045: PUSH
74046: LD_INT 1
74048: NEG
74049: EQUAL
74050: IFFALSE 74054
// continue ;
74052: GO 74010
// PrepareHuman ( false , i , skill ) ;
74054: LD_INT 0
74056: PPUSH
74057: LD_VAR 0 8
74061: PPUSH
74062: LD_VAR 0 4
74066: PPUSH
74067: CALL_OW 380
// un := CreateHuman ;
74071: LD_ADDR_VAR 0 14
74075: PUSH
74076: CALL_OW 44
74080: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74081: LD_VAR 0 14
74085: PPUSH
74086: LD_VAR 0 1
74090: PPUSH
74091: CALL_OW 250
74095: PPUSH
74096: LD_VAR 0 1
74100: PPUSH
74101: CALL_OW 251
74105: PPUSH
74106: LD_INT 10
74108: PPUSH
74109: LD_INT 0
74111: PPUSH
74112: CALL_OW 50
// result := result ^ un ;
74116: LD_ADDR_VAR 0 7
74120: PUSH
74121: LD_VAR 0 7
74125: PUSH
74126: LD_VAR 0 14
74130: ADD
74131: ST_TO_ADDR
// end ;
74132: GO 74010
74134: POP
74135: POP
// end ; end ;
74136: LD_VAR 0 7
74140: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74141: LD_INT 0
74143: PPUSH
74144: PPUSH
74145: PPUSH
74146: PPUSH
74147: PPUSH
74148: PPUSH
74149: PPUSH
74150: PPUSH
74151: PPUSH
74152: PPUSH
74153: PPUSH
74154: PPUSH
74155: PPUSH
74156: PPUSH
74157: PPUSH
74158: PPUSH
// result := false ;
74159: LD_ADDR_VAR 0 3
74163: PUSH
74164: LD_INT 0
74166: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74167: LD_VAR 0 1
74171: NOT
74172: PUSH
74173: LD_VAR 0 1
74177: PPUSH
74178: CALL_OW 266
74182: PUSH
74183: LD_INT 32
74185: PUSH
74186: LD_INT 33
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: IN
74193: NOT
74194: OR
74195: IFFALSE 74199
// exit ;
74197: GO 75308
// nat := GetNation ( tower ) ;
74199: LD_ADDR_VAR 0 12
74203: PUSH
74204: LD_VAR 0 1
74208: PPUSH
74209: CALL_OW 248
74213: ST_TO_ADDR
// side := GetSide ( tower ) ;
74214: LD_ADDR_VAR 0 16
74218: PUSH
74219: LD_VAR 0 1
74223: PPUSH
74224: CALL_OW 255
74228: ST_TO_ADDR
// x := GetX ( tower ) ;
74229: LD_ADDR_VAR 0 10
74233: PUSH
74234: LD_VAR 0 1
74238: PPUSH
74239: CALL_OW 250
74243: ST_TO_ADDR
// y := GetY ( tower ) ;
74244: LD_ADDR_VAR 0 11
74248: PUSH
74249: LD_VAR 0 1
74253: PPUSH
74254: CALL_OW 251
74258: ST_TO_ADDR
// if not x or not y then
74259: LD_VAR 0 10
74263: NOT
74264: PUSH
74265: LD_VAR 0 11
74269: NOT
74270: OR
74271: IFFALSE 74275
// exit ;
74273: GO 75308
// weapon := 0 ;
74275: LD_ADDR_VAR 0 18
74279: PUSH
74280: LD_INT 0
74282: ST_TO_ADDR
// fac_list := [ ] ;
74283: LD_ADDR_VAR 0 17
74287: PUSH
74288: EMPTY
74289: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
74290: LD_ADDR_VAR 0 6
74294: PUSH
74295: LD_VAR 0 1
74299: PPUSH
74300: CALL_OW 274
74304: PPUSH
74305: LD_VAR 0 2
74309: PPUSH
74310: LD_INT 0
74312: PPUSH
74313: CALL 71879 0 3
74317: PPUSH
74318: LD_INT 30
74320: PUSH
74321: LD_INT 3
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PPUSH
74328: CALL_OW 72
74332: ST_TO_ADDR
// if not factories then
74333: LD_VAR 0 6
74337: NOT
74338: IFFALSE 74342
// exit ;
74340: GO 75308
// for i in factories do
74342: LD_ADDR_VAR 0 8
74346: PUSH
74347: LD_VAR 0 6
74351: PUSH
74352: FOR_IN
74353: IFFALSE 74378
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74355: LD_ADDR_VAR 0 17
74359: PUSH
74360: LD_VAR 0 17
74364: PUSH
74365: LD_VAR 0 8
74369: PPUSH
74370: CALL_OW 478
74374: UNION
74375: ST_TO_ADDR
74376: GO 74352
74378: POP
74379: POP
// if not fac_list then
74380: LD_VAR 0 17
74384: NOT
74385: IFFALSE 74389
// exit ;
74387: GO 75308
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74389: LD_ADDR_VAR 0 5
74393: PUSH
74394: LD_INT 4
74396: PUSH
74397: LD_INT 5
74399: PUSH
74400: LD_INT 9
74402: PUSH
74403: LD_INT 10
74405: PUSH
74406: LD_INT 6
74408: PUSH
74409: LD_INT 7
74411: PUSH
74412: LD_INT 11
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: PUSH
74424: LD_INT 27
74426: PUSH
74427: LD_INT 28
74429: PUSH
74430: LD_INT 26
74432: PUSH
74433: LD_INT 30
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: PUSH
74442: LD_INT 43
74444: PUSH
74445: LD_INT 44
74447: PUSH
74448: LD_INT 46
74450: PUSH
74451: LD_INT 45
74453: PUSH
74454: LD_INT 47
74456: PUSH
74457: LD_INT 49
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: LIST
74464: LIST
74465: LIST
74466: LIST
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: LIST
74472: PUSH
74473: LD_VAR 0 12
74477: ARRAY
74478: ST_TO_ADDR
// list := list isect fac_list ;
74479: LD_ADDR_VAR 0 5
74483: PUSH
74484: LD_VAR 0 5
74488: PUSH
74489: LD_VAR 0 17
74493: ISECT
74494: ST_TO_ADDR
// if not list then
74495: LD_VAR 0 5
74499: NOT
74500: IFFALSE 74504
// exit ;
74502: GO 75308
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
74504: LD_VAR 0 12
74508: PUSH
74509: LD_INT 3
74511: EQUAL
74512: PUSH
74513: LD_INT 49
74515: PUSH
74516: LD_VAR 0 5
74520: IN
74521: AND
74522: PUSH
74523: LD_INT 31
74525: PPUSH
74526: LD_VAR 0 16
74530: PPUSH
74531: CALL_OW 321
74535: PUSH
74536: LD_INT 2
74538: EQUAL
74539: AND
74540: IFFALSE 74600
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
74542: LD_INT 22
74544: PUSH
74545: LD_VAR 0 16
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 35
74556: PUSH
74557: LD_INT 49
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 91
74566: PUSH
74567: LD_VAR 0 1
74571: PUSH
74572: LD_INT 10
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: LIST
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: LIST
74584: PPUSH
74585: CALL_OW 69
74589: NOT
74590: IFFALSE 74600
// weapon := ru_time_lapser ;
74592: LD_ADDR_VAR 0 18
74596: PUSH
74597: LD_INT 49
74599: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
74600: LD_VAR 0 12
74604: PUSH
74605: LD_INT 1
74607: PUSH
74608: LD_INT 2
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: IN
74615: PUSH
74616: LD_INT 11
74618: PUSH
74619: LD_VAR 0 5
74623: IN
74624: PUSH
74625: LD_INT 30
74627: PUSH
74628: LD_VAR 0 5
74632: IN
74633: OR
74634: AND
74635: PUSH
74636: LD_INT 6
74638: PPUSH
74639: LD_VAR 0 16
74643: PPUSH
74644: CALL_OW 321
74648: PUSH
74649: LD_INT 2
74651: EQUAL
74652: AND
74653: IFFALSE 74818
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
74655: LD_INT 22
74657: PUSH
74658: LD_VAR 0 16
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: LD_INT 35
74672: PUSH
74673: LD_INT 11
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 35
74682: PUSH
74683: LD_INT 30
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 91
74697: PUSH
74698: LD_VAR 0 1
74702: PUSH
74703: LD_INT 18
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: LIST
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: LIST
74715: PPUSH
74716: CALL_OW 69
74720: NOT
74721: PUSH
74722: LD_INT 22
74724: PUSH
74725: LD_VAR 0 16
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 2
74736: PUSH
74737: LD_INT 30
74739: PUSH
74740: LD_INT 32
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 30
74749: PUSH
74750: LD_INT 33
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 91
74764: PUSH
74765: LD_VAR 0 1
74769: PUSH
74770: LD_INT 12
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: LIST
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: LIST
74782: PUSH
74783: EMPTY
74784: LIST
74785: PPUSH
74786: CALL_OW 69
74790: PUSH
74791: LD_INT 2
74793: GREATER
74794: AND
74795: IFFALSE 74818
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74797: LD_ADDR_VAR 0 18
74801: PUSH
74802: LD_INT 11
74804: PUSH
74805: LD_INT 30
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_VAR 0 12
74816: ARRAY
74817: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74818: LD_VAR 0 18
74822: NOT
74823: PUSH
74824: LD_INT 40
74826: PPUSH
74827: LD_VAR 0 16
74831: PPUSH
74832: CALL_OW 321
74836: PUSH
74837: LD_INT 2
74839: EQUAL
74840: AND
74841: PUSH
74842: LD_INT 7
74844: PUSH
74845: LD_VAR 0 5
74849: IN
74850: PUSH
74851: LD_INT 28
74853: PUSH
74854: LD_VAR 0 5
74858: IN
74859: OR
74860: PUSH
74861: LD_INT 45
74863: PUSH
74864: LD_VAR 0 5
74868: IN
74869: OR
74870: AND
74871: IFFALSE 75125
// begin hex := GetHexInfo ( x , y ) ;
74873: LD_ADDR_VAR 0 4
74877: PUSH
74878: LD_VAR 0 10
74882: PPUSH
74883: LD_VAR 0 11
74887: PPUSH
74888: CALL_OW 546
74892: ST_TO_ADDR
// if hex [ 1 ] then
74893: LD_VAR 0 4
74897: PUSH
74898: LD_INT 1
74900: ARRAY
74901: IFFALSE 74905
// exit ;
74903: GO 75308
// height := hex [ 2 ] ;
74905: LD_ADDR_VAR 0 15
74909: PUSH
74910: LD_VAR 0 4
74914: PUSH
74915: LD_INT 2
74917: ARRAY
74918: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74919: LD_ADDR_VAR 0 14
74923: PUSH
74924: LD_INT 0
74926: PUSH
74927: LD_INT 2
74929: PUSH
74930: LD_INT 3
74932: PUSH
74933: LD_INT 5
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: ST_TO_ADDR
// for i in tmp do
74942: LD_ADDR_VAR 0 8
74946: PUSH
74947: LD_VAR 0 14
74951: PUSH
74952: FOR_IN
74953: IFFALSE 75123
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74955: LD_ADDR_VAR 0 9
74959: PUSH
74960: LD_VAR 0 10
74964: PPUSH
74965: LD_VAR 0 8
74969: PPUSH
74970: LD_INT 5
74972: PPUSH
74973: CALL_OW 272
74977: PUSH
74978: LD_VAR 0 11
74982: PPUSH
74983: LD_VAR 0 8
74987: PPUSH
74988: LD_INT 5
74990: PPUSH
74991: CALL_OW 273
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75000: LD_VAR 0 9
75004: PUSH
75005: LD_INT 1
75007: ARRAY
75008: PPUSH
75009: LD_VAR 0 9
75013: PUSH
75014: LD_INT 2
75016: ARRAY
75017: PPUSH
75018: CALL_OW 488
75022: IFFALSE 75121
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75024: LD_ADDR_VAR 0 4
75028: PUSH
75029: LD_VAR 0 9
75033: PUSH
75034: LD_INT 1
75036: ARRAY
75037: PPUSH
75038: LD_VAR 0 9
75042: PUSH
75043: LD_INT 2
75045: ARRAY
75046: PPUSH
75047: CALL_OW 546
75051: ST_TO_ADDR
// if hex [ 1 ] then
75052: LD_VAR 0 4
75056: PUSH
75057: LD_INT 1
75059: ARRAY
75060: IFFALSE 75064
// continue ;
75062: GO 74952
// h := hex [ 2 ] ;
75064: LD_ADDR_VAR 0 13
75068: PUSH
75069: LD_VAR 0 4
75073: PUSH
75074: LD_INT 2
75076: ARRAY
75077: ST_TO_ADDR
// if h + 7 < height then
75078: LD_VAR 0 13
75082: PUSH
75083: LD_INT 7
75085: PLUS
75086: PUSH
75087: LD_VAR 0 15
75091: LESS
75092: IFFALSE 75121
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75094: LD_ADDR_VAR 0 18
75098: PUSH
75099: LD_INT 7
75101: PUSH
75102: LD_INT 28
75104: PUSH
75105: LD_INT 45
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: LIST
75112: PUSH
75113: LD_VAR 0 12
75117: ARRAY
75118: ST_TO_ADDR
// break ;
75119: GO 75123
// end ; end ; end ;
75121: GO 74952
75123: POP
75124: POP
// end ; if not weapon then
75125: LD_VAR 0 18
75129: NOT
75130: IFFALSE 75190
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75132: LD_ADDR_VAR 0 5
75136: PUSH
75137: LD_VAR 0 5
75141: PUSH
75142: LD_INT 11
75144: PUSH
75145: LD_INT 30
75147: PUSH
75148: LD_INT 49
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: LIST
75155: DIFF
75156: ST_TO_ADDR
// if not list then
75157: LD_VAR 0 5
75161: NOT
75162: IFFALSE 75166
// exit ;
75164: GO 75308
// weapon := list [ rand ( 1 , list ) ] ;
75166: LD_ADDR_VAR 0 18
75170: PUSH
75171: LD_VAR 0 5
75175: PUSH
75176: LD_INT 1
75178: PPUSH
75179: LD_VAR 0 5
75183: PPUSH
75184: CALL_OW 12
75188: ARRAY
75189: ST_TO_ADDR
// end ; if weapon then
75190: LD_VAR 0 18
75194: IFFALSE 75308
// begin tmp := CostOfWeapon ( weapon ) ;
75196: LD_ADDR_VAR 0 14
75200: PUSH
75201: LD_VAR 0 18
75205: PPUSH
75206: CALL_OW 451
75210: ST_TO_ADDR
// j := GetBase ( tower ) ;
75211: LD_ADDR_VAR 0 9
75215: PUSH
75216: LD_VAR 0 1
75220: PPUSH
75221: CALL_OW 274
75225: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75226: LD_VAR 0 9
75230: PPUSH
75231: LD_INT 1
75233: PPUSH
75234: CALL_OW 275
75238: PUSH
75239: LD_VAR 0 14
75243: PUSH
75244: LD_INT 1
75246: ARRAY
75247: GREATEREQUAL
75248: PUSH
75249: LD_VAR 0 9
75253: PPUSH
75254: LD_INT 2
75256: PPUSH
75257: CALL_OW 275
75261: PUSH
75262: LD_VAR 0 14
75266: PUSH
75267: LD_INT 2
75269: ARRAY
75270: GREATEREQUAL
75271: AND
75272: PUSH
75273: LD_VAR 0 9
75277: PPUSH
75278: LD_INT 3
75280: PPUSH
75281: CALL_OW 275
75285: PUSH
75286: LD_VAR 0 14
75290: PUSH
75291: LD_INT 3
75293: ARRAY
75294: GREATEREQUAL
75295: AND
75296: IFFALSE 75308
// result := weapon ;
75298: LD_ADDR_VAR 0 3
75302: PUSH
75303: LD_VAR 0 18
75307: ST_TO_ADDR
// end ; end ;
75308: LD_VAR 0 3
75312: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75313: LD_INT 0
75315: PPUSH
75316: PPUSH
// result := true ;
75317: LD_ADDR_VAR 0 3
75321: PUSH
75322: LD_INT 1
75324: ST_TO_ADDR
// if array1 = array2 then
75325: LD_VAR 0 1
75329: PUSH
75330: LD_VAR 0 2
75334: EQUAL
75335: IFFALSE 75395
// begin for i = 1 to array1 do
75337: LD_ADDR_VAR 0 4
75341: PUSH
75342: DOUBLE
75343: LD_INT 1
75345: DEC
75346: ST_TO_ADDR
75347: LD_VAR 0 1
75351: PUSH
75352: FOR_TO
75353: IFFALSE 75391
// if array1 [ i ] <> array2 [ i ] then
75355: LD_VAR 0 1
75359: PUSH
75360: LD_VAR 0 4
75364: ARRAY
75365: PUSH
75366: LD_VAR 0 2
75370: PUSH
75371: LD_VAR 0 4
75375: ARRAY
75376: NONEQUAL
75377: IFFALSE 75389
// begin result := false ;
75379: LD_ADDR_VAR 0 3
75383: PUSH
75384: LD_INT 0
75386: ST_TO_ADDR
// break ;
75387: GO 75391
// end ;
75389: GO 75352
75391: POP
75392: POP
// end else
75393: GO 75403
// result := false ;
75395: LD_ADDR_VAR 0 3
75399: PUSH
75400: LD_INT 0
75402: ST_TO_ADDR
// end ;
75403: LD_VAR 0 3
75407: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
75408: LD_INT 0
75410: PPUSH
75411: PPUSH
// if not array1 or not array2 then
75412: LD_VAR 0 1
75416: NOT
75417: PUSH
75418: LD_VAR 0 2
75422: NOT
75423: OR
75424: IFFALSE 75428
// exit ;
75426: GO 75492
// result := true ;
75428: LD_ADDR_VAR 0 3
75432: PUSH
75433: LD_INT 1
75435: ST_TO_ADDR
// for i = 1 to array1 do
75436: LD_ADDR_VAR 0 4
75440: PUSH
75441: DOUBLE
75442: LD_INT 1
75444: DEC
75445: ST_TO_ADDR
75446: LD_VAR 0 1
75450: PUSH
75451: FOR_TO
75452: IFFALSE 75490
// if array1 [ i ] <> array2 [ i ] then
75454: LD_VAR 0 1
75458: PUSH
75459: LD_VAR 0 4
75463: ARRAY
75464: PUSH
75465: LD_VAR 0 2
75469: PUSH
75470: LD_VAR 0 4
75474: ARRAY
75475: NONEQUAL
75476: IFFALSE 75488
// begin result := false ;
75478: LD_ADDR_VAR 0 3
75482: PUSH
75483: LD_INT 0
75485: ST_TO_ADDR
// break ;
75486: GO 75490
// end ;
75488: GO 75451
75490: POP
75491: POP
// end ;
75492: LD_VAR 0 3
75496: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75497: LD_INT 0
75499: PPUSH
75500: PPUSH
75501: PPUSH
// pom := GetBase ( fac ) ;
75502: LD_ADDR_VAR 0 5
75506: PUSH
75507: LD_VAR 0 1
75511: PPUSH
75512: CALL_OW 274
75516: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75517: LD_ADDR_VAR 0 4
75521: PUSH
75522: LD_VAR 0 2
75526: PUSH
75527: LD_INT 1
75529: ARRAY
75530: PPUSH
75531: LD_VAR 0 2
75535: PUSH
75536: LD_INT 2
75538: ARRAY
75539: PPUSH
75540: LD_VAR 0 2
75544: PUSH
75545: LD_INT 3
75547: ARRAY
75548: PPUSH
75549: LD_VAR 0 2
75553: PUSH
75554: LD_INT 4
75556: ARRAY
75557: PPUSH
75558: CALL_OW 449
75562: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75563: LD_ADDR_VAR 0 3
75567: PUSH
75568: LD_VAR 0 5
75572: PPUSH
75573: LD_INT 1
75575: PPUSH
75576: CALL_OW 275
75580: PUSH
75581: LD_VAR 0 4
75585: PUSH
75586: LD_INT 1
75588: ARRAY
75589: GREATEREQUAL
75590: PUSH
75591: LD_VAR 0 5
75595: PPUSH
75596: LD_INT 2
75598: PPUSH
75599: CALL_OW 275
75603: PUSH
75604: LD_VAR 0 4
75608: PUSH
75609: LD_INT 2
75611: ARRAY
75612: GREATEREQUAL
75613: AND
75614: PUSH
75615: LD_VAR 0 5
75619: PPUSH
75620: LD_INT 3
75622: PPUSH
75623: CALL_OW 275
75627: PUSH
75628: LD_VAR 0 4
75632: PUSH
75633: LD_INT 3
75635: ARRAY
75636: GREATEREQUAL
75637: AND
75638: ST_TO_ADDR
// end ;
75639: LD_VAR 0 3
75643: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
75644: LD_INT 0
75646: PPUSH
75647: PPUSH
75648: PPUSH
75649: PPUSH
// pom := GetBase ( building ) ;
75650: LD_ADDR_VAR 0 3
75654: PUSH
75655: LD_VAR 0 1
75659: PPUSH
75660: CALL_OW 274
75664: ST_TO_ADDR
// if not pom then
75665: LD_VAR 0 3
75669: NOT
75670: IFFALSE 75674
// exit ;
75672: GO 75844
// btype := GetBType ( building ) ;
75674: LD_ADDR_VAR 0 5
75678: PUSH
75679: LD_VAR 0 1
75683: PPUSH
75684: CALL_OW 266
75688: ST_TO_ADDR
// if btype = b_armoury then
75689: LD_VAR 0 5
75693: PUSH
75694: LD_INT 4
75696: EQUAL
75697: IFFALSE 75707
// btype := b_barracks ;
75699: LD_ADDR_VAR 0 5
75703: PUSH
75704: LD_INT 5
75706: ST_TO_ADDR
// if btype = b_depot then
75707: LD_VAR 0 5
75711: PUSH
75712: LD_INT 0
75714: EQUAL
75715: IFFALSE 75725
// btype := b_warehouse ;
75717: LD_ADDR_VAR 0 5
75721: PUSH
75722: LD_INT 1
75724: ST_TO_ADDR
// if btype = b_workshop then
75725: LD_VAR 0 5
75729: PUSH
75730: LD_INT 2
75732: EQUAL
75733: IFFALSE 75743
// btype := b_factory ;
75735: LD_ADDR_VAR 0 5
75739: PUSH
75740: LD_INT 3
75742: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75743: LD_ADDR_VAR 0 4
75747: PUSH
75748: LD_VAR 0 5
75752: PPUSH
75753: LD_VAR 0 1
75757: PPUSH
75758: CALL_OW 248
75762: PPUSH
75763: CALL_OW 450
75767: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75768: LD_ADDR_VAR 0 2
75772: PUSH
75773: LD_VAR 0 3
75777: PPUSH
75778: LD_INT 1
75780: PPUSH
75781: CALL_OW 275
75785: PUSH
75786: LD_VAR 0 4
75790: PUSH
75791: LD_INT 1
75793: ARRAY
75794: GREATEREQUAL
75795: PUSH
75796: LD_VAR 0 3
75800: PPUSH
75801: LD_INT 2
75803: PPUSH
75804: CALL_OW 275
75808: PUSH
75809: LD_VAR 0 4
75813: PUSH
75814: LD_INT 2
75816: ARRAY
75817: GREATEREQUAL
75818: AND
75819: PUSH
75820: LD_VAR 0 3
75824: PPUSH
75825: LD_INT 3
75827: PPUSH
75828: CALL_OW 275
75832: PUSH
75833: LD_VAR 0 4
75837: PUSH
75838: LD_INT 3
75840: ARRAY
75841: GREATEREQUAL
75842: AND
75843: ST_TO_ADDR
// end ;
75844: LD_VAR 0 2
75848: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75849: LD_INT 0
75851: PPUSH
75852: PPUSH
75853: PPUSH
// pom := GetBase ( building ) ;
75854: LD_ADDR_VAR 0 4
75858: PUSH
75859: LD_VAR 0 1
75863: PPUSH
75864: CALL_OW 274
75868: ST_TO_ADDR
// if not pom then
75869: LD_VAR 0 4
75873: NOT
75874: IFFALSE 75878
// exit ;
75876: GO 75979
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75878: LD_ADDR_VAR 0 5
75882: PUSH
75883: LD_VAR 0 2
75887: PPUSH
75888: LD_VAR 0 1
75892: PPUSH
75893: CALL_OW 248
75897: PPUSH
75898: CALL_OW 450
75902: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75903: LD_ADDR_VAR 0 3
75907: PUSH
75908: LD_VAR 0 4
75912: PPUSH
75913: LD_INT 1
75915: PPUSH
75916: CALL_OW 275
75920: PUSH
75921: LD_VAR 0 5
75925: PUSH
75926: LD_INT 1
75928: ARRAY
75929: GREATEREQUAL
75930: PUSH
75931: LD_VAR 0 4
75935: PPUSH
75936: LD_INT 2
75938: PPUSH
75939: CALL_OW 275
75943: PUSH
75944: LD_VAR 0 5
75948: PUSH
75949: LD_INT 2
75951: ARRAY
75952: GREATEREQUAL
75953: AND
75954: PUSH
75955: LD_VAR 0 4
75959: PPUSH
75960: LD_INT 3
75962: PPUSH
75963: CALL_OW 275
75967: PUSH
75968: LD_VAR 0 5
75972: PUSH
75973: LD_INT 3
75975: ARRAY
75976: GREATEREQUAL
75977: AND
75978: ST_TO_ADDR
// end ;
75979: LD_VAR 0 3
75983: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75984: LD_INT 0
75986: PPUSH
75987: PPUSH
75988: PPUSH
75989: PPUSH
75990: PPUSH
75991: PPUSH
75992: PPUSH
75993: PPUSH
75994: PPUSH
75995: PPUSH
75996: PPUSH
// result := false ;
75997: LD_ADDR_VAR 0 8
76001: PUSH
76002: LD_INT 0
76004: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
76005: LD_VAR 0 5
76009: NOT
76010: PUSH
76011: LD_VAR 0 1
76015: NOT
76016: OR
76017: PUSH
76018: LD_VAR 0 2
76022: NOT
76023: OR
76024: PUSH
76025: LD_VAR 0 3
76029: NOT
76030: OR
76031: IFFALSE 76035
// exit ;
76033: GO 76849
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
76035: LD_ADDR_VAR 0 14
76039: PUSH
76040: LD_VAR 0 1
76044: PPUSH
76045: LD_VAR 0 2
76049: PPUSH
76050: LD_VAR 0 3
76054: PPUSH
76055: LD_VAR 0 4
76059: PPUSH
76060: LD_VAR 0 5
76064: PUSH
76065: LD_INT 1
76067: ARRAY
76068: PPUSH
76069: CALL_OW 248
76073: PPUSH
76074: LD_INT 0
76076: PPUSH
76077: CALL 78102 0 6
76081: ST_TO_ADDR
// if not hexes then
76082: LD_VAR 0 14
76086: NOT
76087: IFFALSE 76091
// exit ;
76089: GO 76849
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76091: LD_ADDR_VAR 0 17
76095: PUSH
76096: LD_VAR 0 5
76100: PPUSH
76101: LD_INT 22
76103: PUSH
76104: LD_VAR 0 13
76108: PPUSH
76109: CALL_OW 255
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 2
76120: PUSH
76121: LD_INT 30
76123: PUSH
76124: LD_INT 0
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: LD_INT 30
76133: PUSH
76134: LD_INT 1
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: LIST
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PPUSH
76150: CALL_OW 72
76154: ST_TO_ADDR
// for i = 1 to hexes do
76155: LD_ADDR_VAR 0 9
76159: PUSH
76160: DOUBLE
76161: LD_INT 1
76163: DEC
76164: ST_TO_ADDR
76165: LD_VAR 0 14
76169: PUSH
76170: FOR_TO
76171: IFFALSE 76847
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76173: LD_ADDR_VAR 0 13
76177: PUSH
76178: LD_VAR 0 14
76182: PUSH
76183: LD_VAR 0 9
76187: ARRAY
76188: PUSH
76189: LD_INT 1
76191: ARRAY
76192: PPUSH
76193: LD_VAR 0 14
76197: PUSH
76198: LD_VAR 0 9
76202: ARRAY
76203: PUSH
76204: LD_INT 2
76206: ARRAY
76207: PPUSH
76208: CALL_OW 428
76212: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76213: LD_VAR 0 14
76217: PUSH
76218: LD_VAR 0 9
76222: ARRAY
76223: PUSH
76224: LD_INT 1
76226: ARRAY
76227: PPUSH
76228: LD_VAR 0 14
76232: PUSH
76233: LD_VAR 0 9
76237: ARRAY
76238: PUSH
76239: LD_INT 2
76241: ARRAY
76242: PPUSH
76243: CALL_OW 351
76247: PUSH
76248: LD_VAR 0 14
76252: PUSH
76253: LD_VAR 0 9
76257: ARRAY
76258: PUSH
76259: LD_INT 1
76261: ARRAY
76262: PPUSH
76263: LD_VAR 0 14
76267: PUSH
76268: LD_VAR 0 9
76272: ARRAY
76273: PUSH
76274: LD_INT 2
76276: ARRAY
76277: PPUSH
76278: CALL_OW 488
76282: NOT
76283: OR
76284: PUSH
76285: LD_VAR 0 13
76289: PPUSH
76290: CALL_OW 247
76294: PUSH
76295: LD_INT 3
76297: EQUAL
76298: OR
76299: IFFALSE 76305
// exit ;
76301: POP
76302: POP
76303: GO 76849
// if not tmp then
76305: LD_VAR 0 13
76309: NOT
76310: IFFALSE 76314
// continue ;
76312: GO 76170
// result := true ;
76314: LD_ADDR_VAR 0 8
76318: PUSH
76319: LD_INT 1
76321: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
76322: LD_VAR 0 6
76326: PUSH
76327: LD_VAR 0 13
76331: PPUSH
76332: CALL_OW 247
76336: PUSH
76337: LD_INT 2
76339: EQUAL
76340: AND
76341: PUSH
76342: LD_VAR 0 13
76346: PPUSH
76347: CALL_OW 263
76351: PUSH
76352: LD_INT 1
76354: EQUAL
76355: AND
76356: IFFALSE 76520
// begin if IsDrivenBy ( tmp ) then
76358: LD_VAR 0 13
76362: PPUSH
76363: CALL_OW 311
76367: IFFALSE 76371
// continue ;
76369: GO 76170
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
76371: LD_VAR 0 6
76375: PPUSH
76376: LD_INT 3
76378: PUSH
76379: LD_INT 60
76381: PUSH
76382: EMPTY
76383: LIST
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 3
76391: PUSH
76392: LD_INT 55
76394: PUSH
76395: EMPTY
76396: LIST
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PPUSH
76406: CALL_OW 72
76410: IFFALSE 76518
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
76412: LD_ADDR_VAR 0 18
76416: PUSH
76417: LD_VAR 0 6
76421: PPUSH
76422: LD_INT 3
76424: PUSH
76425: LD_INT 60
76427: PUSH
76428: EMPTY
76429: LIST
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 3
76437: PUSH
76438: LD_INT 55
76440: PUSH
76441: EMPTY
76442: LIST
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PPUSH
76452: CALL_OW 72
76456: PUSH
76457: LD_INT 1
76459: ARRAY
76460: ST_TO_ADDR
// if IsInUnit ( driver ) then
76461: LD_VAR 0 18
76465: PPUSH
76466: CALL_OW 310
76470: IFFALSE 76481
// ComExit ( driver ) ;
76472: LD_VAR 0 18
76476: PPUSH
76477: CALL 101894 0 1
// AddComEnterUnit ( driver , tmp ) ;
76481: LD_VAR 0 18
76485: PPUSH
76486: LD_VAR 0 13
76490: PPUSH
76491: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
76495: LD_VAR 0 18
76499: PPUSH
76500: LD_VAR 0 7
76504: PPUSH
76505: CALL_OW 173
// AddComExitVehicle ( driver ) ;
76509: LD_VAR 0 18
76513: PPUSH
76514: CALL_OW 181
// end ; continue ;
76518: GO 76170
// end ; if not cleaners or not tmp in cleaners then
76520: LD_VAR 0 6
76524: NOT
76525: PUSH
76526: LD_VAR 0 13
76530: PUSH
76531: LD_VAR 0 6
76535: IN
76536: NOT
76537: OR
76538: IFFALSE 76845
// begin if dep then
76540: LD_VAR 0 17
76544: IFFALSE 76680
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76546: LD_ADDR_VAR 0 16
76550: PUSH
76551: LD_VAR 0 17
76555: PUSH
76556: LD_INT 1
76558: ARRAY
76559: PPUSH
76560: CALL_OW 250
76564: PPUSH
76565: LD_VAR 0 17
76569: PUSH
76570: LD_INT 1
76572: ARRAY
76573: PPUSH
76574: CALL_OW 254
76578: PPUSH
76579: LD_INT 5
76581: PPUSH
76582: CALL_OW 272
76586: PUSH
76587: LD_VAR 0 17
76591: PUSH
76592: LD_INT 1
76594: ARRAY
76595: PPUSH
76596: CALL_OW 251
76600: PPUSH
76601: LD_VAR 0 17
76605: PUSH
76606: LD_INT 1
76608: ARRAY
76609: PPUSH
76610: CALL_OW 254
76614: PPUSH
76615: LD_INT 5
76617: PPUSH
76618: CALL_OW 273
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76627: LD_VAR 0 16
76631: PUSH
76632: LD_INT 1
76634: ARRAY
76635: PPUSH
76636: LD_VAR 0 16
76640: PUSH
76641: LD_INT 2
76643: ARRAY
76644: PPUSH
76645: CALL_OW 488
76649: IFFALSE 76680
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76651: LD_VAR 0 13
76655: PPUSH
76656: LD_VAR 0 16
76660: PUSH
76661: LD_INT 1
76663: ARRAY
76664: PPUSH
76665: LD_VAR 0 16
76669: PUSH
76670: LD_INT 2
76672: ARRAY
76673: PPUSH
76674: CALL_OW 111
// continue ;
76678: GO 76170
// end ; end ; r := GetDir ( tmp ) ;
76680: LD_ADDR_VAR 0 15
76684: PUSH
76685: LD_VAR 0 13
76689: PPUSH
76690: CALL_OW 254
76694: ST_TO_ADDR
// if r = 5 then
76695: LD_VAR 0 15
76699: PUSH
76700: LD_INT 5
76702: EQUAL
76703: IFFALSE 76713
// r := 0 ;
76705: LD_ADDR_VAR 0 15
76709: PUSH
76710: LD_INT 0
76712: ST_TO_ADDR
// for j = r to 5 do
76713: LD_ADDR_VAR 0 10
76717: PUSH
76718: DOUBLE
76719: LD_VAR 0 15
76723: DEC
76724: ST_TO_ADDR
76725: LD_INT 5
76727: PUSH
76728: FOR_TO
76729: IFFALSE 76843
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76731: LD_ADDR_VAR 0 11
76735: PUSH
76736: LD_VAR 0 13
76740: PPUSH
76741: CALL_OW 250
76745: PPUSH
76746: LD_VAR 0 10
76750: PPUSH
76751: LD_INT 2
76753: PPUSH
76754: CALL_OW 272
76758: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76759: LD_ADDR_VAR 0 12
76763: PUSH
76764: LD_VAR 0 13
76768: PPUSH
76769: CALL_OW 251
76773: PPUSH
76774: LD_VAR 0 10
76778: PPUSH
76779: LD_INT 2
76781: PPUSH
76782: CALL_OW 273
76786: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76787: LD_VAR 0 11
76791: PPUSH
76792: LD_VAR 0 12
76796: PPUSH
76797: CALL_OW 488
76801: PUSH
76802: LD_VAR 0 11
76806: PPUSH
76807: LD_VAR 0 12
76811: PPUSH
76812: CALL_OW 428
76816: NOT
76817: AND
76818: IFFALSE 76841
// begin ComMoveXY ( tmp , _x , _y ) ;
76820: LD_VAR 0 13
76824: PPUSH
76825: LD_VAR 0 11
76829: PPUSH
76830: LD_VAR 0 12
76834: PPUSH
76835: CALL_OW 111
// break ;
76839: GO 76843
// end ; end ;
76841: GO 76728
76843: POP
76844: POP
// end ; end ;
76845: GO 76170
76847: POP
76848: POP
// end ;
76849: LD_VAR 0 8
76853: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76854: LD_INT 0
76856: PPUSH
// result := true ;
76857: LD_ADDR_VAR 0 3
76861: PUSH
76862: LD_INT 1
76864: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76865: LD_VAR 0 2
76869: PUSH
76870: LD_INT 24
76872: DOUBLE
76873: EQUAL
76874: IFTRUE 76884
76876: LD_INT 33
76878: DOUBLE
76879: EQUAL
76880: IFTRUE 76884
76882: GO 76909
76884: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76885: LD_ADDR_VAR 0 3
76889: PUSH
76890: LD_INT 32
76892: PPUSH
76893: LD_VAR 0 1
76897: PPUSH
76898: CALL_OW 321
76902: PUSH
76903: LD_INT 2
76905: EQUAL
76906: ST_TO_ADDR
76907: GO 77225
76909: LD_INT 20
76911: DOUBLE
76912: EQUAL
76913: IFTRUE 76917
76915: GO 76942
76917: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76918: LD_ADDR_VAR 0 3
76922: PUSH
76923: LD_INT 6
76925: PPUSH
76926: LD_VAR 0 1
76930: PPUSH
76931: CALL_OW 321
76935: PUSH
76936: LD_INT 2
76938: EQUAL
76939: ST_TO_ADDR
76940: GO 77225
76942: LD_INT 22
76944: DOUBLE
76945: EQUAL
76946: IFTRUE 76956
76948: LD_INT 36
76950: DOUBLE
76951: EQUAL
76952: IFTRUE 76956
76954: GO 76981
76956: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76957: LD_ADDR_VAR 0 3
76961: PUSH
76962: LD_INT 15
76964: PPUSH
76965: LD_VAR 0 1
76969: PPUSH
76970: CALL_OW 321
76974: PUSH
76975: LD_INT 2
76977: EQUAL
76978: ST_TO_ADDR
76979: GO 77225
76981: LD_INT 30
76983: DOUBLE
76984: EQUAL
76985: IFTRUE 76989
76987: GO 77014
76989: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76990: LD_ADDR_VAR 0 3
76994: PUSH
76995: LD_INT 20
76997: PPUSH
76998: LD_VAR 0 1
77002: PPUSH
77003: CALL_OW 321
77007: PUSH
77008: LD_INT 2
77010: EQUAL
77011: ST_TO_ADDR
77012: GO 77225
77014: LD_INT 28
77016: DOUBLE
77017: EQUAL
77018: IFTRUE 77028
77020: LD_INT 21
77022: DOUBLE
77023: EQUAL
77024: IFTRUE 77028
77026: GO 77053
77028: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
77029: LD_ADDR_VAR 0 3
77033: PUSH
77034: LD_INT 21
77036: PPUSH
77037: LD_VAR 0 1
77041: PPUSH
77042: CALL_OW 321
77046: PUSH
77047: LD_INT 2
77049: EQUAL
77050: ST_TO_ADDR
77051: GO 77225
77053: LD_INT 16
77055: DOUBLE
77056: EQUAL
77057: IFTRUE 77061
77059: GO 77086
77061: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
77062: LD_ADDR_VAR 0 3
77066: PUSH
77067: LD_INT 84
77069: PPUSH
77070: LD_VAR 0 1
77074: PPUSH
77075: CALL_OW 321
77079: PUSH
77080: LD_INT 2
77082: EQUAL
77083: ST_TO_ADDR
77084: GO 77225
77086: LD_INT 19
77088: DOUBLE
77089: EQUAL
77090: IFTRUE 77100
77092: LD_INT 23
77094: DOUBLE
77095: EQUAL
77096: IFTRUE 77100
77098: GO 77125
77100: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
77101: LD_ADDR_VAR 0 3
77105: PUSH
77106: LD_INT 83
77108: PPUSH
77109: LD_VAR 0 1
77113: PPUSH
77114: CALL_OW 321
77118: PUSH
77119: LD_INT 2
77121: EQUAL
77122: ST_TO_ADDR
77123: GO 77225
77125: LD_INT 17
77127: DOUBLE
77128: EQUAL
77129: IFTRUE 77133
77131: GO 77158
77133: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
77134: LD_ADDR_VAR 0 3
77138: PUSH
77139: LD_INT 39
77141: PPUSH
77142: LD_VAR 0 1
77146: PPUSH
77147: CALL_OW 321
77151: PUSH
77152: LD_INT 2
77154: EQUAL
77155: ST_TO_ADDR
77156: GO 77225
77158: LD_INT 18
77160: DOUBLE
77161: EQUAL
77162: IFTRUE 77166
77164: GO 77191
77166: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
77167: LD_ADDR_VAR 0 3
77171: PUSH
77172: LD_INT 40
77174: PPUSH
77175: LD_VAR 0 1
77179: PPUSH
77180: CALL_OW 321
77184: PUSH
77185: LD_INT 2
77187: EQUAL
77188: ST_TO_ADDR
77189: GO 77225
77191: LD_INT 27
77193: DOUBLE
77194: EQUAL
77195: IFTRUE 77199
77197: GO 77224
77199: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
77200: LD_ADDR_VAR 0 3
77204: PUSH
77205: LD_INT 35
77207: PPUSH
77208: LD_VAR 0 1
77212: PPUSH
77213: CALL_OW 321
77217: PUSH
77218: LD_INT 2
77220: EQUAL
77221: ST_TO_ADDR
77222: GO 77225
77224: POP
// end ;
77225: LD_VAR 0 3
77229: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
77230: LD_INT 0
77232: PPUSH
77233: PPUSH
77234: PPUSH
77235: PPUSH
77236: PPUSH
77237: PPUSH
77238: PPUSH
77239: PPUSH
77240: PPUSH
77241: PPUSH
77242: PPUSH
// result := false ;
77243: LD_ADDR_VAR 0 6
77247: PUSH
77248: LD_INT 0
77250: ST_TO_ADDR
// if btype = b_depot then
77251: LD_VAR 0 2
77255: PUSH
77256: LD_INT 0
77258: EQUAL
77259: IFFALSE 77271
// begin result := true ;
77261: LD_ADDR_VAR 0 6
77265: PUSH
77266: LD_INT 1
77268: ST_TO_ADDR
// exit ;
77269: GO 78097
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77271: LD_VAR 0 1
77275: NOT
77276: PUSH
77277: LD_VAR 0 1
77281: PPUSH
77282: CALL_OW 266
77286: PUSH
77287: LD_INT 0
77289: PUSH
77290: LD_INT 1
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: IN
77297: NOT
77298: OR
77299: PUSH
77300: LD_VAR 0 2
77304: NOT
77305: OR
77306: PUSH
77307: LD_VAR 0 5
77311: PUSH
77312: LD_INT 0
77314: PUSH
77315: LD_INT 1
77317: PUSH
77318: LD_INT 2
77320: PUSH
77321: LD_INT 3
77323: PUSH
77324: LD_INT 4
77326: PUSH
77327: LD_INT 5
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: LIST
77334: LIST
77335: LIST
77336: LIST
77337: IN
77338: NOT
77339: OR
77340: PUSH
77341: LD_VAR 0 3
77345: PPUSH
77346: LD_VAR 0 4
77350: PPUSH
77351: CALL_OW 488
77355: NOT
77356: OR
77357: IFFALSE 77361
// exit ;
77359: GO 78097
// side := GetSide ( depot ) ;
77361: LD_ADDR_VAR 0 9
77365: PUSH
77366: LD_VAR 0 1
77370: PPUSH
77371: CALL_OW 255
77375: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
77376: LD_VAR 0 9
77380: PPUSH
77381: LD_VAR 0 2
77385: PPUSH
77386: CALL 76854 0 2
77390: NOT
77391: IFFALSE 77395
// exit ;
77393: GO 78097
// pom := GetBase ( depot ) ;
77395: LD_ADDR_VAR 0 10
77399: PUSH
77400: LD_VAR 0 1
77404: PPUSH
77405: CALL_OW 274
77409: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77410: LD_ADDR_VAR 0 11
77414: PUSH
77415: LD_VAR 0 2
77419: PPUSH
77420: LD_VAR 0 1
77424: PPUSH
77425: CALL_OW 248
77429: PPUSH
77430: CALL_OW 450
77434: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77435: LD_VAR 0 10
77439: PPUSH
77440: LD_INT 1
77442: PPUSH
77443: CALL_OW 275
77447: PUSH
77448: LD_VAR 0 11
77452: PUSH
77453: LD_INT 1
77455: ARRAY
77456: GREATEREQUAL
77457: PUSH
77458: LD_VAR 0 10
77462: PPUSH
77463: LD_INT 2
77465: PPUSH
77466: CALL_OW 275
77470: PUSH
77471: LD_VAR 0 11
77475: PUSH
77476: LD_INT 2
77478: ARRAY
77479: GREATEREQUAL
77480: AND
77481: PUSH
77482: LD_VAR 0 10
77486: PPUSH
77487: LD_INT 3
77489: PPUSH
77490: CALL_OW 275
77494: PUSH
77495: LD_VAR 0 11
77499: PUSH
77500: LD_INT 3
77502: ARRAY
77503: GREATEREQUAL
77504: AND
77505: NOT
77506: IFFALSE 77510
// exit ;
77508: GO 78097
// if GetBType ( depot ) = b_depot then
77510: LD_VAR 0 1
77514: PPUSH
77515: CALL_OW 266
77519: PUSH
77520: LD_INT 0
77522: EQUAL
77523: IFFALSE 77535
// dist := 28 else
77525: LD_ADDR_VAR 0 14
77529: PUSH
77530: LD_INT 28
77532: ST_TO_ADDR
77533: GO 77543
// dist := 36 ;
77535: LD_ADDR_VAR 0 14
77539: PUSH
77540: LD_INT 36
77542: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77543: LD_VAR 0 1
77547: PPUSH
77548: LD_VAR 0 3
77552: PPUSH
77553: LD_VAR 0 4
77557: PPUSH
77558: CALL_OW 297
77562: PUSH
77563: LD_VAR 0 14
77567: GREATER
77568: IFFALSE 77572
// exit ;
77570: GO 78097
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77572: LD_ADDR_VAR 0 12
77576: PUSH
77577: LD_VAR 0 2
77581: PPUSH
77582: LD_VAR 0 3
77586: PPUSH
77587: LD_VAR 0 4
77591: PPUSH
77592: LD_VAR 0 5
77596: PPUSH
77597: LD_VAR 0 1
77601: PPUSH
77602: CALL_OW 248
77606: PPUSH
77607: LD_INT 0
77609: PPUSH
77610: CALL 78102 0 6
77614: ST_TO_ADDR
// if not hexes then
77615: LD_VAR 0 12
77619: NOT
77620: IFFALSE 77624
// exit ;
77622: GO 78097
// hex := GetHexInfo ( x , y ) ;
77624: LD_ADDR_VAR 0 15
77628: PUSH
77629: LD_VAR 0 3
77633: PPUSH
77634: LD_VAR 0 4
77638: PPUSH
77639: CALL_OW 546
77643: ST_TO_ADDR
// if hex [ 1 ] then
77644: LD_VAR 0 15
77648: PUSH
77649: LD_INT 1
77651: ARRAY
77652: IFFALSE 77656
// exit ;
77654: GO 78097
// height := hex [ 2 ] ;
77656: LD_ADDR_VAR 0 13
77660: PUSH
77661: LD_VAR 0 15
77665: PUSH
77666: LD_INT 2
77668: ARRAY
77669: ST_TO_ADDR
// for i = 1 to hexes do
77670: LD_ADDR_VAR 0 7
77674: PUSH
77675: DOUBLE
77676: LD_INT 1
77678: DEC
77679: ST_TO_ADDR
77680: LD_VAR 0 12
77684: PUSH
77685: FOR_TO
77686: IFFALSE 78016
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77688: LD_VAR 0 12
77692: PUSH
77693: LD_VAR 0 7
77697: ARRAY
77698: PUSH
77699: LD_INT 1
77701: ARRAY
77702: PPUSH
77703: LD_VAR 0 12
77707: PUSH
77708: LD_VAR 0 7
77712: ARRAY
77713: PUSH
77714: LD_INT 2
77716: ARRAY
77717: PPUSH
77718: CALL_OW 488
77722: NOT
77723: PUSH
77724: LD_VAR 0 12
77728: PUSH
77729: LD_VAR 0 7
77733: ARRAY
77734: PUSH
77735: LD_INT 1
77737: ARRAY
77738: PPUSH
77739: LD_VAR 0 12
77743: PUSH
77744: LD_VAR 0 7
77748: ARRAY
77749: PUSH
77750: LD_INT 2
77752: ARRAY
77753: PPUSH
77754: CALL_OW 428
77758: PUSH
77759: LD_INT 0
77761: GREATER
77762: OR
77763: PUSH
77764: LD_VAR 0 12
77768: PUSH
77769: LD_VAR 0 7
77773: ARRAY
77774: PUSH
77775: LD_INT 1
77777: ARRAY
77778: PPUSH
77779: LD_VAR 0 12
77783: PUSH
77784: LD_VAR 0 7
77788: ARRAY
77789: PUSH
77790: LD_INT 2
77792: ARRAY
77793: PPUSH
77794: CALL_OW 351
77798: OR
77799: IFFALSE 77805
// exit ;
77801: POP
77802: POP
77803: GO 78097
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77805: LD_ADDR_VAR 0 8
77809: PUSH
77810: LD_VAR 0 12
77814: PUSH
77815: LD_VAR 0 7
77819: ARRAY
77820: PUSH
77821: LD_INT 1
77823: ARRAY
77824: PPUSH
77825: LD_VAR 0 12
77829: PUSH
77830: LD_VAR 0 7
77834: ARRAY
77835: PUSH
77836: LD_INT 2
77838: ARRAY
77839: PPUSH
77840: CALL_OW 546
77844: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77845: LD_VAR 0 8
77849: PUSH
77850: LD_INT 1
77852: ARRAY
77853: PUSH
77854: LD_VAR 0 8
77858: PUSH
77859: LD_INT 2
77861: ARRAY
77862: PUSH
77863: LD_VAR 0 13
77867: PUSH
77868: LD_INT 2
77870: PLUS
77871: GREATER
77872: OR
77873: PUSH
77874: LD_VAR 0 8
77878: PUSH
77879: LD_INT 2
77881: ARRAY
77882: PUSH
77883: LD_VAR 0 13
77887: PUSH
77888: LD_INT 2
77890: MINUS
77891: LESS
77892: OR
77893: PUSH
77894: LD_VAR 0 8
77898: PUSH
77899: LD_INT 3
77901: ARRAY
77902: PUSH
77903: LD_INT 0
77905: PUSH
77906: LD_INT 8
77908: PUSH
77909: LD_INT 9
77911: PUSH
77912: LD_INT 10
77914: PUSH
77915: LD_INT 11
77917: PUSH
77918: LD_INT 12
77920: PUSH
77921: LD_INT 13
77923: PUSH
77924: LD_INT 16
77926: PUSH
77927: LD_INT 17
77929: PUSH
77930: LD_INT 18
77932: PUSH
77933: LD_INT 19
77935: PUSH
77936: LD_INT 20
77938: PUSH
77939: LD_INT 21
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: LIST
77946: LIST
77947: LIST
77948: LIST
77949: LIST
77950: LIST
77951: LIST
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: IN
77957: NOT
77958: OR
77959: PUSH
77960: LD_VAR 0 8
77964: PUSH
77965: LD_INT 5
77967: ARRAY
77968: NOT
77969: OR
77970: PUSH
77971: LD_VAR 0 8
77975: PUSH
77976: LD_INT 6
77978: ARRAY
77979: PUSH
77980: LD_INT 1
77982: PUSH
77983: LD_INT 2
77985: PUSH
77986: LD_INT 7
77988: PUSH
77989: LD_INT 9
77991: PUSH
77992: LD_INT 10
77994: PUSH
77995: LD_INT 11
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: IN
78006: NOT
78007: OR
78008: IFFALSE 78014
// exit ;
78010: POP
78011: POP
78012: GO 78097
// end ;
78014: GO 77685
78016: POP
78017: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78018: LD_VAR 0 9
78022: PPUSH
78023: LD_VAR 0 3
78027: PPUSH
78028: LD_VAR 0 4
78032: PPUSH
78033: LD_INT 20
78035: PPUSH
78036: CALL 70020 0 4
78040: PUSH
78041: LD_INT 4
78043: ARRAY
78044: IFFALSE 78048
// exit ;
78046: GO 78097
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78048: LD_VAR 0 2
78052: PUSH
78053: LD_INT 29
78055: PUSH
78056: LD_INT 30
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: IN
78063: PUSH
78064: LD_VAR 0 3
78068: PPUSH
78069: LD_VAR 0 4
78073: PPUSH
78074: LD_VAR 0 9
78078: PPUSH
78079: CALL_OW 440
78083: NOT
78084: AND
78085: IFFALSE 78089
// exit ;
78087: GO 78097
// result := true ;
78089: LD_ADDR_VAR 0 6
78093: PUSH
78094: LD_INT 1
78096: ST_TO_ADDR
// end ;
78097: LD_VAR 0 6
78101: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78102: LD_INT 0
78104: PPUSH
78105: PPUSH
78106: PPUSH
78107: PPUSH
78108: PPUSH
78109: PPUSH
78110: PPUSH
78111: PPUSH
78112: PPUSH
78113: PPUSH
78114: PPUSH
78115: PPUSH
78116: PPUSH
78117: PPUSH
78118: PPUSH
78119: PPUSH
78120: PPUSH
78121: PPUSH
78122: PPUSH
78123: PPUSH
78124: PPUSH
78125: PPUSH
78126: PPUSH
78127: PPUSH
78128: PPUSH
78129: PPUSH
78130: PPUSH
78131: PPUSH
78132: PPUSH
78133: PPUSH
78134: PPUSH
78135: PPUSH
78136: PPUSH
78137: PPUSH
78138: PPUSH
78139: PPUSH
78140: PPUSH
78141: PPUSH
78142: PPUSH
78143: PPUSH
78144: PPUSH
78145: PPUSH
78146: PPUSH
78147: PPUSH
78148: PPUSH
78149: PPUSH
78150: PPUSH
78151: PPUSH
78152: PPUSH
78153: PPUSH
78154: PPUSH
78155: PPUSH
78156: PPUSH
78157: PPUSH
78158: PPUSH
78159: PPUSH
78160: PPUSH
78161: PPUSH
// result = [ ] ;
78162: LD_ADDR_VAR 0 7
78166: PUSH
78167: EMPTY
78168: ST_TO_ADDR
// temp_list = [ ] ;
78169: LD_ADDR_VAR 0 9
78173: PUSH
78174: EMPTY
78175: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78176: LD_VAR 0 4
78180: PUSH
78181: LD_INT 0
78183: PUSH
78184: LD_INT 1
78186: PUSH
78187: LD_INT 2
78189: PUSH
78190: LD_INT 3
78192: PUSH
78193: LD_INT 4
78195: PUSH
78196: LD_INT 5
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: LIST
78203: LIST
78204: LIST
78205: LIST
78206: IN
78207: NOT
78208: PUSH
78209: LD_VAR 0 1
78213: PUSH
78214: LD_INT 0
78216: PUSH
78217: LD_INT 1
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: IN
78224: PUSH
78225: LD_VAR 0 5
78229: PUSH
78230: LD_INT 1
78232: PUSH
78233: LD_INT 2
78235: PUSH
78236: LD_INT 3
78238: PUSH
78239: EMPTY
78240: LIST
78241: LIST
78242: LIST
78243: IN
78244: NOT
78245: AND
78246: OR
78247: IFFALSE 78251
// exit ;
78249: GO 96642
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78251: LD_VAR 0 1
78255: PUSH
78256: LD_INT 6
78258: PUSH
78259: LD_INT 7
78261: PUSH
78262: LD_INT 8
78264: PUSH
78265: LD_INT 13
78267: PUSH
78268: LD_INT 12
78270: PUSH
78271: LD_INT 15
78273: PUSH
78274: LD_INT 11
78276: PUSH
78277: LD_INT 14
78279: PUSH
78280: LD_INT 10
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: IN
78294: IFFALSE 78304
// btype = b_lab ;
78296: LD_ADDR_VAR 0 1
78300: PUSH
78301: LD_INT 6
78303: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78304: LD_VAR 0 6
78308: PUSH
78309: LD_INT 0
78311: PUSH
78312: LD_INT 1
78314: PUSH
78315: LD_INT 2
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: LIST
78322: IN
78323: NOT
78324: PUSH
78325: LD_VAR 0 1
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: LD_INT 1
78335: PUSH
78336: LD_INT 2
78338: PUSH
78339: LD_INT 3
78341: PUSH
78342: LD_INT 6
78344: PUSH
78345: LD_INT 36
78347: PUSH
78348: LD_INT 4
78350: PUSH
78351: LD_INT 5
78353: PUSH
78354: LD_INT 31
78356: PUSH
78357: LD_INT 32
78359: PUSH
78360: LD_INT 33
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: IN
78376: NOT
78377: PUSH
78378: LD_VAR 0 6
78382: PUSH
78383: LD_INT 1
78385: EQUAL
78386: AND
78387: OR
78388: PUSH
78389: LD_VAR 0 1
78393: PUSH
78394: LD_INT 2
78396: PUSH
78397: LD_INT 3
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: IN
78404: NOT
78405: PUSH
78406: LD_VAR 0 6
78410: PUSH
78411: LD_INT 2
78413: EQUAL
78414: AND
78415: OR
78416: IFFALSE 78426
// mode = 0 ;
78418: LD_ADDR_VAR 0 6
78422: PUSH
78423: LD_INT 0
78425: ST_TO_ADDR
// case mode of 0 :
78426: LD_VAR 0 6
78430: PUSH
78431: LD_INT 0
78433: DOUBLE
78434: EQUAL
78435: IFTRUE 78439
78437: GO 89892
78439: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78440: LD_ADDR_VAR 0 11
78444: PUSH
78445: LD_INT 0
78447: PUSH
78448: LD_INT 0
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: LD_INT 1
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: PUSH
78469: LD_INT 0
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 1
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 1
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: NEG
78499: PUSH
78500: LD_INT 0
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 1
78509: NEG
78510: PUSH
78511: LD_INT 1
78513: NEG
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 1
78521: NEG
78522: PUSH
78523: LD_INT 2
78525: NEG
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 0
78533: PUSH
78534: LD_INT 2
78536: NEG
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 1
78544: PUSH
78545: LD_INT 1
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 1
78555: PUSH
78556: LD_INT 2
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 0
78565: PUSH
78566: LD_INT 2
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: LD_INT 1
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 1
78586: PUSH
78587: LD_INT 3
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 0
78596: PUSH
78597: LD_INT 3
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 1
78606: NEG
78607: PUSH
78608: LD_INT 2
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: LIST
78619: LIST
78620: LIST
78621: LIST
78622: LIST
78623: LIST
78624: LIST
78625: LIST
78626: LIST
78627: LIST
78628: LIST
78629: LIST
78630: LIST
78631: LIST
78632: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78633: LD_ADDR_VAR 0 12
78637: PUSH
78638: LD_INT 0
78640: PUSH
78641: LD_INT 0
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 0
78650: PUSH
78651: LD_INT 1
78653: NEG
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 1
78671: PUSH
78672: LD_INT 1
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 0
78681: PUSH
78682: LD_INT 1
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 1
78691: NEG
78692: PUSH
78693: LD_INT 0
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 1
78702: NEG
78703: PUSH
78704: LD_INT 1
78706: NEG
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 1
78714: PUSH
78715: LD_INT 1
78717: NEG
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: PUSH
78723: LD_INT 2
78725: PUSH
78726: LD_INT 0
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: LD_INT 2
78735: PUSH
78736: LD_INT 1
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 1
78745: NEG
78746: PUSH
78747: LD_INT 1
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 2
78756: NEG
78757: PUSH
78758: LD_INT 0
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 2
78767: NEG
78768: PUSH
78769: LD_INT 1
78771: NEG
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 2
78779: NEG
78780: PUSH
78781: LD_INT 1
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: NEG
78791: PUSH
78792: LD_INT 0
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 3
78801: NEG
78802: PUSH
78803: LD_INT 1
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78829: LD_ADDR_VAR 0 13
78833: PUSH
78834: LD_INT 0
78836: PUSH
78837: LD_INT 0
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 0
78846: PUSH
78847: LD_INT 1
78849: NEG
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 1
78857: PUSH
78858: LD_INT 0
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: PUSH
78865: LD_INT 1
78867: PUSH
78868: LD_INT 1
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 0
78877: PUSH
78878: LD_INT 1
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 1
78887: NEG
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 1
78898: NEG
78899: PUSH
78900: LD_INT 1
78902: NEG
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: LD_INT 1
78910: NEG
78911: PUSH
78912: LD_INT 2
78914: NEG
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 2
78922: PUSH
78923: LD_INT 1
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 2
78932: PUSH
78933: LD_INT 2
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 1
78942: PUSH
78943: LD_INT 2
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 2
78952: NEG
78953: PUSH
78954: LD_INT 1
78956: NEG
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 2
78964: NEG
78965: PUSH
78966: LD_INT 2
78968: NEG
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 2
78976: NEG
78977: PUSH
78978: LD_INT 3
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 3
78988: NEG
78989: PUSH
78990: LD_INT 2
78992: NEG
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 3
79000: NEG
79001: PUSH
79002: LD_INT 3
79004: NEG
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79028: LD_ADDR_VAR 0 14
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 0
79045: PUSH
79046: LD_INT 1
79048: NEG
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 1
79056: PUSH
79057: LD_INT 0
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 1
79066: PUSH
79067: LD_INT 1
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 0
79076: PUSH
79077: LD_INT 1
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 1
79086: NEG
79087: PUSH
79088: LD_INT 0
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 1
79097: NEG
79098: PUSH
79099: LD_INT 1
79101: NEG
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 1
79109: NEG
79110: PUSH
79111: LD_INT 2
79113: NEG
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 0
79121: PUSH
79122: LD_INT 2
79124: NEG
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 1
79132: PUSH
79133: LD_INT 1
79135: NEG
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: LD_INT 2
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 0
79153: PUSH
79154: LD_INT 2
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 1
79163: NEG
79164: PUSH
79165: LD_INT 1
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 1
79174: NEG
79175: PUSH
79176: LD_INT 3
79178: NEG
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 0
79186: PUSH
79187: LD_INT 3
79189: NEG
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 1
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: LIST
79210: LIST
79211: LIST
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79224: LD_ADDR_VAR 0 15
79228: PUSH
79229: LD_INT 0
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 0
79241: PUSH
79242: LD_INT 1
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 1
79252: PUSH
79253: LD_INT 0
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 1
79262: PUSH
79263: LD_INT 1
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 0
79272: PUSH
79273: LD_INT 1
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 1
79282: NEG
79283: PUSH
79284: LD_INT 0
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 1
79293: NEG
79294: PUSH
79295: LD_INT 1
79297: NEG
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 1
79305: PUSH
79306: LD_INT 1
79308: NEG
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 2
79316: PUSH
79317: LD_INT 0
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 2
79326: PUSH
79327: LD_INT 1
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 1
79336: NEG
79337: PUSH
79338: LD_INT 1
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 2
79347: NEG
79348: PUSH
79349: LD_INT 0
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 2
79358: NEG
79359: PUSH
79360: LD_INT 1
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 2
79370: PUSH
79371: LD_INT 1
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 3
79381: PUSH
79382: LD_INT 0
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 3
79391: PUSH
79392: LD_INT 1
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79417: LD_ADDR_VAR 0 16
79421: PUSH
79422: LD_INT 0
79424: PUSH
79425: LD_INT 0
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: PUSH
79432: LD_INT 0
79434: PUSH
79435: LD_INT 1
79437: NEG
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 1
79445: PUSH
79446: LD_INT 0
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 0
79465: PUSH
79466: LD_INT 1
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 1
79475: NEG
79476: PUSH
79477: LD_INT 0
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: LD_INT 1
79486: NEG
79487: PUSH
79488: LD_INT 1
79490: NEG
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 1
79498: NEG
79499: PUSH
79500: LD_INT 2
79502: NEG
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 2
79510: PUSH
79511: LD_INT 1
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 2
79520: PUSH
79521: LD_INT 2
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 1
79530: PUSH
79531: LD_INT 2
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 2
79540: NEG
79541: PUSH
79542: LD_INT 1
79544: NEG
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 2
79552: NEG
79553: PUSH
79554: LD_INT 2
79556: NEG
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 3
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: LD_INT 3
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 2
79584: PUSH
79585: LD_INT 3
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: LIST
79596: LIST
79597: LIST
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79610: LD_ADDR_VAR 0 17
79614: PUSH
79615: LD_INT 0
79617: PUSH
79618: LD_INT 0
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 0
79627: PUSH
79628: LD_INT 1
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 1
79638: PUSH
79639: LD_INT 0
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 1
79648: PUSH
79649: LD_INT 1
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 0
79658: PUSH
79659: LD_INT 1
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: LD_INT 1
79668: NEG
79669: PUSH
79670: LD_INT 0
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 1
79679: NEG
79680: PUSH
79681: LD_INT 1
79683: NEG
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 1
79691: NEG
79692: PUSH
79693: LD_INT 2
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 0
79703: PUSH
79704: LD_INT 2
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 1
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 2
79725: PUSH
79726: LD_INT 0
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 2
79735: PUSH
79736: LD_INT 1
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 2
79745: PUSH
79746: LD_INT 2
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: LD_INT 2
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 0
79765: PUSH
79766: LD_INT 2
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: LD_INT 1
79775: NEG
79776: PUSH
79777: LD_INT 1
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 2
79786: NEG
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 2
79797: NEG
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 2
79809: NEG
79810: PUSH
79811: LD_INT 2
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: LIST
79827: LIST
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: LIST
79839: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79840: LD_ADDR_VAR 0 18
79844: PUSH
79845: LD_INT 0
79847: PUSH
79848: LD_INT 0
79850: PUSH
79851: EMPTY
79852: LIST
79853: LIST
79854: PUSH
79855: LD_INT 0
79857: PUSH
79858: LD_INT 1
79860: NEG
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 1
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 1
79878: PUSH
79879: LD_INT 1
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 0
79888: PUSH
79889: LD_INT 1
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 1
79898: NEG
79899: PUSH
79900: LD_INT 0
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 1
79909: NEG
79910: PUSH
79911: LD_INT 1
79913: NEG
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: NEG
79922: PUSH
79923: LD_INT 2
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 0
79933: PUSH
79934: LD_INT 2
79936: NEG
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: LD_INT 1
79944: PUSH
79945: LD_INT 1
79947: NEG
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: LD_INT 2
79955: PUSH
79956: LD_INT 0
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: LD_INT 1
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: PUSH
79973: LD_INT 2
79975: PUSH
79976: LD_INT 2
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: LD_INT 1
79985: PUSH
79986: LD_INT 2
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: PUSH
79993: LD_INT 0
79995: PUSH
79996: LD_INT 2
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 1
80005: NEG
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 2
80016: NEG
80017: PUSH
80018: LD_INT 0
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 2
80027: NEG
80028: PUSH
80029: LD_INT 1
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: NEG
80040: PUSH
80041: LD_INT 2
80043: NEG
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: LIST
80053: LIST
80054: LIST
80055: LIST
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80070: LD_ADDR_VAR 0 19
80074: PUSH
80075: LD_INT 0
80077: PUSH
80078: LD_INT 0
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 0
80087: PUSH
80088: LD_INT 1
80090: NEG
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 1
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 1
80108: PUSH
80109: LD_INT 1
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 1
80128: NEG
80129: PUSH
80130: LD_INT 0
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 1
80139: NEG
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 2
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 0
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 1
80174: PUSH
80175: LD_INT 1
80177: NEG
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 2
80185: PUSH
80186: LD_INT 0
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 2
80195: PUSH
80196: LD_INT 1
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 2
80205: PUSH
80206: LD_INT 2
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 1
80215: PUSH
80216: LD_INT 2
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 0
80225: PUSH
80226: LD_INT 2
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 1
80235: NEG
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 2
80246: NEG
80247: PUSH
80248: LD_INT 0
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 2
80257: NEG
80258: PUSH
80259: LD_INT 1
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 2
80269: NEG
80270: PUSH
80271: LD_INT 2
80273: NEG
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80300: LD_ADDR_VAR 0 20
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 0
80317: PUSH
80318: LD_INT 1
80320: NEG
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: LD_INT 0
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 1
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 0
80348: PUSH
80349: LD_INT 1
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 1
80358: NEG
80359: PUSH
80360: LD_INT 0
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 1
80369: NEG
80370: PUSH
80371: LD_INT 1
80373: NEG
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 1
80381: NEG
80382: PUSH
80383: LD_INT 2
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 0
80393: PUSH
80394: LD_INT 2
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 1
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 2
80415: PUSH
80416: LD_INT 0
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 2
80425: PUSH
80426: LD_INT 1
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 2
80435: PUSH
80436: LD_INT 2
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: PUSH
80446: LD_INT 2
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 0
80455: PUSH
80456: LD_INT 2
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 1
80465: NEG
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 2
80476: NEG
80477: PUSH
80478: LD_INT 0
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 2
80487: NEG
80488: PUSH
80489: LD_INT 1
80491: NEG
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 2
80499: NEG
80500: PUSH
80501: LD_INT 2
80503: NEG
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: LIST
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80530: LD_ADDR_VAR 0 21
80534: PUSH
80535: LD_INT 0
80537: PUSH
80538: LD_INT 0
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 0
80547: PUSH
80548: LD_INT 1
80550: NEG
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 1
80558: PUSH
80559: LD_INT 0
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 1
80568: PUSH
80569: LD_INT 1
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 0
80578: PUSH
80579: LD_INT 1
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 1
80588: NEG
80589: PUSH
80590: LD_INT 0
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 1
80599: NEG
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: LD_INT 2
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: LD_INT 2
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 2
80645: PUSH
80646: LD_INT 0
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 2
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 2
80665: PUSH
80666: LD_INT 2
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: PUSH
80676: LD_INT 2
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 0
80685: PUSH
80686: LD_INT 2
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 1
80695: NEG
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 2
80706: NEG
80707: PUSH
80708: LD_INT 0
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 2
80717: NEG
80718: PUSH
80719: LD_INT 1
80721: NEG
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: LD_INT 2
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80760: LD_ADDR_VAR 0 22
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: LD_INT 0
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 0
80777: PUSH
80778: LD_INT 1
80780: NEG
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 1
80788: PUSH
80789: LD_INT 0
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 1
80798: PUSH
80799: LD_INT 1
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: LD_INT 0
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 1
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 2
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: LD_INT 2
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: LD_INT 1
80867: NEG
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 2
80875: PUSH
80876: LD_INT 0
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 2
80885: PUSH
80886: LD_INT 1
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 2
80895: PUSH
80896: LD_INT 2
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: PUSH
80906: LD_INT 2
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 0
80915: PUSH
80916: LD_INT 2
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 1
80925: NEG
80926: PUSH
80927: LD_INT 1
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 2
80936: NEG
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 2
80947: NEG
80948: PUSH
80949: LD_INT 1
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 2
80959: NEG
80960: PUSH
80961: LD_INT 2
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80990: LD_ADDR_VAR 0 23
80994: PUSH
80995: LD_INT 0
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 0
81007: PUSH
81008: LD_INT 1
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 1
81018: PUSH
81019: LD_INT 0
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 1
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 0
81038: PUSH
81039: LD_INT 1
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: PUSH
81046: LD_INT 1
81048: NEG
81049: PUSH
81050: LD_INT 0
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 1
81059: NEG
81060: PUSH
81061: LD_INT 1
81063: NEG
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: NEG
81072: PUSH
81073: LD_INT 2
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 0
81083: PUSH
81084: LD_INT 2
81086: NEG
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 1
81094: PUSH
81095: LD_INT 1
81097: NEG
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 2
81105: PUSH
81106: LD_INT 0
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 2
81115: PUSH
81116: LD_INT 1
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 2
81125: PUSH
81126: LD_INT 2
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 1
81135: PUSH
81136: LD_INT 2
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 0
81145: PUSH
81146: LD_INT 2
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 1
81155: NEG
81156: PUSH
81157: LD_INT 1
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 2
81166: NEG
81167: PUSH
81168: LD_INT 0
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 2
81177: NEG
81178: PUSH
81179: LD_INT 1
81181: NEG
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 2
81189: NEG
81190: PUSH
81191: LD_INT 2
81193: NEG
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 2
81201: NEG
81202: PUSH
81203: LD_INT 3
81205: NEG
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 1
81213: NEG
81214: PUSH
81215: LD_INT 3
81217: NEG
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 1
81225: PUSH
81226: LD_INT 2
81228: NEG
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 2
81236: PUSH
81237: LD_INT 1
81239: NEG
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81270: LD_ADDR_VAR 0 24
81274: PUSH
81275: LD_INT 0
81277: PUSH
81278: LD_INT 0
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 0
81287: PUSH
81288: LD_INT 1
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 1
81298: PUSH
81299: LD_INT 0
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 1
81308: PUSH
81309: LD_INT 1
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 0
81318: PUSH
81319: LD_INT 1
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 1
81328: NEG
81329: PUSH
81330: LD_INT 0
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 1
81339: NEG
81340: PUSH
81341: LD_INT 1
81343: NEG
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 1
81351: NEG
81352: PUSH
81353: LD_INT 2
81355: NEG
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 0
81363: PUSH
81364: LD_INT 2
81366: NEG
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 1
81374: PUSH
81375: LD_INT 1
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 2
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 2
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 2
81405: PUSH
81406: LD_INT 2
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 1
81415: PUSH
81416: LD_INT 2
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: LD_INT 2
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: LD_INT 1
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 2
81446: NEG
81447: PUSH
81448: LD_INT 0
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 2
81457: NEG
81458: PUSH
81459: LD_INT 1
81461: NEG
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 2
81469: NEG
81470: PUSH
81471: LD_INT 2
81473: NEG
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 1
81481: PUSH
81482: LD_INT 2
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 2
81492: PUSH
81493: LD_INT 1
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 3
81503: PUSH
81504: LD_INT 1
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 3
81513: PUSH
81514: LD_INT 2
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81546: LD_ADDR_VAR 0 25
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: LD_INT 0
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 0
81563: PUSH
81564: LD_INT 1
81566: NEG
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 1
81574: PUSH
81575: LD_INT 0
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 1
81584: PUSH
81585: LD_INT 1
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 0
81594: PUSH
81595: LD_INT 1
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: LD_INT 1
81604: NEG
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 1
81615: NEG
81616: PUSH
81617: LD_INT 1
81619: NEG
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 1
81627: NEG
81628: PUSH
81629: LD_INT 2
81631: NEG
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 0
81639: PUSH
81640: LD_INT 2
81642: NEG
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 1
81650: PUSH
81651: LD_INT 1
81653: NEG
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 2
81661: PUSH
81662: LD_INT 0
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 2
81671: PUSH
81672: LD_INT 1
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 2
81681: PUSH
81682: LD_INT 2
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 1
81691: PUSH
81692: LD_INT 2
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 0
81701: PUSH
81702: LD_INT 2
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 1
81711: NEG
81712: PUSH
81713: LD_INT 1
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 2
81722: NEG
81723: PUSH
81724: LD_INT 0
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 2
81733: NEG
81734: PUSH
81735: LD_INT 1
81737: NEG
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PUSH
81743: LD_INT 2
81745: NEG
81746: PUSH
81747: LD_INT 2
81749: NEG
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 3
81757: PUSH
81758: LD_INT 1
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 3
81767: PUSH
81768: LD_INT 2
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 2
81777: PUSH
81778: LD_INT 3
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 3
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81820: LD_ADDR_VAR 0 26
81824: PUSH
81825: LD_INT 0
81827: PUSH
81828: LD_INT 0
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 0
81837: PUSH
81838: LD_INT 1
81840: NEG
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 1
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: LD_INT 1
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 0
81868: PUSH
81869: LD_INT 1
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 1
81878: NEG
81879: PUSH
81880: LD_INT 0
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 1
81889: NEG
81890: PUSH
81891: LD_INT 1
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 1
81901: NEG
81902: PUSH
81903: LD_INT 2
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: LD_INT 2
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 1
81924: PUSH
81925: LD_INT 1
81927: NEG
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 2
81935: PUSH
81936: LD_INT 0
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 2
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 2
81955: PUSH
81956: LD_INT 2
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 1
81965: PUSH
81966: LD_INT 2
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_INT 0
81975: PUSH
81976: LD_INT 2
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 1
81985: NEG
81986: PUSH
81987: LD_INT 1
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 2
81996: NEG
81997: PUSH
81998: LD_INT 0
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: LD_INT 2
82007: NEG
82008: PUSH
82009: LD_INT 1
82011: NEG
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 2
82019: NEG
82020: PUSH
82021: LD_INT 2
82023: NEG
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 2
82031: PUSH
82032: LD_INT 3
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: PUSH
82042: LD_INT 3
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 1
82051: NEG
82052: PUSH
82053: LD_INT 2
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 2
82062: NEG
82063: PUSH
82064: LD_INT 1
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82096: LD_ADDR_VAR 0 27
82100: PUSH
82101: LD_INT 0
82103: PUSH
82104: LD_INT 0
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: LD_INT 1
82116: NEG
82117: PUSH
82118: EMPTY
82119: LIST
82120: LIST
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: LD_INT 0
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 1
82134: PUSH
82135: LD_INT 1
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 0
82144: PUSH
82145: LD_INT 1
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 1
82154: NEG
82155: PUSH
82156: LD_INT 0
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 1
82165: NEG
82166: PUSH
82167: LD_INT 1
82169: NEG
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 1
82177: NEG
82178: PUSH
82179: LD_INT 2
82181: NEG
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 0
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 1
82200: PUSH
82201: LD_INT 1
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 2
82211: PUSH
82212: LD_INT 0
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 2
82221: PUSH
82222: LD_INT 1
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 2
82231: PUSH
82232: LD_INT 2
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 1
82241: PUSH
82242: LD_INT 2
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 0
82251: PUSH
82252: LD_INT 2
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 1
82261: NEG
82262: PUSH
82263: LD_INT 1
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 2
82272: NEG
82273: PUSH
82274: LD_INT 0
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 2
82283: NEG
82284: PUSH
82285: LD_INT 1
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 2
82295: NEG
82296: PUSH
82297: LD_INT 2
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 1
82307: NEG
82308: PUSH
82309: LD_INT 2
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 2
82318: NEG
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 3
82329: NEG
82330: PUSH
82331: LD_INT 1
82333: NEG
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 3
82341: NEG
82342: PUSH
82343: LD_INT 2
82345: NEG
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82376: LD_ADDR_VAR 0 28
82380: PUSH
82381: LD_INT 0
82383: PUSH
82384: LD_INT 0
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 0
82393: PUSH
82394: LD_INT 1
82396: NEG
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 1
82404: PUSH
82405: LD_INT 0
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 1
82414: PUSH
82415: LD_INT 1
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: LD_INT 1
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 1
82434: NEG
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 1
82445: NEG
82446: PUSH
82447: LD_INT 1
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 1
82457: NEG
82458: PUSH
82459: LD_INT 2
82461: NEG
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 0
82469: PUSH
82470: LD_INT 2
82472: NEG
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: LD_INT 1
82483: NEG
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 2
82491: PUSH
82492: LD_INT 0
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 2
82501: PUSH
82502: LD_INT 1
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 2
82511: PUSH
82512: LD_INT 2
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 1
82521: PUSH
82522: LD_INT 2
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 0
82531: PUSH
82532: LD_INT 2
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 1
82541: NEG
82542: PUSH
82543: LD_INT 1
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 2
82552: NEG
82553: PUSH
82554: LD_INT 0
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 2
82563: NEG
82564: PUSH
82565: LD_INT 1
82567: NEG
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 2
82575: NEG
82576: PUSH
82577: LD_INT 2
82579: NEG
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 2
82587: NEG
82588: PUSH
82589: LD_INT 3
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 1
82599: NEG
82600: PUSH
82601: LD_INT 3
82603: NEG
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 3
82611: NEG
82612: PUSH
82613: LD_INT 1
82615: NEG
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 3
82623: NEG
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82658: LD_ADDR_VAR 0 29
82662: PUSH
82663: LD_INT 0
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 0
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: NEG
82728: PUSH
82729: LD_INT 1
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: LD_INT 2
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 1
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 2
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 1
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 0
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: LD_INT 1
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 2
82824: NEG
82825: PUSH
82826: LD_INT 1
82828: NEG
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 2
82836: NEG
82837: PUSH
82838: LD_INT 2
82840: NEG
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 2
82848: NEG
82849: PUSH
82850: LD_INT 3
82852: NEG
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: LD_INT 2
82860: PUSH
82861: LD_INT 1
82863: NEG
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 3
82871: PUSH
82872: LD_INT 1
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: PUSH
82882: LD_INT 3
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 1
82891: NEG
82892: PUSH
82893: LD_INT 2
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 3
82902: NEG
82903: PUSH
82904: LD_INT 2
82906: NEG
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82937: LD_ADDR_VAR 0 30
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: LD_INT 0
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 0
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: LD_INT 1
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: LD_INT 1
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 1
82995: NEG
82996: PUSH
82997: LD_INT 0
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: LD_INT 1
83010: NEG
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 1
83018: NEG
83019: PUSH
83020: LD_INT 2
83022: NEG
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: LD_INT 0
83030: PUSH
83031: LD_INT 2
83033: NEG
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 1
83041: PUSH
83042: LD_INT 1
83044: NEG
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 2
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 2
83062: PUSH
83063: LD_INT 1
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 2
83072: PUSH
83073: LD_INT 2
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 1
83082: PUSH
83083: LD_INT 2
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 1
83092: NEG
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 2
83103: NEG
83104: PUSH
83105: LD_INT 0
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: LD_INT 2
83114: NEG
83115: PUSH
83116: LD_INT 1
83118: NEG
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 1
83126: NEG
83127: PUSH
83128: LD_INT 3
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 1
83138: PUSH
83139: LD_INT 2
83141: NEG
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 3
83149: PUSH
83150: LD_INT 2
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: LD_INT 3
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 2
83169: NEG
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 3
83180: NEG
83181: PUSH
83182: LD_INT 1
83184: NEG
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83215: LD_ADDR_VAR 0 31
83219: PUSH
83220: LD_INT 0
83222: PUSH
83223: LD_INT 0
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: PUSH
83230: LD_INT 0
83232: PUSH
83233: LD_INT 1
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 1
83243: PUSH
83244: LD_INT 0
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 1
83253: PUSH
83254: LD_INT 1
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 0
83263: PUSH
83264: LD_INT 1
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 1
83273: NEG
83274: PUSH
83275: LD_INT 0
83277: PUSH
83278: EMPTY
83279: LIST
83280: LIST
83281: PUSH
83282: LD_INT 1
83284: NEG
83285: PUSH
83286: LD_INT 1
83288: NEG
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 1
83296: NEG
83297: PUSH
83298: LD_INT 2
83300: NEG
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 1
83308: PUSH
83309: LD_INT 1
83311: NEG
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 2
83319: PUSH
83320: LD_INT 0
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: PUSH
83330: LD_INT 1
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 2
83339: PUSH
83340: LD_INT 2
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 1
83349: PUSH
83350: LD_INT 2
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 0
83359: PUSH
83360: LD_INT 2
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: LD_INT 1
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: PUSH
83378: LD_INT 2
83380: NEG
83381: PUSH
83382: LD_INT 1
83384: NEG
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 2
83392: NEG
83393: PUSH
83394: LD_INT 2
83396: NEG
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 2
83404: NEG
83405: PUSH
83406: LD_INT 3
83408: NEG
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 2
83416: PUSH
83417: LD_INT 1
83419: NEG
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 3
83427: PUSH
83428: LD_INT 1
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 1
83437: PUSH
83438: LD_INT 3
83440: PUSH
83441: EMPTY
83442: LIST
83443: LIST
83444: PUSH
83445: LD_INT 1
83447: NEG
83448: PUSH
83449: LD_INT 2
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 3
83458: NEG
83459: PUSH
83460: LD_INT 2
83462: NEG
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83493: LD_ADDR_VAR 0 32
83497: PUSH
83498: LD_INT 0
83500: PUSH
83501: LD_INT 0
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 0
83510: PUSH
83511: LD_INT 1
83513: NEG
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 1
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 1
83531: PUSH
83532: LD_INT 1
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: LD_INT 1
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 1
83551: NEG
83552: PUSH
83553: LD_INT 0
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 1
83562: NEG
83563: PUSH
83564: LD_INT 1
83566: NEG
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 1
83574: NEG
83575: PUSH
83576: LD_INT 2
83578: NEG
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: LD_INT 0
83586: PUSH
83587: LD_INT 2
83589: NEG
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 1
83597: PUSH
83598: LD_INT 1
83600: NEG
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: LD_INT 2
83608: PUSH
83609: LD_INT 1
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 2
83618: PUSH
83619: LD_INT 2
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: PUSH
83629: LD_INT 2
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: LD_INT 2
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: LD_INT 1
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 2
83659: NEG
83660: PUSH
83661: LD_INT 0
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: PUSH
83668: LD_INT 2
83670: NEG
83671: PUSH
83672: LD_INT 1
83674: NEG
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: LD_INT 3
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: PUSH
83695: LD_INT 2
83697: NEG
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 3
83705: PUSH
83706: LD_INT 2
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: LD_INT 2
83715: PUSH
83716: LD_INT 3
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 2
83725: NEG
83726: PUSH
83727: LD_INT 1
83729: PUSH
83730: EMPTY
83731: LIST
83732: LIST
83733: PUSH
83734: LD_INT 3
83736: NEG
83737: PUSH
83738: LD_INT 1
83740: NEG
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83771: LD_ADDR_VAR 0 33
83775: PUSH
83776: LD_INT 0
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 0
83788: PUSH
83789: LD_INT 1
83791: NEG
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 1
83799: PUSH
83800: LD_INT 0
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 1
83809: PUSH
83810: LD_INT 1
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: LD_INT 1
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 1
83829: NEG
83830: PUSH
83831: LD_INT 0
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: LD_INT 1
83844: NEG
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 1
83852: NEG
83853: PUSH
83854: LD_INT 2
83856: NEG
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 1
83864: PUSH
83865: LD_INT 1
83867: NEG
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 2
83875: PUSH
83876: LD_INT 0
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 2
83885: PUSH
83886: LD_INT 1
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 1
83895: PUSH
83896: LD_INT 2
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 0
83905: PUSH
83906: LD_INT 2
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 1
83915: NEG
83916: PUSH
83917: LD_INT 1
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 2
83926: NEG
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 2
83937: NEG
83938: PUSH
83939: LD_INT 1
83941: NEG
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 2
83949: NEG
83950: PUSH
83951: LD_INT 2
83953: NEG
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 2
83961: NEG
83962: PUSH
83963: LD_INT 3
83965: NEG
83966: PUSH
83967: EMPTY
83968: LIST
83969: LIST
83970: PUSH
83971: LD_INT 2
83973: PUSH
83974: LD_INT 1
83976: NEG
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 3
83984: PUSH
83985: LD_INT 1
83987: PUSH
83988: EMPTY
83989: LIST
83990: LIST
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: LD_INT 3
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 1
84004: NEG
84005: PUSH
84006: LD_INT 2
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PUSH
84013: LD_INT 3
84015: NEG
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84050: LD_ADDR_VAR 0 34
84054: PUSH
84055: LD_INT 0
84057: PUSH
84058: LD_INT 0
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 0
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 1
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: PUSH
84089: LD_INT 1
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 1
84119: NEG
84120: PUSH
84121: LD_INT 1
84123: NEG
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: LD_INT 2
84135: NEG
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 0
84143: PUSH
84144: LD_INT 2
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: PUSH
84155: LD_INT 1
84157: NEG
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 2
84165: PUSH
84166: LD_INT 1
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 2
84175: PUSH
84176: LD_INT 2
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 1
84185: PUSH
84186: LD_INT 2
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 1
84195: NEG
84196: PUSH
84197: LD_INT 1
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 2
84206: NEG
84207: PUSH
84208: LD_INT 0
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 2
84217: NEG
84218: PUSH
84219: LD_INT 1
84221: NEG
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 2
84229: NEG
84230: PUSH
84231: LD_INT 2
84233: NEG
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: LD_INT 3
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 1
84253: PUSH
84254: LD_INT 2
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 3
84264: PUSH
84265: LD_INT 2
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 2
84274: PUSH
84275: LD_INT 3
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 2
84284: NEG
84285: PUSH
84286: LD_INT 1
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 3
84295: NEG
84296: PUSH
84297: LD_INT 1
84299: NEG
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84330: LD_ADDR_VAR 0 35
84334: PUSH
84335: LD_INT 0
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 0
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 1
84358: PUSH
84359: LD_INT 0
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 1
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: LD_INT 1
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 1
84388: NEG
84389: PUSH
84390: LD_INT 0
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 2
84411: PUSH
84412: LD_INT 1
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 2
84421: NEG
84422: PUSH
84423: LD_INT 1
84425: NEG
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84442: LD_ADDR_VAR 0 36
84446: PUSH
84447: LD_INT 0
84449: PUSH
84450: LD_INT 0
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 0
84459: PUSH
84460: LD_INT 1
84462: NEG
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 1
84470: PUSH
84471: LD_INT 0
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 1
84480: PUSH
84481: LD_INT 1
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 0
84490: PUSH
84491: LD_INT 1
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: PUSH
84498: LD_INT 1
84500: NEG
84501: PUSH
84502: LD_INT 0
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 1
84511: NEG
84512: PUSH
84513: LD_INT 1
84515: NEG
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 1
84523: NEG
84524: PUSH
84525: LD_INT 2
84527: NEG
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 1
84535: PUSH
84536: LD_INT 2
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PUSH
84543: EMPTY
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84554: LD_ADDR_VAR 0 37
84558: PUSH
84559: LD_INT 0
84561: PUSH
84562: LD_INT 0
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 0
84571: PUSH
84572: LD_INT 1
84574: NEG
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 1
84582: PUSH
84583: LD_INT 0
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 1
84592: PUSH
84593: LD_INT 1
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 0
84602: PUSH
84603: LD_INT 1
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 1
84612: NEG
84613: PUSH
84614: LD_INT 0
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: LD_INT 1
84627: NEG
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 1
84635: PUSH
84636: LD_INT 1
84638: NEG
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 1
84646: NEG
84647: PUSH
84648: LD_INT 1
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84666: LD_ADDR_VAR 0 38
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: LD_INT 1
84686: NEG
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: PUSH
84695: LD_INT 0
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: LD_INT 1
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 0
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 1
84724: NEG
84725: PUSH
84726: LD_INT 0
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 1
84735: NEG
84736: PUSH
84737: LD_INT 1
84739: NEG
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 2
84747: PUSH
84748: LD_INT 1
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 2
84757: NEG
84758: PUSH
84759: LD_INT 1
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84778: LD_ADDR_VAR 0 39
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 0
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 0
84795: PUSH
84796: LD_INT 1
84798: NEG
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: LD_INT 0
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 1
84816: PUSH
84817: LD_INT 1
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 0
84826: PUSH
84827: LD_INT 1
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: LD_INT 1
84836: NEG
84837: PUSH
84838: LD_INT 0
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 1
84847: NEG
84848: PUSH
84849: LD_INT 1
84851: NEG
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: LD_INT 1
84859: NEG
84860: PUSH
84861: LD_INT 2
84863: NEG
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 1
84871: PUSH
84872: LD_INT 2
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84890: LD_ADDR_VAR 0 40
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 0
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 0
84907: PUSH
84908: LD_INT 1
84910: NEG
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: PUSH
84929: LD_INT 1
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: PUSH
84936: LD_INT 0
84938: PUSH
84939: LD_INT 1
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 1
84948: NEG
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: LD_INT 1
84963: NEG
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 1
84971: PUSH
84972: LD_INT 1
84974: NEG
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 1
84982: NEG
84983: PUSH
84984: LD_INT 1
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85002: LD_ADDR_VAR 0 41
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: LD_INT 0
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 0
85019: PUSH
85020: LD_INT 1
85022: NEG
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: PUSH
85031: LD_INT 0
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 1
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 0
85050: PUSH
85051: LD_INT 1
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 1
85060: NEG
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 1
85071: NEG
85072: PUSH
85073: LD_INT 1
85075: NEG
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 1
85083: NEG
85084: PUSH
85085: LD_INT 2
85087: NEG
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 1
85095: PUSH
85096: LD_INT 1
85098: NEG
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 2
85106: PUSH
85107: LD_INT 0
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 2
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 2
85126: PUSH
85127: LD_INT 2
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: LD_INT 1
85136: PUSH
85137: LD_INT 2
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: LD_INT 1
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 2
85157: NEG
85158: PUSH
85159: LD_INT 0
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 2
85168: NEG
85169: PUSH
85170: LD_INT 1
85172: NEG
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 2
85180: NEG
85181: PUSH
85182: LD_INT 2
85184: NEG
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 2
85192: NEG
85193: PUSH
85194: LD_INT 3
85196: NEG
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PUSH
85202: LD_INT 2
85204: PUSH
85205: LD_INT 1
85207: NEG
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 3
85215: PUSH
85216: LD_INT 0
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: PUSH
85223: LD_INT 3
85225: PUSH
85226: LD_INT 1
85228: PUSH
85229: EMPTY
85230: LIST
85231: LIST
85232: PUSH
85233: LD_INT 3
85235: PUSH
85236: LD_INT 2
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 3
85245: PUSH
85246: LD_INT 3
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 2
85255: PUSH
85256: LD_INT 3
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 2
85265: NEG
85266: PUSH
85267: LD_INT 1
85269: PUSH
85270: EMPTY
85271: LIST
85272: LIST
85273: PUSH
85274: LD_INT 3
85276: NEG
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 3
85287: NEG
85288: PUSH
85289: LD_INT 1
85291: NEG
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: PUSH
85297: LD_INT 3
85299: NEG
85300: PUSH
85301: LD_INT 2
85303: NEG
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 3
85311: NEG
85312: PUSH
85313: LD_INT 3
85315: NEG
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85352: LD_ADDR_VAR 0 42
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: LD_INT 0
85362: PUSH
85363: EMPTY
85364: LIST
85365: LIST
85366: PUSH
85367: LD_INT 0
85369: PUSH
85370: LD_INT 1
85372: NEG
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: LD_INT 1
85380: PUSH
85381: LD_INT 0
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 1
85390: PUSH
85391: LD_INT 1
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 0
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 1
85410: NEG
85411: PUSH
85412: LD_INT 0
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: LD_INT 1
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 1
85433: NEG
85434: PUSH
85435: LD_INT 2
85437: NEG
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 0
85445: PUSH
85446: LD_INT 2
85448: NEG
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 1
85456: PUSH
85457: LD_INT 1
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 2
85467: PUSH
85468: LD_INT 1
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 2
85477: PUSH
85478: LD_INT 2
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 1
85487: PUSH
85488: LD_INT 2
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 0
85497: PUSH
85498: LD_INT 2
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: LD_INT 1
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 2
85518: NEG
85519: PUSH
85520: LD_INT 1
85522: NEG
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 2
85530: NEG
85531: PUSH
85532: LD_INT 2
85534: NEG
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 2
85542: NEG
85543: PUSH
85544: LD_INT 3
85546: NEG
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 1
85554: NEG
85555: PUSH
85556: LD_INT 3
85558: NEG
85559: PUSH
85560: EMPTY
85561: LIST
85562: LIST
85563: PUSH
85564: LD_INT 0
85566: PUSH
85567: LD_INT 3
85569: NEG
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 1
85577: PUSH
85578: LD_INT 2
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 3
85588: PUSH
85589: LD_INT 2
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PUSH
85596: LD_INT 3
85598: PUSH
85599: LD_INT 3
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 2
85608: PUSH
85609: LD_INT 3
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: LD_INT 3
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 0
85628: PUSH
85629: LD_INT 3
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 1
85638: NEG
85639: PUSH
85640: LD_INT 2
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 3
85649: NEG
85650: PUSH
85651: LD_INT 2
85653: NEG
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 3
85661: NEG
85662: PUSH
85663: LD_INT 3
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85702: LD_ADDR_VAR 0 43
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 1
85722: NEG
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 1
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 0
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: NEG
85761: PUSH
85762: LD_INT 0
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 1
85771: NEG
85772: PUSH
85773: LD_INT 1
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 1
85783: NEG
85784: PUSH
85785: LD_INT 2
85787: NEG
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: LD_INT 2
85798: NEG
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 1
85806: PUSH
85807: LD_INT 1
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 2
85817: PUSH
85818: LD_INT 0
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 2
85827: PUSH
85828: LD_INT 1
85830: PUSH
85831: EMPTY
85832: LIST
85833: LIST
85834: PUSH
85835: LD_INT 1
85837: PUSH
85838: LD_INT 2
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 0
85847: PUSH
85848: LD_INT 2
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 1
85857: NEG
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 2
85868: NEG
85869: PUSH
85870: LD_INT 0
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 2
85879: NEG
85880: PUSH
85881: LD_INT 1
85883: NEG
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 1
85891: NEG
85892: PUSH
85893: LD_INT 3
85895: NEG
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 0
85903: PUSH
85904: LD_INT 3
85906: NEG
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 1
85914: PUSH
85915: LD_INT 2
85917: NEG
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 2
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 3
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 3
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: LD_INT 3
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 0
85966: PUSH
85967: LD_INT 3
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: LD_INT 2
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: LD_INT 2
85987: NEG
85988: PUSH
85989: LD_INT 1
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 3
85998: NEG
85999: PUSH
86000: LD_INT 0
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 3
86009: NEG
86010: PUSH
86011: LD_INT 1
86013: NEG
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86050: LD_ADDR_VAR 0 44
86054: PUSH
86055: LD_INT 0
86057: PUSH
86058: LD_INT 0
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 0
86067: PUSH
86068: LD_INT 1
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 1
86078: PUSH
86079: LD_INT 0
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: PUSH
86086: LD_INT 1
86088: PUSH
86089: LD_INT 1
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: LD_INT 0
86098: PUSH
86099: LD_INT 1
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PUSH
86106: LD_INT 1
86108: NEG
86109: PUSH
86110: LD_INT 0
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: PUSH
86121: LD_INT 1
86123: NEG
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 1
86131: NEG
86132: PUSH
86133: LD_INT 2
86135: NEG
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 1
86143: PUSH
86144: LD_INT 1
86146: NEG
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 2
86154: PUSH
86155: LD_INT 0
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 2
86164: PUSH
86165: LD_INT 1
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 2
86174: PUSH
86175: LD_INT 2
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 1
86184: PUSH
86185: LD_INT 2
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: LD_INT 1
86194: NEG
86195: PUSH
86196: LD_INT 1
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: PUSH
86203: LD_INT 2
86205: NEG
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 2
86216: NEG
86217: PUSH
86218: LD_INT 1
86220: NEG
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: PUSH
86226: LD_INT 2
86228: NEG
86229: PUSH
86230: LD_INT 2
86232: NEG
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 2
86240: NEG
86241: PUSH
86242: LD_INT 3
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 2
86252: PUSH
86253: LD_INT 1
86255: NEG
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 3
86263: PUSH
86264: LD_INT 0
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 3
86273: PUSH
86274: LD_INT 1
86276: PUSH
86277: EMPTY
86278: LIST
86279: LIST
86280: PUSH
86281: LD_INT 3
86283: PUSH
86284: LD_INT 2
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 3
86293: PUSH
86294: LD_INT 3
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: LD_INT 3
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 2
86313: NEG
86314: PUSH
86315: LD_INT 1
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: PUSH
86322: LD_INT 3
86324: NEG
86325: PUSH
86326: LD_INT 0
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 3
86335: NEG
86336: PUSH
86337: LD_INT 1
86339: NEG
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 3
86347: NEG
86348: PUSH
86349: LD_INT 2
86351: NEG
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 3
86359: NEG
86360: PUSH
86361: LD_INT 3
86363: NEG
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86400: LD_ADDR_VAR 0 45
86404: PUSH
86405: LD_INT 0
86407: PUSH
86408: LD_INT 0
86410: PUSH
86411: EMPTY
86412: LIST
86413: LIST
86414: PUSH
86415: LD_INT 0
86417: PUSH
86418: LD_INT 1
86420: NEG
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 1
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 1
86438: PUSH
86439: LD_INT 1
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 0
86448: PUSH
86449: LD_INT 1
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 1
86458: NEG
86459: PUSH
86460: LD_INT 0
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 1
86469: NEG
86470: PUSH
86471: LD_INT 1
86473: NEG
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 1
86481: NEG
86482: PUSH
86483: LD_INT 2
86485: NEG
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 0
86493: PUSH
86494: LD_INT 2
86496: NEG
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: LD_INT 1
86507: NEG
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 2
86515: PUSH
86516: LD_INT 1
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: PUSH
86523: LD_INT 2
86525: PUSH
86526: LD_INT 2
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: LD_INT 2
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 0
86545: PUSH
86546: LD_INT 2
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 1
86555: NEG
86556: PUSH
86557: LD_INT 1
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 2
86566: NEG
86567: PUSH
86568: LD_INT 1
86570: NEG
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: LD_INT 2
86578: NEG
86579: PUSH
86580: LD_INT 2
86582: NEG
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 2
86590: NEG
86591: PUSH
86592: LD_INT 3
86594: NEG
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: LD_INT 3
86606: NEG
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 0
86614: PUSH
86615: LD_INT 3
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: PUSH
86626: LD_INT 2
86628: NEG
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 3
86636: PUSH
86637: LD_INT 2
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 3
86646: PUSH
86647: LD_INT 3
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 2
86656: PUSH
86657: LD_INT 3
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: LD_INT 1
86666: PUSH
86667: LD_INT 3
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: LD_INT 3
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: LD_INT 1
86686: NEG
86687: PUSH
86688: LD_INT 2
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PUSH
86695: LD_INT 3
86697: NEG
86698: PUSH
86699: LD_INT 2
86701: NEG
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 3
86709: NEG
86710: PUSH
86711: LD_INT 3
86713: NEG
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86750: LD_ADDR_VAR 0 46
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: LD_INT 0
86760: PUSH
86761: EMPTY
86762: LIST
86763: LIST
86764: PUSH
86765: LD_INT 0
86767: PUSH
86768: LD_INT 1
86770: NEG
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 1
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 1
86788: PUSH
86789: LD_INT 1
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 0
86798: PUSH
86799: LD_INT 1
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 1
86808: NEG
86809: PUSH
86810: LD_INT 0
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 1
86819: NEG
86820: PUSH
86821: LD_INT 1
86823: NEG
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 1
86831: NEG
86832: PUSH
86833: LD_INT 2
86835: NEG
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: LD_INT 2
86846: NEG
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: LD_INT 1
86857: NEG
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 2
86865: PUSH
86866: LD_INT 0
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 2
86875: PUSH
86876: LD_INT 1
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 1
86885: PUSH
86886: LD_INT 2
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: LD_INT 0
86895: PUSH
86896: LD_INT 2
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 1
86905: NEG
86906: PUSH
86907: LD_INT 1
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 2
86916: NEG
86917: PUSH
86918: LD_INT 0
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: LD_INT 2
86927: NEG
86928: PUSH
86929: LD_INT 1
86931: NEG
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 1
86939: NEG
86940: PUSH
86941: LD_INT 3
86943: NEG
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 0
86951: PUSH
86952: LD_INT 3
86954: NEG
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 1
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 2
86973: PUSH
86974: LD_INT 1
86976: NEG
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: PUSH
86982: LD_INT 3
86984: PUSH
86985: LD_INT 0
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 3
86994: PUSH
86995: LD_INT 1
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 1
87004: PUSH
87005: LD_INT 3
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 0
87014: PUSH
87015: LD_INT 3
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 1
87024: NEG
87025: PUSH
87026: LD_INT 2
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 2
87035: NEG
87036: PUSH
87037: LD_INT 1
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 3
87046: NEG
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 3
87057: NEG
87058: PUSH
87059: LD_INT 1
87061: NEG
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87098: LD_ADDR_VAR 0 47
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: LD_INT 0
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 0
87115: PUSH
87116: LD_INT 1
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: PUSH
87127: LD_INT 0
87129: PUSH
87130: EMPTY
87131: LIST
87132: LIST
87133: PUSH
87134: LD_INT 1
87136: PUSH
87137: LD_INT 1
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 0
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 1
87156: NEG
87157: PUSH
87158: LD_INT 0
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 1
87167: NEG
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: LD_INT 2
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 0
87191: PUSH
87192: LD_INT 2
87194: NEG
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 1
87202: PUSH
87203: LD_INT 1
87205: NEG
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 2
87213: NEG
87214: PUSH
87215: LD_INT 1
87217: NEG
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: LD_INT 2
87225: NEG
87226: PUSH
87227: LD_INT 2
87229: NEG
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87249: LD_ADDR_VAR 0 48
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: LD_INT 0
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 0
87266: PUSH
87267: LD_INT 1
87269: NEG
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 1
87277: PUSH
87278: LD_INT 0
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 1
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 0
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: LD_INT 0
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: NEG
87319: PUSH
87320: LD_INT 1
87322: NEG
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 1
87330: NEG
87331: PUSH
87332: LD_INT 2
87334: NEG
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 0
87342: PUSH
87343: LD_INT 2
87345: NEG
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 1
87353: PUSH
87354: LD_INT 1
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: LD_INT 0
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 2
87374: PUSH
87375: LD_INT 1
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87396: LD_ADDR_VAR 0 49
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: LD_INT 0
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 0
87413: PUSH
87414: LD_INT 1
87416: NEG
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 1
87424: PUSH
87425: LD_INT 0
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PUSH
87432: LD_INT 1
87434: PUSH
87435: LD_INT 1
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 0
87444: PUSH
87445: LD_INT 1
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: LD_INT 1
87454: NEG
87455: PUSH
87456: LD_INT 0
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: PUSH
87463: LD_INT 1
87465: NEG
87466: PUSH
87467: LD_INT 1
87469: NEG
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: LD_INT 1
87480: NEG
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 2
87488: PUSH
87489: LD_INT 0
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 2
87498: PUSH
87499: LD_INT 1
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: LD_INT 2
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: LD_INT 2
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: EMPTY
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87540: LD_ADDR_VAR 0 50
87544: PUSH
87545: LD_INT 0
87547: PUSH
87548: LD_INT 0
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 0
87557: PUSH
87558: LD_INT 1
87560: NEG
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 1
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 1
87578: PUSH
87579: LD_INT 1
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: LD_INT 1
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 1
87598: NEG
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 1
87609: NEG
87610: PUSH
87611: LD_INT 1
87613: NEG
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 2
87621: PUSH
87622: LD_INT 1
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 2
87631: PUSH
87632: LD_INT 2
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 1
87641: PUSH
87642: LD_INT 2
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 0
87651: PUSH
87652: LD_INT 2
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 1
87661: NEG
87662: PUSH
87663: LD_INT 1
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87684: LD_ADDR_VAR 0 51
87688: PUSH
87689: LD_INT 0
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: LD_INT 1
87704: NEG
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 1
87712: PUSH
87713: LD_INT 0
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 1
87722: PUSH
87723: LD_INT 1
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: LD_INT 1
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 1
87742: NEG
87743: PUSH
87744: LD_INT 0
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 1
87753: NEG
87754: PUSH
87755: LD_INT 1
87757: NEG
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 1
87765: PUSH
87766: LD_INT 2
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: LD_INT 0
87775: PUSH
87776: LD_INT 2
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 1
87785: NEG
87786: PUSH
87787: LD_INT 1
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 2
87796: NEG
87797: PUSH
87798: LD_INT 0
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 2
87807: NEG
87808: PUSH
87809: LD_INT 1
87811: NEG
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87831: LD_ADDR_VAR 0 52
87835: PUSH
87836: LD_INT 0
87838: PUSH
87839: LD_INT 0
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 0
87848: PUSH
87849: LD_INT 1
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: LD_INT 0
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 1
87869: PUSH
87870: LD_INT 1
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 0
87879: PUSH
87880: LD_INT 1
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 1
87889: NEG
87890: PUSH
87891: LD_INT 0
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 1
87900: NEG
87901: PUSH
87902: LD_INT 1
87904: NEG
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 1
87912: NEG
87913: PUSH
87914: LD_INT 2
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 1
87924: NEG
87925: PUSH
87926: LD_INT 1
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: PUSH
87933: LD_INT 2
87935: NEG
87936: PUSH
87937: LD_INT 0
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 2
87946: NEG
87947: PUSH
87948: LD_INT 1
87950: NEG
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 2
87958: NEG
87959: PUSH
87960: LD_INT 2
87962: NEG
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87982: LD_ADDR_VAR 0 53
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 0
87999: PUSH
88000: LD_INT 1
88002: NEG
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 1
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 0
88030: PUSH
88031: LD_INT 1
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 1
88040: NEG
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 1
88051: NEG
88052: PUSH
88053: LD_INT 1
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: LD_INT 2
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: LD_INT 2
88078: NEG
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 1
88086: PUSH
88087: LD_INT 1
88089: NEG
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 2
88097: PUSH
88098: LD_INT 0
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 2
88107: PUSH
88108: LD_INT 1
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 2
88117: PUSH
88118: LD_INT 2
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 1
88127: PUSH
88128: LD_INT 2
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 0
88137: PUSH
88138: LD_INT 2
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 1
88147: NEG
88148: PUSH
88149: LD_INT 1
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 2
88158: NEG
88159: PUSH
88160: LD_INT 0
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 2
88169: NEG
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 2
88181: NEG
88182: PUSH
88183: LD_INT 2
88185: NEG
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88212: LD_ADDR_VAR 0 54
88216: PUSH
88217: LD_INT 0
88219: PUSH
88220: LD_INT 0
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 0
88229: PUSH
88230: LD_INT 1
88232: NEG
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 1
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 1
88250: PUSH
88251: LD_INT 1
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 0
88260: PUSH
88261: LD_INT 1
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 1
88270: NEG
88271: PUSH
88272: LD_INT 0
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 1
88281: NEG
88282: PUSH
88283: LD_INT 1
88285: NEG
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: NEG
88294: PUSH
88295: LD_INT 2
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 2
88308: NEG
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 1
88316: PUSH
88317: LD_INT 1
88319: NEG
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: PUSH
88325: LD_INT 2
88327: PUSH
88328: LD_INT 0
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: PUSH
88335: LD_INT 2
88337: PUSH
88338: LD_INT 1
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: PUSH
88345: LD_INT 2
88347: PUSH
88348: LD_INT 2
88350: PUSH
88351: EMPTY
88352: LIST
88353: LIST
88354: PUSH
88355: LD_INT 1
88357: PUSH
88358: LD_INT 2
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 0
88367: PUSH
88368: LD_INT 2
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: NEG
88378: PUSH
88379: LD_INT 1
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 2
88388: NEG
88389: PUSH
88390: LD_INT 0
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 2
88399: NEG
88400: PUSH
88401: LD_INT 1
88403: NEG
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 2
88411: NEG
88412: PUSH
88413: LD_INT 2
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88442: LD_ADDR_VAR 0 55
88446: PUSH
88447: LD_INT 0
88449: PUSH
88450: LD_INT 0
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 0
88459: PUSH
88460: LD_INT 1
88462: NEG
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 1
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 1
88480: PUSH
88481: LD_INT 1
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 0
88490: PUSH
88491: LD_INT 1
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 1
88500: NEG
88501: PUSH
88502: LD_INT 0
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 1
88511: NEG
88512: PUSH
88513: LD_INT 1
88515: NEG
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: NEG
88524: PUSH
88525: LD_INT 2
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: LD_INT 2
88538: NEG
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: PUSH
88544: LD_INT 1
88546: PUSH
88547: LD_INT 1
88549: NEG
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: LD_INT 2
88557: PUSH
88558: LD_INT 0
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 2
88567: PUSH
88568: LD_INT 1
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: PUSH
88575: LD_INT 2
88577: PUSH
88578: LD_INT 2
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: PUSH
88585: LD_INT 1
88587: PUSH
88588: LD_INT 2
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: PUSH
88595: LD_INT 0
88597: PUSH
88598: LD_INT 2
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: PUSH
88605: LD_INT 1
88607: NEG
88608: PUSH
88609: LD_INT 1
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 2
88618: NEG
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 2
88629: NEG
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: NEG
88642: PUSH
88643: LD_INT 2
88645: NEG
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88672: LD_ADDR_VAR 0 56
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 0
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 1
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 1
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 0
88720: PUSH
88721: LD_INT 1
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 1
88730: NEG
88731: PUSH
88732: LD_INT 0
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 1
88741: NEG
88742: PUSH
88743: LD_INT 1
88745: NEG
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 1
88753: NEG
88754: PUSH
88755: LD_INT 2
88757: NEG
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 0
88765: PUSH
88766: LD_INT 2
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 1
88776: PUSH
88777: LD_INT 1
88779: NEG
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 2
88787: PUSH
88788: LD_INT 0
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 2
88797: PUSH
88798: LD_INT 1
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 2
88807: PUSH
88808: LD_INT 2
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 1
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 0
88827: PUSH
88828: LD_INT 2
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 1
88837: NEG
88838: PUSH
88839: LD_INT 1
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: LD_INT 2
88848: NEG
88849: PUSH
88850: LD_INT 0
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 2
88859: NEG
88860: PUSH
88861: LD_INT 1
88863: NEG
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 2
88871: NEG
88872: PUSH
88873: LD_INT 2
88875: NEG
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88902: LD_ADDR_VAR 0 57
88906: PUSH
88907: LD_INT 0
88909: PUSH
88910: LD_INT 0
88912: PUSH
88913: EMPTY
88914: LIST
88915: LIST
88916: PUSH
88917: LD_INT 0
88919: PUSH
88920: LD_INT 1
88922: NEG
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 1
88930: PUSH
88931: LD_INT 0
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 1
88940: PUSH
88941: LD_INT 1
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 0
88950: PUSH
88951: LD_INT 1
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 1
88960: NEG
88961: PUSH
88962: LD_INT 0
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 1
88971: NEG
88972: PUSH
88973: LD_INT 1
88975: NEG
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 1
88983: NEG
88984: PUSH
88985: LD_INT 2
88987: NEG
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 0
88995: PUSH
88996: LD_INT 2
88998: NEG
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: LD_INT 1
89009: NEG
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 2
89017: PUSH
89018: LD_INT 0
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 2
89027: PUSH
89028: LD_INT 1
89030: PUSH
89031: EMPTY
89032: LIST
89033: LIST
89034: PUSH
89035: LD_INT 2
89037: PUSH
89038: LD_INT 2
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: PUSH
89045: LD_INT 1
89047: PUSH
89048: LD_INT 2
89050: PUSH
89051: EMPTY
89052: LIST
89053: LIST
89054: PUSH
89055: LD_INT 0
89057: PUSH
89058: LD_INT 2
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 1
89067: NEG
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: LD_INT 2
89078: NEG
89079: PUSH
89080: LD_INT 0
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 2
89089: NEG
89090: PUSH
89091: LD_INT 1
89093: NEG
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 2
89101: NEG
89102: PUSH
89103: LD_INT 2
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89132: LD_ADDR_VAR 0 58
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: LD_INT 0
89149: PUSH
89150: LD_INT 1
89152: NEG
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 1
89160: PUSH
89161: LD_INT 0
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 1
89170: PUSH
89171: LD_INT 1
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: PUSH
89178: LD_INT 0
89180: PUSH
89181: LD_INT 1
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 1
89190: NEG
89191: PUSH
89192: LD_INT 0
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: NEG
89202: PUSH
89203: LD_INT 1
89205: NEG
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: NEG
89214: PUSH
89215: LD_INT 2
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 0
89225: PUSH
89226: LD_INT 2
89228: NEG
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 1
89236: PUSH
89237: LD_INT 1
89239: NEG
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 2
89247: PUSH
89248: LD_INT 0
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 2
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: LD_INT 2
89267: PUSH
89268: LD_INT 2
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 1
89277: PUSH
89278: LD_INT 2
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: LD_INT 2
89290: PUSH
89291: EMPTY
89292: LIST
89293: LIST
89294: PUSH
89295: LD_INT 1
89297: NEG
89298: PUSH
89299: LD_INT 1
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: LD_INT 2
89308: NEG
89309: PUSH
89310: LD_INT 0
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 2
89319: NEG
89320: PUSH
89321: LD_INT 1
89323: NEG
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 2
89331: NEG
89332: PUSH
89333: LD_INT 2
89335: NEG
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89362: LD_ADDR_VAR 0 59
89366: PUSH
89367: LD_INT 0
89369: PUSH
89370: LD_INT 0
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: LD_INT 1
89382: NEG
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 1
89390: PUSH
89391: LD_INT 0
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: LD_INT 1
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 0
89410: PUSH
89411: LD_INT 1
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 1
89420: NEG
89421: PUSH
89422: LD_INT 0
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 1
89431: NEG
89432: PUSH
89433: LD_INT 1
89435: NEG
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89450: LD_ADDR_VAR 0 60
89454: PUSH
89455: LD_INT 0
89457: PUSH
89458: LD_INT 0
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 0
89467: PUSH
89468: LD_INT 1
89470: NEG
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PUSH
89476: LD_INT 1
89478: PUSH
89479: LD_INT 0
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: PUSH
89486: LD_INT 1
89488: PUSH
89489: LD_INT 1
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: LD_INT 0
89498: PUSH
89499: LD_INT 1
89501: PUSH
89502: EMPTY
89503: LIST
89504: LIST
89505: PUSH
89506: LD_INT 1
89508: NEG
89509: PUSH
89510: LD_INT 0
89512: PUSH
89513: EMPTY
89514: LIST
89515: LIST
89516: PUSH
89517: LD_INT 1
89519: NEG
89520: PUSH
89521: LD_INT 1
89523: NEG
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89538: LD_ADDR_VAR 0 61
89542: PUSH
89543: LD_INT 0
89545: PUSH
89546: LD_INT 0
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 1
89566: PUSH
89567: LD_INT 0
89569: PUSH
89570: EMPTY
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 1
89576: PUSH
89577: LD_INT 1
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: LD_INT 1
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 1
89596: NEG
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: PUSH
89605: LD_INT 1
89607: NEG
89608: PUSH
89609: LD_INT 1
89611: NEG
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89626: LD_ADDR_VAR 0 62
89630: PUSH
89631: LD_INT 0
89633: PUSH
89634: LD_INT 0
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 0
89643: PUSH
89644: LD_INT 1
89646: NEG
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: PUSH
89655: LD_INT 0
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 1
89664: PUSH
89665: LD_INT 1
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 0
89674: PUSH
89675: LD_INT 1
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 1
89684: NEG
89685: PUSH
89686: LD_INT 0
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 1
89695: NEG
89696: PUSH
89697: LD_INT 1
89699: NEG
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89714: LD_ADDR_VAR 0 63
89718: PUSH
89719: LD_INT 0
89721: PUSH
89722: LD_INT 0
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: LD_INT 1
89734: NEG
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: PUSH
89743: LD_INT 0
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: PUSH
89750: LD_INT 1
89752: PUSH
89753: LD_INT 1
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: LD_INT 1
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 1
89772: NEG
89773: PUSH
89774: LD_INT 0
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 1
89783: NEG
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89802: LD_ADDR_VAR 0 64
89806: PUSH
89807: LD_INT 0
89809: PUSH
89810: LD_INT 0
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: PUSH
89817: LD_INT 0
89819: PUSH
89820: LD_INT 1
89822: NEG
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: PUSH
89828: LD_INT 1
89830: PUSH
89831: LD_INT 0
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PUSH
89838: LD_INT 1
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: LD_INT 0
89850: PUSH
89851: LD_INT 1
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: LD_INT 1
89860: NEG
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 1
89871: NEG
89872: PUSH
89873: LD_INT 1
89875: NEG
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: ST_TO_ADDR
// end ; 1 :
89890: GO 95787
89892: LD_INT 1
89894: DOUBLE
89895: EQUAL
89896: IFTRUE 89900
89898: GO 92523
89900: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89901: LD_ADDR_VAR 0 11
89905: PUSH
89906: LD_INT 1
89908: NEG
89909: PUSH
89910: LD_INT 3
89912: NEG
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 0
89920: PUSH
89921: LD_INT 3
89923: NEG
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: LD_INT 2
89934: NEG
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: LIST
89944: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89945: LD_ADDR_VAR 0 12
89949: PUSH
89950: LD_INT 2
89952: PUSH
89953: LD_INT 1
89955: NEG
89956: PUSH
89957: EMPTY
89958: LIST
89959: LIST
89960: PUSH
89961: LD_INT 3
89963: PUSH
89964: LD_INT 0
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 3
89973: PUSH
89974: LD_INT 1
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: LIST
89985: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89986: LD_ADDR_VAR 0 13
89990: PUSH
89991: LD_INT 3
89993: PUSH
89994: LD_INT 2
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: LD_INT 3
90003: PUSH
90004: LD_INT 3
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 2
90013: PUSH
90014: LD_INT 3
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: LIST
90025: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90026: LD_ADDR_VAR 0 14
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: LD_INT 3
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 0
90043: PUSH
90044: LD_INT 3
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 1
90053: NEG
90054: PUSH
90055: LD_INT 2
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: EMPTY
90063: LIST
90064: LIST
90065: LIST
90066: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90067: LD_ADDR_VAR 0 15
90071: PUSH
90072: LD_INT 2
90074: NEG
90075: PUSH
90076: LD_INT 1
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 3
90085: NEG
90086: PUSH
90087: LD_INT 0
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 3
90096: NEG
90097: PUSH
90098: LD_INT 1
90100: NEG
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: PUSH
90106: EMPTY
90107: LIST
90108: LIST
90109: LIST
90110: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90111: LD_ADDR_VAR 0 16
90115: PUSH
90116: LD_INT 2
90118: NEG
90119: PUSH
90120: LD_INT 3
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 3
90130: NEG
90131: PUSH
90132: LD_INT 2
90134: NEG
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 3
90142: NEG
90143: PUSH
90144: LD_INT 3
90146: NEG
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: LIST
90156: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90157: LD_ADDR_VAR 0 17
90161: PUSH
90162: LD_INT 1
90164: NEG
90165: PUSH
90166: LD_INT 3
90168: NEG
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 0
90176: PUSH
90177: LD_INT 3
90179: NEG
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: PUSH
90185: LD_INT 1
90187: PUSH
90188: LD_INT 2
90190: NEG
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: LIST
90200: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90201: LD_ADDR_VAR 0 18
90205: PUSH
90206: LD_INT 2
90208: PUSH
90209: LD_INT 1
90211: NEG
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: PUSH
90217: LD_INT 3
90219: PUSH
90220: LD_INT 0
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: LD_INT 3
90229: PUSH
90230: LD_INT 1
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: EMPTY
90238: LIST
90239: LIST
90240: LIST
90241: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90242: LD_ADDR_VAR 0 19
90246: PUSH
90247: LD_INT 3
90249: PUSH
90250: LD_INT 2
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: PUSH
90257: LD_INT 3
90259: PUSH
90260: LD_INT 3
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 2
90269: PUSH
90270: LD_INT 3
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: LIST
90281: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90282: LD_ADDR_VAR 0 20
90286: PUSH
90287: LD_INT 1
90289: PUSH
90290: LD_INT 3
90292: PUSH
90293: EMPTY
90294: LIST
90295: LIST
90296: PUSH
90297: LD_INT 0
90299: PUSH
90300: LD_INT 3
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 1
90309: NEG
90310: PUSH
90311: LD_INT 2
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: LIST
90322: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90323: LD_ADDR_VAR 0 21
90327: PUSH
90328: LD_INT 2
90330: NEG
90331: PUSH
90332: LD_INT 1
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 3
90341: NEG
90342: PUSH
90343: LD_INT 0
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 3
90352: NEG
90353: PUSH
90354: LD_INT 1
90356: NEG
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: LIST
90366: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90367: LD_ADDR_VAR 0 22
90371: PUSH
90372: LD_INT 2
90374: NEG
90375: PUSH
90376: LD_INT 3
90378: NEG
90379: PUSH
90380: EMPTY
90381: LIST
90382: LIST
90383: PUSH
90384: LD_INT 3
90386: NEG
90387: PUSH
90388: LD_INT 2
90390: NEG
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 3
90398: NEG
90399: PUSH
90400: LD_INT 3
90402: NEG
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: LIST
90412: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90413: LD_ADDR_VAR 0 23
90417: PUSH
90418: LD_INT 0
90420: PUSH
90421: LD_INT 3
90423: NEG
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 1
90431: NEG
90432: PUSH
90433: LD_INT 4
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 1
90443: PUSH
90444: LD_INT 3
90446: NEG
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: LIST
90456: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90457: LD_ADDR_VAR 0 24
90461: PUSH
90462: LD_INT 3
90464: PUSH
90465: LD_INT 0
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 3
90474: PUSH
90475: LD_INT 1
90477: NEG
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 4
90485: PUSH
90486: LD_INT 1
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: LIST
90497: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90498: LD_ADDR_VAR 0 25
90502: PUSH
90503: LD_INT 3
90505: PUSH
90506: LD_INT 3
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 4
90515: PUSH
90516: LD_INT 3
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 3
90525: PUSH
90526: LD_INT 4
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: LIST
90537: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90538: LD_ADDR_VAR 0 26
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: LD_INT 3
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 1
90555: PUSH
90556: LD_INT 4
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PUSH
90563: LD_INT 1
90565: NEG
90566: PUSH
90567: LD_INT 3
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90579: LD_ADDR_VAR 0 27
90583: PUSH
90584: LD_INT 3
90586: NEG
90587: PUSH
90588: LD_INT 0
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 3
90597: NEG
90598: PUSH
90599: LD_INT 1
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: LD_INT 4
90608: NEG
90609: PUSH
90610: LD_INT 1
90612: NEG
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: EMPTY
90619: LIST
90620: LIST
90621: LIST
90622: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90623: LD_ADDR_VAR 0 28
90627: PUSH
90628: LD_INT 3
90630: NEG
90631: PUSH
90632: LD_INT 3
90634: NEG
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 3
90642: NEG
90643: PUSH
90644: LD_INT 4
90646: NEG
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 4
90654: NEG
90655: PUSH
90656: LD_INT 3
90658: NEG
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: LIST
90668: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90669: LD_ADDR_VAR 0 29
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: LD_INT 3
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: LD_INT 3
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: PUSH
90700: LD_INT 2
90702: NEG
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 1
90710: NEG
90711: PUSH
90712: LD_INT 4
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 0
90722: PUSH
90723: LD_INT 4
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 1
90733: PUSH
90734: LD_INT 3
90736: NEG
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: LD_INT 1
90744: NEG
90745: PUSH
90746: LD_INT 5
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 0
90756: PUSH
90757: LD_INT 5
90759: NEG
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 1
90767: PUSH
90768: LD_INT 4
90770: NEG
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 1
90778: NEG
90779: PUSH
90780: LD_INT 6
90782: NEG
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 0
90790: PUSH
90791: LD_INT 6
90793: NEG
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 1
90801: PUSH
90802: LD_INT 5
90804: NEG
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90824: LD_ADDR_VAR 0 30
90828: PUSH
90829: LD_INT 2
90831: PUSH
90832: LD_INT 1
90834: NEG
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 3
90842: PUSH
90843: LD_INT 0
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 3
90852: PUSH
90853: LD_INT 1
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 3
90862: PUSH
90863: LD_INT 1
90865: NEG
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 4
90873: PUSH
90874: LD_INT 0
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 4
90883: PUSH
90884: LD_INT 1
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 4
90893: PUSH
90894: LD_INT 1
90896: NEG
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 5
90904: PUSH
90905: LD_INT 0
90907: PUSH
90908: EMPTY
90909: LIST
90910: LIST
90911: PUSH
90912: LD_INT 5
90914: PUSH
90915: LD_INT 1
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: LD_INT 5
90924: PUSH
90925: LD_INT 1
90927: NEG
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 6
90935: PUSH
90936: LD_INT 0
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 6
90945: PUSH
90946: LD_INT 1
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: LIST
90961: LIST
90962: LIST
90963: LIST
90964: LIST
90965: LIST
90966: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90967: LD_ADDR_VAR 0 31
90971: PUSH
90972: LD_INT 3
90974: PUSH
90975: LD_INT 2
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: PUSH
90982: LD_INT 3
90984: PUSH
90985: LD_INT 3
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: LD_INT 3
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 4
91004: PUSH
91005: LD_INT 3
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 4
91014: PUSH
91015: LD_INT 4
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 3
91024: PUSH
91025: LD_INT 4
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 5
91034: PUSH
91035: LD_INT 4
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 5
91044: PUSH
91045: LD_INT 5
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 4
91054: PUSH
91055: LD_INT 5
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: PUSH
91062: LD_INT 6
91064: PUSH
91065: LD_INT 5
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 6
91074: PUSH
91075: LD_INT 6
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: LD_INT 5
91084: PUSH
91085: LD_INT 6
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91106: LD_ADDR_VAR 0 32
91110: PUSH
91111: LD_INT 1
91113: PUSH
91114: LD_INT 3
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 3
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 1
91133: NEG
91134: PUSH
91135: LD_INT 2
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: LD_INT 4
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: LD_INT 4
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 1
91164: NEG
91165: PUSH
91166: LD_INT 3
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 1
91175: PUSH
91176: LD_INT 5
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: LD_INT 5
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 1
91195: NEG
91196: PUSH
91197: LD_INT 4
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 1
91206: PUSH
91207: LD_INT 6
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: LD_INT 6
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 1
91226: NEG
91227: PUSH
91228: LD_INT 5
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91249: LD_ADDR_VAR 0 33
91253: PUSH
91254: LD_INT 2
91256: NEG
91257: PUSH
91258: LD_INT 1
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 3
91267: NEG
91268: PUSH
91269: LD_INT 0
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: PUSH
91276: LD_INT 3
91278: NEG
91279: PUSH
91280: LD_INT 1
91282: NEG
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 3
91290: NEG
91291: PUSH
91292: LD_INT 1
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 4
91301: NEG
91302: PUSH
91303: LD_INT 0
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 4
91312: NEG
91313: PUSH
91314: LD_INT 1
91316: NEG
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 4
91324: NEG
91325: PUSH
91326: LD_INT 1
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: LD_INT 5
91335: NEG
91336: PUSH
91337: LD_INT 0
91339: PUSH
91340: EMPTY
91341: LIST
91342: LIST
91343: PUSH
91344: LD_INT 5
91346: NEG
91347: PUSH
91348: LD_INT 1
91350: NEG
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 5
91358: NEG
91359: PUSH
91360: LD_INT 1
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 6
91369: NEG
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 6
91380: NEG
91381: PUSH
91382: LD_INT 1
91384: NEG
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91404: LD_ADDR_VAR 0 34
91408: PUSH
91409: LD_INT 2
91411: NEG
91412: PUSH
91413: LD_INT 3
91415: NEG
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 3
91423: NEG
91424: PUSH
91425: LD_INT 2
91427: NEG
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 3
91435: NEG
91436: PUSH
91437: LD_INT 3
91439: NEG
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 3
91447: NEG
91448: PUSH
91449: LD_INT 4
91451: NEG
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 4
91459: NEG
91460: PUSH
91461: LD_INT 3
91463: NEG
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: LD_INT 4
91471: NEG
91472: PUSH
91473: LD_INT 4
91475: NEG
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: PUSH
91481: LD_INT 4
91483: NEG
91484: PUSH
91485: LD_INT 5
91487: NEG
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 5
91495: NEG
91496: PUSH
91497: LD_INT 4
91499: NEG
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 5
91507: NEG
91508: PUSH
91509: LD_INT 5
91511: NEG
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 5
91519: NEG
91520: PUSH
91521: LD_INT 6
91523: NEG
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: LD_INT 6
91531: NEG
91532: PUSH
91533: LD_INT 5
91535: NEG
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 6
91543: NEG
91544: PUSH
91545: LD_INT 6
91547: NEG
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91567: LD_ADDR_VAR 0 41
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: LD_INT 2
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 1
91585: NEG
91586: PUSH
91587: LD_INT 3
91589: NEG
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: LD_INT 1
91597: PUSH
91598: LD_INT 2
91600: NEG
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: LIST
91610: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91611: LD_ADDR_VAR 0 42
91615: PUSH
91616: LD_INT 2
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 2
91628: PUSH
91629: LD_INT 1
91631: NEG
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: PUSH
91637: LD_INT 3
91639: PUSH
91640: LD_INT 1
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: LIST
91651: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91652: LD_ADDR_VAR 0 43
91656: PUSH
91657: LD_INT 2
91659: PUSH
91660: LD_INT 2
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: PUSH
91667: LD_INT 3
91669: PUSH
91670: LD_INT 2
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: LD_INT 2
91679: PUSH
91680: LD_INT 3
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: LIST
91691: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91692: LD_ADDR_VAR 0 44
91696: PUSH
91697: LD_INT 0
91699: PUSH
91700: LD_INT 2
91702: PUSH
91703: EMPTY
91704: LIST
91705: LIST
91706: PUSH
91707: LD_INT 1
91709: PUSH
91710: LD_INT 3
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 1
91719: NEG
91720: PUSH
91721: LD_INT 2
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91733: LD_ADDR_VAR 0 45
91737: PUSH
91738: LD_INT 2
91740: NEG
91741: PUSH
91742: LD_INT 0
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: LD_INT 2
91751: NEG
91752: PUSH
91753: LD_INT 1
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: LD_INT 3
91762: NEG
91763: PUSH
91764: LD_INT 1
91766: NEG
91767: PUSH
91768: EMPTY
91769: LIST
91770: LIST
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: LIST
91776: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91777: LD_ADDR_VAR 0 46
91781: PUSH
91782: LD_INT 2
91784: NEG
91785: PUSH
91786: LD_INT 2
91788: NEG
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 2
91796: NEG
91797: PUSH
91798: LD_INT 3
91800: NEG
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 3
91808: NEG
91809: PUSH
91810: LD_INT 2
91812: NEG
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: LIST
91822: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91823: LD_ADDR_VAR 0 47
91827: PUSH
91828: LD_INT 2
91830: NEG
91831: PUSH
91832: LD_INT 3
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 1
91842: NEG
91843: PUSH
91844: LD_INT 3
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91856: LD_ADDR_VAR 0 48
91860: PUSH
91861: LD_INT 1
91863: PUSH
91864: LD_INT 2
91866: NEG
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 2
91874: PUSH
91875: LD_INT 1
91877: NEG
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91887: LD_ADDR_VAR 0 49
91891: PUSH
91892: LD_INT 3
91894: PUSH
91895: LD_INT 1
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: LD_INT 3
91904: PUSH
91905: LD_INT 2
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91916: LD_ADDR_VAR 0 50
91920: PUSH
91921: LD_INT 2
91923: PUSH
91924: LD_INT 3
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 1
91933: PUSH
91934: LD_INT 3
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91945: LD_ADDR_VAR 0 51
91949: PUSH
91950: LD_INT 1
91952: NEG
91953: PUSH
91954: LD_INT 2
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 2
91963: NEG
91964: PUSH
91965: LD_INT 1
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91976: LD_ADDR_VAR 0 52
91980: PUSH
91981: LD_INT 3
91983: NEG
91984: PUSH
91985: LD_INT 1
91987: NEG
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 3
91995: NEG
91996: PUSH
91997: LD_INT 2
91999: NEG
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92009: LD_ADDR_VAR 0 53
92013: PUSH
92014: LD_INT 1
92016: NEG
92017: PUSH
92018: LD_INT 3
92020: NEG
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 0
92028: PUSH
92029: LD_INT 3
92031: NEG
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 1
92039: PUSH
92040: LD_INT 2
92042: NEG
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: LIST
92052: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92053: LD_ADDR_VAR 0 54
92057: PUSH
92058: LD_INT 2
92060: PUSH
92061: LD_INT 1
92063: NEG
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 3
92071: PUSH
92072: LD_INT 0
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 3
92081: PUSH
92082: LD_INT 1
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: LIST
92093: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92094: LD_ADDR_VAR 0 55
92098: PUSH
92099: LD_INT 3
92101: PUSH
92102: LD_INT 2
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: LD_INT 3
92111: PUSH
92112: LD_INT 3
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 2
92121: PUSH
92122: LD_INT 3
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: EMPTY
92130: LIST
92131: LIST
92132: LIST
92133: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92134: LD_ADDR_VAR 0 56
92138: PUSH
92139: LD_INT 1
92141: PUSH
92142: LD_INT 3
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 0
92151: PUSH
92152: LD_INT 3
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 1
92161: NEG
92162: PUSH
92163: LD_INT 2
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: LIST
92174: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92175: LD_ADDR_VAR 0 57
92179: PUSH
92180: LD_INT 2
92182: NEG
92183: PUSH
92184: LD_INT 1
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 3
92193: NEG
92194: PUSH
92195: LD_INT 0
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: PUSH
92202: LD_INT 3
92204: NEG
92205: PUSH
92206: LD_INT 1
92208: NEG
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: LIST
92218: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92219: LD_ADDR_VAR 0 58
92223: PUSH
92224: LD_INT 2
92226: NEG
92227: PUSH
92228: LD_INT 3
92230: NEG
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 3
92238: NEG
92239: PUSH
92240: LD_INT 2
92242: NEG
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: PUSH
92248: LD_INT 3
92250: NEG
92251: PUSH
92252: LD_INT 3
92254: NEG
92255: PUSH
92256: EMPTY
92257: LIST
92258: LIST
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: LIST
92264: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92265: LD_ADDR_VAR 0 59
92269: PUSH
92270: LD_INT 1
92272: NEG
92273: PUSH
92274: LD_INT 2
92276: NEG
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 0
92284: PUSH
92285: LD_INT 2
92287: NEG
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: LD_INT 1
92295: PUSH
92296: LD_INT 1
92298: NEG
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: LIST
92308: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92309: LD_ADDR_VAR 0 60
92313: PUSH
92314: LD_INT 1
92316: PUSH
92317: LD_INT 1
92319: NEG
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: LD_INT 2
92327: PUSH
92328: LD_INT 0
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: LD_INT 2
92337: PUSH
92338: LD_INT 1
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: LIST
92349: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92350: LD_ADDR_VAR 0 61
92354: PUSH
92355: LD_INT 2
92357: PUSH
92358: LD_INT 1
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: LD_INT 2
92367: PUSH
92368: LD_INT 2
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: LD_INT 1
92377: PUSH
92378: LD_INT 2
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: LIST
92389: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92390: LD_ADDR_VAR 0 62
92394: PUSH
92395: LD_INT 1
92397: PUSH
92398: LD_INT 2
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: LD_INT 0
92407: PUSH
92408: LD_INT 2
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 1
92417: NEG
92418: PUSH
92419: LD_INT 1
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: LIST
92430: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92431: LD_ADDR_VAR 0 63
92435: PUSH
92436: LD_INT 1
92438: NEG
92439: PUSH
92440: LD_INT 1
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: LD_INT 2
92449: NEG
92450: PUSH
92451: LD_INT 0
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 2
92460: NEG
92461: PUSH
92462: LD_INT 1
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: LIST
92474: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92475: LD_ADDR_VAR 0 64
92479: PUSH
92480: LD_INT 1
92482: NEG
92483: PUSH
92484: LD_INT 2
92486: NEG
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 2
92494: NEG
92495: PUSH
92496: LD_INT 1
92498: NEG
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 2
92506: NEG
92507: PUSH
92508: LD_INT 2
92510: NEG
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: LIST
92520: ST_TO_ADDR
// end ; 2 :
92521: GO 95787
92523: LD_INT 2
92525: DOUBLE
92526: EQUAL
92527: IFTRUE 92531
92529: GO 95786
92531: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92532: LD_ADDR_VAR 0 29
92536: PUSH
92537: LD_INT 4
92539: PUSH
92540: LD_INT 0
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 4
92549: PUSH
92550: LD_INT 1
92552: NEG
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 5
92560: PUSH
92561: LD_INT 0
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 5
92570: PUSH
92571: LD_INT 1
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 4
92580: PUSH
92581: LD_INT 1
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 3
92590: PUSH
92591: LD_INT 0
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 3
92600: PUSH
92601: LD_INT 1
92603: NEG
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 3
92611: PUSH
92612: LD_INT 2
92614: NEG
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 5
92622: PUSH
92623: LD_INT 2
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 3
92632: PUSH
92633: LD_INT 3
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 3
92642: PUSH
92643: LD_INT 2
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 4
92652: PUSH
92653: LD_INT 3
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 4
92662: PUSH
92663: LD_INT 4
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 3
92672: PUSH
92673: LD_INT 4
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 2
92682: PUSH
92683: LD_INT 3
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 2
92692: PUSH
92693: LD_INT 2
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 4
92702: PUSH
92703: LD_INT 2
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 2
92712: PUSH
92713: LD_INT 4
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 0
92722: PUSH
92723: LD_INT 4
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 0
92732: PUSH
92733: LD_INT 3
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: LD_INT 1
92742: PUSH
92743: LD_INT 4
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: PUSH
92750: LD_INT 1
92752: PUSH
92753: LD_INT 5
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 0
92762: PUSH
92763: LD_INT 5
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 1
92772: NEG
92773: PUSH
92774: LD_INT 4
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 1
92783: NEG
92784: PUSH
92785: LD_INT 3
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 2
92794: PUSH
92795: LD_INT 5
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 2
92804: NEG
92805: PUSH
92806: LD_INT 3
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 3
92815: NEG
92816: PUSH
92817: LD_INT 0
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: LD_INT 3
92826: NEG
92827: PUSH
92828: LD_INT 1
92830: NEG
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 2
92838: NEG
92839: PUSH
92840: LD_INT 0
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 2
92849: NEG
92850: PUSH
92851: LD_INT 1
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 3
92860: NEG
92861: PUSH
92862: LD_INT 1
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: LD_INT 4
92871: NEG
92872: PUSH
92873: LD_INT 0
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: PUSH
92880: LD_INT 4
92882: NEG
92883: PUSH
92884: LD_INT 1
92886: NEG
92887: PUSH
92888: EMPTY
92889: LIST
92890: LIST
92891: PUSH
92892: LD_INT 4
92894: NEG
92895: PUSH
92896: LD_INT 2
92898: NEG
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: LD_INT 2
92906: NEG
92907: PUSH
92908: LD_INT 2
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PUSH
92915: LD_INT 4
92917: NEG
92918: PUSH
92919: LD_INT 4
92921: NEG
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 4
92929: NEG
92930: PUSH
92931: LD_INT 5
92933: NEG
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: LD_INT 3
92941: NEG
92942: PUSH
92943: LD_INT 4
92945: NEG
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 3
92953: NEG
92954: PUSH
92955: LD_INT 3
92957: NEG
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 4
92965: NEG
92966: PUSH
92967: LD_INT 3
92969: NEG
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 5
92977: NEG
92978: PUSH
92979: LD_INT 4
92981: NEG
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 5
92989: NEG
92990: PUSH
92991: LD_INT 5
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 3
93001: NEG
93002: PUSH
93003: LD_INT 5
93005: NEG
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 5
93013: NEG
93014: PUSH
93015: LD_INT 3
93017: NEG
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93070: LD_ADDR_VAR 0 30
93074: PUSH
93075: LD_INT 4
93077: PUSH
93078: LD_INT 4
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PUSH
93085: LD_INT 4
93087: PUSH
93088: LD_INT 3
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: PUSH
93095: LD_INT 5
93097: PUSH
93098: LD_INT 4
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: PUSH
93105: LD_INT 5
93107: PUSH
93108: LD_INT 5
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 4
93117: PUSH
93118: LD_INT 5
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 3
93127: PUSH
93128: LD_INT 4
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: LD_INT 3
93137: PUSH
93138: LD_INT 3
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: LD_INT 5
93147: PUSH
93148: LD_INT 3
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PUSH
93155: LD_INT 3
93157: PUSH
93158: LD_INT 5
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: LD_INT 0
93167: PUSH
93168: LD_INT 3
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 0
93177: PUSH
93178: LD_INT 2
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 1
93187: PUSH
93188: LD_INT 3
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 1
93197: PUSH
93198: LD_INT 4
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 0
93207: PUSH
93208: LD_INT 4
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: PUSH
93215: LD_INT 1
93217: NEG
93218: PUSH
93219: LD_INT 3
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 1
93228: NEG
93229: PUSH
93230: LD_INT 2
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_INT 2
93239: PUSH
93240: LD_INT 4
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 2
93249: NEG
93250: PUSH
93251: LD_INT 2
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 4
93260: NEG
93261: PUSH
93262: LD_INT 0
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 4
93271: NEG
93272: PUSH
93273: LD_INT 1
93275: NEG
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 3
93283: NEG
93284: PUSH
93285: LD_INT 0
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 3
93294: NEG
93295: PUSH
93296: LD_INT 1
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: PUSH
93303: LD_INT 4
93305: NEG
93306: PUSH
93307: LD_INT 1
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 5
93316: NEG
93317: PUSH
93318: LD_INT 0
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: LD_INT 5
93327: NEG
93328: PUSH
93329: LD_INT 1
93331: NEG
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 5
93339: NEG
93340: PUSH
93341: LD_INT 2
93343: NEG
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: LD_INT 3
93351: NEG
93352: PUSH
93353: LD_INT 2
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 3
93362: NEG
93363: PUSH
93364: LD_INT 3
93366: NEG
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 3
93374: NEG
93375: PUSH
93376: LD_INT 4
93378: NEG
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: LD_INT 2
93386: NEG
93387: PUSH
93388: LD_INT 3
93390: NEG
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 2
93398: NEG
93399: PUSH
93400: LD_INT 2
93402: NEG
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 3
93410: NEG
93411: PUSH
93412: LD_INT 2
93414: NEG
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 4
93422: NEG
93423: PUSH
93424: LD_INT 3
93426: NEG
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: LD_INT 4
93434: NEG
93435: PUSH
93436: LD_INT 4
93438: NEG
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 2
93446: NEG
93447: PUSH
93448: LD_INT 4
93450: NEG
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 4
93458: NEG
93459: PUSH
93460: LD_INT 2
93462: NEG
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: PUSH
93468: LD_INT 0
93470: PUSH
93471: LD_INT 4
93473: NEG
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 0
93481: PUSH
93482: LD_INT 5
93484: NEG
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: LD_INT 4
93495: NEG
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: LD_INT 1
93503: PUSH
93504: LD_INT 3
93506: NEG
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 0
93514: PUSH
93515: LD_INT 3
93517: NEG
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: PUSH
93523: LD_INT 1
93525: NEG
93526: PUSH
93527: LD_INT 4
93529: NEG
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 1
93537: NEG
93538: PUSH
93539: LD_INT 5
93541: NEG
93542: PUSH
93543: EMPTY
93544: LIST
93545: LIST
93546: PUSH
93547: LD_INT 2
93549: PUSH
93550: LD_INT 3
93552: NEG
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: LD_INT 2
93560: NEG
93561: PUSH
93562: LD_INT 5
93564: NEG
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93617: LD_ADDR_VAR 0 31
93621: PUSH
93622: LD_INT 0
93624: PUSH
93625: LD_INT 4
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 0
93634: PUSH
93635: LD_INT 3
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: LD_INT 1
93644: PUSH
93645: LD_INT 4
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 1
93654: PUSH
93655: LD_INT 5
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_INT 0
93664: PUSH
93665: LD_INT 5
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: LD_INT 1
93674: NEG
93675: PUSH
93676: LD_INT 4
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: PUSH
93683: LD_INT 1
93685: NEG
93686: PUSH
93687: LD_INT 3
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 2
93696: PUSH
93697: LD_INT 5
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 2
93706: NEG
93707: PUSH
93708: LD_INT 3
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 3
93717: NEG
93718: PUSH
93719: LD_INT 0
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: LD_INT 3
93728: NEG
93729: PUSH
93730: LD_INT 1
93732: NEG
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: PUSH
93738: LD_INT 2
93740: NEG
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 2
93751: NEG
93752: PUSH
93753: LD_INT 1
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: PUSH
93760: LD_INT 3
93762: NEG
93763: PUSH
93764: LD_INT 1
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: LD_INT 4
93773: NEG
93774: PUSH
93775: LD_INT 0
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: LD_INT 4
93784: NEG
93785: PUSH
93786: LD_INT 1
93788: NEG
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 4
93796: NEG
93797: PUSH
93798: LD_INT 2
93800: NEG
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 2
93808: NEG
93809: PUSH
93810: LD_INT 2
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 4
93819: NEG
93820: PUSH
93821: LD_INT 4
93823: NEG
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 4
93831: NEG
93832: PUSH
93833: LD_INT 5
93835: NEG
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: PUSH
93841: LD_INT 3
93843: NEG
93844: PUSH
93845: LD_INT 4
93847: NEG
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 3
93855: NEG
93856: PUSH
93857: LD_INT 3
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 4
93867: NEG
93868: PUSH
93869: LD_INT 3
93871: NEG
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 5
93879: NEG
93880: PUSH
93881: LD_INT 4
93883: NEG
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: LD_INT 5
93891: NEG
93892: PUSH
93893: LD_INT 5
93895: NEG
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PUSH
93901: LD_INT 3
93903: NEG
93904: PUSH
93905: LD_INT 5
93907: NEG
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 5
93915: NEG
93916: PUSH
93917: LD_INT 3
93919: NEG
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 0
93927: PUSH
93928: LD_INT 3
93930: NEG
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: LD_INT 0
93938: PUSH
93939: LD_INT 4
93941: NEG
93942: PUSH
93943: EMPTY
93944: LIST
93945: LIST
93946: PUSH
93947: LD_INT 1
93949: PUSH
93950: LD_INT 3
93952: NEG
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 1
93960: PUSH
93961: LD_INT 2
93963: NEG
93964: PUSH
93965: EMPTY
93966: LIST
93967: LIST
93968: PUSH
93969: LD_INT 0
93971: PUSH
93972: LD_INT 2
93974: NEG
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: PUSH
93980: LD_INT 1
93982: NEG
93983: PUSH
93984: LD_INT 3
93986: NEG
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 1
93994: NEG
93995: PUSH
93996: LD_INT 4
93998: NEG
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 2
94006: PUSH
94007: LD_INT 2
94009: NEG
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: PUSH
94015: LD_INT 2
94017: NEG
94018: PUSH
94019: LD_INT 4
94021: NEG
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: PUSH
94027: LD_INT 4
94029: PUSH
94030: LD_INT 0
94032: PUSH
94033: EMPTY
94034: LIST
94035: LIST
94036: PUSH
94037: LD_INT 4
94039: PUSH
94040: LD_INT 1
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 5
94050: PUSH
94051: LD_INT 0
94053: PUSH
94054: EMPTY
94055: LIST
94056: LIST
94057: PUSH
94058: LD_INT 5
94060: PUSH
94061: LD_INT 1
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 4
94070: PUSH
94071: LD_INT 1
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: PUSH
94078: LD_INT 3
94080: PUSH
94081: LD_INT 0
94083: PUSH
94084: EMPTY
94085: LIST
94086: LIST
94087: PUSH
94088: LD_INT 3
94090: PUSH
94091: LD_INT 1
94093: NEG
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 3
94101: PUSH
94102: LD_INT 2
94104: NEG
94105: PUSH
94106: EMPTY
94107: LIST
94108: LIST
94109: PUSH
94110: LD_INT 5
94112: PUSH
94113: LD_INT 2
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94167: LD_ADDR_VAR 0 32
94171: PUSH
94172: LD_INT 4
94174: NEG
94175: PUSH
94176: LD_INT 0
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 4
94185: NEG
94186: PUSH
94187: LD_INT 1
94189: NEG
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: LD_INT 3
94197: NEG
94198: PUSH
94199: LD_INT 0
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 3
94208: NEG
94209: PUSH
94210: LD_INT 1
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: LD_INT 4
94219: NEG
94220: PUSH
94221: LD_INT 1
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 5
94230: NEG
94231: PUSH
94232: LD_INT 0
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 5
94241: NEG
94242: PUSH
94243: LD_INT 1
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 5
94253: NEG
94254: PUSH
94255: LD_INT 2
94257: NEG
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 3
94265: NEG
94266: PUSH
94267: LD_INT 2
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 3
94276: NEG
94277: PUSH
94278: LD_INT 3
94280: NEG
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_INT 3
94288: NEG
94289: PUSH
94290: LD_INT 4
94292: NEG
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: LD_INT 2
94300: NEG
94301: PUSH
94302: LD_INT 3
94304: NEG
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 2
94312: NEG
94313: PUSH
94314: LD_INT 2
94316: NEG
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 3
94324: NEG
94325: PUSH
94326: LD_INT 2
94328: NEG
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 4
94336: NEG
94337: PUSH
94338: LD_INT 3
94340: NEG
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 4
94348: NEG
94349: PUSH
94350: LD_INT 4
94352: NEG
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_INT 2
94360: NEG
94361: PUSH
94362: LD_INT 4
94364: NEG
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 4
94372: NEG
94373: PUSH
94374: LD_INT 2
94376: NEG
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PUSH
94382: LD_INT 0
94384: PUSH
94385: LD_INT 4
94387: NEG
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: LD_INT 0
94395: PUSH
94396: LD_INT 5
94398: NEG
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 1
94406: PUSH
94407: LD_INT 4
94409: NEG
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: LD_INT 1
94417: PUSH
94418: LD_INT 3
94420: NEG
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: LD_INT 0
94428: PUSH
94429: LD_INT 3
94431: NEG
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: PUSH
94437: LD_INT 1
94439: NEG
94440: PUSH
94441: LD_INT 4
94443: NEG
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 1
94451: NEG
94452: PUSH
94453: LD_INT 5
94455: NEG
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 2
94463: PUSH
94464: LD_INT 3
94466: NEG
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: LD_INT 2
94474: NEG
94475: PUSH
94476: LD_INT 5
94478: NEG
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 3
94486: PUSH
94487: LD_INT 0
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 3
94496: PUSH
94497: LD_INT 1
94499: NEG
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 4
94507: PUSH
94508: LD_INT 0
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 4
94517: PUSH
94518: LD_INT 1
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 3
94527: PUSH
94528: LD_INT 1
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 2
94537: PUSH
94538: LD_INT 0
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PUSH
94545: LD_INT 2
94547: PUSH
94548: LD_INT 1
94550: NEG
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 2
94558: PUSH
94559: LD_INT 2
94561: NEG
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 4
94569: PUSH
94570: LD_INT 2
94572: PUSH
94573: EMPTY
94574: LIST
94575: LIST
94576: PUSH
94577: LD_INT 4
94579: PUSH
94580: LD_INT 4
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: PUSH
94587: LD_INT 4
94589: PUSH
94590: LD_INT 3
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: PUSH
94597: LD_INT 5
94599: PUSH
94600: LD_INT 4
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 5
94609: PUSH
94610: LD_INT 5
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 4
94619: PUSH
94620: LD_INT 5
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 3
94629: PUSH
94630: LD_INT 4
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 3
94639: PUSH
94640: LD_INT 3
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 5
94649: PUSH
94650: LD_INT 3
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: PUSH
94657: LD_INT 3
94659: PUSH
94660: LD_INT 5
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: EMPTY
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94714: LD_ADDR_VAR 0 33
94718: PUSH
94719: LD_INT 4
94721: NEG
94722: PUSH
94723: LD_INT 4
94725: NEG
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: PUSH
94731: LD_INT 4
94733: NEG
94734: PUSH
94735: LD_INT 5
94737: NEG
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: PUSH
94743: LD_INT 3
94745: NEG
94746: PUSH
94747: LD_INT 4
94749: NEG
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 3
94757: NEG
94758: PUSH
94759: LD_INT 3
94761: NEG
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 4
94769: NEG
94770: PUSH
94771: LD_INT 3
94773: NEG
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 5
94781: NEG
94782: PUSH
94783: LD_INT 4
94785: NEG
94786: PUSH
94787: EMPTY
94788: LIST
94789: LIST
94790: PUSH
94791: LD_INT 5
94793: NEG
94794: PUSH
94795: LD_INT 5
94797: NEG
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 3
94805: NEG
94806: PUSH
94807: LD_INT 5
94809: NEG
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: PUSH
94815: LD_INT 5
94817: NEG
94818: PUSH
94819: LD_INT 3
94821: NEG
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: LD_INT 0
94829: PUSH
94830: LD_INT 3
94832: NEG
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 0
94840: PUSH
94841: LD_INT 4
94843: NEG
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 1
94851: PUSH
94852: LD_INT 3
94854: NEG
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 1
94862: PUSH
94863: LD_INT 2
94865: NEG
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 0
94873: PUSH
94874: LD_INT 2
94876: NEG
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 1
94884: NEG
94885: PUSH
94886: LD_INT 3
94888: NEG
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 1
94896: NEG
94897: PUSH
94898: LD_INT 4
94900: NEG
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PUSH
94906: LD_INT 2
94908: PUSH
94909: LD_INT 2
94911: NEG
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: LD_INT 2
94919: NEG
94920: PUSH
94921: LD_INT 4
94923: NEG
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 4
94931: PUSH
94932: LD_INT 0
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 4
94941: PUSH
94942: LD_INT 1
94944: NEG
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 5
94952: PUSH
94953: LD_INT 0
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: LD_INT 5
94962: PUSH
94963: LD_INT 1
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: PUSH
94970: LD_INT 4
94972: PUSH
94973: LD_INT 1
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 3
94982: PUSH
94983: LD_INT 0
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: LD_INT 3
94992: PUSH
94993: LD_INT 1
94995: NEG
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: LD_INT 3
95003: PUSH
95004: LD_INT 2
95006: NEG
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: LD_INT 5
95014: PUSH
95015: LD_INT 2
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 3
95024: PUSH
95025: LD_INT 3
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 3
95034: PUSH
95035: LD_INT 2
95037: PUSH
95038: EMPTY
95039: LIST
95040: LIST
95041: PUSH
95042: LD_INT 4
95044: PUSH
95045: LD_INT 3
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 4
95054: PUSH
95055: LD_INT 4
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 3
95064: PUSH
95065: LD_INT 4
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 2
95074: PUSH
95075: LD_INT 3
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 2
95084: PUSH
95085: LD_INT 2
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 4
95094: PUSH
95095: LD_INT 2
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PUSH
95102: LD_INT 2
95104: PUSH
95105: LD_INT 4
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 0
95114: PUSH
95115: LD_INT 4
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 0
95124: PUSH
95125: LD_INT 3
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 1
95134: PUSH
95135: LD_INT 4
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 1
95144: PUSH
95145: LD_INT 5
95147: PUSH
95148: EMPTY
95149: LIST
95150: LIST
95151: PUSH
95152: LD_INT 0
95154: PUSH
95155: LD_INT 5
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 1
95164: NEG
95165: PUSH
95166: LD_INT 4
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 1
95175: NEG
95176: PUSH
95177: LD_INT 3
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 2
95186: PUSH
95187: LD_INT 5
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PUSH
95194: LD_INT 2
95196: NEG
95197: PUSH
95198: LD_INT 3
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95252: LD_ADDR_VAR 0 34
95256: PUSH
95257: LD_INT 0
95259: PUSH
95260: LD_INT 4
95262: NEG
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 0
95270: PUSH
95271: LD_INT 5
95273: NEG
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 1
95281: PUSH
95282: LD_INT 4
95284: NEG
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 1
95292: PUSH
95293: LD_INT 3
95295: NEG
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: PUSH
95301: LD_INT 0
95303: PUSH
95304: LD_INT 3
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 1
95314: NEG
95315: PUSH
95316: LD_INT 4
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 1
95326: NEG
95327: PUSH
95328: LD_INT 5
95330: NEG
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: PUSH
95336: LD_INT 2
95338: PUSH
95339: LD_INT 3
95341: NEG
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 2
95349: NEG
95350: PUSH
95351: LD_INT 5
95353: NEG
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 3
95361: PUSH
95362: LD_INT 0
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 3
95371: PUSH
95372: LD_INT 1
95374: NEG
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 4
95382: PUSH
95383: LD_INT 0
95385: PUSH
95386: EMPTY
95387: LIST
95388: LIST
95389: PUSH
95390: LD_INT 4
95392: PUSH
95393: LD_INT 1
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: LD_INT 3
95402: PUSH
95403: LD_INT 1
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: LD_INT 2
95412: PUSH
95413: LD_INT 0
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 2
95422: PUSH
95423: LD_INT 1
95425: NEG
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 2
95433: PUSH
95434: LD_INT 2
95436: NEG
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 4
95444: PUSH
95445: LD_INT 2
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: PUSH
95452: LD_INT 4
95454: PUSH
95455: LD_INT 4
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 4
95464: PUSH
95465: LD_INT 3
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 5
95474: PUSH
95475: LD_INT 4
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: PUSH
95482: LD_INT 5
95484: PUSH
95485: LD_INT 5
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 4
95494: PUSH
95495: LD_INT 5
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: PUSH
95502: LD_INT 3
95504: PUSH
95505: LD_INT 4
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: PUSH
95512: LD_INT 3
95514: PUSH
95515: LD_INT 3
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 5
95524: PUSH
95525: LD_INT 3
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 3
95534: PUSH
95535: LD_INT 5
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: LD_INT 0
95544: PUSH
95545: LD_INT 3
95547: PUSH
95548: EMPTY
95549: LIST
95550: LIST
95551: PUSH
95552: LD_INT 0
95554: PUSH
95555: LD_INT 2
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 1
95564: PUSH
95565: LD_INT 3
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 1
95574: PUSH
95575: LD_INT 4
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: PUSH
95582: LD_INT 0
95584: PUSH
95585: LD_INT 4
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 1
95594: NEG
95595: PUSH
95596: LD_INT 3
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 1
95605: NEG
95606: PUSH
95607: LD_INT 2
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 2
95616: PUSH
95617: LD_INT 4
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 2
95626: NEG
95627: PUSH
95628: LD_INT 2
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 4
95637: NEG
95638: PUSH
95639: LD_INT 0
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 4
95648: NEG
95649: PUSH
95650: LD_INT 1
95652: NEG
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 3
95660: NEG
95661: PUSH
95662: LD_INT 0
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 3
95671: NEG
95672: PUSH
95673: LD_INT 1
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PUSH
95680: LD_INT 4
95682: NEG
95683: PUSH
95684: LD_INT 1
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: LD_INT 5
95693: NEG
95694: PUSH
95695: LD_INT 0
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: PUSH
95702: LD_INT 5
95704: NEG
95705: PUSH
95706: LD_INT 1
95708: NEG
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 5
95716: NEG
95717: PUSH
95718: LD_INT 2
95720: NEG
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 3
95728: NEG
95729: PUSH
95730: LD_INT 2
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: ST_TO_ADDR
// end ; end ;
95784: GO 95787
95786: POP
// case btype of b_depot , b_warehouse :
95787: LD_VAR 0 1
95791: PUSH
95792: LD_INT 0
95794: DOUBLE
95795: EQUAL
95796: IFTRUE 95806
95798: LD_INT 1
95800: DOUBLE
95801: EQUAL
95802: IFTRUE 95806
95804: GO 96007
95806: POP
// case nation of nation_american :
95807: LD_VAR 0 5
95811: PUSH
95812: LD_INT 1
95814: DOUBLE
95815: EQUAL
95816: IFTRUE 95820
95818: GO 95876
95820: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95821: LD_ADDR_VAR 0 9
95825: PUSH
95826: LD_VAR 0 11
95830: PUSH
95831: LD_VAR 0 12
95835: PUSH
95836: LD_VAR 0 13
95840: PUSH
95841: LD_VAR 0 14
95845: PUSH
95846: LD_VAR 0 15
95850: PUSH
95851: LD_VAR 0 16
95855: PUSH
95856: EMPTY
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: PUSH
95864: LD_VAR 0 4
95868: PUSH
95869: LD_INT 1
95871: PLUS
95872: ARRAY
95873: ST_TO_ADDR
95874: GO 96005
95876: LD_INT 2
95878: DOUBLE
95879: EQUAL
95880: IFTRUE 95884
95882: GO 95940
95884: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95885: LD_ADDR_VAR 0 9
95889: PUSH
95890: LD_VAR 0 17
95894: PUSH
95895: LD_VAR 0 18
95899: PUSH
95900: LD_VAR 0 19
95904: PUSH
95905: LD_VAR 0 20
95909: PUSH
95910: LD_VAR 0 21
95914: PUSH
95915: LD_VAR 0 22
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: PUSH
95928: LD_VAR 0 4
95932: PUSH
95933: LD_INT 1
95935: PLUS
95936: ARRAY
95937: ST_TO_ADDR
95938: GO 96005
95940: LD_INT 3
95942: DOUBLE
95943: EQUAL
95944: IFTRUE 95948
95946: GO 96004
95948: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95949: LD_ADDR_VAR 0 9
95953: PUSH
95954: LD_VAR 0 23
95958: PUSH
95959: LD_VAR 0 24
95963: PUSH
95964: LD_VAR 0 25
95968: PUSH
95969: LD_VAR 0 26
95973: PUSH
95974: LD_VAR 0 27
95978: PUSH
95979: LD_VAR 0 28
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: PUSH
95992: LD_VAR 0 4
95996: PUSH
95997: LD_INT 1
95999: PLUS
96000: ARRAY
96001: ST_TO_ADDR
96002: GO 96005
96004: POP
96005: GO 96560
96007: LD_INT 2
96009: DOUBLE
96010: EQUAL
96011: IFTRUE 96021
96013: LD_INT 3
96015: DOUBLE
96016: EQUAL
96017: IFTRUE 96021
96019: GO 96077
96021: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96022: LD_ADDR_VAR 0 9
96026: PUSH
96027: LD_VAR 0 29
96031: PUSH
96032: LD_VAR 0 30
96036: PUSH
96037: LD_VAR 0 31
96041: PUSH
96042: LD_VAR 0 32
96046: PUSH
96047: LD_VAR 0 33
96051: PUSH
96052: LD_VAR 0 34
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: PUSH
96065: LD_VAR 0 4
96069: PUSH
96070: LD_INT 1
96072: PLUS
96073: ARRAY
96074: ST_TO_ADDR
96075: GO 96560
96077: LD_INT 16
96079: DOUBLE
96080: EQUAL
96081: IFTRUE 96139
96083: LD_INT 17
96085: DOUBLE
96086: EQUAL
96087: IFTRUE 96139
96089: LD_INT 18
96091: DOUBLE
96092: EQUAL
96093: IFTRUE 96139
96095: LD_INT 19
96097: DOUBLE
96098: EQUAL
96099: IFTRUE 96139
96101: LD_INT 22
96103: DOUBLE
96104: EQUAL
96105: IFTRUE 96139
96107: LD_INT 20
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96139
96113: LD_INT 21
96115: DOUBLE
96116: EQUAL
96117: IFTRUE 96139
96119: LD_INT 23
96121: DOUBLE
96122: EQUAL
96123: IFTRUE 96139
96125: LD_INT 24
96127: DOUBLE
96128: EQUAL
96129: IFTRUE 96139
96131: LD_INT 25
96133: DOUBLE
96134: EQUAL
96135: IFTRUE 96139
96137: GO 96195
96139: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96140: LD_ADDR_VAR 0 9
96144: PUSH
96145: LD_VAR 0 35
96149: PUSH
96150: LD_VAR 0 36
96154: PUSH
96155: LD_VAR 0 37
96159: PUSH
96160: LD_VAR 0 38
96164: PUSH
96165: LD_VAR 0 39
96169: PUSH
96170: LD_VAR 0 40
96174: PUSH
96175: EMPTY
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: PUSH
96183: LD_VAR 0 4
96187: PUSH
96188: LD_INT 1
96190: PLUS
96191: ARRAY
96192: ST_TO_ADDR
96193: GO 96560
96195: LD_INT 6
96197: DOUBLE
96198: EQUAL
96199: IFTRUE 96251
96201: LD_INT 7
96203: DOUBLE
96204: EQUAL
96205: IFTRUE 96251
96207: LD_INT 8
96209: DOUBLE
96210: EQUAL
96211: IFTRUE 96251
96213: LD_INT 13
96215: DOUBLE
96216: EQUAL
96217: IFTRUE 96251
96219: LD_INT 12
96221: DOUBLE
96222: EQUAL
96223: IFTRUE 96251
96225: LD_INT 15
96227: DOUBLE
96228: EQUAL
96229: IFTRUE 96251
96231: LD_INT 11
96233: DOUBLE
96234: EQUAL
96235: IFTRUE 96251
96237: LD_INT 14
96239: DOUBLE
96240: EQUAL
96241: IFTRUE 96251
96243: LD_INT 10
96245: DOUBLE
96246: EQUAL
96247: IFTRUE 96251
96249: GO 96307
96251: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96252: LD_ADDR_VAR 0 9
96256: PUSH
96257: LD_VAR 0 41
96261: PUSH
96262: LD_VAR 0 42
96266: PUSH
96267: LD_VAR 0 43
96271: PUSH
96272: LD_VAR 0 44
96276: PUSH
96277: LD_VAR 0 45
96281: PUSH
96282: LD_VAR 0 46
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: PUSH
96295: LD_VAR 0 4
96299: PUSH
96300: LD_INT 1
96302: PLUS
96303: ARRAY
96304: ST_TO_ADDR
96305: GO 96560
96307: LD_INT 36
96309: DOUBLE
96310: EQUAL
96311: IFTRUE 96315
96313: GO 96371
96315: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96316: LD_ADDR_VAR 0 9
96320: PUSH
96321: LD_VAR 0 47
96325: PUSH
96326: LD_VAR 0 48
96330: PUSH
96331: LD_VAR 0 49
96335: PUSH
96336: LD_VAR 0 50
96340: PUSH
96341: LD_VAR 0 51
96345: PUSH
96346: LD_VAR 0 52
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: PUSH
96359: LD_VAR 0 4
96363: PUSH
96364: LD_INT 1
96366: PLUS
96367: ARRAY
96368: ST_TO_ADDR
96369: GO 96560
96371: LD_INT 4
96373: DOUBLE
96374: EQUAL
96375: IFTRUE 96397
96377: LD_INT 5
96379: DOUBLE
96380: EQUAL
96381: IFTRUE 96397
96383: LD_INT 34
96385: DOUBLE
96386: EQUAL
96387: IFTRUE 96397
96389: LD_INT 37
96391: DOUBLE
96392: EQUAL
96393: IFTRUE 96397
96395: GO 96453
96397: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96398: LD_ADDR_VAR 0 9
96402: PUSH
96403: LD_VAR 0 53
96407: PUSH
96408: LD_VAR 0 54
96412: PUSH
96413: LD_VAR 0 55
96417: PUSH
96418: LD_VAR 0 56
96422: PUSH
96423: LD_VAR 0 57
96427: PUSH
96428: LD_VAR 0 58
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: PUSH
96441: LD_VAR 0 4
96445: PUSH
96446: LD_INT 1
96448: PLUS
96449: ARRAY
96450: ST_TO_ADDR
96451: GO 96560
96453: LD_INT 31
96455: DOUBLE
96456: EQUAL
96457: IFTRUE 96503
96459: LD_INT 32
96461: DOUBLE
96462: EQUAL
96463: IFTRUE 96503
96465: LD_INT 33
96467: DOUBLE
96468: EQUAL
96469: IFTRUE 96503
96471: LD_INT 27
96473: DOUBLE
96474: EQUAL
96475: IFTRUE 96503
96477: LD_INT 26
96479: DOUBLE
96480: EQUAL
96481: IFTRUE 96503
96483: LD_INT 28
96485: DOUBLE
96486: EQUAL
96487: IFTRUE 96503
96489: LD_INT 29
96491: DOUBLE
96492: EQUAL
96493: IFTRUE 96503
96495: LD_INT 30
96497: DOUBLE
96498: EQUAL
96499: IFTRUE 96503
96501: GO 96559
96503: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96504: LD_ADDR_VAR 0 9
96508: PUSH
96509: LD_VAR 0 59
96513: PUSH
96514: LD_VAR 0 60
96518: PUSH
96519: LD_VAR 0 61
96523: PUSH
96524: LD_VAR 0 62
96528: PUSH
96529: LD_VAR 0 63
96533: PUSH
96534: LD_VAR 0 64
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: PUSH
96547: LD_VAR 0 4
96551: PUSH
96552: LD_INT 1
96554: PLUS
96555: ARRAY
96556: ST_TO_ADDR
96557: GO 96560
96559: POP
// temp_list2 = [ ] ;
96560: LD_ADDR_VAR 0 10
96564: PUSH
96565: EMPTY
96566: ST_TO_ADDR
// for i in temp_list do
96567: LD_ADDR_VAR 0 8
96571: PUSH
96572: LD_VAR 0 9
96576: PUSH
96577: FOR_IN
96578: IFFALSE 96630
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96580: LD_ADDR_VAR 0 10
96584: PUSH
96585: LD_VAR 0 10
96589: PUSH
96590: LD_VAR 0 8
96594: PUSH
96595: LD_INT 1
96597: ARRAY
96598: PUSH
96599: LD_VAR 0 2
96603: PLUS
96604: PUSH
96605: LD_VAR 0 8
96609: PUSH
96610: LD_INT 2
96612: ARRAY
96613: PUSH
96614: LD_VAR 0 3
96618: PLUS
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: EMPTY
96625: LIST
96626: ADD
96627: ST_TO_ADDR
96628: GO 96577
96630: POP
96631: POP
// result = temp_list2 ;
96632: LD_ADDR_VAR 0 7
96636: PUSH
96637: LD_VAR 0 10
96641: ST_TO_ADDR
// end ;
96642: LD_VAR 0 7
96646: RET
// export function EnemyInRange ( unit , dist ) ; begin
96647: LD_INT 0
96649: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96650: LD_ADDR_VAR 0 3
96654: PUSH
96655: LD_VAR 0 1
96659: PPUSH
96660: CALL_OW 255
96664: PPUSH
96665: LD_VAR 0 1
96669: PPUSH
96670: CALL_OW 250
96674: PPUSH
96675: LD_VAR 0 1
96679: PPUSH
96680: CALL_OW 251
96684: PPUSH
96685: LD_VAR 0 2
96689: PPUSH
96690: CALL 70020 0 4
96694: PUSH
96695: LD_INT 4
96697: ARRAY
96698: ST_TO_ADDR
// end ;
96699: LD_VAR 0 3
96703: RET
// export function PlayerSeeMe ( unit ) ; begin
96704: LD_INT 0
96706: PPUSH
// result := See ( your_side , unit ) ;
96707: LD_ADDR_VAR 0 2
96711: PUSH
96712: LD_OWVAR 2
96716: PPUSH
96717: LD_VAR 0 1
96721: PPUSH
96722: CALL_OW 292
96726: ST_TO_ADDR
// end ;
96727: LD_VAR 0 2
96731: RET
// export function ReverseDir ( unit ) ; begin
96732: LD_INT 0
96734: PPUSH
// if not unit then
96735: LD_VAR 0 1
96739: NOT
96740: IFFALSE 96744
// exit ;
96742: GO 96767
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96744: LD_ADDR_VAR 0 2
96748: PUSH
96749: LD_VAR 0 1
96753: PPUSH
96754: CALL_OW 254
96758: PUSH
96759: LD_INT 3
96761: PLUS
96762: PUSH
96763: LD_INT 6
96765: MOD
96766: ST_TO_ADDR
// end ;
96767: LD_VAR 0 2
96771: RET
// export function ReverseArray ( array ) ; var i ; begin
96772: LD_INT 0
96774: PPUSH
96775: PPUSH
// if not array then
96776: LD_VAR 0 1
96780: NOT
96781: IFFALSE 96785
// exit ;
96783: GO 96840
// result := [ ] ;
96785: LD_ADDR_VAR 0 2
96789: PUSH
96790: EMPTY
96791: ST_TO_ADDR
// for i := array downto 1 do
96792: LD_ADDR_VAR 0 3
96796: PUSH
96797: DOUBLE
96798: LD_VAR 0 1
96802: INC
96803: ST_TO_ADDR
96804: LD_INT 1
96806: PUSH
96807: FOR_DOWNTO
96808: IFFALSE 96838
// result := Join ( result , array [ i ] ) ;
96810: LD_ADDR_VAR 0 2
96814: PUSH
96815: LD_VAR 0 2
96819: PPUSH
96820: LD_VAR 0 1
96824: PUSH
96825: LD_VAR 0 3
96829: ARRAY
96830: PPUSH
96831: CALL 101496 0 2
96835: ST_TO_ADDR
96836: GO 96807
96838: POP
96839: POP
// end ;
96840: LD_VAR 0 2
96844: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
96845: LD_INT 0
96847: PPUSH
96848: PPUSH
96849: PPUSH
96850: PPUSH
96851: PPUSH
96852: PPUSH
// if not unit or not hexes then
96853: LD_VAR 0 1
96857: NOT
96858: PUSH
96859: LD_VAR 0 2
96863: NOT
96864: OR
96865: IFFALSE 96869
// exit ;
96867: GO 96992
// dist := 9999 ;
96869: LD_ADDR_VAR 0 5
96873: PUSH
96874: LD_INT 9999
96876: ST_TO_ADDR
// for i = 1 to hexes do
96877: LD_ADDR_VAR 0 4
96881: PUSH
96882: DOUBLE
96883: LD_INT 1
96885: DEC
96886: ST_TO_ADDR
96887: LD_VAR 0 2
96891: PUSH
96892: FOR_TO
96893: IFFALSE 96980
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96895: LD_ADDR_VAR 0 6
96899: PUSH
96900: LD_VAR 0 1
96904: PPUSH
96905: LD_VAR 0 2
96909: PUSH
96910: LD_VAR 0 4
96914: ARRAY
96915: PUSH
96916: LD_INT 1
96918: ARRAY
96919: PPUSH
96920: LD_VAR 0 2
96924: PUSH
96925: LD_VAR 0 4
96929: ARRAY
96930: PUSH
96931: LD_INT 2
96933: ARRAY
96934: PPUSH
96935: CALL_OW 297
96939: ST_TO_ADDR
// if tdist < dist then
96940: LD_VAR 0 6
96944: PUSH
96945: LD_VAR 0 5
96949: LESS
96950: IFFALSE 96978
// begin hex := hexes [ i ] ;
96952: LD_ADDR_VAR 0 8
96956: PUSH
96957: LD_VAR 0 2
96961: PUSH
96962: LD_VAR 0 4
96966: ARRAY
96967: ST_TO_ADDR
// dist := tdist ;
96968: LD_ADDR_VAR 0 5
96972: PUSH
96973: LD_VAR 0 6
96977: ST_TO_ADDR
// end ; end ;
96978: GO 96892
96980: POP
96981: POP
// result := hex ;
96982: LD_ADDR_VAR 0 3
96986: PUSH
96987: LD_VAR 0 8
96991: ST_TO_ADDR
// end ;
96992: LD_VAR 0 3
96996: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96997: LD_INT 0
96999: PPUSH
97000: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97001: LD_VAR 0 1
97005: NOT
97006: PUSH
97007: LD_VAR 0 1
97011: PUSH
97012: LD_INT 21
97014: PUSH
97015: LD_INT 2
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PUSH
97022: LD_INT 23
97024: PUSH
97025: LD_INT 2
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PPUSH
97036: CALL_OW 69
97040: IN
97041: NOT
97042: OR
97043: IFFALSE 97047
// exit ;
97045: GO 97094
// for i = 1 to 3 do
97047: LD_ADDR_VAR 0 3
97051: PUSH
97052: DOUBLE
97053: LD_INT 1
97055: DEC
97056: ST_TO_ADDR
97057: LD_INT 3
97059: PUSH
97060: FOR_TO
97061: IFFALSE 97092
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97063: LD_VAR 0 1
97067: PPUSH
97068: CALL_OW 250
97072: PPUSH
97073: LD_VAR 0 1
97077: PPUSH
97078: CALL_OW 251
97082: PPUSH
97083: LD_INT 1
97085: PPUSH
97086: CALL_OW 453
97090: GO 97060
97092: POP
97093: POP
// end ;
97094: LD_VAR 0 2
97098: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97099: LD_INT 0
97101: PPUSH
97102: PPUSH
97103: PPUSH
97104: PPUSH
97105: PPUSH
97106: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97107: LD_VAR 0 1
97111: NOT
97112: PUSH
97113: LD_VAR 0 2
97117: NOT
97118: OR
97119: PUSH
97120: LD_VAR 0 1
97124: PPUSH
97125: CALL_OW 314
97129: OR
97130: IFFALSE 97134
// exit ;
97132: GO 97601
// if GetLives ( i ) < 250 then
97134: LD_VAR 0 4
97138: PPUSH
97139: CALL_OW 256
97143: PUSH
97144: LD_INT 250
97146: LESS
97147: IFFALSE 97160
// begin ComAutodestruct ( i ) ;
97149: LD_VAR 0 4
97153: PPUSH
97154: CALL 96997 0 1
// exit ;
97158: GO 97601
// end ; x := GetX ( enemy_unit ) ;
97160: LD_ADDR_VAR 0 7
97164: PUSH
97165: LD_VAR 0 2
97169: PPUSH
97170: CALL_OW 250
97174: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97175: LD_ADDR_VAR 0 8
97179: PUSH
97180: LD_VAR 0 2
97184: PPUSH
97185: CALL_OW 251
97189: ST_TO_ADDR
// if not x or not y then
97190: LD_VAR 0 7
97194: NOT
97195: PUSH
97196: LD_VAR 0 8
97200: NOT
97201: OR
97202: IFFALSE 97206
// exit ;
97204: GO 97601
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97206: LD_ADDR_VAR 0 6
97210: PUSH
97211: LD_VAR 0 7
97215: PPUSH
97216: LD_INT 0
97218: PPUSH
97219: LD_INT 4
97221: PPUSH
97222: CALL_OW 272
97226: PUSH
97227: LD_VAR 0 8
97231: PPUSH
97232: LD_INT 0
97234: PPUSH
97235: LD_INT 4
97237: PPUSH
97238: CALL_OW 273
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: LD_VAR 0 7
97251: PPUSH
97252: LD_INT 1
97254: PPUSH
97255: LD_INT 4
97257: PPUSH
97258: CALL_OW 272
97262: PUSH
97263: LD_VAR 0 8
97267: PPUSH
97268: LD_INT 1
97270: PPUSH
97271: LD_INT 4
97273: PPUSH
97274: CALL_OW 273
97278: PUSH
97279: EMPTY
97280: LIST
97281: LIST
97282: PUSH
97283: LD_VAR 0 7
97287: PPUSH
97288: LD_INT 2
97290: PPUSH
97291: LD_INT 4
97293: PPUSH
97294: CALL_OW 272
97298: PUSH
97299: LD_VAR 0 8
97303: PPUSH
97304: LD_INT 2
97306: PPUSH
97307: LD_INT 4
97309: PPUSH
97310: CALL_OW 273
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_VAR 0 7
97323: PPUSH
97324: LD_INT 3
97326: PPUSH
97327: LD_INT 4
97329: PPUSH
97330: CALL_OW 272
97334: PUSH
97335: LD_VAR 0 8
97339: PPUSH
97340: LD_INT 3
97342: PPUSH
97343: LD_INT 4
97345: PPUSH
97346: CALL_OW 273
97350: PUSH
97351: EMPTY
97352: LIST
97353: LIST
97354: PUSH
97355: LD_VAR 0 7
97359: PPUSH
97360: LD_INT 4
97362: PPUSH
97363: LD_INT 4
97365: PPUSH
97366: CALL_OW 272
97370: PUSH
97371: LD_VAR 0 8
97375: PPUSH
97376: LD_INT 4
97378: PPUSH
97379: LD_INT 4
97381: PPUSH
97382: CALL_OW 273
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: PUSH
97391: LD_VAR 0 7
97395: PPUSH
97396: LD_INT 5
97398: PPUSH
97399: LD_INT 4
97401: PPUSH
97402: CALL_OW 272
97406: PUSH
97407: LD_VAR 0 8
97411: PPUSH
97412: LD_INT 5
97414: PPUSH
97415: LD_INT 4
97417: PPUSH
97418: CALL_OW 273
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: EMPTY
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: ST_TO_ADDR
// for i = tmp downto 1 do
97435: LD_ADDR_VAR 0 4
97439: PUSH
97440: DOUBLE
97441: LD_VAR 0 6
97445: INC
97446: ST_TO_ADDR
97447: LD_INT 1
97449: PUSH
97450: FOR_DOWNTO
97451: IFFALSE 97552
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97453: LD_VAR 0 6
97457: PUSH
97458: LD_VAR 0 4
97462: ARRAY
97463: PUSH
97464: LD_INT 1
97466: ARRAY
97467: PPUSH
97468: LD_VAR 0 6
97472: PUSH
97473: LD_VAR 0 4
97477: ARRAY
97478: PUSH
97479: LD_INT 2
97481: ARRAY
97482: PPUSH
97483: CALL_OW 488
97487: NOT
97488: PUSH
97489: LD_VAR 0 6
97493: PUSH
97494: LD_VAR 0 4
97498: ARRAY
97499: PUSH
97500: LD_INT 1
97502: ARRAY
97503: PPUSH
97504: LD_VAR 0 6
97508: PUSH
97509: LD_VAR 0 4
97513: ARRAY
97514: PUSH
97515: LD_INT 2
97517: ARRAY
97518: PPUSH
97519: CALL_OW 428
97523: PUSH
97524: LD_INT 0
97526: NONEQUAL
97527: OR
97528: IFFALSE 97550
// tmp := Delete ( tmp , i ) ;
97530: LD_ADDR_VAR 0 6
97534: PUSH
97535: LD_VAR 0 6
97539: PPUSH
97540: LD_VAR 0 4
97544: PPUSH
97545: CALL_OW 3
97549: ST_TO_ADDR
97550: GO 97450
97552: POP
97553: POP
// j := GetClosestHex ( unit , tmp ) ;
97554: LD_ADDR_VAR 0 5
97558: PUSH
97559: LD_VAR 0 1
97563: PPUSH
97564: LD_VAR 0 6
97568: PPUSH
97569: CALL 96845 0 2
97573: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97574: LD_VAR 0 1
97578: PPUSH
97579: LD_VAR 0 5
97583: PUSH
97584: LD_INT 1
97586: ARRAY
97587: PPUSH
97588: LD_VAR 0 5
97592: PUSH
97593: LD_INT 2
97595: ARRAY
97596: PPUSH
97597: CALL_OW 111
// end ;
97601: LD_VAR 0 3
97605: RET
// export function PrepareApemanSoldier ( ) ; begin
97606: LD_INT 0
97608: PPUSH
// uc_nation := 0 ;
97609: LD_ADDR_OWVAR 21
97613: PUSH
97614: LD_INT 0
97616: ST_TO_ADDR
// hc_sex := sex_male ;
97617: LD_ADDR_OWVAR 27
97621: PUSH
97622: LD_INT 1
97624: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
97625: LD_ADDR_OWVAR 28
97629: PUSH
97630: LD_INT 15
97632: ST_TO_ADDR
// hc_gallery :=  ;
97633: LD_ADDR_OWVAR 33
97637: PUSH
97638: LD_STRING 
97640: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97641: LD_ADDR_OWVAR 31
97645: PUSH
97646: LD_INT 0
97648: PPUSH
97649: LD_INT 3
97651: PPUSH
97652: CALL_OW 12
97656: PUSH
97657: LD_INT 0
97659: PPUSH
97660: LD_INT 3
97662: PPUSH
97663: CALL_OW 12
97667: PUSH
97668: LD_INT 0
97670: PUSH
97671: LD_INT 0
97673: PUSH
97674: EMPTY
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: ST_TO_ADDR
// end ;
97680: LD_VAR 0 1
97684: RET
// export function PrepareApemanEngineer ( ) ; begin
97685: LD_INT 0
97687: PPUSH
// uc_nation := 0 ;
97688: LD_ADDR_OWVAR 21
97692: PUSH
97693: LD_INT 0
97695: ST_TO_ADDR
// hc_sex := sex_male ;
97696: LD_ADDR_OWVAR 27
97700: PUSH
97701: LD_INT 1
97703: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
97704: LD_ADDR_OWVAR 28
97708: PUSH
97709: LD_INT 16
97711: ST_TO_ADDR
// hc_gallery :=  ;
97712: LD_ADDR_OWVAR 33
97716: PUSH
97717: LD_STRING 
97719: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97720: LD_ADDR_OWVAR 31
97724: PUSH
97725: LD_INT 0
97727: PPUSH
97728: LD_INT 3
97730: PPUSH
97731: CALL_OW 12
97735: PUSH
97736: LD_INT 0
97738: PPUSH
97739: LD_INT 3
97741: PPUSH
97742: CALL_OW 12
97746: PUSH
97747: LD_INT 0
97749: PUSH
97750: LD_INT 0
97752: PUSH
97753: EMPTY
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: ST_TO_ADDR
// end ;
97759: LD_VAR 0 1
97763: RET
// export function PrepareApeman ( agressivity ) ; begin
97764: LD_INT 0
97766: PPUSH
// uc_side := 0 ;
97767: LD_ADDR_OWVAR 20
97771: PUSH
97772: LD_INT 0
97774: ST_TO_ADDR
// uc_nation := 0 ;
97775: LD_ADDR_OWVAR 21
97779: PUSH
97780: LD_INT 0
97782: ST_TO_ADDR
// hc_sex := sex_male ;
97783: LD_ADDR_OWVAR 27
97787: PUSH
97788: LD_INT 1
97790: ST_TO_ADDR
// hc_class := class_apeman ;
97791: LD_ADDR_OWVAR 28
97795: PUSH
97796: LD_INT 12
97798: ST_TO_ADDR
// hc_gallery :=  ;
97799: LD_ADDR_OWVAR 33
97803: PUSH
97804: LD_STRING 
97806: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97807: LD_ADDR_OWVAR 35
97811: PUSH
97812: LD_VAR 0 1
97816: NEG
97817: PPUSH
97818: LD_VAR 0 1
97822: PPUSH
97823: CALL_OW 12
97827: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97828: LD_ADDR_OWVAR 31
97832: PUSH
97833: LD_INT 0
97835: PPUSH
97836: LD_INT 3
97838: PPUSH
97839: CALL_OW 12
97843: PUSH
97844: LD_INT 0
97846: PPUSH
97847: LD_INT 3
97849: PPUSH
97850: CALL_OW 12
97854: PUSH
97855: LD_INT 0
97857: PUSH
97858: LD_INT 0
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: ST_TO_ADDR
// end ;
97867: LD_VAR 0 2
97871: RET
// export function PrepareTiger ( agressivity ) ; begin
97872: LD_INT 0
97874: PPUSH
// uc_side := 0 ;
97875: LD_ADDR_OWVAR 20
97879: PUSH
97880: LD_INT 0
97882: ST_TO_ADDR
// uc_nation := 0 ;
97883: LD_ADDR_OWVAR 21
97887: PUSH
97888: LD_INT 0
97890: ST_TO_ADDR
// hc_class := class_tiger ;
97891: LD_ADDR_OWVAR 28
97895: PUSH
97896: LD_INT 14
97898: ST_TO_ADDR
// hc_gallery :=  ;
97899: LD_ADDR_OWVAR 33
97903: PUSH
97904: LD_STRING 
97906: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97907: LD_ADDR_OWVAR 35
97911: PUSH
97912: LD_VAR 0 1
97916: NEG
97917: PPUSH
97918: LD_VAR 0 1
97922: PPUSH
97923: CALL_OW 12
97927: ST_TO_ADDR
// end ;
97928: LD_VAR 0 2
97932: RET
// export function PrepareEnchidna ( ) ; begin
97933: LD_INT 0
97935: PPUSH
// uc_side := 0 ;
97936: LD_ADDR_OWVAR 20
97940: PUSH
97941: LD_INT 0
97943: ST_TO_ADDR
// uc_nation := 0 ;
97944: LD_ADDR_OWVAR 21
97948: PUSH
97949: LD_INT 0
97951: ST_TO_ADDR
// hc_class := class_baggie ;
97952: LD_ADDR_OWVAR 28
97956: PUSH
97957: LD_INT 13
97959: ST_TO_ADDR
// hc_gallery :=  ;
97960: LD_ADDR_OWVAR 33
97964: PUSH
97965: LD_STRING 
97967: ST_TO_ADDR
// end ;
97968: LD_VAR 0 1
97972: RET
// export function PrepareFrog ( ) ; begin
97973: LD_INT 0
97975: PPUSH
// uc_side := 0 ;
97976: LD_ADDR_OWVAR 20
97980: PUSH
97981: LD_INT 0
97983: ST_TO_ADDR
// uc_nation := 0 ;
97984: LD_ADDR_OWVAR 21
97988: PUSH
97989: LD_INT 0
97991: ST_TO_ADDR
// hc_class := class_frog ;
97992: LD_ADDR_OWVAR 28
97996: PUSH
97997: LD_INT 19
97999: ST_TO_ADDR
// hc_gallery :=  ;
98000: LD_ADDR_OWVAR 33
98004: PUSH
98005: LD_STRING 
98007: ST_TO_ADDR
// end ;
98008: LD_VAR 0 1
98012: RET
// export function PrepareFish ( ) ; begin
98013: LD_INT 0
98015: PPUSH
// uc_side := 0 ;
98016: LD_ADDR_OWVAR 20
98020: PUSH
98021: LD_INT 0
98023: ST_TO_ADDR
// uc_nation := 0 ;
98024: LD_ADDR_OWVAR 21
98028: PUSH
98029: LD_INT 0
98031: ST_TO_ADDR
// hc_class := class_fish ;
98032: LD_ADDR_OWVAR 28
98036: PUSH
98037: LD_INT 20
98039: ST_TO_ADDR
// hc_gallery :=  ;
98040: LD_ADDR_OWVAR 33
98044: PUSH
98045: LD_STRING 
98047: ST_TO_ADDR
// end ;
98048: LD_VAR 0 1
98052: RET
// export function PrepareBird ( ) ; begin
98053: LD_INT 0
98055: PPUSH
// uc_side := 0 ;
98056: LD_ADDR_OWVAR 20
98060: PUSH
98061: LD_INT 0
98063: ST_TO_ADDR
// uc_nation := 0 ;
98064: LD_ADDR_OWVAR 21
98068: PUSH
98069: LD_INT 0
98071: ST_TO_ADDR
// hc_class := class_phororhacos ;
98072: LD_ADDR_OWVAR 28
98076: PUSH
98077: LD_INT 18
98079: ST_TO_ADDR
// hc_gallery :=  ;
98080: LD_ADDR_OWVAR 33
98084: PUSH
98085: LD_STRING 
98087: ST_TO_ADDR
// end ;
98088: LD_VAR 0 1
98092: RET
// export function PrepareHorse ( ) ; begin
98093: LD_INT 0
98095: PPUSH
// uc_side := 0 ;
98096: LD_ADDR_OWVAR 20
98100: PUSH
98101: LD_INT 0
98103: ST_TO_ADDR
// uc_nation := 0 ;
98104: LD_ADDR_OWVAR 21
98108: PUSH
98109: LD_INT 0
98111: ST_TO_ADDR
// hc_class := class_horse ;
98112: LD_ADDR_OWVAR 28
98116: PUSH
98117: LD_INT 21
98119: ST_TO_ADDR
// hc_gallery :=  ;
98120: LD_ADDR_OWVAR 33
98124: PUSH
98125: LD_STRING 
98127: ST_TO_ADDR
// end ;
98128: LD_VAR 0 1
98132: RET
// export function PrepareMastodont ( ) ; begin
98133: LD_INT 0
98135: PPUSH
// uc_side := 0 ;
98136: LD_ADDR_OWVAR 20
98140: PUSH
98141: LD_INT 0
98143: ST_TO_ADDR
// uc_nation := 0 ;
98144: LD_ADDR_OWVAR 21
98148: PUSH
98149: LD_INT 0
98151: ST_TO_ADDR
// vc_chassis := class_mastodont ;
98152: LD_ADDR_OWVAR 37
98156: PUSH
98157: LD_INT 31
98159: ST_TO_ADDR
// vc_control := control_rider ;
98160: LD_ADDR_OWVAR 38
98164: PUSH
98165: LD_INT 4
98167: ST_TO_ADDR
// end ;
98168: LD_VAR 0 1
98172: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98173: LD_INT 0
98175: PPUSH
98176: PPUSH
98177: PPUSH
// uc_side = 0 ;
98178: LD_ADDR_OWVAR 20
98182: PUSH
98183: LD_INT 0
98185: ST_TO_ADDR
// uc_nation = 0 ;
98186: LD_ADDR_OWVAR 21
98190: PUSH
98191: LD_INT 0
98193: ST_TO_ADDR
// InitHc_All ( ) ;
98194: CALL_OW 584
// InitVc ;
98198: CALL_OW 20
// if mastodonts then
98202: LD_VAR 0 6
98206: IFFALSE 98273
// for i = 1 to mastodonts do
98208: LD_ADDR_VAR 0 11
98212: PUSH
98213: DOUBLE
98214: LD_INT 1
98216: DEC
98217: ST_TO_ADDR
98218: LD_VAR 0 6
98222: PUSH
98223: FOR_TO
98224: IFFALSE 98271
// begin vc_chassis := 31 ;
98226: LD_ADDR_OWVAR 37
98230: PUSH
98231: LD_INT 31
98233: ST_TO_ADDR
// vc_control := control_rider ;
98234: LD_ADDR_OWVAR 38
98238: PUSH
98239: LD_INT 4
98241: ST_TO_ADDR
// animal := CreateVehicle ;
98242: LD_ADDR_VAR 0 12
98246: PUSH
98247: CALL_OW 45
98251: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98252: LD_VAR 0 12
98256: PPUSH
98257: LD_VAR 0 8
98261: PPUSH
98262: LD_INT 0
98264: PPUSH
98265: CALL 100401 0 3
// end ;
98269: GO 98223
98271: POP
98272: POP
// if horses then
98273: LD_VAR 0 5
98277: IFFALSE 98344
// for i = 1 to horses do
98279: LD_ADDR_VAR 0 11
98283: PUSH
98284: DOUBLE
98285: LD_INT 1
98287: DEC
98288: ST_TO_ADDR
98289: LD_VAR 0 5
98293: PUSH
98294: FOR_TO
98295: IFFALSE 98342
// begin hc_class := 21 ;
98297: LD_ADDR_OWVAR 28
98301: PUSH
98302: LD_INT 21
98304: ST_TO_ADDR
// hc_gallery :=  ;
98305: LD_ADDR_OWVAR 33
98309: PUSH
98310: LD_STRING 
98312: ST_TO_ADDR
// animal := CreateHuman ;
98313: LD_ADDR_VAR 0 12
98317: PUSH
98318: CALL_OW 44
98322: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98323: LD_VAR 0 12
98327: PPUSH
98328: LD_VAR 0 8
98332: PPUSH
98333: LD_INT 0
98335: PPUSH
98336: CALL 100401 0 3
// end ;
98340: GO 98294
98342: POP
98343: POP
// if birds then
98344: LD_VAR 0 1
98348: IFFALSE 98415
// for i = 1 to birds do
98350: LD_ADDR_VAR 0 11
98354: PUSH
98355: DOUBLE
98356: LD_INT 1
98358: DEC
98359: ST_TO_ADDR
98360: LD_VAR 0 1
98364: PUSH
98365: FOR_TO
98366: IFFALSE 98413
// begin hc_class := 18 ;
98368: LD_ADDR_OWVAR 28
98372: PUSH
98373: LD_INT 18
98375: ST_TO_ADDR
// hc_gallery =  ;
98376: LD_ADDR_OWVAR 33
98380: PUSH
98381: LD_STRING 
98383: ST_TO_ADDR
// animal := CreateHuman ;
98384: LD_ADDR_VAR 0 12
98388: PUSH
98389: CALL_OW 44
98393: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98394: LD_VAR 0 12
98398: PPUSH
98399: LD_VAR 0 8
98403: PPUSH
98404: LD_INT 0
98406: PPUSH
98407: CALL 100401 0 3
// end ;
98411: GO 98365
98413: POP
98414: POP
// if tigers then
98415: LD_VAR 0 2
98419: IFFALSE 98503
// for i = 1 to tigers do
98421: LD_ADDR_VAR 0 11
98425: PUSH
98426: DOUBLE
98427: LD_INT 1
98429: DEC
98430: ST_TO_ADDR
98431: LD_VAR 0 2
98435: PUSH
98436: FOR_TO
98437: IFFALSE 98501
// begin hc_class = class_tiger ;
98439: LD_ADDR_OWVAR 28
98443: PUSH
98444: LD_INT 14
98446: ST_TO_ADDR
// hc_gallery =  ;
98447: LD_ADDR_OWVAR 33
98451: PUSH
98452: LD_STRING 
98454: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98455: LD_ADDR_OWVAR 35
98459: PUSH
98460: LD_INT 7
98462: NEG
98463: PPUSH
98464: LD_INT 7
98466: PPUSH
98467: CALL_OW 12
98471: ST_TO_ADDR
// animal := CreateHuman ;
98472: LD_ADDR_VAR 0 12
98476: PUSH
98477: CALL_OW 44
98481: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98482: LD_VAR 0 12
98486: PPUSH
98487: LD_VAR 0 8
98491: PPUSH
98492: LD_INT 0
98494: PPUSH
98495: CALL 100401 0 3
// end ;
98499: GO 98436
98501: POP
98502: POP
// if apemans then
98503: LD_VAR 0 3
98507: IFFALSE 98630
// for i = 1 to apemans do
98509: LD_ADDR_VAR 0 11
98513: PUSH
98514: DOUBLE
98515: LD_INT 1
98517: DEC
98518: ST_TO_ADDR
98519: LD_VAR 0 3
98523: PUSH
98524: FOR_TO
98525: IFFALSE 98628
// begin hc_class = class_apeman ;
98527: LD_ADDR_OWVAR 28
98531: PUSH
98532: LD_INT 12
98534: ST_TO_ADDR
// hc_gallery =  ;
98535: LD_ADDR_OWVAR 33
98539: PUSH
98540: LD_STRING 
98542: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
98543: LD_ADDR_OWVAR 35
98547: PUSH
98548: LD_INT 2
98550: NEG
98551: PPUSH
98552: LD_INT 2
98554: PPUSH
98555: CALL_OW 12
98559: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98560: LD_ADDR_OWVAR 31
98564: PUSH
98565: LD_INT 1
98567: PPUSH
98568: LD_INT 3
98570: PPUSH
98571: CALL_OW 12
98575: PUSH
98576: LD_INT 1
98578: PPUSH
98579: LD_INT 3
98581: PPUSH
98582: CALL_OW 12
98586: PUSH
98587: LD_INT 0
98589: PUSH
98590: LD_INT 0
98592: PUSH
98593: EMPTY
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: ST_TO_ADDR
// animal := CreateHuman ;
98599: LD_ADDR_VAR 0 12
98603: PUSH
98604: CALL_OW 44
98608: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98609: LD_VAR 0 12
98613: PPUSH
98614: LD_VAR 0 8
98618: PPUSH
98619: LD_INT 0
98621: PPUSH
98622: CALL 100401 0 3
// end ;
98626: GO 98524
98628: POP
98629: POP
// if enchidnas then
98630: LD_VAR 0 4
98634: IFFALSE 98701
// for i = 1 to enchidnas do
98636: LD_ADDR_VAR 0 11
98640: PUSH
98641: DOUBLE
98642: LD_INT 1
98644: DEC
98645: ST_TO_ADDR
98646: LD_VAR 0 4
98650: PUSH
98651: FOR_TO
98652: IFFALSE 98699
// begin hc_class = 13 ;
98654: LD_ADDR_OWVAR 28
98658: PUSH
98659: LD_INT 13
98661: ST_TO_ADDR
// hc_gallery =  ;
98662: LD_ADDR_OWVAR 33
98666: PUSH
98667: LD_STRING 
98669: ST_TO_ADDR
// animal := CreateHuman ;
98670: LD_ADDR_VAR 0 12
98674: PUSH
98675: CALL_OW 44
98679: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98680: LD_VAR 0 12
98684: PPUSH
98685: LD_VAR 0 8
98689: PPUSH
98690: LD_INT 0
98692: PPUSH
98693: CALL 100401 0 3
// end ;
98697: GO 98651
98699: POP
98700: POP
// if fishes then
98701: LD_VAR 0 7
98705: IFFALSE 98772
// for i = 1 to fishes do
98707: LD_ADDR_VAR 0 11
98711: PUSH
98712: DOUBLE
98713: LD_INT 1
98715: DEC
98716: ST_TO_ADDR
98717: LD_VAR 0 7
98721: PUSH
98722: FOR_TO
98723: IFFALSE 98770
// begin hc_class = 20 ;
98725: LD_ADDR_OWVAR 28
98729: PUSH
98730: LD_INT 20
98732: ST_TO_ADDR
// hc_gallery =  ;
98733: LD_ADDR_OWVAR 33
98737: PUSH
98738: LD_STRING 
98740: ST_TO_ADDR
// animal := CreateHuman ;
98741: LD_ADDR_VAR 0 12
98745: PUSH
98746: CALL_OW 44
98750: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98751: LD_VAR 0 12
98755: PPUSH
98756: LD_VAR 0 9
98760: PPUSH
98761: LD_INT 0
98763: PPUSH
98764: CALL 100401 0 3
// end ;
98768: GO 98722
98770: POP
98771: POP
// end ;
98772: LD_VAR 0 10
98776: RET
// export function WantHeal ( sci , unit ) ; begin
98777: LD_INT 0
98779: PPUSH
// if GetTaskList ( sci ) > 0 then
98780: LD_VAR 0 1
98784: PPUSH
98785: CALL_OW 437
98789: PUSH
98790: LD_INT 0
98792: GREATER
98793: IFFALSE 98863
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98795: LD_VAR 0 1
98799: PPUSH
98800: CALL_OW 437
98804: PUSH
98805: LD_INT 1
98807: ARRAY
98808: PUSH
98809: LD_INT 1
98811: ARRAY
98812: PUSH
98813: LD_STRING l
98815: EQUAL
98816: PUSH
98817: LD_VAR 0 1
98821: PPUSH
98822: CALL_OW 437
98826: PUSH
98827: LD_INT 1
98829: ARRAY
98830: PUSH
98831: LD_INT 4
98833: ARRAY
98834: PUSH
98835: LD_VAR 0 2
98839: EQUAL
98840: AND
98841: IFFALSE 98853
// result := true else
98843: LD_ADDR_VAR 0 3
98847: PUSH
98848: LD_INT 1
98850: ST_TO_ADDR
98851: GO 98861
// result := false ;
98853: LD_ADDR_VAR 0 3
98857: PUSH
98858: LD_INT 0
98860: ST_TO_ADDR
// end else
98861: GO 98871
// result := false ;
98863: LD_ADDR_VAR 0 3
98867: PUSH
98868: LD_INT 0
98870: ST_TO_ADDR
// end ;
98871: LD_VAR 0 3
98875: RET
// export function HealTarget ( sci ) ; begin
98876: LD_INT 0
98878: PPUSH
// if not sci then
98879: LD_VAR 0 1
98883: NOT
98884: IFFALSE 98888
// exit ;
98886: GO 98953
// result := 0 ;
98888: LD_ADDR_VAR 0 2
98892: PUSH
98893: LD_INT 0
98895: ST_TO_ADDR
// if GetTaskList ( sci ) then
98896: LD_VAR 0 1
98900: PPUSH
98901: CALL_OW 437
98905: IFFALSE 98953
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98907: LD_VAR 0 1
98911: PPUSH
98912: CALL_OW 437
98916: PUSH
98917: LD_INT 1
98919: ARRAY
98920: PUSH
98921: LD_INT 1
98923: ARRAY
98924: PUSH
98925: LD_STRING l
98927: EQUAL
98928: IFFALSE 98953
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98930: LD_ADDR_VAR 0 2
98934: PUSH
98935: LD_VAR 0 1
98939: PPUSH
98940: CALL_OW 437
98944: PUSH
98945: LD_INT 1
98947: ARRAY
98948: PUSH
98949: LD_INT 4
98951: ARRAY
98952: ST_TO_ADDR
// end ;
98953: LD_VAR 0 2
98957: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98958: LD_INT 0
98960: PPUSH
98961: PPUSH
98962: PPUSH
98963: PPUSH
// if not base_units then
98964: LD_VAR 0 1
98968: NOT
98969: IFFALSE 98973
// exit ;
98971: GO 99060
// result := false ;
98973: LD_ADDR_VAR 0 2
98977: PUSH
98978: LD_INT 0
98980: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98981: LD_ADDR_VAR 0 5
98985: PUSH
98986: LD_VAR 0 1
98990: PPUSH
98991: LD_INT 21
98993: PUSH
98994: LD_INT 3
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: PPUSH
99001: CALL_OW 72
99005: ST_TO_ADDR
// if not tmp then
99006: LD_VAR 0 5
99010: NOT
99011: IFFALSE 99015
// exit ;
99013: GO 99060
// for i in tmp do
99015: LD_ADDR_VAR 0 3
99019: PUSH
99020: LD_VAR 0 5
99024: PUSH
99025: FOR_IN
99026: IFFALSE 99058
// begin result := EnemyInRange ( i , 22 ) ;
99028: LD_ADDR_VAR 0 2
99032: PUSH
99033: LD_VAR 0 3
99037: PPUSH
99038: LD_INT 22
99040: PPUSH
99041: CALL 96647 0 2
99045: ST_TO_ADDR
// if result then
99046: LD_VAR 0 2
99050: IFFALSE 99056
// exit ;
99052: POP
99053: POP
99054: GO 99060
// end ;
99056: GO 99025
99058: POP
99059: POP
// end ;
99060: LD_VAR 0 2
99064: RET
// export function FilterByTag ( units , tag ) ; begin
99065: LD_INT 0
99067: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
99068: LD_ADDR_VAR 0 3
99072: PUSH
99073: LD_VAR 0 1
99077: PPUSH
99078: LD_INT 120
99080: PUSH
99081: LD_VAR 0 2
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: PPUSH
99090: CALL_OW 72
99094: ST_TO_ADDR
// end ;
99095: LD_VAR 0 3
99099: RET
// export function IsDriver ( un ) ; begin
99100: LD_INT 0
99102: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99103: LD_ADDR_VAR 0 2
99107: PUSH
99108: LD_VAR 0 1
99112: PUSH
99113: LD_INT 55
99115: PUSH
99116: EMPTY
99117: LIST
99118: PPUSH
99119: CALL_OW 69
99123: IN
99124: ST_TO_ADDR
// end ;
99125: LD_VAR 0 2
99129: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
// list := [ ] ;
99134: LD_ADDR_VAR 0 5
99138: PUSH
99139: EMPTY
99140: ST_TO_ADDR
// case d of 0 :
99141: LD_VAR 0 3
99145: PUSH
99146: LD_INT 0
99148: DOUBLE
99149: EQUAL
99150: IFTRUE 99154
99152: GO 99287
99154: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
99155: LD_ADDR_VAR 0 5
99159: PUSH
99160: LD_VAR 0 1
99164: PUSH
99165: LD_INT 4
99167: MINUS
99168: PUSH
99169: LD_VAR 0 2
99173: PUSH
99174: LD_INT 4
99176: MINUS
99177: PUSH
99178: LD_INT 2
99180: PUSH
99181: EMPTY
99182: LIST
99183: LIST
99184: LIST
99185: PUSH
99186: LD_VAR 0 1
99190: PUSH
99191: LD_INT 3
99193: MINUS
99194: PUSH
99195: LD_VAR 0 2
99199: PUSH
99200: LD_INT 1
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: LIST
99207: PUSH
99208: LD_VAR 0 1
99212: PUSH
99213: LD_INT 4
99215: PLUS
99216: PUSH
99217: LD_VAR 0 2
99221: PUSH
99222: LD_INT 4
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: LIST
99229: PUSH
99230: LD_VAR 0 1
99234: PUSH
99235: LD_INT 3
99237: PLUS
99238: PUSH
99239: LD_VAR 0 2
99243: PUSH
99244: LD_INT 3
99246: PLUS
99247: PUSH
99248: LD_INT 5
99250: PUSH
99251: EMPTY
99252: LIST
99253: LIST
99254: LIST
99255: PUSH
99256: LD_VAR 0 1
99260: PUSH
99261: LD_VAR 0 2
99265: PUSH
99266: LD_INT 4
99268: PLUS
99269: PUSH
99270: LD_INT 0
99272: PUSH
99273: EMPTY
99274: LIST
99275: LIST
99276: LIST
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: ST_TO_ADDR
// end ; 1 :
99285: GO 99985
99287: LD_INT 1
99289: DOUBLE
99290: EQUAL
99291: IFTRUE 99295
99293: GO 99428
99295: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
99296: LD_ADDR_VAR 0 5
99300: PUSH
99301: LD_VAR 0 1
99305: PUSH
99306: LD_VAR 0 2
99310: PUSH
99311: LD_INT 4
99313: MINUS
99314: PUSH
99315: LD_INT 3
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: LIST
99322: PUSH
99323: LD_VAR 0 1
99327: PUSH
99328: LD_INT 3
99330: MINUS
99331: PUSH
99332: LD_VAR 0 2
99336: PUSH
99337: LD_INT 3
99339: MINUS
99340: PUSH
99341: LD_INT 2
99343: PUSH
99344: EMPTY
99345: LIST
99346: LIST
99347: LIST
99348: PUSH
99349: LD_VAR 0 1
99353: PUSH
99354: LD_INT 4
99356: MINUS
99357: PUSH
99358: LD_VAR 0 2
99362: PUSH
99363: LD_INT 1
99365: PUSH
99366: EMPTY
99367: LIST
99368: LIST
99369: LIST
99370: PUSH
99371: LD_VAR 0 1
99375: PUSH
99376: LD_VAR 0 2
99380: PUSH
99381: LD_INT 3
99383: PLUS
99384: PUSH
99385: LD_INT 0
99387: PUSH
99388: EMPTY
99389: LIST
99390: LIST
99391: LIST
99392: PUSH
99393: LD_VAR 0 1
99397: PUSH
99398: LD_INT 4
99400: PLUS
99401: PUSH
99402: LD_VAR 0 2
99406: PUSH
99407: LD_INT 4
99409: PLUS
99410: PUSH
99411: LD_INT 5
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: LIST
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: ST_TO_ADDR
// end ; 2 :
99426: GO 99985
99428: LD_INT 2
99430: DOUBLE
99431: EQUAL
99432: IFTRUE 99436
99434: GO 99565
99436: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99437: LD_ADDR_VAR 0 5
99441: PUSH
99442: LD_VAR 0 1
99446: PUSH
99447: LD_VAR 0 2
99451: PUSH
99452: LD_INT 3
99454: MINUS
99455: PUSH
99456: LD_INT 3
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: LIST
99463: PUSH
99464: LD_VAR 0 1
99468: PUSH
99469: LD_INT 4
99471: PLUS
99472: PUSH
99473: LD_VAR 0 2
99477: PUSH
99478: LD_INT 4
99480: PUSH
99481: EMPTY
99482: LIST
99483: LIST
99484: LIST
99485: PUSH
99486: LD_VAR 0 1
99490: PUSH
99491: LD_VAR 0 2
99495: PUSH
99496: LD_INT 4
99498: PLUS
99499: PUSH
99500: LD_INT 0
99502: PUSH
99503: EMPTY
99504: LIST
99505: LIST
99506: LIST
99507: PUSH
99508: LD_VAR 0 1
99512: PUSH
99513: LD_INT 3
99515: MINUS
99516: PUSH
99517: LD_VAR 0 2
99521: PUSH
99522: LD_INT 1
99524: PUSH
99525: EMPTY
99526: LIST
99527: LIST
99528: LIST
99529: PUSH
99530: LD_VAR 0 1
99534: PUSH
99535: LD_INT 4
99537: MINUS
99538: PUSH
99539: LD_VAR 0 2
99543: PUSH
99544: LD_INT 4
99546: MINUS
99547: PUSH
99548: LD_INT 2
99550: PUSH
99551: EMPTY
99552: LIST
99553: LIST
99554: LIST
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: ST_TO_ADDR
// end ; 3 :
99563: GO 99985
99565: LD_INT 3
99567: DOUBLE
99568: EQUAL
99569: IFTRUE 99573
99571: GO 99706
99573: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99574: LD_ADDR_VAR 0 5
99578: PUSH
99579: LD_VAR 0 1
99583: PUSH
99584: LD_INT 3
99586: PLUS
99587: PUSH
99588: LD_VAR 0 2
99592: PUSH
99593: LD_INT 4
99595: PUSH
99596: EMPTY
99597: LIST
99598: LIST
99599: LIST
99600: PUSH
99601: LD_VAR 0 1
99605: PUSH
99606: LD_INT 4
99608: PLUS
99609: PUSH
99610: LD_VAR 0 2
99614: PUSH
99615: LD_INT 4
99617: PLUS
99618: PUSH
99619: LD_INT 5
99621: PUSH
99622: EMPTY
99623: LIST
99624: LIST
99625: LIST
99626: PUSH
99627: LD_VAR 0 1
99631: PUSH
99632: LD_INT 4
99634: MINUS
99635: PUSH
99636: LD_VAR 0 2
99640: PUSH
99641: LD_INT 1
99643: PUSH
99644: EMPTY
99645: LIST
99646: LIST
99647: LIST
99648: PUSH
99649: LD_VAR 0 1
99653: PUSH
99654: LD_VAR 0 2
99658: PUSH
99659: LD_INT 4
99661: MINUS
99662: PUSH
99663: LD_INT 3
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: LIST
99670: PUSH
99671: LD_VAR 0 1
99675: PUSH
99676: LD_INT 3
99678: MINUS
99679: PUSH
99680: LD_VAR 0 2
99684: PUSH
99685: LD_INT 3
99687: MINUS
99688: PUSH
99689: LD_INT 2
99691: PUSH
99692: EMPTY
99693: LIST
99694: LIST
99695: LIST
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: LIST
99703: ST_TO_ADDR
// end ; 4 :
99704: GO 99985
99706: LD_INT 4
99708: DOUBLE
99709: EQUAL
99710: IFTRUE 99714
99712: GO 99847
99714: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99715: LD_ADDR_VAR 0 5
99719: PUSH
99720: LD_VAR 0 1
99724: PUSH
99725: LD_VAR 0 2
99729: PUSH
99730: LD_INT 4
99732: PLUS
99733: PUSH
99734: LD_INT 0
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: LIST
99741: PUSH
99742: LD_VAR 0 1
99746: PUSH
99747: LD_INT 3
99749: PLUS
99750: PUSH
99751: LD_VAR 0 2
99755: PUSH
99756: LD_INT 3
99758: PLUS
99759: PUSH
99760: LD_INT 5
99762: PUSH
99763: EMPTY
99764: LIST
99765: LIST
99766: LIST
99767: PUSH
99768: LD_VAR 0 1
99772: PUSH
99773: LD_INT 4
99775: PLUS
99776: PUSH
99777: LD_VAR 0 2
99781: PUSH
99782: LD_INT 4
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: LIST
99789: PUSH
99790: LD_VAR 0 1
99794: PUSH
99795: LD_VAR 0 2
99799: PUSH
99800: LD_INT 3
99802: MINUS
99803: PUSH
99804: LD_INT 3
99806: PUSH
99807: EMPTY
99808: LIST
99809: LIST
99810: LIST
99811: PUSH
99812: LD_VAR 0 1
99816: PUSH
99817: LD_INT 4
99819: MINUS
99820: PUSH
99821: LD_VAR 0 2
99825: PUSH
99826: LD_INT 4
99828: MINUS
99829: PUSH
99830: LD_INT 2
99832: PUSH
99833: EMPTY
99834: LIST
99835: LIST
99836: LIST
99837: PUSH
99838: EMPTY
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: ST_TO_ADDR
// end ; 5 :
99845: GO 99985
99847: LD_INT 5
99849: DOUBLE
99850: EQUAL
99851: IFTRUE 99855
99853: GO 99984
99855: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99856: LD_ADDR_VAR 0 5
99860: PUSH
99861: LD_VAR 0 1
99865: PUSH
99866: LD_INT 4
99868: MINUS
99869: PUSH
99870: LD_VAR 0 2
99874: PUSH
99875: LD_INT 1
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: LIST
99882: PUSH
99883: LD_VAR 0 1
99887: PUSH
99888: LD_VAR 0 2
99892: PUSH
99893: LD_INT 4
99895: MINUS
99896: PUSH
99897: LD_INT 3
99899: PUSH
99900: EMPTY
99901: LIST
99902: LIST
99903: LIST
99904: PUSH
99905: LD_VAR 0 1
99909: PUSH
99910: LD_INT 4
99912: PLUS
99913: PUSH
99914: LD_VAR 0 2
99918: PUSH
99919: LD_INT 4
99921: PLUS
99922: PUSH
99923: LD_INT 5
99925: PUSH
99926: EMPTY
99927: LIST
99928: LIST
99929: LIST
99930: PUSH
99931: LD_VAR 0 1
99935: PUSH
99936: LD_INT 3
99938: PLUS
99939: PUSH
99940: LD_VAR 0 2
99944: PUSH
99945: LD_INT 4
99947: PUSH
99948: EMPTY
99949: LIST
99950: LIST
99951: LIST
99952: PUSH
99953: LD_VAR 0 1
99957: PUSH
99958: LD_VAR 0 2
99962: PUSH
99963: LD_INT 3
99965: PLUS
99966: PUSH
99967: LD_INT 0
99969: PUSH
99970: EMPTY
99971: LIST
99972: LIST
99973: LIST
99974: PUSH
99975: EMPTY
99976: LIST
99977: LIST
99978: LIST
99979: LIST
99980: LIST
99981: ST_TO_ADDR
// end ; end ;
99982: GO 99985
99984: POP
// result := list ;
99985: LD_ADDR_VAR 0 4
99989: PUSH
99990: LD_VAR 0 5
99994: ST_TO_ADDR
// end ;
99995: LD_VAR 0 4
99999: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100000: LD_INT 0
100002: PPUSH
100003: PPUSH
100004: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100005: LD_VAR 0 1
100009: NOT
100010: PUSH
100011: LD_VAR 0 2
100015: PUSH
100016: LD_INT 1
100018: PUSH
100019: LD_INT 2
100021: PUSH
100022: LD_INT 3
100024: PUSH
100025: LD_INT 4
100027: PUSH
100028: EMPTY
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: IN
100034: NOT
100035: OR
100036: IFFALSE 100040
// exit ;
100038: GO 100123
// tmp := [ ] ;
100040: LD_ADDR_VAR 0 5
100044: PUSH
100045: EMPTY
100046: ST_TO_ADDR
// for i in units do
100047: LD_ADDR_VAR 0 4
100051: PUSH
100052: LD_VAR 0 1
100056: PUSH
100057: FOR_IN
100058: IFFALSE 100092
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
100060: LD_ADDR_VAR 0 5
100064: PUSH
100065: LD_VAR 0 5
100069: PPUSH
100070: LD_VAR 0 4
100074: PPUSH
100075: LD_VAR 0 2
100079: PPUSH
100080: CALL_OW 259
100084: PPUSH
100085: CALL 101496 0 2
100089: ST_TO_ADDR
100090: GO 100057
100092: POP
100093: POP
// if not tmp then
100094: LD_VAR 0 5
100098: NOT
100099: IFFALSE 100103
// exit ;
100101: GO 100123
// result := SortListByListDesc ( units , tmp ) ;
100103: LD_ADDR_VAR 0 3
100107: PUSH
100108: LD_VAR 0 1
100112: PPUSH
100113: LD_VAR 0 5
100117: PPUSH
100118: CALL_OW 77
100122: ST_TO_ADDR
// end ;
100123: LD_VAR 0 3
100127: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
100128: LD_INT 0
100130: PPUSH
100131: PPUSH
100132: PPUSH
// result := false ;
100133: LD_ADDR_VAR 0 3
100137: PUSH
100138: LD_INT 0
100140: ST_TO_ADDR
// if not building then
100141: LD_VAR 0 2
100145: NOT
100146: IFFALSE 100150
// exit ;
100148: GO 100288
// x := GetX ( building ) ;
100150: LD_ADDR_VAR 0 4
100154: PUSH
100155: LD_VAR 0 2
100159: PPUSH
100160: CALL_OW 250
100164: ST_TO_ADDR
// y := GetY ( building ) ;
100165: LD_ADDR_VAR 0 5
100169: PUSH
100170: LD_VAR 0 2
100174: PPUSH
100175: CALL_OW 251
100179: ST_TO_ADDR
// if not x or not y then
100180: LD_VAR 0 4
100184: NOT
100185: PUSH
100186: LD_VAR 0 5
100190: NOT
100191: OR
100192: IFFALSE 100196
// exit ;
100194: GO 100288
// if GetTaskList ( unit ) then
100196: LD_VAR 0 1
100200: PPUSH
100201: CALL_OW 437
100205: IFFALSE 100288
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100207: LD_STRING e
100209: PUSH
100210: LD_VAR 0 1
100214: PPUSH
100215: CALL_OW 437
100219: PUSH
100220: LD_INT 1
100222: ARRAY
100223: PUSH
100224: LD_INT 1
100226: ARRAY
100227: EQUAL
100228: PUSH
100229: LD_VAR 0 4
100233: PUSH
100234: LD_VAR 0 1
100238: PPUSH
100239: CALL_OW 437
100243: PUSH
100244: LD_INT 1
100246: ARRAY
100247: PUSH
100248: LD_INT 2
100250: ARRAY
100251: EQUAL
100252: AND
100253: PUSH
100254: LD_VAR 0 5
100258: PUSH
100259: LD_VAR 0 1
100263: PPUSH
100264: CALL_OW 437
100268: PUSH
100269: LD_INT 1
100271: ARRAY
100272: PUSH
100273: LD_INT 3
100275: ARRAY
100276: EQUAL
100277: AND
100278: IFFALSE 100288
// result := true end ;
100280: LD_ADDR_VAR 0 3
100284: PUSH
100285: LD_INT 1
100287: ST_TO_ADDR
// end ;
100288: LD_VAR 0 3
100292: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
100293: LD_INT 0
100295: PPUSH
// result := false ;
100296: LD_ADDR_VAR 0 4
100300: PUSH
100301: LD_INT 0
100303: ST_TO_ADDR
// if GetTaskList ( unit ) then
100304: LD_VAR 0 1
100308: PPUSH
100309: CALL_OW 437
100313: IFFALSE 100396
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100315: LD_STRING M
100317: PUSH
100318: LD_VAR 0 1
100322: PPUSH
100323: CALL_OW 437
100327: PUSH
100328: LD_INT 1
100330: ARRAY
100331: PUSH
100332: LD_INT 1
100334: ARRAY
100335: EQUAL
100336: PUSH
100337: LD_VAR 0 2
100341: PUSH
100342: LD_VAR 0 1
100346: PPUSH
100347: CALL_OW 437
100351: PUSH
100352: LD_INT 1
100354: ARRAY
100355: PUSH
100356: LD_INT 2
100358: ARRAY
100359: EQUAL
100360: AND
100361: PUSH
100362: LD_VAR 0 3
100366: PUSH
100367: LD_VAR 0 1
100371: PPUSH
100372: CALL_OW 437
100376: PUSH
100377: LD_INT 1
100379: ARRAY
100380: PUSH
100381: LD_INT 3
100383: ARRAY
100384: EQUAL
100385: AND
100386: IFFALSE 100396
// result := true ;
100388: LD_ADDR_VAR 0 4
100392: PUSH
100393: LD_INT 1
100395: ST_TO_ADDR
// end ; end ;
100396: LD_VAR 0 4
100400: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100401: LD_INT 0
100403: PPUSH
100404: PPUSH
100405: PPUSH
100406: PPUSH
// if not unit or not area then
100407: LD_VAR 0 1
100411: NOT
100412: PUSH
100413: LD_VAR 0 2
100417: NOT
100418: OR
100419: IFFALSE 100423
// exit ;
100421: GO 100599
// tmp := AreaToList ( area , i ) ;
100423: LD_ADDR_VAR 0 6
100427: PUSH
100428: LD_VAR 0 2
100432: PPUSH
100433: LD_VAR 0 5
100437: PPUSH
100438: CALL_OW 517
100442: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100443: LD_ADDR_VAR 0 5
100447: PUSH
100448: DOUBLE
100449: LD_INT 1
100451: DEC
100452: ST_TO_ADDR
100453: LD_VAR 0 6
100457: PUSH
100458: LD_INT 1
100460: ARRAY
100461: PUSH
100462: FOR_TO
100463: IFFALSE 100597
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100465: LD_ADDR_VAR 0 7
100469: PUSH
100470: LD_VAR 0 6
100474: PUSH
100475: LD_INT 1
100477: ARRAY
100478: PUSH
100479: LD_VAR 0 5
100483: ARRAY
100484: PUSH
100485: LD_VAR 0 6
100489: PUSH
100490: LD_INT 2
100492: ARRAY
100493: PUSH
100494: LD_VAR 0 5
100498: ARRAY
100499: PUSH
100500: EMPTY
100501: LIST
100502: LIST
100503: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
100504: LD_INT 92
100506: PUSH
100507: LD_VAR 0 7
100511: PUSH
100512: LD_INT 1
100514: ARRAY
100515: PUSH
100516: LD_VAR 0 7
100520: PUSH
100521: LD_INT 2
100523: ARRAY
100524: PUSH
100525: LD_INT 2
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: LIST
100532: LIST
100533: PPUSH
100534: CALL_OW 69
100538: PUSH
100539: LD_INT 0
100541: EQUAL
100542: IFFALSE 100595
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100544: LD_VAR 0 1
100548: PPUSH
100549: LD_VAR 0 7
100553: PUSH
100554: LD_INT 1
100556: ARRAY
100557: PPUSH
100558: LD_VAR 0 7
100562: PUSH
100563: LD_INT 2
100565: ARRAY
100566: PPUSH
100567: LD_VAR 0 3
100571: PPUSH
100572: CALL_OW 48
// result := IsPlaced ( unit ) ;
100576: LD_ADDR_VAR 0 4
100580: PUSH
100581: LD_VAR 0 1
100585: PPUSH
100586: CALL_OW 305
100590: ST_TO_ADDR
// exit ;
100591: POP
100592: POP
100593: GO 100599
// end ; end ;
100595: GO 100462
100597: POP
100598: POP
// end ;
100599: LD_VAR 0 4
100603: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100604: LD_INT 0
100606: PPUSH
100607: PPUSH
100608: PPUSH
// if not side or side > 8 then
100609: LD_VAR 0 1
100613: NOT
100614: PUSH
100615: LD_VAR 0 1
100619: PUSH
100620: LD_INT 8
100622: GREATER
100623: OR
100624: IFFALSE 100628
// exit ;
100626: GO 100815
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100628: LD_ADDR_VAR 0 4
100632: PUSH
100633: LD_INT 22
100635: PUSH
100636: LD_VAR 0 1
100640: PUSH
100641: EMPTY
100642: LIST
100643: LIST
100644: PUSH
100645: LD_INT 21
100647: PUSH
100648: LD_INT 3
100650: PUSH
100651: EMPTY
100652: LIST
100653: LIST
100654: PUSH
100655: EMPTY
100656: LIST
100657: LIST
100658: PPUSH
100659: CALL_OW 69
100663: ST_TO_ADDR
// if not tmp then
100664: LD_VAR 0 4
100668: NOT
100669: IFFALSE 100673
// exit ;
100671: GO 100815
// enable_addtolog := true ;
100673: LD_ADDR_OWVAR 81
100677: PUSH
100678: LD_INT 1
100680: ST_TO_ADDR
// AddToLog ( [ ) ;
100681: LD_STRING [
100683: PPUSH
100684: CALL_OW 561
// for i in tmp do
100688: LD_ADDR_VAR 0 3
100692: PUSH
100693: LD_VAR 0 4
100697: PUSH
100698: FOR_IN
100699: IFFALSE 100806
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100701: LD_STRING [
100703: PUSH
100704: LD_VAR 0 3
100708: PPUSH
100709: CALL_OW 266
100713: STR
100714: PUSH
100715: LD_STRING , 
100717: STR
100718: PUSH
100719: LD_VAR 0 3
100723: PPUSH
100724: CALL_OW 250
100728: STR
100729: PUSH
100730: LD_STRING , 
100732: STR
100733: PUSH
100734: LD_VAR 0 3
100738: PPUSH
100739: CALL_OW 251
100743: STR
100744: PUSH
100745: LD_STRING , 
100747: STR
100748: PUSH
100749: LD_VAR 0 3
100753: PPUSH
100754: CALL_OW 254
100758: STR
100759: PUSH
100760: LD_STRING , 
100762: STR
100763: PUSH
100764: LD_VAR 0 3
100768: PPUSH
100769: LD_INT 1
100771: PPUSH
100772: CALL_OW 268
100776: STR
100777: PUSH
100778: LD_STRING , 
100780: STR
100781: PUSH
100782: LD_VAR 0 3
100786: PPUSH
100787: LD_INT 2
100789: PPUSH
100790: CALL_OW 268
100794: STR
100795: PUSH
100796: LD_STRING ],
100798: STR
100799: PPUSH
100800: CALL_OW 561
// end ;
100804: GO 100698
100806: POP
100807: POP
// AddToLog ( ]; ) ;
100808: LD_STRING ];
100810: PPUSH
100811: CALL_OW 561
// end ;
100815: LD_VAR 0 2
100819: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100820: LD_INT 0
100822: PPUSH
100823: PPUSH
100824: PPUSH
100825: PPUSH
100826: PPUSH
// if not area or not rate or not max then
100827: LD_VAR 0 1
100831: NOT
100832: PUSH
100833: LD_VAR 0 2
100837: NOT
100838: OR
100839: PUSH
100840: LD_VAR 0 4
100844: NOT
100845: OR
100846: IFFALSE 100850
// exit ;
100848: GO 101039
// while 1 do
100850: LD_INT 1
100852: IFFALSE 101039
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100854: LD_ADDR_VAR 0 9
100858: PUSH
100859: LD_VAR 0 1
100863: PPUSH
100864: LD_INT 1
100866: PPUSH
100867: CALL_OW 287
100871: PUSH
100872: LD_INT 10
100874: MUL
100875: ST_TO_ADDR
// r := rate / 10 ;
100876: LD_ADDR_VAR 0 7
100880: PUSH
100881: LD_VAR 0 2
100885: PUSH
100886: LD_INT 10
100888: DIVREAL
100889: ST_TO_ADDR
// time := 1 1$00 ;
100890: LD_ADDR_VAR 0 8
100894: PUSH
100895: LD_INT 2100
100897: ST_TO_ADDR
// if amount < min then
100898: LD_VAR 0 9
100902: PUSH
100903: LD_VAR 0 3
100907: LESS
100908: IFFALSE 100926
// r := r * 2 else
100910: LD_ADDR_VAR 0 7
100914: PUSH
100915: LD_VAR 0 7
100919: PUSH
100920: LD_INT 2
100922: MUL
100923: ST_TO_ADDR
100924: GO 100952
// if amount > max then
100926: LD_VAR 0 9
100930: PUSH
100931: LD_VAR 0 4
100935: GREATER
100936: IFFALSE 100952
// r := r / 2 ;
100938: LD_ADDR_VAR 0 7
100942: PUSH
100943: LD_VAR 0 7
100947: PUSH
100948: LD_INT 2
100950: DIVREAL
100951: ST_TO_ADDR
// time := time / r ;
100952: LD_ADDR_VAR 0 8
100956: PUSH
100957: LD_VAR 0 8
100961: PUSH
100962: LD_VAR 0 7
100966: DIVREAL
100967: ST_TO_ADDR
// if time < 0 then
100968: LD_VAR 0 8
100972: PUSH
100973: LD_INT 0
100975: LESS
100976: IFFALSE 100993
// time := time * - 1 ;
100978: LD_ADDR_VAR 0 8
100982: PUSH
100983: LD_VAR 0 8
100987: PUSH
100988: LD_INT 1
100990: NEG
100991: MUL
100992: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100993: LD_VAR 0 8
100997: PUSH
100998: LD_INT 35
101000: PPUSH
101001: LD_INT 875
101003: PPUSH
101004: CALL_OW 12
101008: PLUS
101009: PPUSH
101010: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101014: LD_INT 1
101016: PPUSH
101017: LD_INT 5
101019: PPUSH
101020: CALL_OW 12
101024: PPUSH
101025: LD_VAR 0 1
101029: PPUSH
101030: LD_INT 1
101032: PPUSH
101033: CALL_OW 55
// end ;
101037: GO 100850
// end ;
101039: LD_VAR 0 5
101043: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101044: LD_INT 0
101046: PPUSH
101047: PPUSH
101048: PPUSH
101049: PPUSH
101050: PPUSH
101051: PPUSH
101052: PPUSH
101053: PPUSH
// if not turrets or not factories then
101054: LD_VAR 0 1
101058: NOT
101059: PUSH
101060: LD_VAR 0 2
101064: NOT
101065: OR
101066: IFFALSE 101070
// exit ;
101068: GO 101377
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101070: LD_ADDR_VAR 0 10
101074: PUSH
101075: LD_INT 5
101077: PUSH
101078: LD_INT 6
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: PUSH
101085: LD_INT 2
101087: PUSH
101088: LD_INT 4
101090: PUSH
101091: EMPTY
101092: LIST
101093: LIST
101094: PUSH
101095: LD_INT 3
101097: PUSH
101098: LD_INT 5
101100: PUSH
101101: EMPTY
101102: LIST
101103: LIST
101104: PUSH
101105: EMPTY
101106: LIST
101107: LIST
101108: LIST
101109: PUSH
101110: LD_INT 24
101112: PUSH
101113: LD_INT 25
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PUSH
101120: LD_INT 23
101122: PUSH
101123: LD_INT 27
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PUSH
101130: EMPTY
101131: LIST
101132: LIST
101133: PUSH
101134: LD_INT 42
101136: PUSH
101137: LD_INT 43
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PUSH
101144: LD_INT 44
101146: PUSH
101147: LD_INT 46
101149: PUSH
101150: EMPTY
101151: LIST
101152: LIST
101153: PUSH
101154: LD_INT 45
101156: PUSH
101157: LD_INT 47
101159: PUSH
101160: EMPTY
101161: LIST
101162: LIST
101163: PUSH
101164: EMPTY
101165: LIST
101166: LIST
101167: LIST
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: LIST
101173: ST_TO_ADDR
// result := [ ] ;
101174: LD_ADDR_VAR 0 3
101178: PUSH
101179: EMPTY
101180: ST_TO_ADDR
// for i in turrets do
101181: LD_ADDR_VAR 0 4
101185: PUSH
101186: LD_VAR 0 1
101190: PUSH
101191: FOR_IN
101192: IFFALSE 101375
// begin nat := GetNation ( i ) ;
101194: LD_ADDR_VAR 0 7
101198: PUSH
101199: LD_VAR 0 4
101203: PPUSH
101204: CALL_OW 248
101208: ST_TO_ADDR
// weapon := 0 ;
101209: LD_ADDR_VAR 0 8
101213: PUSH
101214: LD_INT 0
101216: ST_TO_ADDR
// if not nat then
101217: LD_VAR 0 7
101221: NOT
101222: IFFALSE 101226
// continue ;
101224: GO 101191
// for j in list [ nat ] do
101226: LD_ADDR_VAR 0 5
101230: PUSH
101231: LD_VAR 0 10
101235: PUSH
101236: LD_VAR 0 7
101240: ARRAY
101241: PUSH
101242: FOR_IN
101243: IFFALSE 101284
// if GetBWeapon ( i ) = j [ 1 ] then
101245: LD_VAR 0 4
101249: PPUSH
101250: CALL_OW 269
101254: PUSH
101255: LD_VAR 0 5
101259: PUSH
101260: LD_INT 1
101262: ARRAY
101263: EQUAL
101264: IFFALSE 101282
// begin weapon := j [ 2 ] ;
101266: LD_ADDR_VAR 0 8
101270: PUSH
101271: LD_VAR 0 5
101275: PUSH
101276: LD_INT 2
101278: ARRAY
101279: ST_TO_ADDR
// break ;
101280: GO 101284
// end ;
101282: GO 101242
101284: POP
101285: POP
// if not weapon then
101286: LD_VAR 0 8
101290: NOT
101291: IFFALSE 101295
// continue ;
101293: GO 101191
// for k in factories do
101295: LD_ADDR_VAR 0 6
101299: PUSH
101300: LD_VAR 0 2
101304: PUSH
101305: FOR_IN
101306: IFFALSE 101371
// begin weapons := AvailableWeaponList ( k ) ;
101308: LD_ADDR_VAR 0 9
101312: PUSH
101313: LD_VAR 0 6
101317: PPUSH
101318: CALL_OW 478
101322: ST_TO_ADDR
// if not weapons then
101323: LD_VAR 0 9
101327: NOT
101328: IFFALSE 101332
// continue ;
101330: GO 101305
// if weapon in weapons then
101332: LD_VAR 0 8
101336: PUSH
101337: LD_VAR 0 9
101341: IN
101342: IFFALSE 101369
// begin result := [ i , weapon ] ;
101344: LD_ADDR_VAR 0 3
101348: PUSH
101349: LD_VAR 0 4
101353: PUSH
101354: LD_VAR 0 8
101358: PUSH
101359: EMPTY
101360: LIST
101361: LIST
101362: ST_TO_ADDR
// exit ;
101363: POP
101364: POP
101365: POP
101366: POP
101367: GO 101377
// end ; end ;
101369: GO 101305
101371: POP
101372: POP
// end ;
101373: GO 101191
101375: POP
101376: POP
// end ;
101377: LD_VAR 0 3
101381: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101382: LD_INT 0
101384: PPUSH
// if not side or side > 8 then
101385: LD_VAR 0 3
101389: NOT
101390: PUSH
101391: LD_VAR 0 3
101395: PUSH
101396: LD_INT 8
101398: GREATER
101399: OR
101400: IFFALSE 101404
// exit ;
101402: GO 101463
// if not range then
101404: LD_VAR 0 4
101408: NOT
101409: IFFALSE 101420
// range := - 12 ;
101411: LD_ADDR_VAR 0 4
101415: PUSH
101416: LD_INT 12
101418: NEG
101419: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101420: LD_VAR 0 1
101424: PPUSH
101425: LD_VAR 0 2
101429: PPUSH
101430: LD_VAR 0 3
101434: PPUSH
101435: LD_VAR 0 4
101439: PPUSH
101440: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101444: LD_VAR 0 1
101448: PPUSH
101449: LD_VAR 0 2
101453: PPUSH
101454: LD_VAR 0 3
101458: PPUSH
101459: CALL_OW 331
// end ;
101463: LD_VAR 0 5
101467: RET
// export function Video ( mode ) ; begin
101468: LD_INT 0
101470: PPUSH
// ingame_video = mode ;
101471: LD_ADDR_OWVAR 52
101475: PUSH
101476: LD_VAR 0 1
101480: ST_TO_ADDR
// interface_hidden = mode ;
101481: LD_ADDR_OWVAR 54
101485: PUSH
101486: LD_VAR 0 1
101490: ST_TO_ADDR
// end ;
101491: LD_VAR 0 2
101495: RET
// export function Join ( array , element ) ; begin
101496: LD_INT 0
101498: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101499: LD_ADDR_VAR 0 3
101503: PUSH
101504: LD_VAR 0 1
101508: PPUSH
101509: LD_VAR 0 1
101513: PUSH
101514: LD_INT 1
101516: PLUS
101517: PPUSH
101518: LD_VAR 0 2
101522: PPUSH
101523: CALL_OW 1
101527: ST_TO_ADDR
// end ;
101528: LD_VAR 0 3
101532: RET
// export function JoinUnion ( array , element ) ; begin
101533: LD_INT 0
101535: PPUSH
// result := array union element ;
101536: LD_ADDR_VAR 0 3
101540: PUSH
101541: LD_VAR 0 1
101545: PUSH
101546: LD_VAR 0 2
101550: UNION
101551: ST_TO_ADDR
// end ;
101552: LD_VAR 0 3
101556: RET
// export function GetBehemoths ( side ) ; begin
101557: LD_INT 0
101559: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
101560: LD_ADDR_VAR 0 2
101564: PUSH
101565: LD_INT 22
101567: PUSH
101568: LD_VAR 0 1
101572: PUSH
101573: EMPTY
101574: LIST
101575: LIST
101576: PUSH
101577: LD_INT 31
101579: PUSH
101580: LD_INT 25
101582: PUSH
101583: EMPTY
101584: LIST
101585: LIST
101586: PUSH
101587: EMPTY
101588: LIST
101589: LIST
101590: PPUSH
101591: CALL_OW 69
101595: ST_TO_ADDR
// end ;
101596: LD_VAR 0 2
101600: RET
// export function Shuffle ( array ) ; var i , index ; begin
101601: LD_INT 0
101603: PPUSH
101604: PPUSH
101605: PPUSH
// result := [ ] ;
101606: LD_ADDR_VAR 0 2
101610: PUSH
101611: EMPTY
101612: ST_TO_ADDR
// if not array then
101613: LD_VAR 0 1
101617: NOT
101618: IFFALSE 101622
// exit ;
101620: GO 101721
// Randomize ;
101622: CALL_OW 10
// for i = array downto 1 do
101626: LD_ADDR_VAR 0 3
101630: PUSH
101631: DOUBLE
101632: LD_VAR 0 1
101636: INC
101637: ST_TO_ADDR
101638: LD_INT 1
101640: PUSH
101641: FOR_DOWNTO
101642: IFFALSE 101719
// begin index := rand ( 1 , array ) ;
101644: LD_ADDR_VAR 0 4
101648: PUSH
101649: LD_INT 1
101651: PPUSH
101652: LD_VAR 0 1
101656: PPUSH
101657: CALL_OW 12
101661: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101662: LD_ADDR_VAR 0 2
101666: PUSH
101667: LD_VAR 0 2
101671: PPUSH
101672: LD_VAR 0 2
101676: PUSH
101677: LD_INT 1
101679: PLUS
101680: PPUSH
101681: LD_VAR 0 1
101685: PUSH
101686: LD_VAR 0 4
101690: ARRAY
101691: PPUSH
101692: CALL_OW 2
101696: ST_TO_ADDR
// array := Delete ( array , index ) ;
101697: LD_ADDR_VAR 0 1
101701: PUSH
101702: LD_VAR 0 1
101706: PPUSH
101707: LD_VAR 0 4
101711: PPUSH
101712: CALL_OW 3
101716: ST_TO_ADDR
// end ;
101717: GO 101641
101719: POP
101720: POP
// end ;
101721: LD_VAR 0 2
101725: RET
// export function GetBaseMaterials ( base ) ; begin
101726: LD_INT 0
101728: PPUSH
// result := [ 0 , 0 , 0 ] ;
101729: LD_ADDR_VAR 0 2
101733: PUSH
101734: LD_INT 0
101736: PUSH
101737: LD_INT 0
101739: PUSH
101740: LD_INT 0
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: LIST
101747: ST_TO_ADDR
// if not base then
101748: LD_VAR 0 1
101752: NOT
101753: IFFALSE 101757
// exit ;
101755: GO 101806
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101757: LD_ADDR_VAR 0 2
101761: PUSH
101762: LD_VAR 0 1
101766: PPUSH
101767: LD_INT 1
101769: PPUSH
101770: CALL_OW 275
101774: PUSH
101775: LD_VAR 0 1
101779: PPUSH
101780: LD_INT 2
101782: PPUSH
101783: CALL_OW 275
101787: PUSH
101788: LD_VAR 0 1
101792: PPUSH
101793: LD_INT 3
101795: PPUSH
101796: CALL_OW 275
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: LIST
101805: ST_TO_ADDR
// end ;
101806: LD_VAR 0 2
101810: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101811: LD_INT 0
101813: PPUSH
101814: PPUSH
// result := array ;
101815: LD_ADDR_VAR 0 3
101819: PUSH
101820: LD_VAR 0 1
101824: ST_TO_ADDR
// if size >= result then
101825: LD_VAR 0 2
101829: PUSH
101830: LD_VAR 0 3
101834: GREATEREQUAL
101835: IFFALSE 101839
// exit ;
101837: GO 101889
// if size then
101839: LD_VAR 0 2
101843: IFFALSE 101889
// for i := array downto size do
101845: LD_ADDR_VAR 0 4
101849: PUSH
101850: DOUBLE
101851: LD_VAR 0 1
101855: INC
101856: ST_TO_ADDR
101857: LD_VAR 0 2
101861: PUSH
101862: FOR_DOWNTO
101863: IFFALSE 101887
// result := Delete ( result , result ) ;
101865: LD_ADDR_VAR 0 3
101869: PUSH
101870: LD_VAR 0 3
101874: PPUSH
101875: LD_VAR 0 3
101879: PPUSH
101880: CALL_OW 3
101884: ST_TO_ADDR
101885: GO 101862
101887: POP
101888: POP
// end ;
101889: LD_VAR 0 3
101893: RET
// export function ComExit ( unit ) ; var tmp ; begin
101894: LD_INT 0
101896: PPUSH
101897: PPUSH
// if not IsInUnit ( unit ) then
101898: LD_VAR 0 1
101902: PPUSH
101903: CALL_OW 310
101907: NOT
101908: IFFALSE 101912
// exit ;
101910: GO 101972
// tmp := IsInUnit ( unit ) ;
101912: LD_ADDR_VAR 0 3
101916: PUSH
101917: LD_VAR 0 1
101921: PPUSH
101922: CALL_OW 310
101926: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101927: LD_VAR 0 3
101931: PPUSH
101932: CALL_OW 247
101936: PUSH
101937: LD_INT 2
101939: EQUAL
101940: IFFALSE 101953
// ComExitVehicle ( unit ) else
101942: LD_VAR 0 1
101946: PPUSH
101947: CALL_OW 121
101951: GO 101962
// ComExitBuilding ( unit ) ;
101953: LD_VAR 0 1
101957: PPUSH
101958: CALL_OW 122
// result := tmp ;
101962: LD_ADDR_VAR 0 2
101966: PUSH
101967: LD_VAR 0 3
101971: ST_TO_ADDR
// end ;
101972: LD_VAR 0 2
101976: RET
// export function ComExitAll ( units ) ; var i ; begin
101977: LD_INT 0
101979: PPUSH
101980: PPUSH
// if not units then
101981: LD_VAR 0 1
101985: NOT
101986: IFFALSE 101990
// exit ;
101988: GO 102016
// for i in units do
101990: LD_ADDR_VAR 0 3
101994: PUSH
101995: LD_VAR 0 1
101999: PUSH
102000: FOR_IN
102001: IFFALSE 102014
// ComExit ( i ) ;
102003: LD_VAR 0 3
102007: PPUSH
102008: CALL 101894 0 1
102012: GO 102000
102014: POP
102015: POP
// end ;
102016: LD_VAR 0 2
102020: RET
// export function ResetHc ; begin
102021: LD_INT 0
102023: PPUSH
// InitHc ;
102024: CALL_OW 19
// hc_importance := 0 ;
102028: LD_ADDR_OWVAR 32
102032: PUSH
102033: LD_INT 0
102035: ST_TO_ADDR
// end ;
102036: LD_VAR 0 1
102040: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102041: LD_INT 0
102043: PPUSH
102044: PPUSH
102045: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102046: LD_ADDR_VAR 0 6
102050: PUSH
102051: LD_VAR 0 1
102055: PUSH
102056: LD_VAR 0 3
102060: PLUS
102061: PUSH
102062: LD_INT 2
102064: DIV
102065: ST_TO_ADDR
// if _x < 0 then
102066: LD_VAR 0 6
102070: PUSH
102071: LD_INT 0
102073: LESS
102074: IFFALSE 102091
// _x := _x * - 1 ;
102076: LD_ADDR_VAR 0 6
102080: PUSH
102081: LD_VAR 0 6
102085: PUSH
102086: LD_INT 1
102088: NEG
102089: MUL
102090: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
102091: LD_ADDR_VAR 0 7
102095: PUSH
102096: LD_VAR 0 2
102100: PUSH
102101: LD_VAR 0 4
102105: PLUS
102106: PUSH
102107: LD_INT 2
102109: DIV
102110: ST_TO_ADDR
// if _y < 0 then
102111: LD_VAR 0 7
102115: PUSH
102116: LD_INT 0
102118: LESS
102119: IFFALSE 102136
// _y := _y * - 1 ;
102121: LD_ADDR_VAR 0 7
102125: PUSH
102126: LD_VAR 0 7
102130: PUSH
102131: LD_INT 1
102133: NEG
102134: MUL
102135: ST_TO_ADDR
// result := [ _x , _y ] ;
102136: LD_ADDR_VAR 0 5
102140: PUSH
102141: LD_VAR 0 6
102145: PUSH
102146: LD_VAR 0 7
102150: PUSH
102151: EMPTY
102152: LIST
102153: LIST
102154: ST_TO_ADDR
// end ;
102155: LD_VAR 0 5
102159: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
102160: LD_INT 0
102162: PPUSH
102163: PPUSH
102164: PPUSH
102165: PPUSH
// task := GetTaskList ( unit ) ;
102166: LD_ADDR_VAR 0 7
102170: PUSH
102171: LD_VAR 0 1
102175: PPUSH
102176: CALL_OW 437
102180: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
102181: LD_VAR 0 7
102185: NOT
102186: PUSH
102187: LD_VAR 0 1
102191: PPUSH
102192: LD_VAR 0 2
102196: PPUSH
102197: CALL_OW 308
102201: NOT
102202: AND
102203: IFFALSE 102207
// exit ;
102205: GO 102325
// if IsInArea ( unit , area ) then
102207: LD_VAR 0 1
102211: PPUSH
102212: LD_VAR 0 2
102216: PPUSH
102217: CALL_OW 308
102221: IFFALSE 102239
// begin ComMoveToArea ( unit , goAway ) ;
102223: LD_VAR 0 1
102227: PPUSH
102228: LD_VAR 0 3
102232: PPUSH
102233: CALL_OW 113
// exit ;
102237: GO 102325
// end ; if task [ 1 ] [ 1 ] <> M then
102239: LD_VAR 0 7
102243: PUSH
102244: LD_INT 1
102246: ARRAY
102247: PUSH
102248: LD_INT 1
102250: ARRAY
102251: PUSH
102252: LD_STRING M
102254: NONEQUAL
102255: IFFALSE 102259
// exit ;
102257: GO 102325
// x := task [ 1 ] [ 2 ] ;
102259: LD_ADDR_VAR 0 5
102263: PUSH
102264: LD_VAR 0 7
102268: PUSH
102269: LD_INT 1
102271: ARRAY
102272: PUSH
102273: LD_INT 2
102275: ARRAY
102276: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
102277: LD_ADDR_VAR 0 6
102281: PUSH
102282: LD_VAR 0 7
102286: PUSH
102287: LD_INT 1
102289: ARRAY
102290: PUSH
102291: LD_INT 3
102293: ARRAY
102294: ST_TO_ADDR
// if InArea ( x , y , area ) then
102295: LD_VAR 0 5
102299: PPUSH
102300: LD_VAR 0 6
102304: PPUSH
102305: LD_VAR 0 2
102309: PPUSH
102310: CALL_OW 309
102314: IFFALSE 102325
// ComStop ( unit ) ;
102316: LD_VAR 0 1
102320: PPUSH
102321: CALL_OW 141
// end ;
102325: LD_VAR 0 4
102329: RET
// export function Abs ( value ) ; begin
102330: LD_INT 0
102332: PPUSH
// result := value ;
102333: LD_ADDR_VAR 0 2
102337: PUSH
102338: LD_VAR 0 1
102342: ST_TO_ADDR
// if value < 0 then
102343: LD_VAR 0 1
102347: PUSH
102348: LD_INT 0
102350: LESS
102351: IFFALSE 102368
// result := value * - 1 ;
102353: LD_ADDR_VAR 0 2
102357: PUSH
102358: LD_VAR 0 1
102362: PUSH
102363: LD_INT 1
102365: NEG
102366: MUL
102367: ST_TO_ADDR
// end ;
102368: LD_VAR 0 2
102372: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
102373: LD_INT 0
102375: PPUSH
102376: PPUSH
102377: PPUSH
102378: PPUSH
102379: PPUSH
102380: PPUSH
102381: PPUSH
102382: PPUSH
// if not unit or not building then
102383: LD_VAR 0 1
102387: NOT
102388: PUSH
102389: LD_VAR 0 2
102393: NOT
102394: OR
102395: IFFALSE 102399
// exit ;
102397: GO 102625
// x := GetX ( building ) ;
102399: LD_ADDR_VAR 0 4
102403: PUSH
102404: LD_VAR 0 2
102408: PPUSH
102409: CALL_OW 250
102413: ST_TO_ADDR
// y := GetY ( building ) ;
102414: LD_ADDR_VAR 0 6
102418: PUSH
102419: LD_VAR 0 2
102423: PPUSH
102424: CALL_OW 251
102428: ST_TO_ADDR
// d := GetDir ( building ) ;
102429: LD_ADDR_VAR 0 8
102433: PUSH
102434: LD_VAR 0 2
102438: PPUSH
102439: CALL_OW 254
102443: ST_TO_ADDR
// r := 4 ;
102444: LD_ADDR_VAR 0 9
102448: PUSH
102449: LD_INT 4
102451: ST_TO_ADDR
// for i := 1 to 5 do
102452: LD_ADDR_VAR 0 10
102456: PUSH
102457: DOUBLE
102458: LD_INT 1
102460: DEC
102461: ST_TO_ADDR
102462: LD_INT 5
102464: PUSH
102465: FOR_TO
102466: IFFALSE 102623
// begin _x := ShiftX ( x , d , r + i ) ;
102468: LD_ADDR_VAR 0 5
102472: PUSH
102473: LD_VAR 0 4
102477: PPUSH
102478: LD_VAR 0 8
102482: PPUSH
102483: LD_VAR 0 9
102487: PUSH
102488: LD_VAR 0 10
102492: PLUS
102493: PPUSH
102494: CALL_OW 272
102498: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102499: LD_ADDR_VAR 0 7
102503: PUSH
102504: LD_VAR 0 6
102508: PPUSH
102509: LD_VAR 0 8
102513: PPUSH
102514: LD_VAR 0 9
102518: PUSH
102519: LD_VAR 0 10
102523: PLUS
102524: PPUSH
102525: CALL_OW 273
102529: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102530: LD_VAR 0 5
102534: PPUSH
102535: LD_VAR 0 7
102539: PPUSH
102540: CALL_OW 488
102544: PUSH
102545: LD_VAR 0 5
102549: PPUSH
102550: LD_VAR 0 7
102554: PPUSH
102555: CALL_OW 428
102559: PPUSH
102560: CALL_OW 247
102564: PUSH
102565: LD_INT 3
102567: PUSH
102568: LD_INT 2
102570: PUSH
102571: EMPTY
102572: LIST
102573: LIST
102574: IN
102575: NOT
102576: AND
102577: IFFALSE 102621
// begin ComMoveXY ( unit , _x , _y ) ;
102579: LD_VAR 0 1
102583: PPUSH
102584: LD_VAR 0 5
102588: PPUSH
102589: LD_VAR 0 7
102593: PPUSH
102594: CALL_OW 111
// result := [ _x , _y ] ;
102598: LD_ADDR_VAR 0 3
102602: PUSH
102603: LD_VAR 0 5
102607: PUSH
102608: LD_VAR 0 7
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: ST_TO_ADDR
// exit ;
102617: POP
102618: POP
102619: GO 102625
// end ; end ;
102621: GO 102465
102623: POP
102624: POP
// end ;
102625: LD_VAR 0 3
102629: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
102630: LD_INT 0
102632: PPUSH
102633: PPUSH
102634: PPUSH
// result := 0 ;
102635: LD_ADDR_VAR 0 3
102639: PUSH
102640: LD_INT 0
102642: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
102643: LD_VAR 0 1
102647: PUSH
102648: LD_INT 0
102650: LESS
102651: PUSH
102652: LD_VAR 0 1
102656: PUSH
102657: LD_INT 8
102659: GREATER
102660: OR
102661: PUSH
102662: LD_VAR 0 2
102666: PUSH
102667: LD_INT 0
102669: LESS
102670: OR
102671: PUSH
102672: LD_VAR 0 2
102676: PUSH
102677: LD_INT 8
102679: GREATER
102680: OR
102681: IFFALSE 102685
// exit ;
102683: GO 102760
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
102685: LD_ADDR_VAR 0 4
102689: PUSH
102690: LD_INT 22
102692: PUSH
102693: LD_VAR 0 2
102697: PUSH
102698: EMPTY
102699: LIST
102700: LIST
102701: PPUSH
102702: CALL_OW 69
102706: PUSH
102707: FOR_IN
102708: IFFALSE 102758
// begin un := UnitShoot ( i ) ;
102710: LD_ADDR_VAR 0 5
102714: PUSH
102715: LD_VAR 0 4
102719: PPUSH
102720: CALL_OW 504
102724: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102725: LD_VAR 0 5
102729: PPUSH
102730: CALL_OW 255
102734: PUSH
102735: LD_VAR 0 1
102739: EQUAL
102740: IFFALSE 102756
// begin result := un ;
102742: LD_ADDR_VAR 0 3
102746: PUSH
102747: LD_VAR 0 5
102751: ST_TO_ADDR
// exit ;
102752: POP
102753: POP
102754: GO 102760
// end ; end ;
102756: GO 102707
102758: POP
102759: POP
// end ;
102760: LD_VAR 0 3
102764: RET
// export function GetCargoBay ( units ) ; begin
102765: LD_INT 0
102767: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
102768: LD_ADDR_VAR 0 2
102772: PUSH
102773: LD_VAR 0 1
102777: PPUSH
102778: LD_INT 2
102780: PUSH
102781: LD_INT 34
102783: PUSH
102784: LD_INT 12
102786: PUSH
102787: EMPTY
102788: LIST
102789: LIST
102790: PUSH
102791: LD_INT 34
102793: PUSH
102794: LD_INT 51
102796: PUSH
102797: EMPTY
102798: LIST
102799: LIST
102800: PUSH
102801: LD_INT 34
102803: PUSH
102804: LD_INT 32
102806: PUSH
102807: EMPTY
102808: LIST
102809: LIST
102810: PUSH
102811: LD_INT 34
102813: PUSH
102814: LD_INT 89
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: PUSH
102821: EMPTY
102822: LIST
102823: LIST
102824: LIST
102825: LIST
102826: LIST
102827: PPUSH
102828: CALL_OW 72
102832: ST_TO_ADDR
// end ;
102833: LD_VAR 0 2
102837: RET
// export function Negate ( value ) ; begin
102838: LD_INT 0
102840: PPUSH
// result := not value ;
102841: LD_ADDR_VAR 0 2
102845: PUSH
102846: LD_VAR 0 1
102850: NOT
102851: ST_TO_ADDR
// end ;
102852: LD_VAR 0 2
102856: RET
// export function Inc ( value ) ; begin
102857: LD_INT 0
102859: PPUSH
// result := value + 1 ;
102860: LD_ADDR_VAR 0 2
102864: PUSH
102865: LD_VAR 0 1
102869: PUSH
102870: LD_INT 1
102872: PLUS
102873: ST_TO_ADDR
// end ;
102874: LD_VAR 0 2
102878: RET
// export function Dec ( value ) ; begin
102879: LD_INT 0
102881: PPUSH
// result := value - 1 ;
102882: LD_ADDR_VAR 0 2
102886: PUSH
102887: LD_VAR 0 1
102891: PUSH
102892: LD_INT 1
102894: MINUS
102895: ST_TO_ADDR
// end ;
102896: LD_VAR 0 2
102900: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
102901: LD_INT 0
102903: PPUSH
102904: PPUSH
102905: PPUSH
102906: PPUSH
102907: PPUSH
102908: PPUSH
102909: PPUSH
102910: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102911: LD_VAR 0 1
102915: PPUSH
102916: LD_VAR 0 2
102920: PPUSH
102921: CALL_OW 488
102925: NOT
102926: PUSH
102927: LD_VAR 0 3
102931: PPUSH
102932: LD_VAR 0 4
102936: PPUSH
102937: CALL_OW 488
102941: NOT
102942: OR
102943: IFFALSE 102956
// begin result := - 1 ;
102945: LD_ADDR_VAR 0 5
102949: PUSH
102950: LD_INT 1
102952: NEG
102953: ST_TO_ADDR
// exit ;
102954: GO 103191
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102956: LD_ADDR_VAR 0 12
102960: PUSH
102961: LD_VAR 0 1
102965: PPUSH
102966: LD_VAR 0 2
102970: PPUSH
102971: LD_VAR 0 3
102975: PPUSH
102976: LD_VAR 0 4
102980: PPUSH
102981: CALL 102041 0 4
102985: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102986: LD_ADDR_VAR 0 11
102990: PUSH
102991: LD_VAR 0 1
102995: PPUSH
102996: LD_VAR 0 2
103000: PPUSH
103001: LD_VAR 0 12
103005: PUSH
103006: LD_INT 1
103008: ARRAY
103009: PPUSH
103010: LD_VAR 0 12
103014: PUSH
103015: LD_INT 2
103017: ARRAY
103018: PPUSH
103019: CALL_OW 298
103023: ST_TO_ADDR
// distance := 9999 ;
103024: LD_ADDR_VAR 0 10
103028: PUSH
103029: LD_INT 9999
103031: ST_TO_ADDR
// for i := 0 to 5 do
103032: LD_ADDR_VAR 0 6
103036: PUSH
103037: DOUBLE
103038: LD_INT 0
103040: DEC
103041: ST_TO_ADDR
103042: LD_INT 5
103044: PUSH
103045: FOR_TO
103046: IFFALSE 103189
// begin _x := ShiftX ( x1 , i , centerDist ) ;
103048: LD_ADDR_VAR 0 7
103052: PUSH
103053: LD_VAR 0 1
103057: PPUSH
103058: LD_VAR 0 6
103062: PPUSH
103063: LD_VAR 0 11
103067: PPUSH
103068: CALL_OW 272
103072: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
103073: LD_ADDR_VAR 0 8
103077: PUSH
103078: LD_VAR 0 2
103082: PPUSH
103083: LD_VAR 0 6
103087: PPUSH
103088: LD_VAR 0 11
103092: PPUSH
103093: CALL_OW 273
103097: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
103098: LD_VAR 0 7
103102: PPUSH
103103: LD_VAR 0 8
103107: PPUSH
103108: CALL_OW 488
103112: NOT
103113: IFFALSE 103117
// continue ;
103115: GO 103045
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
103117: LD_ADDR_VAR 0 9
103121: PUSH
103122: LD_VAR 0 12
103126: PUSH
103127: LD_INT 1
103129: ARRAY
103130: PPUSH
103131: LD_VAR 0 12
103135: PUSH
103136: LD_INT 2
103138: ARRAY
103139: PPUSH
103140: LD_VAR 0 7
103144: PPUSH
103145: LD_VAR 0 8
103149: PPUSH
103150: CALL_OW 298
103154: ST_TO_ADDR
// if tmp < distance then
103155: LD_VAR 0 9
103159: PUSH
103160: LD_VAR 0 10
103164: LESS
103165: IFFALSE 103187
// begin result := i ;
103167: LD_ADDR_VAR 0 5
103171: PUSH
103172: LD_VAR 0 6
103176: ST_TO_ADDR
// distance := tmp ;
103177: LD_ADDR_VAR 0 10
103181: PUSH
103182: LD_VAR 0 9
103186: ST_TO_ADDR
// end ; end ;
103187: GO 103045
103189: POP
103190: POP
// end ;
103191: LD_VAR 0 5
103195: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103196: LD_INT 0
103198: PPUSH
103199: PPUSH
// if not driver or not IsInUnit ( driver ) then
103200: LD_VAR 0 1
103204: NOT
103205: PUSH
103206: LD_VAR 0 1
103210: PPUSH
103211: CALL_OW 310
103215: NOT
103216: OR
103217: IFFALSE 103221
// exit ;
103219: GO 103311
// vehicle := IsInUnit ( driver ) ;
103221: LD_ADDR_VAR 0 3
103225: PUSH
103226: LD_VAR 0 1
103230: PPUSH
103231: CALL_OW 310
103235: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103236: LD_VAR 0 1
103240: PPUSH
103241: LD_STRING \
103243: PUSH
103244: LD_INT 0
103246: PUSH
103247: LD_INT 0
103249: PUSH
103250: LD_INT 0
103252: PUSH
103253: LD_INT 0
103255: PUSH
103256: LD_INT 0
103258: PUSH
103259: LD_INT 0
103261: PUSH
103262: EMPTY
103263: LIST
103264: LIST
103265: LIST
103266: LIST
103267: LIST
103268: LIST
103269: LIST
103270: PUSH
103271: LD_STRING E
103273: PUSH
103274: LD_INT 0
103276: PUSH
103277: LD_INT 0
103279: PUSH
103280: LD_VAR 0 3
103284: PUSH
103285: LD_INT 0
103287: PUSH
103288: LD_INT 0
103290: PUSH
103291: LD_INT 0
103293: PUSH
103294: EMPTY
103295: LIST
103296: LIST
103297: LIST
103298: LIST
103299: LIST
103300: LIST
103301: LIST
103302: PUSH
103303: EMPTY
103304: LIST
103305: LIST
103306: PPUSH
103307: CALL_OW 446
// end ;
103311: LD_VAR 0 2
103315: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103316: LD_INT 0
103318: PPUSH
103319: PPUSH
// if not driver or not IsInUnit ( driver ) then
103320: LD_VAR 0 1
103324: NOT
103325: PUSH
103326: LD_VAR 0 1
103330: PPUSH
103331: CALL_OW 310
103335: NOT
103336: OR
103337: IFFALSE 103341
// exit ;
103339: GO 103431
// vehicle := IsInUnit ( driver ) ;
103341: LD_ADDR_VAR 0 3
103345: PUSH
103346: LD_VAR 0 1
103350: PPUSH
103351: CALL_OW 310
103355: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103356: LD_VAR 0 1
103360: PPUSH
103361: LD_STRING \
103363: PUSH
103364: LD_INT 0
103366: PUSH
103367: LD_INT 0
103369: PUSH
103370: LD_INT 0
103372: PUSH
103373: LD_INT 0
103375: PUSH
103376: LD_INT 0
103378: PUSH
103379: LD_INT 0
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: LIST
103386: LIST
103387: LIST
103388: LIST
103389: LIST
103390: PUSH
103391: LD_STRING E
103393: PUSH
103394: LD_INT 0
103396: PUSH
103397: LD_INT 0
103399: PUSH
103400: LD_VAR 0 3
103404: PUSH
103405: LD_INT 0
103407: PUSH
103408: LD_INT 0
103410: PUSH
103411: LD_INT 0
103413: PUSH
103414: EMPTY
103415: LIST
103416: LIST
103417: LIST
103418: LIST
103419: LIST
103420: LIST
103421: LIST
103422: PUSH
103423: EMPTY
103424: LIST
103425: LIST
103426: PPUSH
103427: CALL_OW 447
// end ;
103431: LD_VAR 0 2
103435: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
103436: LD_INT 0
103438: PPUSH
103439: PPUSH
103440: PPUSH
// tmp := [ ] ;
103441: LD_ADDR_VAR 0 5
103445: PUSH
103446: EMPTY
103447: ST_TO_ADDR
// for i in units do
103448: LD_ADDR_VAR 0 4
103452: PUSH
103453: LD_VAR 0 1
103457: PUSH
103458: FOR_IN
103459: IFFALSE 103497
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
103461: LD_ADDR_VAR 0 5
103465: PUSH
103466: LD_VAR 0 5
103470: PPUSH
103471: LD_VAR 0 5
103475: PUSH
103476: LD_INT 1
103478: PLUS
103479: PPUSH
103480: LD_VAR 0 4
103484: PPUSH
103485: CALL_OW 256
103489: PPUSH
103490: CALL_OW 2
103494: ST_TO_ADDR
103495: GO 103458
103497: POP
103498: POP
// if not tmp then
103499: LD_VAR 0 5
103503: NOT
103504: IFFALSE 103508
// exit ;
103506: GO 103556
// if asc then
103508: LD_VAR 0 2
103512: IFFALSE 103536
// result := SortListByListAsc ( units , tmp ) else
103514: LD_ADDR_VAR 0 3
103518: PUSH
103519: LD_VAR 0 1
103523: PPUSH
103524: LD_VAR 0 5
103528: PPUSH
103529: CALL_OW 76
103533: ST_TO_ADDR
103534: GO 103556
// result := SortListByListDesc ( units , tmp ) ;
103536: LD_ADDR_VAR 0 3
103540: PUSH
103541: LD_VAR 0 1
103545: PPUSH
103546: LD_VAR 0 5
103550: PPUSH
103551: CALL_OW 77
103555: ST_TO_ADDR
// end ;
103556: LD_VAR 0 3
103560: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
103561: LD_INT 0
103563: PPUSH
103564: PPUSH
// task := GetTaskList ( mech ) ;
103565: LD_ADDR_VAR 0 4
103569: PUSH
103570: LD_VAR 0 1
103574: PPUSH
103575: CALL_OW 437
103579: ST_TO_ADDR
// if not task then
103580: LD_VAR 0 4
103584: NOT
103585: IFFALSE 103589
// exit ;
103587: GO 103631
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
103589: LD_ADDR_VAR 0 3
103593: PUSH
103594: LD_VAR 0 4
103598: PUSH
103599: LD_INT 1
103601: ARRAY
103602: PUSH
103603: LD_INT 1
103605: ARRAY
103606: PUSH
103607: LD_STRING r
103609: EQUAL
103610: PUSH
103611: LD_VAR 0 4
103615: PUSH
103616: LD_INT 1
103618: ARRAY
103619: PUSH
103620: LD_INT 4
103622: ARRAY
103623: PUSH
103624: LD_VAR 0 2
103628: EQUAL
103629: AND
103630: ST_TO_ADDR
// end ;
103631: LD_VAR 0 3
103635: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
103636: LD_INT 0
103638: PPUSH
// SetDir ( unit , d ) ;
103639: LD_VAR 0 1
103643: PPUSH
103644: LD_VAR 0 4
103648: PPUSH
103649: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
103653: LD_VAR 0 1
103657: PPUSH
103658: LD_VAR 0 2
103662: PPUSH
103663: LD_VAR 0 3
103667: PPUSH
103668: LD_VAR 0 5
103672: PPUSH
103673: CALL_OW 48
// end ;
103677: LD_VAR 0 6
103681: RET
// export function ToNaturalNumber ( number ) ; begin
103682: LD_INT 0
103684: PPUSH
// result := number div 1 ;
103685: LD_ADDR_VAR 0 2
103689: PUSH
103690: LD_VAR 0 1
103694: PUSH
103695: LD_INT 1
103697: DIV
103698: ST_TO_ADDR
// if number < 0 then
103699: LD_VAR 0 1
103703: PUSH
103704: LD_INT 0
103706: LESS
103707: IFFALSE 103717
// result := 0 ;
103709: LD_ADDR_VAR 0 2
103713: PUSH
103714: LD_INT 0
103716: ST_TO_ADDR
// end ;
103717: LD_VAR 0 2
103721: RET
// export function SortByClass ( units , class ) ; var un ; begin
103722: LD_INT 0
103724: PPUSH
103725: PPUSH
// if not units or not class then
103726: LD_VAR 0 1
103730: NOT
103731: PUSH
103732: LD_VAR 0 2
103736: NOT
103737: OR
103738: IFFALSE 103742
// exit ;
103740: GO 103837
// result := [ ] ;
103742: LD_ADDR_VAR 0 3
103746: PUSH
103747: EMPTY
103748: ST_TO_ADDR
// for un in units do
103749: LD_ADDR_VAR 0 4
103753: PUSH
103754: LD_VAR 0 1
103758: PUSH
103759: FOR_IN
103760: IFFALSE 103835
// if GetClass ( un ) = class then
103762: LD_VAR 0 4
103766: PPUSH
103767: CALL_OW 257
103771: PUSH
103772: LD_VAR 0 2
103776: EQUAL
103777: IFFALSE 103804
// result := Insert ( result , 1 , un ) else
103779: LD_ADDR_VAR 0 3
103783: PUSH
103784: LD_VAR 0 3
103788: PPUSH
103789: LD_INT 1
103791: PPUSH
103792: LD_VAR 0 4
103796: PPUSH
103797: CALL_OW 2
103801: ST_TO_ADDR
103802: GO 103833
// result := Replace ( result , result + 1 , un ) ;
103804: LD_ADDR_VAR 0 3
103808: PUSH
103809: LD_VAR 0 3
103813: PPUSH
103814: LD_VAR 0 3
103818: PUSH
103819: LD_INT 1
103821: PLUS
103822: PPUSH
103823: LD_VAR 0 4
103827: PPUSH
103828: CALL_OW 1
103832: ST_TO_ADDR
103833: GO 103759
103835: POP
103836: POP
// end ;
103837: LD_VAR 0 3
103841: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
103842: LD_INT 0
103844: PPUSH
103845: PPUSH
103846: PPUSH
103847: PPUSH
103848: PPUSH
103849: PPUSH
103850: PPUSH
// result := [ ] ;
103851: LD_ADDR_VAR 0 4
103855: PUSH
103856: EMPTY
103857: ST_TO_ADDR
// if x - r < 0 then
103858: LD_VAR 0 1
103862: PUSH
103863: LD_VAR 0 3
103867: MINUS
103868: PUSH
103869: LD_INT 0
103871: LESS
103872: IFFALSE 103884
// min_x := 0 else
103874: LD_ADDR_VAR 0 8
103878: PUSH
103879: LD_INT 0
103881: ST_TO_ADDR
103882: GO 103900
// min_x := x - r ;
103884: LD_ADDR_VAR 0 8
103888: PUSH
103889: LD_VAR 0 1
103893: PUSH
103894: LD_VAR 0 3
103898: MINUS
103899: ST_TO_ADDR
// if y - r < 0 then
103900: LD_VAR 0 2
103904: PUSH
103905: LD_VAR 0 3
103909: MINUS
103910: PUSH
103911: LD_INT 0
103913: LESS
103914: IFFALSE 103926
// min_y := 0 else
103916: LD_ADDR_VAR 0 7
103920: PUSH
103921: LD_INT 0
103923: ST_TO_ADDR
103924: GO 103942
// min_y := y - r ;
103926: LD_ADDR_VAR 0 7
103930: PUSH
103931: LD_VAR 0 2
103935: PUSH
103936: LD_VAR 0 3
103940: MINUS
103941: ST_TO_ADDR
// max_x := x + r ;
103942: LD_ADDR_VAR 0 9
103946: PUSH
103947: LD_VAR 0 1
103951: PUSH
103952: LD_VAR 0 3
103956: PLUS
103957: ST_TO_ADDR
// max_y := y + r ;
103958: LD_ADDR_VAR 0 10
103962: PUSH
103963: LD_VAR 0 2
103967: PUSH
103968: LD_VAR 0 3
103972: PLUS
103973: ST_TO_ADDR
// for _x = min_x to max_x do
103974: LD_ADDR_VAR 0 5
103978: PUSH
103979: DOUBLE
103980: LD_VAR 0 8
103984: DEC
103985: ST_TO_ADDR
103986: LD_VAR 0 9
103990: PUSH
103991: FOR_TO
103992: IFFALSE 104093
// for _y = min_y to max_y do
103994: LD_ADDR_VAR 0 6
103998: PUSH
103999: DOUBLE
104000: LD_VAR 0 7
104004: DEC
104005: ST_TO_ADDR
104006: LD_VAR 0 10
104010: PUSH
104011: FOR_TO
104012: IFFALSE 104089
// begin if not ValidHex ( _x , _y ) then
104014: LD_VAR 0 5
104018: PPUSH
104019: LD_VAR 0 6
104023: PPUSH
104024: CALL_OW 488
104028: NOT
104029: IFFALSE 104033
// continue ;
104031: GO 104011
// if GetResourceTypeXY ( _x , _y ) then
104033: LD_VAR 0 5
104037: PPUSH
104038: LD_VAR 0 6
104042: PPUSH
104043: CALL_OW 283
104047: IFFALSE 104087
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
104049: LD_ADDR_VAR 0 4
104053: PUSH
104054: LD_VAR 0 4
104058: PPUSH
104059: LD_VAR 0 4
104063: PUSH
104064: LD_INT 1
104066: PLUS
104067: PPUSH
104068: LD_VAR 0 5
104072: PUSH
104073: LD_VAR 0 6
104077: PUSH
104078: EMPTY
104079: LIST
104080: LIST
104081: PPUSH
104082: CALL_OW 1
104086: ST_TO_ADDR
// end ;
104087: GO 104011
104089: POP
104090: POP
104091: GO 103991
104093: POP
104094: POP
// end ;
104095: LD_VAR 0 4
104099: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
104100: LD_INT 0
104102: PPUSH
104103: PPUSH
104104: PPUSH
104105: PPUSH
104106: PPUSH
104107: PPUSH
104108: PPUSH
104109: PPUSH
// if not units then
104110: LD_VAR 0 1
104114: NOT
104115: IFFALSE 104119
// exit ;
104117: GO 104643
// result := UnitFilter ( units , [ f_ok ] ) ;
104119: LD_ADDR_VAR 0 3
104123: PUSH
104124: LD_VAR 0 1
104128: PPUSH
104129: LD_INT 50
104131: PUSH
104132: EMPTY
104133: LIST
104134: PPUSH
104135: CALL_OW 72
104139: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
104140: LD_ADDR_VAR 0 8
104144: PUSH
104145: LD_VAR 0 1
104149: PUSH
104150: LD_INT 1
104152: ARRAY
104153: PPUSH
104154: CALL_OW 255
104158: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
104159: LD_ADDR_VAR 0 10
104163: PUSH
104164: LD_INT 29
104166: PUSH
104167: LD_INT 91
104169: PUSH
104170: LD_INT 49
104172: PUSH
104173: EMPTY
104174: LIST
104175: LIST
104176: LIST
104177: ST_TO_ADDR
// if not result then
104178: LD_VAR 0 3
104182: NOT
104183: IFFALSE 104187
// exit ;
104185: GO 104643
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
104187: LD_ADDR_VAR 0 5
104191: PUSH
104192: LD_INT 81
104194: PUSH
104195: LD_VAR 0 8
104199: PUSH
104200: EMPTY
104201: LIST
104202: LIST
104203: PPUSH
104204: CALL_OW 69
104208: ST_TO_ADDR
// for i in result do
104209: LD_ADDR_VAR 0 4
104213: PUSH
104214: LD_VAR 0 3
104218: PUSH
104219: FOR_IN
104220: IFFALSE 104641
// begin tag := GetTag ( i ) + 1 ;
104222: LD_ADDR_VAR 0 9
104226: PUSH
104227: LD_VAR 0 4
104231: PPUSH
104232: CALL_OW 110
104236: PUSH
104237: LD_INT 1
104239: PLUS
104240: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
104241: LD_ADDR_VAR 0 7
104245: PUSH
104246: LD_VAR 0 4
104250: PPUSH
104251: CALL_OW 250
104255: PPUSH
104256: LD_VAR 0 4
104260: PPUSH
104261: CALL_OW 251
104265: PPUSH
104266: LD_INT 6
104268: PPUSH
104269: CALL 103842 0 3
104273: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
104274: LD_VAR 0 4
104278: PPUSH
104279: CALL_OW 247
104283: PUSH
104284: LD_INT 2
104286: EQUAL
104287: PUSH
104288: LD_VAR 0 7
104292: AND
104293: PUSH
104294: LD_VAR 0 4
104298: PPUSH
104299: CALL_OW 264
104303: PUSH
104304: LD_VAR 0 10
104308: IN
104309: NOT
104310: AND
104311: IFFALSE 104350
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
104313: LD_VAR 0 4
104317: PPUSH
104318: LD_VAR 0 7
104322: PUSH
104323: LD_INT 1
104325: ARRAY
104326: PUSH
104327: LD_INT 1
104329: ARRAY
104330: PPUSH
104331: LD_VAR 0 7
104335: PUSH
104336: LD_INT 1
104338: ARRAY
104339: PUSH
104340: LD_INT 2
104342: ARRAY
104343: PPUSH
104344: CALL_OW 116
104348: GO 104639
// if path > tag then
104350: LD_VAR 0 2
104354: PUSH
104355: LD_VAR 0 9
104359: GREATER
104360: IFFALSE 104568
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
104362: LD_ADDR_VAR 0 6
104366: PUSH
104367: LD_VAR 0 5
104371: PPUSH
104372: LD_INT 91
104374: PUSH
104375: LD_VAR 0 4
104379: PUSH
104380: LD_INT 8
104382: PUSH
104383: EMPTY
104384: LIST
104385: LIST
104386: LIST
104387: PPUSH
104388: CALL_OW 72
104392: ST_TO_ADDR
// if nearEnemy then
104393: LD_VAR 0 6
104397: IFFALSE 104466
// begin if GetWeapon ( i ) = ru_time_lapser then
104399: LD_VAR 0 4
104403: PPUSH
104404: CALL_OW 264
104408: PUSH
104409: LD_INT 49
104411: EQUAL
104412: IFFALSE 104440
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
104414: LD_VAR 0 4
104418: PPUSH
104419: LD_VAR 0 6
104423: PPUSH
104424: LD_VAR 0 4
104428: PPUSH
104429: CALL_OW 74
104433: PPUSH
104434: CALL_OW 112
104438: GO 104464
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
104440: LD_VAR 0 4
104444: PPUSH
104445: LD_VAR 0 6
104449: PPUSH
104450: LD_VAR 0 4
104454: PPUSH
104455: CALL_OW 74
104459: PPUSH
104460: CALL 105568 0 2
// end else
104464: GO 104566
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
104466: LD_VAR 0 4
104470: PPUSH
104471: LD_VAR 0 2
104475: PUSH
104476: LD_VAR 0 9
104480: ARRAY
104481: PUSH
104482: LD_INT 1
104484: ARRAY
104485: PPUSH
104486: LD_VAR 0 2
104490: PUSH
104491: LD_VAR 0 9
104495: ARRAY
104496: PUSH
104497: LD_INT 2
104499: ARRAY
104500: PPUSH
104501: CALL_OW 297
104505: PUSH
104506: LD_INT 6
104508: GREATER
104509: IFFALSE 104552
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
104511: LD_VAR 0 4
104515: PPUSH
104516: LD_VAR 0 2
104520: PUSH
104521: LD_VAR 0 9
104525: ARRAY
104526: PUSH
104527: LD_INT 1
104529: ARRAY
104530: PPUSH
104531: LD_VAR 0 2
104535: PUSH
104536: LD_VAR 0 9
104540: ARRAY
104541: PUSH
104542: LD_INT 2
104544: ARRAY
104545: PPUSH
104546: CALL_OW 114
104550: GO 104566
// SetTag ( i , tag ) ;
104552: LD_VAR 0 4
104556: PPUSH
104557: LD_VAR 0 9
104561: PPUSH
104562: CALL_OW 109
// end else
104566: GO 104639
// if enemy then
104568: LD_VAR 0 5
104572: IFFALSE 104639
// begin if GetWeapon ( i ) = ru_time_lapser then
104574: LD_VAR 0 4
104578: PPUSH
104579: CALL_OW 264
104583: PUSH
104584: LD_INT 49
104586: EQUAL
104587: IFFALSE 104615
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
104589: LD_VAR 0 4
104593: PPUSH
104594: LD_VAR 0 5
104598: PPUSH
104599: LD_VAR 0 4
104603: PPUSH
104604: CALL_OW 74
104608: PPUSH
104609: CALL_OW 112
104613: GO 104639
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
104615: LD_VAR 0 4
104619: PPUSH
104620: LD_VAR 0 5
104624: PPUSH
104625: LD_VAR 0 4
104629: PPUSH
104630: CALL_OW 74
104634: PPUSH
104635: CALL 105568 0 2
// end ; end ;
104639: GO 104219
104641: POP
104642: POP
// end ;
104643: LD_VAR 0 3
104647: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
104648: LD_INT 0
104650: PPUSH
104651: PPUSH
104652: PPUSH
// if not unit or IsInUnit ( unit ) then
104653: LD_VAR 0 1
104657: NOT
104658: PUSH
104659: LD_VAR 0 1
104663: PPUSH
104664: CALL_OW 310
104668: OR
104669: IFFALSE 104673
// exit ;
104671: GO 104764
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
104673: LD_ADDR_VAR 0 4
104677: PUSH
104678: LD_VAR 0 1
104682: PPUSH
104683: CALL_OW 250
104687: PPUSH
104688: LD_VAR 0 2
104692: PPUSH
104693: LD_INT 1
104695: PPUSH
104696: CALL_OW 272
104700: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
104701: LD_ADDR_VAR 0 5
104705: PUSH
104706: LD_VAR 0 1
104710: PPUSH
104711: CALL_OW 251
104715: PPUSH
104716: LD_VAR 0 2
104720: PPUSH
104721: LD_INT 1
104723: PPUSH
104724: CALL_OW 273
104728: ST_TO_ADDR
// if ValidHex ( x , y ) then
104729: LD_VAR 0 4
104733: PPUSH
104734: LD_VAR 0 5
104738: PPUSH
104739: CALL_OW 488
104743: IFFALSE 104764
// ComTurnXY ( unit , x , y ) ;
104745: LD_VAR 0 1
104749: PPUSH
104750: LD_VAR 0 4
104754: PPUSH
104755: LD_VAR 0 5
104759: PPUSH
104760: CALL_OW 118
// end ;
104764: LD_VAR 0 3
104768: RET
// export function SeeUnits ( side , units ) ; var i ; begin
104769: LD_INT 0
104771: PPUSH
104772: PPUSH
// result := false ;
104773: LD_ADDR_VAR 0 3
104777: PUSH
104778: LD_INT 0
104780: ST_TO_ADDR
// if not units then
104781: LD_VAR 0 2
104785: NOT
104786: IFFALSE 104790
// exit ;
104788: GO 104835
// for i in units do
104790: LD_ADDR_VAR 0 4
104794: PUSH
104795: LD_VAR 0 2
104799: PUSH
104800: FOR_IN
104801: IFFALSE 104833
// if See ( side , i ) then
104803: LD_VAR 0 1
104807: PPUSH
104808: LD_VAR 0 4
104812: PPUSH
104813: CALL_OW 292
104817: IFFALSE 104831
// begin result := true ;
104819: LD_ADDR_VAR 0 3
104823: PUSH
104824: LD_INT 1
104826: ST_TO_ADDR
// exit ;
104827: POP
104828: POP
104829: GO 104835
// end ;
104831: GO 104800
104833: POP
104834: POP
// end ;
104835: LD_VAR 0 3
104839: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
104840: LD_INT 0
104842: PPUSH
104843: PPUSH
104844: PPUSH
104845: PPUSH
// if not unit or not points then
104846: LD_VAR 0 1
104850: NOT
104851: PUSH
104852: LD_VAR 0 2
104856: NOT
104857: OR
104858: IFFALSE 104862
// exit ;
104860: GO 104952
// dist := 99999 ;
104862: LD_ADDR_VAR 0 5
104866: PUSH
104867: LD_INT 99999
104869: ST_TO_ADDR
// for i in points do
104870: LD_ADDR_VAR 0 4
104874: PUSH
104875: LD_VAR 0 2
104879: PUSH
104880: FOR_IN
104881: IFFALSE 104950
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
104883: LD_ADDR_VAR 0 6
104887: PUSH
104888: LD_VAR 0 1
104892: PPUSH
104893: LD_VAR 0 4
104897: PUSH
104898: LD_INT 1
104900: ARRAY
104901: PPUSH
104902: LD_VAR 0 4
104906: PUSH
104907: LD_INT 2
104909: ARRAY
104910: PPUSH
104911: CALL_OW 297
104915: ST_TO_ADDR
// if tmpDist < dist then
104916: LD_VAR 0 6
104920: PUSH
104921: LD_VAR 0 5
104925: LESS
104926: IFFALSE 104948
// begin result := i ;
104928: LD_ADDR_VAR 0 3
104932: PUSH
104933: LD_VAR 0 4
104937: ST_TO_ADDR
// dist := tmpDist ;
104938: LD_ADDR_VAR 0 5
104942: PUSH
104943: LD_VAR 0 6
104947: ST_TO_ADDR
// end ; end ;
104948: GO 104880
104950: POP
104951: POP
// end ;
104952: LD_VAR 0 3
104956: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104957: LD_INT 0
104959: PPUSH
// uc_side := side ;
104960: LD_ADDR_OWVAR 20
104964: PUSH
104965: LD_VAR 0 1
104969: ST_TO_ADDR
// uc_nation := 3 ;
104970: LD_ADDR_OWVAR 21
104974: PUSH
104975: LD_INT 3
104977: ST_TO_ADDR
// vc_chassis := 25 ;
104978: LD_ADDR_OWVAR 37
104982: PUSH
104983: LD_INT 25
104985: ST_TO_ADDR
// vc_engine := engine_siberite ;
104986: LD_ADDR_OWVAR 39
104990: PUSH
104991: LD_INT 3
104993: ST_TO_ADDR
// vc_control := control_computer ;
104994: LD_ADDR_OWVAR 38
104998: PUSH
104999: LD_INT 3
105001: ST_TO_ADDR
// vc_weapon := 59 ;
105002: LD_ADDR_OWVAR 40
105006: PUSH
105007: LD_INT 59
105009: ST_TO_ADDR
// result := CreateVehicle ;
105010: LD_ADDR_VAR 0 5
105014: PUSH
105015: CALL_OW 45
105019: ST_TO_ADDR
// SetDir ( result , d ) ;
105020: LD_VAR 0 5
105024: PPUSH
105025: LD_VAR 0 4
105029: PPUSH
105030: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
105034: LD_VAR 0 5
105038: PPUSH
105039: LD_VAR 0 2
105043: PPUSH
105044: LD_VAR 0 3
105048: PPUSH
105049: LD_INT 0
105051: PPUSH
105052: CALL_OW 48
// end ;
105056: LD_VAR 0 5
105060: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
105061: LD_INT 0
105063: PPUSH
105064: PPUSH
105065: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
105066: LD_ADDR_VAR 0 2
105070: PUSH
105071: LD_INT 0
105073: PUSH
105074: LD_INT 0
105076: PUSH
105077: LD_INT 0
105079: PUSH
105080: LD_INT 0
105082: PUSH
105083: EMPTY
105084: LIST
105085: LIST
105086: LIST
105087: LIST
105088: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
105089: LD_VAR 0 1
105093: NOT
105094: PUSH
105095: LD_VAR 0 1
105099: PPUSH
105100: CALL_OW 264
105104: PUSH
105105: LD_INT 12
105107: PUSH
105108: LD_INT 51
105110: PUSH
105111: LD_INT 32
105113: PUSH
105114: LD_INT 89
105116: PUSH
105117: EMPTY
105118: LIST
105119: LIST
105120: LIST
105121: LIST
105122: IN
105123: NOT
105124: OR
105125: IFFALSE 105129
// exit ;
105127: GO 105227
// for i := 1 to 3 do
105129: LD_ADDR_VAR 0 3
105133: PUSH
105134: DOUBLE
105135: LD_INT 1
105137: DEC
105138: ST_TO_ADDR
105139: LD_INT 3
105141: PUSH
105142: FOR_TO
105143: IFFALSE 105225
// begin tmp := GetCargo ( cargo , i ) ;
105145: LD_ADDR_VAR 0 4
105149: PUSH
105150: LD_VAR 0 1
105154: PPUSH
105155: LD_VAR 0 3
105159: PPUSH
105160: CALL_OW 289
105164: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
105165: LD_ADDR_VAR 0 2
105169: PUSH
105170: LD_VAR 0 2
105174: PPUSH
105175: LD_VAR 0 3
105179: PPUSH
105180: LD_VAR 0 4
105184: PPUSH
105185: CALL_OW 1
105189: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
105190: LD_ADDR_VAR 0 2
105194: PUSH
105195: LD_VAR 0 2
105199: PPUSH
105200: LD_INT 4
105202: PPUSH
105203: LD_VAR 0 2
105207: PUSH
105208: LD_INT 4
105210: ARRAY
105211: PUSH
105212: LD_VAR 0 4
105216: PLUS
105217: PPUSH
105218: CALL_OW 1
105222: ST_TO_ADDR
// end ;
105223: GO 105142
105225: POP
105226: POP
// end ;
105227: LD_VAR 0 2
105231: RET
// export function Length ( array ) ; begin
105232: LD_INT 0
105234: PPUSH
// result := array + 0 ;
105235: LD_ADDR_VAR 0 2
105239: PUSH
105240: LD_VAR 0 1
105244: PUSH
105245: LD_INT 0
105247: PLUS
105248: ST_TO_ADDR
// end ;
105249: LD_VAR 0 2
105253: RET
// export function PrepareArray ( array ) ; begin
105254: LD_INT 0
105256: PPUSH
// result := array diff 0 ;
105257: LD_ADDR_VAR 0 2
105261: PUSH
105262: LD_VAR 0 1
105266: PUSH
105267: LD_INT 0
105269: DIFF
105270: ST_TO_ADDR
// if not result [ 1 ] then
105271: LD_VAR 0 2
105275: PUSH
105276: LD_INT 1
105278: ARRAY
105279: NOT
105280: IFFALSE 105300
// result := Delete ( result , 1 ) ;
105282: LD_ADDR_VAR 0 2
105286: PUSH
105287: LD_VAR 0 2
105291: PPUSH
105292: LD_INT 1
105294: PPUSH
105295: CALL_OW 3
105299: ST_TO_ADDR
// end ;
105300: LD_VAR 0 2
105304: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
105305: LD_INT 0
105307: PPUSH
105308: PPUSH
105309: PPUSH
105310: PPUSH
// sibRocketRange := 25 ;
105311: LD_ADDR_VAR 0 6
105315: PUSH
105316: LD_INT 25
105318: ST_TO_ADDR
// result := false ;
105319: LD_ADDR_VAR 0 4
105323: PUSH
105324: LD_INT 0
105326: ST_TO_ADDR
// for i := 0 to 5 do
105327: LD_ADDR_VAR 0 5
105331: PUSH
105332: DOUBLE
105333: LD_INT 0
105335: DEC
105336: ST_TO_ADDR
105337: LD_INT 5
105339: PUSH
105340: FOR_TO
105341: IFFALSE 105408
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
105343: LD_VAR 0 1
105347: PPUSH
105348: LD_VAR 0 5
105352: PPUSH
105353: LD_VAR 0 6
105357: PPUSH
105358: CALL_OW 272
105362: PPUSH
105363: LD_VAR 0 2
105367: PPUSH
105368: LD_VAR 0 5
105372: PPUSH
105373: LD_VAR 0 6
105377: PPUSH
105378: CALL_OW 273
105382: PPUSH
105383: LD_VAR 0 3
105387: PPUSH
105388: CALL_OW 309
105392: IFFALSE 105406
// begin result := true ;
105394: LD_ADDR_VAR 0 4
105398: PUSH
105399: LD_INT 1
105401: ST_TO_ADDR
// exit ;
105402: POP
105403: POP
105404: GO 105410
// end ;
105406: GO 105340
105408: POP
105409: POP
// end ;
105410: LD_VAR 0 4
105414: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
105415: LD_INT 0
105417: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
105418: LD_VAR 0 1
105422: PPUSH
105423: LD_VAR 0 2
105427: PPUSH
105428: LD_INT 0
105430: PPUSH
105431: LD_INT 0
105433: PPUSH
105434: LD_INT 1
105436: PPUSH
105437: LD_INT 0
105439: PPUSH
105440: CALL_OW 587
// end ;
105444: LD_VAR 0 3
105448: RET
// export function CenterOnNow ( unit ) ; begin
105449: LD_INT 0
105451: PPUSH
// result := IsInUnit ( unit ) ;
105452: LD_ADDR_VAR 0 2
105456: PUSH
105457: LD_VAR 0 1
105461: PPUSH
105462: CALL_OW 310
105466: ST_TO_ADDR
// if not result then
105467: LD_VAR 0 2
105471: NOT
105472: IFFALSE 105484
// result := unit ;
105474: LD_ADDR_VAR 0 2
105478: PUSH
105479: LD_VAR 0 1
105483: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
105484: LD_VAR 0 1
105488: PPUSH
105489: CALL_OW 87
// end ;
105493: LD_VAR 0 2
105497: RET
// export function ComMoveHex ( unit , hex ) ; begin
105498: LD_INT 0
105500: PPUSH
// if not hex then
105501: LD_VAR 0 2
105505: NOT
105506: IFFALSE 105510
// exit ;
105508: GO 105563
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
105510: LD_VAR 0 2
105514: PUSH
105515: LD_INT 1
105517: ARRAY
105518: PPUSH
105519: LD_VAR 0 2
105523: PUSH
105524: LD_INT 2
105526: ARRAY
105527: PPUSH
105528: CALL_OW 428
105532: IFFALSE 105536
// exit ;
105534: GO 105563
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
105536: LD_VAR 0 1
105540: PPUSH
105541: LD_VAR 0 2
105545: PUSH
105546: LD_INT 1
105548: ARRAY
105549: PPUSH
105550: LD_VAR 0 2
105554: PUSH
105555: LD_INT 2
105557: ARRAY
105558: PPUSH
105559: CALL_OW 111
// end ;
105563: LD_VAR 0 3
105567: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
105568: LD_INT 0
105570: PPUSH
105571: PPUSH
105572: PPUSH
// if not unit or not enemy then
105573: LD_VAR 0 1
105577: NOT
105578: PUSH
105579: LD_VAR 0 2
105583: NOT
105584: OR
105585: IFFALSE 105589
// exit ;
105587: GO 105713
// x := GetX ( enemy ) ;
105589: LD_ADDR_VAR 0 4
105593: PUSH
105594: LD_VAR 0 2
105598: PPUSH
105599: CALL_OW 250
105603: ST_TO_ADDR
// y := GetY ( enemy ) ;
105604: LD_ADDR_VAR 0 5
105608: PUSH
105609: LD_VAR 0 2
105613: PPUSH
105614: CALL_OW 251
105618: ST_TO_ADDR
// if ValidHex ( x , y ) then
105619: LD_VAR 0 4
105623: PPUSH
105624: LD_VAR 0 5
105628: PPUSH
105629: CALL_OW 488
105633: IFFALSE 105713
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
105635: LD_VAR 0 2
105639: PPUSH
105640: CALL_OW 247
105644: PUSH
105645: LD_INT 3
105647: PUSH
105648: LD_INT 2
105650: PUSH
105651: EMPTY
105652: LIST
105653: LIST
105654: IN
105655: PUSH
105656: LD_VAR 0 1
105660: PPUSH
105661: CALL_OW 255
105665: PPUSH
105666: LD_VAR 0 2
105670: PPUSH
105671: CALL_OW 292
105675: AND
105676: IFFALSE 105694
// ComAttackUnit ( unit , enemy ) else
105678: LD_VAR 0 1
105682: PPUSH
105683: LD_VAR 0 2
105687: PPUSH
105688: CALL_OW 115
105692: GO 105713
// ComAgressiveMove ( unit , x , y ) ;
105694: LD_VAR 0 1
105698: PPUSH
105699: LD_VAR 0 4
105703: PPUSH
105704: LD_VAR 0 5
105708: PPUSH
105709: CALL_OW 114
// end ; end_of_file
105713: LD_VAR 0 3
105717: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
105718: LD_VAR 0 1
105722: PUSH
105723: LD_INT 200
105725: DOUBLE
105726: GREATEREQUAL
105727: IFFALSE 105735
105729: LD_INT 299
105731: DOUBLE
105732: LESSEQUAL
105733: IFTRUE 105737
105735: GO 105769
105737: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
105738: LD_VAR 0 1
105742: PPUSH
105743: LD_VAR 0 2
105747: PPUSH
105748: LD_VAR 0 3
105752: PPUSH
105753: LD_VAR 0 4
105757: PPUSH
105758: LD_VAR 0 5
105762: PPUSH
105763: CALL 59442 0 5
105767: GO 105846
105769: LD_INT 300
105771: DOUBLE
105772: GREATEREQUAL
105773: IFFALSE 105781
105775: LD_INT 399
105777: DOUBLE
105778: LESSEQUAL
105779: IFTRUE 105783
105781: GO 105845
105783: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
105784: LD_VAR 0 1
105788: PPUSH
105789: LD_VAR 0 2
105793: PPUSH
105794: LD_VAR 0 3
105798: PPUSH
105799: LD_VAR 0 4
105803: PPUSH
105804: LD_VAR 0 5
105808: PPUSH
105809: LD_VAR 0 6
105813: PPUSH
105814: LD_VAR 0 7
105818: PPUSH
105819: LD_VAR 0 8
105823: PPUSH
105824: LD_VAR 0 9
105828: PPUSH
105829: LD_VAR 0 10
105833: PPUSH
105834: LD_VAR 0 11
105838: PPUSH
105839: CALL 55767 0 11
105843: GO 105846
105845: POP
// end ;
105846: PPOPN 11
105848: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
105849: LD_VAR 0 1
105853: PPUSH
105854: LD_VAR 0 2
105858: PPUSH
105859: LD_VAR 0 3
105863: PPUSH
105864: LD_VAR 0 4
105868: PPUSH
105869: LD_VAR 0 5
105873: PPUSH
105874: CALL 59178 0 5
// end ; end_of_file
105878: PPOPN 5
105880: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
105881: LD_VAR 0 1
105885: PPUSH
105886: LD_VAR 0 2
105890: PPUSH
105891: LD_VAR 0 3
105895: PPUSH
105896: LD_VAR 0 4
105900: PPUSH
105901: LD_VAR 0 5
105905: PPUSH
105906: LD_VAR 0 6
105910: PPUSH
105911: CALL 43419 0 6
// end ;
105915: PPOPN 6
105917: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
105918: LD_INT 0
105920: PPUSH
// begin if not units then
105921: LD_VAR 0 1
105925: NOT
105926: IFFALSE 105930
// exit ;
105928: GO 105930
// end ;
105930: PPOPN 7
105932: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
105933: CALL 43323 0 0
// end ;
105937: PPOPN 1
105939: END
