// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7606 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4583 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4882 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 42094 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42545 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21337 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21273 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18266 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21173 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22187 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21414 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21207 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21240 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18045 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22095 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20352 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20927 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20927 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20724 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20388 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20564 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19848 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20462 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20963 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21703 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21273 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18266 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21173 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21414 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21207 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21240 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18045 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22095 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20352 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20927 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20927 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20724 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20388 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20564 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19848 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20462 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20963 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21703 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19848 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11553 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21921 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11553 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21921 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11553 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21921 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11553 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21921 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7825 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7825 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7825 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7825 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7825 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4443
// tmp := CharacterSelection ( text , 12 , 12 , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 12
4392: PPUSH
4393: LD_INT -2
4395: PUSH
4396: LD_INT -5
4398: PUSH
4399: LD_INT -3
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PUSH
4407: LD_VAR 0 6
4411: ADD
4412: PPUSH
4413: LD_INT 1
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 3
4428: PUSH
4429: LD_INT 4
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: PPUSH
4438: CALL_OW 42
4442: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4443: LD_EXP 25
4447: PPUSH
4448: LD_INT 9
4450: PPUSH
4451: LD_INT 0
4453: PPUSH
4454: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4458: LD_VAR 0 5
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PPUSH
4467: LD_INT 2
4469: PPUSH
4470: CALL_OW 336
// for i = 1 to tmp do
4474: LD_ADDR_VAR 0 3
4478: PUSH
4479: DOUBLE
4480: LD_INT 1
4482: DEC
4483: ST_TO_ADDR
4484: LD_VAR 0 5
4488: PUSH
4489: FOR_TO
4490: IFFALSE 4545
// if i < 4 then
4492: LD_VAR 0 3
4496: PUSH
4497: LD_INT 4
4499: LESS
4500: IFFALSE 4525
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4502: LD_VAR 0 5
4506: PUSH
4507: LD_VAR 0 3
4511: ARRAY
4512: PPUSH
4513: LD_INT 9
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 49
4523: GO 4543
// SetSide ( tmp [ i ] , 6 ) ;
4525: LD_VAR 0 5
4529: PUSH
4530: LD_VAR 0 3
4534: ARRAY
4535: PPUSH
4536: LD_INT 6
4538: PPUSH
4539: CALL_OW 235
4543: GO 4489
4545: POP
4546: POP
// player_squad := tmp ;
4547: LD_ADDR_EXP 23
4551: PUSH
4552: LD_VAR 0 5
4556: ST_TO_ADDR
// pl_counter := 4 ;
4557: LD_ADDR_EXP 24
4561: PUSH
4562: LD_INT 4
4564: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4565: LD_INT 17
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: LD_INT 1
4573: PPUSH
4574: CALL 18266 0 3
// end ;
4578: LD_VAR 0 2
4582: RET
// export Popov ; export function InitAction ; var commander ; begin
4583: LD_INT 0
4585: PPUSH
4586: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4587: LD_INT 6
4589: PPUSH
4590: LD_INT 3
4592: PPUSH
4593: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4597: LD_INT 1
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: CALL_OW 86
// uc_side := 6 ;
4607: LD_ADDR_OWVAR 20
4611: PUSH
4612: LD_INT 6
4614: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4615: LD_ADDR_EXP 26
4619: PUSH
4620: LD_STRING Popov
4622: PPUSH
4623: CALL_OW 25
4627: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4628: LD_ADDR_OWVAR 67
4632: PUSH
4633: LD_INT 0
4635: PPUSH
4636: CALL_OW 426
4640: ST_TO_ADDR
// if not Difficulty then
4641: LD_OWVAR 67
4645: NOT
4646: IFFALSE 4656
// Difficulty := 2 ;
4648: LD_ADDR_OWVAR 67
4652: PUSH
4653: LD_INT 2
4655: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: LD_INT 1
4663: PPUSH
4664: CALL_OW 426
4668: ST_TO_ADDR
// if not commander then
4669: LD_VAR 0 2
4673: NOT
4674: IFFALSE 4684
// commander := 1 ;
4676: LD_ADDR_VAR 0 2
4680: PUSH
4681: LD_INT 1
4683: ST_TO_ADDR
// InitCommanders ( commander ) ;
4684: LD_VAR 0 2
4688: PPUSH
4689: CALL 3137 0 1
// end ;
4693: LD_VAR 0 1
4697: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4698: LD_EXP 24
4702: PUSH
4703: LD_INT 12
4705: LESS
4706: IFFALSE 4879
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
// begin enable ;
4714: ENABLE
// for i = pl_counter to pl_counter + 2 do
4715: LD_ADDR_VAR 0 1
4719: PUSH
4720: DOUBLE
4721: LD_EXP 24
4725: DEC
4726: ST_TO_ADDR
4727: LD_EXP 24
4731: PUSH
4732: LD_INT 2
4734: PLUS
4735: PUSH
4736: FOR_TO
4737: IFFALSE 4783
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4739: LD_EXP 23
4743: PUSH
4744: LD_VAR 0 1
4748: ARRAY
4749: PPUSH
4750: LD_INT 18
4752: PPUSH
4753: LD_INT 0
4755: PPUSH
4756: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4760: LD_EXP 23
4764: PUSH
4765: LD_VAR 0 1
4769: ARRAY
4770: PPUSH
4771: LD_INT 107
4773: PPUSH
4774: LD_INT 88
4776: PPUSH
4777: CALL_OW 111
// end ;
4781: GO 4736
4783: POP
4784: POP
// for i = pl_counter to pl_counter + 2 do
4785: LD_ADDR_VAR 0 1
4789: PUSH
4790: DOUBLE
4791: LD_EXP 24
4795: DEC
4796: ST_TO_ADDR
4797: LD_EXP 24
4801: PUSH
4802: LD_INT 2
4804: PLUS
4805: PUSH
4806: FOR_TO
4807: IFFALSE 4863
// begin repeat wait ( 0 0$01 ) ;
4809: LD_INT 35
4811: PPUSH
4812: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4816: LD_EXP 23
4820: PUSH
4821: LD_VAR 0 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 107
4829: PPUSH
4830: LD_INT 88
4832: PPUSH
4833: CALL_OW 297
4837: PUSH
4838: LD_INT 6
4840: LESS
4841: IFFALSE 4809
// SetSide ( player_squad [ i ] , 3 ) ;
4843: LD_EXP 23
4847: PUSH
4848: LD_VAR 0 1
4852: ARRAY
4853: PPUSH
4854: LD_INT 3
4856: PPUSH
4857: CALL_OW 235
// end ;
4861: GO 4806
4863: POP
4864: POP
// pl_counter := pl_counter + 3 ;
4865: LD_ADDR_EXP 24
4869: PUSH
4870: LD_EXP 24
4874: PUSH
4875: LD_INT 3
4877: PLUS
4878: ST_TO_ADDR
// end ;
4879: PPOPN 1
4881: END
// export function Dialog ; begin
4882: LD_INT 0
4884: PPUSH
// if not isTest then
4885: LD_EXP 1
4889: NOT
4890: IFFALSE 4912
// case query ( task ) of 1 :
4892: LD_STRING task
4894: PPUSH
4895: CALL_OW 97
4899: PUSH
4900: LD_INT 1
4902: DOUBLE
4903: EQUAL
4904: IFTRUE 4908
4906: GO 4911
4908: POP
// ; end ;
4909: GO 4912
4911: POP
// InGameOn ;
4912: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4916: LD_INT 107
4918: PPUSH
4919: LD_INT 84
4921: PPUSH
4922: CALL_OW 86
// if isTest then
4926: LD_EXP 1
4930: IFFALSE 4940
// dialogue_skipped := true ;
4932: LD_ADDR_OWVAR 59
4936: PUSH
4937: LD_INT 1
4939: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4940: LD_ADDR_EXP 11
4944: PUSH
4945: LD_EXP 23
4949: PUSH
4950: LD_INT 1
4952: ARRAY
4953: PPUSH
4954: LD_INT 0
4956: PPUSH
4957: LD_INT 96
4959: PPUSH
4960: LD_INT 79
4962: PPUSH
4963: LD_INT 2
4965: PPUSH
4966: CALL_OW 145
4970: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4971: LD_INT 35
4973: PPUSH
4974: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
4978: LD_EXP 26
4982: PPUSH
4983: LD_STRING DR1
4985: PPUSH
4986: CALL_OW 94
// Wait ( 0 0$01 ) ;
4990: LD_INT 35
4992: PPUSH
4993: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
4997: LD_EXP 26
5001: PPUSH
5002: LD_STRING DR2
5004: PPUSH
5005: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5009: LD_EXP 26
5013: PPUSH
5014: LD_STRING DR3
5016: PPUSH
5017: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5021: LD_INT 35
5023: PPUSH
5024: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5028: LD_INT 3
5030: PPUSH
5031: LD_INT 30
5033: PUSH
5034: LD_INT 0
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PPUSH
5041: CALL 11553 0 2
5045: PUSH
5046: LD_EXP 1
5050: OR
5051: IFFALSE 5021
// InGameOff ;
5053: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5057: LD_STRING C1
5059: PPUSH
5060: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5064: LD_INT 35
5066: PPUSH
5067: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5071: LD_EXP 11
5075: PPUSH
5076: CALL_OW 461
5080: PUSH
5081: LD_INT 2
5083: EQUAL
5084: IFFALSE 5064
// if not isTest then
5086: LD_EXP 1
5090: NOT
5091: IFFALSE 5113
// case query ( support ) of 1 :
5093: LD_STRING support
5095: PPUSH
5096: CALL_OW 97
5100: PUSH
5101: LD_INT 1
5103: DOUBLE
5104: EQUAL
5105: IFTRUE 5109
5107: GO 5112
5109: POP
// ; end ;
5110: GO 5113
5112: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5113: LD_INT 3
5115: PPUSH
5116: LD_INT 12
5118: PPUSH
5119: LD_INT 2
5121: PPUSH
5122: LD_INT 22
5124: PUSH
5125: LD_INT 3
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 30
5134: PUSH
5135: LD_INT 0
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: PUSH
5151: LD_INT 1
5153: ARRAY
5154: PPUSH
5155: CALL_OW 468
// if player_com = stolypin then
5159: LD_EXP 25
5163: PUSH
5164: LD_EXP 22
5168: EQUAL
5169: IFFALSE 5198
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5171: LD_INT 18
5173: PPUSH
5174: LD_INT 3
5176: PUSH
5177: LD_INT 3
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: PUSH
5188: LD_OWVAR 67
5192: ARRAY
5193: PPUSH
5194: CALL 6622 0 2
// end ;
5198: LD_VAR 0 1
5202: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5203: LD_EXP 12
5207: PUSH
5208: LD_OWVAR 1
5212: PUSH
5213: LD_INT 31500
5215: LESS
5216: AND
5217: IFFALSE 5389
// case query ( call1 ) of 1 :
5219: LD_STRING call1
5221: PPUSH
5222: CALL_OW 97
5226: PUSH
5227: LD_INT 1
5229: DOUBLE
5230: EQUAL
5231: IFTRUE 5235
5233: GO 5377
5235: POP
// begin callUsed := true ;
5236: LD_ADDR_EXP 3
5240: PUSH
5241: LD_INT 1
5243: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5244: LD_INT 3
5246: PPUSH
5247: LD_INT 12
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: LD_EXP 11
5257: PPUSH
5258: CALL_OW 468
// call := false ;
5262: LD_ADDR_EXP 12
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5270: LD_EXP 26
5274: PPUSH
5275: LD_STRING DR6
5277: PPUSH
5278: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5282: LD_INT 6300
5284: PPUSH
5285: LD_INT 8400
5287: PPUSH
5288: CALL_OW 12
5292: PPUSH
5293: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5297: LD_INT 18
5299: PUSH
5300: LD_INT 19
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: PUSH
5307: LD_INT 1
5309: PPUSH
5310: LD_INT 2
5312: PPUSH
5313: CALL_OW 12
5317: ARRAY
5318: PPUSH
5319: LD_INT 1
5321: PPUSH
5322: LD_INT 2
5324: PPUSH
5325: CALL_OW 12
5329: PPUSH
5330: CALL 6622 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5334: LD_INT 25200
5336: PPUSH
5337: LD_INT 35700
5339: PPUSH
5340: CALL_OW 12
5344: PPUSH
5345: CALL_OW 67
// call := true ;
5349: LD_ADDR_EXP 12
5353: PUSH
5354: LD_INT 1
5356: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5357: LD_INT 3
5359: PPUSH
5360: LD_INT 12
5362: PPUSH
5363: LD_INT 2
5365: PPUSH
5366: LD_EXP 11
5370: PPUSH
5371: CALL_OW 468
// end ; 2 :
5375: GO 5389
5377: LD_INT 2
5379: DOUBLE
5380: EQUAL
5381: IFTRUE 5385
5383: GO 5388
5385: POP
// ; end ;
5386: GO 5389
5388: POP
// if call and tick >= 15 15$00 then
5389: LD_EXP 12
5393: PUSH
5394: LD_OWVAR 1
5398: PUSH
5399: LD_INT 31500
5401: GREATEREQUAL
5402: AND
5403: IFFALSE 5848
// case query ( call2 ) of 1 :
5405: LD_STRING call2
5407: PPUSH
5408: CALL_OW 97
5412: PUSH
5413: LD_INT 1
5415: DOUBLE
5416: EQUAL
5417: IFTRUE 5421
5419: GO 5665
5421: POP
// begin callUsed := true ;
5422: LD_ADDR_EXP 3
5426: PUSH
5427: LD_INT 1
5429: ST_TO_ADDR
// call := false ;
5430: LD_ADDR_EXP 12
5434: PUSH
5435: LD_INT 0
5437: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5438: LD_INT 1
5440: PPUSH
5441: LD_INT 21
5443: PUSH
5444: LD_INT 3
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: PPUSH
5451: CALL 11553 0 2
5455: PUSH
5456: LD_INT 4
5458: PPUSH
5459: LD_INT 21
5461: PUSH
5462: LD_INT 3
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PPUSH
5469: CALL 11553 0 2
5473: AND
5474: IFFALSE 5522
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5476: LD_INT 18
5478: PUSH
5479: LD_INT 19
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: LD_INT 1
5488: PPUSH
5489: LD_INT 2
5491: PPUSH
5492: CALL_OW 12
5496: ARRAY
5497: PPUSH
5498: LD_INT 5
5500: PUSH
5501: LD_INT 4
5503: PUSH
5504: LD_INT 4
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_OWVAR 67
5516: ARRAY
5517: PPUSH
5518: CALL 6383 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5522: LD_INT 1
5524: PPUSH
5525: LD_INT 21
5527: PUSH
5528: LD_INT 3
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL 11553 0 2
5539: PUSH
5540: LD_INT 0
5542: EQUAL
5543: IFFALSE 5572
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5545: LD_INT 19
5547: PPUSH
5548: LD_INT 5
5550: PUSH
5551: LD_INT 4
5553: PUSH
5554: LD_INT 3
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: LIST
5561: PUSH
5562: LD_OWVAR 67
5566: ARRAY
5567: PPUSH
5568: CALL 6383 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5572: LD_INT 4
5574: PPUSH
5575: LD_INT 21
5577: PUSH
5578: LD_INT 3
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PPUSH
5585: CALL 11553 0 2
5589: PUSH
5590: LD_INT 0
5592: EQUAL
5593: IFFALSE 5622
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5595: LD_INT 18
5597: PPUSH
5598: LD_INT 5
5600: PUSH
5601: LD_INT 4
5603: PUSH
5604: LD_INT 4
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_OWVAR 67
5616: ARRAY
5617: PPUSH
5618: CALL 6383 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5622: LD_INT 10500
5624: PPUSH
5625: LD_INT 23100
5627: PPUSH
5628: CALL_OW 12
5632: PPUSH
5633: CALL_OW 67
// call := true ;
5637: LD_ADDR_EXP 12
5641: PUSH
5642: LD_INT 1
5644: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5645: LD_INT 3
5647: PPUSH
5648: LD_INT 12
5650: PPUSH
5651: LD_INT 2
5653: PPUSH
5654: LD_EXP 11
5658: PPUSH
5659: CALL_OW 468
// end ; 2 :
5663: GO 5848
5665: LD_INT 2
5667: DOUBLE
5668: EQUAL
5669: IFTRUE 5673
5671: GO 5836
5673: POP
// begin callUsed := true ;
5674: LD_ADDR_EXP 3
5678: PUSH
5679: LD_INT 1
5681: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5682: LD_INT 3
5684: PPUSH
5685: LD_INT 12
5687: PPUSH
5688: LD_INT 1
5690: PPUSH
5691: LD_EXP 11
5695: PPUSH
5696: CALL_OW 468
// call := false ;
5700: LD_ADDR_EXP 12
5704: PUSH
5705: LD_INT 0
5707: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5708: LD_EXP 26
5712: PPUSH
5713: LD_STRING DR6
5715: PPUSH
5716: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5720: LD_INT 6300
5722: PPUSH
5723: LD_INT 8400
5725: PPUSH
5726: CALL_OW 12
5730: PPUSH
5731: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5735: LD_INT 18
5737: PUSH
5738: LD_INT 19
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: PUSH
5745: LD_INT 1
5747: PPUSH
5748: LD_INT 2
5750: PPUSH
5751: CALL_OW 12
5755: ARRAY
5756: PPUSH
5757: LD_INT 3
5759: PUSH
5760: LD_INT 2
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: LD_INT 0
5779: PPUSH
5780: LD_INT 1
5782: PPUSH
5783: CALL_OW 12
5787: MINUS
5788: PPUSH
5789: CALL 6622 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5793: LD_INT 35700
5795: PPUSH
5796: LD_INT 44100
5798: PPUSH
5799: CALL_OW 12
5803: PPUSH
5804: CALL_OW 67
// call := true ;
5808: LD_ADDR_EXP 12
5812: PUSH
5813: LD_INT 1
5815: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5816: LD_INT 3
5818: PPUSH
5819: LD_INT 12
5821: PPUSH
5822: LD_INT 2
5824: PPUSH
5825: LD_EXP 11
5829: PPUSH
5830: CALL_OW 468
// end ; 3 :
5834: GO 5848
5836: LD_INT 3
5838: DOUBLE
5839: EQUAL
5840: IFTRUE 5844
5842: GO 5847
5844: POP
// ; end ;
5845: GO 5848
5847: POP
// end ;
5848: PPOPN 4
5850: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5851: LD_INT 22
5853: PUSH
5854: LD_INT 1
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 21
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: PUSH
5871: EMPTY
5872: LIST
5873: LIST
5874: PPUSH
5875: CALL_OW 69
5879: PUSH
5880: LD_INT 0
5882: EQUAL
5883: PUSH
5884: LD_INT 22
5886: PUSH
5887: LD_INT 4
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: PUSH
5894: LD_INT 21
5896: PUSH
5897: LD_INT 1
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PPUSH
5908: CALL_OW 69
5912: PUSH
5913: LD_INT 0
5915: EQUAL
5916: AND
5917: IFFALSE 6221
5919: GO 5921
5921: DISABLE
// begin DialogueOn ;
5922: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5926: LD_EXP 26
5930: PPUSH
5931: LD_STRING DR7
5933: PPUSH
5934: CALL_OW 94
// case player_com of Gorki :
5938: LD_EXP 25
5942: PUSH
5943: LD_EXP 21
5947: DOUBLE
5948: EQUAL
5949: IFTRUE 5953
5951: GO 5963
5953: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5954: LD_STRING ACH_GORKI
5956: PPUSH
5957: CALL_OW 543
5961: GO 6024
5963: LD_EXP 22
5967: DOUBLE
5968: EQUAL
5969: IFTRUE 5973
5971: GO 5983
5973: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5974: LD_STRING ACH_STOLYP
5976: PPUSH
5977: CALL_OW 543
5981: GO 6024
5983: LD_EXP 20
5987: DOUBLE
5988: EQUAL
5989: IFTRUE 5993
5991: GO 6003
5993: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5994: LD_STRING ACH_DAVIDOV
5996: PPUSH
5997: CALL_OW 543
6001: GO 6024
6003: LD_EXP 19
6007: DOUBLE
6008: EQUAL
6009: IFTRUE 6013
6011: GO 6023
6013: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6014: LD_STRING ACH_GLADKOV
6016: PPUSH
6017: CALL_OW 543
6021: GO 6024
6023: POP
// if not callUsed then
6024: LD_EXP 3
6028: NOT
6029: IFFALSE 6038
// SetAchievement ( ACH_NOSUPP ) ;
6031: LD_STRING ACH_NOSUPP
6033: PPUSH
6034: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6038: LD_OWVAR 1
6042: PUSH
6043: LD_INT 116550
6045: PUSH
6046: LD_INT 95550
6048: PUSH
6049: LD_INT 89250
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: LIST
6056: PUSH
6057: LD_OWVAR 67
6061: ARRAY
6062: LESS
6063: IFFALSE 6077
// AddMedal ( med1 , 1 ) else
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: PPUSH
6071: CALL_OW 101
6075: GO 6088
// AddMedal ( med1 , - 1 ) ;
6077: LD_STRING med1
6079: PPUSH
6080: LD_INT 1
6082: NEG
6083: PPUSH
6084: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6088: LD_INT 81
6090: PUSH
6091: LD_INT 3
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PUSH
6098: LD_INT 21
6100: PUSH
6101: LD_INT 3
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: PUSH
6108: EMPTY
6109: LIST
6110: LIST
6111: PPUSH
6112: CALL_OW 69
6116: PUSH
6117: LD_INT 0
6119: EQUAL
6120: IFFALSE 6134
// AddMedal ( med3 , 1 ) else
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: PPUSH
6128: CALL_OW 101
6132: GO 6145
// AddMedal ( med3 , - 1 ) ;
6134: LD_STRING med3
6136: PPUSH
6137: LD_INT 1
6139: NEG
6140: PPUSH
6141: CALL_OW 101
// if player_loss = 0 then
6145: LD_EXP 10
6149: PUSH
6150: LD_INT 0
6152: EQUAL
6153: IFFALSE 6167
// AddMedal ( med2 , 1 ) else
6155: LD_STRING med2
6157: PPUSH
6158: LD_INT 1
6160: PPUSH
6161: CALL_OW 101
6165: GO 6210
// if player_loss > 0 and player_loss < 3 then
6167: LD_EXP 10
6171: PUSH
6172: LD_INT 0
6174: GREATER
6175: PUSH
6176: LD_EXP 10
6180: PUSH
6181: LD_INT 3
6183: LESS
6184: AND
6185: IFFALSE 6199
// AddMedal ( med2 , 2 ) else
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 2
6192: PPUSH
6193: CALL_OW 101
6197: GO 6210
// AddMedal ( med2 , - 1 ) ;
6199: LD_STRING med2
6201: PPUSH
6202: LD_INT 1
6204: NEG
6205: PPUSH
6206: CALL_OW 101
// GiveMedals ( MAIN ) ;
6210: LD_STRING MAIN
6212: PPUSH
6213: CALL_OW 102
// YouWin ;
6217: CALL_OW 103
// end ;
6221: END
// every 0 0$01 trigger IsDead ( player_com ) do
6222: LD_EXP 25
6226: PPUSH
6227: CALL_OW 301
6231: IFFALSE 6298
6233: GO 6235
6235: DISABLE
// begin if IsLive ( Houten ) then
6236: LD_EXP 4
6240: PPUSH
6241: CALL_OW 300
6245: IFFALSE 6261
// SayRadio ( Houten , DJ5 ) else
6247: LD_EXP 4
6251: PPUSH
6252: LD_STRING DJ5
6254: PPUSH
6255: CALL_OW 94
6259: GO 6284
// if IsLive ( Brown ) then
6261: LD_EXP 5
6265: PPUSH
6266: CALL_OW 300
6270: IFFALSE 6284
// SayRadio ( Brown , DS5 ) ;
6272: LD_EXP 5
6276: PPUSH
6277: LD_STRING DS5
6279: PPUSH
6280: CALL_OW 94
// Wait ( 0 0$01 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// YouLost ( dead ) ;
6291: LD_STRING dead
6293: PPUSH
6294: CALL_OW 104
// end ;
6298: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6299: LD_EXP 11
6303: PPUSH
6304: CALL_OW 301
6308: PUSH
6309: LD_EXP 1
6313: NOT
6314: AND
6315: IFFALSE 6382
6317: GO 6319
6319: DISABLE
// begin if IsLive ( Brown ) then
6320: LD_EXP 5
6324: PPUSH
6325: CALL_OW 300
6329: IFFALSE 6345
// SayRadio ( Brown , DS5 ) else
6331: LD_EXP 5
6335: PPUSH
6336: LD_STRING DS5
6338: PPUSH
6339: CALL_OW 94
6343: GO 6368
// if IsLive ( Houten ) then
6345: LD_EXP 4
6349: PPUSH
6350: CALL_OW 300
6354: IFFALSE 6368
// SayRadio ( Houten , DJ5 ) ;
6356: LD_EXP 4
6360: PPUSH
6361: LD_STRING DJ5
6363: PPUSH
6364: CALL_OW 94
// Wait ( 0 0$01 ) ;
6368: LD_INT 35
6370: PPUSH
6371: CALL_OW 67
// YouLost ( depot ) ;
6375: LD_STRING depot
6377: PPUSH
6378: CALL_OW 104
// end ;
6382: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6383: LD_INT 0
6385: PPUSH
6386: PPUSH
6387: PPUSH
// for i = 1 to n do
6388: LD_ADDR_VAR 0 4
6392: PUSH
6393: DOUBLE
6394: LD_INT 1
6396: DEC
6397: ST_TO_ADDR
6398: LD_VAR 0 2
6402: PUSH
6403: FOR_TO
6404: IFFALSE 6607
// begin uc_side := 6 ;
6406: LD_ADDR_OWVAR 20
6410: PUSH
6411: LD_INT 6
6413: ST_TO_ADDR
// uc_nation := 3 ;
6414: LD_ADDR_OWVAR 21
6418: PUSH
6419: LD_INT 3
6421: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6422: LD_ADDR_OWVAR 37
6426: PUSH
6427: LD_INT 23
6429: PUSH
6430: LD_INT 22
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: LD_INT 1
6439: PPUSH
6440: LD_INT 2
6442: PPUSH
6443: CALL_OW 12
6447: ARRAY
6448: ST_TO_ADDR
// vc_control := control_computer ;
6449: LD_ADDR_OWVAR 38
6453: PUSH
6454: LD_INT 3
6456: ST_TO_ADDR
// vc_engine := engine_siberite ;
6457: LD_ADDR_OWVAR 39
6461: PUSH
6462: LD_INT 3
6464: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6465: LD_ADDR_OWVAR 40
6469: PUSH
6470: LD_INT 43
6472: PUSH
6473: LD_INT 44
6475: PUSH
6476: LD_INT 44
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 1
6486: PPUSH
6487: LD_INT 3
6489: PPUSH
6490: CALL_OW 12
6494: ARRAY
6495: ST_TO_ADDR
// un := CreateVehicle ;
6496: LD_ADDR_VAR 0 5
6500: PUSH
6501: CALL_OW 45
6505: ST_TO_ADDR
// case area of east_arr :
6506: LD_VAR 0 1
6510: PUSH
6511: LD_INT 18
6513: DOUBLE
6514: EQUAL
6515: IFTRUE 6519
6517: GO 6554
6519: POP
// begin PlaceUnitArea ( un , area , false ) ;
6520: LD_VAR 0 5
6524: PPUSH
6525: LD_VAR 0 1
6529: PPUSH
6530: LD_INT 0
6532: PPUSH
6533: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6537: LD_VAR 0 5
6541: PPUSH
6542: LD_INT 79
6544: PPUSH
6545: LD_INT 33
6547: PPUSH
6548: CALL_OW 111
// end ; south_arr :
6552: GO 6598
6554: LD_INT 19
6556: DOUBLE
6557: EQUAL
6558: IFTRUE 6562
6560: GO 6597
6562: POP
// begin PlaceUnitArea ( un , area , false ) ;
6563: LD_VAR 0 5
6567: PPUSH
6568: LD_VAR 0 1
6572: PPUSH
6573: LD_INT 0
6575: PPUSH
6576: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6580: LD_VAR 0 5
6584: PPUSH
6585: LD_INT 131
6587: PPUSH
6588: LD_INT 148
6590: PPUSH
6591: CALL_OW 111
// end ; end ;
6595: GO 6598
6597: POP
// Wait ( 0 0$02 ) ;
6598: LD_INT 70
6600: PPUSH
6601: CALL_OW 67
// end ;
6605: GO 6403
6607: POP
6608: POP
// pink_attack := true ;
6609: LD_ADDR_EXP 13
6613: PUSH
6614: LD_INT 1
6616: ST_TO_ADDR
// end ;
6617: LD_VAR 0 3
6621: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6622: LD_INT 0
6624: PPUSH
6625: PPUSH
6626: PPUSH
// for i = 1 to n do
6627: LD_ADDR_VAR 0 4
6631: PUSH
6632: DOUBLE
6633: LD_INT 1
6635: DEC
6636: ST_TO_ADDR
6637: LD_VAR 0 2
6641: PUSH
6642: FOR_TO
6643: IFFALSE 6869
// begin uc_side := 6 ;
6645: LD_ADDR_OWVAR 20
6649: PUSH
6650: LD_INT 6
6652: ST_TO_ADDR
// uc_nation := 3 ;
6653: LD_ADDR_OWVAR 21
6657: PUSH
6658: LD_INT 3
6660: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6661: LD_INT 0
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: LD_INT 4
6669: PPUSH
6670: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6674: LD_ADDR_OWVAR 37
6678: PUSH
6679: LD_INT 22
6681: ST_TO_ADDR
// vc_control := control_manual ;
6682: LD_ADDR_OWVAR 38
6686: PUSH
6687: LD_INT 1
6689: ST_TO_ADDR
// vc_engine := engine_combustion ;
6690: LD_ADDR_OWVAR 39
6694: PUSH
6695: LD_INT 1
6697: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6698: LD_ADDR_OWVAR 40
6702: PUSH
6703: LD_INT 51
6705: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6706: LD_ADDR_OWVAR 41
6710: PUSH
6711: LD_INT 50
6713: ST_TO_ADDR
// un := CreateVehicle ;
6714: LD_ADDR_VAR 0 5
6718: PUSH
6719: CALL_OW 45
6723: ST_TO_ADDR
// case area of east_arr :
6724: LD_VAR 0 1
6728: PUSH
6729: LD_INT 18
6731: DOUBLE
6732: EQUAL
6733: IFTRUE 6737
6735: GO 6752
6737: POP
// SetDir ( un , 4 ) ; south_arr :
6738: LD_VAR 0 5
6742: PPUSH
6743: LD_INT 4
6745: PPUSH
6746: CALL_OW 233
6750: GO 6776
6752: LD_INT 19
6754: DOUBLE
6755: EQUAL
6756: IFTRUE 6760
6758: GO 6775
6760: POP
// SetDir ( un , 5 ) ; end ;
6761: LD_VAR 0 5
6765: PPUSH
6766: LD_INT 5
6768: PPUSH
6769: CALL_OW 233
6773: GO 6776
6775: POP
// PlaceUnitArea ( un , area , false ) ;
6776: LD_VAR 0 5
6780: PPUSH
6781: LD_VAR 0 1
6785: PPUSH
6786: LD_INT 0
6788: PPUSH
6789: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6793: CALL_OW 44
6797: PPUSH
6798: LD_VAR 0 5
6802: PPUSH
6803: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: LD_INT 1
6814: PPUSH
6815: LD_INT 100
6817: PPUSH
6818: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6822: LD_VAR 0 5
6826: PPUSH
6827: LD_INT 106
6829: PPUSH
6830: LD_INT 88
6832: PPUSH
6833: CALL_OW 111
// AddComUnload ( un ) ;
6837: LD_VAR 0 5
6841: PPUSH
6842: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6846: LD_VAR 0 5
6850: PPUSH
6851: LD_VAR 0 1
6855: PPUSH
6856: CALL_OW 173
// Wait ( 0 0$02 ) ;
6860: LD_INT 70
6862: PPUSH
6863: CALL_OW 67
// end ;
6867: GO 6642
6869: POP
6870: POP
// Wait ( 0 0$05 ) ;
6871: LD_INT 175
6873: PPUSH
6874: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6878: LD_INT 6
6880: PPUSH
6881: LD_INT 34
6883: PUSH
6884: LD_INT 51
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PPUSH
6891: CALL 11553 0 2
6895: IFFALSE 7083
// begin wait ( 0 0$01 ) ;
6897: LD_INT 35
6899: PPUSH
6900: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6904: LD_ADDR_VAR 0 4
6908: PUSH
6909: LD_INT 6
6911: PPUSH
6912: LD_INT 34
6914: PUSH
6915: LD_INT 51
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: PPUSH
6922: CALL 11553 0 2
6926: PUSH
6927: FOR_IN
6928: IFFALSE 7079
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6930: LD_VAR 0 4
6934: PPUSH
6935: LD_INT 9
6937: PPUSH
6938: CALL_OW 308
6942: PUSH
6943: LD_VAR 0 4
6947: PPUSH
6948: CALL 31785 0 1
6952: PPUSH
6953: CALL_OW 258
6957: PUSH
6958: LD_INT 1
6960: EQUAL
6961: AND
6962: PUSH
6963: LD_EXP 9
6967: AND
6968: IFFALSE 6995
// begin Say ( GetDriver ( i ) , Dtran ) ;
6970: LD_VAR 0 4
6974: PPUSH
6975: CALL 31785 0 1
6979: PPUSH
6980: LD_STRING Dtran
6982: PPUSH
6983: CALL_OW 88
// dialog_trans := false ;
6987: LD_ADDR_EXP 9
6991: PUSH
6992: LD_INT 0
6994: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6995: LD_VAR 0 4
6999: PPUSH
7000: CALL_OW 316
7004: IFFALSE 7020
// ComMoveToArea ( i , area ) ;
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7020: LD_VAR 0 4
7024: PPUSH
7025: LD_VAR 0 1
7029: PPUSH
7030: CALL_OW 308
7034: PUSH
7035: LD_VAR 0 4
7039: PPUSH
7040: LD_INT 1
7042: PPUSH
7043: CALL_OW 289
7047: PUSH
7048: LD_INT 0
7050: EQUAL
7051: AND
7052: IFFALSE 7077
// begin RemoveUnit ( GetDriver ( i ) ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL 31785 0 1
7063: PPUSH
7064: CALL_OW 64
// RemoveUnit ( i ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: CALL_OW 64
// end ; end ;
7077: GO 6927
7079: POP
7080: POP
// end ;
7081: GO 6878
// end ;
7083: LD_VAR 0 3
7087: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7088: LD_INT 0
7090: PPUSH
7091: PPUSH
7092: PPUSH
7093: PPUSH
// if isTest then
7094: LD_EXP 1
7098: IFFALSE 7102
// exit ;
7100: GO 7491
// for i = 1 to n do
7102: LD_ADDR_VAR 0 4
7106: PUSH
7107: DOUBLE
7108: LD_INT 1
7110: DEC
7111: ST_TO_ADDR
7112: LD_VAR 0 2
7116: PUSH
7117: FOR_TO
7118: IFFALSE 7350
// begin uc_side := 8 ;
7120: LD_ADDR_OWVAR 20
7124: PUSH
7125: LD_INT 8
7127: ST_TO_ADDR
// uc_nation := 1 ;
7128: LD_ADDR_OWVAR 21
7132: PUSH
7133: LD_INT 1
7135: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7136: LD_ADDR_VAR 0 6
7140: PUSH
7141: LD_INT 3
7143: PUSH
7144: LD_INT 4
7146: PUSH
7147: LD_INT 4
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 1
7157: PPUSH
7158: LD_OWVAR 67
7162: PPUSH
7163: CALL_OW 12
7167: ARRAY
7168: ST_TO_ADDR
// vc_chassis := ch ;
7169: LD_ADDR_OWVAR 37
7173: PUSH
7174: LD_VAR 0 6
7178: ST_TO_ADDR
// vc_control := control_computer ;
7179: LD_ADDR_OWVAR 38
7183: PUSH
7184: LD_INT 3
7186: ST_TO_ADDR
// vc_engine := engine_combustion ;
7187: LD_ADDR_OWVAR 39
7191: PUSH
7192: LD_INT 1
7194: ST_TO_ADDR
// if ch = us_medium_tracked then
7195: LD_VAR 0 6
7199: PUSH
7200: LD_INT 3
7202: EQUAL
7203: IFFALSE 7250
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7205: LD_ADDR_OWVAR 40
7209: PUSH
7210: LD_INT 3
7212: PUSH
7213: LD_INT 4
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: LD_INT 7
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: PUSH
7228: LD_OWVAR 67
7232: PPUSH
7233: LD_OWVAR 67
7237: PUSH
7238: LD_INT 1
7240: PLUS
7241: PPUSH
7242: CALL_OW 12
7246: ARRAY
7247: ST_TO_ADDR
7248: GO 7291
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7250: LD_ADDR_OWVAR 40
7254: PUSH
7255: LD_INT 5
7257: PUSH
7258: LD_INT 6
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: LD_INT 7
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: LIST
7271: LIST
7272: PUSH
7273: LD_INT 1
7275: PPUSH
7276: LD_OWVAR 67
7280: PUSH
7281: LD_INT 1
7283: PLUS
7284: PPUSH
7285: CALL_OW 12
7289: ARRAY
7290: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7291: LD_ADDR_OWVAR 41
7295: PUSH
7296: LD_INT 70
7298: ST_TO_ADDR
// un := CreateVehicle ;
7299: LD_ADDR_VAR 0 5
7303: PUSH
7304: CALL_OW 45
7308: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7309: LD_VAR 0 5
7313: PPUSH
7314: LD_VAR 0 1
7318: PPUSH
7319: LD_INT 0
7321: PPUSH
7322: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7326: LD_VAR 0 5
7330: PPUSH
7331: LD_INT 65
7333: PPUSH
7334: LD_INT 9
7336: PPUSH
7337: CALL_OW 111
// Wait ( 0 0$02 ) ;
7341: LD_INT 70
7343: PPUSH
7344: CALL_OW 67
// end ;
7348: GO 7117
7350: POP
7351: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7352: LD_INT 90
7354: PUSH
7355: LD_INT 80
7357: PUSH
7358: LD_INT 70
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: PUSH
7366: LD_OWVAR 67
7370: ARRAY
7371: PPUSH
7372: CALL_OW 13
7376: IFFALSE 7483
// begin uc_side := 8 ;
7378: LD_ADDR_OWVAR 20
7382: PUSH
7383: LD_INT 8
7385: ST_TO_ADDR
// uc_nation := 1 ;
7386: LD_ADDR_OWVAR 21
7390: PUSH
7391: LD_INT 1
7393: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7394: LD_ADDR_OWVAR 37
7398: PUSH
7399: LD_INT 4
7401: ST_TO_ADDR
// vc_control := control_computer ;
7402: LD_ADDR_OWVAR 38
7406: PUSH
7407: LD_INT 3
7409: ST_TO_ADDR
// vc_engine := engine_combustion ;
7410: LD_ADDR_OWVAR 39
7414: PUSH
7415: LD_INT 1
7417: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7418: LD_ADDR_OWVAR 40
7422: PUSH
7423: LD_INT 14
7425: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7426: LD_ADDR_OWVAR 41
7430: PUSH
7431: LD_INT 70
7433: ST_TO_ADDR
// un := CreateVehicle ;
7434: LD_ADDR_VAR 0 5
7438: PUSH
7439: CALL_OW 45
7443: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7444: LD_VAR 0 5
7448: PPUSH
7449: LD_VAR 0 1
7453: PPUSH
7454: LD_INT 0
7456: PPUSH
7457: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7461: LD_VAR 0 5
7465: PPUSH
7466: LD_INT 65
7468: PPUSH
7469: LD_INT 9
7471: PPUSH
7472: CALL_OW 111
// Wait ( 0 0$02 ) ;
7476: LD_INT 70
7478: PPUSH
7479: CALL_OW 67
// end ; alfa_support := true ;
7483: LD_ADDR_EXP 14
7487: PUSH
7488: LD_INT 1
7490: ST_TO_ADDR
// end ;
7491: LD_VAR 0 3
7495: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7496: LD_OWVAR 1
7500: PUSH
7501: LD_INT 21000
7503: PUSH
7504: LD_INT 18900
7506: PUSH
7507: LD_INT 16800
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: LIST
7514: PUSH
7515: LD_OWVAR 67
7519: ARRAY
7520: GREATER
7521: IFFALSE 7605
7523: GO 7525
7525: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7526: LD_EXP 26
7530: PPUSH
7531: LD_STRING DR5
7533: PPUSH
7534: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7538: LD_INT 1050
7540: PPUSH
7541: LD_INT 4200
7543: PPUSH
7544: CALL_OW 12
7548: PPUSH
7549: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
7553: LD_INT 20
7555: PPUSH
7556: LD_INT 5
7558: PUSH
7559: LD_INT 6
7561: PUSH
7562: LD_INT 7
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: LD_OWVAR 67
7574: ARRAY
7575: PPUSH
7576: CALL 7088 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7580: LD_INT 8400
7582: PPUSH
7583: LD_INT 12600
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// until tick >= 120 120$00 ;
7595: LD_OWVAR 1
7599: PUSH
7600: LD_INT 252000
7602: GREATEREQUAL
7603: IFFALSE 7526
// end ; end_of_file
7605: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7606: LD_INT 0
7608: PPUSH
// enable_addtolog := isTest ;
7609: LD_ADDR_OWVAR 81
7613: PUSH
7614: LD_EXP 1
7618: ST_TO_ADDR
// lines_break_limit := 5 ;
7619: LD_ADDR_EXP 28
7623: PUSH
7624: LD_INT 5
7626: ST_TO_ADDR
// lines_break_type := --- ;
7627: LD_ADDR_EXP 29
7631: PUSH
7632: LD_STRING ---
7634: ST_TO_ADDR
// lines_counter := 0 ;
7635: LD_ADDR_EXP 27
7639: PUSH
7640: LD_INT 0
7642: ST_TO_ADDR
// show_line_index := true ;
7643: LD_ADDR_EXP 30
7647: PUSH
7648: LD_INT 1
7650: ST_TO_ADDR
// tick_log := true ;
7651: LD_ADDR_EXP 31
7655: PUSH
7656: LD_INT 1
7658: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7659: LD_STRING ----------SAND OF SIBERIA LOG----------
7661: PPUSH
7662: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7666: LD_STRING Map Name: 
7668: PUSH
7669: LD_OWVAR 68
7673: STR
7674: PPUSH
7675: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7679: LD_STRING Map Number: 
7681: PUSH
7682: LD_OWVAR 70
7686: STR
7687: PPUSH
7688: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7692: LD_STRING Difficulty: 
7694: PUSH
7695: LD_OWVAR 67
7699: STR
7700: PPUSH
7701: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7705: LD_STRING ---------------------------------------
7707: PPUSH
7708: CALL_OW 561
// end ;
7712: LD_VAR 0 1
7716: RET
// function Log ( text ) ; begin
7717: LD_INT 0
7719: PPUSH
// if show_line_index then
7720: LD_EXP 30
7724: IFFALSE 7736
// result := lines_counter ;
7726: LD_ADDR_VAR 0 2
7730: PUSH
7731: LD_EXP 27
7735: ST_TO_ADDR
// if tick_log then
7736: LD_EXP 31
7740: IFFALSE 7766
// result := result &  T:  & tick &   ;
7742: LD_ADDR_VAR 0 2
7746: PUSH
7747: LD_VAR 0 2
7751: PUSH
7752: LD_STRING  T: 
7754: STR
7755: PUSH
7756: LD_OWVAR 1
7760: STR
7761: PUSH
7762: LD_STRING  
7764: STR
7765: ST_TO_ADDR
// AddToLog ( result & text ) ;
7766: LD_VAR 0 2
7770: PUSH
7771: LD_VAR 0 1
7775: STR
7776: PPUSH
7777: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7781: LD_ADDR_EXP 27
7785: PUSH
7786: LD_EXP 27
7790: PUSH
7791: LD_INT 1
7793: PLUS
7794: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7795: LD_EXP 27
7799: PUSH
7800: LD_EXP 28
7804: MOD
7805: PUSH
7806: LD_INT 0
7808: EQUAL
7809: IFFALSE 7820
// AddToLog ( lines_break_type ) ;
7811: LD_EXP 29
7815: PPUSH
7816: CALL_OW 561
// end ;
7820: LD_VAR 0 2
7824: RET
// export function LogHuman ( id ) ; begin
7825: LD_INT 0
7827: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7828: LD_STRING Human Created. id: 
7830: PUSH
7831: LD_VAR 0 1
7835: STR
7836: PUSH
7837: LD_STRING ; side: 
7839: STR
7840: PUSH
7841: LD_VAR 0 1
7845: PPUSH
7846: CALL_OW 255
7850: STR
7851: PUSH
7852: LD_STRING ; class: 
7854: STR
7855: PUSH
7856: LD_VAR 0 1
7860: PPUSH
7861: CALL_OW 257
7865: STR
7866: PUSH
7867: LD_STRING ; 
7869: STR
7870: PPUSH
7871: CALL 7717 0 1
// end ;
7875: LD_VAR 0 2
7879: RET
// export function LogVeh ( id ) ; begin
7880: LD_INT 0
7882: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7883: LD_STRING Vehicle Created. id: 
7885: PUSH
7886: LD_VAR 0 1
7890: STR
7891: PUSH
7892: LD_STRING ; side: 
7894: STR
7895: PUSH
7896: LD_VAR 0 1
7900: PPUSH
7901: CALL_OW 255
7905: STR
7906: PUSH
7907: LD_STRING ; nation: 
7909: STR
7910: PUSH
7911: LD_VAR 0 1
7915: PPUSH
7916: CALL_OW 248
7920: STR
7921: PUSH
7922: LD_STRING ; weapon: 
7924: STR
7925: PUSH
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 264
7935: STR
7936: PUSH
7937: LD_STRING ; 
7939: STR
7940: PPUSH
7941: CALL 7717 0 1
// end ;
7945: LD_VAR 0 2
7949: RET
// export function LogEvent ( event ) ; begin
7950: LD_INT 0
7952: PPUSH
// Log ( Event Executed. id:  & event ) ;
7953: LD_STRING Event Executed. id: 
7955: PUSH
7956: LD_VAR 0 1
7960: STR
7961: PPUSH
7962: CALL 7717 0 1
// end ; end_of_file
7966: LD_VAR 0 2
7970: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
7971: LD_INT 0
7973: PPUSH
7974: PPUSH
7975: PPUSH
7976: PPUSH
7977: PPUSH
7978: PPUSH
7979: PPUSH
7980: PPUSH
// if unit then
7981: LD_VAR 0 1
7985: IFFALSE 8385
// begin if mode = 0 then
7987: LD_VAR 0 3
7991: PUSH
7992: LD_INT 0
7994: EQUAL
7995: IFFALSE 8143
// begin if coords then
7997: LD_VAR 0 2
8001: IFFALSE 8141
// while ( coords > 1 ) do
8003: LD_VAR 0 2
8007: PUSH
8008: LD_INT 1
8010: GREATER
8011: IFFALSE 8141
// if not HasTask ( unit ) then
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 314
8022: NOT
8023: IFFALSE 8139
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8025: LD_VAR 0 1
8029: PPUSH
8030: LD_VAR 0 2
8034: PUSH
8035: LD_INT 1
8037: ARRAY
8038: PPUSH
8039: LD_VAR 0 2
8043: PUSH
8044: LD_INT 2
8046: ARRAY
8047: PPUSH
8048: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8052: LD_INT 35
8054: PPUSH
8055: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8059: LD_VAR 0 1
8063: PPUSH
8064: CALL_OW 250
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: LD_INT 1
8076: ARRAY
8077: EQUAL
8078: PUSH
8079: LD_VAR 0 1
8083: PPUSH
8084: CALL_OW 251
8088: PUSH
8089: LD_VAR 0 2
8093: PUSH
8094: LD_INT 2
8096: ARRAY
8097: EQUAL
8098: AND
8099: IFFALSE 8052
// for i = 1 to 2 do
8101: LD_ADDR_VAR 0 5
8105: PUSH
8106: DOUBLE
8107: LD_INT 1
8109: DEC
8110: ST_TO_ADDR
8111: LD_INT 2
8113: PUSH
8114: FOR_TO
8115: IFFALSE 8137
// coords := Delete ( coords , 1 ) ;
8117: LD_ADDR_VAR 0 2
8121: PUSH
8122: LD_VAR 0 2
8126: PPUSH
8127: LD_INT 1
8129: PPUSH
8130: CALL_OW 3
8134: ST_TO_ADDR
8135: GO 8114
8137: POP
8138: POP
// end ;
8139: GO 8003
// end else
8141: GO 8385
// begin if coords then
8143: LD_VAR 0 2
8147: IFFALSE 8385
// begin x := GetX ( unit ) ;
8149: LD_ADDR_VAR 0 6
8153: PUSH
8154: LD_VAR 0 1
8158: PPUSH
8159: CALL_OW 250
8163: ST_TO_ADDR
// y := GetY ( unit ) ;
8164: LD_ADDR_VAR 0 7
8168: PUSH
8169: LD_VAR 0 1
8173: PPUSH
8174: CALL_OW 251
8178: ST_TO_ADDR
// while ( coords > 1 ) do
8179: LD_VAR 0 2
8183: PUSH
8184: LD_INT 1
8186: GREATER
8187: IFFALSE 8385
// begin Wait ( 0 0$0.3 ) ;
8189: LD_INT 10
8191: PPUSH
8192: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8196: LD_VAR 0 1
8200: PPUSH
8201: CALL_OW 255
8205: PPUSH
8206: LD_VAR 0 1
8210: PPUSH
8211: CALL_OW 250
8215: PPUSH
8216: LD_VAR 0 1
8220: PPUSH
8221: CALL_OW 251
8225: PPUSH
8226: LD_INT 14
8228: PPUSH
8229: CALL 22723 0 4
8233: IFFALSE 8264
// begin ComMoveXY ( unit , x , y ) ;
8235: LD_VAR 0 1
8239: PPUSH
8240: LD_VAR 0 6
8244: PPUSH
8245: LD_VAR 0 7
8249: PPUSH
8250: CALL_OW 111
// result := false ;
8254: LD_ADDR_VAR 0 4
8258: PUSH
8259: LD_INT 0
8261: ST_TO_ADDR
// end else
8262: GO 8303
// if not HasTask ( unit ) then
8264: LD_VAR 0 1
8268: PPUSH
8269: CALL_OW 314
8273: NOT
8274: IFFALSE 8303
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8276: LD_VAR 0 1
8280: PPUSH
8281: LD_VAR 0 2
8285: PUSH
8286: LD_INT 1
8288: ARRAY
8289: PPUSH
8290: LD_VAR 0 2
8294: PUSH
8295: LD_INT 2
8297: ARRAY
8298: PPUSH
8299: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8303: LD_VAR 0 1
8307: PPUSH
8308: CALL_OW 250
8312: PUSH
8313: LD_VAR 0 2
8317: PUSH
8318: LD_INT 1
8320: ARRAY
8321: EQUAL
8322: PUSH
8323: LD_VAR 0 1
8327: PPUSH
8328: CALL_OW 251
8332: PUSH
8333: LD_VAR 0 2
8337: PUSH
8338: LD_INT 2
8340: ARRAY
8341: EQUAL
8342: AND
8343: IFFALSE 8383
// for i = 1 to 2 do
8345: LD_ADDR_VAR 0 5
8349: PUSH
8350: DOUBLE
8351: LD_INT 1
8353: DEC
8354: ST_TO_ADDR
8355: LD_INT 2
8357: PUSH
8358: FOR_TO
8359: IFFALSE 8381
// coords := Delete ( coords , 1 ) ;
8361: LD_ADDR_VAR 0 2
8365: PUSH
8366: LD_VAR 0 2
8370: PPUSH
8371: LD_INT 1
8373: PPUSH
8374: CALL_OW 3
8378: ST_TO_ADDR
8379: GO 8358
8381: POP
8382: POP
// end ;
8383: GO 8179
// end ; end ; end ; result := true ;
8385: LD_ADDR_VAR 0 4
8389: PUSH
8390: LD_INT 1
8392: ST_TO_ADDR
// end ;
8393: LD_VAR 0 4
8397: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8398: LD_INT 0
8400: PPUSH
8401: PPUSH
8402: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8403: LD_ADDR_VAR 0 5
8407: PUSH
8408: LD_INT 81
8410: PUSH
8411: LD_VAR 0 1
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: ST_TO_ADDR
// for i in units do
8425: LD_ADDR_VAR 0 4
8429: PUSH
8430: LD_VAR 0 2
8434: PUSH
8435: FOR_IN
8436: IFFALSE 8464
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8438: LD_VAR 0 4
8442: PPUSH
8443: LD_VAR 0 5
8447: PPUSH
8448: LD_VAR 0 4
8452: PPUSH
8453: CALL_OW 74
8457: PPUSH
8458: CALL_OW 115
// end ;
8462: GO 8435
8464: POP
8465: POP
// end ;
8466: LD_VAR 0 3
8470: RET
// export function MC_Show ( string ) ; begin
8471: LD_INT 0
8473: PPUSH
// display_strings := string ;
8474: LD_ADDR_OWVAR 47
8478: PUSH
8479: LD_VAR 0 1
8483: ST_TO_ADDR
// end ; end_of_file
8484: LD_VAR 0 2
8488: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
8494: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8495: LD_ADDR_VAR 0 8
8499: PUSH
8500: LD_VAR 0 1
8504: PPUSH
8505: LD_INT 2
8507: PPUSH
8508: EMPTY
8509: PPUSH
8510: CALL 11636 0 3
8514: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8515: LD_VAR 0 8
8519: PUSH
8520: LD_VAR 0 2
8524: PPUSH
8525: LD_VAR 0 3
8529: PPUSH
8530: CALL_OW 428
8534: PUSH
8535: LD_INT 0
8537: EQUAL
8538: AND
8539: IFFALSE 8613
// for i = 1 to plist do
8541: LD_ADDR_VAR 0 6
8545: PUSH
8546: DOUBLE
8547: LD_INT 1
8549: DEC
8550: ST_TO_ADDR
8551: LD_VAR 0 8
8555: PUSH
8556: FOR_TO
8557: IFFALSE 8611
// if NotTask ( plist [ i ] ) then
8559: LD_VAR 0 8
8563: PUSH
8564: LD_VAR 0 6
8568: ARRAY
8569: PPUSH
8570: CALL 32430 0 1
8574: IFFALSE 8609
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8576: LD_VAR 0 8
8580: PUSH
8581: LD_VAR 0 6
8585: ARRAY
8586: PPUSH
8587: LD_INT 0
8589: PPUSH
8590: LD_VAR 0 2
8594: PPUSH
8595: LD_VAR 0 3
8599: PPUSH
8600: LD_VAR 0 4
8604: PPUSH
8605: CALL_OW 145
// end ;
8609: GO 8556
8611: POP
8612: POP
// end ;
8613: LD_VAR 0 5
8617: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8618: LD_INT 0
8620: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8621: LD_VAR 0 1
8625: PPUSH
8626: LD_INT 6
8628: PPUSH
8629: LD_VAR 0 2
8633: PPUSH
8634: LD_VAR 0 3
8638: PPUSH
8639: LD_VAR 0 4
8643: PPUSH
8644: CALL 10122 0 5
// end ;
8648: LD_VAR 0 5
8652: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8653: LD_INT 0
8655: PPUSH
8656: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8657: LD_ADDR_VAR 0 4
8661: PUSH
8662: LD_INT 22
8664: PUSH
8665: LD_VAR 0 1
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: LD_INT 2
8676: PUSH
8677: LD_INT 30
8679: PUSH
8680: LD_INT 0
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PUSH
8687: LD_INT 30
8689: PUSH
8690: LD_INT 1
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: EMPTY
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: PUSH
8706: EMPTY
8707: LIST
8708: PPUSH
8709: CALL_OW 69
8713: PPUSH
8714: LD_VAR 0 2
8718: PPUSH
8719: CALL_OW 250
8723: PPUSH
8724: LD_VAR 0 2
8728: PPUSH
8729: CALL_OW 251
8733: PPUSH
8734: CALL_OW 73
8738: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8739: LD_VAR 0 4
8743: PPUSH
8744: LD_VAR 0 2
8748: PPUSH
8749: CALL 10411 0 2
8753: IFFALSE 8812
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8755: LD_VAR 0 1
8759: PPUSH
8760: LD_INT 30
8762: PUSH
8763: LD_VAR 0 2
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PPUSH
8772: CALL 11553 0 2
8776: PUSH
8777: LD_INT 1
8779: ARRAY
8780: PPUSH
8781: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8785: LD_ADDR_EXP 50
8789: PUSH
8790: LD_EXP 50
8794: PPUSH
8795: LD_VAR 0 1
8799: PPUSH
8800: LD_VAR 0 2
8804: PPUSH
8805: EMPTY
8806: PPUSH
8807: CALL 42464 0 4
8811: ST_TO_ADDR
// end ; end ;
8812: LD_VAR 0 3
8816: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8817: LD_INT 0
8819: PPUSH
8820: PPUSH
8821: PPUSH
8822: PPUSH
8823: PPUSH
8824: PPUSH
// result := false ;
8825: LD_ADDR_VAR 0 4
8829: PUSH
8830: LD_INT 0
8832: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8833: LD_VAR 0 1
8837: PPUSH
8838: LD_EXP 42
8842: PPUSH
8843: CALL 43412 0 2
8847: IFFALSE 9060
// for i = 1 to MREG_LabList do
8849: LD_ADDR_VAR 0 5
8853: PUSH
8854: DOUBLE
8855: LD_INT 1
8857: DEC
8858: ST_TO_ADDR
8859: LD_EXP 42
8863: PUSH
8864: FOR_TO
8865: IFFALSE 9058
// begin if MREG_LabList [ i ] [ 1 ] = side then
8867: LD_EXP 42
8871: PUSH
8872: LD_VAR 0 5
8876: ARRAY
8877: PUSH
8878: LD_INT 1
8880: ARRAY
8881: PUSH
8882: LD_VAR 0 1
8886: EQUAL
8887: IFFALSE 9056
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8889: LD_ADDR_VAR 0 7
8893: PUSH
8894: LD_EXP 42
8898: PUSH
8899: LD_VAR 0 5
8903: ARRAY
8904: PUSH
8905: LD_INT 2
8907: ARRAY
8908: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8909: LD_ADDR_VAR 0 9
8913: PUSH
8914: LD_INT 22
8916: PUSH
8917: LD_VAR 0 1
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 2
8928: PUSH
8929: LD_INT 30
8931: PUSH
8932: LD_INT 0
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PUSH
8939: LD_INT 30
8941: PUSH
8942: LD_INT 1
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: LIST
8953: PUSH
8954: EMPTY
8955: LIST
8956: LIST
8957: PUSH
8958: EMPTY
8959: LIST
8960: PPUSH
8961: CALL_OW 69
8965: PPUSH
8966: LD_VAR 0 7
8970: PPUSH
8971: CALL_OW 250
8975: PPUSH
8976: LD_VAR 0 7
8980: PPUSH
8981: CALL_OW 251
8985: PPUSH
8986: CALL_OW 73
8990: ST_TO_ADDR
// if dep then
8991: LD_VAR 0 9
8995: IFFALSE 9054
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
8997: LD_VAR 0 9
9001: PPUSH
9002: LD_VAR 0 2
9006: PPUSH
9007: LD_VAR 0 3
9011: PPUSH
9012: CALL 10527 0 3
9016: IFFALSE 9054
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9018: LD_VAR 0 7
9022: PPUSH
9023: LD_VAR 0 2
9027: PPUSH
9028: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9032: LD_VAR 0 7
9036: PPUSH
9037: LD_VAR 0 3
9041: PPUSH
9042: CALL_OW 207
// result := true ;
9046: LD_ADDR_VAR 0 4
9050: PUSH
9051: LD_INT 1
9053: ST_TO_ADDR
// end ; end ; break ;
9054: GO 9058
// end ; end ;
9056: GO 8864
9058: POP
9059: POP
// end ;
9060: LD_VAR 0 4
9064: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9065: LD_INT 0
9067: PPUSH
9068: PPUSH
9069: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9070: LD_ADDR_VAR 0 7
9074: PUSH
9075: LD_VAR 0 2
9079: PPUSH
9080: LD_VAR 0 3
9084: PPUSH
9085: LD_VAR 0 4
9089: PPUSH
9090: CALL 9252 0 3
9094: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9095: LD_ADDR_EXP 48
9099: PUSH
9100: LD_EXP 48
9104: PPUSH
9105: LD_VAR 0 1
9109: PPUSH
9110: LD_INT 2
9112: PPUSH
9113: LD_VAR 0 2
9117: PUSH
9118: LD_VAR 0 3
9122: PUSH
9123: LD_VAR 0 4
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PPUSH
9133: CALL 42373 0 4
9137: ST_TO_ADDR
// if ext_list then
9138: LD_VAR 0 5
9142: IFFALSE 9247
// for i = 1 to ext_list do
9144: LD_ADDR_VAR 0 8
9148: PUSH
9149: DOUBLE
9150: LD_INT 1
9152: DEC
9153: ST_TO_ADDR
9154: LD_VAR 0 5
9158: PUSH
9159: FOR_TO
9160: IFFALSE 9245
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9162: LD_ADDR_EXP 48
9166: PUSH
9167: LD_EXP 48
9171: PPUSH
9172: LD_VAR 0 1
9176: PPUSH
9177: LD_VAR 0 5
9181: PUSH
9182: LD_VAR 0 8
9186: ARRAY
9187: PPUSH
9188: LD_VAR 0 7
9192: PUSH
9193: LD_VAR 0 8
9197: ARRAY
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PUSH
9203: LD_VAR 0 7
9207: PUSH
9208: LD_VAR 0 8
9212: ARRAY
9213: PUSH
9214: LD_INT 2
9216: ARRAY
9217: PUSH
9218: LD_VAR 0 7
9222: PUSH
9223: LD_VAR 0 8
9227: ARRAY
9228: PUSH
9229: LD_INT 3
9231: ARRAY
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: LIST
9237: PPUSH
9238: CALL 42373 0 4
9242: ST_TO_ADDR
9243: GO 9159
9245: POP
9246: POP
// end ;
9247: LD_VAR 0 6
9251: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9252: LD_INT 0
9254: PPUSH
9255: PPUSH
// list := [ ] ;
9256: LD_ADDR_VAR 0 5
9260: PUSH
9261: EMPTY
9262: ST_TO_ADDR
// case d of 0 :
9263: LD_VAR 0 3
9267: PUSH
9268: LD_INT 0
9270: DOUBLE
9271: EQUAL
9272: IFTRUE 9276
9274: GO 9409
9276: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9277: LD_ADDR_VAR 0 5
9281: PUSH
9282: LD_VAR 0 1
9286: PUSH
9287: LD_INT 4
9289: MINUS
9290: PUSH
9291: LD_VAR 0 2
9295: PUSH
9296: LD_INT 4
9298: MINUS
9299: PUSH
9300: LD_INT 2
9302: PUSH
9303: EMPTY
9304: LIST
9305: LIST
9306: LIST
9307: PUSH
9308: LD_VAR 0 1
9312: PUSH
9313: LD_INT 3
9315: MINUS
9316: PUSH
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 1
9324: PUSH
9325: EMPTY
9326: LIST
9327: LIST
9328: LIST
9329: PUSH
9330: LD_VAR 0 1
9334: PUSH
9335: LD_INT 4
9337: PLUS
9338: PUSH
9339: LD_VAR 0 2
9343: PUSH
9344: LD_INT 4
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PUSH
9352: LD_VAR 0 1
9356: PUSH
9357: LD_INT 3
9359: PLUS
9360: PUSH
9361: LD_VAR 0 2
9365: PUSH
9366: LD_INT 3
9368: PLUS
9369: PUSH
9370: LD_INT 5
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: LIST
9377: PUSH
9378: LD_VAR 0 1
9382: PUSH
9383: LD_VAR 0 2
9387: PUSH
9388: LD_INT 4
9390: PLUS
9391: PUSH
9392: LD_INT 0
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: LIST
9406: ST_TO_ADDR
// end ; 1 :
9407: GO 10107
9409: LD_INT 1
9411: DOUBLE
9412: EQUAL
9413: IFTRUE 9417
9415: GO 9550
9417: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9418: LD_ADDR_VAR 0 5
9422: PUSH
9423: LD_VAR 0 1
9427: PUSH
9428: LD_VAR 0 2
9432: PUSH
9433: LD_INT 4
9435: MINUS
9436: PUSH
9437: LD_INT 3
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: LIST
9444: PUSH
9445: LD_VAR 0 1
9449: PUSH
9450: LD_INT 3
9452: MINUS
9453: PUSH
9454: LD_VAR 0 2
9458: PUSH
9459: LD_INT 3
9461: MINUS
9462: PUSH
9463: LD_INT 2
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: LIST
9470: PUSH
9471: LD_VAR 0 1
9475: PUSH
9476: LD_INT 4
9478: MINUS
9479: PUSH
9480: LD_VAR 0 2
9484: PUSH
9485: LD_INT 1
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: LIST
9492: PUSH
9493: LD_VAR 0 1
9497: PUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 3
9505: PLUS
9506: PUSH
9507: LD_INT 0
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: LIST
9514: PUSH
9515: LD_VAR 0 1
9519: PUSH
9520: LD_INT 4
9522: PLUS
9523: PUSH
9524: LD_VAR 0 2
9528: PUSH
9529: LD_INT 4
9531: PLUS
9532: PUSH
9533: LD_INT 5
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: LIST
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: LIST
9547: ST_TO_ADDR
// end ; 2 :
9548: GO 10107
9550: LD_INT 2
9552: DOUBLE
9553: EQUAL
9554: IFTRUE 9558
9556: GO 9687
9558: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9559: LD_ADDR_VAR 0 5
9563: PUSH
9564: LD_VAR 0 1
9568: PUSH
9569: LD_VAR 0 2
9573: PUSH
9574: LD_INT 3
9576: MINUS
9577: PUSH
9578: LD_INT 3
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_VAR 0 1
9590: PUSH
9591: LD_INT 4
9593: PLUS
9594: PUSH
9595: LD_VAR 0 2
9599: PUSH
9600: LD_INT 4
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: LIST
9607: PUSH
9608: LD_VAR 0 1
9612: PUSH
9613: LD_VAR 0 2
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_INT 0
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: LIST
9629: PUSH
9630: LD_VAR 0 1
9634: PUSH
9635: LD_INT 3
9637: MINUS
9638: PUSH
9639: LD_VAR 0 2
9643: PUSH
9644: LD_INT 1
9646: PUSH
9647: EMPTY
9648: LIST
9649: LIST
9650: LIST
9651: PUSH
9652: LD_VAR 0 1
9656: PUSH
9657: LD_INT 4
9659: MINUS
9660: PUSH
9661: LD_VAR 0 2
9665: PUSH
9666: LD_INT 4
9668: MINUS
9669: PUSH
9670: LD_INT 2
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: LIST
9677: PUSH
9678: EMPTY
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: ST_TO_ADDR
// end ; 3 :
9685: GO 10107
9687: LD_INT 3
9689: DOUBLE
9690: EQUAL
9691: IFTRUE 9695
9693: GO 9828
9695: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9696: LD_ADDR_VAR 0 5
9700: PUSH
9701: LD_VAR 0 1
9705: PUSH
9706: LD_INT 3
9708: PLUS
9709: PUSH
9710: LD_VAR 0 2
9714: PUSH
9715: LD_INT 4
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: LIST
9722: PUSH
9723: LD_VAR 0 1
9727: PUSH
9728: LD_INT 4
9730: PLUS
9731: PUSH
9732: LD_VAR 0 2
9736: PUSH
9737: LD_INT 4
9739: PLUS
9740: PUSH
9741: LD_INT 5
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: LIST
9748: PUSH
9749: LD_VAR 0 1
9753: PUSH
9754: LD_INT 4
9756: MINUS
9757: PUSH
9758: LD_VAR 0 2
9762: PUSH
9763: LD_INT 1
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: LIST
9770: PUSH
9771: LD_VAR 0 1
9775: PUSH
9776: LD_VAR 0 2
9780: PUSH
9781: LD_INT 4
9783: MINUS
9784: PUSH
9785: LD_INT 3
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: LIST
9792: PUSH
9793: LD_VAR 0 1
9797: PUSH
9798: LD_INT 3
9800: MINUS
9801: PUSH
9802: LD_VAR 0 2
9806: PUSH
9807: LD_INT 3
9809: MINUS
9810: PUSH
9811: LD_INT 2
9813: PUSH
9814: EMPTY
9815: LIST
9816: LIST
9817: LIST
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: ST_TO_ADDR
// end ; 4 :
9826: GO 10107
9828: LD_INT 4
9830: DOUBLE
9831: EQUAL
9832: IFTRUE 9836
9834: GO 9969
9836: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9837: LD_ADDR_VAR 0 5
9841: PUSH
9842: LD_VAR 0 1
9846: PUSH
9847: LD_VAR 0 2
9851: PUSH
9852: LD_INT 4
9854: PLUS
9855: PUSH
9856: LD_INT 0
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: LIST
9863: PUSH
9864: LD_VAR 0 1
9868: PUSH
9869: LD_INT 3
9871: PLUS
9872: PUSH
9873: LD_VAR 0 2
9877: PUSH
9878: LD_INT 3
9880: PLUS
9881: PUSH
9882: LD_INT 5
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: LIST
9889: PUSH
9890: LD_VAR 0 1
9894: PUSH
9895: LD_INT 3
9897: PLUS
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: LD_INT 4
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: LIST
9911: PUSH
9912: LD_VAR 0 1
9916: PUSH
9917: LD_VAR 0 2
9921: PUSH
9922: LD_INT 3
9924: MINUS
9925: PUSH
9926: LD_INT 3
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: LIST
9933: PUSH
9934: LD_VAR 0 1
9938: PUSH
9939: LD_INT 4
9941: MINUS
9942: PUSH
9943: LD_VAR 0 2
9947: PUSH
9948: LD_INT 4
9950: MINUS
9951: PUSH
9952: LD_INT 2
9954: PUSH
9955: EMPTY
9956: LIST
9957: LIST
9958: LIST
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: LIST
9966: ST_TO_ADDR
// end ; 5 :
9967: GO 10107
9969: LD_INT 5
9971: DOUBLE
9972: EQUAL
9973: IFTRUE 9977
9975: GO 10106
9977: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
9978: LD_ADDR_VAR 0 5
9982: PUSH
9983: LD_VAR 0 1
9987: PUSH
9988: LD_INT 4
9990: MINUS
9991: PUSH
9992: LD_VAR 0 2
9996: PUSH
9997: LD_INT 1
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: PUSH
10005: LD_VAR 0 1
10009: PUSH
10010: LD_VAR 0 2
10014: PUSH
10015: LD_INT 4
10017: MINUS
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: LIST
10026: PUSH
10027: LD_VAR 0 1
10031: PUSH
10032: LD_INT 4
10034: PLUS
10035: PUSH
10036: LD_VAR 0 2
10040: PUSH
10041: LD_INT 4
10043: PLUS
10044: PUSH
10045: LD_INT 5
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: LIST
10052: PUSH
10053: LD_VAR 0 1
10057: PUSH
10058: LD_INT 3
10060: PLUS
10061: PUSH
10062: LD_VAR 0 2
10066: PUSH
10067: LD_INT 4
10069: PUSH
10070: EMPTY
10071: LIST
10072: LIST
10073: LIST
10074: PUSH
10075: LD_VAR 0 1
10079: PUSH
10080: LD_VAR 0 2
10084: PUSH
10085: LD_INT 3
10087: PLUS
10088: PUSH
10089: LD_INT 0
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: LIST
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: ST_TO_ADDR
// end ; end ;
10104: GO 10107
10106: POP
// result := list ;
10107: LD_ADDR_VAR 0 4
10111: PUSH
10112: LD_VAR 0 5
10116: ST_TO_ADDR
// end ;
10117: LD_VAR 0 4
10121: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10122: LD_INT 0
10124: PPUSH
10125: PPUSH
10126: PPUSH
10127: PPUSH
10128: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10129: LD_ADDR_VAR 0 10
10133: PUSH
10134: LD_VAR 0 1
10138: PPUSH
10139: LD_INT 2
10141: PPUSH
10142: EMPTY
10143: PPUSH
10144: CALL 11636 0 3
10148: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10149: LD_ADDR_VAR 0 9
10153: PUSH
10154: LD_INT 22
10156: PUSH
10157: LD_VAR 0 1
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: PUSH
10166: LD_INT 2
10168: PUSH
10169: LD_INT 30
10171: PUSH
10172: LD_INT 0
10174: PUSH
10175: EMPTY
10176: LIST
10177: LIST
10178: PUSH
10179: LD_INT 30
10181: PUSH
10182: LD_INT 1
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: LIST
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: EMPTY
10199: LIST
10200: PPUSH
10201: CALL_OW 69
10205: PPUSH
10206: LD_VAR 0 3
10210: PPUSH
10211: LD_VAR 0 4
10215: PPUSH
10216: CALL_OW 73
10220: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10221: LD_ADDR_VAR 0 8
10225: PUSH
10226: LD_VAR 0 9
10230: PPUSH
10231: LD_VAR 0 2
10235: PPUSH
10236: CALL 10411 0 2
10240: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10241: LD_VAR 0 10
10245: PUSH
10246: LD_VAR 0 8
10250: AND
10251: PUSH
10252: LD_VAR 0 9
10256: PPUSH
10257: LD_VAR 0 3
10261: PPUSH
10262: LD_VAR 0 4
10266: PPUSH
10267: CALL_OW 297
10271: PUSH
10272: LD_INT 26
10274: LESSEQUAL
10275: AND
10276: PUSH
10277: LD_VAR 0 3
10281: PPUSH
10282: LD_VAR 0 4
10286: PPUSH
10287: CALL_OW 428
10291: PUSH
10292: LD_INT 0
10294: EQUAL
10295: AND
10296: IFFALSE 10406
// for i = 1 to plist do
10298: LD_ADDR_VAR 0 7
10302: PUSH
10303: DOUBLE
10304: LD_INT 1
10306: DEC
10307: ST_TO_ADDR
10308: LD_VAR 0 10
10312: PUSH
10313: FOR_TO
10314: IFFALSE 10404
// if IsInUnit ( plist [ i ] ) then
10316: LD_VAR 0 10
10320: PUSH
10321: LD_VAR 0 7
10325: ARRAY
10326: PPUSH
10327: CALL_OW 310
10331: IFFALSE 10350
// ComExitBuilding ( plist [ i ] ) else
10333: LD_VAR 0 10
10337: PUSH
10338: LD_VAR 0 7
10342: ARRAY
10343: PPUSH
10344: CALL_OW 122
10348: GO 10402
// if NotTask ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL 32430 0 1
10365: IFFALSE 10402
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_VAR 0 3
10387: PPUSH
10388: LD_VAR 0 4
10392: PPUSH
10393: LD_VAR 0 5
10397: PPUSH
10398: CALL_OW 145
// end ;
10402: GO 10313
10404: POP
10405: POP
// end ;
10406: LD_VAR 0 6
10410: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10411: LD_INT 0
10413: PPUSH
10414: PPUSH
10415: PPUSH
// pom := GetBase ( bdepot ) ;
10416: LD_ADDR_VAR 0 4
10420: PUSH
10421: LD_VAR 0 1
10425: PPUSH
10426: CALL_OW 274
10430: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10431: LD_ADDR_VAR 0 5
10435: PUSH
10436: LD_VAR 0 2
10440: PPUSH
10441: LD_VAR 0 1
10445: PPUSH
10446: CALL_OW 248
10450: PPUSH
10451: CALL_OW 450
10455: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10456: LD_VAR 0 4
10460: PPUSH
10461: LD_INT 1
10463: PPUSH
10464: CALL_OW 275
10468: PUSH
10469: LD_VAR 0 5
10473: PUSH
10474: LD_INT 1
10476: ARRAY
10477: GREATEREQUAL
10478: PUSH
10479: LD_VAR 0 4
10483: PPUSH
10484: LD_INT 3
10486: PPUSH
10487: CALL_OW 275
10491: PUSH
10492: LD_VAR 0 5
10496: PUSH
10497: LD_INT 3
10499: ARRAY
10500: GREATEREQUAL
10501: AND
10502: IFFALSE 10514
// result := true else
10504: LD_ADDR_VAR 0 3
10508: PUSH
10509: LD_INT 1
10511: ST_TO_ADDR
10512: GO 10522
// result := false ;
10514: LD_ADDR_VAR 0 3
10518: PUSH
10519: LD_INT 0
10521: ST_TO_ADDR
// end ;
10522: LD_VAR 0 3
10526: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10527: LD_INT 0
10529: PPUSH
10530: PPUSH
10531: PPUSH
10532: PPUSH
10533: PPUSH
// pom := GetBase ( bdepot ) ;
10534: LD_ADDR_VAR 0 5
10538: PUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 274
10548: ST_TO_ADDR
// cost := [ ] ;
10549: LD_ADDR_VAR 0 8
10553: PUSH
10554: EMPTY
10555: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10556: LD_ADDR_VAR 0 6
10560: PUSH
10561: LD_VAR 0 2
10565: PPUSH
10566: LD_VAR 0 1
10570: PPUSH
10571: CALL_OW 248
10575: PPUSH
10576: CALL_OW 450
10580: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10581: LD_ADDR_VAR 0 7
10585: PUSH
10586: LD_VAR 0 3
10590: PPUSH
10591: LD_VAR 0 1
10595: PPUSH
10596: CALL_OW 248
10600: PPUSH
10601: CALL_OW 450
10605: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10606: LD_ADDR_VAR 0 8
10610: PUSH
10611: LD_VAR 0 8
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: LD_VAR 0 6
10623: PUSH
10624: LD_INT 1
10626: ARRAY
10627: PUSH
10628: LD_VAR 0 7
10632: PUSH
10633: LD_INT 1
10635: ARRAY
10636: PLUS
10637: PPUSH
10638: CALL_OW 1
10642: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10643: LD_ADDR_VAR 0 8
10647: PUSH
10648: LD_VAR 0 8
10652: PPUSH
10653: LD_INT 2
10655: PPUSH
10656: LD_VAR 0 6
10660: PUSH
10661: LD_INT 2
10663: ARRAY
10664: PUSH
10665: LD_VAR 0 7
10669: PUSH
10670: LD_INT 2
10672: ARRAY
10673: PLUS
10674: PPUSH
10675: CALL_OW 1
10679: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10680: LD_ADDR_VAR 0 8
10684: PUSH
10685: LD_VAR 0 8
10689: PPUSH
10690: LD_INT 3
10692: PPUSH
10693: LD_VAR 0 6
10697: PUSH
10698: LD_INT 3
10700: ARRAY
10701: PUSH
10702: LD_VAR 0 7
10706: PUSH
10707: LD_INT 3
10709: ARRAY
10710: PLUS
10711: PPUSH
10712: CALL_OW 1
10716: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10717: LD_VAR 0 5
10721: PPUSH
10722: LD_INT 1
10724: PPUSH
10725: CALL_OW 275
10729: PUSH
10730: LD_VAR 0 8
10734: PUSH
10735: LD_INT 1
10737: ARRAY
10738: GREATEREQUAL
10739: PUSH
10740: LD_VAR 0 5
10744: PPUSH
10745: LD_INT 3
10747: PPUSH
10748: CALL_OW 275
10752: PUSH
10753: LD_VAR 0 8
10757: PUSH
10758: LD_INT 3
10760: ARRAY
10761: GREATEREQUAL
10762: AND
10763: IFFALSE 10775
// result := true else
10765: LD_ADDR_VAR 0 4
10769: PUSH
10770: LD_INT 1
10772: ST_TO_ADDR
10773: GO 10783
// result := false ;
10775: LD_ADDR_VAR 0 4
10779: PUSH
10780: LD_INT 0
10782: ST_TO_ADDR
// end ;
10783: LD_VAR 0 4
10787: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10788: LD_INT 0
10790: PPUSH
10791: PPUSH
10792: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10793: LD_ADDR_VAR 0 5
10797: PUSH
10798: LD_VAR 0 1
10802: PPUSH
10803: LD_INT 2
10805: PPUSH
10806: EMPTY
10807: PPUSH
10808: CALL 11636 0 3
10812: ST_TO_ADDR
// if unit and plist then
10813: LD_VAR 0 2
10817: PUSH
10818: LD_VAR 0 5
10822: AND
10823: IFFALSE 10884
// for i = 1 to plist do
10825: LD_ADDR_VAR 0 4
10829: PUSH
10830: DOUBLE
10831: LD_INT 1
10833: DEC
10834: ST_TO_ADDR
10835: LD_VAR 0 5
10839: PUSH
10840: FOR_TO
10841: IFFALSE 10882
// if NotTask ( plist [ i ] ) then
10843: LD_VAR 0 5
10847: PUSH
10848: LD_VAR 0 4
10852: ARRAY
10853: PPUSH
10854: CALL 32430 0 1
10858: IFFALSE 10880
// ComDismantle ( plist [ i ] , unit ) ;
10860: LD_VAR 0 5
10864: PUSH
10865: LD_VAR 0 4
10869: ARRAY
10870: PPUSH
10871: LD_VAR 0 2
10875: PPUSH
10876: CALL_OW 167
10880: GO 10840
10882: POP
10883: POP
// result := true ;
10884: LD_ADDR_VAR 0 3
10888: PUSH
10889: LD_INT 1
10891: ST_TO_ADDR
// end ;
10892: LD_VAR 0 3
10896: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10897: LD_INT 0
10899: PPUSH
10900: PPUSH
10901: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10902: LD_ADDR_VAR 0 5
10906: PUSH
10907: LD_VAR 0 1
10911: PPUSH
10912: LD_INT 2
10914: PPUSH
10915: EMPTY
10916: PPUSH
10917: CALL 11636 0 3
10921: ST_TO_ADDR
// if unit and plist then
10922: LD_VAR 0 2
10926: PUSH
10927: LD_VAR 0 5
10931: AND
10932: IFFALSE 10993
// for i = 1 to plist do
10934: LD_ADDR_VAR 0 4
10938: PUSH
10939: DOUBLE
10940: LD_INT 1
10942: DEC
10943: ST_TO_ADDR
10944: LD_VAR 0 5
10948: PUSH
10949: FOR_TO
10950: IFFALSE 10991
// if NotTask ( plist [ i ] ) then
10952: LD_VAR 0 5
10956: PUSH
10957: LD_VAR 0 4
10961: ARRAY
10962: PPUSH
10963: CALL 32430 0 1
10967: IFFALSE 10989
// ComComplete ( plist [ i ] , unit ) ;
10969: LD_VAR 0 5
10973: PUSH
10974: LD_VAR 0 4
10978: ARRAY
10979: PPUSH
10980: LD_VAR 0 2
10984: PPUSH
10985: CALL 31966 0 2
10989: GO 10949
10991: POP
10992: POP
// result := true ;
10993: LD_ADDR_VAR 0 3
10997: PUSH
10998: LD_INT 1
11000: ST_TO_ADDR
// end ;
11001: LD_VAR 0 3
11005: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11006: LD_INT 0
11008: PPUSH
11009: PPUSH
11010: PPUSH
11011: PPUSH
11012: PPUSH
11013: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11014: LD_ADDR_VAR 0 5
11018: PUSH
11019: LD_INT 22
11021: PUSH
11022: LD_VAR 0 1
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: PUSH
11031: LD_INT 21
11033: PUSH
11034: LD_INT 3
11036: PUSH
11037: EMPTY
11038: LIST
11039: LIST
11040: PUSH
11041: LD_INT 3
11043: PUSH
11044: LD_INT 57
11046: PUSH
11047: EMPTY
11048: LIST
11049: PUSH
11050: EMPTY
11051: LIST
11052: LIST
11053: PUSH
11054: LD_INT 3
11056: PUSH
11057: LD_INT 24
11059: PUSH
11060: LD_INT 1000
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: PPUSH
11077: CALL_OW 69
11081: ST_TO_ADDR
// r := [ ] ;
11082: LD_ADDR_VAR 0 6
11086: PUSH
11087: EMPTY
11088: ST_TO_ADDR
// if not tmp then
11089: LD_VAR 0 5
11093: NOT
11094: IFFALSE 11100
// exit else
11096: GO 11288
11098: GO 11268
// begin r := [ tmp [ 1 ] ] ;
11100: LD_ADDR_VAR 0 6
11104: PUSH
11105: LD_VAR 0 5
11109: PUSH
11110: LD_INT 1
11112: ARRAY
11113: PUSH
11114: EMPTY
11115: LIST
11116: ST_TO_ADDR
// for i = 2 to tmp do
11117: LD_ADDR_VAR 0 3
11121: PUSH
11122: DOUBLE
11123: LD_INT 2
11125: DEC
11126: ST_TO_ADDR
11127: LD_VAR 0 5
11131: PUSH
11132: FOR_TO
11133: IFFALSE 11266
// begin m := false ;
11135: LD_ADDR_VAR 0 7
11139: PUSH
11140: LD_INT 0
11142: ST_TO_ADDR
// for j = 1 to r do
11143: LD_ADDR_VAR 0 4
11147: PUSH
11148: DOUBLE
11149: LD_INT 1
11151: DEC
11152: ST_TO_ADDR
11153: LD_VAR 0 6
11157: PUSH
11158: FOR_TO
11159: IFFALSE 11233
// if GetLives ( tmp [ i ] ) < r [ j ] then
11161: LD_VAR 0 5
11165: PUSH
11166: LD_VAR 0 3
11170: ARRAY
11171: PPUSH
11172: CALL_OW 256
11176: PUSH
11177: LD_VAR 0 6
11181: PUSH
11182: LD_VAR 0 4
11186: ARRAY
11187: LESS
11188: IFFALSE 11231
// begin r := Insert ( r , j , tmp [ i ] ) ;
11190: LD_ADDR_VAR 0 6
11194: PUSH
11195: LD_VAR 0 6
11199: PPUSH
11200: LD_VAR 0 4
11204: PPUSH
11205: LD_VAR 0 5
11209: PUSH
11210: LD_VAR 0 3
11214: ARRAY
11215: PPUSH
11216: CALL_OW 2
11220: ST_TO_ADDR
// m := true ;
11221: LD_ADDR_VAR 0 7
11225: PUSH
11226: LD_INT 1
11228: ST_TO_ADDR
// break ;
11229: GO 11233
// end ;
11231: GO 11158
11233: POP
11234: POP
// if not m then
11235: LD_VAR 0 7
11239: NOT
11240: IFFALSE 11264
// r := r ^ tmp [ i ] ;
11242: LD_ADDR_VAR 0 6
11246: PUSH
11247: LD_VAR 0 6
11251: PUSH
11252: LD_VAR 0 5
11256: PUSH
11257: LD_VAR 0 3
11261: ARRAY
11262: ADD
11263: ST_TO_ADDR
// end ;
11264: GO 11132
11266: POP
11267: POP
// end ; if r then
11268: LD_VAR 0 6
11272: IFFALSE 11286
// result := r else
11274: LD_ADDR_VAR 0 2
11278: PUSH
11279: LD_VAR 0 6
11283: ST_TO_ADDR
11284: GO 11288
// exit ;
11286: GO 11288
// end ;
11288: LD_VAR 0 2
11292: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11293: LD_INT 0
11295: PPUSH
11296: PPUSH
11297: PPUSH
11298: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11299: LD_ADDR_VAR 0 5
11303: PUSH
11304: LD_INT 22
11306: PUSH
11307: LD_VAR 0 1
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: PUSH
11316: LD_INT 2
11318: PUSH
11319: LD_INT 25
11321: PUSH
11322: LD_INT 2
11324: PUSH
11325: EMPTY
11326: LIST
11327: LIST
11328: PUSH
11329: LD_INT 25
11331: PUSH
11332: LD_INT 16
11334: PUSH
11335: EMPTY
11336: LIST
11337: LIST
11338: PUSH
11339: LD_INT 34
11341: PUSH
11342: LD_INT 13
11344: PUSH
11345: EMPTY
11346: LIST
11347: LIST
11348: PUSH
11349: LD_INT 34
11351: PUSH
11352: LD_INT 52
11354: PUSH
11355: EMPTY
11356: LIST
11357: LIST
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: PUSH
11366: LD_INT 24
11368: PUSH
11369: LD_INT 650
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: PUSH
11376: EMPTY
11377: LIST
11378: LIST
11379: LIST
11380: PPUSH
11381: CALL_OW 69
11385: ST_TO_ADDR
// p := 1 ;
11386: LD_ADDR_VAR 0 4
11390: PUSH
11391: LD_INT 1
11393: ST_TO_ADDR
// for i = 1 to repairs do
11394: LD_ADDR_VAR 0 3
11398: PUSH
11399: DOUBLE
11400: LD_INT 1
11402: DEC
11403: ST_TO_ADDR
11404: LD_VAR 0 5
11408: PUSH
11409: FOR_TO
11410: IFFALSE 11546
// begin if IsInUnit ( repairs [ i ] ) then
11412: LD_VAR 0 5
11416: PUSH
11417: LD_VAR 0 3
11421: ARRAY
11422: PPUSH
11423: CALL_OW 310
11427: IFFALSE 11446
// ComExitBuilding ( repairs [ i ] ) else
11429: LD_VAR 0 5
11433: PUSH
11434: LD_VAR 0 3
11438: ARRAY
11439: PPUSH
11440: CALL_OW 122
11444: GO 11544
// if not HasTask ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 314
11461: NOT
11462: IFFALSE 11544
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11464: LD_VAR 0 5
11468: PUSH
11469: LD_VAR 0 3
11473: ARRAY
11474: PPUSH
11475: LD_EXP 49
11479: PUSH
11480: LD_VAR 0 1
11484: ARRAY
11485: PUSH
11486: LD_VAR 0 4
11490: ARRAY
11491: PPUSH
11492: CALL_OW 130
// if i mod 3 = 0 then
11496: LD_VAR 0 3
11500: PUSH
11501: LD_INT 3
11503: MOD
11504: PUSH
11505: LD_INT 0
11507: EQUAL
11508: IFFALSE 11524
// p := p + 1 ;
11510: LD_ADDR_VAR 0 4
11514: PUSH
11515: LD_VAR 0 4
11519: PUSH
11520: LD_INT 1
11522: PLUS
11523: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11524: LD_EXP 49
11528: PUSH
11529: LD_VAR 0 1
11533: ARRAY
11534: PUSH
11535: LD_VAR 0 4
11539: LESS
11540: IFFALSE 11544
// break ;
11542: GO 11546
// end ; end ;
11544: GO 11409
11546: POP
11547: POP
// end ; end_of_file
11548: LD_VAR 0 2
11552: RET
// export function MCF_Get ( side , filter ) ; begin
11553: LD_INT 0
11555: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11556: LD_ADDR_VAR 0 3
11560: PUSH
11561: LD_INT 22
11563: PUSH
11564: LD_VAR 0 1
11568: PUSH
11569: EMPTY
11570: LIST
11571: LIST
11572: PUSH
11573: LD_VAR 0 2
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PPUSH
11582: CALL_OW 69
11586: ST_TO_ADDR
// end ;
11587: LD_VAR 0 3
11591: RET
// export function MCF_Lab ( side ) ; begin
11592: LD_INT 0
11594: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11595: LD_ADDR_VAR 0 2
11599: PUSH
11600: LD_INT 22
11602: PUSH
11603: LD_VAR 0 1
11607: PUSH
11608: EMPTY
11609: LIST
11610: LIST
11611: PUSH
11612: LD_INT 30
11614: PUSH
11615: LD_INT 8
11617: PUSH
11618: EMPTY
11619: LIST
11620: LIST
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PPUSH
11626: CALL_OW 69
11630: ST_TO_ADDR
// end ;
11631: LD_VAR 0 2
11635: RET
// export function MCF_Class ( side , class , filter ) ; begin
11636: LD_INT 0
11638: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11639: LD_ADDR_VAR 0 4
11643: PUSH
11644: LD_INT 22
11646: PUSH
11647: LD_VAR 0 1
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: LD_INT 25
11658: PUSH
11659: LD_VAR 0 2
11663: PUSH
11664: EMPTY
11665: LIST
11666: LIST
11667: PUSH
11668: LD_VAR 0 3
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: LIST
11677: PPUSH
11678: CALL_OW 69
11682: ST_TO_ADDR
// end ;
11683: LD_VAR 0 4
11687: RET
// export function MCF_All ( side , filter ) ; begin
11688: LD_INT 0
11690: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11691: LD_ADDR_VAR 0 3
11695: PUSH
11696: LD_INT 22
11698: PUSH
11699: LD_VAR 0 1
11703: PUSH
11704: EMPTY
11705: LIST
11706: LIST
11707: PUSH
11708: LD_INT 2
11710: PUSH
11711: LD_INT 25
11713: PUSH
11714: LD_INT 1
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: PUSH
11721: LD_INT 25
11723: PUSH
11724: LD_INT 2
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: PUSH
11731: LD_INT 25
11733: PUSH
11734: LD_INT 3
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 25
11743: PUSH
11744: LD_INT 4
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: PUSH
11758: LD_VAR 0 2
11762: PUSH
11763: EMPTY
11764: LIST
11765: LIST
11766: LIST
11767: PPUSH
11768: CALL_OW 69
11772: ST_TO_ADDR
// end ;
11773: LD_VAR 0 3
11777: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11778: LD_INT 0
11780: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11781: LD_ADDR_VAR 0 4
11785: PUSH
11786: LD_INT 22
11788: PUSH
11789: LD_VAR 0 1
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: PUSH
11798: LD_INT 92
11800: PUSH
11801: LD_VAR 0 2
11805: PUSH
11806: LD_INT 1
11808: ARRAY
11809: PUSH
11810: LD_VAR 0 2
11814: PUSH
11815: LD_INT 2
11817: ARRAY
11818: PUSH
11819: LD_VAR 0 2
11823: PUSH
11824: LD_INT 3
11826: ARRAY
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: PUSH
11834: LD_VAR 0 3
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: LIST
11843: PPUSH
11844: CALL_OW 69
11848: ST_TO_ADDR
// end ;
11849: LD_VAR 0 4
11853: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11854: LD_INT 0
11856: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11857: LD_ADDR_VAR 0 3
11861: PUSH
11862: LD_INT 22
11864: PUSH
11865: LD_VAR 0 1
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: LD_INT 21
11876: PUSH
11877: LD_INT 2
11879: PUSH
11880: EMPTY
11881: LIST
11882: LIST
11883: PUSH
11884: LD_VAR 0 2
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: LIST
11893: PPUSH
11894: CALL_OW 69
11898: ST_TO_ADDR
// end ;
11899: LD_VAR 0 3
11903: RET
// export function MCF_Cargo ( side ) ; begin
11904: LD_INT 0
11906: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11907: LD_ADDR_VAR 0 2
11911: PUSH
11912: LD_VAR 0 1
11916: PPUSH
11917: LD_INT 2
11919: PUSH
11920: LD_INT 34
11922: PUSH
11923: LD_INT 12
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: PUSH
11930: LD_INT 34
11932: PUSH
11933: LD_INT 32
11935: PUSH
11936: EMPTY
11937: LIST
11938: LIST
11939: PUSH
11940: LD_INT 34
11942: PUSH
11943: LD_INT 51
11945: PUSH
11946: EMPTY
11947: LIST
11948: LIST
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: LIST
11954: LIST
11955: PPUSH
11956: CALL 11854 0 2
11960: ST_TO_ADDR
// end ;
11961: LD_VAR 0 2
11965: RET
// export function MCF_Ape ( side ) ; begin
11966: LD_INT 0
11968: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
11969: LD_ADDR_VAR 0 2
11973: PUSH
11974: LD_INT 22
11976: PUSH
11977: LD_VAR 0 1
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 2
11988: PUSH
11989: LD_INT 25
11991: PUSH
11992: LD_INT 12
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: LD_INT 25
12001: PUSH
12002: LD_INT 15
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PUSH
12009: LD_INT 25
12011: PUSH
12012: LD_INT 16
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: PUSH
12019: LD_INT 25
12021: PUSH
12022: LD_INT 17
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PPUSH
12040: CALL_OW 69
12044: ST_TO_ADDR
// end ;
12045: LD_VAR 0 2
12049: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12050: LD_INT 0
12052: PPUSH
12053: PPUSH
12054: PPUSH
12055: PPUSH
// result := [ ] ;
12056: LD_ADDR_VAR 0 3
12060: PUSH
12061: EMPTY
12062: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12063: LD_ADDR_VAR 0 4
12067: PUSH
12068: LD_VAR 0 1
12072: PPUSH
12073: CALL 11966 0 1
12077: ST_TO_ADDR
// case type of 0 , normal :
12078: LD_VAR 0 2
12082: PUSH
12083: LD_INT 0
12085: DOUBLE
12086: EQUAL
12087: IFTRUE 12097
12089: LD_STRING normal
12091: DOUBLE
12092: EQUAL
12093: IFTRUE 12097
12095: GO 12108
12097: POP
// cl := class_apeman ; 1 , soldier :
12098: LD_ADDR_VAR 0 5
12102: PUSH
12103: LD_INT 12
12105: ST_TO_ADDR
12106: GO 12184
12108: LD_INT 1
12110: DOUBLE
12111: EQUAL
12112: IFTRUE 12122
12114: LD_STRING soldier
12116: DOUBLE
12117: EQUAL
12118: IFTRUE 12122
12120: GO 12133
12122: POP
// cl := class_apeman_soldier ; 2 , engineer :
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_INT 15
12130: ST_TO_ADDR
12131: GO 12184
12133: LD_INT 2
12135: DOUBLE
12136: EQUAL
12137: IFTRUE 12147
12139: LD_STRING engineer
12141: DOUBLE
12142: EQUAL
12143: IFTRUE 12147
12145: GO 12158
12147: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12148: LD_ADDR_VAR 0 5
12152: PUSH
12153: LD_INT 16
12155: ST_TO_ADDR
12156: GO 12184
12158: LD_INT 3
12160: DOUBLE
12161: EQUAL
12162: IFTRUE 12172
12164: LD_STRING kamikaze
12166: DOUBLE
12167: EQUAL
12168: IFTRUE 12172
12170: GO 12183
12172: POP
// cl := class_apeman_kamikaze ; end ;
12173: LD_ADDR_VAR 0 5
12177: PUSH
12178: LD_INT 17
12180: ST_TO_ADDR
12181: GO 12184
12183: POP
// for i = 1 to tmp do
12184: LD_ADDR_VAR 0 6
12188: PUSH
12189: DOUBLE
12190: LD_INT 1
12192: DEC
12193: ST_TO_ADDR
12194: LD_VAR 0 4
12198: PUSH
12199: FOR_TO
12200: IFFALSE 12249
// if GetClass ( tmp [ i ] ) = cl then
12202: LD_VAR 0 4
12206: PUSH
12207: LD_VAR 0 6
12211: ARRAY
12212: PPUSH
12213: CALL_OW 257
12217: PUSH
12218: LD_VAR 0 5
12222: EQUAL
12223: IFFALSE 12247
// result := result ^ tmp [ i ] ;
12225: LD_ADDR_VAR 0 3
12229: PUSH
12230: LD_VAR 0 3
12234: PUSH
12235: LD_VAR 0 4
12239: PUSH
12240: LD_VAR 0 6
12244: ARRAY
12245: ADD
12246: ST_TO_ADDR
12247: GO 12199
12249: POP
12250: POP
// end ;
12251: LD_VAR 0 3
12255: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
12261: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 22
12269: PUSH
12270: LD_VAR 0 1
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: PUSH
12279: LD_VAR 0 3
12283: PUSH
12284: EMPTY
12285: LIST
12286: LIST
12287: PPUSH
12288: CALL_OW 69
12292: ST_TO_ADDR
// r := [ ] ;
12293: LD_ADDR_VAR 0 6
12297: PUSH
12298: EMPTY
12299: ST_TO_ADDR
// if tmp then
12300: LD_VAR 0 5
12304: IFFALSE 12373
// for i = 1 to tmp do
12306: LD_ADDR_VAR 0 7
12310: PUSH
12311: DOUBLE
12312: LD_INT 1
12314: DEC
12315: ST_TO_ADDR
12316: LD_VAR 0 5
12320: PUSH
12321: FOR_TO
12322: IFFALSE 12371
// if GetTag ( tmp [ i ] ) = tag then
12324: LD_VAR 0 5
12328: PUSH
12329: LD_VAR 0 7
12333: ARRAY
12334: PPUSH
12335: CALL_OW 110
12339: PUSH
12340: LD_VAR 0 2
12344: EQUAL
12345: IFFALSE 12369
// r := r ^ tmp [ i ] ;
12347: LD_ADDR_VAR 0 6
12351: PUSH
12352: LD_VAR 0 6
12356: PUSH
12357: LD_VAR 0 5
12361: PUSH
12362: LD_VAR 0 7
12366: ARRAY
12367: ADD
12368: ST_TO_ADDR
12369: GO 12321
12371: POP
12372: POP
// result := r ;
12373: LD_ADDR_VAR 0 4
12377: PUSH
12378: LD_VAR 0 6
12382: ST_TO_ADDR
// end ;
12383: LD_VAR 0 4
12387: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12388: LD_INT 0
12390: PPUSH
12391: PPUSH
12392: PPUSH
// tmp := plist ;
12393: LD_ADDR_VAR 0 5
12397: PUSH
12398: LD_VAR 0 2
12402: ST_TO_ADDR
// if tmp then
12403: LD_VAR 0 5
12407: IFFALSE 12484
// begin for i = 1 to tmp do
12409: LD_ADDR_VAR 0 6
12413: PUSH
12414: DOUBLE
12415: LD_INT 1
12417: DEC
12418: ST_TO_ADDR
12419: LD_VAR 0 5
12423: PUSH
12424: FOR_TO
12425: IFFALSE 12472
// if GetTag ( tmp [ i ] ) <> tag then
12427: LD_VAR 0 5
12431: PUSH
12432: LD_VAR 0 6
12436: ARRAY
12437: PPUSH
12438: CALL_OW 110
12442: PUSH
12443: LD_VAR 0 3
12447: NONEQUAL
12448: IFFALSE 12470
// SetTag ( tmp [ i ] , tag ) ;
12450: LD_VAR 0 5
12454: PUSH
12455: LD_VAR 0 6
12459: ARRAY
12460: PPUSH
12461: LD_VAR 0 3
12465: PPUSH
12466: CALL_OW 109
12470: GO 12424
12472: POP
12473: POP
// result := true ;
12474: LD_ADDR_VAR 0 4
12478: PUSH
12479: LD_INT 1
12481: ST_TO_ADDR
// end else
12482: GO 12492
// result := false ;
12484: LD_ADDR_VAR 0 4
12488: PUSH
12489: LD_INT 0
12491: ST_TO_ADDR
// end ;
12492: LD_VAR 0 4
12496: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12497: LD_INT 0
12499: PPUSH
12500: PPUSH
12501: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12502: LD_ADDR_VAR 0 4
12506: PUSH
12507: LD_VAR 0 1
12511: PPUSH
12512: LD_VAR 0 2
12516: PPUSH
12517: EMPTY
12518: PPUSH
12519: CALL 12256 0 3
12523: ST_TO_ADDR
// if tmp then
12524: LD_VAR 0 4
12528: IFFALSE 12580
// begin for i = 1 to tmp do
12530: LD_ADDR_VAR 0 5
12534: PUSH
12535: DOUBLE
12536: LD_INT 1
12538: DEC
12539: ST_TO_ADDR
12540: LD_VAR 0 4
12544: PUSH
12545: FOR_TO
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , 0 ) ;
12548: LD_VAR 0 4
12552: PUSH
12553: LD_VAR 0 5
12557: ARRAY
12558: PPUSH
12559: LD_INT 0
12561: PPUSH
12562: CALL_OW 109
12566: GO 12545
12568: POP
12569: POP
// result := true ;
12570: LD_ADDR_VAR 0 3
12574: PUSH
12575: LD_INT 1
12577: ST_TO_ADDR
// end else
12578: GO 12588
// result := false ;
12580: LD_ADDR_VAR 0 3
12584: PUSH
12585: LD_INT 0
12587: ST_TO_ADDR
// end ;
12588: LD_VAR 0 3
12592: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12593: LD_INT 0
12595: PPUSH
12596: PPUSH
12597: PPUSH
12598: PPUSH
12599: PPUSH
// sort_list := [ ] ;
12600: LD_ADDR_VAR 0 5
12604: PUSH
12605: EMPTY
12606: ST_TO_ADDR
// for i = 1 to list do
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: DOUBLE
12613: LD_INT 1
12615: DEC
12616: ST_TO_ADDR
12617: LD_VAR 0 1
12621: PUSH
12622: FOR_TO
12623: IFFALSE 12785
// begin if i = 1 then
12625: LD_VAR 0 3
12629: PUSH
12630: LD_INT 1
12632: EQUAL
12633: IFFALSE 12659
// sort_list := sort_list ^ list [ i ] else
12635: LD_ADDR_VAR 0 5
12639: PUSH
12640: LD_VAR 0 5
12644: PUSH
12645: LD_VAR 0 1
12649: PUSH
12650: LD_VAR 0 3
12654: ARRAY
12655: ADD
12656: ST_TO_ADDR
12657: GO 12783
// begin for j = 1 to sort_list do
12659: LD_ADDR_VAR 0 4
12663: PUSH
12664: DOUBLE
12665: LD_INT 1
12667: DEC
12668: ST_TO_ADDR
12669: LD_VAR 0 5
12673: PUSH
12674: FOR_TO
12675: IFFALSE 12752
// begin add := false ;
12677: LD_ADDR_VAR 0 6
12681: PUSH
12682: LD_INT 0
12684: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12685: LD_VAR 0 1
12689: PUSH
12690: LD_VAR 0 3
12694: ARRAY
12695: PUSH
12696: LD_VAR 0 5
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: LESS
12707: IFFALSE 12750
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12709: LD_ADDR_VAR 0 5
12713: PUSH
12714: LD_VAR 0 5
12718: PPUSH
12719: LD_VAR 0 4
12723: PPUSH
12724: LD_VAR 0 1
12728: PUSH
12729: LD_VAR 0 3
12733: ARRAY
12734: PPUSH
12735: CALL_OW 2
12739: ST_TO_ADDR
// add := true ;
12740: LD_ADDR_VAR 0 6
12744: PUSH
12745: LD_INT 1
12747: ST_TO_ADDR
// break ;
12748: GO 12752
// end ; end ;
12750: GO 12674
12752: POP
12753: POP
// if not add then
12754: LD_VAR 0 6
12758: NOT
12759: IFFALSE 12783
// sort_list := sort_list ^ list [ i ] ;
12761: LD_ADDR_VAR 0 5
12765: PUSH
12766: LD_VAR 0 5
12770: PUSH
12771: LD_VAR 0 1
12775: PUSH
12776: LD_VAR 0 3
12780: ARRAY
12781: ADD
12782: ST_TO_ADDR
// end ; end ;
12783: GO 12622
12785: POP
12786: POP
// result := sort_list ;
12787: LD_ADDR_VAR 0 2
12791: PUSH
12792: LD_VAR 0 5
12796: ST_TO_ADDR
// end ;
12797: LD_VAR 0 2
12801: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12802: LD_INT 0
12804: PPUSH
12805: PPUSH
12806: PPUSH
12807: PPUSH
12808: PPUSH
// sort_list := [ ] ;
12809: LD_ADDR_VAR 0 5
12813: PUSH
12814: EMPTY
12815: ST_TO_ADDR
// for i = 1 to list do
12816: LD_ADDR_VAR 0 3
12820: PUSH
12821: DOUBLE
12822: LD_INT 1
12824: DEC
12825: ST_TO_ADDR
12826: LD_VAR 0 1
12830: PUSH
12831: FOR_TO
12832: IFFALSE 12994
// begin if i = 1 then
12834: LD_VAR 0 3
12838: PUSH
12839: LD_INT 1
12841: EQUAL
12842: IFFALSE 12868
// sort_list := sort_list ^ list [ i ] else
12844: LD_ADDR_VAR 0 5
12848: PUSH
12849: LD_VAR 0 5
12853: PUSH
12854: LD_VAR 0 1
12858: PUSH
12859: LD_VAR 0 3
12863: ARRAY
12864: ADD
12865: ST_TO_ADDR
12866: GO 12992
// begin for j = 1 to sort_list do
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_VAR 0 5
12882: PUSH
12883: FOR_TO
12884: IFFALSE 12961
// begin add := false ;
12886: LD_ADDR_VAR 0 6
12890: PUSH
12891: LD_INT 0
12893: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12894: LD_VAR 0 1
12898: PUSH
12899: LD_VAR 0 3
12903: ARRAY
12904: PUSH
12905: LD_VAR 0 5
12909: PUSH
12910: LD_VAR 0 4
12914: ARRAY
12915: GREATER
12916: IFFALSE 12959
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12918: LD_ADDR_VAR 0 5
12922: PUSH
12923: LD_VAR 0 5
12927: PPUSH
12928: LD_VAR 0 4
12932: PPUSH
12933: LD_VAR 0 1
12937: PUSH
12938: LD_VAR 0 3
12942: ARRAY
12943: PPUSH
12944: CALL_OW 2
12948: ST_TO_ADDR
// add := true ;
12949: LD_ADDR_VAR 0 6
12953: PUSH
12954: LD_INT 1
12956: ST_TO_ADDR
// break ;
12957: GO 12961
// end ; end ;
12959: GO 12883
12961: POP
12962: POP
// if not add then
12963: LD_VAR 0 6
12967: NOT
12968: IFFALSE 12992
// sort_list := sort_list ^ list [ i ] ;
12970: LD_ADDR_VAR 0 5
12974: PUSH
12975: LD_VAR 0 5
12979: PUSH
12980: LD_VAR 0 1
12984: PUSH
12985: LD_VAR 0 3
12989: ARRAY
12990: ADD
12991: ST_TO_ADDR
// end ; end ;
12992: GO 12831
12994: POP
12995: POP
// result := sort_list ;
12996: LD_ADDR_VAR 0 2
13000: PUSH
13001: LD_VAR 0 5
13005: ST_TO_ADDR
// end ;
13006: LD_VAR 0 2
13010: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13011: LD_INT 0
13013: PPUSH
13014: PPUSH
13015: PPUSH
13016: PPUSH
13017: PPUSH
13018: PPUSH
// tmp := [ ] ;
13019: LD_ADDR_VAR 0 8
13023: PUSH
13024: EMPTY
13025: ST_TO_ADDR
// r := [ ] ;
13026: LD_ADDR_VAR 0 7
13030: PUSH
13031: EMPTY
13032: ST_TO_ADDR
// add := false ;
13033: LD_ADDR_VAR 0 9
13037: PUSH
13038: LD_INT 0
13040: ST_TO_ADDR
// if plist then
13041: LD_VAR 0 2
13045: IFFALSE 13121
// begin for i = 1 to plist do
13047: LD_ADDR_VAR 0 5
13051: PUSH
13052: DOUBLE
13053: LD_INT 1
13055: DEC
13056: ST_TO_ADDR
13057: LD_VAR 0 2
13061: PUSH
13062: FOR_TO
13063: IFFALSE 13117
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13065: LD_ADDR_VAR 0 8
13069: PUSH
13070: LD_VAR 0 8
13074: PUSH
13075: LD_VAR 0 2
13079: PUSH
13080: LD_VAR 0 5
13084: ARRAY
13085: PUSH
13086: LD_VAR 0 2
13090: PUSH
13091: LD_VAR 0 5
13095: ARRAY
13096: PPUSH
13097: LD_VAR 0 3
13101: PPUSH
13102: CALL_OW 259
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: PUSH
13111: EMPTY
13112: LIST
13113: ADD
13114: ST_TO_ADDR
// end ;
13115: GO 13062
13117: POP
13118: POP
// end else
13119: GO 13129
// result := false ;
13121: LD_ADDR_VAR 0 4
13125: PUSH
13126: LD_INT 0
13128: ST_TO_ADDR
// if tmp then
13129: LD_VAR 0 8
13133: IFFALSE 13307
// begin r := r ^ [ tmp [ 1 ] ] ;
13135: LD_ADDR_VAR 0 7
13139: PUSH
13140: LD_VAR 0 7
13144: PUSH
13145: LD_VAR 0 8
13149: PUSH
13150: LD_INT 1
13152: ARRAY
13153: PUSH
13154: EMPTY
13155: LIST
13156: ADD
13157: ST_TO_ADDR
// for i = 2 to tmp do
13158: LD_ADDR_VAR 0 5
13162: PUSH
13163: DOUBLE
13164: LD_INT 2
13166: DEC
13167: ST_TO_ADDR
13168: LD_VAR 0 8
13172: PUSH
13173: FOR_TO
13174: IFFALSE 13305
// begin for j = 1 to r do
13176: LD_ADDR_VAR 0 6
13180: PUSH
13181: DOUBLE
13182: LD_INT 1
13184: DEC
13185: ST_TO_ADDR
13186: LD_VAR 0 7
13190: PUSH
13191: FOR_TO
13192: IFFALSE 13269
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13194: LD_VAR 0 8
13198: PUSH
13199: LD_VAR 0 5
13203: ARRAY
13204: PUSH
13205: LD_INT 2
13207: ARRAY
13208: PUSH
13209: LD_VAR 0 7
13213: PUSH
13214: LD_VAR 0 6
13218: ARRAY
13219: PUSH
13220: LD_INT 2
13222: ARRAY
13223: LESS
13224: IFFALSE 13267
// begin r := Insert ( r , j , tmp [ i ] ) ;
13226: LD_ADDR_VAR 0 7
13230: PUSH
13231: LD_VAR 0 7
13235: PPUSH
13236: LD_VAR 0 6
13240: PPUSH
13241: LD_VAR 0 8
13245: PUSH
13246: LD_VAR 0 5
13250: ARRAY
13251: PPUSH
13252: CALL_OW 2
13256: ST_TO_ADDR
// add := true ;
13257: LD_ADDR_VAR 0 9
13261: PUSH
13262: LD_INT 1
13264: ST_TO_ADDR
// break ;
13265: GO 13269
// end ; end ;
13267: GO 13191
13269: POP
13270: POP
// if not add then
13271: LD_VAR 0 9
13275: NOT
13276: IFFALSE 13303
// r := r ^ [ tmp [ i ] ] ;
13278: LD_ADDR_VAR 0 7
13282: PUSH
13283: LD_VAR 0 7
13287: PUSH
13288: LD_VAR 0 8
13292: PUSH
13293: LD_VAR 0 5
13297: ARRAY
13298: PUSH
13299: EMPTY
13300: LIST
13301: ADD
13302: ST_TO_ADDR
// end ;
13303: GO 13173
13305: POP
13306: POP
// end ; result := r ;
13307: LD_ADDR_VAR 0 4
13311: PUSH
13312: LD_VAR 0 7
13316: ST_TO_ADDR
// end ;
13317: LD_VAR 0 4
13321: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13322: LD_INT 0
13324: PPUSH
13325: PPUSH
13326: PPUSH
13327: PPUSH
13328: PPUSH
13329: PPUSH
// tmp := [ ] ;
13330: LD_ADDR_VAR 0 8
13334: PUSH
13335: EMPTY
13336: ST_TO_ADDR
// r := [ ] ;
13337: LD_ADDR_VAR 0 7
13341: PUSH
13342: EMPTY
13343: ST_TO_ADDR
// add := false ;
13344: LD_ADDR_VAR 0 9
13348: PUSH
13349: LD_INT 0
13351: ST_TO_ADDR
// if plist then
13352: LD_VAR 0 2
13356: IFFALSE 13432
// begin for i = 1 to plist do
13358: LD_ADDR_VAR 0 5
13362: PUSH
13363: DOUBLE
13364: LD_INT 1
13366: DEC
13367: ST_TO_ADDR
13368: LD_VAR 0 2
13372: PUSH
13373: FOR_TO
13374: IFFALSE 13428
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13376: LD_ADDR_VAR 0 8
13380: PUSH
13381: LD_VAR 0 8
13385: PUSH
13386: LD_VAR 0 2
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: LD_VAR 0 2
13401: PUSH
13402: LD_VAR 0 5
13406: ARRAY
13407: PPUSH
13408: LD_VAR 0 3
13412: PPUSH
13413: CALL_OW 259
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: EMPTY
13423: LIST
13424: ADD
13425: ST_TO_ADDR
// end ;
13426: GO 13373
13428: POP
13429: POP
// end else
13430: GO 13440
// result := false ;
13432: LD_ADDR_VAR 0 4
13436: PUSH
13437: LD_INT 0
13439: ST_TO_ADDR
// if tmp then
13440: LD_VAR 0 8
13444: IFFALSE 13618
// begin r := r ^ [ tmp [ 1 ] ] ;
13446: LD_ADDR_VAR 0 7
13450: PUSH
13451: LD_VAR 0 7
13455: PUSH
13456: LD_VAR 0 8
13460: PUSH
13461: LD_INT 1
13463: ARRAY
13464: PUSH
13465: EMPTY
13466: LIST
13467: ADD
13468: ST_TO_ADDR
// for i = 2 to tmp do
13469: LD_ADDR_VAR 0 5
13473: PUSH
13474: DOUBLE
13475: LD_INT 2
13477: DEC
13478: ST_TO_ADDR
13479: LD_VAR 0 8
13483: PUSH
13484: FOR_TO
13485: IFFALSE 13616
// begin for j = 1 to r do
13487: LD_ADDR_VAR 0 6
13491: PUSH
13492: DOUBLE
13493: LD_INT 1
13495: DEC
13496: ST_TO_ADDR
13497: LD_VAR 0 7
13501: PUSH
13502: FOR_TO
13503: IFFALSE 13580
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13505: LD_VAR 0 8
13509: PUSH
13510: LD_VAR 0 5
13514: ARRAY
13515: PUSH
13516: LD_INT 2
13518: ARRAY
13519: PUSH
13520: LD_VAR 0 7
13524: PUSH
13525: LD_VAR 0 6
13529: ARRAY
13530: PUSH
13531: LD_INT 2
13533: ARRAY
13534: GREATER
13535: IFFALSE 13578
// begin r := Insert ( r , j , tmp [ i ] ) ;
13537: LD_ADDR_VAR 0 7
13541: PUSH
13542: LD_VAR 0 7
13546: PPUSH
13547: LD_VAR 0 6
13551: PPUSH
13552: LD_VAR 0 8
13556: PUSH
13557: LD_VAR 0 5
13561: ARRAY
13562: PPUSH
13563: CALL_OW 2
13567: ST_TO_ADDR
// add := true ;
13568: LD_ADDR_VAR 0 9
13572: PUSH
13573: LD_INT 1
13575: ST_TO_ADDR
// break ;
13576: GO 13580
// end ; end ;
13578: GO 13502
13580: POP
13581: POP
// if not add then
13582: LD_VAR 0 9
13586: NOT
13587: IFFALSE 13614
// r := r ^ [ tmp [ i ] ] ;
13589: LD_ADDR_VAR 0 7
13593: PUSH
13594: LD_VAR 0 7
13598: PUSH
13599: LD_VAR 0 8
13603: PUSH
13604: LD_VAR 0 5
13608: ARRAY
13609: PUSH
13610: EMPTY
13611: LIST
13612: ADD
13613: ST_TO_ADDR
// end ;
13614: GO 13484
13616: POP
13617: POP
// end ; result := r ;
13618: LD_ADDR_VAR 0 4
13622: PUSH
13623: LD_VAR 0 7
13627: ST_TO_ADDR
// end ;
13628: LD_VAR 0 4
13632: RET
// export function MCF_Clear ( side ) ; var i ; begin
13633: LD_INT 0
13635: PPUSH
13636: PPUSH
// for i = 1 to 100 do
13637: LD_ADDR_VAR 0 3
13641: PUSH
13642: DOUBLE
13643: LD_INT 1
13645: DEC
13646: ST_TO_ADDR
13647: LD_INT 100
13649: PUSH
13650: FOR_TO
13651: IFFALSE 13687
// if MCF_Tag ( side , i , [ ] ) then
13653: LD_VAR 0 1
13657: PPUSH
13658: LD_VAR 0 3
13662: PPUSH
13663: EMPTY
13664: PPUSH
13665: CALL 12256 0 3
13669: IFFALSE 13685
// MCF_ClearTag ( side , i ) ;
13671: LD_VAR 0 1
13675: PPUSH
13676: LD_VAR 0 3
13680: PPUSH
13681: CALL 12497 0 2
13685: GO 13650
13687: POP
13688: POP
// result := true ;
13689: LD_ADDR_VAR 0 2
13693: PUSH
13694: LD_INT 1
13696: ST_TO_ADDR
// end ;
13697: LD_VAR 0 2
13701: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13702: LD_INT 0
13704: PPUSH
13705: PPUSH
13706: PPUSH
// for i = 1 to plist do
13707: LD_ADDR_VAR 0 4
13711: PUSH
13712: DOUBLE
13713: LD_INT 1
13715: DEC
13716: ST_TO_ADDR
13717: LD_VAR 0 1
13721: PUSH
13722: FOR_TO
13723: IFFALSE 13772
// if MCF_HasClass ( plist [ i ] ) = n then
13725: LD_VAR 0 1
13729: PUSH
13730: LD_VAR 0 4
13734: ARRAY
13735: PPUSH
13736: CALL 14259 0 1
13740: PUSH
13741: LD_VAR 0 2
13745: EQUAL
13746: IFFALSE 13770
// tmp := tmp ^ plist [ i ] ;
13748: LD_ADDR_VAR 0 5
13752: PUSH
13753: LD_VAR 0 5
13757: PUSH
13758: LD_VAR 0 1
13762: PUSH
13763: LD_VAR 0 4
13767: ARRAY
13768: ADD
13769: ST_TO_ADDR
13770: GO 13722
13772: POP
13773: POP
// result := tmp ;
13774: LD_ADDR_VAR 0 3
13778: PUSH
13779: LD_VAR 0 5
13783: ST_TO_ADDR
// end ;
13784: LD_VAR 0 3
13788: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13789: LD_INT 0
13791: PPUSH
13792: PPUSH
13793: PPUSH
// if mreg = ToArm then
13794: LD_VAR 0 2
13798: PUSH
13799: LD_STRING ToArm
13801: EQUAL
13802: IFFALSE 13907
// begin tmp := MREG_ToArm [ side ] ;
13804: LD_ADDR_VAR 0 6
13808: PUSH
13809: LD_EXP 58
13813: PUSH
13814: LD_VAR 0 1
13818: ARRAY
13819: ST_TO_ADDR
// if tmp = 0 then
13820: LD_VAR 0 6
13824: PUSH
13825: LD_INT 0
13827: EQUAL
13828: IFFALSE 13834
// exit else
13830: GO 14254
13832: GO 13907
// begin for i = MREG_ToArm [ side ] downto n do
13834: LD_ADDR_VAR 0 5
13838: PUSH
13839: DOUBLE
13840: LD_EXP 58
13844: PUSH
13845: LD_VAR 0 1
13849: ARRAY
13850: INC
13851: ST_TO_ADDR
13852: LD_VAR 0 3
13856: PUSH
13857: FOR_DOWNTO
13858: IFFALSE 13880
// tmp := Delete ( tmp , 1 ) ;
13860: LD_ADDR_VAR 0 6
13864: PUSH
13865: LD_VAR 0 6
13869: PPUSH
13870: LD_INT 1
13872: PPUSH
13873: CALL_OW 3
13877: ST_TO_ADDR
13878: GO 13857
13880: POP
13881: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13882: LD_ADDR_EXP 58
13886: PUSH
13887: LD_EXP 58
13891: PPUSH
13892: LD_VAR 0 1
13896: PPUSH
13897: LD_VAR 0 6
13901: PPUSH
13902: CALL_OW 1
13906: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13907: LD_VAR 0 2
13911: PUSH
13912: LD_STRING ToDep
13914: EQUAL
13915: IFFALSE 14020
// begin tmp := MREG_ToDep [ side ] ;
13917: LD_ADDR_VAR 0 6
13921: PUSH
13922: LD_EXP 59
13926: PUSH
13927: LD_VAR 0 1
13931: ARRAY
13932: ST_TO_ADDR
// if tmp = 0 then
13933: LD_VAR 0 6
13937: PUSH
13938: LD_INT 0
13940: EQUAL
13941: IFFALSE 13947
// exit else
13943: GO 14254
13945: GO 14020
// begin for i = MREG_ToDep [ side ] downto n do
13947: LD_ADDR_VAR 0 5
13951: PUSH
13952: DOUBLE
13953: LD_EXP 59
13957: PUSH
13958: LD_VAR 0 1
13962: ARRAY
13963: INC
13964: ST_TO_ADDR
13965: LD_VAR 0 3
13969: PUSH
13970: FOR_DOWNTO
13971: IFFALSE 13993
// tmp := Delete ( tmp , 1 ) ;
13973: LD_ADDR_VAR 0 6
13977: PUSH
13978: LD_VAR 0 6
13982: PPUSH
13983: LD_INT 1
13985: PPUSH
13986: CALL_OW 3
13990: ST_TO_ADDR
13991: GO 13970
13993: POP
13994: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
13995: LD_ADDR_EXP 59
13999: PUSH
14000: LD_EXP 59
14004: PPUSH
14005: LD_VAR 0 1
14009: PPUSH
14010: LD_VAR 0 6
14014: PPUSH
14015: CALL_OW 1
14019: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14020: LD_VAR 0 2
14024: PUSH
14025: LD_STRING ToFac
14027: EQUAL
14028: IFFALSE 14133
// begin tmp := MREG_ToFac [ side ] ;
14030: LD_ADDR_VAR 0 6
14034: PUSH
14035: LD_EXP 57
14039: PUSH
14040: LD_VAR 0 1
14044: ARRAY
14045: ST_TO_ADDR
// if tmp = 0 then
14046: LD_VAR 0 6
14050: PUSH
14051: LD_INT 0
14053: EQUAL
14054: IFFALSE 14060
// exit else
14056: GO 14254
14058: GO 14133
// begin for i = MREG_ToFac [ side ] downto n do
14060: LD_ADDR_VAR 0 5
14064: PUSH
14065: DOUBLE
14066: LD_EXP 57
14070: PUSH
14071: LD_VAR 0 1
14075: ARRAY
14076: INC
14077: ST_TO_ADDR
14078: LD_VAR 0 3
14082: PUSH
14083: FOR_DOWNTO
14084: IFFALSE 14106
// tmp := Delete ( tmp , 1 ) ;
14086: LD_ADDR_VAR 0 6
14090: PUSH
14091: LD_VAR 0 6
14095: PPUSH
14096: LD_INT 1
14098: PPUSH
14099: CALL_OW 3
14103: ST_TO_ADDR
14104: GO 14083
14106: POP
14107: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14108: LD_ADDR_EXP 57
14112: PUSH
14113: LD_EXP 57
14117: PPUSH
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_VAR 0 6
14127: PPUSH
14128: CALL_OW 1
14132: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14133: LD_VAR 0 2
14137: PUSH
14138: LD_STRING ToLab
14140: EQUAL
14141: IFFALSE 14246
// begin tmp := MREG_ToLab [ side ] ;
14143: LD_ADDR_VAR 0 6
14147: PUSH
14148: LD_EXP 56
14152: PUSH
14153: LD_VAR 0 1
14157: ARRAY
14158: ST_TO_ADDR
// if tmp = 0 then
14159: LD_VAR 0 6
14163: PUSH
14164: LD_INT 0
14166: EQUAL
14167: IFFALSE 14173
// exit else
14169: GO 14254
14171: GO 14246
// begin for i = MREG_ToLab [ side ] downto n do
14173: LD_ADDR_VAR 0 5
14177: PUSH
14178: DOUBLE
14179: LD_EXP 56
14183: PUSH
14184: LD_VAR 0 1
14188: ARRAY
14189: INC
14190: ST_TO_ADDR
14191: LD_VAR 0 3
14195: PUSH
14196: FOR_DOWNTO
14197: IFFALSE 14219
// tmp := Delete ( tmp , 1 ) ;
14199: LD_ADDR_VAR 0 6
14203: PUSH
14204: LD_VAR 0 6
14208: PPUSH
14209: LD_INT 1
14211: PPUSH
14212: CALL_OW 3
14216: ST_TO_ADDR
14217: GO 14196
14219: POP
14220: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14221: LD_ADDR_EXP 56
14225: PUSH
14226: LD_EXP 56
14230: PPUSH
14231: LD_VAR 0 1
14235: PPUSH
14236: LD_VAR 0 6
14240: PPUSH
14241: CALL_OW 1
14245: ST_TO_ADDR
// end ; end ; result := true ;
14246: LD_ADDR_VAR 0 4
14250: PUSH
14251: LD_INT 1
14253: ST_TO_ADDR
// end ;
14254: LD_VAR 0 4
14258: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14259: LD_INT 0
14261: PPUSH
14262: PPUSH
14263: PPUSH
// side := GetSide ( unit ) ;
14264: LD_ADDR_VAR 0 4
14268: PUSH
14269: LD_VAR 0 1
14273: PPUSH
14274: CALL_OW 255
14278: ST_TO_ADDR
// tmp := 0 ;
14279: LD_ADDR_VAR 0 3
14283: PUSH
14284: LD_INT 0
14286: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14287: LD_VAR 0 1
14291: PUSH
14292: LD_EXP 58
14296: PUSH
14297: LD_VAR 0 4
14301: ARRAY
14302: IN
14303: IFFALSE 14313
// tmp := 1 ;
14305: LD_ADDR_VAR 0 3
14309: PUSH
14310: LD_INT 1
14312: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14313: LD_VAR 0 1
14317: PUSH
14318: LD_EXP 59
14322: PUSH
14323: LD_VAR 0 4
14327: ARRAY
14328: IN
14329: IFFALSE 14339
// tmp := 2 ;
14331: LD_ADDR_VAR 0 3
14335: PUSH
14336: LD_INT 2
14338: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14339: LD_VAR 0 1
14343: PUSH
14344: LD_EXP 57
14348: PUSH
14349: LD_VAR 0 4
14353: ARRAY
14354: IN
14355: IFFALSE 14365
// tmp := 3 ;
14357: LD_ADDR_VAR 0 3
14361: PUSH
14362: LD_INT 3
14364: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14365: LD_VAR 0 1
14369: PUSH
14370: LD_EXP 56
14374: PUSH
14375: LD_VAR 0 4
14379: ARRAY
14380: IN
14381: IFFALSE 14391
// tmp := 4 ;
14383: LD_ADDR_VAR 0 3
14387: PUSH
14388: LD_INT 4
14390: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14391: LD_VAR 0 1
14395: PUSH
14396: LD_EXP 70
14400: PUSH
14401: LD_VAR 0 4
14405: ARRAY
14406: IN
14407: IFFALSE 14417
// tmp := 5 ;
14409: LD_ADDR_VAR 0 3
14413: PUSH
14414: LD_INT 5
14416: ST_TO_ADDR
// result := tmp ;
14417: LD_ADDR_VAR 0 2
14421: PUSH
14422: LD_VAR 0 3
14426: ST_TO_ADDR
// end ;
14427: LD_VAR 0 2
14431: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14432: LD_INT 0
14434: PPUSH
14435: PPUSH
// if mreg = ToArm then
14436: LD_VAR 0 2
14440: PUSH
14441: LD_STRING ToArm
14443: EQUAL
14444: IFFALSE 14533
// for i = MREG_ToArm [ side ] downto 1 do
14446: LD_ADDR_VAR 0 5
14450: PUSH
14451: DOUBLE
14452: LD_EXP 58
14456: PUSH
14457: LD_VAR 0 1
14461: ARRAY
14462: INC
14463: ST_TO_ADDR
14464: LD_INT 1
14466: PUSH
14467: FOR_DOWNTO
14468: IFFALSE 14531
// if MREG_ToArm [ side ] [ i ] = unit then
14470: LD_EXP 58
14474: PUSH
14475: LD_VAR 0 1
14479: ARRAY
14480: PUSH
14481: LD_VAR 0 5
14485: ARRAY
14486: PUSH
14487: LD_VAR 0 3
14491: EQUAL
14492: IFFALSE 14529
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14494: LD_ADDR_EXP 58
14498: PUSH
14499: LD_EXP 58
14503: PPUSH
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PPUSH
14521: LD_INT 1
14523: PPUSH
14524: CALL 31250 0 3
14528: ST_TO_ADDR
// end ;
14529: GO 14467
14531: POP
14532: POP
// if mreg = ToDep then
14533: LD_VAR 0 2
14537: PUSH
14538: LD_STRING ToDep
14540: EQUAL
14541: IFFALSE 14630
// for i = MREG_ToDep [ side ] downto 1 do
14543: LD_ADDR_VAR 0 5
14547: PUSH
14548: DOUBLE
14549: LD_EXP 59
14553: PUSH
14554: LD_VAR 0 1
14558: ARRAY
14559: INC
14560: ST_TO_ADDR
14561: LD_INT 1
14563: PUSH
14564: FOR_DOWNTO
14565: IFFALSE 14628
// if MREG_ToDep [ side ] [ i ] = unit then
14567: LD_EXP 59
14571: PUSH
14572: LD_VAR 0 1
14576: ARRAY
14577: PUSH
14578: LD_VAR 0 5
14582: ARRAY
14583: PUSH
14584: LD_VAR 0 3
14588: EQUAL
14589: IFFALSE 14626
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14591: LD_ADDR_EXP 59
14595: PUSH
14596: LD_EXP 59
14600: PPUSH
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PPUSH
14618: LD_INT 1
14620: PPUSH
14621: CALL 31250 0 3
14625: ST_TO_ADDR
// end ;
14626: GO 14564
14628: POP
14629: POP
// if mreg = ToFac then
14630: LD_VAR 0 2
14634: PUSH
14635: LD_STRING ToFac
14637: EQUAL
14638: IFFALSE 14727
// for i = MREG_ToFac [ side ] downto 1 do
14640: LD_ADDR_VAR 0 5
14644: PUSH
14645: DOUBLE
14646: LD_EXP 57
14650: PUSH
14651: LD_VAR 0 1
14655: ARRAY
14656: INC
14657: ST_TO_ADDR
14658: LD_INT 1
14660: PUSH
14661: FOR_DOWNTO
14662: IFFALSE 14725
// if MREG_ToFac [ side ] [ i ] = unit then
14664: LD_EXP 57
14668: PUSH
14669: LD_VAR 0 1
14673: ARRAY
14674: PUSH
14675: LD_VAR 0 5
14679: ARRAY
14680: PUSH
14681: LD_VAR 0 3
14685: EQUAL
14686: IFFALSE 14723
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14688: LD_ADDR_EXP 57
14692: PUSH
14693: LD_EXP 57
14697: PPUSH
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PPUSH
14715: LD_INT 1
14717: PPUSH
14718: CALL 31250 0 3
14722: ST_TO_ADDR
// end ;
14723: GO 14661
14725: POP
14726: POP
// if mreg = ToLab then
14727: LD_VAR 0 2
14731: PUSH
14732: LD_STRING ToLab
14734: EQUAL
14735: IFFALSE 14824
// for i = MREG_ToLab [ side ] downto 1 do
14737: LD_ADDR_VAR 0 5
14741: PUSH
14742: DOUBLE
14743: LD_EXP 56
14747: PUSH
14748: LD_VAR 0 1
14752: ARRAY
14753: INC
14754: ST_TO_ADDR
14755: LD_INT 1
14757: PUSH
14758: FOR_DOWNTO
14759: IFFALSE 14822
// if MREG_ToLab [ side ] [ i ] = unit then
14761: LD_EXP 56
14765: PUSH
14766: LD_VAR 0 1
14770: ARRAY
14771: PUSH
14772: LD_VAR 0 5
14776: ARRAY
14777: PUSH
14778: LD_VAR 0 3
14782: EQUAL
14783: IFFALSE 14820
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14785: LD_ADDR_EXP 56
14789: PUSH
14790: LD_EXP 56
14794: PPUSH
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PPUSH
14812: LD_INT 1
14814: PPUSH
14815: CALL 31250 0 3
14819: ST_TO_ADDR
// end ;
14820: GO 14758
14822: POP
14823: POP
// end ;
14824: LD_VAR 0 4
14828: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14829: LD_INT 0
14831: PPUSH
14832: PPUSH
// result := false ;
14833: LD_ADDR_VAR 0 2
14837: PUSH
14838: LD_INT 0
14840: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: DOUBLE
14847: LD_INT 1
14849: DEC
14850: ST_TO_ADDR
14851: LD_EXP 48
14855: PUSH
14856: FOR_TO
14857: IFFALSE 14921
// if MREG_ToBuild [ i ] [ 1 ] = side then
14859: LD_EXP 48
14863: PUSH
14864: LD_VAR 0 3
14868: ARRAY
14869: PUSH
14870: LD_INT 1
14872: ARRAY
14873: PUSH
14874: LD_VAR 0 1
14878: EQUAL
14879: IFFALSE 14919
// begin if MREG_ToBuild [ i ] [ 1 ] then
14881: LD_EXP 48
14885: PUSH
14886: LD_VAR 0 3
14890: ARRAY
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: IFFALSE 14919
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14897: LD_ADDR_VAR 0 2
14901: PUSH
14902: LD_EXP 48
14906: PUSH
14907: LD_VAR 0 3
14911: ARRAY
14912: PUSH
14913: LD_INT 1
14915: ARRAY
14916: ST_TO_ADDR
// break ;
14917: GO 14921
// end ; end ;
14919: GO 14856
14921: POP
14922: POP
// for i = 1 to MREG_ToRepair do
14923: LD_ADDR_VAR 0 3
14927: PUSH
14928: DOUBLE
14929: LD_INT 1
14931: DEC
14932: ST_TO_ADDR
14933: LD_EXP 49
14937: PUSH
14938: FOR_TO
14939: IFFALSE 15003
// if MREG_ToRepair [ i ] [ 1 ] = side then
14941: LD_EXP 49
14945: PUSH
14946: LD_VAR 0 3
14950: ARRAY
14951: PUSH
14952: LD_INT 1
14954: ARRAY
14955: PUSH
14956: LD_VAR 0 1
14960: EQUAL
14961: IFFALSE 15001
// begin if MREG_ToRepair [ i ] [ 1 ] then
14963: LD_EXP 49
14967: PUSH
14968: LD_VAR 0 3
14972: ARRAY
14973: PUSH
14974: LD_INT 1
14976: ARRAY
14977: IFFALSE 15001
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
14979: LD_ADDR_VAR 0 2
14983: PUSH
14984: LD_EXP 49
14988: PUSH
14989: LD_VAR 0 3
14993: ARRAY
14994: PUSH
14995: LD_INT 1
14997: ARRAY
14998: ST_TO_ADDR
// break ;
14999: GO 15003
// end ; end ;
15001: GO 14938
15003: POP
15004: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 57
15012: PUSH
15013: EMPTY
15014: LIST
15015: PPUSH
15016: CALL 11553 0 2
15020: IFFALSE 15047
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15022: LD_ADDR_VAR 0 2
15026: PUSH
15027: LD_VAR 0 1
15031: PPUSH
15032: LD_INT 57
15034: PUSH
15035: EMPTY
15036: LIST
15037: PPUSH
15038: CALL 11553 0 2
15042: PUSH
15043: LD_INT 1
15045: ARRAY
15046: ST_TO_ADDR
// end ;
15047: LD_VAR 0 2
15051: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15052: LD_INT 0
15054: PPUSH
15055: PPUSH
15056: PPUSH
15057: PPUSH
15058: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15059: LD_ADDR_VAR 0 6
15063: PUSH
15064: LD_VAR 0 1
15068: PPUSH
15069: LD_INT 21
15071: PUSH
15072: LD_INT 3
15074: PUSH
15075: EMPTY
15076: LIST
15077: LIST
15078: PPUSH
15079: CALL 11553 0 2
15083: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15084: LD_ADDR_VAR 0 7
15088: PUSH
15089: LD_VAR 0 1
15093: PPUSH
15094: LD_INT 81
15096: PUSH
15097: LD_VAR 0 1
15101: PUSH
15102: EMPTY
15103: LIST
15104: LIST
15105: PPUSH
15106: CALL 11553 0 2
15110: ST_TO_ADDR
// if not enemy then
15111: LD_VAR 0 7
15115: NOT
15116: IFFALSE 15128
// result := false else
15118: LD_ADDR_VAR 0 3
15122: PUSH
15123: LD_INT 0
15125: ST_TO_ADDR
15126: GO 15182
// begin scan := NearestUnit ( b , enemy ) ;
15128: LD_ADDR_VAR 0 5
15132: PUSH
15133: LD_VAR 0 6
15137: PPUSH
15138: LD_VAR 0 7
15142: PPUSH
15143: CALL 32575 0 2
15147: ST_TO_ADDR
// if scan [ 2 ] < dist then
15148: LD_VAR 0 5
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 2
15161: LESS
15162: IFFALSE 15174
// result := true else
15164: LD_ADDR_VAR 0 3
15168: PUSH
15169: LD_INT 1
15171: ST_TO_ADDR
15172: GO 15182
// result := false ;
15174: LD_ADDR_VAR 0 3
15178: PUSH
15179: LD_INT 0
15181: ST_TO_ADDR
// end ; end ;
15182: LD_VAR 0 3
15186: RET
// export function MCF_Info ( ) ; begin
15187: LD_INT 0
15189: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15190: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15192: PUSH
15193: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15195: ADD
15196: PUSH
15197: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15199: ADD
15200: PUSH
15201: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15203: ADD
15204: PUSH
15205: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15207: ADD
15208: PUSH
15209: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15211: ADD
15212: PUSH
15213: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15215: ADD
15216: PUSH
15217: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15219: ADD
15220: PUSH
15221: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15223: ADD
15224: PUSH
15225: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15227: ADD
15228: PPUSH
15229: CALL 8471 0 1
// end ; end_of_file
15233: LD_VAR 0 1
15237: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15238: LD_INT 0
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15244: LD_ADDR_VAR 0 5
15248: PUSH
15249: LD_VAR 0 1
15253: PPUSH
15254: LD_INT 2
15256: PUSH
15257: LD_INT 25
15259: PUSH
15260: LD_INT 2
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: LD_INT 25
15269: PUSH
15270: LD_INT 3
15272: PUSH
15273: EMPTY
15274: LIST
15275: LIST
15276: PUSH
15277: LD_INT 25
15279: PUSH
15280: LD_INT 4
15282: PUSH
15283: EMPTY
15284: LIST
15285: LIST
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: PPUSH
15293: CALL 11553 0 2
15297: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15298: LD_ADDR_VAR 0 5
15302: PUSH
15303: LD_VAR 0 5
15307: PPUSH
15308: LD_INT 0
15310: PPUSH
15311: CALL 13702 0 2
15315: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15316: LD_ADDR_VAR 0 6
15320: PUSH
15321: LD_VAR 0 1
15325: PPUSH
15326: LD_VAR 0 5
15330: PPUSH
15331: LD_INT 1
15333: PPUSH
15334: CALL 13322 0 3
15338: ST_TO_ADDR
// if n > sk then
15339: LD_VAR 0 2
15343: PUSH
15344: LD_VAR 0 6
15348: GREATER
15349: IFFALSE 15361
// n := sk ;
15351: LD_ADDR_VAR 0 2
15355: PUSH
15356: LD_VAR 0 6
15360: ST_TO_ADDR
// for i = 1 to n do
15361: LD_ADDR_VAR 0 4
15365: PUSH
15366: DOUBLE
15367: LD_INT 1
15369: DEC
15370: ST_TO_ADDR
15371: LD_VAR 0 2
15375: PUSH
15376: FOR_TO
15377: IFFALSE 15489
// if ( sk [ i ] [ 1 ] ) <> 0 then
15379: LD_VAR 0 6
15383: PUSH
15384: LD_VAR 0 4
15388: ARRAY
15389: PUSH
15390: LD_INT 1
15392: ARRAY
15393: PUSH
15394: LD_INT 0
15396: NONEQUAL
15397: IFFALSE 15487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15399: LD_ADDR_EXP 55
15403: PUSH
15404: LD_EXP 55
15408: PPUSH
15409: LD_VAR 0 1
15413: PPUSH
15414: LD_VAR 0 6
15418: PUSH
15419: LD_VAR 0 4
15423: ARRAY
15424: PUSH
15425: LD_INT 1
15427: ARRAY
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 42373 0 4
15436: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15437: LD_ADDR_EXP 58
15441: PUSH
15442: LD_EXP 58
15446: PPUSH
15447: LD_VAR 0 1
15451: PPUSH
15452: LD_EXP 58
15456: PUSH
15457: LD_VAR 0 1
15461: ARRAY
15462: PUSH
15463: LD_INT 1
15465: PLUS
15466: PPUSH
15467: LD_VAR 0 6
15471: PUSH
15472: LD_VAR 0 4
15476: ARRAY
15477: PUSH
15478: LD_INT 1
15480: ARRAY
15481: PPUSH
15482: CALL 31091 0 4
15486: ST_TO_ADDR
// end ;
15487: GO 15376
15489: POP
15490: POP
// end ;
15491: LD_VAR 0 3
15495: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15496: LD_INT 0
15498: PPUSH
15499: PPUSH
15500: PPUSH
15501: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15502: LD_ADDR_VAR 0 5
15506: PUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_INT 2
15514: PUSH
15515: LD_INT 25
15517: PUSH
15518: LD_INT 1
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: PUSH
15525: LD_INT 25
15527: PUSH
15528: LD_INT 3
15530: PUSH
15531: EMPTY
15532: LIST
15533: LIST
15534: PUSH
15535: LD_INT 25
15537: PUSH
15538: LD_INT 4
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: LIST
15549: LIST
15550: PPUSH
15551: CALL 11553 0 2
15555: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15556: LD_ADDR_VAR 0 5
15560: PUSH
15561: LD_VAR 0 5
15565: PPUSH
15566: LD_INT 0
15568: PPUSH
15569: CALL 13702 0 2
15573: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15574: LD_ADDR_VAR 0 6
15578: PUSH
15579: LD_VAR 0 1
15583: PPUSH
15584: LD_VAR 0 5
15588: PPUSH
15589: LD_INT 2
15591: PPUSH
15592: CALL 13322 0 3
15596: ST_TO_ADDR
// if n > sk then
15597: LD_VAR 0 2
15601: PUSH
15602: LD_VAR 0 6
15606: GREATER
15607: IFFALSE 15619
// n := sk ;
15609: LD_ADDR_VAR 0 2
15613: PUSH
15614: LD_VAR 0 6
15618: ST_TO_ADDR
// for i = 1 to n do
15619: LD_ADDR_VAR 0 4
15623: PUSH
15624: DOUBLE
15625: LD_INT 1
15627: DEC
15628: ST_TO_ADDR
15629: LD_VAR 0 2
15633: PUSH
15634: FOR_TO
15635: IFFALSE 15747
// if ( sk [ i ] [ 1 ] ) <> 0 then
15637: LD_VAR 0 6
15641: PUSH
15642: LD_VAR 0 4
15646: ARRAY
15647: PUSH
15648: LD_INT 1
15650: ARRAY
15651: PUSH
15652: LD_INT 0
15654: NONEQUAL
15655: IFFALSE 15745
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15657: LD_ADDR_EXP 55
15661: PUSH
15662: LD_EXP 55
15666: PPUSH
15667: LD_VAR 0 1
15671: PPUSH
15672: LD_VAR 0 6
15676: PUSH
15677: LD_VAR 0 4
15681: ARRAY
15682: PUSH
15683: LD_INT 1
15685: ARRAY
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 42373 0 4
15694: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15695: LD_ADDR_EXP 59
15699: PUSH
15700: LD_EXP 59
15704: PPUSH
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_EXP 59
15714: PUSH
15715: LD_VAR 0 1
15719: ARRAY
15720: PUSH
15721: LD_INT 1
15723: PLUS
15724: PPUSH
15725: LD_VAR 0 6
15729: PUSH
15730: LD_VAR 0 4
15734: ARRAY
15735: PUSH
15736: LD_INT 1
15738: ARRAY
15739: PPUSH
15740: CALL 31091 0 4
15744: ST_TO_ADDR
// end ;
15745: GO 15634
15747: POP
15748: POP
// end ;
15749: LD_VAR 0 3
15753: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15754: LD_INT 0
15756: PPUSH
15757: PPUSH
15758: PPUSH
15759: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15760: LD_ADDR_VAR 0 5
15764: PUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_INT 2
15772: PUSH
15773: LD_INT 25
15775: PUSH
15776: LD_INT 1
15778: PUSH
15779: EMPTY
15780: LIST
15781: LIST
15782: PUSH
15783: LD_INT 25
15785: PUSH
15786: LD_INT 2
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: PUSH
15793: LD_INT 25
15795: PUSH
15796: LD_INT 4
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: PPUSH
15809: CALL 11553 0 2
15813: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15814: LD_ADDR_VAR 0 5
15818: PUSH
15819: LD_VAR 0 5
15823: PPUSH
15824: LD_INT 0
15826: PPUSH
15827: CALL 13702 0 2
15831: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15832: LD_ADDR_VAR 0 6
15836: PUSH
15837: LD_VAR 0 1
15841: PPUSH
15842: LD_VAR 0 5
15846: PPUSH
15847: LD_INT 3
15849: PPUSH
15850: CALL 13322 0 3
15854: ST_TO_ADDR
// if n > sk then
15855: LD_VAR 0 2
15859: PUSH
15860: LD_VAR 0 6
15864: GREATER
15865: IFFALSE 15877
// n := sk ;
15867: LD_ADDR_VAR 0 2
15871: PUSH
15872: LD_VAR 0 6
15876: ST_TO_ADDR
// for i = 1 to n do
15877: LD_ADDR_VAR 0 4
15881: PUSH
15882: DOUBLE
15883: LD_INT 1
15885: DEC
15886: ST_TO_ADDR
15887: LD_VAR 0 2
15891: PUSH
15892: FOR_TO
15893: IFFALSE 16005
// if ( sk [ i ] [ 1 ] ) <> 0 then
15895: LD_VAR 0 6
15899: PUSH
15900: LD_VAR 0 4
15904: ARRAY
15905: PUSH
15906: LD_INT 1
15908: ARRAY
15909: PUSH
15910: LD_INT 0
15912: NONEQUAL
15913: IFFALSE 16003
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15915: LD_ADDR_EXP 55
15919: PUSH
15920: LD_EXP 55
15924: PPUSH
15925: LD_VAR 0 1
15929: PPUSH
15930: LD_VAR 0 6
15934: PUSH
15935: LD_VAR 0 4
15939: ARRAY
15940: PUSH
15941: LD_INT 1
15943: ARRAY
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 42373 0 4
15952: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15953: LD_ADDR_EXP 57
15957: PUSH
15958: LD_EXP 57
15962: PPUSH
15963: LD_VAR 0 1
15967: PPUSH
15968: LD_EXP 57
15972: PUSH
15973: LD_VAR 0 1
15977: ARRAY
15978: PUSH
15979: LD_INT 1
15981: PLUS
15982: PPUSH
15983: LD_VAR 0 6
15987: PUSH
15988: LD_VAR 0 4
15992: ARRAY
15993: PUSH
15994: LD_INT 1
15996: ARRAY
15997: PPUSH
15998: CALL 31091 0 4
16002: ST_TO_ADDR
// end ;
16003: GO 15892
16005: POP
16006: POP
// end ;
16007: LD_VAR 0 3
16011: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16012: LD_INT 0
16014: PPUSH
16015: PPUSH
16016: PPUSH
16017: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16018: LD_ADDR_VAR 0 5
16022: PUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_INT 2
16030: PUSH
16031: LD_INT 25
16033: PUSH
16034: LD_INT 1
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: PUSH
16041: LD_INT 25
16043: PUSH
16044: LD_INT 2
16046: PUSH
16047: EMPTY
16048: LIST
16049: LIST
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: PPUSH
16056: CALL 11553 0 2
16060: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16061: LD_ADDR_VAR 0 5
16065: PUSH
16066: LD_VAR 0 5
16070: PPUSH
16071: LD_INT 0
16073: PPUSH
16074: CALL 13702 0 2
16078: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16079: LD_ADDR_VAR 0 6
16083: PUSH
16084: LD_VAR 0 1
16088: PPUSH
16089: LD_VAR 0 5
16093: PPUSH
16094: LD_INT 4
16096: PPUSH
16097: CALL 13322 0 3
16101: ST_TO_ADDR
// if n > sk then
16102: LD_VAR 0 2
16106: PUSH
16107: LD_VAR 0 6
16111: GREATER
16112: IFFALSE 16124
// n := sk ;
16114: LD_ADDR_VAR 0 2
16118: PUSH
16119: LD_VAR 0 6
16123: ST_TO_ADDR
// for i = 1 to n do
16124: LD_ADDR_VAR 0 4
16128: PUSH
16129: DOUBLE
16130: LD_INT 1
16132: DEC
16133: ST_TO_ADDR
16134: LD_VAR 0 2
16138: PUSH
16139: FOR_TO
16140: IFFALSE 16252
// if ( sk [ i ] [ 1 ] ) <> 0 then
16142: LD_VAR 0 6
16146: PUSH
16147: LD_VAR 0 4
16151: ARRAY
16152: PUSH
16153: LD_INT 1
16155: ARRAY
16156: PUSH
16157: LD_INT 0
16159: NONEQUAL
16160: IFFALSE 16250
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16162: LD_ADDR_EXP 55
16166: PUSH
16167: LD_EXP 55
16171: PPUSH
16172: LD_VAR 0 1
16176: PPUSH
16177: LD_VAR 0 6
16181: PUSH
16182: LD_VAR 0 4
16186: ARRAY
16187: PUSH
16188: LD_INT 1
16190: ARRAY
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 42373 0 4
16199: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16200: LD_ADDR_EXP 56
16204: PUSH
16205: LD_EXP 56
16209: PPUSH
16210: LD_VAR 0 1
16214: PPUSH
16215: LD_EXP 56
16219: PUSH
16220: LD_VAR 0 1
16224: ARRAY
16225: PUSH
16226: LD_INT 1
16228: PLUS
16229: PPUSH
16230: LD_VAR 0 6
16234: PUSH
16235: LD_VAR 0 4
16239: ARRAY
16240: PUSH
16241: LD_INT 1
16243: ARRAY
16244: PPUSH
16245: CALL 31091 0 4
16249: ST_TO_ADDR
// end ;
16250: GO 16139
16252: POP
16253: POP
// end ;
16254: LD_VAR 0 3
16258: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16259: LD_INT 0
16261: PPUSH
16262: PPUSH
16263: PPUSH
16264: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16265: LD_ADDR_VAR 0 6
16269: PUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_INT 2
16277: PUSH
16278: LD_INT 25
16280: PUSH
16281: LD_INT 1
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PUSH
16288: LD_INT 25
16290: PUSH
16291: LD_INT 2
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 25
16300: PUSH
16301: LD_INT 3
16303: PUSH
16304: EMPTY
16305: LIST
16306: LIST
16307: PUSH
16308: LD_INT 25
16310: PUSH
16311: LD_INT 4
16313: PUSH
16314: EMPTY
16315: LIST
16316: LIST
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: LIST
16322: LIST
16323: LIST
16324: PPUSH
16325: CALL 11553 0 2
16329: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16330: LD_ADDR_VAR 0 6
16334: PUSH
16335: LD_VAR 0 6
16339: PPUSH
16340: LD_INT 0
16342: PPUSH
16343: CALL 13702 0 2
16347: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16348: LD_ADDR_VAR 0 7
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: LD_VAR 0 6
16362: PPUSH
16363: LD_INT 1
16365: PPUSH
16366: CALL 13322 0 3
16370: ST_TO_ADDR
// if n > sk then
16371: LD_VAR 0 2
16375: PUSH
16376: LD_VAR 0 7
16380: GREATER
16381: IFFALSE 16393
// n := sk ;
16383: LD_ADDR_VAR 0 2
16387: PUSH
16388: LD_VAR 0 7
16392: ST_TO_ADDR
// for i = 1 to n do
16393: LD_ADDR_VAR 0 5
16397: PUSH
16398: DOUBLE
16399: LD_INT 1
16401: DEC
16402: ST_TO_ADDR
16403: LD_VAR 0 2
16407: PUSH
16408: FOR_TO
16409: IFFALSE 16453
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16411: LD_ADDR_EXP 55
16415: PUSH
16416: LD_EXP 55
16420: PPUSH
16421: LD_VAR 0 1
16425: PPUSH
16426: LD_VAR 0 7
16430: PUSH
16431: LD_VAR 0 5
16435: ARRAY
16436: PUSH
16437: LD_INT 1
16439: ARRAY
16440: PPUSH
16441: LD_VAR 0 3
16445: PPUSH
16446: CALL 42373 0 4
16450: ST_TO_ADDR
// end ;
16451: GO 16408
16453: POP
16454: POP
// end ;
16455: LD_VAR 0 4
16459: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16460: LD_INT 0
16462: PPUSH
16463: PPUSH
16464: PPUSH
// b := false ;
16465: LD_ADDR_VAR 0 6
16469: PUSH
16470: LD_INT 0
16472: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16473: LD_VAR 0 3
16477: PUSH
16478: LD_INT 1
16480: PUSH
16481: LD_INT 9
16483: PUSH
16484: LD_INT 5
16486: PUSH
16487: LD_INT 8
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: LIST
16494: LIST
16495: IN
16496: IFFALSE 16584
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16498: LD_VAR 0 1
16502: PPUSH
16503: LD_INT 2
16505: PUSH
16506: LD_INT 30
16508: PUSH
16509: LD_INT 4
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 30
16518: PUSH
16519: LD_INT 5
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PPUSH
16531: CALL 11553 0 2
16535: IFFALSE 16584
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16537: LD_ADDR_VAR 0 6
16541: PUSH
16542: LD_VAR 0 1
16546: PPUSH
16547: LD_INT 2
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 4
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: LD_INT 30
16562: PUSH
16563: LD_INT 5
16565: PUSH
16566: EMPTY
16567: LIST
16568: LIST
16569: PUSH
16570: EMPTY
16571: LIST
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL 11553 0 2
16579: PUSH
16580: LD_INT 1
16582: ARRAY
16583: ST_TO_ADDR
// if class = class_engineer then
16584: LD_VAR 0 3
16588: PUSH
16589: LD_INT 2
16591: EQUAL
16592: IFFALSE 16680
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16594: LD_VAR 0 1
16598: PPUSH
16599: LD_INT 2
16601: PUSH
16602: LD_INT 30
16604: PUSH
16605: LD_INT 0
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: LD_INT 30
16614: PUSH
16615: LD_INT 1
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: LIST
16626: PPUSH
16627: CALL 11553 0 2
16631: IFFALSE 16680
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16633: LD_ADDR_VAR 0 6
16637: PUSH
16638: LD_VAR 0 1
16642: PPUSH
16643: LD_INT 2
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 0
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: LD_INT 30
16658: PUSH
16659: LD_INT 1
16661: PUSH
16662: EMPTY
16663: LIST
16664: LIST
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: PPUSH
16671: CALL 11553 0 2
16675: PUSH
16676: LD_INT 1
16678: ARRAY
16679: ST_TO_ADDR
// if class = class_mechanic then
16680: LD_VAR 0 3
16684: PUSH
16685: LD_INT 3
16687: EQUAL
16688: IFFALSE 16758
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16690: LD_VAR 0 1
16694: PPUSH
16695: LD_INT 30
16697: PUSH
16698: LD_INT 3
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11553 0 2
16709: IFFALSE 16758
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16711: LD_ADDR_VAR 0 6
16715: PUSH
16716: LD_VAR 0 1
16720: PPUSH
16721: LD_INT 2
16723: PUSH
16724: LD_INT 30
16726: PUSH
16727: LD_INT 2
16729: PUSH
16730: EMPTY
16731: LIST
16732: LIST
16733: PUSH
16734: LD_INT 30
16736: PUSH
16737: LD_INT 3
16739: PUSH
16740: EMPTY
16741: LIST
16742: LIST
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: LIST
16748: PPUSH
16749: CALL 11553 0 2
16753: PUSH
16754: LD_INT 1
16756: ARRAY
16757: ST_TO_ADDR
// if class = class_scientistic then
16758: LD_VAR 0 3
16762: PUSH
16763: LD_INT 4
16765: EQUAL
16766: IFFALSE 16876
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16768: LD_VAR 0 1
16772: PPUSH
16773: LD_INT 2
16775: PUSH
16776: LD_INT 30
16778: PUSH
16779: LD_INT 6
16781: PUSH
16782: EMPTY
16783: LIST
16784: LIST
16785: PUSH
16786: LD_INT 30
16788: PUSH
16789: LD_INT 7
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: PUSH
16796: LD_INT 30
16798: PUSH
16799: LD_INT 8
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PUSH
16806: EMPTY
16807: LIST
16808: LIST
16809: LIST
16810: LIST
16811: PPUSH
16812: CALL 11553 0 2
16816: IFFALSE 16876
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16818: LD_ADDR_VAR 0 6
16822: PUSH
16823: LD_VAR 0 1
16827: PPUSH
16828: LD_INT 2
16830: PUSH
16831: LD_INT 30
16833: PUSH
16834: LD_INT 6
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: LD_INT 30
16843: PUSH
16844: LD_INT 7
16846: PUSH
16847: EMPTY
16848: LIST
16849: LIST
16850: PUSH
16851: LD_INT 30
16853: PUSH
16854: LD_INT 8
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: PPUSH
16867: CALL 11553 0 2
16871: PUSH
16872: LD_INT 1
16874: ARRAY
16875: ST_TO_ADDR
// if GetClass ( unit ) = class then
16876: LD_VAR 0 2
16880: PPUSH
16881: CALL_OW 257
16885: PUSH
16886: LD_VAR 0 3
16890: EQUAL
16891: IFFALSE 16925
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16893: LD_ADDR_EXP 55
16897: PUSH
16898: LD_EXP 55
16902: PPUSH
16903: LD_VAR 0 1
16907: PPUSH
16908: LD_VAR 0 2
16912: PPUSH
16913: LD_VAR 0 3
16917: PPUSH
16918: CALL 42464 0 4
16922: ST_TO_ADDR
// end else
16923: GO 17018
// if b then
16925: LD_VAR 0 6
16929: IFFALSE 17010
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16931: LD_VAR 0 2
16935: PPUSH
16936: CALL_OW 310
16940: PUSH
16941: LD_VAR 0 2
16945: PPUSH
16946: CALL_OW 310
16950: PUSH
16951: LD_VAR 0 6
16955: NONEQUAL
16956: AND
16957: IFFALSE 16968
// ComExitBuilding ( unit ) ;
16959: LD_VAR 0 2
16963: PPUSH
16964: CALL_OW 122
// if not IsInUnit ( unit ) then
16968: LD_VAR 0 2
16972: PPUSH
16973: CALL_OW 310
16977: NOT
16978: IFFALSE 16994
// ComEnterUnit ( unit , b ) ;
16980: LD_VAR 0 2
16984: PPUSH
16985: LD_VAR 0 6
16989: PPUSH
16990: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
16994: LD_VAR 0 2
16998: PPUSH
16999: LD_VAR 0 3
17003: PPUSH
17004: CALL_OW 183
// end else
17008: GO 17018
// result := false ;
17010: LD_ADDR_VAR 0 4
17014: PUSH
17015: LD_INT 0
17017: ST_TO_ADDR
// end ; end_of_file
17018: LD_VAR 0 4
17022: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17023: LD_INT 0
17025: PPUSH
17026: PPUSH
17027: PPUSH
17028: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17029: LD_ADDR_VAR 0 5
17033: PUSH
17034: LD_INT 35
17036: PUSH
17037: LD_INT 45
17039: PUSH
17040: LD_INT 46
17042: PUSH
17043: LD_INT 47
17045: PUSH
17046: LD_INT 1
17048: PUSH
17049: LD_INT 2
17051: PUSH
17052: LD_INT 48
17054: PUSH
17055: LD_INT 49
17057: PUSH
17058: LD_INT 50
17060: PUSH
17061: LD_INT 20
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: LIST
17068: LIST
17069: LIST
17070: LIST
17071: LIST
17072: LIST
17073: LIST
17074: LIST
17075: ST_TO_ADDR
// if MCF_Lab ( side ) then
17076: LD_VAR 0 1
17080: PPUSH
17081: CALL 11592 0 1
17085: IFFALSE 17324
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17087: LD_VAR 0 1
17091: PPUSH
17092: CALL 11592 0 1
17096: PUSH
17097: LD_INT 1
17099: ARRAY
17100: PPUSH
17101: CALL_OW 461
17105: PUSH
17106: LD_INT 2
17108: EQUAL
17109: IFFALSE 17248
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17111: LD_VAR 0 1
17115: PPUSH
17116: CALL 11592 0 1
17120: PUSH
17121: LD_INT 1
17123: ARRAY
17124: PPUSH
17125: LD_VAR 0 2
17129: PPUSH
17130: CALL 17420 0 2
17134: IFFALSE 17161
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17136: LD_VAR 0 1
17140: PPUSH
17141: CALL 11592 0 1
17145: PUSH
17146: LD_INT 1
17148: ARRAY
17149: PPUSH
17150: LD_VAR 0 2
17154: PPUSH
17155: CALL_OW 124
17159: GO 17248
// if MCF_Lab ( side ) > 1 then
17161: LD_VAR 0 1
17165: PPUSH
17166: CALL 11592 0 1
17170: PUSH
17171: LD_INT 1
17173: GREATER
17174: IFFALSE 17248
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17176: LD_VAR 0 1
17180: PPUSH
17181: CALL 11592 0 1
17185: PUSH
17186: LD_INT 2
17188: ARRAY
17189: PPUSH
17190: CALL_OW 461
17194: PUSH
17195: LD_INT 2
17197: EQUAL
17198: IFFALSE 17248
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL 11592 0 1
17209: PUSH
17210: LD_INT 2
17212: ARRAY
17213: PPUSH
17214: LD_VAR 0 2
17218: PPUSH
17219: CALL 17420 0 2
17223: IFFALSE 17248
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11592 0 1
17234: PUSH
17235: LD_INT 2
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17248: LD_VAR 0 2
17252: PUSH
17253: LD_INT 2
17255: PUSH
17256: LD_INT 11
17258: PUSH
17259: LD_INT 4
17261: PUSH
17262: LD_INT 3
17264: PUSH
17265: EMPTY
17266: LIST
17267: LIST
17268: LIST
17269: LIST
17270: IN
17271: IFFALSE 17324
// begin for lab in MCF_Lab ( side ) do
17273: LD_ADDR_VAR 0 6
17277: PUSH
17278: LD_VAR 0 1
17282: PPUSH
17283: CALL 11592 0 1
17287: PUSH
17288: FOR_IN
17289: IFFALSE 17322
// if BuildingStatus ( lab ) = bs_need_ape then
17291: LD_VAR 0 6
17295: PPUSH
17296: CALL_OW 461
17300: PUSH
17301: LD_INT 10
17303: EQUAL
17304: IFFALSE 17320
// MCL_ResTame ( side , lab ) ;
17306: LD_VAR 0 1
17310: PPUSH
17311: LD_VAR 0 6
17315: PPUSH
17316: CALL 17545 0 2
17320: GO 17288
17322: POP
17323: POP
// end ; end ; end ;
17324: LD_VAR 0 3
17328: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17329: LD_INT 0
17331: PPUSH
17332: PPUSH
// tmp := [ ] ;
17333: LD_ADDR_VAR 0 3
17337: PUSH
17338: EMPTY
17339: ST_TO_ADDR
// if not lab then
17340: LD_VAR 0 1
17344: NOT
17345: IFFALSE 17357
// result := false else
17347: LD_ADDR_VAR 0 2
17351: PUSH
17352: LD_INT 0
17354: ST_TO_ADDR
17355: GO 17415
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17357: LD_ADDR_VAR 0 3
17361: PUSH
17362: LD_VAR 0 3
17366: PUSH
17367: LD_VAR 0 1
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: CALL_OW 268
17379: ADD
17380: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17381: LD_ADDR_VAR 0 3
17385: PUSH
17386: LD_VAR 0 3
17390: PUSH
17391: LD_VAR 0 1
17395: PPUSH
17396: LD_INT 2
17398: PPUSH
17399: CALL_OW 268
17403: ADD
17404: ST_TO_ADDR
// result := tmp ;
17405: LD_ADDR_VAR 0 2
17409: PUSH
17410: LD_VAR 0 3
17414: ST_TO_ADDR
// end ; end ;
17415: LD_VAR 0 2
17419: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17420: LD_INT 0
17422: PPUSH
17423: PPUSH
17424: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17425: LD_ADDR_VAR 0 5
17429: PUSH
17430: LD_INT 35
17432: PUSH
17433: LD_INT 45
17435: PUSH
17436: LD_INT 46
17438: PUSH
17439: LD_INT 47
17441: PUSH
17442: LD_INT 1
17444: PUSH
17445: LD_INT 2
17447: PUSH
17448: LD_INT 48
17450: PUSH
17451: LD_INT 49
17453: PUSH
17454: LD_INT 50
17456: PUSH
17457: LD_INT 20
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: LIST
17465: LIST
17466: LIST
17467: LIST
17468: LIST
17469: LIST
17470: LIST
17471: ST_TO_ADDR
// if lab then
17472: LD_VAR 0 1
17476: IFFALSE 17532
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17478: LD_VAR 0 2
17482: PUSH
17483: LD_VAR 0 5
17487: IN
17488: PUSH
17489: LD_VAR 0 2
17493: PPUSH
17494: CALL_OW 481
17498: PUSH
17499: LD_VAR 0 1
17503: PPUSH
17504: CALL 17329 0 1
17508: IN
17509: OR
17510: IFFALSE 17522
// result := true else
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: LD_INT 1
17519: ST_TO_ADDR
17520: GO 17530
// result := false ;
17522: LD_ADDR_VAR 0 3
17526: PUSH
17527: LD_INT 0
17529: ST_TO_ADDR
// end else
17530: GO 17540
// result := false ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_INT 0
17539: ST_TO_ADDR
// end ;
17540: LD_VAR 0 3
17544: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17545: LD_INT 0
17547: PPUSH
17548: PPUSH
17549: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17550: LD_ADDR_VAR 0 4
17554: PUSH
17555: LD_VAR 0 1
17559: PPUSH
17560: LD_INT 171
17562: PPUSH
17563: EMPTY
17564: PPUSH
17565: CALL 12256 0 3
17569: ST_TO_ADDR
// if not ape then
17570: LD_VAR 0 4
17574: NOT
17575: IFFALSE 17607
// if MCF_Ape ( side ) then
17577: LD_VAR 0 1
17581: PPUSH
17582: CALL 11966 0 1
17586: IFFALSE 17607
// ape := MCF_Ape ( side ) [ 1 ] ;
17588: LD_ADDR_VAR 0 4
17592: PUSH
17593: LD_VAR 0 1
17597: PPUSH
17598: CALL 11966 0 1
17602: PUSH
17603: LD_INT 1
17605: ARRAY
17606: ST_TO_ADDR
// if ape then
17607: LD_VAR 0 4
17611: IFFALSE 17662
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17613: LD_VAR 0 4
17617: PUSH
17618: LD_INT 1
17620: ARRAY
17621: PPUSH
17622: CALL_OW 310
17626: PUSH
17627: LD_VAR 0 4
17631: PUSH
17632: LD_INT 1
17634: ARRAY
17635: PPUSH
17636: CALL_OW 310
17640: PUSH
17641: LD_VAR 0 2
17645: NONEQUAL
17646: AND
17647: IFFALSE 17662
// ComExitBuilding ( ape [ 1 ] ) ;
17649: LD_VAR 0 4
17653: PUSH
17654: LD_INT 1
17656: ARRAY
17657: PPUSH
17658: CALL_OW 122
// if not lab then
17662: LD_VAR 0 2
17666: NOT
17667: IFFALSE 17673
// exit else
17669: GO 17821
17671: GO 17781
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17673: LD_VAR 0 1
17677: PPUSH
17678: LD_INT 16
17680: PPUSH
17681: LD_INT 25
17683: PUSH
17684: LD_INT 4
17686: PUSH
17687: EMPTY
17688: LIST
17689: LIST
17690: PPUSH
17691: CALL 12256 0 3
17695: PUSH
17696: LD_INT 0
17698: EQUAL
17699: PUSH
17700: LD_VAR 0 2
17704: PPUSH
17705: CALL_OW 313
17709: PUSH
17710: LD_INT 6
17712: EQUAL
17713: AND
17714: IFFALSE 17781
// begin tmp := UnitsInside ( lab ) ;
17716: LD_ADDR_VAR 0 5
17720: PUSH
17721: LD_VAR 0 2
17725: PPUSH
17726: CALL_OW 313
17730: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17731: LD_VAR 0 5
17735: PUSH
17736: LD_VAR 0 5
17740: ARRAY
17741: PPUSH
17742: LD_INT 16
17744: PPUSH
17745: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17749: LD_VAR 0 5
17753: PUSH
17754: LD_VAR 0 5
17758: ARRAY
17759: PPUSH
17760: CALL_OW 310
17764: IFFALSE 17781
// ComExitBuilding ( tmp [ tmp ] ) ;
17766: LD_VAR 0 5
17770: PUSH
17771: LD_VAR 0 5
17775: ARRAY
17776: PPUSH
17777: CALL_OW 122
// end ; if ape then
17781: LD_VAR 0 4
17785: IFFALSE 17821
// if not IsInUnit ( ape [ 1 ] ) then
17787: LD_VAR 0 4
17791: PUSH
17792: LD_INT 1
17794: ARRAY
17795: PPUSH
17796: CALL_OW 310
17800: NOT
17801: IFFALSE 17821
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17803: LD_VAR 0 4
17807: PUSH
17808: LD_INT 1
17810: ARRAY
17811: PPUSH
17812: LD_VAR 0 2
17816: PPUSH
17817: CALL_OW 120
// end ;
17821: LD_VAR 0 3
17825: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17826: LD_INT 0
17828: PPUSH
17829: PPUSH
17830: PPUSH
// result := false ;
17831: LD_ADDR_VAR 0 2
17835: PUSH
17836: LD_INT 0
17838: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17839: LD_ADDR_VAR 0 3
17843: PUSH
17844: LD_VAR 0 1
17848: PPUSH
17849: CALL 17936 0 1
17853: ST_TO_ADDR
// if techs then
17854: LD_VAR 0 3
17858: IFFALSE 17888
// if techs [ 2 ] then
17860: LD_VAR 0 3
17864: PUSH
17865: LD_INT 2
17867: ARRAY
17868: IFFALSE 17880
// result := true else
17870: LD_ADDR_VAR 0 2
17874: PUSH
17875: LD_INT 1
17877: ST_TO_ADDR
17878: GO 17888
// result := false ;
17880: LD_ADDR_VAR 0 2
17884: PUSH
17885: LD_INT 0
17887: ST_TO_ADDR
// end ;
17888: LD_VAR 0 2
17892: RET
// export function MCL_Start ( side ) ; var i ; begin
17893: LD_INT 0
17895: PPUSH
17896: PPUSH
// if MCL_GetTechList ( side ) then
17897: LD_VAR 0 1
17901: PPUSH
17902: CALL 17936 0 1
17906: IFFALSE 17931
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17908: LD_VAR 0 1
17912: PPUSH
17913: LD_VAR 0 1
17917: PPUSH
17918: CALL 17936 0 1
17922: PUSH
17923: LD_INT 1
17925: ARRAY
17926: PPUSH
17927: CALL 17023 0 2
// end ;
17931: LD_VAR 0 2
17935: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17936: LD_INT 0
17938: PPUSH
17939: PPUSH
17940: PPUSH
// if MREG_ToRes then
17941: LD_EXP 52
17945: IFFALSE 18030
// for i = 1 to MREG_ToRes do
17947: LD_ADDR_VAR 0 3
17951: PUSH
17952: DOUBLE
17953: LD_INT 1
17955: DEC
17956: ST_TO_ADDR
17957: LD_EXP 52
17961: PUSH
17962: FOR_TO
17963: IFFALSE 18028
// if MREG_ToRes [ i ] [ 1 ] = side then
17965: LD_EXP 52
17969: PUSH
17970: LD_VAR 0 3
17974: ARRAY
17975: PUSH
17976: LD_INT 1
17978: ARRAY
17979: PUSH
17980: LD_VAR 0 1
17984: EQUAL
17985: IFFALSE 18026
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
17987: LD_ADDR_VAR 0 4
17991: PUSH
17992: LD_VAR 0 4
17996: PPUSH
17997: LD_VAR 0 4
18001: PUSH
18002: LD_INT 1
18004: PLUS
18005: PPUSH
18006: LD_EXP 52
18010: PUSH
18011: LD_VAR 0 3
18015: ARRAY
18016: PUSH
18017: LD_INT 2
18019: ARRAY
18020: PPUSH
18021: CALL_OW 1
18025: ST_TO_ADDR
// end ;
18026: GO 17962
18028: POP
18029: POP
// result := techs ;
18030: LD_ADDR_VAR 0 2
18034: PUSH
18035: LD_VAR 0 4
18039: ST_TO_ADDR
// end ;
18040: LD_VAR 0 2
18044: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18045: LD_INT 0
18047: PPUSH
18048: PPUSH
// for i = 1 to tech_list do
18049: LD_ADDR_VAR 0 4
18053: PUSH
18054: DOUBLE
18055: LD_INT 1
18057: DEC
18058: ST_TO_ADDR
18059: LD_VAR 0 2
18063: PUSH
18064: FOR_TO
18065: IFFALSE 18119
// if not tech_list [ i ] = 20 then
18067: LD_VAR 0 2
18071: PUSH
18072: LD_VAR 0 4
18076: ARRAY
18077: PUSH
18078: LD_INT 20
18080: EQUAL
18081: NOT
18082: IFFALSE 18117
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18084: LD_ADDR_EXP 52
18088: PUSH
18089: LD_EXP 52
18093: PPUSH
18094: LD_VAR 0 1
18098: PPUSH
18099: LD_VAR 0 2
18103: PUSH
18104: LD_VAR 0 4
18108: ARRAY
18109: PPUSH
18110: EMPTY
18111: PPUSH
18112: CALL 42373 0 4
18116: ST_TO_ADDR
18117: GO 18064
18119: POP
18120: POP
// result := true ;
18121: LD_ADDR_VAR 0 3
18125: PUSH
18126: LD_INT 1
18128: ST_TO_ADDR
// end ;
18129: LD_VAR 0 3
18133: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18134: LD_INT 0
18136: PPUSH
18137: PPUSH
// for i = MREG_ToRes downto 1 do
18138: LD_ADDR_VAR 0 3
18142: PUSH
18143: DOUBLE
18144: LD_EXP 52
18148: INC
18149: ST_TO_ADDR
18150: LD_INT 1
18152: PUSH
18153: FOR_DOWNTO
18154: IFFALSE 18200
// if MREG_ToRes [ i ] [ 1 ] = side then
18156: LD_EXP 52
18160: PUSH
18161: LD_VAR 0 3
18165: ARRAY
18166: PUSH
18167: LD_INT 1
18169: ARRAY
18170: PUSH
18171: LD_VAR 0 1
18175: EQUAL
18176: IFFALSE 18198
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18178: LD_ADDR_EXP 52
18182: PUSH
18183: LD_EXP 52
18187: PPUSH
18188: LD_VAR 0 3
18192: PPUSH
18193: CALL_OW 3
18197: ST_TO_ADDR
18198: GO 18153
18200: POP
18201: POP
// result := true ;
18202: LD_ADDR_VAR 0 2
18206: PUSH
18207: LD_INT 1
18209: ST_TO_ADDR
// end ;
18210: LD_VAR 0 2
18214: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18215: LD_INT 0
18217: PPUSH
// result := GetTechProgress ( side , tech ) ;
18218: LD_ADDR_VAR 0 3
18222: PUSH
18223: LD_VAR 0 1
18227: PPUSH
18228: LD_VAR 0 2
18232: PPUSH
18233: CALL_OW 326
18237: ST_TO_ADDR
// end ;
18238: LD_VAR 0 3
18242: RET
// export function MCL_Require ( tech ) ; begin
18243: LD_INT 0
18245: PPUSH
// result := GetTechTechsReq ( tech ) ;
18246: LD_ADDR_VAR 0 2
18250: PUSH
18251: LD_VAR 0 1
18255: PPUSH
18256: CALL_OW 480
18260: ST_TO_ADDR
// end ; end_of_file
18261: LD_VAR 0 2
18265: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18266: LD_INT 0
18268: PPUSH
18269: PPUSH
18270: PPUSH
// uc_side := 0 ;
18271: LD_ADDR_OWVAR 20
18275: PUSH
18276: LD_INT 0
18278: ST_TO_ADDR
// uc_nation := 0 ;
18279: LD_ADDR_OWVAR 21
18283: PUSH
18284: LD_INT 0
18286: ST_TO_ADDR
// for i = 1 to n do
18287: LD_ADDR_VAR 0 5
18291: PUSH
18292: DOUBLE
18293: LD_INT 1
18295: DEC
18296: ST_TO_ADDR
18297: LD_VAR 0 2
18301: PUSH
18302: FOR_TO
18303: IFFALSE 18448
// begin hc_importance := 0 ;
18305: LD_ADDR_OWVAR 32
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// hc_gallery :=  ;
18313: LD_ADDR_OWVAR 33
18317: PUSH
18318: LD_STRING 
18320: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18321: LD_ADDR_OWVAR 35
18325: PUSH
18326: LD_VAR 0 3
18330: PUSH
18331: LD_INT 20
18333: MINUS
18334: PPUSH
18335: LD_VAR 0 3
18339: PUSH
18340: LD_INT 20
18342: PLUS
18343: PPUSH
18344: CALL_OW 12
18348: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18349: LD_ADDR_OWVAR 31
18353: PUSH
18354: LD_INT 0
18356: PPUSH
18357: LD_INT 2
18359: PPUSH
18360: CALL_OW 12
18364: PUSH
18365: LD_INT 0
18367: PUSH
18368: LD_INT 0
18370: PUSH
18371: LD_INT 0
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: LIST
18378: LIST
18379: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18380: LD_ADDR_OWVAR 30
18384: PUSH
18385: LD_INT 0
18387: PUSH
18388: LD_INT 0
18390: PUSH
18391: LD_INT 0
18393: PUSH
18394: LD_INT 0
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: LIST
18401: LIST
18402: ST_TO_ADDR
// hc_name :=  ;
18403: LD_ADDR_OWVAR 26
18407: PUSH
18408: LD_STRING 
18410: ST_TO_ADDR
// hc_class := class_apeman ;
18411: LD_ADDR_OWVAR 28
18415: PUSH
18416: LD_INT 12
18418: ST_TO_ADDR
// ape := CreateHuman ;
18419: LD_ADDR_VAR 0 6
18423: PUSH
18424: CALL_OW 44
18428: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18429: LD_VAR 0 6
18433: PPUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: LD_INT 0
18441: PPUSH
18442: CALL_OW 49
// end ;
18446: GO 18302
18448: POP
18449: POP
// end ;
18450: LD_VAR 0 4
18454: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18455: LD_INT 0
18457: PPUSH
18458: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18459: LD_VAR 0 1
18463: PPUSH
18464: CALL 11966 0 1
18468: PUSH
18469: LD_EXP 39
18473: PUSH
18474: LD_VAR 0 1
18478: ARRAY
18479: GREATEREQUAL
18480: IFFALSE 18657
// begin if GetTag ( unit ) = 17 then
18482: LD_VAR 0 2
18486: PPUSH
18487: CALL_OW 110
18491: PUSH
18492: LD_INT 17
18494: EQUAL
18495: IFFALSE 18655
// begin SetTag ( unit , 0 ) ;
18497: LD_VAR 0 2
18501: PPUSH
18502: LD_INT 0
18504: PPUSH
18505: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18509: LD_VAR 0 1
18513: PPUSH
18514: CALL 11592 0 1
18518: PUSH
18519: LD_VAR 0 1
18523: PPUSH
18524: CALL 17936 0 1
18528: NOT
18529: AND
18530: IFFALSE 18555
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18532: LD_VAR 0 2
18536: PPUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: CALL 11592 0 1
18546: PUSH
18547: LD_INT 1
18549: ARRAY
18550: PPUSH
18551: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18555: LD_VAR 0 1
18559: PPUSH
18560: CALL 11592 0 1
18564: NOT
18565: PUSH
18566: LD_VAR 0 1
18570: PPUSH
18571: LD_INT 30
18573: PUSH
18574: LD_INT 1
18576: PUSH
18577: EMPTY
18578: LIST
18579: LIST
18580: PPUSH
18581: CALL 11553 0 2
18585: AND
18586: IFFALSE 18655
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18588: LD_VAR 0 2
18592: PPUSH
18593: LD_VAR 0 1
18597: PPUSH
18598: LD_INT 30
18600: PUSH
18601: LD_INT 1
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PPUSH
18608: CALL 11553 0 2
18612: PUSH
18613: LD_INT 1
18615: ARRAY
18616: PPUSH
18617: CALL_OW 250
18621: PPUSH
18622: LD_VAR 0 1
18626: PPUSH
18627: LD_INT 30
18629: PUSH
18630: LD_INT 1
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PPUSH
18637: CALL 11553 0 2
18641: PUSH
18642: LD_INT 1
18644: ARRAY
18645: PPUSH
18646: CALL_OW 251
18650: PPUSH
18651: CALL_OW 111
// end ; end else
18655: GO 18841
// if GetClass ( unit ) <> 4 then
18657: LD_VAR 0 2
18661: PPUSH
18662: CALL_OW 257
18666: PUSH
18667: LD_INT 4
18669: NONEQUAL
18670: IFFALSE 18676
// exit else
18672: GO 18841
18674: GO 18841
// if GetTag ( unit ) = 0 then
18676: LD_VAR 0 2
18680: PPUSH
18681: CALL_OW 110
18685: PUSH
18686: LD_INT 0
18688: EQUAL
18689: IFFALSE 18705
// SetTag ( unit , 17 ) else
18691: LD_VAR 0 2
18695: PPUSH
18696: LD_INT 17
18698: PPUSH
18699: CALL_OW 109
18703: GO 18841
// begin if IsInUnit ( unit ) then
18705: LD_VAR 0 2
18709: PPUSH
18710: CALL_OW 310
18714: IFFALSE 18725
// ComExitBuilding ( unit ) ;
18716: LD_VAR 0 2
18720: PPUSH
18721: CALL_OW 122
// Wait ( 1 ) ;
18725: LD_INT 1
18727: PPUSH
18728: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18732: LD_ADDR_VAR 0 4
18736: PUSH
18737: LD_INT 22
18739: PUSH
18740: LD_INT 0
18742: PUSH
18743: EMPTY
18744: LIST
18745: LIST
18746: PUSH
18747: LD_INT 25
18749: PUSH
18750: LD_INT 12
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: PPUSH
18761: CALL_OW 69
18765: PPUSH
18766: LD_VAR 0 2
18770: PPUSH
18771: CALL_OW 74
18775: ST_TO_ADDR
// if not ape then
18776: LD_VAR 0 4
18780: NOT
18781: IFFALSE 18787
// exit else
18783: GO 18841
18785: GO 18796
// ComHold ( ape ) ;
18787: LD_VAR 0 4
18791: PPUSH
18792: CALL_OW 140
// if not HasTask ( unit ) then
18796: LD_VAR 0 2
18800: PPUSH
18801: CALL_OW 314
18805: NOT
18806: IFFALSE 18839
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18808: LD_VAR 0 2
18812: PPUSH
18813: LD_VAR 0 4
18817: PPUSH
18818: CALL_OW 250
18822: PPUSH
18823: LD_VAR 0 4
18827: PPUSH
18828: CALL_OW 251
18832: PPUSH
18833: CALL_OW 131
18837: GO 18841
// exit ;
18839: GO 18841
// end ; end ;
18841: LD_VAR 0 3
18845: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18846: LD_INT 0
18848: PPUSH
18849: PPUSH
18850: PPUSH
18851: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18852: LD_ADDR_VAR 0 4
18856: PUSH
18857: LD_EXP 40
18861: PUSH
18862: LD_VAR 0 1
18866: ARRAY
18867: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18868: LD_ADDR_VAR 0 5
18872: PUSH
18873: LD_VAR 0 1
18877: PPUSH
18878: LD_STRING normal
18880: PPUSH
18881: CALL 12050 0 2
18885: ST_TO_ADDR
// if apes then
18886: LD_VAR 0 5
18890: IFFALSE 19118
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18892: LD_INT 2
18894: PPUSH
18895: LD_VAR 0 1
18899: PPUSH
18900: CALL_OW 321
18904: PUSH
18905: LD_INT 2
18907: EQUAL
18908: PUSH
18909: LD_VAR 0 4
18913: PUSH
18914: LD_INT 2
18916: ARRAY
18917: PUSH
18918: LD_INT 1
18920: EQUAL
18921: AND
18922: PUSH
18923: LD_VAR 0 1
18927: PPUSH
18928: LD_STRING engineer
18930: PPUSH
18931: CALL 12050 0 2
18935: PUSH
18936: LD_INT 3
18938: LESS
18939: AND
18940: PUSH
18941: LD_VAR 0 1
18945: PPUSH
18946: LD_INT 30
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PPUSH
18956: CALL 11553 0 2
18960: AND
18961: IFFALSE 19015
// begin for i in apes do
18963: LD_ADDR_VAR 0 3
18967: PUSH
18968: LD_VAR 0 5
18972: PUSH
18973: FOR_IN
18974: IFFALSE 19011
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
18976: LD_VAR 0 3
18980: PPUSH
18981: LD_VAR 0 1
18985: PPUSH
18986: LD_INT 30
18988: PUSH
18989: LD_INT 1
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: PPUSH
18996: CALL 11553 0 2
19000: PUSH
19001: LD_INT 1
19003: ARRAY
19004: PPUSH
19005: CALL_OW 120
// end ;
19009: GO 18973
19011: POP
19012: POP
// end else
19013: GO 19118
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19015: LD_INT 11
19017: PPUSH
19018: LD_VAR 0 1
19022: PPUSH
19023: CALL_OW 321
19027: PUSH
19028: LD_INT 2
19030: EQUAL
19031: PUSH
19032: LD_VAR 0 4
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: PUSH
19041: LD_INT 1
19043: EQUAL
19044: AND
19045: PUSH
19046: LD_VAR 0 1
19050: PPUSH
19051: LD_INT 30
19053: PUSH
19054: LD_INT 5
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: PPUSH
19061: CALL 11553 0 2
19065: AND
19066: IFFALSE 19118
// begin for i in apes do
19068: LD_ADDR_VAR 0 3
19072: PUSH
19073: LD_VAR 0 5
19077: PUSH
19078: FOR_IN
19079: IFFALSE 19116
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19081: LD_VAR 0 3
19085: PPUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: LD_INT 30
19093: PUSH
19094: LD_INT 5
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: PPUSH
19101: CALL 11553 0 2
19105: PUSH
19106: LD_INT 1
19108: ARRAY
19109: PPUSH
19110: CALL_OW 120
// end ;
19114: GO 19078
19116: POP
19117: POP
// end ; end ; end ; end_of_file
19118: LD_VAR 0 2
19122: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19123: LD_INT 0
19125: PPUSH
19126: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19127: LD_VAR 0 1
19131: PPUSH
19132: CALL_OW 257
19136: PUSH
19137: LD_INT 4
19139: EQUAL
19140: NOT
19141: PUSH
19142: LD_VAR 0 2
19146: NOT
19147: OR
19148: IFFALSE 19154
// exit else
19150: GO 19188
19152: GO 19188
// if not GetTag ( unit ) = 4 then
19154: LD_VAR 0 1
19158: PPUSH
19159: CALL_OW 110
19163: PUSH
19164: LD_INT 4
19166: EQUAL
19167: NOT
19168: IFFALSE 19174
// exit else
19170: GO 19188
19172: GO 19188
// ComHeal ( unit , target ) ;
19174: LD_VAR 0 1
19178: PPUSH
19179: LD_VAR 0 2
19183: PPUSH
19184: CALL_OW 128
// end ;
19188: LD_VAR 0 3
19192: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19193: LD_INT 0
19195: PPUSH
19196: PPUSH
19197: PPUSH
19198: PPUSH
19199: PPUSH
19200: PPUSH
19201: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19202: LD_ADDR_VAR 0 5
19206: PUSH
19207: LD_INT 22
19209: PUSH
19210: LD_VAR 0 1
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PUSH
19219: LD_INT 21
19221: PUSH
19222: LD_INT 1
19224: PUSH
19225: EMPTY
19226: LIST
19227: LIST
19228: PUSH
19229: LD_INT 3
19231: PUSH
19232: LD_INT 55
19234: PUSH
19235: EMPTY
19236: LIST
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: PUSH
19242: LD_INT 3
19244: PUSH
19245: LD_INT 54
19247: PUSH
19248: EMPTY
19249: LIST
19250: PUSH
19251: EMPTY
19252: LIST
19253: LIST
19254: PUSH
19255: LD_INT 3
19257: PUSH
19258: LD_INT 24
19260: PUSH
19261: LD_INT 1000
19263: PUSH
19264: EMPTY
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: LIST
19276: LIST
19277: LIST
19278: PPUSH
19279: CALL_OW 69
19283: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19284: LD_ADDR_VAR 0 8
19288: PUSH
19289: LD_VAR 0 1
19293: PPUSH
19294: LD_INT 30
19296: PUSH
19297: LD_INT 1
19299: PUSH
19300: EMPTY
19301: LIST
19302: LIST
19303: PPUSH
19304: CALL 11553 0 2
19308: ST_TO_ADDR
// r := [ ] ;
19309: LD_ADDR_VAR 0 6
19313: PUSH
19314: EMPTY
19315: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: LD_INT 5
19323: PPUSH
19324: EMPTY
19325: PPUSH
19326: CALL 12256 0 3
19330: IFFALSE 19386
// for j in MCF_Tag ( side , 5 , [ ] ) do
19332: LD_ADDR_VAR 0 4
19336: PUSH
19337: LD_VAR 0 1
19341: PPUSH
19342: LD_INT 5
19344: PPUSH
19345: EMPTY
19346: PPUSH
19347: CALL 12256 0 3
19351: PUSH
19352: FOR_IN
19353: IFFALSE 19384
// if GetLives ( j ) = 1000 then
19355: LD_VAR 0 4
19359: PPUSH
19360: CALL_OW 256
19364: PUSH
19365: LD_INT 1000
19367: EQUAL
19368: IFFALSE 19382
// SetTag ( j , 0 ) ;
19370: LD_VAR 0 4
19374: PPUSH
19375: LD_INT 0
19377: PPUSH
19378: CALL_OW 109
19382: GO 19352
19384: POP
19385: POP
// if tmp then
19386: LD_VAR 0 5
19390: IFFALSE 19719
// begin r := [ tmp [ 1 ] ] ;
19392: LD_ADDR_VAR 0 6
19396: PUSH
19397: LD_VAR 0 5
19401: PUSH
19402: LD_INT 1
19404: ARRAY
19405: PUSH
19406: EMPTY
19407: LIST
19408: ST_TO_ADDR
// for i = 2 to tmp do
19409: LD_ADDR_VAR 0 3
19413: PUSH
19414: DOUBLE
19415: LD_INT 2
19417: DEC
19418: ST_TO_ADDR
19419: LD_VAR 0 5
19423: PUSH
19424: FOR_TO
19425: IFFALSE 19717
// begin m := false ;
19427: LD_ADDR_VAR 0 7
19431: PUSH
19432: LD_INT 0
19434: ST_TO_ADDR
// if d then
19435: LD_VAR 0 8
19439: IFFALSE 19594
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19441: LD_VAR 0 5
19445: PUSH
19446: LD_VAR 0 3
19450: ARRAY
19451: PPUSH
19452: CALL_OW 256
19456: PUSH
19457: LD_INT 650
19459: LESS
19460: PUSH
19461: LD_VAR 0 5
19465: PUSH
19466: LD_VAR 0 3
19470: ARRAY
19471: PPUSH
19472: LD_VAR 0 8
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: CALL_OW 250
19485: PPUSH
19486: LD_VAR 0 8
19490: PUSH
19491: LD_INT 1
19493: ARRAY
19494: PPUSH
19495: CALL_OW 251
19499: PPUSH
19500: CALL_OW 297
19504: PUSH
19505: LD_INT 10
19507: GREATER
19508: AND
19509: IFFALSE 19594
// begin if not GetTag ( tmp [ i ] ) = 5 then
19511: LD_VAR 0 5
19515: PUSH
19516: LD_VAR 0 3
19520: ARRAY
19521: PPUSH
19522: CALL_OW 110
19526: PUSH
19527: LD_INT 5
19529: EQUAL
19530: NOT
19531: IFFALSE 19551
// SetTag ( tmp [ i ] , 5 ) ;
19533: LD_VAR 0 5
19537: PUSH
19538: LD_VAR 0 3
19542: ARRAY
19543: PPUSH
19544: LD_INT 5
19546: PPUSH
19547: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19551: LD_VAR 0 5
19555: PUSH
19556: LD_VAR 0 3
19560: ARRAY
19561: PPUSH
19562: LD_VAR 0 8
19566: PUSH
19567: LD_INT 1
19569: ARRAY
19570: PPUSH
19571: CALL_OW 250
19575: PPUSH
19576: LD_VAR 0 8
19580: PUSH
19581: LD_INT 1
19583: ARRAY
19584: PPUSH
19585: CALL_OW 251
19589: PPUSH
19590: CALL_OW 111
// end ; for j = 1 to r do
19594: LD_ADDR_VAR 0 4
19598: PUSH
19599: DOUBLE
19600: LD_INT 1
19602: DEC
19603: ST_TO_ADDR
19604: LD_VAR 0 6
19608: PUSH
19609: FOR_TO
19610: IFFALSE 19684
// if GetLives ( tmp [ i ] ) < r [ j ] then
19612: LD_VAR 0 5
19616: PUSH
19617: LD_VAR 0 3
19621: ARRAY
19622: PPUSH
19623: CALL_OW 256
19627: PUSH
19628: LD_VAR 0 6
19632: PUSH
19633: LD_VAR 0 4
19637: ARRAY
19638: LESS
19639: IFFALSE 19682
// begin r := Insert ( r , j , tmp [ i ] ) ;
19641: LD_ADDR_VAR 0 6
19645: PUSH
19646: LD_VAR 0 6
19650: PPUSH
19651: LD_VAR 0 4
19655: PPUSH
19656: LD_VAR 0 5
19660: PUSH
19661: LD_VAR 0 3
19665: ARRAY
19666: PPUSH
19667: CALL_OW 2
19671: ST_TO_ADDR
// m := true ;
19672: LD_ADDR_VAR 0 7
19676: PUSH
19677: LD_INT 1
19679: ST_TO_ADDR
// break ;
19680: GO 19684
// end ;
19682: GO 19609
19684: POP
19685: POP
// if not m then
19686: LD_VAR 0 7
19690: NOT
19691: IFFALSE 19715
// r := r ^ tmp [ i ] ;
19693: LD_ADDR_VAR 0 6
19697: PUSH
19698: LD_VAR 0 6
19702: PUSH
19703: LD_VAR 0 5
19707: PUSH
19708: LD_VAR 0 3
19712: ARRAY
19713: ADD
19714: ST_TO_ADDR
// end ;
19715: GO 19424
19717: POP
19718: POP
// end ; result := r end ; end_of_file
19719: LD_ADDR_VAR 0 2
19723: PUSH
19724: LD_VAR 0 6
19728: ST_TO_ADDR
19729: LD_VAR 0 2
19733: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19734: LD_INT 0
19736: PPUSH
19737: PPUSH
19738: PPUSH
// pom := GetBase ( bdepot ) ;
19739: LD_ADDR_VAR 0 3
19743: PUSH
19744: LD_VAR 0 1
19748: PPUSH
19749: CALL_OW 274
19753: ST_TO_ADDR
// sor := [ ] ;
19754: LD_ADDR_VAR 0 4
19758: PUSH
19759: EMPTY
19760: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19761: LD_ADDR_VAR 0 4
19765: PUSH
19766: LD_VAR 0 4
19770: PUSH
19771: LD_VAR 0 3
19775: PPUSH
19776: LD_INT 1
19778: PPUSH
19779: CALL_OW 275
19783: ADD
19784: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19785: LD_ADDR_VAR 0 4
19789: PUSH
19790: LD_VAR 0 4
19794: PUSH
19795: LD_VAR 0 3
19799: PPUSH
19800: LD_INT 2
19802: PPUSH
19803: CALL_OW 275
19807: ADD
19808: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19809: LD_ADDR_VAR 0 4
19813: PUSH
19814: LD_VAR 0 4
19818: PUSH
19819: LD_VAR 0 3
19823: PPUSH
19824: LD_INT 3
19826: PPUSH
19827: CALL_OW 275
19831: ADD
19832: ST_TO_ADDR
// result := sor ;
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 4
19842: ST_TO_ADDR
// end ;
19843: LD_VAR 0 2
19847: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
// while ( coord_list ) do
19852: LD_VAR 0 3
19856: IFFALSE 20030
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19858: LD_ADDR_EXP 48
19862: PUSH
19863: LD_EXP 48
19867: PPUSH
19868: LD_VAR 0 1
19872: PPUSH
19873: LD_VAR 0 2
19877: PPUSH
19878: LD_VAR 0 3
19882: PUSH
19883: LD_INT 1
19885: ARRAY
19886: PUSH
19887: LD_VAR 0 3
19891: PUSH
19892: LD_INT 2
19894: ARRAY
19895: PUSH
19896: LD_VAR 0 3
19900: PUSH
19901: LD_INT 3
19903: ARRAY
19904: PUSH
19905: EMPTY
19906: LIST
19907: LIST
19908: LIST
19909: PPUSH
19910: CALL 42373 0 4
19914: ST_TO_ADDR
// if weapon_list then
19915: LD_VAR 0 4
19919: IFFALSE 19990
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19921: LD_ADDR_EXP 45
19925: PUSH
19926: LD_EXP 45
19930: PPUSH
19931: LD_VAR 0 1
19935: PPUSH
19936: LD_VAR 0 4
19940: PUSH
19941: LD_INT 1
19943: ARRAY
19944: PPUSH
19945: LD_VAR 0 3
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: LD_VAR 0 3
19958: PUSH
19959: LD_INT 2
19961: ARRAY
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: PPUSH
19967: CALL 42373 0 4
19971: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
19972: LD_ADDR_VAR 0 4
19976: PUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: LD_INT 1
19984: PPUSH
19985: CALL_OW 3
19989: ST_TO_ADDR
// end ; for i = 1 to 3 do
19990: LD_ADDR_VAR 0 6
19994: PUSH
19995: DOUBLE
19996: LD_INT 1
19998: DEC
19999: ST_TO_ADDR
20000: LD_INT 3
20002: PUSH
20003: FOR_TO
20004: IFFALSE 20026
// coord_list := Delete ( coord_list , 1 ) ;
20006: LD_ADDR_VAR 0 3
20010: PUSH
20011: LD_VAR 0 3
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
20024: GO 20003
20026: POP
20027: POP
// end ;
20028: GO 19852
// result := true ;
20030: LD_ADDR_VAR 0 5
20034: PUSH
20035: LD_INT 1
20037: ST_TO_ADDR
// end ;
20038: LD_VAR 0 5
20042: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20043: LD_INT 0
20045: PPUSH
20046: PPUSH
// if not weapon_list then
20047: LD_VAR 0 3
20051: NOT
20052: IFFALSE 20056
// exit ;
20054: GO 20171
// while ( coord_list ) do
20056: LD_VAR 0 2
20060: IFFALSE 20171
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20062: LD_ADDR_EXP 45
20066: PUSH
20067: LD_EXP 45
20071: PPUSH
20072: LD_VAR 0 1
20076: PPUSH
20077: LD_VAR 0 3
20081: PUSH
20082: LD_INT 1
20084: ARRAY
20085: PPUSH
20086: LD_VAR 0 2
20090: PUSH
20091: LD_INT 1
20093: ARRAY
20094: PUSH
20095: LD_VAR 0 2
20099: PUSH
20100: LD_INT 2
20102: ARRAY
20103: PUSH
20104: EMPTY
20105: LIST
20106: LIST
20107: PPUSH
20108: CALL 42373 0 4
20112: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20113: LD_ADDR_VAR 0 3
20117: PUSH
20118: LD_VAR 0 3
20122: PPUSH
20123: LD_INT 1
20125: PPUSH
20126: CALL_OW 3
20130: ST_TO_ADDR
// for i = 1 to 2 do
20131: LD_ADDR_VAR 0 5
20135: PUSH
20136: DOUBLE
20137: LD_INT 1
20139: DEC
20140: ST_TO_ADDR
20141: LD_INT 2
20143: PUSH
20144: FOR_TO
20145: IFFALSE 20167
// coord_list := Delete ( coord_list , 1 ) ;
20147: LD_ADDR_VAR 0 2
20151: PUSH
20152: LD_VAR 0 2
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
20165: GO 20144
20167: POP
20168: POP
// end ;
20169: GO 20056
// end ;
20171: LD_VAR 0 4
20175: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20176: LD_INT 0
20178: PPUSH
20179: PPUSH
// while ( coord_list ) do
20180: LD_VAR 0 2
20184: IFFALSE 20339
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20186: LD_VAR 0 2
20190: PUSH
20191: LD_INT 1
20193: ARRAY
20194: PPUSH
20195: LD_VAR 0 2
20199: PUSH
20200: LD_INT 2
20202: ARRAY
20203: PPUSH
20204: CALL_OW 428
20208: IFFALSE 20299
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20210: LD_VAR 0 2
20214: PUSH
20215: LD_INT 1
20217: ARRAY
20218: PPUSH
20219: LD_VAR 0 2
20223: PUSH
20224: LD_INT 2
20226: ARRAY
20227: PPUSH
20228: CALL_OW 428
20232: PPUSH
20233: CALL_OW 266
20237: PUSH
20238: LD_INT 31
20240: PUSH
20241: LD_INT 32
20243: PUSH
20244: LD_INT 33
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: LIST
20251: IN
20252: IFFALSE 20299
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20254: LD_ADDR_EXP 54
20258: PUSH
20259: LD_EXP 54
20263: PPUSH
20264: LD_VAR 0 1
20268: PPUSH
20269: LD_VAR 0 2
20273: PUSH
20274: LD_INT 1
20276: ARRAY
20277: PPUSH
20278: LD_VAR 0 2
20282: PUSH
20283: LD_INT 2
20285: ARRAY
20286: PPUSH
20287: CALL_OW 428
20291: PPUSH
20292: EMPTY
20293: PPUSH
20294: CALL 42373 0 4
20298: ST_TO_ADDR
// for i = 1 to 3 do
20299: LD_ADDR_VAR 0 4
20303: PUSH
20304: DOUBLE
20305: LD_INT 1
20307: DEC
20308: ST_TO_ADDR
20309: LD_INT 3
20311: PUSH
20312: FOR_TO
20313: IFFALSE 20335
// coord_list := Delete ( coord_list , 1 ) ;
20315: LD_ADDR_VAR 0 2
20319: PUSH
20320: LD_VAR 0 2
20324: PPUSH
20325: LD_INT 1
20327: PPUSH
20328: CALL_OW 3
20332: ST_TO_ADDR
20333: GO 20312
20335: POP
20336: POP
// end ;
20337: GO 20180
// result := true ;
20339: LD_ADDR_VAR 0 3
20343: PUSH
20344: LD_INT 1
20346: ST_TO_ADDR
// end ;
20347: LD_VAR 0 3
20351: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20352: LD_INT 0
20354: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20355: LD_ADDR_EXP 48
20359: PUSH
20360: LD_EXP 48
20364: PPUSH
20365: LD_VAR 0 1
20369: PPUSH
20370: LD_INT 0
20372: PPUSH
20373: LD_VAR 0 2
20377: PPUSH
20378: CALL 42373 0 4
20382: ST_TO_ADDR
// end ;
20383: LD_VAR 0 3
20387: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20388: LD_INT 0
20390: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20391: LD_ADDR_EXP 48
20395: PUSH
20396: LD_EXP 48
20400: PPUSH
20401: LD_VAR 0 1
20405: PPUSH
20406: LD_INT 6
20408: PPUSH
20409: LD_VAR 0 2
20413: PPUSH
20414: CALL 42373 0 4
20418: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20419: LD_ADDR_EXP 51
20423: PUSH
20424: LD_EXP 51
20428: PPUSH
20429: LD_VAR 0 1
20433: PPUSH
20434: LD_VAR 0 3
20438: PUSH
20439: LD_INT 1
20441: ARRAY
20442: PPUSH
20443: LD_VAR 0 3
20447: PUSH
20448: LD_INT 2
20450: ARRAY
20451: PPUSH
20452: CALL 42373 0 4
20456: ST_TO_ADDR
// end ;
20457: LD_VAR 0 4
20461: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20462: LD_INT 0
20464: PPUSH
20465: PPUSH
// if ext_list > 5 then
20466: LD_VAR 0 3
20470: PUSH
20471: LD_INT 5
20473: GREATER
20474: IFFALSE 20518
// for i = 6 to ext_list do
20476: LD_ADDR_VAR 0 5
20480: PUSH
20481: DOUBLE
20482: LD_INT 6
20484: DEC
20485: ST_TO_ADDR
20486: LD_VAR 0 3
20490: PUSH
20491: FOR_TO
20492: IFFALSE 20516
// ext_list := Delete ( ext_list , ext_list ) ;
20494: LD_ADDR_VAR 0 3
20498: PUSH
20499: LD_VAR 0 3
20503: PPUSH
20504: LD_VAR 0 3
20508: PPUSH
20509: CALL_OW 3
20513: ST_TO_ADDR
20514: GO 20491
20516: POP
20517: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20518: LD_VAR 0 1
20522: PPUSH
20523: LD_VAR 0 2
20527: PUSH
20528: LD_INT 1
20530: ARRAY
20531: PPUSH
20532: LD_VAR 0 2
20536: PUSH
20537: LD_INT 2
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 2
20545: PUSH
20546: LD_INT 3
20548: ARRAY
20549: PPUSH
20550: LD_VAR 0 3
20554: PPUSH
20555: CALL 9065 0 5
// end ;
20559: LD_VAR 0 4
20563: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20564: LD_INT 0
20566: PPUSH
20567: PPUSH
20568: PPUSH
// p := 1 ;
20569: LD_ADDR_VAR 0 6
20573: PUSH
20574: LD_INT 1
20576: ST_TO_ADDR
// if type_list = [ ] then
20577: LD_VAR 0 3
20581: PUSH
20582: EMPTY
20583: EQUAL
20584: IFFALSE 20594
// type_list := b_oil_power ;
20586: LD_ADDR_VAR 0 3
20590: PUSH
20591: LD_INT 26
20593: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20594: LD_ADDR_VAR 0 5
20598: PUSH
20599: DOUBLE
20600: LD_INT 1
20602: DEC
20603: ST_TO_ADDR
20604: LD_VAR 0 2
20608: PUSH
20609: LD_INT 3
20611: DIVREAL
20612: PUSH
20613: FOR_TO
20614: IFFALSE 20717
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20616: LD_ADDR_EXP 48
20620: PUSH
20621: LD_EXP 48
20625: PPUSH
20626: LD_VAR 0 1
20630: PPUSH
20631: LD_VAR 0 3
20635: PUSH
20636: LD_INT 1
20638: PPUSH
20639: LD_VAR 0 3
20643: PPUSH
20644: CALL_OW 12
20648: ARRAY
20649: PPUSH
20650: LD_VAR 0 2
20654: PUSH
20655: LD_VAR 0 6
20659: ARRAY
20660: PUSH
20661: LD_VAR 0 2
20665: PUSH
20666: LD_VAR 0 6
20670: PUSH
20671: LD_INT 1
20673: PLUS
20674: ARRAY
20675: PUSH
20676: LD_VAR 0 2
20680: PUSH
20681: LD_VAR 0 6
20685: PUSH
20686: LD_INT 2
20688: PLUS
20689: ARRAY
20690: PUSH
20691: EMPTY
20692: LIST
20693: LIST
20694: LIST
20695: PPUSH
20696: CALL 42373 0 4
20700: ST_TO_ADDR
// p := p + 3 ;
20701: LD_ADDR_VAR 0 6
20705: PUSH
20706: LD_VAR 0 6
20710: PUSH
20711: LD_INT 3
20713: PLUS
20714: ST_TO_ADDR
// end ;
20715: GO 20613
20717: POP
20718: POP
// end ;
20719: LD_VAR 0 4
20723: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20724: LD_INT 0
20726: PPUSH
20727: PPUSH
20728: PPUSH
20729: PPUSH
// if not MREG_Deposit [ side ] then
20730: LD_EXP 63
20734: PUSH
20735: LD_VAR 0 1
20739: ARRAY
20740: NOT
20741: IFFALSE 20745
// exit ;
20743: GO 20922
// p := 1 ;
20745: LD_ADDR_VAR 0 4
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20753: LD_ADDR_VAR 0 3
20757: PUSH
20758: DOUBLE
20759: LD_INT 1
20761: DEC
20762: ST_TO_ADDR
20763: LD_EXP 63
20767: PUSH
20768: LD_VAR 0 1
20772: ARRAY
20773: PUSH
20774: LD_INT 3
20776: DIVREAL
20777: PUSH
20778: FOR_TO
20779: IFFALSE 20920
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20781: LD_EXP 63
20785: PUSH
20786: LD_VAR 0 1
20790: ARRAY
20791: PUSH
20792: LD_VAR 0 4
20796: PUSH
20797: LD_INT 2
20799: PLUS
20800: ARRAY
20801: PUSH
20802: LD_INT 2
20804: EQUAL
20805: IFFALSE 20817
// b := b_oil_mine else
20807: LD_ADDR_VAR 0 5
20811: PUSH
20812: LD_INT 29
20814: ST_TO_ADDR
20815: GO 20825
// b := b_siberite_mine ;
20817: LD_ADDR_VAR 0 5
20821: PUSH
20822: LD_INT 30
20824: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20825: LD_ADDR_EXP 48
20829: PUSH
20830: LD_EXP 48
20834: PPUSH
20835: LD_VAR 0 1
20839: PPUSH
20840: LD_VAR 0 5
20844: PPUSH
20845: LD_EXP 63
20849: PUSH
20850: LD_VAR 0 1
20854: ARRAY
20855: PUSH
20856: LD_VAR 0 4
20860: ARRAY
20861: PUSH
20862: LD_EXP 63
20866: PUSH
20867: LD_VAR 0 1
20871: ARRAY
20872: PUSH
20873: LD_VAR 0 4
20877: PUSH
20878: LD_INT 1
20880: PLUS
20881: ARRAY
20882: PUSH
20883: LD_INT 0
20885: PPUSH
20886: LD_INT 5
20888: PPUSH
20889: CALL_OW 12
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: LIST
20898: PPUSH
20899: CALL 42373 0 4
20903: ST_TO_ADDR
// p := p + 3 ;
20904: LD_ADDR_VAR 0 4
20908: PUSH
20909: LD_VAR 0 4
20913: PUSH
20914: LD_INT 3
20916: PLUS
20917: ST_TO_ADDR
// end ;
20918: GO 20778
20920: POP
20921: POP
// end ;
20922: LD_VAR 0 2
20926: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20927: LD_INT 0
20929: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20930: LD_ADDR_EXP 48
20934: PUSH
20935: LD_EXP 48
20939: PPUSH
20940: LD_VAR 0 1
20944: PPUSH
20945: LD_INT 4
20947: PPUSH
20948: LD_VAR 0 2
20952: PPUSH
20953: CALL 42373 0 4
20957: ST_TO_ADDR
// end ;
20958: LD_VAR 0 3
20962: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20963: LD_INT 0
20965: PPUSH
// case nation of 1 , us :
20966: LD_VAR 0 2
20970: PUSH
20971: LD_INT 1
20973: DOUBLE
20974: EQUAL
20975: IFTRUE 20985
20977: LD_STRING us
20979: DOUBLE
20980: EQUAL
20981: IFTRUE 20985
20983: GO 21016
20985: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
20986: LD_ADDR_EXP 48
20990: PUSH
20991: LD_EXP 48
20995: PPUSH
20996: LD_VAR 0 1
21000: PPUSH
21001: LD_INT 36
21003: PPUSH
21004: LD_VAR 0 3
21008: PPUSH
21009: CALL 42373 0 4
21013: ST_TO_ADDR
21014: GO 21067
21016: LD_INT 2
21018: DOUBLE
21019: EQUAL
21020: IFTRUE 21030
21022: LD_STRING ar
21024: DOUBLE
21025: EQUAL
21026: IFTRUE 21030
21028: GO 21066
21030: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21031: LD_ADDR_EXP 48
21035: PUSH
21036: LD_VAR 0 1
21040: PPUSH
21041: LD_INT 14
21043: PUSH
21044: LD_INT 2
21046: PUSH
21047: LD_INT 1
21049: PUSH
21050: LD_INT 31
21052: PUSH
21053: EMPTY
21054: LIST
21055: LIST
21056: LIST
21057: LIST
21058: PPUSH
21059: CALL 21072 0 2
21063: ST_TO_ADDR
21064: GO 21067
21066: POP
// end ;
21067: LD_VAR 0 4
21071: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21072: LD_INT 0
21074: PPUSH
21075: PPUSH
// for i = 1 to list do
21076: LD_ADDR_VAR 0 4
21080: PUSH
21081: DOUBLE
21082: LD_INT 1
21084: DEC
21085: ST_TO_ADDR
21086: LD_VAR 0 2
21090: PUSH
21091: FOR_TO
21092: IFFALSE 21142
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21094: LD_ADDR_EXP 53
21098: PUSH
21099: LD_EXP 53
21103: PPUSH
21104: LD_VAR 0 1
21108: PPUSH
21109: LD_EXP 53
21113: PUSH
21114: LD_VAR 0 1
21118: ARRAY
21119: PUSH
21120: LD_INT 1
21122: PLUS
21123: PPUSH
21124: LD_VAR 0 2
21128: PUSH
21129: LD_VAR 0 4
21133: ARRAY
21134: PPUSH
21135: CALL 31091 0 4
21139: ST_TO_ADDR
21140: GO 21091
21142: POP
21143: POP
// end ;
21144: LD_VAR 0 3
21148: RET
// export function MCS_GetVehicleList ( side ) ; begin
21149: LD_INT 0
21151: PPUSH
// result := MREG_ToConstruct [ side ] ;
21152: LD_ADDR_VAR 0 2
21156: PUSH
21157: LD_EXP 53
21161: PUSH
21162: LD_VAR 0 1
21166: ARRAY
21167: ST_TO_ADDR
// end ;
21168: LD_VAR 0 2
21172: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21173: LD_INT 0
21175: PPUSH
21176: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21177: LD_ADDR_EXP 60
21181: PUSH
21182: LD_EXP 60
21186: PPUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: LD_VAR 0 2
21196: PPUSH
21197: CALL_OW 1
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 3
21206: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21207: LD_INT 0
21209: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21210: LD_ADDR_EXP 39
21214: PUSH
21215: LD_EXP 39
21219: PPUSH
21220: LD_VAR 0 1
21224: PPUSH
21225: LD_VAR 0 2
21229: PPUSH
21230: CALL_OW 1
21234: ST_TO_ADDR
// end ;
21235: LD_VAR 0 3
21239: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21240: LD_INT 0
21242: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21243: LD_ADDR_EXP 40
21247: PUSH
21248: LD_EXP 40
21252: PPUSH
21253: LD_VAR 0 1
21257: PPUSH
21258: LD_VAR 0 2
21262: PPUSH
21263: CALL_OW 1
21267: ST_TO_ADDR
// end ;
21268: LD_VAR 0 3
21272: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21273: LD_INT 0
21275: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21276: LD_ADDR_EXP 62
21280: PUSH
21281: LD_EXP 62
21285: PPUSH
21286: LD_VAR 0 1
21290: PPUSH
21291: LD_INT 1
21293: PPUSH
21294: LD_VAR 0 2
21298: PPUSH
21299: CALL 31091 0 4
21303: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21304: LD_ADDR_EXP 62
21308: PUSH
21309: LD_EXP 62
21313: PPUSH
21314: LD_VAR 0 1
21318: PPUSH
21319: LD_INT 2
21321: PPUSH
21322: LD_VAR 0 3
21326: PPUSH
21327: CALL 31091 0 4
21331: ST_TO_ADDR
// end ;
21332: LD_VAR 0 4
21336: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21337: LD_INT 0
21339: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21340: LD_ADDR_EXP 74
21344: PUSH
21345: LD_EXP 74
21349: PPUSH
21350: LD_INT 1
21352: PPUSH
21353: LD_VAR 0 1
21357: PPUSH
21358: CALL_OW 1
21362: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21363: LD_ADDR_EXP 74
21367: PUSH
21368: LD_EXP 74
21372: PPUSH
21373: LD_INT 2
21375: PPUSH
21376: LD_VAR 0 2
21380: PPUSH
21381: CALL_OW 1
21385: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21386: LD_ADDR_EXP 74
21390: PUSH
21391: LD_EXP 74
21395: PPUSH
21396: LD_INT 3
21398: PPUSH
21399: LD_VAR 0 3
21403: PPUSH
21404: CALL_OW 1
21408: ST_TO_ADDR
// end ;
21409: LD_VAR 0 4
21413: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21414: LD_INT 0
21416: PPUSH
21417: PPUSH
21418: PPUSH
// if not side or not list then
21419: LD_VAR 0 1
21423: NOT
21424: PUSH
21425: LD_VAR 0 2
21429: NOT
21430: OR
21431: IFFALSE 21435
// exit ;
21433: GO 21603
// SetTech ( 20 , side , state_researched ) ;
21435: LD_INT 20
21437: PPUSH
21438: LD_VAR 0 1
21442: PPUSH
21443: LD_INT 2
21445: PPUSH
21446: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21450: LD_ADDR_EXP 63
21454: PUSH
21455: LD_EXP 63
21459: PPUSH
21460: LD_VAR 0 1
21464: PPUSH
21465: LD_VAR 0 2
21469: PPUSH
21470: CALL_OW 2
21474: ST_TO_ADDR
// p := 1 ;
21475: LD_ADDR_VAR 0 5
21479: PUSH
21480: LD_INT 1
21482: ST_TO_ADDR
// for i = 1 to list / 3 do
21483: LD_ADDR_VAR 0 4
21487: PUSH
21488: DOUBLE
21489: LD_INT 1
21491: DEC
21492: ST_TO_ADDR
21493: LD_VAR 0 2
21497: PUSH
21498: LD_INT 3
21500: DIVREAL
21501: PUSH
21502: FOR_TO
21503: IFFALSE 21601
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21505: LD_VAR 0 2
21509: PUSH
21510: LD_VAR 0 5
21514: ARRAY
21515: PPUSH
21516: LD_VAR 0 2
21520: PUSH
21521: LD_VAR 0 5
21525: PUSH
21526: LD_INT 1
21528: PLUS
21529: ARRAY
21530: PPUSH
21531: LD_VAR 0 2
21535: PUSH
21536: LD_VAR 0 5
21540: PUSH
21541: LD_INT 2
21543: PLUS
21544: ARRAY
21545: PPUSH
21546: CALL 22305 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: ARRAY
21560: PPUSH
21561: LD_VAR 0 2
21565: PUSH
21566: LD_VAR 0 5
21570: PUSH
21571: LD_INT 1
21573: PLUS
21574: ARRAY
21575: PPUSH
21576: LD_VAR 0 1
21580: PPUSH
21581: CALL_OW 441
// p := p + 3 ;
21585: LD_ADDR_VAR 0 5
21589: PUSH
21590: LD_VAR 0 5
21594: PUSH
21595: LD_INT 3
21597: PLUS
21598: ST_TO_ADDR
// end ;
21599: GO 21502
21601: POP
21602: POP
// end ;
21603: LD_VAR 0 3
21607: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21608: LD_INT 0
21610: PPUSH
21611: PPUSH
// if nat = nation_arabian then
21612: LD_VAR 0 2
21616: PUSH
21617: LD_INT 2
21619: EQUAL
21620: IFFALSE 21626
// exit else
21622: GO 21698
21624: GO 21684
// if nat = nation_american then
21626: LD_VAR 0 2
21630: PUSH
21631: LD_INT 1
21633: EQUAL
21634: IFFALSE 21661
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21636: LD_ADDR_VAR 0 4
21640: PUSH
21641: LD_INT 4
21643: PUSH
21644: LD_INT 3
21646: PUSH
21647: LD_INT 1
21649: PUSH
21650: LD_INT 8
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: ST_TO_ADDR
21659: GO 21684
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21661: LD_ADDR_VAR 0 4
21665: PUSH
21666: LD_INT 24
21668: PUSH
21669: LD_INT 3
21671: PUSH
21672: LD_INT 1
21674: PUSH
21675: LD_INT 48
21677: PUSH
21678: EMPTY
21679: LIST
21680: LIST
21681: LIST
21682: LIST
21683: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21684: LD_VAR 0 1
21688: PPUSH
21689: LD_VAR 0 4
21693: PPUSH
21694: CALL 21072 0 2
// end ;
21698: LD_VAR 0 3
21702: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21703: LD_INT 0
21705: PPUSH
21706: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21707: LD_ADDR_EXP 65
21711: PUSH
21712: LD_EXP 65
21716: PPUSH
21717: LD_VAR 0 1
21721: PPUSH
21722: LD_INT 1
21724: PPUSH
21725: LD_VAR 0 4
21729: PPUSH
21730: CALL 31091 0 4
21734: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21735: LD_ADDR_EXP 66
21739: PUSH
21740: LD_EXP 66
21744: PPUSH
21745: LD_VAR 0 1
21749: PPUSH
21750: LD_INT 1
21752: PPUSH
21753: LD_VAR 0 2
21757: PPUSH
21758: CALL 31091 0 4
21762: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21763: LD_ADDR_EXP 67
21767: PUSH
21768: LD_EXP 67
21772: PPUSH
21773: LD_VAR 0 1
21777: PPUSH
21778: LD_INT 1
21780: PPUSH
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL 31091 0 4
21790: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21791: LD_ADDR_EXP 68
21795: PUSH
21796: LD_EXP 68
21800: PPUSH
21801: LD_VAR 0 1
21805: PPUSH
21806: LD_INT 1
21808: PPUSH
21809: LD_VAR 0 5
21813: PPUSH
21814: CALL 31091 0 4
21818: ST_TO_ADDR
// while squad do
21819: LD_VAR 0 5
21823: IFFALSE 21916
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21825: LD_VAR 0 1
21829: PPUSH
21830: LD_VAR 0 5
21834: PUSH
21835: LD_INT 1
21837: ARRAY
21838: PUSH
21839: LD_VAR 0 5
21843: PUSH
21844: LD_INT 2
21846: ARRAY
21847: PUSH
21848: LD_VAR 0 5
21852: PUSH
21853: LD_INT 3
21855: ARRAY
21856: PUSH
21857: LD_VAR 0 5
21861: PUSH
21862: LD_INT 4
21864: ARRAY
21865: PUSH
21866: EMPTY
21867: LIST
21868: LIST
21869: LIST
21870: LIST
21871: PPUSH
21872: CALL 21072 0 2
// for i = 1 to 4 do
21876: LD_ADDR_VAR 0 7
21880: PUSH
21881: DOUBLE
21882: LD_INT 1
21884: DEC
21885: ST_TO_ADDR
21886: LD_INT 4
21888: PUSH
21889: FOR_TO
21890: IFFALSE 21912
// squad := Delete ( squad , 1 ) ;
21892: LD_ADDR_VAR 0 5
21896: PUSH
21897: LD_VAR 0 5
21901: PPUSH
21902: LD_INT 1
21904: PPUSH
21905: CALL_OW 3
21909: ST_TO_ADDR
21910: GO 21889
21912: POP
21913: POP
// end ;
21914: GO 21819
// end ;
21916: LD_VAR 0 6
21920: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21921: LD_INT 0
21923: PPUSH
21924: PPUSH
// for i = 1 to squad do
21925: LD_ADDR_VAR 0 4
21929: PUSH
21930: DOUBLE
21931: LD_INT 1
21933: DEC
21934: ST_TO_ADDR
21935: LD_VAR 0 2
21939: PUSH
21940: FOR_TO
21941: IFFALSE 21991
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21943: LD_ADDR_EXP 71
21947: PUSH
21948: LD_EXP 71
21952: PPUSH
21953: LD_VAR 0 1
21957: PPUSH
21958: LD_EXP 71
21962: PUSH
21963: LD_VAR 0 1
21967: ARRAY
21968: PUSH
21969: LD_INT 1
21971: PLUS
21972: PPUSH
21973: LD_VAR 0 2
21977: PUSH
21978: LD_VAR 0 4
21982: ARRAY
21983: PPUSH
21984: CALL 31091 0 4
21988: ST_TO_ADDR
21989: GO 21940
21991: POP
21992: POP
// while squad do
21993: LD_VAR 0 2
21997: IFFALSE 22090
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21999: LD_VAR 0 1
22003: PPUSH
22004: LD_VAR 0 2
22008: PUSH
22009: LD_INT 1
22011: ARRAY
22012: PUSH
22013: LD_VAR 0 2
22017: PUSH
22018: LD_INT 2
22020: ARRAY
22021: PUSH
22022: LD_VAR 0 2
22026: PUSH
22027: LD_INT 3
22029: ARRAY
22030: PUSH
22031: LD_VAR 0 2
22035: PUSH
22036: LD_INT 4
22038: ARRAY
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: LIST
22044: LIST
22045: PPUSH
22046: CALL 21072 0 2
// for i = 1 to 4 do
22050: LD_ADDR_VAR 0 4
22054: PUSH
22055: DOUBLE
22056: LD_INT 1
22058: DEC
22059: ST_TO_ADDR
22060: LD_INT 4
22062: PUSH
22063: FOR_TO
22064: IFFALSE 22086
// squad := Delete ( squad , 1 ) ;
22066: LD_ADDR_VAR 0 2
22070: PUSH
22071: LD_VAR 0 2
22075: PPUSH
22076: LD_INT 1
22078: PPUSH
22079: CALL_OW 3
22083: ST_TO_ADDR
22084: GO 22063
22086: POP
22087: POP
// end ;
22088: GO 21993
// end ;
22090: LD_VAR 0 3
22094: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22095: LD_INT 0
22097: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22098: LD_ADDR_EXP 64
22102: PUSH
22103: LD_EXP 64
22107: PPUSH
22108: LD_VAR 0 1
22112: PPUSH
22113: LD_INT 1
22115: PPUSH
22116: LD_VAR 0 2
22120: PPUSH
22121: CALL 31091 0 4
22125: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22126: LD_ADDR_EXP 64
22130: PUSH
22131: LD_EXP 64
22135: PPUSH
22136: LD_VAR 0 1
22140: PPUSH
22141: LD_INT 2
22143: PPUSH
22144: LD_VAR 0 3
22148: PPUSH
22149: CALL 31091 0 4
22153: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22154: LD_ADDR_EXP 64
22158: PUSH
22159: LD_EXP 64
22163: PPUSH
22164: LD_VAR 0 1
22168: PPUSH
22169: LD_INT 3
22171: PPUSH
22172: LD_VAR 0 4
22176: PPUSH
22177: CALL 31091 0 4
22181: ST_TO_ADDR
// end ; end_of_file
22182: LD_VAR 0 5
22186: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22187: LD_INT 0
22189: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22190: LD_ADDR_EXP 44
22194: PUSH
22195: LD_EXP 44
22199: PPUSH
22200: LD_VAR 0 1
22204: PPUSH
22205: LD_INT 1
22207: PPUSH
22208: LD_VAR 0 2
22212: PPUSH
22213: CALL 31091 0 4
22217: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22218: LD_VAR 0 1
22222: PPUSH
22223: EMPTY
22224: PPUSH
22225: CALL 11688 0 2
22229: PUSH
22230: LD_INT 1
22232: ARRAY
22233: PPUSH
22234: CALL_OW 248
22238: PUSH
22239: LD_INT 1
22241: EQUAL
22242: IFFALSE 22273
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22244: LD_VAR 0 1
22248: PPUSH
22249: LD_INT 4
22251: PUSH
22252: LD_INT 1
22254: PUSH
22255: LD_INT 1
22257: PUSH
22258: LD_INT 14
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: LIST
22265: LIST
22266: PPUSH
22267: CALL 21072 0 2
22271: GO 22300
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22273: LD_VAR 0 1
22277: PPUSH
22278: LD_INT 24
22280: PUSH
22281: LD_INT 1
22283: PUSH
22284: LD_INT 1
22286: PUSH
22287: LD_INT 53
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: LIST
22294: LIST
22295: PPUSH
22296: CALL 21072 0 2
// end ;
22300: LD_VAR 0 3
22304: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22305: LD_INT 0
22307: PPUSH
// CreateDepositXY ( x , y , t ) ;
22308: LD_VAR 0 1
22312: PPUSH
22313: LD_VAR 0 2
22317: PPUSH
22318: LD_VAR 0 3
22322: PPUSH
22323: CALL_OW 62
// end ;
22327: LD_VAR 0 4
22331: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22332: LD_INT 0
22334: PPUSH
22335: PPUSH
// c := 1 ;
22336: LD_ADDR_VAR 0 5
22340: PUSH
22341: LD_INT 1
22343: ST_TO_ADDR
// case color of red :
22344: LD_VAR 0 3
22348: PUSH
22349: LD_STRING red
22351: DOUBLE
22352: EQUAL
22353: IFTRUE 22357
22355: GO 22368
22357: POP
// c = 1 ; dark-green :
22358: LD_ADDR_VAR 0 5
22362: PUSH
22363: LD_INT 1
22365: ST_TO_ADDR
22366: GO 22654
22368: LD_STRING dark-green
22370: DOUBLE
22371: EQUAL
22372: IFTRUE 22376
22374: GO 22387
22376: POP
// c = 2 ; purple :
22377: LD_ADDR_VAR 0 5
22381: PUSH
22382: LD_INT 2
22384: ST_TO_ADDR
22385: GO 22654
22387: LD_STRING purple
22389: DOUBLE
22390: EQUAL
22391: IFTRUE 22395
22393: GO 22406
22395: POP
// c = 3 ; aqua :
22396: LD_ADDR_VAR 0 5
22400: PUSH
22401: LD_INT 3
22403: ST_TO_ADDR
22404: GO 22654
22406: LD_STRING aqua
22408: DOUBLE
22409: EQUAL
22410: IFTRUE 22414
22412: GO 22425
22414: POP
// c = 4 ; grey :
22415: LD_ADDR_VAR 0 5
22419: PUSH
22420: LD_INT 4
22422: ST_TO_ADDR
22423: GO 22654
22425: LD_STRING grey
22427: DOUBLE
22428: EQUAL
22429: IFTRUE 22433
22431: GO 22444
22433: POP
// c = 5 ; lime :
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 5
22441: ST_TO_ADDR
22442: GO 22654
22444: LD_STRING lime
22446: DOUBLE
22447: EQUAL
22448: IFTRUE 22452
22450: GO 22463
22452: POP
// c = 6 ; tan :
22453: LD_ADDR_VAR 0 5
22457: PUSH
22458: LD_INT 6
22460: ST_TO_ADDR
22461: GO 22654
22463: LD_STRING tan
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 7 ; pink :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 7
22479: ST_TO_ADDR
22480: GO 22654
22482: LD_STRING pink
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 8 ; green :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 8
22498: ST_TO_ADDR
22499: GO 22654
22501: LD_STRING green
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 9 ; blue :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 9
22517: ST_TO_ADDR
22518: GO 22654
22520: LD_STRING blue
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 10 ; yellow :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 10
22536: ST_TO_ADDR
22537: GO 22654
22539: LD_STRING yellow
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 11 ; brown :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 11
22555: ST_TO_ADDR
22556: GO 22654
22558: LD_STRING brown
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 12 ; black :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 12
22574: ST_TO_ADDR
22575: GO 22654
22577: LD_STRING black
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 13 ; aqua2 :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 13
22593: ST_TO_ADDR
22594: GO 22654
22596: LD_STRING aqua2
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 14 ; orange :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 14
22612: ST_TO_ADDR
22613: GO 22654
22615: LD_STRING orange
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 15 ; white :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 15
22631: ST_TO_ADDR
22632: GO 22654
22634: LD_STRING white
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 16 ; end ;
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 16
22650: ST_TO_ADDR
22651: GO 22654
22653: POP
// if HexInfo ( x , y ) = 0 then
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: CALL_OW 428
22668: PUSH
22669: LD_INT 0
22671: EQUAL
22672: IFFALSE 22696
// PlaceEnvironment ( x , y , 58 , c ) ;
22674: LD_VAR 0 1
22678: PPUSH
22679: LD_VAR 0 2
22683: PPUSH
22684: LD_INT 58
22686: PPUSH
22687: LD_VAR 0 5
22691: PPUSH
22692: CALL_OW 349
// end ;
22696: LD_VAR 0 4
22700: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22701: LD_INT 0
22703: PPUSH
// RemoveEnvironment ( x , y ) ;
22704: LD_VAR 0 1
22708: PPUSH
22709: LD_VAR 0 2
22713: PPUSH
22714: CALL_OW 347
// end ;
22718: LD_VAR 0 3
22722: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22723: LD_INT 0
22725: PPUSH
// if FilterAllUnits ( [ f_enemy , side ] ) = 0 then
22726: LD_INT 81
22728: PUSH
22729: LD_VAR 0 1
22733: PUSH
22734: EMPTY
22735: LIST
22736: LIST
22737: PPUSH
22738: CALL_OW 69
22742: PUSH
22743: LD_INT 0
22745: EQUAL
22746: IFFALSE 22758
// result := false else
22748: LD_ADDR_VAR 0 5
22752: PUSH
22753: LD_INT 0
22755: ST_TO_ADDR
22756: GO 22822
// if FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) then
22758: LD_INT 81
22760: PUSH
22761: LD_VAR 0 1
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PUSH
22770: LD_INT 92
22772: PUSH
22773: LD_VAR 0 2
22777: PUSH
22778: LD_VAR 0 3
22782: PUSH
22783: LD_VAR 0 4
22787: PUSH
22788: EMPTY
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: PPUSH
22798: CALL_OW 69
22802: IFFALSE 22814
// result := true else
22804: LD_ADDR_VAR 0 5
22808: PUSH
22809: LD_INT 1
22811: ST_TO_ADDR
22812: GO 22822
// result := false ;
22814: LD_ADDR_VAR 0 5
22818: PUSH
22819: LD_INT 0
22821: ST_TO_ADDR
// end ;
22822: LD_VAR 0 5
22826: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22827: LD_INT 0
22829: PPUSH
22830: PPUSH
22831: PPUSH
22832: PPUSH
22833: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22834: LD_VAR 0 1
22838: PPUSH
22839: LD_INT 81
22841: PUSH
22842: LD_VAR 0 1
22846: PPUSH
22847: CALL_OW 255
22851: PUSH
22852: EMPTY
22853: LIST
22854: LIST
22855: PPUSH
22856: CALL_OW 69
22860: PPUSH
22861: LD_VAR 0 1
22865: PPUSH
22866: CALL_OW 74
22870: PPUSH
22871: CALL_OW 119
// dir := GetDir ( un ) ;
22875: LD_ADDR_VAR 0 4
22879: PUSH
22880: LD_VAR 0 1
22884: PPUSH
22885: CALL_OW 254
22889: ST_TO_ADDR
// dir := dir - 3 ;
22890: LD_ADDR_VAR 0 4
22894: PUSH
22895: LD_VAR 0 4
22899: PUSH
22900: LD_INT 3
22902: MINUS
22903: ST_TO_ADDR
// if dir < 0 then
22904: LD_VAR 0 4
22908: PUSH
22909: LD_INT 0
22911: LESS
22912: IFFALSE 22928
// dir := dir + 6 ;
22914: LD_ADDR_VAR 0 4
22918: PUSH
22919: LD_VAR 0 4
22923: PUSH
22924: LD_INT 6
22926: PLUS
22927: ST_TO_ADDR
// while true do
22928: LD_INT 1
22930: IFFALSE 23427
// begin coord_dist := 3 ;
22932: LD_ADDR_VAR 0 3
22936: PUSH
22937: LD_INT 3
22939: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22940: LD_ADDR_VAR 0 5
22944: PUSH
22945: LD_VAR 0 1
22949: PPUSH
22950: CALL_OW 250
22954: PPUSH
22955: LD_VAR 0 4
22959: PPUSH
22960: LD_VAR 0 3
22964: PPUSH
22965: CALL_OW 272
22969: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22970: LD_ADDR_VAR 0 6
22974: PUSH
22975: LD_VAR 0 1
22979: PPUSH
22980: CALL_OW 251
22984: PPUSH
22985: LD_VAR 0 4
22989: PPUSH
22990: LD_VAR 0 3
22994: PPUSH
22995: CALL_OW 273
22999: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23000: LD_VAR 0 1
23004: PPUSH
23005: CALL_OW 255
23009: PPUSH
23010: LD_VAR 0 1
23014: PPUSH
23015: CALL_OW 250
23019: PPUSH
23020: LD_VAR 0 1
23024: PPUSH
23025: CALL_OW 251
23029: PPUSH
23030: LD_INT 14
23032: PPUSH
23033: CALL 22723 0 4
23037: PUSH
23038: LD_VAR 0 5
23042: PPUSH
23043: LD_VAR 0 6
23047: PPUSH
23048: CALL_OW 351
23052: OR
23053: PUSH
23054: LD_VAR 0 5
23058: PPUSH
23059: LD_VAR 0 6
23063: PPUSH
23064: CALL_OW 488
23068: PUSH
23069: LD_INT 0
23071: EQUAL
23072: OR
23073: PUSH
23074: LD_VAR 0 5
23078: PPUSH
23079: LD_VAR 0 6
23083: PPUSH
23084: CALL_OW 546
23088: PUSH
23089: LD_INT 1
23091: EQUAL
23092: OR
23093: PUSH
23094: LD_VAR 0 5
23098: PPUSH
23099: LD_VAR 0 6
23103: PPUSH
23104: CALL_OW 428
23108: PUSH
23109: LD_INT 0
23111: NONEQUAL
23112: OR
23113: IFFALSE 23341
// begin repeat begin Wait ( 0 0$0.3 ) ;
23115: LD_INT 10
23117: PPUSH
23118: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23122: LD_ADDR_VAR 0 3
23126: PUSH
23127: LD_VAR 0 3
23131: PUSH
23132: LD_INT 1
23134: PLUS
23135: ST_TO_ADDR
// dir := dir + 1 ;
23136: LD_ADDR_VAR 0 4
23140: PUSH
23141: LD_VAR 0 4
23145: PUSH
23146: LD_INT 1
23148: PLUS
23149: ST_TO_ADDR
// if dir > 5 then
23150: LD_VAR 0 4
23154: PUSH
23155: LD_INT 5
23157: GREATER
23158: IFFALSE 23168
// dir = 0 ;
23160: LD_ADDR_VAR 0 4
23164: PUSH
23165: LD_INT 0
23167: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23168: LD_ADDR_VAR 0 5
23172: PUSH
23173: LD_VAR 0 1
23177: PPUSH
23178: CALL_OW 250
23182: PPUSH
23183: LD_VAR 0 4
23187: PPUSH
23188: LD_VAR 0 3
23192: PPUSH
23193: CALL_OW 272
23197: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23198: LD_ADDR_VAR 0 6
23202: PUSH
23203: LD_VAR 0 1
23207: PPUSH
23208: CALL_OW 251
23212: PPUSH
23213: LD_VAR 0 4
23217: PPUSH
23218: LD_VAR 0 3
23222: PPUSH
23223: CALL_OW 273
23227: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23228: LD_VAR 0 1
23232: PPUSH
23233: CALL_OW 255
23237: PPUSH
23238: LD_VAR 0 1
23242: PPUSH
23243: CALL_OW 250
23247: PPUSH
23248: LD_VAR 0 1
23252: PPUSH
23253: CALL_OW 251
23257: PPUSH
23258: LD_INT 14
23260: PPUSH
23261: CALL 22723 0 4
23265: NOT
23266: PUSH
23267: LD_VAR 0 5
23271: PPUSH
23272: LD_VAR 0 6
23276: PPUSH
23277: CALL_OW 351
23281: NOT
23282: AND
23283: PUSH
23284: LD_VAR 0 5
23288: PPUSH
23289: LD_VAR 0 6
23293: PPUSH
23294: CALL_OW 488
23298: AND
23299: PUSH
23300: LD_VAR 0 5
23304: PPUSH
23305: LD_VAR 0 6
23309: PPUSH
23310: CALL_OW 546
23314: PUSH
23315: LD_INT 0
23317: EQUAL
23318: AND
23319: PUSH
23320: LD_VAR 0 5
23324: PPUSH
23325: LD_VAR 0 6
23329: PPUSH
23330: CALL_OW 428
23334: PUSH
23335: LD_INT 0
23337: EQUAL
23338: AND
23339: IFFALSE 23115
// end ; ComMoveXY ( un , x , y ) ;
23341: LD_VAR 0 1
23345: PPUSH
23346: LD_VAR 0 5
23350: PPUSH
23351: LD_VAR 0 6
23355: PPUSH
23356: CALL_OW 111
// Wait ( 0 0$1 ) ;
23360: LD_INT 35
23362: PPUSH
23363: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23367: LD_VAR 0 1
23371: PPUSH
23372: LD_INT 81
23374: PUSH
23375: LD_VAR 0 1
23379: PPUSH
23380: CALL_OW 255
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: PPUSH
23389: CALL_OW 69
23393: PPUSH
23394: LD_VAR 0 1
23398: PPUSH
23399: CALL_OW 74
23403: PPUSH
23404: CALL_OW 296
23408: PUSH
23409: LD_INT 14
23411: GREATEREQUAL
23412: IFFALSE 23425
// begin ComStop ( un ) ;
23414: LD_VAR 0 1
23418: PPUSH
23419: CALL_OW 141
// break ;
23423: GO 23427
// end ; end ;
23425: GO 22928
// end ;
23427: LD_VAR 0 2
23431: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23432: LD_INT 0
23434: PPUSH
23435: PPUSH
23436: PPUSH
23437: PPUSH
23438: PPUSH
23439: PPUSH
23440: PPUSH
23441: PPUSH
// x := GetX ( unit ) ;
23442: LD_ADDR_VAR 0 3
23446: PUSH
23447: LD_VAR 0 1
23451: PPUSH
23452: CALL_OW 250
23456: ST_TO_ADDR
// y := GetY ( unit ) ;
23457: LD_ADDR_VAR 0 4
23461: PUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 251
23471: ST_TO_ADDR
// i := 0 ;
23472: LD_ADDR_VAR 0 8
23476: PUSH
23477: LD_INT 0
23479: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23480: LD_VAR 0 1
23484: PPUSH
23485: LD_INT 81
23487: PUSH
23488: LD_VAR 0 1
23492: PPUSH
23493: CALL_OW 255
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PPUSH
23502: CALL_OW 69
23506: PPUSH
23507: LD_VAR 0 1
23511: PPUSH
23512: CALL_OW 74
23516: PPUSH
23517: CALL_OW 119
// dir := GetDir ( unit ) ;
23521: LD_ADDR_VAR 0 7
23525: PUSH
23526: LD_VAR 0 1
23530: PPUSH
23531: CALL_OW 254
23535: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23536: LD_ADDR_VAR 0 9
23540: PUSH
23541: LD_INT 0
23543: PPUSH
23544: LD_INT 1
23546: PPUSH
23547: CALL_OW 12
23551: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23552: LD_INT 10
23554: PPUSH
23555: CALL_OW 67
// if mode then
23559: LD_VAR 0 9
23563: IFFALSE 23581
// dir := dir + 1 else
23565: LD_ADDR_VAR 0 7
23569: PUSH
23570: LD_VAR 0 7
23574: PUSH
23575: LD_INT 1
23577: PLUS
23578: ST_TO_ADDR
23579: GO 23595
// dir := dir - 1 ;
23581: LD_ADDR_VAR 0 7
23585: PUSH
23586: LD_VAR 0 7
23590: PUSH
23591: LD_INT 1
23593: MINUS
23594: ST_TO_ADDR
// if ( dir < 0 ) then
23595: LD_VAR 0 7
23599: PUSH
23600: LD_INT 0
23602: LESS
23603: IFFALSE 23613
// dir := 5 ;
23605: LD_ADDR_VAR 0 7
23609: PUSH
23610: LD_INT 5
23612: ST_TO_ADDR
// if ( dir > 5 ) then
23613: LD_VAR 0 7
23617: PUSH
23618: LD_INT 5
23620: GREATER
23621: IFFALSE 23631
// dir := 0 ;
23623: LD_ADDR_VAR 0 7
23627: PUSH
23628: LD_INT 0
23630: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23631: LD_ADDR_VAR 0 5
23635: PUSH
23636: LD_VAR 0 3
23640: PPUSH
23641: LD_VAR 0 7
23645: PPUSH
23646: LD_INT 4
23648: PPUSH
23649: CALL_OW 272
23653: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23654: LD_ADDR_VAR 0 6
23658: PUSH
23659: LD_VAR 0 4
23663: PPUSH
23664: LD_VAR 0 7
23668: PPUSH
23669: LD_INT 4
23671: PPUSH
23672: CALL_OW 273
23676: ST_TO_ADDR
// i := i + 1 ;
23677: LD_ADDR_VAR 0 8
23681: PUSH
23682: LD_VAR 0 8
23686: PUSH
23687: LD_INT 1
23689: PLUS
23690: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23691: LD_VAR 0 1
23695: PPUSH
23696: CALL_OW 255
23700: PPUSH
23701: LD_VAR 0 5
23705: PPUSH
23706: LD_VAR 0 6
23710: PPUSH
23711: LD_INT 14
23713: PPUSH
23714: CALL 22723 0 4
23718: PUSH
23719: LD_INT 0
23721: EQUAL
23722: PUSH
23723: LD_VAR 0 5
23727: PPUSH
23728: LD_VAR 0 6
23732: PPUSH
23733: CALL_OW 546
23737: PUSH
23738: LD_INT 0
23740: EQUAL
23741: AND
23742: PUSH
23743: LD_VAR 0 5
23747: PPUSH
23748: LD_VAR 0 6
23752: PPUSH
23753: CALL_OW 428
23757: PUSH
23758: LD_INT 0
23760: EQUAL
23761: AND
23762: IFFALSE 23766
// break ;
23764: GO 23776
// end until i > 4 ;
23766: LD_VAR 0 8
23770: PUSH
23771: LD_INT 4
23773: GREATER
23774: IFFALSE 23552
// if x2 and y2 then
23776: LD_VAR 0 5
23780: PUSH
23781: LD_VAR 0 6
23785: AND
23786: IFFALSE 23809
// result := [ x2 , y2 ] else
23788: LD_ADDR_VAR 0 2
23792: PUSH
23793: LD_VAR 0 5
23797: PUSH
23798: LD_VAR 0 6
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: ST_TO_ADDR
23807: GO 23838
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23809: LD_ADDR_VAR 0 2
23813: PUSH
23814: LD_VAR 0 1
23818: PPUSH
23819: CALL_OW 250
23823: PUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: CALL_OW 251
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: ST_TO_ADDR
// end ;
23838: LD_VAR 0 2
23842: RET
// export function MCT_Hex ( x , y ) ; begin
23843: LD_INT 0
23845: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23846: LD_ADDR_VAR 0 3
23850: PUSH
23851: LD_VAR 0 1
23855: PPUSH
23856: LD_VAR 0 2
23860: PPUSH
23861: CALL_OW 546
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: LD_VAR 0 2
23875: PPUSH
23876: CALL_OW 428
23880: PUSH
23881: EMPTY
23882: LIST
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: ST_TO_ADDR
// end ;
23888: LD_VAR 0 3
23892: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23893: LD_INT 0
23895: PPUSH
23896: PPUSH
23897: PPUSH
23898: PPUSH
23899: PPUSH
23900: PPUSH
23901: PPUSH
23902: PPUSH
23903: PPUSH
23904: PPUSH
23905: PPUSH
23906: PPUSH
23907: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23908: LD_ADDR_VAR 0 10
23912: PUSH
23913: LD_EXP 62
23917: PUSH
23918: LD_VAR 0 1
23922: ARRAY
23923: PUSH
23924: LD_INT 1
23926: ARRAY
23927: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23928: LD_ADDR_VAR 0 11
23932: PUSH
23933: LD_EXP 62
23937: PUSH
23938: LD_VAR 0 1
23942: ARRAY
23943: PUSH
23944: LD_INT 2
23946: ARRAY
23947: ST_TO_ADDR
// collectors := [ ] ;
23948: LD_ADDR_VAR 0 12
23952: PUSH
23953: EMPTY
23954: ST_TO_ADDR
// is_cargo := false ;
23955: LD_ADDR_VAR 0 13
23959: PUSH
23960: LD_INT 0
23962: ST_TO_ADDR
// if isTest then
23963: LD_EXP 1
23967: IFFALSE 23973
// TimerStart ( ) ;
23969: CALL_OW 548
// if MCF_Cargo ( side ) then
23973: LD_VAR 0 1
23977: PPUSH
23978: CALL 11904 0 1
23982: IFFALSE 24009
// begin collectors := MCF_Cargo ( side ) ;
23984: LD_ADDR_VAR 0 12
23988: PUSH
23989: LD_VAR 0 1
23993: PPUSH
23994: CALL 11904 0 1
23998: ST_TO_ADDR
// is_cargo := true ;
23999: LD_ADDR_VAR 0 13
24003: PUSH
24004: LD_INT 1
24006: ST_TO_ADDR
// end else
24007: GO 24158
// begin if MCF_ApeSpec ( side , engineer ) then
24009: LD_VAR 0 1
24013: PPUSH
24014: LD_STRING engineer
24016: PPUSH
24017: CALL 12050 0 2
24021: IFFALSE 24041
// collectors := MCF_ApeSpec ( side , engineer ) ;
24023: LD_ADDR_VAR 0 12
24027: PUSH
24028: LD_VAR 0 1
24032: PPUSH
24033: LD_STRING engineer
24035: PPUSH
24036: CALL 12050 0 2
24040: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: LD_INT 2
24048: PPUSH
24049: EMPTY
24050: PPUSH
24051: CALL 11636 0 3
24055: IFFALSE 24158
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24057: LD_ADDR_VAR 0 7
24061: PUSH
24062: LD_VAR 0 1
24066: PPUSH
24067: LD_INT 2
24069: PPUSH
24070: EMPTY
24071: PPUSH
24072: CALL 11636 0 3
24076: ST_TO_ADDR
// if z > 5 then
24077: LD_VAR 0 7
24081: PUSH
24082: LD_INT 5
24084: GREATER
24085: IFFALSE 24097
// t1 := 5 else
24087: LD_ADDR_VAR 0 8
24091: PUSH
24092: LD_INT 5
24094: ST_TO_ADDR
24095: GO 24107
// t1 := z ;
24097: LD_ADDR_VAR 0 8
24101: PUSH
24102: LD_VAR 0 7
24106: ST_TO_ADDR
// for t2 = 1 to t1 do
24107: LD_ADDR_VAR 0 9
24111: PUSH
24112: DOUBLE
24113: LD_INT 1
24115: DEC
24116: ST_TO_ADDR
24117: LD_VAR 0 8
24121: PUSH
24122: FOR_TO
24123: IFFALSE 24156
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24125: LD_ADDR_VAR 0 12
24129: PUSH
24130: LD_VAR 0 12
24134: PPUSH
24135: LD_INT 1
24137: PPUSH
24138: LD_VAR 0 7
24142: PUSH
24143: LD_VAR 0 9
24147: ARRAY
24148: PPUSH
24149: CALL_OW 2
24153: ST_TO_ADDR
24154: GO 24122
24156: POP
24157: POP
// end ; end ; if not mode then
24158: LD_VAR 0 10
24162: NOT
24163: IFFALSE 24169
// exit else
24165: GO 24428
24167: GO 24428
// begin if collectors then
24169: LD_VAR 0 12
24173: IFFALSE 24428
// for i in areas do
24175: LD_ADDR_VAR 0 3
24179: PUSH
24180: LD_VAR 0 11
24184: PUSH
24185: FOR_IN
24186: IFFALSE 24426
// if GetListOfCratesInArea ( i ) then
24188: LD_VAR 0 3
24192: PPUSH
24193: CALL_OW 435
24197: IFFALSE 24424
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24199: LD_ADDR_VAR 0 5
24203: PUSH
24204: LD_VAR 0 3
24208: PPUSH
24209: CALL_OW 435
24213: PUSH
24214: LD_INT 1
24216: ARRAY
24217: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24218: LD_ADDR_VAR 0 6
24222: PUSH
24223: LD_VAR 0 3
24227: PPUSH
24228: CALL_OW 435
24232: PUSH
24233: LD_INT 2
24235: ARRAY
24236: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24237: LD_VAR 0 13
24241: PUSH
24242: LD_VAR 0 12
24246: PUSH
24247: LD_INT 1
24249: ARRAY
24250: PPUSH
24251: CALL_OW 110
24255: PUSH
24256: LD_INT 0
24258: EQUAL
24259: AND
24260: IFFALSE 24322
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24262: LD_VAR 0 12
24266: PUSH
24267: LD_INT 1
24269: ARRAY
24270: PPUSH
24271: CALL_OW 314
24275: NOT
24276: PUSH
24277: LD_VAR 0 12
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: PPUSH
24286: CALL_OW 110
24290: PUSH
24291: LD_INT 0
24293: EQUAL
24294: AND
24295: IFFALSE 24320
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24297: LD_VAR 0 12
24301: PUSH
24302: LD_INT 1
24304: ARRAY
24305: PPUSH
24306: LD_VAR 0 5
24310: PPUSH
24311: LD_VAR 0 6
24315: PPUSH
24316: CALL_OW 117
// end ; end else
24320: GO 24408
// begin for j = 1 to collectors do
24322: LD_ADDR_VAR 0 4
24326: PUSH
24327: DOUBLE
24328: LD_INT 1
24330: DEC
24331: ST_TO_ADDR
24332: LD_VAR 0 12
24336: PUSH
24337: FOR_TO
24338: IFFALSE 24406
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24340: LD_VAR 0 12
24344: PUSH
24345: LD_VAR 0 4
24349: ARRAY
24350: PPUSH
24351: CALL_OW 314
24355: NOT
24356: PUSH
24357: LD_VAR 0 12
24361: PUSH
24362: LD_VAR 0 4
24366: ARRAY
24367: PPUSH
24368: CALL_OW 110
24372: PUSH
24373: LD_INT 0
24375: EQUAL
24376: AND
24377: IFFALSE 24404
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24379: LD_VAR 0 12
24383: PUSH
24384: LD_VAR 0 4
24388: ARRAY
24389: PPUSH
24390: LD_VAR 0 5
24394: PPUSH
24395: LD_VAR 0 6
24399: PPUSH
24400: CALL 24799 0 3
// end ;
24404: GO 24337
24406: POP
24407: POP
// end ; if isTest then
24408: LD_EXP 1
24412: IFFALSE 24424
// begin debug_time := TimerEnd ( ) ;
24414: LD_ADDR_VAR 0 14
24418: PUSH
24419: CALL_OW 549
24423: ST_TO_ADDR
// end ; end ;
24424: GO 24185
24426: POP
24427: POP
// end ; end ;
24428: LD_VAR 0 2
24432: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24433: LD_INT 0
24435: PPUSH
24436: PPUSH
24437: PPUSH
24438: PPUSH
24439: PPUSH
24440: PPUSH
// if not area then
24441: LD_VAR 0 1
24445: NOT
24446: IFFALSE 24452
// exit else
24448: GO 24714
24450: GO 24714
// if tick mod interval = 0 and Prob ( percent ) then
24452: LD_OWVAR 1
24456: PUSH
24457: LD_VAR 0 4
24461: MOD
24462: PUSH
24463: LD_INT 0
24465: EQUAL
24466: PUSH
24467: LD_VAR 0 3
24471: PPUSH
24472: CALL_OW 13
24476: AND
24477: IFFALSE 24714
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24479: LD_VAR 0 1
24483: PPUSH
24484: CALL_OW 435
24488: PUSH
24489: LD_VAR 0 5
24493: LESS
24494: PUSH
24495: LD_VAR 0 5
24499: PUSH
24500: LD_INT 0
24502: EQUAL
24503: OR
24504: IFFALSE 24714
// begin Randomize ;
24506: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24510: LD_ADDR_VAR 0 7
24514: PUSH
24515: LD_INT 1
24517: PPUSH
24518: LD_VAR 0 2
24522: PPUSH
24523: CALL_OW 12
24527: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24528: LD_ADDR_VAR 0 9
24532: PUSH
24533: LD_VAR 0 1
24537: PPUSH
24538: LD_INT 0
24540: PPUSH
24541: CALL_OW 517
24545: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24546: LD_ADDR_VAR 0 8
24550: PUSH
24551: LD_INT 1
24553: PPUSH
24554: LD_VAR 0 9
24558: PUSH
24559: LD_INT 1
24561: ARRAY
24562: PPUSH
24563: CALL_OW 12
24567: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24568: LD_VAR 0 9
24572: PUSH
24573: LD_INT 1
24575: ARRAY
24576: PUSH
24577: LD_VAR 0 8
24581: ARRAY
24582: PPUSH
24583: LD_VAR 0 9
24587: PUSH
24588: LD_INT 2
24590: ARRAY
24591: PUSH
24592: LD_VAR 0 8
24596: ARRAY
24597: PPUSH
24598: CALL_OW 428
24602: PUSH
24603: LD_INT 0
24605: GREATER
24606: PUSH
24607: LD_VAR 0 9
24611: PUSH
24612: LD_INT 1
24614: ARRAY
24615: PUSH
24616: LD_VAR 0 8
24620: ARRAY
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 2
24629: ARRAY
24630: PUSH
24631: LD_VAR 0 8
24635: ARRAY
24636: PPUSH
24637: CALL_OW 284
24641: PUSH
24642: LD_INT 0
24644: GREATER
24645: AND
24646: IFFALSE 24672
// c := Rand ( 1 , tmp [ 1 ] ) ;
24648: LD_ADDR_VAR 0 8
24652: PUSH
24653: LD_INT 1
24655: PPUSH
24656: LD_VAR 0 9
24660: PUSH
24661: LD_INT 1
24663: ARRAY
24664: PPUSH
24665: CALL_OW 12
24669: ST_TO_ADDR
24670: GO 24568
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24672: LD_VAR 0 7
24676: PPUSH
24677: LD_VAR 0 9
24681: PUSH
24682: LD_INT 1
24684: ARRAY
24685: PUSH
24686: LD_VAR 0 8
24690: ARRAY
24691: PPUSH
24692: LD_VAR 0 9
24696: PUSH
24697: LD_INT 2
24699: ARRAY
24700: PUSH
24701: LD_VAR 0 8
24705: ARRAY
24706: PPUSH
24707: LD_INT 1
24709: PPUSH
24710: CALL_OW 54
// end ; end ; end ;
24714: LD_VAR 0 6
24718: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24719: LD_INT 0
24721: PPUSH
24722: PPUSH
// if not MREG_Crates then
24723: LD_EXP 36
24727: NOT
24728: IFFALSE 24732
// exit ;
24730: GO 24794
// for i = MREG_Crates downto 1 do
24732: LD_ADDR_VAR 0 2
24736: PUSH
24737: DOUBLE
24738: LD_EXP 36
24742: INC
24743: ST_TO_ADDR
24744: LD_INT 1
24746: PUSH
24747: FOR_DOWNTO
24748: IFFALSE 24792
// if MREG_Crates [ i ] [ 3 ] = 0 then
24750: LD_EXP 36
24754: PUSH
24755: LD_VAR 0 2
24759: ARRAY
24760: PUSH
24761: LD_INT 3
24763: ARRAY
24764: PUSH
24765: LD_INT 0
24767: EQUAL
24768: IFFALSE 24790
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24770: LD_ADDR_EXP 36
24774: PUSH
24775: LD_EXP 36
24779: PPUSH
24780: LD_VAR 0 2
24784: PPUSH
24785: CALL_OW 3
24789: ST_TO_ADDR
24790: GO 24747
24792: POP
24793: POP
// end ;
24794: LD_VAR 0 1
24798: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24799: LD_INT 0
24801: PPUSH
24802: PPUSH
24803: PPUSH
24804: PPUSH
// if not unit then
24805: LD_VAR 0 1
24809: NOT
24810: IFFALSE 24814
// exit ;
24812: GO 24949
// if HasTask ( unit ) or not CanCarry ( unit ) then
24814: LD_VAR 0 1
24818: PPUSH
24819: CALL_OW 314
24823: PUSH
24824: LD_VAR 0 1
24828: PPUSH
24829: CALL_OW 280
24833: NOT
24834: OR
24835: IFFALSE 24839
// exit ;
24837: GO 24949
// side := GetSide ( unit ) ;
24839: LD_ADDR_VAR 0 6
24843: PUSH
24844: LD_VAR 0 1
24848: PPUSH
24849: CALL_OW 255
24853: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24854: LD_ADDR_VAR 0 7
24858: PUSH
24859: LD_VAR 0 6
24863: PPUSH
24864: LD_INT 30
24866: PUSH
24867: LD_INT 1
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: PPUSH
24874: CALL 11553 0 2
24878: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24879: LD_VAR 0 1
24883: PPUSH
24884: CALL_OW 281
24888: PUSH
24889: LD_VAR 0 7
24893: NOT
24894: OR
24895: IFFALSE 24901
// exit else
24897: GO 24949
24899: GO 24949
// if GetResourceAmountXY ( x , y ) then
24901: LD_VAR 0 2
24905: PPUSH
24906: LD_VAR 0 3
24910: PPUSH
24911: CALL_OW 284
24915: IFFALSE 24947
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24917: LD_VAR 0 1
24921: PPUSH
24922: LD_VAR 0 2
24926: PPUSH
24927: LD_VAR 0 3
24931: PPUSH
24932: LD_VAR 0 7
24936: PUSH
24937: LD_INT 1
24939: ARRAY
24940: PPUSH
24941: CALL 32255 0 4
// end else
24945: GO 24949
// exit ;
24947: GO 24949
// end ;
24949: LD_VAR 0 4
24953: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24954: LD_INT 0
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
// result := 0 ;
24961: LD_ADDR_VAR 0 2
24965: PUSH
24966: LD_INT 0
24968: ST_TO_ADDR
// p := 1 ;
24969: LD_ADDR_VAR 0 4
24973: PUSH
24974: LD_INT 1
24976: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24977: LD_ADDR_VAR 0 3
24981: PUSH
24982: DOUBLE
24983: LD_INT 1
24985: DEC
24986: ST_TO_ADDR
24987: LD_EXP 65
24991: PUSH
24992: LD_VAR 0 1
24996: ARRAY
24997: PUSH
24998: LD_INT 1
25000: ARRAY
25001: PUSH
25002: LD_INT 2
25004: DIVREAL
25005: PUSH
25006: FOR_TO
25007: IFFALSE 25131
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25009: LD_ADDR_VAR 0 5
25013: PUSH
25014: LD_INT 81
25016: PUSH
25017: LD_VAR 0 1
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 92
25028: PUSH
25029: LD_EXP 65
25033: PUSH
25034: LD_VAR 0 1
25038: ARRAY
25039: PUSH
25040: LD_INT 1
25042: ARRAY
25043: PUSH
25044: LD_VAR 0 4
25048: ARRAY
25049: PUSH
25050: LD_EXP 65
25054: PUSH
25055: LD_VAR 0 1
25059: ARRAY
25060: PUSH
25061: LD_INT 1
25063: ARRAY
25064: PUSH
25065: LD_VAR 0 4
25069: PUSH
25070: LD_INT 1
25072: PLUS
25073: ARRAY
25074: PUSH
25075: LD_INT 12
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PPUSH
25088: CALL_OW 69
25092: ST_TO_ADDR
// if tmp then
25093: LD_VAR 0 5
25097: IFFALSE 25115
// result := result ^ tmp ;
25099: LD_ADDR_VAR 0 2
25103: PUSH
25104: LD_VAR 0 2
25108: PUSH
25109: LD_VAR 0 5
25113: ADD
25114: ST_TO_ADDR
// p := p + 2 ;
25115: LD_ADDR_VAR 0 4
25119: PUSH
25120: LD_VAR 0 4
25124: PUSH
25125: LD_INT 2
25127: PLUS
25128: ST_TO_ADDR
// end ;
25129: GO 25006
25131: POP
25132: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25133: LD_EXP 66
25137: PUSH
25138: LD_VAR 0 1
25142: ARRAY
25143: PPUSH
25144: LD_INT 81
25146: PUSH
25147: LD_VAR 0 1
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PPUSH
25156: CALL_OW 70
25160: IFFALSE 25201
// result := result ^ FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25162: LD_ADDR_VAR 0 2
25166: PUSH
25167: LD_VAR 0 2
25171: PUSH
25172: LD_EXP 66
25176: PUSH
25177: LD_VAR 0 1
25181: ARRAY
25182: PPUSH
25183: LD_INT 81
25185: PUSH
25186: LD_VAR 0 1
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PPUSH
25195: CALL_OW 70
25199: ADD
25200: ST_TO_ADDR
// end ; end_of_file
25201: LD_VAR 0 2
25205: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25206: LD_INT 0
25208: PPUSH
25209: PPUSH
25210: PPUSH
// pom := GetBase ( fac ) ;
25211: LD_ADDR_VAR 0 5
25215: PUSH
25216: LD_VAR 0 1
25220: PPUSH
25221: CALL_OW 274
25225: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25226: LD_ADDR_VAR 0 4
25230: PUSH
25231: LD_VAR 0 2
25235: PUSH
25236: LD_INT 1
25238: ARRAY
25239: PPUSH
25240: LD_VAR 0 2
25244: PUSH
25245: LD_INT 2
25247: ARRAY
25248: PPUSH
25249: LD_VAR 0 2
25253: PUSH
25254: LD_INT 3
25256: ARRAY
25257: PPUSH
25258: LD_VAR 0 2
25262: PUSH
25263: LD_INT 4
25265: ARRAY
25266: PPUSH
25267: CALL_OW 449
25271: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
25272: LD_VAR 0 5
25276: PPUSH
25277: LD_INT 1
25279: PPUSH
25280: CALL_OW 275
25284: PUSH
25285: LD_VAR 0 4
25289: PUSH
25290: LD_INT 1
25292: ARRAY
25293: GREATEREQUAL
25294: PUSH
25295: LD_VAR 0 5
25299: PPUSH
25300: LD_INT 2
25302: PPUSH
25303: CALL_OW 275
25307: PUSH
25308: LD_VAR 0 4
25312: PUSH
25313: LD_INT 2
25315: ARRAY
25316: GREATEREQUAL
25317: AND
25318: PUSH
25319: LD_VAR 0 5
25323: PPUSH
25324: LD_INT 3
25326: PPUSH
25327: CALL_OW 275
25331: PUSH
25332: LD_VAR 0 4
25336: PUSH
25337: LD_INT 3
25339: ARRAY
25340: GREATEREQUAL
25341: AND
25342: IFFALSE 25354
// result := true else
25344: LD_ADDR_VAR 0 3
25348: PUSH
25349: LD_INT 1
25351: ST_TO_ADDR
25352: GO 25362
// result := false ;
25354: LD_ADDR_VAR 0 3
25358: PUSH
25359: LD_INT 0
25361: ST_TO_ADDR
// end ;
25362: LD_VAR 0 3
25366: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25367: LD_INT 0
25369: PPUSH
25370: PPUSH
25371: PPUSH
// result := false ;
25372: LD_ADDR_VAR 0 3
25376: PUSH
25377: LD_INT 0
25379: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25380: LD_ADDR_VAR 0 4
25384: PUSH
25385: LD_EXP 53
25389: PUSH
25390: LD_VAR 0 1
25394: ARRAY
25395: ST_TO_ADDR
// if tmp then
25396: LD_VAR 0 4
25400: IFFALSE 25452
// for i = 1 to tmp do
25402: LD_ADDR_VAR 0 5
25406: PUSH
25407: DOUBLE
25408: LD_INT 1
25410: DEC
25411: ST_TO_ADDR
25412: LD_VAR 0 4
25416: PUSH
25417: FOR_TO
25418: IFFALSE 25450
// if component = tmp [ i ] then
25420: LD_VAR 0 2
25424: PUSH
25425: LD_VAR 0 4
25429: PUSH
25430: LD_VAR 0 5
25434: ARRAY
25435: EQUAL
25436: IFFALSE 25448
// begin result := true ;
25438: LD_ADDR_VAR 0 3
25442: PUSH
25443: LD_INT 1
25445: ST_TO_ADDR
// break ;
25446: GO 25450
// end ;
25448: GO 25417
25450: POP
25451: POP
// end ;
25452: LD_VAR 0 3
25456: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25457: LD_INT 0
25459: PPUSH
25460: PPUSH
25461: PPUSH
// if fac then
25462: LD_VAR 0 2
25466: IFFALSE 25701
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25468: LD_VAR 0 2
25472: PPUSH
25473: LD_VAR 0 3
25477: PPUSH
25478: CALL 25206 0 2
25482: PUSH
25483: LD_VAR 0 2
25487: PPUSH
25488: CALL_OW 461
25492: PUSH
25493: LD_INT 2
25495: EQUAL
25496: AND
25497: PUSH
25498: LD_VAR 0 2
25502: PPUSH
25503: LD_VAR 0 3
25507: PUSH
25508: LD_INT 1
25510: ARRAY
25511: PPUSH
25512: LD_VAR 0 3
25516: PUSH
25517: LD_INT 2
25519: ARRAY
25520: PPUSH
25521: LD_VAR 0 3
25525: PUSH
25526: LD_INT 3
25528: ARRAY
25529: PPUSH
25530: LD_VAR 0 3
25534: PUSH
25535: LD_INT 4
25537: ARRAY
25538: PPUSH
25539: CALL_OW 448
25543: AND
25544: IFFALSE 25691
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25546: LD_VAR 0 2
25550: PPUSH
25551: LD_VAR 0 3
25555: PUSH
25556: LD_INT 1
25558: ARRAY
25559: PPUSH
25560: LD_VAR 0 3
25564: PUSH
25565: LD_INT 2
25567: ARRAY
25568: PPUSH
25569: LD_VAR 0 3
25573: PUSH
25574: LD_INT 3
25576: ARRAY
25577: PPUSH
25578: LD_VAR 0 3
25582: PUSH
25583: LD_INT 4
25585: ARRAY
25586: PPUSH
25587: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25591: LD_ADDR_VAR 0 6
25595: PUSH
25596: LD_EXP 53
25600: PUSH
25601: LD_VAR 0 1
25605: ARRAY
25606: ST_TO_ADDR
// for i = 4 downto 1 do
25607: LD_ADDR_VAR 0 5
25611: PUSH
25612: DOUBLE
25613: LD_INT 4
25615: INC
25616: ST_TO_ADDR
25617: LD_INT 1
25619: PUSH
25620: FOR_DOWNTO
25621: IFFALSE 25654
// tab := Remove ( tab , list [ i ] , true ) ;
25623: LD_ADDR_VAR 0 6
25627: PUSH
25628: LD_VAR 0 6
25632: PPUSH
25633: LD_VAR 0 3
25637: PUSH
25638: LD_VAR 0 5
25642: ARRAY
25643: PPUSH
25644: LD_INT 1
25646: PPUSH
25647: CALL 31250 0 3
25651: ST_TO_ADDR
25652: GO 25620
25654: POP
25655: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25656: LD_ADDR_EXP 53
25660: PUSH
25661: LD_EXP 53
25665: PPUSH
25666: LD_VAR 0 1
25670: PPUSH
25671: LD_VAR 0 6
25675: PPUSH
25676: CALL_OW 1
25680: ST_TO_ADDR
// result := true ;
25681: LD_ADDR_VAR 0 4
25685: PUSH
25686: LD_INT 1
25688: ST_TO_ADDR
// end else
25689: GO 25699
// result := false ;
25691: LD_ADDR_VAR 0 4
25695: PUSH
25696: LD_INT 0
25698: ST_TO_ADDR
// end else
25699: GO 25709
// result := false ;
25701: LD_ADDR_VAR 0 4
25705: PUSH
25706: LD_INT 0
25708: ST_TO_ADDR
// end ;
25709: LD_VAR 0 4
25713: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25714: LD_INT 0
25716: PPUSH
25717: PPUSH
// if not veh then
25718: LD_VAR 0 2
25722: NOT
25723: IFFALSE 25727
// exit ;
25725: GO 25901
// if MREG_Parking [ side ] then
25727: LD_EXP 60
25731: PUSH
25732: LD_VAR 0 1
25736: ARRAY
25737: IFFALSE 25901
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25739: LD_VAR 0 2
25743: PPUSH
25744: LD_EXP 60
25748: PUSH
25749: LD_VAR 0 1
25753: ARRAY
25754: PPUSH
25755: CALL_OW 308
25759: NOT
25760: IFFALSE 25901
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25762: LD_VAR 0 2
25766: PPUSH
25767: LD_EXP 60
25771: PUSH
25772: LD_VAR 0 1
25776: ARRAY
25777: PPUSH
25778: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25782: LD_VAR 0 2
25786: PPUSH
25787: CALL_OW 263
25791: PUSH
25792: LD_INT 1
25794: EQUAL
25795: IFFALSE 25901
// begin i := GetDriver ( veh ) ;
25797: LD_ADDR_VAR 0 4
25801: PUSH
25802: LD_VAR 0 2
25806: PPUSH
25807: CALL 31785 0 1
25811: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25812: LD_INT 35
25814: PPUSH
25815: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25819: LD_VAR 0 2
25823: PPUSH
25824: LD_EXP 60
25828: PUSH
25829: LD_VAR 0 1
25833: ARRAY
25834: PPUSH
25835: CALL_OW 308
25839: PUSH
25840: LD_VAR 0 2
25844: PPUSH
25845: CALL_OW 301
25849: OR
25850: IFFALSE 25812
// ComExitVehicle ( i ) ;
25852: LD_VAR 0 4
25856: PPUSH
25857: CALL_OW 121
// Wait ( 1 ) ;
25861: LD_INT 1
25863: PPUSH
25864: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25868: LD_VAR 0 4
25872: PPUSH
25873: LD_VAR 0 1
25877: PPUSH
25878: LD_INT 30
25880: PUSH
25881: LD_INT 3
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PPUSH
25888: CALL 11553 0 2
25892: PUSH
25893: LD_INT 1
25895: ARRAY
25896: PPUSH
25897: CALL_OW 180
// end ; end ; end ;
25901: LD_VAR 0 3
25905: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25906: LD_INT 0
25908: PPUSH
25909: PPUSH
25910: PPUSH
25911: PPUSH
25912: PPUSH
25913: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25914: LD_VAR 0 1
25918: PPUSH
25919: LD_INT 30
25921: PUSH
25922: LD_INT 3
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PPUSH
25929: CALL 11553 0 2
25933: IFFALSE 26117
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25935: LD_VAR 0 1
25939: PPUSH
25940: LD_INT 30
25942: PUSH
25943: LD_INT 3
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PPUSH
25950: CALL 11553 0 2
25954: PUSH
25955: LD_INT 1
25957: ARRAY
25958: PPUSH
25959: CALL_OW 461
25963: PUSH
25964: LD_INT 2
25966: EQUAL
25967: IFFALSE 26117
// begin for i = 1 to MREG_TurretWeapon do
25969: LD_ADDR_VAR 0 3
25973: PUSH
25974: DOUBLE
25975: LD_INT 1
25977: DEC
25978: ST_TO_ADDR
25979: LD_EXP 45
25983: PUSH
25984: FOR_TO
25985: IFFALSE 26115
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25987: LD_EXP 45
25991: PUSH
25992: LD_VAR 0 3
25996: ARRAY
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PUSH
26002: LD_VAR 0 1
26006: EQUAL
26007: IFFALSE 26113
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26009: LD_ADDR_VAR 0 5
26013: PUSH
26014: LD_EXP 45
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 2
26027: ARRAY
26028: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26029: LD_ADDR_VAR 0 6
26033: PUSH
26034: LD_EXP 45
26038: PUSH
26039: LD_VAR 0 3
26043: ARRAY
26044: PUSH
26045: LD_INT 3
26047: ARRAY
26048: PUSH
26049: LD_INT 1
26051: ARRAY
26052: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26053: LD_ADDR_VAR 0 7
26057: PUSH
26058: LD_EXP 45
26062: PUSH
26063: LD_VAR 0 3
26067: ARRAY
26068: PUSH
26069: LD_INT 3
26071: ARRAY
26072: PUSH
26073: LD_INT 2
26075: ARRAY
26076: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26077: LD_ADDR_VAR 0 4
26081: PUSH
26082: LD_VAR 0 6
26086: PPUSH
26087: LD_VAR 0 7
26091: PPUSH
26092: CALL_OW 428
26096: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26097: LD_VAR 0 4
26101: PPUSH
26102: LD_VAR 0 5
26106: PPUSH
26107: CALL_OW 148
// break ;
26111: GO 26115
// end ;
26113: GO 25984
26115: POP
26116: POP
// end ; end ;
26117: LD_VAR 0 2
26121: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26122: LD_INT 0
26124: PPUSH
26125: PPUSH
26126: PPUSH
26127: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26128: LD_ADDR_VAR 0 4
26132: PUSH
26133: LD_VAR 0 1
26137: PPUSH
26138: LD_INT 32
26140: PUSH
26141: LD_INT 1
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PPUSH
26148: CALL 11553 0 2
26152: ST_TO_ADDR
// if not tmp then
26153: LD_VAR 0 4
26157: NOT
26158: IFFALSE 26164
// exit else
26160: GO 26246
26162: GO 26246
// begin for i = 1 to tmp do
26164: LD_ADDR_VAR 0 3
26168: PUSH
26169: DOUBLE
26170: LD_INT 1
26172: DEC
26173: ST_TO_ADDR
26174: LD_VAR 0 4
26178: PUSH
26179: FOR_TO
26180: IFFALSE 26244
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26182: LD_VAR 0 4
26186: PUSH
26187: LD_VAR 0 3
26191: ARRAY
26192: PPUSH
26193: CALL_OW 261
26197: PUSH
26198: LD_INT 20
26200: LESS
26201: PUSH
26202: LD_VAR 0 4
26206: PUSH
26207: LD_VAR 0 3
26211: ARRAY
26212: PPUSH
26213: CALL_OW 110
26217: PUSH
26218: LD_INT 0
26220: EQUAL
26221: AND
26222: IFFALSE 26242
// begin SetTag ( tmp [ i ] , 21 ) ;
26224: LD_VAR 0 4
26228: PUSH
26229: LD_VAR 0 3
26233: ARRAY
26234: PPUSH
26235: LD_INT 21
26237: PPUSH
26238: CALL_OW 109
// end ;
26242: GO 26179
26244: POP
26245: POP
// end ; end ;
26246: LD_VAR 0 2
26250: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26251: LD_INT 0
26253: PPUSH
26254: PPUSH
26255: PPUSH
26256: PPUSH
26257: PPUSH
// if not unit then
26258: LD_VAR 0 1
26262: NOT
26263: IFFALSE 26267
// exit ;
26265: GO 26455
// side := GetSide ( unit ) ;
26267: LD_ADDR_VAR 0 3
26271: PUSH
26272: LD_VAR 0 1
26276: PPUSH
26277: CALL_OW 255
26281: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26282: LD_ADDR_VAR 0 5
26286: PUSH
26287: LD_VAR 0 3
26291: PPUSH
26292: LD_INT 2
26294: PUSH
26295: LD_INT 30
26297: PUSH
26298: LD_INT 1
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: PUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 3
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: LD_INT 29
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: LIST
26329: LIST
26330: PPUSH
26331: CALL 11553 0 2
26335: ST_TO_ADDR
// if not b then
26336: LD_VAR 0 5
26340: NOT
26341: IFFALSE 26345
// exit ;
26343: GO 26455
// if GetTag ( unit ) = 21 then
26345: LD_VAR 0 1
26349: PPUSH
26350: CALL_OW 110
26354: PUSH
26355: LD_INT 21
26357: EQUAL
26358: IFFALSE 26455
// begin c := NearestUnitToUnit ( b , unit ) ;
26360: LD_ADDR_VAR 0 6
26364: PUSH
26365: LD_VAR 0 5
26369: PPUSH
26370: LD_VAR 0 1
26374: PPUSH
26375: CALL_OW 74
26379: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26380: LD_VAR 0 1
26384: PPUSH
26385: LD_VAR 0 6
26389: PPUSH
26390: CALL_OW 250
26394: PPUSH
26395: LD_VAR 0 6
26399: PPUSH
26400: CALL_OW 251
26404: PPUSH
26405: CALL_OW 297
26409: PUSH
26410: LD_INT 6
26412: GREATER
26413: IFFALSE 26431
// ComMoveUnit ( unit , c ) else
26415: LD_VAR 0 1
26419: PPUSH
26420: LD_VAR 0 6
26424: PPUSH
26425: CALL_OW 112
26429: GO 26455
// begin SetFuel ( unit , 100 ) ;
26431: LD_VAR 0 1
26435: PPUSH
26436: LD_INT 100
26438: PPUSH
26439: CALL_OW 240
// SetTag ( unit , 0 ) ;
26443: LD_VAR 0 1
26447: PPUSH
26448: LD_INT 0
26450: PPUSH
26451: CALL_OW 109
// end ; end ; end ;
26455: LD_VAR 0 2
26459: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26460: LD_INT 0
26462: PPUSH
26463: PPUSH
26464: PPUSH
26465: PPUSH
26466: PPUSH
26467: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26468: LD_ADDR_VAR 0 7
26472: PUSH
26473: LD_VAR 0 1
26477: PPUSH
26478: LD_INT 33
26480: PUSH
26481: LD_INT 2
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 3
26490: PUSH
26491: LD_INT 61
26493: PUSH
26494: EMPTY
26495: LIST
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PPUSH
26505: CALL 11553 0 2
26509: ST_TO_ADDR
// if not vehs then
26510: LD_VAR 0 7
26514: NOT
26515: IFFALSE 26519
// exit ;
26517: GO 26804
// if nation = 1 then
26519: LD_VAR 0 2
26523: PUSH
26524: LD_INT 1
26526: EQUAL
26527: IFFALSE 26697
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26529: LD_VAR 0 1
26533: PPUSH
26534: LD_INT 30
26536: PUSH
26537: LD_INT 36
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PPUSH
26544: CALL 11553 0 2
26548: NOT
26549: IFFALSE 26555
// exit else
26551: GO 26804
26553: GO 26695
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26555: LD_ADDR_VAR 0 5
26559: PUSH
26560: LD_VAR 0 1
26564: PPUSH
26565: LD_INT 30
26567: PUSH
26568: LD_INT 36
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PPUSH
26575: CALL 11553 0 2
26579: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26580: LD_ADDR_VAR 0 6
26584: PUSH
26585: LD_VAR 0 5
26589: PUSH
26590: LD_INT 1
26592: ARRAY
26593: PPUSH
26594: CALL_OW 313
26598: ST_TO_ADDR
// for i = vehs downto 1 do
26599: LD_ADDR_VAR 0 4
26603: PUSH
26604: DOUBLE
26605: LD_VAR 0 7
26609: INC
26610: ST_TO_ADDR
26611: LD_INT 1
26613: PUSH
26614: FOR_DOWNTO
26615: IFFALSE 26693
// begin if not IsControledBy ( vehs [ i ] ) then
26617: LD_VAR 0 7
26621: PUSH
26622: LD_VAR 0 4
26626: ARRAY
26627: PPUSH
26628: CALL_OW 312
26632: NOT
26633: IFFALSE 26691
// begin tmp := MCV_RemoteDriver ( oper ) ;
26635: LD_ADDR_VAR 0 8
26639: PUSH
26640: LD_VAR 0 6
26644: PPUSH
26645: CALL 26809 0 1
26649: ST_TO_ADDR
// if not tmp then
26650: LD_VAR 0 8
26654: NOT
26655: IFFALSE 26663
// exit else
26657: POP
26658: POP
26659: GO 26804
26661: GO 26691
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26663: LD_VAR 0 7
26667: PUSH
26668: LD_VAR 0 4
26672: ARRAY
26673: PPUSH
26674: LD_VAR 0 8
26678: PUSH
26679: LD_INT 1
26681: ARRAY
26682: PUSH
26683: LD_INT 1
26685: ARRAY
26686: PPUSH
26687: CALL_OW 135
// end ; end ;
26691: GO 26614
26693: POP
26694: POP
// end ; end else
26695: GO 26804
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26697: LD_VAR 0 1
26701: PPUSH
26702: LD_INT 34
26704: PUSH
26705: LD_INT 31
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: PPUSH
26712: CALL 11553 0 2
26716: NOT
26717: IFFALSE 26723
// exit else
26719: GO 26804
26721: GO 26804
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26723: LD_ADDR_VAR 0 5
26727: PUSH
26728: LD_VAR 0 1
26732: PPUSH
26733: LD_INT 34
26735: PUSH
26736: LD_INT 31
26738: PUSH
26739: EMPTY
26740: LIST
26741: LIST
26742: PPUSH
26743: CALL 11553 0 2
26747: ST_TO_ADDR
// oper := [ ] ;
26748: LD_ADDR_VAR 0 6
26752: PUSH
26753: EMPTY
26754: ST_TO_ADDR
// for i = 1 to ct do
26755: LD_ADDR_VAR 0 4
26759: PUSH
26760: DOUBLE
26761: LD_INT 1
26763: DEC
26764: ST_TO_ADDR
26765: LD_VAR 0 5
26769: PUSH
26770: FOR_TO
26771: IFFALSE 26802
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26773: LD_ADDR_VAR 0 6
26777: PUSH
26778: LD_VAR 0 6
26782: PUSH
26783: LD_VAR 0 5
26787: PUSH
26788: LD_VAR 0 4
26792: ARRAY
26793: PPUSH
26794: CALL 31785 0 1
26798: ADD
26799: ST_TO_ADDR
26800: GO 26770
26802: POP
26803: POP
// end ; end ; end ;
26804: LD_VAR 0 3
26808: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26809: LD_INT 0
26811: PPUSH
26812: PPUSH
26813: PPUSH
26814: PPUSH
26815: PPUSH
26816: PPUSH
// if not drivers then
26817: LD_VAR 0 1
26821: NOT
26822: IFFALSE 26828
// exit else
26824: GO 27108
26826: GO 27108
// begin linked := [ ] ;
26828: LD_ADDR_VAR 0 5
26832: PUSH
26833: EMPTY
26834: ST_TO_ADDR
// for i = 1 to drivers do
26835: LD_ADDR_VAR 0 3
26839: PUSH
26840: DOUBLE
26841: LD_INT 1
26843: DEC
26844: ST_TO_ADDR
26845: LD_VAR 0 1
26849: PUSH
26850: FOR_TO
26851: IFFALSE 27096
// begin if CanControl ( drivers [ i ] ) then
26853: LD_VAR 0 1
26857: PUSH
26858: LD_VAR 0 3
26862: ARRAY
26863: PPUSH
26864: CALL 32357 0 1
26868: IFFALSE 27094
// if i > 1 then
26870: LD_VAR 0 3
26874: PUSH
26875: LD_INT 1
26877: GREATER
26878: IFFALSE 27055
// begin m := false ;
26880: LD_ADDR_VAR 0 6
26884: PUSH
26885: LD_INT 0
26887: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26888: LD_ADDR_VAR 0 7
26892: PUSH
26893: LD_VAR 0 1
26897: PUSH
26898: LD_VAR 0 3
26902: ARRAY
26903: PPUSH
26904: CALL_OW 432
26908: ST_TO_ADDR
// for j = 1 to linked do
26909: LD_ADDR_VAR 0 4
26913: PUSH
26914: DOUBLE
26915: LD_INT 1
26917: DEC
26918: ST_TO_ADDR
26919: LD_VAR 0 5
26923: PUSH
26924: FOR_TO
26925: IFFALSE 26999
// begin if l < linked [ j ] [ 2 ] then
26927: LD_VAR 0 7
26931: PUSH
26932: LD_VAR 0 5
26936: PUSH
26937: LD_VAR 0 4
26941: ARRAY
26942: PUSH
26943: LD_INT 2
26945: ARRAY
26946: LESS
26947: IFFALSE 26997
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26949: LD_ADDR_VAR 0 5
26953: PUSH
26954: LD_VAR 0 5
26958: PPUSH
26959: LD_INT 1
26961: PPUSH
26962: LD_VAR 0 1
26966: PUSH
26967: LD_VAR 0 3
26971: ARRAY
26972: PUSH
26973: LD_VAR 0 7
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PPUSH
26982: CALL_OW 2
26986: ST_TO_ADDR
// m := true ;
26987: LD_ADDR_VAR 0 6
26991: PUSH
26992: LD_INT 1
26994: ST_TO_ADDR
// break ;
26995: GO 26999
// end ; end ;
26997: GO 26924
26999: POP
27000: POP
// if not m then
27001: LD_VAR 0 6
27005: NOT
27006: IFFALSE 27053
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27008: LD_ADDR_VAR 0 5
27012: PUSH
27013: LD_VAR 0 5
27017: PUSH
27018: LD_VAR 0 1
27022: PUSH
27023: LD_VAR 0 3
27027: ARRAY
27028: PUSH
27029: LD_VAR 0 1
27033: PUSH
27034: LD_VAR 0 3
27038: ARRAY
27039: PPUSH
27040: CALL_OW 432
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: EMPTY
27050: LIST
27051: ADD
27052: ST_TO_ADDR
// end else
27053: GO 27094
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27055: LD_ADDR_VAR 0 5
27059: PUSH
27060: LD_VAR 0 1
27064: PUSH
27065: LD_VAR 0 3
27069: ARRAY
27070: PUSH
27071: LD_VAR 0 1
27075: PUSH
27076: LD_VAR 0 3
27080: ARRAY
27081: PPUSH
27082: CALL_OW 432
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: PUSH
27091: EMPTY
27092: LIST
27093: ST_TO_ADDR
// end ;
27094: GO 26850
27096: POP
27097: POP
// result := linked ;
27098: LD_ADDR_VAR 0 2
27102: PUSH
27103: LD_VAR 0 5
27107: ST_TO_ADDR
// end ; end ;
27108: LD_VAR 0 2
27112: RET
// export function MCV_ToRepair ( unit ) ; begin
27113: LD_INT 0
27115: PPUSH
// if not unit then
27116: LD_VAR 0 1
27120: NOT
27121: IFFALSE 27127
// exit else
27123: GO 27158
27125: GO 27158
// begin SetTag ( unit , 6 ) ;
27127: LD_VAR 0 1
27131: PPUSH
27132: LD_INT 6
27134: PPUSH
27135: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27139: LD_VAR 0 1
27143: PPUSH
27144: CALL_OW 255
27148: PPUSH
27149: LD_VAR 0 1
27153: PPUSH
27154: CALL 25714 0 2
// end ; end ;
27158: LD_VAR 0 2
27162: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27163: LD_INT 0
27165: PPUSH
27166: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27167: LD_VAR 0 1
27171: PPUSH
27172: LD_INT 6
27174: PPUSH
27175: EMPTY
27176: PPUSH
27177: CALL 12256 0 3
27181: IFFALSE 27274
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27183: LD_ADDR_VAR 0 3
27187: PUSH
27188: DOUBLE
27189: LD_VAR 0 1
27193: PPUSH
27194: LD_INT 6
27196: PPUSH
27197: EMPTY
27198: PPUSH
27199: CALL 12256 0 3
27203: INC
27204: ST_TO_ADDR
27205: LD_INT 1
27207: PUSH
27208: FOR_DOWNTO
27209: IFFALSE 27272
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27211: LD_VAR 0 1
27215: PPUSH
27216: LD_INT 6
27218: PPUSH
27219: EMPTY
27220: PPUSH
27221: CALL 12256 0 3
27225: PUSH
27226: LD_VAR 0 3
27230: ARRAY
27231: PPUSH
27232: CALL_OW 256
27236: PUSH
27237: LD_INT 1000
27239: EQUAL
27240: IFFALSE 27270
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27242: LD_VAR 0 1
27246: PPUSH
27247: LD_INT 6
27249: PPUSH
27250: EMPTY
27251: PPUSH
27252: CALL 12256 0 3
27256: PUSH
27257: LD_VAR 0 3
27261: ARRAY
27262: PPUSH
27263: LD_INT 0
27265: PPUSH
27266: CALL_OW 109
27270: GO 27208
27272: POP
27273: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27274: LD_VAR 0 1
27278: PPUSH
27279: LD_INT 10
27281: PPUSH
27282: EMPTY
27283: PPUSH
27284: CALL 12256 0 3
27288: IFFALSE 27405
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27290: LD_ADDR_VAR 0 3
27294: PUSH
27295: DOUBLE
27296: LD_VAR 0 1
27300: PPUSH
27301: LD_INT 10
27303: PPUSH
27304: EMPTY
27305: PPUSH
27306: CALL 12256 0 3
27310: INC
27311: ST_TO_ADDR
27312: LD_INT 1
27314: PUSH
27315: FOR_DOWNTO
27316: IFFALSE 27403
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27318: LD_VAR 0 1
27322: PPUSH
27323: LD_INT 10
27325: PPUSH
27326: EMPTY
27327: PPUSH
27328: CALL 12256 0 3
27332: PUSH
27333: LD_VAR 0 3
27337: ARRAY
27338: PPUSH
27339: CALL_OW 302
27343: NOT
27344: PUSH
27345: LD_VAR 0 1
27349: PPUSH
27350: LD_INT 10
27352: PPUSH
27353: EMPTY
27354: PPUSH
27355: CALL 12256 0 3
27359: PUSH
27360: LD_VAR 0 3
27364: ARRAY
27365: PPUSH
27366: CALL_OW 301
27370: OR
27371: IFFALSE 27401
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27373: LD_VAR 0 1
27377: PPUSH
27378: LD_INT 10
27380: PPUSH
27381: EMPTY
27382: PPUSH
27383: CALL 12256 0 3
27387: PUSH
27388: LD_VAR 0 3
27392: ARRAY
27393: PPUSH
27394: LD_INT 0
27396: PPUSH
27397: CALL_OW 109
27401: GO 27315
27403: POP
27404: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: LD_VAR 0 1
27414: PPUSH
27415: EMPTY
27416: PPUSH
27417: CALL 11854 0 2
27421: PUSH
27422: LD_VAR 0 1
27426: PPUSH
27427: LD_INT 7
27429: PPUSH
27430: EMPTY
27431: PPUSH
27432: CALL 12256 0 3
27436: DIFF
27437: PUSH
27438: FOR_IN
27439: IFFALSE 27483
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27441: LD_VAR 0 3
27445: PPUSH
27446: CALL_OW 256
27450: PUSH
27451: LD_INT 650
27453: LESS
27454: PUSH
27455: LD_VAR 0 3
27459: PPUSH
27460: CALL_OW 110
27464: PUSH
27465: LD_INT 6
27467: EQUAL
27468: NOT
27469: AND
27470: IFFALSE 27481
// MCV_ToRepair ( i ) ;
27472: LD_VAR 0 3
27476: PPUSH
27477: CALL 27113 0 1
27481: GO 27438
27483: POP
27484: POP
// end ; end_of_file end_of_file
27485: LD_VAR 0 2
27489: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27490: LD_STRING SAILEvent [
27492: PUSH
27493: LD_VAR 0 1
27497: STR
27498: PUSH
27499: LD_STRING ]
27501: STR
27502: PPUSH
27503: CALL 7950 0 1
// if event = 101 and dialog_north then
27507: LD_VAR 0 1
27511: PUSH
27512: LD_INT 101
27514: EQUAL
27515: PUSH
27516: LD_EXP 6
27520: AND
27521: IFFALSE 27585
// begin dialog_north := false ;
27523: LD_ADDR_EXP 6
27527: PUSH
27528: LD_INT 0
27530: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27531: LD_EXP 5
27535: PPUSH
27536: LD_STRING DS1
27538: PUSH
27539: LD_STRING DS2
27541: PUSH
27542: LD_STRING DS3
27544: PUSH
27545: LD_STRING DS6
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 1
27556: PPUSH
27557: LD_INT 4
27559: PPUSH
27560: CALL_OW 12
27564: ARRAY
27565: PPUSH
27566: CALL_OW 94
// Wait ( 4 4$00 ) ;
27570: LD_INT 8400
27572: PPUSH
27573: CALL_OW 67
// dialog_north := true ;
27577: LD_ADDR_EXP 6
27581: PUSH
27582: LD_INT 1
27584: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27585: LD_VAR 0 1
27589: PUSH
27590: LD_INT 102
27592: EQUAL
27593: PUSH
27594: LD_EXP 7
27598: AND
27599: IFFALSE 27659
// begin dialog_south := false ;
27601: LD_ADDR_EXP 7
27605: PUSH
27606: LD_INT 0
27608: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27609: LD_EXP 4
27613: PPUSH
27614: LD_STRING DJ1
27616: PUSH
27617: LD_STRING DJ4
27619: PUSH
27620: LD_STRING DJ6
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: PPUSH
27631: LD_INT 3
27633: PPUSH
27634: CALL_OW 12
27638: ARRAY
27639: PPUSH
27640: CALL_OW 94
// Wait ( 4 4$00 ) ;
27644: LD_INT 8400
27646: PPUSH
27647: CALL_OW 67
// dialog_south := true ;
27651: LD_ADDR_EXP 7
27655: PUSH
27656: LD_INT 1
27658: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27659: LD_VAR 0 1
27663: PUSH
27664: LD_INT 104
27666: EQUAL
27667: PUSH
27668: LD_EXP 8
27672: AND
27673: IFFALSE 27695
// begin dialog_popov := false ;
27675: LD_ADDR_EXP 8
27679: PUSH
27680: LD_INT 0
27682: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27683: LD_EXP 26
27687: PPUSH
27688: LD_STRING DR4
27690: PPUSH
27691: CALL_OW 94
// end ; end ;
27695: PPOPN 1
27697: END
// on BuildingStarted ( b , unit ) do var side , i ;
27698: LD_INT 0
27700: PPUSH
27701: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27702: LD_EXP 41
27706: PUSH
27707: LD_VAR 0 1
27711: PPUSH
27712: CALL_OW 255
27716: ARRAY
27717: IFFALSE 27895
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27719: LD_STRING BuildingStarted [side: 
27721: PUSH
27722: LD_VAR 0 1
27726: PPUSH
27727: CALL_OW 255
27731: STR
27732: PUSH
27733: LD_STRING ; btype: 
27735: STR
27736: PUSH
27737: LD_VAR 0 1
27741: PPUSH
27742: CALL_OW 266
27746: STR
27747: PUSH
27748: LD_STRING ; unit: 
27750: STR
27751: PUSH
27752: LD_VAR 0 2
27756: STR
27757: PUSH
27758: LD_STRING ]
27760: STR
27761: PPUSH
27762: CALL 7950 0 1
// side := GetSide ( b ) ;
27766: LD_ADDR_VAR 0 3
27770: PUSH
27771: LD_VAR 0 1
27775: PPUSH
27776: CALL_OW 255
27780: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27781: LD_VAR 0 3
27785: PPUSH
27786: LD_INT 21
27788: PUSH
27789: LD_INT 3
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PPUSH
27796: CALL 11553 0 2
27800: PUSH
27801: LD_INT 1
27803: EQUAL
27804: IFFALSE 27895
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27806: LD_ADDR_VAR 0 4
27810: PUSH
27811: LD_VAR 0 3
27815: PPUSH
27816: LD_INT 21
27818: PUSH
27819: LD_INT 1
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PPUSH
27826: CALL 11553 0 2
27830: PUSH
27831: LD_VAR 0 3
27835: PPUSH
27836: LD_INT 2
27838: PPUSH
27839: EMPTY
27840: PPUSH
27841: CALL 11636 0 3
27845: DIFF
27846: PUSH
27847: FOR_IN
27848: IFFALSE 27893
// if not HasTask ( i ) then
27850: LD_VAR 0 4
27854: PPUSH
27855: CALL_OW 314
27859: NOT
27860: IFFALSE 27891
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27862: LD_VAR 0 4
27866: PPUSH
27867: LD_VAR 0 1
27871: PPUSH
27872: CALL_OW 250
27876: PPUSH
27877: LD_VAR 0 1
27881: PPUSH
27882: CALL_OW 251
27886: PPUSH
27887: CALL_OW 111
27891: GO 27847
27893: POP
27894: POP
// end ;
27895: PPOPN 4
27897: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27898: LD_EXP 41
27902: PUSH
27903: LD_VAR 0 1
27907: PPUSH
27908: CALL_OW 255
27912: ARRAY
27913: IFFALSE 28282
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27915: LD_STRING BuildingComplete [side: 
27917: PUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 255
27927: STR
27928: PUSH
27929: LD_STRING ; btype: 
27931: STR
27932: PUSH
27933: LD_VAR 0 1
27937: PPUSH
27938: CALL_OW 266
27942: STR
27943: PUSH
27944: LD_STRING ]
27946: STR
27947: PPUSH
27948: CALL 7950 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27952: LD_ADDR_EXP 48
27956: PUSH
27957: LD_EXP 48
27961: PPUSH
27962: LD_VAR 0 1
27966: PPUSH
27967: CALL_OW 255
27971: PPUSH
27972: LD_VAR 0 1
27976: PPUSH
27977: CALL_OW 266
27981: PPUSH
27982: LD_VAR 0 1
27986: PPUSH
27987: CALL_OW 250
27991: PUSH
27992: LD_VAR 0 1
27996: PPUSH
27997: CALL_OW 251
28001: PUSH
28002: LD_VAR 0 1
28006: PPUSH
28007: CALL_OW 254
28011: PUSH
28012: EMPTY
28013: LIST
28014: LIST
28015: LIST
28016: PPUSH
28017: CALL 42464 0 4
28021: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28022: LD_VAR 0 1
28026: PPUSH
28027: CALL_OW 266
28031: PUSH
28032: LD_INT 6
28034: EQUAL
28035: IFFALSE 28069
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28037: LD_ADDR_EXP 42
28041: PUSH
28042: LD_EXP 42
28046: PPUSH
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 255
28056: PPUSH
28057: LD_VAR 0 1
28061: PPUSH
28062: EMPTY
28063: PPUSH
28064: CALL 42373 0 4
28068: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28069: LD_VAR 0 1
28073: PPUSH
28074: CALL_OW 266
28078: PUSH
28079: LD_INT 0
28081: EQUAL
28082: IFFALSE 28192
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28084: LD_ADDR_EXP 50
28088: PUSH
28089: LD_EXP 50
28093: PPUSH
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 255
28103: PPUSH
28104: LD_INT 0
28106: PPUSH
28107: EMPTY
28108: PPUSH
28109: CALL 42373 0 4
28113: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28114: LD_VAR 0 1
28118: PPUSH
28119: CALL_OW 274
28123: PPUSH
28124: LD_INT 1
28126: PPUSH
28127: LD_EXP 74
28131: PUSH
28132: LD_INT 1
28134: ARRAY
28135: PPUSH
28136: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: CALL_OW 274
28149: PPUSH
28150: LD_INT 2
28152: PPUSH
28153: LD_EXP 74
28157: PUSH
28158: LD_INT 2
28160: ARRAY
28161: PPUSH
28162: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28166: LD_VAR 0 1
28170: PPUSH
28171: CALL_OW 274
28175: PPUSH
28176: LD_INT 3
28178: PPUSH
28179: LD_EXP 74
28183: PUSH
28184: LD_INT 3
28186: ARRAY
28187: PPUSH
28188: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28192: LD_VAR 0 1
28196: PPUSH
28197: CALL_OW 266
28201: PUSH
28202: LD_INT 2
28204: EQUAL
28205: IFFALSE 28237
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28207: LD_ADDR_EXP 50
28211: PUSH
28212: LD_EXP 50
28216: PPUSH
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 255
28226: PPUSH
28227: LD_INT 2
28229: PPUSH
28230: EMPTY
28231: PPUSH
28232: CALL 42373 0 4
28236: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28237: LD_VAR 0 1
28241: PPUSH
28242: CALL_OW 266
28246: PUSH
28247: LD_INT 4
28249: EQUAL
28250: IFFALSE 28282
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28252: LD_ADDR_EXP 50
28256: PUSH
28257: LD_EXP 50
28261: PPUSH
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 255
28271: PPUSH
28272: LD_INT 4
28274: PPUSH
28275: EMPTY
28276: PPUSH
28277: CALL 42373 0 4
28281: ST_TO_ADDR
// end ;
28282: PPOPN 1
28284: END
// on ResearchComplete ( tech , lab ) do var i ;
28285: LD_INT 0
28287: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28288: LD_EXP 41
28292: PUSH
28293: LD_VAR 0 2
28297: PPUSH
28298: CALL_OW 255
28302: ARRAY
28303: IFFALSE 28587
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28305: LD_STRING ResearchComplete [side: 
28307: PUSH
28308: LD_VAR 0 2
28312: PPUSH
28313: CALL_OW 255
28317: PPUSH
28318: CALL_OW 255
28322: STR
28323: PUSH
28324: LD_STRING ; tech:
28326: STR
28327: PUSH
28328: LD_VAR 0 1
28332: STR
28333: PUSH
28334: LD_STRING ]
28336: STR
28337: PPUSH
28338: CALL 7950 0 1
// for i = 1 to MREG_ToRes do
28342: LD_ADDR_VAR 0 3
28346: PUSH
28347: DOUBLE
28348: LD_INT 1
28350: DEC
28351: ST_TO_ADDR
28352: LD_EXP 52
28356: PUSH
28357: FOR_TO
28358: IFFALSE 28445
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28360: LD_EXP 52
28364: PUSH
28365: LD_VAR 0 3
28369: ARRAY
28370: PUSH
28371: LD_INT 1
28373: ARRAY
28374: PUSH
28375: LD_VAR 0 2
28379: PPUSH
28380: CALL_OW 255
28384: EQUAL
28385: PUSH
28386: LD_EXP 52
28390: PUSH
28391: LD_VAR 0 3
28395: ARRAY
28396: PUSH
28397: LD_INT 2
28399: ARRAY
28400: PUSH
28401: LD_VAR 0 1
28405: EQUAL
28406: AND
28407: IFFALSE 28443
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28409: LD_ADDR_EXP 52
28413: PUSH
28414: LD_EXP 52
28418: PPUSH
28419: LD_VAR 0 2
28423: PPUSH
28424: CALL_OW 255
28428: PPUSH
28429: LD_VAR 0 1
28433: PPUSH
28434: EMPTY
28435: PPUSH
28436: CALL 42464 0 4
28440: ST_TO_ADDR
// break ;
28441: GO 28445
// end ;
28443: GO 28357
28445: POP
28446: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28447: LD_VAR 0 1
28451: PUSH
28452: LD_INT 2
28454: PUSH
28455: LD_INT 11
28457: PUSH
28458: LD_INT 4
28460: PUSH
28461: LD_INT 3
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: IN
28470: IFFALSE 28587
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28472: LD_ADDR_VAR 0 3
28476: PUSH
28477: LD_VAR 0 2
28481: PPUSH
28482: CALL_OW 255
28486: PPUSH
28487: LD_INT 16
28489: PPUSH
28490: LD_INT 25
28492: PUSH
28493: LD_INT 4
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PPUSH
28500: CALL 12256 0 3
28504: ST_TO_ADDR
// if i then
28505: LD_VAR 0 3
28509: IFFALSE 28527
// SetTag ( i [ 1 ] , 0 ) ;
28511: LD_VAR 0 3
28515: PUSH
28516: LD_INT 1
28518: ARRAY
28519: PPUSH
28520: LD_INT 0
28522: PPUSH
28523: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28527: LD_ADDR_VAR 0 3
28531: PUSH
28532: LD_VAR 0 2
28536: PPUSH
28537: CALL_OW 255
28541: PPUSH
28542: LD_INT 171
28544: PPUSH
28545: EMPTY
28546: PPUSH
28547: CALL 12256 0 3
28551: ST_TO_ADDR
// if i then
28552: LD_VAR 0 3
28556: IFFALSE 28587
// begin SetTag ( i [ 1 ] , 0 ) ;
28558: LD_VAR 0 3
28562: PUSH
28563: LD_INT 1
28565: ARRAY
28566: PPUSH
28567: LD_INT 0
28569: PPUSH
28570: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28574: LD_VAR 0 3
28578: PUSH
28579: LD_INT 1
28581: ARRAY
28582: PPUSH
28583: CALL_OW 122
// end ; end ; end ;
28587: PPOPN 3
28589: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28590: LD_INT 0
28592: PPUSH
28593: PPUSH
28594: PPUSH
28595: PPUSH
28596: PPUSH
28597: PPUSH
28598: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28599: LD_EXP 41
28603: PUSH
28604: LD_VAR 0 2
28608: PPUSH
28609: CALL_OW 255
28613: ARRAY
28614: IFFALSE 29341
// begin side := GetSide ( veh ) ;
28616: LD_ADDR_VAR 0 4
28620: PUSH
28621: LD_VAR 0 1
28625: PPUSH
28626: CALL_OW 255
28630: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28631: LD_ADDR_VAR 0 6
28635: PUSH
28636: LD_VAR 0 1
28640: PPUSH
28641: CALL_OW 265
28645: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28646: LD_ADDR_VAR 0 7
28650: PUSH
28651: LD_VAR 0 1
28655: PPUSH
28656: CALL_OW 262
28660: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28661: LD_ADDR_VAR 0 8
28665: PUSH
28666: LD_VAR 0 1
28670: PPUSH
28671: CALL_OW 263
28675: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28676: LD_ADDR_VAR 0 9
28680: PUSH
28681: LD_VAR 0 1
28685: PPUSH
28686: CALL_OW 264
28690: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28691: LD_STRING VehicleConstructed [side: 
28693: PUSH
28694: LD_VAR 0 4
28698: STR
28699: PUSH
28700: LD_STRING ; id:
28702: STR
28703: PUSH
28704: LD_VAR 0 1
28708: STR
28709: PUSH
28710: LD_STRING ; components: [
28712: STR
28713: PUSH
28714: LD_VAR 0 6
28718: STR
28719: PUSH
28720: LD_STRING , 
28722: STR
28723: PUSH
28724: LD_VAR 0 7
28728: STR
28729: PUSH
28730: LD_STRING , 
28732: STR
28733: PUSH
28734: LD_VAR 0 8
28738: STR
28739: PUSH
28740: LD_STRING , 
28742: STR
28743: PUSH
28744: LD_VAR 0 9
28748: STR
28749: PUSH
28750: LD_STRING ]]
28752: STR
28753: PPUSH
28754: CALL 7950 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28758: LD_VAR 0 1
28762: PPUSH
28763: CALL_OW 264
28767: PUSH
28768: LD_INT 13
28770: PUSH
28771: LD_INT 12
28773: PUSH
28774: LD_INT 14
28776: PUSH
28777: LD_INT 51
28779: PUSH
28780: LD_INT 53
28782: PUSH
28783: LD_INT 52
28785: PUSH
28786: LD_INT 32
28788: PUSH
28789: EMPTY
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: IN
28798: NOT
28799: IFFALSE 28841
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28801: LD_ADDR_EXP 61
28805: PUSH
28806: LD_EXP 61
28810: PPUSH
28811: LD_VAR 0 4
28815: PPUSH
28816: LD_EXP 61
28820: PUSH
28821: LD_VAR 0 4
28825: ARRAY
28826: PUSH
28827: LD_INT 1
28829: PLUS
28830: PPUSH
28831: LD_VAR 0 1
28835: PPUSH
28836: CALL 31091 0 4
28840: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28841: LD_VAR 0 1
28845: PPUSH
28846: CALL_OW 264
28850: PUSH
28851: LD_INT 31
28853: EQUAL
28854: IFFALSE 28873
// SetTag ( GetDriver ( veh ) , 9 ) ;
28856: LD_VAR 0 1
28860: PPUSH
28861: CALL 31785 0 1
28865: PPUSH
28866: LD_INT 9
28868: PPUSH
28869: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28873: LD_VAR 0 1
28877: PPUSH
28878: CALL_OW 264
28882: PUSH
28883: LD_INT 14
28885: PUSH
28886: LD_INT 53
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: IN
28893: IFFALSE 28930
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28895: LD_ADDR_EXP 44
28899: PUSH
28900: LD_EXP 44
28904: PPUSH
28905: LD_VAR 0 1
28909: PPUSH
28910: CALL_OW 255
28914: PPUSH
28915: LD_INT 2
28917: PPUSH
28918: LD_VAR 0 1
28922: PPUSH
28923: CALL 31091 0 4
28927: ST_TO_ADDR
// exit ;
28928: GO 29341
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28930: LD_VAR 0 1
28934: PPUSH
28935: CALL_OW 265
28939: PUSH
28940: LD_EXP 68
28944: PUSH
28945: LD_VAR 0 4
28949: ARRAY
28950: PUSH
28951: LD_INT 1
28953: ARRAY
28954: IN
28955: PUSH
28956: LD_VAR 0 1
28960: PPUSH
28961: CALL_OW 262
28965: PUSH
28966: LD_EXP 68
28970: PUSH
28971: LD_VAR 0 4
28975: ARRAY
28976: PUSH
28977: LD_INT 1
28979: ARRAY
28980: IN
28981: AND
28982: PUSH
28983: LD_VAR 0 1
28987: PPUSH
28988: CALL_OW 263
28992: PUSH
28993: LD_EXP 68
28997: PUSH
28998: LD_VAR 0 4
29002: ARRAY
29003: PUSH
29004: LD_INT 1
29006: ARRAY
29007: IN
29008: AND
29009: PUSH
29010: LD_VAR 0 1
29014: PPUSH
29015: CALL_OW 264
29019: PUSH
29020: LD_EXP 68
29024: PUSH
29025: LD_VAR 0 4
29029: ARRAY
29030: PUSH
29031: LD_INT 1
29033: ARRAY
29034: IN
29035: AND
29036: IFFALSE 29080
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29038: LD_ADDR_EXP 69
29042: PUSH
29043: LD_EXP 69
29047: PPUSH
29048: LD_VAR 0 4
29052: PPUSH
29053: LD_EXP 69
29057: PUSH
29058: LD_VAR 0 4
29062: ARRAY
29063: PUSH
29064: LD_INT 1
29066: PLUS
29067: PPUSH
29068: LD_VAR 0 1
29072: PPUSH
29073: CALL 31091 0 4
29077: ST_TO_ADDR
// exit ;
29078: GO 29341
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29080: LD_VAR 0 6
29084: PUSH
29085: LD_EXP 71
29089: PUSH
29090: LD_VAR 0 4
29094: ARRAY
29095: PUSH
29096: LD_INT 1
29098: ARRAY
29099: EQUAL
29100: PUSH
29101: LD_VAR 0 7
29105: PUSH
29106: LD_EXP 71
29110: PUSH
29111: LD_VAR 0 4
29115: ARRAY
29116: PUSH
29117: LD_INT 2
29119: ARRAY
29120: EQUAL
29121: AND
29122: PUSH
29123: LD_VAR 0 8
29127: PUSH
29128: LD_EXP 71
29132: PUSH
29133: LD_VAR 0 4
29137: ARRAY
29138: PUSH
29139: LD_INT 3
29141: ARRAY
29142: EQUAL
29143: AND
29144: PUSH
29145: LD_VAR 0 9
29149: PUSH
29150: LD_EXP 71
29154: PUSH
29155: LD_VAR 0 4
29159: ARRAY
29160: PUSH
29161: LD_INT 4
29163: ARRAY
29164: EQUAL
29165: AND
29166: IFFALSE 29322
// begin tmp := MREG_ToAttack [ side ] ;
29168: LD_ADDR_VAR 0 5
29172: PUSH
29173: LD_EXP 71
29177: PUSH
29178: LD_VAR 0 4
29182: ARRAY
29183: ST_TO_ADDR
// for i = 1 to 4 do
29184: LD_ADDR_VAR 0 3
29188: PUSH
29189: DOUBLE
29190: LD_INT 1
29192: DEC
29193: ST_TO_ADDR
29194: LD_INT 4
29196: PUSH
29197: FOR_TO
29198: IFFALSE 29220
// tmp := Delete ( tmp , 1 ) ;
29200: LD_ADDR_VAR 0 5
29204: PUSH
29205: LD_VAR 0 5
29209: PPUSH
29210: LD_INT 1
29212: PPUSH
29213: CALL_OW 3
29217: ST_TO_ADDR
29218: GO 29197
29220: POP
29221: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29222: LD_ADDR_EXP 71
29226: PUSH
29227: LD_EXP 71
29231: PPUSH
29232: LD_VAR 0 4
29236: PPUSH
29237: LD_VAR 0 5
29241: PPUSH
29242: CALL_OW 1
29246: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29247: LD_ADDR_EXP 73
29251: PUSH
29252: LD_EXP 73
29256: PPUSH
29257: LD_VAR 0 4
29261: PPUSH
29262: LD_EXP 73
29266: PUSH
29267: LD_VAR 0 4
29271: ARRAY
29272: PUSH
29273: LD_INT 1
29275: PLUS
29276: PPUSH
29277: LD_VAR 0 1
29281: PPUSH
29282: CALL 31091 0 4
29286: ST_TO_ADDR
// if tmp = 0 then
29287: LD_VAR 0 5
29291: PUSH
29292: LD_INT 0
29294: EQUAL
29295: IFFALSE 29320
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29297: LD_ADDR_EXP 71
29301: PUSH
29302: LD_EXP 71
29306: PPUSH
29307: LD_VAR 0 4
29311: PPUSH
29312: LD_INT 0
29314: PPUSH
29315: CALL_OW 1
29319: ST_TO_ADDR
// exit ;
29320: GO 29341
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29322: LD_VAR 0 1
29326: PPUSH
29327: CALL_OW 255
29331: PPUSH
29332: LD_VAR 0 1
29336: PPUSH
29337: CALL 25714 0 2
// end ;
29341: PPOPN 9
29343: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29344: LD_EXP 41
29348: PUSH
29349: LD_VAR 0 2
29353: PPUSH
29354: CALL_OW 255
29358: ARRAY
29359: IFFALSE 29591
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29361: LD_STRING ApemanTamed [side: 
29363: PUSH
29364: LD_VAR 0 2
29368: PPUSH
29369: CALL_OW 255
29373: STR
29374: PUSH
29375: LD_STRING ; sci: 
29377: STR
29378: PUSH
29379: LD_VAR 0 2
29383: STR
29384: PUSH
29385: LD_STRING ; ape: 
29387: STR
29388: PUSH
29389: LD_VAR 0 1
29393: STR
29394: PUSH
29395: LD_STRING ]
29397: STR
29398: PPUSH
29399: CALL 7950 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29403: LD_INT 11
29405: PPUSH
29406: LD_VAR 0 2
29410: PPUSH
29411: CALL_OW 255
29415: PPUSH
29416: CALL_OW 321
29420: PUSH
29421: LD_INT 2
29423: EQUAL
29424: NOT
29425: PUSH
29426: LD_INT 2
29428: PPUSH
29429: LD_VAR 0 2
29433: PPUSH
29434: CALL_OW 255
29438: PPUSH
29439: CALL_OW 321
29443: PUSH
29444: LD_INT 2
29446: EQUAL
29447: NOT
29448: OR
29449: PUSH
29450: LD_VAR 0 2
29454: PPUSH
29455: CALL_OW 255
29459: PPUSH
29460: LD_INT 171
29462: PPUSH
29463: EMPTY
29464: PPUSH
29465: CALL 12256 0 3
29469: PUSH
29470: LD_INT 0
29472: EQUAL
29473: AND
29474: IFFALSE 29488
// begin SetTag ( ape , 171 ) ;
29476: LD_VAR 0 1
29480: PPUSH
29481: LD_INT 171
29483: PPUSH
29484: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29488: LD_VAR 0 2
29492: PPUSH
29493: CALL_OW 255
29497: PPUSH
29498: LD_INT 30
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PPUSH
29508: CALL 11553 0 2
29512: IFFALSE 29591
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29514: LD_VAR 0 1
29518: PPUSH
29519: LD_VAR 0 2
29523: PPUSH
29524: CALL_OW 255
29528: PPUSH
29529: LD_INT 30
29531: PUSH
29532: LD_INT 1
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PPUSH
29539: CALL 11553 0 2
29543: PUSH
29544: LD_INT 1
29546: ARRAY
29547: PPUSH
29548: CALL_OW 250
29552: PPUSH
29553: LD_VAR 0 2
29557: PPUSH
29558: CALL_OW 255
29562: PPUSH
29563: LD_INT 30
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PPUSH
29573: CALL 11553 0 2
29577: PUSH
29578: LD_INT 1
29580: ARRAY
29581: PPUSH
29582: CALL_OW 251
29586: PPUSH
29587: CALL_OW 111
// end ;
29591: PPOPN 2
29593: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29594: LD_EXP 41
29598: PUSH
29599: LD_VAR 0 1
29603: PPUSH
29604: CALL_OW 255
29608: ARRAY
29609: IFFALSE 29887
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29611: LD_VAR 0 2
29615: PUSH
29616: LD_VAR 0 2
29620: PPUSH
29621: CALL_OW 255
29625: PPUSH
29626: CALL 11966 0 1
29630: IN
29631: IFFALSE 29772
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29633: LD_VAR 0 1
29637: PPUSH
29638: CALL_OW 266
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: LD_INT 1
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: IN
29653: IFFALSE 29683
// begin Wait ( 0 0$0.3 ) ;
29655: LD_INT 10
29657: PPUSH
29658: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29662: LD_VAR 0 2
29666: PPUSH
29667: LD_INT 16
29669: PPUSH
29670: CALL_OW 336
// ComExitBuilding ( un ) ;
29674: LD_VAR 0 2
29678: PPUSH
29679: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29683: LD_VAR 0 1
29687: PPUSH
29688: CALL_OW 266
29692: PUSH
29693: LD_INT 4
29695: PUSH
29696: LD_INT 5
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: IN
29703: IFFALSE 29772
// begin Wait ( 0 0$0.3 ) ;
29705: LD_INT 10
29707: PPUSH
29708: CALL_OW 67
// if GetTag ( un ) = 0 then
29712: LD_VAR 0 2
29716: PPUSH
29717: CALL_OW 110
29721: PUSH
29722: LD_INT 0
29724: EQUAL
29725: IFFALSE 29741
// SetClass ( un , class_apeman_soldier ) else
29727: LD_VAR 0 2
29731: PPUSH
29732: LD_INT 15
29734: PPUSH
29735: CALL_OW 336
29739: GO 29772
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29741: LD_INT 3
29743: PPUSH
29744: LD_VAR 0 2
29748: PPUSH
29749: CALL_OW 255
29753: PPUSH
29754: CALL_OW 321
29758: IFFALSE 29772
// SetClass ( un , class_apeman_kamikaze ) ;
29760: LD_VAR 0 2
29764: PPUSH
29765: LD_INT 17
29767: PPUSH
29768: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29772: LD_VAR 0 1
29776: PPUSH
29777: CALL_OW 266
29781: PUSH
29782: LD_INT 32
29784: EQUAL
29785: IFFALSE 29887
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29787: LD_ADDR_EXP 70
29791: PUSH
29792: LD_EXP 70
29796: PPUSH
29797: LD_VAR 0 1
29801: PPUSH
29802: CALL_OW 255
29806: PPUSH
29807: LD_EXP 70
29811: PUSH
29812: LD_VAR 0 1
29816: PPUSH
29817: CALL_OW 255
29821: ARRAY
29822: PUSH
29823: LD_INT 1
29825: PLUS
29826: PPUSH
29827: LD_VAR 0 1
29831: PPUSH
29832: CALL 31091 0 4
29836: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29837: LD_ADDR_EXP 70
29841: PUSH
29842: LD_EXP 70
29846: PPUSH
29847: LD_VAR 0 1
29851: PPUSH
29852: CALL_OW 255
29856: PPUSH
29857: LD_EXP 70
29861: PUSH
29862: LD_VAR 0 1
29866: PPUSH
29867: CALL_OW 255
29871: ARRAY
29872: PUSH
29873: LD_INT 1
29875: PLUS
29876: PPUSH
29877: LD_VAR 0 2
29881: PPUSH
29882: CALL 31091 0 4
29886: ST_TO_ADDR
// end ; end ;
29887: PPOPN 2
29889: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29890: LD_VAR 0 1
29894: PPUSH
29895: CALL 54836 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29899: LD_VAR 0 1
29903: PUSH
29904: LD_INT 22
29906: PUSH
29907: LD_INT 3
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 23
29916: PUSH
29917: LD_INT 3
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 21
29926: PUSH
29927: LD_INT 1
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: LIST
29938: PPUSH
29939: CALL_OW 69
29943: IN
29944: IFFALSE 29960
// player_loss := player_loss + 1 ;
29946: LD_ADDR_EXP 10
29950: PUSH
29951: LD_EXP 10
29955: PUSH
29956: LD_INT 1
29958: PLUS
29959: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29960: LD_VAR 0 1
29964: PUSH
29965: LD_INT 22
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 21
29977: PUSH
29978: LD_INT 3
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PPUSH
29989: CALL_OW 69
29993: IN
29994: PUSH
29995: LD_EXP 15
29999: NOT
30000: AND
30001: IFFALSE 30064
// begin alfa_north_triggered := true ;
30003: LD_ADDR_EXP 15
30007: PUSH
30008: LD_INT 1
30010: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30011: LD_EXP 5
30015: PPUSH
30016: LD_STRING DS4
30018: PPUSH
30019: CALL_OW 94
// Wait ( 1 1$25 ) ;
30023: LD_INT 2975
30025: PPUSH
30026: CALL_OW 67
// if not isTest then
30030: LD_EXP 1
30034: NOT
30035: IFFALSE 30064
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30037: LD_INT 20
30039: PPUSH
30040: LD_INT 5
30042: PUSH
30043: LD_INT 6
30045: PUSH
30046: LD_INT 7
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: LIST
30053: PUSH
30054: LD_OWVAR 67
30058: ARRAY
30059: PPUSH
30060: CALL 7088 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30064: LD_VAR 0 1
30068: PUSH
30069: LD_INT 22
30071: PUSH
30072: LD_INT 4
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 21
30081: PUSH
30082: LD_INT 3
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PPUSH
30093: CALL_OW 69
30097: IN
30098: PUSH
30099: LD_EXP 16
30103: NOT
30104: AND
30105: IFFALSE 30168
// begin alfa_south_triggered := true ;
30107: LD_ADDR_EXP 16
30111: PUSH
30112: LD_INT 1
30114: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30115: LD_EXP 4
30119: PPUSH
30120: LD_STRING DJ3
30122: PPUSH
30123: CALL_OW 94
// Wait ( 0 0$45 ) ;
30127: LD_INT 1575
30129: PPUSH
30130: CALL_OW 67
// if not isTest then
30134: LD_EXP 1
30138: NOT
30139: IFFALSE 30168
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30141: LD_INT 20
30143: PPUSH
30144: LD_INT 5
30146: PUSH
30147: LD_INT 6
30149: PUSH
30150: LD_INT 7
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: LIST
30157: PUSH
30158: LD_OWVAR 67
30162: ARRAY
30163: PPUSH
30164: CALL 7088 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30168: LD_VAR 0 1
30172: PPUSH
30173: CALL_OW 266
30177: PUSH
30178: LD_INT 1
30180: EQUAL
30181: PUSH
30182: LD_VAR 0 1
30186: PPUSH
30187: CALL_OW 255
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: LD_INT 4
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: IN
30202: AND
30203: IFFALSE 30212
// RaiseSailEvent ( 104 ) ;
30205: LD_INT 104
30207: PPUSH
30208: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30212: LD_EXP 41
30216: PUSH
30217: LD_VAR 0 1
30221: PPUSH
30222: CALL_OW 255
30226: ARRAY
30227: IFFALSE 30614
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30229: LD_STRING UnitDestroyed [side 
30231: PUSH
30232: LD_VAR 0 1
30236: PPUSH
30237: CALL_OW 255
30241: STR
30242: PUSH
30243: LD_STRING ; id: 
30245: STR
30246: PUSH
30247: LD_VAR 0 1
30251: STR
30252: PUSH
30253: LD_STRING ; type: 
30255: STR
30256: PUSH
30257: LD_VAR 0 1
30261: PPUSH
30262: CALL_OW 247
30266: STR
30267: PUSH
30268: LD_STRING ]
30270: STR
30271: PPUSH
30272: CALL 7950 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30276: LD_VAR 0 1
30280: PUSH
30281: LD_VAR 0 1
30285: PPUSH
30286: CALL_OW 255
30290: PPUSH
30291: LD_INT 21
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PPUSH
30301: CALL 11553 0 2
30305: IN
30306: IFFALSE 30462
// begin if MCF_HasClass ( un ) then
30308: LD_VAR 0 1
30312: PPUSH
30313: CALL 14259 0 1
30317: IFFALSE 30462
// case MCF_HasClass ( un ) of 1 :
30319: LD_VAR 0 1
30323: PPUSH
30324: CALL 14259 0 1
30328: PUSH
30329: LD_INT 1
30331: DOUBLE
30332: EQUAL
30333: IFTRUE 30337
30335: GO 30362
30337: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30338: LD_VAR 0 1
30342: PPUSH
30343: CALL_OW 255
30347: PPUSH
30348: LD_STRING ToArm
30350: PPUSH
30351: LD_VAR 0 1
30355: PPUSH
30356: CALL 14432 0 3
30360: GO 30462
30362: LD_INT 2
30364: DOUBLE
30365: EQUAL
30366: IFTRUE 30370
30368: GO 30395
30370: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30371: LD_VAR 0 1
30375: PPUSH
30376: CALL_OW 255
30380: PPUSH
30381: LD_STRING ToDep
30383: PPUSH
30384: LD_VAR 0 1
30388: PPUSH
30389: CALL 14432 0 3
30393: GO 30462
30395: LD_INT 3
30397: DOUBLE
30398: EQUAL
30399: IFTRUE 30403
30401: GO 30428
30403: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30404: LD_VAR 0 1
30408: PPUSH
30409: CALL_OW 255
30413: PPUSH
30414: LD_STRING ToFac
30416: PPUSH
30417: LD_VAR 0 1
30421: PPUSH
30422: CALL 14432 0 3
30426: GO 30462
30428: LD_INT 4
30430: DOUBLE
30431: EQUAL
30432: IFTRUE 30436
30434: GO 30461
30436: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30437: LD_VAR 0 1
30441: PPUSH
30442: CALL_OW 255
30446: PPUSH
30447: LD_STRING ToLab
30449: PPUSH
30450: LD_VAR 0 1
30454: PPUSH
30455: CALL 14432 0 3
30459: GO 30462
30461: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30462: LD_VAR 0 1
30466: PUSH
30467: LD_EXP 69
30471: PUSH
30472: LD_VAR 0 1
30476: PPUSH
30477: CALL_OW 255
30481: ARRAY
30482: IN
30483: IFFALSE 30568
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30485: LD_ADDR_EXP 69
30489: PUSH
30490: LD_EXP 69
30494: PPUSH
30495: LD_VAR 0 1
30499: PPUSH
30500: LD_INT 0
30502: PPUSH
30503: CALL 31250 0 3
30507: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30508: LD_VAR 0 1
30512: PPUSH
30513: CALL_OW 255
30517: PPUSH
30518: LD_VAR 0 1
30522: PPUSH
30523: CALL_OW 265
30527: PUSH
30528: LD_VAR 0 1
30532: PPUSH
30533: CALL_OW 262
30537: PUSH
30538: LD_VAR 0 1
30542: PPUSH
30543: CALL_OW 263
30547: PUSH
30548: LD_VAR 0 1
30552: PPUSH
30553: CALL_OW 264
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: LIST
30562: LIST
30563: PPUSH
30564: CALL 21072 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30568: LD_VAR 0 1
30572: PUSH
30573: LD_EXP 73
30577: PUSH
30578: LD_VAR 0 1
30582: PPUSH
30583: CALL_OW 255
30587: ARRAY
30588: IN
30589: IFFALSE 30614
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30591: LD_ADDR_EXP 73
30595: PUSH
30596: LD_EXP 73
30600: PPUSH
30601: LD_VAR 0 1
30605: PPUSH
30606: LD_INT 0
30608: PPUSH
30609: CALL 31250 0 3
30613: ST_TO_ADDR
// end ; end ;
30614: PPOPN 1
30616: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30617: LD_EXP 41
30621: PUSH
30622: LD_VAR 0 2
30626: PPUSH
30627: CALL_OW 255
30631: ARRAY
30632: IFFALSE 30804
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30634: LD_VAR 0 2
30638: PUSH
30639: LD_EXP 70
30643: PUSH
30644: LD_VAR 0 2
30648: PPUSH
30649: CALL_OW 255
30653: ARRAY
30654: IN
30655: PUSH
30656: LD_VAR 0 1
30660: PPUSH
30661: CALL_OW 266
30665: PUSH
30666: LD_INT 32
30668: PUSH
30669: LD_INT 31
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: IN
30676: AND
30677: IFFALSE 30777
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30679: LD_ADDR_EXP 70
30683: PUSH
30684: LD_EXP 70
30688: PPUSH
30689: LD_VAR 0 1
30693: PPUSH
30694: LD_INT 0
30696: PPUSH
30697: CALL 31250 0 3
30701: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30702: LD_ADDR_EXP 70
30706: PUSH
30707: LD_EXP 70
30711: PPUSH
30712: LD_VAR 0 2
30716: PPUSH
30717: LD_INT 0
30719: PPUSH
30720: CALL 31250 0 3
30724: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30725: LD_EXP 70
30729: PUSH
30730: LD_VAR 0 2
30734: PPUSH
30735: CALL_OW 255
30739: ARRAY
30740: PUSH
30741: LD_STRING 
30743: EQUAL
30744: IFFALSE 30777
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30746: LD_ADDR_EXP 70
30750: PUSH
30751: LD_EXP 70
30755: PPUSH
30756: LD_VAR 0 2
30760: PPUSH
30761: CALL_OW 255
30765: PPUSH
30766: LD_INT 1
30768: PPUSH
30769: LD_INT 0
30771: PPUSH
30772: CALL 31091 0 4
30776: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30777: LD_VAR 0 1
30781: PPUSH
30782: CALL_OW 266
30786: PUSH
30787: LD_INT 36
30789: IN
30790: IFFALSE 30804
// SetTag ( un , 0 ) ;
30792: LD_VAR 0 2
30796: PPUSH
30797: LD_INT 0
30799: PPUSH
30800: CALL_OW 109
// end ;
30804: PPOPN 2
30806: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30807: LD_EXP 41
30811: PUSH
30812: LD_VAR 0 1
30816: PPUSH
30817: CALL_OW 255
30821: ARRAY
30822: IFFALSE 30848
// begin if GetControl ( un ) = control_remote then
30824: LD_VAR 0 1
30828: PPUSH
30829: CALL_OW 263
30833: PUSH
30834: LD_INT 2
30836: EQUAL
30837: IFFALSE 30848
// ComUnlink ( un ) ;
30839: LD_VAR 0 1
30843: PPUSH
30844: CALL_OW 136
// end ;
30848: PPOPN 1
30850: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30851: LD_EXP 41
30855: PUSH
30856: LD_VAR 0 1
30860: PPUSH
30861: CALL_OW 255
30865: ARRAY
30866: IFFALSE 30895
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30868: LD_VAR 0 2
30872: PPUSH
30873: CALL_OW 264
30877: PUSH
30878: LD_INT 31
30880: IN
30881: IFFALSE 30895
// SetTag ( driver , 0 ) ;
30883: LD_VAR 0 1
30887: PPUSH
30888: LD_INT 0
30890: PPUSH
30891: CALL_OW 109
// end ;
30895: PPOPN 4
30897: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30898: LD_INT 0
30900: PPUSH
30901: PPUSH
30902: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30903: LD_ADDR_VAR 0 3
30907: PUSH
30908: LD_VAR 0 1
30912: PPUSH
30913: CALL_OW 269
30917: ST_TO_ADDR
// x := GetX ( building ) ;
30918: LD_ADDR_VAR 0 4
30922: PUSH
30923: LD_VAR 0 1
30927: PPUSH
30928: CALL_OW 250
30932: ST_TO_ADDR
// y := GetY ( building ) ;
30933: LD_ADDR_VAR 0 5
30937: PUSH
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL_OW 251
30947: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30948: LD_ADDR_EXP 45
30952: PUSH
30953: LD_EXP 45
30957: PPUSH
30958: LD_VAR 0 1
30962: PPUSH
30963: CALL_OW 255
30967: PPUSH
30968: LD_VAR 0 3
30972: PPUSH
30973: LD_VAR 0 4
30977: PUSH
30978: LD_VAR 0 5
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PPUSH
30987: CALL 42464 0 4
30991: ST_TO_ADDR
// end ;
30992: PPOPN 5
30994: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30995: LD_VAR 0 1
30999: PUSH
31000: LD_EXP 32
31004: IN
31005: NOT
31006: IFFALSE 31054
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31008: LD_ADDR_EXP 32
31012: PUSH
31013: LD_EXP 32
31017: PPUSH
31018: LD_EXP 32
31022: PUSH
31023: LD_INT 1
31025: PLUS
31026: PPUSH
31027: LD_VAR 0 1
31031: PPUSH
31032: CALL_OW 2
31036: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31037: LD_STRING DestinationUnrechable. [unit: 
31039: PUSH
31040: LD_VAR 0 1
31044: STR
31045: PUSH
31046: LD_STRING ]
31048: STR
31049: PPUSH
31050: CALL 7950 0 1
// end ; end ;
31054: PPOPN 1
31056: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31057: LD_VAR 0 1
31061: PPUSH
31062: LD_VAR 0 2
31066: PPUSH
31067: LD_VAR 0 3
31071: PPUSH
31072: CALL 54934 0 3
// end ;
31076: PPOPN 3
31078: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31079: LD_VAR 0 1
31083: PPUSH
31084: CALL 54942 0 1
// end ; end_of_file
31088: PPOPN 1
31090: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31091: LD_INT 0
31093: PPUSH
31094: PPUSH
31095: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31096: LD_ADDR_VAR 0 7
31100: PUSH
31101: LD_VAR 0 1
31105: PUSH
31106: LD_VAR 0 2
31110: ARRAY
31111: PPUSH
31112: LD_VAR 0 3
31116: PPUSH
31117: LD_VAR 0 4
31121: PPUSH
31122: CALL_OW 1
31126: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31127: LD_ADDR_VAR 0 1
31131: PUSH
31132: LD_VAR 0 1
31136: PPUSH
31137: LD_VAR 0 2
31141: PPUSH
31142: LD_VAR 0 7
31146: PPUSH
31147: CALL_OW 1
31151: ST_TO_ADDR
// result := tab ;
31152: LD_ADDR_VAR 0 5
31156: PUSH
31157: LD_VAR 0 1
31161: ST_TO_ADDR
// end ;
31162: LD_VAR 0 5
31166: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31167: LD_INT 0
31169: PPUSH
31170: PPUSH
31171: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31172: LD_ADDR_VAR 0 5
31176: PUSH
31177: LD_VAR 0 1
31181: PUSH
31182: LD_VAR 0 2
31186: PUSH
31187: LD_INT 1
31189: ARRAY
31190: ARRAY
31191: PPUSH
31192: LD_VAR 0 2
31196: PUSH
31197: LD_INT 2
31199: ARRAY
31200: PPUSH
31201: CALL_OW 3
31205: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31206: LD_ADDR_VAR 0 1
31210: PUSH
31211: LD_VAR 0 1
31215: PPUSH
31216: LD_VAR 0 2
31220: PUSH
31221: LD_INT 1
31223: ARRAY
31224: PPUSH
31225: LD_VAR 0 5
31229: PPUSH
31230: CALL_OW 1
31234: ST_TO_ADDR
// result := tab ;
31235: LD_ADDR_VAR 0 3
31239: PUSH
31240: LD_VAR 0 1
31244: ST_TO_ADDR
// end ;
31245: LD_VAR 0 3
31249: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31250: LD_INT 0
31252: PPUSH
31253: PPUSH
31254: PPUSH
31255: PPUSH
// i := 1 ;
31256: LD_ADDR_VAR 0 5
31260: PUSH
31261: LD_INT 1
31263: ST_TO_ADDR
// while ( i <= tab ) do
31264: LD_VAR 0 5
31268: PUSH
31269: LD_VAR 0 1
31273: LESSEQUAL
31274: IFFALSE 31649
// begin if not tab [ i ] then
31276: LD_VAR 0 1
31280: PUSH
31281: LD_VAR 0 5
31285: ARRAY
31286: NOT
31287: IFFALSE 31291
// break ;
31289: GO 31649
// if value in tab then
31291: LD_VAR 0 2
31295: PUSH
31296: LD_VAR 0 1
31300: IN
31301: IFFALSE 31414
// begin if not mode then
31303: LD_VAR 0 3
31307: NOT
31308: IFFALSE 31328
// tab := tab diff value else
31310: LD_ADDR_VAR 0 1
31314: PUSH
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 2
31324: DIFF
31325: ST_TO_ADDR
31326: GO 31390
// for j = 1 to tab do
31328: LD_ADDR_VAR 0 6
31332: PUSH
31333: DOUBLE
31334: LD_INT 1
31336: DEC
31337: ST_TO_ADDR
31338: LD_VAR 0 1
31342: PUSH
31343: FOR_TO
31344: IFFALSE 31388
// if tab [ j ] = value then
31346: LD_VAR 0 1
31350: PUSH
31351: LD_VAR 0 6
31355: ARRAY
31356: PUSH
31357: LD_VAR 0 2
31361: EQUAL
31362: IFFALSE 31386
// begin tab := Delete ( tab , j ) ;
31364: LD_ADDR_VAR 0 1
31368: PUSH
31369: LD_VAR 0 1
31373: PPUSH
31374: LD_VAR 0 6
31378: PPUSH
31379: CALL_OW 3
31383: ST_TO_ADDR
// break ;
31384: GO 31388
// end ;
31386: GO 31343
31388: POP
31389: POP
// i := i - 1 ;
31390: LD_ADDR_VAR 0 5
31394: PUSH
31395: LD_VAR 0 5
31399: PUSH
31400: LD_INT 1
31402: MINUS
31403: ST_TO_ADDR
// if mode then
31404: LD_VAR 0 3
31408: IFFALSE 31412
// break ;
31410: GO 31649
// end else
31412: GO 31633
// if tab [ i ] and value in tab [ i ] then
31414: LD_VAR 0 1
31418: PUSH
31419: LD_VAR 0 5
31423: ARRAY
31424: PUSH
31425: LD_VAR 0 2
31429: PUSH
31430: LD_VAR 0 1
31434: PUSH
31435: LD_VAR 0 5
31439: ARRAY
31440: IN
31441: AND
31442: IFFALSE 31633
// begin if not mode then
31444: LD_VAR 0 3
31448: NOT
31449: IFFALSE 31475
// tmp := tab [ i ] diff value else
31451: LD_ADDR_VAR 0 7
31455: PUSH
31456: LD_VAR 0 1
31460: PUSH
31461: LD_VAR 0 5
31465: ARRAY
31466: PUSH
31467: LD_VAR 0 2
31471: DIFF
31472: ST_TO_ADDR
31473: GO 31555
// for j = 1 to tab [ i ] do
31475: LD_ADDR_VAR 0 6
31479: PUSH
31480: DOUBLE
31481: LD_INT 1
31483: DEC
31484: ST_TO_ADDR
31485: LD_VAR 0 1
31489: PUSH
31490: LD_VAR 0 5
31494: ARRAY
31495: PUSH
31496: FOR_TO
31497: IFFALSE 31553
// if value = tab [ i ] [ j ] then
31499: LD_VAR 0 2
31503: PUSH
31504: LD_VAR 0 1
31508: PUSH
31509: LD_VAR 0 5
31513: ARRAY
31514: PUSH
31515: LD_VAR 0 6
31519: ARRAY
31520: EQUAL
31521: IFFALSE 31551
// begin tmp := Delete ( tab [ i ] , j ) ;
31523: LD_ADDR_VAR 0 7
31527: PUSH
31528: LD_VAR 0 1
31532: PUSH
31533: LD_VAR 0 5
31537: ARRAY
31538: PPUSH
31539: LD_VAR 0 6
31543: PPUSH
31544: CALL_OW 3
31548: ST_TO_ADDR
// break ;
31549: GO 31553
// end ;
31551: GO 31496
31553: POP
31554: POP
// if tmp = [ ] then
31555: LD_VAR 0 7
31559: PUSH
31560: EMPTY
31561: EQUAL
31562: IFFALSE 31586
// begin tab := Delete ( tab , i ) ;
31564: LD_ADDR_VAR 0 1
31568: PUSH
31569: LD_VAR 0 1
31573: PPUSH
31574: LD_VAR 0 5
31578: PPUSH
31579: CALL_OW 3
31583: ST_TO_ADDR
// end else
31584: GO 31611
// tab := Replace ( tab , i , tmp ) ;
31586: LD_ADDR_VAR 0 1
31590: PUSH
31591: LD_VAR 0 1
31595: PPUSH
31596: LD_VAR 0 5
31600: PPUSH
31601: LD_VAR 0 7
31605: PPUSH
31606: CALL_OW 1
31610: ST_TO_ADDR
// i := i - 1 ;
31611: LD_ADDR_VAR 0 5
31615: PUSH
31616: LD_VAR 0 5
31620: PUSH
31621: LD_INT 1
31623: MINUS
31624: ST_TO_ADDR
// if mode then
31625: LD_VAR 0 3
31629: IFFALSE 31633
// break ;
31631: GO 31649
// end ; i := i + 1 ;
31633: LD_ADDR_VAR 0 5
31637: PUSH
31638: LD_VAR 0 5
31642: PUSH
31643: LD_INT 1
31645: PLUS
31646: ST_TO_ADDR
// end ;
31647: GO 31264
// result := tab ;
31649: LD_ADDR_VAR 0 4
31653: PUSH
31654: LD_VAR 0 1
31658: ST_TO_ADDR
// end ;
31659: LD_VAR 0 4
31663: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31664: LD_INT 0
31666: PPUSH
31667: PPUSH
// for i = 1 to values do
31668: LD_ADDR_VAR 0 4
31672: PUSH
31673: DOUBLE
31674: LD_INT 1
31676: DEC
31677: ST_TO_ADDR
31678: LD_VAR 0 2
31682: PUSH
31683: FOR_TO
31684: IFFALSE 31717
// tab := Remove ( tab , values [ i ] , false ) ;
31686: LD_ADDR_VAR 0 1
31690: PUSH
31691: LD_VAR 0 1
31695: PPUSH
31696: LD_VAR 0 2
31700: PUSH
31701: LD_VAR 0 4
31705: ARRAY
31706: PPUSH
31707: LD_INT 0
31709: PPUSH
31710: CALL 31250 0 3
31714: ST_TO_ADDR
31715: GO 31683
31717: POP
31718: POP
// result := tab ;
31719: LD_ADDR_VAR 0 3
31723: PUSH
31724: LD_VAR 0 1
31728: ST_TO_ADDR
// end ;
31729: LD_VAR 0 3
31733: RET
// export function IsDriver ( unit ) ; begin
31734: LD_INT 0
31736: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
31737: LD_VAR 0 1
31741: PUSH
31742: LD_INT 55
31744: PUSH
31745: EMPTY
31746: LIST
31747: PPUSH
31748: CALL_OW 69
31752: IN
31753: IFFALSE 31772
// result := IsInUnit ( unit ) else
31755: LD_ADDR_VAR 0 2
31759: PUSH
31760: LD_VAR 0 1
31764: PPUSH
31765: CALL_OW 310
31769: ST_TO_ADDR
31770: GO 31780
// result := false ;
31772: LD_ADDR_VAR 0 2
31776: PUSH
31777: LD_INT 0
31779: ST_TO_ADDR
// end ;
31780: LD_VAR 0 2
31784: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31785: LD_INT 0
31787: PPUSH
31788: PPUSH
31789: PPUSH
// if not GetControl ( veh ) = control_manual then
31790: LD_VAR 0 1
31794: PPUSH
31795: CALL_OW 263
31799: PUSH
31800: LD_INT 1
31802: EQUAL
31803: NOT
31804: IFFALSE 31816
// result := false else
31806: LD_ADDR_VAR 0 2
31810: PUSH
31811: LD_INT 0
31813: ST_TO_ADDR
31814: GO 31961
// if veh in FilterAllUnits ( [ f_empty ] ) then
31816: LD_VAR 0 1
31820: PUSH
31821: LD_INT 58
31823: PUSH
31824: EMPTY
31825: LIST
31826: PPUSH
31827: CALL_OW 69
31831: IN
31832: IFFALSE 31844
// result := false else
31834: LD_ADDR_VAR 0 2
31838: PUSH
31839: LD_INT 0
31841: ST_TO_ADDR
31842: GO 31961
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31844: LD_ADDR_VAR 0 4
31848: PUSH
31849: LD_INT 22
31851: PUSH
31852: LD_VAR 0 1
31856: PPUSH
31857: CALL_OW 255
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: LD_INT 55
31868: PUSH
31869: EMPTY
31870: LIST
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PPUSH
31876: CALL_OW 69
31880: ST_TO_ADDR
// if not filter then
31881: LD_VAR 0 4
31885: NOT
31886: IFFALSE 31898
// result := false else
31888: LD_ADDR_VAR 0 2
31892: PUSH
31893: LD_INT 0
31895: ST_TO_ADDR
31896: GO 31961
// for i = 1 to filter do
31898: LD_ADDR_VAR 0 3
31902: PUSH
31903: DOUBLE
31904: LD_INT 1
31906: DEC
31907: ST_TO_ADDR
31908: LD_VAR 0 4
31912: PUSH
31913: FOR_TO
31914: IFFALSE 31959
// if IsDriver ( filter [ i ] ) = veh then
31916: LD_VAR 0 4
31920: PUSH
31921: LD_VAR 0 3
31925: ARRAY
31926: PPUSH
31927: CALL 31734 0 1
31931: PUSH
31932: LD_VAR 0 1
31936: EQUAL
31937: IFFALSE 31957
// begin result := filter [ i ] ;
31939: LD_ADDR_VAR 0 2
31943: PUSH
31944: LD_VAR 0 4
31948: PUSH
31949: LD_VAR 0 3
31953: ARRAY
31954: ST_TO_ADDR
// break ;
31955: GO 31959
// end ;
31957: GO 31913
31959: POP
31960: POP
// end ; end ;
31961: LD_VAR 0 2
31965: RET
// export function ComComplete ( unit , b ) ; var i ; begin
31966: LD_INT 0
31968: PPUSH
31969: PPUSH
// if BuildingStatus ( b ) = bs_build then
31970: LD_VAR 0 2
31974: PPUSH
31975: CALL_OW 461
31979: PUSH
31980: LD_INT 1
31982: EQUAL
31983: IFFALSE 32043
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
31985: LD_VAR 0 1
31989: PPUSH
31990: LD_STRING h
31992: PUSH
31993: LD_VAR 0 2
31997: PPUSH
31998: CALL_OW 250
32002: PUSH
32003: LD_VAR 0 2
32007: PPUSH
32008: CALL_OW 251
32012: PUSH
32013: LD_VAR 0 2
32017: PUSH
32018: LD_INT 0
32020: PUSH
32021: LD_INT 0
32023: PUSH
32024: LD_INT 0
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: PUSH
32036: EMPTY
32037: LIST
32038: PPUSH
32039: CALL_OW 446
// end ;
32043: LD_VAR 0 3
32047: RET
// export function Compare ( val1 , val2 ) ; begin
32048: LD_INT 0
32050: PPUSH
// if val1 = val2 then
32051: LD_VAR 0 1
32055: PUSH
32056: LD_VAR 0 2
32060: EQUAL
32061: IFFALSE 32073
// result := true else
32063: LD_ADDR_VAR 0 3
32067: PUSH
32068: LD_INT 1
32070: ST_TO_ADDR
32071: GO 32081
// result := false ;
32073: LD_ADDR_VAR 0 3
32077: PUSH
32078: LD_INT 0
32080: ST_TO_ADDR
// end ;
32081: LD_VAR 0 3
32085: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
32086: LD_INT 0
32088: PPUSH
32089: PPUSH
// result := true ;
32090: LD_ADDR_VAR 0 3
32094: PUSH
32095: LD_INT 1
32097: ST_TO_ADDR
// if array1 = array2 then
32098: LD_VAR 0 1
32102: PUSH
32103: LD_VAR 0 2
32107: EQUAL
32108: IFFALSE 32173
// begin for i = 1 to array1 do
32110: LD_ADDR_VAR 0 4
32114: PUSH
32115: DOUBLE
32116: LD_INT 1
32118: DEC
32119: ST_TO_ADDR
32120: LD_VAR 0 1
32124: PUSH
32125: FOR_TO
32126: IFFALSE 32169
// if not Compare ( array1 [ i ] , array2 [ i ] ) then
32128: LD_VAR 0 1
32132: PUSH
32133: LD_VAR 0 4
32137: ARRAY
32138: PPUSH
32139: LD_VAR 0 2
32143: PUSH
32144: LD_VAR 0 4
32148: ARRAY
32149: PPUSH
32150: CALL 32048 0 2
32154: NOT
32155: IFFALSE 32167
// begin result := false ;
32157: LD_ADDR_VAR 0 3
32161: PUSH
32162: LD_INT 0
32164: ST_TO_ADDR
// break ;
32165: GO 32169
// end ;
32167: GO 32125
32169: POP
32170: POP
// end else
32171: GO 32181
// result := false ;
32173: LD_ADDR_VAR 0 3
32177: PUSH
32178: LD_INT 0
32180: ST_TO_ADDR
// end ;
32181: LD_VAR 0 3
32185: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32186: LD_INT 0
32188: PPUSH
32189: PPUSH
// result := false ;
32190: LD_ADDR_VAR 0 3
32194: PUSH
32195: LD_INT 0
32197: ST_TO_ADDR
// for j = 1 to e2 do
32198: LD_ADDR_VAR 0 4
32202: PUSH
32203: DOUBLE
32204: LD_INT 1
32206: DEC
32207: ST_TO_ADDR
32208: LD_VAR 0 2
32212: PUSH
32213: FOR_TO
32214: IFFALSE 32248
// if Compare ( e1 , e2 [ j ] ) then
32216: LD_VAR 0 1
32220: PPUSH
32221: LD_VAR 0 2
32225: PUSH
32226: LD_VAR 0 4
32230: ARRAY
32231: PPUSH
32232: CALL 32048 0 2
32236: IFFALSE 32246
// result := true ;
32238: LD_ADDR_VAR 0 3
32242: PUSH
32243: LD_INT 1
32245: ST_TO_ADDR
32246: GO 32213
32248: POP
32249: POP
// end ;
32250: LD_VAR 0 3
32254: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32255: LD_INT 0
32257: PPUSH
32258: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32259: LD_VAR 0 1
32263: PPUSH
32264: LD_STRING C
32266: PUSH
32267: LD_VAR 0 2
32271: PUSH
32272: LD_VAR 0 3
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: LD_INT 0
32282: PUSH
32283: LD_INT 0
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: PUSH
32298: LD_STRING v
32300: PUSH
32301: LD_VAR 0 4
32305: PPUSH
32306: CALL_OW 250
32310: PUSH
32311: LD_VAR 0 4
32315: PPUSH
32316: CALL_OW 251
32320: PUSH
32321: LD_VAR 0 4
32325: PUSH
32326: LD_INT 0
32328: PUSH
32329: LD_INT 0
32331: PUSH
32332: LD_INT 0
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PPUSH
32348: CALL_OW 446
// end ;
32352: LD_VAR 0 5
32356: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32357: LD_INT 0
32359: PPUSH
32360: PPUSH
32361: PPUSH
// linked := UnitsLinked ( unit ) ;
32362: LD_ADDR_VAR 0 4
32366: PUSH
32367: LD_VAR 0 1
32371: PPUSH
32372: CALL_OW 432
32376: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32377: LD_ADDR_VAR 0 3
32381: PUSH
32382: LD_VAR 0 1
32386: PPUSH
32387: LD_INT 3
32389: PPUSH
32390: CALL_OW 259
32394: ST_TO_ADDR
// if sk > linked then
32395: LD_VAR 0 3
32399: PUSH
32400: LD_VAR 0 4
32404: GREATER
32405: IFFALSE 32417
// result := true else
32407: LD_ADDR_VAR 0 2
32411: PUSH
32412: LD_INT 1
32414: ST_TO_ADDR
32415: GO 32425
// result := false ;
32417: LD_ADDR_VAR 0 2
32421: PUSH
32422: LD_INT 0
32424: ST_TO_ADDR
// end ;
32425: LD_VAR 0 2
32429: RET
// export function NotTask ( unit ) ; begin
32430: LD_INT 0
32432: PPUSH
// result := true ;
32433: LD_ADDR_VAR 0 2
32437: PUSH
32438: LD_INT 1
32440: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 437
32450: PUSH
32451: LD_VAR 0 1
32455: PPUSH
32456: CALL_OW 314
32460: OR
32461: IFFALSE 32471
// result := false ;
32463: LD_ADDR_VAR 0 2
32467: PUSH
32468: LD_INT 0
32470: ST_TO_ADDR
// end ;
32471: LD_VAR 0 2
32475: RET
// export function WantHeal ( sci , unit ) ; begin
32476: LD_INT 0
32478: PPUSH
// if GetTaskList ( sci ) > 0 then
32479: LD_VAR 0 1
32483: PPUSH
32484: CALL_OW 437
32488: PUSH
32489: LD_INT 0
32491: GREATER
32492: IFFALSE 32562
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
32494: LD_VAR 0 1
32498: PPUSH
32499: CALL_OW 437
32503: PUSH
32504: LD_INT 1
32506: ARRAY
32507: PUSH
32508: LD_INT 1
32510: ARRAY
32511: PUSH
32512: LD_STRING l
32514: EQUAL
32515: PUSH
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 437
32525: PUSH
32526: LD_INT 1
32528: ARRAY
32529: PUSH
32530: LD_INT 4
32532: ARRAY
32533: PUSH
32534: LD_VAR 0 2
32538: EQUAL
32539: AND
32540: IFFALSE 32552
// result := true else
32542: LD_ADDR_VAR 0 3
32546: PUSH
32547: LD_INT 1
32549: ST_TO_ADDR
32550: GO 32560
// result := false ;
32552: LD_ADDR_VAR 0 3
32556: PUSH
32557: LD_INT 0
32559: ST_TO_ADDR
// end else
32560: GO 32570
// result := false ;
32562: LD_ADDR_VAR 0 3
32566: PUSH
32567: LD_INT 0
32569: ST_TO_ADDR
// end ;
32570: LD_VAR 0 3
32574: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32575: LD_INT 0
32577: PPUSH
32578: PPUSH
32579: PPUSH
32580: PPUSH
32581: PPUSH
// dist := 99999 ;
32582: LD_ADDR_VAR 0 7
32586: PUSH
32587: LD_INT 99999
32589: ST_TO_ADDR
// un := - 1 ;
32590: LD_ADDR_VAR 0 6
32594: PUSH
32595: LD_INT 1
32597: NEG
32598: ST_TO_ADDR
// if units1 and units2 then
32599: LD_VAR 0 1
32603: PUSH
32604: LD_VAR 0 2
32608: AND
32609: IFFALSE 32697
// for i in units1 do
32611: LD_ADDR_VAR 0 4
32615: PUSH
32616: LD_VAR 0 1
32620: PUSH
32621: FOR_IN
32622: IFFALSE 32695
// for j in units2 do
32624: LD_ADDR_VAR 0 5
32628: PUSH
32629: LD_VAR 0 2
32633: PUSH
32634: FOR_IN
32635: IFFALSE 32691
// if GetDistUnits ( i , j ) < dist then
32637: LD_VAR 0 4
32641: PPUSH
32642: LD_VAR 0 5
32646: PPUSH
32647: CALL_OW 296
32651: PUSH
32652: LD_VAR 0 7
32656: LESS
32657: IFFALSE 32689
// begin un := i ;
32659: LD_ADDR_VAR 0 6
32663: PUSH
32664: LD_VAR 0 4
32668: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32669: LD_ADDR_VAR 0 7
32673: PUSH
32674: LD_VAR 0 4
32678: PPUSH
32679: LD_VAR 0 5
32683: PPUSH
32684: CALL_OW 296
32688: ST_TO_ADDR
// end ;
32689: GO 32634
32691: POP
32692: POP
32693: GO 32621
32695: POP
32696: POP
// result := [ un , dist ] ;
32697: LD_ADDR_VAR 0 3
32701: PUSH
32702: LD_VAR 0 6
32706: PUSH
32707: LD_VAR 0 7
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: ST_TO_ADDR
// end ;
32716: LD_VAR 0 3
32720: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32721: LD_INT 0
32723: PPUSH
32724: PPUSH
32725: PPUSH
32726: PPUSH
32727: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32728: LD_VAR 0 1
32732: NOT
32733: PUSH
32734: LD_VAR 0 1
32738: PPUSH
32739: CALL_OW 256
32743: PUSH
32744: LD_INT 250
32746: LESS
32747: OR
32748: PUSH
32749: LD_VAR 0 1
32753: PPUSH
32754: CALL_OW 314
32758: PUSH
32759: LD_VAR 0 1
32763: PPUSH
32764: CALL_OW 261
32768: PUSH
32769: LD_INT 20
32771: GREATER
32772: AND
32773: OR
32774: IFFALSE 32778
// exit ;
32776: GO 33152
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32778: LD_VAR 0 1
32782: PPUSH
32783: CALL_OW 261
32787: PUSH
32788: LD_INT 20
32790: LESS
32791: PUSH
32792: LD_VAR 0 1
32796: PPUSH
32797: CALL_OW 110
32801: PUSH
32802: LD_INT 21
32804: EQUAL
32805: NOT
32806: AND
32807: IFFALSE 32843
// begin ComStop ( bulldozer ) ;
32809: LD_VAR 0 1
32813: PPUSH
32814: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32818: LD_VAR 0 1
32822: PPUSH
32823: LD_INT 21
32825: PPUSH
32826: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32830: LD_VAR 0 1
32834: PPUSH
32835: CALL 26251 0 1
// exit ;
32839: GO 33152
// end else
32841: GO 32870
// if GetFuel ( bulldozer ) > 20 then
32843: LD_VAR 0 1
32847: PPUSH
32848: CALL_OW 261
32852: PUSH
32853: LD_INT 20
32855: GREATER
32856: IFFALSE 32870
// SetTag ( bulldozer , 0 ) ;
32858: LD_VAR 0 1
32862: PPUSH
32863: LD_INT 0
32865: PPUSH
32866: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32870: LD_ADDR_VAR 0 5
32874: PUSH
32875: LD_VAR 0 2
32879: PPUSH
32880: CALL_OW 353
32884: ST_TO_ADDR
// tmp := [ ] ;
32885: LD_ADDR_VAR 0 6
32889: PUSH
32890: EMPTY
32891: ST_TO_ADDR
// for i = 1 to list do
32892: LD_ADDR_VAR 0 4
32896: PUSH
32897: DOUBLE
32898: LD_INT 1
32900: DEC
32901: ST_TO_ADDR
32902: LD_VAR 0 5
32906: PUSH
32907: FOR_TO
32908: IFFALSE 33006
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32910: LD_VAR 0 5
32914: PUSH
32915: LD_VAR 0 4
32919: ARRAY
32920: PUSH
32921: LD_INT 1
32923: ARRAY
32924: PPUSH
32925: LD_VAR 0 5
32929: PUSH
32930: LD_VAR 0 4
32934: ARRAY
32935: PUSH
32936: LD_INT 2
32938: ARRAY
32939: PPUSH
32940: CALL_OW 554
32944: IFFALSE 33004
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32946: LD_ADDR_VAR 0 6
32950: PUSH
32951: LD_VAR 0 6
32955: PPUSH
32956: LD_VAR 0 6
32960: PUSH
32961: LD_INT 1
32963: PLUS
32964: PPUSH
32965: LD_VAR 0 5
32969: PUSH
32970: LD_VAR 0 4
32974: ARRAY
32975: PUSH
32976: LD_INT 1
32978: ARRAY
32979: PUSH
32980: LD_VAR 0 5
32984: PUSH
32985: LD_VAR 0 4
32989: ARRAY
32990: PUSH
32991: LD_INT 2
32993: ARRAY
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PPUSH
32999: CALL_OW 1
33003: ST_TO_ADDR
// end ;
33004: GO 32907
33006: POP
33007: POP
// ComStop ( bulldozer ) ;
33008: LD_VAR 0 1
33012: PPUSH
33013: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
33017: LD_ADDR_VAR 0 7
33021: PUSH
33022: LD_VAR 0 1
33026: PPUSH
33027: CALL_OW 250
33031: PUSH
33032: LD_VAR 0 1
33036: PPUSH
33037: CALL_OW 251
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: ST_TO_ADDR
// for i = tmp downto 1 do
33046: LD_ADDR_VAR 0 4
33050: PUSH
33051: DOUBLE
33052: LD_VAR 0 6
33056: INC
33057: ST_TO_ADDR
33058: LD_INT 1
33060: PUSH
33061: FOR_DOWNTO
33062: IFFALSE 33150
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
33064: LD_ADDR_VAR 0 7
33068: PUSH
33069: LD_VAR 0 7
33073: PUSH
33074: LD_INT 1
33076: ARRAY
33077: PPUSH
33078: LD_VAR 0 7
33082: PUSH
33083: LD_INT 2
33085: ARRAY
33086: PPUSH
33087: LD_VAR 0 6
33091: PPUSH
33092: CALL 33253 0 3
33096: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
33097: LD_VAR 0 1
33101: PPUSH
33102: LD_VAR 0 7
33106: PUSH
33107: LD_INT 1
33109: ARRAY
33110: PPUSH
33111: LD_VAR 0 7
33115: PUSH
33116: LD_INT 2
33118: ARRAY
33119: PPUSH
33120: CALL 33157 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
33124: LD_ADDR_VAR 0 6
33128: PUSH
33129: LD_VAR 0 6
33133: PPUSH
33134: LD_VAR 0 7
33138: PUSH
33139: LD_INT 3
33141: ARRAY
33142: PPUSH
33143: CALL_OW 3
33147: ST_TO_ADDR
// end ;
33148: GO 33061
33150: POP
33151: POP
// end ;
33152: LD_VAR 0 3
33156: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
33157: LD_INT 0
33159: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
33160: LD_VAR 0 2
33164: PPUSH
33165: LD_VAR 0 3
33169: PPUSH
33170: CALL_OW 351
33174: PUSH
33175: LD_VAR 0 2
33179: PPUSH
33180: LD_VAR 0 3
33184: PPUSH
33185: CALL_OW 554
33189: AND
33190: PUSH
33191: LD_VAR 0 2
33195: PPUSH
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 488
33205: AND
33206: PUSH
33207: LD_VAR 0 2
33211: PPUSH
33212: LD_VAR 0 3
33216: PPUSH
33217: CALL_OW 428
33221: PUSH
33222: LD_INT 1
33224: NEG
33225: EQUAL
33226: AND
33227: IFFALSE 33248
// AddComMoveXY ( bulldozer , x , y ) ;
33229: LD_VAR 0 1
33233: PPUSH
33234: LD_VAR 0 2
33238: PPUSH
33239: LD_VAR 0 3
33243: PPUSH
33244: CALL_OW 171
// end ;
33248: LD_VAR 0 4
33252: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
33253: LD_INT 0
33255: PPUSH
33256: PPUSH
33257: PPUSH
33258: PPUSH
33259: PPUSH
33260: PPUSH
33261: PPUSH
// dist := 99999 ;
33262: LD_ADDR_VAR 0 6
33266: PUSH
33267: LD_INT 99999
33269: ST_TO_ADDR
// for i = 1 to list do
33270: LD_ADDR_VAR 0 5
33274: PUSH
33275: DOUBLE
33276: LD_INT 1
33278: DEC
33279: ST_TO_ADDR
33280: LD_VAR 0 3
33284: PUSH
33285: FOR_TO
33286: IFFALSE 33424
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33288: LD_ADDR_VAR 0 7
33292: PUSH
33293: LD_VAR 0 1
33297: PPUSH
33298: LD_VAR 0 2
33302: PPUSH
33303: LD_VAR 0 3
33307: PUSH
33308: LD_VAR 0 5
33312: ARRAY
33313: PUSH
33314: LD_INT 1
33316: ARRAY
33317: PPUSH
33318: LD_VAR 0 3
33322: PUSH
33323: LD_VAR 0 5
33327: ARRAY
33328: PUSH
33329: LD_INT 2
33331: ARRAY
33332: PPUSH
33333: CALL_OW 298
33337: ST_TO_ADDR
// if d = 0 then
33338: LD_VAR 0 7
33342: PUSH
33343: LD_INT 0
33345: EQUAL
33346: IFFALSE 33350
// continue ;
33348: GO 33285
// if d < dist then
33350: LD_VAR 0 7
33354: PUSH
33355: LD_VAR 0 6
33359: LESS
33360: IFFALSE 33422
// begin _x := list [ i ] [ 1 ] ;
33362: LD_ADDR_VAR 0 8
33366: PUSH
33367: LD_VAR 0 3
33371: PUSH
33372: LD_VAR 0 5
33376: ARRAY
33377: PUSH
33378: LD_INT 1
33380: ARRAY
33381: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33382: LD_ADDR_VAR 0 9
33386: PUSH
33387: LD_VAR 0 3
33391: PUSH
33392: LD_VAR 0 5
33396: ARRAY
33397: PUSH
33398: LD_INT 2
33400: ARRAY
33401: ST_TO_ADDR
// _i := i ;
33402: LD_ADDR_VAR 0 10
33406: PUSH
33407: LD_VAR 0 5
33411: ST_TO_ADDR
// dist := d ;
33412: LD_ADDR_VAR 0 6
33416: PUSH
33417: LD_VAR 0 7
33421: ST_TO_ADDR
// end ; end ;
33422: GO 33285
33424: POP
33425: POP
// result := [ _x , _y , _i , dist ] ;
33426: LD_ADDR_VAR 0 4
33430: PUSH
33431: LD_VAR 0 8
33435: PUSH
33436: LD_VAR 0 9
33440: PUSH
33441: LD_VAR 0 10
33445: PUSH
33446: LD_VAR 0 6
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: ST_TO_ADDR
// end ;
33457: LD_VAR 0 4
33461: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33462: LD_INT 0
33464: PPUSH
33465: PPUSH
33466: PPUSH
33467: PPUSH
33468: PPUSH
// for i = 1 to list do
33469: LD_ADDR_VAR 0 5
33473: PUSH
33474: DOUBLE
33475: LD_INT 1
33477: DEC
33478: ST_TO_ADDR
33479: LD_VAR 0 1
33483: PUSH
33484: FOR_TO
33485: IFFALSE 33799
// begin for j = list downto 2 do
33487: LD_ADDR_VAR 0 6
33491: PUSH
33492: DOUBLE
33493: LD_VAR 0 1
33497: INC
33498: ST_TO_ADDR
33499: LD_INT 2
33501: PUSH
33502: FOR_DOWNTO
33503: IFFALSE 33795
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33505: LD_VAR 0 2
33509: PPUSH
33510: LD_VAR 0 3
33514: PPUSH
33515: LD_VAR 0 1
33519: PUSH
33520: LD_VAR 0 6
33524: ARRAY
33525: PUSH
33526: LD_INT 1
33528: ARRAY
33529: PPUSH
33530: LD_VAR 0 1
33534: PUSH
33535: LD_VAR 0 6
33539: ARRAY
33540: PUSH
33541: LD_INT 2
33543: ARRAY
33544: PPUSH
33545: CALL_OW 298
33549: PUSH
33550: LD_VAR 0 2
33554: PPUSH
33555: LD_VAR 0 3
33559: PPUSH
33560: LD_VAR 0 1
33564: PUSH
33565: LD_VAR 0 6
33569: PUSH
33570: LD_INT 1
33572: MINUS
33573: ARRAY
33574: PUSH
33575: LD_INT 1
33577: ARRAY
33578: PPUSH
33579: LD_VAR 0 1
33583: PUSH
33584: LD_VAR 0 6
33588: PUSH
33589: LD_INT 1
33591: MINUS
33592: ARRAY
33593: PUSH
33594: LD_INT 2
33596: ARRAY
33597: PPUSH
33598: CALL_OW 298
33602: LESS
33603: IFFALSE 33793
// begin _x := list [ j ] [ 1 ] ;
33605: LD_ADDR_VAR 0 7
33609: PUSH
33610: LD_VAR 0 1
33614: PUSH
33615: LD_VAR 0 6
33619: ARRAY
33620: PUSH
33621: LD_INT 1
33623: ARRAY
33624: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33625: LD_ADDR_VAR 0 8
33629: PUSH
33630: LD_VAR 0 1
33634: PUSH
33635: LD_VAR 0 6
33639: ARRAY
33640: PUSH
33641: LD_INT 2
33643: ARRAY
33644: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33645: LD_ADDR_VAR 0 1
33649: PUSH
33650: LD_VAR 0 1
33654: PPUSH
33655: LD_VAR 0 6
33659: PPUSH
33660: LD_INT 1
33662: PPUSH
33663: LD_VAR 0 1
33667: PUSH
33668: LD_VAR 0 6
33672: PUSH
33673: LD_INT 1
33675: MINUS
33676: ARRAY
33677: PUSH
33678: LD_INT 1
33680: ARRAY
33681: PPUSH
33682: CALL 31091 0 4
33686: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33687: LD_ADDR_VAR 0 1
33691: PUSH
33692: LD_VAR 0 1
33696: PPUSH
33697: LD_VAR 0 6
33701: PPUSH
33702: LD_INT 2
33704: PPUSH
33705: LD_VAR 0 1
33709: PUSH
33710: LD_VAR 0 6
33714: PUSH
33715: LD_INT 1
33717: MINUS
33718: ARRAY
33719: PUSH
33720: LD_INT 2
33722: ARRAY
33723: PPUSH
33724: CALL 31091 0 4
33728: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33729: LD_ADDR_VAR 0 1
33733: PUSH
33734: LD_VAR 0 1
33738: PPUSH
33739: LD_VAR 0 6
33743: PUSH
33744: LD_INT 1
33746: MINUS
33747: PPUSH
33748: LD_INT 1
33750: PPUSH
33751: LD_VAR 0 7
33755: PPUSH
33756: CALL 31091 0 4
33760: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33761: LD_ADDR_VAR 0 1
33765: PUSH
33766: LD_VAR 0 1
33770: PPUSH
33771: LD_VAR 0 6
33775: PUSH
33776: LD_INT 1
33778: MINUS
33779: PPUSH
33780: LD_INT 2
33782: PPUSH
33783: LD_VAR 0 8
33787: PPUSH
33788: CALL 31091 0 4
33792: ST_TO_ADDR
// end ; end ;
33793: GO 33502
33795: POP
33796: POP
// end ;
33797: GO 33484
33799: POP
33800: POP
// result := list ;
33801: LD_ADDR_VAR 0 4
33805: PUSH
33806: LD_VAR 0 1
33810: ST_TO_ADDR
// end ;
33811: LD_VAR 0 4
33815: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33816: LD_INT 0
33818: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33819: LD_ADDR_VAR 0 5
33823: PUSH
33824: LD_VAR 0 1
33828: PPUSH
33829: LD_VAR 0 2
33833: PPUSH
33834: CALL_OW 546
33838: PUSH
33839: LD_INT 2
33841: ARRAY
33842: PUSH
33843: LD_VAR 0 3
33847: PPUSH
33848: LD_VAR 0 4
33852: PPUSH
33853: CALL_OW 546
33857: PUSH
33858: LD_INT 2
33860: ARRAY
33861: MINUS
33862: ST_TO_ADDR
// if result < 0 then
33863: LD_VAR 0 5
33867: PUSH
33868: LD_INT 0
33870: LESS
33871: IFFALSE 33888
// result := result * - 1 ;
33873: LD_ADDR_VAR 0 5
33877: PUSH
33878: LD_VAR 0 5
33882: PUSH
33883: LD_INT 1
33885: NEG
33886: MUL
33887: ST_TO_ADDR
// end ;
33888: LD_VAR 0 5
33892: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33893: LD_INT 0
33895: PPUSH
33896: PPUSH
// area = ListEnvironmentArea ( area ) ;
33897: LD_ADDR_VAR 0 2
33901: PUSH
33902: LD_VAR 0 2
33906: PPUSH
33907: CALL_OW 353
33911: ST_TO_ADDR
// if bulldozer > 0 then
33912: LD_VAR 0 1
33916: PUSH
33917: LD_INT 0
33919: GREATER
33920: IFFALSE 34031
// for i = area downto 1 do
33922: LD_ADDR_VAR 0 4
33926: PUSH
33927: DOUBLE
33928: LD_VAR 0 2
33932: INC
33933: ST_TO_ADDR
33934: LD_INT 1
33936: PUSH
33937: FOR_DOWNTO
33938: IFFALSE 34029
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33940: LD_VAR 0 2
33944: PUSH
33945: LD_VAR 0 4
33949: ARRAY
33950: PUSH
33951: LD_INT 1
33953: ARRAY
33954: PPUSH
33955: LD_VAR 0 2
33959: PUSH
33960: LD_VAR 0 4
33964: ARRAY
33965: PUSH
33966: LD_INT 2
33968: ARRAY
33969: PPUSH
33970: CALL_OW 351
33974: IFFALSE 34027
// if not HasTask ( bulldozer ) then
33976: LD_VAR 0 1
33980: PPUSH
33981: CALL_OW 314
33985: NOT
33986: IFFALSE 34027
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33988: LD_VAR 0 1
33992: PPUSH
33993: LD_VAR 0 2
33997: PUSH
33998: LD_VAR 0 4
34002: ARRAY
34003: PUSH
34004: LD_INT 1
34006: ARRAY
34007: PPUSH
34008: LD_VAR 0 2
34012: PUSH
34013: LD_VAR 0 4
34017: ARRAY
34018: PUSH
34019: LD_INT 2
34021: ARRAY
34022: PPUSH
34023: CALL_OW 171
34027: GO 33937
34029: POP
34030: POP
// end ;
34031: LD_VAR 0 3
34035: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
34036: LD_INT 0
34038: PPUSH
34039: PPUSH
34040: PPUSH
34041: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
34042: LD_ADDR_VAR 0 6
34046: PUSH
34047: LD_INT 22
34049: PUSH
34050: LD_VAR 0 1
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 21
34061: PUSH
34062: LD_VAR 0 2
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PPUSH
34075: CALL_OW 69
34079: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
34080: LD_ADDR_VAR 0 7
34084: PUSH
34085: LD_VAR 0 3
34089: PPUSH
34090: LD_INT 22
34092: PUSH
34093: LD_VAR 0 1
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 21
34104: PUSH
34105: LD_VAR 0 2
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PPUSH
34118: CALL_OW 70
34122: ST_TO_ADDR
// if tmp and pom then
34123: LD_VAR 0 6
34127: PUSH
34128: LD_VAR 0 7
34132: AND
34133: IFFALSE 34153
// result := tmp diff pom else
34135: LD_ADDR_VAR 0 4
34139: PUSH
34140: LD_VAR 0 6
34144: PUSH
34145: LD_VAR 0 7
34149: DIFF
34150: ST_TO_ADDR
34151: GO 34161
// result := false ;
34153: LD_ADDR_VAR 0 4
34157: PUSH
34158: LD_INT 0
34160: ST_TO_ADDR
// end ;
34161: LD_VAR 0 4
34165: RET
// export function SavePosition ( unit ) ; begin
34166: LD_INT 0
34168: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
34169: LD_VAR 0 1
34173: PPUSH
34174: LD_VAR 0 1
34178: PPUSH
34179: CALL_OW 250
34183: PPUSH
34184: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
34188: LD_VAR 0 1
34192: PPUSH
34193: LD_VAR 0 1
34197: PPUSH
34198: CALL_OW 251
34202: PPUSH
34203: CALL_OW 232
// end ;
34207: LD_VAR 0 2
34211: RET
// export function GetPosition ( unit ) ; begin
34212: LD_INT 0
34214: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
34215: LD_ADDR_VAR 0 2
34219: PUSH
34220: LD_VAR 0 1
34224: PPUSH
34225: CALL_OW 252
34229: PUSH
34230: LD_VAR 0 1
34234: PPUSH
34235: CALL_OW 253
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: ST_TO_ADDR
// end ;
34244: LD_VAR 0 2
34248: RET
// export function DestinationReachable ( unit , x , y ) ; begin
34249: LD_INT 0
34251: PPUSH
// if unit in unreachableList then
34252: LD_VAR 0 1
34256: PUSH
34257: LD_EXP 32
34261: IN
34262: IFFALSE 34280
// unreachableList := unreachableList diff unit ;
34264: LD_ADDR_EXP 32
34268: PUSH
34269: LD_EXP 32
34273: PUSH
34274: LD_VAR 0 1
34278: DIFF
34279: ST_TO_ADDR
// if ValidHex ( x , y ) then
34280: LD_VAR 0 2
34284: PPUSH
34285: LD_VAR 0 3
34289: PPUSH
34290: CALL_OW 488
34294: IFFALSE 34320
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34296: LD_VAR 0 1
34300: PPUSH
34301: LD_VAR 0 2
34305: PPUSH
34306: LD_VAR 0 3
34310: PPUSH
34311: CALL_OW 428
34315: PPUSH
34316: CALL_OW 115
// Wait ( 3 ) ;
34320: LD_INT 3
34322: PPUSH
34323: CALL_OW 67
// if unit in unreachableList then
34327: LD_VAR 0 1
34331: PUSH
34332: LD_EXP 32
34336: IN
34337: IFFALSE 34349
// result := false else
34339: LD_ADDR_VAR 0 4
34343: PUSH
34344: LD_INT 0
34346: ST_TO_ADDR
34347: GO 34357
// result := true ;
34349: LD_ADDR_VAR 0 4
34353: PUSH
34354: LD_INT 1
34356: ST_TO_ADDR
// end ; end_of_file
34357: LD_VAR 0 4
34361: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34362: LD_EXP 33
34366: IFFALSE 34428
34368: GO 34370
34370: DISABLE
34371: LD_INT 0
34373: PPUSH
// begin enable ;
34374: ENABLE
// for i = 1 to mc_crates_list do
34375: LD_ADDR_VAR 0 1
34379: PUSH
34380: DOUBLE
34381: LD_INT 1
34383: DEC
34384: ST_TO_ADDR
34385: LD_EXP 34
34389: PUSH
34390: FOR_TO
34391: IFFALSE 34422
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34393: LD_EXP 34
34397: PUSH
34398: LD_VAR 0 1
34402: ARRAY
34403: PPUSH
34404: LD_INT 5
34406: PPUSH
34407: LD_INT 50
34409: PPUSH
34410: LD_INT 700
34412: PPUSH
34413: LD_INT 20
34415: PPUSH
34416: CALL 24433 0 5
34420: GO 34390
34422: POP
34423: POP
// MC_Game ( ) ;
34424: CALL 34431 0 0
// end ;
34428: PPOPN 1
34430: END
// export function MC_Game ( ) ; var i , side , un ; begin
34431: LD_INT 0
34433: PPUSH
34434: PPUSH
34435: PPUSH
34436: PPUSH
// if not isTest then
34437: LD_EXP 1
34441: NOT
34442: IFFALSE 34462
// MC_Show ( [ #tick , tick ] ) else
34444: LD_STRING #tick
34446: PUSH
34447: LD_OWVAR 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PPUSH
34456: CALL 8471 0 1
34460: GO 34471
// MC_Show ( debug_string ) ;
34462: LD_EXP 2
34466: PPUSH
34467: CALL 8471 0 1
// for side = 1 to 8 do
34471: LD_ADDR_VAR 0 3
34475: PUSH
34476: DOUBLE
34477: LD_INT 1
34479: DEC
34480: ST_TO_ADDR
34481: LD_INT 8
34483: PUSH
34484: FOR_TO
34485: IFFALSE 36485
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34487: LD_EXP 41
34491: PUSH
34492: LD_VAR 0 3
34496: ARRAY
34497: PUSH
34498: LD_INT 0
34500: EQUAL
34501: PUSH
34502: LD_VAR 0 3
34506: PPUSH
34507: EMPTY
34508: PPUSH
34509: CALL 11688 0 2
34513: PUSH
34514: LD_INT 0
34516: EQUAL
34517: OR
34518: IFFALSE 34522
// continue ;
34520: GO 34484
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34522: LD_VAR 0 3
34526: PPUSH
34527: LD_VAR 0 3
34531: PPUSH
34532: CALL 24954 0 1
34536: PPUSH
34537: CALL 36492 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34541: LD_EXP 73
34545: PUSH
34546: LD_VAR 0 3
34550: ARRAY
34551: PUSH
34552: LD_INT 1
34554: ARRAY
34555: PUSH
34556: LD_INT 0
34558: GREATER
34559: PUSH
34560: LD_EXP 71
34564: PUSH
34565: LD_VAR 0 3
34569: ARRAY
34570: PUSH
34571: LD_INT 1
34573: ARRAY
34574: PUSH
34575: LD_INT 0
34577: EQUAL
34578: AND
34579: PUSH
34580: LD_VAR 0 3
34584: PPUSH
34585: LD_INT 7
34587: PPUSH
34588: EMPTY
34589: PPUSH
34590: CALL 12256 0 3
34594: NOT
34595: AND
34596: IFFALSE 34667
// begin if side = 1 then
34598: LD_VAR 0 3
34602: PUSH
34603: LD_INT 1
34605: EQUAL
34606: IFFALSE 34615
// RaiseSailEvent ( 101 ) ;
34608: LD_INT 101
34610: PPUSH
34611: CALL_OW 427
// if side = 4 then
34615: LD_VAR 0 3
34619: PUSH
34620: LD_INT 4
34622: EQUAL
34623: IFFALSE 34632
// RaiseSailEvent ( 102 ) ;
34625: LD_INT 102
34627: PPUSH
34628: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34632: LD_ADDR_VAR 0 2
34636: PUSH
34637: LD_EXP 73
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: PUSH
34648: FOR_IN
34649: IFFALSE 34665
// SetTag ( i , 7 ) ;
34651: LD_VAR 0 2
34655: PPUSH
34656: LD_INT 7
34658: PPUSH
34659: CALL_OW 109
34663: GO 34648
34665: POP
34666: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34667: LD_VAR 0 3
34671: PPUSH
34672: LD_INT 7
34674: PPUSH
34675: EMPTY
34676: PPUSH
34677: CALL 12256 0 3
34681: IFFALSE 34707
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34683: LD_VAR 0 3
34687: PPUSH
34688: LD_VAR 0 3
34692: PPUSH
34693: LD_INT 7
34695: PPUSH
34696: EMPTY
34697: PPUSH
34698: CALL 12256 0 3
34702: PPUSH
34703: CALL 8398 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34707: LD_VAR 0 3
34711: PPUSH
34712: CALL 17936 0 1
34716: PUSH
34717: LD_VAR 0 3
34721: PPUSH
34722: CALL 11592 0 1
34726: AND
34727: IFFALSE 34738
// MCL_Start ( side ) ;
34729: LD_VAR 0 3
34733: PPUSH
34734: CALL 17893 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34738: LD_ADDR_EXP 37
34742: PUSH
34743: LD_EXP 37
34747: PPUSH
34748: LD_VAR 0 3
34752: PPUSH
34753: LD_VAR 0 3
34757: PPUSH
34758: CALL 19193 0 1
34762: PPUSH
34763: CALL_OW 1
34767: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34768: LD_ADDR_EXP 49
34772: PUSH
34773: LD_EXP 49
34777: PPUSH
34778: LD_VAR 0 3
34782: PPUSH
34783: LD_VAR 0 3
34787: PPUSH
34788: CALL 11006 0 1
34792: PPUSH
34793: CALL_OW 1
34797: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34798: LD_VAR 0 3
34802: PPUSH
34803: LD_INT 21
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PPUSH
34813: CALL 11553 0 2
34817: IFFALSE 34828
// MCV_CheckStatus ( side ) ;
34819: LD_VAR 0 3
34823: PPUSH
34824: CALL 27163 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34828: LD_VAR 0 3
34832: PPUSH
34833: LD_EXP 55
34837: PPUSH
34838: CALL 43412 0 2
34842: IFFALSE 34927
// begin for i = MREG_ToChangeClass downto 1 do
34844: LD_ADDR_VAR 0 2
34848: PUSH
34849: DOUBLE
34850: LD_EXP 55
34854: INC
34855: ST_TO_ADDR
34856: LD_INT 1
34858: PUSH
34859: FOR_DOWNTO
34860: IFFALSE 34925
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34862: LD_EXP 55
34866: PUSH
34867: LD_VAR 0 2
34871: ARRAY
34872: PUSH
34873: LD_INT 1
34875: ARRAY
34876: PUSH
34877: LD_VAR 0 3
34881: EQUAL
34882: IFFALSE 34923
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34884: LD_VAR 0 3
34888: PPUSH
34889: LD_EXP 55
34893: PUSH
34894: LD_VAR 0 2
34898: ARRAY
34899: PUSH
34900: LD_INT 2
34902: ARRAY
34903: PPUSH
34904: LD_EXP 55
34908: PUSH
34909: LD_VAR 0 2
34913: ARRAY
34914: PUSH
34915: LD_INT 3
34917: ARRAY
34918: PPUSH
34919: CALL 16460 0 3
// end ; end ;
34923: GO 34859
34925: POP
34926: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34927: LD_INT 1
34929: PUSH
34930: LD_EXP 40
34934: PUSH
34935: LD_VAR 0 3
34939: ARRAY
34940: IN
34941: IFFALSE 34952
// begin MCN_TrainApe ( side ) ;
34943: LD_VAR 0 3
34947: PPUSH
34948: CALL 18846 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34952: LD_VAR 0 3
34956: PPUSH
34957: LD_INT 30
34959: PUSH
34960: LD_INT 3
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PPUSH
34967: CALL 11553 0 2
34971: IFFALSE 35145
// begin if MCF_Tag ( side , 10 , [ ] ) then
34973: LD_VAR 0 3
34977: PPUSH
34978: LD_INT 10
34980: PPUSH
34981: EMPTY
34982: PPUSH
34983: CALL 12256 0 3
34987: IFFALSE 35034
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34989: LD_VAR 0 3
34993: PPUSH
34994: LD_INT 10
34996: PPUSH
34997: EMPTY
34998: PPUSH
34999: CALL 12256 0 3
35003: PPUSH
35004: LD_VAR 0 3
35008: PPUSH
35009: LD_INT 30
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PPUSH
35019: CALL 11553 0 2
35023: PUSH
35024: LD_INT 1
35026: ARRAY
35027: PPUSH
35028: CALL_OW 168
// end else
35032: GO 35145
// if MREG_ToConstruct [ side ] then
35034: LD_EXP 53
35038: PUSH
35039: LD_VAR 0 3
35043: ARRAY
35044: IFFALSE 35145
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
35046: LD_VAR 0 3
35050: PPUSH
35051: LD_VAR 0 3
35055: PPUSH
35056: LD_INT 30
35058: PUSH
35059: LD_INT 3
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PPUSH
35066: CALL 11553 0 2
35070: PUSH
35071: LD_INT 1
35073: ARRAY
35074: PPUSH
35075: LD_EXP 53
35079: PUSH
35080: LD_VAR 0 3
35084: ARRAY
35085: PUSH
35086: LD_INT 1
35088: ARRAY
35089: PUSH
35090: LD_EXP 53
35094: PUSH
35095: LD_VAR 0 3
35099: ARRAY
35100: PUSH
35101: LD_INT 2
35103: ARRAY
35104: PUSH
35105: LD_EXP 53
35109: PUSH
35110: LD_VAR 0 3
35114: ARRAY
35115: PUSH
35116: LD_INT 3
35118: ARRAY
35119: PUSH
35120: LD_EXP 53
35124: PUSH
35125: LD_VAR 0 3
35129: ARRAY
35130: PUSH
35131: LD_INT 4
35133: ARRAY
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: PPUSH
35141: CALL 25457 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
35145: LD_VAR 0 3
35149: PPUSH
35150: LD_INT 30
35152: PUSH
35153: LD_INT 3
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PPUSH
35160: CALL 11553 0 2
35164: PUSH
35165: LD_VAR 0 3
35169: PPUSH
35170: LD_EXP 45
35174: PPUSH
35175: CALL 43412 0 2
35179: AND
35180: PUSH
35181: LD_INT 22
35183: PUSH
35184: LD_VAR 0 3
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 2
35195: PUSH
35196: LD_INT 30
35198: PUSH
35199: LD_INT 33
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 30
35208: PUSH
35209: LD_INT 32
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 35
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: LIST
35235: PPUSH
35236: CALL_OW 69
35240: AND
35241: IFFALSE 35252
// MCV_Turret ( side ) ;
35243: LD_VAR 0 3
35247: PPUSH
35248: CALL 25906 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
35252: LD_EXP 44
35256: PUSH
35257: LD_VAR 0 3
35261: ARRAY
35262: PUSH
35263: LD_INT 1
35265: GREATER
35266: PUSH
35267: LD_VAR 0 3
35271: PPUSH
35272: CALL 24954 0 1
35276: PUSH
35277: LD_INT 0
35279: EQUAL
35280: AND
35281: IFFALSE 35443
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35283: LD_EXP 44
35287: PUSH
35288: LD_VAR 0 3
35292: ARRAY
35293: PUSH
35294: LD_INT 1
35296: ARRAY
35297: PPUSH
35298: CALL_OW 353
35302: IFFALSE 35340
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35304: LD_EXP 44
35308: PUSH
35309: LD_VAR 0 3
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PPUSH
35319: LD_EXP 44
35323: PUSH
35324: LD_VAR 0 3
35328: ARRAY
35329: PUSH
35330: LD_INT 1
35332: ARRAY
35333: PPUSH
35334: CALL 32721 0 2
35338: GO 35443
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35340: LD_VAR 0 3
35344: PPUSH
35345: LD_INT 30
35347: PUSH
35348: LD_INT 3
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PPUSH
35355: CALL 11553 0 2
35359: IFFALSE 35443
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35361: LD_VAR 0 3
35365: PPUSH
35366: LD_INT 30
35368: PUSH
35369: LD_INT 3
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PPUSH
35376: CALL 11553 0 2
35380: PUSH
35381: LD_INT 1
35383: ARRAY
35384: PPUSH
35385: CALL_OW 461
35389: PUSH
35390: LD_INT 2
35392: EQUAL
35393: IFFALSE 35443
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35395: LD_EXP 44
35399: PUSH
35400: LD_VAR 0 3
35404: ARRAY
35405: PUSH
35406: LD_INT 2
35408: ARRAY
35409: PPUSH
35410: LD_INT 10
35412: PPUSH
35413: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35417: LD_ADDR_EXP 44
35421: PUSH
35422: LD_EXP 44
35426: PPUSH
35427: LD_VAR 0 3
35431: PPUSH
35432: LD_INT 0
35434: PUSH
35435: EMPTY
35436: LIST
35437: PPUSH
35438: CALL_OW 1
35442: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35443: LD_VAR 0 3
35447: PPUSH
35448: LD_INT 33
35450: PUSH
35451: LD_INT 2
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PPUSH
35458: CALL 11553 0 2
35462: IFFALSE 35502
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35464: LD_VAR 0 3
35468: PPUSH
35469: LD_VAR 0 3
35473: PPUSH
35474: LD_INT 33
35476: PUSH
35477: LD_INT 2
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PPUSH
35484: CALL 11553 0 2
35488: PUSH
35489: LD_INT 1
35491: ARRAY
35492: PPUSH
35493: CALL_OW 248
35497: PPUSH
35498: CALL 26460 0 2
// if MREG_ToRepair [ side ] then
35502: LD_EXP 49
35506: PUSH
35507: LD_VAR 0 3
35511: ARRAY
35512: IFFALSE 35525
// begin MCB_Repair ( side ) ;
35514: LD_VAR 0 3
35518: PPUSH
35519: CALL 11293 0 1
// end else
35523: GO 36438
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35525: LD_VAR 0 3
35529: PPUSH
35530: LD_EXP 51
35534: PPUSH
35535: CALL 43412 0 2
35539: PUSH
35540: LD_VAR 0 3
35544: PPUSH
35545: LD_EXP 42
35549: PPUSH
35550: CALL 43412 0 2
35554: AND
35555: IFFALSE 35763
// begin for i = 1 to MREG_ToUpLab do
35557: LD_ADDR_VAR 0 2
35561: PUSH
35562: DOUBLE
35563: LD_INT 1
35565: DEC
35566: ST_TO_ADDR
35567: LD_EXP 51
35571: PUSH
35572: FOR_TO
35573: IFFALSE 35759
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35575: LD_EXP 51
35579: PUSH
35580: LD_VAR 0 2
35584: ARRAY
35585: PUSH
35586: LD_INT 1
35588: ARRAY
35589: PUSH
35590: LD_VAR 0 3
35594: EQUAL
35595: IFFALSE 35757
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35597: LD_EXP 51
35601: PUSH
35602: LD_VAR 0 2
35606: ARRAY
35607: PUSH
35608: LD_INT 2
35610: ARRAY
35611: PUSH
35612: LD_EXP 51
35616: PUSH
35617: LD_VAR 0 2
35621: ARRAY
35622: PUSH
35623: LD_INT 3
35625: ARRAY
35626: AND
35627: IFFALSE 35755
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35629: LD_VAR 0 3
35633: PPUSH
35634: LD_EXP 51
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: PUSH
35645: LD_INT 2
35647: ARRAY
35648: PPUSH
35649: LD_EXP 51
35653: PUSH
35654: LD_VAR 0 2
35658: ARRAY
35659: PUSH
35660: LD_INT 3
35662: ARRAY
35663: PPUSH
35664: CALL 8817 0 3
35668: IFFALSE 35755
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35670: LD_ADDR_EXP 51
35674: PUSH
35675: LD_EXP 51
35679: PPUSH
35680: LD_VAR 0 3
35684: PPUSH
35685: LD_EXP 51
35689: PUSH
35690: LD_VAR 0 2
35694: ARRAY
35695: PUSH
35696: LD_INT 2
35698: ARRAY
35699: PPUSH
35700: LD_EXP 51
35704: PUSH
35705: LD_VAR 0 2
35709: ARRAY
35710: PUSH
35711: LD_INT 3
35713: ARRAY
35714: PPUSH
35715: CALL 42464 0 4
35719: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35720: LD_ADDR_EXP 42
35724: PUSH
35725: LD_EXP 42
35729: PPUSH
35730: LD_VAR 0 3
35734: PPUSH
35735: LD_EXP 42
35739: PUSH
35740: LD_INT 1
35742: ARRAY
35743: PUSH
35744: LD_INT 2
35746: ARRAY
35747: PPUSH
35748: EMPTY
35749: PPUSH
35750: CALL 42464 0 4
35754: ST_TO_ADDR
// end ; break ;
35755: GO 35759
// end ;
35757: GO 35572
35759: POP
35760: POP
// end else
35761: GO 36438
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35763: LD_VAR 0 3
35767: PPUSH
35768: LD_EXP 50
35772: PPUSH
35773: CALL 43412 0 2
35777: IFFALSE 35851
// begin for i = 1 to MREG_ToUpdate do
35779: LD_ADDR_VAR 0 2
35783: PUSH
35784: DOUBLE
35785: LD_INT 1
35787: DEC
35788: ST_TO_ADDR
35789: LD_EXP 50
35793: PUSH
35794: FOR_TO
35795: IFFALSE 35847
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35797: LD_EXP 50
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: PUSH
35808: LD_INT 1
35810: ARRAY
35811: PUSH
35812: LD_VAR 0 3
35816: EQUAL
35817: IFFALSE 35845
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35819: LD_VAR 0 3
35823: PPUSH
35824: LD_EXP 50
35828: PUSH
35829: LD_VAR 0 2
35833: ARRAY
35834: PUSH
35835: LD_INT 2
35837: ARRAY
35838: PPUSH
35839: CALL 8653 0 2
// break ;
35843: GO 35847
// end ;
35845: GO 35794
35847: POP
35848: POP
// end else
35849: GO 36438
// if MCF_Get ( side , [ f_constructed ] ) then
35851: LD_VAR 0 3
35855: PPUSH
35856: LD_INT 57
35858: PUSH
35859: EMPTY
35860: LIST
35861: PPUSH
35862: CALL 11553 0 2
35866: IFFALSE 35899
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35868: LD_VAR 0 3
35872: PPUSH
35873: LD_VAR 0 3
35877: PPUSH
35878: LD_INT 57
35880: PUSH
35881: EMPTY
35882: LIST
35883: PPUSH
35884: CALL 11553 0 2
35888: PUSH
35889: LD_INT 1
35891: ARRAY
35892: PPUSH
35893: CALL 10897 0 2
35897: GO 36438
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35899: LD_VAR 0 3
35903: PPUSH
35904: LD_EXP 48
35908: PPUSH
35909: CALL 43412 0 2
35913: PUSH
35914: LD_VAR 0 3
35918: PPUSH
35919: CALL_OW 345
35923: NOT
35924: AND
35925: PUSH
35926: LD_VAR 0 3
35930: PPUSH
35931: CALL 24954 0 1
35935: PUSH
35936: LD_INT 0
35938: EQUAL
35939: AND
35940: IFFALSE 36339
// begin for i = 1 to MREG_ToBuild do
35942: LD_ADDR_VAR 0 2
35946: PUSH
35947: DOUBLE
35948: LD_INT 1
35950: DEC
35951: ST_TO_ADDR
35952: LD_EXP 48
35956: PUSH
35957: FOR_TO
35958: IFFALSE 36335
// if MREG_ToBuild [ i ] [ 1 ] = side then
35960: LD_EXP 48
35964: PUSH
35965: LD_VAR 0 2
35969: ARRAY
35970: PUSH
35971: LD_INT 1
35973: ARRAY
35974: PUSH
35975: LD_VAR 0 3
35979: EQUAL
35980: IFFALSE 36333
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35982: LD_OWVAR 84
35986: PUSH
35987: LD_EXP 48
35991: PUSH
35992: LD_VAR 0 2
35996: ARRAY
35997: PUSH
35998: LD_INT 3
36000: ARRAY
36001: PUSH
36002: LD_INT 1
36004: ARRAY
36005: PPUSH
36006: LD_EXP 48
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_INT 3
36019: ARRAY
36020: PUSH
36021: LD_INT 2
36023: ARRAY
36024: PPUSH
36025: CALL_OW 351
36029: AND
36030: IFFALSE 36074
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
36032: LD_EXP 48
36036: PUSH
36037: LD_VAR 0 2
36041: ARRAY
36042: PUSH
36043: LD_INT 3
36045: ARRAY
36046: PUSH
36047: LD_INT 1
36049: ARRAY
36050: PPUSH
36051: LD_EXP 48
36055: PUSH
36056: LD_VAR 0 2
36060: ARRAY
36061: PUSH
36062: LD_INT 3
36064: ARRAY
36065: PUSH
36066: LD_INT 2
36068: ARRAY
36069: PPUSH
36070: CALL 22701 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
36074: LD_EXP 48
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PUSH
36085: LD_INT 2
36087: ARRAY
36088: PUSH
36089: LD_INT 0
36091: EQUAL
36092: IFFALSE 36162
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36094: LD_VAR 0 3
36098: PPUSH
36099: LD_EXP 48
36103: PUSH
36104: LD_VAR 0 2
36108: ARRAY
36109: PUSH
36110: LD_INT 3
36112: ARRAY
36113: PUSH
36114: LD_INT 1
36116: ARRAY
36117: PPUSH
36118: LD_EXP 48
36122: PUSH
36123: LD_VAR 0 2
36127: ARRAY
36128: PUSH
36129: LD_INT 3
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: LD_EXP 48
36141: PUSH
36142: LD_VAR 0 2
36146: ARRAY
36147: PUSH
36148: LD_INT 3
36150: ARRAY
36151: PUSH
36152: LD_INT 3
36154: ARRAY
36155: PPUSH
36156: CALL 8489 0 4
36160: GO 36331
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
36162: LD_EXP 48
36166: PUSH
36167: LD_VAR 0 2
36171: ARRAY
36172: PUSH
36173: LD_INT 2
36175: ARRAY
36176: PUSH
36177: LD_INT 6
36179: EQUAL
36180: IFFALSE 36250
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
36182: LD_VAR 0 3
36186: PPUSH
36187: LD_EXP 48
36191: PUSH
36192: LD_VAR 0 2
36196: ARRAY
36197: PUSH
36198: LD_INT 3
36200: ARRAY
36201: PUSH
36202: LD_INT 1
36204: ARRAY
36205: PPUSH
36206: LD_EXP 48
36210: PUSH
36211: LD_VAR 0 2
36215: ARRAY
36216: PUSH
36217: LD_INT 3
36219: ARRAY
36220: PUSH
36221: LD_INT 2
36223: ARRAY
36224: PPUSH
36225: LD_EXP 48
36229: PUSH
36230: LD_VAR 0 2
36234: ARRAY
36235: PUSH
36236: LD_INT 3
36238: ARRAY
36239: PUSH
36240: LD_INT 3
36242: ARRAY
36243: PPUSH
36244: CALL 8618 0 4
36248: GO 36331
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
36250: LD_VAR 0 3
36254: PPUSH
36255: LD_EXP 48
36259: PUSH
36260: LD_VAR 0 2
36264: ARRAY
36265: PUSH
36266: LD_INT 2
36268: ARRAY
36269: PPUSH
36270: LD_EXP 48
36274: PUSH
36275: LD_VAR 0 2
36279: ARRAY
36280: PUSH
36281: LD_INT 3
36283: ARRAY
36284: PUSH
36285: LD_INT 1
36287: ARRAY
36288: PPUSH
36289: LD_EXP 48
36293: PUSH
36294: LD_VAR 0 2
36298: ARRAY
36299: PUSH
36300: LD_INT 3
36302: ARRAY
36303: PUSH
36304: LD_INT 2
36306: ARRAY
36307: PPUSH
36308: LD_EXP 48
36312: PUSH
36313: LD_VAR 0 2
36317: ARRAY
36318: PUSH
36319: LD_INT 3
36321: ARRAY
36322: PUSH
36323: LD_INT 3
36325: ARRAY
36326: PPUSH
36327: CALL 10122 0 5
// break ;
36331: GO 36335
// end ;
36333: GO 35957
36335: POP
36336: POP
// end else
36337: GO 36438
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36339: LD_VAR 0 3
36343: PPUSH
36344: LD_EXP 54
36348: PPUSH
36349: CALL 43412 0 2
36353: PUSH
36354: LD_VAR 0 3
36358: PPUSH
36359: CALL 24954 0 1
36363: PUSH
36364: LD_INT 0
36366: EQUAL
36367: AND
36368: IFFALSE 36438
// begin for i = 1 to MREG_ToDismantle do
36370: LD_ADDR_VAR 0 2
36374: PUSH
36375: DOUBLE
36376: LD_INT 1
36378: DEC
36379: ST_TO_ADDR
36380: LD_EXP 54
36384: PUSH
36385: FOR_TO
36386: IFFALSE 36436
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36388: LD_EXP 54
36392: PUSH
36393: LD_VAR 0 2
36397: ARRAY
36398: PUSH
36399: LD_INT 1
36401: ARRAY
36402: PUSH
36403: LD_VAR 0 3
36407: EQUAL
36408: IFFALSE 36434
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36410: LD_VAR 0 3
36414: PPUSH
36415: LD_EXP 54
36419: PUSH
36420: LD_VAR 0 2
36424: ARRAY
36425: PUSH
36426: LD_INT 2
36428: ARRAY
36429: PPUSH
36430: CALL 10788 0 2
// end ;
36434: GO 36385
36436: POP
36437: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36438: LD_VAR 0 3
36442: PPUSH
36443: LD_INT 30
36445: PUSH
36446: LD_INT 1
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PPUSH
36453: CALL 11553 0 2
36457: PUSH
36458: LD_VAR 0 3
36462: PPUSH
36463: CALL 24954 0 1
36467: PUSH
36468: LD_INT 0
36470: EQUAL
36471: AND
36472: IFFALSE 36483
// MCT_CollectCrates ( side ) ;
36474: LD_VAR 0 3
36478: PPUSH
36479: CALL 23893 0 1
// end ;
36483: GO 34484
36485: POP
36486: POP
// end ;
36487: LD_VAR 0 1
36491: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36492: LD_INT 0
36494: PPUSH
36495: PPUSH
36496: PPUSH
36497: PPUSH
36498: PPUSH
36499: PPUSH
36500: PPUSH
36501: PPUSH
36502: PPUSH
36503: PPUSH
36504: PPUSH
36505: PPUSH
36506: PPUSH
36507: PPUSH
36508: PPUSH
// all := MCF_All ( side , [ ] ) ;
36509: LD_ADDR_VAR 0 17
36513: PUSH
36514: LD_VAR 0 1
36518: PPUSH
36519: EMPTY
36520: PPUSH
36521: CALL 11688 0 2
36525: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36526: LD_ADDR_VAR 0 13
36530: PUSH
36531: LD_VAR 0 1
36535: PPUSH
36536: LD_INT 1
36538: PPUSH
36539: EMPTY
36540: PPUSH
36541: CALL 11636 0 3
36545: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36546: LD_ADDR_VAR 0 14
36550: PUSH
36551: LD_VAR 0 1
36555: PPUSH
36556: LD_INT 2
36558: PPUSH
36559: EMPTY
36560: PPUSH
36561: CALL 11636 0 3
36565: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36566: LD_ADDR_VAR 0 15
36570: PUSH
36571: LD_VAR 0 1
36575: PPUSH
36576: LD_INT 3
36578: PPUSH
36579: EMPTY
36580: PPUSH
36581: CALL 11636 0 3
36585: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36586: LD_ADDR_VAR 0 16
36590: PUSH
36591: LD_VAR 0 1
36595: PPUSH
36596: LD_INT 4
36598: PPUSH
36599: EMPTY
36600: PPUSH
36601: CALL 11636 0 3
36605: ST_TO_ADDR
// if mech then
36606: LD_VAR 0 15
36610: IFFALSE 36627
// mech := MCF_SortListDesc ( mech ) ;
36612: LD_ADDR_VAR 0 15
36616: PUSH
36617: LD_VAR 0 15
36621: PPUSH
36622: CALL 12802 0 1
36626: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36627: LD_EXP 58
36631: PUSH
36632: LD_VAR 0 1
36636: ARRAY
36637: PUSH
36638: LD_STRING 
36640: EQUAL
36641: NOT
36642: IFFALSE 36698
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36644: LD_EXP 58
36648: PUSH
36649: LD_VAR 0 1
36653: ARRAY
36654: PUSH
36655: LD_INT 1
36657: ARRAY
36658: PPUSH
36659: CALL_OW 257
36663: PUSH
36664: LD_INT 1
36666: EQUAL
36667: IFFALSE 36696
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36669: LD_VAR 0 1
36673: PPUSH
36674: LD_STRING ToArm
36676: PPUSH
36677: LD_EXP 58
36681: PUSH
36682: LD_VAR 0 1
36686: ARRAY
36687: PUSH
36688: LD_INT 1
36690: ARRAY
36691: PPUSH
36692: CALL 14432 0 3
// end else
36696: GO 36724
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36698: LD_ADDR_EXP 58
36702: PUSH
36703: LD_EXP 58
36707: PPUSH
36708: LD_VAR 0 1
36712: PPUSH
36713: LD_INT 1
36715: PPUSH
36716: LD_INT 0
36718: PPUSH
36719: CALL 31091 0 4
36723: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36724: LD_EXP 59
36728: PUSH
36729: LD_VAR 0 1
36733: ARRAY
36734: PUSH
36735: LD_STRING 
36737: EQUAL
36738: NOT
36739: IFFALSE 36795
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36741: LD_EXP 59
36745: PUSH
36746: LD_VAR 0 1
36750: ARRAY
36751: PUSH
36752: LD_INT 1
36754: ARRAY
36755: PPUSH
36756: CALL_OW 257
36760: PUSH
36761: LD_INT 2
36763: EQUAL
36764: IFFALSE 36793
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36766: LD_VAR 0 1
36770: PPUSH
36771: LD_STRING ToDep
36773: PPUSH
36774: LD_EXP 59
36778: PUSH
36779: LD_VAR 0 1
36783: ARRAY
36784: PUSH
36785: LD_INT 1
36787: ARRAY
36788: PPUSH
36789: CALL 14432 0 3
// end else
36793: GO 36821
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36795: LD_ADDR_EXP 59
36799: PUSH
36800: LD_EXP 59
36804: PPUSH
36805: LD_VAR 0 1
36809: PPUSH
36810: LD_INT 1
36812: PPUSH
36813: LD_INT 0
36815: PPUSH
36816: CALL 31091 0 4
36820: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36821: LD_EXP 57
36825: PUSH
36826: LD_VAR 0 1
36830: ARRAY
36831: PUSH
36832: LD_STRING 
36834: EQUAL
36835: NOT
36836: IFFALSE 36892
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36838: LD_EXP 57
36842: PUSH
36843: LD_VAR 0 1
36847: ARRAY
36848: PUSH
36849: LD_INT 1
36851: ARRAY
36852: PPUSH
36853: CALL_OW 257
36857: PUSH
36858: LD_INT 3
36860: EQUAL
36861: IFFALSE 36890
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36863: LD_VAR 0 1
36867: PPUSH
36868: LD_STRING ToFac
36870: PPUSH
36871: LD_EXP 57
36875: PUSH
36876: LD_VAR 0 1
36880: ARRAY
36881: PUSH
36882: LD_INT 1
36884: ARRAY
36885: PPUSH
36886: CALL 14432 0 3
// end else
36890: GO 36918
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36892: LD_ADDR_EXP 57
36896: PUSH
36897: LD_EXP 57
36901: PPUSH
36902: LD_VAR 0 1
36906: PPUSH
36907: LD_INT 1
36909: PPUSH
36910: LD_INT 0
36912: PPUSH
36913: CALL 31091 0 4
36917: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36918: LD_EXP 56
36922: PUSH
36923: LD_VAR 0 1
36927: ARRAY
36928: PUSH
36929: LD_STRING 
36931: EQUAL
36932: NOT
36933: IFFALSE 36989
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36935: LD_EXP 56
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: PUSH
36946: LD_INT 1
36948: ARRAY
36949: PPUSH
36950: CALL_OW 257
36954: PUSH
36955: LD_INT 4
36957: EQUAL
36958: IFFALSE 36987
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36960: LD_VAR 0 1
36964: PPUSH
36965: LD_STRING ToLab
36967: PPUSH
36968: LD_EXP 56
36972: PUSH
36973: LD_VAR 0 1
36977: ARRAY
36978: PUSH
36979: LD_INT 1
36981: ARRAY
36982: PPUSH
36983: CALL 14432 0 3
// end else
36987: GO 37015
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36989: LD_ADDR_EXP 56
36993: PUSH
36994: LD_EXP 56
36998: PPUSH
36999: LD_VAR 0 1
37003: PPUSH
37004: LD_INT 1
37006: PPUSH
37007: LD_INT 0
37009: PPUSH
37010: CALL 31091 0 4
37014: ST_TO_ADDR
// if mode = 0 then
37015: LD_VAR 0 2
37019: PUSH
37020: LD_INT 0
37022: EQUAL
37023: IFFALSE 38861
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
37025: LD_VAR 0 1
37029: PPUSH
37030: LD_INT 30
37032: PUSH
37033: LD_INT 1
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PPUSH
37040: CALL 11553 0 2
37044: PUSH
37045: LD_VAR 0 1
37049: PPUSH
37050: LD_INT 21
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PPUSH
37060: CALL 11553 0 2
37064: PUSH
37065: LD_INT 1
37067: EQUAL
37068: AND
37069: IFFALSE 37134
// begin if all then
37071: LD_VAR 0 17
37075: IFFALSE 37132
// for i in ( all diff eng ) do
37077: LD_ADDR_VAR 0 4
37081: PUSH
37082: LD_VAR 0 17
37086: PUSH
37087: LD_VAR 0 14
37091: DIFF
37092: PUSH
37093: FOR_IN
37094: IFFALSE 37130
// if GetTag ( i ) = 0 then
37096: LD_VAR 0 4
37100: PPUSH
37101: CALL_OW 110
37105: PUSH
37106: LD_INT 0
37108: EQUAL
37109: IFFALSE 37128
// MCH_ChangeClass ( side , i , 2 ) ;
37111: LD_VAR 0 1
37115: PPUSH
37116: LD_VAR 0 4
37120: PPUSH
37121: LD_INT 2
37123: PPUSH
37124: CALL 16460 0 3
37128: GO 37093
37130: POP
37131: POP
// end else
37132: GO 37453
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
37134: LD_VAR 0 13
37138: PUSH
37139: LD_EXP 58
37143: PUSH
37144: LD_VAR 0 1
37148: ARRAY
37149: PLUS
37150: PUSH
37151: LD_INT 22
37153: PUSH
37154: LD_VAR 0 1
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 30
37165: PUSH
37166: LD_INT 32
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PPUSH
37177: CALL_OW 69
37181: LESS
37182: IFFALSE 37207
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
37184: LD_VAR 0 1
37188: PPUSH
37189: LD_VAR 0 14
37193: PUSH
37194: LD_INT 1
37196: ARRAY
37197: PPUSH
37198: LD_INT 1
37200: PPUSH
37201: CALL 16460 0 3
// end else
37205: GO 37453
// if sci < 6 and MCF_Lab ( side ) then
37207: LD_VAR 0 16
37211: PUSH
37212: LD_INT 6
37214: LESS
37215: PUSH
37216: LD_VAR 0 1
37220: PPUSH
37221: CALL 11592 0 1
37225: AND
37226: IFFALSE 37331
// begin if MREG_ToBunker [ side ] then
37228: LD_EXP 70
37232: PUSH
37233: LD_VAR 0 1
37237: ARRAY
37238: IFFALSE 37264
// tmp := sol diff MREG_ToBunker [ side ] else
37240: LD_ADDR_VAR 0 12
37244: PUSH
37245: LD_VAR 0 13
37249: PUSH
37250: LD_EXP 70
37254: PUSH
37255: LD_VAR 0 1
37259: ARRAY
37260: DIFF
37261: ST_TO_ADDR
37262: GO 37274
// tmp := sol ;
37264: LD_ADDR_VAR 0 12
37268: PUSH
37269: LD_VAR 0 13
37273: ST_TO_ADDR
// if tmp then
37274: LD_VAR 0 12
37278: IFFALSE 37329
// for i in tmp do
37280: LD_ADDR_VAR 0 4
37284: PUSH
37285: LD_VAR 0 12
37289: PUSH
37290: FOR_IN
37291: IFFALSE 37327
// if GetTag ( i ) = 0 then
37293: LD_VAR 0 4
37297: PPUSH
37298: CALL_OW 110
37302: PUSH
37303: LD_INT 0
37305: EQUAL
37306: IFFALSE 37325
// MCH_ChangeClass ( side , i , 4 ) ;
37308: LD_VAR 0 1
37312: PPUSH
37313: LD_VAR 0 4
37317: PPUSH
37318: LD_INT 4
37320: PPUSH
37321: CALL 16460 0 3
37325: GO 37290
37327: POP
37328: POP
// end else
37329: GO 37453
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37331: LD_VAR 0 1
37335: PPUSH
37336: LD_INT 30
37338: PUSH
37339: LD_INT 1
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PPUSH
37346: CALL 11553 0 2
37350: IFFALSE 37453
// begin if MREG_ToBunker [ side ] then
37352: LD_EXP 70
37356: PUSH
37357: LD_VAR 0 1
37361: ARRAY
37362: IFFALSE 37388
// tmp := sol diff MREG_ToBunker [ side ] else
37364: LD_ADDR_VAR 0 12
37368: PUSH
37369: LD_VAR 0 13
37373: PUSH
37374: LD_EXP 70
37378: PUSH
37379: LD_VAR 0 1
37383: ARRAY
37384: DIFF
37385: ST_TO_ADDR
37386: GO 37398
// tmp := sol ;
37388: LD_ADDR_VAR 0 12
37392: PUSH
37393: LD_VAR 0 13
37397: ST_TO_ADDR
// if tmp then
37398: LD_VAR 0 12
37402: IFFALSE 37453
// for i in tmp do
37404: LD_ADDR_VAR 0 4
37408: PUSH
37409: LD_VAR 0 12
37413: PUSH
37414: FOR_IN
37415: IFFALSE 37451
// if GetTag ( i ) = 0 then
37417: LD_VAR 0 4
37421: PPUSH
37422: CALL_OW 110
37426: PUSH
37427: LD_INT 0
37429: EQUAL
37430: IFFALSE 37449
// MCH_ChangeClass ( side , i , 2 ) ;
37432: LD_VAR 0 1
37436: PPUSH
37437: LD_VAR 0 4
37441: PPUSH
37442: LD_INT 2
37444: PPUSH
37445: CALL 16460 0 3
37449: GO 37414
37451: POP
37452: POP
// end ; if MCF_Lab ( side ) then
37453: LD_VAR 0 1
37457: PPUSH
37458: CALL 11592 0 1
37462: IFFALSE 38002
// begin if MCL_GetTechList ( side ) then
37464: LD_VAR 0 1
37468: PPUSH
37469: CALL 17936 0 1
37473: IFFALSE 37599
// begin if MREG_ToLab [ side ] then
37475: LD_EXP 56
37479: PUSH
37480: LD_VAR 0 1
37484: ARRAY
37485: IFFALSE 37505
// k := MREG_ToLab [ side ] else
37487: LD_ADDR_VAR 0 8
37491: PUSH
37492: LD_EXP 56
37496: PUSH
37497: LD_VAR 0 1
37501: ARRAY
37502: ST_TO_ADDR
37503: GO 37513
// k := 0 ;
37505: LD_ADDR_VAR 0 8
37509: PUSH
37510: LD_INT 0
37512: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37513: LD_VAR 0 16
37517: PUSH
37518: LD_VAR 0 8
37522: PLUS
37523: PUSH
37524: LD_INT 6
37526: LESSEQUAL
37527: PUSH
37528: LD_VAR 0 17
37532: PUSH
37533: LD_INT 6
37535: GREATER
37536: AND
37537: IFFALSE 37553
// MCH_TrainScientist ( side , 1 ) else
37539: LD_VAR 0 1
37543: PPUSH
37544: LD_INT 1
37546: PPUSH
37547: CALL 16012 0 2
37551: GO 37597
// if all < 6 then
37553: LD_VAR 0 17
37557: PUSH
37558: LD_INT 6
37560: LESS
37561: IFFALSE 37597
// if sci + k < all / 2 then
37563: LD_VAR 0 16
37567: PUSH
37568: LD_VAR 0 8
37572: PLUS
37573: PUSH
37574: LD_VAR 0 17
37578: PUSH
37579: LD_INT 2
37581: DIVREAL
37582: LESS
37583: IFFALSE 37597
// MCH_TrainScientist ( side , 1 ) ;
37585: LD_VAR 0 1
37589: PPUSH
37590: LD_INT 1
37592: PPUSH
37593: CALL 16012 0 2
// end else
37597: GO 37675
// begin if sci > 2 then
37599: LD_VAR 0 16
37603: PUSH
37604: LD_INT 2
37606: GREATER
37607: IFFALSE 37675
// for i = sci downto 2 do
37609: LD_ADDR_VAR 0 4
37613: PUSH
37614: DOUBLE
37615: LD_VAR 0 16
37619: INC
37620: ST_TO_ADDR
37621: LD_INT 2
37623: PUSH
37624: FOR_DOWNTO
37625: IFFALSE 37673
// if GetTag ( sci [ i ] ) = 0 then
37627: LD_VAR 0 16
37631: PUSH
37632: LD_VAR 0 4
37636: ARRAY
37637: PPUSH
37638: CALL_OW 110
37642: PUSH
37643: LD_INT 0
37645: EQUAL
37646: IFFALSE 37671
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37648: LD_VAR 0 1
37652: PPUSH
37653: LD_VAR 0 16
37657: PUSH
37658: LD_VAR 0 4
37662: ARRAY
37663: PPUSH
37664: LD_INT 2
37666: PPUSH
37667: CALL 16460 0 3
37671: GO 37624
37673: POP
37674: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37675: LD_VAR 0 1
37679: PPUSH
37680: CALL 17936 0 1
37684: PUSH
37685: LD_VAR 0 1
37689: PPUSH
37690: CALL 11592 0 1
37694: AND
37695: PUSH
37696: LD_EXP 37
37700: PUSH
37701: LD_VAR 0 1
37705: ARRAY
37706: NOT
37707: AND
37708: IFFALSE 38002
// begin for j = 1 to MCF_Lab ( side ) do
37710: LD_ADDR_VAR 0 5
37714: PUSH
37715: DOUBLE
37716: LD_INT 1
37718: DEC
37719: ST_TO_ADDR
37720: LD_VAR 0 1
37724: PPUSH
37725: CALL 11592 0 1
37729: PUSH
37730: FOR_TO
37731: IFFALSE 37791
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37733: LD_VAR 0 1
37737: PPUSH
37738: CALL 11592 0 1
37742: PUSH
37743: LD_VAR 0 5
37747: ARRAY
37748: PPUSH
37749: CALL_OW 461
37753: PUSH
37754: LD_INT 3
37756: PUSH
37757: LD_INT 6
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: IN
37764: IFFALSE 37789
// begin b := MCF_Lab ( side ) [ j ] ;
37766: LD_ADDR_VAR 0 11
37770: PUSH
37771: LD_VAR 0 1
37775: PPUSH
37776: CALL 11592 0 1
37780: PUSH
37781: LD_VAR 0 5
37785: ARRAY
37786: ST_TO_ADDR
// break ;
37787: GO 37791
// end ;
37789: GO 37730
37791: POP
37792: POP
// if MCF_Class ( side , 4 , [ ] ) then
37793: LD_VAR 0 1
37797: PPUSH
37798: LD_INT 4
37800: PPUSH
37801: EMPTY
37802: PPUSH
37803: CALL 11636 0 3
37807: IFFALSE 38002
// for j in MCF_Class ( side , 4 , [ ] ) do
37809: LD_ADDR_VAR 0 5
37813: PUSH
37814: LD_VAR 0 1
37818: PPUSH
37819: LD_INT 4
37821: PPUSH
37822: EMPTY
37823: PPUSH
37824: CALL 11636 0 3
37828: PUSH
37829: FOR_IN
37830: IFFALSE 38000
// begin if GetTag ( j ) = 0 then
37832: LD_VAR 0 5
37836: PPUSH
37837: CALL_OW 110
37841: PUSH
37842: LD_INT 0
37844: EQUAL
37845: IFFALSE 37936
// begin if IsInUnit ( j ) and b then
37847: LD_VAR 0 5
37851: PPUSH
37852: CALL_OW 310
37856: PUSH
37857: LD_VAR 0 11
37861: AND
37862: IFFALSE 37910
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37864: LD_VAR 0 5
37868: PPUSH
37869: CALL_OW 310
37873: PPUSH
37874: CALL_OW 461
37878: PUSH
37879: LD_INT 2
37881: EQUAL
37882: PUSH
37883: LD_VAR 0 5
37887: PPUSH
37888: CALL_OW 310
37892: PUSH
37893: LD_VAR 0 11
37897: NONEQUAL
37898: AND
37899: IFFALSE 37910
// ComExitBuilding ( j ) ;
37901: LD_VAR 0 5
37905: PPUSH
37906: CALL_OW 122
// if not IsInUnit ( j ) then
37910: LD_VAR 0 5
37914: PPUSH
37915: CALL_OW 310
37919: NOT
37920: IFFALSE 37936
// ComEnterUnit ( j , b ) ;
37922: LD_VAR 0 5
37926: PPUSH
37927: LD_VAR 0 11
37931: PPUSH
37932: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37936: LD_INT 1
37938: PPUSH
37939: LD_VAR 0 5
37943: PPUSH
37944: CALL_OW 255
37948: PPUSH
37949: CALL_OW 321
37953: PUSH
37954: LD_INT 2
37956: EQUAL
37957: PUSH
37958: LD_VAR 0 5
37962: PPUSH
37963: CALL_OW 255
37967: PPUSH
37968: CALL 24954 0 1
37972: PUSH
37973: LD_INT 0
37975: EQUAL
37976: AND
37977: IFFALSE 37998
// MCN_Tame ( GetSide ( j ) , j ) ;
37979: LD_VAR 0 5
37983: PPUSH
37984: CALL_OW 255
37988: PPUSH
37989: LD_VAR 0 5
37993: PPUSH
37994: CALL 18455 0 2
// end ;
37998: GO 37829
38000: POP
38001: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
38002: LD_VAR 0 1
38006: PPUSH
38007: LD_INT 30
38009: PUSH
38010: LD_INT 3
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PPUSH
38017: CALL 11553 0 2
38021: IFFALSE 38280
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
38023: LD_ADDR_VAR 0 11
38027: PUSH
38028: LD_VAR 0 1
38032: PPUSH
38033: LD_INT 30
38035: PUSH
38036: LD_INT 3
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PPUSH
38043: CALL 11553 0 2
38047: PUSH
38048: LD_INT 1
38050: ARRAY
38051: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
38052: LD_ADDR_VAR 0 12
38056: PUSH
38057: LD_VAR 0 1
38061: PPUSH
38062: LD_INT 0
38064: PPUSH
38065: LD_INT 25
38067: PUSH
38068: LD_INT 3
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PPUSH
38075: CALL 12256 0 3
38079: ST_TO_ADDR
// for i = 1 to tmp do
38080: LD_ADDR_VAR 0 4
38084: PUSH
38085: DOUBLE
38086: LD_INT 1
38088: DEC
38089: ST_TO_ADDR
38090: LD_VAR 0 12
38094: PUSH
38095: FOR_TO
38096: IFFALSE 38156
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
38098: LD_VAR 0 12
38102: PUSH
38103: LD_VAR 0 4
38107: ARRAY
38108: PPUSH
38109: CALL_OW 310
38113: NOT
38114: PUSH
38115: LD_VAR 0 12
38119: PUSH
38120: LD_VAR 0 4
38124: ARRAY
38125: PPUSH
38126: CALL_OW 314
38130: NOT
38131: AND
38132: IFFALSE 38154
// ComEnterUnit ( tmp [ i ] , b ) ;
38134: LD_VAR 0 12
38138: PUSH
38139: LD_VAR 0 4
38143: ARRAY
38144: PPUSH
38145: LD_VAR 0 11
38149: PPUSH
38150: CALL_OW 120
38154: GO 38095
38156: POP
38157: POP
// if MREG_ToFac [ side ] then
38158: LD_EXP 57
38162: PUSH
38163: LD_VAR 0 1
38167: ARRAY
38168: IFFALSE 38188
// k := MREG_ToFac [ side ] else
38170: LD_ADDR_VAR 0 8
38174: PUSH
38175: LD_EXP 57
38179: PUSH
38180: LD_VAR 0 1
38184: ARRAY
38185: ST_TO_ADDR
38186: GO 38196
// k := 0 ;
38188: LD_ADDR_VAR 0 8
38192: PUSH
38193: LD_INT 0
38195: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
38196: LD_VAR 0 15
38200: PUSH
38201: LD_VAR 0 8
38205: PLUS
38206: PUSH
38207: LD_INT 6
38209: LESSEQUAL
38210: PUSH
38211: LD_VAR 0 17
38215: PUSH
38216: LD_INT 6
38218: GREATER
38219: AND
38220: IFFALSE 38236
// MCH_TrainMechanic ( side , 1 ) else
38222: LD_VAR 0 1
38226: PPUSH
38227: LD_INT 1
38229: PPUSH
38230: CALL 15754 0 2
38234: GO 38280
// if all < 6 then
38236: LD_VAR 0 17
38240: PUSH
38241: LD_INT 6
38243: LESS
38244: IFFALSE 38280
// if mech + k < all / 2 then
38246: LD_VAR 0 15
38250: PUSH
38251: LD_VAR 0 8
38255: PLUS
38256: PUSH
38257: LD_VAR 0 17
38261: PUSH
38262: LD_INT 2
38264: DIVREAL
38265: LESS
38266: IFFALSE 38280
// MCH_TrainMechanic ( side , 1 ) ;
38268: LD_VAR 0 1
38272: PPUSH
38273: LD_INT 1
38275: PPUSH
38276: CALL 15754 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38280: LD_ADDR_VAR 0 10
38284: PUSH
38285: LD_VAR 0 1
38289: PPUSH
38290: LD_INT 30
38292: PUSH
38293: LD_INT 36
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PPUSH
38300: CALL 11553 0 2
38304: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38305: LD_VAR 0 10
38309: PUSH
38310: LD_VAR 0 15
38314: AND
38315: PUSH
38316: LD_VAR 0 1
38320: PPUSH
38321: LD_INT 3
38323: PPUSH
38324: EMPTY
38325: PPUSH
38326: CALL 11636 0 3
38330: AND
38331: IFFALSE 38489
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38333: LD_VAR 0 1
38337: PPUSH
38338: LD_INT 9
38340: PPUSH
38341: EMPTY
38342: PPUSH
38343: CALL 12256 0 3
38347: PUSH
38348: LD_INT 3
38350: LESS
38351: IFFALSE 38489
// begin if mech < 3 then
38353: LD_VAR 0 15
38357: PUSH
38358: LD_INT 3
38360: LESS
38361: IFFALSE 38375
// k := mech else
38363: LD_ADDR_VAR 0 8
38367: PUSH
38368: LD_VAR 0 15
38372: ST_TO_ADDR
38373: GO 38383
// k := 3 ;
38375: LD_ADDR_VAR 0 8
38379: PUSH
38380: LD_INT 3
38382: ST_TO_ADDR
// for j = 1 to k do
38383: LD_ADDR_VAR 0 5
38387: PUSH
38388: DOUBLE
38389: LD_INT 1
38391: DEC
38392: ST_TO_ADDR
38393: LD_VAR 0 8
38397: PUSH
38398: FOR_TO
38399: IFFALSE 38457
// if GetClass ( mech [ j ] ) = 3 then
38401: LD_VAR 0 15
38405: PUSH
38406: LD_VAR 0 5
38410: ARRAY
38411: PPUSH
38412: CALL_OW 257
38416: PUSH
38417: LD_INT 3
38419: EQUAL
38420: IFFALSE 38455
// begin SetTag ( mech [ j ] , 9 ) ;
38422: LD_VAR 0 15
38426: PUSH
38427: LD_VAR 0 5
38431: ARRAY
38432: PPUSH
38433: LD_INT 9
38435: PPUSH
38436: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38440: LD_VAR 0 15
38444: PUSH
38445: LD_VAR 0 5
38449: ARRAY
38450: PPUSH
38451: CALL_OW 122
// end ;
38455: GO 38398
38457: POP
38458: POP
// if mech < 6 + k then
38459: LD_VAR 0 15
38463: PUSH
38464: LD_INT 6
38466: PUSH
38467: LD_VAR 0 8
38471: PLUS
38472: LESS
38473: IFFALSE 38489
// MCH_TrainMechanic ( side , k ) ;
38475: LD_VAR 0 1
38479: PPUSH
38480: LD_VAR 0 8
38484: PPUSH
38485: CALL 15754 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38489: LD_VAR 0 1
38493: PPUSH
38494: LD_INT 9
38496: PPUSH
38497: EMPTY
38498: PPUSH
38499: CALL 12256 0 3
38503: IFFALSE 38594
// for j in MCF_Tag ( side , 9 , [ ] ) do
38505: LD_ADDR_VAR 0 5
38509: PUSH
38510: LD_VAR 0 1
38514: PPUSH
38515: LD_INT 9
38517: PPUSH
38518: EMPTY
38519: PPUSH
38520: CALL 12256 0 3
38524: PUSH
38525: FOR_IN
38526: IFFALSE 38592
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38528: LD_VAR 0 5
38532: PPUSH
38533: CALL_OW 310
38537: NOT
38538: PUSH
38539: LD_VAR 0 5
38543: PPUSH
38544: CALL 31734 0 1
38548: NOT
38549: AND
38550: IFFALSE 38590
// if ct then
38552: LD_VAR 0 10
38556: IFFALSE 38578
// ComEnterUnit ( j , ct [ 1 ] ) else
38558: LD_VAR 0 5
38562: PPUSH
38563: LD_VAR 0 10
38567: PUSH
38568: LD_INT 1
38570: ARRAY
38571: PPUSH
38572: CALL_OW 120
38576: GO 38590
// SetTag ( j , 0 ) ;
38578: LD_VAR 0 5
38582: PPUSH
38583: LD_INT 0
38585: PPUSH
38586: CALL_OW 109
38590: GO 38525
38592: POP
38593: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38594: LD_INT 1
38596: PPUSH
38597: LD_VAR 0 1
38601: PPUSH
38602: CALL_OW 321
38606: PUSH
38607: LD_INT 2
38609: EQUAL
38610: PUSH
38611: LD_EXP 37
38615: PUSH
38616: LD_VAR 0 1
38620: ARRAY
38621: NOT
38622: AND
38623: PUSH
38624: LD_VAR 0 1
38628: PPUSH
38629: LD_INT 4
38631: PPUSH
38632: EMPTY
38633: PPUSH
38634: CALL 11636 0 3
38638: AND
38639: IFFALSE 38687
// for j in MCF_Class ( side , 4 , [ ] ) do
38641: LD_ADDR_VAR 0 5
38645: PUSH
38646: LD_VAR 0 1
38650: PPUSH
38651: LD_INT 4
38653: PPUSH
38654: EMPTY
38655: PPUSH
38656: CALL 11636 0 3
38660: PUSH
38661: FOR_IN
38662: IFFALSE 38685
// MCN_Tame ( GetSide ( j ) , j ) ;
38664: LD_VAR 0 5
38668: PPUSH
38669: CALL_OW 255
38673: PPUSH
38674: LD_VAR 0 5
38678: PPUSH
38679: CALL 18455 0 2
38683: GO 38661
38685: POP
38686: POP
// if MREG_DefVeh [ side ] then
38687: LD_EXP 69
38691: PUSH
38692: LD_VAR 0 1
38696: ARRAY
38697: IFFALSE 38861
// begin for i in MREG_DefVeh [ side ] do
38699: LD_ADDR_VAR 0 4
38703: PUSH
38704: LD_EXP 69
38708: PUSH
38709: LD_VAR 0 1
38713: ARRAY
38714: PUSH
38715: FOR_IN
38716: IFFALSE 38769
// begin SetTag ( i , 0 ) ;
38718: LD_VAR 0 4
38722: PPUSH
38723: LD_INT 0
38725: PPUSH
38726: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38730: LD_VAR 0 4
38734: PPUSH
38735: LD_EXP 66
38739: PUSH
38740: LD_VAR 0 1
38744: ARRAY
38745: PPUSH
38746: CALL_OW 308
38750: NOT
38751: IFFALSE 38767
// MCV_Parking ( side , i ) ;
38753: LD_VAR 0 1
38757: PPUSH
38758: LD_VAR 0 4
38762: PPUSH
38763: CALL 25714 0 2
// end ;
38767: GO 38715
38769: POP
38770: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38771: LD_VAR 0 1
38775: PPUSH
38776: LD_INT 36
38778: PPUSH
38779: EMPTY
38780: PPUSH
38781: CALL 12256 0 3
38785: IFFALSE 38826
// for i in MCF_Tag ( side , 36 , [ ] ) do
38787: LD_ADDR_VAR 0 4
38791: PUSH
38792: LD_VAR 0 1
38796: PPUSH
38797: LD_INT 36
38799: PPUSH
38800: EMPTY
38801: PPUSH
38802: CALL 12256 0 3
38806: PUSH
38807: FOR_IN
38808: IFFALSE 38824
// SetTag ( i , 0 ) ;
38810: LD_VAR 0 4
38814: PPUSH
38815: LD_INT 0
38817: PPUSH
38818: CALL_OW 109
38822: GO 38807
38824: POP
38825: POP
// if MREG_DefMobActive [ side ] then
38826: LD_EXP 72
38830: PUSH
38831: LD_VAR 0 1
38835: ARRAY
38836: IFFALSE 38861
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38838: LD_ADDR_EXP 72
38842: PUSH
38843: LD_EXP 72
38847: PPUSH
38848: LD_VAR 0 1
38852: PPUSH
38853: LD_INT 0
38855: PPUSH
38856: CALL_OW 1
38860: ST_TO_ADDR
// end ; end ; if mode > 0 then
38861: LD_VAR 0 2
38865: PUSH
38866: LD_INT 0
38868: GREATER
38869: IFFALSE 40884
// begin if tick <= 15 15$00 then
38871: LD_OWVAR 1
38875: PUSH
38876: LD_INT 31500
38878: LESSEQUAL
38879: IFFALSE 39303
// begin if sol > 4 and MCT_EnemyNearBase ( side ) < 4 then
38881: LD_VAR 0 13
38885: PUSH
38886: LD_INT 4
38888: GREATER
38889: PUSH
38890: LD_VAR 0 1
38894: PPUSH
38895: CALL 24954 0 1
38899: PUSH
38900: LD_INT 4
38902: LESS
38903: AND
38904: IFFALSE 39015
// for i in sol do
38906: LD_ADDR_VAR 0 4
38910: PUSH
38911: LD_VAR 0 13
38915: PUSH
38916: FOR_IN
38917: IFFALSE 39013
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38919: LD_ADDR_VAR 0 8
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: CALL 24954 0 1
38933: PPUSH
38934: LD_VAR 0 4
38938: PPUSH
38939: CALL_OW 74
38943: ST_TO_ADDR
// if IsInUnit ( i ) then
38944: LD_VAR 0 4
38948: PPUSH
38949: CALL_OW 310
38953: IFFALSE 38964
// ComExitBuilding ( i ) ;
38955: LD_VAR 0 4
38959: PPUSH
38960: CALL_OW 122
// if not HasTask ( i ) and k then
38964: LD_VAR 0 4
38968: PPUSH
38969: CALL_OW 314
38973: NOT
38974: PUSH
38975: LD_VAR 0 8
38979: AND
38980: IFFALSE 39011
// ComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38982: LD_VAR 0 4
38986: PPUSH
38987: LD_VAR 0 8
38991: PPUSH
38992: CALL_OW 250
38996: PPUSH
38997: LD_VAR 0 8
39001: PPUSH
39002: CALL_OW 251
39006: PPUSH
39007: CALL_OW 114
// end ;
39011: GO 38916
39013: POP
39014: POP
// if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39015: LD_VAR 0 1
39019: PPUSH
39020: LD_INT 30
39022: PUSH
39023: LD_INT 5
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PPUSH
39030: CALL 11553 0 2
39034: IFFALSE 39301
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39036: LD_ADDR_VAR 0 11
39040: PUSH
39041: LD_VAR 0 1
39045: PPUSH
39046: LD_INT 30
39048: PUSH
39049: LD_INT 5
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PPUSH
39056: CALL 11553 0 2
39060: PUSH
39061: LD_INT 1
39063: ARRAY
39064: ST_TO_ADDR
// if mech then
39065: LD_VAR 0 15
39069: IFFALSE 39105
// for i in mech do
39071: LD_ADDR_VAR 0 4
39075: PUSH
39076: LD_VAR 0 15
39080: PUSH
39081: FOR_IN
39082: IFFALSE 39103
// MCH_ChangeClass ( side , i , 1 ) ;
39084: LD_VAR 0 1
39088: PPUSH
39089: LD_VAR 0 4
39093: PPUSH
39094: LD_INT 1
39096: PPUSH
39097: CALL 16460 0 3
39101: GO 39081
39103: POP
39104: POP
// if eng > 1 then
39105: LD_VAR 0 14
39109: PUSH
39110: LD_INT 1
39112: GREATER
39113: IFFALSE 39160
// for i = eng downto 2 do
39115: LD_ADDR_VAR 0 4
39119: PUSH
39120: DOUBLE
39121: LD_VAR 0 14
39125: INC
39126: ST_TO_ADDR
39127: LD_INT 2
39129: PUSH
39130: FOR_DOWNTO
39131: IFFALSE 39158
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39133: LD_VAR 0 1
39137: PPUSH
39138: LD_VAR 0 14
39142: PUSH
39143: LD_VAR 0 4
39147: ARRAY
39148: PPUSH
39149: LD_INT 1
39151: PPUSH
39152: CALL 16460 0 3
39156: GO 39130
39158: POP
39159: POP
// if UnitsInside ( b ) = 6 then
39160: LD_VAR 0 11
39164: PPUSH
39165: CALL_OW 313
39169: PUSH
39170: LD_INT 6
39172: EQUAL
39173: IFFALSE 39301
// begin un := UnitsInside ( b ) [ 1 ] ;
39175: LD_ADDR_VAR 0 9
39179: PUSH
39180: LD_VAR 0 11
39184: PPUSH
39185: CALL_OW 313
39189: PUSH
39190: LD_INT 1
39192: ARRAY
39193: ST_TO_ADDR
// ComExitBuilding ( un ) ;
39194: LD_VAR 0 9
39198: PPUSH
39199: CALL_OW 122
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 and MCT_EnemyNearBase ( side ) >= 4 then
39203: LD_VAR 0 1
39207: PPUSH
39208: LD_INT 30
39210: PUSH
39211: LD_INT 5
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PPUSH
39218: CALL 11553 0 2
39222: PUSH
39223: LD_INT 1
39225: GREATER
39226: PUSH
39227: LD_VAR 0 1
39231: PPUSH
39232: CALL 24954 0 1
39236: PUSH
39237: LD_INT 4
39239: GREATEREQUAL
39240: AND
39241: IFFALSE 39301
// begin k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39243: LD_ADDR_VAR 0 8
39247: PUSH
39248: LD_VAR 0 1
39252: PPUSH
39253: LD_INT 30
39255: PUSH
39256: LD_INT 5
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PPUSH
39263: CALL 11553 0 2
39267: PUSH
39268: LD_INT 2
39270: ARRAY
39271: ST_TO_ADDR
// if UnitsInside ( k ) < 6 then
39272: LD_VAR 0 8
39276: PPUSH
39277: CALL_OW 313
39281: PUSH
39282: LD_INT 6
39284: LESS
39285: IFFALSE 39301
// AddComEnterUnit ( un , k ) ;
39287: LD_VAR 0 9
39291: PPUSH
39292: LD_VAR 0 8
39296: PPUSH
39297: CALL_OW 180
// end ; end ; end ; end else
39301: GO 40884
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
39303: LD_VAR 0 1
39307: PPUSH
39308: LD_INT 1
39310: PPUSH
39311: LD_EXP 67
39315: PUSH
39316: LD_VAR 0 1
39320: ARRAY
39321: PUSH
39322: LD_INT 1
39324: ARRAY
39325: PPUSH
39326: CALL 34036 0 3
39330: IFFALSE 39469
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
39332: LD_ADDR_VAR 0 12
39336: PUSH
39337: LD_VAR 0 1
39341: PPUSH
39342: LD_INT 21
39344: PUSH
39345: LD_INT 1
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PPUSH
39352: CALL 11553 0 2
39356: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
39357: LD_ADDR_VAR 0 11
39361: PUSH
39362: LD_VAR 0 1
39366: PPUSH
39367: LD_INT 30
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PPUSH
39377: CALL 11553 0 2
39381: ST_TO_ADDR
// if b then
39382: LD_VAR 0 11
39386: IFFALSE 39469
// for i in tmp do
39388: LD_ADDR_VAR 0 4
39392: PUSH
39393: LD_VAR 0 12
39397: PUSH
39398: FOR_IN
39399: IFFALSE 39467
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39401: LD_VAR 0 4
39405: PPUSH
39406: LD_EXP 67
39410: PUSH
39411: LD_VAR 0 1
39415: ARRAY
39416: PUSH
39417: LD_INT 1
39419: ARRAY
39420: PPUSH
39421: CALL_OW 308
39425: NOT
39426: IFFALSE 39465
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39428: LD_VAR 0 4
39432: PPUSH
39433: LD_VAR 0 11
39437: PUSH
39438: LD_INT 1
39440: ARRAY
39441: PPUSH
39442: CALL_OW 250
39446: PPUSH
39447: LD_VAR 0 11
39451: PUSH
39452: LD_INT 1
39454: ARRAY
39455: PPUSH
39456: CALL_OW 251
39460: PPUSH
39461: CALL_OW 111
39465: GO 39398
39467: POP
39468: POP
// end ; if MREG_DefVeh [ side ] then
39469: LD_EXP 69
39473: PUSH
39474: LD_VAR 0 1
39478: ARRAY
39479: IFFALSE 40047
// begin tmp := [ ] ;
39481: LD_ADDR_VAR 0 12
39485: PUSH
39486: EMPTY
39487: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39488: LD_EXP 72
39492: PUSH
39493: LD_VAR 0 1
39497: ARRAY
39498: PUSH
39499: LD_INT 0
39501: EQUAL
39502: IFFALSE 39642
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39504: LD_ADDR_VAR 0 8
39508: PUSH
39509: LD_VAR 0 1
39513: PPUSH
39514: LD_INT 0
39516: PPUSH
39517: LD_INT 25
39519: PUSH
39520: LD_INT 3
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PPUSH
39527: CALL 12256 0 3
39531: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39532: LD_VAR 0 8
39536: PUSH
39537: LD_EXP 69
39541: PUSH
39542: LD_VAR 0 1
39546: ARRAY
39547: GREATER
39548: IFFALSE 39609
// begin for i = 1 to MREG_DefVeh [ side ] do
39550: LD_ADDR_VAR 0 4
39554: PUSH
39555: DOUBLE
39556: LD_INT 1
39558: DEC
39559: ST_TO_ADDR
39560: LD_EXP 69
39564: PUSH
39565: LD_VAR 0 1
39569: ARRAY
39570: PUSH
39571: FOR_TO
39572: IFFALSE 39605
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39574: LD_ADDR_VAR 0 12
39578: PUSH
39579: LD_VAR 0 12
39583: PPUSH
39584: LD_INT 1
39586: PPUSH
39587: LD_VAR 0 8
39591: PUSH
39592: LD_VAR 0 4
39596: ARRAY
39597: PPUSH
39598: CALL_OW 2
39602: ST_TO_ADDR
39603: GO 39571
39605: POP
39606: POP
// end else
39607: GO 39619
// tmp := k ;
39609: LD_ADDR_VAR 0 12
39613: PUSH
39614: LD_VAR 0 8
39618: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39619: LD_ADDR_EXP 72
39623: PUSH
39624: LD_EXP 72
39628: PPUSH
39629: LD_VAR 0 1
39633: PPUSH
39634: LD_INT 1
39636: PPUSH
39637: CALL_OW 1
39641: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39642: LD_ADDR_VAR 0 4
39646: PUSH
39647: LD_EXP 69
39651: PUSH
39652: LD_VAR 0 1
39656: ARRAY
39657: PUSH
39658: FOR_IN
39659: IFFALSE 40045
// begin if not GetDriver ( i ) then
39661: LD_VAR 0 4
39665: PPUSH
39666: CALL 31785 0 1
39670: NOT
39671: IFFALSE 39746
// begin if tmp then
39673: LD_VAR 0 12
39677: IFFALSE 39744
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39679: LD_VAR 0 12
39683: PUSH
39684: LD_INT 1
39686: ARRAY
39687: PPUSH
39688: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39692: LD_VAR 0 12
39696: PUSH
39697: LD_INT 1
39699: ARRAY
39700: PPUSH
39701: LD_VAR 0 4
39705: PPUSH
39706: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39710: LD_VAR 0 12
39714: PUSH
39715: LD_INT 1
39717: ARRAY
39718: PPUSH
39719: LD_INT 36
39721: PPUSH
39722: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39726: LD_ADDR_VAR 0 12
39730: PUSH
39731: LD_VAR 0 12
39735: PPUSH
39736: LD_INT 1
39738: PPUSH
39739: CALL_OW 3
39743: ST_TO_ADDR
// end ; end else
39744: GO 40043
// begin if GetTag ( i ) = 0 then
39746: LD_VAR 0 4
39750: PPUSH
39751: CALL_OW 110
39755: PUSH
39756: LD_INT 0
39758: EQUAL
39759: IFFALSE 39775
// SetTag ( i , 31 ) else
39761: LD_VAR 0 4
39765: PPUSH
39766: LD_INT 31
39768: PPUSH
39769: CALL_OW 109
39773: GO 40043
// if GetTag ( i ) = 31 then
39775: LD_VAR 0 4
39779: PPUSH
39780: CALL_OW 110
39784: PUSH
39785: LD_INT 31
39787: EQUAL
39788: IFFALSE 40043
// begin if GetFuel ( i ) < 20 then
39790: LD_VAR 0 4
39794: PPUSH
39795: CALL_OW 261
39799: PUSH
39800: LD_INT 20
39802: LESS
39803: IFFALSE 39828
// begin SetTag ( i , 21 ) ;
39805: LD_VAR 0 4
39809: PPUSH
39810: LD_INT 21
39812: PPUSH
39813: CALL_OW 109
// MCV_Refuel ( i ) ;
39817: LD_VAR 0 4
39821: PPUSH
39822: CALL 26251 0 1
// continue ;
39826: GO 39658
// end ; if GetLives ( i ) < 700 then
39828: LD_VAR 0 4
39832: PPUSH
39833: CALL_OW 256
39837: PUSH
39838: LD_INT 700
39840: LESS
39841: IFFALSE 39953
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39843: LD_VAR 0 4
39847: PPUSH
39848: LD_EXP 60
39852: PUSH
39853: LD_VAR 0 1
39857: ARRAY
39858: PPUSH
39859: CALL_OW 308
39863: NOT
39864: IFFALSE 39888
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39866: LD_VAR 0 4
39870: PPUSH
39871: LD_EXP 60
39875: PUSH
39876: LD_VAR 0 1
39880: ARRAY
39881: PPUSH
39882: CALL_OW 113
39886: GO 39951
// if GetDriver ( i ) then
39888: LD_VAR 0 4
39892: PPUSH
39893: CALL 31785 0 1
39897: IFFALSE 39951
// begin k := GetDriver ( i ) ;
39899: LD_ADDR_VAR 0 8
39903: PUSH
39904: LD_VAR 0 4
39908: PPUSH
39909: CALL 31785 0 1
39913: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39914: LD_VAR 0 8
39918: PPUSH
39919: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39923: LD_VAR 0 8
39927: PPUSH
39928: LD_VAR 0 4
39932: PPUSH
39933: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39937: LD_VAR 0 8
39941: PPUSH
39942: LD_VAR 0 4
39946: PPUSH
39947: CALL_OW 180
// end ; end else
39951: GO 40043
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39953: LD_ADDR_VAR 0 8
39957: PUSH
39958: LD_VAR 0 1
39962: PPUSH
39963: CALL 24954 0 1
39967: PPUSH
39968: LD_VAR 0 4
39972: PPUSH
39973: CALL_OW 74
39977: ST_TO_ADDR
// if k then
39978: LD_VAR 0 8
39982: IFFALSE 40000
// ComAttackUnit ( i , k ) else
39984: LD_VAR 0 4
39988: PPUSH
39989: LD_VAR 0 8
39993: PPUSH
39994: CALL_OW 115
39998: GO 40043
// if not IsInArea ( i , MREG_Parking [ side ] ) then
40000: LD_VAR 0 4
40004: PPUSH
40005: LD_EXP 60
40009: PUSH
40010: LD_VAR 0 1
40014: ARRAY
40015: PPUSH
40016: CALL_OW 308
40020: NOT
40021: IFFALSE 40043
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
40023: LD_VAR 0 4
40027: PPUSH
40028: LD_EXP 60
40032: PUSH
40033: LD_VAR 0 1
40037: ARRAY
40038: PPUSH
40039: CALL_OW 113
// end ; end ; end ; end ;
40043: GO 39658
40045: POP
40046: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
40047: LD_VAR 0 1
40051: PPUSH
40052: LD_INT 30
40054: PUSH
40055: LD_INT 5
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PPUSH
40062: CALL 11553 0 2
40066: IFFALSE 40884
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
40068: LD_ADDR_VAR 0 11
40072: PUSH
40073: LD_VAR 0 1
40077: PPUSH
40078: LD_INT 30
40080: PUSH
40081: LD_INT 5
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PPUSH
40088: CALL 11553 0 2
40092: PUSH
40093: LD_INT 1
40095: ARRAY
40096: ST_TO_ADDR
// if eng > 1 then
40097: LD_VAR 0 14
40101: PUSH
40102: LD_INT 1
40104: GREATER
40105: IFFALSE 40152
// for i = eng downto 2 do
40107: LD_ADDR_VAR 0 4
40111: PUSH
40112: DOUBLE
40113: LD_VAR 0 14
40117: INC
40118: ST_TO_ADDR
40119: LD_INT 2
40121: PUSH
40122: FOR_DOWNTO
40123: IFFALSE 40150
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
40125: LD_VAR 0 1
40129: PPUSH
40130: LD_VAR 0 14
40134: PUSH
40135: LD_VAR 0 4
40139: ARRAY
40140: PPUSH
40141: LD_INT 1
40143: PPUSH
40144: CALL 16460 0 3
40148: GO 40122
40150: POP
40151: POP
// if sci > 1 then
40152: LD_VAR 0 16
40156: PUSH
40157: LD_INT 1
40159: GREATER
40160: IFFALSE 40207
// for i = sci downto 2 do
40162: LD_ADDR_VAR 0 4
40166: PUSH
40167: DOUBLE
40168: LD_VAR 0 16
40172: INC
40173: ST_TO_ADDR
40174: LD_INT 2
40176: PUSH
40177: FOR_DOWNTO
40178: IFFALSE 40205
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
40180: LD_VAR 0 1
40184: PPUSH
40185: LD_VAR 0 16
40189: PUSH
40190: LD_VAR 0 4
40194: ARRAY
40195: PPUSH
40196: LD_INT 1
40198: PPUSH
40199: CALL 16460 0 3
40203: GO 40177
40205: POP
40206: POP
// if sol then
40207: LD_VAR 0 13
40211: IFFALSE 40884
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
40213: LD_VAR 0 13
40217: PUSH
40218: LD_EXP 70
40222: PUSH
40223: LD_VAR 0 1
40227: ARRAY
40228: DIFF
40229: PUSH
40230: LD_INT 22
40232: PUSH
40233: LD_VAR 0 1
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PUSH
40242: LD_INT 58
40244: PUSH
40245: EMPTY
40246: LIST
40247: PUSH
40248: LD_INT 2
40250: PUSH
40251: LD_INT 30
40253: PUSH
40254: LD_INT 32
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 30
40263: PUSH
40264: LD_INT 31
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: LIST
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: LIST
40280: PPUSH
40281: CALL_OW 69
40285: PUSH
40286: LD_INT 0
40288: EQUAL
40289: AND
40290: IFFALSE 40884
// begin tmp := sol diff MREG_ToBunker [ side ] ;
40292: LD_ADDR_VAR 0 12
40296: PUSH
40297: LD_VAR 0 13
40301: PUSH
40302: LD_EXP 70
40306: PUSH
40307: LD_VAR 0 1
40311: ARRAY
40312: DIFF
40313: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
40314: LD_VAR 0 1
40318: PPUSH
40319: LD_INT 30
40321: PUSH
40322: LD_INT 5
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PPUSH
40329: CALL 11553 0 2
40333: PUSH
40334: LD_INT 1
40336: GREATER
40337: IFFALSE 40368
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
40339: LD_ADDR_VAR 0 8
40343: PUSH
40344: LD_VAR 0 1
40348: PPUSH
40349: LD_INT 30
40351: PUSH
40352: LD_INT 5
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PPUSH
40359: CALL 11553 0 2
40363: PUSH
40364: LD_INT 2
40366: ARRAY
40367: ST_TO_ADDR
// for j in tmp do
40368: LD_ADDR_VAR 0 5
40372: PUSH
40373: LD_VAR 0 12
40377: PUSH
40378: FOR_IN
40379: IFFALSE 40882
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
40381: LD_VAR 0 5
40385: PUSH
40386: LD_VAR 0 11
40390: PPUSH
40391: CALL_OW 313
40395: IN
40396: PUSH
40397: LD_VAR 0 11
40401: PPUSH
40402: CALL_OW 313
40406: PUSH
40407: LD_INT 6
40409: EQUAL
40410: AND
40411: PUSH
40412: LD_VAR 0 8
40416: AND
40417: PUSH
40418: LD_VAR 0 8
40422: PPUSH
40423: CALL_OW 313
40427: PUSH
40428: LD_INT 6
40430: LESS
40431: AND
40432: IFFALSE 40459
// begin ComExitBuilding ( j ) ;
40434: LD_VAR 0 5
40438: PPUSH
40439: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40443: LD_VAR 0 5
40447: PPUSH
40448: LD_VAR 0 8
40452: PPUSH
40453: CALL_OW 180
// continue ;
40457: GO 40378
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40459: LD_VAR 0 5
40463: PPUSH
40464: CALL_OW 314
40468: NOT
40469: PUSH
40470: LD_VAR 0 5
40474: PPUSH
40475: CALL_OW 110
40479: PUSH
40480: LD_INT 0
40482: EQUAL
40483: AND
40484: PUSH
40485: LD_VAR 0 5
40489: PPUSH
40490: CALL_OW 310
40494: NOT
40495: AND
40496: IFFALSE 40602
// begin if k then
40498: LD_VAR 0 8
40502: IFFALSE 40573
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40504: LD_VAR 0 8
40508: PPUSH
40509: CALL_OW 313
40513: PUSH
40514: LD_VAR 0 11
40518: PPUSH
40519: CALL_OW 313
40523: LESS
40524: IFFALSE 40542
// ComEnterUnit ( j , k ) else
40526: LD_VAR 0 5
40530: PPUSH
40531: LD_VAR 0 8
40535: PPUSH
40536: CALL_OW 120
40540: GO 40571
// if UnitsInside ( b ) < 6 then
40542: LD_VAR 0 11
40546: PPUSH
40547: CALL_OW 313
40551: PUSH
40552: LD_INT 6
40554: LESS
40555: IFFALSE 40571
// ComEnterUnit ( j , b ) ;
40557: LD_VAR 0 5
40561: PPUSH
40562: LD_VAR 0 11
40566: PPUSH
40567: CALL_OW 120
// end else
40571: GO 40602
// if UnitsInside ( b ) < 6 then
40573: LD_VAR 0 11
40577: PPUSH
40578: CALL_OW 313
40582: PUSH
40583: LD_INT 6
40585: LESS
40586: IFFALSE 40602
// ComEnterUnit ( j , b ) ;
40588: LD_VAR 0 5
40592: PPUSH
40593: LD_VAR 0 11
40597: PPUSH
40598: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40602: LD_VAR 0 5
40606: PUSH
40607: LD_VAR 0 1
40611: PPUSH
40612: LD_INT 54
40614: PUSH
40615: EMPTY
40616: LIST
40617: PPUSH
40618: CALL 11553 0 2
40622: IN
40623: PUSH
40624: LD_VAR 0 5
40628: PPUSH
40629: CALL_OW 257
40633: PUSH
40634: LD_INT 1
40636: EQUAL
40637: AND
40638: IFFALSE 40880
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40640: LD_EXP 64
40644: PUSH
40645: LD_VAR 0 1
40649: ARRAY
40650: PUSH
40651: LD_INT 1
40653: ARRAY
40654: PUSH
40655: LD_INT 12
40657: PPUSH
40658: LD_VAR 0 1
40662: PPUSH
40663: CALL_OW 321
40667: PUSH
40668: LD_INT 2
40670: EQUAL
40671: AND
40672: IFFALSE 40720
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40674: LD_VAR 0 1
40678: PPUSH
40679: LD_INT 5
40681: PPUSH
40682: EMPTY
40683: PPUSH
40684: CALL 11636 0 3
40688: PUSH
40689: LD_EXP 64
40693: PUSH
40694: LD_VAR 0 1
40698: ARRAY
40699: PUSH
40700: LD_INT 1
40702: ARRAY
40703: LESS
40704: IFFALSE 40720
// begin SetClass ( j , class_sniper ) ;
40706: LD_VAR 0 5
40710: PPUSH
40711: LD_INT 5
40713: PPUSH
40714: CALL_OW 336
// continue ;
40718: GO 40378
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40720: LD_EXP 64
40724: PUSH
40725: LD_VAR 0 1
40729: ARRAY
40730: PUSH
40731: LD_INT 2
40733: ARRAY
40734: PUSH
40735: LD_INT 41
40737: PPUSH
40738: LD_VAR 0 1
40742: PPUSH
40743: CALL_OW 321
40747: PUSH
40748: LD_INT 2
40750: EQUAL
40751: AND
40752: IFFALSE 40800
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40754: LD_VAR 0 1
40758: PPUSH
40759: LD_INT 8
40761: PPUSH
40762: EMPTY
40763: PPUSH
40764: CALL 11636 0 3
40768: PUSH
40769: LD_EXP 64
40773: PUSH
40774: LD_VAR 0 1
40778: ARRAY
40779: PUSH
40780: LD_INT 2
40782: ARRAY
40783: LESS
40784: IFFALSE 40800
// begin SetClass ( j , class_mortar ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_INT 8
40793: PPUSH
40794: CALL_OW 336
// continue ;
40798: GO 40378
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40800: LD_EXP 64
40804: PUSH
40805: LD_VAR 0 1
40809: ARRAY
40810: PUSH
40811: LD_INT 3
40813: ARRAY
40814: PUSH
40815: LD_INT 44
40817: PPUSH
40818: LD_VAR 0 1
40822: PPUSH
40823: CALL_OW 321
40827: PUSH
40828: LD_INT 2
40830: EQUAL
40831: AND
40832: IFFALSE 40880
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40834: LD_VAR 0 1
40838: PPUSH
40839: LD_INT 9
40841: PPUSH
40842: EMPTY
40843: PPUSH
40844: CALL 11636 0 3
40848: PUSH
40849: LD_EXP 64
40853: PUSH
40854: LD_VAR 0 1
40858: ARRAY
40859: PUSH
40860: LD_INT 3
40862: ARRAY
40863: LESS
40864: IFFALSE 40880
// begin SetClass ( j , class_bazooker ) ;
40866: LD_VAR 0 5
40870: PPUSH
40871: LD_INT 9
40873: PPUSH
40874: CALL_OW 336
// continue ;
40878: GO 40378
// end ; end ; end ;
40880: GO 40378
40882: POP
40883: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40884: LD_INT 22
40886: PUSH
40887: LD_VAR 0 1
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 58
40898: PUSH
40899: EMPTY
40900: LIST
40901: PUSH
40902: LD_INT 30
40904: PUSH
40905: LD_INT 32
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: LIST
40916: PPUSH
40917: CALL_OW 69
40921: IFFALSE 41071
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40923: LD_ADDR_VAR 0 12
40927: PUSH
40928: LD_INT 22
40930: PUSH
40931: LD_VAR 0 1
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 58
40942: PUSH
40943: EMPTY
40944: LIST
40945: PUSH
40946: LD_INT 30
40948: PUSH
40949: LD_INT 32
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: LIST
40960: PPUSH
40961: CALL_OW 69
40965: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40966: LD_ADDR_VAR 0 8
40970: PUSH
40971: LD_VAR 0 13
40975: PUSH
40976: LD_EXP 70
40980: PUSH
40981: LD_VAR 0 1
40985: ARRAY
40986: DIFF
40987: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40988: LD_VAR 0 12
40992: PUSH
40993: LD_INT 1
40995: ARRAY
40996: PPUSH
40997: CALL_OW 461
41001: PUSH
41002: LD_INT 2
41004: EQUAL
41005: PUSH
41006: LD_VAR 0 12
41010: PUSH
41011: LD_INT 1
41013: ARRAY
41014: PUSH
41015: LD_EXP 70
41019: PUSH
41020: LD_VAR 0 1
41024: ARRAY
41025: IN
41026: NOT
41027: AND
41028: PUSH
41029: LD_VAR 0 8
41033: AND
41034: IFFALSE 41071
// begin ComExitBuilding ( k [ 1 ] ) ;
41036: LD_VAR 0 8
41040: PUSH
41041: LD_INT 1
41043: ARRAY
41044: PPUSH
41045: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
41049: LD_VAR 0 8
41053: PUSH
41054: LD_INT 1
41056: ARRAY
41057: PPUSH
41058: LD_VAR 0 12
41062: PUSH
41063: LD_INT 1
41065: ARRAY
41066: PPUSH
41067: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
41071: LD_EXP 37
41075: PUSH
41076: LD_VAR 0 1
41080: ARRAY
41081: IFFALSE 41229
// begin if MCF_Class ( side , 4 , [ ] ) then
41083: LD_VAR 0 1
41087: PPUSH
41088: LD_INT 4
41090: PPUSH
41091: EMPTY
41092: PPUSH
41093: CALL 11636 0 3
41097: IFFALSE 41227
// for j in MCF_Class ( side , 4 , [ ] ) do
41099: LD_ADDR_VAR 0 5
41103: PUSH
41104: LD_VAR 0 1
41108: PPUSH
41109: LD_INT 4
41111: PPUSH
41112: EMPTY
41113: PPUSH
41114: CALL 11636 0 3
41118: PUSH
41119: FOR_IN
41120: IFFALSE 41225
// begin if not GetTag ( j ) = 4 then
41122: LD_VAR 0 5
41126: PPUSH
41127: CALL_OW 110
41131: PUSH
41132: LD_INT 4
41134: EQUAL
41135: NOT
41136: IFFALSE 41172
// begin SetTag ( j , 4 ) ;
41138: LD_VAR 0 5
41142: PPUSH
41143: LD_INT 4
41145: PPUSH
41146: CALL_OW 109
// if IsInUnit ( j ) then
41150: LD_VAR 0 5
41154: PPUSH
41155: CALL_OW 310
41159: IFFALSE 41170
// ComExitBuilding ( j ) ;
41161: LD_VAR 0 5
41165: PPUSH
41166: CALL_OW 122
// end else
41170: GO 41223
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
41172: LD_VAR 0 5
41176: PPUSH
41177: LD_EXP 37
41181: PUSH
41182: LD_VAR 0 1
41186: ARRAY
41187: PUSH
41188: LD_INT 1
41190: ARRAY
41191: PPUSH
41192: CALL 32476 0 2
41196: NOT
41197: IFFALSE 41223
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
41199: LD_VAR 0 5
41203: PPUSH
41204: LD_EXP 37
41208: PUSH
41209: LD_VAR 0 1
41213: ARRAY
41214: PUSH
41215: LD_INT 1
41217: ARRAY
41218: PPUSH
41219: CALL 19123 0 2
// end ;
41223: GO 41119
41225: POP
41226: POP
// end else
41227: GO 41461
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
41229: LD_VAR 0 1
41233: PPUSH
41234: LD_INT 4
41236: PPUSH
41237: EMPTY
41238: PPUSH
41239: CALL 11636 0 3
41243: PUSH
41244: LD_VAR 0 1
41248: PPUSH
41249: LD_INT 4
41251: PPUSH
41252: EMPTY
41253: PPUSH
41254: CALL 12256 0 3
41258: AND
41259: IFFALSE 41461
// for j in MCF_Class ( side , 4 , [ ] ) do
41261: LD_ADDR_VAR 0 5
41265: PUSH
41266: LD_VAR 0 1
41270: PPUSH
41271: LD_INT 4
41273: PPUSH
41274: EMPTY
41275: PPUSH
41276: CALL 11636 0 3
41280: PUSH
41281: FOR_IN
41282: IFFALSE 41459
// begin if GetTag ( j ) = 4 then
41284: LD_VAR 0 5
41288: PPUSH
41289: CALL_OW 110
41293: PUSH
41294: LD_INT 4
41296: EQUAL
41297: IFFALSE 41457
// begin SetTag ( j , 0 ) ;
41299: LD_VAR 0 5
41303: PPUSH
41304: LD_INT 0
41306: PPUSH
41307: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
41311: LD_VAR 0 1
41315: PPUSH
41316: CALL 11592 0 1
41320: PUSH
41321: LD_VAR 0 1
41325: PPUSH
41326: CALL 17936 0 1
41330: NOT
41331: AND
41332: IFFALSE 41357
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
41334: LD_VAR 0 5
41338: PPUSH
41339: LD_VAR 0 1
41343: PPUSH
41344: CALL 11592 0 1
41348: PUSH
41349: LD_INT 1
41351: ARRAY
41352: PPUSH
41353: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
41357: LD_VAR 0 1
41361: PPUSH
41362: CALL 11592 0 1
41366: NOT
41367: PUSH
41368: LD_VAR 0 1
41372: PPUSH
41373: LD_INT 30
41375: PUSH
41376: LD_INT 1
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 11553 0 2
41387: AND
41388: IFFALSE 41457
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
41390: LD_VAR 0 5
41394: PPUSH
41395: LD_VAR 0 1
41399: PPUSH
41400: LD_INT 30
41402: PUSH
41403: LD_INT 1
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PPUSH
41410: CALL 11553 0 2
41414: PUSH
41415: LD_INT 1
41417: ARRAY
41418: PPUSH
41419: CALL_OW 250
41423: PPUSH
41424: LD_VAR 0 1
41428: PPUSH
41429: LD_INT 30
41431: PUSH
41432: LD_INT 1
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PPUSH
41439: CALL 11553 0 2
41443: PUSH
41444: LD_INT 1
41446: ARRAY
41447: PPUSH
41448: CALL_OW 251
41452: PPUSH
41453: CALL_OW 111
// end ; end ;
41457: GO 41281
41459: POP
41460: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41461: LD_VAR 0 1
41465: PPUSH
41466: LD_INT 3
41468: PPUSH
41469: EMPTY
41470: PPUSH
41471: CALL 11636 0 3
41475: PUSH
41476: LD_EXP 60
41480: PUSH
41481: LD_VAR 0 1
41485: ARRAY
41486: AND
41487: PUSH
41488: LD_VAR 0 1
41492: PPUSH
41493: LD_INT 6
41495: PPUSH
41496: EMPTY
41497: PPUSH
41498: CALL 12256 0 3
41502: AND
41503: IFFALSE 42034
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41505: LD_ADDR_VAR 0 6
41509: PUSH
41510: LD_EXP 60
41514: PUSH
41515: LD_VAR 0 1
41519: ARRAY
41520: PPUSH
41521: LD_INT 0
41523: PPUSH
41524: CALL_OW 517
41528: PUSH
41529: LD_INT 1
41531: ARRAY
41532: PUSH
41533: LD_INT 1
41535: ARRAY
41536: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41537: LD_ADDR_VAR 0 7
41541: PUSH
41542: LD_EXP 60
41546: PUSH
41547: LD_VAR 0 1
41551: ARRAY
41552: PPUSH
41553: LD_INT 0
41555: PPUSH
41556: CALL_OW 517
41560: PUSH
41561: LD_INT 2
41563: ARRAY
41564: PUSH
41565: LD_INT 1
41567: ARRAY
41568: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41569: LD_VAR 0 1
41573: PPUSH
41574: LD_INT 6
41576: PPUSH
41577: EMPTY
41578: PPUSH
41579: CALL 12256 0 3
41583: IFFALSE 42032
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41585: LD_ADDR_VAR 0 8
41589: PUSH
41590: LD_VAR 0 1
41594: PPUSH
41595: LD_INT 6
41597: PPUSH
41598: EMPTY
41599: PPUSH
41600: CALL 12256 0 3
41604: PUSH
41605: FOR_IN
41606: IFFALSE 41637
// if GetLives ( k ) = 1000 then
41608: LD_VAR 0 8
41612: PPUSH
41613: CALL_OW 256
41617: PUSH
41618: LD_INT 1000
41620: EQUAL
41621: IFFALSE 41635
// SetTag ( k , 0 ) ;
41623: LD_VAR 0 8
41627: PPUSH
41628: LD_INT 0
41630: PPUSH
41631: CALL_OW 109
41635: GO 41605
41637: POP
41638: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41639: LD_VAR 0 1
41643: PPUSH
41644: LD_INT 0
41646: PPUSH
41647: LD_INT 25
41649: PUSH
41650: LD_INT 3
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PPUSH
41657: CALL 12256 0 3
41661: IFFALSE 41725
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41663: LD_ADDR_VAR 0 8
41667: PUSH
41668: LD_VAR 0 4
41672: PPUSH
41673: LD_INT 0
41675: PPUSH
41676: LD_INT 25
41678: PUSH
41679: LD_INT 3
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PPUSH
41686: CALL 12256 0 3
41690: PUSH
41691: FOR_IN
41692: IFFALSE 41723
// if GetTag ( k ) = 0 then
41694: LD_VAR 0 8
41698: PPUSH
41699: CALL_OW 110
41703: PUSH
41704: LD_INT 0
41706: EQUAL
41707: IFFALSE 41721
// begin SetTag ( k , 8 ) ;
41709: LD_VAR 0 8
41713: PPUSH
41714: LD_INT 8
41716: PPUSH
41717: CALL_OW 109
// end ;
41721: GO 41691
41723: POP
41724: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41725: LD_VAR 0 1
41729: PPUSH
41730: LD_INT 6
41732: PPUSH
41733: LD_INT 92
41735: PUSH
41736: LD_VAR 0 6
41740: PUSH
41741: LD_VAR 0 7
41745: PUSH
41746: LD_INT 10
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: PPUSH
41755: CALL 12256 0 3
41759: IFFALSE 41883
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41761: LD_ADDR_VAR 0 5
41765: PUSH
41766: LD_VAR 0 4
41770: PPUSH
41771: LD_INT 6
41773: PPUSH
41774: LD_INT 92
41776: PUSH
41777: LD_VAR 0 6
41781: PUSH
41782: LD_VAR 0 7
41786: PUSH
41787: LD_INT 10
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: PPUSH
41796: CALL 12256 0 3
41800: PUSH
41801: FOR_IN
41802: IFFALSE 41881
// begin if not HasTask ( j ) and GetDriver ( j ) then
41804: LD_VAR 0 5
41808: PPUSH
41809: CALL_OW 314
41813: NOT
41814: PUSH
41815: LD_VAR 0 5
41819: PPUSH
41820: CALL 31785 0 1
41824: AND
41825: IFFALSE 41879
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41827: LD_VAR 0 5
41831: PPUSH
41832: CALL 31785 0 1
41836: PPUSH
41837: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41841: LD_VAR 0 5
41845: PPUSH
41846: CALL 31785 0 1
41850: PPUSH
41851: LD_VAR 0 5
41855: PPUSH
41856: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41860: LD_VAR 0 5
41864: PPUSH
41865: CALL 31785 0 1
41869: PPUSH
41870: LD_VAR 0 5
41874: PPUSH
41875: CALL_OW 180
// end ; end ;
41879: GO 41801
41881: POP
41882: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41883: LD_VAR 0 1
41887: PPUSH
41888: LD_INT 6
41890: PPUSH
41891: LD_INT 92
41893: PUSH
41894: LD_VAR 0 6
41898: PUSH
41899: LD_VAR 0 7
41903: PUSH
41904: LD_INT 10
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: PPUSH
41913: CALL 12256 0 3
41917: PUSH
41918: LD_VAR 0 1
41922: PPUSH
41923: LD_INT 8
41925: PPUSH
41926: EMPTY
41927: PPUSH
41928: CALL 12256 0 3
41932: AND
41933: IFFALSE 42032
// for j in MCF_Tag ( side , 8 , [ ] ) do
41935: LD_ADDR_VAR 0 5
41939: PUSH
41940: LD_VAR 0 1
41944: PPUSH
41945: LD_INT 8
41947: PPUSH
41948: EMPTY
41949: PPUSH
41950: CALL 12256 0 3
41954: PUSH
41955: FOR_IN
41956: IFFALSE 42030
// begin if IsInUnit ( j ) then
41958: LD_VAR 0 5
41962: PPUSH
41963: CALL_OW 310
41967: IFFALSE 41980
// ComExitBuilding ( j ) else
41969: LD_VAR 0 5
41973: PPUSH
41974: CALL_OW 122
41978: GO 42028
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41980: LD_VAR 0 5
41984: PPUSH
41985: LD_VAR 0 1
41989: PPUSH
41990: LD_INT 6
41992: PPUSH
41993: LD_INT 92
41995: PUSH
41996: LD_VAR 0 6
42000: PUSH
42001: LD_VAR 0 7
42005: PUSH
42006: LD_INT 10
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: LIST
42013: LIST
42014: PPUSH
42015: CALL 12256 0 3
42019: PUSH
42020: LD_INT 1
42022: ARRAY
42023: PPUSH
42024: CALL_OW 129
// end ;
42028: GO 41955
42030: POP
42031: POP
// end ; end else
42032: GO 42089
// if MCF_Tag ( side , 8 , [ ] ) then
42034: LD_VAR 0 1
42038: PPUSH
42039: LD_INT 8
42041: PPUSH
42042: EMPTY
42043: PPUSH
42044: CALL 12256 0 3
42048: IFFALSE 42089
// for k in MCF_Tag ( side , 8 , [ ] ) do
42050: LD_ADDR_VAR 0 8
42054: PUSH
42055: LD_VAR 0 1
42059: PPUSH
42060: LD_INT 8
42062: PPUSH
42063: EMPTY
42064: PPUSH
42065: CALL 12256 0 3
42069: PUSH
42070: FOR_IN
42071: IFFALSE 42087
// SetTag ( k , 0 ) ;
42073: LD_VAR 0 8
42077: PPUSH
42078: LD_INT 0
42080: PPUSH
42081: CALL_OW 109
42085: GO 42070
42087: POP
42088: POP
// end ; end_of_file
42089: LD_VAR 0 3
42093: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
42094: LD_INT 0
42096: PPUSH
// MREG_Game := [ ] ;
42097: LD_ADDR_EXP 35
42101: PUSH
42102: EMPTY
42103: ST_TO_ADDR
// MREG_Crates := [ ] ;
42104: LD_ADDR_EXP 36
42108: PUSH
42109: EMPTY
42110: ST_TO_ADDR
// MREG_Heal := [ ] ;
42111: LD_ADDR_EXP 37
42115: PUSH
42116: EMPTY
42117: ST_TO_ADDR
// MREG_Tame := [ ] ;
42118: LD_ADDR_EXP 39
42122: PUSH
42123: EMPTY
42124: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
42125: LD_ADDR_EXP 40
42129: PUSH
42130: EMPTY
42131: ST_TO_ADDR
// MREG_SidesList := [ ] ;
42132: LD_ADDR_EXP 41
42136: PUSH
42137: EMPTY
42138: ST_TO_ADDR
// MREG_LabList := [ ] ;
42139: LD_ADDR_EXP 42
42143: PUSH
42144: EMPTY
42145: ST_TO_ADDR
// MREG_Cargo := [ ] ;
42146: LD_ADDR_EXP 43
42150: PUSH
42151: EMPTY
42152: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
42153: LD_ADDR_EXP 44
42157: PUSH
42158: EMPTY
42159: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
42160: LD_ADDR_EXP 45
42164: PUSH
42165: EMPTY
42166: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
42167: LD_ADDR_EXP 46
42171: PUSH
42172: EMPTY
42173: ST_TO_ADDR
// MREG_Status := [ ] ;
42174: LD_ADDR_EXP 47
42178: PUSH
42179: EMPTY
42180: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
42181: LD_ADDR_EXP 48
42185: PUSH
42186: EMPTY
42187: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
42188: LD_ADDR_EXP 49
42192: PUSH
42193: EMPTY
42194: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
42195: LD_ADDR_EXP 50
42199: PUSH
42200: EMPTY
42201: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
42202: LD_ADDR_EXP 51
42206: PUSH
42207: EMPTY
42208: ST_TO_ADDR
// MREG_ToRes := [ ] ;
42209: LD_ADDR_EXP 52
42213: PUSH
42214: EMPTY
42215: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
42216: LD_ADDR_EXP 53
42220: PUSH
42221: EMPTY
42222: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
42223: LD_ADDR_EXP 54
42227: PUSH
42228: EMPTY
42229: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
42230: LD_ADDR_EXP 55
42234: PUSH
42235: EMPTY
42236: ST_TO_ADDR
// MREG_ToLab := [ ] ;
42237: LD_ADDR_EXP 56
42241: PUSH
42242: EMPTY
42243: ST_TO_ADDR
// MREG_ToFac := [ ] ;
42244: LD_ADDR_EXP 57
42248: PUSH
42249: EMPTY
42250: ST_TO_ADDR
// MREG_ToArm := [ ] ;
42251: LD_ADDR_EXP 58
42255: PUSH
42256: EMPTY
42257: ST_TO_ADDR
// MREG_ToDep := [ ] ;
42258: LD_ADDR_EXP 59
42262: PUSH
42263: EMPTY
42264: ST_TO_ADDR
// MREG_Deposit := [ ] ;
42265: LD_ADDR_EXP 63
42269: PUSH
42270: EMPTY
42271: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
42272: LD_ADDR_EXP 64
42276: PUSH
42277: EMPTY
42278: ST_TO_ADDR
// MREG_Parking := [ ] ;
42279: LD_ADDR_EXP 60
42283: PUSH
42284: EMPTY
42285: ST_TO_ADDR
// MREG_VCombat := [ ] ;
42286: LD_ADDR_EXP 61
42290: PUSH
42291: EMPTY
42292: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
42293: LD_ADDR_EXP 65
42297: PUSH
42298: EMPTY
42299: ST_TO_ADDR
// MREG_DefArea := [ ] ;
42300: LD_ADDR_EXP 66
42304: PUSH
42305: EMPTY
42306: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
42307: LD_ADDR_EXP 67
42311: PUSH
42312: EMPTY
42313: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
42314: LD_ADDR_EXP 69
42318: PUSH
42319: EMPTY
42320: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
42321: LD_ADDR_EXP 70
42325: PUSH
42326: EMPTY
42327: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
42328: LD_ADDR_EXP 71
42332: PUSH
42333: EMPTY
42334: ST_TO_ADDR
// MREG_Attackers := [ ] ;
42335: LD_ADDR_EXP 73
42339: PUSH
42340: EMPTY
42341: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
42342: LD_ADDR_EXP 72
42346: PUSH
42347: EMPTY
42348: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
42349: LD_ADDR_EXP 74
42353: PUSH
42354: LD_INT 300
42356: PUSH
42357: LD_INT 100
42359: PUSH
42360: LD_INT 25
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: LIST
42367: ST_TO_ADDR
// end ;
42368: LD_VAR 0 1
42372: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
42373: LD_INT 0
42375: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42376: LD_VAR 0 2
42380: PUSH
42381: LD_VAR 0 3
42385: PUSH
42386: LD_VAR 0 4
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: LIST
42395: PUSH
42396: LD_VAR 0 1
42400: IN
42401: IFFALSE 42415
// result := mreg_list else
42403: LD_ADDR_VAR 0 5
42407: PUSH
42408: LD_VAR 0 1
42412: ST_TO_ADDR
42413: GO 42449
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42415: LD_ADDR_VAR 0 1
42419: PUSH
42420: LD_VAR 0 1
42424: PUSH
42425: LD_VAR 0 2
42429: PUSH
42430: LD_VAR 0 3
42434: PUSH
42435: LD_VAR 0 4
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: ADD
42448: ST_TO_ADDR
// result := mreg_list ;
42449: LD_ADDR_VAR 0 5
42453: PUSH
42454: LD_VAR 0 1
42458: ST_TO_ADDR
// end ;
42459: LD_VAR 0 5
42463: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42464: LD_INT 0
42466: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42467: LD_VAR 0 2
42471: PUSH
42472: LD_VAR 0 3
42476: PUSH
42477: LD_VAR 0 4
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: LIST
42486: PUSH
42487: LD_VAR 0 1
42491: IN
42492: IFFALSE 42530
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42494: LD_ADDR_VAR 0 5
42498: PUSH
42499: LD_VAR 0 1
42503: PUSH
42504: LD_VAR 0 2
42508: PUSH
42509: LD_VAR 0 3
42513: PUSH
42514: LD_VAR 0 4
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: LIST
42523: PUSH
42524: EMPTY
42525: LIST
42526: DIFF
42527: ST_TO_ADDR
42528: GO 42540
// result := mreg_list ;
42530: LD_ADDR_VAR 0 5
42534: PUSH
42535: LD_VAR 0 1
42539: ST_TO_ADDR
// end ;
42540: LD_VAR 0 5
42544: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42545: LD_INT 0
42547: PPUSH
42548: PPUSH
42549: PPUSH
// for j = 1 to 8 do
42550: LD_ADDR_VAR 0 3
42554: PUSH
42555: DOUBLE
42556: LD_INT 1
42558: DEC
42559: ST_TO_ADDR
42560: LD_INT 8
42562: PUSH
42563: FOR_TO
42564: IFFALSE 43405
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42566: LD_VAR 0 3
42570: PPUSH
42571: LD_INT 51
42573: PUSH
42574: EMPTY
42575: LIST
42576: PPUSH
42577: CALL 11553 0 2
42581: PUSH
42582: LD_OWVAR 2
42586: PUSH
42587: LD_VAR 0 3
42591: EQUAL
42592: NOT
42593: AND
42594: IFFALSE 42612
// MREG_SidesList := MREG_SidesList ^ 1 else
42596: LD_ADDR_EXP 41
42600: PUSH
42601: LD_EXP 41
42605: PUSH
42606: LD_INT 1
42608: ADD
42609: ST_TO_ADDR
42610: GO 42626
// MREG_SidesList := MREG_SidesList ^ 0 ;
42612: LD_ADDR_EXP 41
42616: PUSH
42617: LD_EXP 41
42621: PUSH
42622: LD_INT 0
42624: ADD
42625: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42626: LD_VAR 0 3
42630: PPUSH
42631: LD_INT 2
42633: PUSH
42634: LD_INT 34
42636: PUSH
42637: LD_INT 12
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 34
42646: PUSH
42647: LD_INT 32
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 34
42656: PUSH
42657: LD_INT 51
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: PUSH
42670: EMPTY
42671: LIST
42672: PPUSH
42673: CALL 11854 0 2
42677: IFFALSE 42778
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42679: LD_ADDR_VAR 0 2
42683: PUSH
42684: LD_VAR 0 3
42688: PPUSH
42689: LD_INT 2
42691: PUSH
42692: LD_INT 34
42694: PUSH
42695: LD_INT 12
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 34
42704: PUSH
42705: LD_INT 32
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 34
42714: PUSH
42715: LD_INT 51
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: LIST
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PPUSH
42731: CALL 11854 0 2
42735: PUSH
42736: FOR_IN
42737: IFFALSE 42776
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42739: LD_ADDR_EXP 43
42743: PUSH
42744: LD_EXP 43
42748: PPUSH
42749: LD_VAR 0 3
42753: PPUSH
42754: LD_VAR 0 2
42758: PPUSH
42759: LD_VAR 0 2
42763: PPUSH
42764: CALL_OW 264
42768: PPUSH
42769: CALL 42373 0 4
42773: ST_TO_ADDR
42774: GO 42736
42776: POP
42777: POP
// if MCF_Class ( j , 4 , [ ] ) then
42778: LD_VAR 0 3
42782: PPUSH
42783: LD_INT 4
42785: PPUSH
42786: EMPTY
42787: PPUSH
42788: CALL 11636 0 3
42792: IFFALSE 42825
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42794: LD_ADDR_EXP 56
42798: PUSH
42799: LD_EXP 56
42803: PUSH
42804: LD_VAR 0 3
42808: PPUSH
42809: LD_INT 4
42811: PPUSH
42812: EMPTY
42813: PPUSH
42814: CALL 11636 0 3
42818: PUSH
42819: EMPTY
42820: LIST
42821: ADD
42822: ST_TO_ADDR
42823: GO 42842
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42825: LD_ADDR_EXP 56
42829: PUSH
42830: LD_EXP 56
42834: PUSH
42835: LD_INT 0
42837: PUSH
42838: EMPTY
42839: LIST
42840: ADD
42841: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42842: LD_VAR 0 3
42846: PPUSH
42847: LD_INT 3
42849: PPUSH
42850: EMPTY
42851: PPUSH
42852: CALL 11636 0 3
42856: IFFALSE 42889
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42858: LD_ADDR_EXP 57
42862: PUSH
42863: LD_EXP 57
42867: PUSH
42868: LD_VAR 0 3
42872: PPUSH
42873: LD_INT 3
42875: PPUSH
42876: EMPTY
42877: PPUSH
42878: CALL 11636 0 3
42882: PUSH
42883: EMPTY
42884: LIST
42885: ADD
42886: ST_TO_ADDR
42887: GO 42906
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42889: LD_ADDR_EXP 57
42893: PUSH
42894: LD_EXP 57
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: EMPTY
42903: LIST
42904: ADD
42905: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42906: LD_VAR 0 3
42910: PPUSH
42911: LD_INT 1
42913: PPUSH
42914: EMPTY
42915: PPUSH
42916: CALL 11636 0 3
42920: IFFALSE 42953
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42922: LD_ADDR_EXP 58
42926: PUSH
42927: LD_EXP 58
42931: PUSH
42932: LD_VAR 0 3
42936: PPUSH
42937: LD_INT 1
42939: PPUSH
42940: EMPTY
42941: PPUSH
42942: CALL 11636 0 3
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
42951: GO 42970
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42953: LD_ADDR_EXP 58
42957: PUSH
42958: LD_EXP 58
42962: PUSH
42963: LD_INT 0
42965: PUSH
42966: EMPTY
42967: LIST
42968: ADD
42969: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42970: LD_VAR 0 3
42974: PPUSH
42975: LD_INT 2
42977: PPUSH
42978: EMPTY
42979: PPUSH
42980: CALL 11636 0 3
42984: IFFALSE 43017
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42986: LD_ADDR_EXP 59
42990: PUSH
42991: LD_EXP 59
42995: PUSH
42996: LD_VAR 0 3
43000: PPUSH
43001: LD_INT 2
43003: PPUSH
43004: EMPTY
43005: PPUSH
43006: CALL 11636 0 3
43010: PUSH
43011: EMPTY
43012: LIST
43013: ADD
43014: ST_TO_ADDR
43015: GO 43034
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
43017: LD_ADDR_EXP 59
43021: PUSH
43022: LD_EXP 59
43026: PUSH
43027: LD_INT 0
43029: PUSH
43030: EMPTY
43031: LIST
43032: ADD
43033: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
43034: LD_ADDR_EXP 49
43038: PUSH
43039: LD_EXP 49
43043: PUSH
43044: LD_INT 0
43046: PUSH
43047: EMPTY
43048: LIST
43049: ADD
43050: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
43051: LD_ADDR_EXP 37
43055: PUSH
43056: LD_EXP 37
43060: PUSH
43061: LD_INT 0
43063: PUSH
43064: EMPTY
43065: LIST
43066: ADD
43067: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
43068: LD_ADDR_EXP 39
43072: PUSH
43073: LD_EXP 39
43077: PUSH
43078: LD_INT 0
43080: PUSH
43081: EMPTY
43082: LIST
43083: ADD
43084: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
43085: LD_ADDR_EXP 60
43089: PUSH
43090: LD_EXP 60
43094: PUSH
43095: LD_INT 0
43097: PUSH
43098: EMPTY
43099: LIST
43100: ADD
43101: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
43102: LD_ADDR_EXP 61
43106: PUSH
43107: LD_EXP 61
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: ADD
43118: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
43119: LD_ADDR_EXP 53
43123: PUSH
43124: LD_EXP 53
43128: PUSH
43129: LD_INT 0
43131: PUSH
43132: EMPTY
43133: LIST
43134: ADD
43135: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
43136: LD_ADDR_EXP 40
43140: PUSH
43141: LD_EXP 40
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: LD_INT 0
43151: PUSH
43152: LD_INT 0
43154: PUSH
43155: LD_INT 0
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: PUSH
43164: EMPTY
43165: LIST
43166: ADD
43167: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
43168: LD_ADDR_EXP 62
43172: PUSH
43173: LD_EXP 62
43177: PUSH
43178: LD_INT 0
43180: PUSH
43181: EMPTY
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: EMPTY
43188: LIST
43189: ADD
43190: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
43191: LD_ADDR_EXP 63
43195: PUSH
43196: LD_EXP 63
43200: PUSH
43201: LD_INT 0
43203: PUSH
43204: EMPTY
43205: LIST
43206: PUSH
43207: EMPTY
43208: LIST
43209: ADD
43210: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
43211: LD_ADDR_EXP 44
43215: PUSH
43216: LD_EXP 44
43220: PUSH
43221: LD_INT 0
43223: PUSH
43224: EMPTY
43225: LIST
43226: ADD
43227: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
43228: LD_ADDR_EXP 65
43232: PUSH
43233: LD_EXP 65
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: EMPTY
43242: LIST
43243: ADD
43244: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
43245: LD_ADDR_EXP 66
43249: PUSH
43250: LD_EXP 66
43254: PUSH
43255: LD_INT 0
43257: PUSH
43258: EMPTY
43259: LIST
43260: ADD
43261: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
43262: LD_ADDR_EXP 67
43266: PUSH
43267: LD_EXP 67
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: ADD
43278: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
43279: LD_ADDR_EXP 68
43283: PUSH
43284: LD_EXP 68
43288: PUSH
43289: LD_INT 0
43291: PUSH
43292: EMPTY
43293: LIST
43294: ADD
43295: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
43296: LD_ADDR_EXP 69
43300: PUSH
43301: LD_EXP 69
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: EMPTY
43310: LIST
43311: ADD
43312: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
43313: LD_ADDR_EXP 70
43317: PUSH
43318: LD_EXP 70
43322: PUSH
43323: LD_INT 0
43325: PUSH
43326: EMPTY
43327: LIST
43328: ADD
43329: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
43330: LD_ADDR_EXP 71
43334: PUSH
43335: LD_EXP 71
43339: PUSH
43340: LD_INT 0
43342: PUSH
43343: EMPTY
43344: LIST
43345: ADD
43346: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
43347: LD_ADDR_EXP 73
43351: PUSH
43352: LD_EXP 73
43356: PUSH
43357: LD_INT 0
43359: PUSH
43360: EMPTY
43361: LIST
43362: ADD
43363: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
43364: LD_ADDR_EXP 72
43368: PUSH
43369: LD_EXP 72
43373: PUSH
43374: LD_INT 0
43376: ADD
43377: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
43378: LD_ADDR_EXP 64
43382: PUSH
43383: LD_EXP 64
43387: PUSH
43388: LD_INT 0
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: LD_INT 0
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: LIST
43401: ADD
43402: ST_TO_ADDR
// end ;
43403: GO 42563
43405: POP
43406: POP
// end ;
43407: LD_VAR 0 1
43411: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43412: LD_INT 0
43414: PPUSH
43415: PPUSH
43416: PPUSH
// m := false ;
43417: LD_ADDR_VAR 0 5
43421: PUSH
43422: LD_INT 0
43424: ST_TO_ADDR
// for i = 1 to mreg do
43425: LD_ADDR_VAR 0 4
43429: PUSH
43430: DOUBLE
43431: LD_INT 1
43433: DEC
43434: ST_TO_ADDR
43435: LD_VAR 0 2
43439: PUSH
43440: FOR_TO
43441: IFFALSE 43477
// if mreg [ i ] [ 1 ] = side then
43443: LD_VAR 0 2
43447: PUSH
43448: LD_VAR 0 4
43452: ARRAY
43453: PUSH
43454: LD_INT 1
43456: ARRAY
43457: PUSH
43458: LD_VAR 0 1
43462: EQUAL
43463: IFFALSE 43475
// begin m := true ;
43465: LD_ADDR_VAR 0 5
43469: PUSH
43470: LD_INT 1
43472: ST_TO_ADDR
// break ;
43473: GO 43477
// end ;
43475: GO 43440
43477: POP
43478: POP
// result := m ;
43479: LD_ADDR_VAR 0 3
43483: PUSH
43484: LD_VAR 0 5
43488: ST_TO_ADDR
// end ;
43489: LD_VAR 0 3
43493: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43494: LD_INT 0
43496: PPUSH
43497: PPUSH
43498: PPUSH
// m := 0 ;
43499: LD_ADDR_VAR 0 5
43503: PUSH
43504: LD_INT 0
43506: ST_TO_ADDR
// for i = 1 to mreg do
43507: LD_ADDR_VAR 0 4
43511: PUSH
43512: DOUBLE
43513: LD_INT 1
43515: DEC
43516: ST_TO_ADDR
43517: LD_VAR 0 2
43521: PUSH
43522: FOR_TO
43523: IFFALSE 43563
// if mreg [ i ] [ 1 ] = side then
43525: LD_VAR 0 2
43529: PUSH
43530: LD_VAR 0 4
43534: ARRAY
43535: PUSH
43536: LD_INT 1
43538: ARRAY
43539: PUSH
43540: LD_VAR 0 1
43544: EQUAL
43545: IFFALSE 43561
// begin m := m + 1 ;
43547: LD_ADDR_VAR 0 5
43551: PUSH
43552: LD_VAR 0 5
43556: PUSH
43557: LD_INT 1
43559: PLUS
43560: ST_TO_ADDR
// end ;
43561: GO 43522
43563: POP
43564: POP
// result := m ;
43565: LD_ADDR_VAR 0 3
43569: PUSH
43570: LD_VAR 0 5
43574: ST_TO_ADDR
// end ;
43575: LD_VAR 0 3
43579: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43580: LD_INT 0
43582: PPUSH
43583: PPUSH
// result := 0 ;
43584: LD_ADDR_VAR 0 3
43588: PUSH
43589: LD_INT 0
43591: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43592: LD_ADDR_VAR 0 4
43596: PUSH
43597: DOUBLE
43598: LD_INT 1
43600: DEC
43601: ST_TO_ADDR
43602: LD_EXP 55
43606: PUSH
43607: FOR_TO
43608: IFFALSE 43670
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43610: LD_EXP 55
43614: PUSH
43615: LD_VAR 0 4
43619: ARRAY
43620: PUSH
43621: LD_INT 1
43623: ARRAY
43624: PUSH
43625: LD_VAR 0 1
43629: EQUAL
43630: PUSH
43631: LD_EXP 55
43635: PUSH
43636: LD_VAR 0 4
43640: ARRAY
43641: PUSH
43642: LD_INT 2
43644: ARRAY
43645: PUSH
43646: LD_VAR 0 2
43650: EQUAL
43651: AND
43652: IFFALSE 43668
// begin result := result + 1 ;
43654: LD_ADDR_VAR 0 3
43658: PUSH
43659: LD_VAR 0 3
43663: PUSH
43664: LD_INT 1
43666: PLUS
43667: ST_TO_ADDR
// end ;
43668: GO 43607
43670: POP
43671: POP
// end ; end_of_file
43672: LD_VAR 0 3
43676: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
43677: GO 43679
43679: DISABLE
// begin ru_radar := 98 ;
43680: LD_ADDR_EXP 75
43684: PUSH
43685: LD_INT 98
43687: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43688: LD_ADDR_EXP 76
43692: PUSH
43693: LD_INT 89
43695: ST_TO_ADDR
// us_hack := 99 ;
43696: LD_ADDR_EXP 77
43700: PUSH
43701: LD_INT 99
43703: ST_TO_ADDR
// us_artillery := 97 ;
43704: LD_ADDR_EXP 78
43708: PUSH
43709: LD_INT 97
43711: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43712: LD_ADDR_EXP 79
43716: PUSH
43717: LD_INT 91
43719: ST_TO_ADDR
// tech_Artillery := 80 ;
43720: LD_ADDR_EXP 80
43724: PUSH
43725: LD_INT 80
43727: ST_TO_ADDR
// tech_RadMat := 81 ;
43728: LD_ADDR_EXP 81
43732: PUSH
43733: LD_INT 81
43735: ST_TO_ADDR
// tech_BasicTools := 82 ;
43736: LD_ADDR_EXP 82
43740: PUSH
43741: LD_INT 82
43743: ST_TO_ADDR
// tech_Cargo := 83 ;
43744: LD_ADDR_EXP 83
43748: PUSH
43749: LD_INT 83
43751: ST_TO_ADDR
// tech_Track := 84 ;
43752: LD_ADDR_EXP 84
43756: PUSH
43757: LD_INT 84
43759: ST_TO_ADDR
// tech_Crane := 85 ;
43760: LD_ADDR_EXP 85
43764: PUSH
43765: LD_INT 85
43767: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43768: LD_ADDR_EXP 86
43772: PUSH
43773: LD_INT 86
43775: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43776: LD_ADDR_EXP 87
43780: PUSH
43781: LD_INT 87
43783: ST_TO_ADDR
// end ; end_of_file end_of_file
43784: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
43785: GO 43787
43787: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
43788: LD_STRING initStreamRollete();
43790: PPUSH
43791: CALL_OW 559
// InitStreamMode ;
43795: CALL 43804 0 0
// DefineStreamItems ( ) ;
43799: CALL 44244 0 0
// end ;
43803: END
// function InitStreamMode ; begin
43804: LD_INT 0
43806: PPUSH
// streamModeActive := false ;
43807: LD_ADDR_EXP 88
43811: PUSH
43812: LD_INT 0
43814: ST_TO_ADDR
// normalCounter := 36 ;
43815: LD_ADDR_EXP 89
43819: PUSH
43820: LD_INT 36
43822: ST_TO_ADDR
// hardcoreCounter := 16 ;
43823: LD_ADDR_EXP 90
43827: PUSH
43828: LD_INT 16
43830: ST_TO_ADDR
// sRocket := false ;
43831: LD_ADDR_EXP 93
43835: PUSH
43836: LD_INT 0
43838: ST_TO_ADDR
// sSpeed := false ;
43839: LD_ADDR_EXP 92
43843: PUSH
43844: LD_INT 0
43846: ST_TO_ADDR
// sEngine := false ;
43847: LD_ADDR_EXP 94
43851: PUSH
43852: LD_INT 0
43854: ST_TO_ADDR
// sSpec := false ;
43855: LD_ADDR_EXP 91
43859: PUSH
43860: LD_INT 0
43862: ST_TO_ADDR
// sLevel := false ;
43863: LD_ADDR_EXP 95
43867: PUSH
43868: LD_INT 0
43870: ST_TO_ADDR
// sArmoury := false ;
43871: LD_ADDR_EXP 96
43875: PUSH
43876: LD_INT 0
43878: ST_TO_ADDR
// sRadar := false ;
43879: LD_ADDR_EXP 97
43883: PUSH
43884: LD_INT 0
43886: ST_TO_ADDR
// sBunker := false ;
43887: LD_ADDR_EXP 98
43891: PUSH
43892: LD_INT 0
43894: ST_TO_ADDR
// sHack := false ;
43895: LD_ADDR_EXP 99
43899: PUSH
43900: LD_INT 0
43902: ST_TO_ADDR
// sFire := false ;
43903: LD_ADDR_EXP 100
43907: PUSH
43908: LD_INT 0
43910: ST_TO_ADDR
// sRefresh := false ;
43911: LD_ADDR_EXP 101
43915: PUSH
43916: LD_INT 0
43918: ST_TO_ADDR
// sExp := false ;
43919: LD_ADDR_EXP 102
43923: PUSH
43924: LD_INT 0
43926: ST_TO_ADDR
// sDepot := false ;
43927: LD_ADDR_EXP 103
43931: PUSH
43932: LD_INT 0
43934: ST_TO_ADDR
// sFlag := false ;
43935: LD_ADDR_EXP 104
43939: PUSH
43940: LD_INT 0
43942: ST_TO_ADDR
// sKamikadze := false ;
43943: LD_ADDR_EXP 112
43947: PUSH
43948: LD_INT 0
43950: ST_TO_ADDR
// sTroll := false ;
43951: LD_ADDR_EXP 113
43955: PUSH
43956: LD_INT 0
43958: ST_TO_ADDR
// sSlow := false ;
43959: LD_ADDR_EXP 114
43963: PUSH
43964: LD_INT 0
43966: ST_TO_ADDR
// sLack := false ;
43967: LD_ADDR_EXP 115
43971: PUSH
43972: LD_INT 0
43974: ST_TO_ADDR
// sTank := false ;
43975: LD_ADDR_EXP 117
43979: PUSH
43980: LD_INT 0
43982: ST_TO_ADDR
// sRemote := false ;
43983: LD_ADDR_EXP 118
43987: PUSH
43988: LD_INT 0
43990: ST_TO_ADDR
// sPowell := false ;
43991: LD_ADDR_EXP 119
43995: PUSH
43996: LD_INT 0
43998: ST_TO_ADDR
// sTeleport := false ;
43999: LD_ADDR_EXP 122
44003: PUSH
44004: LD_INT 0
44006: ST_TO_ADDR
// sOilTower := false ;
44007: LD_ADDR_EXP 124
44011: PUSH
44012: LD_INT 0
44014: ST_TO_ADDR
// sShovel := false ;
44015: LD_ADDR_EXP 125
44019: PUSH
44020: LD_INT 0
44022: ST_TO_ADDR
// sSheik := false ;
44023: LD_ADDR_EXP 126
44027: PUSH
44028: LD_INT 0
44030: ST_TO_ADDR
// sEarthquake := false ;
44031: LD_ADDR_EXP 128
44035: PUSH
44036: LD_INT 0
44038: ST_TO_ADDR
// sAI := false ;
44039: LD_ADDR_EXP 129
44043: PUSH
44044: LD_INT 0
44046: ST_TO_ADDR
// sCargo := false ;
44047: LD_ADDR_EXP 132
44051: PUSH
44052: LD_INT 0
44054: ST_TO_ADDR
// sDLaser := false ;
44055: LD_ADDR_EXP 133
44059: PUSH
44060: LD_INT 0
44062: ST_TO_ADDR
// sExchange := false ;
44063: LD_ADDR_EXP 134
44067: PUSH
44068: LD_INT 0
44070: ST_TO_ADDR
// sFac := false ;
44071: LD_ADDR_EXP 135
44075: PUSH
44076: LD_INT 0
44078: ST_TO_ADDR
// sPower := false ;
44079: LD_ADDR_EXP 136
44083: PUSH
44084: LD_INT 0
44086: ST_TO_ADDR
// sRandom := false ;
44087: LD_ADDR_EXP 137
44091: PUSH
44092: LD_INT 0
44094: ST_TO_ADDR
// sShield := false ;
44095: LD_ADDR_EXP 138
44099: PUSH
44100: LD_INT 0
44102: ST_TO_ADDR
// sTime := false ;
44103: LD_ADDR_EXP 139
44107: PUSH
44108: LD_INT 0
44110: ST_TO_ADDR
// sTools := false ;
44111: LD_ADDR_EXP 140
44115: PUSH
44116: LD_INT 0
44118: ST_TO_ADDR
// sSold := false ;
44119: LD_ADDR_EXP 105
44123: PUSH
44124: LD_INT 0
44126: ST_TO_ADDR
// sDiff := false ;
44127: LD_ADDR_EXP 106
44131: PUSH
44132: LD_INT 0
44134: ST_TO_ADDR
// sFog := false ;
44135: LD_ADDR_EXP 109
44139: PUSH
44140: LD_INT 0
44142: ST_TO_ADDR
// sReset := false ;
44143: LD_ADDR_EXP 110
44147: PUSH
44148: LD_INT 0
44150: ST_TO_ADDR
// sSun := false ;
44151: LD_ADDR_EXP 111
44155: PUSH
44156: LD_INT 0
44158: ST_TO_ADDR
// sTiger := false ;
44159: LD_ADDR_EXP 107
44163: PUSH
44164: LD_INT 0
44166: ST_TO_ADDR
// sBomb := false ;
44167: LD_ADDR_EXP 108
44171: PUSH
44172: LD_INT 0
44174: ST_TO_ADDR
// sWound := false ;
44175: LD_ADDR_EXP 116
44179: PUSH
44180: LD_INT 0
44182: ST_TO_ADDR
// sBetray := false ;
44183: LD_ADDR_EXP 120
44187: PUSH
44188: LD_INT 0
44190: ST_TO_ADDR
// sContamin := false ;
44191: LD_ADDR_EXP 121
44195: PUSH
44196: LD_INT 0
44198: ST_TO_ADDR
// sOil := false ;
44199: LD_ADDR_EXP 123
44203: PUSH
44204: LD_INT 0
44206: ST_TO_ADDR
// sStu := false ;
44207: LD_ADDR_EXP 127
44211: PUSH
44212: LD_INT 0
44214: ST_TO_ADDR
// sBazooka := false ;
44215: LD_ADDR_EXP 130
44219: PUSH
44220: LD_INT 0
44222: ST_TO_ADDR
// sMortar := false ;
44223: LD_ADDR_EXP 131
44227: PUSH
44228: LD_INT 0
44230: ST_TO_ADDR
// sRanger := false ;
44231: LD_ADDR_EXP 141
44235: PUSH
44236: LD_INT 0
44238: ST_TO_ADDR
// end ;
44239: LD_VAR 0 1
44243: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44244: LD_INT 0
44246: PPUSH
44247: PPUSH
44248: PPUSH
44249: PPUSH
44250: PPUSH
// result := [ ] ;
44251: LD_ADDR_VAR 0 1
44255: PUSH
44256: EMPTY
44257: ST_TO_ADDR
// if campaign_id = 1 then
44258: LD_OWVAR 69
44262: PUSH
44263: LD_INT 1
44265: EQUAL
44266: IFFALSE 47204
// begin case mission_number of 1 :
44268: LD_OWVAR 70
44272: PUSH
44273: LD_INT 1
44275: DOUBLE
44276: EQUAL
44277: IFTRUE 44281
44279: GO 44345
44281: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44282: LD_ADDR_VAR 0 1
44286: PUSH
44287: LD_INT 2
44289: PUSH
44290: LD_INT 4
44292: PUSH
44293: LD_INT 11
44295: PUSH
44296: LD_INT 12
44298: PUSH
44299: LD_INT 15
44301: PUSH
44302: LD_INT 16
44304: PUSH
44305: LD_INT 22
44307: PUSH
44308: LD_INT 23
44310: PUSH
44311: LD_INT 26
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: LIST
44318: LIST
44319: LIST
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 101
44327: PUSH
44328: LD_INT 102
44330: PUSH
44331: LD_INT 106
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: LIST
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: ST_TO_ADDR
44343: GO 47202
44345: LD_INT 2
44347: DOUBLE
44348: EQUAL
44349: IFTRUE 44353
44351: GO 44425
44353: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44354: LD_ADDR_VAR 0 1
44358: PUSH
44359: LD_INT 2
44361: PUSH
44362: LD_INT 4
44364: PUSH
44365: LD_INT 11
44367: PUSH
44368: LD_INT 12
44370: PUSH
44371: LD_INT 15
44373: PUSH
44374: LD_INT 16
44376: PUSH
44377: LD_INT 22
44379: PUSH
44380: LD_INT 23
44382: PUSH
44383: LD_INT 26
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: PUSH
44397: LD_INT 101
44399: PUSH
44400: LD_INT 102
44402: PUSH
44403: LD_INT 105
44405: PUSH
44406: LD_INT 106
44408: PUSH
44409: LD_INT 108
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: ST_TO_ADDR
44423: GO 47202
44425: LD_INT 3
44427: DOUBLE
44428: EQUAL
44429: IFTRUE 44433
44431: GO 44509
44433: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
44434: LD_ADDR_VAR 0 1
44438: PUSH
44439: LD_INT 2
44441: PUSH
44442: LD_INT 4
44444: PUSH
44445: LD_INT 5
44447: PUSH
44448: LD_INT 11
44450: PUSH
44451: LD_INT 12
44453: PUSH
44454: LD_INT 15
44456: PUSH
44457: LD_INT 16
44459: PUSH
44460: LD_INT 22
44462: PUSH
44463: LD_INT 26
44465: PUSH
44466: LD_INT 36
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: LIST
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 101
44483: PUSH
44484: LD_INT 102
44486: PUSH
44487: LD_INT 105
44489: PUSH
44490: LD_INT 106
44492: PUSH
44493: LD_INT 108
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: ST_TO_ADDR
44507: GO 47202
44509: LD_INT 4
44511: DOUBLE
44512: EQUAL
44513: IFTRUE 44517
44515: GO 44601
44517: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
44518: LD_ADDR_VAR 0 1
44522: PUSH
44523: LD_INT 2
44525: PUSH
44526: LD_INT 4
44528: PUSH
44529: LD_INT 5
44531: PUSH
44532: LD_INT 8
44534: PUSH
44535: LD_INT 11
44537: PUSH
44538: LD_INT 12
44540: PUSH
44541: LD_INT 15
44543: PUSH
44544: LD_INT 16
44546: PUSH
44547: LD_INT 22
44549: PUSH
44550: LD_INT 23
44552: PUSH
44553: LD_INT 26
44555: PUSH
44556: LD_INT 36
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 101
44575: PUSH
44576: LD_INT 102
44578: PUSH
44579: LD_INT 105
44581: PUSH
44582: LD_INT 106
44584: PUSH
44585: LD_INT 108
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: ST_TO_ADDR
44599: GO 47202
44601: LD_INT 5
44603: DOUBLE
44604: EQUAL
44605: IFTRUE 44609
44607: GO 44709
44609: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
44610: LD_ADDR_VAR 0 1
44614: PUSH
44615: LD_INT 2
44617: PUSH
44618: LD_INT 4
44620: PUSH
44621: LD_INT 5
44623: PUSH
44624: LD_INT 6
44626: PUSH
44627: LD_INT 8
44629: PUSH
44630: LD_INT 11
44632: PUSH
44633: LD_INT 12
44635: PUSH
44636: LD_INT 15
44638: PUSH
44639: LD_INT 16
44641: PUSH
44642: LD_INT 22
44644: PUSH
44645: LD_INT 23
44647: PUSH
44648: LD_INT 25
44650: PUSH
44651: LD_INT 26
44653: PUSH
44654: LD_INT 36
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 101
44675: PUSH
44676: LD_INT 102
44678: PUSH
44679: LD_INT 105
44681: PUSH
44682: LD_INT 106
44684: PUSH
44685: LD_INT 108
44687: PUSH
44688: LD_INT 109
44690: PUSH
44691: LD_INT 112
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: LIST
44701: LIST
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: ST_TO_ADDR
44707: GO 47202
44709: LD_INT 6
44711: DOUBLE
44712: EQUAL
44713: IFTRUE 44717
44715: GO 44837
44717: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
44718: LD_ADDR_VAR 0 1
44722: PUSH
44723: LD_INT 2
44725: PUSH
44726: LD_INT 4
44728: PUSH
44729: LD_INT 5
44731: PUSH
44732: LD_INT 6
44734: PUSH
44735: LD_INT 8
44737: PUSH
44738: LD_INT 11
44740: PUSH
44741: LD_INT 12
44743: PUSH
44744: LD_INT 15
44746: PUSH
44747: LD_INT 16
44749: PUSH
44750: LD_INT 20
44752: PUSH
44753: LD_INT 21
44755: PUSH
44756: LD_INT 22
44758: PUSH
44759: LD_INT 23
44761: PUSH
44762: LD_INT 25
44764: PUSH
44765: LD_INT 26
44767: PUSH
44768: LD_INT 30
44770: PUSH
44771: LD_INT 31
44773: PUSH
44774: LD_INT 32
44776: PUSH
44777: LD_INT 36
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 101
44803: PUSH
44804: LD_INT 102
44806: PUSH
44807: LD_INT 105
44809: PUSH
44810: LD_INT 106
44812: PUSH
44813: LD_INT 108
44815: PUSH
44816: LD_INT 109
44818: PUSH
44819: LD_INT 112
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: ST_TO_ADDR
44835: GO 47202
44837: LD_INT 7
44839: DOUBLE
44840: EQUAL
44841: IFTRUE 44845
44843: GO 44945
44845: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
44846: LD_ADDR_VAR 0 1
44850: PUSH
44851: LD_INT 2
44853: PUSH
44854: LD_INT 4
44856: PUSH
44857: LD_INT 5
44859: PUSH
44860: LD_INT 7
44862: PUSH
44863: LD_INT 11
44865: PUSH
44866: LD_INT 12
44868: PUSH
44869: LD_INT 15
44871: PUSH
44872: LD_INT 16
44874: PUSH
44875: LD_INT 20
44877: PUSH
44878: LD_INT 21
44880: PUSH
44881: LD_INT 22
44883: PUSH
44884: LD_INT 23
44886: PUSH
44887: LD_INT 25
44889: PUSH
44890: LD_INT 26
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 101
44911: PUSH
44912: LD_INT 102
44914: PUSH
44915: LD_INT 103
44917: PUSH
44918: LD_INT 105
44920: PUSH
44921: LD_INT 106
44923: PUSH
44924: LD_INT 108
44926: PUSH
44927: LD_INT 112
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: ST_TO_ADDR
44943: GO 47202
44945: LD_INT 8
44947: DOUBLE
44948: EQUAL
44949: IFTRUE 44953
44951: GO 45081
44953: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
44954: LD_ADDR_VAR 0 1
44958: PUSH
44959: LD_INT 2
44961: PUSH
44962: LD_INT 4
44964: PUSH
44965: LD_INT 5
44967: PUSH
44968: LD_INT 6
44970: PUSH
44971: LD_INT 7
44973: PUSH
44974: LD_INT 8
44976: PUSH
44977: LD_INT 11
44979: PUSH
44980: LD_INT 12
44982: PUSH
44983: LD_INT 15
44985: PUSH
44986: LD_INT 16
44988: PUSH
44989: LD_INT 20
44991: PUSH
44992: LD_INT 21
44994: PUSH
44995: LD_INT 22
44997: PUSH
44998: LD_INT 23
45000: PUSH
45001: LD_INT 25
45003: PUSH
45004: LD_INT 26
45006: PUSH
45007: LD_INT 30
45009: PUSH
45010: LD_INT 31
45012: PUSH
45013: LD_INT 32
45015: PUSH
45016: LD_INT 36
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: LIST
45023: LIST
45024: LIST
45025: LIST
45026: LIST
45027: LIST
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: LIST
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 101
45043: PUSH
45044: LD_INT 102
45046: PUSH
45047: LD_INT 103
45049: PUSH
45050: LD_INT 105
45052: PUSH
45053: LD_INT 106
45055: PUSH
45056: LD_INT 108
45058: PUSH
45059: LD_INT 109
45061: PUSH
45062: LD_INT 112
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: ST_TO_ADDR
45079: GO 47202
45081: LD_INT 9
45083: DOUBLE
45084: EQUAL
45085: IFTRUE 45089
45087: GO 45225
45089: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45090: LD_ADDR_VAR 0 1
45094: PUSH
45095: LD_INT 2
45097: PUSH
45098: LD_INT 4
45100: PUSH
45101: LD_INT 5
45103: PUSH
45104: LD_INT 6
45106: PUSH
45107: LD_INT 7
45109: PUSH
45110: LD_INT 8
45112: PUSH
45113: LD_INT 11
45115: PUSH
45116: LD_INT 12
45118: PUSH
45119: LD_INT 15
45121: PUSH
45122: LD_INT 16
45124: PUSH
45125: LD_INT 20
45127: PUSH
45128: LD_INT 21
45130: PUSH
45131: LD_INT 22
45133: PUSH
45134: LD_INT 23
45136: PUSH
45137: LD_INT 25
45139: PUSH
45140: LD_INT 26
45142: PUSH
45143: LD_INT 28
45145: PUSH
45146: LD_INT 30
45148: PUSH
45149: LD_INT 31
45151: PUSH
45152: LD_INT 32
45154: PUSH
45155: LD_INT 36
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: PUSH
45181: LD_INT 101
45183: PUSH
45184: LD_INT 102
45186: PUSH
45187: LD_INT 103
45189: PUSH
45190: LD_INT 105
45192: PUSH
45193: LD_INT 106
45195: PUSH
45196: LD_INT 108
45198: PUSH
45199: LD_INT 109
45201: PUSH
45202: LD_INT 112
45204: PUSH
45205: LD_INT 114
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: ST_TO_ADDR
45223: GO 47202
45225: LD_INT 10
45227: DOUBLE
45228: EQUAL
45229: IFTRUE 45233
45231: GO 45417
45233: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45234: LD_ADDR_VAR 0 1
45238: PUSH
45239: LD_INT 2
45241: PUSH
45242: LD_INT 4
45244: PUSH
45245: LD_INT 5
45247: PUSH
45248: LD_INT 6
45250: PUSH
45251: LD_INT 7
45253: PUSH
45254: LD_INT 8
45256: PUSH
45257: LD_INT 9
45259: PUSH
45260: LD_INT 10
45262: PUSH
45263: LD_INT 11
45265: PUSH
45266: LD_INT 12
45268: PUSH
45269: LD_INT 13
45271: PUSH
45272: LD_INT 14
45274: PUSH
45275: LD_INT 15
45277: PUSH
45278: LD_INT 16
45280: PUSH
45281: LD_INT 17
45283: PUSH
45284: LD_INT 18
45286: PUSH
45287: LD_INT 19
45289: PUSH
45290: LD_INT 20
45292: PUSH
45293: LD_INT 21
45295: PUSH
45296: LD_INT 22
45298: PUSH
45299: LD_INT 23
45301: PUSH
45302: LD_INT 24
45304: PUSH
45305: LD_INT 25
45307: PUSH
45308: LD_INT 26
45310: PUSH
45311: LD_INT 28
45313: PUSH
45314: LD_INT 30
45316: PUSH
45317: LD_INT 31
45319: PUSH
45320: LD_INT 32
45322: PUSH
45323: LD_INT 36
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 101
45359: PUSH
45360: LD_INT 102
45362: PUSH
45363: LD_INT 103
45365: PUSH
45366: LD_INT 104
45368: PUSH
45369: LD_INT 105
45371: PUSH
45372: LD_INT 106
45374: PUSH
45375: LD_INT 107
45377: PUSH
45378: LD_INT 108
45380: PUSH
45381: LD_INT 109
45383: PUSH
45384: LD_INT 110
45386: PUSH
45387: LD_INT 111
45389: PUSH
45390: LD_INT 112
45392: PUSH
45393: LD_INT 114
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: ST_TO_ADDR
45415: GO 47202
45417: LD_INT 11
45419: DOUBLE
45420: EQUAL
45421: IFTRUE 45425
45423: GO 45617
45425: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
45426: LD_ADDR_VAR 0 1
45430: PUSH
45431: LD_INT 2
45433: PUSH
45434: LD_INT 3
45436: PUSH
45437: LD_INT 4
45439: PUSH
45440: LD_INT 5
45442: PUSH
45443: LD_INT 6
45445: PUSH
45446: LD_INT 7
45448: PUSH
45449: LD_INT 8
45451: PUSH
45452: LD_INT 9
45454: PUSH
45455: LD_INT 10
45457: PUSH
45458: LD_INT 11
45460: PUSH
45461: LD_INT 12
45463: PUSH
45464: LD_INT 13
45466: PUSH
45467: LD_INT 14
45469: PUSH
45470: LD_INT 15
45472: PUSH
45473: LD_INT 16
45475: PUSH
45476: LD_INT 17
45478: PUSH
45479: LD_INT 18
45481: PUSH
45482: LD_INT 19
45484: PUSH
45485: LD_INT 20
45487: PUSH
45488: LD_INT 21
45490: PUSH
45491: LD_INT 22
45493: PUSH
45494: LD_INT 23
45496: PUSH
45497: LD_INT 24
45499: PUSH
45500: LD_INT 25
45502: PUSH
45503: LD_INT 26
45505: PUSH
45506: LD_INT 28
45508: PUSH
45509: LD_INT 30
45511: PUSH
45512: LD_INT 31
45514: PUSH
45515: LD_INT 32
45517: PUSH
45518: LD_INT 34
45520: PUSH
45521: LD_INT 36
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: PUSH
45557: LD_INT 101
45559: PUSH
45560: LD_INT 102
45562: PUSH
45563: LD_INT 103
45565: PUSH
45566: LD_INT 104
45568: PUSH
45569: LD_INT 105
45571: PUSH
45572: LD_INT 106
45574: PUSH
45575: LD_INT 107
45577: PUSH
45578: LD_INT 108
45580: PUSH
45581: LD_INT 109
45583: PUSH
45584: LD_INT 110
45586: PUSH
45587: LD_INT 111
45589: PUSH
45590: LD_INT 112
45592: PUSH
45593: LD_INT 114
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: LIST
45601: LIST
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: PUSH
45611: EMPTY
45612: LIST
45613: LIST
45614: ST_TO_ADDR
45615: GO 47202
45617: LD_INT 12
45619: DOUBLE
45620: EQUAL
45621: IFTRUE 45625
45623: GO 45833
45625: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
45626: LD_ADDR_VAR 0 1
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: LD_INT 2
45636: PUSH
45637: LD_INT 3
45639: PUSH
45640: LD_INT 4
45642: PUSH
45643: LD_INT 5
45645: PUSH
45646: LD_INT 6
45648: PUSH
45649: LD_INT 7
45651: PUSH
45652: LD_INT 8
45654: PUSH
45655: LD_INT 9
45657: PUSH
45658: LD_INT 10
45660: PUSH
45661: LD_INT 11
45663: PUSH
45664: LD_INT 12
45666: PUSH
45667: LD_INT 13
45669: PUSH
45670: LD_INT 14
45672: PUSH
45673: LD_INT 15
45675: PUSH
45676: LD_INT 16
45678: PUSH
45679: LD_INT 17
45681: PUSH
45682: LD_INT 18
45684: PUSH
45685: LD_INT 19
45687: PUSH
45688: LD_INT 20
45690: PUSH
45691: LD_INT 21
45693: PUSH
45694: LD_INT 22
45696: PUSH
45697: LD_INT 23
45699: PUSH
45700: LD_INT 24
45702: PUSH
45703: LD_INT 25
45705: PUSH
45706: LD_INT 26
45708: PUSH
45709: LD_INT 27
45711: PUSH
45712: LD_INT 28
45714: PUSH
45715: LD_INT 30
45717: PUSH
45718: LD_INT 31
45720: PUSH
45721: LD_INT 32
45723: PUSH
45724: LD_INT 33
45726: PUSH
45727: LD_INT 34
45729: PUSH
45730: LD_INT 36
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 101
45771: PUSH
45772: LD_INT 102
45774: PUSH
45775: LD_INT 103
45777: PUSH
45778: LD_INT 104
45780: PUSH
45781: LD_INT 105
45783: PUSH
45784: LD_INT 106
45786: PUSH
45787: LD_INT 107
45789: PUSH
45790: LD_INT 108
45792: PUSH
45793: LD_INT 109
45795: PUSH
45796: LD_INT 110
45798: PUSH
45799: LD_INT 111
45801: PUSH
45802: LD_INT 112
45804: PUSH
45805: LD_INT 113
45807: PUSH
45808: LD_INT 114
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: ST_TO_ADDR
45831: GO 47202
45833: LD_INT 13
45835: DOUBLE
45836: EQUAL
45837: IFTRUE 45841
45839: GO 46037
45841: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
45842: LD_ADDR_VAR 0 1
45846: PUSH
45847: LD_INT 1
45849: PUSH
45850: LD_INT 2
45852: PUSH
45853: LD_INT 3
45855: PUSH
45856: LD_INT 4
45858: PUSH
45859: LD_INT 5
45861: PUSH
45862: LD_INT 8
45864: PUSH
45865: LD_INT 9
45867: PUSH
45868: LD_INT 10
45870: PUSH
45871: LD_INT 11
45873: PUSH
45874: LD_INT 12
45876: PUSH
45877: LD_INT 14
45879: PUSH
45880: LD_INT 15
45882: PUSH
45883: LD_INT 16
45885: PUSH
45886: LD_INT 17
45888: PUSH
45889: LD_INT 18
45891: PUSH
45892: LD_INT 19
45894: PUSH
45895: LD_INT 20
45897: PUSH
45898: LD_INT 21
45900: PUSH
45901: LD_INT 22
45903: PUSH
45904: LD_INT 23
45906: PUSH
45907: LD_INT 24
45909: PUSH
45910: LD_INT 25
45912: PUSH
45913: LD_INT 26
45915: PUSH
45916: LD_INT 27
45918: PUSH
45919: LD_INT 28
45921: PUSH
45922: LD_INT 30
45924: PUSH
45925: LD_INT 31
45927: PUSH
45928: LD_INT 32
45930: PUSH
45931: LD_INT 33
45933: PUSH
45934: LD_INT 34
45936: PUSH
45937: LD_INT 36
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: LIST
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: PUSH
45973: LD_INT 101
45975: PUSH
45976: LD_INT 102
45978: PUSH
45979: LD_INT 103
45981: PUSH
45982: LD_INT 104
45984: PUSH
45985: LD_INT 105
45987: PUSH
45988: LD_INT 106
45990: PUSH
45991: LD_INT 107
45993: PUSH
45994: LD_INT 108
45996: PUSH
45997: LD_INT 109
45999: PUSH
46000: LD_INT 110
46002: PUSH
46003: LD_INT 111
46005: PUSH
46006: LD_INT 112
46008: PUSH
46009: LD_INT 113
46011: PUSH
46012: LD_INT 114
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: PUSH
46031: EMPTY
46032: LIST
46033: LIST
46034: ST_TO_ADDR
46035: GO 47202
46037: LD_INT 14
46039: DOUBLE
46040: EQUAL
46041: IFTRUE 46045
46043: GO 46257
46045: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46046: LD_ADDR_VAR 0 1
46050: PUSH
46051: LD_INT 1
46053: PUSH
46054: LD_INT 2
46056: PUSH
46057: LD_INT 3
46059: PUSH
46060: LD_INT 4
46062: PUSH
46063: LD_INT 5
46065: PUSH
46066: LD_INT 6
46068: PUSH
46069: LD_INT 7
46071: PUSH
46072: LD_INT 8
46074: PUSH
46075: LD_INT 9
46077: PUSH
46078: LD_INT 10
46080: PUSH
46081: LD_INT 11
46083: PUSH
46084: LD_INT 12
46086: PUSH
46087: LD_INT 13
46089: PUSH
46090: LD_INT 14
46092: PUSH
46093: LD_INT 15
46095: PUSH
46096: LD_INT 16
46098: PUSH
46099: LD_INT 17
46101: PUSH
46102: LD_INT 18
46104: PUSH
46105: LD_INT 19
46107: PUSH
46108: LD_INT 20
46110: PUSH
46111: LD_INT 21
46113: PUSH
46114: LD_INT 22
46116: PUSH
46117: LD_INT 23
46119: PUSH
46120: LD_INT 24
46122: PUSH
46123: LD_INT 25
46125: PUSH
46126: LD_INT 26
46128: PUSH
46129: LD_INT 27
46131: PUSH
46132: LD_INT 28
46134: PUSH
46135: LD_INT 29
46137: PUSH
46138: LD_INT 30
46140: PUSH
46141: LD_INT 31
46143: PUSH
46144: LD_INT 32
46146: PUSH
46147: LD_INT 33
46149: PUSH
46150: LD_INT 34
46152: PUSH
46153: LD_INT 36
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: PUSH
46193: LD_INT 101
46195: PUSH
46196: LD_INT 102
46198: PUSH
46199: LD_INT 103
46201: PUSH
46202: LD_INT 104
46204: PUSH
46205: LD_INT 105
46207: PUSH
46208: LD_INT 106
46210: PUSH
46211: LD_INT 107
46213: PUSH
46214: LD_INT 108
46216: PUSH
46217: LD_INT 109
46219: PUSH
46220: LD_INT 110
46222: PUSH
46223: LD_INT 111
46225: PUSH
46226: LD_INT 112
46228: PUSH
46229: LD_INT 113
46231: PUSH
46232: LD_INT 114
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: ST_TO_ADDR
46255: GO 47202
46257: LD_INT 15
46259: DOUBLE
46260: EQUAL
46261: IFTRUE 46265
46263: GO 46477
46265: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46266: LD_ADDR_VAR 0 1
46270: PUSH
46271: LD_INT 1
46273: PUSH
46274: LD_INT 2
46276: PUSH
46277: LD_INT 3
46279: PUSH
46280: LD_INT 4
46282: PUSH
46283: LD_INT 5
46285: PUSH
46286: LD_INT 6
46288: PUSH
46289: LD_INT 7
46291: PUSH
46292: LD_INT 8
46294: PUSH
46295: LD_INT 9
46297: PUSH
46298: LD_INT 10
46300: PUSH
46301: LD_INT 11
46303: PUSH
46304: LD_INT 12
46306: PUSH
46307: LD_INT 13
46309: PUSH
46310: LD_INT 14
46312: PUSH
46313: LD_INT 15
46315: PUSH
46316: LD_INT 16
46318: PUSH
46319: LD_INT 17
46321: PUSH
46322: LD_INT 18
46324: PUSH
46325: LD_INT 19
46327: PUSH
46328: LD_INT 20
46330: PUSH
46331: LD_INT 21
46333: PUSH
46334: LD_INT 22
46336: PUSH
46337: LD_INT 23
46339: PUSH
46340: LD_INT 24
46342: PUSH
46343: LD_INT 25
46345: PUSH
46346: LD_INT 26
46348: PUSH
46349: LD_INT 27
46351: PUSH
46352: LD_INT 28
46354: PUSH
46355: LD_INT 29
46357: PUSH
46358: LD_INT 30
46360: PUSH
46361: LD_INT 31
46363: PUSH
46364: LD_INT 32
46366: PUSH
46367: LD_INT 33
46369: PUSH
46370: LD_INT 34
46372: PUSH
46373: LD_INT 36
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: PUSH
46413: LD_INT 101
46415: PUSH
46416: LD_INT 102
46418: PUSH
46419: LD_INT 103
46421: PUSH
46422: LD_INT 104
46424: PUSH
46425: LD_INT 105
46427: PUSH
46428: LD_INT 106
46430: PUSH
46431: LD_INT 107
46433: PUSH
46434: LD_INT 108
46436: PUSH
46437: LD_INT 109
46439: PUSH
46440: LD_INT 110
46442: PUSH
46443: LD_INT 111
46445: PUSH
46446: LD_INT 112
46448: PUSH
46449: LD_INT 113
46451: PUSH
46452: LD_INT 114
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: LIST
46468: LIST
46469: LIST
46470: PUSH
46471: EMPTY
46472: LIST
46473: LIST
46474: ST_TO_ADDR
46475: GO 47202
46477: LD_INT 16
46479: DOUBLE
46480: EQUAL
46481: IFTRUE 46485
46483: GO 46609
46485: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
46486: LD_ADDR_VAR 0 1
46490: PUSH
46491: LD_INT 2
46493: PUSH
46494: LD_INT 4
46496: PUSH
46497: LD_INT 5
46499: PUSH
46500: LD_INT 7
46502: PUSH
46503: LD_INT 11
46505: PUSH
46506: LD_INT 12
46508: PUSH
46509: LD_INT 15
46511: PUSH
46512: LD_INT 16
46514: PUSH
46515: LD_INT 20
46517: PUSH
46518: LD_INT 21
46520: PUSH
46521: LD_INT 22
46523: PUSH
46524: LD_INT 23
46526: PUSH
46527: LD_INT 25
46529: PUSH
46530: LD_INT 26
46532: PUSH
46533: LD_INT 30
46535: PUSH
46536: LD_INT 31
46538: PUSH
46539: LD_INT 32
46541: PUSH
46542: LD_INT 33
46544: PUSH
46545: LD_INT 34
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 101
46571: PUSH
46572: LD_INT 102
46574: PUSH
46575: LD_INT 103
46577: PUSH
46578: LD_INT 106
46580: PUSH
46581: LD_INT 108
46583: PUSH
46584: LD_INT 112
46586: PUSH
46587: LD_INT 113
46589: PUSH
46590: LD_INT 114
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: ST_TO_ADDR
46607: GO 47202
46609: LD_INT 17
46611: DOUBLE
46612: EQUAL
46613: IFTRUE 46617
46615: GO 46829
46617: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
46618: LD_ADDR_VAR 0 1
46622: PUSH
46623: LD_INT 1
46625: PUSH
46626: LD_INT 2
46628: PUSH
46629: LD_INT 3
46631: PUSH
46632: LD_INT 4
46634: PUSH
46635: LD_INT 5
46637: PUSH
46638: LD_INT 6
46640: PUSH
46641: LD_INT 7
46643: PUSH
46644: LD_INT 8
46646: PUSH
46647: LD_INT 9
46649: PUSH
46650: LD_INT 10
46652: PUSH
46653: LD_INT 11
46655: PUSH
46656: LD_INT 12
46658: PUSH
46659: LD_INT 13
46661: PUSH
46662: LD_INT 14
46664: PUSH
46665: LD_INT 15
46667: PUSH
46668: LD_INT 16
46670: PUSH
46671: LD_INT 17
46673: PUSH
46674: LD_INT 18
46676: PUSH
46677: LD_INT 19
46679: PUSH
46680: LD_INT 20
46682: PUSH
46683: LD_INT 21
46685: PUSH
46686: LD_INT 22
46688: PUSH
46689: LD_INT 23
46691: PUSH
46692: LD_INT 24
46694: PUSH
46695: LD_INT 25
46697: PUSH
46698: LD_INT 26
46700: PUSH
46701: LD_INT 27
46703: PUSH
46704: LD_INT 28
46706: PUSH
46707: LD_INT 29
46709: PUSH
46710: LD_INT 30
46712: PUSH
46713: LD_INT 31
46715: PUSH
46716: LD_INT 32
46718: PUSH
46719: LD_INT 33
46721: PUSH
46722: LD_INT 34
46724: PUSH
46725: LD_INT 36
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: PUSH
46765: LD_INT 101
46767: PUSH
46768: LD_INT 102
46770: PUSH
46771: LD_INT 103
46773: PUSH
46774: LD_INT 104
46776: PUSH
46777: LD_INT 105
46779: PUSH
46780: LD_INT 106
46782: PUSH
46783: LD_INT 107
46785: PUSH
46786: LD_INT 108
46788: PUSH
46789: LD_INT 109
46791: PUSH
46792: LD_INT 110
46794: PUSH
46795: LD_INT 111
46797: PUSH
46798: LD_INT 112
46800: PUSH
46801: LD_INT 113
46803: PUSH
46804: LD_INT 114
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: PUSH
46823: EMPTY
46824: LIST
46825: LIST
46826: ST_TO_ADDR
46827: GO 47202
46829: LD_INT 18
46831: DOUBLE
46832: EQUAL
46833: IFTRUE 46837
46835: GO 46973
46837: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
46838: LD_ADDR_VAR 0 1
46842: PUSH
46843: LD_INT 2
46845: PUSH
46846: LD_INT 4
46848: PUSH
46849: LD_INT 5
46851: PUSH
46852: LD_INT 7
46854: PUSH
46855: LD_INT 11
46857: PUSH
46858: LD_INT 12
46860: PUSH
46861: LD_INT 15
46863: PUSH
46864: LD_INT 16
46866: PUSH
46867: LD_INT 20
46869: PUSH
46870: LD_INT 21
46872: PUSH
46873: LD_INT 22
46875: PUSH
46876: LD_INT 23
46878: PUSH
46879: LD_INT 25
46881: PUSH
46882: LD_INT 26
46884: PUSH
46885: LD_INT 30
46887: PUSH
46888: LD_INT 31
46890: PUSH
46891: LD_INT 32
46893: PUSH
46894: LD_INT 33
46896: PUSH
46897: LD_INT 34
46899: PUSH
46900: LD_INT 35
46902: PUSH
46903: LD_INT 36
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: PUSH
46929: LD_INT 101
46931: PUSH
46932: LD_INT 102
46934: PUSH
46935: LD_INT 103
46937: PUSH
46938: LD_INT 106
46940: PUSH
46941: LD_INT 108
46943: PUSH
46944: LD_INT 112
46946: PUSH
46947: LD_INT 113
46949: PUSH
46950: LD_INT 114
46952: PUSH
46953: LD_INT 115
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: ST_TO_ADDR
46971: GO 47202
46973: LD_INT 19
46975: DOUBLE
46976: EQUAL
46977: IFTRUE 46981
46979: GO 47201
46981: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
46982: LD_ADDR_VAR 0 1
46986: PUSH
46987: LD_INT 1
46989: PUSH
46990: LD_INT 2
46992: PUSH
46993: LD_INT 3
46995: PUSH
46996: LD_INT 4
46998: PUSH
46999: LD_INT 5
47001: PUSH
47002: LD_INT 6
47004: PUSH
47005: LD_INT 7
47007: PUSH
47008: LD_INT 8
47010: PUSH
47011: LD_INT 9
47013: PUSH
47014: LD_INT 10
47016: PUSH
47017: LD_INT 11
47019: PUSH
47020: LD_INT 12
47022: PUSH
47023: LD_INT 13
47025: PUSH
47026: LD_INT 14
47028: PUSH
47029: LD_INT 15
47031: PUSH
47032: LD_INT 16
47034: PUSH
47035: LD_INT 17
47037: PUSH
47038: LD_INT 18
47040: PUSH
47041: LD_INT 19
47043: PUSH
47044: LD_INT 20
47046: PUSH
47047: LD_INT 21
47049: PUSH
47050: LD_INT 22
47052: PUSH
47053: LD_INT 23
47055: PUSH
47056: LD_INT 24
47058: PUSH
47059: LD_INT 25
47061: PUSH
47062: LD_INT 26
47064: PUSH
47065: LD_INT 27
47067: PUSH
47068: LD_INT 28
47070: PUSH
47071: LD_INT 29
47073: PUSH
47074: LD_INT 30
47076: PUSH
47077: LD_INT 31
47079: PUSH
47080: LD_INT 32
47082: PUSH
47083: LD_INT 33
47085: PUSH
47086: LD_INT 34
47088: PUSH
47089: LD_INT 35
47091: PUSH
47092: LD_INT 36
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: LIST
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 101
47135: PUSH
47136: LD_INT 102
47138: PUSH
47139: LD_INT 103
47141: PUSH
47142: LD_INT 104
47144: PUSH
47145: LD_INT 105
47147: PUSH
47148: LD_INT 106
47150: PUSH
47151: LD_INT 107
47153: PUSH
47154: LD_INT 108
47156: PUSH
47157: LD_INT 109
47159: PUSH
47160: LD_INT 110
47162: PUSH
47163: LD_INT 111
47165: PUSH
47166: LD_INT 112
47168: PUSH
47169: LD_INT 113
47171: PUSH
47172: LD_INT 114
47174: PUSH
47175: LD_INT 115
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: ST_TO_ADDR
47199: GO 47202
47201: POP
// end else
47202: GO 47421
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47204: LD_ADDR_VAR 0 1
47208: PUSH
47209: LD_INT 1
47211: PUSH
47212: LD_INT 2
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: LD_INT 4
47220: PUSH
47221: LD_INT 5
47223: PUSH
47224: LD_INT 6
47226: PUSH
47227: LD_INT 7
47229: PUSH
47230: LD_INT 8
47232: PUSH
47233: LD_INT 9
47235: PUSH
47236: LD_INT 10
47238: PUSH
47239: LD_INT 11
47241: PUSH
47242: LD_INT 12
47244: PUSH
47245: LD_INT 13
47247: PUSH
47248: LD_INT 14
47250: PUSH
47251: LD_INT 15
47253: PUSH
47254: LD_INT 16
47256: PUSH
47257: LD_INT 17
47259: PUSH
47260: LD_INT 18
47262: PUSH
47263: LD_INT 19
47265: PUSH
47266: LD_INT 20
47268: PUSH
47269: LD_INT 21
47271: PUSH
47272: LD_INT 22
47274: PUSH
47275: LD_INT 23
47277: PUSH
47278: LD_INT 24
47280: PUSH
47281: LD_INT 25
47283: PUSH
47284: LD_INT 26
47286: PUSH
47287: LD_INT 27
47289: PUSH
47290: LD_INT 28
47292: PUSH
47293: LD_INT 29
47295: PUSH
47296: LD_INT 30
47298: PUSH
47299: LD_INT 31
47301: PUSH
47302: LD_INT 32
47304: PUSH
47305: LD_INT 33
47307: PUSH
47308: LD_INT 34
47310: PUSH
47311: LD_INT 35
47313: PUSH
47314: LD_INT 36
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 101
47357: PUSH
47358: LD_INT 102
47360: PUSH
47361: LD_INT 103
47363: PUSH
47364: LD_INT 104
47366: PUSH
47367: LD_INT 105
47369: PUSH
47370: LD_INT 106
47372: PUSH
47373: LD_INT 107
47375: PUSH
47376: LD_INT 108
47378: PUSH
47379: LD_INT 109
47381: PUSH
47382: LD_INT 110
47384: PUSH
47385: LD_INT 111
47387: PUSH
47388: LD_INT 112
47390: PUSH
47391: LD_INT 113
47393: PUSH
47394: LD_INT 114
47396: PUSH
47397: LD_INT 115
47399: PUSH
47400: EMPTY
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: ST_TO_ADDR
// if result then
47421: LD_VAR 0 1
47425: IFFALSE 47714
// begin normal :=  ;
47427: LD_ADDR_VAR 0 3
47431: PUSH
47432: LD_STRING 
47434: ST_TO_ADDR
// hardcore :=  ;
47435: LD_ADDR_VAR 0 4
47439: PUSH
47440: LD_STRING 
47442: ST_TO_ADDR
// for i = 1 to normalCounter do
47443: LD_ADDR_VAR 0 5
47447: PUSH
47448: DOUBLE
47449: LD_INT 1
47451: DEC
47452: ST_TO_ADDR
47453: LD_EXP 89
47457: PUSH
47458: FOR_TO
47459: IFFALSE 47560
// begin tmp := 0 ;
47461: LD_ADDR_VAR 0 2
47465: PUSH
47466: LD_STRING 0
47468: ST_TO_ADDR
// if result [ 1 ] then
47469: LD_VAR 0 1
47473: PUSH
47474: LD_INT 1
47476: ARRAY
47477: IFFALSE 47542
// if result [ 1 ] [ 1 ] = i then
47479: LD_VAR 0 1
47483: PUSH
47484: LD_INT 1
47486: ARRAY
47487: PUSH
47488: LD_INT 1
47490: ARRAY
47491: PUSH
47492: LD_VAR 0 5
47496: EQUAL
47497: IFFALSE 47542
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
47499: LD_ADDR_VAR 0 1
47503: PUSH
47504: LD_VAR 0 1
47508: PPUSH
47509: LD_INT 1
47511: PPUSH
47512: LD_VAR 0 1
47516: PUSH
47517: LD_INT 1
47519: ARRAY
47520: PPUSH
47521: LD_INT 1
47523: PPUSH
47524: CALL_OW 3
47528: PPUSH
47529: CALL_OW 1
47533: ST_TO_ADDR
// tmp := 1 ;
47534: LD_ADDR_VAR 0 2
47538: PUSH
47539: LD_STRING 1
47541: ST_TO_ADDR
// end ; normal := normal & tmp ;
47542: LD_ADDR_VAR 0 3
47546: PUSH
47547: LD_VAR 0 3
47551: PUSH
47552: LD_VAR 0 2
47556: STR
47557: ST_TO_ADDR
// end ;
47558: GO 47458
47560: POP
47561: POP
// for i = 1 to hardcoreCounter do
47562: LD_ADDR_VAR 0 5
47566: PUSH
47567: DOUBLE
47568: LD_INT 1
47570: DEC
47571: ST_TO_ADDR
47572: LD_EXP 90
47576: PUSH
47577: FOR_TO
47578: IFFALSE 47683
// begin tmp := 0 ;
47580: LD_ADDR_VAR 0 2
47584: PUSH
47585: LD_STRING 0
47587: ST_TO_ADDR
// if result [ 2 ] then
47588: LD_VAR 0 1
47592: PUSH
47593: LD_INT 2
47595: ARRAY
47596: IFFALSE 47665
// if result [ 2 ] [ 1 ] = 100 + i then
47598: LD_VAR 0 1
47602: PUSH
47603: LD_INT 2
47605: ARRAY
47606: PUSH
47607: LD_INT 1
47609: ARRAY
47610: PUSH
47611: LD_INT 100
47613: PUSH
47614: LD_VAR 0 5
47618: PLUS
47619: EQUAL
47620: IFFALSE 47665
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
47622: LD_ADDR_VAR 0 1
47626: PUSH
47627: LD_VAR 0 1
47631: PPUSH
47632: LD_INT 2
47634: PPUSH
47635: LD_VAR 0 1
47639: PUSH
47640: LD_INT 2
47642: ARRAY
47643: PPUSH
47644: LD_INT 1
47646: PPUSH
47647: CALL_OW 3
47651: PPUSH
47652: CALL_OW 1
47656: ST_TO_ADDR
// tmp := 1 ;
47657: LD_ADDR_VAR 0 2
47661: PUSH
47662: LD_STRING 1
47664: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
47665: LD_ADDR_VAR 0 4
47669: PUSH
47670: LD_VAR 0 4
47674: PUSH
47675: LD_VAR 0 2
47679: STR
47680: ST_TO_ADDR
// end ;
47681: GO 47577
47683: POP
47684: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
47685: LD_STRING getStreamItemsFromMission("
47687: PUSH
47688: LD_VAR 0 3
47692: STR
47693: PUSH
47694: LD_STRING ","
47696: STR
47697: PUSH
47698: LD_VAR 0 4
47702: STR
47703: PUSH
47704: LD_STRING ")
47706: STR
47707: PPUSH
47708: CALL_OW 559
// end else
47712: GO 47721
// ToLua ( getStreamItemsFromMission("","") ) ;
47714: LD_STRING getStreamItemsFromMission("","")
47716: PPUSH
47717: CALL_OW 559
// end ;
47721: LD_VAR 0 1
47725: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
47726: LD_VAR 0 2
47730: PUSH
47731: LD_INT 100
47733: EQUAL
47734: IFFALSE 48683
// begin if not StreamModeActive then
47736: LD_EXP 88
47740: NOT
47741: IFFALSE 47751
// StreamModeActive := true ;
47743: LD_ADDR_EXP 88
47747: PUSH
47748: LD_INT 1
47750: ST_TO_ADDR
// if p3 = 0 then
47751: LD_VAR 0 3
47755: PUSH
47756: LD_INT 0
47758: EQUAL
47759: IFFALSE 47765
// InitStreamMode ;
47761: CALL 43804 0 0
// if p3 = 1 then
47765: LD_VAR 0 3
47769: PUSH
47770: LD_INT 1
47772: EQUAL
47773: IFFALSE 47783
// sRocket := true ;
47775: LD_ADDR_EXP 93
47779: PUSH
47780: LD_INT 1
47782: ST_TO_ADDR
// if p3 = 2 then
47783: LD_VAR 0 3
47787: PUSH
47788: LD_INT 2
47790: EQUAL
47791: IFFALSE 47801
// sSpeed := true ;
47793: LD_ADDR_EXP 92
47797: PUSH
47798: LD_INT 1
47800: ST_TO_ADDR
// if p3 = 3 then
47801: LD_VAR 0 3
47805: PUSH
47806: LD_INT 3
47808: EQUAL
47809: IFFALSE 47819
// sEngine := true ;
47811: LD_ADDR_EXP 94
47815: PUSH
47816: LD_INT 1
47818: ST_TO_ADDR
// if p3 = 4 then
47819: LD_VAR 0 3
47823: PUSH
47824: LD_INT 4
47826: EQUAL
47827: IFFALSE 47837
// sSpec := true ;
47829: LD_ADDR_EXP 91
47833: PUSH
47834: LD_INT 1
47836: ST_TO_ADDR
// if p3 = 5 then
47837: LD_VAR 0 3
47841: PUSH
47842: LD_INT 5
47844: EQUAL
47845: IFFALSE 47855
// sLevel := true ;
47847: LD_ADDR_EXP 95
47851: PUSH
47852: LD_INT 1
47854: ST_TO_ADDR
// if p3 = 6 then
47855: LD_VAR 0 3
47859: PUSH
47860: LD_INT 6
47862: EQUAL
47863: IFFALSE 47873
// sArmoury := true ;
47865: LD_ADDR_EXP 96
47869: PUSH
47870: LD_INT 1
47872: ST_TO_ADDR
// if p3 = 7 then
47873: LD_VAR 0 3
47877: PUSH
47878: LD_INT 7
47880: EQUAL
47881: IFFALSE 47891
// sRadar := true ;
47883: LD_ADDR_EXP 97
47887: PUSH
47888: LD_INT 1
47890: ST_TO_ADDR
// if p3 = 8 then
47891: LD_VAR 0 3
47895: PUSH
47896: LD_INT 8
47898: EQUAL
47899: IFFALSE 47909
// sBunker := true ;
47901: LD_ADDR_EXP 98
47905: PUSH
47906: LD_INT 1
47908: ST_TO_ADDR
// if p3 = 9 then
47909: LD_VAR 0 3
47913: PUSH
47914: LD_INT 9
47916: EQUAL
47917: IFFALSE 47927
// sHack := true ;
47919: LD_ADDR_EXP 99
47923: PUSH
47924: LD_INT 1
47926: ST_TO_ADDR
// if p3 = 10 then
47927: LD_VAR 0 3
47931: PUSH
47932: LD_INT 10
47934: EQUAL
47935: IFFALSE 47945
// sFire := true ;
47937: LD_ADDR_EXP 100
47941: PUSH
47942: LD_INT 1
47944: ST_TO_ADDR
// if p3 = 11 then
47945: LD_VAR 0 3
47949: PUSH
47950: LD_INT 11
47952: EQUAL
47953: IFFALSE 47963
// sRefresh := true ;
47955: LD_ADDR_EXP 101
47959: PUSH
47960: LD_INT 1
47962: ST_TO_ADDR
// if p3 = 12 then
47963: LD_VAR 0 3
47967: PUSH
47968: LD_INT 12
47970: EQUAL
47971: IFFALSE 47981
// sExp := true ;
47973: LD_ADDR_EXP 102
47977: PUSH
47978: LD_INT 1
47980: ST_TO_ADDR
// if p3 = 13 then
47981: LD_VAR 0 3
47985: PUSH
47986: LD_INT 13
47988: EQUAL
47989: IFFALSE 47999
// sDepot := true ;
47991: LD_ADDR_EXP 103
47995: PUSH
47996: LD_INT 1
47998: ST_TO_ADDR
// if p3 = 14 then
47999: LD_VAR 0 3
48003: PUSH
48004: LD_INT 14
48006: EQUAL
48007: IFFALSE 48017
// sFlag := true ;
48009: LD_ADDR_EXP 104
48013: PUSH
48014: LD_INT 1
48016: ST_TO_ADDR
// if p3 = 15 then
48017: LD_VAR 0 3
48021: PUSH
48022: LD_INT 15
48024: EQUAL
48025: IFFALSE 48035
// sKamikadze := true ;
48027: LD_ADDR_EXP 112
48031: PUSH
48032: LD_INT 1
48034: ST_TO_ADDR
// if p3 = 16 then
48035: LD_VAR 0 3
48039: PUSH
48040: LD_INT 16
48042: EQUAL
48043: IFFALSE 48053
// sTroll := true ;
48045: LD_ADDR_EXP 113
48049: PUSH
48050: LD_INT 1
48052: ST_TO_ADDR
// if p3 = 17 then
48053: LD_VAR 0 3
48057: PUSH
48058: LD_INT 17
48060: EQUAL
48061: IFFALSE 48071
// sSlow := true ;
48063: LD_ADDR_EXP 114
48067: PUSH
48068: LD_INT 1
48070: ST_TO_ADDR
// if p3 = 18 then
48071: LD_VAR 0 3
48075: PUSH
48076: LD_INT 18
48078: EQUAL
48079: IFFALSE 48089
// sLack := true ;
48081: LD_ADDR_EXP 115
48085: PUSH
48086: LD_INT 1
48088: ST_TO_ADDR
// if p3 = 19 then
48089: LD_VAR 0 3
48093: PUSH
48094: LD_INT 19
48096: EQUAL
48097: IFFALSE 48107
// sTank := true ;
48099: LD_ADDR_EXP 117
48103: PUSH
48104: LD_INT 1
48106: ST_TO_ADDR
// if p3 = 20 then
48107: LD_VAR 0 3
48111: PUSH
48112: LD_INT 20
48114: EQUAL
48115: IFFALSE 48125
// sRemote := true ;
48117: LD_ADDR_EXP 118
48121: PUSH
48122: LD_INT 1
48124: ST_TO_ADDR
// if p3 = 21 then
48125: LD_VAR 0 3
48129: PUSH
48130: LD_INT 21
48132: EQUAL
48133: IFFALSE 48143
// sPowell := true ;
48135: LD_ADDR_EXP 119
48139: PUSH
48140: LD_INT 1
48142: ST_TO_ADDR
// if p3 = 22 then
48143: LD_VAR 0 3
48147: PUSH
48148: LD_INT 22
48150: EQUAL
48151: IFFALSE 48161
// sTeleport := true ;
48153: LD_ADDR_EXP 122
48157: PUSH
48158: LD_INT 1
48160: ST_TO_ADDR
// if p3 = 23 then
48161: LD_VAR 0 3
48165: PUSH
48166: LD_INT 23
48168: EQUAL
48169: IFFALSE 48179
// sOilTower := true ;
48171: LD_ADDR_EXP 124
48175: PUSH
48176: LD_INT 1
48178: ST_TO_ADDR
// if p3 = 24 then
48179: LD_VAR 0 3
48183: PUSH
48184: LD_INT 24
48186: EQUAL
48187: IFFALSE 48197
// sShovel := true ;
48189: LD_ADDR_EXP 125
48193: PUSH
48194: LD_INT 1
48196: ST_TO_ADDR
// if p3 = 25 then
48197: LD_VAR 0 3
48201: PUSH
48202: LD_INT 25
48204: EQUAL
48205: IFFALSE 48215
// sSheik := true ;
48207: LD_ADDR_EXP 126
48211: PUSH
48212: LD_INT 1
48214: ST_TO_ADDR
// if p3 = 26 then
48215: LD_VAR 0 3
48219: PUSH
48220: LD_INT 26
48222: EQUAL
48223: IFFALSE 48233
// sEarthquake := true ;
48225: LD_ADDR_EXP 128
48229: PUSH
48230: LD_INT 1
48232: ST_TO_ADDR
// if p3 = 27 then
48233: LD_VAR 0 3
48237: PUSH
48238: LD_INT 27
48240: EQUAL
48241: IFFALSE 48251
// sAI := true ;
48243: LD_ADDR_EXP 129
48247: PUSH
48248: LD_INT 1
48250: ST_TO_ADDR
// if p3 = 28 then
48251: LD_VAR 0 3
48255: PUSH
48256: LD_INT 28
48258: EQUAL
48259: IFFALSE 48269
// sCargo := true ;
48261: LD_ADDR_EXP 132
48265: PUSH
48266: LD_INT 1
48268: ST_TO_ADDR
// if p3 = 29 then
48269: LD_VAR 0 3
48273: PUSH
48274: LD_INT 29
48276: EQUAL
48277: IFFALSE 48287
// sDLaser := true ;
48279: LD_ADDR_EXP 133
48283: PUSH
48284: LD_INT 1
48286: ST_TO_ADDR
// if p3 = 30 then
48287: LD_VAR 0 3
48291: PUSH
48292: LD_INT 30
48294: EQUAL
48295: IFFALSE 48305
// sExchange := true ;
48297: LD_ADDR_EXP 134
48301: PUSH
48302: LD_INT 1
48304: ST_TO_ADDR
// if p3 = 31 then
48305: LD_VAR 0 3
48309: PUSH
48310: LD_INT 31
48312: EQUAL
48313: IFFALSE 48323
// sFac := true ;
48315: LD_ADDR_EXP 135
48319: PUSH
48320: LD_INT 1
48322: ST_TO_ADDR
// if p3 = 32 then
48323: LD_VAR 0 3
48327: PUSH
48328: LD_INT 32
48330: EQUAL
48331: IFFALSE 48341
// sPower := true ;
48333: LD_ADDR_EXP 136
48337: PUSH
48338: LD_INT 1
48340: ST_TO_ADDR
// if p3 = 33 then
48341: LD_VAR 0 3
48345: PUSH
48346: LD_INT 33
48348: EQUAL
48349: IFFALSE 48359
// sRandom := true ;
48351: LD_ADDR_EXP 137
48355: PUSH
48356: LD_INT 1
48358: ST_TO_ADDR
// if p3 = 34 then
48359: LD_VAR 0 3
48363: PUSH
48364: LD_INT 34
48366: EQUAL
48367: IFFALSE 48377
// sShield := true ;
48369: LD_ADDR_EXP 138
48373: PUSH
48374: LD_INT 1
48376: ST_TO_ADDR
// if p3 = 35 then
48377: LD_VAR 0 3
48381: PUSH
48382: LD_INT 35
48384: EQUAL
48385: IFFALSE 48395
// sTime := true ;
48387: LD_ADDR_EXP 139
48391: PUSH
48392: LD_INT 1
48394: ST_TO_ADDR
// if p3 = 36 then
48395: LD_VAR 0 3
48399: PUSH
48400: LD_INT 36
48402: EQUAL
48403: IFFALSE 48413
// sTools := true ;
48405: LD_ADDR_EXP 140
48409: PUSH
48410: LD_INT 1
48412: ST_TO_ADDR
// if p3 = 101 then
48413: LD_VAR 0 3
48417: PUSH
48418: LD_INT 101
48420: EQUAL
48421: IFFALSE 48431
// sSold := true ;
48423: LD_ADDR_EXP 105
48427: PUSH
48428: LD_INT 1
48430: ST_TO_ADDR
// if p3 = 102 then
48431: LD_VAR 0 3
48435: PUSH
48436: LD_INT 102
48438: EQUAL
48439: IFFALSE 48449
// sDiff := true ;
48441: LD_ADDR_EXP 106
48445: PUSH
48446: LD_INT 1
48448: ST_TO_ADDR
// if p3 = 103 then
48449: LD_VAR 0 3
48453: PUSH
48454: LD_INT 103
48456: EQUAL
48457: IFFALSE 48467
// sFog := true ;
48459: LD_ADDR_EXP 109
48463: PUSH
48464: LD_INT 1
48466: ST_TO_ADDR
// if p3 = 104 then
48467: LD_VAR 0 3
48471: PUSH
48472: LD_INT 104
48474: EQUAL
48475: IFFALSE 48485
// sReset := true ;
48477: LD_ADDR_EXP 110
48481: PUSH
48482: LD_INT 1
48484: ST_TO_ADDR
// if p3 = 105 then
48485: LD_VAR 0 3
48489: PUSH
48490: LD_INT 105
48492: EQUAL
48493: IFFALSE 48503
// sSun := true ;
48495: LD_ADDR_EXP 111
48499: PUSH
48500: LD_INT 1
48502: ST_TO_ADDR
// if p3 = 106 then
48503: LD_VAR 0 3
48507: PUSH
48508: LD_INT 106
48510: EQUAL
48511: IFFALSE 48521
// sTiger := true ;
48513: LD_ADDR_EXP 107
48517: PUSH
48518: LD_INT 1
48520: ST_TO_ADDR
// if p3 = 107 then
48521: LD_VAR 0 3
48525: PUSH
48526: LD_INT 107
48528: EQUAL
48529: IFFALSE 48539
// sBomb := true ;
48531: LD_ADDR_EXP 108
48535: PUSH
48536: LD_INT 1
48538: ST_TO_ADDR
// if p3 = 108 then
48539: LD_VAR 0 3
48543: PUSH
48544: LD_INT 108
48546: EQUAL
48547: IFFALSE 48557
// sWound := true ;
48549: LD_ADDR_EXP 116
48553: PUSH
48554: LD_INT 1
48556: ST_TO_ADDR
// if p3 = 109 then
48557: LD_VAR 0 3
48561: PUSH
48562: LD_INT 109
48564: EQUAL
48565: IFFALSE 48575
// sBetray := true ;
48567: LD_ADDR_EXP 120
48571: PUSH
48572: LD_INT 1
48574: ST_TO_ADDR
// if p3 = 110 then
48575: LD_VAR 0 3
48579: PUSH
48580: LD_INT 110
48582: EQUAL
48583: IFFALSE 48593
// sContamin := true ;
48585: LD_ADDR_EXP 121
48589: PUSH
48590: LD_INT 1
48592: ST_TO_ADDR
// if p3 = 111 then
48593: LD_VAR 0 3
48597: PUSH
48598: LD_INT 111
48600: EQUAL
48601: IFFALSE 48611
// sOil := true ;
48603: LD_ADDR_EXP 123
48607: PUSH
48608: LD_INT 1
48610: ST_TO_ADDR
// if p3 = 112 then
48611: LD_VAR 0 3
48615: PUSH
48616: LD_INT 112
48618: EQUAL
48619: IFFALSE 48629
// sStu := true ;
48621: LD_ADDR_EXP 127
48625: PUSH
48626: LD_INT 1
48628: ST_TO_ADDR
// if p3 = 113 then
48629: LD_VAR 0 3
48633: PUSH
48634: LD_INT 113
48636: EQUAL
48637: IFFALSE 48647
// sBazooka := true ;
48639: LD_ADDR_EXP 130
48643: PUSH
48644: LD_INT 1
48646: ST_TO_ADDR
// if p3 = 114 then
48647: LD_VAR 0 3
48651: PUSH
48652: LD_INT 114
48654: EQUAL
48655: IFFALSE 48665
// sMortar := true ;
48657: LD_ADDR_EXP 131
48661: PUSH
48662: LD_INT 1
48664: ST_TO_ADDR
// if p3 = 115 then
48665: LD_VAR 0 3
48669: PUSH
48670: LD_INT 115
48672: EQUAL
48673: IFFALSE 48683
// sRanger := true ;
48675: LD_ADDR_EXP 141
48679: PUSH
48680: LD_INT 1
48682: ST_TO_ADDR
// end ; end ;
48683: PPOPN 6
48685: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48686: LD_EXP 88
48690: PUSH
48691: LD_EXP 93
48695: AND
48696: IFFALSE 48820
48698: GO 48700
48700: DISABLE
48701: LD_INT 0
48703: PPUSH
48704: PPUSH
// begin enable ;
48705: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48706: LD_ADDR_VAR 0 2
48710: PUSH
48711: LD_INT 22
48713: PUSH
48714: LD_OWVAR 2
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: PUSH
48723: LD_INT 2
48725: PUSH
48726: LD_INT 34
48728: PUSH
48729: LD_INT 7
48731: PUSH
48732: EMPTY
48733: LIST
48734: LIST
48735: PUSH
48736: LD_INT 34
48738: PUSH
48739: LD_INT 45
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 34
48748: PUSH
48749: LD_INT 28
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: LD_INT 34
48758: PUSH
48759: LD_INT 47
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: LIST
48770: LIST
48771: LIST
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: PPUSH
48777: CALL_OW 69
48781: ST_TO_ADDR
// if not tmp then
48782: LD_VAR 0 2
48786: NOT
48787: IFFALSE 48791
// exit ;
48789: GO 48820
// for i in tmp do
48791: LD_ADDR_VAR 0 1
48795: PUSH
48796: LD_VAR 0 2
48800: PUSH
48801: FOR_IN
48802: IFFALSE 48818
// begin SetLives ( i , 0 ) ;
48804: LD_VAR 0 1
48808: PPUSH
48809: LD_INT 0
48811: PPUSH
48812: CALL_OW 234
// end ;
48816: GO 48801
48818: POP
48819: POP
// end ;
48820: PPOPN 2
48822: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48823: LD_EXP 88
48827: PUSH
48828: LD_EXP 94
48832: AND
48833: IFFALSE 48917
48835: GO 48837
48837: DISABLE
48838: LD_INT 0
48840: PPUSH
48841: PPUSH
// begin enable ;
48842: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48843: LD_ADDR_VAR 0 2
48847: PUSH
48848: LD_INT 22
48850: PUSH
48851: LD_OWVAR 2
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 32
48862: PUSH
48863: LD_INT 3
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: EMPTY
48871: LIST
48872: LIST
48873: PPUSH
48874: CALL_OW 69
48878: ST_TO_ADDR
// if not tmp then
48879: LD_VAR 0 2
48883: NOT
48884: IFFALSE 48888
// exit ;
48886: GO 48917
// for i in tmp do
48888: LD_ADDR_VAR 0 1
48892: PUSH
48893: LD_VAR 0 2
48897: PUSH
48898: FOR_IN
48899: IFFALSE 48915
// begin SetLives ( i , 0 ) ;
48901: LD_VAR 0 1
48905: PPUSH
48906: LD_INT 0
48908: PPUSH
48909: CALL_OW 234
// end ;
48913: GO 48898
48915: POP
48916: POP
// end ;
48917: PPOPN 2
48919: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48920: LD_EXP 88
48924: PUSH
48925: LD_EXP 91
48929: AND
48930: IFFALSE 49023
48932: GO 48934
48934: DISABLE
48935: LD_INT 0
48937: PPUSH
// begin enable ;
48938: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48939: LD_ADDR_VAR 0 1
48943: PUSH
48944: LD_INT 22
48946: PUSH
48947: LD_OWVAR 2
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: PUSH
48956: LD_INT 2
48958: PUSH
48959: LD_INT 25
48961: PUSH
48962: LD_INT 5
48964: PUSH
48965: EMPTY
48966: LIST
48967: LIST
48968: PUSH
48969: LD_INT 25
48971: PUSH
48972: LD_INT 9
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: PUSH
48979: LD_INT 25
48981: PUSH
48982: LD_INT 8
48984: PUSH
48985: EMPTY
48986: LIST
48987: LIST
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: LIST
48993: LIST
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PPUSH
48999: CALL_OW 69
49003: PUSH
49004: FOR_IN
49005: IFFALSE 49021
// begin SetClass ( i , 1 ) ;
49007: LD_VAR 0 1
49011: PPUSH
49012: LD_INT 1
49014: PPUSH
49015: CALL_OW 336
// end ;
49019: GO 49004
49021: POP
49022: POP
// end ;
49023: PPOPN 1
49025: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49026: LD_EXP 88
49030: PUSH
49031: LD_EXP 92
49035: AND
49036: PUSH
49037: LD_OWVAR 65
49041: PUSH
49042: LD_INT 7
49044: LESS
49045: AND
49046: IFFALSE 49060
49048: GO 49050
49050: DISABLE
// begin enable ;
49051: ENABLE
// game_speed := 7 ;
49052: LD_ADDR_OWVAR 65
49056: PUSH
49057: LD_INT 7
49059: ST_TO_ADDR
// end ;
49060: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49061: LD_EXP 88
49065: PUSH
49066: LD_EXP 95
49070: AND
49071: IFFALSE 49273
49073: GO 49075
49075: DISABLE
49076: LD_INT 0
49078: PPUSH
49079: PPUSH
49080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49081: LD_ADDR_VAR 0 3
49085: PUSH
49086: LD_INT 81
49088: PUSH
49089: LD_OWVAR 2
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: PUSH
49098: LD_INT 21
49100: PUSH
49101: LD_INT 1
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PPUSH
49112: CALL_OW 69
49116: ST_TO_ADDR
// if not tmp then
49117: LD_VAR 0 3
49121: NOT
49122: IFFALSE 49126
// exit ;
49124: GO 49273
// if tmp > 5 then
49126: LD_VAR 0 3
49130: PUSH
49131: LD_INT 5
49133: GREATER
49134: IFFALSE 49146
// k := 5 else
49136: LD_ADDR_VAR 0 2
49140: PUSH
49141: LD_INT 5
49143: ST_TO_ADDR
49144: GO 49156
// k := tmp ;
49146: LD_ADDR_VAR 0 2
49150: PUSH
49151: LD_VAR 0 3
49155: ST_TO_ADDR
// for i := 1 to k do
49156: LD_ADDR_VAR 0 1
49160: PUSH
49161: DOUBLE
49162: LD_INT 1
49164: DEC
49165: ST_TO_ADDR
49166: LD_VAR 0 2
49170: PUSH
49171: FOR_TO
49172: IFFALSE 49271
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49174: LD_VAR 0 3
49178: PUSH
49179: LD_VAR 0 1
49183: ARRAY
49184: PPUSH
49185: LD_VAR 0 1
49189: PUSH
49190: LD_INT 4
49192: MOD
49193: PUSH
49194: LD_INT 1
49196: PLUS
49197: PPUSH
49198: CALL_OW 259
49202: PUSH
49203: LD_INT 10
49205: LESS
49206: IFFALSE 49269
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49208: LD_VAR 0 3
49212: PUSH
49213: LD_VAR 0 1
49217: ARRAY
49218: PPUSH
49219: LD_VAR 0 1
49223: PUSH
49224: LD_INT 4
49226: MOD
49227: PUSH
49228: LD_INT 1
49230: PLUS
49231: PPUSH
49232: LD_VAR 0 3
49236: PUSH
49237: LD_VAR 0 1
49241: ARRAY
49242: PPUSH
49243: LD_VAR 0 1
49247: PUSH
49248: LD_INT 4
49250: MOD
49251: PUSH
49252: LD_INT 1
49254: PLUS
49255: PPUSH
49256: CALL_OW 259
49260: PUSH
49261: LD_INT 1
49263: PLUS
49264: PPUSH
49265: CALL_OW 237
49269: GO 49171
49271: POP
49272: POP
// end ;
49273: PPOPN 3
49275: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49276: LD_EXP 88
49280: PUSH
49281: LD_EXP 96
49285: AND
49286: IFFALSE 49306
49288: GO 49290
49290: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49291: LD_INT 4
49293: PPUSH
49294: LD_OWVAR 2
49298: PPUSH
49299: LD_INT 0
49301: PPUSH
49302: CALL_OW 324
49306: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49307: LD_EXP 88
49311: PUSH
49312: LD_EXP 125
49316: AND
49317: IFFALSE 49337
49319: GO 49321
49321: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49322: LD_INT 19
49324: PPUSH
49325: LD_OWVAR 2
49329: PPUSH
49330: LD_INT 0
49332: PPUSH
49333: CALL_OW 324
49337: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49338: LD_EXP 88
49342: PUSH
49343: LD_EXP 97
49347: AND
49348: IFFALSE 49450
49350: GO 49352
49352: DISABLE
49353: LD_INT 0
49355: PPUSH
49356: PPUSH
// begin enable ;
49357: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49358: LD_ADDR_VAR 0 2
49362: PUSH
49363: LD_INT 22
49365: PUSH
49366: LD_OWVAR 2
49370: PUSH
49371: EMPTY
49372: LIST
49373: LIST
49374: PUSH
49375: LD_INT 2
49377: PUSH
49378: LD_INT 34
49380: PUSH
49381: LD_INT 11
49383: PUSH
49384: EMPTY
49385: LIST
49386: LIST
49387: PUSH
49388: LD_INT 34
49390: PUSH
49391: LD_INT 30
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: LIST
49402: PUSH
49403: EMPTY
49404: LIST
49405: LIST
49406: PPUSH
49407: CALL_OW 69
49411: ST_TO_ADDR
// if not tmp then
49412: LD_VAR 0 2
49416: NOT
49417: IFFALSE 49421
// exit ;
49419: GO 49450
// for i in tmp do
49421: LD_ADDR_VAR 0 1
49425: PUSH
49426: LD_VAR 0 2
49430: PUSH
49431: FOR_IN
49432: IFFALSE 49448
// begin SetLives ( i , 0 ) ;
49434: LD_VAR 0 1
49438: PPUSH
49439: LD_INT 0
49441: PPUSH
49442: CALL_OW 234
// end ;
49446: GO 49431
49448: POP
49449: POP
// end ;
49450: PPOPN 2
49452: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49453: LD_EXP 88
49457: PUSH
49458: LD_EXP 98
49462: AND
49463: IFFALSE 49483
49465: GO 49467
49467: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49468: LD_INT 32
49470: PPUSH
49471: LD_OWVAR 2
49475: PPUSH
49476: LD_INT 0
49478: PPUSH
49479: CALL_OW 324
49483: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49484: LD_EXP 88
49488: PUSH
49489: LD_EXP 99
49493: AND
49494: IFFALSE 49675
49496: GO 49498
49498: DISABLE
49499: LD_INT 0
49501: PPUSH
49502: PPUSH
49503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49504: LD_ADDR_VAR 0 2
49508: PUSH
49509: LD_INT 22
49511: PUSH
49512: LD_OWVAR 2
49516: PUSH
49517: EMPTY
49518: LIST
49519: LIST
49520: PUSH
49521: LD_INT 33
49523: PUSH
49524: LD_INT 3
49526: PUSH
49527: EMPTY
49528: LIST
49529: LIST
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PPUSH
49535: CALL_OW 69
49539: ST_TO_ADDR
// if not tmp then
49540: LD_VAR 0 2
49544: NOT
49545: IFFALSE 49549
// exit ;
49547: GO 49675
// side := 0 ;
49549: LD_ADDR_VAR 0 3
49553: PUSH
49554: LD_INT 0
49556: ST_TO_ADDR
// for i := 1 to 8 do
49557: LD_ADDR_VAR 0 1
49561: PUSH
49562: DOUBLE
49563: LD_INT 1
49565: DEC
49566: ST_TO_ADDR
49567: LD_INT 8
49569: PUSH
49570: FOR_TO
49571: IFFALSE 49619
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49573: LD_OWVAR 2
49577: PUSH
49578: LD_VAR 0 1
49582: NONEQUAL
49583: PUSH
49584: LD_OWVAR 2
49588: PPUSH
49589: LD_VAR 0 1
49593: PPUSH
49594: CALL_OW 81
49598: PUSH
49599: LD_INT 2
49601: EQUAL
49602: AND
49603: IFFALSE 49617
// begin side := i ;
49605: LD_ADDR_VAR 0 3
49609: PUSH
49610: LD_VAR 0 1
49614: ST_TO_ADDR
// break ;
49615: GO 49619
// end ;
49617: GO 49570
49619: POP
49620: POP
// if not side then
49621: LD_VAR 0 3
49625: NOT
49626: IFFALSE 49630
// exit ;
49628: GO 49675
// for i := 1 to tmp do
49630: LD_ADDR_VAR 0 1
49634: PUSH
49635: DOUBLE
49636: LD_INT 1
49638: DEC
49639: ST_TO_ADDR
49640: LD_VAR 0 2
49644: PUSH
49645: FOR_TO
49646: IFFALSE 49673
// if Prob ( 60 ) then
49648: LD_INT 60
49650: PPUSH
49651: CALL_OW 13
49655: IFFALSE 49671
// SetSide ( i , side ) ;
49657: LD_VAR 0 1
49661: PPUSH
49662: LD_VAR 0 3
49666: PPUSH
49667: CALL_OW 235
49671: GO 49645
49673: POP
49674: POP
// end ;
49675: PPOPN 3
49677: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49678: LD_EXP 88
49682: PUSH
49683: LD_EXP 101
49687: AND
49688: IFFALSE 49807
49690: GO 49692
49692: DISABLE
49693: LD_INT 0
49695: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49696: LD_ADDR_VAR 0 1
49700: PUSH
49701: LD_INT 22
49703: PUSH
49704: LD_OWVAR 2
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PUSH
49713: LD_INT 21
49715: PUSH
49716: LD_INT 1
49718: PUSH
49719: EMPTY
49720: LIST
49721: LIST
49722: PUSH
49723: LD_INT 3
49725: PUSH
49726: LD_INT 23
49728: PUSH
49729: LD_INT 0
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: PUSH
49736: EMPTY
49737: LIST
49738: LIST
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: LIST
49744: PPUSH
49745: CALL_OW 69
49749: PUSH
49750: FOR_IN
49751: IFFALSE 49805
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49753: LD_VAR 0 1
49757: PPUSH
49758: CALL_OW 257
49762: PUSH
49763: LD_INT 1
49765: PUSH
49766: LD_INT 2
49768: PUSH
49769: LD_INT 3
49771: PUSH
49772: LD_INT 4
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: LIST
49779: LIST
49780: IN
49781: IFFALSE 49803
// SetClass ( un , rand ( 1 , 4 ) ) ;
49783: LD_VAR 0 1
49787: PPUSH
49788: LD_INT 1
49790: PPUSH
49791: LD_INT 4
49793: PPUSH
49794: CALL_OW 12
49798: PPUSH
49799: CALL_OW 336
49803: GO 49750
49805: POP
49806: POP
// end ;
49807: PPOPN 1
49809: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49810: LD_EXP 88
49814: PUSH
49815: LD_EXP 100
49819: AND
49820: IFFALSE 49899
49822: GO 49824
49824: DISABLE
49825: LD_INT 0
49827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49828: LD_ADDR_VAR 0 1
49832: PUSH
49833: LD_INT 22
49835: PUSH
49836: LD_OWVAR 2
49840: PUSH
49841: EMPTY
49842: LIST
49843: LIST
49844: PUSH
49845: LD_INT 21
49847: PUSH
49848: LD_INT 3
49850: PUSH
49851: EMPTY
49852: LIST
49853: LIST
49854: PUSH
49855: EMPTY
49856: LIST
49857: LIST
49858: PPUSH
49859: CALL_OW 69
49863: ST_TO_ADDR
// if not tmp then
49864: LD_VAR 0 1
49868: NOT
49869: IFFALSE 49873
// exit ;
49871: GO 49899
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49873: LD_VAR 0 1
49877: PUSH
49878: LD_INT 1
49880: PPUSH
49881: LD_VAR 0 1
49885: PPUSH
49886: CALL_OW 12
49890: ARRAY
49891: PPUSH
49892: LD_INT 100
49894: PPUSH
49895: CALL_OW 234
// end ;
49899: PPOPN 1
49901: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49902: LD_EXP 88
49906: PUSH
49907: LD_EXP 102
49911: AND
49912: IFFALSE 50010
49914: GO 49916
49916: DISABLE
49917: LD_INT 0
49919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49920: LD_ADDR_VAR 0 1
49924: PUSH
49925: LD_INT 22
49927: PUSH
49928: LD_OWVAR 2
49932: PUSH
49933: EMPTY
49934: LIST
49935: LIST
49936: PUSH
49937: LD_INT 21
49939: PUSH
49940: LD_INT 1
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: PPUSH
49951: CALL_OW 69
49955: ST_TO_ADDR
// if not tmp then
49956: LD_VAR 0 1
49960: NOT
49961: IFFALSE 49965
// exit ;
49963: GO 50010
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49965: LD_VAR 0 1
49969: PUSH
49970: LD_INT 1
49972: PPUSH
49973: LD_VAR 0 1
49977: PPUSH
49978: CALL_OW 12
49982: ARRAY
49983: PPUSH
49984: LD_INT 1
49986: PPUSH
49987: LD_INT 4
49989: PPUSH
49990: CALL_OW 12
49994: PPUSH
49995: LD_INT 3000
49997: PPUSH
49998: LD_INT 9000
50000: PPUSH
50001: CALL_OW 12
50005: PPUSH
50006: CALL_OW 492
// end ;
50010: PPOPN 1
50012: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50013: LD_EXP 88
50017: PUSH
50018: LD_EXP 103
50022: AND
50023: IFFALSE 50043
50025: GO 50027
50027: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50028: LD_INT 1
50030: PPUSH
50031: LD_OWVAR 2
50035: PPUSH
50036: LD_INT 0
50038: PPUSH
50039: CALL_OW 324
50043: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50044: LD_EXP 88
50048: PUSH
50049: LD_EXP 104
50053: AND
50054: IFFALSE 50137
50056: GO 50058
50058: DISABLE
50059: LD_INT 0
50061: PPUSH
50062: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50063: LD_ADDR_VAR 0 2
50067: PUSH
50068: LD_INT 22
50070: PUSH
50071: LD_OWVAR 2
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PUSH
50080: LD_INT 21
50082: PUSH
50083: LD_INT 3
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PPUSH
50094: CALL_OW 69
50098: ST_TO_ADDR
// if not tmp then
50099: LD_VAR 0 2
50103: NOT
50104: IFFALSE 50108
// exit ;
50106: GO 50137
// for i in tmp do
50108: LD_ADDR_VAR 0 1
50112: PUSH
50113: LD_VAR 0 2
50117: PUSH
50118: FOR_IN
50119: IFFALSE 50135
// SetBLevel ( i , 10 ) ;
50121: LD_VAR 0 1
50125: PPUSH
50126: LD_INT 10
50128: PPUSH
50129: CALL_OW 241
50133: GO 50118
50135: POP
50136: POP
// end ;
50137: PPOPN 2
50139: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50140: LD_EXP 88
50144: PUSH
50145: LD_EXP 105
50149: AND
50150: IFFALSE 50261
50152: GO 50154
50154: DISABLE
50155: LD_INT 0
50157: PPUSH
50158: PPUSH
50159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50160: LD_ADDR_VAR 0 3
50164: PUSH
50165: LD_INT 22
50167: PUSH
50168: LD_OWVAR 2
50172: PUSH
50173: EMPTY
50174: LIST
50175: LIST
50176: PUSH
50177: LD_INT 25
50179: PUSH
50180: LD_INT 1
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: PUSH
50187: EMPTY
50188: LIST
50189: LIST
50190: PPUSH
50191: CALL_OW 69
50195: ST_TO_ADDR
// if not tmp then
50196: LD_VAR 0 3
50200: NOT
50201: IFFALSE 50205
// exit ;
50203: GO 50261
// un := tmp [ rand ( 1 , tmp ) ] ;
50205: LD_ADDR_VAR 0 2
50209: PUSH
50210: LD_VAR 0 3
50214: PUSH
50215: LD_INT 1
50217: PPUSH
50218: LD_VAR 0 3
50222: PPUSH
50223: CALL_OW 12
50227: ARRAY
50228: ST_TO_ADDR
// if Crawls ( un ) then
50229: LD_VAR 0 2
50233: PPUSH
50234: CALL_OW 318
50238: IFFALSE 50249
// ComWalk ( un ) ;
50240: LD_VAR 0 2
50244: PPUSH
50245: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50249: LD_VAR 0 2
50253: PPUSH
50254: LD_INT 5
50256: PPUSH
50257: CALL_OW 336
// end ;
50261: PPOPN 3
50263: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
50264: LD_EXP 88
50268: PUSH
50269: LD_EXP 106
50273: AND
50274: PUSH
50275: LD_OWVAR 67
50279: PUSH
50280: LD_INT 3
50282: LESS
50283: AND
50284: IFFALSE 50303
50286: GO 50288
50288: DISABLE
// Difficulty := Difficulty + 1 ;
50289: LD_ADDR_OWVAR 67
50293: PUSH
50294: LD_OWVAR 67
50298: PUSH
50299: LD_INT 1
50301: PLUS
50302: ST_TO_ADDR
50303: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50304: LD_EXP 88
50308: PUSH
50309: LD_EXP 107
50313: AND
50314: IFFALSE 50417
50316: GO 50318
50318: DISABLE
50319: LD_INT 0
50321: PPUSH
// begin for i := 1 to 5 do
50322: LD_ADDR_VAR 0 1
50326: PUSH
50327: DOUBLE
50328: LD_INT 1
50330: DEC
50331: ST_TO_ADDR
50332: LD_INT 5
50334: PUSH
50335: FOR_TO
50336: IFFALSE 50415
// begin uc_nation := nation_nature ;
50338: LD_ADDR_OWVAR 21
50342: PUSH
50343: LD_INT 0
50345: ST_TO_ADDR
// uc_side := 0 ;
50346: LD_ADDR_OWVAR 20
50350: PUSH
50351: LD_INT 0
50353: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50354: LD_ADDR_OWVAR 29
50358: PUSH
50359: LD_INT 12
50361: PUSH
50362: LD_INT 12
50364: PUSH
50365: EMPTY
50366: LIST
50367: LIST
50368: ST_TO_ADDR
// hc_agressivity := 20 ;
50369: LD_ADDR_OWVAR 35
50373: PUSH
50374: LD_INT 20
50376: ST_TO_ADDR
// hc_class := class_tiger ;
50377: LD_ADDR_OWVAR 28
50381: PUSH
50382: LD_INT 14
50384: ST_TO_ADDR
// hc_gallery :=  ;
50385: LD_ADDR_OWVAR 33
50389: PUSH
50390: LD_STRING 
50392: ST_TO_ADDR
// hc_name :=  ;
50393: LD_ADDR_OWVAR 26
50397: PUSH
50398: LD_STRING 
50400: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50401: CALL_OW 44
50405: PPUSH
50406: LD_INT 0
50408: PPUSH
50409: CALL_OW 51
// end ;
50413: GO 50335
50415: POP
50416: POP
// end ;
50417: PPOPN 1
50419: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50420: LD_EXP 88
50424: PUSH
50425: LD_EXP 108
50429: AND
50430: IFFALSE 50439
50432: GO 50434
50434: DISABLE
// StreamSibBomb ;
50435: CALL 50440 0 0
50439: END
// export function StreamSibBomb ; var i , x , y ; begin
50440: LD_INT 0
50442: PPUSH
50443: PPUSH
50444: PPUSH
50445: PPUSH
// result := false ;
50446: LD_ADDR_VAR 0 1
50450: PUSH
50451: LD_INT 0
50453: ST_TO_ADDR
// for i := 1 to 16 do
50454: LD_ADDR_VAR 0 2
50458: PUSH
50459: DOUBLE
50460: LD_INT 1
50462: DEC
50463: ST_TO_ADDR
50464: LD_INT 16
50466: PUSH
50467: FOR_TO
50468: IFFALSE 50667
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50470: LD_ADDR_VAR 0 3
50474: PUSH
50475: LD_INT 10
50477: PUSH
50478: LD_INT 20
50480: PUSH
50481: LD_INT 30
50483: PUSH
50484: LD_INT 40
50486: PUSH
50487: LD_INT 50
50489: PUSH
50490: LD_INT 60
50492: PUSH
50493: LD_INT 70
50495: PUSH
50496: LD_INT 80
50498: PUSH
50499: LD_INT 90
50501: PUSH
50502: LD_INT 100
50504: PUSH
50505: LD_INT 110
50507: PUSH
50508: LD_INT 120
50510: PUSH
50511: LD_INT 130
50513: PUSH
50514: LD_INT 140
50516: PUSH
50517: LD_INT 150
50519: PUSH
50520: EMPTY
50521: LIST
50522: LIST
50523: LIST
50524: LIST
50525: LIST
50526: LIST
50527: LIST
50528: LIST
50529: LIST
50530: LIST
50531: LIST
50532: LIST
50533: LIST
50534: LIST
50535: LIST
50536: PUSH
50537: LD_INT 1
50539: PPUSH
50540: LD_INT 15
50542: PPUSH
50543: CALL_OW 12
50547: ARRAY
50548: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50549: LD_ADDR_VAR 0 4
50553: PUSH
50554: LD_INT 10
50556: PUSH
50557: LD_INT 20
50559: PUSH
50560: LD_INT 30
50562: PUSH
50563: LD_INT 40
50565: PUSH
50566: LD_INT 50
50568: PUSH
50569: LD_INT 60
50571: PUSH
50572: LD_INT 70
50574: PUSH
50575: LD_INT 80
50577: PUSH
50578: LD_INT 90
50580: PUSH
50581: LD_INT 100
50583: PUSH
50584: LD_INT 110
50586: PUSH
50587: LD_INT 120
50589: PUSH
50590: LD_INT 130
50592: PUSH
50593: LD_INT 140
50595: PUSH
50596: LD_INT 150
50598: PUSH
50599: EMPTY
50600: LIST
50601: LIST
50602: LIST
50603: LIST
50604: LIST
50605: LIST
50606: LIST
50607: LIST
50608: LIST
50609: LIST
50610: LIST
50611: LIST
50612: LIST
50613: LIST
50614: LIST
50615: PUSH
50616: LD_INT 1
50618: PPUSH
50619: LD_INT 15
50621: PPUSH
50622: CALL_OW 12
50626: ARRAY
50627: ST_TO_ADDR
// if ValidHex ( x , y ) then
50628: LD_VAR 0 3
50632: PPUSH
50633: LD_VAR 0 4
50637: PPUSH
50638: CALL_OW 488
50642: IFFALSE 50665
// begin result := [ x , y ] ;
50644: LD_ADDR_VAR 0 1
50648: PUSH
50649: LD_VAR 0 3
50653: PUSH
50654: LD_VAR 0 4
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: ST_TO_ADDR
// break ;
50663: GO 50667
// end ; end ;
50665: GO 50467
50667: POP
50668: POP
// if result then
50669: LD_VAR 0 1
50673: IFFALSE 50733
// begin ToLua ( playSibBomb() ) ;
50675: LD_STRING playSibBomb()
50677: PPUSH
50678: CALL_OW 559
// wait ( 0 0$14 ) ;
50682: LD_INT 490
50684: PPUSH
50685: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50689: LD_VAR 0 1
50693: PUSH
50694: LD_INT 1
50696: ARRAY
50697: PPUSH
50698: LD_VAR 0 1
50702: PUSH
50703: LD_INT 2
50705: ARRAY
50706: PPUSH
50707: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50711: LD_VAR 0 1
50715: PUSH
50716: LD_INT 1
50718: ARRAY
50719: PPUSH
50720: LD_VAR 0 1
50724: PUSH
50725: LD_INT 2
50727: ARRAY
50728: PPUSH
50729: CALL_OW 429
// end ; end ;
50733: LD_VAR 0 1
50737: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50738: LD_EXP 88
50742: PUSH
50743: LD_EXP 110
50747: AND
50748: IFFALSE 50760
50750: GO 50752
50752: DISABLE
// YouLost (  ) ;
50753: LD_STRING 
50755: PPUSH
50756: CALL_OW 104
50760: END
// every 0 0$1 trigger StreamModeActive and sFog do
50761: LD_EXP 88
50765: PUSH
50766: LD_EXP 109
50770: AND
50771: IFFALSE 50785
50773: GO 50775
50775: DISABLE
// FogOff ( your_side ) ;
50776: LD_OWVAR 2
50780: PPUSH
50781: CALL_OW 344
50785: END
// every 0 0$1 trigger StreamModeActive and sSun do
50786: LD_EXP 88
50790: PUSH
50791: LD_EXP 111
50795: AND
50796: IFFALSE 50824
50798: GO 50800
50800: DISABLE
// begin solar_recharge_percent := 0 ;
50801: LD_ADDR_OWVAR 79
50805: PUSH
50806: LD_INT 0
50808: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50809: LD_INT 10500
50811: PPUSH
50812: CALL_OW 67
// solar_recharge_percent := 100 ;
50816: LD_ADDR_OWVAR 79
50820: PUSH
50821: LD_INT 100
50823: ST_TO_ADDR
// end ;
50824: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50825: LD_EXP 88
50829: PUSH
50830: LD_EXP 112
50834: AND
50835: IFFALSE 51074
50837: GO 50839
50839: DISABLE
50840: LD_INT 0
50842: PPUSH
50843: PPUSH
50844: PPUSH
// begin tmp := [ ] ;
50845: LD_ADDR_VAR 0 3
50849: PUSH
50850: EMPTY
50851: ST_TO_ADDR
// for i := 1 to 6 do
50852: LD_ADDR_VAR 0 1
50856: PUSH
50857: DOUBLE
50858: LD_INT 1
50860: DEC
50861: ST_TO_ADDR
50862: LD_INT 6
50864: PUSH
50865: FOR_TO
50866: IFFALSE 50971
// begin uc_nation := nation_nature ;
50868: LD_ADDR_OWVAR 21
50872: PUSH
50873: LD_INT 0
50875: ST_TO_ADDR
// uc_side := 0 ;
50876: LD_ADDR_OWVAR 20
50880: PUSH
50881: LD_INT 0
50883: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50884: LD_ADDR_OWVAR 29
50888: PUSH
50889: LD_INT 12
50891: PUSH
50892: LD_INT 12
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: ST_TO_ADDR
// hc_agressivity := 20 ;
50899: LD_ADDR_OWVAR 35
50903: PUSH
50904: LD_INT 20
50906: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50907: LD_ADDR_OWVAR 28
50911: PUSH
50912: LD_INT 17
50914: ST_TO_ADDR
// hc_gallery :=  ;
50915: LD_ADDR_OWVAR 33
50919: PUSH
50920: LD_STRING 
50922: ST_TO_ADDR
// hc_name :=  ;
50923: LD_ADDR_OWVAR 26
50927: PUSH
50928: LD_STRING 
50930: ST_TO_ADDR
// un := CreateHuman ;
50931: LD_ADDR_VAR 0 2
50935: PUSH
50936: CALL_OW 44
50940: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50941: LD_VAR 0 2
50945: PPUSH
50946: LD_INT 1
50948: PPUSH
50949: CALL_OW 51
// tmp := tmp ^ un ;
50953: LD_ADDR_VAR 0 3
50957: PUSH
50958: LD_VAR 0 3
50962: PUSH
50963: LD_VAR 0 2
50967: ADD
50968: ST_TO_ADDR
// end ;
50969: GO 50865
50971: POP
50972: POP
// repeat wait ( 0 0$1 ) ;
50973: LD_INT 35
50975: PPUSH
50976: CALL_OW 67
// for un in tmp do
50980: LD_ADDR_VAR 0 2
50984: PUSH
50985: LD_VAR 0 3
50989: PUSH
50990: FOR_IN
50991: IFFALSE 51065
// begin if IsDead ( un ) then
50993: LD_VAR 0 2
50997: PPUSH
50998: CALL_OW 301
51002: IFFALSE 51022
// begin tmp := tmp diff un ;
51004: LD_ADDR_VAR 0 3
51008: PUSH
51009: LD_VAR 0 3
51013: PUSH
51014: LD_VAR 0 2
51018: DIFF
51019: ST_TO_ADDR
// continue ;
51020: GO 50990
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51022: LD_VAR 0 2
51026: PPUSH
51027: LD_INT 3
51029: PUSH
51030: LD_INT 22
51032: PUSH
51033: LD_INT 0
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: PUSH
51040: EMPTY
51041: LIST
51042: LIST
51043: PPUSH
51044: CALL_OW 69
51048: PPUSH
51049: LD_VAR 0 2
51053: PPUSH
51054: CALL_OW 74
51058: PPUSH
51059: CALL_OW 115
// end ;
51063: GO 50990
51065: POP
51066: POP
// until not tmp ;
51067: LD_VAR 0 3
51071: NOT
51072: IFFALSE 50973
// end ;
51074: PPOPN 3
51076: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51077: LD_EXP 88
51081: PUSH
51082: LD_EXP 113
51086: AND
51087: IFFALSE 51141
51089: GO 51091
51091: DISABLE
// begin ToLua ( displayTroll(); ) ;
51092: LD_STRING displayTroll();
51094: PPUSH
51095: CALL_OW 559
// wait ( 3 3$00 ) ;
51099: LD_INT 6300
51101: PPUSH
51102: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51106: LD_STRING hideTroll();
51108: PPUSH
51109: CALL_OW 559
// wait ( 1 1$00 ) ;
51113: LD_INT 2100
51115: PPUSH
51116: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51120: LD_STRING displayTroll();
51122: PPUSH
51123: CALL_OW 559
// wait ( 1 1$00 ) ;
51127: LD_INT 2100
51129: PPUSH
51130: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51134: LD_STRING hideTroll();
51136: PPUSH
51137: CALL_OW 559
// end ;
51141: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51142: LD_EXP 88
51146: PUSH
51147: LD_EXP 114
51151: AND
51152: IFFALSE 51215
51154: GO 51156
51156: DISABLE
51157: LD_INT 0
51159: PPUSH
// begin p := 0 ;
51160: LD_ADDR_VAR 0 1
51164: PUSH
51165: LD_INT 0
51167: ST_TO_ADDR
// repeat game_speed := 1 ;
51168: LD_ADDR_OWVAR 65
51172: PUSH
51173: LD_INT 1
51175: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51176: LD_INT 35
51178: PPUSH
51179: CALL_OW 67
// p := p + 1 ;
51183: LD_ADDR_VAR 0 1
51187: PUSH
51188: LD_VAR 0 1
51192: PUSH
51193: LD_INT 1
51195: PLUS
51196: ST_TO_ADDR
// until p >= 60 ;
51197: LD_VAR 0 1
51201: PUSH
51202: LD_INT 60
51204: GREATEREQUAL
51205: IFFALSE 51168
// game_speed := 4 ;
51207: LD_ADDR_OWVAR 65
51211: PUSH
51212: LD_INT 4
51214: ST_TO_ADDR
// end ;
51215: PPOPN 1
51217: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51218: LD_EXP 88
51222: PUSH
51223: LD_EXP 115
51227: AND
51228: IFFALSE 51374
51230: GO 51232
51232: DISABLE
51233: LD_INT 0
51235: PPUSH
51236: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51237: LD_ADDR_VAR 0 1
51241: PUSH
51242: LD_INT 22
51244: PUSH
51245: LD_OWVAR 2
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: LD_INT 2
51256: PUSH
51257: LD_INT 30
51259: PUSH
51260: LD_INT 0
51262: PUSH
51263: EMPTY
51264: LIST
51265: LIST
51266: PUSH
51267: LD_INT 30
51269: PUSH
51270: LD_INT 1
51272: PUSH
51273: EMPTY
51274: LIST
51275: LIST
51276: PUSH
51277: EMPTY
51278: LIST
51279: LIST
51280: LIST
51281: PUSH
51282: EMPTY
51283: LIST
51284: LIST
51285: PPUSH
51286: CALL_OW 69
51290: ST_TO_ADDR
// if not depot then
51291: LD_VAR 0 1
51295: NOT
51296: IFFALSE 51300
// exit ;
51298: GO 51374
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51300: LD_ADDR_VAR 0 2
51304: PUSH
51305: LD_VAR 0 1
51309: PUSH
51310: LD_INT 1
51312: PPUSH
51313: LD_VAR 0 1
51317: PPUSH
51318: CALL_OW 12
51322: ARRAY
51323: PPUSH
51324: CALL_OW 274
51328: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51329: LD_VAR 0 2
51333: PPUSH
51334: LD_INT 1
51336: PPUSH
51337: LD_INT 0
51339: PPUSH
51340: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51344: LD_VAR 0 2
51348: PPUSH
51349: LD_INT 2
51351: PPUSH
51352: LD_INT 0
51354: PPUSH
51355: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51359: LD_VAR 0 2
51363: PPUSH
51364: LD_INT 3
51366: PPUSH
51367: LD_INT 0
51369: PPUSH
51370: CALL_OW 277
// end ;
51374: PPOPN 2
51376: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51377: LD_EXP 88
51381: PUSH
51382: LD_EXP 116
51386: AND
51387: IFFALSE 51484
51389: GO 51391
51391: DISABLE
51392: LD_INT 0
51394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51395: LD_ADDR_VAR 0 1
51399: PUSH
51400: LD_INT 22
51402: PUSH
51403: LD_OWVAR 2
51407: PUSH
51408: EMPTY
51409: LIST
51410: LIST
51411: PUSH
51412: LD_INT 21
51414: PUSH
51415: LD_INT 1
51417: PUSH
51418: EMPTY
51419: LIST
51420: LIST
51421: PUSH
51422: LD_INT 3
51424: PUSH
51425: LD_INT 23
51427: PUSH
51428: LD_INT 0
51430: PUSH
51431: EMPTY
51432: LIST
51433: LIST
51434: PUSH
51435: EMPTY
51436: LIST
51437: LIST
51438: PUSH
51439: EMPTY
51440: LIST
51441: LIST
51442: LIST
51443: PPUSH
51444: CALL_OW 69
51448: ST_TO_ADDR
// if not tmp then
51449: LD_VAR 0 1
51453: NOT
51454: IFFALSE 51458
// exit ;
51456: GO 51484
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51458: LD_VAR 0 1
51462: PUSH
51463: LD_INT 1
51465: PPUSH
51466: LD_VAR 0 1
51470: PPUSH
51471: CALL_OW 12
51475: ARRAY
51476: PPUSH
51477: LD_INT 200
51479: PPUSH
51480: CALL_OW 234
// end ;
51484: PPOPN 1
51486: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51487: LD_EXP 88
51491: PUSH
51492: LD_EXP 117
51496: AND
51497: IFFALSE 51576
51499: GO 51501
51501: DISABLE
51502: LD_INT 0
51504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51505: LD_ADDR_VAR 0 1
51509: PUSH
51510: LD_INT 22
51512: PUSH
51513: LD_OWVAR 2
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: PUSH
51522: LD_INT 21
51524: PUSH
51525: LD_INT 2
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: PUSH
51532: EMPTY
51533: LIST
51534: LIST
51535: PPUSH
51536: CALL_OW 69
51540: ST_TO_ADDR
// if not tmp then
51541: LD_VAR 0 1
51545: NOT
51546: IFFALSE 51550
// exit ;
51548: GO 51576
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51550: LD_VAR 0 1
51554: PUSH
51555: LD_INT 1
51557: PPUSH
51558: LD_VAR 0 1
51562: PPUSH
51563: CALL_OW 12
51567: ARRAY
51568: PPUSH
51569: LD_INT 60
51571: PPUSH
51572: CALL_OW 234
// end ;
51576: PPOPN 1
51578: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51579: LD_EXP 88
51583: PUSH
51584: LD_EXP 118
51588: AND
51589: IFFALSE 51688
51591: GO 51593
51593: DISABLE
51594: LD_INT 0
51596: PPUSH
51597: PPUSH
// begin enable ;
51598: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51599: LD_ADDR_VAR 0 1
51603: PUSH
51604: LD_INT 22
51606: PUSH
51607: LD_OWVAR 2
51611: PUSH
51612: EMPTY
51613: LIST
51614: LIST
51615: PUSH
51616: LD_INT 61
51618: PUSH
51619: EMPTY
51620: LIST
51621: PUSH
51622: LD_INT 33
51624: PUSH
51625: LD_INT 2
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: PUSH
51632: EMPTY
51633: LIST
51634: LIST
51635: LIST
51636: PPUSH
51637: CALL_OW 69
51641: ST_TO_ADDR
// if not tmp then
51642: LD_VAR 0 1
51646: NOT
51647: IFFALSE 51651
// exit ;
51649: GO 51688
// for i in tmp do
51651: LD_ADDR_VAR 0 2
51655: PUSH
51656: LD_VAR 0 1
51660: PUSH
51661: FOR_IN
51662: IFFALSE 51686
// if IsControledBy ( i ) then
51664: LD_VAR 0 2
51668: PPUSH
51669: CALL_OW 312
51673: IFFALSE 51684
// ComUnlink ( i ) ;
51675: LD_VAR 0 2
51679: PPUSH
51680: CALL_OW 136
51684: GO 51661
51686: POP
51687: POP
// end ;
51688: PPOPN 2
51690: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51691: LD_EXP 88
51695: PUSH
51696: LD_EXP 119
51700: AND
51701: IFFALSE 51841
51703: GO 51705
51705: DISABLE
51706: LD_INT 0
51708: PPUSH
51709: PPUSH
// begin ToLua ( displayPowell(); ) ;
51710: LD_STRING displayPowell();
51712: PPUSH
51713: CALL_OW 559
// uc_side := 0 ;
51717: LD_ADDR_OWVAR 20
51721: PUSH
51722: LD_INT 0
51724: ST_TO_ADDR
// uc_nation := 2 ;
51725: LD_ADDR_OWVAR 21
51729: PUSH
51730: LD_INT 2
51732: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51733: LD_ADDR_OWVAR 37
51737: PUSH
51738: LD_INT 14
51740: ST_TO_ADDR
// vc_engine := engine_siberite ;
51741: LD_ADDR_OWVAR 39
51745: PUSH
51746: LD_INT 3
51748: ST_TO_ADDR
// vc_control := control_apeman ;
51749: LD_ADDR_OWVAR 38
51753: PUSH
51754: LD_INT 5
51756: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51757: LD_ADDR_OWVAR 40
51761: PUSH
51762: LD_INT 29
51764: ST_TO_ADDR
// un := CreateVehicle ;
51765: LD_ADDR_VAR 0 2
51769: PUSH
51770: CALL_OW 45
51774: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51775: LD_VAR 0 2
51779: PPUSH
51780: LD_INT 1
51782: PPUSH
51783: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51787: LD_INT 35
51789: PPUSH
51790: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51794: LD_VAR 0 2
51798: PPUSH
51799: LD_INT 22
51801: PUSH
51802: LD_OWVAR 2
51806: PUSH
51807: EMPTY
51808: LIST
51809: LIST
51810: PPUSH
51811: CALL_OW 69
51815: PPUSH
51816: LD_VAR 0 2
51820: PPUSH
51821: CALL_OW 74
51825: PPUSH
51826: CALL_OW 115
// until IsDead ( un ) ;
51830: LD_VAR 0 2
51834: PPUSH
51835: CALL_OW 301
51839: IFFALSE 51787
// end ;
51841: PPOPN 2
51843: END
// every 0 0$1 trigger StreamModeActive and sStu do
51844: LD_EXP 88
51848: PUSH
51849: LD_EXP 127
51853: AND
51854: IFFALSE 51870
51856: GO 51858
51858: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51859: LD_STRING displayStucuk();
51861: PPUSH
51862: CALL_OW 559
// ResetFog ;
51866: CALL_OW 335
// end ;
51870: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51871: LD_EXP 88
51875: PUSH
51876: LD_EXP 120
51880: AND
51881: IFFALSE 52022
51883: GO 51885
51885: DISABLE
51886: LD_INT 0
51888: PPUSH
51889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51890: LD_ADDR_VAR 0 2
51894: PUSH
51895: LD_INT 22
51897: PUSH
51898: LD_OWVAR 2
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: PUSH
51907: LD_INT 21
51909: PUSH
51910: LD_INT 1
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PPUSH
51921: CALL_OW 69
51925: ST_TO_ADDR
// if not tmp then
51926: LD_VAR 0 2
51930: NOT
51931: IFFALSE 51935
// exit ;
51933: GO 52022
// un := tmp [ rand ( 1 , tmp ) ] ;
51935: LD_ADDR_VAR 0 1
51939: PUSH
51940: LD_VAR 0 2
51944: PUSH
51945: LD_INT 1
51947: PPUSH
51948: LD_VAR 0 2
51952: PPUSH
51953: CALL_OW 12
51957: ARRAY
51958: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51959: LD_VAR 0 1
51963: PPUSH
51964: LD_INT 0
51966: PPUSH
51967: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51971: LD_VAR 0 1
51975: PPUSH
51976: LD_OWVAR 3
51980: PUSH
51981: LD_VAR 0 1
51985: DIFF
51986: PPUSH
51987: LD_VAR 0 1
51991: PPUSH
51992: CALL_OW 74
51996: PPUSH
51997: CALL_OW 115
// wait ( 0 0$20 ) ;
52001: LD_INT 700
52003: PPUSH
52004: CALL_OW 67
// SetSide ( un , your_side ) ;
52008: LD_VAR 0 1
52012: PPUSH
52013: LD_OWVAR 2
52017: PPUSH
52018: CALL_OW 235
// end ;
52022: PPOPN 2
52024: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52025: LD_EXP 88
52029: PUSH
52030: LD_EXP 121
52034: AND
52035: IFFALSE 52141
52037: GO 52039
52039: DISABLE
52040: LD_INT 0
52042: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52043: LD_ADDR_VAR 0 1
52047: PUSH
52048: LD_INT 22
52050: PUSH
52051: LD_OWVAR 2
52055: PUSH
52056: EMPTY
52057: LIST
52058: LIST
52059: PUSH
52060: LD_INT 2
52062: PUSH
52063: LD_INT 30
52065: PUSH
52066: LD_INT 0
52068: PUSH
52069: EMPTY
52070: LIST
52071: LIST
52072: PUSH
52073: LD_INT 30
52075: PUSH
52076: LD_INT 1
52078: PUSH
52079: EMPTY
52080: LIST
52081: LIST
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: LIST
52087: PUSH
52088: EMPTY
52089: LIST
52090: LIST
52091: PPUSH
52092: CALL_OW 69
52096: ST_TO_ADDR
// if not depot then
52097: LD_VAR 0 1
52101: NOT
52102: IFFALSE 52106
// exit ;
52104: GO 52141
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52106: LD_VAR 0 1
52110: PUSH
52111: LD_INT 1
52113: ARRAY
52114: PPUSH
52115: CALL_OW 250
52119: PPUSH
52120: LD_VAR 0 1
52124: PUSH
52125: LD_INT 1
52127: ARRAY
52128: PPUSH
52129: CALL_OW 251
52133: PPUSH
52134: LD_INT 70
52136: PPUSH
52137: CALL_OW 495
// end ;
52141: PPOPN 1
52143: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52144: LD_EXP 88
52148: PUSH
52149: LD_EXP 122
52153: AND
52154: IFFALSE 52365
52156: GO 52158
52158: DISABLE
52159: LD_INT 0
52161: PPUSH
52162: PPUSH
52163: PPUSH
52164: PPUSH
52165: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52166: LD_ADDR_VAR 0 5
52170: PUSH
52171: LD_INT 22
52173: PUSH
52174: LD_OWVAR 2
52178: PUSH
52179: EMPTY
52180: LIST
52181: LIST
52182: PUSH
52183: LD_INT 21
52185: PUSH
52186: LD_INT 1
52188: PUSH
52189: EMPTY
52190: LIST
52191: LIST
52192: PUSH
52193: EMPTY
52194: LIST
52195: LIST
52196: PPUSH
52197: CALL_OW 69
52201: ST_TO_ADDR
// if not tmp then
52202: LD_VAR 0 5
52206: NOT
52207: IFFALSE 52211
// exit ;
52209: GO 52365
// for i in tmp do
52211: LD_ADDR_VAR 0 1
52215: PUSH
52216: LD_VAR 0 5
52220: PUSH
52221: FOR_IN
52222: IFFALSE 52363
// begin d := rand ( 0 , 5 ) ;
52224: LD_ADDR_VAR 0 4
52228: PUSH
52229: LD_INT 0
52231: PPUSH
52232: LD_INT 5
52234: PPUSH
52235: CALL_OW 12
52239: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52240: LD_ADDR_VAR 0 2
52244: PUSH
52245: LD_VAR 0 1
52249: PPUSH
52250: CALL_OW 250
52254: PPUSH
52255: LD_VAR 0 4
52259: PPUSH
52260: LD_INT 3
52262: PPUSH
52263: LD_INT 12
52265: PPUSH
52266: CALL_OW 12
52270: PPUSH
52271: CALL_OW 272
52275: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52276: LD_ADDR_VAR 0 3
52280: PUSH
52281: LD_VAR 0 1
52285: PPUSH
52286: CALL_OW 251
52290: PPUSH
52291: LD_VAR 0 4
52295: PPUSH
52296: LD_INT 3
52298: PPUSH
52299: LD_INT 12
52301: PPUSH
52302: CALL_OW 12
52306: PPUSH
52307: CALL_OW 273
52311: ST_TO_ADDR
// if ValidHex ( x , y ) then
52312: LD_VAR 0 2
52316: PPUSH
52317: LD_VAR 0 3
52321: PPUSH
52322: CALL_OW 488
52326: IFFALSE 52361
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52328: LD_VAR 0 1
52332: PPUSH
52333: LD_VAR 0 2
52337: PPUSH
52338: LD_VAR 0 3
52342: PPUSH
52343: LD_INT 3
52345: PPUSH
52346: LD_INT 6
52348: PPUSH
52349: CALL_OW 12
52353: PPUSH
52354: LD_INT 1
52356: PPUSH
52357: CALL_OW 483
// end ;
52361: GO 52221
52363: POP
52364: POP
// end ;
52365: PPOPN 5
52367: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52368: LD_EXP 88
52372: PUSH
52373: LD_EXP 123
52377: AND
52378: IFFALSE 52472
52380: GO 52382
52382: DISABLE
52383: LD_INT 0
52385: PPUSH
52386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52387: LD_ADDR_VAR 0 2
52391: PUSH
52392: LD_INT 22
52394: PUSH
52395: LD_OWVAR 2
52399: PUSH
52400: EMPTY
52401: LIST
52402: LIST
52403: PUSH
52404: LD_INT 32
52406: PUSH
52407: LD_INT 1
52409: PUSH
52410: EMPTY
52411: LIST
52412: LIST
52413: PUSH
52414: LD_INT 21
52416: PUSH
52417: LD_INT 2
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: PUSH
52424: EMPTY
52425: LIST
52426: LIST
52427: LIST
52428: PPUSH
52429: CALL_OW 69
52433: ST_TO_ADDR
// if not tmp then
52434: LD_VAR 0 2
52438: NOT
52439: IFFALSE 52443
// exit ;
52441: GO 52472
// for i in tmp do
52443: LD_ADDR_VAR 0 1
52447: PUSH
52448: LD_VAR 0 2
52452: PUSH
52453: FOR_IN
52454: IFFALSE 52470
// SetFuel ( i , 0 ) ;
52456: LD_VAR 0 1
52460: PPUSH
52461: LD_INT 0
52463: PPUSH
52464: CALL_OW 240
52468: GO 52453
52470: POP
52471: POP
// end ;
52472: PPOPN 2
52474: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52475: LD_EXP 88
52479: PUSH
52480: LD_EXP 124
52484: AND
52485: IFFALSE 52551
52487: GO 52489
52489: DISABLE
52490: LD_INT 0
52492: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52493: LD_ADDR_VAR 0 1
52497: PUSH
52498: LD_INT 22
52500: PUSH
52501: LD_OWVAR 2
52505: PUSH
52506: EMPTY
52507: LIST
52508: LIST
52509: PUSH
52510: LD_INT 30
52512: PUSH
52513: LD_INT 29
52515: PUSH
52516: EMPTY
52517: LIST
52518: LIST
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: PPUSH
52524: CALL_OW 69
52528: ST_TO_ADDR
// if not tmp then
52529: LD_VAR 0 1
52533: NOT
52534: IFFALSE 52538
// exit ;
52536: GO 52551
// DestroyUnit ( tmp [ 1 ] ) ;
52538: LD_VAR 0 1
52542: PUSH
52543: LD_INT 1
52545: ARRAY
52546: PPUSH
52547: CALL_OW 65
// end ;
52551: PPOPN 1
52553: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52554: LD_EXP 88
52558: PUSH
52559: LD_EXP 126
52563: AND
52564: IFFALSE 52693
52566: GO 52568
52568: DISABLE
52569: LD_INT 0
52571: PPUSH
// begin uc_side := 0 ;
52572: LD_ADDR_OWVAR 20
52576: PUSH
52577: LD_INT 0
52579: ST_TO_ADDR
// uc_nation := nation_arabian ;
52580: LD_ADDR_OWVAR 21
52584: PUSH
52585: LD_INT 2
52587: ST_TO_ADDR
// hc_gallery :=  ;
52588: LD_ADDR_OWVAR 33
52592: PUSH
52593: LD_STRING 
52595: ST_TO_ADDR
// hc_name :=  ;
52596: LD_ADDR_OWVAR 26
52600: PUSH
52601: LD_STRING 
52603: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52604: LD_INT 1
52606: PPUSH
52607: LD_INT 11
52609: PPUSH
52610: LD_INT 10
52612: PPUSH
52613: CALL_OW 380
// un := CreateHuman ;
52617: LD_ADDR_VAR 0 1
52621: PUSH
52622: CALL_OW 44
52626: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52627: LD_VAR 0 1
52631: PPUSH
52632: LD_INT 1
52634: PPUSH
52635: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52639: LD_INT 35
52641: PPUSH
52642: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52646: LD_VAR 0 1
52650: PPUSH
52651: LD_INT 22
52653: PUSH
52654: LD_OWVAR 2
52658: PUSH
52659: EMPTY
52660: LIST
52661: LIST
52662: PPUSH
52663: CALL_OW 69
52667: PPUSH
52668: LD_VAR 0 1
52672: PPUSH
52673: CALL_OW 74
52677: PPUSH
52678: CALL_OW 115
// until IsDead ( un ) ;
52682: LD_VAR 0 1
52686: PPUSH
52687: CALL_OW 301
52691: IFFALSE 52639
// end ;
52693: PPOPN 1
52695: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52696: LD_EXP 88
52700: PUSH
52701: LD_EXP 128
52705: AND
52706: IFFALSE 52718
52708: GO 52710
52710: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52711: LD_STRING earthquake(getX(game), 0, 32)
52713: PPUSH
52714: CALL_OW 559
52718: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52719: LD_EXP 88
52723: PUSH
52724: LD_EXP 129
52728: AND
52729: IFFALSE 52820
52731: GO 52733
52733: DISABLE
52734: LD_INT 0
52736: PPUSH
// begin enable ;
52737: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52738: LD_ADDR_VAR 0 1
52742: PUSH
52743: LD_INT 22
52745: PUSH
52746: LD_OWVAR 2
52750: PUSH
52751: EMPTY
52752: LIST
52753: LIST
52754: PUSH
52755: LD_INT 21
52757: PUSH
52758: LD_INT 2
52760: PUSH
52761: EMPTY
52762: LIST
52763: LIST
52764: PUSH
52765: LD_INT 33
52767: PUSH
52768: LD_INT 3
52770: PUSH
52771: EMPTY
52772: LIST
52773: LIST
52774: PUSH
52775: EMPTY
52776: LIST
52777: LIST
52778: LIST
52779: PPUSH
52780: CALL_OW 69
52784: ST_TO_ADDR
// if not tmp then
52785: LD_VAR 0 1
52789: NOT
52790: IFFALSE 52794
// exit ;
52792: GO 52820
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52794: LD_VAR 0 1
52798: PUSH
52799: LD_INT 1
52801: PPUSH
52802: LD_VAR 0 1
52806: PPUSH
52807: CALL_OW 12
52811: ARRAY
52812: PPUSH
52813: LD_INT 1
52815: PPUSH
52816: CALL_OW 234
// end ;
52820: PPOPN 1
52822: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52823: LD_EXP 88
52827: PUSH
52828: LD_EXP 130
52832: AND
52833: IFFALSE 52974
52835: GO 52837
52837: DISABLE
52838: LD_INT 0
52840: PPUSH
52841: PPUSH
52842: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52843: LD_ADDR_VAR 0 3
52847: PUSH
52848: LD_INT 22
52850: PUSH
52851: LD_OWVAR 2
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: PUSH
52860: LD_INT 25
52862: PUSH
52863: LD_INT 1
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: PPUSH
52874: CALL_OW 69
52878: ST_TO_ADDR
// if not tmp then
52879: LD_VAR 0 3
52883: NOT
52884: IFFALSE 52888
// exit ;
52886: GO 52974
// un := tmp [ rand ( 1 , tmp ) ] ;
52888: LD_ADDR_VAR 0 2
52892: PUSH
52893: LD_VAR 0 3
52897: PUSH
52898: LD_INT 1
52900: PPUSH
52901: LD_VAR 0 3
52905: PPUSH
52906: CALL_OW 12
52910: ARRAY
52911: ST_TO_ADDR
// if Crawls ( un ) then
52912: LD_VAR 0 2
52916: PPUSH
52917: CALL_OW 318
52921: IFFALSE 52932
// ComWalk ( un ) ;
52923: LD_VAR 0 2
52927: PPUSH
52928: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52932: LD_VAR 0 2
52936: PPUSH
52937: LD_INT 9
52939: PPUSH
52940: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52944: LD_INT 28
52946: PPUSH
52947: LD_OWVAR 2
52951: PPUSH
52952: LD_INT 2
52954: PPUSH
52955: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52959: LD_INT 29
52961: PPUSH
52962: LD_OWVAR 2
52966: PPUSH
52967: LD_INT 2
52969: PPUSH
52970: CALL_OW 322
// end ;
52974: PPOPN 3
52976: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52977: LD_EXP 88
52981: PUSH
52982: LD_EXP 131
52986: AND
52987: IFFALSE 53098
52989: GO 52991
52991: DISABLE
52992: LD_INT 0
52994: PPUSH
52995: PPUSH
52996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52997: LD_ADDR_VAR 0 3
53001: PUSH
53002: LD_INT 22
53004: PUSH
53005: LD_OWVAR 2
53009: PUSH
53010: EMPTY
53011: LIST
53012: LIST
53013: PUSH
53014: LD_INT 25
53016: PUSH
53017: LD_INT 1
53019: PUSH
53020: EMPTY
53021: LIST
53022: LIST
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: PPUSH
53028: CALL_OW 69
53032: ST_TO_ADDR
// if not tmp then
53033: LD_VAR 0 3
53037: NOT
53038: IFFALSE 53042
// exit ;
53040: GO 53098
// un := tmp [ rand ( 1 , tmp ) ] ;
53042: LD_ADDR_VAR 0 2
53046: PUSH
53047: LD_VAR 0 3
53051: PUSH
53052: LD_INT 1
53054: PPUSH
53055: LD_VAR 0 3
53059: PPUSH
53060: CALL_OW 12
53064: ARRAY
53065: ST_TO_ADDR
// if Crawls ( un ) then
53066: LD_VAR 0 2
53070: PPUSH
53071: CALL_OW 318
53075: IFFALSE 53086
// ComWalk ( un ) ;
53077: LD_VAR 0 2
53081: PPUSH
53082: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53086: LD_VAR 0 2
53090: PPUSH
53091: LD_INT 8
53093: PPUSH
53094: CALL_OW 336
// end ;
53098: PPOPN 3
53100: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53101: LD_EXP 88
53105: PUSH
53106: LD_EXP 132
53110: AND
53111: IFFALSE 53255
53113: GO 53115
53115: DISABLE
53116: LD_INT 0
53118: PPUSH
53119: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53120: LD_ADDR_VAR 0 2
53124: PUSH
53125: LD_INT 22
53127: PUSH
53128: LD_OWVAR 2
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: PUSH
53137: LD_INT 21
53139: PUSH
53140: LD_INT 2
53142: PUSH
53143: EMPTY
53144: LIST
53145: LIST
53146: PUSH
53147: LD_INT 2
53149: PUSH
53150: LD_INT 34
53152: PUSH
53153: LD_INT 12
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PUSH
53160: LD_INT 34
53162: PUSH
53163: LD_INT 51
53165: PUSH
53166: EMPTY
53167: LIST
53168: LIST
53169: PUSH
53170: LD_INT 34
53172: PUSH
53173: LD_INT 32
53175: PUSH
53176: EMPTY
53177: LIST
53178: LIST
53179: PUSH
53180: EMPTY
53181: LIST
53182: LIST
53183: LIST
53184: LIST
53185: PUSH
53186: EMPTY
53187: LIST
53188: LIST
53189: LIST
53190: PPUSH
53191: CALL_OW 69
53195: ST_TO_ADDR
// if not tmp then
53196: LD_VAR 0 2
53200: NOT
53201: IFFALSE 53205
// exit ;
53203: GO 53255
// for i in tmp do
53205: LD_ADDR_VAR 0 1
53209: PUSH
53210: LD_VAR 0 2
53214: PUSH
53215: FOR_IN
53216: IFFALSE 53253
// if GetCargo ( i , mat_artifact ) = 0 then
53218: LD_VAR 0 1
53222: PPUSH
53223: LD_INT 4
53225: PPUSH
53226: CALL_OW 289
53230: PUSH
53231: LD_INT 0
53233: EQUAL
53234: IFFALSE 53251
// SetCargo ( i , mat_siberit , 100 ) ;
53236: LD_VAR 0 1
53240: PPUSH
53241: LD_INT 3
53243: PPUSH
53244: LD_INT 100
53246: PPUSH
53247: CALL_OW 290
53251: GO 53215
53253: POP
53254: POP
// end ;
53255: PPOPN 2
53257: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53258: LD_EXP 88
53262: PUSH
53263: LD_EXP 133
53267: AND
53268: IFFALSE 53451
53270: GO 53272
53272: DISABLE
53273: LD_INT 0
53275: PPUSH
53276: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53277: LD_ADDR_VAR 0 2
53281: PUSH
53282: LD_INT 22
53284: PUSH
53285: LD_OWVAR 2
53289: PUSH
53290: EMPTY
53291: LIST
53292: LIST
53293: PPUSH
53294: CALL_OW 69
53298: ST_TO_ADDR
// if not tmp then
53299: LD_VAR 0 2
53303: NOT
53304: IFFALSE 53308
// exit ;
53306: GO 53451
// for i := 1 to 2 do
53308: LD_ADDR_VAR 0 1
53312: PUSH
53313: DOUBLE
53314: LD_INT 1
53316: DEC
53317: ST_TO_ADDR
53318: LD_INT 2
53320: PUSH
53321: FOR_TO
53322: IFFALSE 53449
// begin uc_side := your_side ;
53324: LD_ADDR_OWVAR 20
53328: PUSH
53329: LD_OWVAR 2
53333: ST_TO_ADDR
// uc_nation := nation_american ;
53334: LD_ADDR_OWVAR 21
53338: PUSH
53339: LD_INT 1
53341: ST_TO_ADDR
// vc_chassis := us_morphling ;
53342: LD_ADDR_OWVAR 37
53346: PUSH
53347: LD_INT 5
53349: ST_TO_ADDR
// vc_engine := engine_siberite ;
53350: LD_ADDR_OWVAR 39
53354: PUSH
53355: LD_INT 3
53357: ST_TO_ADDR
// vc_control := control_computer ;
53358: LD_ADDR_OWVAR 38
53362: PUSH
53363: LD_INT 3
53365: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53366: LD_ADDR_OWVAR 40
53370: PUSH
53371: LD_INT 10
53373: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53374: LD_VAR 0 2
53378: PUSH
53379: LD_INT 1
53381: ARRAY
53382: PPUSH
53383: CALL_OW 310
53387: NOT
53388: IFFALSE 53435
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53390: CALL_OW 45
53394: PPUSH
53395: LD_VAR 0 2
53399: PUSH
53400: LD_INT 1
53402: ARRAY
53403: PPUSH
53404: CALL_OW 250
53408: PPUSH
53409: LD_VAR 0 2
53413: PUSH
53414: LD_INT 1
53416: ARRAY
53417: PPUSH
53418: CALL_OW 251
53422: PPUSH
53423: LD_INT 12
53425: PPUSH
53426: LD_INT 1
53428: PPUSH
53429: CALL_OW 50
53433: GO 53447
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53435: CALL_OW 45
53439: PPUSH
53440: LD_INT 1
53442: PPUSH
53443: CALL_OW 51
// end ;
53447: GO 53321
53449: POP
53450: POP
// end ;
53451: PPOPN 2
53453: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53454: LD_EXP 88
53458: PUSH
53459: LD_EXP 134
53463: AND
53464: IFFALSE 53686
53466: GO 53468
53468: DISABLE
53469: LD_INT 0
53471: PPUSH
53472: PPUSH
53473: PPUSH
53474: PPUSH
53475: PPUSH
53476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53477: LD_ADDR_VAR 0 6
53481: PUSH
53482: LD_INT 22
53484: PUSH
53485: LD_OWVAR 2
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: PUSH
53494: LD_INT 21
53496: PUSH
53497: LD_INT 1
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: PUSH
53504: LD_INT 3
53506: PUSH
53507: LD_INT 23
53509: PUSH
53510: LD_INT 0
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: LIST
53525: PPUSH
53526: CALL_OW 69
53530: ST_TO_ADDR
// if not tmp then
53531: LD_VAR 0 6
53535: NOT
53536: IFFALSE 53540
// exit ;
53538: GO 53686
// s1 := rand ( 1 , 4 ) ;
53540: LD_ADDR_VAR 0 2
53544: PUSH
53545: LD_INT 1
53547: PPUSH
53548: LD_INT 4
53550: PPUSH
53551: CALL_OW 12
53555: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53556: LD_ADDR_VAR 0 4
53560: PUSH
53561: LD_VAR 0 6
53565: PUSH
53566: LD_INT 1
53568: ARRAY
53569: PPUSH
53570: LD_VAR 0 2
53574: PPUSH
53575: CALL_OW 259
53579: ST_TO_ADDR
// if s1 = 1 then
53580: LD_VAR 0 2
53584: PUSH
53585: LD_INT 1
53587: EQUAL
53588: IFFALSE 53608
// s2 := rand ( 2 , 4 ) else
53590: LD_ADDR_VAR 0 3
53594: PUSH
53595: LD_INT 2
53597: PPUSH
53598: LD_INT 4
53600: PPUSH
53601: CALL_OW 12
53605: ST_TO_ADDR
53606: GO 53616
// s2 := 1 ;
53608: LD_ADDR_VAR 0 3
53612: PUSH
53613: LD_INT 1
53615: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53616: LD_ADDR_VAR 0 5
53620: PUSH
53621: LD_VAR 0 6
53625: PUSH
53626: LD_INT 1
53628: ARRAY
53629: PPUSH
53630: LD_VAR 0 3
53634: PPUSH
53635: CALL_OW 259
53639: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53640: LD_VAR 0 6
53644: PUSH
53645: LD_INT 1
53647: ARRAY
53648: PPUSH
53649: LD_VAR 0 2
53653: PPUSH
53654: LD_VAR 0 5
53658: PPUSH
53659: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53663: LD_VAR 0 6
53667: PUSH
53668: LD_INT 1
53670: ARRAY
53671: PPUSH
53672: LD_VAR 0 3
53676: PPUSH
53677: LD_VAR 0 4
53681: PPUSH
53682: CALL_OW 237
// end ;
53686: PPOPN 6
53688: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53689: LD_EXP 88
53693: PUSH
53694: LD_EXP 135
53698: AND
53699: IFFALSE 53778
53701: GO 53703
53703: DISABLE
53704: LD_INT 0
53706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53707: LD_ADDR_VAR 0 1
53711: PUSH
53712: LD_INT 22
53714: PUSH
53715: LD_OWVAR 2
53719: PUSH
53720: EMPTY
53721: LIST
53722: LIST
53723: PUSH
53724: LD_INT 30
53726: PUSH
53727: LD_INT 3
53729: PUSH
53730: EMPTY
53731: LIST
53732: LIST
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: PPUSH
53738: CALL_OW 69
53742: ST_TO_ADDR
// if not tmp then
53743: LD_VAR 0 1
53747: NOT
53748: IFFALSE 53752
// exit ;
53750: GO 53778
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53752: LD_VAR 0 1
53756: PUSH
53757: LD_INT 1
53759: PPUSH
53760: LD_VAR 0 1
53764: PPUSH
53765: CALL_OW 12
53769: ARRAY
53770: PPUSH
53771: LD_INT 1
53773: PPUSH
53774: CALL_OW 234
// end ;
53778: PPOPN 1
53780: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53781: LD_EXP 88
53785: PUSH
53786: LD_EXP 136
53790: AND
53791: IFFALSE 53903
53793: GO 53795
53795: DISABLE
53796: LD_INT 0
53798: PPUSH
53799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53800: LD_ADDR_VAR 0 2
53804: PUSH
53805: LD_INT 22
53807: PUSH
53808: LD_OWVAR 2
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PUSH
53817: LD_INT 2
53819: PUSH
53820: LD_INT 30
53822: PUSH
53823: LD_INT 27
53825: PUSH
53826: EMPTY
53827: LIST
53828: LIST
53829: PUSH
53830: LD_INT 30
53832: PUSH
53833: LD_INT 26
53835: PUSH
53836: EMPTY
53837: LIST
53838: LIST
53839: PUSH
53840: LD_INT 30
53842: PUSH
53843: LD_INT 28
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: LIST
53854: LIST
53855: PUSH
53856: EMPTY
53857: LIST
53858: LIST
53859: PPUSH
53860: CALL_OW 69
53864: ST_TO_ADDR
// if not tmp then
53865: LD_VAR 0 2
53869: NOT
53870: IFFALSE 53874
// exit ;
53872: GO 53903
// for i in tmp do
53874: LD_ADDR_VAR 0 1
53878: PUSH
53879: LD_VAR 0 2
53883: PUSH
53884: FOR_IN
53885: IFFALSE 53901
// SetLives ( i , 1 ) ;
53887: LD_VAR 0 1
53891: PPUSH
53892: LD_INT 1
53894: PPUSH
53895: CALL_OW 234
53899: GO 53884
53901: POP
53902: POP
// end ;
53903: PPOPN 2
53905: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53906: LD_EXP 88
53910: PUSH
53911: LD_EXP 137
53915: AND
53916: IFFALSE 54190
53918: GO 53920
53920: DISABLE
53921: LD_INT 0
53923: PPUSH
53924: PPUSH
53925: PPUSH
// begin i := rand ( 1 , 7 ) ;
53926: LD_ADDR_VAR 0 1
53930: PUSH
53931: LD_INT 1
53933: PPUSH
53934: LD_INT 7
53936: PPUSH
53937: CALL_OW 12
53941: ST_TO_ADDR
// case i of 1 :
53942: LD_VAR 0 1
53946: PUSH
53947: LD_INT 1
53949: DOUBLE
53950: EQUAL
53951: IFTRUE 53955
53953: GO 53965
53955: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53956: LD_STRING earthquake(getX(game), 0, 32)
53958: PPUSH
53959: CALL_OW 559
53963: GO 54190
53965: LD_INT 2
53967: DOUBLE
53968: EQUAL
53969: IFTRUE 53973
53971: GO 53987
53973: POP
// begin ToLua ( displayStucuk(); ) ;
53974: LD_STRING displayStucuk();
53976: PPUSH
53977: CALL_OW 559
// ResetFog ;
53981: CALL_OW 335
// end ; 3 :
53985: GO 54190
53987: LD_INT 3
53989: DOUBLE
53990: EQUAL
53991: IFTRUE 53995
53993: GO 54099
53995: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53996: LD_ADDR_VAR 0 2
54000: PUSH
54001: LD_INT 22
54003: PUSH
54004: LD_OWVAR 2
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: PUSH
54013: LD_INT 25
54015: PUSH
54016: LD_INT 1
54018: PUSH
54019: EMPTY
54020: LIST
54021: LIST
54022: PUSH
54023: EMPTY
54024: LIST
54025: LIST
54026: PPUSH
54027: CALL_OW 69
54031: ST_TO_ADDR
// if not tmp then
54032: LD_VAR 0 2
54036: NOT
54037: IFFALSE 54041
// exit ;
54039: GO 54190
// un := tmp [ rand ( 1 , tmp ) ] ;
54041: LD_ADDR_VAR 0 3
54045: PUSH
54046: LD_VAR 0 2
54050: PUSH
54051: LD_INT 1
54053: PPUSH
54054: LD_VAR 0 2
54058: PPUSH
54059: CALL_OW 12
54063: ARRAY
54064: ST_TO_ADDR
// if Crawls ( un ) then
54065: LD_VAR 0 3
54069: PPUSH
54070: CALL_OW 318
54074: IFFALSE 54085
// ComWalk ( un ) ;
54076: LD_VAR 0 3
54080: PPUSH
54081: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54085: LD_VAR 0 3
54089: PPUSH
54090: LD_INT 8
54092: PPUSH
54093: CALL_OW 336
// end ; 4 :
54097: GO 54190
54099: LD_INT 4
54101: DOUBLE
54102: EQUAL
54103: IFTRUE 54107
54105: GO 54168
54107: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54108: LD_ADDR_VAR 0 2
54112: PUSH
54113: LD_INT 22
54115: PUSH
54116: LD_OWVAR 2
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: PUSH
54125: LD_INT 30
54127: PUSH
54128: LD_INT 29
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: PPUSH
54139: CALL_OW 69
54143: ST_TO_ADDR
// if not tmp then
54144: LD_VAR 0 2
54148: NOT
54149: IFFALSE 54153
// exit ;
54151: GO 54190
// DestroyUnit ( tmp [ 1 ] ) ;
54153: LD_VAR 0 2
54157: PUSH
54158: LD_INT 1
54160: ARRAY
54161: PPUSH
54162: CALL_OW 65
// end ; 5 .. 7 :
54166: GO 54190
54168: LD_INT 5
54170: DOUBLE
54171: GREATEREQUAL
54172: IFFALSE 54180
54174: LD_INT 7
54176: DOUBLE
54177: LESSEQUAL
54178: IFTRUE 54182
54180: GO 54189
54182: POP
// StreamSibBomb ; end ;
54183: CALL 50440 0 0
54187: GO 54190
54189: POP
// end ;
54190: PPOPN 3
54192: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54193: LD_EXP 88
54197: PUSH
54198: LD_EXP 138
54202: AND
54203: IFFALSE 54359
54205: GO 54207
54207: DISABLE
54208: LD_INT 0
54210: PPUSH
54211: PPUSH
54212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54213: LD_ADDR_VAR 0 2
54217: PUSH
54218: LD_INT 81
54220: PUSH
54221: LD_OWVAR 2
54225: PUSH
54226: EMPTY
54227: LIST
54228: LIST
54229: PUSH
54230: LD_INT 2
54232: PUSH
54233: LD_INT 21
54235: PUSH
54236: LD_INT 1
54238: PUSH
54239: EMPTY
54240: LIST
54241: LIST
54242: PUSH
54243: LD_INT 21
54245: PUSH
54246: LD_INT 2
54248: PUSH
54249: EMPTY
54250: LIST
54251: LIST
54252: PUSH
54253: EMPTY
54254: LIST
54255: LIST
54256: LIST
54257: PUSH
54258: EMPTY
54259: LIST
54260: LIST
54261: PPUSH
54262: CALL_OW 69
54266: ST_TO_ADDR
// if not tmp then
54267: LD_VAR 0 2
54271: NOT
54272: IFFALSE 54276
// exit ;
54274: GO 54359
// p := 0 ;
54276: LD_ADDR_VAR 0 3
54280: PUSH
54281: LD_INT 0
54283: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54284: LD_INT 35
54286: PPUSH
54287: CALL_OW 67
// p := p + 1 ;
54291: LD_ADDR_VAR 0 3
54295: PUSH
54296: LD_VAR 0 3
54300: PUSH
54301: LD_INT 1
54303: PLUS
54304: ST_TO_ADDR
// for i in tmp do
54305: LD_ADDR_VAR 0 1
54309: PUSH
54310: LD_VAR 0 2
54314: PUSH
54315: FOR_IN
54316: IFFALSE 54347
// if GetLives ( i ) < 1000 then
54318: LD_VAR 0 1
54322: PPUSH
54323: CALL_OW 256
54327: PUSH
54328: LD_INT 1000
54330: LESS
54331: IFFALSE 54345
// SetLives ( i , 1000 ) ;
54333: LD_VAR 0 1
54337: PPUSH
54338: LD_INT 1000
54340: PPUSH
54341: CALL_OW 234
54345: GO 54315
54347: POP
54348: POP
// until p > 20 ;
54349: LD_VAR 0 3
54353: PUSH
54354: LD_INT 20
54356: GREATER
54357: IFFALSE 54284
// end ;
54359: PPOPN 3
54361: END
// every 0 0$1 trigger StreamModeActive and sTime do
54362: LD_EXP 88
54366: PUSH
54367: LD_EXP 139
54371: AND
54372: IFFALSE 54407
54374: GO 54376
54376: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54377: LD_INT 28
54379: PPUSH
54380: LD_OWVAR 2
54384: PPUSH
54385: LD_INT 2
54387: PPUSH
54388: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54392: LD_INT 30
54394: PPUSH
54395: LD_OWVAR 2
54399: PPUSH
54400: LD_INT 2
54402: PPUSH
54403: CALL_OW 322
// end ;
54407: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54408: LD_EXP 88
54412: PUSH
54413: LD_EXP 140
54417: AND
54418: IFFALSE 54539
54420: GO 54422
54422: DISABLE
54423: LD_INT 0
54425: PPUSH
54426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54427: LD_ADDR_VAR 0 2
54431: PUSH
54432: LD_INT 22
54434: PUSH
54435: LD_OWVAR 2
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: PUSH
54444: LD_INT 21
54446: PUSH
54447: LD_INT 1
54449: PUSH
54450: EMPTY
54451: LIST
54452: LIST
54453: PUSH
54454: LD_INT 3
54456: PUSH
54457: LD_INT 23
54459: PUSH
54460: LD_INT 0
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: PUSH
54467: EMPTY
54468: LIST
54469: LIST
54470: PUSH
54471: EMPTY
54472: LIST
54473: LIST
54474: LIST
54475: PPUSH
54476: CALL_OW 69
54480: ST_TO_ADDR
// if not tmp then
54481: LD_VAR 0 2
54485: NOT
54486: IFFALSE 54490
// exit ;
54488: GO 54539
// for i in tmp do
54490: LD_ADDR_VAR 0 1
54494: PUSH
54495: LD_VAR 0 2
54499: PUSH
54500: FOR_IN
54501: IFFALSE 54537
// begin if Crawls ( i ) then
54503: LD_VAR 0 1
54507: PPUSH
54508: CALL_OW 318
54512: IFFALSE 54523
// ComWalk ( i ) ;
54514: LD_VAR 0 1
54518: PPUSH
54519: CALL_OW 138
// SetClass ( i , 2 ) ;
54523: LD_VAR 0 1
54527: PPUSH
54528: LD_INT 2
54530: PPUSH
54531: CALL_OW 336
// end ;
54535: GO 54500
54537: POP
54538: POP
// end ;
54539: PPOPN 2
54541: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54542: LD_EXP 88
54546: PUSH
54547: LD_EXP 141
54551: AND
54552: IFFALSE 54833
54554: GO 54556
54556: DISABLE
54557: LD_INT 0
54559: PPUSH
54560: PPUSH
54561: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54562: LD_OWVAR 2
54566: PPUSH
54567: LD_INT 9
54569: PPUSH
54570: LD_INT 1
54572: PPUSH
54573: LD_INT 1
54575: PPUSH
54576: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54580: LD_INT 9
54582: PPUSH
54583: LD_OWVAR 2
54587: PPUSH
54588: CALL_OW 343
// uc_side := 9 ;
54592: LD_ADDR_OWVAR 20
54596: PUSH
54597: LD_INT 9
54599: ST_TO_ADDR
// uc_nation := 2 ;
54600: LD_ADDR_OWVAR 21
54604: PUSH
54605: LD_INT 2
54607: ST_TO_ADDR
// hc_name := Dark Warrior ;
54608: LD_ADDR_OWVAR 26
54612: PUSH
54613: LD_STRING Dark Warrior
54615: ST_TO_ADDR
// hc_gallery :=  ;
54616: LD_ADDR_OWVAR 33
54620: PUSH
54621: LD_STRING 
54623: ST_TO_ADDR
// hc_noskilllimit := true ;
54624: LD_ADDR_OWVAR 76
54628: PUSH
54629: LD_INT 1
54631: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54632: LD_ADDR_OWVAR 31
54636: PUSH
54637: LD_INT 30
54639: PUSH
54640: LD_INT 30
54642: PUSH
54643: LD_INT 30
54645: PUSH
54646: LD_INT 30
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: LIST
54653: LIST
54654: ST_TO_ADDR
// un := CreateHuman ;
54655: LD_ADDR_VAR 0 3
54659: PUSH
54660: CALL_OW 44
54664: ST_TO_ADDR
// hc_noskilllimit := false ;
54665: LD_ADDR_OWVAR 76
54669: PUSH
54670: LD_INT 0
54672: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54673: LD_VAR 0 3
54677: PPUSH
54678: LD_INT 1
54680: PPUSH
54681: CALL_OW 51
// p := 0 ;
54685: LD_ADDR_VAR 0 2
54689: PUSH
54690: LD_INT 0
54692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54693: LD_INT 35
54695: PPUSH
54696: CALL_OW 67
// p := p + 1 ;
54700: LD_ADDR_VAR 0 2
54704: PUSH
54705: LD_VAR 0 2
54709: PUSH
54710: LD_INT 1
54712: PLUS
54713: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54714: LD_VAR 0 3
54718: PPUSH
54719: CALL_OW 256
54723: PUSH
54724: LD_INT 1000
54726: LESS
54727: IFFALSE 54741
// SetLives ( un , 1000 ) ;
54729: LD_VAR 0 3
54733: PPUSH
54734: LD_INT 1000
54736: PPUSH
54737: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54741: LD_VAR 0 3
54745: PPUSH
54746: LD_INT 81
54748: PUSH
54749: LD_OWVAR 2
54753: PUSH
54754: EMPTY
54755: LIST
54756: LIST
54757: PUSH
54758: LD_INT 91
54760: PUSH
54761: LD_VAR 0 3
54765: PUSH
54766: LD_INT 30
54768: PUSH
54769: EMPTY
54770: LIST
54771: LIST
54772: LIST
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: PPUSH
54778: CALL_OW 69
54782: PPUSH
54783: LD_VAR 0 3
54787: PPUSH
54788: CALL_OW 74
54792: PPUSH
54793: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54797: LD_VAR 0 2
54801: PUSH
54802: LD_INT 60
54804: GREATER
54805: PUSH
54806: LD_VAR 0 3
54810: PPUSH
54811: CALL_OW 301
54815: OR
54816: IFFALSE 54693
// if un then
54818: LD_VAR 0 3
54822: IFFALSE 54833
// RemoveUnit ( un ) ;
54824: LD_VAR 0 3
54828: PPUSH
54829: CALL_OW 64
// end ; end_of_file
54833: PPOPN 3
54835: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
54836: LD_INT 0
54838: PPUSH
54839: PPUSH
54840: PPUSH
54841: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
54842: LD_VAR 0 1
54846: PPUSH
54847: CALL_OW 264
54851: PUSH
54852: LD_EXP 79
54856: EQUAL
54857: IFFALSE 54929
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
54859: LD_INT 68
54861: PPUSH
54862: LD_VAR 0 1
54866: PPUSH
54867: CALL_OW 255
54871: PPUSH
54872: CALL_OW 321
54876: PUSH
54877: LD_INT 2
54879: EQUAL
54880: IFFALSE 54892
// eff := 70 else
54882: LD_ADDR_VAR 0 4
54886: PUSH
54887: LD_INT 70
54889: ST_TO_ADDR
54890: GO 54900
// eff := 30 ;
54892: LD_ADDR_VAR 0 4
54896: PUSH
54897: LD_INT 30
54899: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
54900: LD_VAR 0 1
54904: PPUSH
54905: CALL_OW 250
54909: PPUSH
54910: LD_VAR 0 1
54914: PPUSH
54915: CALL_OW 251
54919: PPUSH
54920: LD_VAR 0 4
54924: PPUSH
54925: CALL_OW 495
// end ; end ;
54929: LD_VAR 0 2
54933: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
54934: LD_INT 0
54936: PPUSH
// end ;
54937: LD_VAR 0 4
54941: RET
// export function SOS_Command ( cmd ) ; begin
54942: LD_INT 0
54944: PPUSH
// end ;
54945: LD_VAR 0 2
54949: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
54950: LD_VAR 0 1
54954: PUSH
54955: LD_INT 255
54957: EQUAL
54958: PUSH
54959: LD_VAR 0 2
54963: PPUSH
54964: CALL_OW 264
54968: PUSH
54969: LD_INT 14
54971: PUSH
54972: LD_INT 53
54974: PUSH
54975: EMPTY
54976: LIST
54977: LIST
54978: IN
54979: AND
54980: PUSH
54981: LD_VAR 0 4
54985: PPUSH
54986: LD_VAR 0 5
54990: PPUSH
54991: CALL_OW 488
54995: AND
54996: IFFALSE 55020
// CutTreeXYR ( unit , x , y , 12 ) ;
54998: LD_VAR 0 2
55002: PPUSH
55003: LD_VAR 0 4
55007: PPUSH
55008: LD_VAR 0 5
55012: PPUSH
55013: LD_INT 12
55015: PPUSH
55016: CALL 55023 0 4
// end ;
55020: PPOPN 5
55022: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
55023: LD_INT 0
55025: PPUSH
55026: PPUSH
55027: PPUSH
55028: PPUSH
55029: PPUSH
55030: PPUSH
55031: PPUSH
55032: PPUSH
55033: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
55034: LD_VAR 0 1
55038: NOT
55039: PUSH
55040: LD_VAR 0 2
55044: PPUSH
55045: LD_VAR 0 3
55049: PPUSH
55050: CALL_OW 488
55054: NOT
55055: OR
55056: PUSH
55057: LD_VAR 0 4
55061: NOT
55062: OR
55063: IFFALSE 55067
// exit ;
55065: GO 55407
// list := [ ] ;
55067: LD_ADDR_VAR 0 13
55071: PUSH
55072: EMPTY
55073: ST_TO_ADDR
// if x - r < 0 then
55074: LD_VAR 0 2
55078: PUSH
55079: LD_VAR 0 4
55083: MINUS
55084: PUSH
55085: LD_INT 0
55087: LESS
55088: IFFALSE 55100
// min_x := 0 else
55090: LD_ADDR_VAR 0 7
55094: PUSH
55095: LD_INT 0
55097: ST_TO_ADDR
55098: GO 55116
// min_x := x - r ;
55100: LD_ADDR_VAR 0 7
55104: PUSH
55105: LD_VAR 0 2
55109: PUSH
55110: LD_VAR 0 4
55114: MINUS
55115: ST_TO_ADDR
// if y - r < 0 then
55116: LD_VAR 0 3
55120: PUSH
55121: LD_VAR 0 4
55125: MINUS
55126: PUSH
55127: LD_INT 0
55129: LESS
55130: IFFALSE 55142
// min_y := 0 else
55132: LD_ADDR_VAR 0 8
55136: PUSH
55137: LD_INT 0
55139: ST_TO_ADDR
55140: GO 55158
// min_y := y - r ;
55142: LD_ADDR_VAR 0 8
55146: PUSH
55147: LD_VAR 0 3
55151: PUSH
55152: LD_VAR 0 4
55156: MINUS
55157: ST_TO_ADDR
// max_x := x + r ;
55158: LD_ADDR_VAR 0 9
55162: PUSH
55163: LD_VAR 0 2
55167: PUSH
55168: LD_VAR 0 4
55172: PLUS
55173: ST_TO_ADDR
// max_y := y + r ;
55174: LD_ADDR_VAR 0 10
55178: PUSH
55179: LD_VAR 0 3
55183: PUSH
55184: LD_VAR 0 4
55188: PLUS
55189: ST_TO_ADDR
// for _x = min_x to max_x do
55190: LD_ADDR_VAR 0 11
55194: PUSH
55195: DOUBLE
55196: LD_VAR 0 7
55200: DEC
55201: ST_TO_ADDR
55202: LD_VAR 0 9
55206: PUSH
55207: FOR_TO
55208: IFFALSE 55325
// for _y = min_y to max_y do
55210: LD_ADDR_VAR 0 12
55214: PUSH
55215: DOUBLE
55216: LD_VAR 0 8
55220: DEC
55221: ST_TO_ADDR
55222: LD_VAR 0 10
55226: PUSH
55227: FOR_TO
55228: IFFALSE 55321
// begin if not ValidHex ( _x , _y ) then
55230: LD_VAR 0 11
55234: PPUSH
55235: LD_VAR 0 12
55239: PPUSH
55240: CALL_OW 488
55244: NOT
55245: IFFALSE 55249
// continue ;
55247: GO 55227
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
55249: LD_VAR 0 11
55253: PPUSH
55254: LD_VAR 0 12
55258: PPUSH
55259: CALL_OW 351
55263: PUSH
55264: LD_VAR 0 11
55268: PPUSH
55269: LD_VAR 0 12
55273: PPUSH
55274: CALL_OW 554
55278: AND
55279: IFFALSE 55319
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
55281: LD_ADDR_VAR 0 13
55285: PUSH
55286: LD_VAR 0 13
55290: PPUSH
55291: LD_VAR 0 13
55295: PUSH
55296: LD_INT 1
55298: PLUS
55299: PPUSH
55300: LD_VAR 0 11
55304: PUSH
55305: LD_VAR 0 12
55309: PUSH
55310: EMPTY
55311: LIST
55312: LIST
55313: PPUSH
55314: CALL_OW 2
55318: ST_TO_ADDR
// end ;
55319: GO 55227
55321: POP
55322: POP
55323: GO 55207
55325: POP
55326: POP
// if not list then
55327: LD_VAR 0 13
55331: NOT
55332: IFFALSE 55336
// exit ;
55334: GO 55407
// for i in list do
55336: LD_ADDR_VAR 0 6
55340: PUSH
55341: LD_VAR 0 13
55345: PUSH
55346: FOR_IN
55347: IFFALSE 55405
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
55349: LD_VAR 0 1
55353: PPUSH
55354: LD_STRING M
55356: PUSH
55357: LD_VAR 0 6
55361: PUSH
55362: LD_INT 1
55364: ARRAY
55365: PUSH
55366: LD_VAR 0 6
55370: PUSH
55371: LD_INT 2
55373: ARRAY
55374: PUSH
55375: LD_INT 0
55377: PUSH
55378: LD_INT 0
55380: PUSH
55381: LD_INT 0
55383: PUSH
55384: LD_INT 0
55386: PUSH
55387: EMPTY
55388: LIST
55389: LIST
55390: LIST
55391: LIST
55392: LIST
55393: LIST
55394: LIST
55395: PUSH
55396: EMPTY
55397: LIST
55398: PPUSH
55399: CALL_OW 447
55403: GO 55346
55405: POP
55406: POP
// end ;
55407: LD_VAR 0 5
55411: RET
