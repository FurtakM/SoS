// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41683 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42134 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31775 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31775 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31775 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32238 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42053 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43001 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41962 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41962 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32238 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32238 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32238 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 68470 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31291 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31291 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31291 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31291 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32284 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41962 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31132 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41962 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31132 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41962 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31132 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41962 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31132 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41962 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42053 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41962 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41962 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41962 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41962 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41962 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41962 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41962 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41962 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41962 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41962 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41962 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41962 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31132 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31132 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31132 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31132 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31132 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31132 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31132 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31132 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31132 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31132 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31132 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31132 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32063 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31291 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31775 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31775 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32165 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42053 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41962 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41962 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41962 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41962 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42053 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28640: LD_EXP 39
28644: PUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL_OW 255
28654: ARRAY
28655: IFFALSE 29382
// begin side := GetSide ( veh ) ;
28657: LD_ADDR_VAR 0 4
28661: PUSH
28662: LD_VAR 0 1
28666: PPUSH
28667: CALL_OW 255
28671: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28672: LD_ADDR_VAR 0 6
28676: PUSH
28677: LD_VAR 0 1
28681: PPUSH
28682: CALL_OW 265
28686: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28687: LD_ADDR_VAR 0 7
28691: PUSH
28692: LD_VAR 0 1
28696: PPUSH
28697: CALL_OW 262
28701: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28702: LD_ADDR_VAR 0 8
28706: PUSH
28707: LD_VAR 0 1
28711: PPUSH
28712: CALL_OW 263
28716: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28717: LD_ADDR_VAR 0 9
28721: PUSH
28722: LD_VAR 0 1
28726: PPUSH
28727: CALL_OW 264
28731: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28732: LD_STRING VehicleConstructed [side: 
28734: PUSH
28735: LD_VAR 0 4
28739: STR
28740: PUSH
28741: LD_STRING ; id:
28743: STR
28744: PUSH
28745: LD_VAR 0 1
28749: STR
28750: PUSH
28751: LD_STRING ; components: [
28753: STR
28754: PUSH
28755: LD_VAR 0 6
28759: STR
28760: PUSH
28761: LD_STRING , 
28763: STR
28764: PUSH
28765: LD_VAR 0 7
28769: STR
28770: PUSH
28771: LD_STRING , 
28773: STR
28774: PUSH
28775: LD_VAR 0 8
28779: STR
28780: PUSH
28781: LD_STRING , 
28783: STR
28784: PUSH
28785: LD_VAR 0 9
28789: STR
28790: PUSH
28791: LD_STRING ]]
28793: STR
28794: PPUSH
28795: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28799: LD_VAR 0 1
28803: PPUSH
28804: CALL_OW 264
28808: PUSH
28809: LD_INT 13
28811: PUSH
28812: LD_INT 12
28814: PUSH
28815: LD_INT 14
28817: PUSH
28818: LD_INT 51
28820: PUSH
28821: LD_INT 53
28823: PUSH
28824: LD_INT 52
28826: PUSH
28827: LD_INT 32
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: IN
28839: NOT
28840: IFFALSE 28882
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28842: LD_ADDR_EXP 59
28846: PUSH
28847: LD_EXP 59
28851: PPUSH
28852: LD_VAR 0 4
28856: PPUSH
28857: LD_EXP 59
28861: PUSH
28862: LD_VAR 0 4
28866: ARRAY
28867: PUSH
28868: LD_INT 1
28870: PLUS
28871: PPUSH
28872: LD_VAR 0 1
28876: PPUSH
28877: CALL 31132 0 4
28881: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28882: LD_VAR 0 1
28886: PPUSH
28887: CALL_OW 264
28891: PUSH
28892: LD_INT 31
28894: EQUAL
28895: IFFALSE 28914
// SetTag ( GetDriver ( veh ) , 9 ) ;
28897: LD_VAR 0 1
28901: PPUSH
28902: CALL 31775 0 1
28906: PPUSH
28907: LD_INT 9
28909: PPUSH
28910: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28914: LD_VAR 0 1
28918: PPUSH
28919: CALL_OW 264
28923: PUSH
28924: LD_INT 14
28926: PUSH
28927: LD_INT 53
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: IN
28934: IFFALSE 28971
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28936: LD_ADDR_EXP 42
28940: PUSH
28941: LD_EXP 42
28945: PPUSH
28946: LD_VAR 0 1
28950: PPUSH
28951: CALL_OW 255
28955: PPUSH
28956: LD_INT 2
28958: PPUSH
28959: LD_VAR 0 1
28963: PPUSH
28964: CALL 31132 0 4
28968: ST_TO_ADDR
// exit ;
28969: GO 29382
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 265
28980: PUSH
28981: LD_EXP 66
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: PUSH
28997: LD_VAR 0 1
29001: PPUSH
29002: CALL_OW 262
29006: PUSH
29007: LD_EXP 66
29011: PUSH
29012: LD_VAR 0 4
29016: ARRAY
29017: PUSH
29018: LD_INT 1
29020: ARRAY
29021: IN
29022: AND
29023: PUSH
29024: LD_VAR 0 1
29028: PPUSH
29029: CALL_OW 263
29033: PUSH
29034: LD_EXP 66
29038: PUSH
29039: LD_VAR 0 4
29043: ARRAY
29044: PUSH
29045: LD_INT 1
29047: ARRAY
29048: IN
29049: AND
29050: PUSH
29051: LD_VAR 0 1
29055: PPUSH
29056: CALL_OW 264
29060: PUSH
29061: LD_EXP 66
29065: PUSH
29066: LD_VAR 0 4
29070: ARRAY
29071: PUSH
29072: LD_INT 1
29074: ARRAY
29075: IN
29076: AND
29077: IFFALSE 29121
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29079: LD_ADDR_EXP 67
29083: PUSH
29084: LD_EXP 67
29088: PPUSH
29089: LD_VAR 0 4
29093: PPUSH
29094: LD_EXP 67
29098: PUSH
29099: LD_VAR 0 4
29103: ARRAY
29104: PUSH
29105: LD_INT 1
29107: PLUS
29108: PPUSH
29109: LD_VAR 0 1
29113: PPUSH
29114: CALL 31132 0 4
29118: ST_TO_ADDR
// exit ;
29119: GO 29382
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29121: LD_VAR 0 6
29125: PUSH
29126: LD_EXP 69
29130: PUSH
29131: LD_VAR 0 4
29135: ARRAY
29136: PUSH
29137: LD_INT 1
29139: ARRAY
29140: EQUAL
29141: PUSH
29142: LD_VAR 0 7
29146: PUSH
29147: LD_EXP 69
29151: PUSH
29152: LD_VAR 0 4
29156: ARRAY
29157: PUSH
29158: LD_INT 2
29160: ARRAY
29161: EQUAL
29162: AND
29163: PUSH
29164: LD_VAR 0 8
29168: PUSH
29169: LD_EXP 69
29173: PUSH
29174: LD_VAR 0 4
29178: ARRAY
29179: PUSH
29180: LD_INT 3
29182: ARRAY
29183: EQUAL
29184: AND
29185: PUSH
29186: LD_VAR 0 9
29190: PUSH
29191: LD_EXP 69
29195: PUSH
29196: LD_VAR 0 4
29200: ARRAY
29201: PUSH
29202: LD_INT 4
29204: ARRAY
29205: EQUAL
29206: AND
29207: IFFALSE 29363
// begin tmp := MREG_ToAttack [ side ] ;
29209: LD_ADDR_VAR 0 5
29213: PUSH
29214: LD_EXP 69
29218: PUSH
29219: LD_VAR 0 4
29223: ARRAY
29224: ST_TO_ADDR
// for i = 1 to 4 do
29225: LD_ADDR_VAR 0 3
29229: PUSH
29230: DOUBLE
29231: LD_INT 1
29233: DEC
29234: ST_TO_ADDR
29235: LD_INT 4
29237: PUSH
29238: FOR_TO
29239: IFFALSE 29261
// tmp := Delete ( tmp , 1 ) ;
29241: LD_ADDR_VAR 0 5
29245: PUSH
29246: LD_VAR 0 5
29250: PPUSH
29251: LD_INT 1
29253: PPUSH
29254: CALL_OW 3
29258: ST_TO_ADDR
29259: GO 29238
29261: POP
29262: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29263: LD_ADDR_EXP 69
29267: PUSH
29268: LD_EXP 69
29272: PPUSH
29273: LD_VAR 0 4
29277: PPUSH
29278: LD_VAR 0 5
29282: PPUSH
29283: CALL_OW 1
29287: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29288: LD_ADDR_EXP 71
29292: PUSH
29293: LD_EXP 71
29297: PPUSH
29298: LD_VAR 0 4
29302: PPUSH
29303: LD_EXP 71
29307: PUSH
29308: LD_VAR 0 4
29312: ARRAY
29313: PUSH
29314: LD_INT 1
29316: PLUS
29317: PPUSH
29318: LD_VAR 0 1
29322: PPUSH
29323: CALL 31132 0 4
29327: ST_TO_ADDR
// if tmp = 0 then
29328: LD_VAR 0 5
29332: PUSH
29333: LD_INT 0
29335: EQUAL
29336: IFFALSE 29361
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29338: LD_ADDR_EXP 69
29342: PUSH
29343: LD_EXP 69
29347: PPUSH
29348: LD_VAR 0 4
29352: PPUSH
29353: LD_INT 0
29355: PPUSH
29356: CALL_OW 1
29360: ST_TO_ADDR
// exit ;
29361: GO 29382
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29363: LD_VAR 0 1
29367: PPUSH
29368: CALL_OW 255
29372: PPUSH
29373: LD_VAR 0 1
29377: PPUSH
29378: CALL 25757 0 2
// end ;
29382: PPOPN 9
29384: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29385: LD_EXP 39
29389: PUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: ARRAY
29400: IFFALSE 29632
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29402: LD_STRING ApemanTamed [side: 
29404: PUSH
29405: LD_VAR 0 2
29409: PPUSH
29410: CALL_OW 255
29414: STR
29415: PUSH
29416: LD_STRING ; sci: 
29418: STR
29419: PUSH
29420: LD_VAR 0 2
29424: STR
29425: PUSH
29426: LD_STRING ; ape: 
29428: STR
29429: PUSH
29430: LD_VAR 0 1
29434: STR
29435: PUSH
29436: LD_STRING ]
29438: STR
29439: PPUSH
29440: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29444: LD_INT 11
29446: PPUSH
29447: LD_VAR 0 2
29451: PPUSH
29452: CALL_OW 255
29456: PPUSH
29457: CALL_OW 321
29461: PUSH
29462: LD_INT 2
29464: EQUAL
29465: NOT
29466: PUSH
29467: LD_INT 2
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: CALL_OW 255
29479: PPUSH
29480: CALL_OW 321
29484: PUSH
29485: LD_INT 2
29487: EQUAL
29488: NOT
29489: OR
29490: PUSH
29491: LD_VAR 0 2
29495: PPUSH
29496: CALL_OW 255
29500: PPUSH
29501: LD_INT 171
29503: PPUSH
29504: EMPTY
29505: PPUSH
29506: CALL 12370 0 3
29510: PUSH
29511: LD_INT 0
29513: EQUAL
29514: AND
29515: IFFALSE 29529
// begin SetTag ( ape , 171 ) ;
29517: LD_VAR 0 1
29521: PPUSH
29522: LD_INT 171
29524: PPUSH
29525: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29529: LD_VAR 0 2
29533: PPUSH
29534: CALL_OW 255
29538: PPUSH
29539: LD_INT 30
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PPUSH
29549: CALL 11667 0 2
29553: IFFALSE 29632
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29555: LD_VAR 0 1
29559: PPUSH
29560: LD_VAR 0 2
29564: PPUSH
29565: CALL_OW 255
29569: PPUSH
29570: LD_INT 30
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PPUSH
29580: CALL 11667 0 2
29584: PUSH
29585: LD_INT 1
29587: ARRAY
29588: PPUSH
29589: CALL_OW 250
29593: PPUSH
29594: LD_VAR 0 2
29598: PPUSH
29599: CALL_OW 255
29603: PPUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL 11667 0 2
29618: PUSH
29619: LD_INT 1
29621: ARRAY
29622: PPUSH
29623: CALL_OW 251
29627: PPUSH
29628: CALL_OW 111
// end ;
29632: PPOPN 2
29634: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29635: LD_EXP 39
29639: PUSH
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 255
29649: ARRAY
29650: IFFALSE 29928
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29652: LD_VAR 0 2
29656: PUSH
29657: LD_VAR 0 2
29661: PPUSH
29662: CALL_OW 255
29666: PPUSH
29667: CALL 12080 0 1
29671: IN
29672: IFFALSE 29813
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 266
29683: PUSH
29684: LD_INT 0
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: IFFALSE 29724
// begin Wait ( 0 0$0.3 ) ;
29696: LD_INT 10
29698: PPUSH
29699: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29703: LD_VAR 0 2
29707: PPUSH
29708: LD_INT 16
29710: PPUSH
29711: CALL_OW 336
// ComExitBuilding ( un ) ;
29715: LD_VAR 0 2
29719: PPUSH
29720: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29724: LD_VAR 0 1
29728: PPUSH
29729: CALL_OW 266
29733: PUSH
29734: LD_INT 4
29736: PUSH
29737: LD_INT 5
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: IN
29744: IFFALSE 29813
// begin Wait ( 0 0$0.3 ) ;
29746: LD_INT 10
29748: PPUSH
29749: CALL_OW 67
// if GetTag ( un ) = 0 then
29753: LD_VAR 0 2
29757: PPUSH
29758: CALL_OW 110
29762: PUSH
29763: LD_INT 0
29765: EQUAL
29766: IFFALSE 29782
// SetClass ( un , class_apeman_soldier ) else
29768: LD_VAR 0 2
29772: PPUSH
29773: LD_INT 15
29775: PPUSH
29776: CALL_OW 336
29780: GO 29813
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29782: LD_INT 3
29784: PPUSH
29785: LD_VAR 0 2
29789: PPUSH
29790: CALL_OW 255
29794: PPUSH
29795: CALL_OW 321
29799: IFFALSE 29813
// SetClass ( un , class_apeman_kamikaze ) ;
29801: LD_VAR 0 2
29805: PPUSH
29806: LD_INT 17
29808: PPUSH
29809: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29813: LD_VAR 0 1
29817: PPUSH
29818: CALL_OW 266
29822: PUSH
29823: LD_INT 32
29825: EQUAL
29826: IFFALSE 29928
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29828: LD_ADDR_EXP 68
29832: PUSH
29833: LD_EXP 68
29837: PPUSH
29838: LD_VAR 0 1
29842: PPUSH
29843: CALL_OW 255
29847: PPUSH
29848: LD_EXP 68
29852: PUSH
29853: LD_VAR 0 1
29857: PPUSH
29858: CALL_OW 255
29862: ARRAY
29863: PUSH
29864: LD_INT 1
29866: PLUS
29867: PPUSH
29868: LD_VAR 0 1
29872: PPUSH
29873: CALL 31132 0 4
29877: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29878: LD_ADDR_EXP 68
29882: PUSH
29883: LD_EXP 68
29887: PPUSH
29888: LD_VAR 0 1
29892: PPUSH
29893: CALL_OW 255
29897: PPUSH
29898: LD_EXP 68
29902: PUSH
29903: LD_VAR 0 1
29907: PPUSH
29908: CALL_OW 255
29912: ARRAY
29913: PUSH
29914: LD_INT 1
29916: PLUS
29917: PPUSH
29918: LD_VAR 0 2
29922: PPUSH
29923: CALL 31132 0 4
29927: ST_TO_ADDR
// end ; end ;
29928: PPOPN 2
29930: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29931: LD_VAR 0 1
29935: PPUSH
29936: CALL 56606 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29940: LD_VAR 0 1
29944: PUSH
29945: LD_INT 22
29947: PUSH
29948: LD_INT 3
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 23
29957: PUSH
29958: LD_INT 3
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 21
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: LIST
29979: PPUSH
29980: CALL_OW 69
29984: IN
29985: IFFALSE 30001
// player_loss := player_loss + 1 ;
29987: LD_ADDR_EXP 10
29991: PUSH
29992: LD_EXP 10
29996: PUSH
29997: LD_INT 1
29999: PLUS
30000: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30001: LD_VAR 0 1
30005: PUSH
30006: LD_INT 22
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 21
30018: PUSH
30019: LD_INT 3
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PPUSH
30030: CALL_OW 69
30034: IN
30035: PUSH
30036: LD_EXP 14
30040: NOT
30041: AND
30042: IFFALSE 30105
// begin alfa_north_triggered := true ;
30044: LD_ADDR_EXP 14
30048: PUSH
30049: LD_INT 1
30051: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30052: LD_EXP 5
30056: PPUSH
30057: LD_STRING DS4
30059: PPUSH
30060: CALL_OW 94
// Wait ( 1 1$25 ) ;
30064: LD_INT 2975
30066: PPUSH
30067: CALL_OW 67
// if not isTest then
30071: LD_EXP 1
30075: NOT
30076: IFFALSE 30105
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30078: LD_INT 20
30080: PPUSH
30081: LD_INT 5
30083: PUSH
30084: LD_INT 6
30086: PUSH
30087: LD_INT 7
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: LIST
30094: PUSH
30095: LD_OWVAR 67
30099: ARRAY
30100: PPUSH
30101: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30105: LD_VAR 0 1
30109: PUSH
30110: LD_INT 22
30112: PUSH
30113: LD_INT 4
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 21
30122: PUSH
30123: LD_INT 3
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PPUSH
30134: CALL_OW 69
30138: IN
30139: PUSH
30140: LD_EXP 15
30144: NOT
30145: AND
30146: IFFALSE 30209
// begin alfa_south_triggered := true ;
30148: LD_ADDR_EXP 15
30152: PUSH
30153: LD_INT 1
30155: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30156: LD_EXP 4
30160: PPUSH
30161: LD_STRING DJ3
30163: PPUSH
30164: CALL_OW 94
// Wait ( 0 0$45 ) ;
30168: LD_INT 1575
30170: PPUSH
30171: CALL_OW 67
// if not isTest then
30175: LD_EXP 1
30179: NOT
30180: IFFALSE 30209
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30182: LD_INT 20
30184: PPUSH
30185: LD_INT 5
30187: PUSH
30188: LD_INT 6
30190: PUSH
30191: LD_INT 7
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: LIST
30198: PUSH
30199: LD_OWVAR 67
30203: ARRAY
30204: PPUSH
30205: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30209: LD_VAR 0 1
30213: PPUSH
30214: CALL_OW 266
30218: PUSH
30219: LD_INT 1
30221: EQUAL
30222: PUSH
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 255
30232: PUSH
30233: LD_INT 1
30235: PUSH
30236: LD_INT 4
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: IN
30243: AND
30244: IFFALSE 30253
// RaiseSailEvent ( 104 ) ;
30246: LD_INT 104
30248: PPUSH
30249: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30253: LD_EXP 39
30257: PUSH
30258: LD_VAR 0 1
30262: PPUSH
30263: CALL_OW 255
30267: ARRAY
30268: IFFALSE 30655
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30270: LD_STRING UnitDestroyed [side 
30272: PUSH
30273: LD_VAR 0 1
30277: PPUSH
30278: CALL_OW 255
30282: STR
30283: PUSH
30284: LD_STRING ; id: 
30286: STR
30287: PUSH
30288: LD_VAR 0 1
30292: STR
30293: PUSH
30294: LD_STRING ; type: 
30296: STR
30297: PUSH
30298: LD_VAR 0 1
30302: PPUSH
30303: CALL_OW 247
30307: STR
30308: PUSH
30309: LD_STRING ]
30311: STR
30312: PPUSH
30313: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30317: LD_VAR 0 1
30321: PUSH
30322: LD_VAR 0 1
30326: PPUSH
30327: CALL_OW 255
30331: PPUSH
30332: LD_INT 21
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PPUSH
30342: CALL 11667 0 2
30346: IN
30347: IFFALSE 30503
// begin if MCF_HasClass ( un ) then
30349: LD_VAR 0 1
30353: PPUSH
30354: CALL 14373 0 1
30358: IFFALSE 30503
// case MCF_HasClass ( un ) of 1 :
30360: LD_VAR 0 1
30364: PPUSH
30365: CALL 14373 0 1
30369: PUSH
30370: LD_INT 1
30372: DOUBLE
30373: EQUAL
30374: IFTRUE 30378
30376: GO 30403
30378: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30379: LD_VAR 0 1
30383: PPUSH
30384: CALL_OW 255
30388: PPUSH
30389: LD_STRING ToArm
30391: PPUSH
30392: LD_VAR 0 1
30396: PPUSH
30397: CALL 14546 0 3
30401: GO 30503
30403: LD_INT 2
30405: DOUBLE
30406: EQUAL
30407: IFTRUE 30411
30409: GO 30436
30411: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30412: LD_VAR 0 1
30416: PPUSH
30417: CALL_OW 255
30421: PPUSH
30422: LD_STRING ToDep
30424: PPUSH
30425: LD_VAR 0 1
30429: PPUSH
30430: CALL 14546 0 3
30434: GO 30503
30436: LD_INT 3
30438: DOUBLE
30439: EQUAL
30440: IFTRUE 30444
30442: GO 30469
30444: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30445: LD_VAR 0 1
30449: PPUSH
30450: CALL_OW 255
30454: PPUSH
30455: LD_STRING ToFac
30457: PPUSH
30458: LD_VAR 0 1
30462: PPUSH
30463: CALL 14546 0 3
30467: GO 30503
30469: LD_INT 4
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30502
30477: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30478: LD_VAR 0 1
30482: PPUSH
30483: CALL_OW 255
30487: PPUSH
30488: LD_STRING ToLab
30490: PPUSH
30491: LD_VAR 0 1
30495: PPUSH
30496: CALL 14546 0 3
30500: GO 30503
30502: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30503: LD_VAR 0 1
30507: PUSH
30508: LD_EXP 67
30512: PUSH
30513: LD_VAR 0 1
30517: PPUSH
30518: CALL_OW 255
30522: ARRAY
30523: IN
30524: IFFALSE 30609
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30526: LD_ADDR_EXP 67
30530: PUSH
30531: LD_EXP 67
30535: PPUSH
30536: LD_VAR 0 1
30540: PPUSH
30541: LD_INT 0
30543: PPUSH
30544: CALL 31291 0 3
30548: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30549: LD_VAR 0 1
30553: PPUSH
30554: CALL_OW 255
30558: PPUSH
30559: LD_VAR 0 1
30563: PPUSH
30564: CALL_OW 265
30568: PUSH
30569: LD_VAR 0 1
30573: PPUSH
30574: CALL_OW 262
30578: PUSH
30579: LD_VAR 0 1
30583: PPUSH
30584: CALL_OW 263
30588: PUSH
30589: LD_VAR 0 1
30593: PPUSH
30594: CALL_OW 264
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: PPUSH
30605: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30609: LD_VAR 0 1
30613: PUSH
30614: LD_EXP 71
30618: PUSH
30619: LD_VAR 0 1
30623: PPUSH
30624: CALL_OW 255
30628: ARRAY
30629: IN
30630: IFFALSE 30655
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30632: LD_ADDR_EXP 71
30636: PUSH
30637: LD_EXP 71
30641: PPUSH
30642: LD_VAR 0 1
30646: PPUSH
30647: LD_INT 0
30649: PPUSH
30650: CALL 31291 0 3
30654: ST_TO_ADDR
// end ; end ;
30655: PPOPN 1
30657: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30658: LD_EXP 39
30662: PUSH
30663: LD_VAR 0 2
30667: PPUSH
30668: CALL_OW 255
30672: ARRAY
30673: IFFALSE 30845
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30675: LD_VAR 0 2
30679: PUSH
30680: LD_EXP 68
30684: PUSH
30685: LD_VAR 0 2
30689: PPUSH
30690: CALL_OW 255
30694: ARRAY
30695: IN
30696: PUSH
30697: LD_VAR 0 1
30701: PPUSH
30702: CALL_OW 266
30706: PUSH
30707: LD_INT 32
30709: PUSH
30710: LD_INT 31
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: IN
30717: AND
30718: IFFALSE 30818
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30720: LD_ADDR_EXP 68
30724: PUSH
30725: LD_EXP 68
30729: PPUSH
30730: LD_VAR 0 1
30734: PPUSH
30735: LD_INT 0
30737: PPUSH
30738: CALL 31291 0 3
30742: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30743: LD_ADDR_EXP 68
30747: PUSH
30748: LD_EXP 68
30752: PPUSH
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL 31291 0 3
30765: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30766: LD_EXP 68
30770: PUSH
30771: LD_VAR 0 2
30775: PPUSH
30776: CALL_OW 255
30780: ARRAY
30781: PUSH
30782: LD_STRING 
30784: EQUAL
30785: IFFALSE 30818
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30787: LD_ADDR_EXP 68
30791: PUSH
30792: LD_EXP 68
30796: PPUSH
30797: LD_VAR 0 2
30801: PPUSH
30802: CALL_OW 255
30806: PPUSH
30807: LD_INT 1
30809: PPUSH
30810: LD_INT 0
30812: PPUSH
30813: CALL 31132 0 4
30817: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30818: LD_VAR 0 1
30822: PPUSH
30823: CALL_OW 266
30827: PUSH
30828: LD_INT 36
30830: IN
30831: IFFALSE 30845
// SetTag ( un , 0 ) ;
30833: LD_VAR 0 2
30837: PPUSH
30838: LD_INT 0
30840: PPUSH
30841: CALL_OW 109
// end ;
30845: PPOPN 2
30847: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30848: LD_EXP 39
30852: PUSH
30853: LD_VAR 0 1
30857: PPUSH
30858: CALL_OW 255
30862: ARRAY
30863: IFFALSE 30889
// begin if GetControl ( un ) = control_remote then
30865: LD_VAR 0 1
30869: PPUSH
30870: CALL_OW 263
30874: PUSH
30875: LD_INT 2
30877: EQUAL
30878: IFFALSE 30889
// ComUnlink ( un ) ;
30880: LD_VAR 0 1
30884: PPUSH
30885: CALL_OW 136
// end ;
30889: PPOPN 1
30891: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30892: LD_EXP 39
30896: PUSH
30897: LD_VAR 0 1
30901: PPUSH
30902: CALL_OW 255
30906: ARRAY
30907: IFFALSE 30936
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30909: LD_VAR 0 2
30913: PPUSH
30914: CALL_OW 264
30918: PUSH
30919: LD_INT 31
30921: IN
30922: IFFALSE 30936
// SetTag ( driver , 0 ) ;
30924: LD_VAR 0 1
30928: PPUSH
30929: LD_INT 0
30931: PPUSH
30932: CALL_OW 109
// end ;
30936: PPOPN 4
30938: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30939: LD_INT 0
30941: PPUSH
30942: PPUSH
30943: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30944: LD_ADDR_VAR 0 3
30948: PUSH
30949: LD_VAR 0 1
30953: PPUSH
30954: CALL_OW 269
30958: ST_TO_ADDR
// x := GetX ( building ) ;
30959: LD_ADDR_VAR 0 4
30963: PUSH
30964: LD_VAR 0 1
30968: PPUSH
30969: CALL_OW 250
30973: ST_TO_ADDR
// y := GetY ( building ) ;
30974: LD_ADDR_VAR 0 5
30978: PUSH
30979: LD_VAR 0 1
30983: PPUSH
30984: CALL_OW 251
30988: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30989: LD_ADDR_EXP 43
30993: PUSH
30994: LD_EXP 43
30998: PPUSH
30999: LD_VAR 0 1
31003: PPUSH
31004: CALL_OW 255
31008: PPUSH
31009: LD_VAR 0 3
31013: PPUSH
31014: LD_VAR 0 4
31018: PUSH
31019: LD_VAR 0 5
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PPUSH
31028: CALL 42053 0 4
31032: ST_TO_ADDR
// end ;
31033: PPOPN 5
31035: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31036: LD_VAR 0 1
31040: PUSH
31041: LD_EXP 30
31045: IN
31046: NOT
31047: IFFALSE 31095
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31049: LD_ADDR_EXP 30
31053: PUSH
31054: LD_EXP 30
31058: PPUSH
31059: LD_EXP 30
31063: PUSH
31064: LD_INT 1
31066: PLUS
31067: PPUSH
31068: LD_VAR 0 1
31072: PPUSH
31073: CALL_OW 2
31077: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31078: LD_STRING DestinationUnrechable. [unit: 
31080: PUSH
31081: LD_VAR 0 1
31085: STR
31086: PUSH
31087: LD_STRING ]
31089: STR
31090: PPUSH
31091: CALL 8055 0 1
// end ; end ;
31095: PPOPN 1
31097: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31098: LD_VAR 0 1
31102: PPUSH
31103: LD_VAR 0 2
31107: PPUSH
31108: LD_VAR 0 3
31112: PPUSH
31113: CALL 56704 0 3
// end ;
31117: PPOPN 3
31119: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31120: LD_VAR 0 1
31124: PPUSH
31125: CALL 56712 0 1
// end ; end_of_file
31129: PPOPN 1
31131: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31132: LD_INT 0
31134: PPUSH
31135: PPUSH
31136: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31137: LD_ADDR_VAR 0 7
31141: PUSH
31142: LD_VAR 0 1
31146: PUSH
31147: LD_VAR 0 2
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 3
31157: PPUSH
31158: LD_VAR 0 4
31162: PPUSH
31163: CALL_OW 1
31167: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31168: LD_ADDR_VAR 0 1
31172: PUSH
31173: LD_VAR 0 1
31177: PPUSH
31178: LD_VAR 0 2
31182: PPUSH
31183: LD_VAR 0 7
31187: PPUSH
31188: CALL_OW 1
31192: ST_TO_ADDR
// result := tab ;
31193: LD_ADDR_VAR 0 5
31197: PUSH
31198: LD_VAR 0 1
31202: ST_TO_ADDR
// end ;
31203: LD_VAR 0 5
31207: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31208: LD_INT 0
31210: PPUSH
31211: PPUSH
31212: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31213: LD_ADDR_VAR 0 5
31217: PUSH
31218: LD_VAR 0 1
31222: PUSH
31223: LD_VAR 0 2
31227: PUSH
31228: LD_INT 1
31230: ARRAY
31231: ARRAY
31232: PPUSH
31233: LD_VAR 0 2
31237: PUSH
31238: LD_INT 2
31240: ARRAY
31241: PPUSH
31242: CALL_OW 3
31246: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31247: LD_ADDR_VAR 0 1
31251: PUSH
31252: LD_VAR 0 1
31256: PPUSH
31257: LD_VAR 0 2
31261: PUSH
31262: LD_INT 1
31264: ARRAY
31265: PPUSH
31266: LD_VAR 0 5
31270: PPUSH
31271: CALL_OW 1
31275: ST_TO_ADDR
// result := tab ;
31276: LD_ADDR_VAR 0 3
31280: PUSH
31281: LD_VAR 0 1
31285: ST_TO_ADDR
// end ;
31286: LD_VAR 0 3
31290: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31291: LD_INT 0
31293: PPUSH
31294: PPUSH
31295: PPUSH
31296: PPUSH
// i := 1 ;
31297: LD_ADDR_VAR 0 5
31301: PUSH
31302: LD_INT 1
31304: ST_TO_ADDR
// while ( i <= tab ) do
31305: LD_VAR 0 5
31309: PUSH
31310: LD_VAR 0 1
31314: LESSEQUAL
31315: IFFALSE 31690
// begin if not tab [ i ] then
31317: LD_VAR 0 1
31321: PUSH
31322: LD_VAR 0 5
31326: ARRAY
31327: NOT
31328: IFFALSE 31332
// break ;
31330: GO 31690
// if value in tab then
31332: LD_VAR 0 2
31336: PUSH
31337: LD_VAR 0 1
31341: IN
31342: IFFALSE 31455
// begin if not mode then
31344: LD_VAR 0 3
31348: NOT
31349: IFFALSE 31369
// tab := tab diff value else
31351: LD_ADDR_VAR 0 1
31355: PUSH
31356: LD_VAR 0 1
31360: PUSH
31361: LD_VAR 0 2
31365: DIFF
31366: ST_TO_ADDR
31367: GO 31431
// for j = 1 to tab do
31369: LD_ADDR_VAR 0 6
31373: PUSH
31374: DOUBLE
31375: LD_INT 1
31377: DEC
31378: ST_TO_ADDR
31379: LD_VAR 0 1
31383: PUSH
31384: FOR_TO
31385: IFFALSE 31429
// if tab [ j ] = value then
31387: LD_VAR 0 1
31391: PUSH
31392: LD_VAR 0 6
31396: ARRAY
31397: PUSH
31398: LD_VAR 0 2
31402: EQUAL
31403: IFFALSE 31427
// begin tab := Delete ( tab , j ) ;
31405: LD_ADDR_VAR 0 1
31409: PUSH
31410: LD_VAR 0 1
31414: PPUSH
31415: LD_VAR 0 6
31419: PPUSH
31420: CALL_OW 3
31424: ST_TO_ADDR
// break ;
31425: GO 31429
// end ;
31427: GO 31384
31429: POP
31430: POP
// i := i - 1 ;
31431: LD_ADDR_VAR 0 5
31435: PUSH
31436: LD_VAR 0 5
31440: PUSH
31441: LD_INT 1
31443: MINUS
31444: ST_TO_ADDR
// if mode then
31445: LD_VAR 0 3
31449: IFFALSE 31453
// break ;
31451: GO 31690
// end else
31453: GO 31674
// if tab [ i ] and value in tab [ i ] then
31455: LD_VAR 0 1
31459: PUSH
31460: LD_VAR 0 5
31464: ARRAY
31465: PUSH
31466: LD_VAR 0 2
31470: PUSH
31471: LD_VAR 0 1
31475: PUSH
31476: LD_VAR 0 5
31480: ARRAY
31481: IN
31482: AND
31483: IFFALSE 31674
// begin if not mode then
31485: LD_VAR 0 3
31489: NOT
31490: IFFALSE 31516
// tmp := tab [ i ] diff value else
31492: LD_ADDR_VAR 0 7
31496: PUSH
31497: LD_VAR 0 1
31501: PUSH
31502: LD_VAR 0 5
31506: ARRAY
31507: PUSH
31508: LD_VAR 0 2
31512: DIFF
31513: ST_TO_ADDR
31514: GO 31596
// for j = 1 to tab [ i ] do
31516: LD_ADDR_VAR 0 6
31520: PUSH
31521: DOUBLE
31522: LD_INT 1
31524: DEC
31525: ST_TO_ADDR
31526: LD_VAR 0 1
31530: PUSH
31531: LD_VAR 0 5
31535: ARRAY
31536: PUSH
31537: FOR_TO
31538: IFFALSE 31594
// if value = tab [ i ] [ j ] then
31540: LD_VAR 0 2
31544: PUSH
31545: LD_VAR 0 1
31549: PUSH
31550: LD_VAR 0 5
31554: ARRAY
31555: PUSH
31556: LD_VAR 0 6
31560: ARRAY
31561: EQUAL
31562: IFFALSE 31592
// begin tmp := Delete ( tab [ i ] , j ) ;
31564: LD_ADDR_VAR 0 7
31568: PUSH
31569: LD_VAR 0 1
31573: PUSH
31574: LD_VAR 0 5
31578: ARRAY
31579: PPUSH
31580: LD_VAR 0 6
31584: PPUSH
31585: CALL_OW 3
31589: ST_TO_ADDR
// break ;
31590: GO 31594
// end ;
31592: GO 31537
31594: POP
31595: POP
// if tmp = [ ] then
31596: LD_VAR 0 7
31600: PUSH
31601: EMPTY
31602: EQUAL
31603: IFFALSE 31627
// begin tab := Delete ( tab , i ) ;
31605: LD_ADDR_VAR 0 1
31609: PUSH
31610: LD_VAR 0 1
31614: PPUSH
31615: LD_VAR 0 5
31619: PPUSH
31620: CALL_OW 3
31624: ST_TO_ADDR
// end else
31625: GO 31652
// tab := Replace ( tab , i , tmp ) ;
31627: LD_ADDR_VAR 0 1
31631: PUSH
31632: LD_VAR 0 1
31636: PPUSH
31637: LD_VAR 0 5
31641: PPUSH
31642: LD_VAR 0 7
31646: PPUSH
31647: CALL_OW 1
31651: ST_TO_ADDR
// i := i - 1 ;
31652: LD_ADDR_VAR 0 5
31656: PUSH
31657: LD_VAR 0 5
31661: PUSH
31662: LD_INT 1
31664: MINUS
31665: ST_TO_ADDR
// if mode then
31666: LD_VAR 0 3
31670: IFFALSE 31674
// break ;
31672: GO 31690
// end ; i := i + 1 ;
31674: LD_ADDR_VAR 0 5
31678: PUSH
31679: LD_VAR 0 5
31683: PUSH
31684: LD_INT 1
31686: PLUS
31687: ST_TO_ADDR
// end ;
31688: GO 31305
// result := tab ;
31690: LD_ADDR_VAR 0 4
31694: PUSH
31695: LD_VAR 0 1
31699: ST_TO_ADDR
// end ;
31700: LD_VAR 0 4
31704: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31705: LD_INT 0
31707: PPUSH
31708: PPUSH
// for i = 1 to values do
31709: LD_ADDR_VAR 0 4
31713: PUSH
31714: DOUBLE
31715: LD_INT 1
31717: DEC
31718: ST_TO_ADDR
31719: LD_VAR 0 2
31723: PUSH
31724: FOR_TO
31725: IFFALSE 31758
// tab := Remove ( tab , values [ i ] , false ) ;
31727: LD_ADDR_VAR 0 1
31731: PUSH
31732: LD_VAR 0 1
31736: PPUSH
31737: LD_VAR 0 2
31741: PUSH
31742: LD_VAR 0 4
31746: ARRAY
31747: PPUSH
31748: LD_INT 0
31750: PPUSH
31751: CALL 31291 0 3
31755: ST_TO_ADDR
31756: GO 31724
31758: POP
31759: POP
// result := tab ;
31760: LD_ADDR_VAR 0 3
31764: PUSH
31765: LD_VAR 0 1
31769: ST_TO_ADDR
// end ;
31770: LD_VAR 0 3
31774: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31775: LD_INT 0
31777: PPUSH
31778: PPUSH
31779: PPUSH
// if not GetControl ( veh ) = control_manual then
31780: LD_VAR 0 1
31784: PPUSH
31785: CALL_OW 263
31789: PUSH
31790: LD_INT 1
31792: EQUAL
31793: NOT
31794: IFFALSE 31806
// result := false else
31796: LD_ADDR_VAR 0 2
31800: PUSH
31801: LD_INT 0
31803: ST_TO_ADDR
31804: GO 31951
// if veh in FilterAllUnits ( [ f_empty ] ) then
31806: LD_VAR 0 1
31810: PUSH
31811: LD_INT 58
31813: PUSH
31814: EMPTY
31815: LIST
31816: PPUSH
31817: CALL_OW 69
31821: IN
31822: IFFALSE 31834
// result := false else
31824: LD_ADDR_VAR 0 2
31828: PUSH
31829: LD_INT 0
31831: ST_TO_ADDR
31832: GO 31951
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31834: LD_ADDR_VAR 0 4
31838: PUSH
31839: LD_INT 22
31841: PUSH
31842: LD_VAR 0 1
31846: PPUSH
31847: CALL_OW 255
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 55
31858: PUSH
31859: EMPTY
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PPUSH
31866: CALL_OW 69
31870: ST_TO_ADDR
// if not filter then
31871: LD_VAR 0 4
31875: NOT
31876: IFFALSE 31888
// result := false else
31878: LD_ADDR_VAR 0 2
31882: PUSH
31883: LD_INT 0
31885: ST_TO_ADDR
31886: GO 31951
// for i = 1 to filter do
31888: LD_ADDR_VAR 0 3
31892: PUSH
31893: DOUBLE
31894: LD_INT 1
31896: DEC
31897: ST_TO_ADDR
31898: LD_VAR 0 4
31902: PUSH
31903: FOR_TO
31904: IFFALSE 31949
// if IsDriver ( filter [ i ] ) = veh then
31906: LD_VAR 0 4
31910: PUSH
31911: LD_VAR 0 3
31915: ARRAY
31916: PPUSH
31917: CALL 94965 0 1
31921: PUSH
31922: LD_VAR 0 1
31926: EQUAL
31927: IFFALSE 31947
// begin result := filter [ i ] ;
31929: LD_ADDR_VAR 0 2
31933: PUSH
31934: LD_VAR 0 4
31938: PUSH
31939: LD_VAR 0 3
31943: ARRAY
31944: ST_TO_ADDR
// break ;
31945: GO 31949
// end ;
31947: GO 31903
31949: POP
31950: POP
// end ; end ;
31951: LD_VAR 0 2
31955: RET
// export function Compare ( val1 , val2 ) ; begin
31956: LD_INT 0
31958: PPUSH
// if val1 = val2 then
31959: LD_VAR 0 1
31963: PUSH
31964: LD_VAR 0 2
31968: EQUAL
31969: IFFALSE 31981
// result := true else
31971: LD_ADDR_VAR 0 3
31975: PUSH
31976: LD_INT 1
31978: ST_TO_ADDR
31979: GO 31989
// result := false ;
31981: LD_ADDR_VAR 0 3
31985: PUSH
31986: LD_INT 0
31988: ST_TO_ADDR
// end ;
31989: LD_VAR 0 3
31993: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31994: LD_INT 0
31996: PPUSH
31997: PPUSH
// result := false ;
31998: LD_ADDR_VAR 0 3
32002: PUSH
32003: LD_INT 0
32005: ST_TO_ADDR
// for j = 1 to e2 do
32006: LD_ADDR_VAR 0 4
32010: PUSH
32011: DOUBLE
32012: LD_INT 1
32014: DEC
32015: ST_TO_ADDR
32016: LD_VAR 0 2
32020: PUSH
32021: FOR_TO
32022: IFFALSE 32056
// if Compare ( e1 , e2 [ j ] ) then
32024: LD_VAR 0 1
32028: PPUSH
32029: LD_VAR 0 2
32033: PUSH
32034: LD_VAR 0 4
32038: ARRAY
32039: PPUSH
32040: CALL 31956 0 2
32044: IFFALSE 32054
// result := true ;
32046: LD_ADDR_VAR 0 3
32050: PUSH
32051: LD_INT 1
32053: ST_TO_ADDR
32054: GO 32021
32056: POP
32057: POP
// end ;
32058: LD_VAR 0 3
32062: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32063: LD_INT 0
32065: PPUSH
32066: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32067: LD_VAR 0 1
32071: PPUSH
32072: LD_STRING C
32074: PUSH
32075: LD_VAR 0 2
32079: PUSH
32080: LD_VAR 0 3
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: LD_INT 0
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: PUSH
32106: LD_STRING v
32108: PUSH
32109: LD_VAR 0 4
32113: PPUSH
32114: CALL_OW 250
32118: PUSH
32119: LD_VAR 0 4
32123: PPUSH
32124: CALL_OW 251
32128: PUSH
32129: LD_VAR 0 4
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: LD_INT 0
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PPUSH
32156: CALL_OW 446
// end ;
32160: LD_VAR 0 5
32164: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32165: LD_INT 0
32167: PPUSH
32168: PPUSH
32169: PPUSH
// linked := UnitsLinked ( unit ) ;
32170: LD_ADDR_VAR 0 4
32174: PUSH
32175: LD_VAR 0 1
32179: PPUSH
32180: CALL_OW 432
32184: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_VAR 0 1
32194: PPUSH
32195: LD_INT 3
32197: PPUSH
32198: CALL_OW 259
32202: ST_TO_ADDR
// if sk > linked then
32203: LD_VAR 0 3
32207: PUSH
32208: LD_VAR 0 4
32212: GREATER
32213: IFFALSE 32225
// result := true else
32215: LD_ADDR_VAR 0 2
32219: PUSH
32220: LD_INT 1
32222: ST_TO_ADDR
32223: GO 32233
// result := false ;
32225: LD_ADDR_VAR 0 2
32229: PUSH
32230: LD_INT 0
32232: ST_TO_ADDR
// end ;
32233: LD_VAR 0 2
32237: RET
// export function NotTask ( unit ) ; begin
32238: LD_INT 0
32240: PPUSH
// result := true ;
32241: LD_ADDR_VAR 0 2
32245: PUSH
32246: LD_INT 1
32248: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 437
32258: PUSH
32259: LD_VAR 0 1
32263: PPUSH
32264: CALL_OW 314
32268: OR
32269: IFFALSE 32279
// result := false ;
32271: LD_ADDR_VAR 0 2
32275: PUSH
32276: LD_INT 0
32278: ST_TO_ADDR
// end ;
32279: LD_VAR 0 2
32283: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32284: LD_INT 0
32286: PPUSH
32287: PPUSH
32288: PPUSH
32289: PPUSH
32290: PPUSH
// dist := 99999 ;
32291: LD_ADDR_VAR 0 7
32295: PUSH
32296: LD_INT 99999
32298: ST_TO_ADDR
// un := - 1 ;
32299: LD_ADDR_VAR 0 6
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: ST_TO_ADDR
// if units1 and units2 then
32308: LD_VAR 0 1
32312: PUSH
32313: LD_VAR 0 2
32317: AND
32318: IFFALSE 32406
// for i in units1 do
32320: LD_ADDR_VAR 0 4
32324: PUSH
32325: LD_VAR 0 1
32329: PUSH
32330: FOR_IN
32331: IFFALSE 32404
// for j in units2 do
32333: LD_ADDR_VAR 0 5
32337: PUSH
32338: LD_VAR 0 2
32342: PUSH
32343: FOR_IN
32344: IFFALSE 32400
// if GetDistUnits ( i , j ) < dist then
32346: LD_VAR 0 4
32350: PPUSH
32351: LD_VAR 0 5
32355: PPUSH
32356: CALL_OW 296
32360: PUSH
32361: LD_VAR 0 7
32365: LESS
32366: IFFALSE 32398
// begin un := i ;
32368: LD_ADDR_VAR 0 6
32372: PUSH
32373: LD_VAR 0 4
32377: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32378: LD_ADDR_VAR 0 7
32382: PUSH
32383: LD_VAR 0 4
32387: PPUSH
32388: LD_VAR 0 5
32392: PPUSH
32393: CALL_OW 296
32397: ST_TO_ADDR
// end ;
32398: GO 32343
32400: POP
32401: POP
32402: GO 32330
32404: POP
32405: POP
// result := [ un , dist ] ;
32406: LD_ADDR_VAR 0 3
32410: PUSH
32411: LD_VAR 0 6
32415: PUSH
32416: LD_VAR 0 7
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: ST_TO_ADDR
// end ;
32425: LD_VAR 0 3
32429: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32430: LD_INT 0
32432: PPUSH
32433: PPUSH
32434: PPUSH
32435: PPUSH
32436: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32437: LD_VAR 0 1
32441: NOT
32442: PUSH
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 256
32452: PUSH
32453: LD_INT 250
32455: LESS
32456: OR
32457: PUSH
32458: LD_VAR 0 1
32462: PPUSH
32463: CALL_OW 314
32467: PUSH
32468: LD_VAR 0 1
32472: PPUSH
32473: CALL_OW 261
32477: PUSH
32478: LD_INT 20
32480: GREATER
32481: AND
32482: OR
32483: IFFALSE 32487
// exit ;
32485: GO 32861
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32487: LD_VAR 0 1
32491: PPUSH
32492: CALL_OW 261
32496: PUSH
32497: LD_INT 20
32499: LESS
32500: PUSH
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 110
32510: PUSH
32511: LD_INT 21
32513: EQUAL
32514: NOT
32515: AND
32516: IFFALSE 32552
// begin ComStop ( bulldozer ) ;
32518: LD_VAR 0 1
32522: PPUSH
32523: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32527: LD_VAR 0 1
32531: PPUSH
32532: LD_INT 21
32534: PPUSH
32535: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32539: LD_VAR 0 1
32543: PPUSH
32544: CALL 26294 0 1
// exit ;
32548: GO 32861
// end else
32550: GO 32579
// if GetFuel ( bulldozer ) > 20 then
32552: LD_VAR 0 1
32556: PPUSH
32557: CALL_OW 261
32561: PUSH
32562: LD_INT 20
32564: GREATER
32565: IFFALSE 32579
// SetTag ( bulldozer , 0 ) ;
32567: LD_VAR 0 1
32571: PPUSH
32572: LD_INT 0
32574: PPUSH
32575: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32579: LD_ADDR_VAR 0 5
32583: PUSH
32584: LD_VAR 0 2
32588: PPUSH
32589: CALL_OW 353
32593: ST_TO_ADDR
// tmp := [ ] ;
32594: LD_ADDR_VAR 0 6
32598: PUSH
32599: EMPTY
32600: ST_TO_ADDR
// for i = 1 to list do
32601: LD_ADDR_VAR 0 4
32605: PUSH
32606: DOUBLE
32607: LD_INT 1
32609: DEC
32610: ST_TO_ADDR
32611: LD_VAR 0 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32715
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32619: LD_VAR 0 5
32623: PUSH
32624: LD_VAR 0 4
32628: ARRAY
32629: PUSH
32630: LD_INT 1
32632: ARRAY
32633: PPUSH
32634: LD_VAR 0 5
32638: PUSH
32639: LD_VAR 0 4
32643: ARRAY
32644: PUSH
32645: LD_INT 2
32647: ARRAY
32648: PPUSH
32649: CALL_OW 554
32653: IFFALSE 32713
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32655: LD_ADDR_VAR 0 6
32659: PUSH
32660: LD_VAR 0 6
32664: PPUSH
32665: LD_VAR 0 6
32669: PUSH
32670: LD_INT 1
32672: PLUS
32673: PPUSH
32674: LD_VAR 0 5
32678: PUSH
32679: LD_VAR 0 4
32683: ARRAY
32684: PUSH
32685: LD_INT 1
32687: ARRAY
32688: PUSH
32689: LD_VAR 0 5
32693: PUSH
32694: LD_VAR 0 4
32698: ARRAY
32699: PUSH
32700: LD_INT 2
32702: ARRAY
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PPUSH
32708: CALL_OW 1
32712: ST_TO_ADDR
// end ;
32713: GO 32616
32715: POP
32716: POP
// ComStop ( bulldozer ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32726: LD_ADDR_VAR 0 7
32730: PUSH
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 250
32740: PUSH
32741: LD_VAR 0 1
32745: PPUSH
32746: CALL_OW 251
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: ST_TO_ADDR
// for i = tmp downto 1 do
32755: LD_ADDR_VAR 0 4
32759: PUSH
32760: DOUBLE
32761: LD_VAR 0 6
32765: INC
32766: ST_TO_ADDR
32767: LD_INT 1
32769: PUSH
32770: FOR_DOWNTO
32771: IFFALSE 32859
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32773: LD_ADDR_VAR 0 7
32777: PUSH
32778: LD_VAR 0 7
32782: PUSH
32783: LD_INT 1
32785: ARRAY
32786: PPUSH
32787: LD_VAR 0 7
32791: PUSH
32792: LD_INT 2
32794: ARRAY
32795: PPUSH
32796: LD_VAR 0 6
32800: PPUSH
32801: CALL 32962 0 3
32805: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: LD_VAR 0 7
32815: PUSH
32816: LD_INT 1
32818: ARRAY
32819: PPUSH
32820: LD_VAR 0 7
32824: PUSH
32825: LD_INT 2
32827: ARRAY
32828: PPUSH
32829: CALL 32866 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32833: LD_ADDR_VAR 0 6
32837: PUSH
32838: LD_VAR 0 6
32842: PPUSH
32843: LD_VAR 0 7
32847: PUSH
32848: LD_INT 3
32850: ARRAY
32851: PPUSH
32852: CALL_OW 3
32856: ST_TO_ADDR
// end ;
32857: GO 32770
32859: POP
32860: POP
// end ;
32861: LD_VAR 0 3
32865: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32866: LD_INT 0
32868: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32869: LD_VAR 0 2
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL_OW 351
32883: PUSH
32884: LD_VAR 0 2
32888: PPUSH
32889: LD_VAR 0 3
32893: PPUSH
32894: CALL_OW 554
32898: AND
32899: PUSH
32900: LD_VAR 0 2
32904: PPUSH
32905: LD_VAR 0 3
32909: PPUSH
32910: CALL_OW 488
32914: AND
32915: PUSH
32916: LD_VAR 0 2
32920: PPUSH
32921: LD_VAR 0 3
32925: PPUSH
32926: CALL_OW 428
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: EQUAL
32935: AND
32936: IFFALSE 32957
// AddComMoveXY ( bulldozer , x , y ) ;
32938: LD_VAR 0 1
32942: PPUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 3
32952: PPUSH
32953: CALL_OW 171
// end ;
32957: LD_VAR 0 4
32961: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32962: LD_INT 0
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
32969: PPUSH
32970: PPUSH
// dist := 99999 ;
32971: LD_ADDR_VAR 0 6
32975: PUSH
32976: LD_INT 99999
32978: ST_TO_ADDR
// for i = 1 to list do
32979: LD_ADDR_VAR 0 5
32983: PUSH
32984: DOUBLE
32985: LD_INT 1
32987: DEC
32988: ST_TO_ADDR
32989: LD_VAR 0 3
32993: PUSH
32994: FOR_TO
32995: IFFALSE 33133
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32997: LD_ADDR_VAR 0 7
33001: PUSH
33002: LD_VAR 0 1
33006: PPUSH
33007: LD_VAR 0 2
33011: PPUSH
33012: LD_VAR 0 3
33016: PUSH
33017: LD_VAR 0 5
33021: ARRAY
33022: PUSH
33023: LD_INT 1
33025: ARRAY
33026: PPUSH
33027: LD_VAR 0 3
33031: PUSH
33032: LD_VAR 0 5
33036: ARRAY
33037: PUSH
33038: LD_INT 2
33040: ARRAY
33041: PPUSH
33042: CALL_OW 298
33046: ST_TO_ADDR
// if d = 0 then
33047: LD_VAR 0 7
33051: PUSH
33052: LD_INT 0
33054: EQUAL
33055: IFFALSE 33059
// continue ;
33057: GO 32994
// if d < dist then
33059: LD_VAR 0 7
33063: PUSH
33064: LD_VAR 0 6
33068: LESS
33069: IFFALSE 33131
// begin _x := list [ i ] [ 1 ] ;
33071: LD_ADDR_VAR 0 8
33075: PUSH
33076: LD_VAR 0 3
33080: PUSH
33081: LD_VAR 0 5
33085: ARRAY
33086: PUSH
33087: LD_INT 1
33089: ARRAY
33090: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33091: LD_ADDR_VAR 0 9
33095: PUSH
33096: LD_VAR 0 3
33100: PUSH
33101: LD_VAR 0 5
33105: ARRAY
33106: PUSH
33107: LD_INT 2
33109: ARRAY
33110: ST_TO_ADDR
// _i := i ;
33111: LD_ADDR_VAR 0 10
33115: PUSH
33116: LD_VAR 0 5
33120: ST_TO_ADDR
// dist := d ;
33121: LD_ADDR_VAR 0 6
33125: PUSH
33126: LD_VAR 0 7
33130: ST_TO_ADDR
// end ; end ;
33131: GO 32994
33133: POP
33134: POP
// result := [ _x , _y , _i , dist ] ;
33135: LD_ADDR_VAR 0 4
33139: PUSH
33140: LD_VAR 0 8
33144: PUSH
33145: LD_VAR 0 9
33149: PUSH
33150: LD_VAR 0 10
33154: PUSH
33155: LD_VAR 0 6
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: ST_TO_ADDR
// end ;
33166: LD_VAR 0 4
33170: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33171: LD_INT 0
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
// for i = 1 to list do
33178: LD_ADDR_VAR 0 5
33182: PUSH
33183: DOUBLE
33184: LD_INT 1
33186: DEC
33187: ST_TO_ADDR
33188: LD_VAR 0 1
33192: PUSH
33193: FOR_TO
33194: IFFALSE 33508
// begin for j = list downto 2 do
33196: LD_ADDR_VAR 0 6
33200: PUSH
33201: DOUBLE
33202: LD_VAR 0 1
33206: INC
33207: ST_TO_ADDR
33208: LD_INT 2
33210: PUSH
33211: FOR_DOWNTO
33212: IFFALSE 33504
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33214: LD_VAR 0 2
33218: PPUSH
33219: LD_VAR 0 3
33223: PPUSH
33224: LD_VAR 0 1
33228: PUSH
33229: LD_VAR 0 6
33233: ARRAY
33234: PUSH
33235: LD_INT 1
33237: ARRAY
33238: PPUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 2
33252: ARRAY
33253: PPUSH
33254: CALL_OW 298
33258: PUSH
33259: LD_VAR 0 2
33263: PPUSH
33264: LD_VAR 0 3
33268: PPUSH
33269: LD_VAR 0 1
33273: PUSH
33274: LD_VAR 0 6
33278: PUSH
33279: LD_INT 1
33281: MINUS
33282: ARRAY
33283: PUSH
33284: LD_INT 1
33286: ARRAY
33287: PPUSH
33288: LD_VAR 0 1
33292: PUSH
33293: LD_VAR 0 6
33297: PUSH
33298: LD_INT 1
33300: MINUS
33301: ARRAY
33302: PUSH
33303: LD_INT 2
33305: ARRAY
33306: PPUSH
33307: CALL_OW 298
33311: LESS
33312: IFFALSE 33502
// begin _x := list [ j ] [ 1 ] ;
33314: LD_ADDR_VAR 0 7
33318: PUSH
33319: LD_VAR 0 1
33323: PUSH
33324: LD_VAR 0 6
33328: ARRAY
33329: PUSH
33330: LD_INT 1
33332: ARRAY
33333: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33334: LD_ADDR_VAR 0 8
33338: PUSH
33339: LD_VAR 0 1
33343: PUSH
33344: LD_VAR 0 6
33348: ARRAY
33349: PUSH
33350: LD_INT 2
33352: ARRAY
33353: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33354: LD_ADDR_VAR 0 1
33358: PUSH
33359: LD_VAR 0 1
33363: PPUSH
33364: LD_VAR 0 6
33368: PPUSH
33369: LD_INT 1
33371: PPUSH
33372: LD_VAR 0 1
33376: PUSH
33377: LD_VAR 0 6
33381: PUSH
33382: LD_INT 1
33384: MINUS
33385: ARRAY
33386: PUSH
33387: LD_INT 1
33389: ARRAY
33390: PPUSH
33391: CALL 31132 0 4
33395: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33396: LD_ADDR_VAR 0 1
33400: PUSH
33401: LD_VAR 0 1
33405: PPUSH
33406: LD_VAR 0 6
33410: PPUSH
33411: LD_INT 2
33413: PPUSH
33414: LD_VAR 0 1
33418: PUSH
33419: LD_VAR 0 6
33423: PUSH
33424: LD_INT 1
33426: MINUS
33427: ARRAY
33428: PUSH
33429: LD_INT 2
33431: ARRAY
33432: PPUSH
33433: CALL 31132 0 4
33437: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33438: LD_ADDR_VAR 0 1
33442: PUSH
33443: LD_VAR 0 1
33447: PPUSH
33448: LD_VAR 0 6
33452: PUSH
33453: LD_INT 1
33455: MINUS
33456: PPUSH
33457: LD_INT 1
33459: PPUSH
33460: LD_VAR 0 7
33464: PPUSH
33465: CALL 31132 0 4
33469: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33470: LD_ADDR_VAR 0 1
33474: PUSH
33475: LD_VAR 0 1
33479: PPUSH
33480: LD_VAR 0 6
33484: PUSH
33485: LD_INT 1
33487: MINUS
33488: PPUSH
33489: LD_INT 2
33491: PPUSH
33492: LD_VAR 0 8
33496: PPUSH
33497: CALL 31132 0 4
33501: ST_TO_ADDR
// end ; end ;
33502: GO 33211
33504: POP
33505: POP
// end ;
33506: GO 33193
33508: POP
33509: POP
// result := list ;
33510: LD_ADDR_VAR 0 4
33514: PUSH
33515: LD_VAR 0 1
33519: ST_TO_ADDR
// end ;
33520: LD_VAR 0 4
33524: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33525: LD_INT 0
33527: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33528: LD_ADDR_VAR 0 5
33532: PUSH
33533: LD_VAR 0 1
33537: PPUSH
33538: LD_VAR 0 2
33542: PPUSH
33543: CALL_OW 546
33547: PUSH
33548: LD_INT 2
33550: ARRAY
33551: PUSH
33552: LD_VAR 0 3
33556: PPUSH
33557: LD_VAR 0 4
33561: PPUSH
33562: CALL_OW 546
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: MINUS
33571: ST_TO_ADDR
// if result < 0 then
33572: LD_VAR 0 5
33576: PUSH
33577: LD_INT 0
33579: LESS
33580: IFFALSE 33597
// result := result * - 1 ;
33582: LD_ADDR_VAR 0 5
33586: PUSH
33587: LD_VAR 0 5
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: MUL
33596: ST_TO_ADDR
// end ;
33597: LD_VAR 0 5
33601: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33602: LD_INT 0
33604: PPUSH
33605: PPUSH
// area = ListEnvironmentArea ( area ) ;
33606: LD_ADDR_VAR 0 2
33610: PUSH
33611: LD_VAR 0 2
33615: PPUSH
33616: CALL_OW 353
33620: ST_TO_ADDR
// if bulldozer > 0 then
33621: LD_VAR 0 1
33625: PUSH
33626: LD_INT 0
33628: GREATER
33629: IFFALSE 33740
// for i = area downto 1 do
33631: LD_ADDR_VAR 0 4
33635: PUSH
33636: DOUBLE
33637: LD_VAR 0 2
33641: INC
33642: ST_TO_ADDR
33643: LD_INT 1
33645: PUSH
33646: FOR_DOWNTO
33647: IFFALSE 33738
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33649: LD_VAR 0 2
33653: PUSH
33654: LD_VAR 0 4
33658: ARRAY
33659: PUSH
33660: LD_INT 1
33662: ARRAY
33663: PPUSH
33664: LD_VAR 0 2
33668: PUSH
33669: LD_VAR 0 4
33673: ARRAY
33674: PUSH
33675: LD_INT 2
33677: ARRAY
33678: PPUSH
33679: CALL_OW 351
33683: IFFALSE 33736
// if not HasTask ( bulldozer ) then
33685: LD_VAR 0 1
33689: PPUSH
33690: CALL_OW 314
33694: NOT
33695: IFFALSE 33736
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33697: LD_VAR 0 1
33701: PPUSH
33702: LD_VAR 0 2
33706: PUSH
33707: LD_VAR 0 4
33711: ARRAY
33712: PUSH
33713: LD_INT 1
33715: ARRAY
33716: PPUSH
33717: LD_VAR 0 2
33721: PUSH
33722: LD_VAR 0 4
33726: ARRAY
33727: PUSH
33728: LD_INT 2
33730: ARRAY
33731: PPUSH
33732: CALL_OW 171
33736: GO 33646
33738: POP
33739: POP
// end ;
33740: LD_VAR 0 3
33744: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33745: LD_INT 0
33747: PPUSH
33748: PPUSH
33749: PPUSH
33750: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33751: LD_ADDR_VAR 0 6
33755: PUSH
33756: LD_INT 22
33758: PUSH
33759: LD_VAR 0 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 21
33770: PUSH
33771: LD_VAR 0 2
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PPUSH
33784: CALL_OW 69
33788: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33789: LD_ADDR_VAR 0 7
33793: PUSH
33794: LD_VAR 0 3
33798: PPUSH
33799: LD_INT 22
33801: PUSH
33802: LD_VAR 0 1
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 21
33813: PUSH
33814: LD_VAR 0 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PPUSH
33827: CALL_OW 70
33831: ST_TO_ADDR
// if tmp and pom then
33832: LD_VAR 0 6
33836: PUSH
33837: LD_VAR 0 7
33841: AND
33842: IFFALSE 33862
// result := tmp diff pom else
33844: LD_ADDR_VAR 0 4
33848: PUSH
33849: LD_VAR 0 6
33853: PUSH
33854: LD_VAR 0 7
33858: DIFF
33859: ST_TO_ADDR
33860: GO 33870
// result := false ;
33862: LD_ADDR_VAR 0 4
33866: PUSH
33867: LD_INT 0
33869: ST_TO_ADDR
// end ;
33870: LD_VAR 0 4
33874: RET
// export function SavePosition ( unit ) ; begin
33875: LD_INT 0
33877: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33878: LD_VAR 0 1
33882: PPUSH
33883: LD_VAR 0 1
33887: PPUSH
33888: CALL_OW 250
33892: PPUSH
33893: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33897: LD_VAR 0 1
33901: PPUSH
33902: LD_VAR 0 1
33906: PPUSH
33907: CALL_OW 251
33911: PPUSH
33912: CALL_OW 232
// end ;
33916: LD_VAR 0 2
33920: RET
// export function GetPosition ( unit ) ; begin
33921: LD_INT 0
33923: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33924: LD_ADDR_VAR 0 2
33928: PUSH
33929: LD_VAR 0 1
33933: PPUSH
33934: CALL_OW 252
33938: PUSH
33939: LD_VAR 0 1
33943: PPUSH
33944: CALL_OW 253
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: ST_TO_ADDR
// end ;
33953: LD_VAR 0 2
33957: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33958: LD_INT 0
33960: PPUSH
// if unit in unreachableList then
33961: LD_VAR 0 1
33965: PUSH
33966: LD_EXP 30
33970: IN
33971: IFFALSE 33989
// unreachableList := unreachableList diff unit ;
33973: LD_ADDR_EXP 30
33977: PUSH
33978: LD_EXP 30
33982: PUSH
33983: LD_VAR 0 1
33987: DIFF
33988: ST_TO_ADDR
// if ValidHex ( x , y ) then
33989: LD_VAR 0 2
33993: PPUSH
33994: LD_VAR 0 3
33998: PPUSH
33999: CALL_OW 488
34003: IFFALSE 34029
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: LD_VAR 0 2
34014: PPUSH
34015: LD_VAR 0 3
34019: PPUSH
34020: CALL_OW 428
34024: PPUSH
34025: CALL_OW 115
// Wait ( 3 ) ;
34029: LD_INT 3
34031: PPUSH
34032: CALL_OW 67
// if unit in unreachableList then
34036: LD_VAR 0 1
34040: PUSH
34041: LD_EXP 30
34045: IN
34046: IFFALSE 34058
// result := false else
34048: LD_ADDR_VAR 0 4
34052: PUSH
34053: LD_INT 0
34055: ST_TO_ADDR
34056: GO 34066
// result := true ;
34058: LD_ADDR_VAR 0 4
34062: PUSH
34063: LD_INT 1
34065: ST_TO_ADDR
// end ; end_of_file
34066: LD_VAR 0 4
34070: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34071: LD_EXP 31
34075: IFFALSE 34137
34077: GO 34079
34079: DISABLE
34080: LD_INT 0
34082: PPUSH
// begin enable ;
34083: ENABLE
// for i = 1 to mc_crates_list do
34084: LD_ADDR_VAR 0 1
34088: PUSH
34089: DOUBLE
34090: LD_INT 1
34092: DEC
34093: ST_TO_ADDR
34094: LD_EXP 32
34098: PUSH
34099: FOR_TO
34100: IFFALSE 34131
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34102: LD_EXP 32
34106: PUSH
34107: LD_VAR 0 1
34111: ARRAY
34112: PPUSH
34113: LD_INT 5
34115: PPUSH
34116: LD_INT 50
34118: PPUSH
34119: LD_INT 700
34121: PPUSH
34122: LD_INT 20
34124: PPUSH
34125: CALL 24501 0 5
34129: GO 34099
34131: POP
34132: POP
// MC_Game ( ) ;
34133: CALL 34140 0 0
// end ;
34137: PPOPN 1
34139: END
// export function MC_Game ( ) ; var i , side , un ; begin
34140: LD_INT 0
34142: PPUSH
34143: PPUSH
34144: PPUSH
34145: PPUSH
// if not isTest then
34146: LD_EXP 1
34150: NOT
34151: IFFALSE 34171
// MC_Show ( [ #tick , tick ] ) else
34153: LD_STRING #tick
34155: PUSH
34156: LD_OWVAR 1
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PPUSH
34165: CALL 8585 0 1
34169: GO 34180
// MC_Show ( debug_string ) ;
34171: LD_EXP 2
34175: PPUSH
34176: CALL 8585 0 1
// for side = 1 to 8 do
34180: LD_ADDR_VAR 0 3
34184: PUSH
34185: DOUBLE
34186: LD_INT 1
34188: DEC
34189: ST_TO_ADDR
34190: LD_INT 8
34192: PUSH
34193: FOR_TO
34194: IFFALSE 36194
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34196: LD_EXP 39
34200: PUSH
34201: LD_VAR 0 3
34205: ARRAY
34206: PUSH
34207: LD_INT 0
34209: EQUAL
34210: PUSH
34211: LD_VAR 0 3
34215: PPUSH
34216: EMPTY
34217: PPUSH
34218: CALL 11802 0 2
34222: PUSH
34223: LD_INT 0
34225: EQUAL
34226: OR
34227: IFFALSE 34231
// continue ;
34229: GO 34193
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34231: LD_VAR 0 3
34235: PPUSH
34236: LD_VAR 0 3
34240: PPUSH
34241: CALL 25022 0 1
34245: PPUSH
34246: CALL 36201 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34250: LD_EXP 71
34254: PUSH
34255: LD_VAR 0 3
34259: ARRAY
34260: PUSH
34261: LD_INT 1
34263: ARRAY
34264: PUSH
34265: LD_INT 0
34267: GREATER
34268: PUSH
34269: LD_EXP 69
34273: PUSH
34274: LD_VAR 0 3
34278: ARRAY
34279: PUSH
34280: LD_INT 1
34282: ARRAY
34283: PUSH
34284: LD_INT 0
34286: EQUAL
34287: AND
34288: PUSH
34289: LD_VAR 0 3
34293: PPUSH
34294: LD_INT 7
34296: PPUSH
34297: EMPTY
34298: PPUSH
34299: CALL 12370 0 3
34303: NOT
34304: AND
34305: IFFALSE 34342
// begin for i in MREG_Attackers [ side ] do
34307: LD_ADDR_VAR 0 2
34311: PUSH
34312: LD_EXP 71
34316: PUSH
34317: LD_VAR 0 3
34321: ARRAY
34322: PUSH
34323: FOR_IN
34324: IFFALSE 34340
// SetTag ( i , 7 ) ;
34326: LD_VAR 0 2
34330: PPUSH
34331: LD_INT 7
34333: PPUSH
34334: CALL_OW 109
34338: GO 34323
34340: POP
34341: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34342: LD_VAR 0 3
34346: PPUSH
34347: LD_INT 7
34349: PPUSH
34350: EMPTY
34351: PPUSH
34352: CALL 12370 0 3
34356: IFFALSE 34416
// begin if side = 1 then
34358: LD_VAR 0 3
34362: PUSH
34363: LD_INT 1
34365: EQUAL
34366: IFFALSE 34375
// RaiseSailEvent ( 101 ) ;
34368: LD_INT 101
34370: PPUSH
34371: CALL_OW 427
// if side = 4 then
34375: LD_VAR 0 3
34379: PUSH
34380: LD_INT 4
34382: EQUAL
34383: IFFALSE 34392
// RaiseSailEvent ( 102 ) ;
34385: LD_INT 102
34387: PPUSH
34388: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34392: LD_VAR 0 3
34396: PPUSH
34397: LD_VAR 0 3
34401: PPUSH
34402: LD_INT 7
34404: PPUSH
34405: EMPTY
34406: PPUSH
34407: CALL 12370 0 3
34411: PPUSH
34412: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34416: LD_VAR 0 3
34420: PPUSH
34421: CALL 18050 0 1
34425: PUSH
34426: LD_VAR 0 3
34430: PPUSH
34431: CALL 11706 0 1
34435: AND
34436: IFFALSE 34447
// MCL_Start ( side ) ;
34438: LD_VAR 0 3
34442: PPUSH
34443: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34447: LD_ADDR_EXP 35
34451: PUSH
34452: LD_EXP 35
34456: PPUSH
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_VAR 0 3
34466: PPUSH
34467: CALL 19307 0 1
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34477: LD_ADDR_EXP 47
34481: PUSH
34482: LD_EXP 47
34486: PPUSH
34487: LD_VAR 0 3
34491: PPUSH
34492: LD_VAR 0 3
34496: PPUSH
34497: CALL 11120 0 1
34501: PPUSH
34502: CALL_OW 1
34506: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34507: LD_VAR 0 3
34511: PPUSH
34512: LD_INT 21
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PPUSH
34522: CALL 11667 0 2
34526: IFFALSE 34537
// MCV_CheckStatus ( side ) ;
34528: LD_VAR 0 3
34532: PPUSH
34533: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34537: LD_VAR 0 3
34541: PPUSH
34542: LD_EXP 53
34546: PPUSH
34547: CALL 43001 0 2
34551: IFFALSE 34636
// begin for i = MREG_ToChangeClass downto 1 do
34553: LD_ADDR_VAR 0 2
34557: PUSH
34558: DOUBLE
34559: LD_EXP 53
34563: INC
34564: ST_TO_ADDR
34565: LD_INT 1
34567: PUSH
34568: FOR_DOWNTO
34569: IFFALSE 34634
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34571: LD_EXP 53
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_INT 1
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: EQUAL
34591: IFFALSE 34632
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34593: LD_VAR 0 3
34597: PPUSH
34598: LD_EXP 53
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 2
34611: ARRAY
34612: PPUSH
34613: LD_EXP 53
34617: PUSH
34618: LD_VAR 0 2
34622: ARRAY
34623: PUSH
34624: LD_INT 3
34626: ARRAY
34627: PPUSH
34628: CALL 16574 0 3
// end ; end ;
34632: GO 34568
34634: POP
34635: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34636: LD_INT 1
34638: PUSH
34639: LD_EXP 38
34643: PUSH
34644: LD_VAR 0 3
34648: ARRAY
34649: IN
34650: IFFALSE 34661
// begin MCN_TrainApe ( side ) ;
34652: LD_VAR 0 3
34656: PPUSH
34657: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34661: LD_VAR 0 3
34665: PPUSH
34666: LD_INT 30
34668: PUSH
34669: LD_INT 3
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PPUSH
34676: CALL 11667 0 2
34680: IFFALSE 34854
// begin if MCF_Tag ( side , 10 , [ ] ) then
34682: LD_VAR 0 3
34686: PPUSH
34687: LD_INT 10
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL 12370 0 3
34696: IFFALSE 34743
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34698: LD_VAR 0 3
34702: PPUSH
34703: LD_INT 10
34705: PPUSH
34706: EMPTY
34707: PPUSH
34708: CALL 12370 0 3
34712: PPUSH
34713: LD_VAR 0 3
34717: PPUSH
34718: LD_INT 30
34720: PUSH
34721: LD_INT 3
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PPUSH
34728: CALL 11667 0 2
34732: PUSH
34733: LD_INT 1
34735: ARRAY
34736: PPUSH
34737: CALL_OW 168
// end else
34741: GO 34854
// if MREG_ToConstruct [ side ] then
34743: LD_EXP 51
34747: PUSH
34748: LD_VAR 0 3
34752: ARRAY
34753: IFFALSE 34854
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34755: LD_VAR 0 3
34759: PPUSH
34760: LD_VAR 0 3
34764: PPUSH
34765: LD_INT 30
34767: PUSH
34768: LD_INT 3
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PPUSH
34775: CALL 11667 0 2
34779: PUSH
34780: LD_INT 1
34782: ARRAY
34783: PPUSH
34784: LD_EXP 51
34788: PUSH
34789: LD_VAR 0 3
34793: ARRAY
34794: PUSH
34795: LD_INT 1
34797: ARRAY
34798: PUSH
34799: LD_EXP 51
34803: PUSH
34804: LD_VAR 0 3
34808: ARRAY
34809: PUSH
34810: LD_INT 2
34812: ARRAY
34813: PUSH
34814: LD_EXP 51
34818: PUSH
34819: LD_VAR 0 3
34823: ARRAY
34824: PUSH
34825: LD_INT 3
34827: ARRAY
34828: PUSH
34829: LD_EXP 51
34833: PUSH
34834: LD_VAR 0 3
34838: ARRAY
34839: PUSH
34840: LD_INT 4
34842: ARRAY
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: LIST
34848: LIST
34849: PPUSH
34850: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 3
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PPUSH
34869: CALL 11667 0 2
34873: PUSH
34874: LD_VAR 0 3
34878: PPUSH
34879: LD_EXP 43
34883: PPUSH
34884: CALL 43001 0 2
34888: AND
34889: PUSH
34890: LD_INT 22
34892: PUSH
34893: LD_VAR 0 3
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 2
34904: PUSH
34905: LD_INT 30
34907: PUSH
34908: LD_INT 33
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 30
34917: PUSH
34918: LD_INT 32
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 35
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: PPUSH
34945: CALL_OW 69
34949: AND
34950: IFFALSE 34961
// MCV_Turret ( side ) ;
34952: LD_VAR 0 3
34956: PPUSH
34957: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34961: LD_EXP 42
34965: PUSH
34966: LD_VAR 0 3
34970: ARRAY
34971: PUSH
34972: LD_INT 1
34974: GREATER
34975: PUSH
34976: LD_VAR 0 3
34980: PPUSH
34981: CALL 25022 0 1
34985: PUSH
34986: LD_INT 0
34988: EQUAL
34989: AND
34990: IFFALSE 35152
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34992: LD_EXP 42
34996: PUSH
34997: LD_VAR 0 3
35001: ARRAY
35002: PUSH
35003: LD_INT 1
35005: ARRAY
35006: PPUSH
35007: CALL_OW 353
35011: IFFALSE 35049
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35013: LD_EXP 42
35017: PUSH
35018: LD_VAR 0 3
35022: ARRAY
35023: PUSH
35024: LD_INT 2
35026: ARRAY
35027: PPUSH
35028: LD_EXP 42
35032: PUSH
35033: LD_VAR 0 3
35037: ARRAY
35038: PUSH
35039: LD_INT 1
35041: ARRAY
35042: PPUSH
35043: CALL 32430 0 2
35047: GO 35152
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35049: LD_VAR 0 3
35053: PPUSH
35054: LD_INT 30
35056: PUSH
35057: LD_INT 3
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PPUSH
35064: CALL 11667 0 2
35068: IFFALSE 35152
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35070: LD_VAR 0 3
35074: PPUSH
35075: LD_INT 30
35077: PUSH
35078: LD_INT 3
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PPUSH
35085: CALL 11667 0 2
35089: PUSH
35090: LD_INT 1
35092: ARRAY
35093: PPUSH
35094: CALL_OW 461
35098: PUSH
35099: LD_INT 2
35101: EQUAL
35102: IFFALSE 35152
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35104: LD_EXP 42
35108: PUSH
35109: LD_VAR 0 3
35113: ARRAY
35114: PUSH
35115: LD_INT 2
35117: ARRAY
35118: PPUSH
35119: LD_INT 10
35121: PPUSH
35122: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35126: LD_ADDR_EXP 42
35130: PUSH
35131: LD_EXP 42
35135: PPUSH
35136: LD_VAR 0 3
35140: PPUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_INT 33
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PPUSH
35167: CALL 11667 0 2
35171: IFFALSE 35211
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35173: LD_VAR 0 3
35177: PPUSH
35178: LD_VAR 0 3
35182: PPUSH
35183: LD_INT 33
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PPUSH
35193: CALL 11667 0 2
35197: PUSH
35198: LD_INT 1
35200: ARRAY
35201: PPUSH
35202: CALL_OW 248
35206: PPUSH
35207: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35211: LD_EXP 47
35215: PUSH
35216: LD_VAR 0 3
35220: ARRAY
35221: IFFALSE 35234
// begin MCB_Repair ( side ) ;
35223: LD_VAR 0 3
35227: PPUSH
35228: CALL 11407 0 1
// end else
35232: GO 36147
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_EXP 49
35243: PPUSH
35244: CALL 43001 0 2
35248: PUSH
35249: LD_VAR 0 3
35253: PPUSH
35254: LD_EXP 40
35258: PPUSH
35259: CALL 43001 0 2
35263: AND
35264: IFFALSE 35472
// begin for i = 1 to MREG_ToUpLab do
35266: LD_ADDR_VAR 0 2
35270: PUSH
35271: DOUBLE
35272: LD_INT 1
35274: DEC
35275: ST_TO_ADDR
35276: LD_EXP 49
35280: PUSH
35281: FOR_TO
35282: IFFALSE 35468
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35284: LD_EXP 49
35288: PUSH
35289: LD_VAR 0 2
35293: ARRAY
35294: PUSH
35295: LD_INT 1
35297: ARRAY
35298: PUSH
35299: LD_VAR 0 3
35303: EQUAL
35304: IFFALSE 35466
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35306: LD_EXP 49
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_INT 2
35319: ARRAY
35320: PUSH
35321: LD_EXP 49
35325: PUSH
35326: LD_VAR 0 2
35330: ARRAY
35331: PUSH
35332: LD_INT 3
35334: ARRAY
35335: AND
35336: IFFALSE 35464
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35338: LD_VAR 0 3
35342: PPUSH
35343: LD_EXP 49
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PUSH
35354: LD_INT 2
35356: ARRAY
35357: PPUSH
35358: LD_EXP 49
35362: PUSH
35363: LD_VAR 0 2
35367: ARRAY
35368: PUSH
35369: LD_INT 3
35371: ARRAY
35372: PPUSH
35373: CALL 8931 0 3
35377: IFFALSE 35464
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35379: LD_ADDR_EXP 49
35383: PUSH
35384: LD_EXP 49
35388: PPUSH
35389: LD_VAR 0 3
35393: PPUSH
35394: LD_EXP 49
35398: PUSH
35399: LD_VAR 0 2
35403: ARRAY
35404: PUSH
35405: LD_INT 2
35407: ARRAY
35408: PPUSH
35409: LD_EXP 49
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: PUSH
35420: LD_INT 3
35422: ARRAY
35423: PPUSH
35424: CALL 42053 0 4
35428: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35429: LD_ADDR_EXP 40
35433: PUSH
35434: LD_EXP 40
35438: PPUSH
35439: LD_VAR 0 3
35443: PPUSH
35444: LD_EXP 40
35448: PUSH
35449: LD_INT 1
35451: ARRAY
35452: PUSH
35453: LD_INT 2
35455: ARRAY
35456: PPUSH
35457: EMPTY
35458: PPUSH
35459: CALL 42053 0 4
35463: ST_TO_ADDR
// end ; break ;
35464: GO 35468
// end ;
35466: GO 35281
35468: POP
35469: POP
// end else
35470: GO 36147
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35472: LD_VAR 0 3
35476: PPUSH
35477: LD_EXP 48
35481: PPUSH
35482: CALL 43001 0 2
35486: IFFALSE 35560
// begin for i = 1 to MREG_ToUpdate do
35488: LD_ADDR_VAR 0 2
35492: PUSH
35493: DOUBLE
35494: LD_INT 1
35496: DEC
35497: ST_TO_ADDR
35498: LD_EXP 48
35502: PUSH
35503: FOR_TO
35504: IFFALSE 35556
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35506: LD_EXP 48
35510: PUSH
35511: LD_VAR 0 2
35515: ARRAY
35516: PUSH
35517: LD_INT 1
35519: ARRAY
35520: PUSH
35521: LD_VAR 0 3
35525: EQUAL
35526: IFFALSE 35554
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PUSH
35538: LD_VAR 0 2
35542: ARRAY
35543: PUSH
35544: LD_INT 2
35546: ARRAY
35547: PPUSH
35548: CALL 8767 0 2
// break ;
35552: GO 35556
// end ;
35554: GO 35503
35556: POP
35557: POP
// end else
35558: GO 36147
// if MCF_Get ( side , [ f_constructed ] ) then
35560: LD_VAR 0 3
35564: PPUSH
35565: LD_INT 57
35567: PUSH
35568: EMPTY
35569: LIST
35570: PPUSH
35571: CALL 11667 0 2
35575: IFFALSE 35608
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35577: LD_VAR 0 3
35581: PPUSH
35582: LD_VAR 0 3
35586: PPUSH
35587: LD_INT 57
35589: PUSH
35590: EMPTY
35591: LIST
35592: PPUSH
35593: CALL 11667 0 2
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: CALL 11011 0 2
35606: GO 36147
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35608: LD_VAR 0 3
35612: PPUSH
35613: LD_EXP 46
35617: PPUSH
35618: CALL 43001 0 2
35622: PUSH
35623: LD_VAR 0 3
35627: PPUSH
35628: CALL_OW 345
35632: NOT
35633: AND
35634: PUSH
35635: LD_VAR 0 3
35639: PPUSH
35640: CALL 25022 0 1
35644: PUSH
35645: LD_INT 0
35647: EQUAL
35648: AND
35649: IFFALSE 36048
// begin for i = 1 to MREG_ToBuild do
35651: LD_ADDR_VAR 0 2
35655: PUSH
35656: DOUBLE
35657: LD_INT 1
35659: DEC
35660: ST_TO_ADDR
35661: LD_EXP 46
35665: PUSH
35666: FOR_TO
35667: IFFALSE 36044
// if MREG_ToBuild [ i ] [ 1 ] = side then
35669: LD_EXP 46
35673: PUSH
35674: LD_VAR 0 2
35678: ARRAY
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 3
35688: EQUAL
35689: IFFALSE 36042
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35691: LD_OWVAR 84
35695: PUSH
35696: LD_EXP 46
35700: PUSH
35701: LD_VAR 0 2
35705: ARRAY
35706: PUSH
35707: LD_INT 3
35709: ARRAY
35710: PUSH
35711: LD_INT 1
35713: ARRAY
35714: PPUSH
35715: LD_EXP 46
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_INT 3
35728: ARRAY
35729: PUSH
35730: LD_INT 2
35732: ARRAY
35733: PPUSH
35734: CALL_OW 351
35738: AND
35739: IFFALSE 35783
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35741: LD_EXP 46
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PUSH
35752: LD_INT 3
35754: ARRAY
35755: PUSH
35756: LD_INT 1
35758: ARRAY
35759: PPUSH
35760: LD_EXP 46
35764: PUSH
35765: LD_VAR 0 2
35769: ARRAY
35770: PUSH
35771: LD_INT 3
35773: ARRAY
35774: PUSH
35775: LD_INT 2
35777: ARRAY
35778: PPUSH
35779: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35783: LD_EXP 46
35787: PUSH
35788: LD_VAR 0 2
35792: ARRAY
35793: PUSH
35794: LD_INT 2
35796: ARRAY
35797: PUSH
35798: LD_INT 0
35800: EQUAL
35801: IFFALSE 35871
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35803: LD_VAR 0 3
35807: PPUSH
35808: LD_EXP 46
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: PUSH
35819: LD_INT 3
35821: ARRAY
35822: PUSH
35823: LD_INT 1
35825: ARRAY
35826: PPUSH
35827: LD_EXP 46
35831: PUSH
35832: LD_VAR 0 2
35836: ARRAY
35837: PUSH
35838: LD_INT 3
35840: ARRAY
35841: PUSH
35842: LD_INT 2
35844: ARRAY
35845: PPUSH
35846: LD_EXP 46
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_INT 3
35859: ARRAY
35860: PUSH
35861: LD_INT 3
35863: ARRAY
35864: PPUSH
35865: CALL 8603 0 4
35869: GO 36040
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35871: LD_EXP 46
35875: PUSH
35876: LD_VAR 0 2
35880: ARRAY
35881: PUSH
35882: LD_INT 2
35884: ARRAY
35885: PUSH
35886: LD_INT 6
35888: EQUAL
35889: IFFALSE 35959
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35891: LD_VAR 0 3
35895: PPUSH
35896: LD_EXP 46
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 3
35909: ARRAY
35910: PUSH
35911: LD_INT 1
35913: ARRAY
35914: PPUSH
35915: LD_EXP 46
35919: PUSH
35920: LD_VAR 0 2
35924: ARRAY
35925: PUSH
35926: LD_INT 3
35928: ARRAY
35929: PUSH
35930: LD_INT 2
35932: ARRAY
35933: PPUSH
35934: LD_EXP 46
35938: PUSH
35939: LD_VAR 0 2
35943: ARRAY
35944: PUSH
35945: LD_INT 3
35947: ARRAY
35948: PUSH
35949: LD_INT 3
35951: ARRAY
35952: PPUSH
35953: CALL 8732 0 4
35957: GO 36040
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35959: LD_VAR 0 3
35963: PPUSH
35964: LD_EXP 46
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 2
35977: ARRAY
35978: PPUSH
35979: LD_EXP 46
35983: PUSH
35984: LD_VAR 0 2
35988: ARRAY
35989: PUSH
35990: LD_INT 3
35992: ARRAY
35993: PUSH
35994: LD_INT 1
35996: ARRAY
35997: PPUSH
35998: LD_EXP 46
36002: PUSH
36003: LD_VAR 0 2
36007: ARRAY
36008: PUSH
36009: LD_INT 3
36011: ARRAY
36012: PUSH
36013: LD_INT 2
36015: ARRAY
36016: PPUSH
36017: LD_EXP 46
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 3
36030: ARRAY
36031: PUSH
36032: LD_INT 3
36034: ARRAY
36035: PPUSH
36036: CALL 10236 0 5
// break ;
36040: GO 36044
// end ;
36042: GO 35666
36044: POP
36045: POP
// end else
36046: GO 36147
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36048: LD_VAR 0 3
36052: PPUSH
36053: LD_EXP 52
36057: PPUSH
36058: CALL 43001 0 2
36062: PUSH
36063: LD_VAR 0 3
36067: PPUSH
36068: CALL 25022 0 1
36072: PUSH
36073: LD_INT 0
36075: EQUAL
36076: AND
36077: IFFALSE 36147
// begin for i = 1 to MREG_ToDismantle do
36079: LD_ADDR_VAR 0 2
36083: PUSH
36084: DOUBLE
36085: LD_INT 1
36087: DEC
36088: ST_TO_ADDR
36089: LD_EXP 52
36093: PUSH
36094: FOR_TO
36095: IFFALSE 36145
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36097: LD_EXP 52
36101: PUSH
36102: LD_VAR 0 2
36106: ARRAY
36107: PUSH
36108: LD_INT 1
36110: ARRAY
36111: PUSH
36112: LD_VAR 0 3
36116: EQUAL
36117: IFFALSE 36143
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36119: LD_VAR 0 3
36123: PPUSH
36124: LD_EXP 52
36128: PUSH
36129: LD_VAR 0 2
36133: ARRAY
36134: PUSH
36135: LD_INT 2
36137: ARRAY
36138: PPUSH
36139: CALL 10902 0 2
// end ;
36143: GO 36094
36145: POP
36146: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36147: LD_VAR 0 3
36151: PPUSH
36152: LD_INT 30
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PPUSH
36162: CALL 11667 0 2
36166: PUSH
36167: LD_VAR 0 3
36171: PPUSH
36172: CALL 25022 0 1
36176: PUSH
36177: LD_INT 0
36179: EQUAL
36180: AND
36181: IFFALSE 36192
// MCT_CollectCrates ( side ) ;
36183: LD_VAR 0 3
36187: PPUSH
36188: CALL 23961 0 1
// end ;
36192: GO 34193
36194: POP
36195: POP
// end ;
36196: LD_VAR 0 1
36200: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36201: LD_INT 0
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
36216: PPUSH
36217: PPUSH
// all := MCF_All ( side , [ ] ) ;
36218: LD_ADDR_VAR 0 17
36222: PUSH
36223: LD_VAR 0 1
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11802 0 2
36234: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36235: LD_ADDR_VAR 0 13
36239: PUSH
36240: LD_VAR 0 1
36244: PPUSH
36245: LD_INT 1
36247: PPUSH
36248: EMPTY
36249: PPUSH
36250: CALL 11750 0 3
36254: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36255: LD_ADDR_VAR 0 14
36259: PUSH
36260: LD_VAR 0 1
36264: PPUSH
36265: LD_INT 2
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL 11750 0 3
36274: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36275: LD_ADDR_VAR 0 15
36279: PUSH
36280: LD_VAR 0 1
36284: PPUSH
36285: LD_INT 3
36287: PPUSH
36288: EMPTY
36289: PPUSH
36290: CALL 11750 0 3
36294: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36295: LD_ADDR_VAR 0 16
36299: PUSH
36300: LD_VAR 0 1
36304: PPUSH
36305: LD_INT 4
36307: PPUSH
36308: EMPTY
36309: PPUSH
36310: CALL 11750 0 3
36314: ST_TO_ADDR
// if mech then
36315: LD_VAR 0 15
36319: IFFALSE 36336
// mech := MCF_SortListDesc ( mech ) ;
36321: LD_ADDR_VAR 0 15
36325: PUSH
36326: LD_VAR 0 15
36330: PPUSH
36331: CALL 12916 0 1
36335: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36336: LD_EXP 56
36340: PUSH
36341: LD_VAR 0 1
36345: ARRAY
36346: PUSH
36347: LD_STRING 
36349: EQUAL
36350: NOT
36351: IFFALSE 36407
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36353: LD_EXP 56
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_INT 1
36366: ARRAY
36367: PPUSH
36368: CALL_OW 257
36372: PUSH
36373: LD_INT 1
36375: EQUAL
36376: IFFALSE 36405
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36378: LD_VAR 0 1
36382: PPUSH
36383: LD_STRING ToArm
36385: PPUSH
36386: LD_EXP 56
36390: PUSH
36391: LD_VAR 0 1
36395: ARRAY
36396: PUSH
36397: LD_INT 1
36399: ARRAY
36400: PPUSH
36401: CALL 14546 0 3
// end else
36405: GO 36433
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36407: LD_ADDR_EXP 56
36411: PUSH
36412: LD_EXP 56
36416: PPUSH
36417: LD_VAR 0 1
36421: PPUSH
36422: LD_INT 1
36424: PPUSH
36425: LD_INT 0
36427: PPUSH
36428: CALL 31132 0 4
36432: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36433: LD_EXP 57
36437: PUSH
36438: LD_VAR 0 1
36442: ARRAY
36443: PUSH
36444: LD_STRING 
36446: EQUAL
36447: NOT
36448: IFFALSE 36504
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_INT 1
36463: ARRAY
36464: PPUSH
36465: CALL_OW 257
36469: PUSH
36470: LD_INT 2
36472: EQUAL
36473: IFFALSE 36502
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36475: LD_VAR 0 1
36479: PPUSH
36480: LD_STRING ToDep
36482: PPUSH
36483: LD_EXP 57
36487: PUSH
36488: LD_VAR 0 1
36492: ARRAY
36493: PUSH
36494: LD_INT 1
36496: ARRAY
36497: PPUSH
36498: CALL 14546 0 3
// end else
36502: GO 36530
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36504: LD_ADDR_EXP 57
36508: PUSH
36509: LD_EXP 57
36513: PPUSH
36514: LD_VAR 0 1
36518: PPUSH
36519: LD_INT 1
36521: PPUSH
36522: LD_INT 0
36524: PPUSH
36525: CALL 31132 0 4
36529: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36530: LD_EXP 55
36534: PUSH
36535: LD_VAR 0 1
36539: ARRAY
36540: PUSH
36541: LD_STRING 
36543: EQUAL
36544: NOT
36545: IFFALSE 36601
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36547: LD_EXP 55
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_INT 1
36560: ARRAY
36561: PPUSH
36562: CALL_OW 257
36566: PUSH
36567: LD_INT 3
36569: EQUAL
36570: IFFALSE 36599
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36572: LD_VAR 0 1
36576: PPUSH
36577: LD_STRING ToFac
36579: PPUSH
36580: LD_EXP 55
36584: PUSH
36585: LD_VAR 0 1
36589: ARRAY
36590: PUSH
36591: LD_INT 1
36593: ARRAY
36594: PPUSH
36595: CALL 14546 0 3
// end else
36599: GO 36627
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36601: LD_ADDR_EXP 55
36605: PUSH
36606: LD_EXP 55
36610: PPUSH
36611: LD_VAR 0 1
36615: PPUSH
36616: LD_INT 1
36618: PPUSH
36619: LD_INT 0
36621: PPUSH
36622: CALL 31132 0 4
36626: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36627: LD_EXP 54
36631: PUSH
36632: LD_VAR 0 1
36636: ARRAY
36637: PUSH
36638: LD_STRING 
36640: EQUAL
36641: NOT
36642: IFFALSE 36698
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36644: LD_EXP 54
36648: PUSH
36649: LD_VAR 0 1
36653: ARRAY
36654: PUSH
36655: LD_INT 1
36657: ARRAY
36658: PPUSH
36659: CALL_OW 257
36663: PUSH
36664: LD_INT 4
36666: EQUAL
36667: IFFALSE 36696
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36669: LD_VAR 0 1
36673: PPUSH
36674: LD_STRING ToLab
36676: PPUSH
36677: LD_EXP 54
36681: PUSH
36682: LD_VAR 0 1
36686: ARRAY
36687: PUSH
36688: LD_INT 1
36690: ARRAY
36691: PPUSH
36692: CALL 14546 0 3
// end else
36696: GO 36724
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36698: LD_ADDR_EXP 54
36702: PUSH
36703: LD_EXP 54
36707: PPUSH
36708: LD_VAR 0 1
36712: PPUSH
36713: LD_INT 1
36715: PPUSH
36716: LD_INT 0
36718: PPUSH
36719: CALL 31132 0 4
36723: ST_TO_ADDR
// if mode = 0 then
36724: LD_VAR 0 2
36728: PUSH
36729: LD_INT 0
36731: EQUAL
36732: IFFALSE 38570
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36734: LD_VAR 0 1
36738: PPUSH
36739: LD_INT 30
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PPUSH
36749: CALL 11667 0 2
36753: PUSH
36754: LD_VAR 0 1
36758: PPUSH
36759: LD_INT 21
36761: PUSH
36762: LD_INT 3
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PPUSH
36769: CALL 11667 0 2
36773: PUSH
36774: LD_INT 1
36776: EQUAL
36777: AND
36778: IFFALSE 36843
// begin if all then
36780: LD_VAR 0 17
36784: IFFALSE 36841
// for i in ( all diff eng ) do
36786: LD_ADDR_VAR 0 4
36790: PUSH
36791: LD_VAR 0 17
36795: PUSH
36796: LD_VAR 0 14
36800: DIFF
36801: PUSH
36802: FOR_IN
36803: IFFALSE 36839
// if GetTag ( i ) = 0 then
36805: LD_VAR 0 4
36809: PPUSH
36810: CALL_OW 110
36814: PUSH
36815: LD_INT 0
36817: EQUAL
36818: IFFALSE 36837
// MCH_ChangeClass ( side , i , 2 ) ;
36820: LD_VAR 0 1
36824: PPUSH
36825: LD_VAR 0 4
36829: PPUSH
36830: LD_INT 2
36832: PPUSH
36833: CALL 16574 0 3
36837: GO 36802
36839: POP
36840: POP
// end else
36841: GO 37162
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36843: LD_VAR 0 13
36847: PUSH
36848: LD_EXP 56
36852: PUSH
36853: LD_VAR 0 1
36857: ARRAY
36858: PLUS
36859: PUSH
36860: LD_INT 22
36862: PUSH
36863: LD_VAR 0 1
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 30
36874: PUSH
36875: LD_INT 32
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PPUSH
36886: CALL_OW 69
36890: LESS
36891: IFFALSE 36916
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36893: LD_VAR 0 1
36897: PPUSH
36898: LD_VAR 0 14
36902: PUSH
36903: LD_INT 1
36905: ARRAY
36906: PPUSH
36907: LD_INT 1
36909: PPUSH
36910: CALL 16574 0 3
// end else
36914: GO 37162
// if sci < 6 and MCF_Lab ( side ) then
36916: LD_VAR 0 16
36920: PUSH
36921: LD_INT 6
36923: LESS
36924: PUSH
36925: LD_VAR 0 1
36929: PPUSH
36930: CALL 11706 0 1
36934: AND
36935: IFFALSE 37040
// begin if MREG_ToBunker [ side ] then
36937: LD_EXP 68
36941: PUSH
36942: LD_VAR 0 1
36946: ARRAY
36947: IFFALSE 36973
// tmp := sol diff MREG_ToBunker [ side ] else
36949: LD_ADDR_VAR 0 12
36953: PUSH
36954: LD_VAR 0 13
36958: PUSH
36959: LD_EXP 68
36963: PUSH
36964: LD_VAR 0 1
36968: ARRAY
36969: DIFF
36970: ST_TO_ADDR
36971: GO 36983
// tmp := sol ;
36973: LD_ADDR_VAR 0 12
36977: PUSH
36978: LD_VAR 0 13
36982: ST_TO_ADDR
// if tmp then
36983: LD_VAR 0 12
36987: IFFALSE 37038
// for i in tmp do
36989: LD_ADDR_VAR 0 4
36993: PUSH
36994: LD_VAR 0 12
36998: PUSH
36999: FOR_IN
37000: IFFALSE 37036
// if GetTag ( i ) = 0 then
37002: LD_VAR 0 4
37006: PPUSH
37007: CALL_OW 110
37011: PUSH
37012: LD_INT 0
37014: EQUAL
37015: IFFALSE 37034
// MCH_ChangeClass ( side , i , 4 ) ;
37017: LD_VAR 0 1
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: LD_INT 4
37029: PPUSH
37030: CALL 16574 0 3
37034: GO 36999
37036: POP
37037: POP
// end else
37038: GO 37162
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37040: LD_VAR 0 1
37044: PPUSH
37045: LD_INT 30
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: CALL 11667 0 2
37059: IFFALSE 37162
// begin if MREG_ToBunker [ side ] then
37061: LD_EXP 68
37065: PUSH
37066: LD_VAR 0 1
37070: ARRAY
37071: IFFALSE 37097
// tmp := sol diff MREG_ToBunker [ side ] else
37073: LD_ADDR_VAR 0 12
37077: PUSH
37078: LD_VAR 0 13
37082: PUSH
37083: LD_EXP 68
37087: PUSH
37088: LD_VAR 0 1
37092: ARRAY
37093: DIFF
37094: ST_TO_ADDR
37095: GO 37107
// tmp := sol ;
37097: LD_ADDR_VAR 0 12
37101: PUSH
37102: LD_VAR 0 13
37106: ST_TO_ADDR
// if tmp then
37107: LD_VAR 0 12
37111: IFFALSE 37162
// for i in tmp do
37113: LD_ADDR_VAR 0 4
37117: PUSH
37118: LD_VAR 0 12
37122: PUSH
37123: FOR_IN
37124: IFFALSE 37160
// if GetTag ( i ) = 0 then
37126: LD_VAR 0 4
37130: PPUSH
37131: CALL_OW 110
37135: PUSH
37136: LD_INT 0
37138: EQUAL
37139: IFFALSE 37158
// MCH_ChangeClass ( side , i , 2 ) ;
37141: LD_VAR 0 1
37145: PPUSH
37146: LD_VAR 0 4
37150: PPUSH
37151: LD_INT 2
37153: PPUSH
37154: CALL 16574 0 3
37158: GO 37123
37160: POP
37161: POP
// end ; if MCF_Lab ( side ) then
37162: LD_VAR 0 1
37166: PPUSH
37167: CALL 11706 0 1
37171: IFFALSE 37711
// begin if MCL_GetTechList ( side ) then
37173: LD_VAR 0 1
37177: PPUSH
37178: CALL 18050 0 1
37182: IFFALSE 37308
// begin if MREG_ToLab [ side ] then
37184: LD_EXP 54
37188: PUSH
37189: LD_VAR 0 1
37193: ARRAY
37194: IFFALSE 37214
// k := MREG_ToLab [ side ] else
37196: LD_ADDR_VAR 0 8
37200: PUSH
37201: LD_EXP 54
37205: PUSH
37206: LD_VAR 0 1
37210: ARRAY
37211: ST_TO_ADDR
37212: GO 37222
// k := 0 ;
37214: LD_ADDR_VAR 0 8
37218: PUSH
37219: LD_INT 0
37221: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37222: LD_VAR 0 16
37226: PUSH
37227: LD_VAR 0 8
37231: PLUS
37232: PUSH
37233: LD_INT 6
37235: LESSEQUAL
37236: PUSH
37237: LD_VAR 0 17
37241: PUSH
37242: LD_INT 6
37244: GREATER
37245: AND
37246: IFFALSE 37262
// MCH_TrainScientist ( side , 1 ) else
37248: LD_VAR 0 1
37252: PPUSH
37253: LD_INT 1
37255: PPUSH
37256: CALL 16126 0 2
37260: GO 37306
// if all < 6 then
37262: LD_VAR 0 17
37266: PUSH
37267: LD_INT 6
37269: LESS
37270: IFFALSE 37306
// if sci + k < all / 2 then
37272: LD_VAR 0 16
37276: PUSH
37277: LD_VAR 0 8
37281: PLUS
37282: PUSH
37283: LD_VAR 0 17
37287: PUSH
37288: LD_INT 2
37290: DIVREAL
37291: LESS
37292: IFFALSE 37306
// MCH_TrainScientist ( side , 1 ) ;
37294: LD_VAR 0 1
37298: PPUSH
37299: LD_INT 1
37301: PPUSH
37302: CALL 16126 0 2
// end else
37306: GO 37384
// begin if sci > 2 then
37308: LD_VAR 0 16
37312: PUSH
37313: LD_INT 2
37315: GREATER
37316: IFFALSE 37384
// for i = sci downto 2 do
37318: LD_ADDR_VAR 0 4
37322: PUSH
37323: DOUBLE
37324: LD_VAR 0 16
37328: INC
37329: ST_TO_ADDR
37330: LD_INT 2
37332: PUSH
37333: FOR_DOWNTO
37334: IFFALSE 37382
// if GetTag ( sci [ i ] ) = 0 then
37336: LD_VAR 0 16
37340: PUSH
37341: LD_VAR 0 4
37345: ARRAY
37346: PPUSH
37347: CALL_OW 110
37351: PUSH
37352: LD_INT 0
37354: EQUAL
37355: IFFALSE 37380
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37357: LD_VAR 0 1
37361: PPUSH
37362: LD_VAR 0 16
37366: PUSH
37367: LD_VAR 0 4
37371: ARRAY
37372: PPUSH
37373: LD_INT 2
37375: PPUSH
37376: CALL 16574 0 3
37380: GO 37333
37382: POP
37383: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37384: LD_VAR 0 1
37388: PPUSH
37389: CALL 18050 0 1
37393: PUSH
37394: LD_VAR 0 1
37398: PPUSH
37399: CALL 11706 0 1
37403: AND
37404: PUSH
37405: LD_EXP 35
37409: PUSH
37410: LD_VAR 0 1
37414: ARRAY
37415: NOT
37416: AND
37417: IFFALSE 37711
// begin for j = 1 to MCF_Lab ( side ) do
37419: LD_ADDR_VAR 0 5
37423: PUSH
37424: DOUBLE
37425: LD_INT 1
37427: DEC
37428: ST_TO_ADDR
37429: LD_VAR 0 1
37433: PPUSH
37434: CALL 11706 0 1
37438: PUSH
37439: FOR_TO
37440: IFFALSE 37500
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37442: LD_VAR 0 1
37446: PPUSH
37447: CALL 11706 0 1
37451: PUSH
37452: LD_VAR 0 5
37456: ARRAY
37457: PPUSH
37458: CALL_OW 461
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: LD_INT 6
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: IN
37473: IFFALSE 37498
// begin b := MCF_Lab ( side ) [ j ] ;
37475: LD_ADDR_VAR 0 11
37479: PUSH
37480: LD_VAR 0 1
37484: PPUSH
37485: CALL 11706 0 1
37489: PUSH
37490: LD_VAR 0 5
37494: ARRAY
37495: ST_TO_ADDR
// break ;
37496: GO 37500
// end ;
37498: GO 37439
37500: POP
37501: POP
// if MCF_Class ( side , 4 , [ ] ) then
37502: LD_VAR 0 1
37506: PPUSH
37507: LD_INT 4
37509: PPUSH
37510: EMPTY
37511: PPUSH
37512: CALL 11750 0 3
37516: IFFALSE 37711
// for j in MCF_Class ( side , 4 , [ ] ) do
37518: LD_ADDR_VAR 0 5
37522: PUSH
37523: LD_VAR 0 1
37527: PPUSH
37528: LD_INT 4
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL 11750 0 3
37537: PUSH
37538: FOR_IN
37539: IFFALSE 37709
// begin if GetTag ( j ) = 0 then
37541: LD_VAR 0 5
37545: PPUSH
37546: CALL_OW 110
37550: PUSH
37551: LD_INT 0
37553: EQUAL
37554: IFFALSE 37645
// begin if IsInUnit ( j ) and b then
37556: LD_VAR 0 5
37560: PPUSH
37561: CALL_OW 310
37565: PUSH
37566: LD_VAR 0 11
37570: AND
37571: IFFALSE 37619
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37573: LD_VAR 0 5
37577: PPUSH
37578: CALL_OW 310
37582: PPUSH
37583: CALL_OW 461
37587: PUSH
37588: LD_INT 2
37590: EQUAL
37591: PUSH
37592: LD_VAR 0 5
37596: PPUSH
37597: CALL_OW 310
37601: PUSH
37602: LD_VAR 0 11
37606: NONEQUAL
37607: AND
37608: IFFALSE 37619
// ComExitBuilding ( j ) ;
37610: LD_VAR 0 5
37614: PPUSH
37615: CALL_OW 122
// if not IsInUnit ( j ) then
37619: LD_VAR 0 5
37623: PPUSH
37624: CALL_OW 310
37628: NOT
37629: IFFALSE 37645
// ComEnterUnit ( j , b ) ;
37631: LD_VAR 0 5
37635: PPUSH
37636: LD_VAR 0 11
37640: PPUSH
37641: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37645: LD_INT 1
37647: PPUSH
37648: LD_VAR 0 5
37652: PPUSH
37653: CALL_OW 255
37657: PPUSH
37658: CALL_OW 321
37662: PUSH
37663: LD_INT 2
37665: EQUAL
37666: PUSH
37667: LD_VAR 0 5
37671: PPUSH
37672: CALL_OW 255
37676: PPUSH
37677: CALL 25022 0 1
37681: PUSH
37682: LD_INT 0
37684: EQUAL
37685: AND
37686: IFFALSE 37707
// MCN_Tame ( GetSide ( j ) , j ) ;
37688: LD_VAR 0 5
37692: PPUSH
37693: CALL_OW 255
37697: PPUSH
37698: LD_VAR 0 5
37702: PPUSH
37703: CALL 18569 0 2
// end ;
37707: GO 37538
37709: POP
37710: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37711: LD_VAR 0 1
37715: PPUSH
37716: LD_INT 30
37718: PUSH
37719: LD_INT 3
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PPUSH
37726: CALL 11667 0 2
37730: IFFALSE 37989
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37732: LD_ADDR_VAR 0 11
37736: PUSH
37737: LD_VAR 0 1
37741: PPUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 3
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PPUSH
37752: CALL 11667 0 2
37756: PUSH
37757: LD_INT 1
37759: ARRAY
37760: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37761: LD_ADDR_VAR 0 12
37765: PUSH
37766: LD_VAR 0 1
37770: PPUSH
37771: LD_INT 0
37773: PPUSH
37774: LD_INT 25
37776: PUSH
37777: LD_INT 3
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PPUSH
37784: CALL 12370 0 3
37788: ST_TO_ADDR
// for i = 1 to tmp do
37789: LD_ADDR_VAR 0 4
37793: PUSH
37794: DOUBLE
37795: LD_INT 1
37797: DEC
37798: ST_TO_ADDR
37799: LD_VAR 0 12
37803: PUSH
37804: FOR_TO
37805: IFFALSE 37865
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37807: LD_VAR 0 12
37811: PUSH
37812: LD_VAR 0 4
37816: ARRAY
37817: PPUSH
37818: CALL_OW 310
37822: NOT
37823: PUSH
37824: LD_VAR 0 12
37828: PUSH
37829: LD_VAR 0 4
37833: ARRAY
37834: PPUSH
37835: CALL_OW 314
37839: NOT
37840: AND
37841: IFFALSE 37863
// ComEnterUnit ( tmp [ i ] , b ) ;
37843: LD_VAR 0 12
37847: PUSH
37848: LD_VAR 0 4
37852: ARRAY
37853: PPUSH
37854: LD_VAR 0 11
37858: PPUSH
37859: CALL_OW 120
37863: GO 37804
37865: POP
37866: POP
// if MREG_ToFac [ side ] then
37867: LD_EXP 55
37871: PUSH
37872: LD_VAR 0 1
37876: ARRAY
37877: IFFALSE 37897
// k := MREG_ToFac [ side ] else
37879: LD_ADDR_VAR 0 8
37883: PUSH
37884: LD_EXP 55
37888: PUSH
37889: LD_VAR 0 1
37893: ARRAY
37894: ST_TO_ADDR
37895: GO 37905
// k := 0 ;
37897: LD_ADDR_VAR 0 8
37901: PUSH
37902: LD_INT 0
37904: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37905: LD_VAR 0 15
37909: PUSH
37910: LD_VAR 0 8
37914: PLUS
37915: PUSH
37916: LD_INT 6
37918: LESSEQUAL
37919: PUSH
37920: LD_VAR 0 17
37924: PUSH
37925: LD_INT 6
37927: GREATER
37928: AND
37929: IFFALSE 37945
// MCH_TrainMechanic ( side , 1 ) else
37931: LD_VAR 0 1
37935: PPUSH
37936: LD_INT 1
37938: PPUSH
37939: CALL 15868 0 2
37943: GO 37989
// if all < 6 then
37945: LD_VAR 0 17
37949: PUSH
37950: LD_INT 6
37952: LESS
37953: IFFALSE 37989
// if mech + k < all / 2 then
37955: LD_VAR 0 15
37959: PUSH
37960: LD_VAR 0 8
37964: PLUS
37965: PUSH
37966: LD_VAR 0 17
37970: PUSH
37971: LD_INT 2
37973: DIVREAL
37974: LESS
37975: IFFALSE 37989
// MCH_TrainMechanic ( side , 1 ) ;
37977: LD_VAR 0 1
37981: PPUSH
37982: LD_INT 1
37984: PPUSH
37985: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37989: LD_ADDR_VAR 0 10
37993: PUSH
37994: LD_VAR 0 1
37998: PPUSH
37999: LD_INT 30
38001: PUSH
38002: LD_INT 36
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PPUSH
38009: CALL 11667 0 2
38013: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38014: LD_VAR 0 10
38018: PUSH
38019: LD_VAR 0 15
38023: AND
38024: PUSH
38025: LD_VAR 0 1
38029: PPUSH
38030: LD_INT 3
38032: PPUSH
38033: EMPTY
38034: PPUSH
38035: CALL 11750 0 3
38039: AND
38040: IFFALSE 38198
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38042: LD_VAR 0 1
38046: PPUSH
38047: LD_INT 9
38049: PPUSH
38050: EMPTY
38051: PPUSH
38052: CALL 12370 0 3
38056: PUSH
38057: LD_INT 3
38059: LESS
38060: IFFALSE 38198
// begin if mech < 3 then
38062: LD_VAR 0 15
38066: PUSH
38067: LD_INT 3
38069: LESS
38070: IFFALSE 38084
// k := mech else
38072: LD_ADDR_VAR 0 8
38076: PUSH
38077: LD_VAR 0 15
38081: ST_TO_ADDR
38082: GO 38092
// k := 3 ;
38084: LD_ADDR_VAR 0 8
38088: PUSH
38089: LD_INT 3
38091: ST_TO_ADDR
// for j = 1 to k do
38092: LD_ADDR_VAR 0 5
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_VAR 0 8
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38166
// if GetClass ( mech [ j ] ) = 3 then
38110: LD_VAR 0 15
38114: PUSH
38115: LD_VAR 0 5
38119: ARRAY
38120: PPUSH
38121: CALL_OW 257
38125: PUSH
38126: LD_INT 3
38128: EQUAL
38129: IFFALSE 38164
// begin SetTag ( mech [ j ] , 9 ) ;
38131: LD_VAR 0 15
38135: PUSH
38136: LD_VAR 0 5
38140: ARRAY
38141: PPUSH
38142: LD_INT 9
38144: PPUSH
38145: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38149: LD_VAR 0 15
38153: PUSH
38154: LD_VAR 0 5
38158: ARRAY
38159: PPUSH
38160: CALL_OW 122
// end ;
38164: GO 38107
38166: POP
38167: POP
// if mech < 6 + k then
38168: LD_VAR 0 15
38172: PUSH
38173: LD_INT 6
38175: PUSH
38176: LD_VAR 0 8
38180: PLUS
38181: LESS
38182: IFFALSE 38198
// MCH_TrainMechanic ( side , k ) ;
38184: LD_VAR 0 1
38188: PPUSH
38189: LD_VAR 0 8
38193: PPUSH
38194: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_INT 9
38205: PPUSH
38206: EMPTY
38207: PPUSH
38208: CALL 12370 0 3
38212: IFFALSE 38303
// for j in MCF_Tag ( side , 9 , [ ] ) do
38214: LD_ADDR_VAR 0 5
38218: PUSH
38219: LD_VAR 0 1
38223: PPUSH
38224: LD_INT 9
38226: PPUSH
38227: EMPTY
38228: PPUSH
38229: CALL 12370 0 3
38233: PUSH
38234: FOR_IN
38235: IFFALSE 38301
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38237: LD_VAR 0 5
38241: PPUSH
38242: CALL_OW 310
38246: NOT
38247: PUSH
38248: LD_VAR 0 5
38252: PPUSH
38253: CALL 94965 0 1
38257: NOT
38258: AND
38259: IFFALSE 38299
// if ct then
38261: LD_VAR 0 10
38265: IFFALSE 38287
// ComEnterUnit ( j , ct [ 1 ] ) else
38267: LD_VAR 0 5
38271: PPUSH
38272: LD_VAR 0 10
38276: PUSH
38277: LD_INT 1
38279: ARRAY
38280: PPUSH
38281: CALL_OW 120
38285: GO 38299
// SetTag ( j , 0 ) ;
38287: LD_VAR 0 5
38291: PPUSH
38292: LD_INT 0
38294: PPUSH
38295: CALL_OW 109
38299: GO 38234
38301: POP
38302: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38303: LD_INT 1
38305: PPUSH
38306: LD_VAR 0 1
38310: PPUSH
38311: CALL_OW 321
38315: PUSH
38316: LD_INT 2
38318: EQUAL
38319: PUSH
38320: LD_EXP 35
38324: PUSH
38325: LD_VAR 0 1
38329: ARRAY
38330: NOT
38331: AND
38332: PUSH
38333: LD_VAR 0 1
38337: PPUSH
38338: LD_INT 4
38340: PPUSH
38341: EMPTY
38342: PPUSH
38343: CALL 11750 0 3
38347: AND
38348: IFFALSE 38396
// for j in MCF_Class ( side , 4 , [ ] ) do
38350: LD_ADDR_VAR 0 5
38354: PUSH
38355: LD_VAR 0 1
38359: PPUSH
38360: LD_INT 4
38362: PPUSH
38363: EMPTY
38364: PPUSH
38365: CALL 11750 0 3
38369: PUSH
38370: FOR_IN
38371: IFFALSE 38394
// MCN_Tame ( GetSide ( j ) , j ) ;
38373: LD_VAR 0 5
38377: PPUSH
38378: CALL_OW 255
38382: PPUSH
38383: LD_VAR 0 5
38387: PPUSH
38388: CALL 18569 0 2
38392: GO 38370
38394: POP
38395: POP
// if MREG_DefVeh [ side ] then
38396: LD_EXP 67
38400: PUSH
38401: LD_VAR 0 1
38405: ARRAY
38406: IFFALSE 38570
// begin for i in MREG_DefVeh [ side ] do
38408: LD_ADDR_VAR 0 4
38412: PUSH
38413: LD_EXP 67
38417: PUSH
38418: LD_VAR 0 1
38422: ARRAY
38423: PUSH
38424: FOR_IN
38425: IFFALSE 38478
// begin SetTag ( i , 0 ) ;
38427: LD_VAR 0 4
38431: PPUSH
38432: LD_INT 0
38434: PPUSH
38435: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_EXP 64
38448: PUSH
38449: LD_VAR 0 1
38453: ARRAY
38454: PPUSH
38455: CALL_OW 308
38459: NOT
38460: IFFALSE 38476
// MCV_Parking ( side , i ) ;
38462: LD_VAR 0 1
38466: PPUSH
38467: LD_VAR 0 4
38471: PPUSH
38472: CALL 25757 0 2
// end ;
38476: GO 38424
38478: POP
38479: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38480: LD_VAR 0 1
38484: PPUSH
38485: LD_INT 36
38487: PPUSH
38488: EMPTY
38489: PPUSH
38490: CALL 12370 0 3
38494: IFFALSE 38535
// for i in MCF_Tag ( side , 36 , [ ] ) do
38496: LD_ADDR_VAR 0 4
38500: PUSH
38501: LD_VAR 0 1
38505: PPUSH
38506: LD_INT 36
38508: PPUSH
38509: EMPTY
38510: PPUSH
38511: CALL 12370 0 3
38515: PUSH
38516: FOR_IN
38517: IFFALSE 38533
// SetTag ( i , 0 ) ;
38519: LD_VAR 0 4
38523: PPUSH
38524: LD_INT 0
38526: PPUSH
38527: CALL_OW 109
38531: GO 38516
38533: POP
38534: POP
// if MREG_DefMobActive [ side ] then
38535: LD_EXP 70
38539: PUSH
38540: LD_VAR 0 1
38544: ARRAY
38545: IFFALSE 38570
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38547: LD_ADDR_EXP 70
38551: PUSH
38552: LD_EXP 70
38556: PPUSH
38557: LD_VAR 0 1
38561: PPUSH
38562: LD_INT 0
38564: PPUSH
38565: CALL_OW 1
38569: ST_TO_ADDR
// end ; end ; if mode > 0 then
38570: LD_VAR 0 2
38574: PUSH
38575: LD_INT 0
38577: GREATER
38578: IFFALSE 40473
// begin if tick <= 15 15$00 then
38580: LD_OWVAR 1
38584: PUSH
38585: LD_INT 31500
38587: LESSEQUAL
38588: IFFALSE 38892
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38590: LD_VAR 0 13
38594: PUSH
38595: LD_VAR 0 1
38599: PPUSH
38600: CALL 25022 0 1
38604: PUSH
38605: LD_INT 4
38607: LESS
38608: AND
38609: IFFALSE 38720
// begin for i in sol do
38611: LD_ADDR_VAR 0 4
38615: PUSH
38616: LD_VAR 0 13
38620: PUSH
38621: FOR_IN
38622: IFFALSE 38718
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38624: LD_ADDR_VAR 0 8
38628: PUSH
38629: LD_VAR 0 1
38633: PPUSH
38634: CALL 25022 0 1
38638: PPUSH
38639: LD_VAR 0 4
38643: PPUSH
38644: CALL_OW 74
38648: ST_TO_ADDR
// if IsInUnit ( i ) then
38649: LD_VAR 0 4
38653: PPUSH
38654: CALL_OW 310
38658: IFFALSE 38669
// ComExitBuilding ( i ) ;
38660: LD_VAR 0 4
38664: PPUSH
38665: CALL_OW 122
// if not HasTask ( i ) and k then
38669: LD_VAR 0 4
38673: PPUSH
38674: CALL_OW 314
38678: NOT
38679: PUSH
38680: LD_VAR 0 8
38684: AND
38685: IFFALSE 38716
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38687: LD_VAR 0 4
38691: PPUSH
38692: LD_VAR 0 8
38696: PPUSH
38697: CALL_OW 250
38701: PPUSH
38702: LD_VAR 0 8
38706: PPUSH
38707: CALL_OW 251
38711: PPUSH
38712: CALL_OW 174
// end ;
38716: GO 38621
38718: POP
38719: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38720: LD_VAR 0 1
38724: PPUSH
38725: LD_INT 30
38727: PUSH
38728: LD_INT 5
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PPUSH
38735: CALL 11667 0 2
38739: IFFALSE 38890
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38741: LD_ADDR_VAR 0 11
38745: PUSH
38746: LD_VAR 0 1
38750: PPUSH
38751: LD_INT 30
38753: PUSH
38754: LD_INT 5
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PPUSH
38761: CALL 11667 0 2
38765: PUSH
38766: LD_INT 1
38768: ARRAY
38769: ST_TO_ADDR
// if mech then
38770: LD_VAR 0 15
38774: IFFALSE 38810
// for i in mech do
38776: LD_ADDR_VAR 0 4
38780: PUSH
38781: LD_VAR 0 15
38785: PUSH
38786: FOR_IN
38787: IFFALSE 38808
// MCH_ChangeClass ( side , i , 1 ) ;
38789: LD_VAR 0 1
38793: PPUSH
38794: LD_VAR 0 4
38798: PPUSH
38799: LD_INT 1
38801: PPUSH
38802: CALL 16574 0 3
38806: GO 38786
38808: POP
38809: POP
// if eng > 1 then
38810: LD_VAR 0 14
38814: PUSH
38815: LD_INT 1
38817: GREATER
38818: IFFALSE 38865
// for i = eng downto 2 do
38820: LD_ADDR_VAR 0 4
38824: PUSH
38825: DOUBLE
38826: LD_VAR 0 14
38830: INC
38831: ST_TO_ADDR
38832: LD_INT 2
38834: PUSH
38835: FOR_DOWNTO
38836: IFFALSE 38863
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38838: LD_VAR 0 1
38842: PPUSH
38843: LD_VAR 0 14
38847: PUSH
38848: LD_VAR 0 4
38852: ARRAY
38853: PPUSH
38854: LD_INT 1
38856: PPUSH
38857: CALL 16574 0 3
38861: GO 38835
38863: POP
38864: POP
// if UnitsInside ( b ) then
38865: LD_VAR 0 11
38869: PPUSH
38870: CALL_OW 313
38874: IFFALSE 38890
// ComExitBuilding ( UnitsInside ( b ) ) ;
38876: LD_VAR 0 11
38880: PPUSH
38881: CALL_OW 313
38885: PPUSH
38886: CALL_OW 122
// end ; end else
38890: GO 40473
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38892: LD_VAR 0 1
38896: PPUSH
38897: LD_INT 1
38899: PPUSH
38900: LD_EXP 65
38904: PUSH
38905: LD_VAR 0 1
38909: ARRAY
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PPUSH
38915: CALL 33745 0 3
38919: IFFALSE 39058
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38921: LD_ADDR_VAR 0 12
38925: PUSH
38926: LD_VAR 0 1
38930: PPUSH
38931: LD_INT 21
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PPUSH
38941: CALL 11667 0 2
38945: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38946: LD_ADDR_VAR 0 11
38950: PUSH
38951: LD_VAR 0 1
38955: PPUSH
38956: LD_INT 30
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PPUSH
38966: CALL 11667 0 2
38970: ST_TO_ADDR
// if b then
38971: LD_VAR 0 11
38975: IFFALSE 39058
// for i in tmp do
38977: LD_ADDR_VAR 0 4
38981: PUSH
38982: LD_VAR 0 12
38986: PUSH
38987: FOR_IN
38988: IFFALSE 39056
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38990: LD_VAR 0 4
38994: PPUSH
38995: LD_EXP 65
38999: PUSH
39000: LD_VAR 0 1
39004: ARRAY
39005: PUSH
39006: LD_INT 1
39008: ARRAY
39009: PPUSH
39010: CALL_OW 308
39014: NOT
39015: IFFALSE 39054
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39017: LD_VAR 0 4
39021: PPUSH
39022: LD_VAR 0 11
39026: PUSH
39027: LD_INT 1
39029: ARRAY
39030: PPUSH
39031: CALL_OW 250
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 251
39049: PPUSH
39050: CALL_OW 111
39054: GO 38987
39056: POP
39057: POP
// end ; if MREG_DefVeh [ side ] then
39058: LD_EXP 67
39062: PUSH
39063: LD_VAR 0 1
39067: ARRAY
39068: IFFALSE 39636
// begin tmp := [ ] ;
39070: LD_ADDR_VAR 0 12
39074: PUSH
39075: EMPTY
39076: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39077: LD_EXP 70
39081: PUSH
39082: LD_VAR 0 1
39086: ARRAY
39087: PUSH
39088: LD_INT 0
39090: EQUAL
39091: IFFALSE 39231
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39093: LD_ADDR_VAR 0 8
39097: PUSH
39098: LD_VAR 0 1
39102: PPUSH
39103: LD_INT 0
39105: PPUSH
39106: LD_INT 25
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PPUSH
39116: CALL 12370 0 3
39120: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39121: LD_VAR 0 8
39125: PUSH
39126: LD_EXP 67
39130: PUSH
39131: LD_VAR 0 1
39135: ARRAY
39136: GREATER
39137: IFFALSE 39198
// begin for i = 1 to MREG_DefVeh [ side ] do
39139: LD_ADDR_VAR 0 4
39143: PUSH
39144: DOUBLE
39145: LD_INT 1
39147: DEC
39148: ST_TO_ADDR
39149: LD_EXP 67
39153: PUSH
39154: LD_VAR 0 1
39158: ARRAY
39159: PUSH
39160: FOR_TO
39161: IFFALSE 39194
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39163: LD_ADDR_VAR 0 12
39167: PUSH
39168: LD_VAR 0 12
39172: PPUSH
39173: LD_INT 1
39175: PPUSH
39176: LD_VAR 0 8
39180: PUSH
39181: LD_VAR 0 4
39185: ARRAY
39186: PPUSH
39187: CALL_OW 2
39191: ST_TO_ADDR
39192: GO 39160
39194: POP
39195: POP
// end else
39196: GO 39208
// tmp := k ;
39198: LD_ADDR_VAR 0 12
39202: PUSH
39203: LD_VAR 0 8
39207: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39208: LD_ADDR_EXP 70
39212: PUSH
39213: LD_EXP 70
39217: PPUSH
39218: LD_VAR 0 1
39222: PPUSH
39223: LD_INT 1
39225: PPUSH
39226: CALL_OW 1
39230: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39231: LD_ADDR_VAR 0 4
39235: PUSH
39236: LD_EXP 67
39240: PUSH
39241: LD_VAR 0 1
39245: ARRAY
39246: PUSH
39247: FOR_IN
39248: IFFALSE 39634
// begin if not GetDriver ( i ) then
39250: LD_VAR 0 4
39254: PPUSH
39255: CALL 31775 0 1
39259: NOT
39260: IFFALSE 39335
// begin if tmp then
39262: LD_VAR 0 12
39266: IFFALSE 39333
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39268: LD_VAR 0 12
39272: PUSH
39273: LD_INT 1
39275: ARRAY
39276: PPUSH
39277: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39281: LD_VAR 0 12
39285: PUSH
39286: LD_INT 1
39288: ARRAY
39289: PPUSH
39290: LD_VAR 0 4
39294: PPUSH
39295: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39299: LD_VAR 0 12
39303: PUSH
39304: LD_INT 1
39306: ARRAY
39307: PPUSH
39308: LD_INT 36
39310: PPUSH
39311: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39315: LD_ADDR_VAR 0 12
39319: PUSH
39320: LD_VAR 0 12
39324: PPUSH
39325: LD_INT 1
39327: PPUSH
39328: CALL_OW 3
39332: ST_TO_ADDR
// end ; end else
39333: GO 39632
// begin if GetTag ( i ) = 0 then
39335: LD_VAR 0 4
39339: PPUSH
39340: CALL_OW 110
39344: PUSH
39345: LD_INT 0
39347: EQUAL
39348: IFFALSE 39364
// SetTag ( i , 31 ) else
39350: LD_VAR 0 4
39354: PPUSH
39355: LD_INT 31
39357: PPUSH
39358: CALL_OW 109
39362: GO 39632
// if GetTag ( i ) = 31 then
39364: LD_VAR 0 4
39368: PPUSH
39369: CALL_OW 110
39373: PUSH
39374: LD_INT 31
39376: EQUAL
39377: IFFALSE 39632
// begin if GetFuel ( i ) < 20 then
39379: LD_VAR 0 4
39383: PPUSH
39384: CALL_OW 261
39388: PUSH
39389: LD_INT 20
39391: LESS
39392: IFFALSE 39417
// begin SetTag ( i , 21 ) ;
39394: LD_VAR 0 4
39398: PPUSH
39399: LD_INT 21
39401: PPUSH
39402: CALL_OW 109
// MCV_Refuel ( i ) ;
39406: LD_VAR 0 4
39410: PPUSH
39411: CALL 26294 0 1
// continue ;
39415: GO 39247
// end ; if GetLives ( i ) < 700 then
39417: LD_VAR 0 4
39421: PPUSH
39422: CALL_OW 256
39426: PUSH
39427: LD_INT 700
39429: LESS
39430: IFFALSE 39542
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39432: LD_VAR 0 4
39436: PPUSH
39437: LD_EXP 58
39441: PUSH
39442: LD_VAR 0 1
39446: ARRAY
39447: PPUSH
39448: CALL_OW 308
39452: NOT
39453: IFFALSE 39477
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39455: LD_VAR 0 4
39459: PPUSH
39460: LD_EXP 58
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: CALL_OW 113
39475: GO 39540
// if GetDriver ( i ) then
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL 31775 0 1
39486: IFFALSE 39540
// begin k := GetDriver ( i ) ;
39488: LD_ADDR_VAR 0 8
39492: PUSH
39493: LD_VAR 0 4
39497: PPUSH
39498: CALL 31775 0 1
39502: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39503: LD_VAR 0 8
39507: PPUSH
39508: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39512: LD_VAR 0 8
39516: PPUSH
39517: LD_VAR 0 4
39521: PPUSH
39522: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 180
// end ; end else
39540: GO 39632
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39542: LD_ADDR_VAR 0 8
39546: PUSH
39547: LD_VAR 0 1
39551: PPUSH
39552: CALL 25022 0 1
39556: PPUSH
39557: LD_VAR 0 4
39561: PPUSH
39562: CALL_OW 74
39566: ST_TO_ADDR
// if k then
39567: LD_VAR 0 8
39571: IFFALSE 39589
// ComAttackUnit ( i , k ) else
39573: LD_VAR 0 4
39577: PPUSH
39578: LD_VAR 0 8
39582: PPUSH
39583: CALL_OW 115
39587: GO 39632
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39589: LD_VAR 0 4
39593: PPUSH
39594: LD_EXP 58
39598: PUSH
39599: LD_VAR 0 1
39603: ARRAY
39604: PPUSH
39605: CALL_OW 308
39609: NOT
39610: IFFALSE 39632
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39612: LD_VAR 0 4
39616: PPUSH
39617: LD_EXP 58
39621: PUSH
39622: LD_VAR 0 1
39626: ARRAY
39627: PPUSH
39628: CALL_OW 113
// end ; end ; end ; end ;
39632: GO 39247
39634: POP
39635: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39636: LD_VAR 0 1
39640: PPUSH
39641: LD_INT 30
39643: PUSH
39644: LD_INT 5
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PPUSH
39651: CALL 11667 0 2
39655: IFFALSE 40473
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39657: LD_ADDR_VAR 0 11
39661: PUSH
39662: LD_VAR 0 1
39666: PPUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 5
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PPUSH
39677: CALL 11667 0 2
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: ST_TO_ADDR
// if eng > 1 then
39686: LD_VAR 0 14
39690: PUSH
39691: LD_INT 1
39693: GREATER
39694: IFFALSE 39741
// for i = eng downto 2 do
39696: LD_ADDR_VAR 0 4
39700: PUSH
39701: DOUBLE
39702: LD_VAR 0 14
39706: INC
39707: ST_TO_ADDR
39708: LD_INT 2
39710: PUSH
39711: FOR_DOWNTO
39712: IFFALSE 39739
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39714: LD_VAR 0 1
39718: PPUSH
39719: LD_VAR 0 14
39723: PUSH
39724: LD_VAR 0 4
39728: ARRAY
39729: PPUSH
39730: LD_INT 1
39732: PPUSH
39733: CALL 16574 0 3
39737: GO 39711
39739: POP
39740: POP
// if sci > 1 then
39741: LD_VAR 0 16
39745: PUSH
39746: LD_INT 1
39748: GREATER
39749: IFFALSE 39796
// for i = sci downto 2 do
39751: LD_ADDR_VAR 0 4
39755: PUSH
39756: DOUBLE
39757: LD_VAR 0 16
39761: INC
39762: ST_TO_ADDR
39763: LD_INT 2
39765: PUSH
39766: FOR_DOWNTO
39767: IFFALSE 39794
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39769: LD_VAR 0 1
39773: PPUSH
39774: LD_VAR 0 16
39778: PUSH
39779: LD_VAR 0 4
39783: ARRAY
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: CALL 16574 0 3
39792: GO 39766
39794: POP
39795: POP
// if sol then
39796: LD_VAR 0 13
39800: IFFALSE 40473
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39802: LD_VAR 0 13
39806: PUSH
39807: LD_EXP 68
39811: PUSH
39812: LD_VAR 0 1
39816: ARRAY
39817: DIFF
39818: PUSH
39819: LD_INT 22
39821: PUSH
39822: LD_VAR 0 1
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 58
39833: PUSH
39834: EMPTY
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: PUSH
39840: LD_INT 30
39842: PUSH
39843: LD_INT 32
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 30
39852: PUSH
39853: LD_INT 31
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: PPUSH
39870: CALL_OW 69
39874: PUSH
39875: LD_INT 0
39877: EQUAL
39878: AND
39879: IFFALSE 40473
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39881: LD_ADDR_VAR 0 12
39885: PUSH
39886: LD_VAR 0 13
39890: PUSH
39891: LD_EXP 68
39895: PUSH
39896: LD_VAR 0 1
39900: ARRAY
39901: DIFF
39902: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39903: LD_VAR 0 1
39907: PPUSH
39908: LD_INT 30
39910: PUSH
39911: LD_INT 5
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PPUSH
39918: CALL 11667 0 2
39922: PUSH
39923: LD_INT 1
39925: GREATER
39926: IFFALSE 39957
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39928: LD_ADDR_VAR 0 8
39932: PUSH
39933: LD_VAR 0 1
39937: PPUSH
39938: LD_INT 30
39940: PUSH
39941: LD_INT 5
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PPUSH
39948: CALL 11667 0 2
39952: PUSH
39953: LD_INT 2
39955: ARRAY
39956: ST_TO_ADDR
// for j in tmp do
39957: LD_ADDR_VAR 0 5
39961: PUSH
39962: LD_VAR 0 12
39966: PUSH
39967: FOR_IN
39968: IFFALSE 40471
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39970: LD_VAR 0 5
39974: PUSH
39975: LD_VAR 0 11
39979: PPUSH
39980: CALL_OW 313
39984: IN
39985: PUSH
39986: LD_VAR 0 11
39990: PPUSH
39991: CALL_OW 313
39995: PUSH
39996: LD_INT 6
39998: EQUAL
39999: AND
40000: PUSH
40001: LD_VAR 0 8
40005: AND
40006: PUSH
40007: LD_VAR 0 8
40011: PPUSH
40012: CALL_OW 313
40016: PUSH
40017: LD_INT 6
40019: LESS
40020: AND
40021: IFFALSE 40048
// begin ComExitBuilding ( j ) ;
40023: LD_VAR 0 5
40027: PPUSH
40028: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40032: LD_VAR 0 5
40036: PPUSH
40037: LD_VAR 0 8
40041: PPUSH
40042: CALL_OW 180
// continue ;
40046: GO 39967
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40048: LD_VAR 0 5
40052: PPUSH
40053: CALL_OW 314
40057: NOT
40058: PUSH
40059: LD_VAR 0 5
40063: PPUSH
40064: CALL_OW 110
40068: PUSH
40069: LD_INT 0
40071: EQUAL
40072: AND
40073: PUSH
40074: LD_VAR 0 5
40078: PPUSH
40079: CALL_OW 310
40083: NOT
40084: AND
40085: IFFALSE 40191
// begin if k then
40087: LD_VAR 0 8
40091: IFFALSE 40162
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40093: LD_VAR 0 8
40097: PPUSH
40098: CALL_OW 313
40102: PUSH
40103: LD_VAR 0 11
40107: PPUSH
40108: CALL_OW 313
40112: LESS
40113: IFFALSE 40131
// ComEnterUnit ( j , k ) else
40115: LD_VAR 0 5
40119: PPUSH
40120: LD_VAR 0 8
40124: PPUSH
40125: CALL_OW 120
40129: GO 40160
// if UnitsInside ( b ) < 6 then
40131: LD_VAR 0 11
40135: PPUSH
40136: CALL_OW 313
40140: PUSH
40141: LD_INT 6
40143: LESS
40144: IFFALSE 40160
// ComEnterUnit ( j , b ) ;
40146: LD_VAR 0 5
40150: PPUSH
40151: LD_VAR 0 11
40155: PPUSH
40156: CALL_OW 120
// end else
40160: GO 40191
// if UnitsInside ( b ) < 6 then
40162: LD_VAR 0 11
40166: PPUSH
40167: CALL_OW 313
40171: PUSH
40172: LD_INT 6
40174: LESS
40175: IFFALSE 40191
// ComEnterUnit ( j , b ) ;
40177: LD_VAR 0 5
40181: PPUSH
40182: LD_VAR 0 11
40186: PPUSH
40187: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40191: LD_VAR 0 5
40195: PUSH
40196: LD_VAR 0 1
40200: PPUSH
40201: LD_INT 54
40203: PUSH
40204: EMPTY
40205: LIST
40206: PPUSH
40207: CALL 11667 0 2
40211: IN
40212: PUSH
40213: LD_VAR 0 5
40217: PPUSH
40218: CALL_OW 257
40222: PUSH
40223: LD_INT 1
40225: EQUAL
40226: AND
40227: IFFALSE 40469
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40229: LD_EXP 62
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 1
40242: ARRAY
40243: PUSH
40244: LD_INT 12
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 5
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11750 0 3
40277: PUSH
40278: LD_EXP 62
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 1
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_sniper ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 5
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39967
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40309: LD_EXP 62
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 2
40322: ARRAY
40323: PUSH
40324: LD_INT 41
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 8
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11750 0 3
40357: PUSH
40358: LD_EXP 62
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 2
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_mortar ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 8
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39967
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40389: LD_EXP 62
40393: PUSH
40394: LD_VAR 0 1
40398: ARRAY
40399: PUSH
40400: LD_INT 3
40402: ARRAY
40403: PUSH
40404: LD_INT 44
40406: PPUSH
40407: LD_VAR 0 1
40411: PPUSH
40412: CALL_OW 321
40416: PUSH
40417: LD_INT 2
40419: EQUAL
40420: AND
40421: IFFALSE 40469
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40423: LD_VAR 0 1
40427: PPUSH
40428: LD_INT 9
40430: PPUSH
40431: EMPTY
40432: PPUSH
40433: CALL 11750 0 3
40437: PUSH
40438: LD_EXP 62
40442: PUSH
40443: LD_VAR 0 1
40447: ARRAY
40448: PUSH
40449: LD_INT 3
40451: ARRAY
40452: LESS
40453: IFFALSE 40469
// begin SetClass ( j , class_bazooker ) ;
40455: LD_VAR 0 5
40459: PPUSH
40460: LD_INT 9
40462: PPUSH
40463: CALL_OW 336
// continue ;
40467: GO 39967
// end ; end ; end ;
40469: GO 39967
40471: POP
40472: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40473: LD_INT 22
40475: PUSH
40476: LD_VAR 0 1
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 58
40487: PUSH
40488: EMPTY
40489: LIST
40490: PUSH
40491: LD_INT 30
40493: PUSH
40494: LD_INT 32
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 69
40510: IFFALSE 40660
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40512: LD_ADDR_VAR 0 12
40516: PUSH
40517: LD_INT 22
40519: PUSH
40520: LD_VAR 0 1
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 58
40531: PUSH
40532: EMPTY
40533: LIST
40534: PUSH
40535: LD_INT 30
40537: PUSH
40538: LD_INT 32
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: LIST
40549: PPUSH
40550: CALL_OW 69
40554: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40555: LD_ADDR_VAR 0 8
40559: PUSH
40560: LD_VAR 0 13
40564: PUSH
40565: LD_EXP 68
40569: PUSH
40570: LD_VAR 0 1
40574: ARRAY
40575: DIFF
40576: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40577: LD_VAR 0 12
40581: PUSH
40582: LD_INT 1
40584: ARRAY
40585: PPUSH
40586: CALL_OW 461
40590: PUSH
40591: LD_INT 2
40593: EQUAL
40594: PUSH
40595: LD_VAR 0 12
40599: PUSH
40600: LD_INT 1
40602: ARRAY
40603: PUSH
40604: LD_EXP 68
40608: PUSH
40609: LD_VAR 0 1
40613: ARRAY
40614: IN
40615: NOT
40616: AND
40617: PUSH
40618: LD_VAR 0 8
40622: AND
40623: IFFALSE 40660
// begin ComExitBuilding ( k [ 1 ] ) ;
40625: LD_VAR 0 8
40629: PUSH
40630: LD_INT 1
40632: ARRAY
40633: PPUSH
40634: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40638: LD_VAR 0 8
40642: PUSH
40643: LD_INT 1
40645: ARRAY
40646: PPUSH
40647: LD_VAR 0 12
40651: PUSH
40652: LD_INT 1
40654: ARRAY
40655: PPUSH
40656: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40660: LD_EXP 35
40664: PUSH
40665: LD_VAR 0 1
40669: ARRAY
40670: IFFALSE 40818
// begin if MCF_Class ( side , 4 , [ ] ) then
40672: LD_VAR 0 1
40676: PPUSH
40677: LD_INT 4
40679: PPUSH
40680: EMPTY
40681: PPUSH
40682: CALL 11750 0 3
40686: IFFALSE 40816
// for j in MCF_Class ( side , 4 , [ ] ) do
40688: LD_ADDR_VAR 0 5
40692: PUSH
40693: LD_VAR 0 1
40697: PPUSH
40698: LD_INT 4
40700: PPUSH
40701: EMPTY
40702: PPUSH
40703: CALL 11750 0 3
40707: PUSH
40708: FOR_IN
40709: IFFALSE 40814
// begin if not GetTag ( j ) = 4 then
40711: LD_VAR 0 5
40715: PPUSH
40716: CALL_OW 110
40720: PUSH
40721: LD_INT 4
40723: EQUAL
40724: NOT
40725: IFFALSE 40761
// begin SetTag ( j , 4 ) ;
40727: LD_VAR 0 5
40731: PPUSH
40732: LD_INT 4
40734: PPUSH
40735: CALL_OW 109
// if IsInUnit ( j ) then
40739: LD_VAR 0 5
40743: PPUSH
40744: CALL_OW 310
40748: IFFALSE 40759
// ComExitBuilding ( j ) ;
40750: LD_VAR 0 5
40754: PPUSH
40755: CALL_OW 122
// end else
40759: GO 40812
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40761: LD_VAR 0 5
40765: PPUSH
40766: LD_EXP 35
40770: PUSH
40771: LD_VAR 0 1
40775: ARRAY
40776: PUSH
40777: LD_INT 1
40779: ARRAY
40780: PPUSH
40781: CALL 94589 0 2
40785: NOT
40786: IFFALSE 40812
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40788: LD_VAR 0 5
40792: PPUSH
40793: LD_EXP 35
40797: PUSH
40798: LD_VAR 0 1
40802: ARRAY
40803: PUSH
40804: LD_INT 1
40806: ARRAY
40807: PPUSH
40808: CALL 19237 0 2
// end ;
40812: GO 40708
40814: POP
40815: POP
// end else
40816: GO 41050
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40818: LD_VAR 0 1
40822: PPUSH
40823: LD_INT 4
40825: PPUSH
40826: EMPTY
40827: PPUSH
40828: CALL 11750 0 3
40832: PUSH
40833: LD_VAR 0 1
40837: PPUSH
40838: LD_INT 4
40840: PPUSH
40841: EMPTY
40842: PPUSH
40843: CALL 12370 0 3
40847: AND
40848: IFFALSE 41050
// for j in MCF_Class ( side , 4 , [ ] ) do
40850: LD_ADDR_VAR 0 5
40854: PUSH
40855: LD_VAR 0 1
40859: PPUSH
40860: LD_INT 4
40862: PPUSH
40863: EMPTY
40864: PPUSH
40865: CALL 11750 0 3
40869: PUSH
40870: FOR_IN
40871: IFFALSE 41048
// begin if GetTag ( j ) = 4 then
40873: LD_VAR 0 5
40877: PPUSH
40878: CALL_OW 110
40882: PUSH
40883: LD_INT 4
40885: EQUAL
40886: IFFALSE 41046
// begin SetTag ( j , 0 ) ;
40888: LD_VAR 0 5
40892: PPUSH
40893: LD_INT 0
40895: PPUSH
40896: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40900: LD_VAR 0 1
40904: PPUSH
40905: CALL 11706 0 1
40909: PUSH
40910: LD_VAR 0 1
40914: PPUSH
40915: CALL 18050 0 1
40919: NOT
40920: AND
40921: IFFALSE 40946
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40923: LD_VAR 0 5
40927: PPUSH
40928: LD_VAR 0 1
40932: PPUSH
40933: CALL 11706 0 1
40937: PUSH
40938: LD_INT 1
40940: ARRAY
40941: PPUSH
40942: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40946: LD_VAR 0 1
40950: PPUSH
40951: CALL 11706 0 1
40955: NOT
40956: PUSH
40957: LD_VAR 0 1
40961: PPUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PPUSH
40972: CALL 11667 0 2
40976: AND
40977: IFFALSE 41046
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40979: LD_VAR 0 5
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: LD_INT 30
40991: PUSH
40992: LD_INT 1
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PPUSH
40999: CALL 11667 0 2
41003: PUSH
41004: LD_INT 1
41006: ARRAY
41007: PPUSH
41008: CALL_OW 250
41012: PPUSH
41013: LD_VAR 0 1
41017: PPUSH
41018: LD_INT 30
41020: PUSH
41021: LD_INT 1
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PPUSH
41028: CALL 11667 0 2
41032: PUSH
41033: LD_INT 1
41035: ARRAY
41036: PPUSH
41037: CALL_OW 251
41041: PPUSH
41042: CALL_OW 111
// end ; end ;
41046: GO 40870
41048: POP
41049: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41050: LD_VAR 0 1
41054: PPUSH
41055: LD_INT 3
41057: PPUSH
41058: EMPTY
41059: PPUSH
41060: CALL 11750 0 3
41064: PUSH
41065: LD_EXP 58
41069: PUSH
41070: LD_VAR 0 1
41074: ARRAY
41075: AND
41076: PUSH
41077: LD_VAR 0 1
41081: PPUSH
41082: LD_INT 6
41084: PPUSH
41085: EMPTY
41086: PPUSH
41087: CALL 12370 0 3
41091: AND
41092: IFFALSE 41623
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41094: LD_ADDR_VAR 0 6
41098: PUSH
41099: LD_EXP 58
41103: PUSH
41104: LD_VAR 0 1
41108: ARRAY
41109: PPUSH
41110: LD_INT 0
41112: PPUSH
41113: CALL_OW 517
41117: PUSH
41118: LD_INT 1
41120: ARRAY
41121: PUSH
41122: LD_INT 1
41124: ARRAY
41125: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41126: LD_ADDR_VAR 0 7
41130: PUSH
41131: LD_EXP 58
41135: PUSH
41136: LD_VAR 0 1
41140: ARRAY
41141: PPUSH
41142: LD_INT 0
41144: PPUSH
41145: CALL_OW 517
41149: PUSH
41150: LD_INT 2
41152: ARRAY
41153: PUSH
41154: LD_INT 1
41156: ARRAY
41157: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41158: LD_VAR 0 1
41162: PPUSH
41163: LD_INT 6
41165: PPUSH
41166: EMPTY
41167: PPUSH
41168: CALL 12370 0 3
41172: IFFALSE 41621
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41174: LD_ADDR_VAR 0 8
41178: PUSH
41179: LD_VAR 0 1
41183: PPUSH
41184: LD_INT 6
41186: PPUSH
41187: EMPTY
41188: PPUSH
41189: CALL 12370 0 3
41193: PUSH
41194: FOR_IN
41195: IFFALSE 41226
// if GetLives ( k ) = 1000 then
41197: LD_VAR 0 8
41201: PPUSH
41202: CALL_OW 256
41206: PUSH
41207: LD_INT 1000
41209: EQUAL
41210: IFFALSE 41224
// SetTag ( k , 0 ) ;
41212: LD_VAR 0 8
41216: PPUSH
41217: LD_INT 0
41219: PPUSH
41220: CALL_OW 109
41224: GO 41194
41226: POP
41227: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41228: LD_VAR 0 1
41232: PPUSH
41233: LD_INT 0
41235: PPUSH
41236: LD_INT 25
41238: PUSH
41239: LD_INT 3
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PPUSH
41246: CALL 12370 0 3
41250: IFFALSE 41314
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41252: LD_ADDR_VAR 0 8
41256: PUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: LD_INT 0
41264: PPUSH
41265: LD_INT 25
41267: PUSH
41268: LD_INT 3
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PPUSH
41275: CALL 12370 0 3
41279: PUSH
41280: FOR_IN
41281: IFFALSE 41312
// if GetTag ( k ) = 0 then
41283: LD_VAR 0 8
41287: PPUSH
41288: CALL_OW 110
41292: PUSH
41293: LD_INT 0
41295: EQUAL
41296: IFFALSE 41310
// begin SetTag ( k , 8 ) ;
41298: LD_VAR 0 8
41302: PPUSH
41303: LD_INT 8
41305: PPUSH
41306: CALL_OW 109
// end ;
41310: GO 41280
41312: POP
41313: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41314: LD_VAR 0 1
41318: PPUSH
41319: LD_INT 6
41321: PPUSH
41322: LD_INT 92
41324: PUSH
41325: LD_VAR 0 6
41329: PUSH
41330: LD_VAR 0 7
41334: PUSH
41335: LD_INT 10
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: PPUSH
41344: CALL 12370 0 3
41348: IFFALSE 41472
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41350: LD_ADDR_VAR 0 5
41354: PUSH
41355: LD_VAR 0 4
41359: PPUSH
41360: LD_INT 6
41362: PPUSH
41363: LD_INT 92
41365: PUSH
41366: LD_VAR 0 6
41370: PUSH
41371: LD_VAR 0 7
41375: PUSH
41376: LD_INT 10
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: PPUSH
41385: CALL 12370 0 3
41389: PUSH
41390: FOR_IN
41391: IFFALSE 41470
// begin if not HasTask ( j ) and GetDriver ( j ) then
41393: LD_VAR 0 5
41397: PPUSH
41398: CALL_OW 314
41402: NOT
41403: PUSH
41404: LD_VAR 0 5
41408: PPUSH
41409: CALL 31775 0 1
41413: AND
41414: IFFALSE 41468
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41416: LD_VAR 0 5
41420: PPUSH
41421: CALL 31775 0 1
41425: PPUSH
41426: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31775 0 1
41439: PPUSH
41440: LD_VAR 0 5
41444: PPUSH
41445: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41449: LD_VAR 0 5
41453: PPUSH
41454: CALL 31775 0 1
41458: PPUSH
41459: LD_VAR 0 5
41463: PPUSH
41464: CALL_OW 180
// end ; end ;
41468: GO 41390
41470: POP
41471: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41472: LD_VAR 0 1
41476: PPUSH
41477: LD_INT 6
41479: PPUSH
41480: LD_INT 92
41482: PUSH
41483: LD_VAR 0 6
41487: PUSH
41488: LD_VAR 0 7
41492: PUSH
41493: LD_INT 10
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL 12370 0 3
41506: PUSH
41507: LD_VAR 0 1
41511: PPUSH
41512: LD_INT 8
41514: PPUSH
41515: EMPTY
41516: PPUSH
41517: CALL 12370 0 3
41521: AND
41522: IFFALSE 41621
// for j in MCF_Tag ( side , 8 , [ ] ) do
41524: LD_ADDR_VAR 0 5
41528: PUSH
41529: LD_VAR 0 1
41533: PPUSH
41534: LD_INT 8
41536: PPUSH
41537: EMPTY
41538: PPUSH
41539: CALL 12370 0 3
41543: PUSH
41544: FOR_IN
41545: IFFALSE 41619
// begin if IsInUnit ( j ) then
41547: LD_VAR 0 5
41551: PPUSH
41552: CALL_OW 310
41556: IFFALSE 41569
// ComExitBuilding ( j ) else
41558: LD_VAR 0 5
41562: PPUSH
41563: CALL_OW 122
41567: GO 41617
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41569: LD_VAR 0 5
41573: PPUSH
41574: LD_VAR 0 1
41578: PPUSH
41579: LD_INT 6
41581: PPUSH
41582: LD_INT 92
41584: PUSH
41585: LD_VAR 0 6
41589: PUSH
41590: LD_VAR 0 7
41594: PUSH
41595: LD_INT 10
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: PPUSH
41604: CALL 12370 0 3
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PPUSH
41613: CALL_OW 129
// end ;
41617: GO 41544
41619: POP
41620: POP
// end ; end else
41621: GO 41678
// if MCF_Tag ( side , 8 , [ ] ) then
41623: LD_VAR 0 1
41627: PPUSH
41628: LD_INT 8
41630: PPUSH
41631: EMPTY
41632: PPUSH
41633: CALL 12370 0 3
41637: IFFALSE 41678
// for k in MCF_Tag ( side , 8 , [ ] ) do
41639: LD_ADDR_VAR 0 8
41643: PUSH
41644: LD_VAR 0 1
41648: PPUSH
41649: LD_INT 8
41651: PPUSH
41652: EMPTY
41653: PPUSH
41654: CALL 12370 0 3
41658: PUSH
41659: FOR_IN
41660: IFFALSE 41676
// SetTag ( k , 0 ) ;
41662: LD_VAR 0 8
41666: PPUSH
41667: LD_INT 0
41669: PPUSH
41670: CALL_OW 109
41674: GO 41659
41676: POP
41677: POP
// end ; end_of_file
41678: LD_VAR 0 3
41682: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41683: LD_INT 0
41685: PPUSH
// MREG_Game := [ ] ;
41686: LD_ADDR_EXP 33
41690: PUSH
41691: EMPTY
41692: ST_TO_ADDR
// MREG_Crates := [ ] ;
41693: LD_ADDR_EXP 34
41697: PUSH
41698: EMPTY
41699: ST_TO_ADDR
// MREG_Heal := [ ] ;
41700: LD_ADDR_EXP 35
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Tame := [ ] ;
41707: LD_ADDR_EXP 37
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41714: LD_ADDR_EXP 38
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41721: LD_ADDR_EXP 39
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_LabList := [ ] ;
41728: LD_ADDR_EXP 40
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41735: LD_ADDR_EXP 41
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41742: LD_ADDR_EXP 42
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41749: LD_ADDR_EXP 43
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41756: LD_ADDR_EXP 44
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_Status := [ ] ;
41763: LD_ADDR_EXP 45
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41770: LD_ADDR_EXP 46
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41777: LD_ADDR_EXP 47
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41784: LD_ADDR_EXP 48
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41791: LD_ADDR_EXP 49
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41798: LD_ADDR_EXP 50
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41805: LD_ADDR_EXP 51
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41812: LD_ADDR_EXP 52
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41819: LD_ADDR_EXP 53
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41826: LD_ADDR_EXP 54
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41833: LD_ADDR_EXP 55
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41840: LD_ADDR_EXP 56
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41847: LD_ADDR_EXP 57
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41854: LD_ADDR_EXP 61
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41861: LD_ADDR_EXP 62
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Parking := [ ] ;
41868: LD_ADDR_EXP 58
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41875: LD_ADDR_EXP 59
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41882: LD_ADDR_EXP 63
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41889: LD_ADDR_EXP 64
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41896: LD_ADDR_EXP 65
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41903: LD_ADDR_EXP 67
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41910: LD_ADDR_EXP 68
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41917: LD_ADDR_EXP 69
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41924: LD_ADDR_EXP 71
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41931: LD_ADDR_EXP 70
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41938: LD_ADDR_EXP 72
41942: PUSH
41943: LD_INT 300
41945: PUSH
41946: LD_INT 100
41948: PUSH
41949: LD_INT 25
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: LIST
41956: ST_TO_ADDR
// end ;
41957: LD_VAR 0 1
41961: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41962: LD_INT 0
41964: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41965: LD_VAR 0 2
41969: PUSH
41970: LD_VAR 0 3
41974: PUSH
41975: LD_VAR 0 4
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: LD_VAR 0 1
41989: IN
41990: IFFALSE 42004
// result := mreg_list else
41992: LD_ADDR_VAR 0 5
41996: PUSH
41997: LD_VAR 0 1
42001: ST_TO_ADDR
42002: GO 42038
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42004: LD_ADDR_VAR 0 1
42008: PUSH
42009: LD_VAR 0 1
42013: PUSH
42014: LD_VAR 0 2
42018: PUSH
42019: LD_VAR 0 3
42023: PUSH
42024: LD_VAR 0 4
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: LIST
42033: PUSH
42034: EMPTY
42035: LIST
42036: ADD
42037: ST_TO_ADDR
// result := mreg_list ;
42038: LD_ADDR_VAR 0 5
42042: PUSH
42043: LD_VAR 0 1
42047: ST_TO_ADDR
// end ;
42048: LD_VAR 0 5
42052: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42053: LD_INT 0
42055: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42056: LD_VAR 0 2
42060: PUSH
42061: LD_VAR 0 3
42065: PUSH
42066: LD_VAR 0 4
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: LIST
42075: PUSH
42076: LD_VAR 0 1
42080: IN
42081: IFFALSE 42119
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42083: LD_ADDR_VAR 0 5
42087: PUSH
42088: LD_VAR 0 1
42092: PUSH
42093: LD_VAR 0 2
42097: PUSH
42098: LD_VAR 0 3
42102: PUSH
42103: LD_VAR 0 4
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: LIST
42112: PUSH
42113: EMPTY
42114: LIST
42115: DIFF
42116: ST_TO_ADDR
42117: GO 42129
// result := mreg_list ;
42119: LD_ADDR_VAR 0 5
42123: PUSH
42124: LD_VAR 0 1
42128: ST_TO_ADDR
// end ;
42129: LD_VAR 0 5
42133: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42134: LD_INT 0
42136: PPUSH
42137: PPUSH
42138: PPUSH
// for j = 1 to 8 do
42139: LD_ADDR_VAR 0 3
42143: PUSH
42144: DOUBLE
42145: LD_INT 1
42147: DEC
42148: ST_TO_ADDR
42149: LD_INT 8
42151: PUSH
42152: FOR_TO
42153: IFFALSE 42994
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42155: LD_VAR 0 3
42159: PPUSH
42160: LD_INT 51
42162: PUSH
42163: EMPTY
42164: LIST
42165: PPUSH
42166: CALL 11667 0 2
42170: PUSH
42171: LD_OWVAR 2
42175: PUSH
42176: LD_VAR 0 3
42180: EQUAL
42181: NOT
42182: AND
42183: IFFALSE 42201
// MREG_SidesList := MREG_SidesList ^ 1 else
42185: LD_ADDR_EXP 39
42189: PUSH
42190: LD_EXP 39
42194: PUSH
42195: LD_INT 1
42197: ADD
42198: ST_TO_ADDR
42199: GO 42215
// MREG_SidesList := MREG_SidesList ^ 0 ;
42201: LD_ADDR_EXP 39
42205: PUSH
42206: LD_EXP 39
42210: PUSH
42211: LD_INT 0
42213: ADD
42214: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42215: LD_VAR 0 3
42219: PPUSH
42220: LD_INT 2
42222: PUSH
42223: LD_INT 34
42225: PUSH
42226: LD_INT 12
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 34
42235: PUSH
42236: LD_INT 32
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 34
42245: PUSH
42246: LD_INT 51
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: PUSH
42259: EMPTY
42260: LIST
42261: PPUSH
42262: CALL 11968 0 2
42266: IFFALSE 42367
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42268: LD_ADDR_VAR 0 2
42272: PUSH
42273: LD_VAR 0 3
42277: PPUSH
42278: LD_INT 2
42280: PUSH
42281: LD_INT 34
42283: PUSH
42284: LD_INT 12
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 34
42293: PUSH
42294: LD_INT 32
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 34
42303: PUSH
42304: LD_INT 51
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: LIST
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: CALL 11968 0 2
42324: PUSH
42325: FOR_IN
42326: IFFALSE 42365
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42328: LD_ADDR_EXP 41
42332: PUSH
42333: LD_EXP 41
42337: PPUSH
42338: LD_VAR 0 3
42342: PPUSH
42343: LD_VAR 0 2
42347: PPUSH
42348: LD_VAR 0 2
42352: PPUSH
42353: CALL_OW 264
42357: PPUSH
42358: CALL 41962 0 4
42362: ST_TO_ADDR
42363: GO 42325
42365: POP
42366: POP
// if MCF_Class ( j , 4 , [ ] ) then
42367: LD_VAR 0 3
42371: PPUSH
42372: LD_INT 4
42374: PPUSH
42375: EMPTY
42376: PPUSH
42377: CALL 11750 0 3
42381: IFFALSE 42414
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42383: LD_ADDR_EXP 54
42387: PUSH
42388: LD_EXP 54
42392: PUSH
42393: LD_VAR 0 3
42397: PPUSH
42398: LD_INT 4
42400: PPUSH
42401: EMPTY
42402: PPUSH
42403: CALL 11750 0 3
42407: PUSH
42408: EMPTY
42409: LIST
42410: ADD
42411: ST_TO_ADDR
42412: GO 42431
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42414: LD_ADDR_EXP 54
42418: PUSH
42419: LD_EXP 54
42423: PUSH
42424: LD_INT 0
42426: PUSH
42427: EMPTY
42428: LIST
42429: ADD
42430: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42431: LD_VAR 0 3
42435: PPUSH
42436: LD_INT 3
42438: PPUSH
42439: EMPTY
42440: PPUSH
42441: CALL 11750 0 3
42445: IFFALSE 42478
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42447: LD_ADDR_EXP 55
42451: PUSH
42452: LD_EXP 55
42456: PUSH
42457: LD_VAR 0 3
42461: PPUSH
42462: LD_INT 3
42464: PPUSH
42465: EMPTY
42466: PPUSH
42467: CALL 11750 0 3
42471: PUSH
42472: EMPTY
42473: LIST
42474: ADD
42475: ST_TO_ADDR
42476: GO 42495
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42478: LD_ADDR_EXP 55
42482: PUSH
42483: LD_EXP 55
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: ADD
42494: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42495: LD_VAR 0 3
42499: PPUSH
42500: LD_INT 1
42502: PPUSH
42503: EMPTY
42504: PPUSH
42505: CALL 11750 0 3
42509: IFFALSE 42542
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42511: LD_ADDR_EXP 56
42515: PUSH
42516: LD_EXP 56
42520: PUSH
42521: LD_VAR 0 3
42525: PPUSH
42526: LD_INT 1
42528: PPUSH
42529: EMPTY
42530: PPUSH
42531: CALL 11750 0 3
42535: PUSH
42536: EMPTY
42537: LIST
42538: ADD
42539: ST_TO_ADDR
42540: GO 42559
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42542: LD_ADDR_EXP 56
42546: PUSH
42547: LD_EXP 56
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: ADD
42558: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42559: LD_VAR 0 3
42563: PPUSH
42564: LD_INT 2
42566: PPUSH
42567: EMPTY
42568: PPUSH
42569: CALL 11750 0 3
42573: IFFALSE 42606
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42575: LD_ADDR_EXP 57
42579: PUSH
42580: LD_EXP 57
42584: PUSH
42585: LD_VAR 0 3
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: EMPTY
42594: PPUSH
42595: CALL 11750 0 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: ADD
42603: ST_TO_ADDR
42604: GO 42623
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42606: LD_ADDR_EXP 57
42610: PUSH
42611: LD_EXP 57
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: EMPTY
42620: LIST
42621: ADD
42622: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42623: LD_ADDR_EXP 47
42627: PUSH
42628: LD_EXP 47
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: ADD
42639: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42640: LD_ADDR_EXP 35
42644: PUSH
42645: LD_EXP 35
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: EMPTY
42654: LIST
42655: ADD
42656: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42657: LD_ADDR_EXP 37
42661: PUSH
42662: LD_EXP 37
42666: PUSH
42667: LD_INT 0
42669: PUSH
42670: EMPTY
42671: LIST
42672: ADD
42673: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42674: LD_ADDR_EXP 58
42678: PUSH
42679: LD_EXP 58
42683: PUSH
42684: LD_INT 0
42686: PUSH
42687: EMPTY
42688: LIST
42689: ADD
42690: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42691: LD_ADDR_EXP 59
42695: PUSH
42696: LD_EXP 59
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: ADD
42707: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42708: LD_ADDR_EXP 51
42712: PUSH
42713: LD_EXP 51
42717: PUSH
42718: LD_INT 0
42720: PUSH
42721: EMPTY
42722: LIST
42723: ADD
42724: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42725: LD_ADDR_EXP 38
42729: PUSH
42730: LD_EXP 38
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: LD_INT 0
42740: PUSH
42741: LD_INT 0
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: PUSH
42753: EMPTY
42754: LIST
42755: ADD
42756: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42757: LD_ADDR_EXP 60
42761: PUSH
42762: LD_EXP 60
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: EMPTY
42777: LIST
42778: ADD
42779: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42780: LD_ADDR_EXP 61
42784: PUSH
42785: LD_EXP 61
42789: PUSH
42790: LD_INT 0
42792: PUSH
42793: EMPTY
42794: LIST
42795: PUSH
42796: EMPTY
42797: LIST
42798: ADD
42799: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42800: LD_ADDR_EXP 42
42804: PUSH
42805: LD_EXP 42
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: EMPTY
42814: LIST
42815: ADD
42816: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42817: LD_ADDR_EXP 63
42821: PUSH
42822: LD_EXP 63
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: EMPTY
42831: LIST
42832: ADD
42833: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42834: LD_ADDR_EXP 64
42838: PUSH
42839: LD_EXP 64
42843: PUSH
42844: LD_INT 0
42846: PUSH
42847: EMPTY
42848: LIST
42849: ADD
42850: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42851: LD_ADDR_EXP 65
42855: PUSH
42856: LD_EXP 65
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: ADD
42867: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42868: LD_ADDR_EXP 66
42872: PUSH
42873: LD_EXP 66
42877: PUSH
42878: LD_INT 0
42880: PUSH
42881: EMPTY
42882: LIST
42883: ADD
42884: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42885: LD_ADDR_EXP 67
42889: PUSH
42890: LD_EXP 67
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: ADD
42901: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42902: LD_ADDR_EXP 68
42906: PUSH
42907: LD_EXP 68
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: EMPTY
42916: LIST
42917: ADD
42918: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42919: LD_ADDR_EXP 69
42923: PUSH
42924: LD_EXP 69
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: ADD
42935: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42936: LD_ADDR_EXP 71
42940: PUSH
42941: LD_EXP 71
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: EMPTY
42950: LIST
42951: ADD
42952: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42953: LD_ADDR_EXP 70
42957: PUSH
42958: LD_EXP 70
42962: PUSH
42963: LD_INT 0
42965: ADD
42966: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42967: LD_ADDR_EXP 62
42971: PUSH
42972: LD_EXP 62
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: LIST
42990: ADD
42991: ST_TO_ADDR
// end ;
42992: GO 42152
42994: POP
42995: POP
// end ;
42996: LD_VAR 0 1
43000: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43001: LD_INT 0
43003: PPUSH
43004: PPUSH
43005: PPUSH
// m := false ;
43006: LD_ADDR_VAR 0 5
43010: PUSH
43011: LD_INT 0
43013: ST_TO_ADDR
// for i = 1 to mreg do
43014: LD_ADDR_VAR 0 4
43018: PUSH
43019: DOUBLE
43020: LD_INT 1
43022: DEC
43023: ST_TO_ADDR
43024: LD_VAR 0 2
43028: PUSH
43029: FOR_TO
43030: IFFALSE 43066
// if mreg [ i ] [ 1 ] = side then
43032: LD_VAR 0 2
43036: PUSH
43037: LD_VAR 0 4
43041: ARRAY
43042: PUSH
43043: LD_INT 1
43045: ARRAY
43046: PUSH
43047: LD_VAR 0 1
43051: EQUAL
43052: IFFALSE 43064
// begin m := true ;
43054: LD_ADDR_VAR 0 5
43058: PUSH
43059: LD_INT 1
43061: ST_TO_ADDR
// break ;
43062: GO 43066
// end ;
43064: GO 43029
43066: POP
43067: POP
// result := m ;
43068: LD_ADDR_VAR 0 3
43072: PUSH
43073: LD_VAR 0 5
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43083: LD_INT 0
43085: PPUSH
43086: PPUSH
43087: PPUSH
// m := 0 ;
43088: LD_ADDR_VAR 0 5
43092: PUSH
43093: LD_INT 0
43095: ST_TO_ADDR
// for i = 1 to mreg do
43096: LD_ADDR_VAR 0 4
43100: PUSH
43101: DOUBLE
43102: LD_INT 1
43104: DEC
43105: ST_TO_ADDR
43106: LD_VAR 0 2
43110: PUSH
43111: FOR_TO
43112: IFFALSE 43152
// if mreg [ i ] [ 1 ] = side then
43114: LD_VAR 0 2
43118: PUSH
43119: LD_VAR 0 4
43123: ARRAY
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: PUSH
43129: LD_VAR 0 1
43133: EQUAL
43134: IFFALSE 43150
// begin m := m + 1 ;
43136: LD_ADDR_VAR 0 5
43140: PUSH
43141: LD_VAR 0 5
43145: PUSH
43146: LD_INT 1
43148: PLUS
43149: ST_TO_ADDR
// end ;
43150: GO 43111
43152: POP
43153: POP
// result := m ;
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_VAR 0 5
43163: ST_TO_ADDR
// end ;
43164: LD_VAR 0 3
43168: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43169: LD_INT 0
43171: PPUSH
43172: PPUSH
// result := 0 ;
43173: LD_ADDR_VAR 0 3
43177: PUSH
43178: LD_INT 0
43180: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43181: LD_ADDR_VAR 0 4
43185: PUSH
43186: DOUBLE
43187: LD_INT 1
43189: DEC
43190: ST_TO_ADDR
43191: LD_EXP 53
43195: PUSH
43196: FOR_TO
43197: IFFALSE 43259
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43199: LD_EXP 53
43203: PUSH
43204: LD_VAR 0 4
43208: ARRAY
43209: PUSH
43210: LD_INT 1
43212: ARRAY
43213: PUSH
43214: LD_VAR 0 1
43218: EQUAL
43219: PUSH
43220: LD_EXP 53
43224: PUSH
43225: LD_VAR 0 4
43229: ARRAY
43230: PUSH
43231: LD_INT 2
43233: ARRAY
43234: PUSH
43235: LD_VAR 0 2
43239: EQUAL
43240: AND
43241: IFFALSE 43257
// begin result := result + 1 ;
43243: LD_ADDR_VAR 0 3
43247: PUSH
43248: LD_VAR 0 3
43252: PUSH
43253: LD_INT 1
43255: PLUS
43256: ST_TO_ADDR
// end ;
43257: GO 43196
43259: POP
43260: POP
// end ; end_of_file
43261: LD_VAR 0 3
43265: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43266: LD_INT 0
43268: PPUSH
// ar_miner := 81 ;
43269: LD_ADDR_EXP 80
43273: PUSH
43274: LD_INT 81
43276: ST_TO_ADDR
// ar_crane := 88 ;
43277: LD_ADDR_EXP 79
43281: PUSH
43282: LD_INT 88
43284: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43285: LD_ADDR_EXP 74
43289: PUSH
43290: LD_INT 89
43292: ST_TO_ADDR
// us_hack := 99 ;
43293: LD_ADDR_EXP 75
43297: PUSH
43298: LD_INT 99
43300: ST_TO_ADDR
// us_artillery := 97 ;
43301: LD_ADDR_EXP 76
43305: PUSH
43306: LD_INT 97
43308: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43309: LD_ADDR_EXP 77
43313: PUSH
43314: LD_INT 91
43316: ST_TO_ADDR
// ar_mortar := 92 ;
43317: LD_ADDR_EXP 78
43321: PUSH
43322: LD_INT 92
43324: ST_TO_ADDR
// ru_radar := 98 ;
43325: LD_ADDR_EXP 73
43329: PUSH
43330: LD_INT 98
43332: ST_TO_ADDR
// tech_Artillery := 80 ;
43333: LD_ADDR_EXP 81
43337: PUSH
43338: LD_INT 80
43340: ST_TO_ADDR
// tech_RadMat := 81 ;
43341: LD_ADDR_EXP 82
43345: PUSH
43346: LD_INT 81
43348: ST_TO_ADDR
// tech_BasicTools := 82 ;
43349: LD_ADDR_EXP 83
43353: PUSH
43354: LD_INT 82
43356: ST_TO_ADDR
// tech_Cargo := 83 ;
43357: LD_ADDR_EXP 84
43361: PUSH
43362: LD_INT 83
43364: ST_TO_ADDR
// tech_Track := 84 ;
43365: LD_ADDR_EXP 85
43369: PUSH
43370: LD_INT 84
43372: ST_TO_ADDR
// tech_Crane := 85 ;
43373: LD_ADDR_EXP 86
43377: PUSH
43378: LD_INT 85
43380: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43381: LD_ADDR_EXP 87
43385: PUSH
43386: LD_INT 86
43388: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43389: LD_ADDR_EXP 88
43393: PUSH
43394: LD_INT 87
43396: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43397: LD_ADDR_EXP 89
43401: PUSH
43402: LD_INT 88
43404: ST_TO_ADDR
// class_mastodont := 31 ;
43405: LD_ADDR_EXP 90
43409: PUSH
43410: LD_INT 31
43412: ST_TO_ADDR
// class_horse := 21 ;
43413: LD_ADDR_EXP 91
43417: PUSH
43418: LD_INT 21
43420: ST_TO_ADDR
// end ;
43421: LD_VAR 0 1
43425: RET
// every 1 do
43426: GO 43428
43428: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43429: CALL 43266 0 0
43433: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43434: LD_INT 0
43436: PPUSH
// if p2 = 100 then
43437: LD_VAR 0 2
43441: PUSH
43442: LD_INT 100
43444: EQUAL
43445: IFFALSE 44394
// begin if not StreamModeActive then
43447: LD_EXP 92
43451: NOT
43452: IFFALSE 43462
// StreamModeActive := true ;
43454: LD_ADDR_EXP 92
43458: PUSH
43459: LD_INT 1
43461: ST_TO_ADDR
// if p3 = 0 then
43462: LD_VAR 0 3
43466: PUSH
43467: LD_INT 0
43469: EQUAL
43470: IFFALSE 43476
// InitStreamMode ;
43472: CALL 44554 0 0
// if p3 = 1 then
43476: LD_VAR 0 3
43480: PUSH
43481: LD_INT 1
43483: EQUAL
43484: IFFALSE 43494
// sRocket := true ;
43486: LD_ADDR_EXP 97
43490: PUSH
43491: LD_INT 1
43493: ST_TO_ADDR
// if p3 = 2 then
43494: LD_VAR 0 3
43498: PUSH
43499: LD_INT 2
43501: EQUAL
43502: IFFALSE 43512
// sSpeed := true ;
43504: LD_ADDR_EXP 96
43508: PUSH
43509: LD_INT 1
43511: ST_TO_ADDR
// if p3 = 3 then
43512: LD_VAR 0 3
43516: PUSH
43517: LD_INT 3
43519: EQUAL
43520: IFFALSE 43530
// sEngine := true ;
43522: LD_ADDR_EXP 98
43526: PUSH
43527: LD_INT 1
43529: ST_TO_ADDR
// if p3 = 4 then
43530: LD_VAR 0 3
43534: PUSH
43535: LD_INT 4
43537: EQUAL
43538: IFFALSE 43548
// sSpec := true ;
43540: LD_ADDR_EXP 95
43544: PUSH
43545: LD_INT 1
43547: ST_TO_ADDR
// if p3 = 5 then
43548: LD_VAR 0 3
43552: PUSH
43553: LD_INT 5
43555: EQUAL
43556: IFFALSE 43566
// sLevel := true ;
43558: LD_ADDR_EXP 99
43562: PUSH
43563: LD_INT 1
43565: ST_TO_ADDR
// if p3 = 6 then
43566: LD_VAR 0 3
43570: PUSH
43571: LD_INT 6
43573: EQUAL
43574: IFFALSE 43584
// sArmoury := true ;
43576: LD_ADDR_EXP 100
43580: PUSH
43581: LD_INT 1
43583: ST_TO_ADDR
// if p3 = 7 then
43584: LD_VAR 0 3
43588: PUSH
43589: LD_INT 7
43591: EQUAL
43592: IFFALSE 43602
// sRadar := true ;
43594: LD_ADDR_EXP 101
43598: PUSH
43599: LD_INT 1
43601: ST_TO_ADDR
// if p3 = 8 then
43602: LD_VAR 0 3
43606: PUSH
43607: LD_INT 8
43609: EQUAL
43610: IFFALSE 43620
// sBunker := true ;
43612: LD_ADDR_EXP 102
43616: PUSH
43617: LD_INT 1
43619: ST_TO_ADDR
// if p3 = 9 then
43620: LD_VAR 0 3
43624: PUSH
43625: LD_INT 9
43627: EQUAL
43628: IFFALSE 43638
// sHack := true ;
43630: LD_ADDR_EXP 103
43634: PUSH
43635: LD_INT 1
43637: ST_TO_ADDR
// if p3 = 10 then
43638: LD_VAR 0 3
43642: PUSH
43643: LD_INT 10
43645: EQUAL
43646: IFFALSE 43656
// sFire := true ;
43648: LD_ADDR_EXP 104
43652: PUSH
43653: LD_INT 1
43655: ST_TO_ADDR
// if p3 = 11 then
43656: LD_VAR 0 3
43660: PUSH
43661: LD_INT 11
43663: EQUAL
43664: IFFALSE 43674
// sRefresh := true ;
43666: LD_ADDR_EXP 105
43670: PUSH
43671: LD_INT 1
43673: ST_TO_ADDR
// if p3 = 12 then
43674: LD_VAR 0 3
43678: PUSH
43679: LD_INT 12
43681: EQUAL
43682: IFFALSE 43692
// sExp := true ;
43684: LD_ADDR_EXP 106
43688: PUSH
43689: LD_INT 1
43691: ST_TO_ADDR
// if p3 = 13 then
43692: LD_VAR 0 3
43696: PUSH
43697: LD_INT 13
43699: EQUAL
43700: IFFALSE 43710
// sDepot := true ;
43702: LD_ADDR_EXP 107
43706: PUSH
43707: LD_INT 1
43709: ST_TO_ADDR
// if p3 = 14 then
43710: LD_VAR 0 3
43714: PUSH
43715: LD_INT 14
43717: EQUAL
43718: IFFALSE 43728
// sFlag := true ;
43720: LD_ADDR_EXP 108
43724: PUSH
43725: LD_INT 1
43727: ST_TO_ADDR
// if p3 = 15 then
43728: LD_VAR 0 3
43732: PUSH
43733: LD_INT 15
43735: EQUAL
43736: IFFALSE 43746
// sKamikadze := true ;
43738: LD_ADDR_EXP 116
43742: PUSH
43743: LD_INT 1
43745: ST_TO_ADDR
// if p3 = 16 then
43746: LD_VAR 0 3
43750: PUSH
43751: LD_INT 16
43753: EQUAL
43754: IFFALSE 43764
// sTroll := true ;
43756: LD_ADDR_EXP 117
43760: PUSH
43761: LD_INT 1
43763: ST_TO_ADDR
// if p3 = 17 then
43764: LD_VAR 0 3
43768: PUSH
43769: LD_INT 17
43771: EQUAL
43772: IFFALSE 43782
// sSlow := true ;
43774: LD_ADDR_EXP 118
43778: PUSH
43779: LD_INT 1
43781: ST_TO_ADDR
// if p3 = 18 then
43782: LD_VAR 0 3
43786: PUSH
43787: LD_INT 18
43789: EQUAL
43790: IFFALSE 43800
// sLack := true ;
43792: LD_ADDR_EXP 119
43796: PUSH
43797: LD_INT 1
43799: ST_TO_ADDR
// if p3 = 19 then
43800: LD_VAR 0 3
43804: PUSH
43805: LD_INT 19
43807: EQUAL
43808: IFFALSE 43818
// sTank := true ;
43810: LD_ADDR_EXP 121
43814: PUSH
43815: LD_INT 1
43817: ST_TO_ADDR
// if p3 = 20 then
43818: LD_VAR 0 3
43822: PUSH
43823: LD_INT 20
43825: EQUAL
43826: IFFALSE 43836
// sRemote := true ;
43828: LD_ADDR_EXP 122
43832: PUSH
43833: LD_INT 1
43835: ST_TO_ADDR
// if p3 = 21 then
43836: LD_VAR 0 3
43840: PUSH
43841: LD_INT 21
43843: EQUAL
43844: IFFALSE 43854
// sPowell := true ;
43846: LD_ADDR_EXP 123
43850: PUSH
43851: LD_INT 1
43853: ST_TO_ADDR
// if p3 = 22 then
43854: LD_VAR 0 3
43858: PUSH
43859: LD_INT 22
43861: EQUAL
43862: IFFALSE 43872
// sTeleport := true ;
43864: LD_ADDR_EXP 126
43868: PUSH
43869: LD_INT 1
43871: ST_TO_ADDR
// if p3 = 23 then
43872: LD_VAR 0 3
43876: PUSH
43877: LD_INT 23
43879: EQUAL
43880: IFFALSE 43890
// sOilTower := true ;
43882: LD_ADDR_EXP 128
43886: PUSH
43887: LD_INT 1
43889: ST_TO_ADDR
// if p3 = 24 then
43890: LD_VAR 0 3
43894: PUSH
43895: LD_INT 24
43897: EQUAL
43898: IFFALSE 43908
// sShovel := true ;
43900: LD_ADDR_EXP 129
43904: PUSH
43905: LD_INT 1
43907: ST_TO_ADDR
// if p3 = 25 then
43908: LD_VAR 0 3
43912: PUSH
43913: LD_INT 25
43915: EQUAL
43916: IFFALSE 43926
// sSheik := true ;
43918: LD_ADDR_EXP 130
43922: PUSH
43923: LD_INT 1
43925: ST_TO_ADDR
// if p3 = 26 then
43926: LD_VAR 0 3
43930: PUSH
43931: LD_INT 26
43933: EQUAL
43934: IFFALSE 43944
// sEarthquake := true ;
43936: LD_ADDR_EXP 132
43940: PUSH
43941: LD_INT 1
43943: ST_TO_ADDR
// if p3 = 27 then
43944: LD_VAR 0 3
43948: PUSH
43949: LD_INT 27
43951: EQUAL
43952: IFFALSE 43962
// sAI := true ;
43954: LD_ADDR_EXP 133
43958: PUSH
43959: LD_INT 1
43961: ST_TO_ADDR
// if p3 = 28 then
43962: LD_VAR 0 3
43966: PUSH
43967: LD_INT 28
43969: EQUAL
43970: IFFALSE 43980
// sCargo := true ;
43972: LD_ADDR_EXP 136
43976: PUSH
43977: LD_INT 1
43979: ST_TO_ADDR
// if p3 = 29 then
43980: LD_VAR 0 3
43984: PUSH
43985: LD_INT 29
43987: EQUAL
43988: IFFALSE 43998
// sDLaser := true ;
43990: LD_ADDR_EXP 137
43994: PUSH
43995: LD_INT 1
43997: ST_TO_ADDR
// if p3 = 30 then
43998: LD_VAR 0 3
44002: PUSH
44003: LD_INT 30
44005: EQUAL
44006: IFFALSE 44016
// sExchange := true ;
44008: LD_ADDR_EXP 138
44012: PUSH
44013: LD_INT 1
44015: ST_TO_ADDR
// if p3 = 31 then
44016: LD_VAR 0 3
44020: PUSH
44021: LD_INT 31
44023: EQUAL
44024: IFFALSE 44034
// sFac := true ;
44026: LD_ADDR_EXP 139
44030: PUSH
44031: LD_INT 1
44033: ST_TO_ADDR
// if p3 = 32 then
44034: LD_VAR 0 3
44038: PUSH
44039: LD_INT 32
44041: EQUAL
44042: IFFALSE 44052
// sPower := true ;
44044: LD_ADDR_EXP 140
44048: PUSH
44049: LD_INT 1
44051: ST_TO_ADDR
// if p3 = 33 then
44052: LD_VAR 0 3
44056: PUSH
44057: LD_INT 33
44059: EQUAL
44060: IFFALSE 44070
// sRandom := true ;
44062: LD_ADDR_EXP 141
44066: PUSH
44067: LD_INT 1
44069: ST_TO_ADDR
// if p3 = 34 then
44070: LD_VAR 0 3
44074: PUSH
44075: LD_INT 34
44077: EQUAL
44078: IFFALSE 44088
// sShield := true ;
44080: LD_ADDR_EXP 142
44084: PUSH
44085: LD_INT 1
44087: ST_TO_ADDR
// if p3 = 35 then
44088: LD_VAR 0 3
44092: PUSH
44093: LD_INT 35
44095: EQUAL
44096: IFFALSE 44106
// sTime := true ;
44098: LD_ADDR_EXP 143
44102: PUSH
44103: LD_INT 1
44105: ST_TO_ADDR
// if p3 = 36 then
44106: LD_VAR 0 3
44110: PUSH
44111: LD_INT 36
44113: EQUAL
44114: IFFALSE 44124
// sTools := true ;
44116: LD_ADDR_EXP 144
44120: PUSH
44121: LD_INT 1
44123: ST_TO_ADDR
// if p3 = 101 then
44124: LD_VAR 0 3
44128: PUSH
44129: LD_INT 101
44131: EQUAL
44132: IFFALSE 44142
// sSold := true ;
44134: LD_ADDR_EXP 109
44138: PUSH
44139: LD_INT 1
44141: ST_TO_ADDR
// if p3 = 102 then
44142: LD_VAR 0 3
44146: PUSH
44147: LD_INT 102
44149: EQUAL
44150: IFFALSE 44160
// sDiff := true ;
44152: LD_ADDR_EXP 110
44156: PUSH
44157: LD_INT 1
44159: ST_TO_ADDR
// if p3 = 103 then
44160: LD_VAR 0 3
44164: PUSH
44165: LD_INT 103
44167: EQUAL
44168: IFFALSE 44178
// sFog := true ;
44170: LD_ADDR_EXP 113
44174: PUSH
44175: LD_INT 1
44177: ST_TO_ADDR
// if p3 = 104 then
44178: LD_VAR 0 3
44182: PUSH
44183: LD_INT 104
44185: EQUAL
44186: IFFALSE 44196
// sReset := true ;
44188: LD_ADDR_EXP 114
44192: PUSH
44193: LD_INT 1
44195: ST_TO_ADDR
// if p3 = 105 then
44196: LD_VAR 0 3
44200: PUSH
44201: LD_INT 105
44203: EQUAL
44204: IFFALSE 44214
// sSun := true ;
44206: LD_ADDR_EXP 115
44210: PUSH
44211: LD_INT 1
44213: ST_TO_ADDR
// if p3 = 106 then
44214: LD_VAR 0 3
44218: PUSH
44219: LD_INT 106
44221: EQUAL
44222: IFFALSE 44232
// sTiger := true ;
44224: LD_ADDR_EXP 111
44228: PUSH
44229: LD_INT 1
44231: ST_TO_ADDR
// if p3 = 107 then
44232: LD_VAR 0 3
44236: PUSH
44237: LD_INT 107
44239: EQUAL
44240: IFFALSE 44250
// sBomb := true ;
44242: LD_ADDR_EXP 112
44246: PUSH
44247: LD_INT 1
44249: ST_TO_ADDR
// if p3 = 108 then
44250: LD_VAR 0 3
44254: PUSH
44255: LD_INT 108
44257: EQUAL
44258: IFFALSE 44268
// sWound := true ;
44260: LD_ADDR_EXP 120
44264: PUSH
44265: LD_INT 1
44267: ST_TO_ADDR
// if p3 = 109 then
44268: LD_VAR 0 3
44272: PUSH
44273: LD_INT 109
44275: EQUAL
44276: IFFALSE 44286
// sBetray := true ;
44278: LD_ADDR_EXP 124
44282: PUSH
44283: LD_INT 1
44285: ST_TO_ADDR
// if p3 = 110 then
44286: LD_VAR 0 3
44290: PUSH
44291: LD_INT 110
44293: EQUAL
44294: IFFALSE 44304
// sContamin := true ;
44296: LD_ADDR_EXP 125
44300: PUSH
44301: LD_INT 1
44303: ST_TO_ADDR
// if p3 = 111 then
44304: LD_VAR 0 3
44308: PUSH
44309: LD_INT 111
44311: EQUAL
44312: IFFALSE 44322
// sOil := true ;
44314: LD_ADDR_EXP 127
44318: PUSH
44319: LD_INT 1
44321: ST_TO_ADDR
// if p3 = 112 then
44322: LD_VAR 0 3
44326: PUSH
44327: LD_INT 112
44329: EQUAL
44330: IFFALSE 44340
// sStu := true ;
44332: LD_ADDR_EXP 131
44336: PUSH
44337: LD_INT 1
44339: ST_TO_ADDR
// if p3 = 113 then
44340: LD_VAR 0 3
44344: PUSH
44345: LD_INT 113
44347: EQUAL
44348: IFFALSE 44358
// sBazooka := true ;
44350: LD_ADDR_EXP 134
44354: PUSH
44355: LD_INT 1
44357: ST_TO_ADDR
// if p3 = 114 then
44358: LD_VAR 0 3
44362: PUSH
44363: LD_INT 114
44365: EQUAL
44366: IFFALSE 44376
// sMortar := true ;
44368: LD_ADDR_EXP 135
44372: PUSH
44373: LD_INT 1
44375: ST_TO_ADDR
// if p3 = 115 then
44376: LD_VAR 0 3
44380: PUSH
44381: LD_INT 115
44383: EQUAL
44384: IFFALSE 44394
// sRanger := true ;
44386: LD_ADDR_EXP 145
44390: PUSH
44391: LD_INT 1
44393: ST_TO_ADDR
// end ; if p2 = 101 then
44394: LD_VAR 0 2
44398: PUSH
44399: LD_INT 101
44401: EQUAL
44402: IFFALSE 44530
// begin case p3 of 1 :
44404: LD_VAR 0 3
44408: PUSH
44409: LD_INT 1
44411: DOUBLE
44412: EQUAL
44413: IFTRUE 44417
44415: GO 44424
44417: POP
// hHackUnlimitedResources ; 2 :
44418: CALL 55567 0 0
44422: GO 44530
44424: LD_INT 2
44426: DOUBLE
44427: EQUAL
44428: IFTRUE 44432
44430: GO 44439
44432: POP
// hHackSetLevel10 ; 3 :
44433: CALL 55700 0 0
44437: GO 44530
44439: LD_INT 3
44441: DOUBLE
44442: EQUAL
44443: IFTRUE 44447
44445: GO 44454
44447: POP
// hHackSetLevel10YourUnits ; 4 :
44448: CALL 55785 0 0
44452: GO 44530
44454: LD_INT 4
44456: DOUBLE
44457: EQUAL
44458: IFTRUE 44462
44460: GO 44469
44462: POP
// hHackInvincible ; 5 :
44463: CALL 56233 0 0
44467: GO 44530
44469: LD_INT 5
44471: DOUBLE
44472: EQUAL
44473: IFTRUE 44477
44475: GO 44484
44477: POP
// hHackInvisible ; 6 :
44478: CALL 56344 0 0
44482: GO 44530
44484: LD_INT 6
44486: DOUBLE
44487: EQUAL
44488: IFTRUE 44492
44490: GO 44499
44492: POP
// hHackChangeYourSide ; 7 :
44493: CALL 56401 0 0
44497: GO 44530
44499: LD_INT 7
44501: DOUBLE
44502: EQUAL
44503: IFTRUE 44507
44505: GO 44514
44507: POP
// hHackChangeUnitSide ; 8 :
44508: CALL 56443 0 0
44512: GO 44530
44514: LD_INT 8
44516: DOUBLE
44517: EQUAL
44518: IFTRUE 44522
44520: GO 44529
44522: POP
// hHackFog ; end ;
44523: CALL 56544 0 0
44527: GO 44530
44529: POP
// end ; end ;
44530: LD_VAR 0 7
44534: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44535: GO 44537
44537: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44538: LD_STRING initStreamRollete();
44540: PPUSH
44541: CALL_OW 559
// InitStreamMode ;
44545: CALL 44554 0 0
// DefineStreamItems ( ) ;
44549: CALL 44994 0 0
// end ;
44553: END
// function InitStreamMode ; begin
44554: LD_INT 0
44556: PPUSH
// streamModeActive := false ;
44557: LD_ADDR_EXP 92
44561: PUSH
44562: LD_INT 0
44564: ST_TO_ADDR
// normalCounter := 36 ;
44565: LD_ADDR_EXP 93
44569: PUSH
44570: LD_INT 36
44572: ST_TO_ADDR
// hardcoreCounter := 16 ;
44573: LD_ADDR_EXP 94
44577: PUSH
44578: LD_INT 16
44580: ST_TO_ADDR
// sRocket := false ;
44581: LD_ADDR_EXP 97
44585: PUSH
44586: LD_INT 0
44588: ST_TO_ADDR
// sSpeed := false ;
44589: LD_ADDR_EXP 96
44593: PUSH
44594: LD_INT 0
44596: ST_TO_ADDR
// sEngine := false ;
44597: LD_ADDR_EXP 98
44601: PUSH
44602: LD_INT 0
44604: ST_TO_ADDR
// sSpec := false ;
44605: LD_ADDR_EXP 95
44609: PUSH
44610: LD_INT 0
44612: ST_TO_ADDR
// sLevel := false ;
44613: LD_ADDR_EXP 99
44617: PUSH
44618: LD_INT 0
44620: ST_TO_ADDR
// sArmoury := false ;
44621: LD_ADDR_EXP 100
44625: PUSH
44626: LD_INT 0
44628: ST_TO_ADDR
// sRadar := false ;
44629: LD_ADDR_EXP 101
44633: PUSH
44634: LD_INT 0
44636: ST_TO_ADDR
// sBunker := false ;
44637: LD_ADDR_EXP 102
44641: PUSH
44642: LD_INT 0
44644: ST_TO_ADDR
// sHack := false ;
44645: LD_ADDR_EXP 103
44649: PUSH
44650: LD_INT 0
44652: ST_TO_ADDR
// sFire := false ;
44653: LD_ADDR_EXP 104
44657: PUSH
44658: LD_INT 0
44660: ST_TO_ADDR
// sRefresh := false ;
44661: LD_ADDR_EXP 105
44665: PUSH
44666: LD_INT 0
44668: ST_TO_ADDR
// sExp := false ;
44669: LD_ADDR_EXP 106
44673: PUSH
44674: LD_INT 0
44676: ST_TO_ADDR
// sDepot := false ;
44677: LD_ADDR_EXP 107
44681: PUSH
44682: LD_INT 0
44684: ST_TO_ADDR
// sFlag := false ;
44685: LD_ADDR_EXP 108
44689: PUSH
44690: LD_INT 0
44692: ST_TO_ADDR
// sKamikadze := false ;
44693: LD_ADDR_EXP 116
44697: PUSH
44698: LD_INT 0
44700: ST_TO_ADDR
// sTroll := false ;
44701: LD_ADDR_EXP 117
44705: PUSH
44706: LD_INT 0
44708: ST_TO_ADDR
// sSlow := false ;
44709: LD_ADDR_EXP 118
44713: PUSH
44714: LD_INT 0
44716: ST_TO_ADDR
// sLack := false ;
44717: LD_ADDR_EXP 119
44721: PUSH
44722: LD_INT 0
44724: ST_TO_ADDR
// sTank := false ;
44725: LD_ADDR_EXP 121
44729: PUSH
44730: LD_INT 0
44732: ST_TO_ADDR
// sRemote := false ;
44733: LD_ADDR_EXP 122
44737: PUSH
44738: LD_INT 0
44740: ST_TO_ADDR
// sPowell := false ;
44741: LD_ADDR_EXP 123
44745: PUSH
44746: LD_INT 0
44748: ST_TO_ADDR
// sTeleport := false ;
44749: LD_ADDR_EXP 126
44753: PUSH
44754: LD_INT 0
44756: ST_TO_ADDR
// sOilTower := false ;
44757: LD_ADDR_EXP 128
44761: PUSH
44762: LD_INT 0
44764: ST_TO_ADDR
// sShovel := false ;
44765: LD_ADDR_EXP 129
44769: PUSH
44770: LD_INT 0
44772: ST_TO_ADDR
// sSheik := false ;
44773: LD_ADDR_EXP 130
44777: PUSH
44778: LD_INT 0
44780: ST_TO_ADDR
// sEarthquake := false ;
44781: LD_ADDR_EXP 132
44785: PUSH
44786: LD_INT 0
44788: ST_TO_ADDR
// sAI := false ;
44789: LD_ADDR_EXP 133
44793: PUSH
44794: LD_INT 0
44796: ST_TO_ADDR
// sCargo := false ;
44797: LD_ADDR_EXP 136
44801: PUSH
44802: LD_INT 0
44804: ST_TO_ADDR
// sDLaser := false ;
44805: LD_ADDR_EXP 137
44809: PUSH
44810: LD_INT 0
44812: ST_TO_ADDR
// sExchange := false ;
44813: LD_ADDR_EXP 138
44817: PUSH
44818: LD_INT 0
44820: ST_TO_ADDR
// sFac := false ;
44821: LD_ADDR_EXP 139
44825: PUSH
44826: LD_INT 0
44828: ST_TO_ADDR
// sPower := false ;
44829: LD_ADDR_EXP 140
44833: PUSH
44834: LD_INT 0
44836: ST_TO_ADDR
// sRandom := false ;
44837: LD_ADDR_EXP 141
44841: PUSH
44842: LD_INT 0
44844: ST_TO_ADDR
// sShield := false ;
44845: LD_ADDR_EXP 142
44849: PUSH
44850: LD_INT 0
44852: ST_TO_ADDR
// sTime := false ;
44853: LD_ADDR_EXP 143
44857: PUSH
44858: LD_INT 0
44860: ST_TO_ADDR
// sTools := false ;
44861: LD_ADDR_EXP 144
44865: PUSH
44866: LD_INT 0
44868: ST_TO_ADDR
// sSold := false ;
44869: LD_ADDR_EXP 109
44873: PUSH
44874: LD_INT 0
44876: ST_TO_ADDR
// sDiff := false ;
44877: LD_ADDR_EXP 110
44881: PUSH
44882: LD_INT 0
44884: ST_TO_ADDR
// sFog := false ;
44885: LD_ADDR_EXP 113
44889: PUSH
44890: LD_INT 0
44892: ST_TO_ADDR
// sReset := false ;
44893: LD_ADDR_EXP 114
44897: PUSH
44898: LD_INT 0
44900: ST_TO_ADDR
// sSun := false ;
44901: LD_ADDR_EXP 115
44905: PUSH
44906: LD_INT 0
44908: ST_TO_ADDR
// sTiger := false ;
44909: LD_ADDR_EXP 111
44913: PUSH
44914: LD_INT 0
44916: ST_TO_ADDR
// sBomb := false ;
44917: LD_ADDR_EXP 112
44921: PUSH
44922: LD_INT 0
44924: ST_TO_ADDR
// sWound := false ;
44925: LD_ADDR_EXP 120
44929: PUSH
44930: LD_INT 0
44932: ST_TO_ADDR
// sBetray := false ;
44933: LD_ADDR_EXP 124
44937: PUSH
44938: LD_INT 0
44940: ST_TO_ADDR
// sContamin := false ;
44941: LD_ADDR_EXP 125
44945: PUSH
44946: LD_INT 0
44948: ST_TO_ADDR
// sOil := false ;
44949: LD_ADDR_EXP 127
44953: PUSH
44954: LD_INT 0
44956: ST_TO_ADDR
// sStu := false ;
44957: LD_ADDR_EXP 131
44961: PUSH
44962: LD_INT 0
44964: ST_TO_ADDR
// sBazooka := false ;
44965: LD_ADDR_EXP 134
44969: PUSH
44970: LD_INT 0
44972: ST_TO_ADDR
// sMortar := false ;
44973: LD_ADDR_EXP 135
44977: PUSH
44978: LD_INT 0
44980: ST_TO_ADDR
// sRanger := false ;
44981: LD_ADDR_EXP 145
44985: PUSH
44986: LD_INT 0
44988: ST_TO_ADDR
// end ;
44989: LD_VAR 0 1
44993: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44994: LD_INT 0
44996: PPUSH
44997: PPUSH
44998: PPUSH
44999: PPUSH
45000: PPUSH
// result := [ ] ;
45001: LD_ADDR_VAR 0 1
45005: PUSH
45006: EMPTY
45007: ST_TO_ADDR
// if campaign_id = 1 then
45008: LD_OWVAR 69
45012: PUSH
45013: LD_INT 1
45015: EQUAL
45016: IFFALSE 47954
// begin case mission_number of 1 :
45018: LD_OWVAR 70
45022: PUSH
45023: LD_INT 1
45025: DOUBLE
45026: EQUAL
45027: IFTRUE 45031
45029: GO 45095
45031: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
45032: LD_ADDR_VAR 0 1
45036: PUSH
45037: LD_INT 2
45039: PUSH
45040: LD_INT 4
45042: PUSH
45043: LD_INT 11
45045: PUSH
45046: LD_INT 12
45048: PUSH
45049: LD_INT 15
45051: PUSH
45052: LD_INT 16
45054: PUSH
45055: LD_INT 22
45057: PUSH
45058: LD_INT 23
45060: PUSH
45061: LD_INT 26
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: PUSH
45075: LD_INT 101
45077: PUSH
45078: LD_INT 102
45080: PUSH
45081: LD_INT 106
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: LIST
45088: PUSH
45089: EMPTY
45090: LIST
45091: LIST
45092: ST_TO_ADDR
45093: GO 47952
45095: LD_INT 2
45097: DOUBLE
45098: EQUAL
45099: IFTRUE 45103
45101: GO 45175
45103: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
45104: LD_ADDR_VAR 0 1
45108: PUSH
45109: LD_INT 2
45111: PUSH
45112: LD_INT 4
45114: PUSH
45115: LD_INT 11
45117: PUSH
45118: LD_INT 12
45120: PUSH
45121: LD_INT 15
45123: PUSH
45124: LD_INT 16
45126: PUSH
45127: LD_INT 22
45129: PUSH
45130: LD_INT 23
45132: PUSH
45133: LD_INT 26
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: PUSH
45147: LD_INT 101
45149: PUSH
45150: LD_INT 102
45152: PUSH
45153: LD_INT 105
45155: PUSH
45156: LD_INT 106
45158: PUSH
45159: LD_INT 108
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: ST_TO_ADDR
45173: GO 47952
45175: LD_INT 3
45177: DOUBLE
45178: EQUAL
45179: IFTRUE 45183
45181: GO 45259
45183: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45184: LD_ADDR_VAR 0 1
45188: PUSH
45189: LD_INT 2
45191: PUSH
45192: LD_INT 4
45194: PUSH
45195: LD_INT 5
45197: PUSH
45198: LD_INT 11
45200: PUSH
45201: LD_INT 12
45203: PUSH
45204: LD_INT 15
45206: PUSH
45207: LD_INT 16
45209: PUSH
45210: LD_INT 22
45212: PUSH
45213: LD_INT 26
45215: PUSH
45216: LD_INT 36
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 101
45233: PUSH
45234: LD_INT 102
45236: PUSH
45237: LD_INT 105
45239: PUSH
45240: LD_INT 106
45242: PUSH
45243: LD_INT 108
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: ST_TO_ADDR
45257: GO 47952
45259: LD_INT 4
45261: DOUBLE
45262: EQUAL
45263: IFTRUE 45267
45265: GO 45351
45267: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45268: LD_ADDR_VAR 0 1
45272: PUSH
45273: LD_INT 2
45275: PUSH
45276: LD_INT 4
45278: PUSH
45279: LD_INT 5
45281: PUSH
45282: LD_INT 8
45284: PUSH
45285: LD_INT 11
45287: PUSH
45288: LD_INT 12
45290: PUSH
45291: LD_INT 15
45293: PUSH
45294: LD_INT 16
45296: PUSH
45297: LD_INT 22
45299: PUSH
45300: LD_INT 23
45302: PUSH
45303: LD_INT 26
45305: PUSH
45306: LD_INT 36
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 101
45325: PUSH
45326: LD_INT 102
45328: PUSH
45329: LD_INT 105
45331: PUSH
45332: LD_INT 106
45334: PUSH
45335: LD_INT 108
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: PUSH
45345: EMPTY
45346: LIST
45347: LIST
45348: ST_TO_ADDR
45349: GO 47952
45351: LD_INT 5
45353: DOUBLE
45354: EQUAL
45355: IFTRUE 45359
45357: GO 45459
45359: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45360: LD_ADDR_VAR 0 1
45364: PUSH
45365: LD_INT 2
45367: PUSH
45368: LD_INT 4
45370: PUSH
45371: LD_INT 5
45373: PUSH
45374: LD_INT 6
45376: PUSH
45377: LD_INT 8
45379: PUSH
45380: LD_INT 11
45382: PUSH
45383: LD_INT 12
45385: PUSH
45386: LD_INT 15
45388: PUSH
45389: LD_INT 16
45391: PUSH
45392: LD_INT 22
45394: PUSH
45395: LD_INT 23
45397: PUSH
45398: LD_INT 25
45400: PUSH
45401: LD_INT 26
45403: PUSH
45404: LD_INT 36
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: LIST
45415: LIST
45416: LIST
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: PUSH
45423: LD_INT 101
45425: PUSH
45426: LD_INT 102
45428: PUSH
45429: LD_INT 105
45431: PUSH
45432: LD_INT 106
45434: PUSH
45435: LD_INT 108
45437: PUSH
45438: LD_INT 109
45440: PUSH
45441: LD_INT 112
45443: PUSH
45444: EMPTY
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: ST_TO_ADDR
45457: GO 47952
45459: LD_INT 6
45461: DOUBLE
45462: EQUAL
45463: IFTRUE 45467
45465: GO 45587
45467: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45468: LD_ADDR_VAR 0 1
45472: PUSH
45473: LD_INT 2
45475: PUSH
45476: LD_INT 4
45478: PUSH
45479: LD_INT 5
45481: PUSH
45482: LD_INT 6
45484: PUSH
45485: LD_INT 8
45487: PUSH
45488: LD_INT 11
45490: PUSH
45491: LD_INT 12
45493: PUSH
45494: LD_INT 15
45496: PUSH
45497: LD_INT 16
45499: PUSH
45500: LD_INT 20
45502: PUSH
45503: LD_INT 21
45505: PUSH
45506: LD_INT 22
45508: PUSH
45509: LD_INT 23
45511: PUSH
45512: LD_INT 25
45514: PUSH
45515: LD_INT 26
45517: PUSH
45518: LD_INT 30
45520: PUSH
45521: LD_INT 31
45523: PUSH
45524: LD_INT 32
45526: PUSH
45527: LD_INT 36
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 101
45553: PUSH
45554: LD_INT 102
45556: PUSH
45557: LD_INT 105
45559: PUSH
45560: LD_INT 106
45562: PUSH
45563: LD_INT 108
45565: PUSH
45566: LD_INT 109
45568: PUSH
45569: LD_INT 112
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: ST_TO_ADDR
45585: GO 47952
45587: LD_INT 7
45589: DOUBLE
45590: EQUAL
45591: IFTRUE 45595
45593: GO 45695
45595: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45596: LD_ADDR_VAR 0 1
45600: PUSH
45601: LD_INT 2
45603: PUSH
45604: LD_INT 4
45606: PUSH
45607: LD_INT 5
45609: PUSH
45610: LD_INT 7
45612: PUSH
45613: LD_INT 11
45615: PUSH
45616: LD_INT 12
45618: PUSH
45619: LD_INT 15
45621: PUSH
45622: LD_INT 16
45624: PUSH
45625: LD_INT 20
45627: PUSH
45628: LD_INT 21
45630: PUSH
45631: LD_INT 22
45633: PUSH
45634: LD_INT 23
45636: PUSH
45637: LD_INT 25
45639: PUSH
45640: LD_INT 26
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 101
45661: PUSH
45662: LD_INT 102
45664: PUSH
45665: LD_INT 103
45667: PUSH
45668: LD_INT 105
45670: PUSH
45671: LD_INT 106
45673: PUSH
45674: LD_INT 108
45676: PUSH
45677: LD_INT 112
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: ST_TO_ADDR
45693: GO 47952
45695: LD_INT 8
45697: DOUBLE
45698: EQUAL
45699: IFTRUE 45703
45701: GO 45831
45703: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45704: LD_ADDR_VAR 0 1
45708: PUSH
45709: LD_INT 2
45711: PUSH
45712: LD_INT 4
45714: PUSH
45715: LD_INT 5
45717: PUSH
45718: LD_INT 6
45720: PUSH
45721: LD_INT 7
45723: PUSH
45724: LD_INT 8
45726: PUSH
45727: LD_INT 11
45729: PUSH
45730: LD_INT 12
45732: PUSH
45733: LD_INT 15
45735: PUSH
45736: LD_INT 16
45738: PUSH
45739: LD_INT 20
45741: PUSH
45742: LD_INT 21
45744: PUSH
45745: LD_INT 22
45747: PUSH
45748: LD_INT 23
45750: PUSH
45751: LD_INT 25
45753: PUSH
45754: LD_INT 26
45756: PUSH
45757: LD_INT 30
45759: PUSH
45760: LD_INT 31
45762: PUSH
45763: LD_INT 32
45765: PUSH
45766: LD_INT 36
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: LIST
45778: LIST
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: PUSH
45791: LD_INT 101
45793: PUSH
45794: LD_INT 102
45796: PUSH
45797: LD_INT 103
45799: PUSH
45800: LD_INT 105
45802: PUSH
45803: LD_INT 106
45805: PUSH
45806: LD_INT 108
45808: PUSH
45809: LD_INT 109
45811: PUSH
45812: LD_INT 112
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: ST_TO_ADDR
45829: GO 47952
45831: LD_INT 9
45833: DOUBLE
45834: EQUAL
45835: IFTRUE 45839
45837: GO 45975
45839: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45840: LD_ADDR_VAR 0 1
45844: PUSH
45845: LD_INT 2
45847: PUSH
45848: LD_INT 4
45850: PUSH
45851: LD_INT 5
45853: PUSH
45854: LD_INT 6
45856: PUSH
45857: LD_INT 7
45859: PUSH
45860: LD_INT 8
45862: PUSH
45863: LD_INT 11
45865: PUSH
45866: LD_INT 12
45868: PUSH
45869: LD_INT 15
45871: PUSH
45872: LD_INT 16
45874: PUSH
45875: LD_INT 20
45877: PUSH
45878: LD_INT 21
45880: PUSH
45881: LD_INT 22
45883: PUSH
45884: LD_INT 23
45886: PUSH
45887: LD_INT 25
45889: PUSH
45890: LD_INT 26
45892: PUSH
45893: LD_INT 28
45895: PUSH
45896: LD_INT 30
45898: PUSH
45899: LD_INT 31
45901: PUSH
45902: LD_INT 32
45904: PUSH
45905: LD_INT 36
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: LIST
45930: PUSH
45931: LD_INT 101
45933: PUSH
45934: LD_INT 102
45936: PUSH
45937: LD_INT 103
45939: PUSH
45940: LD_INT 105
45942: PUSH
45943: LD_INT 106
45945: PUSH
45946: LD_INT 108
45948: PUSH
45949: LD_INT 109
45951: PUSH
45952: LD_INT 112
45954: PUSH
45955: LD_INT 114
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: ST_TO_ADDR
45973: GO 47952
45975: LD_INT 10
45977: DOUBLE
45978: EQUAL
45979: IFTRUE 45983
45981: GO 46167
45983: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45984: LD_ADDR_VAR 0 1
45988: PUSH
45989: LD_INT 2
45991: PUSH
45992: LD_INT 4
45994: PUSH
45995: LD_INT 5
45997: PUSH
45998: LD_INT 6
46000: PUSH
46001: LD_INT 7
46003: PUSH
46004: LD_INT 8
46006: PUSH
46007: LD_INT 9
46009: PUSH
46010: LD_INT 10
46012: PUSH
46013: LD_INT 11
46015: PUSH
46016: LD_INT 12
46018: PUSH
46019: LD_INT 13
46021: PUSH
46022: LD_INT 14
46024: PUSH
46025: LD_INT 15
46027: PUSH
46028: LD_INT 16
46030: PUSH
46031: LD_INT 17
46033: PUSH
46034: LD_INT 18
46036: PUSH
46037: LD_INT 19
46039: PUSH
46040: LD_INT 20
46042: PUSH
46043: LD_INT 21
46045: PUSH
46046: LD_INT 22
46048: PUSH
46049: LD_INT 23
46051: PUSH
46052: LD_INT 24
46054: PUSH
46055: LD_INT 25
46057: PUSH
46058: LD_INT 26
46060: PUSH
46061: LD_INT 28
46063: PUSH
46064: LD_INT 30
46066: PUSH
46067: LD_INT 31
46069: PUSH
46070: LD_INT 32
46072: PUSH
46073: LD_INT 36
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: LIST
46080: LIST
46081: LIST
46082: LIST
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: LIST
46100: LIST
46101: LIST
46102: LIST
46103: LIST
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 101
46109: PUSH
46110: LD_INT 102
46112: PUSH
46113: LD_INT 103
46115: PUSH
46116: LD_INT 104
46118: PUSH
46119: LD_INT 105
46121: PUSH
46122: LD_INT 106
46124: PUSH
46125: LD_INT 107
46127: PUSH
46128: LD_INT 108
46130: PUSH
46131: LD_INT 109
46133: PUSH
46134: LD_INT 110
46136: PUSH
46137: LD_INT 111
46139: PUSH
46140: LD_INT 112
46142: PUSH
46143: LD_INT 114
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: ST_TO_ADDR
46165: GO 47952
46167: LD_INT 11
46169: DOUBLE
46170: EQUAL
46171: IFTRUE 46175
46173: GO 46367
46175: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46176: LD_ADDR_VAR 0 1
46180: PUSH
46181: LD_INT 2
46183: PUSH
46184: LD_INT 3
46186: PUSH
46187: LD_INT 4
46189: PUSH
46190: LD_INT 5
46192: PUSH
46193: LD_INT 6
46195: PUSH
46196: LD_INT 7
46198: PUSH
46199: LD_INT 8
46201: PUSH
46202: LD_INT 9
46204: PUSH
46205: LD_INT 10
46207: PUSH
46208: LD_INT 11
46210: PUSH
46211: LD_INT 12
46213: PUSH
46214: LD_INT 13
46216: PUSH
46217: LD_INT 14
46219: PUSH
46220: LD_INT 15
46222: PUSH
46223: LD_INT 16
46225: PUSH
46226: LD_INT 17
46228: PUSH
46229: LD_INT 18
46231: PUSH
46232: LD_INT 19
46234: PUSH
46235: LD_INT 20
46237: PUSH
46238: LD_INT 21
46240: PUSH
46241: LD_INT 22
46243: PUSH
46244: LD_INT 23
46246: PUSH
46247: LD_INT 24
46249: PUSH
46250: LD_INT 25
46252: PUSH
46253: LD_INT 26
46255: PUSH
46256: LD_INT 28
46258: PUSH
46259: LD_INT 30
46261: PUSH
46262: LD_INT 31
46264: PUSH
46265: LD_INT 32
46267: PUSH
46268: LD_INT 34
46270: PUSH
46271: LD_INT 36
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: LIST
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: LIST
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 101
46309: PUSH
46310: LD_INT 102
46312: PUSH
46313: LD_INT 103
46315: PUSH
46316: LD_INT 104
46318: PUSH
46319: LD_INT 105
46321: PUSH
46322: LD_INT 106
46324: PUSH
46325: LD_INT 107
46327: PUSH
46328: LD_INT 108
46330: PUSH
46331: LD_INT 109
46333: PUSH
46334: LD_INT 110
46336: PUSH
46337: LD_INT 111
46339: PUSH
46340: LD_INT 112
46342: PUSH
46343: LD_INT 114
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: ST_TO_ADDR
46365: GO 47952
46367: LD_INT 12
46369: DOUBLE
46370: EQUAL
46371: IFTRUE 46375
46373: GO 46583
46375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46376: LD_ADDR_VAR 0 1
46380: PUSH
46381: LD_INT 1
46383: PUSH
46384: LD_INT 2
46386: PUSH
46387: LD_INT 3
46389: PUSH
46390: LD_INT 4
46392: PUSH
46393: LD_INT 5
46395: PUSH
46396: LD_INT 6
46398: PUSH
46399: LD_INT 7
46401: PUSH
46402: LD_INT 8
46404: PUSH
46405: LD_INT 9
46407: PUSH
46408: LD_INT 10
46410: PUSH
46411: LD_INT 11
46413: PUSH
46414: LD_INT 12
46416: PUSH
46417: LD_INT 13
46419: PUSH
46420: LD_INT 14
46422: PUSH
46423: LD_INT 15
46425: PUSH
46426: LD_INT 16
46428: PUSH
46429: LD_INT 17
46431: PUSH
46432: LD_INT 18
46434: PUSH
46435: LD_INT 19
46437: PUSH
46438: LD_INT 20
46440: PUSH
46441: LD_INT 21
46443: PUSH
46444: LD_INT 22
46446: PUSH
46447: LD_INT 23
46449: PUSH
46450: LD_INT 24
46452: PUSH
46453: LD_INT 25
46455: PUSH
46456: LD_INT 26
46458: PUSH
46459: LD_INT 27
46461: PUSH
46462: LD_INT 28
46464: PUSH
46465: LD_INT 30
46467: PUSH
46468: LD_INT 31
46470: PUSH
46471: LD_INT 32
46473: PUSH
46474: LD_INT 33
46476: PUSH
46477: LD_INT 34
46479: PUSH
46480: LD_INT 36
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: LIST
46487: LIST
46488: LIST
46489: LIST
46490: LIST
46491: LIST
46492: LIST
46493: LIST
46494: LIST
46495: LIST
46496: LIST
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: PUSH
46519: LD_INT 101
46521: PUSH
46522: LD_INT 102
46524: PUSH
46525: LD_INT 103
46527: PUSH
46528: LD_INT 104
46530: PUSH
46531: LD_INT 105
46533: PUSH
46534: LD_INT 106
46536: PUSH
46537: LD_INT 107
46539: PUSH
46540: LD_INT 108
46542: PUSH
46543: LD_INT 109
46545: PUSH
46546: LD_INT 110
46548: PUSH
46549: LD_INT 111
46551: PUSH
46552: LD_INT 112
46554: PUSH
46555: LD_INT 113
46557: PUSH
46558: LD_INT 114
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: ST_TO_ADDR
46581: GO 47952
46583: LD_INT 13
46585: DOUBLE
46586: EQUAL
46587: IFTRUE 46591
46589: GO 46787
46591: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46592: LD_ADDR_VAR 0 1
46596: PUSH
46597: LD_INT 1
46599: PUSH
46600: LD_INT 2
46602: PUSH
46603: LD_INT 3
46605: PUSH
46606: LD_INT 4
46608: PUSH
46609: LD_INT 5
46611: PUSH
46612: LD_INT 8
46614: PUSH
46615: LD_INT 9
46617: PUSH
46618: LD_INT 10
46620: PUSH
46621: LD_INT 11
46623: PUSH
46624: LD_INT 12
46626: PUSH
46627: LD_INT 14
46629: PUSH
46630: LD_INT 15
46632: PUSH
46633: LD_INT 16
46635: PUSH
46636: LD_INT 17
46638: PUSH
46639: LD_INT 18
46641: PUSH
46642: LD_INT 19
46644: PUSH
46645: LD_INT 20
46647: PUSH
46648: LD_INT 21
46650: PUSH
46651: LD_INT 22
46653: PUSH
46654: LD_INT 23
46656: PUSH
46657: LD_INT 24
46659: PUSH
46660: LD_INT 25
46662: PUSH
46663: LD_INT 26
46665: PUSH
46666: LD_INT 27
46668: PUSH
46669: LD_INT 28
46671: PUSH
46672: LD_INT 30
46674: PUSH
46675: LD_INT 31
46677: PUSH
46678: LD_INT 32
46680: PUSH
46681: LD_INT 33
46683: PUSH
46684: LD_INT 34
46686: PUSH
46687: LD_INT 36
46689: PUSH
46690: EMPTY
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: LIST
46702: LIST
46703: LIST
46704: LIST
46705: LIST
46706: LIST
46707: LIST
46708: LIST
46709: LIST
46710: LIST
46711: LIST
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: PUSH
46723: LD_INT 101
46725: PUSH
46726: LD_INT 102
46728: PUSH
46729: LD_INT 103
46731: PUSH
46732: LD_INT 104
46734: PUSH
46735: LD_INT 105
46737: PUSH
46738: LD_INT 106
46740: PUSH
46741: LD_INT 107
46743: PUSH
46744: LD_INT 108
46746: PUSH
46747: LD_INT 109
46749: PUSH
46750: LD_INT 110
46752: PUSH
46753: LD_INT 111
46755: PUSH
46756: LD_INT 112
46758: PUSH
46759: LD_INT 113
46761: PUSH
46762: LD_INT 114
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: ST_TO_ADDR
46785: GO 47952
46787: LD_INT 14
46789: DOUBLE
46790: EQUAL
46791: IFTRUE 46795
46793: GO 47007
46795: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46796: LD_ADDR_VAR 0 1
46800: PUSH
46801: LD_INT 1
46803: PUSH
46804: LD_INT 2
46806: PUSH
46807: LD_INT 3
46809: PUSH
46810: LD_INT 4
46812: PUSH
46813: LD_INT 5
46815: PUSH
46816: LD_INT 6
46818: PUSH
46819: LD_INT 7
46821: PUSH
46822: LD_INT 8
46824: PUSH
46825: LD_INT 9
46827: PUSH
46828: LD_INT 10
46830: PUSH
46831: LD_INT 11
46833: PUSH
46834: LD_INT 12
46836: PUSH
46837: LD_INT 13
46839: PUSH
46840: LD_INT 14
46842: PUSH
46843: LD_INT 15
46845: PUSH
46846: LD_INT 16
46848: PUSH
46849: LD_INT 17
46851: PUSH
46852: LD_INT 18
46854: PUSH
46855: LD_INT 19
46857: PUSH
46858: LD_INT 20
46860: PUSH
46861: LD_INT 21
46863: PUSH
46864: LD_INT 22
46866: PUSH
46867: LD_INT 23
46869: PUSH
46870: LD_INT 24
46872: PUSH
46873: LD_INT 25
46875: PUSH
46876: LD_INT 26
46878: PUSH
46879: LD_INT 27
46881: PUSH
46882: LD_INT 28
46884: PUSH
46885: LD_INT 29
46887: PUSH
46888: LD_INT 30
46890: PUSH
46891: LD_INT 31
46893: PUSH
46894: LD_INT 32
46896: PUSH
46897: LD_INT 33
46899: PUSH
46900: LD_INT 34
46902: PUSH
46903: LD_INT 36
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 101
46945: PUSH
46946: LD_INT 102
46948: PUSH
46949: LD_INT 103
46951: PUSH
46952: LD_INT 104
46954: PUSH
46955: LD_INT 105
46957: PUSH
46958: LD_INT 106
46960: PUSH
46961: LD_INT 107
46963: PUSH
46964: LD_INT 108
46966: PUSH
46967: LD_INT 109
46969: PUSH
46970: LD_INT 110
46972: PUSH
46973: LD_INT 111
46975: PUSH
46976: LD_INT 112
46978: PUSH
46979: LD_INT 113
46981: PUSH
46982: LD_INT 114
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: ST_TO_ADDR
47005: GO 47952
47007: LD_INT 15
47009: DOUBLE
47010: EQUAL
47011: IFTRUE 47015
47013: GO 47227
47015: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
47016: LD_ADDR_VAR 0 1
47020: PUSH
47021: LD_INT 1
47023: PUSH
47024: LD_INT 2
47026: PUSH
47027: LD_INT 3
47029: PUSH
47030: LD_INT 4
47032: PUSH
47033: LD_INT 5
47035: PUSH
47036: LD_INT 6
47038: PUSH
47039: LD_INT 7
47041: PUSH
47042: LD_INT 8
47044: PUSH
47045: LD_INT 9
47047: PUSH
47048: LD_INT 10
47050: PUSH
47051: LD_INT 11
47053: PUSH
47054: LD_INT 12
47056: PUSH
47057: LD_INT 13
47059: PUSH
47060: LD_INT 14
47062: PUSH
47063: LD_INT 15
47065: PUSH
47066: LD_INT 16
47068: PUSH
47069: LD_INT 17
47071: PUSH
47072: LD_INT 18
47074: PUSH
47075: LD_INT 19
47077: PUSH
47078: LD_INT 20
47080: PUSH
47081: LD_INT 21
47083: PUSH
47084: LD_INT 22
47086: PUSH
47087: LD_INT 23
47089: PUSH
47090: LD_INT 24
47092: PUSH
47093: LD_INT 25
47095: PUSH
47096: LD_INT 26
47098: PUSH
47099: LD_INT 27
47101: PUSH
47102: LD_INT 28
47104: PUSH
47105: LD_INT 29
47107: PUSH
47108: LD_INT 30
47110: PUSH
47111: LD_INT 31
47113: PUSH
47114: LD_INT 32
47116: PUSH
47117: LD_INT 33
47119: PUSH
47120: LD_INT 34
47122: PUSH
47123: LD_INT 36
47125: PUSH
47126: EMPTY
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: LIST
47133: LIST
47134: LIST
47135: LIST
47136: LIST
47137: LIST
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: LIST
47161: LIST
47162: PUSH
47163: LD_INT 101
47165: PUSH
47166: LD_INT 102
47168: PUSH
47169: LD_INT 103
47171: PUSH
47172: LD_INT 104
47174: PUSH
47175: LD_INT 105
47177: PUSH
47178: LD_INT 106
47180: PUSH
47181: LD_INT 107
47183: PUSH
47184: LD_INT 108
47186: PUSH
47187: LD_INT 109
47189: PUSH
47190: LD_INT 110
47192: PUSH
47193: LD_INT 111
47195: PUSH
47196: LD_INT 112
47198: PUSH
47199: LD_INT 113
47201: PUSH
47202: LD_INT 114
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: ST_TO_ADDR
47225: GO 47952
47227: LD_INT 16
47229: DOUBLE
47230: EQUAL
47231: IFTRUE 47235
47233: GO 47359
47235: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47236: LD_ADDR_VAR 0 1
47240: PUSH
47241: LD_INT 2
47243: PUSH
47244: LD_INT 4
47246: PUSH
47247: LD_INT 5
47249: PUSH
47250: LD_INT 7
47252: PUSH
47253: LD_INT 11
47255: PUSH
47256: LD_INT 12
47258: PUSH
47259: LD_INT 15
47261: PUSH
47262: LD_INT 16
47264: PUSH
47265: LD_INT 20
47267: PUSH
47268: LD_INT 21
47270: PUSH
47271: LD_INT 22
47273: PUSH
47274: LD_INT 23
47276: PUSH
47277: LD_INT 25
47279: PUSH
47280: LD_INT 26
47282: PUSH
47283: LD_INT 30
47285: PUSH
47286: LD_INT 31
47288: PUSH
47289: LD_INT 32
47291: PUSH
47292: LD_INT 33
47294: PUSH
47295: LD_INT 34
47297: PUSH
47298: EMPTY
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: LIST
47316: LIST
47317: LIST
47318: PUSH
47319: LD_INT 101
47321: PUSH
47322: LD_INT 102
47324: PUSH
47325: LD_INT 103
47327: PUSH
47328: LD_INT 106
47330: PUSH
47331: LD_INT 108
47333: PUSH
47334: LD_INT 112
47336: PUSH
47337: LD_INT 113
47339: PUSH
47340: LD_INT 114
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: ST_TO_ADDR
47357: GO 47952
47359: LD_INT 17
47361: DOUBLE
47362: EQUAL
47363: IFTRUE 47367
47365: GO 47579
47367: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47368: LD_ADDR_VAR 0 1
47372: PUSH
47373: LD_INT 1
47375: PUSH
47376: LD_INT 2
47378: PUSH
47379: LD_INT 3
47381: PUSH
47382: LD_INT 4
47384: PUSH
47385: LD_INT 5
47387: PUSH
47388: LD_INT 6
47390: PUSH
47391: LD_INT 7
47393: PUSH
47394: LD_INT 8
47396: PUSH
47397: LD_INT 9
47399: PUSH
47400: LD_INT 10
47402: PUSH
47403: LD_INT 11
47405: PUSH
47406: LD_INT 12
47408: PUSH
47409: LD_INT 13
47411: PUSH
47412: LD_INT 14
47414: PUSH
47415: LD_INT 15
47417: PUSH
47418: LD_INT 16
47420: PUSH
47421: LD_INT 17
47423: PUSH
47424: LD_INT 18
47426: PUSH
47427: LD_INT 19
47429: PUSH
47430: LD_INT 20
47432: PUSH
47433: LD_INT 21
47435: PUSH
47436: LD_INT 22
47438: PUSH
47439: LD_INT 23
47441: PUSH
47442: LD_INT 24
47444: PUSH
47445: LD_INT 25
47447: PUSH
47448: LD_INT 26
47450: PUSH
47451: LD_INT 27
47453: PUSH
47454: LD_INT 28
47456: PUSH
47457: LD_INT 29
47459: PUSH
47460: LD_INT 30
47462: PUSH
47463: LD_INT 31
47465: PUSH
47466: LD_INT 32
47468: PUSH
47469: LD_INT 33
47471: PUSH
47472: LD_INT 34
47474: PUSH
47475: LD_INT 36
47477: PUSH
47478: EMPTY
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: PUSH
47515: LD_INT 101
47517: PUSH
47518: LD_INT 102
47520: PUSH
47521: LD_INT 103
47523: PUSH
47524: LD_INT 104
47526: PUSH
47527: LD_INT 105
47529: PUSH
47530: LD_INT 106
47532: PUSH
47533: LD_INT 107
47535: PUSH
47536: LD_INT 108
47538: PUSH
47539: LD_INT 109
47541: PUSH
47542: LD_INT 110
47544: PUSH
47545: LD_INT 111
47547: PUSH
47548: LD_INT 112
47550: PUSH
47551: LD_INT 113
47553: PUSH
47554: LD_INT 114
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: ST_TO_ADDR
47577: GO 47952
47579: LD_INT 18
47581: DOUBLE
47582: EQUAL
47583: IFTRUE 47587
47585: GO 47723
47587: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47588: LD_ADDR_VAR 0 1
47592: PUSH
47593: LD_INT 2
47595: PUSH
47596: LD_INT 4
47598: PUSH
47599: LD_INT 5
47601: PUSH
47602: LD_INT 7
47604: PUSH
47605: LD_INT 11
47607: PUSH
47608: LD_INT 12
47610: PUSH
47611: LD_INT 15
47613: PUSH
47614: LD_INT 16
47616: PUSH
47617: LD_INT 20
47619: PUSH
47620: LD_INT 21
47622: PUSH
47623: LD_INT 22
47625: PUSH
47626: LD_INT 23
47628: PUSH
47629: LD_INT 25
47631: PUSH
47632: LD_INT 26
47634: PUSH
47635: LD_INT 30
47637: PUSH
47638: LD_INT 31
47640: PUSH
47641: LD_INT 32
47643: PUSH
47644: LD_INT 33
47646: PUSH
47647: LD_INT 34
47649: PUSH
47650: LD_INT 35
47652: PUSH
47653: LD_INT 36
47655: PUSH
47656: EMPTY
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: PUSH
47679: LD_INT 101
47681: PUSH
47682: LD_INT 102
47684: PUSH
47685: LD_INT 103
47687: PUSH
47688: LD_INT 106
47690: PUSH
47691: LD_INT 108
47693: PUSH
47694: LD_INT 112
47696: PUSH
47697: LD_INT 113
47699: PUSH
47700: LD_INT 114
47702: PUSH
47703: LD_INT 115
47705: PUSH
47706: EMPTY
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: PUSH
47717: EMPTY
47718: LIST
47719: LIST
47720: ST_TO_ADDR
47721: GO 47952
47723: LD_INT 19
47725: DOUBLE
47726: EQUAL
47727: IFTRUE 47731
47729: GO 47951
47731: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47732: LD_ADDR_VAR 0 1
47736: PUSH
47737: LD_INT 1
47739: PUSH
47740: LD_INT 2
47742: PUSH
47743: LD_INT 3
47745: PUSH
47746: LD_INT 4
47748: PUSH
47749: LD_INT 5
47751: PUSH
47752: LD_INT 6
47754: PUSH
47755: LD_INT 7
47757: PUSH
47758: LD_INT 8
47760: PUSH
47761: LD_INT 9
47763: PUSH
47764: LD_INT 10
47766: PUSH
47767: LD_INT 11
47769: PUSH
47770: LD_INT 12
47772: PUSH
47773: LD_INT 13
47775: PUSH
47776: LD_INT 14
47778: PUSH
47779: LD_INT 15
47781: PUSH
47782: LD_INT 16
47784: PUSH
47785: LD_INT 17
47787: PUSH
47788: LD_INT 18
47790: PUSH
47791: LD_INT 19
47793: PUSH
47794: LD_INT 20
47796: PUSH
47797: LD_INT 21
47799: PUSH
47800: LD_INT 22
47802: PUSH
47803: LD_INT 23
47805: PUSH
47806: LD_INT 24
47808: PUSH
47809: LD_INT 25
47811: PUSH
47812: LD_INT 26
47814: PUSH
47815: LD_INT 27
47817: PUSH
47818: LD_INT 28
47820: PUSH
47821: LD_INT 29
47823: PUSH
47824: LD_INT 30
47826: PUSH
47827: LD_INT 31
47829: PUSH
47830: LD_INT 32
47832: PUSH
47833: LD_INT 33
47835: PUSH
47836: LD_INT 34
47838: PUSH
47839: LD_INT 35
47841: PUSH
47842: LD_INT 36
47844: PUSH
47845: EMPTY
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: PUSH
47883: LD_INT 101
47885: PUSH
47886: LD_INT 102
47888: PUSH
47889: LD_INT 103
47891: PUSH
47892: LD_INT 104
47894: PUSH
47895: LD_INT 105
47897: PUSH
47898: LD_INT 106
47900: PUSH
47901: LD_INT 107
47903: PUSH
47904: LD_INT 108
47906: PUSH
47907: LD_INT 109
47909: PUSH
47910: LD_INT 110
47912: PUSH
47913: LD_INT 111
47915: PUSH
47916: LD_INT 112
47918: PUSH
47919: LD_INT 113
47921: PUSH
47922: LD_INT 114
47924: PUSH
47925: LD_INT 115
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: ST_TO_ADDR
47949: GO 47952
47951: POP
// end else
47952: GO 48171
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47954: LD_ADDR_VAR 0 1
47958: PUSH
47959: LD_INT 1
47961: PUSH
47962: LD_INT 2
47964: PUSH
47965: LD_INT 3
47967: PUSH
47968: LD_INT 4
47970: PUSH
47971: LD_INT 5
47973: PUSH
47974: LD_INT 6
47976: PUSH
47977: LD_INT 7
47979: PUSH
47980: LD_INT 8
47982: PUSH
47983: LD_INT 9
47985: PUSH
47986: LD_INT 10
47988: PUSH
47989: LD_INT 11
47991: PUSH
47992: LD_INT 12
47994: PUSH
47995: LD_INT 13
47997: PUSH
47998: LD_INT 14
48000: PUSH
48001: LD_INT 15
48003: PUSH
48004: LD_INT 16
48006: PUSH
48007: LD_INT 17
48009: PUSH
48010: LD_INT 18
48012: PUSH
48013: LD_INT 19
48015: PUSH
48016: LD_INT 20
48018: PUSH
48019: LD_INT 21
48021: PUSH
48022: LD_INT 22
48024: PUSH
48025: LD_INT 23
48027: PUSH
48028: LD_INT 24
48030: PUSH
48031: LD_INT 25
48033: PUSH
48034: LD_INT 26
48036: PUSH
48037: LD_INT 27
48039: PUSH
48040: LD_INT 28
48042: PUSH
48043: LD_INT 29
48045: PUSH
48046: LD_INT 30
48048: PUSH
48049: LD_INT 31
48051: PUSH
48052: LD_INT 32
48054: PUSH
48055: LD_INT 33
48057: PUSH
48058: LD_INT 34
48060: PUSH
48061: LD_INT 35
48063: PUSH
48064: LD_INT 36
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: LIST
48079: LIST
48080: LIST
48081: LIST
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: LIST
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: PUSH
48105: LD_INT 101
48107: PUSH
48108: LD_INT 102
48110: PUSH
48111: LD_INT 103
48113: PUSH
48114: LD_INT 104
48116: PUSH
48117: LD_INT 105
48119: PUSH
48120: LD_INT 106
48122: PUSH
48123: LD_INT 107
48125: PUSH
48126: LD_INT 108
48128: PUSH
48129: LD_INT 109
48131: PUSH
48132: LD_INT 110
48134: PUSH
48135: LD_INT 111
48137: PUSH
48138: LD_INT 112
48140: PUSH
48141: LD_INT 113
48143: PUSH
48144: LD_INT 114
48146: PUSH
48147: LD_INT 115
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: ST_TO_ADDR
// if result then
48171: LD_VAR 0 1
48175: IFFALSE 48464
// begin normal :=  ;
48177: LD_ADDR_VAR 0 3
48181: PUSH
48182: LD_STRING 
48184: ST_TO_ADDR
// hardcore :=  ;
48185: LD_ADDR_VAR 0 4
48189: PUSH
48190: LD_STRING 
48192: ST_TO_ADDR
// for i = 1 to normalCounter do
48193: LD_ADDR_VAR 0 5
48197: PUSH
48198: DOUBLE
48199: LD_INT 1
48201: DEC
48202: ST_TO_ADDR
48203: LD_EXP 93
48207: PUSH
48208: FOR_TO
48209: IFFALSE 48310
// begin tmp := 0 ;
48211: LD_ADDR_VAR 0 2
48215: PUSH
48216: LD_STRING 0
48218: ST_TO_ADDR
// if result [ 1 ] then
48219: LD_VAR 0 1
48223: PUSH
48224: LD_INT 1
48226: ARRAY
48227: IFFALSE 48292
// if result [ 1 ] [ 1 ] = i then
48229: LD_VAR 0 1
48233: PUSH
48234: LD_INT 1
48236: ARRAY
48237: PUSH
48238: LD_INT 1
48240: ARRAY
48241: PUSH
48242: LD_VAR 0 5
48246: EQUAL
48247: IFFALSE 48292
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48249: LD_ADDR_VAR 0 1
48253: PUSH
48254: LD_VAR 0 1
48258: PPUSH
48259: LD_INT 1
48261: PPUSH
48262: LD_VAR 0 1
48266: PUSH
48267: LD_INT 1
48269: ARRAY
48270: PPUSH
48271: LD_INT 1
48273: PPUSH
48274: CALL_OW 3
48278: PPUSH
48279: CALL_OW 1
48283: ST_TO_ADDR
// tmp := 1 ;
48284: LD_ADDR_VAR 0 2
48288: PUSH
48289: LD_STRING 1
48291: ST_TO_ADDR
// end ; normal := normal & tmp ;
48292: LD_ADDR_VAR 0 3
48296: PUSH
48297: LD_VAR 0 3
48301: PUSH
48302: LD_VAR 0 2
48306: STR
48307: ST_TO_ADDR
// end ;
48308: GO 48208
48310: POP
48311: POP
// for i = 1 to hardcoreCounter do
48312: LD_ADDR_VAR 0 5
48316: PUSH
48317: DOUBLE
48318: LD_INT 1
48320: DEC
48321: ST_TO_ADDR
48322: LD_EXP 94
48326: PUSH
48327: FOR_TO
48328: IFFALSE 48433
// begin tmp := 0 ;
48330: LD_ADDR_VAR 0 2
48334: PUSH
48335: LD_STRING 0
48337: ST_TO_ADDR
// if result [ 2 ] then
48338: LD_VAR 0 1
48342: PUSH
48343: LD_INT 2
48345: ARRAY
48346: IFFALSE 48415
// if result [ 2 ] [ 1 ] = 100 + i then
48348: LD_VAR 0 1
48352: PUSH
48353: LD_INT 2
48355: ARRAY
48356: PUSH
48357: LD_INT 1
48359: ARRAY
48360: PUSH
48361: LD_INT 100
48363: PUSH
48364: LD_VAR 0 5
48368: PLUS
48369: EQUAL
48370: IFFALSE 48415
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48372: LD_ADDR_VAR 0 1
48376: PUSH
48377: LD_VAR 0 1
48381: PPUSH
48382: LD_INT 2
48384: PPUSH
48385: LD_VAR 0 1
48389: PUSH
48390: LD_INT 2
48392: ARRAY
48393: PPUSH
48394: LD_INT 1
48396: PPUSH
48397: CALL_OW 3
48401: PPUSH
48402: CALL_OW 1
48406: ST_TO_ADDR
// tmp := 1 ;
48407: LD_ADDR_VAR 0 2
48411: PUSH
48412: LD_STRING 1
48414: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48415: LD_ADDR_VAR 0 4
48419: PUSH
48420: LD_VAR 0 4
48424: PUSH
48425: LD_VAR 0 2
48429: STR
48430: ST_TO_ADDR
// end ;
48431: GO 48327
48433: POP
48434: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48435: LD_STRING getStreamItemsFromMission("
48437: PUSH
48438: LD_VAR 0 3
48442: STR
48443: PUSH
48444: LD_STRING ","
48446: STR
48447: PUSH
48448: LD_VAR 0 4
48452: STR
48453: PUSH
48454: LD_STRING ")
48456: STR
48457: PPUSH
48458: CALL_OW 559
// end else
48462: GO 48471
// ToLua ( getStreamItemsFromMission("","") ) ;
48464: LD_STRING getStreamItemsFromMission("","")
48466: PPUSH
48467: CALL_OW 559
// end ;
48471: LD_VAR 0 1
48475: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48476: LD_EXP 92
48480: PUSH
48481: LD_EXP 97
48485: AND
48486: IFFALSE 48610
48488: GO 48490
48490: DISABLE
48491: LD_INT 0
48493: PPUSH
48494: PPUSH
// begin enable ;
48495: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48496: LD_ADDR_VAR 0 2
48500: PUSH
48501: LD_INT 22
48503: PUSH
48504: LD_OWVAR 2
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: PUSH
48513: LD_INT 2
48515: PUSH
48516: LD_INT 34
48518: PUSH
48519: LD_INT 7
48521: PUSH
48522: EMPTY
48523: LIST
48524: LIST
48525: PUSH
48526: LD_INT 34
48528: PUSH
48529: LD_INT 45
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: PUSH
48536: LD_INT 34
48538: PUSH
48539: LD_INT 28
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: PUSH
48546: LD_INT 34
48548: PUSH
48549: LD_INT 47
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: PUSH
48556: EMPTY
48557: LIST
48558: LIST
48559: LIST
48560: LIST
48561: LIST
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: PPUSH
48567: CALL_OW 69
48571: ST_TO_ADDR
// if not tmp then
48572: LD_VAR 0 2
48576: NOT
48577: IFFALSE 48581
// exit ;
48579: GO 48610
// for i in tmp do
48581: LD_ADDR_VAR 0 1
48585: PUSH
48586: LD_VAR 0 2
48590: PUSH
48591: FOR_IN
48592: IFFALSE 48608
// begin SetLives ( i , 0 ) ;
48594: LD_VAR 0 1
48598: PPUSH
48599: LD_INT 0
48601: PPUSH
48602: CALL_OW 234
// end ;
48606: GO 48591
48608: POP
48609: POP
// end ;
48610: PPOPN 2
48612: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48613: LD_EXP 92
48617: PUSH
48618: LD_EXP 98
48622: AND
48623: IFFALSE 48707
48625: GO 48627
48627: DISABLE
48628: LD_INT 0
48630: PPUSH
48631: PPUSH
// begin enable ;
48632: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48633: LD_ADDR_VAR 0 2
48637: PUSH
48638: LD_INT 22
48640: PUSH
48641: LD_OWVAR 2
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: LD_INT 32
48652: PUSH
48653: LD_INT 3
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PPUSH
48664: CALL_OW 69
48668: ST_TO_ADDR
// if not tmp then
48669: LD_VAR 0 2
48673: NOT
48674: IFFALSE 48678
// exit ;
48676: GO 48707
// for i in tmp do
48678: LD_ADDR_VAR 0 1
48682: PUSH
48683: LD_VAR 0 2
48687: PUSH
48688: FOR_IN
48689: IFFALSE 48705
// begin SetLives ( i , 0 ) ;
48691: LD_VAR 0 1
48695: PPUSH
48696: LD_INT 0
48698: PPUSH
48699: CALL_OW 234
// end ;
48703: GO 48688
48705: POP
48706: POP
// end ;
48707: PPOPN 2
48709: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48710: LD_EXP 92
48714: PUSH
48715: LD_EXP 95
48719: AND
48720: IFFALSE 48813
48722: GO 48724
48724: DISABLE
48725: LD_INT 0
48727: PPUSH
// begin enable ;
48728: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48729: LD_ADDR_VAR 0 1
48733: PUSH
48734: LD_INT 22
48736: PUSH
48737: LD_OWVAR 2
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 2
48748: PUSH
48749: LD_INT 25
48751: PUSH
48752: LD_INT 5
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: PUSH
48759: LD_INT 25
48761: PUSH
48762: LD_INT 9
48764: PUSH
48765: EMPTY
48766: LIST
48767: LIST
48768: PUSH
48769: LD_INT 25
48771: PUSH
48772: LD_INT 8
48774: PUSH
48775: EMPTY
48776: LIST
48777: LIST
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PPUSH
48789: CALL_OW 69
48793: PUSH
48794: FOR_IN
48795: IFFALSE 48811
// begin SetClass ( i , 1 ) ;
48797: LD_VAR 0 1
48801: PPUSH
48802: LD_INT 1
48804: PPUSH
48805: CALL_OW 336
// end ;
48809: GO 48794
48811: POP
48812: POP
// end ;
48813: PPOPN 1
48815: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48816: LD_EXP 92
48820: PUSH
48821: LD_EXP 96
48825: AND
48826: PUSH
48827: LD_OWVAR 65
48831: PUSH
48832: LD_INT 7
48834: LESS
48835: AND
48836: IFFALSE 48850
48838: GO 48840
48840: DISABLE
// begin enable ;
48841: ENABLE
// game_speed := 7 ;
48842: LD_ADDR_OWVAR 65
48846: PUSH
48847: LD_INT 7
48849: ST_TO_ADDR
// end ;
48850: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48851: LD_EXP 92
48855: PUSH
48856: LD_EXP 99
48860: AND
48861: IFFALSE 49063
48863: GO 48865
48865: DISABLE
48866: LD_INT 0
48868: PPUSH
48869: PPUSH
48870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48871: LD_ADDR_VAR 0 3
48875: PUSH
48876: LD_INT 81
48878: PUSH
48879: LD_OWVAR 2
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: PUSH
48888: LD_INT 21
48890: PUSH
48891: LD_INT 1
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PPUSH
48902: CALL_OW 69
48906: ST_TO_ADDR
// if not tmp then
48907: LD_VAR 0 3
48911: NOT
48912: IFFALSE 48916
// exit ;
48914: GO 49063
// if tmp > 5 then
48916: LD_VAR 0 3
48920: PUSH
48921: LD_INT 5
48923: GREATER
48924: IFFALSE 48936
// k := 5 else
48926: LD_ADDR_VAR 0 2
48930: PUSH
48931: LD_INT 5
48933: ST_TO_ADDR
48934: GO 48946
// k := tmp ;
48936: LD_ADDR_VAR 0 2
48940: PUSH
48941: LD_VAR 0 3
48945: ST_TO_ADDR
// for i := 1 to k do
48946: LD_ADDR_VAR 0 1
48950: PUSH
48951: DOUBLE
48952: LD_INT 1
48954: DEC
48955: ST_TO_ADDR
48956: LD_VAR 0 2
48960: PUSH
48961: FOR_TO
48962: IFFALSE 49061
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48964: LD_VAR 0 3
48968: PUSH
48969: LD_VAR 0 1
48973: ARRAY
48974: PPUSH
48975: LD_VAR 0 1
48979: PUSH
48980: LD_INT 4
48982: MOD
48983: PUSH
48984: LD_INT 1
48986: PLUS
48987: PPUSH
48988: CALL_OW 259
48992: PUSH
48993: LD_INT 10
48995: LESS
48996: IFFALSE 49059
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48998: LD_VAR 0 3
49002: PUSH
49003: LD_VAR 0 1
49007: ARRAY
49008: PPUSH
49009: LD_VAR 0 1
49013: PUSH
49014: LD_INT 4
49016: MOD
49017: PUSH
49018: LD_INT 1
49020: PLUS
49021: PPUSH
49022: LD_VAR 0 3
49026: PUSH
49027: LD_VAR 0 1
49031: ARRAY
49032: PPUSH
49033: LD_VAR 0 1
49037: PUSH
49038: LD_INT 4
49040: MOD
49041: PUSH
49042: LD_INT 1
49044: PLUS
49045: PPUSH
49046: CALL_OW 259
49050: PUSH
49051: LD_INT 1
49053: PLUS
49054: PPUSH
49055: CALL_OW 237
49059: GO 48961
49061: POP
49062: POP
// end ;
49063: PPOPN 3
49065: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49066: LD_EXP 92
49070: PUSH
49071: LD_EXP 100
49075: AND
49076: IFFALSE 49096
49078: GO 49080
49080: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49081: LD_INT 4
49083: PPUSH
49084: LD_OWVAR 2
49088: PPUSH
49089: LD_INT 0
49091: PPUSH
49092: CALL_OW 324
49096: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49097: LD_EXP 92
49101: PUSH
49102: LD_EXP 129
49106: AND
49107: IFFALSE 49127
49109: GO 49111
49111: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49112: LD_INT 19
49114: PPUSH
49115: LD_OWVAR 2
49119: PPUSH
49120: LD_INT 0
49122: PPUSH
49123: CALL_OW 324
49127: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49128: LD_EXP 92
49132: PUSH
49133: LD_EXP 101
49137: AND
49138: IFFALSE 49240
49140: GO 49142
49142: DISABLE
49143: LD_INT 0
49145: PPUSH
49146: PPUSH
// begin enable ;
49147: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49148: LD_ADDR_VAR 0 2
49152: PUSH
49153: LD_INT 22
49155: PUSH
49156: LD_OWVAR 2
49160: PUSH
49161: EMPTY
49162: LIST
49163: LIST
49164: PUSH
49165: LD_INT 2
49167: PUSH
49168: LD_INT 34
49170: PUSH
49171: LD_INT 11
49173: PUSH
49174: EMPTY
49175: LIST
49176: LIST
49177: PUSH
49178: LD_INT 34
49180: PUSH
49181: LD_INT 30
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: LIST
49192: PUSH
49193: EMPTY
49194: LIST
49195: LIST
49196: PPUSH
49197: CALL_OW 69
49201: ST_TO_ADDR
// if not tmp then
49202: LD_VAR 0 2
49206: NOT
49207: IFFALSE 49211
// exit ;
49209: GO 49240
// for i in tmp do
49211: LD_ADDR_VAR 0 1
49215: PUSH
49216: LD_VAR 0 2
49220: PUSH
49221: FOR_IN
49222: IFFALSE 49238
// begin SetLives ( i , 0 ) ;
49224: LD_VAR 0 1
49228: PPUSH
49229: LD_INT 0
49231: PPUSH
49232: CALL_OW 234
// end ;
49236: GO 49221
49238: POP
49239: POP
// end ;
49240: PPOPN 2
49242: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49243: LD_EXP 92
49247: PUSH
49248: LD_EXP 102
49252: AND
49253: IFFALSE 49273
49255: GO 49257
49257: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49258: LD_INT 32
49260: PPUSH
49261: LD_OWVAR 2
49265: PPUSH
49266: LD_INT 0
49268: PPUSH
49269: CALL_OW 324
49273: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49274: LD_EXP 92
49278: PUSH
49279: LD_EXP 103
49283: AND
49284: IFFALSE 49465
49286: GO 49288
49288: DISABLE
49289: LD_INT 0
49291: PPUSH
49292: PPUSH
49293: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49294: LD_ADDR_VAR 0 2
49298: PUSH
49299: LD_INT 22
49301: PUSH
49302: LD_OWVAR 2
49306: PUSH
49307: EMPTY
49308: LIST
49309: LIST
49310: PUSH
49311: LD_INT 33
49313: PUSH
49314: LD_INT 3
49316: PUSH
49317: EMPTY
49318: LIST
49319: LIST
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PPUSH
49325: CALL_OW 69
49329: ST_TO_ADDR
// if not tmp then
49330: LD_VAR 0 2
49334: NOT
49335: IFFALSE 49339
// exit ;
49337: GO 49465
// side := 0 ;
49339: LD_ADDR_VAR 0 3
49343: PUSH
49344: LD_INT 0
49346: ST_TO_ADDR
// for i := 1 to 8 do
49347: LD_ADDR_VAR 0 1
49351: PUSH
49352: DOUBLE
49353: LD_INT 1
49355: DEC
49356: ST_TO_ADDR
49357: LD_INT 8
49359: PUSH
49360: FOR_TO
49361: IFFALSE 49409
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49363: LD_OWVAR 2
49367: PUSH
49368: LD_VAR 0 1
49372: NONEQUAL
49373: PUSH
49374: LD_OWVAR 2
49378: PPUSH
49379: LD_VAR 0 1
49383: PPUSH
49384: CALL_OW 81
49388: PUSH
49389: LD_INT 2
49391: EQUAL
49392: AND
49393: IFFALSE 49407
// begin side := i ;
49395: LD_ADDR_VAR 0 3
49399: PUSH
49400: LD_VAR 0 1
49404: ST_TO_ADDR
// break ;
49405: GO 49409
// end ;
49407: GO 49360
49409: POP
49410: POP
// if not side then
49411: LD_VAR 0 3
49415: NOT
49416: IFFALSE 49420
// exit ;
49418: GO 49465
// for i := 1 to tmp do
49420: LD_ADDR_VAR 0 1
49424: PUSH
49425: DOUBLE
49426: LD_INT 1
49428: DEC
49429: ST_TO_ADDR
49430: LD_VAR 0 2
49434: PUSH
49435: FOR_TO
49436: IFFALSE 49463
// if Prob ( 60 ) then
49438: LD_INT 60
49440: PPUSH
49441: CALL_OW 13
49445: IFFALSE 49461
// SetSide ( i , side ) ;
49447: LD_VAR 0 1
49451: PPUSH
49452: LD_VAR 0 3
49456: PPUSH
49457: CALL_OW 235
49461: GO 49435
49463: POP
49464: POP
// end ;
49465: PPOPN 3
49467: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49468: LD_EXP 92
49472: PUSH
49473: LD_EXP 105
49477: AND
49478: IFFALSE 49597
49480: GO 49482
49482: DISABLE
49483: LD_INT 0
49485: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49486: LD_ADDR_VAR 0 1
49490: PUSH
49491: LD_INT 22
49493: PUSH
49494: LD_OWVAR 2
49498: PUSH
49499: EMPTY
49500: LIST
49501: LIST
49502: PUSH
49503: LD_INT 21
49505: PUSH
49506: LD_INT 1
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: LD_INT 3
49515: PUSH
49516: LD_INT 23
49518: PUSH
49519: LD_INT 0
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: LIST
49534: PPUSH
49535: CALL_OW 69
49539: PUSH
49540: FOR_IN
49541: IFFALSE 49595
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49543: LD_VAR 0 1
49547: PPUSH
49548: CALL_OW 257
49552: PUSH
49553: LD_INT 1
49555: PUSH
49556: LD_INT 2
49558: PUSH
49559: LD_INT 3
49561: PUSH
49562: LD_INT 4
49564: PUSH
49565: EMPTY
49566: LIST
49567: LIST
49568: LIST
49569: LIST
49570: IN
49571: IFFALSE 49593
// SetClass ( un , rand ( 1 , 4 ) ) ;
49573: LD_VAR 0 1
49577: PPUSH
49578: LD_INT 1
49580: PPUSH
49581: LD_INT 4
49583: PPUSH
49584: CALL_OW 12
49588: PPUSH
49589: CALL_OW 336
49593: GO 49540
49595: POP
49596: POP
// end ;
49597: PPOPN 1
49599: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49600: LD_EXP 92
49604: PUSH
49605: LD_EXP 104
49609: AND
49610: IFFALSE 49689
49612: GO 49614
49614: DISABLE
49615: LD_INT 0
49617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49618: LD_ADDR_VAR 0 1
49622: PUSH
49623: LD_INT 22
49625: PUSH
49626: LD_OWVAR 2
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: PUSH
49635: LD_INT 21
49637: PUSH
49638: LD_INT 3
49640: PUSH
49641: EMPTY
49642: LIST
49643: LIST
49644: PUSH
49645: EMPTY
49646: LIST
49647: LIST
49648: PPUSH
49649: CALL_OW 69
49653: ST_TO_ADDR
// if not tmp then
49654: LD_VAR 0 1
49658: NOT
49659: IFFALSE 49663
// exit ;
49661: GO 49689
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49663: LD_VAR 0 1
49667: PUSH
49668: LD_INT 1
49670: PPUSH
49671: LD_VAR 0 1
49675: PPUSH
49676: CALL_OW 12
49680: ARRAY
49681: PPUSH
49682: LD_INT 100
49684: PPUSH
49685: CALL_OW 234
// end ;
49689: PPOPN 1
49691: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49692: LD_EXP 92
49696: PUSH
49697: LD_EXP 106
49701: AND
49702: IFFALSE 49800
49704: GO 49706
49706: DISABLE
49707: LD_INT 0
49709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49710: LD_ADDR_VAR 0 1
49714: PUSH
49715: LD_INT 22
49717: PUSH
49718: LD_OWVAR 2
49722: PUSH
49723: EMPTY
49724: LIST
49725: LIST
49726: PUSH
49727: LD_INT 21
49729: PUSH
49730: LD_INT 1
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PPUSH
49741: CALL_OW 69
49745: ST_TO_ADDR
// if not tmp then
49746: LD_VAR 0 1
49750: NOT
49751: IFFALSE 49755
// exit ;
49753: GO 49800
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49755: LD_VAR 0 1
49759: PUSH
49760: LD_INT 1
49762: PPUSH
49763: LD_VAR 0 1
49767: PPUSH
49768: CALL_OW 12
49772: ARRAY
49773: PPUSH
49774: LD_INT 1
49776: PPUSH
49777: LD_INT 4
49779: PPUSH
49780: CALL_OW 12
49784: PPUSH
49785: LD_INT 3000
49787: PPUSH
49788: LD_INT 9000
49790: PPUSH
49791: CALL_OW 12
49795: PPUSH
49796: CALL_OW 492
// end ;
49800: PPOPN 1
49802: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49803: LD_EXP 92
49807: PUSH
49808: LD_EXP 107
49812: AND
49813: IFFALSE 49833
49815: GO 49817
49817: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49818: LD_INT 1
49820: PPUSH
49821: LD_OWVAR 2
49825: PPUSH
49826: LD_INT 0
49828: PPUSH
49829: CALL_OW 324
49833: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49834: LD_EXP 92
49838: PUSH
49839: LD_EXP 108
49843: AND
49844: IFFALSE 49927
49846: GO 49848
49848: DISABLE
49849: LD_INT 0
49851: PPUSH
49852: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49853: LD_ADDR_VAR 0 2
49857: PUSH
49858: LD_INT 22
49860: PUSH
49861: LD_OWVAR 2
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PUSH
49870: LD_INT 21
49872: PUSH
49873: LD_INT 3
49875: PUSH
49876: EMPTY
49877: LIST
49878: LIST
49879: PUSH
49880: EMPTY
49881: LIST
49882: LIST
49883: PPUSH
49884: CALL_OW 69
49888: ST_TO_ADDR
// if not tmp then
49889: LD_VAR 0 2
49893: NOT
49894: IFFALSE 49898
// exit ;
49896: GO 49927
// for i in tmp do
49898: LD_ADDR_VAR 0 1
49902: PUSH
49903: LD_VAR 0 2
49907: PUSH
49908: FOR_IN
49909: IFFALSE 49925
// SetBLevel ( i , 10 ) ;
49911: LD_VAR 0 1
49915: PPUSH
49916: LD_INT 10
49918: PPUSH
49919: CALL_OW 241
49923: GO 49908
49925: POP
49926: POP
// end ;
49927: PPOPN 2
49929: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49930: LD_EXP 92
49934: PUSH
49935: LD_EXP 109
49939: AND
49940: IFFALSE 50051
49942: GO 49944
49944: DISABLE
49945: LD_INT 0
49947: PPUSH
49948: PPUSH
49949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49950: LD_ADDR_VAR 0 3
49954: PUSH
49955: LD_INT 22
49957: PUSH
49958: LD_OWVAR 2
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 25
49969: PUSH
49970: LD_INT 1
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: PPUSH
49981: CALL_OW 69
49985: ST_TO_ADDR
// if not tmp then
49986: LD_VAR 0 3
49990: NOT
49991: IFFALSE 49995
// exit ;
49993: GO 50051
// un := tmp [ rand ( 1 , tmp ) ] ;
49995: LD_ADDR_VAR 0 2
49999: PUSH
50000: LD_VAR 0 3
50004: PUSH
50005: LD_INT 1
50007: PPUSH
50008: LD_VAR 0 3
50012: PPUSH
50013: CALL_OW 12
50017: ARRAY
50018: ST_TO_ADDR
// if Crawls ( un ) then
50019: LD_VAR 0 2
50023: PPUSH
50024: CALL_OW 318
50028: IFFALSE 50039
// ComWalk ( un ) ;
50030: LD_VAR 0 2
50034: PPUSH
50035: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50039: LD_VAR 0 2
50043: PPUSH
50044: LD_INT 5
50046: PPUSH
50047: CALL_OW 336
// end ;
50051: PPOPN 3
50053: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
50054: LD_EXP 92
50058: PUSH
50059: LD_EXP 110
50063: AND
50064: PUSH
50065: LD_OWVAR 67
50069: PUSH
50070: LD_INT 3
50072: LESS
50073: AND
50074: IFFALSE 50093
50076: GO 50078
50078: DISABLE
// Difficulty := Difficulty + 1 ;
50079: LD_ADDR_OWVAR 67
50083: PUSH
50084: LD_OWVAR 67
50088: PUSH
50089: LD_INT 1
50091: PLUS
50092: ST_TO_ADDR
50093: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50094: LD_EXP 92
50098: PUSH
50099: LD_EXP 111
50103: AND
50104: IFFALSE 50207
50106: GO 50108
50108: DISABLE
50109: LD_INT 0
50111: PPUSH
// begin for i := 1 to 5 do
50112: LD_ADDR_VAR 0 1
50116: PUSH
50117: DOUBLE
50118: LD_INT 1
50120: DEC
50121: ST_TO_ADDR
50122: LD_INT 5
50124: PUSH
50125: FOR_TO
50126: IFFALSE 50205
// begin uc_nation := nation_nature ;
50128: LD_ADDR_OWVAR 21
50132: PUSH
50133: LD_INT 0
50135: ST_TO_ADDR
// uc_side := 0 ;
50136: LD_ADDR_OWVAR 20
50140: PUSH
50141: LD_INT 0
50143: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50144: LD_ADDR_OWVAR 29
50148: PUSH
50149: LD_INT 12
50151: PUSH
50152: LD_INT 12
50154: PUSH
50155: EMPTY
50156: LIST
50157: LIST
50158: ST_TO_ADDR
// hc_agressivity := 20 ;
50159: LD_ADDR_OWVAR 35
50163: PUSH
50164: LD_INT 20
50166: ST_TO_ADDR
// hc_class := class_tiger ;
50167: LD_ADDR_OWVAR 28
50171: PUSH
50172: LD_INT 14
50174: ST_TO_ADDR
// hc_gallery :=  ;
50175: LD_ADDR_OWVAR 33
50179: PUSH
50180: LD_STRING 
50182: ST_TO_ADDR
// hc_name :=  ;
50183: LD_ADDR_OWVAR 26
50187: PUSH
50188: LD_STRING 
50190: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50191: CALL_OW 44
50195: PPUSH
50196: LD_INT 0
50198: PPUSH
50199: CALL_OW 51
// end ;
50203: GO 50125
50205: POP
50206: POP
// end ;
50207: PPOPN 1
50209: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50210: LD_EXP 92
50214: PUSH
50215: LD_EXP 112
50219: AND
50220: IFFALSE 50229
50222: GO 50224
50224: DISABLE
// StreamSibBomb ;
50225: CALL 50230 0 0
50229: END
// export function StreamSibBomb ; var i , x , y ; begin
50230: LD_INT 0
50232: PPUSH
50233: PPUSH
50234: PPUSH
50235: PPUSH
// result := false ;
50236: LD_ADDR_VAR 0 1
50240: PUSH
50241: LD_INT 0
50243: ST_TO_ADDR
// for i := 1 to 16 do
50244: LD_ADDR_VAR 0 2
50248: PUSH
50249: DOUBLE
50250: LD_INT 1
50252: DEC
50253: ST_TO_ADDR
50254: LD_INT 16
50256: PUSH
50257: FOR_TO
50258: IFFALSE 50457
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50260: LD_ADDR_VAR 0 3
50264: PUSH
50265: LD_INT 10
50267: PUSH
50268: LD_INT 20
50270: PUSH
50271: LD_INT 30
50273: PUSH
50274: LD_INT 40
50276: PUSH
50277: LD_INT 50
50279: PUSH
50280: LD_INT 60
50282: PUSH
50283: LD_INT 70
50285: PUSH
50286: LD_INT 80
50288: PUSH
50289: LD_INT 90
50291: PUSH
50292: LD_INT 100
50294: PUSH
50295: LD_INT 110
50297: PUSH
50298: LD_INT 120
50300: PUSH
50301: LD_INT 130
50303: PUSH
50304: LD_INT 140
50306: PUSH
50307: LD_INT 150
50309: PUSH
50310: EMPTY
50311: LIST
50312: LIST
50313: LIST
50314: LIST
50315: LIST
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: LIST
50321: LIST
50322: LIST
50323: LIST
50324: LIST
50325: LIST
50326: PUSH
50327: LD_INT 1
50329: PPUSH
50330: LD_INT 15
50332: PPUSH
50333: CALL_OW 12
50337: ARRAY
50338: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50339: LD_ADDR_VAR 0 4
50343: PUSH
50344: LD_INT 10
50346: PUSH
50347: LD_INT 20
50349: PUSH
50350: LD_INT 30
50352: PUSH
50353: LD_INT 40
50355: PUSH
50356: LD_INT 50
50358: PUSH
50359: LD_INT 60
50361: PUSH
50362: LD_INT 70
50364: PUSH
50365: LD_INT 80
50367: PUSH
50368: LD_INT 90
50370: PUSH
50371: LD_INT 100
50373: PUSH
50374: LD_INT 110
50376: PUSH
50377: LD_INT 120
50379: PUSH
50380: LD_INT 130
50382: PUSH
50383: LD_INT 140
50385: PUSH
50386: LD_INT 150
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: LIST
50405: PUSH
50406: LD_INT 1
50408: PPUSH
50409: LD_INT 15
50411: PPUSH
50412: CALL_OW 12
50416: ARRAY
50417: ST_TO_ADDR
// if ValidHex ( x , y ) then
50418: LD_VAR 0 3
50422: PPUSH
50423: LD_VAR 0 4
50427: PPUSH
50428: CALL_OW 488
50432: IFFALSE 50455
// begin result := [ x , y ] ;
50434: LD_ADDR_VAR 0 1
50438: PUSH
50439: LD_VAR 0 3
50443: PUSH
50444: LD_VAR 0 4
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: ST_TO_ADDR
// break ;
50453: GO 50457
// end ; end ;
50455: GO 50257
50457: POP
50458: POP
// if result then
50459: LD_VAR 0 1
50463: IFFALSE 50523
// begin ToLua ( playSibBomb() ) ;
50465: LD_STRING playSibBomb()
50467: PPUSH
50468: CALL_OW 559
// wait ( 0 0$14 ) ;
50472: LD_INT 490
50474: PPUSH
50475: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50479: LD_VAR 0 1
50483: PUSH
50484: LD_INT 1
50486: ARRAY
50487: PPUSH
50488: LD_VAR 0 1
50492: PUSH
50493: LD_INT 2
50495: ARRAY
50496: PPUSH
50497: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50501: LD_VAR 0 1
50505: PUSH
50506: LD_INT 1
50508: ARRAY
50509: PPUSH
50510: LD_VAR 0 1
50514: PUSH
50515: LD_INT 2
50517: ARRAY
50518: PPUSH
50519: CALL_OW 429
// end ; end ;
50523: LD_VAR 0 1
50527: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50528: LD_EXP 92
50532: PUSH
50533: LD_EXP 114
50537: AND
50538: IFFALSE 50550
50540: GO 50542
50542: DISABLE
// YouLost (  ) ;
50543: LD_STRING 
50545: PPUSH
50546: CALL_OW 104
50550: END
// every 0 0$1 trigger StreamModeActive and sFog do
50551: LD_EXP 92
50555: PUSH
50556: LD_EXP 113
50560: AND
50561: IFFALSE 50575
50563: GO 50565
50565: DISABLE
// FogOff ( your_side ) ;
50566: LD_OWVAR 2
50570: PPUSH
50571: CALL_OW 344
50575: END
// every 0 0$1 trigger StreamModeActive and sSun do
50576: LD_EXP 92
50580: PUSH
50581: LD_EXP 115
50585: AND
50586: IFFALSE 50614
50588: GO 50590
50590: DISABLE
// begin solar_recharge_percent := 0 ;
50591: LD_ADDR_OWVAR 79
50595: PUSH
50596: LD_INT 0
50598: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50599: LD_INT 10500
50601: PPUSH
50602: CALL_OW 67
// solar_recharge_percent := 100 ;
50606: LD_ADDR_OWVAR 79
50610: PUSH
50611: LD_INT 100
50613: ST_TO_ADDR
// end ;
50614: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50615: LD_EXP 92
50619: PUSH
50620: LD_EXP 116
50624: AND
50625: IFFALSE 50864
50627: GO 50629
50629: DISABLE
50630: LD_INT 0
50632: PPUSH
50633: PPUSH
50634: PPUSH
// begin tmp := [ ] ;
50635: LD_ADDR_VAR 0 3
50639: PUSH
50640: EMPTY
50641: ST_TO_ADDR
// for i := 1 to 6 do
50642: LD_ADDR_VAR 0 1
50646: PUSH
50647: DOUBLE
50648: LD_INT 1
50650: DEC
50651: ST_TO_ADDR
50652: LD_INT 6
50654: PUSH
50655: FOR_TO
50656: IFFALSE 50761
// begin uc_nation := nation_nature ;
50658: LD_ADDR_OWVAR 21
50662: PUSH
50663: LD_INT 0
50665: ST_TO_ADDR
// uc_side := 0 ;
50666: LD_ADDR_OWVAR 20
50670: PUSH
50671: LD_INT 0
50673: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50674: LD_ADDR_OWVAR 29
50678: PUSH
50679: LD_INT 12
50681: PUSH
50682: LD_INT 12
50684: PUSH
50685: EMPTY
50686: LIST
50687: LIST
50688: ST_TO_ADDR
// hc_agressivity := 20 ;
50689: LD_ADDR_OWVAR 35
50693: PUSH
50694: LD_INT 20
50696: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50697: LD_ADDR_OWVAR 28
50701: PUSH
50702: LD_INT 17
50704: ST_TO_ADDR
// hc_gallery :=  ;
50705: LD_ADDR_OWVAR 33
50709: PUSH
50710: LD_STRING 
50712: ST_TO_ADDR
// hc_name :=  ;
50713: LD_ADDR_OWVAR 26
50717: PUSH
50718: LD_STRING 
50720: ST_TO_ADDR
// un := CreateHuman ;
50721: LD_ADDR_VAR 0 2
50725: PUSH
50726: CALL_OW 44
50730: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50731: LD_VAR 0 2
50735: PPUSH
50736: LD_INT 1
50738: PPUSH
50739: CALL_OW 51
// tmp := tmp ^ un ;
50743: LD_ADDR_VAR 0 3
50747: PUSH
50748: LD_VAR 0 3
50752: PUSH
50753: LD_VAR 0 2
50757: ADD
50758: ST_TO_ADDR
// end ;
50759: GO 50655
50761: POP
50762: POP
// repeat wait ( 0 0$1 ) ;
50763: LD_INT 35
50765: PPUSH
50766: CALL_OW 67
// for un in tmp do
50770: LD_ADDR_VAR 0 2
50774: PUSH
50775: LD_VAR 0 3
50779: PUSH
50780: FOR_IN
50781: IFFALSE 50855
// begin if IsDead ( un ) then
50783: LD_VAR 0 2
50787: PPUSH
50788: CALL_OW 301
50792: IFFALSE 50812
// begin tmp := tmp diff un ;
50794: LD_ADDR_VAR 0 3
50798: PUSH
50799: LD_VAR 0 3
50803: PUSH
50804: LD_VAR 0 2
50808: DIFF
50809: ST_TO_ADDR
// continue ;
50810: GO 50780
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50812: LD_VAR 0 2
50816: PPUSH
50817: LD_INT 3
50819: PUSH
50820: LD_INT 22
50822: PUSH
50823: LD_INT 0
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: PUSH
50830: EMPTY
50831: LIST
50832: LIST
50833: PPUSH
50834: CALL_OW 69
50838: PPUSH
50839: LD_VAR 0 2
50843: PPUSH
50844: CALL_OW 74
50848: PPUSH
50849: CALL_OW 115
// end ;
50853: GO 50780
50855: POP
50856: POP
// until not tmp ;
50857: LD_VAR 0 3
50861: NOT
50862: IFFALSE 50763
// end ;
50864: PPOPN 3
50866: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50867: LD_EXP 92
50871: PUSH
50872: LD_EXP 117
50876: AND
50877: IFFALSE 50931
50879: GO 50881
50881: DISABLE
// begin ToLua ( displayTroll(); ) ;
50882: LD_STRING displayTroll();
50884: PPUSH
50885: CALL_OW 559
// wait ( 3 3$00 ) ;
50889: LD_INT 6300
50891: PPUSH
50892: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50896: LD_STRING hideTroll();
50898: PPUSH
50899: CALL_OW 559
// wait ( 1 1$00 ) ;
50903: LD_INT 2100
50905: PPUSH
50906: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50910: LD_STRING displayTroll();
50912: PPUSH
50913: CALL_OW 559
// wait ( 1 1$00 ) ;
50917: LD_INT 2100
50919: PPUSH
50920: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50924: LD_STRING hideTroll();
50926: PPUSH
50927: CALL_OW 559
// end ;
50931: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50932: LD_EXP 92
50936: PUSH
50937: LD_EXP 118
50941: AND
50942: IFFALSE 51005
50944: GO 50946
50946: DISABLE
50947: LD_INT 0
50949: PPUSH
// begin p := 0 ;
50950: LD_ADDR_VAR 0 1
50954: PUSH
50955: LD_INT 0
50957: ST_TO_ADDR
// repeat game_speed := 1 ;
50958: LD_ADDR_OWVAR 65
50962: PUSH
50963: LD_INT 1
50965: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50966: LD_INT 35
50968: PPUSH
50969: CALL_OW 67
// p := p + 1 ;
50973: LD_ADDR_VAR 0 1
50977: PUSH
50978: LD_VAR 0 1
50982: PUSH
50983: LD_INT 1
50985: PLUS
50986: ST_TO_ADDR
// until p >= 60 ;
50987: LD_VAR 0 1
50991: PUSH
50992: LD_INT 60
50994: GREATEREQUAL
50995: IFFALSE 50958
// game_speed := 4 ;
50997: LD_ADDR_OWVAR 65
51001: PUSH
51002: LD_INT 4
51004: ST_TO_ADDR
// end ;
51005: PPOPN 1
51007: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51008: LD_EXP 92
51012: PUSH
51013: LD_EXP 119
51017: AND
51018: IFFALSE 51164
51020: GO 51022
51022: DISABLE
51023: LD_INT 0
51025: PPUSH
51026: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51027: LD_ADDR_VAR 0 1
51031: PUSH
51032: LD_INT 22
51034: PUSH
51035: LD_OWVAR 2
51039: PUSH
51040: EMPTY
51041: LIST
51042: LIST
51043: PUSH
51044: LD_INT 2
51046: PUSH
51047: LD_INT 30
51049: PUSH
51050: LD_INT 0
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: PUSH
51057: LD_INT 30
51059: PUSH
51060: LD_INT 1
51062: PUSH
51063: EMPTY
51064: LIST
51065: LIST
51066: PUSH
51067: EMPTY
51068: LIST
51069: LIST
51070: LIST
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: PPUSH
51076: CALL_OW 69
51080: ST_TO_ADDR
// if not depot then
51081: LD_VAR 0 1
51085: NOT
51086: IFFALSE 51090
// exit ;
51088: GO 51164
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51090: LD_ADDR_VAR 0 2
51094: PUSH
51095: LD_VAR 0 1
51099: PUSH
51100: LD_INT 1
51102: PPUSH
51103: LD_VAR 0 1
51107: PPUSH
51108: CALL_OW 12
51112: ARRAY
51113: PPUSH
51114: CALL_OW 274
51118: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51119: LD_VAR 0 2
51123: PPUSH
51124: LD_INT 1
51126: PPUSH
51127: LD_INT 0
51129: PPUSH
51130: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51134: LD_VAR 0 2
51138: PPUSH
51139: LD_INT 2
51141: PPUSH
51142: LD_INT 0
51144: PPUSH
51145: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51149: LD_VAR 0 2
51153: PPUSH
51154: LD_INT 3
51156: PPUSH
51157: LD_INT 0
51159: PPUSH
51160: CALL_OW 277
// end ;
51164: PPOPN 2
51166: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51167: LD_EXP 92
51171: PUSH
51172: LD_EXP 120
51176: AND
51177: IFFALSE 51274
51179: GO 51181
51181: DISABLE
51182: LD_INT 0
51184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51185: LD_ADDR_VAR 0 1
51189: PUSH
51190: LD_INT 22
51192: PUSH
51193: LD_OWVAR 2
51197: PUSH
51198: EMPTY
51199: LIST
51200: LIST
51201: PUSH
51202: LD_INT 21
51204: PUSH
51205: LD_INT 1
51207: PUSH
51208: EMPTY
51209: LIST
51210: LIST
51211: PUSH
51212: LD_INT 3
51214: PUSH
51215: LD_INT 23
51217: PUSH
51218: LD_INT 0
51220: PUSH
51221: EMPTY
51222: LIST
51223: LIST
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: LIST
51233: PPUSH
51234: CALL_OW 69
51238: ST_TO_ADDR
// if not tmp then
51239: LD_VAR 0 1
51243: NOT
51244: IFFALSE 51248
// exit ;
51246: GO 51274
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51248: LD_VAR 0 1
51252: PUSH
51253: LD_INT 1
51255: PPUSH
51256: LD_VAR 0 1
51260: PPUSH
51261: CALL_OW 12
51265: ARRAY
51266: PPUSH
51267: LD_INT 200
51269: PPUSH
51270: CALL_OW 234
// end ;
51274: PPOPN 1
51276: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51277: LD_EXP 92
51281: PUSH
51282: LD_EXP 121
51286: AND
51287: IFFALSE 51366
51289: GO 51291
51291: DISABLE
51292: LD_INT 0
51294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51295: LD_ADDR_VAR 0 1
51299: PUSH
51300: LD_INT 22
51302: PUSH
51303: LD_OWVAR 2
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: PUSH
51312: LD_INT 21
51314: PUSH
51315: LD_INT 2
51317: PUSH
51318: EMPTY
51319: LIST
51320: LIST
51321: PUSH
51322: EMPTY
51323: LIST
51324: LIST
51325: PPUSH
51326: CALL_OW 69
51330: ST_TO_ADDR
// if not tmp then
51331: LD_VAR 0 1
51335: NOT
51336: IFFALSE 51340
// exit ;
51338: GO 51366
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51340: LD_VAR 0 1
51344: PUSH
51345: LD_INT 1
51347: PPUSH
51348: LD_VAR 0 1
51352: PPUSH
51353: CALL_OW 12
51357: ARRAY
51358: PPUSH
51359: LD_INT 60
51361: PPUSH
51362: CALL_OW 234
// end ;
51366: PPOPN 1
51368: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51369: LD_EXP 92
51373: PUSH
51374: LD_EXP 122
51378: AND
51379: IFFALSE 51478
51381: GO 51383
51383: DISABLE
51384: LD_INT 0
51386: PPUSH
51387: PPUSH
// begin enable ;
51388: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51389: LD_ADDR_VAR 0 1
51393: PUSH
51394: LD_INT 22
51396: PUSH
51397: LD_OWVAR 2
51401: PUSH
51402: EMPTY
51403: LIST
51404: LIST
51405: PUSH
51406: LD_INT 61
51408: PUSH
51409: EMPTY
51410: LIST
51411: PUSH
51412: LD_INT 33
51414: PUSH
51415: LD_INT 2
51417: PUSH
51418: EMPTY
51419: LIST
51420: LIST
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: LIST
51426: PPUSH
51427: CALL_OW 69
51431: ST_TO_ADDR
// if not tmp then
51432: LD_VAR 0 1
51436: NOT
51437: IFFALSE 51441
// exit ;
51439: GO 51478
// for i in tmp do
51441: LD_ADDR_VAR 0 2
51445: PUSH
51446: LD_VAR 0 1
51450: PUSH
51451: FOR_IN
51452: IFFALSE 51476
// if IsControledBy ( i ) then
51454: LD_VAR 0 2
51458: PPUSH
51459: CALL_OW 312
51463: IFFALSE 51474
// ComUnlink ( i ) ;
51465: LD_VAR 0 2
51469: PPUSH
51470: CALL_OW 136
51474: GO 51451
51476: POP
51477: POP
// end ;
51478: PPOPN 2
51480: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51481: LD_EXP 92
51485: PUSH
51486: LD_EXP 123
51490: AND
51491: IFFALSE 51631
51493: GO 51495
51495: DISABLE
51496: LD_INT 0
51498: PPUSH
51499: PPUSH
// begin ToLua ( displayPowell(); ) ;
51500: LD_STRING displayPowell();
51502: PPUSH
51503: CALL_OW 559
// uc_side := 0 ;
51507: LD_ADDR_OWVAR 20
51511: PUSH
51512: LD_INT 0
51514: ST_TO_ADDR
// uc_nation := 2 ;
51515: LD_ADDR_OWVAR 21
51519: PUSH
51520: LD_INT 2
51522: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51523: LD_ADDR_OWVAR 37
51527: PUSH
51528: LD_INT 14
51530: ST_TO_ADDR
// vc_engine := engine_siberite ;
51531: LD_ADDR_OWVAR 39
51535: PUSH
51536: LD_INT 3
51538: ST_TO_ADDR
// vc_control := control_apeman ;
51539: LD_ADDR_OWVAR 38
51543: PUSH
51544: LD_INT 5
51546: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51547: LD_ADDR_OWVAR 40
51551: PUSH
51552: LD_INT 29
51554: ST_TO_ADDR
// un := CreateVehicle ;
51555: LD_ADDR_VAR 0 2
51559: PUSH
51560: CALL_OW 45
51564: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51565: LD_VAR 0 2
51569: PPUSH
51570: LD_INT 1
51572: PPUSH
51573: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51577: LD_INT 35
51579: PPUSH
51580: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51584: LD_VAR 0 2
51588: PPUSH
51589: LD_INT 22
51591: PUSH
51592: LD_OWVAR 2
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: PPUSH
51601: CALL_OW 69
51605: PPUSH
51606: LD_VAR 0 2
51610: PPUSH
51611: CALL_OW 74
51615: PPUSH
51616: CALL_OW 115
// until IsDead ( un ) ;
51620: LD_VAR 0 2
51624: PPUSH
51625: CALL_OW 301
51629: IFFALSE 51577
// end ;
51631: PPOPN 2
51633: END
// every 0 0$1 trigger StreamModeActive and sStu do
51634: LD_EXP 92
51638: PUSH
51639: LD_EXP 131
51643: AND
51644: IFFALSE 51660
51646: GO 51648
51648: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51649: LD_STRING displayStucuk();
51651: PPUSH
51652: CALL_OW 559
// ResetFog ;
51656: CALL_OW 335
// end ;
51660: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51661: LD_EXP 92
51665: PUSH
51666: LD_EXP 124
51670: AND
51671: IFFALSE 51812
51673: GO 51675
51675: DISABLE
51676: LD_INT 0
51678: PPUSH
51679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51680: LD_ADDR_VAR 0 2
51684: PUSH
51685: LD_INT 22
51687: PUSH
51688: LD_OWVAR 2
51692: PUSH
51693: EMPTY
51694: LIST
51695: LIST
51696: PUSH
51697: LD_INT 21
51699: PUSH
51700: LD_INT 1
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: PUSH
51707: EMPTY
51708: LIST
51709: LIST
51710: PPUSH
51711: CALL_OW 69
51715: ST_TO_ADDR
// if not tmp then
51716: LD_VAR 0 2
51720: NOT
51721: IFFALSE 51725
// exit ;
51723: GO 51812
// un := tmp [ rand ( 1 , tmp ) ] ;
51725: LD_ADDR_VAR 0 1
51729: PUSH
51730: LD_VAR 0 2
51734: PUSH
51735: LD_INT 1
51737: PPUSH
51738: LD_VAR 0 2
51742: PPUSH
51743: CALL_OW 12
51747: ARRAY
51748: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51749: LD_VAR 0 1
51753: PPUSH
51754: LD_INT 0
51756: PPUSH
51757: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51761: LD_VAR 0 1
51765: PPUSH
51766: LD_OWVAR 3
51770: PUSH
51771: LD_VAR 0 1
51775: DIFF
51776: PPUSH
51777: LD_VAR 0 1
51781: PPUSH
51782: CALL_OW 74
51786: PPUSH
51787: CALL_OW 115
// wait ( 0 0$20 ) ;
51791: LD_INT 700
51793: PPUSH
51794: CALL_OW 67
// SetSide ( un , your_side ) ;
51798: LD_VAR 0 1
51802: PPUSH
51803: LD_OWVAR 2
51807: PPUSH
51808: CALL_OW 235
// end ;
51812: PPOPN 2
51814: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51815: LD_EXP 92
51819: PUSH
51820: LD_EXP 125
51824: AND
51825: IFFALSE 51931
51827: GO 51829
51829: DISABLE
51830: LD_INT 0
51832: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51833: LD_ADDR_VAR 0 1
51837: PUSH
51838: LD_INT 22
51840: PUSH
51841: LD_OWVAR 2
51845: PUSH
51846: EMPTY
51847: LIST
51848: LIST
51849: PUSH
51850: LD_INT 2
51852: PUSH
51853: LD_INT 30
51855: PUSH
51856: LD_INT 0
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PUSH
51863: LD_INT 30
51865: PUSH
51866: LD_INT 1
51868: PUSH
51869: EMPTY
51870: LIST
51871: LIST
51872: PUSH
51873: EMPTY
51874: LIST
51875: LIST
51876: LIST
51877: PUSH
51878: EMPTY
51879: LIST
51880: LIST
51881: PPUSH
51882: CALL_OW 69
51886: ST_TO_ADDR
// if not depot then
51887: LD_VAR 0 1
51891: NOT
51892: IFFALSE 51896
// exit ;
51894: GO 51931
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51896: LD_VAR 0 1
51900: PUSH
51901: LD_INT 1
51903: ARRAY
51904: PPUSH
51905: CALL_OW 250
51909: PPUSH
51910: LD_VAR 0 1
51914: PUSH
51915: LD_INT 1
51917: ARRAY
51918: PPUSH
51919: CALL_OW 251
51923: PPUSH
51924: LD_INT 70
51926: PPUSH
51927: CALL_OW 495
// end ;
51931: PPOPN 1
51933: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51934: LD_EXP 92
51938: PUSH
51939: LD_EXP 126
51943: AND
51944: IFFALSE 52155
51946: GO 51948
51948: DISABLE
51949: LD_INT 0
51951: PPUSH
51952: PPUSH
51953: PPUSH
51954: PPUSH
51955: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51956: LD_ADDR_VAR 0 5
51960: PUSH
51961: LD_INT 22
51963: PUSH
51964: LD_OWVAR 2
51968: PUSH
51969: EMPTY
51970: LIST
51971: LIST
51972: PUSH
51973: LD_INT 21
51975: PUSH
51976: LD_INT 1
51978: PUSH
51979: EMPTY
51980: LIST
51981: LIST
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PPUSH
51987: CALL_OW 69
51991: ST_TO_ADDR
// if not tmp then
51992: LD_VAR 0 5
51996: NOT
51997: IFFALSE 52001
// exit ;
51999: GO 52155
// for i in tmp do
52001: LD_ADDR_VAR 0 1
52005: PUSH
52006: LD_VAR 0 5
52010: PUSH
52011: FOR_IN
52012: IFFALSE 52153
// begin d := rand ( 0 , 5 ) ;
52014: LD_ADDR_VAR 0 4
52018: PUSH
52019: LD_INT 0
52021: PPUSH
52022: LD_INT 5
52024: PPUSH
52025: CALL_OW 12
52029: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52030: LD_ADDR_VAR 0 2
52034: PUSH
52035: LD_VAR 0 1
52039: PPUSH
52040: CALL_OW 250
52044: PPUSH
52045: LD_VAR 0 4
52049: PPUSH
52050: LD_INT 3
52052: PPUSH
52053: LD_INT 12
52055: PPUSH
52056: CALL_OW 12
52060: PPUSH
52061: CALL_OW 272
52065: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52066: LD_ADDR_VAR 0 3
52070: PUSH
52071: LD_VAR 0 1
52075: PPUSH
52076: CALL_OW 251
52080: PPUSH
52081: LD_VAR 0 4
52085: PPUSH
52086: LD_INT 3
52088: PPUSH
52089: LD_INT 12
52091: PPUSH
52092: CALL_OW 12
52096: PPUSH
52097: CALL_OW 273
52101: ST_TO_ADDR
// if ValidHex ( x , y ) then
52102: LD_VAR 0 2
52106: PPUSH
52107: LD_VAR 0 3
52111: PPUSH
52112: CALL_OW 488
52116: IFFALSE 52151
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52118: LD_VAR 0 1
52122: PPUSH
52123: LD_VAR 0 2
52127: PPUSH
52128: LD_VAR 0 3
52132: PPUSH
52133: LD_INT 3
52135: PPUSH
52136: LD_INT 6
52138: PPUSH
52139: CALL_OW 12
52143: PPUSH
52144: LD_INT 1
52146: PPUSH
52147: CALL_OW 483
// end ;
52151: GO 52011
52153: POP
52154: POP
// end ;
52155: PPOPN 5
52157: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52158: LD_EXP 92
52162: PUSH
52163: LD_EXP 127
52167: AND
52168: IFFALSE 52262
52170: GO 52172
52172: DISABLE
52173: LD_INT 0
52175: PPUSH
52176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52177: LD_ADDR_VAR 0 2
52181: PUSH
52182: LD_INT 22
52184: PUSH
52185: LD_OWVAR 2
52189: PUSH
52190: EMPTY
52191: LIST
52192: LIST
52193: PUSH
52194: LD_INT 32
52196: PUSH
52197: LD_INT 1
52199: PUSH
52200: EMPTY
52201: LIST
52202: LIST
52203: PUSH
52204: LD_INT 21
52206: PUSH
52207: LD_INT 2
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: LIST
52218: PPUSH
52219: CALL_OW 69
52223: ST_TO_ADDR
// if not tmp then
52224: LD_VAR 0 2
52228: NOT
52229: IFFALSE 52233
// exit ;
52231: GO 52262
// for i in tmp do
52233: LD_ADDR_VAR 0 1
52237: PUSH
52238: LD_VAR 0 2
52242: PUSH
52243: FOR_IN
52244: IFFALSE 52260
// SetFuel ( i , 0 ) ;
52246: LD_VAR 0 1
52250: PPUSH
52251: LD_INT 0
52253: PPUSH
52254: CALL_OW 240
52258: GO 52243
52260: POP
52261: POP
// end ;
52262: PPOPN 2
52264: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52265: LD_EXP 92
52269: PUSH
52270: LD_EXP 128
52274: AND
52275: IFFALSE 52341
52277: GO 52279
52279: DISABLE
52280: LD_INT 0
52282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52283: LD_ADDR_VAR 0 1
52287: PUSH
52288: LD_INT 22
52290: PUSH
52291: LD_OWVAR 2
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_INT 30
52302: PUSH
52303: LD_INT 29
52305: PUSH
52306: EMPTY
52307: LIST
52308: LIST
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: PPUSH
52314: CALL_OW 69
52318: ST_TO_ADDR
// if not tmp then
52319: LD_VAR 0 1
52323: NOT
52324: IFFALSE 52328
// exit ;
52326: GO 52341
// DestroyUnit ( tmp [ 1 ] ) ;
52328: LD_VAR 0 1
52332: PUSH
52333: LD_INT 1
52335: ARRAY
52336: PPUSH
52337: CALL_OW 65
// end ;
52341: PPOPN 1
52343: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52344: LD_EXP 92
52348: PUSH
52349: LD_EXP 130
52353: AND
52354: IFFALSE 52483
52356: GO 52358
52358: DISABLE
52359: LD_INT 0
52361: PPUSH
// begin uc_side := 0 ;
52362: LD_ADDR_OWVAR 20
52366: PUSH
52367: LD_INT 0
52369: ST_TO_ADDR
// uc_nation := nation_arabian ;
52370: LD_ADDR_OWVAR 21
52374: PUSH
52375: LD_INT 2
52377: ST_TO_ADDR
// hc_gallery :=  ;
52378: LD_ADDR_OWVAR 33
52382: PUSH
52383: LD_STRING 
52385: ST_TO_ADDR
// hc_name :=  ;
52386: LD_ADDR_OWVAR 26
52390: PUSH
52391: LD_STRING 
52393: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52394: LD_INT 1
52396: PPUSH
52397: LD_INT 11
52399: PPUSH
52400: LD_INT 10
52402: PPUSH
52403: CALL_OW 380
// un := CreateHuman ;
52407: LD_ADDR_VAR 0 1
52411: PUSH
52412: CALL_OW 44
52416: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52417: LD_VAR 0 1
52421: PPUSH
52422: LD_INT 1
52424: PPUSH
52425: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52429: LD_INT 35
52431: PPUSH
52432: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52436: LD_VAR 0 1
52440: PPUSH
52441: LD_INT 22
52443: PUSH
52444: LD_OWVAR 2
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: PPUSH
52453: CALL_OW 69
52457: PPUSH
52458: LD_VAR 0 1
52462: PPUSH
52463: CALL_OW 74
52467: PPUSH
52468: CALL_OW 115
// until IsDead ( un ) ;
52472: LD_VAR 0 1
52476: PPUSH
52477: CALL_OW 301
52481: IFFALSE 52429
// end ;
52483: PPOPN 1
52485: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52486: LD_EXP 92
52490: PUSH
52491: LD_EXP 132
52495: AND
52496: IFFALSE 52508
52498: GO 52500
52500: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52501: LD_STRING earthquake(getX(game), 0, 32)
52503: PPUSH
52504: CALL_OW 559
52508: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52509: LD_EXP 92
52513: PUSH
52514: LD_EXP 133
52518: AND
52519: IFFALSE 52610
52521: GO 52523
52523: DISABLE
52524: LD_INT 0
52526: PPUSH
// begin enable ;
52527: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52528: LD_ADDR_VAR 0 1
52532: PUSH
52533: LD_INT 22
52535: PUSH
52536: LD_OWVAR 2
52540: PUSH
52541: EMPTY
52542: LIST
52543: LIST
52544: PUSH
52545: LD_INT 21
52547: PUSH
52548: LD_INT 2
52550: PUSH
52551: EMPTY
52552: LIST
52553: LIST
52554: PUSH
52555: LD_INT 33
52557: PUSH
52558: LD_INT 3
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: PPUSH
52570: CALL_OW 69
52574: ST_TO_ADDR
// if not tmp then
52575: LD_VAR 0 1
52579: NOT
52580: IFFALSE 52584
// exit ;
52582: GO 52610
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52584: LD_VAR 0 1
52588: PUSH
52589: LD_INT 1
52591: PPUSH
52592: LD_VAR 0 1
52596: PPUSH
52597: CALL_OW 12
52601: ARRAY
52602: PPUSH
52603: LD_INT 1
52605: PPUSH
52606: CALL_OW 234
// end ;
52610: PPOPN 1
52612: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52613: LD_EXP 92
52617: PUSH
52618: LD_EXP 134
52622: AND
52623: IFFALSE 52764
52625: GO 52627
52627: DISABLE
52628: LD_INT 0
52630: PPUSH
52631: PPUSH
52632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52633: LD_ADDR_VAR 0 3
52637: PUSH
52638: LD_INT 22
52640: PUSH
52641: LD_OWVAR 2
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: PUSH
52650: LD_INT 25
52652: PUSH
52653: LD_INT 1
52655: PUSH
52656: EMPTY
52657: LIST
52658: LIST
52659: PUSH
52660: EMPTY
52661: LIST
52662: LIST
52663: PPUSH
52664: CALL_OW 69
52668: ST_TO_ADDR
// if not tmp then
52669: LD_VAR 0 3
52673: NOT
52674: IFFALSE 52678
// exit ;
52676: GO 52764
// un := tmp [ rand ( 1 , tmp ) ] ;
52678: LD_ADDR_VAR 0 2
52682: PUSH
52683: LD_VAR 0 3
52687: PUSH
52688: LD_INT 1
52690: PPUSH
52691: LD_VAR 0 3
52695: PPUSH
52696: CALL_OW 12
52700: ARRAY
52701: ST_TO_ADDR
// if Crawls ( un ) then
52702: LD_VAR 0 2
52706: PPUSH
52707: CALL_OW 318
52711: IFFALSE 52722
// ComWalk ( un ) ;
52713: LD_VAR 0 2
52717: PPUSH
52718: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52722: LD_VAR 0 2
52726: PPUSH
52727: LD_INT 9
52729: PPUSH
52730: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52734: LD_INT 28
52736: PPUSH
52737: LD_OWVAR 2
52741: PPUSH
52742: LD_INT 2
52744: PPUSH
52745: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52749: LD_INT 29
52751: PPUSH
52752: LD_OWVAR 2
52756: PPUSH
52757: LD_INT 2
52759: PPUSH
52760: CALL_OW 322
// end ;
52764: PPOPN 3
52766: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52767: LD_EXP 92
52771: PUSH
52772: LD_EXP 135
52776: AND
52777: IFFALSE 52888
52779: GO 52781
52781: DISABLE
52782: LD_INT 0
52784: PPUSH
52785: PPUSH
52786: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52787: LD_ADDR_VAR 0 3
52791: PUSH
52792: LD_INT 22
52794: PUSH
52795: LD_OWVAR 2
52799: PUSH
52800: EMPTY
52801: LIST
52802: LIST
52803: PUSH
52804: LD_INT 25
52806: PUSH
52807: LD_INT 1
52809: PUSH
52810: EMPTY
52811: LIST
52812: LIST
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: PPUSH
52818: CALL_OW 69
52822: ST_TO_ADDR
// if not tmp then
52823: LD_VAR 0 3
52827: NOT
52828: IFFALSE 52832
// exit ;
52830: GO 52888
// un := tmp [ rand ( 1 , tmp ) ] ;
52832: LD_ADDR_VAR 0 2
52836: PUSH
52837: LD_VAR 0 3
52841: PUSH
52842: LD_INT 1
52844: PPUSH
52845: LD_VAR 0 3
52849: PPUSH
52850: CALL_OW 12
52854: ARRAY
52855: ST_TO_ADDR
// if Crawls ( un ) then
52856: LD_VAR 0 2
52860: PPUSH
52861: CALL_OW 318
52865: IFFALSE 52876
// ComWalk ( un ) ;
52867: LD_VAR 0 2
52871: PPUSH
52872: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52876: LD_VAR 0 2
52880: PPUSH
52881: LD_INT 8
52883: PPUSH
52884: CALL_OW 336
// end ;
52888: PPOPN 3
52890: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52891: LD_EXP 92
52895: PUSH
52896: LD_EXP 136
52900: AND
52901: IFFALSE 53045
52903: GO 52905
52905: DISABLE
52906: LD_INT 0
52908: PPUSH
52909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52910: LD_ADDR_VAR 0 2
52914: PUSH
52915: LD_INT 22
52917: PUSH
52918: LD_OWVAR 2
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: PUSH
52927: LD_INT 21
52929: PUSH
52930: LD_INT 2
52932: PUSH
52933: EMPTY
52934: LIST
52935: LIST
52936: PUSH
52937: LD_INT 2
52939: PUSH
52940: LD_INT 34
52942: PUSH
52943: LD_INT 12
52945: PUSH
52946: EMPTY
52947: LIST
52948: LIST
52949: PUSH
52950: LD_INT 34
52952: PUSH
52953: LD_INT 51
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: LD_INT 34
52962: PUSH
52963: LD_INT 32
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: LIST
52974: LIST
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: LIST
52980: PPUSH
52981: CALL_OW 69
52985: ST_TO_ADDR
// if not tmp then
52986: LD_VAR 0 2
52990: NOT
52991: IFFALSE 52995
// exit ;
52993: GO 53045
// for i in tmp do
52995: LD_ADDR_VAR 0 1
52999: PUSH
53000: LD_VAR 0 2
53004: PUSH
53005: FOR_IN
53006: IFFALSE 53043
// if GetCargo ( i , mat_artifact ) = 0 then
53008: LD_VAR 0 1
53012: PPUSH
53013: LD_INT 4
53015: PPUSH
53016: CALL_OW 289
53020: PUSH
53021: LD_INT 0
53023: EQUAL
53024: IFFALSE 53041
// SetCargo ( i , mat_siberit , 100 ) ;
53026: LD_VAR 0 1
53030: PPUSH
53031: LD_INT 3
53033: PPUSH
53034: LD_INT 100
53036: PPUSH
53037: CALL_OW 290
53041: GO 53005
53043: POP
53044: POP
// end ;
53045: PPOPN 2
53047: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53048: LD_EXP 92
53052: PUSH
53053: LD_EXP 137
53057: AND
53058: IFFALSE 53241
53060: GO 53062
53062: DISABLE
53063: LD_INT 0
53065: PPUSH
53066: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53067: LD_ADDR_VAR 0 2
53071: PUSH
53072: LD_INT 22
53074: PUSH
53075: LD_OWVAR 2
53079: PUSH
53080: EMPTY
53081: LIST
53082: LIST
53083: PPUSH
53084: CALL_OW 69
53088: ST_TO_ADDR
// if not tmp then
53089: LD_VAR 0 2
53093: NOT
53094: IFFALSE 53098
// exit ;
53096: GO 53241
// for i := 1 to 2 do
53098: LD_ADDR_VAR 0 1
53102: PUSH
53103: DOUBLE
53104: LD_INT 1
53106: DEC
53107: ST_TO_ADDR
53108: LD_INT 2
53110: PUSH
53111: FOR_TO
53112: IFFALSE 53239
// begin uc_side := your_side ;
53114: LD_ADDR_OWVAR 20
53118: PUSH
53119: LD_OWVAR 2
53123: ST_TO_ADDR
// uc_nation := nation_american ;
53124: LD_ADDR_OWVAR 21
53128: PUSH
53129: LD_INT 1
53131: ST_TO_ADDR
// vc_chassis := us_morphling ;
53132: LD_ADDR_OWVAR 37
53136: PUSH
53137: LD_INT 5
53139: ST_TO_ADDR
// vc_engine := engine_siberite ;
53140: LD_ADDR_OWVAR 39
53144: PUSH
53145: LD_INT 3
53147: ST_TO_ADDR
// vc_control := control_computer ;
53148: LD_ADDR_OWVAR 38
53152: PUSH
53153: LD_INT 3
53155: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53156: LD_ADDR_OWVAR 40
53160: PUSH
53161: LD_INT 10
53163: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53164: LD_VAR 0 2
53168: PUSH
53169: LD_INT 1
53171: ARRAY
53172: PPUSH
53173: CALL_OW 310
53177: NOT
53178: IFFALSE 53225
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53180: CALL_OW 45
53184: PPUSH
53185: LD_VAR 0 2
53189: PUSH
53190: LD_INT 1
53192: ARRAY
53193: PPUSH
53194: CALL_OW 250
53198: PPUSH
53199: LD_VAR 0 2
53203: PUSH
53204: LD_INT 1
53206: ARRAY
53207: PPUSH
53208: CALL_OW 251
53212: PPUSH
53213: LD_INT 12
53215: PPUSH
53216: LD_INT 1
53218: PPUSH
53219: CALL_OW 50
53223: GO 53237
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53225: CALL_OW 45
53229: PPUSH
53230: LD_INT 1
53232: PPUSH
53233: CALL_OW 51
// end ;
53237: GO 53111
53239: POP
53240: POP
// end ;
53241: PPOPN 2
53243: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53244: LD_EXP 92
53248: PUSH
53249: LD_EXP 138
53253: AND
53254: IFFALSE 53476
53256: GO 53258
53258: DISABLE
53259: LD_INT 0
53261: PPUSH
53262: PPUSH
53263: PPUSH
53264: PPUSH
53265: PPUSH
53266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53267: LD_ADDR_VAR 0 6
53271: PUSH
53272: LD_INT 22
53274: PUSH
53275: LD_OWVAR 2
53279: PUSH
53280: EMPTY
53281: LIST
53282: LIST
53283: PUSH
53284: LD_INT 21
53286: PUSH
53287: LD_INT 1
53289: PUSH
53290: EMPTY
53291: LIST
53292: LIST
53293: PUSH
53294: LD_INT 3
53296: PUSH
53297: LD_INT 23
53299: PUSH
53300: LD_INT 0
53302: PUSH
53303: EMPTY
53304: LIST
53305: LIST
53306: PUSH
53307: EMPTY
53308: LIST
53309: LIST
53310: PUSH
53311: EMPTY
53312: LIST
53313: LIST
53314: LIST
53315: PPUSH
53316: CALL_OW 69
53320: ST_TO_ADDR
// if not tmp then
53321: LD_VAR 0 6
53325: NOT
53326: IFFALSE 53330
// exit ;
53328: GO 53476
// s1 := rand ( 1 , 4 ) ;
53330: LD_ADDR_VAR 0 2
53334: PUSH
53335: LD_INT 1
53337: PPUSH
53338: LD_INT 4
53340: PPUSH
53341: CALL_OW 12
53345: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53346: LD_ADDR_VAR 0 4
53350: PUSH
53351: LD_VAR 0 6
53355: PUSH
53356: LD_INT 1
53358: ARRAY
53359: PPUSH
53360: LD_VAR 0 2
53364: PPUSH
53365: CALL_OW 259
53369: ST_TO_ADDR
// if s1 = 1 then
53370: LD_VAR 0 2
53374: PUSH
53375: LD_INT 1
53377: EQUAL
53378: IFFALSE 53398
// s2 := rand ( 2 , 4 ) else
53380: LD_ADDR_VAR 0 3
53384: PUSH
53385: LD_INT 2
53387: PPUSH
53388: LD_INT 4
53390: PPUSH
53391: CALL_OW 12
53395: ST_TO_ADDR
53396: GO 53406
// s2 := 1 ;
53398: LD_ADDR_VAR 0 3
53402: PUSH
53403: LD_INT 1
53405: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53406: LD_ADDR_VAR 0 5
53410: PUSH
53411: LD_VAR 0 6
53415: PUSH
53416: LD_INT 1
53418: ARRAY
53419: PPUSH
53420: LD_VAR 0 3
53424: PPUSH
53425: CALL_OW 259
53429: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53430: LD_VAR 0 6
53434: PUSH
53435: LD_INT 1
53437: ARRAY
53438: PPUSH
53439: LD_VAR 0 2
53443: PPUSH
53444: LD_VAR 0 5
53448: PPUSH
53449: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53453: LD_VAR 0 6
53457: PUSH
53458: LD_INT 1
53460: ARRAY
53461: PPUSH
53462: LD_VAR 0 3
53466: PPUSH
53467: LD_VAR 0 4
53471: PPUSH
53472: CALL_OW 237
// end ;
53476: PPOPN 6
53478: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53479: LD_EXP 92
53483: PUSH
53484: LD_EXP 139
53488: AND
53489: IFFALSE 53568
53491: GO 53493
53493: DISABLE
53494: LD_INT 0
53496: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53497: LD_ADDR_VAR 0 1
53501: PUSH
53502: LD_INT 22
53504: PUSH
53505: LD_OWVAR 2
53509: PUSH
53510: EMPTY
53511: LIST
53512: LIST
53513: PUSH
53514: LD_INT 30
53516: PUSH
53517: LD_INT 3
53519: PUSH
53520: EMPTY
53521: LIST
53522: LIST
53523: PUSH
53524: EMPTY
53525: LIST
53526: LIST
53527: PPUSH
53528: CALL_OW 69
53532: ST_TO_ADDR
// if not tmp then
53533: LD_VAR 0 1
53537: NOT
53538: IFFALSE 53542
// exit ;
53540: GO 53568
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53542: LD_VAR 0 1
53546: PUSH
53547: LD_INT 1
53549: PPUSH
53550: LD_VAR 0 1
53554: PPUSH
53555: CALL_OW 12
53559: ARRAY
53560: PPUSH
53561: LD_INT 1
53563: PPUSH
53564: CALL_OW 234
// end ;
53568: PPOPN 1
53570: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53571: LD_EXP 92
53575: PUSH
53576: LD_EXP 140
53580: AND
53581: IFFALSE 53693
53583: GO 53585
53585: DISABLE
53586: LD_INT 0
53588: PPUSH
53589: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53590: LD_ADDR_VAR 0 2
53594: PUSH
53595: LD_INT 22
53597: PUSH
53598: LD_OWVAR 2
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: PUSH
53607: LD_INT 2
53609: PUSH
53610: LD_INT 30
53612: PUSH
53613: LD_INT 27
53615: PUSH
53616: EMPTY
53617: LIST
53618: LIST
53619: PUSH
53620: LD_INT 30
53622: PUSH
53623: LD_INT 26
53625: PUSH
53626: EMPTY
53627: LIST
53628: LIST
53629: PUSH
53630: LD_INT 30
53632: PUSH
53633: LD_INT 28
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: LIST
53644: LIST
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: PPUSH
53650: CALL_OW 69
53654: ST_TO_ADDR
// if not tmp then
53655: LD_VAR 0 2
53659: NOT
53660: IFFALSE 53664
// exit ;
53662: GO 53693
// for i in tmp do
53664: LD_ADDR_VAR 0 1
53668: PUSH
53669: LD_VAR 0 2
53673: PUSH
53674: FOR_IN
53675: IFFALSE 53691
// SetLives ( i , 1 ) ;
53677: LD_VAR 0 1
53681: PPUSH
53682: LD_INT 1
53684: PPUSH
53685: CALL_OW 234
53689: GO 53674
53691: POP
53692: POP
// end ;
53693: PPOPN 2
53695: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53696: LD_EXP 92
53700: PUSH
53701: LD_EXP 141
53705: AND
53706: IFFALSE 53980
53708: GO 53710
53710: DISABLE
53711: LD_INT 0
53713: PPUSH
53714: PPUSH
53715: PPUSH
// begin i := rand ( 1 , 7 ) ;
53716: LD_ADDR_VAR 0 1
53720: PUSH
53721: LD_INT 1
53723: PPUSH
53724: LD_INT 7
53726: PPUSH
53727: CALL_OW 12
53731: ST_TO_ADDR
// case i of 1 :
53732: LD_VAR 0 1
53736: PUSH
53737: LD_INT 1
53739: DOUBLE
53740: EQUAL
53741: IFTRUE 53745
53743: GO 53755
53745: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53746: LD_STRING earthquake(getX(game), 0, 32)
53748: PPUSH
53749: CALL_OW 559
53753: GO 53980
53755: LD_INT 2
53757: DOUBLE
53758: EQUAL
53759: IFTRUE 53763
53761: GO 53777
53763: POP
// begin ToLua ( displayStucuk(); ) ;
53764: LD_STRING displayStucuk();
53766: PPUSH
53767: CALL_OW 559
// ResetFog ;
53771: CALL_OW 335
// end ; 3 :
53775: GO 53980
53777: LD_INT 3
53779: DOUBLE
53780: EQUAL
53781: IFTRUE 53785
53783: GO 53889
53785: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53786: LD_ADDR_VAR 0 2
53790: PUSH
53791: LD_INT 22
53793: PUSH
53794: LD_OWVAR 2
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: PUSH
53803: LD_INT 25
53805: PUSH
53806: LD_INT 1
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PPUSH
53817: CALL_OW 69
53821: ST_TO_ADDR
// if not tmp then
53822: LD_VAR 0 2
53826: NOT
53827: IFFALSE 53831
// exit ;
53829: GO 53980
// un := tmp [ rand ( 1 , tmp ) ] ;
53831: LD_ADDR_VAR 0 3
53835: PUSH
53836: LD_VAR 0 2
53840: PUSH
53841: LD_INT 1
53843: PPUSH
53844: LD_VAR 0 2
53848: PPUSH
53849: CALL_OW 12
53853: ARRAY
53854: ST_TO_ADDR
// if Crawls ( un ) then
53855: LD_VAR 0 3
53859: PPUSH
53860: CALL_OW 318
53864: IFFALSE 53875
// ComWalk ( un ) ;
53866: LD_VAR 0 3
53870: PPUSH
53871: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53875: LD_VAR 0 3
53879: PPUSH
53880: LD_INT 8
53882: PPUSH
53883: CALL_OW 336
// end ; 4 :
53887: GO 53980
53889: LD_INT 4
53891: DOUBLE
53892: EQUAL
53893: IFTRUE 53897
53895: GO 53958
53897: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53898: LD_ADDR_VAR 0 2
53902: PUSH
53903: LD_INT 22
53905: PUSH
53906: LD_OWVAR 2
53910: PUSH
53911: EMPTY
53912: LIST
53913: LIST
53914: PUSH
53915: LD_INT 30
53917: PUSH
53918: LD_INT 29
53920: PUSH
53921: EMPTY
53922: LIST
53923: LIST
53924: PUSH
53925: EMPTY
53926: LIST
53927: LIST
53928: PPUSH
53929: CALL_OW 69
53933: ST_TO_ADDR
// if not tmp then
53934: LD_VAR 0 2
53938: NOT
53939: IFFALSE 53943
// exit ;
53941: GO 53980
// DestroyUnit ( tmp [ 1 ] ) ;
53943: LD_VAR 0 2
53947: PUSH
53948: LD_INT 1
53950: ARRAY
53951: PPUSH
53952: CALL_OW 65
// end ; 5 .. 7 :
53956: GO 53980
53958: LD_INT 5
53960: DOUBLE
53961: GREATEREQUAL
53962: IFFALSE 53970
53964: LD_INT 7
53966: DOUBLE
53967: LESSEQUAL
53968: IFTRUE 53972
53970: GO 53979
53972: POP
// StreamSibBomb ; end ;
53973: CALL 50230 0 0
53977: GO 53980
53979: POP
// end ;
53980: PPOPN 3
53982: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53983: LD_EXP 92
53987: PUSH
53988: LD_EXP 142
53992: AND
53993: IFFALSE 54149
53995: GO 53997
53997: DISABLE
53998: LD_INT 0
54000: PPUSH
54001: PPUSH
54002: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54003: LD_ADDR_VAR 0 2
54007: PUSH
54008: LD_INT 81
54010: PUSH
54011: LD_OWVAR 2
54015: PUSH
54016: EMPTY
54017: LIST
54018: LIST
54019: PUSH
54020: LD_INT 2
54022: PUSH
54023: LD_INT 21
54025: PUSH
54026: LD_INT 1
54028: PUSH
54029: EMPTY
54030: LIST
54031: LIST
54032: PUSH
54033: LD_INT 21
54035: PUSH
54036: LD_INT 2
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PUSH
54043: EMPTY
54044: LIST
54045: LIST
54046: LIST
54047: PUSH
54048: EMPTY
54049: LIST
54050: LIST
54051: PPUSH
54052: CALL_OW 69
54056: ST_TO_ADDR
// if not tmp then
54057: LD_VAR 0 2
54061: NOT
54062: IFFALSE 54066
// exit ;
54064: GO 54149
// p := 0 ;
54066: LD_ADDR_VAR 0 3
54070: PUSH
54071: LD_INT 0
54073: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54074: LD_INT 35
54076: PPUSH
54077: CALL_OW 67
// p := p + 1 ;
54081: LD_ADDR_VAR 0 3
54085: PUSH
54086: LD_VAR 0 3
54090: PUSH
54091: LD_INT 1
54093: PLUS
54094: ST_TO_ADDR
// for i in tmp do
54095: LD_ADDR_VAR 0 1
54099: PUSH
54100: LD_VAR 0 2
54104: PUSH
54105: FOR_IN
54106: IFFALSE 54137
// if GetLives ( i ) < 1000 then
54108: LD_VAR 0 1
54112: PPUSH
54113: CALL_OW 256
54117: PUSH
54118: LD_INT 1000
54120: LESS
54121: IFFALSE 54135
// SetLives ( i , 1000 ) ;
54123: LD_VAR 0 1
54127: PPUSH
54128: LD_INT 1000
54130: PPUSH
54131: CALL_OW 234
54135: GO 54105
54137: POP
54138: POP
// until p > 20 ;
54139: LD_VAR 0 3
54143: PUSH
54144: LD_INT 20
54146: GREATER
54147: IFFALSE 54074
// end ;
54149: PPOPN 3
54151: END
// every 0 0$1 trigger StreamModeActive and sTime do
54152: LD_EXP 92
54156: PUSH
54157: LD_EXP 143
54161: AND
54162: IFFALSE 54197
54164: GO 54166
54166: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54167: LD_INT 28
54169: PPUSH
54170: LD_OWVAR 2
54174: PPUSH
54175: LD_INT 2
54177: PPUSH
54178: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54182: LD_INT 30
54184: PPUSH
54185: LD_OWVAR 2
54189: PPUSH
54190: LD_INT 2
54192: PPUSH
54193: CALL_OW 322
// end ;
54197: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54198: LD_EXP 92
54202: PUSH
54203: LD_EXP 144
54207: AND
54208: IFFALSE 54329
54210: GO 54212
54212: DISABLE
54213: LD_INT 0
54215: PPUSH
54216: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54217: LD_ADDR_VAR 0 2
54221: PUSH
54222: LD_INT 22
54224: PUSH
54225: LD_OWVAR 2
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: PUSH
54234: LD_INT 21
54236: PUSH
54237: LD_INT 1
54239: PUSH
54240: EMPTY
54241: LIST
54242: LIST
54243: PUSH
54244: LD_INT 3
54246: PUSH
54247: LD_INT 23
54249: PUSH
54250: LD_INT 0
54252: PUSH
54253: EMPTY
54254: LIST
54255: LIST
54256: PUSH
54257: EMPTY
54258: LIST
54259: LIST
54260: PUSH
54261: EMPTY
54262: LIST
54263: LIST
54264: LIST
54265: PPUSH
54266: CALL_OW 69
54270: ST_TO_ADDR
// if not tmp then
54271: LD_VAR 0 2
54275: NOT
54276: IFFALSE 54280
// exit ;
54278: GO 54329
// for i in tmp do
54280: LD_ADDR_VAR 0 1
54284: PUSH
54285: LD_VAR 0 2
54289: PUSH
54290: FOR_IN
54291: IFFALSE 54327
// begin if Crawls ( i ) then
54293: LD_VAR 0 1
54297: PPUSH
54298: CALL_OW 318
54302: IFFALSE 54313
// ComWalk ( i ) ;
54304: LD_VAR 0 1
54308: PPUSH
54309: CALL_OW 138
// SetClass ( i , 2 ) ;
54313: LD_VAR 0 1
54317: PPUSH
54318: LD_INT 2
54320: PPUSH
54321: CALL_OW 336
// end ;
54325: GO 54290
54327: POP
54328: POP
// end ;
54329: PPOPN 2
54331: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54332: LD_EXP 92
54336: PUSH
54337: LD_EXP 145
54341: AND
54342: IFFALSE 54623
54344: GO 54346
54346: DISABLE
54347: LD_INT 0
54349: PPUSH
54350: PPUSH
54351: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54352: LD_OWVAR 2
54356: PPUSH
54357: LD_INT 9
54359: PPUSH
54360: LD_INT 1
54362: PPUSH
54363: LD_INT 1
54365: PPUSH
54366: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54370: LD_INT 9
54372: PPUSH
54373: LD_OWVAR 2
54377: PPUSH
54378: CALL_OW 343
// uc_side := 9 ;
54382: LD_ADDR_OWVAR 20
54386: PUSH
54387: LD_INT 9
54389: ST_TO_ADDR
// uc_nation := 2 ;
54390: LD_ADDR_OWVAR 21
54394: PUSH
54395: LD_INT 2
54397: ST_TO_ADDR
// hc_name := Dark Warrior ;
54398: LD_ADDR_OWVAR 26
54402: PUSH
54403: LD_STRING Dark Warrior
54405: ST_TO_ADDR
// hc_gallery :=  ;
54406: LD_ADDR_OWVAR 33
54410: PUSH
54411: LD_STRING 
54413: ST_TO_ADDR
// hc_noskilllimit := true ;
54414: LD_ADDR_OWVAR 76
54418: PUSH
54419: LD_INT 1
54421: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54422: LD_ADDR_OWVAR 31
54426: PUSH
54427: LD_INT 30
54429: PUSH
54430: LD_INT 30
54432: PUSH
54433: LD_INT 30
54435: PUSH
54436: LD_INT 30
54438: PUSH
54439: EMPTY
54440: LIST
54441: LIST
54442: LIST
54443: LIST
54444: ST_TO_ADDR
// un := CreateHuman ;
54445: LD_ADDR_VAR 0 3
54449: PUSH
54450: CALL_OW 44
54454: ST_TO_ADDR
// hc_noskilllimit := false ;
54455: LD_ADDR_OWVAR 76
54459: PUSH
54460: LD_INT 0
54462: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54463: LD_VAR 0 3
54467: PPUSH
54468: LD_INT 1
54470: PPUSH
54471: CALL_OW 51
// p := 0 ;
54475: LD_ADDR_VAR 0 2
54479: PUSH
54480: LD_INT 0
54482: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54483: LD_INT 35
54485: PPUSH
54486: CALL_OW 67
// p := p + 1 ;
54490: LD_ADDR_VAR 0 2
54494: PUSH
54495: LD_VAR 0 2
54499: PUSH
54500: LD_INT 1
54502: PLUS
54503: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54504: LD_VAR 0 3
54508: PPUSH
54509: CALL_OW 256
54513: PUSH
54514: LD_INT 1000
54516: LESS
54517: IFFALSE 54531
// SetLives ( un , 1000 ) ;
54519: LD_VAR 0 3
54523: PPUSH
54524: LD_INT 1000
54526: PPUSH
54527: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54531: LD_VAR 0 3
54535: PPUSH
54536: LD_INT 81
54538: PUSH
54539: LD_OWVAR 2
54543: PUSH
54544: EMPTY
54545: LIST
54546: LIST
54547: PUSH
54548: LD_INT 91
54550: PUSH
54551: LD_VAR 0 3
54555: PUSH
54556: LD_INT 30
54558: PUSH
54559: EMPTY
54560: LIST
54561: LIST
54562: LIST
54563: PUSH
54564: EMPTY
54565: LIST
54566: LIST
54567: PPUSH
54568: CALL_OW 69
54572: PPUSH
54573: LD_VAR 0 3
54577: PPUSH
54578: CALL_OW 74
54582: PPUSH
54583: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54587: LD_VAR 0 2
54591: PUSH
54592: LD_INT 60
54594: GREATER
54595: PUSH
54596: LD_VAR 0 3
54600: PPUSH
54601: CALL_OW 301
54605: OR
54606: IFFALSE 54483
// if un then
54608: LD_VAR 0 3
54612: IFFALSE 54623
// RemoveUnit ( un ) ;
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 64
// end ;
54623: PPOPN 3
54625: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
54626: LD_INT 0
54628: PPUSH
// case cmd of 301 :
54629: LD_VAR 0 1
54633: PUSH
54634: LD_INT 301
54636: DOUBLE
54637: EQUAL
54638: IFTRUE 54642
54640: GO 54674
54642: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
54643: LD_VAR 0 6
54647: PPUSH
54648: LD_VAR 0 7
54652: PPUSH
54653: LD_VAR 0 8
54657: PPUSH
54658: LD_VAR 0 4
54662: PPUSH
54663: LD_VAR 0 5
54667: PPUSH
54668: CALL 55875 0 5
54672: GO 54795
54674: LD_INT 302
54676: DOUBLE
54677: EQUAL
54678: IFTRUE 54682
54680: GO 54719
54682: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
54683: LD_VAR 0 6
54687: PPUSH
54688: LD_VAR 0 7
54692: PPUSH
54693: LD_VAR 0 8
54697: PPUSH
54698: LD_VAR 0 9
54702: PPUSH
54703: LD_VAR 0 4
54707: PPUSH
54708: LD_VAR 0 5
54712: PPUSH
54713: CALL 55966 0 6
54717: GO 54795
54719: LD_INT 303
54721: DOUBLE
54722: EQUAL
54723: IFTRUE 54727
54725: GO 54764
54727: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
54728: LD_VAR 0 6
54732: PPUSH
54733: LD_VAR 0 7
54737: PPUSH
54738: LD_VAR 0 8
54742: PPUSH
54743: LD_VAR 0 9
54747: PPUSH
54748: LD_VAR 0 4
54752: PPUSH
54753: LD_VAR 0 5
54757: PPUSH
54758: CALL 54800 0 6
54762: GO 54795
54764: LD_INT 304
54766: DOUBLE
54767: EQUAL
54768: IFTRUE 54772
54770: GO 54794
54772: POP
// hHackTeleport ( unit , x , y ) ; end ;
54773: LD_VAR 0 2
54777: PPUSH
54778: LD_VAR 0 4
54782: PPUSH
54783: LD_VAR 0 5
54787: PPUSH
54788: CALL 56559 0 3
54792: GO 54795
54794: POP
// end ;
54795: LD_VAR 0 12
54799: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
54800: LD_INT 0
54802: PPUSH
54803: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
54804: LD_VAR 0 1
54808: PUSH
54809: LD_INT 1
54811: LESS
54812: PUSH
54813: LD_VAR 0 1
54817: PUSH
54818: LD_INT 3
54820: GREATER
54821: OR
54822: PUSH
54823: LD_VAR 0 5
54827: PPUSH
54828: LD_VAR 0 6
54832: PPUSH
54833: CALL_OW 428
54837: OR
54838: IFFALSE 54842
// exit ;
54840: GO 55562
// uc_side := your_side ;
54842: LD_ADDR_OWVAR 20
54846: PUSH
54847: LD_OWVAR 2
54851: ST_TO_ADDR
// uc_nation := nation ;
54852: LD_ADDR_OWVAR 21
54856: PUSH
54857: LD_VAR 0 1
54861: ST_TO_ADDR
// bc_level = 1 ;
54862: LD_ADDR_OWVAR 43
54866: PUSH
54867: LD_INT 1
54869: ST_TO_ADDR
// case btype of 1 :
54870: LD_VAR 0 2
54874: PUSH
54875: LD_INT 1
54877: DOUBLE
54878: EQUAL
54879: IFTRUE 54883
54881: GO 54894
54883: POP
// bc_type := b_depot ; 2 :
54884: LD_ADDR_OWVAR 42
54888: PUSH
54889: LD_INT 0
54891: ST_TO_ADDR
54892: GO 55506
54894: LD_INT 2
54896: DOUBLE
54897: EQUAL
54898: IFTRUE 54902
54900: GO 54913
54902: POP
// bc_type := b_warehouse ; 3 :
54903: LD_ADDR_OWVAR 42
54907: PUSH
54908: LD_INT 1
54910: ST_TO_ADDR
54911: GO 55506
54913: LD_INT 3
54915: DOUBLE
54916: EQUAL
54917: IFTRUE 54921
54919: GO 54932
54921: POP
// bc_type := b_lab ; 4 .. 9 :
54922: LD_ADDR_OWVAR 42
54926: PUSH
54927: LD_INT 6
54929: ST_TO_ADDR
54930: GO 55506
54932: LD_INT 4
54934: DOUBLE
54935: GREATEREQUAL
54936: IFFALSE 54944
54938: LD_INT 9
54940: DOUBLE
54941: LESSEQUAL
54942: IFTRUE 54946
54944: GO 54998
54946: POP
// begin bc_type := b_lab_half ;
54947: LD_ADDR_OWVAR 42
54951: PUSH
54952: LD_INT 7
54954: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
54955: LD_ADDR_OWVAR 44
54959: PUSH
54960: LD_INT 10
54962: PUSH
54963: LD_INT 11
54965: PUSH
54966: LD_INT 12
54968: PUSH
54969: LD_INT 15
54971: PUSH
54972: LD_INT 14
54974: PUSH
54975: LD_INT 13
54977: PUSH
54978: EMPTY
54979: LIST
54980: LIST
54981: LIST
54982: LIST
54983: LIST
54984: LIST
54985: PUSH
54986: LD_VAR 0 2
54990: PUSH
54991: LD_INT 3
54993: MINUS
54994: ARRAY
54995: ST_TO_ADDR
// end ; 10 .. 13 :
54996: GO 55506
54998: LD_INT 10
55000: DOUBLE
55001: GREATEREQUAL
55002: IFFALSE 55010
55004: LD_INT 13
55006: DOUBLE
55007: LESSEQUAL
55008: IFTRUE 55012
55010: GO 55089
55012: POP
// begin bc_type := b_lab_full ;
55013: LD_ADDR_OWVAR 42
55017: PUSH
55018: LD_INT 8
55020: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
55021: LD_ADDR_OWVAR 44
55025: PUSH
55026: LD_INT 10
55028: PUSH
55029: LD_INT 12
55031: PUSH
55032: LD_INT 14
55034: PUSH
55035: LD_INT 13
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: LIST
55042: LIST
55043: PUSH
55044: LD_VAR 0 2
55048: PUSH
55049: LD_INT 9
55051: MINUS
55052: ARRAY
55053: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
55054: LD_ADDR_OWVAR 45
55058: PUSH
55059: LD_INT 11
55061: PUSH
55062: LD_INT 15
55064: PUSH
55065: LD_INT 12
55067: PUSH
55068: LD_INT 15
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: LIST
55075: LIST
55076: PUSH
55077: LD_VAR 0 2
55081: PUSH
55082: LD_INT 9
55084: MINUS
55085: ARRAY
55086: ST_TO_ADDR
// end ; 14 :
55087: GO 55506
55089: LD_INT 14
55091: DOUBLE
55092: EQUAL
55093: IFTRUE 55097
55095: GO 55108
55097: POP
// bc_type := b_workshop ; 15 :
55098: LD_ADDR_OWVAR 42
55102: PUSH
55103: LD_INT 2
55105: ST_TO_ADDR
55106: GO 55506
55108: LD_INT 15
55110: DOUBLE
55111: EQUAL
55112: IFTRUE 55116
55114: GO 55127
55116: POP
// bc_type := b_factory ; 16 :
55117: LD_ADDR_OWVAR 42
55121: PUSH
55122: LD_INT 3
55124: ST_TO_ADDR
55125: GO 55506
55127: LD_INT 16
55129: DOUBLE
55130: EQUAL
55131: IFTRUE 55135
55133: GO 55146
55135: POP
// bc_type := b_ext_gun ; 17 :
55136: LD_ADDR_OWVAR 42
55140: PUSH
55141: LD_INT 17
55143: ST_TO_ADDR
55144: GO 55506
55146: LD_INT 17
55148: DOUBLE
55149: EQUAL
55150: IFTRUE 55154
55152: GO 55182
55154: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55155: LD_ADDR_OWVAR 42
55159: PUSH
55160: LD_INT 19
55162: PUSH
55163: LD_INT 23
55165: PUSH
55166: LD_INT 19
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: LIST
55173: PUSH
55174: LD_VAR 0 1
55178: ARRAY
55179: ST_TO_ADDR
55180: GO 55506
55182: LD_INT 18
55184: DOUBLE
55185: EQUAL
55186: IFTRUE 55190
55188: GO 55201
55190: POP
// bc_type := b_ext_radar ; 19 :
55191: LD_ADDR_OWVAR 42
55195: PUSH
55196: LD_INT 20
55198: ST_TO_ADDR
55199: GO 55506
55201: LD_INT 19
55203: DOUBLE
55204: EQUAL
55205: IFTRUE 55209
55207: GO 55220
55209: POP
// bc_type := b_ext_radio ; 20 :
55210: LD_ADDR_OWVAR 42
55214: PUSH
55215: LD_INT 22
55217: ST_TO_ADDR
55218: GO 55506
55220: LD_INT 20
55222: DOUBLE
55223: EQUAL
55224: IFTRUE 55228
55226: GO 55239
55228: POP
// bc_type := b_ext_siberium ; 21 :
55229: LD_ADDR_OWVAR 42
55233: PUSH
55234: LD_INT 21
55236: ST_TO_ADDR
55237: GO 55506
55239: LD_INT 21
55241: DOUBLE
55242: EQUAL
55243: IFTRUE 55247
55245: GO 55258
55247: POP
// bc_type := b_ext_computer ; 22 :
55248: LD_ADDR_OWVAR 42
55252: PUSH
55253: LD_INT 24
55255: ST_TO_ADDR
55256: GO 55506
55258: LD_INT 22
55260: DOUBLE
55261: EQUAL
55262: IFTRUE 55266
55264: GO 55277
55266: POP
// bc_type := b_ext_track ; 23 :
55267: LD_ADDR_OWVAR 42
55271: PUSH
55272: LD_INT 16
55274: ST_TO_ADDR
55275: GO 55506
55277: LD_INT 23
55279: DOUBLE
55280: EQUAL
55281: IFTRUE 55285
55283: GO 55296
55285: POP
// bc_type := b_ext_laser ; 24 :
55286: LD_ADDR_OWVAR 42
55290: PUSH
55291: LD_INT 25
55293: ST_TO_ADDR
55294: GO 55506
55296: LD_INT 24
55298: DOUBLE
55299: EQUAL
55300: IFTRUE 55304
55302: GO 55315
55304: POP
// bc_type := b_control_tower ; 25 :
55305: LD_ADDR_OWVAR 42
55309: PUSH
55310: LD_INT 36
55312: ST_TO_ADDR
55313: GO 55506
55315: LD_INT 25
55317: DOUBLE
55318: EQUAL
55319: IFTRUE 55323
55321: GO 55334
55323: POP
// bc_type := b_breastwork ; 26 :
55324: LD_ADDR_OWVAR 42
55328: PUSH
55329: LD_INT 31
55331: ST_TO_ADDR
55332: GO 55506
55334: LD_INT 26
55336: DOUBLE
55337: EQUAL
55338: IFTRUE 55342
55340: GO 55353
55342: POP
// bc_type := b_bunker ; 27 :
55343: LD_ADDR_OWVAR 42
55347: PUSH
55348: LD_INT 32
55350: ST_TO_ADDR
55351: GO 55506
55353: LD_INT 27
55355: DOUBLE
55356: EQUAL
55357: IFTRUE 55361
55359: GO 55372
55361: POP
// bc_type := b_turret ; 28 :
55362: LD_ADDR_OWVAR 42
55366: PUSH
55367: LD_INT 33
55369: ST_TO_ADDR
55370: GO 55506
55372: LD_INT 28
55374: DOUBLE
55375: EQUAL
55376: IFTRUE 55380
55378: GO 55391
55380: POP
// bc_type := b_armoury ; 29 :
55381: LD_ADDR_OWVAR 42
55385: PUSH
55386: LD_INT 4
55388: ST_TO_ADDR
55389: GO 55506
55391: LD_INT 29
55393: DOUBLE
55394: EQUAL
55395: IFTRUE 55399
55397: GO 55410
55399: POP
// bc_type := b_barracks ; 30 :
55400: LD_ADDR_OWVAR 42
55404: PUSH
55405: LD_INT 5
55407: ST_TO_ADDR
55408: GO 55506
55410: LD_INT 30
55412: DOUBLE
55413: EQUAL
55414: IFTRUE 55418
55416: GO 55429
55418: POP
// bc_type := b_solar_power ; 31 :
55419: LD_ADDR_OWVAR 42
55423: PUSH
55424: LD_INT 27
55426: ST_TO_ADDR
55427: GO 55506
55429: LD_INT 31
55431: DOUBLE
55432: EQUAL
55433: IFTRUE 55437
55435: GO 55448
55437: POP
// bc_type := b_oil_power ; 32 :
55438: LD_ADDR_OWVAR 42
55442: PUSH
55443: LD_INT 26
55445: ST_TO_ADDR
55446: GO 55506
55448: LD_INT 32
55450: DOUBLE
55451: EQUAL
55452: IFTRUE 55456
55454: GO 55467
55456: POP
// bc_type := b_siberite_power ; 33 :
55457: LD_ADDR_OWVAR 42
55461: PUSH
55462: LD_INT 28
55464: ST_TO_ADDR
55465: GO 55506
55467: LD_INT 33
55469: DOUBLE
55470: EQUAL
55471: IFTRUE 55475
55473: GO 55486
55475: POP
// bc_type := b_oil_mine ; 34 :
55476: LD_ADDR_OWVAR 42
55480: PUSH
55481: LD_INT 29
55483: ST_TO_ADDR
55484: GO 55506
55486: LD_INT 34
55488: DOUBLE
55489: EQUAL
55490: IFTRUE 55494
55492: GO 55505
55494: POP
// bc_type := b_siberite_mine ; end ;
55495: LD_ADDR_OWVAR 42
55499: PUSH
55500: LD_INT 30
55502: ST_TO_ADDR
55503: GO 55506
55505: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
55506: LD_ADDR_VAR 0 8
55510: PUSH
55511: LD_VAR 0 5
55515: PPUSH
55516: LD_VAR 0 6
55520: PPUSH
55521: LD_VAR 0 3
55525: PPUSH
55526: CALL_OW 47
55530: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
55531: LD_OWVAR 42
55535: PUSH
55536: LD_INT 32
55538: PUSH
55539: LD_INT 33
55541: PUSH
55542: EMPTY
55543: LIST
55544: LIST
55545: IN
55546: IFFALSE 55562
// PlaceWeaponTurret ( b , weapon ) ;
55548: LD_VAR 0 8
55552: PPUSH
55553: LD_VAR 0 4
55557: PPUSH
55558: CALL_OW 431
// end ;
55562: LD_VAR 0 7
55566: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
55567: LD_INT 0
55569: PPUSH
55570: PPUSH
55571: PPUSH
55572: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
55573: LD_ADDR_VAR 0 4
55577: PUSH
55578: LD_INT 22
55580: PUSH
55581: LD_OWVAR 2
55585: PUSH
55586: EMPTY
55587: LIST
55588: LIST
55589: PUSH
55590: LD_INT 2
55592: PUSH
55593: LD_INT 30
55595: PUSH
55596: LD_INT 0
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: PUSH
55603: LD_INT 30
55605: PUSH
55606: LD_INT 1
55608: PUSH
55609: EMPTY
55610: LIST
55611: LIST
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: LIST
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: PPUSH
55622: CALL_OW 69
55626: ST_TO_ADDR
// if not tmp then
55627: LD_VAR 0 4
55631: NOT
55632: IFFALSE 55636
// exit ;
55634: GO 55695
// for i in tmp do
55636: LD_ADDR_VAR 0 2
55640: PUSH
55641: LD_VAR 0 4
55645: PUSH
55646: FOR_IN
55647: IFFALSE 55693
// for j = 1 to 3 do
55649: LD_ADDR_VAR 0 3
55653: PUSH
55654: DOUBLE
55655: LD_INT 1
55657: DEC
55658: ST_TO_ADDR
55659: LD_INT 3
55661: PUSH
55662: FOR_TO
55663: IFFALSE 55689
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
55665: LD_VAR 0 2
55669: PPUSH
55670: CALL_OW 274
55674: PPUSH
55675: LD_VAR 0 3
55679: PPUSH
55680: LD_INT 99999
55682: PPUSH
55683: CALL_OW 277
55687: GO 55662
55689: POP
55690: POP
55691: GO 55646
55693: POP
55694: POP
// end ;
55695: LD_VAR 0 1
55699: RET
// export function hHackSetLevel10 ; var i , j ; begin
55700: LD_INT 0
55702: PPUSH
55703: PPUSH
55704: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55705: LD_ADDR_VAR 0 2
55709: PUSH
55710: LD_INT 21
55712: PUSH
55713: LD_INT 1
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: PPUSH
55720: CALL_OW 69
55724: PUSH
55725: FOR_IN
55726: IFFALSE 55778
// if IsSelected ( i ) then
55728: LD_VAR 0 2
55732: PPUSH
55733: CALL_OW 306
55737: IFFALSE 55776
// begin for j := 1 to 4 do
55739: LD_ADDR_VAR 0 3
55743: PUSH
55744: DOUBLE
55745: LD_INT 1
55747: DEC
55748: ST_TO_ADDR
55749: LD_INT 4
55751: PUSH
55752: FOR_TO
55753: IFFALSE 55774
// SetSkill ( i , j , 10 ) ;
55755: LD_VAR 0 2
55759: PPUSH
55760: LD_VAR 0 3
55764: PPUSH
55765: LD_INT 10
55767: PPUSH
55768: CALL_OW 237
55772: GO 55752
55774: POP
55775: POP
// end ;
55776: GO 55725
55778: POP
55779: POP
// end ;
55780: LD_VAR 0 1
55784: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
55785: LD_INT 0
55787: PPUSH
55788: PPUSH
55789: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55790: LD_ADDR_VAR 0 2
55794: PUSH
55795: LD_INT 22
55797: PUSH
55798: LD_OWVAR 2
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: PUSH
55807: LD_INT 21
55809: PUSH
55810: LD_INT 1
55812: PUSH
55813: EMPTY
55814: LIST
55815: LIST
55816: PUSH
55817: EMPTY
55818: LIST
55819: LIST
55820: PPUSH
55821: CALL_OW 69
55825: PUSH
55826: FOR_IN
55827: IFFALSE 55868
// begin for j := 1 to 4 do
55829: LD_ADDR_VAR 0 3
55833: PUSH
55834: DOUBLE
55835: LD_INT 1
55837: DEC
55838: ST_TO_ADDR
55839: LD_INT 4
55841: PUSH
55842: FOR_TO
55843: IFFALSE 55864
// SetSkill ( i , j , 10 ) ;
55845: LD_VAR 0 2
55849: PPUSH
55850: LD_VAR 0 3
55854: PPUSH
55855: LD_INT 10
55857: PPUSH
55858: CALL_OW 237
55862: GO 55842
55864: POP
55865: POP
// end ;
55866: GO 55826
55868: POP
55869: POP
// end ;
55870: LD_VAR 0 1
55874: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
55875: LD_INT 0
55877: PPUSH
// uc_side := your_side ;
55878: LD_ADDR_OWVAR 20
55882: PUSH
55883: LD_OWVAR 2
55887: ST_TO_ADDR
// uc_nation := nation ;
55888: LD_ADDR_OWVAR 21
55892: PUSH
55893: LD_VAR 0 1
55897: ST_TO_ADDR
// InitHc ;
55898: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55902: LD_INT 0
55904: PPUSH
55905: LD_VAR 0 2
55909: PPUSH
55910: LD_VAR 0 3
55914: PPUSH
55915: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
55919: LD_VAR 0 4
55923: PPUSH
55924: LD_VAR 0 5
55928: PPUSH
55929: CALL_OW 428
55933: PUSH
55934: LD_INT 0
55936: EQUAL
55937: IFFALSE 55961
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
55939: CALL_OW 44
55943: PPUSH
55944: LD_VAR 0 4
55948: PPUSH
55949: LD_VAR 0 5
55953: PPUSH
55954: LD_INT 1
55956: PPUSH
55957: CALL_OW 48
// end ;
55961: LD_VAR 0 6
55965: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
55966: LD_INT 0
55968: PPUSH
55969: PPUSH
// uc_side := your_side ;
55970: LD_ADDR_OWVAR 20
55974: PUSH
55975: LD_OWVAR 2
55979: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
55980: LD_VAR 0 1
55984: PUSH
55985: LD_INT 1
55987: PUSH
55988: LD_INT 2
55990: PUSH
55991: LD_INT 3
55993: PUSH
55994: LD_INT 4
55996: PUSH
55997: LD_INT 5
55999: PUSH
56000: EMPTY
56001: LIST
56002: LIST
56003: LIST
56004: LIST
56005: LIST
56006: IN
56007: IFFALSE 56019
// uc_nation := nation_american else
56009: LD_ADDR_OWVAR 21
56013: PUSH
56014: LD_INT 1
56016: ST_TO_ADDR
56017: GO 56062
// if chassis in [ 11 , 12 , 13 , 14 ] then
56019: LD_VAR 0 1
56023: PUSH
56024: LD_INT 11
56026: PUSH
56027: LD_INT 12
56029: PUSH
56030: LD_INT 13
56032: PUSH
56033: LD_INT 14
56035: PUSH
56036: EMPTY
56037: LIST
56038: LIST
56039: LIST
56040: LIST
56041: IN
56042: IFFALSE 56054
// uc_nation := nation_arabian else
56044: LD_ADDR_OWVAR 21
56048: PUSH
56049: LD_INT 2
56051: ST_TO_ADDR
56052: GO 56062
// uc_nation := nation_russian ;
56054: LD_ADDR_OWVAR 21
56058: PUSH
56059: LD_INT 3
56061: ST_TO_ADDR
// vc_chassis := chassis ;
56062: LD_ADDR_OWVAR 37
56066: PUSH
56067: LD_VAR 0 1
56071: ST_TO_ADDR
// vc_engine := engine ;
56072: LD_ADDR_OWVAR 39
56076: PUSH
56077: LD_VAR 0 2
56081: ST_TO_ADDR
// vc_control := control ;
56082: LD_ADDR_OWVAR 38
56086: PUSH
56087: LD_VAR 0 3
56091: ST_TO_ADDR
// vc_weapon := weapon ;
56092: LD_ADDR_OWVAR 40
56096: PUSH
56097: LD_VAR 0 4
56101: ST_TO_ADDR
// un := CreateVehicle ;
56102: LD_ADDR_VAR 0 8
56106: PUSH
56107: CALL_OW 45
56111: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
56112: LD_VAR 0 8
56116: PPUSH
56117: LD_INT 0
56119: PPUSH
56120: LD_INT 5
56122: PPUSH
56123: CALL_OW 12
56127: PPUSH
56128: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56132: LD_VAR 0 8
56136: PPUSH
56137: LD_VAR 0 5
56141: PPUSH
56142: LD_VAR 0 6
56146: PPUSH
56147: LD_INT 1
56149: PPUSH
56150: CALL_OW 48
// end ;
56154: LD_VAR 0 7
56158: RET
// export hInvincible ; every 1 do
56159: GO 56161
56161: DISABLE
// hInvincible := [ ] ;
56162: LD_ADDR_EXP 146
56166: PUSH
56167: EMPTY
56168: ST_TO_ADDR
56169: END
// every 10 do var i ;
56170: GO 56172
56172: DISABLE
56173: LD_INT 0
56175: PPUSH
// begin enable ;
56176: ENABLE
// if not hInvincible then
56177: LD_EXP 146
56181: NOT
56182: IFFALSE 56186
// exit ;
56184: GO 56230
// for i in hInvincible do
56186: LD_ADDR_VAR 0 1
56190: PUSH
56191: LD_EXP 146
56195: PUSH
56196: FOR_IN
56197: IFFALSE 56228
// if GetLives ( i ) < 1000 then
56199: LD_VAR 0 1
56203: PPUSH
56204: CALL_OW 256
56208: PUSH
56209: LD_INT 1000
56211: LESS
56212: IFFALSE 56226
// SetLives ( i , 1000 ) ;
56214: LD_VAR 0 1
56218: PPUSH
56219: LD_INT 1000
56221: PPUSH
56222: CALL_OW 234
56226: GO 56196
56228: POP
56229: POP
// end ;
56230: PPOPN 1
56232: END
// export function hHackInvincible ; var i ; begin
56233: LD_INT 0
56235: PPUSH
56236: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56237: LD_ADDR_VAR 0 2
56241: PUSH
56242: LD_INT 2
56244: PUSH
56245: LD_INT 21
56247: PUSH
56248: LD_INT 1
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: PUSH
56255: LD_INT 21
56257: PUSH
56258: LD_INT 2
56260: PUSH
56261: EMPTY
56262: LIST
56263: LIST
56264: PUSH
56265: EMPTY
56266: LIST
56267: LIST
56268: LIST
56269: PPUSH
56270: CALL_OW 69
56274: PUSH
56275: FOR_IN
56276: IFFALSE 56337
// if IsSelected ( i ) then
56278: LD_VAR 0 2
56282: PPUSH
56283: CALL_OW 306
56287: IFFALSE 56335
// begin if i in hInvincible then
56289: LD_VAR 0 2
56293: PUSH
56294: LD_EXP 146
56298: IN
56299: IFFALSE 56319
// hInvincible := hInvincible diff i else
56301: LD_ADDR_EXP 146
56305: PUSH
56306: LD_EXP 146
56310: PUSH
56311: LD_VAR 0 2
56315: DIFF
56316: ST_TO_ADDR
56317: GO 56335
// hInvincible := hInvincible union i ;
56319: LD_ADDR_EXP 146
56323: PUSH
56324: LD_EXP 146
56328: PUSH
56329: LD_VAR 0 2
56333: UNION
56334: ST_TO_ADDR
// end ;
56335: GO 56275
56337: POP
56338: POP
// end ;
56339: LD_VAR 0 1
56343: RET
// export function hHackInvisible ; var i , j ; begin
56344: LD_INT 0
56346: PPUSH
56347: PPUSH
56348: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56349: LD_ADDR_VAR 0 2
56353: PUSH
56354: LD_INT 21
56356: PUSH
56357: LD_INT 1
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: PPUSH
56364: CALL_OW 69
56368: PUSH
56369: FOR_IN
56370: IFFALSE 56394
// if IsSelected ( i ) then
56372: LD_VAR 0 2
56376: PPUSH
56377: CALL_OW 306
56381: IFFALSE 56392
// ComForceInvisible ( i ) ;
56383: LD_VAR 0 2
56387: PPUSH
56388: CALL_OW 496
56392: GO 56369
56394: POP
56395: POP
// end ;
56396: LD_VAR 0 1
56400: RET
// export function hHackChangeYourSide ; begin
56401: LD_INT 0
56403: PPUSH
// if your_side = 8 then
56404: LD_OWVAR 2
56408: PUSH
56409: LD_INT 8
56411: EQUAL
56412: IFFALSE 56424
// your_side := 0 else
56414: LD_ADDR_OWVAR 2
56418: PUSH
56419: LD_INT 0
56421: ST_TO_ADDR
56422: GO 56438
// your_side := your_side + 1 ;
56424: LD_ADDR_OWVAR 2
56428: PUSH
56429: LD_OWVAR 2
56433: PUSH
56434: LD_INT 1
56436: PLUS
56437: ST_TO_ADDR
// end ;
56438: LD_VAR 0 1
56442: RET
// export function hHackChangeUnitSide ; var i , j ; begin
56443: LD_INT 0
56445: PPUSH
56446: PPUSH
56447: PPUSH
// for i in all_units do
56448: LD_ADDR_VAR 0 2
56452: PUSH
56453: LD_OWVAR 3
56457: PUSH
56458: FOR_IN
56459: IFFALSE 56537
// if IsSelected ( i ) then
56461: LD_VAR 0 2
56465: PPUSH
56466: CALL_OW 306
56470: IFFALSE 56535
// begin j := GetSide ( i ) ;
56472: LD_ADDR_VAR 0 3
56476: PUSH
56477: LD_VAR 0 2
56481: PPUSH
56482: CALL_OW 255
56486: ST_TO_ADDR
// if j = 8 then
56487: LD_VAR 0 3
56491: PUSH
56492: LD_INT 8
56494: EQUAL
56495: IFFALSE 56507
// j := 0 else
56497: LD_ADDR_VAR 0 3
56501: PUSH
56502: LD_INT 0
56504: ST_TO_ADDR
56505: GO 56521
// j := j + 1 ;
56507: LD_ADDR_VAR 0 3
56511: PUSH
56512: LD_VAR 0 3
56516: PUSH
56517: LD_INT 1
56519: PLUS
56520: ST_TO_ADDR
// SetSide ( i , j ) ;
56521: LD_VAR 0 2
56525: PPUSH
56526: LD_VAR 0 3
56530: PPUSH
56531: CALL_OW 235
// end ;
56535: GO 56458
56537: POP
56538: POP
// end ;
56539: LD_VAR 0 1
56543: RET
// export function hHackFog ; begin
56544: LD_INT 0
56546: PPUSH
// FogOff ( true ) ;
56547: LD_INT 1
56549: PPUSH
56550: CALL_OW 344
// end ;
56554: LD_VAR 0 1
56558: RET
// export function hHackTeleport ( unit , x , y ) ; begin
56559: LD_INT 0
56561: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
56562: LD_VAR 0 1
56566: PPUSH
56567: LD_VAR 0 2
56571: PPUSH
56572: LD_VAR 0 3
56576: PPUSH
56577: LD_INT 1
56579: PPUSH
56580: LD_INT 1
56582: PPUSH
56583: CALL_OW 483
// CenterOnXY ( x , y ) ;
56587: LD_VAR 0 2
56591: PPUSH
56592: LD_VAR 0 3
56596: PPUSH
56597: CALL_OW 84
// end ; end_of_file
56601: LD_VAR 0 4
56605: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56606: LD_INT 0
56608: PPUSH
56609: PPUSH
56610: PPUSH
56611: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56612: LD_VAR 0 1
56616: PPUSH
56617: CALL_OW 264
56621: PUSH
56622: LD_EXP 77
56626: EQUAL
56627: IFFALSE 56699
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56629: LD_INT 68
56631: PPUSH
56632: LD_VAR 0 1
56636: PPUSH
56637: CALL_OW 255
56641: PPUSH
56642: CALL_OW 321
56646: PUSH
56647: LD_INT 2
56649: EQUAL
56650: IFFALSE 56662
// eff := 70 else
56652: LD_ADDR_VAR 0 4
56656: PUSH
56657: LD_INT 70
56659: ST_TO_ADDR
56660: GO 56670
// eff := 30 ;
56662: LD_ADDR_VAR 0 4
56666: PUSH
56667: LD_INT 30
56669: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56670: LD_VAR 0 1
56674: PPUSH
56675: CALL_OW 250
56679: PPUSH
56680: LD_VAR 0 1
56684: PPUSH
56685: CALL_OW 251
56689: PPUSH
56690: LD_VAR 0 4
56694: PPUSH
56695: CALL_OW 495
// end ; end ;
56699: LD_VAR 0 2
56703: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56704: LD_INT 0
56706: PPUSH
// end ;
56707: LD_VAR 0 4
56711: RET
// export function SOS_Command ( cmd ) ; begin
56712: LD_INT 0
56714: PPUSH
// end ;
56715: LD_VAR 0 2
56719: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
56720: LD_INT 0
56722: PPUSH
// if cmd = 121 then
56723: LD_VAR 0 1
56727: PUSH
56728: LD_INT 121
56730: EQUAL
56731: IFFALSE 56733
// end ;
56733: LD_VAR 0 6
56737: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56738: LD_INT 0
56740: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56741: LD_VAR 0 1
56745: PUSH
56746: LD_INT 250
56748: EQUAL
56749: PUSH
56750: LD_VAR 0 2
56754: PPUSH
56755: CALL_OW 264
56759: PUSH
56760: LD_EXP 80
56764: EQUAL
56765: AND
56766: IFFALSE 56787
// MinerPlaceMine ( unit , x , y ) ;
56768: LD_VAR 0 2
56772: PPUSH
56773: LD_VAR 0 4
56777: PPUSH
56778: LD_VAR 0 5
56782: PPUSH
56783: CALL 59136 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56787: LD_VAR 0 1
56791: PUSH
56792: LD_INT 251
56794: EQUAL
56795: PUSH
56796: LD_VAR 0 2
56800: PPUSH
56801: CALL_OW 264
56805: PUSH
56806: LD_EXP 80
56810: EQUAL
56811: AND
56812: IFFALSE 56833
// MinerDetonateMine ( unit , x , y ) ;
56814: LD_VAR 0 2
56818: PPUSH
56819: LD_VAR 0 4
56823: PPUSH
56824: LD_VAR 0 5
56828: PPUSH
56829: CALL 59413 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
56833: LD_VAR 0 1
56837: PUSH
56838: LD_INT 252
56840: EQUAL
56841: PUSH
56842: LD_VAR 0 2
56846: PPUSH
56847: CALL_OW 264
56851: PUSH
56852: LD_EXP 80
56856: EQUAL
56857: AND
56858: IFFALSE 56879
// MinerCreateMinefield ( unit , x , y ) ;
56860: LD_VAR 0 2
56864: PPUSH
56865: LD_VAR 0 4
56869: PPUSH
56870: LD_VAR 0 5
56874: PPUSH
56875: CALL 59830 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
56879: LD_VAR 0 1
56883: PUSH
56884: LD_INT 253
56886: EQUAL
56887: PUSH
56888: LD_VAR 0 2
56892: PPUSH
56893: CALL_OW 257
56897: PUSH
56898: LD_INT 5
56900: EQUAL
56901: AND
56902: IFFALSE 56923
// ComBinocular ( unit , x , y ) ;
56904: LD_VAR 0 2
56908: PPUSH
56909: LD_VAR 0 4
56913: PPUSH
56914: LD_VAR 0 5
56918: PPUSH
56919: CALL 60201 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56923: LD_VAR 0 1
56927: PUSH
56928: LD_INT 254
56930: EQUAL
56931: PUSH
56932: LD_VAR 0 2
56936: PPUSH
56937: CALL_OW 264
56941: PUSH
56942: LD_EXP 75
56946: EQUAL
56947: AND
56948: PUSH
56949: LD_VAR 0 3
56953: PPUSH
56954: CALL_OW 263
56958: PUSH
56959: LD_INT 3
56961: EQUAL
56962: AND
56963: IFFALSE 56979
// HackDestroyVehicle ( unit , selectedUnit ) ;
56965: LD_VAR 0 2
56969: PPUSH
56970: LD_VAR 0 3
56974: PPUSH
56975: CALL 58496 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56979: LD_VAR 0 1
56983: PUSH
56984: LD_INT 255
56986: EQUAL
56987: PUSH
56988: LD_VAR 0 2
56992: PPUSH
56993: CALL_OW 264
56997: PUSH
56998: LD_INT 14
57000: PUSH
57001: LD_INT 53
57003: PUSH
57004: EMPTY
57005: LIST
57006: LIST
57007: IN
57008: AND
57009: PUSH
57010: LD_VAR 0 4
57014: PPUSH
57015: LD_VAR 0 5
57019: PPUSH
57020: CALL_OW 488
57024: AND
57025: IFFALSE 57049
// CutTreeXYR ( unit , x , y , 12 ) ;
57027: LD_VAR 0 2
57031: PPUSH
57032: LD_VAR 0 4
57036: PPUSH
57037: LD_VAR 0 5
57041: PPUSH
57042: LD_INT 12
57044: PPUSH
57045: CALL 57062 0 4
// end ;
57049: LD_VAR 0 6
57053: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
57054: LD_INT 0
57056: PPUSH
// end ;
57057: LD_VAR 0 4
57061: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
57062: LD_INT 0
57064: PPUSH
57065: PPUSH
57066: PPUSH
57067: PPUSH
57068: PPUSH
57069: PPUSH
57070: PPUSH
57071: PPUSH
57072: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
57073: LD_VAR 0 1
57077: NOT
57078: PUSH
57079: LD_VAR 0 2
57083: PPUSH
57084: LD_VAR 0 3
57088: PPUSH
57089: CALL_OW 488
57093: NOT
57094: OR
57095: PUSH
57096: LD_VAR 0 4
57100: NOT
57101: OR
57102: IFFALSE 57106
// exit ;
57104: GO 57446
// list := [ ] ;
57106: LD_ADDR_VAR 0 13
57110: PUSH
57111: EMPTY
57112: ST_TO_ADDR
// if x - r < 0 then
57113: LD_VAR 0 2
57117: PUSH
57118: LD_VAR 0 4
57122: MINUS
57123: PUSH
57124: LD_INT 0
57126: LESS
57127: IFFALSE 57139
// min_x := 0 else
57129: LD_ADDR_VAR 0 7
57133: PUSH
57134: LD_INT 0
57136: ST_TO_ADDR
57137: GO 57155
// min_x := x - r ;
57139: LD_ADDR_VAR 0 7
57143: PUSH
57144: LD_VAR 0 2
57148: PUSH
57149: LD_VAR 0 4
57153: MINUS
57154: ST_TO_ADDR
// if y - r < 0 then
57155: LD_VAR 0 3
57159: PUSH
57160: LD_VAR 0 4
57164: MINUS
57165: PUSH
57166: LD_INT 0
57168: LESS
57169: IFFALSE 57181
// min_y := 0 else
57171: LD_ADDR_VAR 0 8
57175: PUSH
57176: LD_INT 0
57178: ST_TO_ADDR
57179: GO 57197
// min_y := y - r ;
57181: LD_ADDR_VAR 0 8
57185: PUSH
57186: LD_VAR 0 3
57190: PUSH
57191: LD_VAR 0 4
57195: MINUS
57196: ST_TO_ADDR
// max_x := x + r ;
57197: LD_ADDR_VAR 0 9
57201: PUSH
57202: LD_VAR 0 2
57206: PUSH
57207: LD_VAR 0 4
57211: PLUS
57212: ST_TO_ADDR
// max_y := y + r ;
57213: LD_ADDR_VAR 0 10
57217: PUSH
57218: LD_VAR 0 3
57222: PUSH
57223: LD_VAR 0 4
57227: PLUS
57228: ST_TO_ADDR
// for _x = min_x to max_x do
57229: LD_ADDR_VAR 0 11
57233: PUSH
57234: DOUBLE
57235: LD_VAR 0 7
57239: DEC
57240: ST_TO_ADDR
57241: LD_VAR 0 9
57245: PUSH
57246: FOR_TO
57247: IFFALSE 57364
// for _y = min_y to max_y do
57249: LD_ADDR_VAR 0 12
57253: PUSH
57254: DOUBLE
57255: LD_VAR 0 8
57259: DEC
57260: ST_TO_ADDR
57261: LD_VAR 0 10
57265: PUSH
57266: FOR_TO
57267: IFFALSE 57360
// begin if not ValidHex ( _x , _y ) then
57269: LD_VAR 0 11
57273: PPUSH
57274: LD_VAR 0 12
57278: PPUSH
57279: CALL_OW 488
57283: NOT
57284: IFFALSE 57288
// continue ;
57286: GO 57266
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57288: LD_VAR 0 11
57292: PPUSH
57293: LD_VAR 0 12
57297: PPUSH
57298: CALL_OW 351
57302: PUSH
57303: LD_VAR 0 11
57307: PPUSH
57308: LD_VAR 0 12
57312: PPUSH
57313: CALL_OW 554
57317: AND
57318: IFFALSE 57358
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57320: LD_ADDR_VAR 0 13
57324: PUSH
57325: LD_VAR 0 13
57329: PPUSH
57330: LD_VAR 0 13
57334: PUSH
57335: LD_INT 1
57337: PLUS
57338: PPUSH
57339: LD_VAR 0 11
57343: PUSH
57344: LD_VAR 0 12
57348: PUSH
57349: EMPTY
57350: LIST
57351: LIST
57352: PPUSH
57353: CALL_OW 2
57357: ST_TO_ADDR
// end ;
57358: GO 57266
57360: POP
57361: POP
57362: GO 57246
57364: POP
57365: POP
// if not list then
57366: LD_VAR 0 13
57370: NOT
57371: IFFALSE 57375
// exit ;
57373: GO 57446
// for i in list do
57375: LD_ADDR_VAR 0 6
57379: PUSH
57380: LD_VAR 0 13
57384: PUSH
57385: FOR_IN
57386: IFFALSE 57444
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57388: LD_VAR 0 1
57392: PPUSH
57393: LD_STRING M
57395: PUSH
57396: LD_VAR 0 6
57400: PUSH
57401: LD_INT 1
57403: ARRAY
57404: PUSH
57405: LD_VAR 0 6
57409: PUSH
57410: LD_INT 2
57412: ARRAY
57413: PUSH
57414: LD_INT 0
57416: PUSH
57417: LD_INT 0
57419: PUSH
57420: LD_INT 0
57422: PUSH
57423: LD_INT 0
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: LIST
57430: LIST
57431: LIST
57432: LIST
57433: LIST
57434: PUSH
57435: EMPTY
57436: LIST
57437: PPUSH
57438: CALL_OW 447
57442: GO 57385
57444: POP
57445: POP
// end ;
57446: LD_VAR 0 5
57450: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57451: LD_EXP 149
57455: NOT
57456: IFFALSE 57506
57458: GO 57460
57460: DISABLE
// begin initHack := true ;
57461: LD_ADDR_EXP 149
57465: PUSH
57466: LD_INT 1
57468: ST_TO_ADDR
// hackTanks := [ ] ;
57469: LD_ADDR_EXP 150
57473: PUSH
57474: EMPTY
57475: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57476: LD_ADDR_EXP 151
57480: PUSH
57481: EMPTY
57482: ST_TO_ADDR
// hackLimit := 3 ;
57483: LD_ADDR_EXP 152
57487: PUSH
57488: LD_INT 3
57490: ST_TO_ADDR
// hackDist := 12 ;
57491: LD_ADDR_EXP 153
57495: PUSH
57496: LD_INT 12
57498: ST_TO_ADDR
// hackCounter := [ ] ;
57499: LD_ADDR_EXP 154
57503: PUSH
57504: EMPTY
57505: ST_TO_ADDR
// end ;
57506: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57507: LD_EXP 149
57511: PUSH
57512: LD_INT 34
57514: PUSH
57515: LD_EXP 75
57519: PUSH
57520: EMPTY
57521: LIST
57522: LIST
57523: PPUSH
57524: CALL_OW 69
57528: AND
57529: IFFALSE 57784
57531: GO 57533
57533: DISABLE
57534: LD_INT 0
57536: PPUSH
57537: PPUSH
// begin enable ;
57538: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57539: LD_ADDR_VAR 0 1
57543: PUSH
57544: LD_INT 34
57546: PUSH
57547: LD_EXP 75
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PPUSH
57556: CALL_OW 69
57560: PUSH
57561: FOR_IN
57562: IFFALSE 57782
// begin if not i in hackTanks then
57564: LD_VAR 0 1
57568: PUSH
57569: LD_EXP 150
57573: IN
57574: NOT
57575: IFFALSE 57658
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57577: LD_ADDR_EXP 150
57581: PUSH
57582: LD_EXP 150
57586: PPUSH
57587: LD_EXP 150
57591: PUSH
57592: LD_INT 1
57594: PLUS
57595: PPUSH
57596: LD_VAR 0 1
57600: PPUSH
57601: CALL_OW 1
57605: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57606: LD_ADDR_EXP 151
57610: PUSH
57611: LD_EXP 151
57615: PPUSH
57616: LD_EXP 151
57620: PUSH
57621: LD_INT 1
57623: PLUS
57624: PPUSH
57625: EMPTY
57626: PPUSH
57627: CALL_OW 1
57631: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57632: LD_ADDR_EXP 154
57636: PUSH
57637: LD_EXP 154
57641: PPUSH
57642: LD_EXP 154
57646: PUSH
57647: LD_INT 1
57649: PLUS
57650: PPUSH
57651: EMPTY
57652: PPUSH
57653: CALL_OW 1
57657: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57658: LD_VAR 0 1
57662: PPUSH
57663: CALL_OW 302
57667: NOT
57668: IFFALSE 57681
// begin HackUnlinkAll ( i ) ;
57670: LD_VAR 0 1
57674: PPUSH
57675: CALL 57787 0 1
// continue ;
57679: GO 57561
// end ; HackCheckCapturedStatus ( i ) ;
57681: LD_VAR 0 1
57685: PPUSH
57686: CALL 58230 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57690: LD_ADDR_VAR 0 2
57694: PUSH
57695: LD_INT 81
57697: PUSH
57698: LD_VAR 0 1
57702: PPUSH
57703: CALL_OW 255
57707: PUSH
57708: EMPTY
57709: LIST
57710: LIST
57711: PUSH
57712: LD_INT 33
57714: PUSH
57715: LD_INT 3
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: PUSH
57722: LD_INT 91
57724: PUSH
57725: LD_VAR 0 1
57729: PUSH
57730: LD_EXP 153
57734: PUSH
57735: EMPTY
57736: LIST
57737: LIST
57738: LIST
57739: PUSH
57740: LD_INT 50
57742: PUSH
57743: EMPTY
57744: LIST
57745: PUSH
57746: EMPTY
57747: LIST
57748: LIST
57749: LIST
57750: LIST
57751: PPUSH
57752: CALL_OW 69
57756: ST_TO_ADDR
// if not tmp then
57757: LD_VAR 0 2
57761: NOT
57762: IFFALSE 57766
// continue ;
57764: GO 57561
// HackLink ( i , tmp ) ;
57766: LD_VAR 0 1
57770: PPUSH
57771: LD_VAR 0 2
57775: PPUSH
57776: CALL 57923 0 2
// end ;
57780: GO 57561
57782: POP
57783: POP
// end ;
57784: PPOPN 2
57786: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57787: LD_INT 0
57789: PPUSH
57790: PPUSH
57791: PPUSH
// if not hack in hackTanks then
57792: LD_VAR 0 1
57796: PUSH
57797: LD_EXP 150
57801: IN
57802: NOT
57803: IFFALSE 57807
// exit ;
57805: GO 57918
// index := GetElementIndex ( hackTanks , hack ) ;
57807: LD_ADDR_VAR 0 4
57811: PUSH
57812: LD_EXP 150
57816: PPUSH
57817: LD_VAR 0 1
57821: PPUSH
57822: CALL 65392 0 2
57826: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57827: LD_EXP 151
57831: PUSH
57832: LD_VAR 0 4
57836: ARRAY
57837: IFFALSE 57918
// begin for i in hackTanksCaptured [ index ] do
57839: LD_ADDR_VAR 0 3
57843: PUSH
57844: LD_EXP 151
57848: PUSH
57849: LD_VAR 0 4
57853: ARRAY
57854: PUSH
57855: FOR_IN
57856: IFFALSE 57882
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57858: LD_VAR 0 3
57862: PUSH
57863: LD_INT 1
57865: ARRAY
57866: PPUSH
57867: LD_VAR 0 3
57871: PUSH
57872: LD_INT 2
57874: ARRAY
57875: PPUSH
57876: CALL_OW 235
57880: GO 57855
57882: POP
57883: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57884: LD_ADDR_EXP 151
57888: PUSH
57889: LD_EXP 151
57893: PPUSH
57894: LD_VAR 0 4
57898: PPUSH
57899: EMPTY
57900: PPUSH
57901: CALL_OW 1
57905: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57906: LD_VAR 0 1
57910: PPUSH
57911: LD_INT 0
57913: PPUSH
57914: CALL_OW 505
// end ; end ;
57918: LD_VAR 0 2
57922: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57923: LD_INT 0
57925: PPUSH
57926: PPUSH
57927: PPUSH
// if not hack in hackTanks or not vehicles then
57928: LD_VAR 0 1
57932: PUSH
57933: LD_EXP 150
57937: IN
57938: NOT
57939: PUSH
57940: LD_VAR 0 2
57944: NOT
57945: OR
57946: IFFALSE 57950
// exit ;
57948: GO 58225
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57950: LD_ADDR_VAR 0 2
57954: PUSH
57955: LD_VAR 0 1
57959: PPUSH
57960: LD_VAR 0 2
57964: PPUSH
57965: LD_INT 1
57967: PPUSH
57968: LD_INT 1
57970: PPUSH
57971: CALL 66042 0 4
57975: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57976: LD_ADDR_VAR 0 5
57980: PUSH
57981: LD_EXP 150
57985: PPUSH
57986: LD_VAR 0 1
57990: PPUSH
57991: CALL 65392 0 2
57995: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57996: LD_EXP 151
58000: PUSH
58001: LD_VAR 0 5
58005: ARRAY
58006: PUSH
58007: LD_EXP 152
58011: LESS
58012: IFFALSE 58201
// begin for i := 1 to vehicles do
58014: LD_ADDR_VAR 0 4
58018: PUSH
58019: DOUBLE
58020: LD_INT 1
58022: DEC
58023: ST_TO_ADDR
58024: LD_VAR 0 2
58028: PUSH
58029: FOR_TO
58030: IFFALSE 58199
// begin if hackTanksCaptured [ index ] = hackLimit then
58032: LD_EXP 151
58036: PUSH
58037: LD_VAR 0 5
58041: ARRAY
58042: PUSH
58043: LD_EXP 152
58047: EQUAL
58048: IFFALSE 58052
// break ;
58050: GO 58199
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
58052: LD_ADDR_EXP 154
58056: PUSH
58057: LD_EXP 154
58061: PPUSH
58062: LD_VAR 0 5
58066: PPUSH
58067: LD_EXP 154
58071: PUSH
58072: LD_VAR 0 5
58076: ARRAY
58077: PUSH
58078: LD_INT 1
58080: PLUS
58081: PPUSH
58082: CALL_OW 1
58086: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
58087: LD_ADDR_EXP 151
58091: PUSH
58092: LD_EXP 151
58096: PPUSH
58097: LD_VAR 0 5
58101: PUSH
58102: LD_EXP 151
58106: PUSH
58107: LD_VAR 0 5
58111: ARRAY
58112: PUSH
58113: LD_INT 1
58115: PLUS
58116: PUSH
58117: EMPTY
58118: LIST
58119: LIST
58120: PPUSH
58121: LD_VAR 0 2
58125: PUSH
58126: LD_VAR 0 4
58130: ARRAY
58131: PUSH
58132: LD_VAR 0 2
58136: PUSH
58137: LD_VAR 0 4
58141: ARRAY
58142: PPUSH
58143: CALL_OW 255
58147: PUSH
58148: EMPTY
58149: LIST
58150: LIST
58151: PPUSH
58152: CALL 65607 0 3
58156: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58157: LD_VAR 0 2
58161: PUSH
58162: LD_VAR 0 4
58166: ARRAY
58167: PPUSH
58168: LD_VAR 0 1
58172: PPUSH
58173: CALL_OW 255
58177: PPUSH
58178: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58182: LD_VAR 0 2
58186: PUSH
58187: LD_VAR 0 4
58191: ARRAY
58192: PPUSH
58193: CALL_OW 141
// end ;
58197: GO 58029
58199: POP
58200: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58201: LD_VAR 0 1
58205: PPUSH
58206: LD_EXP 151
58210: PUSH
58211: LD_VAR 0 5
58215: ARRAY
58216: PUSH
58217: LD_INT 0
58219: PLUS
58220: PPUSH
58221: CALL_OW 505
// end ;
58225: LD_VAR 0 3
58229: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58230: LD_INT 0
58232: PPUSH
58233: PPUSH
58234: PPUSH
58235: PPUSH
// if not hack in hackTanks then
58236: LD_VAR 0 1
58240: PUSH
58241: LD_EXP 150
58245: IN
58246: NOT
58247: IFFALSE 58251
// exit ;
58249: GO 58491
// index := GetElementIndex ( hackTanks , hack ) ;
58251: LD_ADDR_VAR 0 4
58255: PUSH
58256: LD_EXP 150
58260: PPUSH
58261: LD_VAR 0 1
58265: PPUSH
58266: CALL 65392 0 2
58270: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58271: LD_ADDR_VAR 0 3
58275: PUSH
58276: DOUBLE
58277: LD_EXP 151
58281: PUSH
58282: LD_VAR 0 4
58286: ARRAY
58287: INC
58288: ST_TO_ADDR
58289: LD_INT 1
58291: PUSH
58292: FOR_DOWNTO
58293: IFFALSE 58465
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58295: LD_ADDR_VAR 0 5
58299: PUSH
58300: LD_EXP 151
58304: PUSH
58305: LD_VAR 0 4
58309: ARRAY
58310: PUSH
58311: LD_VAR 0 3
58315: ARRAY
58316: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58317: LD_VAR 0 5
58321: PUSH
58322: LD_INT 1
58324: ARRAY
58325: PPUSH
58326: CALL_OW 302
58330: NOT
58331: PUSH
58332: LD_VAR 0 5
58336: PUSH
58337: LD_INT 1
58339: ARRAY
58340: PPUSH
58341: CALL_OW 255
58345: PUSH
58346: LD_VAR 0 1
58350: PPUSH
58351: CALL_OW 255
58355: NONEQUAL
58356: OR
58357: IFFALSE 58463
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58359: LD_VAR 0 5
58363: PUSH
58364: LD_INT 1
58366: ARRAY
58367: PPUSH
58368: CALL_OW 305
58372: PUSH
58373: LD_VAR 0 5
58377: PUSH
58378: LD_INT 1
58380: ARRAY
58381: PPUSH
58382: CALL_OW 255
58386: PUSH
58387: LD_VAR 0 1
58391: PPUSH
58392: CALL_OW 255
58396: EQUAL
58397: AND
58398: IFFALSE 58422
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58400: LD_VAR 0 5
58404: PUSH
58405: LD_INT 1
58407: ARRAY
58408: PPUSH
58409: LD_VAR 0 5
58413: PUSH
58414: LD_INT 2
58416: ARRAY
58417: PPUSH
58418: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58422: LD_ADDR_EXP 151
58426: PUSH
58427: LD_EXP 151
58431: PPUSH
58432: LD_VAR 0 4
58436: PPUSH
58437: LD_EXP 151
58441: PUSH
58442: LD_VAR 0 4
58446: ARRAY
58447: PPUSH
58448: LD_VAR 0 3
58452: PPUSH
58453: CALL_OW 3
58457: PPUSH
58458: CALL_OW 1
58462: ST_TO_ADDR
// end ; end ;
58463: GO 58292
58465: POP
58466: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58467: LD_VAR 0 1
58471: PPUSH
58472: LD_EXP 151
58476: PUSH
58477: LD_VAR 0 4
58481: ARRAY
58482: PUSH
58483: LD_INT 0
58485: PLUS
58486: PPUSH
58487: CALL_OW 505
// end ;
58491: LD_VAR 0 2
58495: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58496: LD_INT 0
58498: PPUSH
58499: PPUSH
58500: PPUSH
58501: PPUSH
// if not hack in hackTanks then
58502: LD_VAR 0 1
58506: PUSH
58507: LD_EXP 150
58511: IN
58512: NOT
58513: IFFALSE 58517
// exit ;
58515: GO 58602
// index := GetElementIndex ( hackTanks , hack ) ;
58517: LD_ADDR_VAR 0 5
58521: PUSH
58522: LD_EXP 150
58526: PPUSH
58527: LD_VAR 0 1
58531: PPUSH
58532: CALL 65392 0 2
58536: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58537: LD_ADDR_VAR 0 4
58541: PUSH
58542: DOUBLE
58543: LD_INT 1
58545: DEC
58546: ST_TO_ADDR
58547: LD_EXP 151
58551: PUSH
58552: LD_VAR 0 5
58556: ARRAY
58557: PUSH
58558: FOR_TO
58559: IFFALSE 58600
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58561: LD_EXP 151
58565: PUSH
58566: LD_VAR 0 5
58570: ARRAY
58571: PUSH
58572: LD_VAR 0 4
58576: ARRAY
58577: PUSH
58578: LD_INT 1
58580: ARRAY
58581: PUSH
58582: LD_VAR 0 2
58586: EQUAL
58587: IFFALSE 58598
// KillUnit ( vehicle ) ;
58589: LD_VAR 0 2
58593: PPUSH
58594: CALL_OW 66
58598: GO 58558
58600: POP
58601: POP
// end ;
58602: LD_VAR 0 3
58606: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58607: LD_EXP 155
58611: NOT
58612: IFFALSE 58647
58614: GO 58616
58616: DISABLE
// begin initMiner := true ;
58617: LD_ADDR_EXP 155
58621: PUSH
58622: LD_INT 1
58624: ST_TO_ADDR
// minersList := [ ] ;
58625: LD_ADDR_EXP 156
58629: PUSH
58630: EMPTY
58631: ST_TO_ADDR
// minerMinesList := [ ] ;
58632: LD_ADDR_EXP 157
58636: PUSH
58637: EMPTY
58638: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58639: LD_ADDR_EXP 158
58643: PUSH
58644: LD_INT 5
58646: ST_TO_ADDR
// end ;
58647: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58648: LD_EXP 155
58652: PUSH
58653: LD_INT 34
58655: PUSH
58656: LD_EXP 80
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: PPUSH
58665: CALL_OW 69
58669: AND
58670: IFFALSE 59133
58672: GO 58674
58674: DISABLE
58675: LD_INT 0
58677: PPUSH
58678: PPUSH
58679: PPUSH
58680: PPUSH
// begin enable ;
58681: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58682: LD_ADDR_VAR 0 1
58686: PUSH
58687: LD_INT 34
58689: PUSH
58690: LD_EXP 80
58694: PUSH
58695: EMPTY
58696: LIST
58697: LIST
58698: PPUSH
58699: CALL_OW 69
58703: PUSH
58704: FOR_IN
58705: IFFALSE 58777
// begin if not i in minersList then
58707: LD_VAR 0 1
58711: PUSH
58712: LD_EXP 156
58716: IN
58717: NOT
58718: IFFALSE 58775
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58720: LD_ADDR_EXP 156
58724: PUSH
58725: LD_EXP 156
58729: PPUSH
58730: LD_EXP 156
58734: PUSH
58735: LD_INT 1
58737: PLUS
58738: PPUSH
58739: LD_VAR 0 1
58743: PPUSH
58744: CALL_OW 1
58748: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58749: LD_ADDR_EXP 157
58753: PUSH
58754: LD_EXP 157
58758: PPUSH
58759: LD_EXP 157
58763: PUSH
58764: LD_INT 1
58766: PLUS
58767: PPUSH
58768: EMPTY
58769: PPUSH
58770: CALL_OW 1
58774: ST_TO_ADDR
// end end ;
58775: GO 58704
58777: POP
58778: POP
// for i := minerMinesList downto 1 do
58779: LD_ADDR_VAR 0 1
58783: PUSH
58784: DOUBLE
58785: LD_EXP 157
58789: INC
58790: ST_TO_ADDR
58791: LD_INT 1
58793: PUSH
58794: FOR_DOWNTO
58795: IFFALSE 59131
// begin if IsLive ( minersList [ i ] ) then
58797: LD_EXP 156
58801: PUSH
58802: LD_VAR 0 1
58806: ARRAY
58807: PPUSH
58808: CALL_OW 300
58812: IFFALSE 58840
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
58814: LD_EXP 156
58818: PUSH
58819: LD_VAR 0 1
58823: ARRAY
58824: PPUSH
58825: LD_EXP 157
58829: PUSH
58830: LD_VAR 0 1
58834: ARRAY
58835: PPUSH
58836: CALL_OW 505
// if not minerMinesList [ i ] then
58840: LD_EXP 157
58844: PUSH
58845: LD_VAR 0 1
58849: ARRAY
58850: NOT
58851: IFFALSE 58855
// continue ;
58853: GO 58794
// for j := minerMinesList [ i ] downto 1 do
58855: LD_ADDR_VAR 0 2
58859: PUSH
58860: DOUBLE
58861: LD_EXP 157
58865: PUSH
58866: LD_VAR 0 1
58870: ARRAY
58871: INC
58872: ST_TO_ADDR
58873: LD_INT 1
58875: PUSH
58876: FOR_DOWNTO
58877: IFFALSE 59127
// begin side := GetSide ( minersList [ i ] ) ;
58879: LD_ADDR_VAR 0 3
58883: PUSH
58884: LD_EXP 156
58888: PUSH
58889: LD_VAR 0 1
58893: ARRAY
58894: PPUSH
58895: CALL_OW 255
58899: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
58900: LD_ADDR_VAR 0 4
58904: PUSH
58905: LD_EXP 157
58909: PUSH
58910: LD_VAR 0 1
58914: ARRAY
58915: PUSH
58916: LD_VAR 0 2
58920: ARRAY
58921: PUSH
58922: LD_INT 1
58924: ARRAY
58925: PPUSH
58926: LD_EXP 157
58930: PUSH
58931: LD_VAR 0 1
58935: ARRAY
58936: PUSH
58937: LD_VAR 0 2
58941: ARRAY
58942: PUSH
58943: LD_INT 2
58945: ARRAY
58946: PPUSH
58947: CALL_OW 428
58951: ST_TO_ADDR
// if not tmp then
58952: LD_VAR 0 4
58956: NOT
58957: IFFALSE 58961
// continue ;
58959: GO 58876
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
58961: LD_VAR 0 4
58965: PUSH
58966: LD_INT 81
58968: PUSH
58969: LD_VAR 0 3
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: PPUSH
58978: CALL_OW 69
58982: IN
58983: PUSH
58984: LD_EXP 157
58988: PUSH
58989: LD_VAR 0 1
58993: ARRAY
58994: PUSH
58995: LD_VAR 0 2
58999: ARRAY
59000: PUSH
59001: LD_INT 1
59003: ARRAY
59004: PPUSH
59005: LD_EXP 157
59009: PUSH
59010: LD_VAR 0 1
59014: ARRAY
59015: PUSH
59016: LD_VAR 0 2
59020: ARRAY
59021: PUSH
59022: LD_INT 2
59024: ARRAY
59025: PPUSH
59026: CALL_OW 458
59030: AND
59031: IFFALSE 59125
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
59033: LD_EXP 157
59037: PUSH
59038: LD_VAR 0 1
59042: ARRAY
59043: PUSH
59044: LD_VAR 0 2
59048: ARRAY
59049: PUSH
59050: LD_INT 1
59052: ARRAY
59053: PPUSH
59054: LD_EXP 157
59058: PUSH
59059: LD_VAR 0 1
59063: ARRAY
59064: PUSH
59065: LD_VAR 0 2
59069: ARRAY
59070: PUSH
59071: LD_INT 2
59073: ARRAY
59074: PPUSH
59075: LD_VAR 0 3
59079: PPUSH
59080: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
59084: LD_ADDR_EXP 157
59088: PUSH
59089: LD_EXP 157
59093: PPUSH
59094: LD_VAR 0 1
59098: PPUSH
59099: LD_EXP 157
59103: PUSH
59104: LD_VAR 0 1
59108: ARRAY
59109: PPUSH
59110: LD_VAR 0 2
59114: PPUSH
59115: CALL_OW 3
59119: PPUSH
59120: CALL_OW 1
59124: ST_TO_ADDR
// end ; end ;
59125: GO 58876
59127: POP
59128: POP
// end ;
59129: GO 58794
59131: POP
59132: POP
// end ;
59133: PPOPN 4
59135: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59136: LD_INT 0
59138: PPUSH
59139: PPUSH
// result := false ;
59140: LD_ADDR_VAR 0 4
59144: PUSH
59145: LD_INT 0
59147: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59148: LD_VAR 0 1
59152: PPUSH
59153: CALL_OW 264
59157: PUSH
59158: LD_EXP 80
59162: EQUAL
59163: NOT
59164: IFFALSE 59168
// exit ;
59166: GO 59408
// index := GetElementIndex ( minersList , unit ) ;
59168: LD_ADDR_VAR 0 5
59172: PUSH
59173: LD_EXP 156
59177: PPUSH
59178: LD_VAR 0 1
59182: PPUSH
59183: CALL 65392 0 2
59187: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59188: LD_EXP 157
59192: PUSH
59193: LD_VAR 0 5
59197: ARRAY
59198: PUSH
59199: LD_EXP 158
59203: GREATEREQUAL
59204: IFFALSE 59208
// exit ;
59206: GO 59408
// ComMoveXY ( unit , x , y ) ;
59208: LD_VAR 0 1
59212: PPUSH
59213: LD_VAR 0 2
59217: PPUSH
59218: LD_VAR 0 3
59222: PPUSH
59223: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59227: LD_INT 35
59229: PPUSH
59230: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59234: LD_VAR 0 1
59238: PPUSH
59239: LD_VAR 0 2
59243: PPUSH
59244: LD_VAR 0 3
59248: PPUSH
59249: CALL 96165 0 3
59253: NOT
59254: PUSH
59255: LD_VAR 0 1
59259: PPUSH
59260: CALL_OW 314
59264: AND
59265: IFFALSE 59269
// exit ;
59267: GO 59408
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59269: LD_VAR 0 2
59273: PPUSH
59274: LD_VAR 0 3
59278: PPUSH
59279: CALL_OW 428
59283: PUSH
59284: LD_VAR 0 1
59288: EQUAL
59289: PUSH
59290: LD_VAR 0 1
59294: PPUSH
59295: CALL_OW 314
59299: NOT
59300: AND
59301: IFFALSE 59227
// PlaySoundXY ( x , y , PlantMine ) ;
59303: LD_VAR 0 2
59307: PPUSH
59308: LD_VAR 0 3
59312: PPUSH
59313: LD_STRING PlantMine
59315: PPUSH
59316: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59320: LD_VAR 0 2
59324: PPUSH
59325: LD_VAR 0 3
59329: PPUSH
59330: LD_VAR 0 1
59334: PPUSH
59335: CALL_OW 255
59339: PPUSH
59340: LD_INT 0
59342: PPUSH
59343: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59347: LD_ADDR_EXP 157
59351: PUSH
59352: LD_EXP 157
59356: PPUSH
59357: LD_VAR 0 5
59361: PUSH
59362: LD_EXP 157
59366: PUSH
59367: LD_VAR 0 5
59371: ARRAY
59372: PUSH
59373: LD_INT 1
59375: PLUS
59376: PUSH
59377: EMPTY
59378: LIST
59379: LIST
59380: PPUSH
59381: LD_VAR 0 2
59385: PUSH
59386: LD_VAR 0 3
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: PPUSH
59395: CALL 65607 0 3
59399: ST_TO_ADDR
// result := true ;
59400: LD_ADDR_VAR 0 4
59404: PUSH
59405: LD_INT 1
59407: ST_TO_ADDR
// end ;
59408: LD_VAR 0 4
59412: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59413: LD_INT 0
59415: PPUSH
59416: PPUSH
59417: PPUSH
// if not unit in minersList then
59418: LD_VAR 0 1
59422: PUSH
59423: LD_EXP 156
59427: IN
59428: NOT
59429: IFFALSE 59433
// exit ;
59431: GO 59825
// index := GetElementIndex ( minersList , unit ) ;
59433: LD_ADDR_VAR 0 6
59437: PUSH
59438: LD_EXP 156
59442: PPUSH
59443: LD_VAR 0 1
59447: PPUSH
59448: CALL 65392 0 2
59452: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59453: LD_ADDR_VAR 0 5
59457: PUSH
59458: DOUBLE
59459: LD_EXP 157
59463: PUSH
59464: LD_VAR 0 6
59468: ARRAY
59469: INC
59470: ST_TO_ADDR
59471: LD_INT 1
59473: PUSH
59474: FOR_DOWNTO
59475: IFFALSE 59636
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59477: LD_EXP 157
59481: PUSH
59482: LD_VAR 0 6
59486: ARRAY
59487: PUSH
59488: LD_VAR 0 5
59492: ARRAY
59493: PUSH
59494: LD_INT 1
59496: ARRAY
59497: PUSH
59498: LD_VAR 0 2
59502: EQUAL
59503: PUSH
59504: LD_EXP 157
59508: PUSH
59509: LD_VAR 0 6
59513: ARRAY
59514: PUSH
59515: LD_VAR 0 5
59519: ARRAY
59520: PUSH
59521: LD_INT 2
59523: ARRAY
59524: PUSH
59525: LD_VAR 0 3
59529: EQUAL
59530: AND
59531: IFFALSE 59634
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59533: LD_EXP 157
59537: PUSH
59538: LD_VAR 0 6
59542: ARRAY
59543: PUSH
59544: LD_VAR 0 5
59548: ARRAY
59549: PUSH
59550: LD_INT 1
59552: ARRAY
59553: PPUSH
59554: LD_EXP 157
59558: PUSH
59559: LD_VAR 0 6
59563: ARRAY
59564: PUSH
59565: LD_VAR 0 5
59569: ARRAY
59570: PUSH
59571: LD_INT 2
59573: ARRAY
59574: PPUSH
59575: LD_VAR 0 1
59579: PPUSH
59580: CALL_OW 255
59584: PPUSH
59585: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59589: LD_ADDR_EXP 157
59593: PUSH
59594: LD_EXP 157
59598: PPUSH
59599: LD_VAR 0 6
59603: PPUSH
59604: LD_EXP 157
59608: PUSH
59609: LD_VAR 0 6
59613: ARRAY
59614: PPUSH
59615: LD_VAR 0 5
59619: PPUSH
59620: CALL_OW 3
59624: PPUSH
59625: CALL_OW 1
59629: ST_TO_ADDR
// exit ;
59630: POP
59631: POP
59632: GO 59825
// end ; end ;
59634: GO 59474
59636: POP
59637: POP
// for i := minerMinesList [ index ] downto 1 do
59638: LD_ADDR_VAR 0 5
59642: PUSH
59643: DOUBLE
59644: LD_EXP 157
59648: PUSH
59649: LD_VAR 0 6
59653: ARRAY
59654: INC
59655: ST_TO_ADDR
59656: LD_INT 1
59658: PUSH
59659: FOR_DOWNTO
59660: IFFALSE 59823
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59662: LD_EXP 157
59666: PUSH
59667: LD_VAR 0 6
59671: ARRAY
59672: PUSH
59673: LD_VAR 0 5
59677: ARRAY
59678: PUSH
59679: LD_INT 1
59681: ARRAY
59682: PPUSH
59683: LD_EXP 157
59687: PUSH
59688: LD_VAR 0 6
59692: ARRAY
59693: PUSH
59694: LD_VAR 0 5
59698: ARRAY
59699: PUSH
59700: LD_INT 2
59702: ARRAY
59703: PPUSH
59704: LD_VAR 0 2
59708: PPUSH
59709: LD_VAR 0 3
59713: PPUSH
59714: CALL_OW 298
59718: PUSH
59719: LD_INT 6
59721: LESS
59722: IFFALSE 59821
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59724: LD_EXP 157
59728: PUSH
59729: LD_VAR 0 6
59733: ARRAY
59734: PUSH
59735: LD_VAR 0 5
59739: ARRAY
59740: PUSH
59741: LD_INT 1
59743: ARRAY
59744: PPUSH
59745: LD_EXP 157
59749: PUSH
59750: LD_VAR 0 6
59754: ARRAY
59755: PUSH
59756: LD_VAR 0 5
59760: ARRAY
59761: PUSH
59762: LD_INT 2
59764: ARRAY
59765: PPUSH
59766: LD_VAR 0 1
59770: PPUSH
59771: CALL_OW 255
59775: PPUSH
59776: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59780: LD_ADDR_EXP 157
59784: PUSH
59785: LD_EXP 157
59789: PPUSH
59790: LD_VAR 0 6
59794: PPUSH
59795: LD_EXP 157
59799: PUSH
59800: LD_VAR 0 6
59804: ARRAY
59805: PPUSH
59806: LD_VAR 0 5
59810: PPUSH
59811: CALL_OW 3
59815: PPUSH
59816: CALL_OW 1
59820: ST_TO_ADDR
// end ; end ;
59821: GO 59659
59823: POP
59824: POP
// end ;
59825: LD_VAR 0 4
59829: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
59830: LD_INT 0
59832: PPUSH
59833: PPUSH
59834: PPUSH
59835: PPUSH
59836: PPUSH
59837: PPUSH
59838: PPUSH
59839: PPUSH
59840: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
59841: LD_VAR 0 1
59845: PPUSH
59846: CALL_OW 264
59850: PUSH
59851: LD_EXP 80
59855: EQUAL
59856: NOT
59857: PUSH
59858: LD_VAR 0 1
59862: PUSH
59863: LD_EXP 156
59867: IN
59868: NOT
59869: OR
59870: IFFALSE 59874
// exit ;
59872: GO 60196
// index := GetElementIndex ( minersList , unit ) ;
59874: LD_ADDR_VAR 0 6
59878: PUSH
59879: LD_EXP 156
59883: PPUSH
59884: LD_VAR 0 1
59888: PPUSH
59889: CALL 65392 0 2
59893: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
59894: LD_ADDR_VAR 0 8
59898: PUSH
59899: LD_EXP 158
59903: PUSH
59904: LD_EXP 157
59908: PUSH
59909: LD_VAR 0 6
59913: ARRAY
59914: MINUS
59915: ST_TO_ADDR
// if not minesFreeAmount then
59916: LD_VAR 0 8
59920: NOT
59921: IFFALSE 59925
// exit ;
59923: GO 60196
// tmp := [ ] ;
59925: LD_ADDR_VAR 0 7
59929: PUSH
59930: EMPTY
59931: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
59932: LD_ADDR_VAR 0 5
59936: PUSH
59937: DOUBLE
59938: LD_INT 1
59940: DEC
59941: ST_TO_ADDR
59942: LD_VAR 0 8
59946: PUSH
59947: FOR_TO
59948: IFFALSE 60143
// begin _d := rand ( 0 , 5 ) ;
59950: LD_ADDR_VAR 0 11
59954: PUSH
59955: LD_INT 0
59957: PPUSH
59958: LD_INT 5
59960: PPUSH
59961: CALL_OW 12
59965: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
59966: LD_ADDR_VAR 0 12
59970: PUSH
59971: LD_INT 2
59973: PPUSH
59974: LD_INT 6
59976: PPUSH
59977: CALL_OW 12
59981: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
59982: LD_ADDR_VAR 0 9
59986: PUSH
59987: LD_VAR 0 2
59991: PPUSH
59992: LD_VAR 0 11
59996: PPUSH
59997: LD_VAR 0 12
60001: PPUSH
60002: CALL_OW 272
60006: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
60007: LD_ADDR_VAR 0 10
60011: PUSH
60012: LD_VAR 0 3
60016: PPUSH
60017: LD_VAR 0 11
60021: PPUSH
60022: LD_VAR 0 12
60026: PPUSH
60027: CALL_OW 273
60031: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
60032: LD_VAR 0 9
60036: PPUSH
60037: LD_VAR 0 10
60041: PPUSH
60042: CALL_OW 488
60046: PUSH
60047: LD_VAR 0 9
60051: PUSH
60052: LD_VAR 0 10
60056: PUSH
60057: EMPTY
60058: LIST
60059: LIST
60060: PUSH
60061: LD_VAR 0 7
60065: IN
60066: NOT
60067: AND
60068: PUSH
60069: LD_VAR 0 9
60073: PPUSH
60074: LD_VAR 0 10
60078: PPUSH
60079: CALL_OW 458
60083: NOT
60084: AND
60085: IFFALSE 60127
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
60087: LD_ADDR_VAR 0 7
60091: PUSH
60092: LD_VAR 0 7
60096: PPUSH
60097: LD_VAR 0 7
60101: PUSH
60102: LD_INT 1
60104: PLUS
60105: PPUSH
60106: LD_VAR 0 9
60110: PUSH
60111: LD_VAR 0 10
60115: PUSH
60116: EMPTY
60117: LIST
60118: LIST
60119: PPUSH
60120: CALL_OW 1
60124: ST_TO_ADDR
60125: GO 60141
// i := i - 1 ;
60127: LD_ADDR_VAR 0 5
60131: PUSH
60132: LD_VAR 0 5
60136: PUSH
60137: LD_INT 1
60139: MINUS
60140: ST_TO_ADDR
// end ;
60141: GO 59947
60143: POP
60144: POP
// for i in tmp do
60145: LD_ADDR_VAR 0 5
60149: PUSH
60150: LD_VAR 0 7
60154: PUSH
60155: FOR_IN
60156: IFFALSE 60194
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60158: LD_VAR 0 1
60162: PPUSH
60163: LD_VAR 0 5
60167: PUSH
60168: LD_INT 1
60170: ARRAY
60171: PPUSH
60172: LD_VAR 0 5
60176: PUSH
60177: LD_INT 2
60179: ARRAY
60180: PPUSH
60181: CALL 59136 0 3
60185: NOT
60186: IFFALSE 60192
// exit ;
60188: POP
60189: POP
60190: GO 60196
60192: GO 60155
60194: POP
60195: POP
// end ;
60196: LD_VAR 0 4
60200: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60201: LD_INT 0
60203: PPUSH
60204: PPUSH
60205: PPUSH
60206: PPUSH
60207: PPUSH
60208: PPUSH
60209: PPUSH
// if not GetClass ( unit ) = class_sniper then
60210: LD_VAR 0 1
60214: PPUSH
60215: CALL_OW 257
60219: PUSH
60220: LD_INT 5
60222: EQUAL
60223: NOT
60224: IFFALSE 60228
// exit ;
60226: GO 60616
// dist := 8 ;
60228: LD_ADDR_VAR 0 5
60232: PUSH
60233: LD_INT 8
60235: ST_TO_ADDR
// viewRange := 12 ;
60236: LD_ADDR_VAR 0 7
60240: PUSH
60241: LD_INT 12
60243: ST_TO_ADDR
// side := GetSide ( unit ) ;
60244: LD_ADDR_VAR 0 6
60248: PUSH
60249: LD_VAR 0 1
60253: PPUSH
60254: CALL_OW 255
60258: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60259: LD_INT 61
60261: PPUSH
60262: LD_VAR 0 6
60266: PPUSH
60267: CALL_OW 321
60271: PUSH
60272: LD_INT 2
60274: EQUAL
60275: IFFALSE 60285
// viewRange := 16 ;
60277: LD_ADDR_VAR 0 7
60281: PUSH
60282: LD_INT 16
60284: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60285: LD_VAR 0 1
60289: PPUSH
60290: LD_VAR 0 2
60294: PPUSH
60295: LD_VAR 0 3
60299: PPUSH
60300: CALL_OW 297
60304: PUSH
60305: LD_VAR 0 5
60309: GREATER
60310: IFFALSE 60389
// begin ComMoveXY ( unit , x , y ) ;
60312: LD_VAR 0 1
60316: PPUSH
60317: LD_VAR 0 2
60321: PPUSH
60322: LD_VAR 0 3
60326: PPUSH
60327: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60331: LD_INT 35
60333: PPUSH
60334: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60338: LD_VAR 0 1
60342: PPUSH
60343: LD_VAR 0 2
60347: PPUSH
60348: LD_VAR 0 3
60352: PPUSH
60353: CALL 96165 0 3
60357: NOT
60358: IFFALSE 60362
// exit ;
60360: GO 60616
// until GetDistUnitXY ( unit , x , y ) < dist ;
60362: LD_VAR 0 1
60366: PPUSH
60367: LD_VAR 0 2
60371: PPUSH
60372: LD_VAR 0 3
60376: PPUSH
60377: CALL_OW 297
60381: PUSH
60382: LD_VAR 0 5
60386: LESS
60387: IFFALSE 60331
// end ; ComTurnXY ( unit , x , y ) ;
60389: LD_VAR 0 1
60393: PPUSH
60394: LD_VAR 0 2
60398: PPUSH
60399: LD_VAR 0 3
60403: PPUSH
60404: CALL_OW 118
// wait ( 5 ) ;
60408: LD_INT 5
60410: PPUSH
60411: CALL_OW 67
// _d := GetDir ( unit ) ;
60415: LD_ADDR_VAR 0 10
60419: PUSH
60420: LD_VAR 0 1
60424: PPUSH
60425: CALL_OW 254
60429: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60430: LD_ADDR_VAR 0 8
60434: PUSH
60435: LD_VAR 0 1
60439: PPUSH
60440: CALL_OW 250
60444: PPUSH
60445: LD_VAR 0 10
60449: PPUSH
60450: LD_VAR 0 5
60454: PPUSH
60455: CALL_OW 272
60459: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60460: LD_ADDR_VAR 0 9
60464: PUSH
60465: LD_VAR 0 1
60469: PPUSH
60470: CALL_OW 251
60474: PPUSH
60475: LD_VAR 0 10
60479: PPUSH
60480: LD_VAR 0 5
60484: PPUSH
60485: CALL_OW 273
60489: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60490: LD_VAR 0 8
60494: PPUSH
60495: LD_VAR 0 9
60499: PPUSH
60500: CALL_OW 488
60504: NOT
60505: IFFALSE 60509
// exit ;
60507: GO 60616
// ComAnimCustom ( unit , 1 ) ;
60509: LD_VAR 0 1
60513: PPUSH
60514: LD_INT 1
60516: PPUSH
60517: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60521: LD_VAR 0 8
60525: PPUSH
60526: LD_VAR 0 9
60530: PPUSH
60531: LD_VAR 0 6
60535: PPUSH
60536: LD_VAR 0 7
60540: PPUSH
60541: CALL_OW 330
// repeat wait ( 1 ) ;
60545: LD_INT 1
60547: PPUSH
60548: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60552: LD_VAR 0 1
60556: PPUSH
60557: CALL_OW 316
60561: PUSH
60562: LD_VAR 0 1
60566: PPUSH
60567: CALL_OW 314
60571: OR
60572: PUSH
60573: LD_VAR 0 1
60577: PPUSH
60578: CALL_OW 302
60582: NOT
60583: OR
60584: PUSH
60585: LD_VAR 0 1
60589: PPUSH
60590: CALL_OW 301
60594: OR
60595: IFFALSE 60545
// RemoveSeeing ( _x , _y , side ) ;
60597: LD_VAR 0 8
60601: PPUSH
60602: LD_VAR 0 9
60606: PPUSH
60607: LD_VAR 0 6
60611: PPUSH
60612: CALL_OW 331
// end ; end_of_file
60616: LD_VAR 0 4
60620: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
60621: LD_INT 0
60623: PPUSH
60624: PPUSH
// if exist_mode then
60625: LD_VAR 0 2
60629: IFFALSE 60654
// unit := CreateCharacter ( prefix & ident ) else
60631: LD_ADDR_VAR 0 5
60635: PUSH
60636: LD_VAR 0 3
60640: PUSH
60641: LD_VAR 0 1
60645: STR
60646: PPUSH
60647: CALL_OW 34
60651: ST_TO_ADDR
60652: GO 60669
// unit := NewCharacter ( ident ) ;
60654: LD_ADDR_VAR 0 5
60658: PUSH
60659: LD_VAR 0 1
60663: PPUSH
60664: CALL_OW 25
60668: ST_TO_ADDR
// result := unit ;
60669: LD_ADDR_VAR 0 4
60673: PUSH
60674: LD_VAR 0 5
60678: ST_TO_ADDR
// end ;
60679: LD_VAR 0 4
60683: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
60684: LD_INT 0
60686: PPUSH
60687: PPUSH
// if not side or not nation then
60688: LD_VAR 0 1
60692: NOT
60693: PUSH
60694: LD_VAR 0 2
60698: NOT
60699: OR
60700: IFFALSE 60704
// exit ;
60702: GO 61472
// case nation of nation_american :
60704: LD_VAR 0 2
60708: PUSH
60709: LD_INT 1
60711: DOUBLE
60712: EQUAL
60713: IFTRUE 60717
60715: GO 60931
60717: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
60718: LD_ADDR_VAR 0 4
60722: PUSH
60723: LD_INT 35
60725: PUSH
60726: LD_INT 45
60728: PUSH
60729: LD_INT 46
60731: PUSH
60732: LD_INT 47
60734: PUSH
60735: LD_INT 82
60737: PUSH
60738: LD_INT 83
60740: PUSH
60741: LD_INT 84
60743: PUSH
60744: LD_INT 85
60746: PUSH
60747: LD_INT 86
60749: PUSH
60750: LD_INT 1
60752: PUSH
60753: LD_INT 2
60755: PUSH
60756: LD_INT 6
60758: PUSH
60759: LD_INT 15
60761: PUSH
60762: LD_INT 16
60764: PUSH
60765: LD_INT 7
60767: PUSH
60768: LD_INT 12
60770: PUSH
60771: LD_INT 13
60773: PUSH
60774: LD_INT 10
60776: PUSH
60777: LD_INT 14
60779: PUSH
60780: LD_INT 20
60782: PUSH
60783: LD_INT 21
60785: PUSH
60786: LD_INT 22
60788: PUSH
60789: LD_INT 25
60791: PUSH
60792: LD_INT 32
60794: PUSH
60795: LD_INT 27
60797: PUSH
60798: LD_INT 36
60800: PUSH
60801: LD_INT 69
60803: PUSH
60804: LD_INT 39
60806: PUSH
60807: LD_INT 34
60809: PUSH
60810: LD_INT 40
60812: PUSH
60813: LD_INT 48
60815: PUSH
60816: LD_INT 49
60818: PUSH
60819: LD_INT 50
60821: PUSH
60822: LD_INT 51
60824: PUSH
60825: LD_INT 52
60827: PUSH
60828: LD_INT 53
60830: PUSH
60831: LD_INT 54
60833: PUSH
60834: LD_INT 55
60836: PUSH
60837: LD_INT 56
60839: PUSH
60840: LD_INT 57
60842: PUSH
60843: LD_INT 58
60845: PUSH
60846: LD_INT 59
60848: PUSH
60849: LD_INT 60
60851: PUSH
60852: LD_INT 61
60854: PUSH
60855: LD_INT 62
60857: PUSH
60858: LD_INT 80
60860: PUSH
60861: LD_INT 82
60863: PUSH
60864: LD_INT 83
60866: PUSH
60867: LD_INT 84
60869: PUSH
60870: LD_INT 85
60872: PUSH
60873: LD_INT 86
60875: PUSH
60876: EMPTY
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: LIST
60889: LIST
60890: LIST
60891: LIST
60892: LIST
60893: LIST
60894: LIST
60895: LIST
60896: LIST
60897: LIST
60898: LIST
60899: LIST
60900: LIST
60901: LIST
60902: LIST
60903: LIST
60904: LIST
60905: LIST
60906: LIST
60907: LIST
60908: LIST
60909: LIST
60910: LIST
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: LIST
60922: LIST
60923: LIST
60924: LIST
60925: LIST
60926: LIST
60927: LIST
60928: ST_TO_ADDR
60929: GO 61396
60931: LD_INT 2
60933: DOUBLE
60934: EQUAL
60935: IFTRUE 60939
60937: GO 61165
60939: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
60940: LD_ADDR_VAR 0 4
60944: PUSH
60945: LD_INT 35
60947: PUSH
60948: LD_INT 45
60950: PUSH
60951: LD_INT 46
60953: PUSH
60954: LD_INT 47
60956: PUSH
60957: LD_INT 82
60959: PUSH
60960: LD_INT 83
60962: PUSH
60963: LD_INT 84
60965: PUSH
60966: LD_INT 85
60968: PUSH
60969: LD_INT 87
60971: PUSH
60972: LD_INT 70
60974: PUSH
60975: LD_INT 1
60977: PUSH
60978: LD_INT 11
60980: PUSH
60981: LD_INT 3
60983: PUSH
60984: LD_INT 4
60986: PUSH
60987: LD_INT 5
60989: PUSH
60990: LD_INT 6
60992: PUSH
60993: LD_INT 15
60995: PUSH
60996: LD_INT 18
60998: PUSH
60999: LD_INT 7
61001: PUSH
61002: LD_INT 17
61004: PUSH
61005: LD_INT 8
61007: PUSH
61008: LD_INT 20
61010: PUSH
61011: LD_INT 21
61013: PUSH
61014: LD_INT 22
61016: PUSH
61017: LD_INT 72
61019: PUSH
61020: LD_INT 26
61022: PUSH
61023: LD_INT 69
61025: PUSH
61026: LD_INT 39
61028: PUSH
61029: LD_INT 40
61031: PUSH
61032: LD_INT 41
61034: PUSH
61035: LD_INT 42
61037: PUSH
61038: LD_INT 43
61040: PUSH
61041: LD_INT 48
61043: PUSH
61044: LD_INT 49
61046: PUSH
61047: LD_INT 50
61049: PUSH
61050: LD_INT 51
61052: PUSH
61053: LD_INT 52
61055: PUSH
61056: LD_INT 53
61058: PUSH
61059: LD_INT 54
61061: PUSH
61062: LD_INT 55
61064: PUSH
61065: LD_INT 56
61067: PUSH
61068: LD_INT 60
61070: PUSH
61071: LD_INT 61
61073: PUSH
61074: LD_INT 62
61076: PUSH
61077: LD_INT 66
61079: PUSH
61080: LD_INT 67
61082: PUSH
61083: LD_INT 68
61085: PUSH
61086: LD_INT 81
61088: PUSH
61089: LD_INT 82
61091: PUSH
61092: LD_INT 83
61094: PUSH
61095: LD_INT 84
61097: PUSH
61098: LD_INT 85
61100: PUSH
61101: LD_INT 87
61103: PUSH
61104: LD_INT 88
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: LIST
61124: LIST
61125: LIST
61126: LIST
61127: LIST
61128: LIST
61129: LIST
61130: LIST
61131: LIST
61132: LIST
61133: LIST
61134: LIST
61135: LIST
61136: LIST
61137: LIST
61138: LIST
61139: LIST
61140: LIST
61141: LIST
61142: LIST
61143: LIST
61144: LIST
61145: LIST
61146: LIST
61147: LIST
61148: LIST
61149: LIST
61150: LIST
61151: LIST
61152: LIST
61153: LIST
61154: LIST
61155: LIST
61156: LIST
61157: LIST
61158: LIST
61159: LIST
61160: LIST
61161: LIST
61162: ST_TO_ADDR
61163: GO 61396
61165: LD_INT 3
61167: DOUBLE
61168: EQUAL
61169: IFTRUE 61173
61171: GO 61395
61173: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61174: LD_ADDR_VAR 0 4
61178: PUSH
61179: LD_INT 46
61181: PUSH
61182: LD_INT 47
61184: PUSH
61185: LD_INT 1
61187: PUSH
61188: LD_INT 2
61190: PUSH
61191: LD_INT 82
61193: PUSH
61194: LD_INT 83
61196: PUSH
61197: LD_INT 84
61199: PUSH
61200: LD_INT 85
61202: PUSH
61203: LD_INT 86
61205: PUSH
61206: LD_INT 11
61208: PUSH
61209: LD_INT 9
61211: PUSH
61212: LD_INT 20
61214: PUSH
61215: LD_INT 19
61217: PUSH
61218: LD_INT 21
61220: PUSH
61221: LD_INT 24
61223: PUSH
61224: LD_INT 22
61226: PUSH
61227: LD_INT 25
61229: PUSH
61230: LD_INT 28
61232: PUSH
61233: LD_INT 29
61235: PUSH
61236: LD_INT 30
61238: PUSH
61239: LD_INT 31
61241: PUSH
61242: LD_INT 37
61244: PUSH
61245: LD_INT 38
61247: PUSH
61248: LD_INT 32
61250: PUSH
61251: LD_INT 27
61253: PUSH
61254: LD_INT 33
61256: PUSH
61257: LD_INT 69
61259: PUSH
61260: LD_INT 39
61262: PUSH
61263: LD_INT 34
61265: PUSH
61266: LD_INT 40
61268: PUSH
61269: LD_INT 71
61271: PUSH
61272: LD_INT 23
61274: PUSH
61275: LD_INT 44
61277: PUSH
61278: LD_INT 48
61280: PUSH
61281: LD_INT 49
61283: PUSH
61284: LD_INT 50
61286: PUSH
61287: LD_INT 51
61289: PUSH
61290: LD_INT 52
61292: PUSH
61293: LD_INT 53
61295: PUSH
61296: LD_INT 54
61298: PUSH
61299: LD_INT 55
61301: PUSH
61302: LD_INT 56
61304: PUSH
61305: LD_INT 57
61307: PUSH
61308: LD_INT 58
61310: PUSH
61311: LD_INT 59
61313: PUSH
61314: LD_INT 63
61316: PUSH
61317: LD_INT 64
61319: PUSH
61320: LD_INT 65
61322: PUSH
61323: LD_INT 82
61325: PUSH
61326: LD_INT 83
61328: PUSH
61329: LD_INT 84
61331: PUSH
61332: LD_INT 85
61334: PUSH
61335: LD_INT 86
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: LIST
61347: LIST
61348: LIST
61349: LIST
61350: LIST
61351: LIST
61352: LIST
61353: LIST
61354: LIST
61355: LIST
61356: LIST
61357: LIST
61358: LIST
61359: LIST
61360: LIST
61361: LIST
61362: LIST
61363: LIST
61364: LIST
61365: LIST
61366: LIST
61367: LIST
61368: LIST
61369: LIST
61370: LIST
61371: LIST
61372: LIST
61373: LIST
61374: LIST
61375: LIST
61376: LIST
61377: LIST
61378: LIST
61379: LIST
61380: LIST
61381: LIST
61382: LIST
61383: LIST
61384: LIST
61385: LIST
61386: LIST
61387: LIST
61388: LIST
61389: LIST
61390: LIST
61391: LIST
61392: ST_TO_ADDR
61393: GO 61396
61395: POP
// if state > - 1 and state < 3 then
61396: LD_VAR 0 3
61400: PUSH
61401: LD_INT 1
61403: NEG
61404: GREATER
61405: PUSH
61406: LD_VAR 0 3
61410: PUSH
61411: LD_INT 3
61413: LESS
61414: AND
61415: IFFALSE 61472
// for i in result do
61417: LD_ADDR_VAR 0 5
61421: PUSH
61422: LD_VAR 0 4
61426: PUSH
61427: FOR_IN
61428: IFFALSE 61470
// if GetTech ( i , side ) <> state then
61430: LD_VAR 0 5
61434: PPUSH
61435: LD_VAR 0 1
61439: PPUSH
61440: CALL_OW 321
61444: PUSH
61445: LD_VAR 0 3
61449: NONEQUAL
61450: IFFALSE 61468
// result := result diff i ;
61452: LD_ADDR_VAR 0 4
61456: PUSH
61457: LD_VAR 0 4
61461: PUSH
61462: LD_VAR 0 5
61466: DIFF
61467: ST_TO_ADDR
61468: GO 61427
61470: POP
61471: POP
// end ;
61472: LD_VAR 0 4
61476: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
61477: LD_INT 0
61479: PPUSH
61480: PPUSH
61481: PPUSH
// result := true ;
61482: LD_ADDR_VAR 0 3
61486: PUSH
61487: LD_INT 1
61489: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
61490: LD_ADDR_VAR 0 5
61494: PUSH
61495: LD_VAR 0 2
61499: PPUSH
61500: CALL_OW 480
61504: ST_TO_ADDR
// if not tmp then
61505: LD_VAR 0 5
61509: NOT
61510: IFFALSE 61514
// exit ;
61512: GO 61563
// for i in tmp do
61514: LD_ADDR_VAR 0 4
61518: PUSH
61519: LD_VAR 0 5
61523: PUSH
61524: FOR_IN
61525: IFFALSE 61561
// if GetTech ( i , side ) <> state_researched then
61527: LD_VAR 0 4
61531: PPUSH
61532: LD_VAR 0 1
61536: PPUSH
61537: CALL_OW 321
61541: PUSH
61542: LD_INT 2
61544: NONEQUAL
61545: IFFALSE 61559
// begin result := false ;
61547: LD_ADDR_VAR 0 3
61551: PUSH
61552: LD_INT 0
61554: ST_TO_ADDR
// exit ;
61555: POP
61556: POP
61557: GO 61563
// end ;
61559: GO 61524
61561: POP
61562: POP
// end ;
61563: LD_VAR 0 3
61567: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
61568: LD_INT 0
61570: PPUSH
61571: PPUSH
61572: PPUSH
61573: PPUSH
61574: PPUSH
61575: PPUSH
61576: PPUSH
61577: PPUSH
61578: PPUSH
61579: PPUSH
61580: PPUSH
61581: PPUSH
61582: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
61583: LD_VAR 0 1
61587: NOT
61588: PUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: CALL_OW 257
61598: PUSH
61599: LD_INT 9
61601: NONEQUAL
61602: OR
61603: IFFALSE 61607
// exit ;
61605: GO 62180
// side := GetSide ( unit ) ;
61607: LD_ADDR_VAR 0 9
61611: PUSH
61612: LD_VAR 0 1
61616: PPUSH
61617: CALL_OW 255
61621: ST_TO_ADDR
// tech_space := tech_spacanom ;
61622: LD_ADDR_VAR 0 12
61626: PUSH
61627: LD_INT 29
61629: ST_TO_ADDR
// tech_time := tech_taurad ;
61630: LD_ADDR_VAR 0 13
61634: PUSH
61635: LD_INT 28
61637: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
61638: LD_ADDR_VAR 0 11
61642: PUSH
61643: LD_VAR 0 1
61647: PPUSH
61648: CALL_OW 310
61652: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
61653: LD_VAR 0 11
61657: PPUSH
61658: CALL_OW 247
61662: PUSH
61663: LD_INT 2
61665: EQUAL
61666: IFFALSE 61670
// exit ;
61668: GO 62180
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61670: LD_ADDR_VAR 0 8
61674: PUSH
61675: LD_INT 81
61677: PUSH
61678: LD_VAR 0 9
61682: PUSH
61683: EMPTY
61684: LIST
61685: LIST
61686: PUSH
61687: LD_INT 3
61689: PUSH
61690: LD_INT 21
61692: PUSH
61693: LD_INT 3
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PPUSH
61708: CALL_OW 69
61712: ST_TO_ADDR
// if not tmp then
61713: LD_VAR 0 8
61717: NOT
61718: IFFALSE 61722
// exit ;
61720: GO 62180
// if in_unit then
61722: LD_VAR 0 11
61726: IFFALSE 61750
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
61728: LD_ADDR_VAR 0 10
61732: PUSH
61733: LD_VAR 0 8
61737: PPUSH
61738: LD_VAR 0 11
61742: PPUSH
61743: CALL_OW 74
61747: ST_TO_ADDR
61748: GO 61770
// enemy := NearestUnitToUnit ( tmp , unit ) ;
61750: LD_ADDR_VAR 0 10
61754: PUSH
61755: LD_VAR 0 8
61759: PPUSH
61760: LD_VAR 0 1
61764: PPUSH
61765: CALL_OW 74
61769: ST_TO_ADDR
// if not enemy then
61770: LD_VAR 0 10
61774: NOT
61775: IFFALSE 61779
// exit ;
61777: GO 62180
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
61779: LD_VAR 0 11
61783: PUSH
61784: LD_VAR 0 11
61788: PPUSH
61789: LD_VAR 0 10
61793: PPUSH
61794: CALL_OW 296
61798: PUSH
61799: LD_INT 13
61801: GREATER
61802: AND
61803: PUSH
61804: LD_VAR 0 1
61808: PPUSH
61809: LD_VAR 0 10
61813: PPUSH
61814: CALL_OW 296
61818: PUSH
61819: LD_INT 12
61821: GREATER
61822: OR
61823: IFFALSE 61827
// exit ;
61825: GO 62180
// missile := [ 1 ] ;
61827: LD_ADDR_VAR 0 14
61831: PUSH
61832: LD_INT 1
61834: PUSH
61835: EMPTY
61836: LIST
61837: ST_TO_ADDR
// if Researched ( side , tech_space ) then
61838: LD_VAR 0 9
61842: PPUSH
61843: LD_VAR 0 12
61847: PPUSH
61848: CALL_OW 325
61852: IFFALSE 61881
// missile := Insert ( missile , missile + 1 , 2 ) ;
61854: LD_ADDR_VAR 0 14
61858: PUSH
61859: LD_VAR 0 14
61863: PPUSH
61864: LD_VAR 0 14
61868: PUSH
61869: LD_INT 1
61871: PLUS
61872: PPUSH
61873: LD_INT 2
61875: PPUSH
61876: CALL_OW 2
61880: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
61881: LD_VAR 0 9
61885: PPUSH
61886: LD_VAR 0 13
61890: PPUSH
61891: CALL_OW 325
61895: PUSH
61896: LD_VAR 0 10
61900: PPUSH
61901: CALL_OW 255
61905: PPUSH
61906: LD_VAR 0 13
61910: PPUSH
61911: CALL_OW 325
61915: NOT
61916: AND
61917: IFFALSE 61946
// missile := Insert ( missile , missile + 1 , 3 ) ;
61919: LD_ADDR_VAR 0 14
61923: PUSH
61924: LD_VAR 0 14
61928: PPUSH
61929: LD_VAR 0 14
61933: PUSH
61934: LD_INT 1
61936: PLUS
61937: PPUSH
61938: LD_INT 3
61940: PPUSH
61941: CALL_OW 2
61945: ST_TO_ADDR
// if missile < 2 then
61946: LD_VAR 0 14
61950: PUSH
61951: LD_INT 2
61953: LESS
61954: IFFALSE 61958
// exit ;
61956: GO 62180
// x := GetX ( enemy ) ;
61958: LD_ADDR_VAR 0 4
61962: PUSH
61963: LD_VAR 0 10
61967: PPUSH
61968: CALL_OW 250
61972: ST_TO_ADDR
// y := GetY ( enemy ) ;
61973: LD_ADDR_VAR 0 5
61977: PUSH
61978: LD_VAR 0 10
61982: PPUSH
61983: CALL_OW 251
61987: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
61988: LD_ADDR_VAR 0 6
61992: PUSH
61993: LD_VAR 0 4
61997: PUSH
61998: LD_INT 1
62000: NEG
62001: PPUSH
62002: LD_INT 1
62004: PPUSH
62005: CALL_OW 12
62009: PLUS
62010: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
62011: LD_ADDR_VAR 0 7
62015: PUSH
62016: LD_VAR 0 5
62020: PUSH
62021: LD_INT 1
62023: NEG
62024: PPUSH
62025: LD_INT 1
62027: PPUSH
62028: CALL_OW 12
62032: PLUS
62033: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62034: LD_VAR 0 6
62038: PPUSH
62039: LD_VAR 0 7
62043: PPUSH
62044: CALL_OW 488
62048: NOT
62049: IFFALSE 62071
// begin _x := x ;
62051: LD_ADDR_VAR 0 6
62055: PUSH
62056: LD_VAR 0 4
62060: ST_TO_ADDR
// _y := y ;
62061: LD_ADDR_VAR 0 7
62065: PUSH
62066: LD_VAR 0 5
62070: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
62071: LD_ADDR_VAR 0 3
62075: PUSH
62076: LD_INT 1
62078: PPUSH
62079: LD_VAR 0 14
62083: PPUSH
62084: CALL_OW 12
62088: ST_TO_ADDR
// case i of 1 :
62089: LD_VAR 0 3
62093: PUSH
62094: LD_INT 1
62096: DOUBLE
62097: EQUAL
62098: IFTRUE 62102
62100: GO 62119
62102: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
62103: LD_VAR 0 1
62107: PPUSH
62108: LD_VAR 0 10
62112: PPUSH
62113: CALL_OW 115
62117: GO 62180
62119: LD_INT 2
62121: DOUBLE
62122: EQUAL
62123: IFTRUE 62127
62125: GO 62149
62127: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62128: LD_VAR 0 1
62132: PPUSH
62133: LD_VAR 0 6
62137: PPUSH
62138: LD_VAR 0 7
62142: PPUSH
62143: CALL_OW 153
62147: GO 62180
62149: LD_INT 3
62151: DOUBLE
62152: EQUAL
62153: IFTRUE 62157
62155: GO 62179
62157: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62158: LD_VAR 0 1
62162: PPUSH
62163: LD_VAR 0 6
62167: PPUSH
62168: LD_VAR 0 7
62172: PPUSH
62173: CALL_OW 154
62177: GO 62180
62179: POP
// end ;
62180: LD_VAR 0 2
62184: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62185: LD_INT 0
62187: PPUSH
62188: PPUSH
62189: PPUSH
62190: PPUSH
62191: PPUSH
62192: PPUSH
// if not unit or not building then
62193: LD_VAR 0 1
62197: NOT
62198: PUSH
62199: LD_VAR 0 2
62203: NOT
62204: OR
62205: IFFALSE 62209
// exit ;
62207: GO 62367
// x := GetX ( building ) ;
62209: LD_ADDR_VAR 0 5
62213: PUSH
62214: LD_VAR 0 2
62218: PPUSH
62219: CALL_OW 250
62223: ST_TO_ADDR
// y := GetY ( building ) ;
62224: LD_ADDR_VAR 0 6
62228: PUSH
62229: LD_VAR 0 2
62233: PPUSH
62234: CALL_OW 251
62238: ST_TO_ADDR
// for i = 0 to 5 do
62239: LD_ADDR_VAR 0 4
62243: PUSH
62244: DOUBLE
62245: LD_INT 0
62247: DEC
62248: ST_TO_ADDR
62249: LD_INT 5
62251: PUSH
62252: FOR_TO
62253: IFFALSE 62365
// begin _x := ShiftX ( x , i , 3 ) ;
62255: LD_ADDR_VAR 0 7
62259: PUSH
62260: LD_VAR 0 5
62264: PPUSH
62265: LD_VAR 0 4
62269: PPUSH
62270: LD_INT 3
62272: PPUSH
62273: CALL_OW 272
62277: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62278: LD_ADDR_VAR 0 8
62282: PUSH
62283: LD_VAR 0 6
62287: PPUSH
62288: LD_VAR 0 4
62292: PPUSH
62293: LD_INT 3
62295: PPUSH
62296: CALL_OW 273
62300: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62301: LD_VAR 0 7
62305: PPUSH
62306: LD_VAR 0 8
62310: PPUSH
62311: CALL_OW 488
62315: NOT
62316: IFFALSE 62320
// continue ;
62318: GO 62252
// if HexInfo ( _x , _y ) = 0 then
62320: LD_VAR 0 7
62324: PPUSH
62325: LD_VAR 0 8
62329: PPUSH
62330: CALL_OW 428
62334: PUSH
62335: LD_INT 0
62337: EQUAL
62338: IFFALSE 62363
// begin ComMoveXY ( unit , _x , _y ) ;
62340: LD_VAR 0 1
62344: PPUSH
62345: LD_VAR 0 7
62349: PPUSH
62350: LD_VAR 0 8
62354: PPUSH
62355: CALL_OW 111
// exit ;
62359: POP
62360: POP
62361: GO 62367
// end ; end ;
62363: GO 62252
62365: POP
62366: POP
// end ;
62367: LD_VAR 0 3
62371: RET
// export function ScanBase ( side , base_area ) ; begin
62372: LD_INT 0
62374: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62375: LD_ADDR_VAR 0 3
62379: PUSH
62380: LD_VAR 0 2
62384: PPUSH
62385: LD_INT 81
62387: PUSH
62388: LD_VAR 0 1
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: PPUSH
62397: CALL_OW 70
62401: ST_TO_ADDR
// end ;
62402: LD_VAR 0 3
62406: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
62407: LD_INT 0
62409: PPUSH
62410: PPUSH
62411: PPUSH
62412: PPUSH
// result := false ;
62413: LD_ADDR_VAR 0 2
62417: PUSH
62418: LD_INT 0
62420: ST_TO_ADDR
// side := GetSide ( unit ) ;
62421: LD_ADDR_VAR 0 3
62425: PUSH
62426: LD_VAR 0 1
62430: PPUSH
62431: CALL_OW 255
62435: ST_TO_ADDR
// nat := GetNation ( unit ) ;
62436: LD_ADDR_VAR 0 4
62440: PUSH
62441: LD_VAR 0 1
62445: PPUSH
62446: CALL_OW 248
62450: ST_TO_ADDR
// case nat of 1 :
62451: LD_VAR 0 4
62455: PUSH
62456: LD_INT 1
62458: DOUBLE
62459: EQUAL
62460: IFTRUE 62464
62462: GO 62475
62464: POP
// tech := tech_lassight ; 2 :
62465: LD_ADDR_VAR 0 5
62469: PUSH
62470: LD_INT 12
62472: ST_TO_ADDR
62473: GO 62514
62475: LD_INT 2
62477: DOUBLE
62478: EQUAL
62479: IFTRUE 62483
62481: GO 62494
62483: POP
// tech := tech_mortar ; 3 :
62484: LD_ADDR_VAR 0 5
62488: PUSH
62489: LD_INT 41
62491: ST_TO_ADDR
62492: GO 62514
62494: LD_INT 3
62496: DOUBLE
62497: EQUAL
62498: IFTRUE 62502
62500: GO 62513
62502: POP
// tech := tech_bazooka ; end ;
62503: LD_ADDR_VAR 0 5
62507: PUSH
62508: LD_INT 44
62510: ST_TO_ADDR
62511: GO 62514
62513: POP
// if Researched ( side , tech ) then
62514: LD_VAR 0 3
62518: PPUSH
62519: LD_VAR 0 5
62523: PPUSH
62524: CALL_OW 325
62528: IFFALSE 62555
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
62530: LD_ADDR_VAR 0 2
62534: PUSH
62535: LD_INT 5
62537: PUSH
62538: LD_INT 8
62540: PUSH
62541: LD_INT 9
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: LIST
62548: PUSH
62549: LD_VAR 0 4
62553: ARRAY
62554: ST_TO_ADDR
// end ;
62555: LD_VAR 0 2
62559: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
62560: LD_INT 0
62562: PPUSH
62563: PPUSH
62564: PPUSH
// if not mines then
62565: LD_VAR 0 2
62569: NOT
62570: IFFALSE 62574
// exit ;
62572: GO 62718
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62574: LD_ADDR_VAR 0 5
62578: PUSH
62579: LD_INT 81
62581: PUSH
62582: LD_VAR 0 1
62586: PUSH
62587: EMPTY
62588: LIST
62589: LIST
62590: PUSH
62591: LD_INT 3
62593: PUSH
62594: LD_INT 21
62596: PUSH
62597: LD_INT 3
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: PPUSH
62612: CALL_OW 69
62616: ST_TO_ADDR
// for i in mines do
62617: LD_ADDR_VAR 0 4
62621: PUSH
62622: LD_VAR 0 2
62626: PUSH
62627: FOR_IN
62628: IFFALSE 62716
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
62630: LD_VAR 0 4
62634: PUSH
62635: LD_INT 1
62637: ARRAY
62638: PPUSH
62639: LD_VAR 0 4
62643: PUSH
62644: LD_INT 2
62646: ARRAY
62647: PPUSH
62648: CALL_OW 458
62652: NOT
62653: IFFALSE 62657
// continue ;
62655: GO 62627
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
62657: LD_VAR 0 4
62661: PUSH
62662: LD_INT 1
62664: ARRAY
62665: PPUSH
62666: LD_VAR 0 4
62670: PUSH
62671: LD_INT 2
62673: ARRAY
62674: PPUSH
62675: CALL_OW 428
62679: PUSH
62680: LD_VAR 0 5
62684: IN
62685: IFFALSE 62714
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
62687: LD_VAR 0 4
62691: PUSH
62692: LD_INT 1
62694: ARRAY
62695: PPUSH
62696: LD_VAR 0 4
62700: PUSH
62701: LD_INT 2
62703: ARRAY
62704: PPUSH
62705: LD_VAR 0 1
62709: PPUSH
62710: CALL_OW 456
// end ;
62714: GO 62627
62716: POP
62717: POP
// end ;
62718: LD_VAR 0 3
62722: RET
// export function Count ( array ) ; var i ; begin
62723: LD_INT 0
62725: PPUSH
62726: PPUSH
// result := 0 ;
62727: LD_ADDR_VAR 0 2
62731: PUSH
62732: LD_INT 0
62734: ST_TO_ADDR
// for i in array do
62735: LD_ADDR_VAR 0 3
62739: PUSH
62740: LD_VAR 0 1
62744: PUSH
62745: FOR_IN
62746: IFFALSE 62770
// if i then
62748: LD_VAR 0 3
62752: IFFALSE 62768
// result := result + 1 ;
62754: LD_ADDR_VAR 0 2
62758: PUSH
62759: LD_VAR 0 2
62763: PUSH
62764: LD_INT 1
62766: PLUS
62767: ST_TO_ADDR
62768: GO 62745
62770: POP
62771: POP
// end ;
62772: LD_VAR 0 2
62776: RET
// export function IsEmpty ( building ) ; begin
62777: LD_INT 0
62779: PPUSH
// if not building then
62780: LD_VAR 0 1
62784: NOT
62785: IFFALSE 62789
// exit ;
62787: GO 62832
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
62789: LD_ADDR_VAR 0 2
62793: PUSH
62794: LD_VAR 0 1
62798: PUSH
62799: LD_INT 22
62801: PUSH
62802: LD_VAR 0 1
62806: PPUSH
62807: CALL_OW 255
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: LD_INT 58
62818: PUSH
62819: EMPTY
62820: LIST
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PPUSH
62826: CALL_OW 69
62830: IN
62831: ST_TO_ADDR
// end ;
62832: LD_VAR 0 2
62836: RET
// export function IsNotFull ( building ) ; begin
62837: LD_INT 0
62839: PPUSH
// if not building then
62840: LD_VAR 0 1
62844: NOT
62845: IFFALSE 62849
// exit ;
62847: GO 62868
// result := UnitsInside ( building ) < 6 ;
62849: LD_ADDR_VAR 0 2
62853: PUSH
62854: LD_VAR 0 1
62858: PPUSH
62859: CALL_OW 313
62863: PUSH
62864: LD_INT 6
62866: LESS
62867: ST_TO_ADDR
// end ;
62868: LD_VAR 0 2
62872: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
62873: LD_INT 0
62875: PPUSH
62876: PPUSH
62877: PPUSH
62878: PPUSH
// tmp := [ ] ;
62879: LD_ADDR_VAR 0 3
62883: PUSH
62884: EMPTY
62885: ST_TO_ADDR
// list := [ ] ;
62886: LD_ADDR_VAR 0 5
62890: PUSH
62891: EMPTY
62892: ST_TO_ADDR
// for i = 16 to 25 do
62893: LD_ADDR_VAR 0 4
62897: PUSH
62898: DOUBLE
62899: LD_INT 16
62901: DEC
62902: ST_TO_ADDR
62903: LD_INT 25
62905: PUSH
62906: FOR_TO
62907: IFFALSE 62980
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
62909: LD_ADDR_VAR 0 3
62913: PUSH
62914: LD_VAR 0 3
62918: PUSH
62919: LD_INT 22
62921: PUSH
62922: LD_VAR 0 1
62926: PPUSH
62927: CALL_OW 255
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 91
62938: PUSH
62939: LD_VAR 0 1
62943: PUSH
62944: LD_INT 6
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: LIST
62951: PUSH
62952: LD_INT 30
62954: PUSH
62955: LD_VAR 0 4
62959: PUSH
62960: EMPTY
62961: LIST
62962: LIST
62963: PUSH
62964: EMPTY
62965: LIST
62966: LIST
62967: LIST
62968: PUSH
62969: EMPTY
62970: LIST
62971: PPUSH
62972: CALL_OW 69
62976: ADD
62977: ST_TO_ADDR
62978: GO 62906
62980: POP
62981: POP
// for i = 1 to tmp do
62982: LD_ADDR_VAR 0 4
62986: PUSH
62987: DOUBLE
62988: LD_INT 1
62990: DEC
62991: ST_TO_ADDR
62992: LD_VAR 0 3
62996: PUSH
62997: FOR_TO
62998: IFFALSE 63086
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
63000: LD_ADDR_VAR 0 5
63004: PUSH
63005: LD_VAR 0 5
63009: PUSH
63010: LD_VAR 0 3
63014: PUSH
63015: LD_VAR 0 4
63019: ARRAY
63020: PPUSH
63021: CALL_OW 266
63025: PUSH
63026: LD_VAR 0 3
63030: PUSH
63031: LD_VAR 0 4
63035: ARRAY
63036: PPUSH
63037: CALL_OW 250
63041: PUSH
63042: LD_VAR 0 3
63046: PUSH
63047: LD_VAR 0 4
63051: ARRAY
63052: PPUSH
63053: CALL_OW 251
63057: PUSH
63058: LD_VAR 0 3
63062: PUSH
63063: LD_VAR 0 4
63067: ARRAY
63068: PPUSH
63069: CALL_OW 254
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: LIST
63078: LIST
63079: PUSH
63080: EMPTY
63081: LIST
63082: ADD
63083: ST_TO_ADDR
63084: GO 62997
63086: POP
63087: POP
// result := list ;
63088: LD_ADDR_VAR 0 2
63092: PUSH
63093: LD_VAR 0 5
63097: ST_TO_ADDR
// end ;
63098: LD_VAR 0 2
63102: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
63103: LD_INT 0
63105: PPUSH
63106: PPUSH
63107: PPUSH
63108: PPUSH
63109: PPUSH
63110: PPUSH
63111: PPUSH
// if not factory then
63112: LD_VAR 0 1
63116: NOT
63117: IFFALSE 63121
// exit ;
63119: GO 63714
// if control = control_apeman then
63121: LD_VAR 0 4
63125: PUSH
63126: LD_INT 5
63128: EQUAL
63129: IFFALSE 63238
// begin tmp := UnitsInside ( factory ) ;
63131: LD_ADDR_VAR 0 8
63135: PUSH
63136: LD_VAR 0 1
63140: PPUSH
63141: CALL_OW 313
63145: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63146: LD_VAR 0 8
63150: PPUSH
63151: LD_INT 25
63153: PUSH
63154: LD_INT 12
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PPUSH
63161: CALL_OW 72
63165: NOT
63166: IFFALSE 63176
// control := control_manual ;
63168: LD_ADDR_VAR 0 4
63172: PUSH
63173: LD_INT 1
63175: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63176: LD_ADDR_VAR 0 8
63180: PUSH
63181: LD_VAR 0 1
63185: PPUSH
63186: CALL 62873 0 1
63190: ST_TO_ADDR
// if tmp then
63191: LD_VAR 0 8
63195: IFFALSE 63238
// begin for i in tmp do
63197: LD_ADDR_VAR 0 7
63201: PUSH
63202: LD_VAR 0 8
63206: PUSH
63207: FOR_IN
63208: IFFALSE 63236
// if i [ 1 ] = b_ext_radio then
63210: LD_VAR 0 7
63214: PUSH
63215: LD_INT 1
63217: ARRAY
63218: PUSH
63219: LD_INT 22
63221: EQUAL
63222: IFFALSE 63234
// begin control := control_remote ;
63224: LD_ADDR_VAR 0 4
63228: PUSH
63229: LD_INT 2
63231: ST_TO_ADDR
// break ;
63232: GO 63236
// end ;
63234: GO 63207
63236: POP
63237: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63238: LD_VAR 0 1
63242: PPUSH
63243: LD_VAR 0 2
63247: PPUSH
63248: LD_VAR 0 3
63252: PPUSH
63253: LD_VAR 0 4
63257: PPUSH
63258: LD_VAR 0 5
63262: PPUSH
63263: CALL_OW 448
63267: IFFALSE 63302
// begin result := [ chassis , engine , control , weapon ] ;
63269: LD_ADDR_VAR 0 6
63273: PUSH
63274: LD_VAR 0 2
63278: PUSH
63279: LD_VAR 0 3
63283: PUSH
63284: LD_VAR 0 4
63288: PUSH
63289: LD_VAR 0 5
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: ST_TO_ADDR
// exit ;
63300: GO 63714
// end ; _chassis := AvailableChassisList ( factory ) ;
63302: LD_ADDR_VAR 0 9
63306: PUSH
63307: LD_VAR 0 1
63311: PPUSH
63312: CALL_OW 475
63316: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63317: LD_ADDR_VAR 0 11
63321: PUSH
63322: LD_VAR 0 1
63326: PPUSH
63327: CALL_OW 476
63331: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63332: LD_ADDR_VAR 0 12
63336: PUSH
63337: LD_VAR 0 1
63341: PPUSH
63342: CALL_OW 477
63346: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63347: LD_ADDR_VAR 0 10
63351: PUSH
63352: LD_VAR 0 1
63356: PPUSH
63357: CALL_OW 478
63361: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63362: LD_VAR 0 9
63366: NOT
63367: PUSH
63368: LD_VAR 0 11
63372: NOT
63373: OR
63374: PUSH
63375: LD_VAR 0 12
63379: NOT
63380: OR
63381: PUSH
63382: LD_VAR 0 10
63386: NOT
63387: OR
63388: IFFALSE 63423
// begin result := [ chassis , engine , control , weapon ] ;
63390: LD_ADDR_VAR 0 6
63394: PUSH
63395: LD_VAR 0 2
63399: PUSH
63400: LD_VAR 0 3
63404: PUSH
63405: LD_VAR 0 4
63409: PUSH
63410: LD_VAR 0 5
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: ST_TO_ADDR
// exit ;
63421: GO 63714
// end ; if not chassis in _chassis then
63423: LD_VAR 0 2
63427: PUSH
63428: LD_VAR 0 9
63432: IN
63433: NOT
63434: IFFALSE 63460
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
63436: LD_ADDR_VAR 0 2
63440: PUSH
63441: LD_VAR 0 9
63445: PUSH
63446: LD_INT 1
63448: PPUSH
63449: LD_VAR 0 9
63453: PPUSH
63454: CALL_OW 12
63458: ARRAY
63459: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
63460: LD_VAR 0 2
63464: PPUSH
63465: LD_VAR 0 3
63469: PPUSH
63470: CALL 63719 0 2
63474: NOT
63475: IFFALSE 63534
// repeat engine := _engine [ 1 ] ;
63477: LD_ADDR_VAR 0 3
63481: PUSH
63482: LD_VAR 0 11
63486: PUSH
63487: LD_INT 1
63489: ARRAY
63490: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
63491: LD_ADDR_VAR 0 11
63495: PUSH
63496: LD_VAR 0 11
63500: PPUSH
63501: LD_INT 1
63503: PPUSH
63504: CALL_OW 3
63508: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
63509: LD_VAR 0 2
63513: PPUSH
63514: LD_VAR 0 3
63518: PPUSH
63519: CALL 63719 0 2
63523: PUSH
63524: LD_VAR 0 11
63528: PUSH
63529: EMPTY
63530: EQUAL
63531: OR
63532: IFFALSE 63477
// if not control in _control then
63534: LD_VAR 0 4
63538: PUSH
63539: LD_VAR 0 12
63543: IN
63544: NOT
63545: IFFALSE 63571
// control := _control [ rand ( 1 , _control ) ] ;
63547: LD_ADDR_VAR 0 4
63551: PUSH
63552: LD_VAR 0 12
63556: PUSH
63557: LD_INT 1
63559: PPUSH
63560: LD_VAR 0 12
63564: PPUSH
63565: CALL_OW 12
63569: ARRAY
63570: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
63571: LD_VAR 0 2
63575: PPUSH
63576: LD_VAR 0 5
63580: PPUSH
63581: CALL 63939 0 2
63585: NOT
63586: IFFALSE 63645
// repeat weapon := _weapon [ 1 ] ;
63588: LD_ADDR_VAR 0 5
63592: PUSH
63593: LD_VAR 0 10
63597: PUSH
63598: LD_INT 1
63600: ARRAY
63601: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
63602: LD_ADDR_VAR 0 10
63606: PUSH
63607: LD_VAR 0 10
63611: PPUSH
63612: LD_INT 1
63614: PPUSH
63615: CALL_OW 3
63619: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
63620: LD_VAR 0 2
63624: PPUSH
63625: LD_VAR 0 5
63629: PPUSH
63630: CALL 63939 0 2
63634: PUSH
63635: LD_VAR 0 10
63639: PUSH
63640: EMPTY
63641: EQUAL
63642: OR
63643: IFFALSE 63588
// result := [ ] ;
63645: LD_ADDR_VAR 0 6
63649: PUSH
63650: EMPTY
63651: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63652: LD_VAR 0 1
63656: PPUSH
63657: LD_VAR 0 2
63661: PPUSH
63662: LD_VAR 0 3
63666: PPUSH
63667: LD_VAR 0 4
63671: PPUSH
63672: LD_VAR 0 5
63676: PPUSH
63677: CALL_OW 448
63681: IFFALSE 63714
// result := [ chassis , engine , control , weapon ] ;
63683: LD_ADDR_VAR 0 6
63687: PUSH
63688: LD_VAR 0 2
63692: PUSH
63693: LD_VAR 0 3
63697: PUSH
63698: LD_VAR 0 4
63702: PUSH
63703: LD_VAR 0 5
63707: PUSH
63708: EMPTY
63709: LIST
63710: LIST
63711: LIST
63712: LIST
63713: ST_TO_ADDR
// end ;
63714: LD_VAR 0 6
63718: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
63719: LD_INT 0
63721: PPUSH
// if not chassis or not engine then
63722: LD_VAR 0 1
63726: NOT
63727: PUSH
63728: LD_VAR 0 2
63732: NOT
63733: OR
63734: IFFALSE 63738
// exit ;
63736: GO 63934
// case engine of engine_solar :
63738: LD_VAR 0 2
63742: PUSH
63743: LD_INT 2
63745: DOUBLE
63746: EQUAL
63747: IFTRUE 63751
63749: GO 63789
63751: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
63752: LD_ADDR_VAR 0 3
63756: PUSH
63757: LD_INT 11
63759: PUSH
63760: LD_INT 12
63762: PUSH
63763: LD_INT 13
63765: PUSH
63766: LD_INT 14
63768: PUSH
63769: LD_INT 1
63771: PUSH
63772: LD_INT 2
63774: PUSH
63775: LD_INT 3
63777: PUSH
63778: EMPTY
63779: LIST
63780: LIST
63781: LIST
63782: LIST
63783: LIST
63784: LIST
63785: LIST
63786: ST_TO_ADDR
63787: GO 63918
63789: LD_INT 1
63791: DOUBLE
63792: EQUAL
63793: IFTRUE 63797
63795: GO 63859
63797: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
63798: LD_ADDR_VAR 0 3
63802: PUSH
63803: LD_INT 11
63805: PUSH
63806: LD_INT 12
63808: PUSH
63809: LD_INT 13
63811: PUSH
63812: LD_INT 14
63814: PUSH
63815: LD_INT 1
63817: PUSH
63818: LD_INT 2
63820: PUSH
63821: LD_INT 3
63823: PUSH
63824: LD_INT 4
63826: PUSH
63827: LD_INT 5
63829: PUSH
63830: LD_INT 21
63832: PUSH
63833: LD_INT 23
63835: PUSH
63836: LD_INT 22
63838: PUSH
63839: LD_INT 24
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: ST_TO_ADDR
63857: GO 63918
63859: LD_INT 3
63861: DOUBLE
63862: EQUAL
63863: IFTRUE 63867
63865: GO 63917
63867: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
63868: LD_ADDR_VAR 0 3
63872: PUSH
63873: LD_INT 13
63875: PUSH
63876: LD_INT 14
63878: PUSH
63879: LD_INT 2
63881: PUSH
63882: LD_INT 3
63884: PUSH
63885: LD_INT 4
63887: PUSH
63888: LD_INT 5
63890: PUSH
63891: LD_INT 21
63893: PUSH
63894: LD_INT 22
63896: PUSH
63897: LD_INT 23
63899: PUSH
63900: LD_INT 24
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: ST_TO_ADDR
63915: GO 63918
63917: POP
// result := ( chassis in result ) ;
63918: LD_ADDR_VAR 0 3
63922: PUSH
63923: LD_VAR 0 1
63927: PUSH
63928: LD_VAR 0 3
63932: IN
63933: ST_TO_ADDR
// end ;
63934: LD_VAR 0 3
63938: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
63939: LD_INT 0
63941: PPUSH
// if not chassis or not weapon then
63942: LD_VAR 0 1
63946: NOT
63947: PUSH
63948: LD_VAR 0 2
63952: NOT
63953: OR
63954: IFFALSE 63958
// exit ;
63956: GO 65020
// case weapon of us_machine_gun :
63958: LD_VAR 0 2
63962: PUSH
63963: LD_INT 2
63965: DOUBLE
63966: EQUAL
63967: IFTRUE 63971
63969: GO 64001
63971: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
63972: LD_ADDR_VAR 0 3
63976: PUSH
63977: LD_INT 1
63979: PUSH
63980: LD_INT 2
63982: PUSH
63983: LD_INT 3
63985: PUSH
63986: LD_INT 4
63988: PUSH
63989: LD_INT 5
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: ST_TO_ADDR
63999: GO 65004
64001: LD_INT 3
64003: DOUBLE
64004: EQUAL
64005: IFTRUE 64009
64007: GO 64039
64009: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
64010: LD_ADDR_VAR 0 3
64014: PUSH
64015: LD_INT 1
64017: PUSH
64018: LD_INT 2
64020: PUSH
64021: LD_INT 3
64023: PUSH
64024: LD_INT 4
64026: PUSH
64027: LD_INT 5
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: LIST
64034: LIST
64035: LIST
64036: ST_TO_ADDR
64037: GO 65004
64039: LD_INT 11
64041: DOUBLE
64042: EQUAL
64043: IFTRUE 64047
64045: GO 64077
64047: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
64048: LD_ADDR_VAR 0 3
64052: PUSH
64053: LD_INT 1
64055: PUSH
64056: LD_INT 2
64058: PUSH
64059: LD_INT 3
64061: PUSH
64062: LD_INT 4
64064: PUSH
64065: LD_INT 5
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: ST_TO_ADDR
64075: GO 65004
64077: LD_INT 4
64079: DOUBLE
64080: EQUAL
64081: IFTRUE 64085
64083: GO 64111
64085: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
64086: LD_ADDR_VAR 0 3
64090: PUSH
64091: LD_INT 2
64093: PUSH
64094: LD_INT 3
64096: PUSH
64097: LD_INT 4
64099: PUSH
64100: LD_INT 5
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: ST_TO_ADDR
64109: GO 65004
64111: LD_INT 5
64113: DOUBLE
64114: EQUAL
64115: IFTRUE 64119
64117: GO 64145
64119: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
64120: LD_ADDR_VAR 0 3
64124: PUSH
64125: LD_INT 2
64127: PUSH
64128: LD_INT 3
64130: PUSH
64131: LD_INT 4
64133: PUSH
64134: LD_INT 5
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: ST_TO_ADDR
64143: GO 65004
64145: LD_INT 9
64147: DOUBLE
64148: EQUAL
64149: IFTRUE 64153
64151: GO 64179
64153: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64154: LD_ADDR_VAR 0 3
64158: PUSH
64159: LD_INT 2
64161: PUSH
64162: LD_INT 3
64164: PUSH
64165: LD_INT 4
64167: PUSH
64168: LD_INT 5
64170: PUSH
64171: EMPTY
64172: LIST
64173: LIST
64174: LIST
64175: LIST
64176: ST_TO_ADDR
64177: GO 65004
64179: LD_INT 7
64181: DOUBLE
64182: EQUAL
64183: IFTRUE 64187
64185: GO 64213
64187: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64188: LD_ADDR_VAR 0 3
64192: PUSH
64193: LD_INT 2
64195: PUSH
64196: LD_INT 3
64198: PUSH
64199: LD_INT 4
64201: PUSH
64202: LD_INT 5
64204: PUSH
64205: EMPTY
64206: LIST
64207: LIST
64208: LIST
64209: LIST
64210: ST_TO_ADDR
64211: GO 65004
64213: LD_INT 12
64215: DOUBLE
64216: EQUAL
64217: IFTRUE 64221
64219: GO 64247
64221: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64222: LD_ADDR_VAR 0 3
64226: PUSH
64227: LD_INT 2
64229: PUSH
64230: LD_INT 3
64232: PUSH
64233: LD_INT 4
64235: PUSH
64236: LD_INT 5
64238: PUSH
64239: EMPTY
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: ST_TO_ADDR
64245: GO 65004
64247: LD_INT 13
64249: DOUBLE
64250: EQUAL
64251: IFTRUE 64255
64253: GO 64281
64255: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64256: LD_ADDR_VAR 0 3
64260: PUSH
64261: LD_INT 2
64263: PUSH
64264: LD_INT 3
64266: PUSH
64267: LD_INT 4
64269: PUSH
64270: LD_INT 5
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: ST_TO_ADDR
64279: GO 65004
64281: LD_INT 14
64283: DOUBLE
64284: EQUAL
64285: IFTRUE 64289
64287: GO 64307
64289: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64290: LD_ADDR_VAR 0 3
64294: PUSH
64295: LD_INT 4
64297: PUSH
64298: LD_INT 5
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: ST_TO_ADDR
64305: GO 65004
64307: LD_INT 6
64309: DOUBLE
64310: EQUAL
64311: IFTRUE 64315
64313: GO 64333
64315: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64316: LD_ADDR_VAR 0 3
64320: PUSH
64321: LD_INT 4
64323: PUSH
64324: LD_INT 5
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: ST_TO_ADDR
64331: GO 65004
64333: LD_INT 10
64335: DOUBLE
64336: EQUAL
64337: IFTRUE 64341
64339: GO 64359
64341: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64342: LD_ADDR_VAR 0 3
64346: PUSH
64347: LD_INT 4
64349: PUSH
64350: LD_INT 5
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: ST_TO_ADDR
64357: GO 65004
64359: LD_INT 22
64361: DOUBLE
64362: EQUAL
64363: IFTRUE 64367
64365: GO 64393
64367: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64368: LD_ADDR_VAR 0 3
64372: PUSH
64373: LD_INT 11
64375: PUSH
64376: LD_INT 12
64378: PUSH
64379: LD_INT 13
64381: PUSH
64382: LD_INT 14
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: LIST
64389: LIST
64390: ST_TO_ADDR
64391: GO 65004
64393: LD_INT 23
64395: DOUBLE
64396: EQUAL
64397: IFTRUE 64401
64399: GO 64427
64401: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
64402: LD_ADDR_VAR 0 3
64406: PUSH
64407: LD_INT 11
64409: PUSH
64410: LD_INT 12
64412: PUSH
64413: LD_INT 13
64415: PUSH
64416: LD_INT 14
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: LIST
64423: LIST
64424: ST_TO_ADDR
64425: GO 65004
64427: LD_INT 24
64429: DOUBLE
64430: EQUAL
64431: IFTRUE 64435
64433: GO 64461
64435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
64436: LD_ADDR_VAR 0 3
64440: PUSH
64441: LD_INT 11
64443: PUSH
64444: LD_INT 12
64446: PUSH
64447: LD_INT 13
64449: PUSH
64450: LD_INT 14
64452: PUSH
64453: EMPTY
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: ST_TO_ADDR
64459: GO 65004
64461: LD_INT 30
64463: DOUBLE
64464: EQUAL
64465: IFTRUE 64469
64467: GO 64495
64469: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
64470: LD_ADDR_VAR 0 3
64474: PUSH
64475: LD_INT 11
64477: PUSH
64478: LD_INT 12
64480: PUSH
64481: LD_INT 13
64483: PUSH
64484: LD_INT 14
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: ST_TO_ADDR
64493: GO 65004
64495: LD_INT 25
64497: DOUBLE
64498: EQUAL
64499: IFTRUE 64503
64501: GO 64521
64503: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
64504: LD_ADDR_VAR 0 3
64508: PUSH
64509: LD_INT 13
64511: PUSH
64512: LD_INT 14
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: ST_TO_ADDR
64519: GO 65004
64521: LD_INT 27
64523: DOUBLE
64524: EQUAL
64525: IFTRUE 64529
64527: GO 64547
64529: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
64530: LD_ADDR_VAR 0 3
64534: PUSH
64535: LD_INT 13
64537: PUSH
64538: LD_INT 14
64540: PUSH
64541: EMPTY
64542: LIST
64543: LIST
64544: ST_TO_ADDR
64545: GO 65004
64547: LD_EXP 78
64551: DOUBLE
64552: EQUAL
64553: IFTRUE 64557
64555: GO 64583
64557: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
64558: LD_ADDR_VAR 0 3
64562: PUSH
64563: LD_INT 11
64565: PUSH
64566: LD_INT 12
64568: PUSH
64569: LD_INT 13
64571: PUSH
64572: LD_INT 14
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: ST_TO_ADDR
64581: GO 65004
64583: LD_INT 28
64585: DOUBLE
64586: EQUAL
64587: IFTRUE 64591
64589: GO 64609
64591: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
64592: LD_ADDR_VAR 0 3
64596: PUSH
64597: LD_INT 13
64599: PUSH
64600: LD_INT 14
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: ST_TO_ADDR
64607: GO 65004
64609: LD_INT 29
64611: DOUBLE
64612: EQUAL
64613: IFTRUE 64617
64615: GO 64635
64617: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
64618: LD_ADDR_VAR 0 3
64622: PUSH
64623: LD_INT 13
64625: PUSH
64626: LD_INT 14
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: ST_TO_ADDR
64633: GO 65004
64635: LD_INT 31
64637: DOUBLE
64638: EQUAL
64639: IFTRUE 64643
64641: GO 64661
64643: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
64644: LD_ADDR_VAR 0 3
64648: PUSH
64649: LD_INT 13
64651: PUSH
64652: LD_INT 14
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: ST_TO_ADDR
64659: GO 65004
64661: LD_INT 26
64663: DOUBLE
64664: EQUAL
64665: IFTRUE 64669
64667: GO 64687
64669: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
64670: LD_ADDR_VAR 0 3
64674: PUSH
64675: LD_INT 13
64677: PUSH
64678: LD_INT 14
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: ST_TO_ADDR
64685: GO 65004
64687: LD_INT 42
64689: DOUBLE
64690: EQUAL
64691: IFTRUE 64695
64693: GO 64721
64695: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
64696: LD_ADDR_VAR 0 3
64700: PUSH
64701: LD_INT 21
64703: PUSH
64704: LD_INT 22
64706: PUSH
64707: LD_INT 23
64709: PUSH
64710: LD_INT 24
64712: PUSH
64713: EMPTY
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: ST_TO_ADDR
64719: GO 65004
64721: LD_INT 43
64723: DOUBLE
64724: EQUAL
64725: IFTRUE 64729
64727: GO 64755
64729: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
64730: LD_ADDR_VAR 0 3
64734: PUSH
64735: LD_INT 21
64737: PUSH
64738: LD_INT 22
64740: PUSH
64741: LD_INT 23
64743: PUSH
64744: LD_INT 24
64746: PUSH
64747: EMPTY
64748: LIST
64749: LIST
64750: LIST
64751: LIST
64752: ST_TO_ADDR
64753: GO 65004
64755: LD_INT 44
64757: DOUBLE
64758: EQUAL
64759: IFTRUE 64763
64761: GO 64789
64763: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
64764: LD_ADDR_VAR 0 3
64768: PUSH
64769: LD_INT 21
64771: PUSH
64772: LD_INT 22
64774: PUSH
64775: LD_INT 23
64777: PUSH
64778: LD_INT 24
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: ST_TO_ADDR
64787: GO 65004
64789: LD_INT 45
64791: DOUBLE
64792: EQUAL
64793: IFTRUE 64797
64795: GO 64823
64797: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
64798: LD_ADDR_VAR 0 3
64802: PUSH
64803: LD_INT 21
64805: PUSH
64806: LD_INT 22
64808: PUSH
64809: LD_INT 23
64811: PUSH
64812: LD_INT 24
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: ST_TO_ADDR
64821: GO 65004
64823: LD_INT 49
64825: DOUBLE
64826: EQUAL
64827: IFTRUE 64831
64829: GO 64857
64831: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
64832: LD_ADDR_VAR 0 3
64836: PUSH
64837: LD_INT 21
64839: PUSH
64840: LD_INT 22
64842: PUSH
64843: LD_INT 23
64845: PUSH
64846: LD_INT 24
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: LIST
64853: LIST
64854: ST_TO_ADDR
64855: GO 65004
64857: LD_INT 51
64859: DOUBLE
64860: EQUAL
64861: IFTRUE 64865
64863: GO 64891
64865: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
64866: LD_ADDR_VAR 0 3
64870: PUSH
64871: LD_INT 21
64873: PUSH
64874: LD_INT 22
64876: PUSH
64877: LD_INT 23
64879: PUSH
64880: LD_INT 24
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: ST_TO_ADDR
64889: GO 65004
64891: LD_INT 52
64893: DOUBLE
64894: EQUAL
64895: IFTRUE 64899
64897: GO 64925
64899: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
64900: LD_ADDR_VAR 0 3
64904: PUSH
64905: LD_INT 21
64907: PUSH
64908: LD_INT 22
64910: PUSH
64911: LD_INT 23
64913: PUSH
64914: LD_INT 24
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: ST_TO_ADDR
64923: GO 65004
64925: LD_INT 53
64927: DOUBLE
64928: EQUAL
64929: IFTRUE 64933
64931: GO 64951
64933: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
64934: LD_ADDR_VAR 0 3
64938: PUSH
64939: LD_INT 23
64941: PUSH
64942: LD_INT 24
64944: PUSH
64945: EMPTY
64946: LIST
64947: LIST
64948: ST_TO_ADDR
64949: GO 65004
64951: LD_INT 46
64953: DOUBLE
64954: EQUAL
64955: IFTRUE 64959
64957: GO 64977
64959: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
64960: LD_ADDR_VAR 0 3
64964: PUSH
64965: LD_INT 23
64967: PUSH
64968: LD_INT 24
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: ST_TO_ADDR
64975: GO 65004
64977: LD_INT 47
64979: DOUBLE
64980: EQUAL
64981: IFTRUE 64985
64983: GO 65003
64985: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64986: LD_ADDR_VAR 0 3
64990: PUSH
64991: LD_INT 23
64993: PUSH
64994: LD_INT 24
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: ST_TO_ADDR
65001: GO 65004
65003: POP
// result := ( chassis in result ) ;
65004: LD_ADDR_VAR 0 3
65008: PUSH
65009: LD_VAR 0 1
65013: PUSH
65014: LD_VAR 0 3
65018: IN
65019: ST_TO_ADDR
// end ;
65020: LD_VAR 0 3
65024: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
65025: LD_INT 0
65027: PPUSH
65028: PPUSH
65029: PPUSH
65030: PPUSH
65031: PPUSH
65032: PPUSH
65033: PPUSH
// result := array ;
65034: LD_ADDR_VAR 0 5
65038: PUSH
65039: LD_VAR 0 1
65043: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
65044: LD_VAR 0 1
65048: NOT
65049: PUSH
65050: LD_VAR 0 2
65054: NOT
65055: OR
65056: PUSH
65057: LD_VAR 0 3
65061: NOT
65062: OR
65063: PUSH
65064: LD_VAR 0 2
65068: PUSH
65069: LD_VAR 0 1
65073: GREATER
65074: OR
65075: PUSH
65076: LD_VAR 0 3
65080: PUSH
65081: LD_VAR 0 1
65085: GREATER
65086: OR
65087: IFFALSE 65091
// exit ;
65089: GO 65387
// if direction then
65091: LD_VAR 0 4
65095: IFFALSE 65159
// begin d := 1 ;
65097: LD_ADDR_VAR 0 9
65101: PUSH
65102: LD_INT 1
65104: ST_TO_ADDR
// if i_from > i_to then
65105: LD_VAR 0 2
65109: PUSH
65110: LD_VAR 0 3
65114: GREATER
65115: IFFALSE 65141
// length := ( array - i_from ) + i_to else
65117: LD_ADDR_VAR 0 11
65121: PUSH
65122: LD_VAR 0 1
65126: PUSH
65127: LD_VAR 0 2
65131: MINUS
65132: PUSH
65133: LD_VAR 0 3
65137: PLUS
65138: ST_TO_ADDR
65139: GO 65157
// length := i_to - i_from ;
65141: LD_ADDR_VAR 0 11
65145: PUSH
65146: LD_VAR 0 3
65150: PUSH
65151: LD_VAR 0 2
65155: MINUS
65156: ST_TO_ADDR
// end else
65157: GO 65220
// begin d := - 1 ;
65159: LD_ADDR_VAR 0 9
65163: PUSH
65164: LD_INT 1
65166: NEG
65167: ST_TO_ADDR
// if i_from > i_to then
65168: LD_VAR 0 2
65172: PUSH
65173: LD_VAR 0 3
65177: GREATER
65178: IFFALSE 65198
// length := i_from - i_to else
65180: LD_ADDR_VAR 0 11
65184: PUSH
65185: LD_VAR 0 2
65189: PUSH
65190: LD_VAR 0 3
65194: MINUS
65195: ST_TO_ADDR
65196: GO 65220
// length := ( array - i_to ) + i_from ;
65198: LD_ADDR_VAR 0 11
65202: PUSH
65203: LD_VAR 0 1
65207: PUSH
65208: LD_VAR 0 3
65212: MINUS
65213: PUSH
65214: LD_VAR 0 2
65218: PLUS
65219: ST_TO_ADDR
// end ; if not length then
65220: LD_VAR 0 11
65224: NOT
65225: IFFALSE 65229
// exit ;
65227: GO 65387
// tmp := array ;
65229: LD_ADDR_VAR 0 10
65233: PUSH
65234: LD_VAR 0 1
65238: ST_TO_ADDR
// for i = 1 to length do
65239: LD_ADDR_VAR 0 6
65243: PUSH
65244: DOUBLE
65245: LD_INT 1
65247: DEC
65248: ST_TO_ADDR
65249: LD_VAR 0 11
65253: PUSH
65254: FOR_TO
65255: IFFALSE 65375
// begin for j = 1 to array do
65257: LD_ADDR_VAR 0 7
65261: PUSH
65262: DOUBLE
65263: LD_INT 1
65265: DEC
65266: ST_TO_ADDR
65267: LD_VAR 0 1
65271: PUSH
65272: FOR_TO
65273: IFFALSE 65361
// begin k := j + d ;
65275: LD_ADDR_VAR 0 8
65279: PUSH
65280: LD_VAR 0 7
65284: PUSH
65285: LD_VAR 0 9
65289: PLUS
65290: ST_TO_ADDR
// if k > array then
65291: LD_VAR 0 8
65295: PUSH
65296: LD_VAR 0 1
65300: GREATER
65301: IFFALSE 65311
// k := 1 ;
65303: LD_ADDR_VAR 0 8
65307: PUSH
65308: LD_INT 1
65310: ST_TO_ADDR
// if not k then
65311: LD_VAR 0 8
65315: NOT
65316: IFFALSE 65328
// k := array ;
65318: LD_ADDR_VAR 0 8
65322: PUSH
65323: LD_VAR 0 1
65327: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65328: LD_ADDR_VAR 0 10
65332: PUSH
65333: LD_VAR 0 10
65337: PPUSH
65338: LD_VAR 0 8
65342: PPUSH
65343: LD_VAR 0 1
65347: PUSH
65348: LD_VAR 0 7
65352: ARRAY
65353: PPUSH
65354: CALL_OW 1
65358: ST_TO_ADDR
// end ;
65359: GO 65272
65361: POP
65362: POP
// array := tmp ;
65363: LD_ADDR_VAR 0 1
65367: PUSH
65368: LD_VAR 0 10
65372: ST_TO_ADDR
// end ;
65373: GO 65254
65375: POP
65376: POP
// result := array ;
65377: LD_ADDR_VAR 0 5
65381: PUSH
65382: LD_VAR 0 1
65386: ST_TO_ADDR
// end ;
65387: LD_VAR 0 5
65391: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65392: LD_INT 0
65394: PPUSH
65395: PPUSH
// result := 0 ;
65396: LD_ADDR_VAR 0 3
65400: PUSH
65401: LD_INT 0
65403: ST_TO_ADDR
// if not array or not value in array then
65404: LD_VAR 0 1
65408: NOT
65409: PUSH
65410: LD_VAR 0 2
65414: PUSH
65415: LD_VAR 0 1
65419: IN
65420: NOT
65421: OR
65422: IFFALSE 65426
// exit ;
65424: GO 65480
// for i = 1 to array do
65426: LD_ADDR_VAR 0 4
65430: PUSH
65431: DOUBLE
65432: LD_INT 1
65434: DEC
65435: ST_TO_ADDR
65436: LD_VAR 0 1
65440: PUSH
65441: FOR_TO
65442: IFFALSE 65478
// if value = array [ i ] then
65444: LD_VAR 0 2
65448: PUSH
65449: LD_VAR 0 1
65453: PUSH
65454: LD_VAR 0 4
65458: ARRAY
65459: EQUAL
65460: IFFALSE 65476
// begin result := i ;
65462: LD_ADDR_VAR 0 3
65466: PUSH
65467: LD_VAR 0 4
65471: ST_TO_ADDR
// exit ;
65472: POP
65473: POP
65474: GO 65480
// end ;
65476: GO 65441
65478: POP
65479: POP
// end ;
65480: LD_VAR 0 3
65484: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
65485: LD_INT 0
65487: PPUSH
// vc_chassis := chassis ;
65488: LD_ADDR_OWVAR 37
65492: PUSH
65493: LD_VAR 0 1
65497: ST_TO_ADDR
// vc_engine := engine ;
65498: LD_ADDR_OWVAR 39
65502: PUSH
65503: LD_VAR 0 2
65507: ST_TO_ADDR
// vc_control := control ;
65508: LD_ADDR_OWVAR 38
65512: PUSH
65513: LD_VAR 0 3
65517: ST_TO_ADDR
// vc_weapon := weapon ;
65518: LD_ADDR_OWVAR 40
65522: PUSH
65523: LD_VAR 0 4
65527: ST_TO_ADDR
// vc_fuel_battery := fuel ;
65528: LD_ADDR_OWVAR 41
65532: PUSH
65533: LD_VAR 0 5
65537: ST_TO_ADDR
// end ;
65538: LD_VAR 0 6
65542: RET
// export function WantPlant ( unit ) ; var task ; begin
65543: LD_INT 0
65545: PPUSH
65546: PPUSH
// result := false ;
65547: LD_ADDR_VAR 0 2
65551: PUSH
65552: LD_INT 0
65554: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
65555: LD_ADDR_VAR 0 3
65559: PUSH
65560: LD_VAR 0 1
65564: PPUSH
65565: CALL_OW 437
65569: ST_TO_ADDR
// if task then
65570: LD_VAR 0 3
65574: IFFALSE 65602
// if task [ 1 ] [ 1 ] = p then
65576: LD_VAR 0 3
65580: PUSH
65581: LD_INT 1
65583: ARRAY
65584: PUSH
65585: LD_INT 1
65587: ARRAY
65588: PUSH
65589: LD_STRING p
65591: EQUAL
65592: IFFALSE 65602
// result := true ;
65594: LD_ADDR_VAR 0 2
65598: PUSH
65599: LD_INT 1
65601: ST_TO_ADDR
// end ;
65602: LD_VAR 0 2
65606: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
65607: LD_INT 0
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
// if pos < 1 then
65613: LD_VAR 0 2
65617: PUSH
65618: LD_INT 1
65620: LESS
65621: IFFALSE 65625
// exit ;
65623: GO 65928
// if pos = 1 then
65625: LD_VAR 0 2
65629: PUSH
65630: LD_INT 1
65632: EQUAL
65633: IFFALSE 65666
// result := Replace ( arr , pos [ 1 ] , value ) else
65635: LD_ADDR_VAR 0 4
65639: PUSH
65640: LD_VAR 0 1
65644: PPUSH
65645: LD_VAR 0 2
65649: PUSH
65650: LD_INT 1
65652: ARRAY
65653: PPUSH
65654: LD_VAR 0 3
65658: PPUSH
65659: CALL_OW 1
65663: ST_TO_ADDR
65664: GO 65928
// begin tmp := arr ;
65666: LD_ADDR_VAR 0 6
65670: PUSH
65671: LD_VAR 0 1
65675: ST_TO_ADDR
// s_arr := [ tmp ] ;
65676: LD_ADDR_VAR 0 7
65680: PUSH
65681: LD_VAR 0 6
65685: PUSH
65686: EMPTY
65687: LIST
65688: ST_TO_ADDR
// for i = 1 to pos - 1 do
65689: LD_ADDR_VAR 0 5
65693: PUSH
65694: DOUBLE
65695: LD_INT 1
65697: DEC
65698: ST_TO_ADDR
65699: LD_VAR 0 2
65703: PUSH
65704: LD_INT 1
65706: MINUS
65707: PUSH
65708: FOR_TO
65709: IFFALSE 65754
// begin tmp := tmp [ pos [ i ] ] ;
65711: LD_ADDR_VAR 0 6
65715: PUSH
65716: LD_VAR 0 6
65720: PUSH
65721: LD_VAR 0 2
65725: PUSH
65726: LD_VAR 0 5
65730: ARRAY
65731: ARRAY
65732: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
65733: LD_ADDR_VAR 0 7
65737: PUSH
65738: LD_VAR 0 7
65742: PUSH
65743: LD_VAR 0 6
65747: PUSH
65748: EMPTY
65749: LIST
65750: ADD
65751: ST_TO_ADDR
// end ;
65752: GO 65708
65754: POP
65755: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
65756: LD_ADDR_VAR 0 6
65760: PUSH
65761: LD_VAR 0 6
65765: PPUSH
65766: LD_VAR 0 2
65770: PUSH
65771: LD_VAR 0 2
65775: ARRAY
65776: PPUSH
65777: LD_VAR 0 3
65781: PPUSH
65782: CALL_OW 1
65786: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
65787: LD_ADDR_VAR 0 7
65791: PUSH
65792: LD_VAR 0 7
65796: PPUSH
65797: LD_VAR 0 7
65801: PPUSH
65802: LD_VAR 0 6
65806: PPUSH
65807: CALL_OW 1
65811: ST_TO_ADDR
// for i = s_arr downto 2 do
65812: LD_ADDR_VAR 0 5
65816: PUSH
65817: DOUBLE
65818: LD_VAR 0 7
65822: INC
65823: ST_TO_ADDR
65824: LD_INT 2
65826: PUSH
65827: FOR_DOWNTO
65828: IFFALSE 65912
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
65830: LD_ADDR_VAR 0 6
65834: PUSH
65835: LD_VAR 0 7
65839: PUSH
65840: LD_VAR 0 5
65844: PUSH
65845: LD_INT 1
65847: MINUS
65848: ARRAY
65849: PPUSH
65850: LD_VAR 0 2
65854: PUSH
65855: LD_VAR 0 5
65859: PUSH
65860: LD_INT 1
65862: MINUS
65863: ARRAY
65864: PPUSH
65865: LD_VAR 0 7
65869: PUSH
65870: LD_VAR 0 5
65874: ARRAY
65875: PPUSH
65876: CALL_OW 1
65880: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
65881: LD_ADDR_VAR 0 7
65885: PUSH
65886: LD_VAR 0 7
65890: PPUSH
65891: LD_VAR 0 5
65895: PUSH
65896: LD_INT 1
65898: MINUS
65899: PPUSH
65900: LD_VAR 0 6
65904: PPUSH
65905: CALL_OW 1
65909: ST_TO_ADDR
// end ;
65910: GO 65827
65912: POP
65913: POP
// result := s_arr [ 1 ] ;
65914: LD_ADDR_VAR 0 4
65918: PUSH
65919: LD_VAR 0 7
65923: PUSH
65924: LD_INT 1
65926: ARRAY
65927: ST_TO_ADDR
// end ; end ;
65928: LD_VAR 0 4
65932: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
65933: LD_INT 0
65935: PPUSH
65936: PPUSH
// if not list then
65937: LD_VAR 0 1
65941: NOT
65942: IFFALSE 65946
// exit ;
65944: GO 66037
// i := list [ pos1 ] ;
65946: LD_ADDR_VAR 0 5
65950: PUSH
65951: LD_VAR 0 1
65955: PUSH
65956: LD_VAR 0 2
65960: ARRAY
65961: ST_TO_ADDR
// if not i then
65962: LD_VAR 0 5
65966: NOT
65967: IFFALSE 65971
// exit ;
65969: GO 66037
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
65971: LD_ADDR_VAR 0 1
65975: PUSH
65976: LD_VAR 0 1
65980: PPUSH
65981: LD_VAR 0 2
65985: PPUSH
65986: LD_VAR 0 1
65990: PUSH
65991: LD_VAR 0 3
65995: ARRAY
65996: PPUSH
65997: CALL_OW 1
66001: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
66002: LD_ADDR_VAR 0 1
66006: PUSH
66007: LD_VAR 0 1
66011: PPUSH
66012: LD_VAR 0 3
66016: PPUSH
66017: LD_VAR 0 5
66021: PPUSH
66022: CALL_OW 1
66026: ST_TO_ADDR
// result := list ;
66027: LD_ADDR_VAR 0 4
66031: PUSH
66032: LD_VAR 0 1
66036: ST_TO_ADDR
// end ;
66037: LD_VAR 0 4
66041: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
66042: LD_INT 0
66044: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
66045: LD_ADDR_VAR 0 5
66049: PUSH
66050: LD_VAR 0 1
66054: PPUSH
66055: CALL_OW 250
66059: PPUSH
66060: LD_VAR 0 1
66064: PPUSH
66065: CALL_OW 251
66069: PPUSH
66070: LD_VAR 0 2
66074: PPUSH
66075: LD_VAR 0 3
66079: PPUSH
66080: LD_VAR 0 4
66084: PPUSH
66085: CALL 66095 0 5
66089: ST_TO_ADDR
// end ;
66090: LD_VAR 0 5
66094: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
66095: LD_INT 0
66097: PPUSH
66098: PPUSH
66099: PPUSH
66100: PPUSH
// if not list then
66101: LD_VAR 0 3
66105: NOT
66106: IFFALSE 66110
// exit ;
66108: GO 66498
// result := [ ] ;
66110: LD_ADDR_VAR 0 6
66114: PUSH
66115: EMPTY
66116: ST_TO_ADDR
// for i in list do
66117: LD_ADDR_VAR 0 7
66121: PUSH
66122: LD_VAR 0 3
66126: PUSH
66127: FOR_IN
66128: IFFALSE 66330
// begin tmp := GetDistUnitXY ( i , x , y ) ;
66130: LD_ADDR_VAR 0 9
66134: PUSH
66135: LD_VAR 0 7
66139: PPUSH
66140: LD_VAR 0 1
66144: PPUSH
66145: LD_VAR 0 2
66149: PPUSH
66150: CALL_OW 297
66154: ST_TO_ADDR
// if not result then
66155: LD_VAR 0 6
66159: NOT
66160: IFFALSE 66186
// result := [ [ i , tmp ] ] else
66162: LD_ADDR_VAR 0 6
66166: PUSH
66167: LD_VAR 0 7
66171: PUSH
66172: LD_VAR 0 9
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: PUSH
66181: EMPTY
66182: LIST
66183: ST_TO_ADDR
66184: GO 66328
// begin if result [ result ] [ 2 ] < tmp then
66186: LD_VAR 0 6
66190: PUSH
66191: LD_VAR 0 6
66195: ARRAY
66196: PUSH
66197: LD_INT 2
66199: ARRAY
66200: PUSH
66201: LD_VAR 0 9
66205: LESS
66206: IFFALSE 66248
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66208: LD_ADDR_VAR 0 6
66212: PUSH
66213: LD_VAR 0 6
66217: PPUSH
66218: LD_VAR 0 6
66222: PUSH
66223: LD_INT 1
66225: PLUS
66226: PPUSH
66227: LD_VAR 0 7
66231: PUSH
66232: LD_VAR 0 9
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PPUSH
66241: CALL_OW 2
66245: ST_TO_ADDR
66246: GO 66328
// for j = 1 to result do
66248: LD_ADDR_VAR 0 8
66252: PUSH
66253: DOUBLE
66254: LD_INT 1
66256: DEC
66257: ST_TO_ADDR
66258: LD_VAR 0 6
66262: PUSH
66263: FOR_TO
66264: IFFALSE 66326
// begin if tmp < result [ j ] [ 2 ] then
66266: LD_VAR 0 9
66270: PUSH
66271: LD_VAR 0 6
66275: PUSH
66276: LD_VAR 0 8
66280: ARRAY
66281: PUSH
66282: LD_INT 2
66284: ARRAY
66285: LESS
66286: IFFALSE 66324
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66288: LD_ADDR_VAR 0 6
66292: PUSH
66293: LD_VAR 0 6
66297: PPUSH
66298: LD_VAR 0 8
66302: PPUSH
66303: LD_VAR 0 7
66307: PUSH
66308: LD_VAR 0 9
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PPUSH
66317: CALL_OW 2
66321: ST_TO_ADDR
// break ;
66322: GO 66326
// end ; end ;
66324: GO 66263
66326: POP
66327: POP
// end ; end ;
66328: GO 66127
66330: POP
66331: POP
// if result and not asc then
66332: LD_VAR 0 6
66336: PUSH
66337: LD_VAR 0 4
66341: NOT
66342: AND
66343: IFFALSE 66418
// begin tmp := result ;
66345: LD_ADDR_VAR 0 9
66349: PUSH
66350: LD_VAR 0 6
66354: ST_TO_ADDR
// for i = tmp downto 1 do
66355: LD_ADDR_VAR 0 7
66359: PUSH
66360: DOUBLE
66361: LD_VAR 0 9
66365: INC
66366: ST_TO_ADDR
66367: LD_INT 1
66369: PUSH
66370: FOR_DOWNTO
66371: IFFALSE 66416
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66373: LD_ADDR_VAR 0 6
66377: PUSH
66378: LD_VAR 0 6
66382: PPUSH
66383: LD_VAR 0 9
66387: PUSH
66388: LD_VAR 0 7
66392: MINUS
66393: PUSH
66394: LD_INT 1
66396: PLUS
66397: PPUSH
66398: LD_VAR 0 9
66402: PUSH
66403: LD_VAR 0 7
66407: ARRAY
66408: PPUSH
66409: CALL_OW 1
66413: ST_TO_ADDR
66414: GO 66370
66416: POP
66417: POP
// end ; tmp := [ ] ;
66418: LD_ADDR_VAR 0 9
66422: PUSH
66423: EMPTY
66424: ST_TO_ADDR
// if mode then
66425: LD_VAR 0 5
66429: IFFALSE 66498
// begin for i = 1 to result do
66431: LD_ADDR_VAR 0 7
66435: PUSH
66436: DOUBLE
66437: LD_INT 1
66439: DEC
66440: ST_TO_ADDR
66441: LD_VAR 0 6
66445: PUSH
66446: FOR_TO
66447: IFFALSE 66486
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
66449: LD_ADDR_VAR 0 9
66453: PUSH
66454: LD_VAR 0 9
66458: PPUSH
66459: LD_VAR 0 7
66463: PPUSH
66464: LD_VAR 0 6
66468: PUSH
66469: LD_VAR 0 7
66473: ARRAY
66474: PUSH
66475: LD_INT 1
66477: ARRAY
66478: PPUSH
66479: CALL_OW 1
66483: ST_TO_ADDR
66484: GO 66446
66486: POP
66487: POP
// result := tmp ;
66488: LD_ADDR_VAR 0 6
66492: PUSH
66493: LD_VAR 0 9
66497: ST_TO_ADDR
// end ; end ;
66498: LD_VAR 0 6
66502: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
66503: LD_INT 0
66505: PPUSH
66506: PPUSH
66507: PPUSH
66508: PPUSH
66509: PPUSH
66510: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
66511: LD_ADDR_VAR 0 5
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: LD_INT 0
66521: PUSH
66522: LD_INT 0
66524: PUSH
66525: EMPTY
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: ST_TO_ADDR
// if not x or not y then
66533: LD_VAR 0 2
66537: NOT
66538: PUSH
66539: LD_VAR 0 3
66543: NOT
66544: OR
66545: IFFALSE 66549
// exit ;
66547: GO 68201
// if not range then
66549: LD_VAR 0 4
66553: NOT
66554: IFFALSE 66564
// range := 10 ;
66556: LD_ADDR_VAR 0 4
66560: PUSH
66561: LD_INT 10
66563: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66564: LD_ADDR_VAR 0 8
66568: PUSH
66569: LD_INT 81
66571: PUSH
66572: LD_VAR 0 1
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 92
66583: PUSH
66584: LD_VAR 0 2
66588: PUSH
66589: LD_VAR 0 3
66593: PUSH
66594: LD_VAR 0 4
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 3
66607: PUSH
66608: LD_INT 21
66610: PUSH
66611: LD_INT 3
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: LIST
66626: PPUSH
66627: CALL_OW 69
66631: ST_TO_ADDR
// if not tmp then
66632: LD_VAR 0 8
66636: NOT
66637: IFFALSE 66641
// exit ;
66639: GO 68201
// for i in tmp do
66641: LD_ADDR_VAR 0 6
66645: PUSH
66646: LD_VAR 0 8
66650: PUSH
66651: FOR_IN
66652: IFFALSE 68176
// begin points := [ 0 , 0 , 0 ] ;
66654: LD_ADDR_VAR 0 9
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: LD_INT 0
66664: PUSH
66665: LD_INT 0
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: LIST
66672: ST_TO_ADDR
// bpoints := 1 ;
66673: LD_ADDR_VAR 0 10
66677: PUSH
66678: LD_INT 1
66680: ST_TO_ADDR
// case GetType ( i ) of unit_human :
66681: LD_VAR 0 6
66685: PPUSH
66686: CALL_OW 247
66690: PUSH
66691: LD_INT 1
66693: DOUBLE
66694: EQUAL
66695: IFTRUE 66699
66697: GO 67277
66699: POP
// begin if GetClass ( i ) = 1 then
66700: LD_VAR 0 6
66704: PPUSH
66705: CALL_OW 257
66709: PUSH
66710: LD_INT 1
66712: EQUAL
66713: IFFALSE 66734
// points := [ 10 , 5 , 3 ] ;
66715: LD_ADDR_VAR 0 9
66719: PUSH
66720: LD_INT 10
66722: PUSH
66723: LD_INT 5
66725: PUSH
66726: LD_INT 3
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: LIST
66733: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
66734: LD_VAR 0 6
66738: PPUSH
66739: CALL_OW 257
66743: PUSH
66744: LD_INT 2
66746: PUSH
66747: LD_INT 3
66749: PUSH
66750: LD_INT 4
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: LIST
66757: IN
66758: IFFALSE 66779
// points := [ 3 , 2 , 1 ] ;
66760: LD_ADDR_VAR 0 9
66764: PUSH
66765: LD_INT 3
66767: PUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: LIST
66778: ST_TO_ADDR
// if GetClass ( i ) = 5 then
66779: LD_VAR 0 6
66783: PPUSH
66784: CALL_OW 257
66788: PUSH
66789: LD_INT 5
66791: EQUAL
66792: IFFALSE 66813
// points := [ 130 , 5 , 2 ] ;
66794: LD_ADDR_VAR 0 9
66798: PUSH
66799: LD_INT 130
66801: PUSH
66802: LD_INT 5
66804: PUSH
66805: LD_INT 2
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: LIST
66812: ST_TO_ADDR
// if GetClass ( i ) = 8 then
66813: LD_VAR 0 6
66817: PPUSH
66818: CALL_OW 257
66822: PUSH
66823: LD_INT 8
66825: EQUAL
66826: IFFALSE 66847
// points := [ 35 , 35 , 30 ] ;
66828: LD_ADDR_VAR 0 9
66832: PUSH
66833: LD_INT 35
66835: PUSH
66836: LD_INT 35
66838: PUSH
66839: LD_INT 30
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: LIST
66846: ST_TO_ADDR
// if GetClass ( i ) = 9 then
66847: LD_VAR 0 6
66851: PPUSH
66852: CALL_OW 257
66856: PUSH
66857: LD_INT 9
66859: EQUAL
66860: IFFALSE 66881
// points := [ 20 , 55 , 40 ] ;
66862: LD_ADDR_VAR 0 9
66866: PUSH
66867: LD_INT 20
66869: PUSH
66870: LD_INT 55
66872: PUSH
66873: LD_INT 40
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: LIST
66880: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
66881: LD_VAR 0 6
66885: PPUSH
66886: CALL_OW 257
66890: PUSH
66891: LD_INT 12
66893: PUSH
66894: LD_INT 16
66896: PUSH
66897: EMPTY
66898: LIST
66899: LIST
66900: IN
66901: IFFALSE 66922
// points := [ 5 , 3 , 2 ] ;
66903: LD_ADDR_VAR 0 9
66907: PUSH
66908: LD_INT 5
66910: PUSH
66911: LD_INT 3
66913: PUSH
66914: LD_INT 2
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: LIST
66921: ST_TO_ADDR
// if GetClass ( i ) = 17 then
66922: LD_VAR 0 6
66926: PPUSH
66927: CALL_OW 257
66931: PUSH
66932: LD_INT 17
66934: EQUAL
66935: IFFALSE 66956
// points := [ 100 , 50 , 75 ] ;
66937: LD_ADDR_VAR 0 9
66941: PUSH
66942: LD_INT 100
66944: PUSH
66945: LD_INT 50
66947: PUSH
66948: LD_INT 75
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: LIST
66955: ST_TO_ADDR
// if GetClass ( i ) = 15 then
66956: LD_VAR 0 6
66960: PPUSH
66961: CALL_OW 257
66965: PUSH
66966: LD_INT 15
66968: EQUAL
66969: IFFALSE 66990
// points := [ 10 , 5 , 3 ] ;
66971: LD_ADDR_VAR 0 9
66975: PUSH
66976: LD_INT 10
66978: PUSH
66979: LD_INT 5
66981: PUSH
66982: LD_INT 3
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: LIST
66989: ST_TO_ADDR
// if GetClass ( i ) = 14 then
66990: LD_VAR 0 6
66994: PPUSH
66995: CALL_OW 257
66999: PUSH
67000: LD_INT 14
67002: EQUAL
67003: IFFALSE 67024
// points := [ 10 , 0 , 0 ] ;
67005: LD_ADDR_VAR 0 9
67009: PUSH
67010: LD_INT 10
67012: PUSH
67013: LD_INT 0
67015: PUSH
67016: LD_INT 0
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: LIST
67023: ST_TO_ADDR
// if GetClass ( i ) = 11 then
67024: LD_VAR 0 6
67028: PPUSH
67029: CALL_OW 257
67033: PUSH
67034: LD_INT 11
67036: EQUAL
67037: IFFALSE 67058
// points := [ 30 , 10 , 5 ] ;
67039: LD_ADDR_VAR 0 9
67043: PUSH
67044: LD_INT 30
67046: PUSH
67047: LD_INT 10
67049: PUSH
67050: LD_INT 5
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: LIST
67057: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
67058: LD_VAR 0 1
67062: PPUSH
67063: LD_INT 5
67065: PPUSH
67066: CALL_OW 321
67070: PUSH
67071: LD_INT 2
67073: EQUAL
67074: IFFALSE 67091
// bpoints := bpoints * 1.8 ;
67076: LD_ADDR_VAR 0 10
67080: PUSH
67081: LD_VAR 0 10
67085: PUSH
67086: LD_REAL  1.80000000000000E+0000
67089: MUL
67090: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
67091: LD_VAR 0 6
67095: PPUSH
67096: CALL_OW 257
67100: PUSH
67101: LD_INT 1
67103: PUSH
67104: LD_INT 2
67106: PUSH
67107: LD_INT 3
67109: PUSH
67110: LD_INT 4
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: IN
67119: PUSH
67120: LD_VAR 0 1
67124: PPUSH
67125: LD_INT 51
67127: PPUSH
67128: CALL_OW 321
67132: PUSH
67133: LD_INT 2
67135: EQUAL
67136: AND
67137: IFFALSE 67154
// bpoints := bpoints * 1.2 ;
67139: LD_ADDR_VAR 0 10
67143: PUSH
67144: LD_VAR 0 10
67148: PUSH
67149: LD_REAL  1.20000000000000E+0000
67152: MUL
67153: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67154: LD_VAR 0 6
67158: PPUSH
67159: CALL_OW 257
67163: PUSH
67164: LD_INT 5
67166: PUSH
67167: LD_INT 7
67169: PUSH
67170: LD_INT 9
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: LIST
67177: IN
67178: PUSH
67179: LD_VAR 0 1
67183: PPUSH
67184: LD_INT 52
67186: PPUSH
67187: CALL_OW 321
67191: PUSH
67192: LD_INT 2
67194: EQUAL
67195: AND
67196: IFFALSE 67213
// bpoints := bpoints * 1.5 ;
67198: LD_ADDR_VAR 0 10
67202: PUSH
67203: LD_VAR 0 10
67207: PUSH
67208: LD_REAL  1.50000000000000E+0000
67211: MUL
67212: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67213: LD_VAR 0 1
67217: PPUSH
67218: LD_INT 66
67220: PPUSH
67221: CALL_OW 321
67225: PUSH
67226: LD_INT 2
67228: EQUAL
67229: IFFALSE 67246
// bpoints := bpoints * 1.1 ;
67231: LD_ADDR_VAR 0 10
67235: PUSH
67236: LD_VAR 0 10
67240: PUSH
67241: LD_REAL  1.10000000000000E+0000
67244: MUL
67245: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67246: LD_ADDR_VAR 0 10
67250: PUSH
67251: LD_VAR 0 10
67255: PUSH
67256: LD_VAR 0 6
67260: PPUSH
67261: LD_INT 1
67263: PPUSH
67264: CALL_OW 259
67268: PUSH
67269: LD_REAL  1.15000000000000E+0000
67272: MUL
67273: MUL
67274: ST_TO_ADDR
// end ; unit_vehicle :
67275: GO 68105
67277: LD_INT 2
67279: DOUBLE
67280: EQUAL
67281: IFTRUE 67285
67283: GO 68093
67285: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67286: LD_VAR 0 6
67290: PPUSH
67291: CALL_OW 264
67295: PUSH
67296: LD_INT 2
67298: PUSH
67299: LD_INT 42
67301: PUSH
67302: LD_INT 24
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: LIST
67309: IN
67310: IFFALSE 67331
// points := [ 25 , 5 , 3 ] ;
67312: LD_ADDR_VAR 0 9
67316: PUSH
67317: LD_INT 25
67319: PUSH
67320: LD_INT 5
67322: PUSH
67323: LD_INT 3
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: LIST
67330: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67331: LD_VAR 0 6
67335: PPUSH
67336: CALL_OW 264
67340: PUSH
67341: LD_INT 4
67343: PUSH
67344: LD_INT 43
67346: PUSH
67347: LD_INT 25
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: LIST
67354: IN
67355: IFFALSE 67376
// points := [ 40 , 15 , 5 ] ;
67357: LD_ADDR_VAR 0 9
67361: PUSH
67362: LD_INT 40
67364: PUSH
67365: LD_INT 15
67367: PUSH
67368: LD_INT 5
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: LIST
67375: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67376: LD_VAR 0 6
67380: PPUSH
67381: CALL_OW 264
67385: PUSH
67386: LD_INT 3
67388: PUSH
67389: LD_INT 23
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: IN
67396: IFFALSE 67417
// points := [ 7 , 25 , 8 ] ;
67398: LD_ADDR_VAR 0 9
67402: PUSH
67403: LD_INT 7
67405: PUSH
67406: LD_INT 25
67408: PUSH
67409: LD_INT 8
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: LIST
67416: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
67417: LD_VAR 0 6
67421: PPUSH
67422: CALL_OW 264
67426: PUSH
67427: LD_INT 5
67429: PUSH
67430: LD_INT 27
67432: PUSH
67433: LD_INT 44
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: LIST
67440: IN
67441: IFFALSE 67462
// points := [ 14 , 50 , 16 ] ;
67443: LD_ADDR_VAR 0 9
67447: PUSH
67448: LD_INT 14
67450: PUSH
67451: LD_INT 50
67453: PUSH
67454: LD_INT 16
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
67462: LD_VAR 0 6
67466: PPUSH
67467: CALL_OW 264
67471: PUSH
67472: LD_INT 6
67474: PUSH
67475: LD_INT 46
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: IN
67482: IFFALSE 67503
// points := [ 32 , 120 , 70 ] ;
67484: LD_ADDR_VAR 0 9
67488: PUSH
67489: LD_INT 32
67491: PUSH
67492: LD_INT 120
67494: PUSH
67495: LD_INT 70
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: LIST
67502: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
67503: LD_VAR 0 6
67507: PPUSH
67508: CALL_OW 264
67512: PUSH
67513: LD_INT 7
67515: PUSH
67516: LD_INT 28
67518: PUSH
67519: LD_INT 45
67521: PUSH
67522: LD_EXP 78
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: IN
67533: IFFALSE 67554
// points := [ 35 , 20 , 45 ] ;
67535: LD_ADDR_VAR 0 9
67539: PUSH
67540: LD_INT 35
67542: PUSH
67543: LD_INT 20
67545: PUSH
67546: LD_INT 45
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: LIST
67553: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
67554: LD_VAR 0 6
67558: PPUSH
67559: CALL_OW 264
67563: PUSH
67564: LD_INT 47
67566: PUSH
67567: EMPTY
67568: LIST
67569: IN
67570: IFFALSE 67591
// points := [ 67 , 45 , 75 ] ;
67572: LD_ADDR_VAR 0 9
67576: PUSH
67577: LD_INT 67
67579: PUSH
67580: LD_INT 45
67582: PUSH
67583: LD_INT 75
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: LIST
67590: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
67591: LD_VAR 0 6
67595: PPUSH
67596: CALL_OW 264
67600: PUSH
67601: LD_INT 26
67603: PUSH
67604: EMPTY
67605: LIST
67606: IN
67607: IFFALSE 67628
// points := [ 120 , 30 , 80 ] ;
67609: LD_ADDR_VAR 0 9
67613: PUSH
67614: LD_INT 120
67616: PUSH
67617: LD_INT 30
67619: PUSH
67620: LD_INT 80
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: LIST
67627: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
67628: LD_VAR 0 6
67632: PPUSH
67633: CALL_OW 264
67637: PUSH
67638: LD_INT 22
67640: PUSH
67641: EMPTY
67642: LIST
67643: IN
67644: IFFALSE 67665
// points := [ 40 , 1 , 1 ] ;
67646: LD_ADDR_VAR 0 9
67650: PUSH
67651: LD_INT 40
67653: PUSH
67654: LD_INT 1
67656: PUSH
67657: LD_INT 1
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: LIST
67664: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
67665: LD_VAR 0 6
67669: PPUSH
67670: CALL_OW 264
67674: PUSH
67675: LD_INT 29
67677: PUSH
67678: EMPTY
67679: LIST
67680: IN
67681: IFFALSE 67702
// points := [ 70 , 200 , 400 ] ;
67683: LD_ADDR_VAR 0 9
67687: PUSH
67688: LD_INT 70
67690: PUSH
67691: LD_INT 200
67693: PUSH
67694: LD_INT 400
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: LIST
67701: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
67702: LD_VAR 0 6
67706: PPUSH
67707: CALL_OW 264
67711: PUSH
67712: LD_INT 14
67714: PUSH
67715: LD_INT 53
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: IN
67722: IFFALSE 67743
// points := [ 40 , 10 , 20 ] ;
67724: LD_ADDR_VAR 0 9
67728: PUSH
67729: LD_INT 40
67731: PUSH
67732: LD_INT 10
67734: PUSH
67735: LD_INT 20
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: LIST
67742: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
67743: LD_VAR 0 6
67747: PPUSH
67748: CALL_OW 264
67752: PUSH
67753: LD_INT 9
67755: PUSH
67756: EMPTY
67757: LIST
67758: IN
67759: IFFALSE 67780
// points := [ 5 , 70 , 20 ] ;
67761: LD_ADDR_VAR 0 9
67765: PUSH
67766: LD_INT 5
67768: PUSH
67769: LD_INT 70
67771: PUSH
67772: LD_INT 20
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: LIST
67779: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
67780: LD_VAR 0 6
67784: PPUSH
67785: CALL_OW 264
67789: PUSH
67790: LD_INT 10
67792: PUSH
67793: EMPTY
67794: LIST
67795: IN
67796: IFFALSE 67817
// points := [ 35 , 110 , 70 ] ;
67798: LD_ADDR_VAR 0 9
67802: PUSH
67803: LD_INT 35
67805: PUSH
67806: LD_INT 110
67808: PUSH
67809: LD_INT 70
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: LIST
67816: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
67817: LD_VAR 0 6
67821: PPUSH
67822: CALL_OW 265
67826: PUSH
67827: LD_INT 25
67829: EQUAL
67830: IFFALSE 67851
// points := [ 80 , 65 , 100 ] ;
67832: LD_ADDR_VAR 0 9
67836: PUSH
67837: LD_INT 80
67839: PUSH
67840: LD_INT 65
67842: PUSH
67843: LD_INT 100
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: LIST
67850: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
67851: LD_VAR 0 6
67855: PPUSH
67856: CALL_OW 263
67860: PUSH
67861: LD_INT 1
67863: EQUAL
67864: IFFALSE 67899
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
67866: LD_ADDR_VAR 0 10
67870: PUSH
67871: LD_VAR 0 10
67875: PUSH
67876: LD_VAR 0 6
67880: PPUSH
67881: CALL_OW 311
67885: PPUSH
67886: LD_INT 3
67888: PPUSH
67889: CALL_OW 259
67893: PUSH
67894: LD_INT 4
67896: MUL
67897: MUL
67898: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
67899: LD_VAR 0 6
67903: PPUSH
67904: CALL_OW 263
67908: PUSH
67909: LD_INT 2
67911: EQUAL
67912: IFFALSE 67963
// begin j := IsControledBy ( i ) ;
67914: LD_ADDR_VAR 0 7
67918: PUSH
67919: LD_VAR 0 6
67923: PPUSH
67924: CALL_OW 312
67928: ST_TO_ADDR
// if j then
67929: LD_VAR 0 7
67933: IFFALSE 67963
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
67935: LD_ADDR_VAR 0 10
67939: PUSH
67940: LD_VAR 0 10
67944: PUSH
67945: LD_VAR 0 7
67949: PPUSH
67950: LD_INT 3
67952: PPUSH
67953: CALL_OW 259
67957: PUSH
67958: LD_INT 3
67960: MUL
67961: MUL
67962: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
67963: LD_VAR 0 6
67967: PPUSH
67968: CALL_OW 264
67972: PUSH
67973: LD_INT 5
67975: PUSH
67976: LD_INT 6
67978: PUSH
67979: LD_INT 46
67981: PUSH
67982: LD_INT 44
67984: PUSH
67985: LD_INT 47
67987: PUSH
67988: LD_INT 45
67990: PUSH
67991: LD_INT 28
67993: PUSH
67994: LD_INT 7
67996: PUSH
67997: LD_INT 27
67999: PUSH
68000: LD_INT 29
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: IN
68015: PUSH
68016: LD_VAR 0 1
68020: PPUSH
68021: LD_INT 52
68023: PPUSH
68024: CALL_OW 321
68028: PUSH
68029: LD_INT 2
68031: EQUAL
68032: AND
68033: IFFALSE 68050
// bpoints := bpoints * 1.2 ;
68035: LD_ADDR_VAR 0 10
68039: PUSH
68040: LD_VAR 0 10
68044: PUSH
68045: LD_REAL  1.20000000000000E+0000
68048: MUL
68049: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
68050: LD_VAR 0 6
68054: PPUSH
68055: CALL_OW 264
68059: PUSH
68060: LD_INT 6
68062: PUSH
68063: LD_INT 46
68065: PUSH
68066: LD_INT 47
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: LIST
68073: IN
68074: IFFALSE 68091
// bpoints := bpoints * 1.2 ;
68076: LD_ADDR_VAR 0 10
68080: PUSH
68081: LD_VAR 0 10
68085: PUSH
68086: LD_REAL  1.20000000000000E+0000
68089: MUL
68090: ST_TO_ADDR
// end ; unit_building :
68091: GO 68105
68093: LD_INT 3
68095: DOUBLE
68096: EQUAL
68097: IFTRUE 68101
68099: GO 68104
68101: POP
// ; end ;
68102: GO 68105
68104: POP
// for j = 1 to 3 do
68105: LD_ADDR_VAR 0 7
68109: PUSH
68110: DOUBLE
68111: LD_INT 1
68113: DEC
68114: ST_TO_ADDR
68115: LD_INT 3
68117: PUSH
68118: FOR_TO
68119: IFFALSE 68172
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
68121: LD_ADDR_VAR 0 5
68125: PUSH
68126: LD_VAR 0 5
68130: PPUSH
68131: LD_VAR 0 7
68135: PPUSH
68136: LD_VAR 0 5
68140: PUSH
68141: LD_VAR 0 7
68145: ARRAY
68146: PUSH
68147: LD_VAR 0 9
68151: PUSH
68152: LD_VAR 0 7
68156: ARRAY
68157: PUSH
68158: LD_VAR 0 10
68162: MUL
68163: PLUS
68164: PPUSH
68165: CALL_OW 1
68169: ST_TO_ADDR
68170: GO 68118
68172: POP
68173: POP
// end ;
68174: GO 66651
68176: POP
68177: POP
// result := Replace ( result , 4 , tmp ) ;
68178: LD_ADDR_VAR 0 5
68182: PUSH
68183: LD_VAR 0 5
68187: PPUSH
68188: LD_INT 4
68190: PPUSH
68191: LD_VAR 0 8
68195: PPUSH
68196: CALL_OW 1
68200: ST_TO_ADDR
// end ;
68201: LD_VAR 0 5
68205: RET
// export function DangerAtRange ( unit , range ) ; begin
68206: LD_INT 0
68208: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68209: LD_ADDR_VAR 0 3
68213: PUSH
68214: LD_VAR 0 1
68218: PPUSH
68219: CALL_OW 255
68223: PPUSH
68224: LD_VAR 0 1
68228: PPUSH
68229: CALL_OW 250
68233: PPUSH
68234: LD_VAR 0 1
68238: PPUSH
68239: CALL_OW 251
68243: PPUSH
68244: LD_VAR 0 2
68248: PPUSH
68249: CALL 66503 0 4
68253: ST_TO_ADDR
// end ;
68254: LD_VAR 0 3
68258: RET
// export function DangerInArea ( side , area ) ; begin
68259: LD_INT 0
68261: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68262: LD_ADDR_VAR 0 3
68266: PUSH
68267: LD_VAR 0 2
68271: PPUSH
68272: LD_INT 81
68274: PUSH
68275: LD_VAR 0 1
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PPUSH
68284: CALL_OW 70
68288: ST_TO_ADDR
// end ;
68289: LD_VAR 0 3
68293: RET
// export function IsExtension ( b ) ; begin
68294: LD_INT 0
68296: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68297: LD_ADDR_VAR 0 2
68301: PUSH
68302: LD_VAR 0 1
68306: PUSH
68307: LD_INT 23
68309: PUSH
68310: LD_INT 20
68312: PUSH
68313: LD_INT 22
68315: PUSH
68316: LD_INT 17
68318: PUSH
68319: LD_INT 24
68321: PUSH
68322: LD_INT 21
68324: PUSH
68325: LD_INT 19
68327: PUSH
68328: LD_INT 16
68330: PUSH
68331: LD_INT 25
68333: PUSH
68334: LD_INT 18
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: IN
68349: ST_TO_ADDR
// end ;
68350: LD_VAR 0 2
68354: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
68355: LD_INT 0
68357: PPUSH
68358: PPUSH
68359: PPUSH
// result := [ ] ;
68360: LD_ADDR_VAR 0 4
68364: PUSH
68365: EMPTY
68366: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68367: LD_ADDR_VAR 0 5
68371: PUSH
68372: LD_VAR 0 2
68376: PPUSH
68377: LD_INT 21
68379: PUSH
68380: LD_INT 3
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PPUSH
68387: CALL_OW 70
68391: ST_TO_ADDR
// if not tmp then
68392: LD_VAR 0 5
68396: NOT
68397: IFFALSE 68401
// exit ;
68399: GO 68465
// if checkLink then
68401: LD_VAR 0 3
68405: IFFALSE 68455
// begin for i in tmp do
68407: LD_ADDR_VAR 0 6
68411: PUSH
68412: LD_VAR 0 5
68416: PUSH
68417: FOR_IN
68418: IFFALSE 68453
// if GetBase ( i ) <> base then
68420: LD_VAR 0 6
68424: PPUSH
68425: CALL_OW 274
68429: PUSH
68430: LD_VAR 0 1
68434: NONEQUAL
68435: IFFALSE 68451
// ComLinkToBase ( base , i ) ;
68437: LD_VAR 0 1
68441: PPUSH
68442: LD_VAR 0 6
68446: PPUSH
68447: CALL_OW 169
68451: GO 68417
68453: POP
68454: POP
// end ; result := tmp ;
68455: LD_ADDR_VAR 0 4
68459: PUSH
68460: LD_VAR 0 5
68464: ST_TO_ADDR
// end ;
68465: LD_VAR 0 4
68469: RET
// export function ComComplete ( units , b ) ; var i ; begin
68470: LD_INT 0
68472: PPUSH
68473: PPUSH
// if not units then
68474: LD_VAR 0 1
68478: NOT
68479: IFFALSE 68483
// exit ;
68481: GO 68573
// for i in units do
68483: LD_ADDR_VAR 0 4
68487: PUSH
68488: LD_VAR 0 1
68492: PUSH
68493: FOR_IN
68494: IFFALSE 68571
// if BuildingStatus ( b ) = bs_build then
68496: LD_VAR 0 2
68500: PPUSH
68501: CALL_OW 461
68505: PUSH
68506: LD_INT 1
68508: EQUAL
68509: IFFALSE 68569
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
68511: LD_VAR 0 4
68515: PPUSH
68516: LD_STRING h
68518: PUSH
68519: LD_VAR 0 2
68523: PPUSH
68524: CALL_OW 250
68528: PUSH
68529: LD_VAR 0 2
68533: PPUSH
68534: CALL_OW 251
68538: PUSH
68539: LD_VAR 0 2
68543: PUSH
68544: LD_INT 0
68546: PUSH
68547: LD_INT 0
68549: PUSH
68550: LD_INT 0
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: PUSH
68562: EMPTY
68563: LIST
68564: PPUSH
68565: CALL_OW 446
68569: GO 68493
68571: POP
68572: POP
// end ;
68573: LD_VAR 0 3
68577: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
68578: LD_INT 0
68580: PPUSH
68581: PPUSH
68582: PPUSH
68583: PPUSH
68584: PPUSH
68585: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
68586: LD_VAR 0 1
68590: NOT
68591: PUSH
68592: LD_VAR 0 1
68596: PPUSH
68597: CALL_OW 263
68601: PUSH
68602: LD_INT 2
68604: EQUAL
68605: NOT
68606: OR
68607: IFFALSE 68611
// exit ;
68609: GO 68927
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
68611: LD_ADDR_VAR 0 6
68615: PUSH
68616: LD_INT 22
68618: PUSH
68619: LD_VAR 0 1
68623: PPUSH
68624: CALL_OW 255
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 2
68635: PUSH
68636: LD_INT 30
68638: PUSH
68639: LD_INT 36
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 34
68648: PUSH
68649: LD_INT 31
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: LIST
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PPUSH
68665: CALL_OW 69
68669: ST_TO_ADDR
// if not tmp then
68670: LD_VAR 0 6
68674: NOT
68675: IFFALSE 68679
// exit ;
68677: GO 68927
// result := [ ] ;
68679: LD_ADDR_VAR 0 2
68683: PUSH
68684: EMPTY
68685: ST_TO_ADDR
// for i in tmp do
68686: LD_ADDR_VAR 0 3
68690: PUSH
68691: LD_VAR 0 6
68695: PUSH
68696: FOR_IN
68697: IFFALSE 68768
// begin t := UnitsInside ( i ) ;
68699: LD_ADDR_VAR 0 4
68703: PUSH
68704: LD_VAR 0 3
68708: PPUSH
68709: CALL_OW 313
68713: ST_TO_ADDR
// if t then
68714: LD_VAR 0 4
68718: IFFALSE 68766
// for j in t do
68720: LD_ADDR_VAR 0 7
68724: PUSH
68725: LD_VAR 0 4
68729: PUSH
68730: FOR_IN
68731: IFFALSE 68764
// result := Insert ( result , result + 1 , j ) ;
68733: LD_ADDR_VAR 0 2
68737: PUSH
68738: LD_VAR 0 2
68742: PPUSH
68743: LD_VAR 0 2
68747: PUSH
68748: LD_INT 1
68750: PLUS
68751: PPUSH
68752: LD_VAR 0 7
68756: PPUSH
68757: CALL_OW 2
68761: ST_TO_ADDR
68762: GO 68730
68764: POP
68765: POP
// end ;
68766: GO 68696
68768: POP
68769: POP
// if not result then
68770: LD_VAR 0 2
68774: NOT
68775: IFFALSE 68779
// exit ;
68777: GO 68927
// mech := result [ 1 ] ;
68779: LD_ADDR_VAR 0 5
68783: PUSH
68784: LD_VAR 0 2
68788: PUSH
68789: LD_INT 1
68791: ARRAY
68792: ST_TO_ADDR
// if result > 1 then
68793: LD_VAR 0 2
68797: PUSH
68798: LD_INT 1
68800: GREATER
68801: IFFALSE 68913
// for i = 2 to result do
68803: LD_ADDR_VAR 0 3
68807: PUSH
68808: DOUBLE
68809: LD_INT 2
68811: DEC
68812: ST_TO_ADDR
68813: LD_VAR 0 2
68817: PUSH
68818: FOR_TO
68819: IFFALSE 68911
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
68821: LD_ADDR_VAR 0 4
68825: PUSH
68826: LD_VAR 0 2
68830: PUSH
68831: LD_VAR 0 3
68835: ARRAY
68836: PPUSH
68837: LD_INT 3
68839: PPUSH
68840: CALL_OW 259
68844: PUSH
68845: LD_VAR 0 2
68849: PUSH
68850: LD_VAR 0 3
68854: ARRAY
68855: PPUSH
68856: CALL_OW 432
68860: MINUS
68861: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
68862: LD_VAR 0 4
68866: PUSH
68867: LD_VAR 0 5
68871: PPUSH
68872: LD_INT 3
68874: PPUSH
68875: CALL_OW 259
68879: PUSH
68880: LD_VAR 0 5
68884: PPUSH
68885: CALL_OW 432
68889: MINUS
68890: GREATEREQUAL
68891: IFFALSE 68909
// mech := result [ i ] ;
68893: LD_ADDR_VAR 0 5
68897: PUSH
68898: LD_VAR 0 2
68902: PUSH
68903: LD_VAR 0 3
68907: ARRAY
68908: ST_TO_ADDR
// end ;
68909: GO 68818
68911: POP
68912: POP
// ComLinkTo ( vehicle , mech ) ;
68913: LD_VAR 0 1
68917: PPUSH
68918: LD_VAR 0 5
68922: PPUSH
68923: CALL_OW 135
// end ;
68927: LD_VAR 0 2
68931: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
68932: LD_INT 0
68934: PPUSH
68935: PPUSH
68936: PPUSH
68937: PPUSH
68938: PPUSH
68939: PPUSH
68940: PPUSH
68941: PPUSH
68942: PPUSH
68943: PPUSH
68944: PPUSH
68945: PPUSH
68946: PPUSH
// result := [ ] ;
68947: LD_ADDR_VAR 0 7
68951: PUSH
68952: EMPTY
68953: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
68954: LD_VAR 0 1
68958: PPUSH
68959: CALL_OW 266
68963: PUSH
68964: LD_INT 0
68966: PUSH
68967: LD_INT 1
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: IN
68974: NOT
68975: IFFALSE 68979
// exit ;
68977: GO 70613
// if name then
68979: LD_VAR 0 3
68983: IFFALSE 68999
// SetBName ( base_dep , name ) ;
68985: LD_VAR 0 1
68989: PPUSH
68990: LD_VAR 0 3
68994: PPUSH
68995: CALL_OW 500
// base := GetBase ( base_dep ) ;
68999: LD_ADDR_VAR 0 15
69003: PUSH
69004: LD_VAR 0 1
69008: PPUSH
69009: CALL_OW 274
69013: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
69014: LD_ADDR_VAR 0 16
69018: PUSH
69019: LD_VAR 0 1
69023: PPUSH
69024: CALL_OW 255
69028: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
69029: LD_ADDR_VAR 0 17
69033: PUSH
69034: LD_VAR 0 1
69038: PPUSH
69039: CALL_OW 248
69043: ST_TO_ADDR
// if sources then
69044: LD_VAR 0 5
69048: IFFALSE 69095
// for i = 1 to 3 do
69050: LD_ADDR_VAR 0 8
69054: PUSH
69055: DOUBLE
69056: LD_INT 1
69058: DEC
69059: ST_TO_ADDR
69060: LD_INT 3
69062: PUSH
69063: FOR_TO
69064: IFFALSE 69093
// AddResourceType ( base , i , sources [ i ] ) ;
69066: LD_VAR 0 15
69070: PPUSH
69071: LD_VAR 0 8
69075: PPUSH
69076: LD_VAR 0 5
69080: PUSH
69081: LD_VAR 0 8
69085: ARRAY
69086: PPUSH
69087: CALL_OW 276
69091: GO 69063
69093: POP
69094: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
69095: LD_ADDR_VAR 0 18
69099: PUSH
69100: LD_VAR 0 15
69104: PPUSH
69105: LD_VAR 0 2
69109: PPUSH
69110: LD_INT 1
69112: PPUSH
69113: CALL 68355 0 3
69117: ST_TO_ADDR
// InitHc ;
69118: CALL_OW 19
// InitUc ;
69122: CALL_OW 18
// uc_side := side ;
69126: LD_ADDR_OWVAR 20
69130: PUSH
69131: LD_VAR 0 16
69135: ST_TO_ADDR
// uc_nation := nation ;
69136: LD_ADDR_OWVAR 21
69140: PUSH
69141: LD_VAR 0 17
69145: ST_TO_ADDR
// if buildings then
69146: LD_VAR 0 18
69150: IFFALSE 70472
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
69152: LD_ADDR_VAR 0 19
69156: PUSH
69157: LD_VAR 0 18
69161: PPUSH
69162: LD_INT 2
69164: PUSH
69165: LD_INT 30
69167: PUSH
69168: LD_INT 29
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 30
69177: PUSH
69178: LD_INT 30
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: LIST
69189: PPUSH
69190: CALL_OW 72
69194: ST_TO_ADDR
// if tmp then
69195: LD_VAR 0 19
69199: IFFALSE 69247
// for i in tmp do
69201: LD_ADDR_VAR 0 8
69205: PUSH
69206: LD_VAR 0 19
69210: PUSH
69211: FOR_IN
69212: IFFALSE 69245
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69214: LD_VAR 0 8
69218: PPUSH
69219: CALL_OW 250
69223: PPUSH
69224: LD_VAR 0 8
69228: PPUSH
69229: CALL_OW 251
69233: PPUSH
69234: LD_VAR 0 16
69238: PPUSH
69239: CALL_OW 441
69243: GO 69211
69245: POP
69246: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69247: LD_VAR 0 18
69251: PPUSH
69252: LD_INT 2
69254: PUSH
69255: LD_INT 30
69257: PUSH
69258: LD_INT 32
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 30
69267: PUSH
69268: LD_INT 33
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: LIST
69279: PPUSH
69280: CALL_OW 72
69284: IFFALSE 69372
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69286: LD_ADDR_VAR 0 8
69290: PUSH
69291: LD_VAR 0 18
69295: PPUSH
69296: LD_INT 2
69298: PUSH
69299: LD_INT 30
69301: PUSH
69302: LD_INT 32
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 30
69311: PUSH
69312: LD_INT 33
69314: PUSH
69315: EMPTY
69316: LIST
69317: LIST
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: LIST
69323: PPUSH
69324: CALL_OW 72
69328: PUSH
69329: FOR_IN
69330: IFFALSE 69370
// begin if not GetBWeapon ( i ) then
69332: LD_VAR 0 8
69336: PPUSH
69337: CALL_OW 269
69341: NOT
69342: IFFALSE 69368
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69344: LD_VAR 0 8
69348: PPUSH
69349: LD_VAR 0 8
69353: PPUSH
69354: LD_VAR 0 2
69358: PPUSH
69359: CALL 70618 0 2
69363: PPUSH
69364: CALL_OW 431
// end ;
69368: GO 69329
69370: POP
69371: POP
// end ; for i = 1 to personel do
69372: LD_ADDR_VAR 0 8
69376: PUSH
69377: DOUBLE
69378: LD_INT 1
69380: DEC
69381: ST_TO_ADDR
69382: LD_VAR 0 6
69386: PUSH
69387: FOR_TO
69388: IFFALSE 70452
// begin if i > 4 then
69390: LD_VAR 0 8
69394: PUSH
69395: LD_INT 4
69397: GREATER
69398: IFFALSE 69402
// break ;
69400: GO 70452
// case i of 1 :
69402: LD_VAR 0 8
69406: PUSH
69407: LD_INT 1
69409: DOUBLE
69410: EQUAL
69411: IFTRUE 69415
69413: GO 69495
69415: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
69416: LD_ADDR_VAR 0 12
69420: PUSH
69421: LD_VAR 0 18
69425: PPUSH
69426: LD_INT 22
69428: PUSH
69429: LD_VAR 0 16
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 58
69440: PUSH
69441: EMPTY
69442: LIST
69443: PUSH
69444: LD_INT 2
69446: PUSH
69447: LD_INT 30
69449: PUSH
69450: LD_INT 32
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 30
69459: PUSH
69460: LD_INT 4
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 30
69469: PUSH
69470: LD_INT 5
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: LIST
69487: PPUSH
69488: CALL_OW 72
69492: ST_TO_ADDR
69493: GO 69717
69495: LD_INT 2
69497: DOUBLE
69498: EQUAL
69499: IFTRUE 69503
69501: GO 69565
69503: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
69504: LD_ADDR_VAR 0 12
69508: PUSH
69509: LD_VAR 0 18
69513: PPUSH
69514: LD_INT 22
69516: PUSH
69517: LD_VAR 0 16
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 2
69528: PUSH
69529: LD_INT 30
69531: PUSH
69532: LD_INT 0
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 30
69541: PUSH
69542: LD_INT 1
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: LIST
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PPUSH
69558: CALL_OW 72
69562: ST_TO_ADDR
69563: GO 69717
69565: LD_INT 3
69567: DOUBLE
69568: EQUAL
69569: IFTRUE 69573
69571: GO 69635
69573: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
69574: LD_ADDR_VAR 0 12
69578: PUSH
69579: LD_VAR 0 18
69583: PPUSH
69584: LD_INT 22
69586: PUSH
69587: LD_VAR 0 16
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 2
69598: PUSH
69599: LD_INT 30
69601: PUSH
69602: LD_INT 2
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PUSH
69609: LD_INT 30
69611: PUSH
69612: LD_INT 3
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: LIST
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PPUSH
69628: CALL_OW 72
69632: ST_TO_ADDR
69633: GO 69717
69635: LD_INT 4
69637: DOUBLE
69638: EQUAL
69639: IFTRUE 69643
69641: GO 69716
69643: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
69644: LD_ADDR_VAR 0 12
69648: PUSH
69649: LD_VAR 0 18
69653: PPUSH
69654: LD_INT 22
69656: PUSH
69657: LD_VAR 0 16
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 2
69668: PUSH
69669: LD_INT 30
69671: PUSH
69672: LD_INT 6
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 30
69681: PUSH
69682: LD_INT 7
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 30
69691: PUSH
69692: LD_INT 8
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PPUSH
69709: CALL_OW 72
69713: ST_TO_ADDR
69714: GO 69717
69716: POP
// if i = 1 then
69717: LD_VAR 0 8
69721: PUSH
69722: LD_INT 1
69724: EQUAL
69725: IFFALSE 69836
// begin tmp := [ ] ;
69727: LD_ADDR_VAR 0 19
69731: PUSH
69732: EMPTY
69733: ST_TO_ADDR
// for j in f do
69734: LD_ADDR_VAR 0 9
69738: PUSH
69739: LD_VAR 0 12
69743: PUSH
69744: FOR_IN
69745: IFFALSE 69818
// if GetBType ( j ) = b_bunker then
69747: LD_VAR 0 9
69751: PPUSH
69752: CALL_OW 266
69756: PUSH
69757: LD_INT 32
69759: EQUAL
69760: IFFALSE 69787
// tmp := Insert ( tmp , 1 , j ) else
69762: LD_ADDR_VAR 0 19
69766: PUSH
69767: LD_VAR 0 19
69771: PPUSH
69772: LD_INT 1
69774: PPUSH
69775: LD_VAR 0 9
69779: PPUSH
69780: CALL_OW 2
69784: ST_TO_ADDR
69785: GO 69816
// tmp := Insert ( tmp , tmp + 1 , j ) ;
69787: LD_ADDR_VAR 0 19
69791: PUSH
69792: LD_VAR 0 19
69796: PPUSH
69797: LD_VAR 0 19
69801: PUSH
69802: LD_INT 1
69804: PLUS
69805: PPUSH
69806: LD_VAR 0 9
69810: PPUSH
69811: CALL_OW 2
69815: ST_TO_ADDR
69816: GO 69744
69818: POP
69819: POP
// if tmp then
69820: LD_VAR 0 19
69824: IFFALSE 69836
// f := tmp ;
69826: LD_ADDR_VAR 0 12
69830: PUSH
69831: LD_VAR 0 19
69835: ST_TO_ADDR
// end ; x := personel [ i ] ;
69836: LD_ADDR_VAR 0 13
69840: PUSH
69841: LD_VAR 0 6
69845: PUSH
69846: LD_VAR 0 8
69850: ARRAY
69851: ST_TO_ADDR
// if x = - 1 then
69852: LD_VAR 0 13
69856: PUSH
69857: LD_INT 1
69859: NEG
69860: EQUAL
69861: IFFALSE 70070
// begin for j in f do
69863: LD_ADDR_VAR 0 9
69867: PUSH
69868: LD_VAR 0 12
69872: PUSH
69873: FOR_IN
69874: IFFALSE 70066
// repeat InitHc ;
69876: CALL_OW 19
// if GetBType ( j ) = b_barracks then
69880: LD_VAR 0 9
69884: PPUSH
69885: CALL_OW 266
69889: PUSH
69890: LD_INT 5
69892: EQUAL
69893: IFFALSE 69963
// begin if UnitsInside ( j ) < 3 then
69895: LD_VAR 0 9
69899: PPUSH
69900: CALL_OW 313
69904: PUSH
69905: LD_INT 3
69907: LESS
69908: IFFALSE 69944
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
69910: LD_INT 0
69912: PPUSH
69913: LD_INT 5
69915: PUSH
69916: LD_INT 8
69918: PUSH
69919: LD_INT 9
69921: PUSH
69922: EMPTY
69923: LIST
69924: LIST
69925: LIST
69926: PUSH
69927: LD_VAR 0 17
69931: ARRAY
69932: PPUSH
69933: LD_VAR 0 4
69937: PPUSH
69938: CALL_OW 380
69942: GO 69961
// PrepareHuman ( false , i , skill ) ;
69944: LD_INT 0
69946: PPUSH
69947: LD_VAR 0 8
69951: PPUSH
69952: LD_VAR 0 4
69956: PPUSH
69957: CALL_OW 380
// end else
69961: GO 69980
// PrepareHuman ( false , i , skill ) ;
69963: LD_INT 0
69965: PPUSH
69966: LD_VAR 0 8
69970: PPUSH
69971: LD_VAR 0 4
69975: PPUSH
69976: CALL_OW 380
// un := CreateHuman ;
69980: LD_ADDR_VAR 0 14
69984: PUSH
69985: CALL_OW 44
69989: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69990: LD_ADDR_VAR 0 7
69994: PUSH
69995: LD_VAR 0 7
69999: PPUSH
70000: LD_INT 1
70002: PPUSH
70003: LD_VAR 0 14
70007: PPUSH
70008: CALL_OW 2
70012: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
70013: LD_VAR 0 14
70017: PPUSH
70018: LD_VAR 0 9
70022: PPUSH
70023: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
70027: LD_VAR 0 9
70031: PPUSH
70032: CALL_OW 313
70036: PUSH
70037: LD_INT 6
70039: EQUAL
70040: PUSH
70041: LD_VAR 0 9
70045: PPUSH
70046: CALL_OW 266
70050: PUSH
70051: LD_INT 32
70053: PUSH
70054: LD_INT 31
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: IN
70061: OR
70062: IFFALSE 69876
70064: GO 69873
70066: POP
70067: POP
// end else
70068: GO 70450
// for j = 1 to x do
70070: LD_ADDR_VAR 0 9
70074: PUSH
70075: DOUBLE
70076: LD_INT 1
70078: DEC
70079: ST_TO_ADDR
70080: LD_VAR 0 13
70084: PUSH
70085: FOR_TO
70086: IFFALSE 70448
// begin InitHc ;
70088: CALL_OW 19
// if not f then
70092: LD_VAR 0 12
70096: NOT
70097: IFFALSE 70186
// begin PrepareHuman ( false , i , skill ) ;
70099: LD_INT 0
70101: PPUSH
70102: LD_VAR 0 8
70106: PPUSH
70107: LD_VAR 0 4
70111: PPUSH
70112: CALL_OW 380
// un := CreateHuman ;
70116: LD_ADDR_VAR 0 14
70120: PUSH
70121: CALL_OW 44
70125: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70126: LD_ADDR_VAR 0 7
70130: PUSH
70131: LD_VAR 0 7
70135: PPUSH
70136: LD_INT 1
70138: PPUSH
70139: LD_VAR 0 14
70143: PPUSH
70144: CALL_OW 2
70148: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70149: LD_VAR 0 14
70153: PPUSH
70154: LD_VAR 0 1
70158: PPUSH
70159: CALL_OW 250
70163: PPUSH
70164: LD_VAR 0 1
70168: PPUSH
70169: CALL_OW 251
70173: PPUSH
70174: LD_INT 10
70176: PPUSH
70177: LD_INT 0
70179: PPUSH
70180: CALL_OW 50
// continue ;
70184: GO 70085
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70186: LD_VAR 0 12
70190: PUSH
70191: LD_INT 1
70193: ARRAY
70194: PPUSH
70195: CALL_OW 313
70199: PUSH
70200: LD_VAR 0 12
70204: PUSH
70205: LD_INT 1
70207: ARRAY
70208: PPUSH
70209: CALL_OW 266
70213: PUSH
70214: LD_INT 32
70216: PUSH
70217: LD_INT 31
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: IN
70224: AND
70225: PUSH
70226: LD_VAR 0 12
70230: PUSH
70231: LD_INT 1
70233: ARRAY
70234: PPUSH
70235: CALL_OW 313
70239: PUSH
70240: LD_INT 6
70242: EQUAL
70243: OR
70244: IFFALSE 70264
// f := Delete ( f , 1 ) ;
70246: LD_ADDR_VAR 0 12
70250: PUSH
70251: LD_VAR 0 12
70255: PPUSH
70256: LD_INT 1
70258: PPUSH
70259: CALL_OW 3
70263: ST_TO_ADDR
// if not f then
70264: LD_VAR 0 12
70268: NOT
70269: IFFALSE 70287
// begin x := x + 2 ;
70271: LD_ADDR_VAR 0 13
70275: PUSH
70276: LD_VAR 0 13
70280: PUSH
70281: LD_INT 2
70283: PLUS
70284: ST_TO_ADDR
// continue ;
70285: GO 70085
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70287: LD_VAR 0 12
70291: PUSH
70292: LD_INT 1
70294: ARRAY
70295: PPUSH
70296: CALL_OW 266
70300: PUSH
70301: LD_INT 5
70303: EQUAL
70304: IFFALSE 70378
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70306: LD_VAR 0 12
70310: PUSH
70311: LD_INT 1
70313: ARRAY
70314: PPUSH
70315: CALL_OW 313
70319: PUSH
70320: LD_INT 3
70322: LESS
70323: IFFALSE 70359
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70325: LD_INT 0
70327: PPUSH
70328: LD_INT 5
70330: PUSH
70331: LD_INT 8
70333: PUSH
70334: LD_INT 9
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: LIST
70341: PUSH
70342: LD_VAR 0 17
70346: ARRAY
70347: PPUSH
70348: LD_VAR 0 4
70352: PPUSH
70353: CALL_OW 380
70357: GO 70376
// PrepareHuman ( false , i , skill ) ;
70359: LD_INT 0
70361: PPUSH
70362: LD_VAR 0 8
70366: PPUSH
70367: LD_VAR 0 4
70371: PPUSH
70372: CALL_OW 380
// end else
70376: GO 70395
// PrepareHuman ( false , i , skill ) ;
70378: LD_INT 0
70380: PPUSH
70381: LD_VAR 0 8
70385: PPUSH
70386: LD_VAR 0 4
70390: PPUSH
70391: CALL_OW 380
// un := CreateHuman ;
70395: LD_ADDR_VAR 0 14
70399: PUSH
70400: CALL_OW 44
70404: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70405: LD_ADDR_VAR 0 7
70409: PUSH
70410: LD_VAR 0 7
70414: PPUSH
70415: LD_INT 1
70417: PPUSH
70418: LD_VAR 0 14
70422: PPUSH
70423: CALL_OW 2
70427: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
70428: LD_VAR 0 14
70432: PPUSH
70433: LD_VAR 0 12
70437: PUSH
70438: LD_INT 1
70440: ARRAY
70441: PPUSH
70442: CALL_OW 52
// end ;
70446: GO 70085
70448: POP
70449: POP
// end ;
70450: GO 69387
70452: POP
70453: POP
// result := result ^ buildings ;
70454: LD_ADDR_VAR 0 7
70458: PUSH
70459: LD_VAR 0 7
70463: PUSH
70464: LD_VAR 0 18
70468: ADD
70469: ST_TO_ADDR
// end else
70470: GO 70613
// begin for i = 1 to personel do
70472: LD_ADDR_VAR 0 8
70476: PUSH
70477: DOUBLE
70478: LD_INT 1
70480: DEC
70481: ST_TO_ADDR
70482: LD_VAR 0 6
70486: PUSH
70487: FOR_TO
70488: IFFALSE 70611
// begin if i > 4 then
70490: LD_VAR 0 8
70494: PUSH
70495: LD_INT 4
70497: GREATER
70498: IFFALSE 70502
// break ;
70500: GO 70611
// x := personel [ i ] ;
70502: LD_ADDR_VAR 0 13
70506: PUSH
70507: LD_VAR 0 6
70511: PUSH
70512: LD_VAR 0 8
70516: ARRAY
70517: ST_TO_ADDR
// if x = - 1 then
70518: LD_VAR 0 13
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: EQUAL
70527: IFFALSE 70531
// continue ;
70529: GO 70487
// PrepareHuman ( false , i , skill ) ;
70531: LD_INT 0
70533: PPUSH
70534: LD_VAR 0 8
70538: PPUSH
70539: LD_VAR 0 4
70543: PPUSH
70544: CALL_OW 380
// un := CreateHuman ;
70548: LD_ADDR_VAR 0 14
70552: PUSH
70553: CALL_OW 44
70557: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70558: LD_VAR 0 14
70562: PPUSH
70563: LD_VAR 0 1
70567: PPUSH
70568: CALL_OW 250
70572: PPUSH
70573: LD_VAR 0 1
70577: PPUSH
70578: CALL_OW 251
70582: PPUSH
70583: LD_INT 10
70585: PPUSH
70586: LD_INT 0
70588: PPUSH
70589: CALL_OW 50
// result := result ^ un ;
70593: LD_ADDR_VAR 0 7
70597: PUSH
70598: LD_VAR 0 7
70602: PUSH
70603: LD_VAR 0 14
70607: ADD
70608: ST_TO_ADDR
// end ;
70609: GO 70487
70611: POP
70612: POP
// end ; end ;
70613: LD_VAR 0 7
70617: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
70618: LD_INT 0
70620: PPUSH
70621: PPUSH
70622: PPUSH
70623: PPUSH
70624: PPUSH
70625: PPUSH
70626: PPUSH
70627: PPUSH
70628: PPUSH
70629: PPUSH
70630: PPUSH
70631: PPUSH
70632: PPUSH
70633: PPUSH
70634: PPUSH
70635: PPUSH
// result := false ;
70636: LD_ADDR_VAR 0 3
70640: PUSH
70641: LD_INT 0
70643: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
70644: LD_VAR 0 1
70648: NOT
70649: PUSH
70650: LD_VAR 0 1
70654: PPUSH
70655: CALL_OW 266
70659: PUSH
70660: LD_INT 32
70662: PUSH
70663: LD_INT 33
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: IN
70670: NOT
70671: OR
70672: IFFALSE 70676
// exit ;
70674: GO 71785
// nat := GetNation ( tower ) ;
70676: LD_ADDR_VAR 0 12
70680: PUSH
70681: LD_VAR 0 1
70685: PPUSH
70686: CALL_OW 248
70690: ST_TO_ADDR
// side := GetSide ( tower ) ;
70691: LD_ADDR_VAR 0 16
70695: PUSH
70696: LD_VAR 0 1
70700: PPUSH
70701: CALL_OW 255
70705: ST_TO_ADDR
// x := GetX ( tower ) ;
70706: LD_ADDR_VAR 0 10
70710: PUSH
70711: LD_VAR 0 1
70715: PPUSH
70716: CALL_OW 250
70720: ST_TO_ADDR
// y := GetY ( tower ) ;
70721: LD_ADDR_VAR 0 11
70725: PUSH
70726: LD_VAR 0 1
70730: PPUSH
70731: CALL_OW 251
70735: ST_TO_ADDR
// if not x or not y then
70736: LD_VAR 0 10
70740: NOT
70741: PUSH
70742: LD_VAR 0 11
70746: NOT
70747: OR
70748: IFFALSE 70752
// exit ;
70750: GO 71785
// weapon := 0 ;
70752: LD_ADDR_VAR 0 18
70756: PUSH
70757: LD_INT 0
70759: ST_TO_ADDR
// fac_list := [ ] ;
70760: LD_ADDR_VAR 0 17
70764: PUSH
70765: EMPTY
70766: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
70767: LD_ADDR_VAR 0 6
70771: PUSH
70772: LD_VAR 0 1
70776: PPUSH
70777: CALL_OW 274
70781: PPUSH
70782: LD_VAR 0 2
70786: PPUSH
70787: LD_INT 0
70789: PPUSH
70790: CALL 68355 0 3
70794: PPUSH
70795: LD_INT 30
70797: PUSH
70798: LD_INT 3
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PPUSH
70805: CALL_OW 72
70809: ST_TO_ADDR
// if not factories then
70810: LD_VAR 0 6
70814: NOT
70815: IFFALSE 70819
// exit ;
70817: GO 71785
// for i in factories do
70819: LD_ADDR_VAR 0 8
70823: PUSH
70824: LD_VAR 0 6
70828: PUSH
70829: FOR_IN
70830: IFFALSE 70855
// fac_list := fac_list union AvailableWeaponList ( i ) ;
70832: LD_ADDR_VAR 0 17
70836: PUSH
70837: LD_VAR 0 17
70841: PUSH
70842: LD_VAR 0 8
70846: PPUSH
70847: CALL_OW 478
70851: UNION
70852: ST_TO_ADDR
70853: GO 70829
70855: POP
70856: POP
// if not fac_list then
70857: LD_VAR 0 17
70861: NOT
70862: IFFALSE 70866
// exit ;
70864: GO 71785
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
70866: LD_ADDR_VAR 0 5
70870: PUSH
70871: LD_INT 4
70873: PUSH
70874: LD_INT 5
70876: PUSH
70877: LD_INT 9
70879: PUSH
70880: LD_INT 10
70882: PUSH
70883: LD_INT 6
70885: PUSH
70886: LD_INT 7
70888: PUSH
70889: LD_INT 11
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: PUSH
70901: LD_INT 27
70903: PUSH
70904: LD_INT 28
70906: PUSH
70907: LD_INT 26
70909: PUSH
70910: LD_INT 30
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 43
70921: PUSH
70922: LD_INT 44
70924: PUSH
70925: LD_INT 46
70927: PUSH
70928: LD_INT 45
70930: PUSH
70931: LD_INT 47
70933: PUSH
70934: LD_INT 49
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: LIST
70949: PUSH
70950: LD_VAR 0 12
70954: ARRAY
70955: ST_TO_ADDR
// list := list isect fac_list ;
70956: LD_ADDR_VAR 0 5
70960: PUSH
70961: LD_VAR 0 5
70965: PUSH
70966: LD_VAR 0 17
70970: ISECT
70971: ST_TO_ADDR
// if not list then
70972: LD_VAR 0 5
70976: NOT
70977: IFFALSE 70981
// exit ;
70979: GO 71785
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
70981: LD_VAR 0 12
70985: PUSH
70986: LD_INT 3
70988: EQUAL
70989: PUSH
70990: LD_INT 49
70992: PUSH
70993: LD_VAR 0 5
70997: IN
70998: AND
70999: PUSH
71000: LD_INT 31
71002: PPUSH
71003: LD_VAR 0 16
71007: PPUSH
71008: CALL_OW 321
71012: PUSH
71013: LD_INT 2
71015: EQUAL
71016: AND
71017: IFFALSE 71077
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
71019: LD_INT 22
71021: PUSH
71022: LD_VAR 0 16
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 35
71033: PUSH
71034: LD_INT 49
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 91
71043: PUSH
71044: LD_VAR 0 1
71048: PUSH
71049: LD_INT 10
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: LIST
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: LIST
71061: PPUSH
71062: CALL_OW 69
71066: NOT
71067: IFFALSE 71077
// weapon := ru_time_lapser ;
71069: LD_ADDR_VAR 0 18
71073: PUSH
71074: LD_INT 49
71076: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
71077: LD_VAR 0 12
71081: PUSH
71082: LD_INT 1
71084: PUSH
71085: LD_INT 2
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: IN
71092: PUSH
71093: LD_INT 11
71095: PUSH
71096: LD_VAR 0 5
71100: IN
71101: PUSH
71102: LD_INT 30
71104: PUSH
71105: LD_VAR 0 5
71109: IN
71110: OR
71111: AND
71112: PUSH
71113: LD_INT 6
71115: PPUSH
71116: LD_VAR 0 16
71120: PPUSH
71121: CALL_OW 321
71125: PUSH
71126: LD_INT 2
71128: EQUAL
71129: AND
71130: IFFALSE 71295
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71132: LD_INT 22
71134: PUSH
71135: LD_VAR 0 16
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 2
71146: PUSH
71147: LD_INT 35
71149: PUSH
71150: LD_INT 11
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 35
71159: PUSH
71160: LD_INT 30
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 91
71174: PUSH
71175: LD_VAR 0 1
71179: PUSH
71180: LD_INT 18
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: LIST
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: LIST
71192: PPUSH
71193: CALL_OW 69
71197: NOT
71198: PUSH
71199: LD_INT 22
71201: PUSH
71202: LD_VAR 0 16
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 2
71213: PUSH
71214: LD_INT 30
71216: PUSH
71217: LD_INT 32
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 30
71226: PUSH
71227: LD_INT 33
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 91
71241: PUSH
71242: LD_VAR 0 1
71246: PUSH
71247: LD_INT 12
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: LIST
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: LIST
71259: PUSH
71260: EMPTY
71261: LIST
71262: PPUSH
71263: CALL_OW 69
71267: PUSH
71268: LD_INT 2
71270: GREATER
71271: AND
71272: IFFALSE 71295
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71274: LD_ADDR_VAR 0 18
71278: PUSH
71279: LD_INT 11
71281: PUSH
71282: LD_INT 30
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_VAR 0 12
71293: ARRAY
71294: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71295: LD_VAR 0 18
71299: NOT
71300: PUSH
71301: LD_INT 40
71303: PPUSH
71304: LD_VAR 0 16
71308: PPUSH
71309: CALL_OW 321
71313: PUSH
71314: LD_INT 2
71316: EQUAL
71317: AND
71318: PUSH
71319: LD_INT 7
71321: PUSH
71322: LD_VAR 0 5
71326: IN
71327: PUSH
71328: LD_INT 28
71330: PUSH
71331: LD_VAR 0 5
71335: IN
71336: OR
71337: PUSH
71338: LD_INT 45
71340: PUSH
71341: LD_VAR 0 5
71345: IN
71346: OR
71347: AND
71348: IFFALSE 71602
// begin hex := GetHexInfo ( x , y ) ;
71350: LD_ADDR_VAR 0 4
71354: PUSH
71355: LD_VAR 0 10
71359: PPUSH
71360: LD_VAR 0 11
71364: PPUSH
71365: CALL_OW 546
71369: ST_TO_ADDR
// if hex [ 1 ] then
71370: LD_VAR 0 4
71374: PUSH
71375: LD_INT 1
71377: ARRAY
71378: IFFALSE 71382
// exit ;
71380: GO 71785
// height := hex [ 2 ] ;
71382: LD_ADDR_VAR 0 15
71386: PUSH
71387: LD_VAR 0 4
71391: PUSH
71392: LD_INT 2
71394: ARRAY
71395: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71396: LD_ADDR_VAR 0 14
71400: PUSH
71401: LD_INT 0
71403: PUSH
71404: LD_INT 2
71406: PUSH
71407: LD_INT 3
71409: PUSH
71410: LD_INT 5
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: ST_TO_ADDR
// for i in tmp do
71419: LD_ADDR_VAR 0 8
71423: PUSH
71424: LD_VAR 0 14
71428: PUSH
71429: FOR_IN
71430: IFFALSE 71600
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
71432: LD_ADDR_VAR 0 9
71436: PUSH
71437: LD_VAR 0 10
71441: PPUSH
71442: LD_VAR 0 8
71446: PPUSH
71447: LD_INT 5
71449: PPUSH
71450: CALL_OW 272
71454: PUSH
71455: LD_VAR 0 11
71459: PPUSH
71460: LD_VAR 0 8
71464: PPUSH
71465: LD_INT 5
71467: PPUSH
71468: CALL_OW 273
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
71477: LD_VAR 0 9
71481: PUSH
71482: LD_INT 1
71484: ARRAY
71485: PPUSH
71486: LD_VAR 0 9
71490: PUSH
71491: LD_INT 2
71493: ARRAY
71494: PPUSH
71495: CALL_OW 488
71499: IFFALSE 71598
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
71501: LD_ADDR_VAR 0 4
71505: PUSH
71506: LD_VAR 0 9
71510: PUSH
71511: LD_INT 1
71513: ARRAY
71514: PPUSH
71515: LD_VAR 0 9
71519: PUSH
71520: LD_INT 2
71522: ARRAY
71523: PPUSH
71524: CALL_OW 546
71528: ST_TO_ADDR
// if hex [ 1 ] then
71529: LD_VAR 0 4
71533: PUSH
71534: LD_INT 1
71536: ARRAY
71537: IFFALSE 71541
// continue ;
71539: GO 71429
// h := hex [ 2 ] ;
71541: LD_ADDR_VAR 0 13
71545: PUSH
71546: LD_VAR 0 4
71550: PUSH
71551: LD_INT 2
71553: ARRAY
71554: ST_TO_ADDR
// if h + 7 < height then
71555: LD_VAR 0 13
71559: PUSH
71560: LD_INT 7
71562: PLUS
71563: PUSH
71564: LD_VAR 0 15
71568: LESS
71569: IFFALSE 71598
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
71571: LD_ADDR_VAR 0 18
71575: PUSH
71576: LD_INT 7
71578: PUSH
71579: LD_INT 28
71581: PUSH
71582: LD_INT 45
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: LIST
71589: PUSH
71590: LD_VAR 0 12
71594: ARRAY
71595: ST_TO_ADDR
// break ;
71596: GO 71600
// end ; end ; end ;
71598: GO 71429
71600: POP
71601: POP
// end ; if not weapon then
71602: LD_VAR 0 18
71606: NOT
71607: IFFALSE 71667
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
71609: LD_ADDR_VAR 0 5
71613: PUSH
71614: LD_VAR 0 5
71618: PUSH
71619: LD_INT 11
71621: PUSH
71622: LD_INT 30
71624: PUSH
71625: LD_INT 49
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: LIST
71632: DIFF
71633: ST_TO_ADDR
// if not list then
71634: LD_VAR 0 5
71638: NOT
71639: IFFALSE 71643
// exit ;
71641: GO 71785
// weapon := list [ rand ( 1 , list ) ] ;
71643: LD_ADDR_VAR 0 18
71647: PUSH
71648: LD_VAR 0 5
71652: PUSH
71653: LD_INT 1
71655: PPUSH
71656: LD_VAR 0 5
71660: PPUSH
71661: CALL_OW 12
71665: ARRAY
71666: ST_TO_ADDR
// end ; if weapon then
71667: LD_VAR 0 18
71671: IFFALSE 71785
// begin tmp := CostOfWeapon ( weapon ) ;
71673: LD_ADDR_VAR 0 14
71677: PUSH
71678: LD_VAR 0 18
71682: PPUSH
71683: CALL_OW 451
71687: ST_TO_ADDR
// j := GetBase ( tower ) ;
71688: LD_ADDR_VAR 0 9
71692: PUSH
71693: LD_VAR 0 1
71697: PPUSH
71698: CALL_OW 274
71702: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
71703: LD_VAR 0 9
71707: PPUSH
71708: LD_INT 1
71710: PPUSH
71711: CALL_OW 275
71715: PUSH
71716: LD_VAR 0 14
71720: PUSH
71721: LD_INT 1
71723: ARRAY
71724: GREATEREQUAL
71725: PUSH
71726: LD_VAR 0 9
71730: PPUSH
71731: LD_INT 2
71733: PPUSH
71734: CALL_OW 275
71738: PUSH
71739: LD_VAR 0 14
71743: PUSH
71744: LD_INT 2
71746: ARRAY
71747: GREATEREQUAL
71748: AND
71749: PUSH
71750: LD_VAR 0 9
71754: PPUSH
71755: LD_INT 3
71757: PPUSH
71758: CALL_OW 275
71762: PUSH
71763: LD_VAR 0 14
71767: PUSH
71768: LD_INT 3
71770: ARRAY
71771: GREATEREQUAL
71772: AND
71773: IFFALSE 71785
// result := weapon ;
71775: LD_ADDR_VAR 0 3
71779: PUSH
71780: LD_VAR 0 18
71784: ST_TO_ADDR
// end ; end ;
71785: LD_VAR 0 3
71789: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
71790: LD_INT 0
71792: PPUSH
71793: PPUSH
// result := true ;
71794: LD_ADDR_VAR 0 3
71798: PUSH
71799: LD_INT 1
71801: ST_TO_ADDR
// if array1 = array2 then
71802: LD_VAR 0 1
71806: PUSH
71807: LD_VAR 0 2
71811: EQUAL
71812: IFFALSE 71872
// begin for i = 1 to array1 do
71814: LD_ADDR_VAR 0 4
71818: PUSH
71819: DOUBLE
71820: LD_INT 1
71822: DEC
71823: ST_TO_ADDR
71824: LD_VAR 0 1
71828: PUSH
71829: FOR_TO
71830: IFFALSE 71868
// if array1 [ i ] <> array2 [ i ] then
71832: LD_VAR 0 1
71836: PUSH
71837: LD_VAR 0 4
71841: ARRAY
71842: PUSH
71843: LD_VAR 0 2
71847: PUSH
71848: LD_VAR 0 4
71852: ARRAY
71853: NONEQUAL
71854: IFFALSE 71866
// begin result := false ;
71856: LD_ADDR_VAR 0 3
71860: PUSH
71861: LD_INT 0
71863: ST_TO_ADDR
// break ;
71864: GO 71868
// end ;
71866: GO 71829
71868: POP
71869: POP
// end else
71870: GO 71880
// result := false ;
71872: LD_ADDR_VAR 0 3
71876: PUSH
71877: LD_INT 0
71879: ST_TO_ADDR
// end ;
71880: LD_VAR 0 3
71884: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
71885: LD_INT 0
71887: PPUSH
71888: PPUSH
// if not array1 or not array2 then
71889: LD_VAR 0 1
71893: NOT
71894: PUSH
71895: LD_VAR 0 2
71899: NOT
71900: OR
71901: IFFALSE 71905
// exit ;
71903: GO 71969
// result := true ;
71905: LD_ADDR_VAR 0 3
71909: PUSH
71910: LD_INT 1
71912: ST_TO_ADDR
// for i = 1 to array1 do
71913: LD_ADDR_VAR 0 4
71917: PUSH
71918: DOUBLE
71919: LD_INT 1
71921: DEC
71922: ST_TO_ADDR
71923: LD_VAR 0 1
71927: PUSH
71928: FOR_TO
71929: IFFALSE 71967
// if array1 [ i ] <> array2 [ i ] then
71931: LD_VAR 0 1
71935: PUSH
71936: LD_VAR 0 4
71940: ARRAY
71941: PUSH
71942: LD_VAR 0 2
71946: PUSH
71947: LD_VAR 0 4
71951: ARRAY
71952: NONEQUAL
71953: IFFALSE 71965
// begin result := false ;
71955: LD_ADDR_VAR 0 3
71959: PUSH
71960: LD_INT 0
71962: ST_TO_ADDR
// break ;
71963: GO 71967
// end ;
71965: GO 71928
71967: POP
71968: POP
// end ;
71969: LD_VAR 0 3
71973: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
71974: LD_INT 0
71976: PPUSH
71977: PPUSH
71978: PPUSH
// pom := GetBase ( fac ) ;
71979: LD_ADDR_VAR 0 5
71983: PUSH
71984: LD_VAR 0 1
71988: PPUSH
71989: CALL_OW 274
71993: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
71994: LD_ADDR_VAR 0 4
71998: PUSH
71999: LD_VAR 0 2
72003: PUSH
72004: LD_INT 1
72006: ARRAY
72007: PPUSH
72008: LD_VAR 0 2
72012: PUSH
72013: LD_INT 2
72015: ARRAY
72016: PPUSH
72017: LD_VAR 0 2
72021: PUSH
72022: LD_INT 3
72024: ARRAY
72025: PPUSH
72026: LD_VAR 0 2
72030: PUSH
72031: LD_INT 4
72033: ARRAY
72034: PPUSH
72035: CALL_OW 449
72039: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72040: LD_ADDR_VAR 0 3
72044: PUSH
72045: LD_VAR 0 5
72049: PPUSH
72050: LD_INT 1
72052: PPUSH
72053: CALL_OW 275
72057: PUSH
72058: LD_VAR 0 4
72062: PUSH
72063: LD_INT 1
72065: ARRAY
72066: GREATEREQUAL
72067: PUSH
72068: LD_VAR 0 5
72072: PPUSH
72073: LD_INT 2
72075: PPUSH
72076: CALL_OW 275
72080: PUSH
72081: LD_VAR 0 4
72085: PUSH
72086: LD_INT 2
72088: ARRAY
72089: GREATEREQUAL
72090: AND
72091: PUSH
72092: LD_VAR 0 5
72096: PPUSH
72097: LD_INT 3
72099: PPUSH
72100: CALL_OW 275
72104: PUSH
72105: LD_VAR 0 4
72109: PUSH
72110: LD_INT 3
72112: ARRAY
72113: GREATEREQUAL
72114: AND
72115: ST_TO_ADDR
// end ;
72116: LD_VAR 0 3
72120: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
72121: LD_INT 0
72123: PPUSH
72124: PPUSH
72125: PPUSH
72126: PPUSH
// pom := GetBase ( building ) ;
72127: LD_ADDR_VAR 0 3
72131: PUSH
72132: LD_VAR 0 1
72136: PPUSH
72137: CALL_OW 274
72141: ST_TO_ADDR
// if not pom then
72142: LD_VAR 0 3
72146: NOT
72147: IFFALSE 72151
// exit ;
72149: GO 72321
// btype := GetBType ( building ) ;
72151: LD_ADDR_VAR 0 5
72155: PUSH
72156: LD_VAR 0 1
72160: PPUSH
72161: CALL_OW 266
72165: ST_TO_ADDR
// if btype = b_armoury then
72166: LD_VAR 0 5
72170: PUSH
72171: LD_INT 4
72173: EQUAL
72174: IFFALSE 72184
// btype := b_barracks ;
72176: LD_ADDR_VAR 0 5
72180: PUSH
72181: LD_INT 5
72183: ST_TO_ADDR
// if btype = b_depot then
72184: LD_VAR 0 5
72188: PUSH
72189: LD_INT 0
72191: EQUAL
72192: IFFALSE 72202
// btype := b_warehouse ;
72194: LD_ADDR_VAR 0 5
72198: PUSH
72199: LD_INT 1
72201: ST_TO_ADDR
// if btype = b_workshop then
72202: LD_VAR 0 5
72206: PUSH
72207: LD_INT 2
72209: EQUAL
72210: IFFALSE 72220
// btype := b_factory ;
72212: LD_ADDR_VAR 0 5
72216: PUSH
72217: LD_INT 3
72219: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72220: LD_ADDR_VAR 0 4
72224: PUSH
72225: LD_VAR 0 5
72229: PPUSH
72230: LD_VAR 0 1
72234: PPUSH
72235: CALL_OW 248
72239: PPUSH
72240: CALL_OW 450
72244: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72245: LD_ADDR_VAR 0 2
72249: PUSH
72250: LD_VAR 0 3
72254: PPUSH
72255: LD_INT 1
72257: PPUSH
72258: CALL_OW 275
72262: PUSH
72263: LD_VAR 0 4
72267: PUSH
72268: LD_INT 1
72270: ARRAY
72271: GREATEREQUAL
72272: PUSH
72273: LD_VAR 0 3
72277: PPUSH
72278: LD_INT 2
72280: PPUSH
72281: CALL_OW 275
72285: PUSH
72286: LD_VAR 0 4
72290: PUSH
72291: LD_INT 2
72293: ARRAY
72294: GREATEREQUAL
72295: AND
72296: PUSH
72297: LD_VAR 0 3
72301: PPUSH
72302: LD_INT 3
72304: PPUSH
72305: CALL_OW 275
72309: PUSH
72310: LD_VAR 0 4
72314: PUSH
72315: LD_INT 3
72317: ARRAY
72318: GREATEREQUAL
72319: AND
72320: ST_TO_ADDR
// end ;
72321: LD_VAR 0 2
72325: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72326: LD_INT 0
72328: PPUSH
72329: PPUSH
72330: PPUSH
// pom := GetBase ( building ) ;
72331: LD_ADDR_VAR 0 4
72335: PUSH
72336: LD_VAR 0 1
72340: PPUSH
72341: CALL_OW 274
72345: ST_TO_ADDR
// if not pom then
72346: LD_VAR 0 4
72350: NOT
72351: IFFALSE 72355
// exit ;
72353: GO 72456
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72355: LD_ADDR_VAR 0 5
72359: PUSH
72360: LD_VAR 0 2
72364: PPUSH
72365: LD_VAR 0 1
72369: PPUSH
72370: CALL_OW 248
72374: PPUSH
72375: CALL_OW 450
72379: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72380: LD_ADDR_VAR 0 3
72384: PUSH
72385: LD_VAR 0 4
72389: PPUSH
72390: LD_INT 1
72392: PPUSH
72393: CALL_OW 275
72397: PUSH
72398: LD_VAR 0 5
72402: PUSH
72403: LD_INT 1
72405: ARRAY
72406: GREATEREQUAL
72407: PUSH
72408: LD_VAR 0 4
72412: PPUSH
72413: LD_INT 2
72415: PPUSH
72416: CALL_OW 275
72420: PUSH
72421: LD_VAR 0 5
72425: PUSH
72426: LD_INT 2
72428: ARRAY
72429: GREATEREQUAL
72430: AND
72431: PUSH
72432: LD_VAR 0 4
72436: PPUSH
72437: LD_INT 3
72439: PPUSH
72440: CALL_OW 275
72444: PUSH
72445: LD_VAR 0 5
72449: PUSH
72450: LD_INT 3
72452: ARRAY
72453: GREATEREQUAL
72454: AND
72455: ST_TO_ADDR
// end ;
72456: LD_VAR 0 3
72460: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
72461: LD_INT 0
72463: PPUSH
72464: PPUSH
72465: PPUSH
72466: PPUSH
72467: PPUSH
72468: PPUSH
72469: PPUSH
72470: PPUSH
72471: PPUSH
72472: PPUSH
72473: PPUSH
// result := false ;
72474: LD_ADDR_VAR 0 8
72478: PUSH
72479: LD_INT 0
72481: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
72482: LD_VAR 0 5
72486: NOT
72487: PUSH
72488: LD_VAR 0 1
72492: NOT
72493: OR
72494: PUSH
72495: LD_VAR 0 2
72499: NOT
72500: OR
72501: PUSH
72502: LD_VAR 0 3
72506: NOT
72507: OR
72508: IFFALSE 72512
// exit ;
72510: GO 73326
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
72512: LD_ADDR_VAR 0 14
72516: PUSH
72517: LD_VAR 0 1
72521: PPUSH
72522: LD_VAR 0 2
72526: PPUSH
72527: LD_VAR 0 3
72531: PPUSH
72532: LD_VAR 0 4
72536: PPUSH
72537: LD_VAR 0 5
72541: PUSH
72542: LD_INT 1
72544: ARRAY
72545: PPUSH
72546: CALL_OW 248
72550: PPUSH
72551: LD_INT 0
72553: PPUSH
72554: CALL 74563 0 6
72558: ST_TO_ADDR
// if not hexes then
72559: LD_VAR 0 14
72563: NOT
72564: IFFALSE 72568
// exit ;
72566: GO 73326
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72568: LD_ADDR_VAR 0 17
72572: PUSH
72573: LD_VAR 0 5
72577: PPUSH
72578: LD_INT 22
72580: PUSH
72581: LD_VAR 0 13
72585: PPUSH
72586: CALL_OW 255
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: LD_INT 30
72600: PUSH
72601: LD_INT 0
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 30
72610: PUSH
72611: LD_INT 1
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: LIST
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PPUSH
72627: CALL_OW 72
72631: ST_TO_ADDR
// for i = 1 to hexes do
72632: LD_ADDR_VAR 0 9
72636: PUSH
72637: DOUBLE
72638: LD_INT 1
72640: DEC
72641: ST_TO_ADDR
72642: LD_VAR 0 14
72646: PUSH
72647: FOR_TO
72648: IFFALSE 73324
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
72650: LD_ADDR_VAR 0 13
72654: PUSH
72655: LD_VAR 0 14
72659: PUSH
72660: LD_VAR 0 9
72664: ARRAY
72665: PUSH
72666: LD_INT 1
72668: ARRAY
72669: PPUSH
72670: LD_VAR 0 14
72674: PUSH
72675: LD_VAR 0 9
72679: ARRAY
72680: PUSH
72681: LD_INT 2
72683: ARRAY
72684: PPUSH
72685: CALL_OW 428
72689: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
72690: LD_VAR 0 14
72694: PUSH
72695: LD_VAR 0 9
72699: ARRAY
72700: PUSH
72701: LD_INT 1
72703: ARRAY
72704: PPUSH
72705: LD_VAR 0 14
72709: PUSH
72710: LD_VAR 0 9
72714: ARRAY
72715: PUSH
72716: LD_INT 2
72718: ARRAY
72719: PPUSH
72720: CALL_OW 351
72724: PUSH
72725: LD_VAR 0 14
72729: PUSH
72730: LD_VAR 0 9
72734: ARRAY
72735: PUSH
72736: LD_INT 1
72738: ARRAY
72739: PPUSH
72740: LD_VAR 0 14
72744: PUSH
72745: LD_VAR 0 9
72749: ARRAY
72750: PUSH
72751: LD_INT 2
72753: ARRAY
72754: PPUSH
72755: CALL_OW 488
72759: NOT
72760: OR
72761: PUSH
72762: LD_VAR 0 13
72766: PPUSH
72767: CALL_OW 247
72771: PUSH
72772: LD_INT 3
72774: EQUAL
72775: OR
72776: IFFALSE 72782
// exit ;
72778: POP
72779: POP
72780: GO 73326
// if not tmp then
72782: LD_VAR 0 13
72786: NOT
72787: IFFALSE 72791
// continue ;
72789: GO 72647
// result := true ;
72791: LD_ADDR_VAR 0 8
72795: PUSH
72796: LD_INT 1
72798: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
72799: LD_VAR 0 6
72803: PUSH
72804: LD_VAR 0 13
72808: PPUSH
72809: CALL_OW 247
72813: PUSH
72814: LD_INT 2
72816: EQUAL
72817: AND
72818: PUSH
72819: LD_VAR 0 13
72823: PPUSH
72824: CALL_OW 263
72828: PUSH
72829: LD_INT 1
72831: EQUAL
72832: AND
72833: IFFALSE 72997
// begin if IsDrivenBy ( tmp ) then
72835: LD_VAR 0 13
72839: PPUSH
72840: CALL_OW 311
72844: IFFALSE 72848
// continue ;
72846: GO 72647
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
72848: LD_VAR 0 6
72852: PPUSH
72853: LD_INT 3
72855: PUSH
72856: LD_INT 60
72858: PUSH
72859: EMPTY
72860: LIST
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 3
72868: PUSH
72869: LD_INT 55
72871: PUSH
72872: EMPTY
72873: LIST
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PPUSH
72883: CALL_OW 72
72887: IFFALSE 72995
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
72889: LD_ADDR_VAR 0 18
72893: PUSH
72894: LD_VAR 0 6
72898: PPUSH
72899: LD_INT 3
72901: PUSH
72902: LD_INT 60
72904: PUSH
72905: EMPTY
72906: LIST
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: PUSH
72912: LD_INT 3
72914: PUSH
72915: LD_INT 55
72917: PUSH
72918: EMPTY
72919: LIST
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PPUSH
72929: CALL_OW 72
72933: PUSH
72934: LD_INT 1
72936: ARRAY
72937: ST_TO_ADDR
// if IsInUnit ( driver ) then
72938: LD_VAR 0 18
72942: PPUSH
72943: CALL_OW 310
72947: IFFALSE 72958
// ComExit ( driver ) ;
72949: LD_VAR 0 18
72953: PPUSH
72954: CALL 97747 0 1
// AddComEnterUnit ( driver , tmp ) ;
72958: LD_VAR 0 18
72962: PPUSH
72963: LD_VAR 0 13
72967: PPUSH
72968: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
72972: LD_VAR 0 18
72976: PPUSH
72977: LD_VAR 0 7
72981: PPUSH
72982: CALL_OW 173
// AddComExitVehicle ( driver ) ;
72986: LD_VAR 0 18
72990: PPUSH
72991: CALL_OW 181
// end ; continue ;
72995: GO 72647
// end ; if not cleaners or not tmp in cleaners then
72997: LD_VAR 0 6
73001: NOT
73002: PUSH
73003: LD_VAR 0 13
73007: PUSH
73008: LD_VAR 0 6
73012: IN
73013: NOT
73014: OR
73015: IFFALSE 73322
// begin if dep then
73017: LD_VAR 0 17
73021: IFFALSE 73157
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
73023: LD_ADDR_VAR 0 16
73027: PUSH
73028: LD_VAR 0 17
73032: PUSH
73033: LD_INT 1
73035: ARRAY
73036: PPUSH
73037: CALL_OW 250
73041: PPUSH
73042: LD_VAR 0 17
73046: PUSH
73047: LD_INT 1
73049: ARRAY
73050: PPUSH
73051: CALL_OW 254
73055: PPUSH
73056: LD_INT 5
73058: PPUSH
73059: CALL_OW 272
73063: PUSH
73064: LD_VAR 0 17
73068: PUSH
73069: LD_INT 1
73071: ARRAY
73072: PPUSH
73073: CALL_OW 251
73077: PPUSH
73078: LD_VAR 0 17
73082: PUSH
73083: LD_INT 1
73085: ARRAY
73086: PPUSH
73087: CALL_OW 254
73091: PPUSH
73092: LD_INT 5
73094: PPUSH
73095: CALL_OW 273
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
73104: LD_VAR 0 16
73108: PUSH
73109: LD_INT 1
73111: ARRAY
73112: PPUSH
73113: LD_VAR 0 16
73117: PUSH
73118: LD_INT 2
73120: ARRAY
73121: PPUSH
73122: CALL_OW 488
73126: IFFALSE 73157
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73128: LD_VAR 0 13
73132: PPUSH
73133: LD_VAR 0 16
73137: PUSH
73138: LD_INT 1
73140: ARRAY
73141: PPUSH
73142: LD_VAR 0 16
73146: PUSH
73147: LD_INT 2
73149: ARRAY
73150: PPUSH
73151: CALL_OW 111
// continue ;
73155: GO 72647
// end ; end ; r := GetDir ( tmp ) ;
73157: LD_ADDR_VAR 0 15
73161: PUSH
73162: LD_VAR 0 13
73166: PPUSH
73167: CALL_OW 254
73171: ST_TO_ADDR
// if r = 5 then
73172: LD_VAR 0 15
73176: PUSH
73177: LD_INT 5
73179: EQUAL
73180: IFFALSE 73190
// r := 0 ;
73182: LD_ADDR_VAR 0 15
73186: PUSH
73187: LD_INT 0
73189: ST_TO_ADDR
// for j = r to 5 do
73190: LD_ADDR_VAR 0 10
73194: PUSH
73195: DOUBLE
73196: LD_VAR 0 15
73200: DEC
73201: ST_TO_ADDR
73202: LD_INT 5
73204: PUSH
73205: FOR_TO
73206: IFFALSE 73320
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73208: LD_ADDR_VAR 0 11
73212: PUSH
73213: LD_VAR 0 13
73217: PPUSH
73218: CALL_OW 250
73222: PPUSH
73223: LD_VAR 0 10
73227: PPUSH
73228: LD_INT 2
73230: PPUSH
73231: CALL_OW 272
73235: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73236: LD_ADDR_VAR 0 12
73240: PUSH
73241: LD_VAR 0 13
73245: PPUSH
73246: CALL_OW 251
73250: PPUSH
73251: LD_VAR 0 10
73255: PPUSH
73256: LD_INT 2
73258: PPUSH
73259: CALL_OW 273
73263: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73264: LD_VAR 0 11
73268: PPUSH
73269: LD_VAR 0 12
73273: PPUSH
73274: CALL_OW 488
73278: PUSH
73279: LD_VAR 0 11
73283: PPUSH
73284: LD_VAR 0 12
73288: PPUSH
73289: CALL_OW 428
73293: NOT
73294: AND
73295: IFFALSE 73318
// begin ComMoveXY ( tmp , _x , _y ) ;
73297: LD_VAR 0 13
73301: PPUSH
73302: LD_VAR 0 11
73306: PPUSH
73307: LD_VAR 0 12
73311: PPUSH
73312: CALL_OW 111
// break ;
73316: GO 73320
// end ; end ;
73318: GO 73205
73320: POP
73321: POP
// end ; end ;
73322: GO 72647
73324: POP
73325: POP
// end ;
73326: LD_VAR 0 8
73330: RET
// export function BuildingTechInvented ( side , btype ) ; begin
73331: LD_INT 0
73333: PPUSH
// result := true ;
73334: LD_ADDR_VAR 0 3
73338: PUSH
73339: LD_INT 1
73341: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
73342: LD_VAR 0 2
73346: PUSH
73347: LD_INT 24
73349: DOUBLE
73350: EQUAL
73351: IFTRUE 73361
73353: LD_INT 33
73355: DOUBLE
73356: EQUAL
73357: IFTRUE 73361
73359: GO 73386
73361: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
73362: LD_ADDR_VAR 0 3
73366: PUSH
73367: LD_INT 32
73369: PPUSH
73370: LD_VAR 0 1
73374: PPUSH
73375: CALL_OW 321
73379: PUSH
73380: LD_INT 2
73382: EQUAL
73383: ST_TO_ADDR
73384: GO 73706
73386: LD_INT 20
73388: DOUBLE
73389: EQUAL
73390: IFTRUE 73394
73392: GO 73419
73394: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
73395: LD_ADDR_VAR 0 3
73399: PUSH
73400: LD_INT 6
73402: PPUSH
73403: LD_VAR 0 1
73407: PPUSH
73408: CALL_OW 321
73412: PUSH
73413: LD_INT 2
73415: EQUAL
73416: ST_TO_ADDR
73417: GO 73706
73419: LD_INT 22
73421: DOUBLE
73422: EQUAL
73423: IFTRUE 73433
73425: LD_INT 36
73427: DOUBLE
73428: EQUAL
73429: IFTRUE 73433
73431: GO 73458
73433: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
73434: LD_ADDR_VAR 0 3
73438: PUSH
73439: LD_INT 15
73441: PPUSH
73442: LD_VAR 0 1
73446: PPUSH
73447: CALL_OW 321
73451: PUSH
73452: LD_INT 2
73454: EQUAL
73455: ST_TO_ADDR
73456: GO 73706
73458: LD_INT 30
73460: DOUBLE
73461: EQUAL
73462: IFTRUE 73466
73464: GO 73491
73466: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
73467: LD_ADDR_VAR 0 3
73471: PUSH
73472: LD_INT 20
73474: PPUSH
73475: LD_VAR 0 1
73479: PPUSH
73480: CALL_OW 321
73484: PUSH
73485: LD_INT 2
73487: EQUAL
73488: ST_TO_ADDR
73489: GO 73706
73491: LD_INT 28
73493: DOUBLE
73494: EQUAL
73495: IFTRUE 73505
73497: LD_INT 21
73499: DOUBLE
73500: EQUAL
73501: IFTRUE 73505
73503: GO 73530
73505: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
73506: LD_ADDR_VAR 0 3
73510: PUSH
73511: LD_INT 21
73513: PPUSH
73514: LD_VAR 0 1
73518: PPUSH
73519: CALL_OW 321
73523: PUSH
73524: LD_INT 2
73526: EQUAL
73527: ST_TO_ADDR
73528: GO 73706
73530: LD_INT 16
73532: DOUBLE
73533: EQUAL
73534: IFTRUE 73538
73536: GO 73565
73538: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
73539: LD_ADDR_VAR 0 3
73543: PUSH
73544: LD_EXP 85
73548: PPUSH
73549: LD_VAR 0 1
73553: PPUSH
73554: CALL_OW 321
73558: PUSH
73559: LD_INT 2
73561: EQUAL
73562: ST_TO_ADDR
73563: GO 73706
73565: LD_INT 19
73567: DOUBLE
73568: EQUAL
73569: IFTRUE 73579
73571: LD_INT 23
73573: DOUBLE
73574: EQUAL
73575: IFTRUE 73579
73577: GO 73606
73579: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
73580: LD_ADDR_VAR 0 3
73584: PUSH
73585: LD_EXP 84
73589: PPUSH
73590: LD_VAR 0 1
73594: PPUSH
73595: CALL_OW 321
73599: PUSH
73600: LD_INT 2
73602: EQUAL
73603: ST_TO_ADDR
73604: GO 73706
73606: LD_INT 17
73608: DOUBLE
73609: EQUAL
73610: IFTRUE 73614
73612: GO 73639
73614: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
73615: LD_ADDR_VAR 0 3
73619: PUSH
73620: LD_INT 39
73622: PPUSH
73623: LD_VAR 0 1
73627: PPUSH
73628: CALL_OW 321
73632: PUSH
73633: LD_INT 2
73635: EQUAL
73636: ST_TO_ADDR
73637: GO 73706
73639: LD_INT 18
73641: DOUBLE
73642: EQUAL
73643: IFTRUE 73647
73645: GO 73672
73647: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
73648: LD_ADDR_VAR 0 3
73652: PUSH
73653: LD_INT 40
73655: PPUSH
73656: LD_VAR 0 1
73660: PPUSH
73661: CALL_OW 321
73665: PUSH
73666: LD_INT 2
73668: EQUAL
73669: ST_TO_ADDR
73670: GO 73706
73672: LD_INT 27
73674: DOUBLE
73675: EQUAL
73676: IFTRUE 73680
73678: GO 73705
73680: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
73681: LD_ADDR_VAR 0 3
73685: PUSH
73686: LD_INT 35
73688: PPUSH
73689: LD_VAR 0 1
73693: PPUSH
73694: CALL_OW 321
73698: PUSH
73699: LD_INT 2
73701: EQUAL
73702: ST_TO_ADDR
73703: GO 73706
73705: POP
// end ;
73706: LD_VAR 0 3
73710: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
73711: LD_INT 0
73713: PPUSH
73714: PPUSH
73715: PPUSH
73716: PPUSH
73717: PPUSH
73718: PPUSH
73719: PPUSH
73720: PPUSH
73721: PPUSH
73722: PPUSH
73723: PPUSH
// result := false ;
73724: LD_ADDR_VAR 0 6
73728: PUSH
73729: LD_INT 0
73731: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
73732: LD_VAR 0 1
73736: NOT
73737: PUSH
73738: LD_VAR 0 1
73742: PPUSH
73743: CALL_OW 266
73747: PUSH
73748: LD_INT 0
73750: PUSH
73751: LD_INT 1
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: IN
73758: NOT
73759: OR
73760: PUSH
73761: LD_VAR 0 2
73765: NOT
73766: OR
73767: PUSH
73768: LD_VAR 0 5
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 1
73778: PUSH
73779: LD_INT 2
73781: PUSH
73782: LD_INT 3
73784: PUSH
73785: LD_INT 4
73787: PUSH
73788: LD_INT 5
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: IN
73799: NOT
73800: OR
73801: PUSH
73802: LD_VAR 0 3
73806: PPUSH
73807: LD_VAR 0 4
73811: PPUSH
73812: CALL_OW 488
73816: NOT
73817: OR
73818: IFFALSE 73822
// exit ;
73820: GO 74558
// side := GetSide ( depot ) ;
73822: LD_ADDR_VAR 0 9
73826: PUSH
73827: LD_VAR 0 1
73831: PPUSH
73832: CALL_OW 255
73836: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
73837: LD_VAR 0 9
73841: PPUSH
73842: LD_VAR 0 2
73846: PPUSH
73847: CALL 73331 0 2
73851: NOT
73852: IFFALSE 73856
// exit ;
73854: GO 74558
// pom := GetBase ( depot ) ;
73856: LD_ADDR_VAR 0 10
73860: PUSH
73861: LD_VAR 0 1
73865: PPUSH
73866: CALL_OW 274
73870: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
73871: LD_ADDR_VAR 0 11
73875: PUSH
73876: LD_VAR 0 2
73880: PPUSH
73881: LD_VAR 0 1
73885: PPUSH
73886: CALL_OW 248
73890: PPUSH
73891: CALL_OW 450
73895: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
73896: LD_VAR 0 10
73900: PPUSH
73901: LD_INT 1
73903: PPUSH
73904: CALL_OW 275
73908: PUSH
73909: LD_VAR 0 11
73913: PUSH
73914: LD_INT 1
73916: ARRAY
73917: GREATEREQUAL
73918: PUSH
73919: LD_VAR 0 10
73923: PPUSH
73924: LD_INT 2
73926: PPUSH
73927: CALL_OW 275
73931: PUSH
73932: LD_VAR 0 11
73936: PUSH
73937: LD_INT 2
73939: ARRAY
73940: GREATEREQUAL
73941: AND
73942: PUSH
73943: LD_VAR 0 10
73947: PPUSH
73948: LD_INT 3
73950: PPUSH
73951: CALL_OW 275
73955: PUSH
73956: LD_VAR 0 11
73960: PUSH
73961: LD_INT 3
73963: ARRAY
73964: GREATEREQUAL
73965: AND
73966: NOT
73967: IFFALSE 73971
// exit ;
73969: GO 74558
// if GetBType ( depot ) = b_depot then
73971: LD_VAR 0 1
73975: PPUSH
73976: CALL_OW 266
73980: PUSH
73981: LD_INT 0
73983: EQUAL
73984: IFFALSE 73996
// dist := 28 else
73986: LD_ADDR_VAR 0 14
73990: PUSH
73991: LD_INT 28
73993: ST_TO_ADDR
73994: GO 74004
// dist := 36 ;
73996: LD_ADDR_VAR 0 14
74000: PUSH
74001: LD_INT 36
74003: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
74004: LD_VAR 0 1
74008: PPUSH
74009: LD_VAR 0 3
74013: PPUSH
74014: LD_VAR 0 4
74018: PPUSH
74019: CALL_OW 297
74023: PUSH
74024: LD_VAR 0 14
74028: GREATER
74029: IFFALSE 74033
// exit ;
74031: GO 74558
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
74033: LD_ADDR_VAR 0 12
74037: PUSH
74038: LD_VAR 0 2
74042: PPUSH
74043: LD_VAR 0 3
74047: PPUSH
74048: LD_VAR 0 4
74052: PPUSH
74053: LD_VAR 0 5
74057: PPUSH
74058: LD_VAR 0 1
74062: PPUSH
74063: CALL_OW 248
74067: PPUSH
74068: LD_INT 0
74070: PPUSH
74071: CALL 74563 0 6
74075: ST_TO_ADDR
// if not hexes then
74076: LD_VAR 0 12
74080: NOT
74081: IFFALSE 74085
// exit ;
74083: GO 74558
// hex := GetHexInfo ( x , y ) ;
74085: LD_ADDR_VAR 0 15
74089: PUSH
74090: LD_VAR 0 3
74094: PPUSH
74095: LD_VAR 0 4
74099: PPUSH
74100: CALL_OW 546
74104: ST_TO_ADDR
// if hex [ 1 ] then
74105: LD_VAR 0 15
74109: PUSH
74110: LD_INT 1
74112: ARRAY
74113: IFFALSE 74117
// exit ;
74115: GO 74558
// height := hex [ 2 ] ;
74117: LD_ADDR_VAR 0 13
74121: PUSH
74122: LD_VAR 0 15
74126: PUSH
74127: LD_INT 2
74129: ARRAY
74130: ST_TO_ADDR
// for i = 1 to hexes do
74131: LD_ADDR_VAR 0 7
74135: PUSH
74136: DOUBLE
74137: LD_INT 1
74139: DEC
74140: ST_TO_ADDR
74141: LD_VAR 0 12
74145: PUSH
74146: FOR_TO
74147: IFFALSE 74477
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
74149: LD_VAR 0 12
74153: PUSH
74154: LD_VAR 0 7
74158: ARRAY
74159: PUSH
74160: LD_INT 1
74162: ARRAY
74163: PPUSH
74164: LD_VAR 0 12
74168: PUSH
74169: LD_VAR 0 7
74173: ARRAY
74174: PUSH
74175: LD_INT 2
74177: ARRAY
74178: PPUSH
74179: CALL_OW 488
74183: NOT
74184: PUSH
74185: LD_VAR 0 12
74189: PUSH
74190: LD_VAR 0 7
74194: ARRAY
74195: PUSH
74196: LD_INT 1
74198: ARRAY
74199: PPUSH
74200: LD_VAR 0 12
74204: PUSH
74205: LD_VAR 0 7
74209: ARRAY
74210: PUSH
74211: LD_INT 2
74213: ARRAY
74214: PPUSH
74215: CALL_OW 428
74219: PUSH
74220: LD_INT 0
74222: GREATER
74223: OR
74224: PUSH
74225: LD_VAR 0 12
74229: PUSH
74230: LD_VAR 0 7
74234: ARRAY
74235: PUSH
74236: LD_INT 1
74238: ARRAY
74239: PPUSH
74240: LD_VAR 0 12
74244: PUSH
74245: LD_VAR 0 7
74249: ARRAY
74250: PUSH
74251: LD_INT 2
74253: ARRAY
74254: PPUSH
74255: CALL_OW 351
74259: OR
74260: IFFALSE 74266
// exit ;
74262: POP
74263: POP
74264: GO 74558
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74266: LD_ADDR_VAR 0 8
74270: PUSH
74271: LD_VAR 0 12
74275: PUSH
74276: LD_VAR 0 7
74280: ARRAY
74281: PUSH
74282: LD_INT 1
74284: ARRAY
74285: PPUSH
74286: LD_VAR 0 12
74290: PUSH
74291: LD_VAR 0 7
74295: ARRAY
74296: PUSH
74297: LD_INT 2
74299: ARRAY
74300: PPUSH
74301: CALL_OW 546
74305: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
74306: LD_VAR 0 8
74310: PUSH
74311: LD_INT 1
74313: ARRAY
74314: PUSH
74315: LD_VAR 0 8
74319: PUSH
74320: LD_INT 2
74322: ARRAY
74323: PUSH
74324: LD_VAR 0 13
74328: PUSH
74329: LD_INT 2
74331: PLUS
74332: GREATER
74333: OR
74334: PUSH
74335: LD_VAR 0 8
74339: PUSH
74340: LD_INT 2
74342: ARRAY
74343: PUSH
74344: LD_VAR 0 13
74348: PUSH
74349: LD_INT 2
74351: MINUS
74352: LESS
74353: OR
74354: PUSH
74355: LD_VAR 0 8
74359: PUSH
74360: LD_INT 3
74362: ARRAY
74363: PUSH
74364: LD_INT 0
74366: PUSH
74367: LD_INT 8
74369: PUSH
74370: LD_INT 9
74372: PUSH
74373: LD_INT 10
74375: PUSH
74376: LD_INT 11
74378: PUSH
74379: LD_INT 12
74381: PUSH
74382: LD_INT 13
74384: PUSH
74385: LD_INT 16
74387: PUSH
74388: LD_INT 17
74390: PUSH
74391: LD_INT 18
74393: PUSH
74394: LD_INT 19
74396: PUSH
74397: LD_INT 20
74399: PUSH
74400: LD_INT 21
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: IN
74418: NOT
74419: OR
74420: PUSH
74421: LD_VAR 0 8
74425: PUSH
74426: LD_INT 5
74428: ARRAY
74429: NOT
74430: OR
74431: PUSH
74432: LD_VAR 0 8
74436: PUSH
74437: LD_INT 6
74439: ARRAY
74440: PUSH
74441: LD_INT 1
74443: PUSH
74444: LD_INT 2
74446: PUSH
74447: LD_INT 7
74449: PUSH
74450: LD_INT 9
74452: PUSH
74453: LD_INT 10
74455: PUSH
74456: LD_INT 11
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: LIST
74463: LIST
74464: LIST
74465: LIST
74466: IN
74467: NOT
74468: OR
74469: IFFALSE 74475
// exit ;
74471: POP
74472: POP
74473: GO 74558
// end ;
74475: GO 74146
74477: POP
74478: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74479: LD_VAR 0 9
74483: PPUSH
74484: LD_VAR 0 3
74488: PPUSH
74489: LD_VAR 0 4
74493: PPUSH
74494: LD_INT 20
74496: PPUSH
74497: CALL 66503 0 4
74501: PUSH
74502: LD_INT 4
74504: ARRAY
74505: IFFALSE 74509
// exit ;
74507: GO 74558
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
74509: LD_VAR 0 2
74513: PUSH
74514: LD_INT 29
74516: PUSH
74517: LD_INT 30
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: IN
74524: PUSH
74525: LD_VAR 0 3
74529: PPUSH
74530: LD_VAR 0 4
74534: PPUSH
74535: LD_VAR 0 9
74539: PPUSH
74540: CALL_OW 440
74544: NOT
74545: AND
74546: IFFALSE 74550
// exit ;
74548: GO 74558
// result := true ;
74550: LD_ADDR_VAR 0 6
74554: PUSH
74555: LD_INT 1
74557: ST_TO_ADDR
// end ;
74558: LD_VAR 0 6
74562: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
74563: LD_INT 0
74565: PPUSH
74566: PPUSH
74567: PPUSH
74568: PPUSH
74569: PPUSH
74570: PPUSH
74571: PPUSH
74572: PPUSH
74573: PPUSH
74574: PPUSH
74575: PPUSH
74576: PPUSH
74577: PPUSH
74578: PPUSH
74579: PPUSH
74580: PPUSH
74581: PPUSH
74582: PPUSH
74583: PPUSH
74584: PPUSH
74585: PPUSH
74586: PPUSH
74587: PPUSH
74588: PPUSH
74589: PPUSH
74590: PPUSH
74591: PPUSH
74592: PPUSH
74593: PPUSH
74594: PPUSH
74595: PPUSH
74596: PPUSH
74597: PPUSH
74598: PPUSH
74599: PPUSH
74600: PPUSH
74601: PPUSH
74602: PPUSH
74603: PPUSH
74604: PPUSH
74605: PPUSH
74606: PPUSH
74607: PPUSH
74608: PPUSH
74609: PPUSH
74610: PPUSH
74611: PPUSH
74612: PPUSH
74613: PPUSH
74614: PPUSH
74615: PPUSH
74616: PPUSH
74617: PPUSH
74618: PPUSH
74619: PPUSH
74620: PPUSH
74621: PPUSH
74622: PPUSH
// result = [ ] ;
74623: LD_ADDR_VAR 0 7
74627: PUSH
74628: EMPTY
74629: ST_TO_ADDR
// temp_list = [ ] ;
74630: LD_ADDR_VAR 0 9
74634: PUSH
74635: EMPTY
74636: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
74637: LD_VAR 0 4
74641: PUSH
74642: LD_INT 0
74644: PUSH
74645: LD_INT 1
74647: PUSH
74648: LD_INT 2
74650: PUSH
74651: LD_INT 3
74653: PUSH
74654: LD_INT 4
74656: PUSH
74657: LD_INT 5
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: IN
74668: NOT
74669: PUSH
74670: LD_VAR 0 1
74674: PUSH
74675: LD_INT 0
74677: PUSH
74678: LD_INT 1
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: IN
74685: PUSH
74686: LD_VAR 0 5
74690: PUSH
74691: LD_INT 1
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: LD_INT 3
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: LIST
74704: IN
74705: NOT
74706: AND
74707: OR
74708: IFFALSE 74712
// exit ;
74710: GO 93103
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
74712: LD_VAR 0 1
74716: PUSH
74717: LD_INT 6
74719: PUSH
74720: LD_INT 7
74722: PUSH
74723: LD_INT 8
74725: PUSH
74726: LD_INT 13
74728: PUSH
74729: LD_INT 12
74731: PUSH
74732: LD_INT 15
74734: PUSH
74735: LD_INT 11
74737: PUSH
74738: LD_INT 14
74740: PUSH
74741: LD_INT 10
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: IN
74755: IFFALSE 74765
// btype = b_lab ;
74757: LD_ADDR_VAR 0 1
74761: PUSH
74762: LD_INT 6
74764: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
74765: LD_VAR 0 6
74769: PUSH
74770: LD_INT 0
74772: PUSH
74773: LD_INT 1
74775: PUSH
74776: LD_INT 2
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: LIST
74783: IN
74784: NOT
74785: PUSH
74786: LD_VAR 0 1
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: LD_INT 1
74796: PUSH
74797: LD_INT 2
74799: PUSH
74800: LD_INT 3
74802: PUSH
74803: LD_INT 6
74805: PUSH
74806: LD_INT 36
74808: PUSH
74809: LD_INT 4
74811: PUSH
74812: LD_INT 5
74814: PUSH
74815: LD_INT 31
74817: PUSH
74818: LD_INT 32
74820: PUSH
74821: LD_INT 33
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: LIST
74828: LIST
74829: LIST
74830: LIST
74831: LIST
74832: LIST
74833: LIST
74834: LIST
74835: LIST
74836: IN
74837: NOT
74838: PUSH
74839: LD_VAR 0 6
74843: PUSH
74844: LD_INT 1
74846: EQUAL
74847: AND
74848: OR
74849: PUSH
74850: LD_VAR 0 1
74854: PUSH
74855: LD_INT 2
74857: PUSH
74858: LD_INT 3
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: IN
74865: NOT
74866: PUSH
74867: LD_VAR 0 6
74871: PUSH
74872: LD_INT 2
74874: EQUAL
74875: AND
74876: OR
74877: IFFALSE 74887
// mode = 0 ;
74879: LD_ADDR_VAR 0 6
74883: PUSH
74884: LD_INT 0
74886: ST_TO_ADDR
// case mode of 0 :
74887: LD_VAR 0 6
74891: PUSH
74892: LD_INT 0
74894: DOUBLE
74895: EQUAL
74896: IFTRUE 74900
74898: GO 86353
74900: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74901: LD_ADDR_VAR 0 11
74905: PUSH
74906: LD_INT 0
74908: PUSH
74909: LD_INT 0
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: LD_INT 0
74918: PUSH
74919: LD_INT 1
74921: NEG
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 1
74929: PUSH
74930: LD_INT 0
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 1
74939: PUSH
74940: LD_INT 1
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: LD_INT 1
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: LD_INT 0
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: LD_INT 1
74970: NEG
74971: PUSH
74972: LD_INT 1
74974: NEG
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 1
74982: NEG
74983: PUSH
74984: LD_INT 2
74986: NEG
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 0
74994: PUSH
74995: LD_INT 2
74997: NEG
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PUSH
75003: LD_INT 1
75005: PUSH
75006: LD_INT 1
75008: NEG
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 1
75016: PUSH
75017: LD_INT 2
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 0
75026: PUSH
75027: LD_INT 2
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: LD_INT 1
75036: NEG
75037: PUSH
75038: LD_INT 1
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 1
75047: PUSH
75048: LD_INT 3
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 0
75057: PUSH
75058: LD_INT 3
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: NEG
75068: PUSH
75069: LD_INT 2
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: LIST
75080: LIST
75081: LIST
75082: LIST
75083: LIST
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75094: LD_ADDR_VAR 0 12
75098: PUSH
75099: LD_INT 0
75101: PUSH
75102: LD_INT 0
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 0
75111: PUSH
75112: LD_INT 1
75114: NEG
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 1
75122: PUSH
75123: LD_INT 0
75125: PUSH
75126: EMPTY
75127: LIST
75128: LIST
75129: PUSH
75130: LD_INT 1
75132: PUSH
75133: LD_INT 1
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 0
75142: PUSH
75143: LD_INT 1
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 1
75152: NEG
75153: PUSH
75154: LD_INT 0
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 1
75163: NEG
75164: PUSH
75165: LD_INT 1
75167: NEG
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 1
75175: PUSH
75176: LD_INT 1
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 2
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 2
75196: PUSH
75197: LD_INT 1
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 1
75206: NEG
75207: PUSH
75208: LD_INT 1
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 2
75217: NEG
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 2
75228: NEG
75229: PUSH
75230: LD_INT 1
75232: NEG
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: LD_INT 2
75240: NEG
75241: PUSH
75242: LD_INT 1
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 3
75251: NEG
75252: PUSH
75253: LD_INT 0
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 3
75262: NEG
75263: PUSH
75264: LD_INT 1
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: LIST
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75290: LD_ADDR_VAR 0 13
75294: PUSH
75295: LD_INT 0
75297: PUSH
75298: LD_INT 0
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 0
75307: PUSH
75308: LD_INT 1
75310: NEG
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 1
75318: PUSH
75319: LD_INT 0
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 1
75328: PUSH
75329: LD_INT 1
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 0
75338: PUSH
75339: LD_INT 1
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 1
75348: NEG
75349: PUSH
75350: LD_INT 0
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 1
75359: NEG
75360: PUSH
75361: LD_INT 1
75363: NEG
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: LD_INT 1
75371: NEG
75372: PUSH
75373: LD_INT 2
75375: NEG
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 2
75383: PUSH
75384: LD_INT 1
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 2
75393: PUSH
75394: LD_INT 2
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 1
75403: PUSH
75404: LD_INT 2
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 2
75413: NEG
75414: PUSH
75415: LD_INT 1
75417: NEG
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 2
75425: NEG
75426: PUSH
75427: LD_INT 2
75429: NEG
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 2
75437: NEG
75438: PUSH
75439: LD_INT 3
75441: NEG
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 3
75449: NEG
75450: PUSH
75451: LD_INT 2
75453: NEG
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 3
75461: NEG
75462: PUSH
75463: LD_INT 3
75465: NEG
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: LIST
75475: LIST
75476: LIST
75477: LIST
75478: LIST
75479: LIST
75480: LIST
75481: LIST
75482: LIST
75483: LIST
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75489: LD_ADDR_VAR 0 14
75493: PUSH
75494: LD_INT 0
75496: PUSH
75497: LD_INT 0
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 0
75506: PUSH
75507: LD_INT 1
75509: NEG
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 1
75517: PUSH
75518: LD_INT 0
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 1
75527: PUSH
75528: LD_INT 1
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: LD_INT 1
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 1
75547: NEG
75548: PUSH
75549: LD_INT 0
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: LD_INT 1
75558: NEG
75559: PUSH
75560: LD_INT 1
75562: NEG
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 1
75570: NEG
75571: PUSH
75572: LD_INT 2
75574: NEG
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 0
75582: PUSH
75583: LD_INT 2
75585: NEG
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 1
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 1
75604: PUSH
75605: LD_INT 2
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 0
75614: PUSH
75615: LD_INT 2
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 1
75624: NEG
75625: PUSH
75626: LD_INT 1
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 1
75635: NEG
75636: PUSH
75637: LD_INT 3
75639: NEG
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PUSH
75645: LD_INT 0
75647: PUSH
75648: LD_INT 3
75650: NEG
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 1
75658: PUSH
75659: LD_INT 2
75661: NEG
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: LIST
75675: LIST
75676: LIST
75677: LIST
75678: LIST
75679: LIST
75680: LIST
75681: LIST
75682: LIST
75683: LIST
75684: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75685: LD_ADDR_VAR 0 15
75689: PUSH
75690: LD_INT 0
75692: PUSH
75693: LD_INT 0
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 0
75702: PUSH
75703: LD_INT 1
75705: NEG
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 1
75713: PUSH
75714: LD_INT 0
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 1
75723: PUSH
75724: LD_INT 1
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: LD_INT 1
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: LD_INT 1
75743: NEG
75744: PUSH
75745: LD_INT 0
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: LD_INT 1
75758: NEG
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 1
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 2
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 2
75787: PUSH
75788: LD_INT 1
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: NEG
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 2
75808: NEG
75809: PUSH
75810: LD_INT 0
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 2
75819: NEG
75820: PUSH
75821: LD_INT 1
75823: NEG
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 2
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 3
75842: PUSH
75843: LD_INT 0
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 3
75852: PUSH
75853: LD_INT 1
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: LIST
75877: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75878: LD_ADDR_VAR 0 16
75882: PUSH
75883: LD_INT 0
75885: PUSH
75886: LD_INT 0
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: LD_INT 1
75898: NEG
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 1
75906: PUSH
75907: LD_INT 0
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 1
75916: PUSH
75917: LD_INT 1
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 0
75926: PUSH
75927: LD_INT 1
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 1
75936: NEG
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 1
75947: NEG
75948: PUSH
75949: LD_INT 1
75951: NEG
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 1
75959: NEG
75960: PUSH
75961: LD_INT 2
75963: NEG
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 2
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 2
75981: PUSH
75982: LD_INT 2
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 1
75991: PUSH
75992: LD_INT 2
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 2
76001: NEG
76002: PUSH
76003: LD_INT 1
76005: NEG
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 2
76013: NEG
76014: PUSH
76015: LD_INT 2
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 3
76025: PUSH
76026: LD_INT 2
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 3
76035: PUSH
76036: LD_INT 3
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 3
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76071: LD_ADDR_VAR 0 17
76075: PUSH
76076: LD_INT 0
76078: PUSH
76079: LD_INT 0
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 0
76088: PUSH
76089: LD_INT 1
76091: NEG
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 1
76099: PUSH
76100: LD_INT 0
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 1
76109: PUSH
76110: LD_INT 1
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 0
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: PUSH
76127: LD_INT 1
76129: NEG
76130: PUSH
76131: LD_INT 0
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 1
76140: NEG
76141: PUSH
76142: LD_INT 1
76144: NEG
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PUSH
76150: LD_INT 1
76152: NEG
76153: PUSH
76154: LD_INT 2
76156: NEG
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 0
76164: PUSH
76165: LD_INT 2
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 1
76175: PUSH
76176: LD_INT 1
76178: NEG
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 2
76186: PUSH
76187: LD_INT 0
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: LD_INT 2
76196: PUSH
76197: LD_INT 1
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 2
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 1
76216: PUSH
76217: LD_INT 2
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 0
76226: PUSH
76227: LD_INT 2
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 1
76236: NEG
76237: PUSH
76238: LD_INT 1
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 2
76247: NEG
76248: PUSH
76249: LD_INT 0
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 2
76258: NEG
76259: PUSH
76260: LD_INT 1
76262: NEG
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 2
76270: NEG
76271: PUSH
76272: LD_INT 2
76274: NEG
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: LIST
76284: LIST
76285: LIST
76286: LIST
76287: LIST
76288: LIST
76289: LIST
76290: LIST
76291: LIST
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76301: LD_ADDR_VAR 0 18
76305: PUSH
76306: LD_INT 0
76308: PUSH
76309: LD_INT 0
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 0
76318: PUSH
76319: LD_INT 1
76321: NEG
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 1
76329: PUSH
76330: LD_INT 0
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 1
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 0
76349: PUSH
76350: LD_INT 1
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 1
76359: NEG
76360: PUSH
76361: LD_INT 0
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 1
76370: NEG
76371: PUSH
76372: LD_INT 1
76374: NEG
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 1
76382: NEG
76383: PUSH
76384: LD_INT 2
76386: NEG
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 0
76394: PUSH
76395: LD_INT 2
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 1
76405: PUSH
76406: LD_INT 1
76408: NEG
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 2
76416: PUSH
76417: LD_INT 0
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 2
76426: PUSH
76427: LD_INT 1
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 2
76436: PUSH
76437: LD_INT 2
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 1
76446: PUSH
76447: LD_INT 2
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 0
76456: PUSH
76457: LD_INT 2
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: LD_INT 1
76466: NEG
76467: PUSH
76468: LD_INT 1
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 2
76477: NEG
76478: PUSH
76479: LD_INT 0
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 2
76488: NEG
76489: PUSH
76490: LD_INT 1
76492: NEG
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 2
76500: NEG
76501: PUSH
76502: LD_INT 2
76504: NEG
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: LIST
76514: LIST
76515: LIST
76516: LIST
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76531: LD_ADDR_VAR 0 19
76535: PUSH
76536: LD_INT 0
76538: PUSH
76539: LD_INT 0
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 0
76548: PUSH
76549: LD_INT 1
76551: NEG
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 1
76559: PUSH
76560: LD_INT 0
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: LD_INT 1
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: LD_INT 1
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: LD_INT 1
76589: NEG
76590: PUSH
76591: LD_INT 0
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 1
76600: NEG
76601: PUSH
76602: LD_INT 1
76604: NEG
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 1
76612: NEG
76613: PUSH
76614: LD_INT 2
76616: NEG
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 0
76624: PUSH
76625: LD_INT 2
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 1
76635: PUSH
76636: LD_INT 1
76638: NEG
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 2
76646: PUSH
76647: LD_INT 0
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 2
76656: PUSH
76657: LD_INT 1
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 2
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 1
76676: PUSH
76677: LD_INT 2
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 0
76686: PUSH
76687: LD_INT 2
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 1
76696: NEG
76697: PUSH
76698: LD_INT 1
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 2
76707: NEG
76708: PUSH
76709: LD_INT 0
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 2
76718: NEG
76719: PUSH
76720: LD_INT 1
76722: NEG
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 2
76730: NEG
76731: PUSH
76732: LD_INT 2
76734: NEG
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76761: LD_ADDR_VAR 0 20
76765: PUSH
76766: LD_INT 0
76768: PUSH
76769: LD_INT 0
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 0
76778: PUSH
76779: LD_INT 1
76781: NEG
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 1
76789: PUSH
76790: LD_INT 0
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 1
76799: PUSH
76800: LD_INT 1
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 0
76809: PUSH
76810: LD_INT 1
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: PUSH
76817: LD_INT 1
76819: NEG
76820: PUSH
76821: LD_INT 0
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 1
76830: NEG
76831: PUSH
76832: LD_INT 1
76834: NEG
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 1
76842: NEG
76843: PUSH
76844: LD_INT 2
76846: NEG
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: LD_INT 2
76857: NEG
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 1
76865: PUSH
76866: LD_INT 1
76868: NEG
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 2
76876: PUSH
76877: LD_INT 0
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 2
76886: PUSH
76887: LD_INT 1
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 2
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 1
76906: PUSH
76907: LD_INT 2
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 0
76916: PUSH
76917: LD_INT 2
76919: PUSH
76920: EMPTY
76921: LIST
76922: LIST
76923: PUSH
76924: LD_INT 1
76926: NEG
76927: PUSH
76928: LD_INT 1
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 2
76937: NEG
76938: PUSH
76939: LD_INT 0
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 2
76948: NEG
76949: PUSH
76950: LD_INT 1
76952: NEG
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 2
76960: NEG
76961: PUSH
76962: LD_INT 2
76964: NEG
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: LIST
76974: LIST
76975: LIST
76976: LIST
76977: LIST
76978: LIST
76979: LIST
76980: LIST
76981: LIST
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76991: LD_ADDR_VAR 0 21
76995: PUSH
76996: LD_INT 0
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 0
77008: PUSH
77009: LD_INT 1
77011: NEG
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 1
77019: PUSH
77020: LD_INT 0
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 1
77029: PUSH
77030: LD_INT 1
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 0
77039: PUSH
77040: LD_INT 1
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 1
77049: NEG
77050: PUSH
77051: LD_INT 0
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 1
77060: NEG
77061: PUSH
77062: LD_INT 1
77064: NEG
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 1
77072: NEG
77073: PUSH
77074: LD_INT 2
77076: NEG
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: LD_INT 0
77084: PUSH
77085: LD_INT 2
77087: NEG
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 1
77095: PUSH
77096: LD_INT 1
77098: NEG
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PUSH
77104: LD_INT 2
77106: PUSH
77107: LD_INT 0
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 2
77116: PUSH
77117: LD_INT 1
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 2
77126: PUSH
77127: LD_INT 2
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 1
77136: PUSH
77137: LD_INT 2
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 0
77146: PUSH
77147: LD_INT 2
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 1
77156: NEG
77157: PUSH
77158: LD_INT 1
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 2
77167: NEG
77168: PUSH
77169: LD_INT 0
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 2
77178: NEG
77179: PUSH
77180: LD_INT 1
77182: NEG
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PUSH
77188: LD_INT 2
77190: NEG
77191: PUSH
77192: LD_INT 2
77194: NEG
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77221: LD_ADDR_VAR 0 22
77225: PUSH
77226: LD_INT 0
77228: PUSH
77229: LD_INT 0
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 0
77238: PUSH
77239: LD_INT 1
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 1
77249: PUSH
77250: LD_INT 0
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 1
77259: PUSH
77260: LD_INT 1
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 0
77269: PUSH
77270: LD_INT 1
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: PUSH
77277: LD_INT 1
77279: NEG
77280: PUSH
77281: LD_INT 0
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 1
77290: NEG
77291: PUSH
77292: LD_INT 1
77294: NEG
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: PUSH
77300: LD_INT 1
77302: NEG
77303: PUSH
77304: LD_INT 2
77306: NEG
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: LD_INT 0
77314: PUSH
77315: LD_INT 2
77317: NEG
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 1
77325: PUSH
77326: LD_INT 1
77328: NEG
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 2
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 2
77346: PUSH
77347: LD_INT 1
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 2
77356: PUSH
77357: LD_INT 2
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 1
77366: PUSH
77367: LD_INT 2
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 0
77376: PUSH
77377: LD_INT 2
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 1
77386: NEG
77387: PUSH
77388: LD_INT 1
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 2
77397: NEG
77398: PUSH
77399: LD_INT 0
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 2
77408: NEG
77409: PUSH
77410: LD_INT 1
77412: NEG
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 2
77420: NEG
77421: PUSH
77422: LD_INT 2
77424: NEG
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: LIST
77441: LIST
77442: LIST
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77451: LD_ADDR_VAR 0 23
77455: PUSH
77456: LD_INT 0
77458: PUSH
77459: LD_INT 0
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 0
77468: PUSH
77469: LD_INT 1
77471: NEG
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 1
77479: PUSH
77480: LD_INT 0
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: PUSH
77490: LD_INT 1
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 0
77499: PUSH
77500: LD_INT 1
77502: PUSH
77503: EMPTY
77504: LIST
77505: LIST
77506: PUSH
77507: LD_INT 1
77509: NEG
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 1
77520: NEG
77521: PUSH
77522: LD_INT 1
77524: NEG
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 1
77532: NEG
77533: PUSH
77534: LD_INT 2
77536: NEG
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 0
77544: PUSH
77545: LD_INT 2
77547: NEG
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 1
77555: PUSH
77556: LD_INT 1
77558: NEG
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 2
77566: PUSH
77567: LD_INT 0
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 2
77576: PUSH
77577: LD_INT 1
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 2
77586: PUSH
77587: LD_INT 2
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 1
77596: PUSH
77597: LD_INT 2
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 0
77606: PUSH
77607: LD_INT 2
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 1
77616: NEG
77617: PUSH
77618: LD_INT 1
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 2
77627: NEG
77628: PUSH
77629: LD_INT 0
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 2
77638: NEG
77639: PUSH
77640: LD_INT 1
77642: NEG
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 2
77650: NEG
77651: PUSH
77652: LD_INT 2
77654: NEG
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 2
77662: NEG
77663: PUSH
77664: LD_INT 3
77666: NEG
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: LD_INT 1
77674: NEG
77675: PUSH
77676: LD_INT 3
77678: NEG
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 1
77686: PUSH
77687: LD_INT 2
77689: NEG
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 2
77697: PUSH
77698: LD_INT 1
77700: NEG
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
77731: LD_ADDR_VAR 0 24
77735: PUSH
77736: LD_INT 0
77738: PUSH
77739: LD_INT 0
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: LD_INT 1
77751: NEG
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 1
77759: PUSH
77760: LD_INT 0
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 1
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 0
77779: PUSH
77780: LD_INT 1
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 1
77789: NEG
77790: PUSH
77791: LD_INT 0
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 1
77800: NEG
77801: PUSH
77802: LD_INT 1
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 1
77812: NEG
77813: PUSH
77814: LD_INT 2
77816: NEG
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 0
77824: PUSH
77825: LD_INT 2
77827: NEG
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 1
77835: PUSH
77836: LD_INT 1
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 2
77846: PUSH
77847: LD_INT 0
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 2
77856: PUSH
77857: LD_INT 1
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 2
77866: PUSH
77867: LD_INT 2
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: LD_INT 2
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 0
77886: PUSH
77887: LD_INT 2
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: LD_INT 1
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 2
77907: NEG
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: NEG
77919: PUSH
77920: LD_INT 1
77922: NEG
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 2
77930: NEG
77931: PUSH
77932: LD_INT 2
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: PUSH
77943: LD_INT 2
77945: NEG
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 2
77953: PUSH
77954: LD_INT 1
77956: NEG
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 3
77964: PUSH
77965: LD_INT 1
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: LD_INT 3
77974: PUSH
77975: LD_INT 2
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
78007: LD_ADDR_VAR 0 25
78011: PUSH
78012: LD_INT 0
78014: PUSH
78015: LD_INT 0
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: LD_INT 0
78024: PUSH
78025: LD_INT 1
78027: NEG
78028: PUSH
78029: EMPTY
78030: LIST
78031: LIST
78032: PUSH
78033: LD_INT 1
78035: PUSH
78036: LD_INT 0
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: PUSH
78043: LD_INT 1
78045: PUSH
78046: LD_INT 1
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 0
78055: PUSH
78056: LD_INT 1
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 1
78065: NEG
78066: PUSH
78067: LD_INT 0
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: LD_INT 1
78080: NEG
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 1
78088: NEG
78089: PUSH
78090: LD_INT 2
78092: NEG
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 0
78100: PUSH
78101: LD_INT 2
78103: NEG
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 1
78111: PUSH
78112: LD_INT 1
78114: NEG
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 2
78122: PUSH
78123: LD_INT 0
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 2
78132: PUSH
78133: LD_INT 1
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 2
78142: PUSH
78143: LD_INT 2
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 1
78152: PUSH
78153: LD_INT 2
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 0
78162: PUSH
78163: LD_INT 2
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 1
78172: NEG
78173: PUSH
78174: LD_INT 1
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 2
78183: NEG
78184: PUSH
78185: LD_INT 0
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 2
78194: NEG
78195: PUSH
78196: LD_INT 1
78198: NEG
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 2
78206: NEG
78207: PUSH
78208: LD_INT 2
78210: NEG
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 3
78218: PUSH
78219: LD_INT 1
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 3
78228: PUSH
78229: LD_INT 2
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 2
78238: PUSH
78239: LD_INT 3
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 1
78248: PUSH
78249: LD_INT 3
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: LIST
78263: LIST
78264: LIST
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78281: LD_ADDR_VAR 0 26
78285: PUSH
78286: LD_INT 0
78288: PUSH
78289: LD_INT 0
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 0
78298: PUSH
78299: LD_INT 1
78301: NEG
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 1
78309: PUSH
78310: LD_INT 0
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 1
78319: PUSH
78320: LD_INT 1
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 0
78329: PUSH
78330: LD_INT 1
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 1
78339: NEG
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 1
78350: NEG
78351: PUSH
78352: LD_INT 1
78354: NEG
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 1
78362: NEG
78363: PUSH
78364: LD_INT 2
78366: NEG
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 0
78374: PUSH
78375: LD_INT 2
78377: NEG
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 1
78385: PUSH
78386: LD_INT 1
78388: NEG
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 2
78396: PUSH
78397: LD_INT 0
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 2
78406: PUSH
78407: LD_INT 1
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 2
78416: PUSH
78417: LD_INT 2
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 1
78426: PUSH
78427: LD_INT 2
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: LD_INT 0
78436: PUSH
78437: LD_INT 2
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 1
78446: NEG
78447: PUSH
78448: LD_INT 1
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 2
78457: NEG
78458: PUSH
78459: LD_INT 0
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 2
78468: NEG
78469: PUSH
78470: LD_INT 1
78472: NEG
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 2
78480: NEG
78481: PUSH
78482: LD_INT 2
78484: NEG
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: LD_INT 3
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 1
78512: NEG
78513: PUSH
78514: LD_INT 2
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 2
78523: NEG
78524: PUSH
78525: LD_INT 1
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78557: LD_ADDR_VAR 0 27
78561: PUSH
78562: LD_INT 0
78564: PUSH
78565: LD_INT 0
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 0
78574: PUSH
78575: LD_INT 1
78577: NEG
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 1
78585: PUSH
78586: LD_INT 0
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 1
78595: PUSH
78596: LD_INT 1
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 0
78605: PUSH
78606: LD_INT 1
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 1
78615: NEG
78616: PUSH
78617: LD_INT 0
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 1
78626: NEG
78627: PUSH
78628: LD_INT 1
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 1
78638: NEG
78639: PUSH
78640: LD_INT 2
78642: NEG
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 0
78650: PUSH
78651: LD_INT 2
78653: NEG
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 1
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 2
78672: PUSH
78673: LD_INT 0
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 2
78682: PUSH
78683: LD_INT 1
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 2
78692: PUSH
78693: LD_INT 2
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 1
78702: PUSH
78703: LD_INT 2
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 0
78712: PUSH
78713: LD_INT 2
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: LD_INT 1
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 2
78733: NEG
78734: PUSH
78735: LD_INT 0
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 2
78744: NEG
78745: PUSH
78746: LD_INT 1
78748: NEG
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 2
78756: NEG
78757: PUSH
78758: LD_INT 2
78760: NEG
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 1
78768: NEG
78769: PUSH
78770: LD_INT 2
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 2
78779: NEG
78780: PUSH
78781: LD_INT 1
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: NEG
78791: PUSH
78792: LD_INT 1
78794: NEG
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 3
78802: NEG
78803: PUSH
78804: LD_INT 2
78806: NEG
78807: PUSH
78808: EMPTY
78809: LIST
78810: LIST
78811: PUSH
78812: EMPTY
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78837: LD_ADDR_VAR 0 28
78841: PUSH
78842: LD_INT 0
78844: PUSH
78845: LD_INT 0
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 0
78854: PUSH
78855: LD_INT 1
78857: NEG
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: LD_INT 1
78865: PUSH
78866: LD_INT 0
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: PUSH
78873: LD_INT 1
78875: PUSH
78876: LD_INT 1
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 0
78885: PUSH
78886: LD_INT 1
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 1
78895: NEG
78896: PUSH
78897: LD_INT 0
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 1
78906: NEG
78907: PUSH
78908: LD_INT 1
78910: NEG
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 1
78918: NEG
78919: PUSH
78920: LD_INT 2
78922: NEG
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 0
78930: PUSH
78931: LD_INT 2
78933: NEG
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 1
78941: PUSH
78942: LD_INT 1
78944: NEG
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 2
78952: PUSH
78953: LD_INT 0
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 2
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 2
78972: PUSH
78973: LD_INT 2
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 1
78982: PUSH
78983: LD_INT 2
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 0
78992: PUSH
78993: LD_INT 2
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 1
79002: NEG
79003: PUSH
79004: LD_INT 1
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 2
79013: NEG
79014: PUSH
79015: LD_INT 0
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 2
79024: NEG
79025: PUSH
79026: LD_INT 1
79028: NEG
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 2
79036: NEG
79037: PUSH
79038: LD_INT 2
79040: NEG
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 2
79048: NEG
79049: PUSH
79050: LD_INT 3
79052: NEG
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: NEG
79061: PUSH
79062: LD_INT 3
79064: NEG
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 3
79072: NEG
79073: PUSH
79074: LD_INT 1
79076: NEG
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 3
79084: NEG
79085: PUSH
79086: LD_INT 2
79088: NEG
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79119: LD_ADDR_VAR 0 29
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: LD_INT 0
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 0
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 1
79147: PUSH
79148: LD_INT 0
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 1
79157: PUSH
79158: LD_INT 1
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 0
79167: PUSH
79168: LD_INT 1
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: LD_INT 0
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 1
79188: NEG
79189: PUSH
79190: LD_INT 1
79192: NEG
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 1
79200: NEG
79201: PUSH
79202: LD_INT 2
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 0
79212: PUSH
79213: LD_INT 2
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 1
79223: PUSH
79224: LD_INT 1
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 2
79234: PUSH
79235: LD_INT 0
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 2
79244: PUSH
79245: LD_INT 1
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 1
79254: PUSH
79255: LD_INT 2
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 0
79264: PUSH
79265: LD_INT 2
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 1
79274: NEG
79275: PUSH
79276: LD_INT 1
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 2
79285: NEG
79286: PUSH
79287: LD_INT 1
79289: NEG
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 2
79297: NEG
79298: PUSH
79299: LD_INT 2
79301: NEG
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 2
79309: NEG
79310: PUSH
79311: LD_INT 3
79313: NEG
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 2
79321: PUSH
79322: LD_INT 1
79324: NEG
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 3
79332: PUSH
79333: LD_INT 1
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 1
79342: PUSH
79343: LD_INT 3
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 1
79352: NEG
79353: PUSH
79354: LD_INT 2
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 3
79363: NEG
79364: PUSH
79365: LD_INT 2
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79398: LD_ADDR_VAR 0 30
79402: PUSH
79403: LD_INT 0
79405: PUSH
79406: LD_INT 0
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 0
79415: PUSH
79416: LD_INT 1
79418: NEG
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 1
79426: PUSH
79427: LD_INT 0
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 1
79436: PUSH
79437: LD_INT 1
79439: PUSH
79440: EMPTY
79441: LIST
79442: LIST
79443: PUSH
79444: LD_INT 0
79446: PUSH
79447: LD_INT 1
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 1
79456: NEG
79457: PUSH
79458: LD_INT 0
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: NEG
79468: PUSH
79469: LD_INT 1
79471: NEG
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: LD_INT 1
79479: NEG
79480: PUSH
79481: LD_INT 2
79483: NEG
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 0
79491: PUSH
79492: LD_INT 2
79494: NEG
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 1
79502: PUSH
79503: LD_INT 1
79505: NEG
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: LD_INT 2
79513: PUSH
79514: LD_INT 0
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 2
79523: PUSH
79524: LD_INT 1
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 2
79533: PUSH
79534: LD_INT 2
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 1
79543: PUSH
79544: LD_INT 2
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 1
79553: NEG
79554: PUSH
79555: LD_INT 1
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 2
79564: NEG
79565: PUSH
79566: LD_INT 0
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: PUSH
79573: LD_INT 2
79575: NEG
79576: PUSH
79577: LD_INT 1
79579: NEG
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 1
79587: NEG
79588: PUSH
79589: LD_INT 3
79591: NEG
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 1
79599: PUSH
79600: LD_INT 2
79602: NEG
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 3
79610: PUSH
79611: LD_INT 2
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 2
79620: PUSH
79621: LD_INT 3
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 2
79630: NEG
79631: PUSH
79632: LD_INT 1
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 3
79641: NEG
79642: PUSH
79643: LD_INT 1
79645: NEG
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79676: LD_ADDR_VAR 0 31
79680: PUSH
79681: LD_INT 0
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 0
79693: PUSH
79694: LD_INT 1
79696: NEG
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: LD_INT 1
79704: PUSH
79705: LD_INT 0
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 1
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 0
79724: PUSH
79725: LD_INT 1
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 1
79734: NEG
79735: PUSH
79736: LD_INT 0
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 1
79745: NEG
79746: PUSH
79747: LD_INT 1
79749: NEG
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 1
79757: NEG
79758: PUSH
79759: LD_INT 2
79761: NEG
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 1
79769: PUSH
79770: LD_INT 1
79772: NEG
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 2
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 2
79790: PUSH
79791: LD_INT 1
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 2
79800: PUSH
79801: LD_INT 2
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 1
79810: PUSH
79811: LD_INT 2
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 0
79820: PUSH
79821: LD_INT 2
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 1
79830: NEG
79831: PUSH
79832: LD_INT 1
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 2
79841: NEG
79842: PUSH
79843: LD_INT 1
79845: NEG
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 2
79853: NEG
79854: PUSH
79855: LD_INT 2
79857: NEG
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 2
79865: NEG
79866: PUSH
79867: LD_INT 3
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 2
79877: PUSH
79878: LD_INT 1
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 3
79888: PUSH
79889: LD_INT 1
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 1
79898: PUSH
79899: LD_INT 3
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 1
79908: NEG
79909: PUSH
79910: LD_INT 2
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 3
79919: NEG
79920: PUSH
79921: LD_INT 2
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79954: LD_ADDR_VAR 0 32
79958: PUSH
79959: LD_INT 0
79961: PUSH
79962: LD_INT 0
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 1
79982: PUSH
79983: LD_INT 0
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: LD_INT 1
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 0
80002: PUSH
80003: LD_INT 1
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 1
80023: NEG
80024: PUSH
80025: LD_INT 1
80027: NEG
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: LD_INT 2
80039: NEG
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 0
80047: PUSH
80048: LD_INT 2
80050: NEG
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 1
80058: PUSH
80059: LD_INT 1
80061: NEG
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 2
80069: PUSH
80070: LD_INT 1
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 2
80079: PUSH
80080: LD_INT 2
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 1
80089: PUSH
80090: LD_INT 2
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 0
80099: PUSH
80100: LD_INT 2
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 1
80109: NEG
80110: PUSH
80111: LD_INT 1
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 2
80120: NEG
80121: PUSH
80122: LD_INT 0
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 2
80131: NEG
80132: PUSH
80133: LD_INT 1
80135: NEG
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: LD_INT 3
80147: NEG
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 1
80155: PUSH
80156: LD_INT 2
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 3
80166: PUSH
80167: LD_INT 2
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 2
80176: PUSH
80177: LD_INT 3
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 2
80186: NEG
80187: PUSH
80188: LD_INT 1
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 3
80197: NEG
80198: PUSH
80199: LD_INT 1
80201: NEG
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: LIST
80224: LIST
80225: LIST
80226: LIST
80227: LIST
80228: LIST
80229: LIST
80230: LIST
80231: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80232: LD_ADDR_VAR 0 33
80236: PUSH
80237: LD_INT 0
80239: PUSH
80240: LD_INT 0
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: LD_INT 1
80252: NEG
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 1
80260: PUSH
80261: LD_INT 0
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 1
80270: PUSH
80271: LD_INT 1
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: LD_INT 1
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 1
80290: NEG
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 1
80301: NEG
80302: PUSH
80303: LD_INT 1
80305: NEG
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: PUSH
80311: LD_INT 1
80313: NEG
80314: PUSH
80315: LD_INT 2
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: LD_INT 1
80328: NEG
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: LD_INT 2
80336: PUSH
80337: LD_INT 0
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 2
80346: PUSH
80347: LD_INT 1
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: LD_INT 1
80356: PUSH
80357: LD_INT 2
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 0
80366: PUSH
80367: LD_INT 2
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 1
80376: NEG
80377: PUSH
80378: LD_INT 1
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 2
80387: NEG
80388: PUSH
80389: LD_INT 0
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 2
80398: NEG
80399: PUSH
80400: LD_INT 1
80402: NEG
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 2
80410: NEG
80411: PUSH
80412: LD_INT 2
80414: NEG
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 2
80422: NEG
80423: PUSH
80424: LD_INT 3
80426: NEG
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 2
80434: PUSH
80435: LD_INT 1
80437: NEG
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 3
80445: PUSH
80446: LD_INT 1
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: LD_INT 3
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 1
80465: NEG
80466: PUSH
80467: LD_INT 2
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 3
80476: NEG
80477: PUSH
80478: LD_INT 2
80480: NEG
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80511: LD_ADDR_VAR 0 34
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 0
80528: PUSH
80529: LD_INT 1
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 1
80539: PUSH
80540: LD_INT 0
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 1
80549: PUSH
80550: LD_INT 1
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 1
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 1
80569: NEG
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 1
80580: NEG
80581: PUSH
80582: LD_INT 1
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: NEG
80593: PUSH
80594: LD_INT 2
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: LD_INT 2
80607: NEG
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 1
80615: PUSH
80616: LD_INT 1
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 2
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 2
80636: PUSH
80637: LD_INT 2
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 2
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 1
80656: NEG
80657: PUSH
80658: LD_INT 1
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 2
80667: NEG
80668: PUSH
80669: LD_INT 0
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 2
80678: NEG
80679: PUSH
80680: LD_INT 1
80682: NEG
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 2
80690: NEG
80691: PUSH
80692: LD_INT 2
80694: NEG
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: LD_INT 3
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 1
80714: PUSH
80715: LD_INT 2
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 3
80725: PUSH
80726: LD_INT 2
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 2
80735: PUSH
80736: LD_INT 3
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 2
80745: NEG
80746: PUSH
80747: LD_INT 1
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 3
80756: NEG
80757: PUSH
80758: LD_INT 1
80760: NEG
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80791: LD_ADDR_VAR 0 35
80795: PUSH
80796: LD_INT 0
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 1
80811: NEG
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: PUSH
80820: LD_INT 0
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: PUSH
80830: LD_INT 1
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 1
80849: NEG
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 1
80860: NEG
80861: PUSH
80862: LD_INT 1
80864: NEG
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 2
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 2
80882: NEG
80883: PUSH
80884: LD_INT 1
80886: NEG
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80903: LD_ADDR_VAR 0 36
80907: PUSH
80908: LD_INT 0
80910: PUSH
80911: LD_INT 0
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 0
80920: PUSH
80921: LD_INT 1
80923: NEG
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 1
80931: PUSH
80932: LD_INT 0
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: LD_INT 1
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 0
80951: PUSH
80952: LD_INT 1
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 1
80961: NEG
80962: PUSH
80963: LD_INT 0
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 1
80972: NEG
80973: PUSH
80974: LD_INT 1
80976: NEG
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 1
80984: NEG
80985: PUSH
80986: LD_INT 2
80988: NEG
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 1
80996: PUSH
80997: LD_INT 2
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: LIST
81013: LIST
81014: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81015: LD_ADDR_VAR 0 37
81019: PUSH
81020: LD_INT 0
81022: PUSH
81023: LD_INT 0
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: LD_INT 1
81035: NEG
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 1
81043: PUSH
81044: LD_INT 0
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 1
81053: PUSH
81054: LD_INT 1
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 0
81063: PUSH
81064: LD_INT 1
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 1
81073: NEG
81074: PUSH
81075: LD_INT 0
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 1
81084: NEG
81085: PUSH
81086: LD_INT 1
81088: NEG
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: LD_INT 1
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 1
81107: NEG
81108: PUSH
81109: LD_INT 1
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
81127: LD_ADDR_VAR 0 38
81131: PUSH
81132: LD_INT 0
81134: PUSH
81135: LD_INT 0
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: PUSH
81142: LD_INT 0
81144: PUSH
81145: LD_INT 1
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 1
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: LD_INT 1
81165: PUSH
81166: LD_INT 1
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: LD_INT 1
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: NEG
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 1
81196: NEG
81197: PUSH
81198: LD_INT 1
81200: NEG
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 2
81208: PUSH
81209: LD_INT 1
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 2
81218: NEG
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: LIST
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81239: LD_ADDR_VAR 0 39
81243: PUSH
81244: LD_INT 0
81246: PUSH
81247: LD_INT 0
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 0
81256: PUSH
81257: LD_INT 1
81259: NEG
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 1
81267: PUSH
81268: LD_INT 0
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 1
81277: PUSH
81278: LD_INT 1
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 0
81287: PUSH
81288: LD_INT 1
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 1
81297: NEG
81298: PUSH
81299: LD_INT 0
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 1
81308: NEG
81309: PUSH
81310: LD_INT 1
81312: NEG
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 1
81320: NEG
81321: PUSH
81322: LD_INT 2
81324: NEG
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 1
81332: PUSH
81333: LD_INT 2
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: LIST
81350: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81351: LD_ADDR_VAR 0 40
81355: PUSH
81356: LD_INT 0
81358: PUSH
81359: LD_INT 0
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 0
81368: PUSH
81369: LD_INT 1
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 1
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 1
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 0
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: LD_INT 0
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 1
81420: NEG
81421: PUSH
81422: LD_INT 1
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 1
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: NEG
81444: PUSH
81445: LD_INT 1
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81463: LD_ADDR_VAR 0 41
81467: PUSH
81468: LD_INT 0
81470: PUSH
81471: LD_INT 0
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 0
81480: PUSH
81481: LD_INT 1
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: PUSH
81492: LD_INT 0
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: PUSH
81502: LD_INT 1
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: LD_INT 1
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 1
81521: NEG
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 1
81532: NEG
81533: PUSH
81534: LD_INT 1
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 1
81544: NEG
81545: PUSH
81546: LD_INT 2
81548: NEG
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PUSH
81554: LD_INT 1
81556: PUSH
81557: LD_INT 1
81559: NEG
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 2
81567: PUSH
81568: LD_INT 0
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 2
81577: PUSH
81578: LD_INT 1
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 2
81587: PUSH
81588: LD_INT 2
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 1
81597: PUSH
81598: LD_INT 2
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: PUSH
81605: LD_INT 1
81607: NEG
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 2
81618: NEG
81619: PUSH
81620: LD_INT 0
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 2
81629: NEG
81630: PUSH
81631: LD_INT 1
81633: NEG
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: LD_INT 2
81645: NEG
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 2
81653: NEG
81654: PUSH
81655: LD_INT 3
81657: NEG
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 2
81665: PUSH
81666: LD_INT 1
81668: NEG
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 3
81676: PUSH
81677: LD_INT 0
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 3
81686: PUSH
81687: LD_INT 1
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 3
81696: PUSH
81697: LD_INT 2
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 3
81706: PUSH
81707: LD_INT 3
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 2
81716: PUSH
81717: LD_INT 3
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PUSH
81724: LD_INT 2
81726: NEG
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 3
81737: NEG
81738: PUSH
81739: LD_INT 0
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 3
81748: NEG
81749: PUSH
81750: LD_INT 1
81752: NEG
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: PUSH
81758: LD_INT 3
81760: NEG
81761: PUSH
81762: LD_INT 2
81764: NEG
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PUSH
81770: LD_INT 3
81772: NEG
81773: PUSH
81774: LD_INT 3
81776: NEG
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81813: LD_ADDR_VAR 0 42
81817: PUSH
81818: LD_INT 0
81820: PUSH
81821: LD_INT 0
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 0
81830: PUSH
81831: LD_INT 1
81833: NEG
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 1
81841: PUSH
81842: LD_INT 0
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 1
81851: PUSH
81852: LD_INT 1
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 0
81861: PUSH
81862: LD_INT 1
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 1
81871: NEG
81872: PUSH
81873: LD_INT 0
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 1
81882: NEG
81883: PUSH
81884: LD_INT 1
81886: NEG
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: LD_INT 2
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: LD_INT 2
81909: NEG
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 1
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 2
81928: PUSH
81929: LD_INT 1
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 2
81938: PUSH
81939: LD_INT 2
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: LD_INT 2
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 0
81958: PUSH
81959: LD_INT 2
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 1
81968: NEG
81969: PUSH
81970: LD_INT 1
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 2
81979: NEG
81980: PUSH
81981: LD_INT 1
81983: NEG
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 2
81991: NEG
81992: PUSH
81993: LD_INT 2
81995: NEG
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 2
82003: NEG
82004: PUSH
82005: LD_INT 3
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: LD_INT 3
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 0
82027: PUSH
82028: LD_INT 3
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 1
82038: PUSH
82039: LD_INT 2
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 3
82049: PUSH
82050: LD_INT 2
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 3
82059: PUSH
82060: LD_INT 3
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 2
82069: PUSH
82070: LD_INT 3
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 1
82079: PUSH
82080: LD_INT 3
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 0
82089: PUSH
82090: LD_INT 3
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 1
82099: NEG
82100: PUSH
82101: LD_INT 2
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 3
82110: NEG
82111: PUSH
82112: LD_INT 2
82114: NEG
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 3
82122: NEG
82123: PUSH
82124: LD_INT 3
82126: NEG
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82163: LD_ADDR_VAR 0 43
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 0
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 0
82180: PUSH
82181: LD_INT 1
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 1
82191: PUSH
82192: LD_INT 0
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 1
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 0
82211: PUSH
82212: LD_INT 1
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 1
82221: NEG
82222: PUSH
82223: LD_INT 0
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 1
82232: NEG
82233: PUSH
82234: LD_INT 1
82236: NEG
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 1
82244: NEG
82245: PUSH
82246: LD_INT 2
82248: NEG
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 0
82256: PUSH
82257: LD_INT 2
82259: NEG
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: PUSH
82268: LD_INT 1
82270: NEG
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 2
82278: PUSH
82279: LD_INT 0
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 2
82288: PUSH
82289: LD_INT 1
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 1
82298: PUSH
82299: LD_INT 2
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: LD_INT 2
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 1
82318: NEG
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 2
82329: NEG
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 2
82340: NEG
82341: PUSH
82342: LD_INT 1
82344: NEG
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PUSH
82350: LD_INT 1
82352: NEG
82353: PUSH
82354: LD_INT 3
82356: NEG
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: LD_INT 3
82367: NEG
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 1
82375: PUSH
82376: LD_INT 2
82378: NEG
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: LD_INT 2
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 3
82397: PUSH
82398: LD_INT 0
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 3
82407: PUSH
82408: LD_INT 1
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 1
82417: PUSH
82418: LD_INT 3
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 0
82427: PUSH
82428: LD_INT 3
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: LD_INT 2
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 2
82448: NEG
82449: PUSH
82450: LD_INT 1
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 3
82459: NEG
82460: PUSH
82461: LD_INT 0
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 3
82470: NEG
82471: PUSH
82472: LD_INT 1
82474: NEG
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82511: LD_ADDR_VAR 0 44
82515: PUSH
82516: LD_INT 0
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 0
82528: PUSH
82529: LD_INT 1
82531: NEG
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 1
82539: PUSH
82540: LD_INT 0
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: LD_INT 1
82549: PUSH
82550: LD_INT 1
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PUSH
82557: LD_INT 0
82559: PUSH
82560: LD_INT 1
82562: PUSH
82563: EMPTY
82564: LIST
82565: LIST
82566: PUSH
82567: LD_INT 1
82569: NEG
82570: PUSH
82571: LD_INT 0
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: LD_INT 1
82584: NEG
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 1
82592: NEG
82593: PUSH
82594: LD_INT 2
82596: NEG
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 1
82604: PUSH
82605: LD_INT 1
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: PUSH
82616: LD_INT 0
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 2
82625: PUSH
82626: LD_INT 1
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 2
82635: PUSH
82636: LD_INT 2
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 1
82645: PUSH
82646: LD_INT 2
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: LD_INT 1
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 2
82666: NEG
82667: PUSH
82668: LD_INT 0
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 2
82677: NEG
82678: PUSH
82679: LD_INT 1
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 2
82689: NEG
82690: PUSH
82691: LD_INT 2
82693: NEG
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 2
82701: NEG
82702: PUSH
82703: LD_INT 3
82705: NEG
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 2
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 3
82724: PUSH
82725: LD_INT 0
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 3
82734: PUSH
82735: LD_INT 1
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 3
82744: PUSH
82745: LD_INT 2
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 3
82754: PUSH
82755: LD_INT 3
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 2
82764: PUSH
82765: LD_INT 3
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: LD_INT 1
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: PUSH
82783: LD_INT 3
82785: NEG
82786: PUSH
82787: LD_INT 0
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 3
82796: NEG
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: LD_INT 3
82808: NEG
82809: PUSH
82810: LD_INT 2
82812: NEG
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PUSH
82818: LD_INT 3
82820: NEG
82821: PUSH
82822: LD_INT 3
82824: NEG
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82861: LD_ADDR_VAR 0 45
82865: PUSH
82866: LD_INT 0
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: PUSH
82876: LD_INT 0
82878: PUSH
82879: LD_INT 1
82881: NEG
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 1
82889: PUSH
82890: LD_INT 0
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 1
82899: PUSH
82900: LD_INT 1
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 0
82909: PUSH
82910: LD_INT 1
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 1
82919: NEG
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: NEG
82931: PUSH
82932: LD_INT 1
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: LD_INT 2
82946: NEG
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 2
82976: PUSH
82977: LD_INT 1
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 2
82986: PUSH
82987: LD_INT 2
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: PUSH
82997: LD_INT 2
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 2
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 1
83016: NEG
83017: PUSH
83018: LD_INT 1
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 2
83039: NEG
83040: PUSH
83041: LD_INT 2
83043: NEG
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 2
83051: NEG
83052: PUSH
83053: LD_INT 3
83055: NEG
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: NEG
83064: PUSH
83065: LD_INT 3
83067: NEG
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 0
83075: PUSH
83076: LD_INT 3
83078: NEG
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 1
83086: PUSH
83087: LD_INT 2
83089: NEG
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 3
83097: PUSH
83098: LD_INT 2
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: LD_INT 3
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 2
83117: PUSH
83118: LD_INT 3
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 1
83127: PUSH
83128: LD_INT 3
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 0
83137: PUSH
83138: LD_INT 3
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 1
83147: NEG
83148: PUSH
83149: LD_INT 2
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 3
83158: NEG
83159: PUSH
83160: LD_INT 2
83162: NEG
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 3
83170: NEG
83171: PUSH
83172: LD_INT 3
83174: NEG
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83211: LD_ADDR_VAR 0 46
83215: PUSH
83216: LD_INT 0
83218: PUSH
83219: LD_INT 0
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 0
83228: PUSH
83229: LD_INT 1
83231: NEG
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 1
83239: PUSH
83240: LD_INT 0
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 1
83249: PUSH
83250: LD_INT 1
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 0
83259: PUSH
83260: LD_INT 1
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 1
83269: NEG
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 1
83280: NEG
83281: PUSH
83282: LD_INT 1
83284: NEG
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 1
83292: NEG
83293: PUSH
83294: LD_INT 2
83296: NEG
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 0
83304: PUSH
83305: LD_INT 2
83307: NEG
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 1
83315: PUSH
83316: LD_INT 1
83318: NEG
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 2
83326: PUSH
83327: LD_INT 0
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 2
83336: PUSH
83337: LD_INT 1
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 1
83346: PUSH
83347: LD_INT 2
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 0
83356: PUSH
83357: LD_INT 2
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 1
83366: NEG
83367: PUSH
83368: LD_INT 1
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: NEG
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 2
83388: NEG
83389: PUSH
83390: LD_INT 1
83392: NEG
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 1
83400: NEG
83401: PUSH
83402: LD_INT 3
83404: NEG
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 0
83412: PUSH
83413: LD_INT 3
83415: NEG
83416: PUSH
83417: EMPTY
83418: LIST
83419: LIST
83420: PUSH
83421: LD_INT 1
83423: PUSH
83424: LD_INT 2
83426: NEG
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 2
83434: PUSH
83435: LD_INT 1
83437: NEG
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 3
83445: PUSH
83446: LD_INT 0
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 3
83455: PUSH
83456: LD_INT 1
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 1
83465: PUSH
83466: LD_INT 3
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 0
83475: PUSH
83476: LD_INT 3
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 1
83485: NEG
83486: PUSH
83487: LD_INT 2
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 2
83496: NEG
83497: PUSH
83498: LD_INT 1
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 3
83507: NEG
83508: PUSH
83509: LD_INT 0
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 3
83518: NEG
83519: PUSH
83520: LD_INT 1
83522: NEG
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83559: LD_ADDR_VAR 0 47
83563: PUSH
83564: LD_INT 0
83566: PUSH
83567: LD_INT 0
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 0
83576: PUSH
83577: LD_INT 1
83579: NEG
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: LD_INT 0
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 1
83597: PUSH
83598: LD_INT 1
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: LD_INT 1
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: LD_INT 0
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: NEG
83629: PUSH
83630: LD_INT 1
83632: NEG
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: LD_INT 2
83644: NEG
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: LD_INT 2
83655: NEG
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 1
83663: PUSH
83664: LD_INT 1
83666: NEG
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: LD_INT 2
83674: NEG
83675: PUSH
83676: LD_INT 1
83678: NEG
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 2
83686: NEG
83687: PUSH
83688: LD_INT 2
83690: NEG
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83710: LD_ADDR_VAR 0 48
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: LD_INT 0
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 0
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 1
83738: PUSH
83739: LD_INT 0
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: LD_INT 1
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: LD_INT 0
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 1
83779: NEG
83780: PUSH
83781: LD_INT 1
83783: NEG
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 1
83791: NEG
83792: PUSH
83793: LD_INT 2
83795: NEG
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: LD_INT 0
83803: PUSH
83804: LD_INT 2
83806: NEG
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 1
83814: PUSH
83815: LD_INT 1
83817: NEG
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 2
83825: PUSH
83826: LD_INT 0
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 2
83835: PUSH
83836: LD_INT 1
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83857: LD_ADDR_VAR 0 49
83861: PUSH
83862: LD_INT 0
83864: PUSH
83865: LD_INT 0
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: LD_INT 1
83877: NEG
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 1
83885: PUSH
83886: LD_INT 0
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 1
83895: PUSH
83896: LD_INT 1
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 0
83905: PUSH
83906: LD_INT 1
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 1
83915: NEG
83916: PUSH
83917: LD_INT 0
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 1
83926: NEG
83927: PUSH
83928: LD_INT 1
83930: NEG
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 1
83938: PUSH
83939: LD_INT 1
83941: NEG
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 2
83949: PUSH
83950: LD_INT 0
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 2
83959: PUSH
83960: LD_INT 1
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 2
83969: PUSH
83970: LD_INT 2
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: PUSH
83977: LD_INT 1
83979: PUSH
83980: LD_INT 2
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
84001: LD_ADDR_VAR 0 50
84005: PUSH
84006: LD_INT 0
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 0
84018: PUSH
84019: LD_INT 1
84021: NEG
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 1
84029: PUSH
84030: LD_INT 0
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: LD_INT 1
84039: PUSH
84040: LD_INT 1
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 0
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 1
84059: NEG
84060: PUSH
84061: LD_INT 0
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: LD_INT 1
84074: NEG
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 2
84082: PUSH
84083: LD_INT 1
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 2
84092: PUSH
84093: LD_INT 2
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PUSH
84100: LD_INT 1
84102: PUSH
84103: LD_INT 2
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: LD_INT 2
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: PUSH
84120: LD_INT 1
84122: NEG
84123: PUSH
84124: LD_INT 1
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
84145: LD_ADDR_VAR 0 51
84149: PUSH
84150: LD_INT 0
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: LD_INT 0
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 1
84214: NEG
84215: PUSH
84216: LD_INT 1
84218: NEG
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 1
84226: PUSH
84227: LD_INT 2
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 0
84236: PUSH
84237: LD_INT 2
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 1
84246: NEG
84247: PUSH
84248: LD_INT 1
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 2
84257: NEG
84258: PUSH
84259: LD_INT 0
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 2
84268: NEG
84269: PUSH
84270: LD_INT 1
84272: NEG
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84292: LD_ADDR_VAR 0 52
84296: PUSH
84297: LD_INT 0
84299: PUSH
84300: LD_INT 0
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 0
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 1
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: LD_INT 1
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: LD_INT 0
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 1
84373: NEG
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 1
84385: NEG
84386: PUSH
84387: LD_INT 1
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 2
84396: NEG
84397: PUSH
84398: LD_INT 0
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 2
84407: NEG
84408: PUSH
84409: LD_INT 1
84411: NEG
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 2
84419: NEG
84420: PUSH
84421: LD_INT 2
84423: NEG
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84443: LD_ADDR_VAR 0 53
84447: PUSH
84448: LD_INT 0
84450: PUSH
84451: LD_INT 0
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: LD_INT 0
84460: PUSH
84461: LD_INT 1
84463: NEG
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: LD_INT 0
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 1
84481: PUSH
84482: LD_INT 1
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 0
84491: PUSH
84492: LD_INT 1
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 1
84501: NEG
84502: PUSH
84503: LD_INT 0
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 1
84512: NEG
84513: PUSH
84514: LD_INT 1
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 1
84524: NEG
84525: PUSH
84526: LD_INT 2
84528: NEG
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: LD_INT 2
84539: NEG
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: LD_INT 1
84550: NEG
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 2
84558: PUSH
84559: LD_INT 0
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 2
84568: PUSH
84569: LD_INT 1
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 2
84578: PUSH
84579: LD_INT 2
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 1
84588: PUSH
84589: LD_INT 2
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 0
84598: PUSH
84599: LD_INT 2
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: NEG
84609: PUSH
84610: LD_INT 1
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 2
84619: NEG
84620: PUSH
84621: LD_INT 0
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 2
84630: NEG
84631: PUSH
84632: LD_INT 1
84634: NEG
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 2
84642: NEG
84643: PUSH
84644: LD_INT 2
84646: NEG
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84673: LD_ADDR_VAR 0 54
84677: PUSH
84678: LD_INT 0
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 0
84690: PUSH
84691: LD_INT 1
84693: NEG
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: PUSH
84702: LD_INT 0
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 1
84711: PUSH
84712: LD_INT 1
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 0
84721: PUSH
84722: LD_INT 1
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 1
84731: NEG
84732: PUSH
84733: LD_INT 0
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: NEG
84743: PUSH
84744: LD_INT 1
84746: NEG
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 1
84754: NEG
84755: PUSH
84756: LD_INT 2
84758: NEG
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: PUSH
84764: LD_INT 0
84766: PUSH
84767: LD_INT 2
84769: NEG
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: LD_INT 1
84780: NEG
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 0
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 2
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 2
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 2
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 0
84828: PUSH
84829: LD_INT 2
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: NEG
84839: PUSH
84840: LD_INT 1
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 2
84849: NEG
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 2
84860: NEG
84861: PUSH
84862: LD_INT 1
84864: NEG
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: PUSH
84870: LD_INT 2
84872: NEG
84873: PUSH
84874: LD_INT 2
84876: NEG
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84903: LD_ADDR_VAR 0 55
84907: PUSH
84908: LD_INT 0
84910: PUSH
84911: LD_INT 0
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PUSH
84918: LD_INT 0
84920: PUSH
84921: LD_INT 1
84923: NEG
84924: PUSH
84925: EMPTY
84926: LIST
84927: LIST
84928: PUSH
84929: LD_INT 1
84931: PUSH
84932: LD_INT 0
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: PUSH
84942: LD_INT 1
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 0
84951: PUSH
84952: LD_INT 1
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: LD_INT 1
84961: NEG
84962: PUSH
84963: LD_INT 0
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 1
84972: NEG
84973: PUSH
84974: LD_INT 1
84976: NEG
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 1
84984: NEG
84985: PUSH
84986: LD_INT 2
84988: NEG
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: LD_INT 0
84996: PUSH
84997: LD_INT 2
84999: NEG
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_INT 1
85007: PUSH
85008: LD_INT 1
85010: NEG
85011: PUSH
85012: EMPTY
85013: LIST
85014: LIST
85015: PUSH
85016: LD_INT 2
85018: PUSH
85019: LD_INT 0
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PUSH
85026: LD_INT 2
85028: PUSH
85029: LD_INT 1
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 2
85038: PUSH
85039: LD_INT 2
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 1
85048: PUSH
85049: LD_INT 2
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 0
85058: PUSH
85059: LD_INT 2
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_INT 1
85068: NEG
85069: PUSH
85070: LD_INT 1
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 2
85079: NEG
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 2
85090: NEG
85091: PUSH
85092: LD_INT 1
85094: NEG
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 2
85102: NEG
85103: PUSH
85104: LD_INT 2
85106: NEG
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85133: LD_ADDR_VAR 0 56
85137: PUSH
85138: LD_INT 0
85140: PUSH
85141: LD_INT 0
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: PUSH
85148: LD_INT 0
85150: PUSH
85151: LD_INT 1
85153: NEG
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: LD_INT 0
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: PUSH
85172: LD_INT 1
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 0
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 1
85191: NEG
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 1
85202: NEG
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 1
85214: NEG
85215: PUSH
85216: LD_INT 2
85218: NEG
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: LD_INT 2
85229: NEG
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: LD_INT 1
85240: NEG
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 2
85248: PUSH
85249: LD_INT 0
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 2
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 2
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: PUSH
85279: LD_INT 2
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 0
85288: PUSH
85289: LD_INT 2
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: NEG
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 2
85309: NEG
85310: PUSH
85311: LD_INT 0
85313: PUSH
85314: EMPTY
85315: LIST
85316: LIST
85317: PUSH
85318: LD_INT 2
85320: NEG
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 2
85332: NEG
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85363: LD_ADDR_VAR 0 57
85367: PUSH
85368: LD_INT 0
85370: PUSH
85371: LD_INT 0
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: LD_INT 0
85380: PUSH
85381: LD_INT 1
85383: NEG
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: LD_INT 1
85391: PUSH
85392: LD_INT 0
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 1
85401: PUSH
85402: LD_INT 1
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 0
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: LD_INT 0
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 1
85432: NEG
85433: PUSH
85434: LD_INT 1
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: NEG
85445: PUSH
85446: LD_INT 2
85448: NEG
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 0
85456: PUSH
85457: LD_INT 2
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 1
85467: PUSH
85468: LD_INT 1
85470: NEG
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PUSH
85476: LD_INT 2
85478: PUSH
85479: LD_INT 0
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: LD_INT 1
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 2
85498: PUSH
85499: LD_INT 2
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 1
85508: PUSH
85509: LD_INT 2
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 0
85518: PUSH
85519: LD_INT 2
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 1
85528: NEG
85529: PUSH
85530: LD_INT 1
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 2
85539: NEG
85540: PUSH
85541: LD_INT 0
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 2
85550: NEG
85551: PUSH
85552: LD_INT 1
85554: NEG
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PUSH
85560: LD_INT 2
85562: NEG
85563: PUSH
85564: LD_INT 2
85566: NEG
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85593: LD_ADDR_VAR 0 58
85597: PUSH
85598: LD_INT 0
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 1
85621: PUSH
85622: LD_INT 0
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 1
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 1
85651: NEG
85652: PUSH
85653: LD_INT 0
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: LD_INT 1
85666: NEG
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: LD_INT 2
85678: NEG
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: LD_INT 0
85686: PUSH
85687: LD_INT 2
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 1
85697: PUSH
85698: LD_INT 1
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 2
85708: PUSH
85709: LD_INT 0
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 2
85718: PUSH
85719: LD_INT 1
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 2
85728: PUSH
85729: LD_INT 2
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 0
85748: PUSH
85749: LD_INT 2
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: NEG
85759: PUSH
85760: LD_INT 1
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 2
85769: NEG
85770: PUSH
85771: LD_INT 0
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 2
85780: NEG
85781: PUSH
85782: LD_INT 1
85784: NEG
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 2
85792: NEG
85793: PUSH
85794: LD_INT 2
85796: NEG
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: EMPTY
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85823: LD_ADDR_VAR 0 59
85827: PUSH
85828: LD_INT 0
85830: PUSH
85831: LD_INT 0
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 0
85840: PUSH
85841: LD_INT 1
85843: NEG
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 1
85851: PUSH
85852: LD_INT 0
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: LD_INT 1
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 0
85871: PUSH
85872: LD_INT 1
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 1
85881: NEG
85882: PUSH
85883: LD_INT 0
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 1
85892: NEG
85893: PUSH
85894: LD_INT 1
85896: NEG
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85911: LD_ADDR_VAR 0 60
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: LD_INT 0
85921: PUSH
85922: EMPTY
85923: LIST
85924: LIST
85925: PUSH
85926: LD_INT 0
85928: PUSH
85929: LD_INT 1
85931: NEG
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: LD_INT 0
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: LD_INT 1
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: PUSH
85957: LD_INT 0
85959: PUSH
85960: LD_INT 1
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 1
85969: NEG
85970: PUSH
85971: LD_INT 0
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 1
85980: NEG
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85999: LD_ADDR_VAR 0 61
86003: PUSH
86004: LD_INT 0
86006: PUSH
86007: LD_INT 0
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PUSH
86014: LD_INT 0
86016: PUSH
86017: LD_INT 1
86019: NEG
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 1
86027: PUSH
86028: LD_INT 0
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 1
86037: PUSH
86038: LD_INT 1
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 0
86047: PUSH
86048: LD_INT 1
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 1
86057: NEG
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 1
86068: NEG
86069: PUSH
86070: LD_INT 1
86072: NEG
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86087: LD_ADDR_VAR 0 62
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: LD_INT 0
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: LD_INT 0
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: LD_INT 1
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 0
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 1
86145: NEG
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: LD_INT 1
86160: NEG
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86175: LD_ADDR_VAR 0 63
86179: PUSH
86180: LD_INT 0
86182: PUSH
86183: LD_INT 0
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: LD_INT 1
86195: NEG
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 1
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 1
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 0
86223: PUSH
86224: LD_INT 1
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 1
86233: NEG
86234: PUSH
86235: LD_INT 0
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: LD_INT 1
86248: NEG
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86263: LD_ADDR_VAR 0 64
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: LD_INT 1
86283: NEG
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: LD_INT 0
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 1
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 0
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 1
86321: NEG
86322: PUSH
86323: LD_INT 0
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 1
86332: NEG
86333: PUSH
86334: LD_INT 1
86336: NEG
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: ST_TO_ADDR
// end ; 1 :
86351: GO 92248
86353: LD_INT 1
86355: DOUBLE
86356: EQUAL
86357: IFTRUE 86361
86359: GO 88984
86361: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86362: LD_ADDR_VAR 0 11
86366: PUSH
86367: LD_INT 1
86369: NEG
86370: PUSH
86371: LD_INT 3
86373: NEG
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 0
86381: PUSH
86382: LD_INT 3
86384: NEG
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 1
86392: PUSH
86393: LD_INT 2
86395: NEG
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: LIST
86405: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86406: LD_ADDR_VAR 0 12
86410: PUSH
86411: LD_INT 2
86413: PUSH
86414: LD_INT 1
86416: NEG
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: PUSH
86422: LD_INT 3
86424: PUSH
86425: LD_INT 0
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: LD_INT 3
86434: PUSH
86435: LD_INT 1
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: LIST
86446: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86447: LD_ADDR_VAR 0 13
86451: PUSH
86452: LD_INT 3
86454: PUSH
86455: LD_INT 2
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 3
86464: PUSH
86465: LD_INT 3
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 2
86474: PUSH
86475: LD_INT 3
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: LIST
86486: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86487: LD_ADDR_VAR 0 14
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: LD_INT 3
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: LD_INT 3
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: LD_INT 2
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: LIST
86527: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86528: LD_ADDR_VAR 0 15
86532: PUSH
86533: LD_INT 2
86535: NEG
86536: PUSH
86537: LD_INT 1
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 3
86546: NEG
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 3
86557: NEG
86558: PUSH
86559: LD_INT 1
86561: NEG
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: LIST
86571: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86572: LD_ADDR_VAR 0 16
86576: PUSH
86577: LD_INT 2
86579: NEG
86580: PUSH
86581: LD_INT 3
86583: NEG
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 3
86591: NEG
86592: PUSH
86593: LD_INT 2
86595: NEG
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 3
86603: NEG
86604: PUSH
86605: LD_INT 3
86607: NEG
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: LIST
86617: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86618: LD_ADDR_VAR 0 17
86622: PUSH
86623: LD_INT 1
86625: NEG
86626: PUSH
86627: LD_INT 3
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: LD_INT 3
86640: NEG
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: LD_INT 2
86651: NEG
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: LIST
86661: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86662: LD_ADDR_VAR 0 18
86666: PUSH
86667: LD_INT 2
86669: PUSH
86670: LD_INT 1
86672: NEG
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 3
86680: PUSH
86681: LD_INT 0
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 3
86690: PUSH
86691: LD_INT 1
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: LIST
86702: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86703: LD_ADDR_VAR 0 19
86707: PUSH
86708: LD_INT 3
86710: PUSH
86711: LD_INT 2
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 3
86720: PUSH
86721: LD_INT 3
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 2
86730: PUSH
86731: LD_INT 3
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: LIST
86742: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86743: LD_ADDR_VAR 0 20
86747: PUSH
86748: LD_INT 1
86750: PUSH
86751: LD_INT 3
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 0
86760: PUSH
86761: LD_INT 3
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 1
86770: NEG
86771: PUSH
86772: LD_INT 2
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: LIST
86783: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86784: LD_ADDR_VAR 0 21
86788: PUSH
86789: LD_INT 2
86791: NEG
86792: PUSH
86793: LD_INT 1
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 3
86802: NEG
86803: PUSH
86804: LD_INT 0
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 3
86813: NEG
86814: PUSH
86815: LD_INT 1
86817: NEG
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: LIST
86827: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86828: LD_ADDR_VAR 0 22
86832: PUSH
86833: LD_INT 2
86835: NEG
86836: PUSH
86837: LD_INT 3
86839: NEG
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 3
86847: NEG
86848: PUSH
86849: LD_INT 2
86851: NEG
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 3
86859: NEG
86860: PUSH
86861: LD_INT 3
86863: NEG
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: LIST
86873: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
86874: LD_ADDR_VAR 0 23
86878: PUSH
86879: LD_INT 0
86881: PUSH
86882: LD_INT 3
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 1
86892: NEG
86893: PUSH
86894: LD_INT 4
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 1
86904: PUSH
86905: LD_INT 3
86907: NEG
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: LIST
86917: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
86918: LD_ADDR_VAR 0 24
86922: PUSH
86923: LD_INT 3
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 3
86935: PUSH
86936: LD_INT 1
86938: NEG
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 4
86946: PUSH
86947: LD_INT 1
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: LIST
86958: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
86959: LD_ADDR_VAR 0 25
86963: PUSH
86964: LD_INT 3
86966: PUSH
86967: LD_INT 3
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 4
86976: PUSH
86977: LD_INT 3
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 3
86986: PUSH
86987: LD_INT 4
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: LIST
86998: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
86999: LD_ADDR_VAR 0 26
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: LD_INT 3
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 1
87016: PUSH
87017: LD_INT 4
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 1
87026: NEG
87027: PUSH
87028: LD_INT 3
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: LIST
87039: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
87040: LD_ADDR_VAR 0 27
87044: PUSH
87045: LD_INT 3
87047: NEG
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 3
87058: NEG
87059: PUSH
87060: LD_INT 1
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 4
87069: NEG
87070: PUSH
87071: LD_INT 1
87073: NEG
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: LIST
87083: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
87084: LD_ADDR_VAR 0 28
87088: PUSH
87089: LD_INT 3
87091: NEG
87092: PUSH
87093: LD_INT 3
87095: NEG
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 3
87103: NEG
87104: PUSH
87105: LD_INT 4
87107: NEG
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 4
87115: NEG
87116: PUSH
87117: LD_INT 3
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: LIST
87129: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
87130: LD_ADDR_VAR 0 29
87134: PUSH
87135: LD_INT 1
87137: NEG
87138: PUSH
87139: LD_INT 3
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 0
87149: PUSH
87150: LD_INT 3
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 1
87160: PUSH
87161: LD_INT 2
87163: NEG
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: LD_INT 4
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 0
87183: PUSH
87184: LD_INT 4
87186: NEG
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: PUSH
87195: LD_INT 3
87197: NEG
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 1
87205: NEG
87206: PUSH
87207: LD_INT 5
87209: NEG
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 0
87217: PUSH
87218: LD_INT 5
87220: NEG
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 1
87228: PUSH
87229: LD_INT 4
87231: NEG
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 1
87239: NEG
87240: PUSH
87241: LD_INT 6
87243: NEG
87244: PUSH
87245: EMPTY
87246: LIST
87247: LIST
87248: PUSH
87249: LD_INT 0
87251: PUSH
87252: LD_INT 6
87254: NEG
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: PUSH
87260: LD_INT 1
87262: PUSH
87263: LD_INT 5
87265: NEG
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
87285: LD_ADDR_VAR 0 30
87289: PUSH
87290: LD_INT 2
87292: PUSH
87293: LD_INT 1
87295: NEG
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 3
87303: PUSH
87304: LD_INT 0
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 3
87313: PUSH
87314: LD_INT 1
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 3
87323: PUSH
87324: LD_INT 1
87326: NEG
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 4
87334: PUSH
87335: LD_INT 0
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 4
87344: PUSH
87345: LD_INT 1
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 4
87354: PUSH
87355: LD_INT 1
87357: NEG
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 5
87365: PUSH
87366: LD_INT 0
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 5
87375: PUSH
87376: LD_INT 1
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 5
87385: PUSH
87386: LD_INT 1
87388: NEG
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 6
87396: PUSH
87397: LD_INT 0
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: PUSH
87404: LD_INT 6
87406: PUSH
87407: LD_INT 1
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
87428: LD_ADDR_VAR 0 31
87432: PUSH
87433: LD_INT 3
87435: PUSH
87436: LD_INT 2
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: LD_INT 3
87445: PUSH
87446: LD_INT 3
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 2
87455: PUSH
87456: LD_INT 3
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: PUSH
87463: LD_INT 4
87465: PUSH
87466: LD_INT 3
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 4
87475: PUSH
87476: LD_INT 4
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 3
87485: PUSH
87486: LD_INT 4
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 5
87495: PUSH
87496: LD_INT 4
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 5
87505: PUSH
87506: LD_INT 5
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 4
87515: PUSH
87516: LD_INT 5
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 6
87525: PUSH
87526: LD_INT 5
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 6
87535: PUSH
87536: LD_INT 6
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: PUSH
87543: LD_INT 5
87545: PUSH
87546: LD_INT 6
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
87567: LD_ADDR_VAR 0 32
87571: PUSH
87572: LD_INT 1
87574: PUSH
87575: LD_INT 3
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 0
87584: PUSH
87585: LD_INT 3
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 1
87594: NEG
87595: PUSH
87596: LD_INT 2
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 1
87605: PUSH
87606: LD_INT 4
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 0
87615: PUSH
87616: LD_INT 4
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 1
87625: NEG
87626: PUSH
87627: LD_INT 3
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 1
87636: PUSH
87637: LD_INT 5
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 0
87646: PUSH
87647: LD_INT 5
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 1
87656: NEG
87657: PUSH
87658: LD_INT 4
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PUSH
87665: LD_INT 1
87667: PUSH
87668: LD_INT 6
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 0
87677: PUSH
87678: LD_INT 6
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: LD_INT 1
87687: NEG
87688: PUSH
87689: LD_INT 5
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
87710: LD_ADDR_VAR 0 33
87714: PUSH
87715: LD_INT 2
87717: NEG
87718: PUSH
87719: LD_INT 1
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 3
87728: NEG
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 3
87739: NEG
87740: PUSH
87741: LD_INT 1
87743: NEG
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 3
87751: NEG
87752: PUSH
87753: LD_INT 1
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 4
87762: NEG
87763: PUSH
87764: LD_INT 0
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 4
87773: NEG
87774: PUSH
87775: LD_INT 1
87777: NEG
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 4
87785: NEG
87786: PUSH
87787: LD_INT 1
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 5
87796: NEG
87797: PUSH
87798: LD_INT 0
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 5
87807: NEG
87808: PUSH
87809: LD_INT 1
87811: NEG
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 5
87819: NEG
87820: PUSH
87821: LD_INT 1
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 6
87830: NEG
87831: PUSH
87832: LD_INT 0
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 6
87841: NEG
87842: PUSH
87843: LD_INT 1
87845: NEG
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
87865: LD_ADDR_VAR 0 34
87869: PUSH
87870: LD_INT 2
87872: NEG
87873: PUSH
87874: LD_INT 3
87876: NEG
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 3
87884: NEG
87885: PUSH
87886: LD_INT 2
87888: NEG
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 3
87896: NEG
87897: PUSH
87898: LD_INT 3
87900: NEG
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 3
87908: NEG
87909: PUSH
87910: LD_INT 4
87912: NEG
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 4
87920: NEG
87921: PUSH
87922: LD_INT 3
87924: NEG
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 4
87932: NEG
87933: PUSH
87934: LD_INT 4
87936: NEG
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 4
87944: NEG
87945: PUSH
87946: LD_INT 5
87948: NEG
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 5
87956: NEG
87957: PUSH
87958: LD_INT 4
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 5
87968: NEG
87969: PUSH
87970: LD_INT 5
87972: NEG
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 5
87980: NEG
87981: PUSH
87982: LD_INT 6
87984: NEG
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PUSH
87990: LD_INT 6
87992: NEG
87993: PUSH
87994: LD_INT 5
87996: NEG
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 6
88004: NEG
88005: PUSH
88006: LD_INT 6
88008: NEG
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
88028: LD_ADDR_VAR 0 41
88032: PUSH
88033: LD_INT 0
88035: PUSH
88036: LD_INT 2
88038: NEG
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 1
88046: NEG
88047: PUSH
88048: LD_INT 3
88050: NEG
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 1
88058: PUSH
88059: LD_INT 2
88061: NEG
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: EMPTY
88068: LIST
88069: LIST
88070: LIST
88071: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
88072: LD_ADDR_VAR 0 42
88076: PUSH
88077: LD_INT 2
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 2
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 3
88100: PUSH
88101: LD_INT 1
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: LIST
88112: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
88113: LD_ADDR_VAR 0 43
88117: PUSH
88118: LD_INT 2
88120: PUSH
88121: LD_INT 2
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 3
88130: PUSH
88131: LD_INT 2
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 2
88140: PUSH
88141: LD_INT 3
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: LIST
88152: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
88153: LD_ADDR_VAR 0 44
88157: PUSH
88158: LD_INT 0
88160: PUSH
88161: LD_INT 2
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 1
88170: PUSH
88171: LD_INT 3
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 1
88180: NEG
88181: PUSH
88182: LD_INT 2
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: LIST
88193: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88194: LD_ADDR_VAR 0 45
88198: PUSH
88199: LD_INT 2
88201: NEG
88202: PUSH
88203: LD_INT 0
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: LD_INT 1
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 3
88223: NEG
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: LIST
88237: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
88238: LD_ADDR_VAR 0 46
88242: PUSH
88243: LD_INT 2
88245: NEG
88246: PUSH
88247: LD_INT 2
88249: NEG
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 2
88257: NEG
88258: PUSH
88259: LD_INT 3
88261: NEG
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 3
88269: NEG
88270: PUSH
88271: LD_INT 2
88273: NEG
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: LIST
88283: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
88284: LD_ADDR_VAR 0 47
88288: PUSH
88289: LD_INT 2
88291: NEG
88292: PUSH
88293: LD_INT 3
88295: NEG
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 1
88303: NEG
88304: PUSH
88305: LD_INT 3
88307: NEG
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88317: LD_ADDR_VAR 0 48
88321: PUSH
88322: LD_INT 1
88324: PUSH
88325: LD_INT 2
88327: NEG
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 2
88335: PUSH
88336: LD_INT 1
88338: NEG
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
88348: LD_ADDR_VAR 0 49
88352: PUSH
88353: LD_INT 3
88355: PUSH
88356: LD_INT 1
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 3
88365: PUSH
88366: LD_INT 2
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
88377: LD_ADDR_VAR 0 50
88381: PUSH
88382: LD_INT 2
88384: PUSH
88385: LD_INT 3
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: PUSH
88392: LD_INT 1
88394: PUSH
88395: LD_INT 3
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88406: LD_ADDR_VAR 0 51
88410: PUSH
88411: LD_INT 1
88413: NEG
88414: PUSH
88415: LD_INT 2
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: PUSH
88422: LD_INT 2
88424: NEG
88425: PUSH
88426: LD_INT 1
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88437: LD_ADDR_VAR 0 52
88441: PUSH
88442: LD_INT 3
88444: NEG
88445: PUSH
88446: LD_INT 1
88448: NEG
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 3
88456: NEG
88457: PUSH
88458: LD_INT 2
88460: NEG
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88470: LD_ADDR_VAR 0 53
88474: PUSH
88475: LD_INT 1
88477: NEG
88478: PUSH
88479: LD_INT 3
88481: NEG
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 0
88489: PUSH
88490: LD_INT 3
88492: NEG
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 1
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: EMPTY
88510: LIST
88511: LIST
88512: LIST
88513: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88514: LD_ADDR_VAR 0 54
88518: PUSH
88519: LD_INT 2
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 3
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 3
88542: PUSH
88543: LD_INT 1
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: LIST
88554: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88555: LD_ADDR_VAR 0 55
88559: PUSH
88560: LD_INT 3
88562: PUSH
88563: LD_INT 2
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 3
88572: PUSH
88573: LD_INT 3
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 2
88582: PUSH
88583: LD_INT 3
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: EMPTY
88591: LIST
88592: LIST
88593: LIST
88594: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88595: LD_ADDR_VAR 0 56
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: LD_INT 3
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 0
88612: PUSH
88613: LD_INT 3
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 1
88622: NEG
88623: PUSH
88624: LD_INT 2
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: LIST
88635: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88636: LD_ADDR_VAR 0 57
88640: PUSH
88641: LD_INT 2
88643: NEG
88644: PUSH
88645: LD_INT 1
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 3
88654: NEG
88655: PUSH
88656: LD_INT 0
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 3
88665: NEG
88666: PUSH
88667: LD_INT 1
88669: NEG
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: LIST
88679: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88680: LD_ADDR_VAR 0 58
88684: PUSH
88685: LD_INT 2
88687: NEG
88688: PUSH
88689: LD_INT 3
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 3
88699: NEG
88700: PUSH
88701: LD_INT 2
88703: NEG
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 3
88711: NEG
88712: PUSH
88713: LD_INT 3
88715: NEG
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: LIST
88725: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
88726: LD_ADDR_VAR 0 59
88730: PUSH
88731: LD_INT 1
88733: NEG
88734: PUSH
88735: LD_INT 2
88737: NEG
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 0
88745: PUSH
88746: LD_INT 2
88748: NEG
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 1
88756: PUSH
88757: LD_INT 1
88759: NEG
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: LIST
88769: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88770: LD_ADDR_VAR 0 60
88774: PUSH
88775: LD_INT 1
88777: PUSH
88778: LD_INT 1
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 2
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 2
88798: PUSH
88799: LD_INT 1
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: LIST
88810: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88811: LD_ADDR_VAR 0 61
88815: PUSH
88816: LD_INT 2
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 2
88828: PUSH
88829: LD_INT 2
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: LD_INT 1
88838: PUSH
88839: LD_INT 2
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: LIST
88850: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88851: LD_ADDR_VAR 0 62
88855: PUSH
88856: LD_INT 1
88858: PUSH
88859: LD_INT 2
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: PUSH
88866: LD_INT 0
88868: PUSH
88869: LD_INT 2
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: LD_INT 1
88878: NEG
88879: PUSH
88880: LD_INT 1
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: LIST
88891: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88892: LD_ADDR_VAR 0 63
88896: PUSH
88897: LD_INT 1
88899: NEG
88900: PUSH
88901: LD_INT 1
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 2
88910: NEG
88911: PUSH
88912: LD_INT 0
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 2
88921: NEG
88922: PUSH
88923: LD_INT 1
88925: NEG
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: LIST
88935: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88936: LD_ADDR_VAR 0 64
88940: PUSH
88941: LD_INT 1
88943: NEG
88944: PUSH
88945: LD_INT 2
88947: NEG
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: LD_INT 2
88955: NEG
88956: PUSH
88957: LD_INT 1
88959: NEG
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: PUSH
88965: LD_INT 2
88967: NEG
88968: PUSH
88969: LD_INT 2
88971: NEG
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: LIST
88981: ST_TO_ADDR
// end ; 2 :
88982: GO 92248
88984: LD_INT 2
88986: DOUBLE
88987: EQUAL
88988: IFTRUE 88992
88990: GO 92247
88992: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
88993: LD_ADDR_VAR 0 29
88997: PUSH
88998: LD_INT 4
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 4
89010: PUSH
89011: LD_INT 1
89013: NEG
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 5
89021: PUSH
89022: LD_INT 0
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 5
89031: PUSH
89032: LD_INT 1
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 4
89041: PUSH
89042: LD_INT 1
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 3
89051: PUSH
89052: LD_INT 0
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PUSH
89059: LD_INT 3
89061: PUSH
89062: LD_INT 1
89064: NEG
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: PUSH
89070: LD_INT 3
89072: PUSH
89073: LD_INT 2
89075: NEG
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 5
89083: PUSH
89084: LD_INT 2
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 3
89093: PUSH
89094: LD_INT 3
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 3
89103: PUSH
89104: LD_INT 2
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 4
89113: PUSH
89114: LD_INT 3
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 4
89123: PUSH
89124: LD_INT 4
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 3
89133: PUSH
89134: LD_INT 4
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: LD_INT 3
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 2
89153: PUSH
89154: LD_INT 2
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 4
89163: PUSH
89164: LD_INT 2
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 2
89173: PUSH
89174: LD_INT 4
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: PUSH
89181: LD_INT 0
89183: PUSH
89184: LD_INT 4
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: LD_INT 0
89193: PUSH
89194: LD_INT 3
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 1
89203: PUSH
89204: LD_INT 4
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: PUSH
89214: LD_INT 5
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: LD_INT 5
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 1
89233: NEG
89234: PUSH
89235: LD_INT 4
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 1
89244: NEG
89245: PUSH
89246: LD_INT 3
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 2
89255: PUSH
89256: LD_INT 5
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 2
89265: NEG
89266: PUSH
89267: LD_INT 3
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 3
89276: NEG
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 3
89287: NEG
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 2
89299: NEG
89300: PUSH
89301: LD_INT 0
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: LD_INT 2
89310: NEG
89311: PUSH
89312: LD_INT 1
89314: PUSH
89315: EMPTY
89316: LIST
89317: LIST
89318: PUSH
89319: LD_INT 3
89321: NEG
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 4
89332: NEG
89333: PUSH
89334: LD_INT 0
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 4
89343: NEG
89344: PUSH
89345: LD_INT 1
89347: NEG
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 4
89355: NEG
89356: PUSH
89357: LD_INT 2
89359: NEG
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 2
89367: NEG
89368: PUSH
89369: LD_INT 2
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 4
89378: NEG
89379: PUSH
89380: LD_INT 4
89382: NEG
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 4
89390: NEG
89391: PUSH
89392: LD_INT 5
89394: NEG
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: LD_INT 3
89402: NEG
89403: PUSH
89404: LD_INT 4
89406: NEG
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: PUSH
89412: LD_INT 3
89414: NEG
89415: PUSH
89416: LD_INT 3
89418: NEG
89419: PUSH
89420: EMPTY
89421: LIST
89422: LIST
89423: PUSH
89424: LD_INT 4
89426: NEG
89427: PUSH
89428: LD_INT 3
89430: NEG
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 5
89438: NEG
89439: PUSH
89440: LD_INT 4
89442: NEG
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 5
89450: NEG
89451: PUSH
89452: LD_INT 5
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 3
89462: NEG
89463: PUSH
89464: LD_INT 5
89466: NEG
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: LD_INT 5
89474: NEG
89475: PUSH
89476: LD_INT 3
89478: NEG
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
89531: LD_ADDR_VAR 0 30
89535: PUSH
89536: LD_INT 4
89538: PUSH
89539: LD_INT 4
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PUSH
89546: LD_INT 4
89548: PUSH
89549: LD_INT 3
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: PUSH
89556: LD_INT 5
89558: PUSH
89559: LD_INT 4
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PUSH
89566: LD_INT 5
89568: PUSH
89569: LD_INT 5
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 4
89578: PUSH
89579: LD_INT 5
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 3
89588: PUSH
89589: LD_INT 4
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 3
89598: PUSH
89599: LD_INT 3
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 5
89608: PUSH
89609: LD_INT 3
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 3
89618: PUSH
89619: LD_INT 5
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: LD_INT 3
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: LD_INT 0
89638: PUSH
89639: LD_INT 2
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: PUSH
89649: LD_INT 3
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 1
89658: PUSH
89659: LD_INT 4
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: LD_INT 4
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: NEG
89679: PUSH
89680: LD_INT 3
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 1
89689: NEG
89690: PUSH
89691: LD_INT 2
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: PUSH
89701: LD_INT 4
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 2
89710: NEG
89711: PUSH
89712: LD_INT 2
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 4
89721: NEG
89722: PUSH
89723: LD_INT 0
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 4
89732: NEG
89733: PUSH
89734: LD_INT 1
89736: NEG
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 3
89744: NEG
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 3
89755: NEG
89756: PUSH
89757: LD_INT 1
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 4
89766: NEG
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 5
89777: NEG
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: LD_INT 5
89788: NEG
89789: PUSH
89790: LD_INT 1
89792: NEG
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 5
89800: NEG
89801: PUSH
89802: LD_INT 2
89804: NEG
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 3
89812: NEG
89813: PUSH
89814: LD_INT 2
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 3
89823: NEG
89824: PUSH
89825: LD_INT 3
89827: NEG
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 3
89835: NEG
89836: PUSH
89837: LD_INT 4
89839: NEG
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 2
89847: NEG
89848: PUSH
89849: LD_INT 3
89851: NEG
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 2
89859: NEG
89860: PUSH
89861: LD_INT 2
89863: NEG
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 3
89871: NEG
89872: PUSH
89873: LD_INT 2
89875: NEG
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PUSH
89881: LD_INT 4
89883: NEG
89884: PUSH
89885: LD_INT 3
89887: NEG
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 4
89895: NEG
89896: PUSH
89897: LD_INT 4
89899: NEG
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PUSH
89905: LD_INT 2
89907: NEG
89908: PUSH
89909: LD_INT 4
89911: NEG
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 4
89919: NEG
89920: PUSH
89921: LD_INT 2
89923: NEG
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 0
89931: PUSH
89932: LD_INT 4
89934: NEG
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 0
89942: PUSH
89943: LD_INT 5
89945: NEG
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 1
89953: PUSH
89954: LD_INT 4
89956: NEG
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 1
89964: PUSH
89965: LD_INT 3
89967: NEG
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 0
89975: PUSH
89976: LD_INT 3
89978: NEG
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: LD_INT 4
89990: NEG
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 1
89998: NEG
89999: PUSH
90000: LD_INT 5
90002: NEG
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 2
90010: PUSH
90011: LD_INT 3
90013: NEG
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: LD_INT 2
90021: NEG
90022: PUSH
90023: LD_INT 5
90025: NEG
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
90078: LD_ADDR_VAR 0 31
90082: PUSH
90083: LD_INT 0
90085: PUSH
90086: LD_INT 4
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 0
90095: PUSH
90096: LD_INT 3
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: PUSH
90103: LD_INT 1
90105: PUSH
90106: LD_INT 4
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 1
90115: PUSH
90116: LD_INT 5
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: LD_INT 0
90125: PUSH
90126: LD_INT 5
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: NEG
90136: PUSH
90137: LD_INT 4
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 1
90146: NEG
90147: PUSH
90148: LD_INT 3
90150: PUSH
90151: EMPTY
90152: LIST
90153: LIST
90154: PUSH
90155: LD_INT 2
90157: PUSH
90158: LD_INT 5
90160: PUSH
90161: EMPTY
90162: LIST
90163: LIST
90164: PUSH
90165: LD_INT 2
90167: NEG
90168: PUSH
90169: LD_INT 3
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 3
90178: NEG
90179: PUSH
90180: LD_INT 0
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: PUSH
90187: LD_INT 3
90189: NEG
90190: PUSH
90191: LD_INT 1
90193: NEG
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 2
90201: NEG
90202: PUSH
90203: LD_INT 0
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 2
90212: NEG
90213: PUSH
90214: LD_INT 1
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: LD_INT 3
90223: NEG
90224: PUSH
90225: LD_INT 1
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: LD_INT 4
90234: NEG
90235: PUSH
90236: LD_INT 0
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 4
90245: NEG
90246: PUSH
90247: LD_INT 1
90249: NEG
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 4
90257: NEG
90258: PUSH
90259: LD_INT 2
90261: NEG
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 2
90269: NEG
90270: PUSH
90271: LD_INT 2
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 4
90280: NEG
90281: PUSH
90282: LD_INT 4
90284: NEG
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 4
90292: NEG
90293: PUSH
90294: LD_INT 5
90296: NEG
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 3
90304: NEG
90305: PUSH
90306: LD_INT 4
90308: NEG
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 3
90316: NEG
90317: PUSH
90318: LD_INT 3
90320: NEG
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 4
90328: NEG
90329: PUSH
90330: LD_INT 3
90332: NEG
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 5
90340: NEG
90341: PUSH
90342: LD_INT 4
90344: NEG
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 5
90352: NEG
90353: PUSH
90354: LD_INT 5
90356: NEG
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 3
90364: NEG
90365: PUSH
90366: LD_INT 5
90368: NEG
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 5
90376: NEG
90377: PUSH
90378: LD_INT 3
90380: NEG
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: LD_INT 3
90391: NEG
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 0
90399: PUSH
90400: LD_INT 4
90402: NEG
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: LD_INT 3
90413: NEG
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 1
90421: PUSH
90422: LD_INT 2
90424: NEG
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 0
90432: PUSH
90433: LD_INT 2
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 1
90443: NEG
90444: PUSH
90445: LD_INT 3
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 1
90455: NEG
90456: PUSH
90457: LD_INT 4
90459: NEG
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: LD_INT 2
90467: PUSH
90468: LD_INT 2
90470: NEG
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 2
90478: NEG
90479: PUSH
90480: LD_INT 4
90482: NEG
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: PUSH
90488: LD_INT 4
90490: PUSH
90491: LD_INT 0
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 4
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 5
90511: PUSH
90512: LD_INT 0
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 5
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 4
90531: PUSH
90532: LD_INT 1
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 3
90541: PUSH
90542: LD_INT 0
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 3
90551: PUSH
90552: LD_INT 1
90554: NEG
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 3
90562: PUSH
90563: LD_INT 2
90565: NEG
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 5
90573: PUSH
90574: LD_INT 2
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
90628: LD_ADDR_VAR 0 32
90632: PUSH
90633: LD_INT 4
90635: NEG
90636: PUSH
90637: LD_INT 0
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 4
90646: NEG
90647: PUSH
90648: LD_INT 1
90650: NEG
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 3
90658: NEG
90659: PUSH
90660: LD_INT 0
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 3
90669: NEG
90670: PUSH
90671: LD_INT 1
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: PUSH
90678: LD_INT 4
90680: NEG
90681: PUSH
90682: LD_INT 1
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: LD_INT 5
90691: NEG
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 5
90702: NEG
90703: PUSH
90704: LD_INT 1
90706: NEG
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PUSH
90712: LD_INT 5
90714: NEG
90715: PUSH
90716: LD_INT 2
90718: NEG
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 3
90726: NEG
90727: PUSH
90728: LD_INT 2
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 3
90737: NEG
90738: PUSH
90739: LD_INT 3
90741: NEG
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: LD_INT 3
90749: NEG
90750: PUSH
90751: LD_INT 4
90753: NEG
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 2
90761: NEG
90762: PUSH
90763: LD_INT 3
90765: NEG
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: LD_INT 2
90777: NEG
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: PUSH
90783: LD_INT 3
90785: NEG
90786: PUSH
90787: LD_INT 2
90789: NEG
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 4
90797: NEG
90798: PUSH
90799: LD_INT 3
90801: NEG
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 4
90809: NEG
90810: PUSH
90811: LD_INT 4
90813: NEG
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 2
90821: NEG
90822: PUSH
90823: LD_INT 4
90825: NEG
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 4
90833: NEG
90834: PUSH
90835: LD_INT 2
90837: NEG
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: PUSH
90843: LD_INT 0
90845: PUSH
90846: LD_INT 4
90848: NEG
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 0
90856: PUSH
90857: LD_INT 5
90859: NEG
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 1
90867: PUSH
90868: LD_INT 4
90870: NEG
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: LD_INT 1
90878: PUSH
90879: LD_INT 3
90881: NEG
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: PUSH
90887: LD_INT 0
90889: PUSH
90890: LD_INT 3
90892: NEG
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 1
90900: NEG
90901: PUSH
90902: LD_INT 4
90904: NEG
90905: PUSH
90906: EMPTY
90907: LIST
90908: LIST
90909: PUSH
90910: LD_INT 1
90912: NEG
90913: PUSH
90914: LD_INT 5
90916: NEG
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: LD_INT 2
90924: PUSH
90925: LD_INT 3
90927: NEG
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 2
90935: NEG
90936: PUSH
90937: LD_INT 5
90939: NEG
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 3
90947: PUSH
90948: LD_INT 0
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 3
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 4
90968: PUSH
90969: LD_INT 0
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 4
90978: PUSH
90979: LD_INT 1
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: PUSH
90986: LD_INT 3
90988: PUSH
90989: LD_INT 1
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 2
90998: PUSH
90999: LD_INT 0
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 2
91008: PUSH
91009: LD_INT 1
91011: NEG
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 2
91019: PUSH
91020: LD_INT 2
91022: NEG
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 4
91030: PUSH
91031: LD_INT 2
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 4
91040: PUSH
91041: LD_INT 4
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 4
91050: PUSH
91051: LD_INT 3
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 5
91060: PUSH
91061: LD_INT 4
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 5
91070: PUSH
91071: LD_INT 5
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 4
91080: PUSH
91081: LD_INT 5
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 3
91090: PUSH
91091: LD_INT 4
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: LD_INT 3
91100: PUSH
91101: LD_INT 3
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 5
91110: PUSH
91111: LD_INT 3
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 3
91120: PUSH
91121: LD_INT 5
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
91175: LD_ADDR_VAR 0 33
91179: PUSH
91180: LD_INT 4
91182: NEG
91183: PUSH
91184: LD_INT 4
91186: NEG
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 4
91194: NEG
91195: PUSH
91196: LD_INT 5
91198: NEG
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 3
91206: NEG
91207: PUSH
91208: LD_INT 4
91210: NEG
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 3
91218: NEG
91219: PUSH
91220: LD_INT 3
91222: NEG
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 4
91230: NEG
91231: PUSH
91232: LD_INT 3
91234: NEG
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 5
91242: NEG
91243: PUSH
91244: LD_INT 4
91246: NEG
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: LD_INT 5
91254: NEG
91255: PUSH
91256: LD_INT 5
91258: NEG
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 3
91266: NEG
91267: PUSH
91268: LD_INT 5
91270: NEG
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: PUSH
91276: LD_INT 5
91278: NEG
91279: PUSH
91280: LD_INT 3
91282: NEG
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 0
91290: PUSH
91291: LD_INT 3
91293: NEG
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 0
91301: PUSH
91302: LD_INT 4
91304: NEG
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 1
91312: PUSH
91313: LD_INT 3
91315: NEG
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: PUSH
91324: LD_INT 2
91326: NEG
91327: PUSH
91328: EMPTY
91329: LIST
91330: LIST
91331: PUSH
91332: LD_INT 0
91334: PUSH
91335: LD_INT 2
91337: NEG
91338: PUSH
91339: EMPTY
91340: LIST
91341: LIST
91342: PUSH
91343: LD_INT 1
91345: NEG
91346: PUSH
91347: LD_INT 3
91349: NEG
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 1
91357: NEG
91358: PUSH
91359: LD_INT 4
91361: NEG
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 2
91369: PUSH
91370: LD_INT 2
91372: NEG
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 2
91380: NEG
91381: PUSH
91382: LD_INT 4
91384: NEG
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 4
91392: PUSH
91393: LD_INT 0
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: LD_INT 4
91402: PUSH
91403: LD_INT 1
91405: NEG
91406: PUSH
91407: EMPTY
91408: LIST
91409: LIST
91410: PUSH
91411: LD_INT 5
91413: PUSH
91414: LD_INT 0
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 5
91423: PUSH
91424: LD_INT 1
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: PUSH
91431: LD_INT 4
91433: PUSH
91434: LD_INT 1
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 3
91443: PUSH
91444: LD_INT 0
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 3
91453: PUSH
91454: LD_INT 1
91456: NEG
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 3
91464: PUSH
91465: LD_INT 2
91467: NEG
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: PUSH
91473: LD_INT 5
91475: PUSH
91476: LD_INT 2
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 3
91485: PUSH
91486: LD_INT 3
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 3
91495: PUSH
91496: LD_INT 2
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 4
91505: PUSH
91506: LD_INT 3
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 4
91515: PUSH
91516: LD_INT 4
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 3
91525: PUSH
91526: LD_INT 4
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 2
91535: PUSH
91536: LD_INT 3
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 2
91545: PUSH
91546: LD_INT 2
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 4
91555: PUSH
91556: LD_INT 2
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: PUSH
91563: LD_INT 2
91565: PUSH
91566: LD_INT 4
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 0
91575: PUSH
91576: LD_INT 4
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 0
91585: PUSH
91586: LD_INT 3
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: PUSH
91596: LD_INT 4
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: LD_INT 1
91605: PUSH
91606: LD_INT 5
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 0
91615: PUSH
91616: LD_INT 5
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 1
91625: NEG
91626: PUSH
91627: LD_INT 4
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 1
91636: NEG
91637: PUSH
91638: LD_INT 3
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 2
91647: PUSH
91648: LD_INT 5
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: LD_INT 2
91657: NEG
91658: PUSH
91659: LD_INT 3
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
91713: LD_ADDR_VAR 0 34
91717: PUSH
91718: LD_INT 0
91720: PUSH
91721: LD_INT 4
91723: NEG
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 0
91731: PUSH
91732: LD_INT 5
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 1
91742: PUSH
91743: LD_INT 4
91745: NEG
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: LD_INT 3
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 0
91764: PUSH
91765: LD_INT 3
91767: NEG
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: LD_INT 4
91779: NEG
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 1
91787: NEG
91788: PUSH
91789: LD_INT 5
91791: NEG
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 2
91799: PUSH
91800: LD_INT 3
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 2
91810: NEG
91811: PUSH
91812: LD_INT 5
91814: NEG
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 3
91822: PUSH
91823: LD_INT 0
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 3
91832: PUSH
91833: LD_INT 1
91835: NEG
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PUSH
91841: LD_INT 4
91843: PUSH
91844: LD_INT 0
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: LD_INT 4
91853: PUSH
91854: LD_INT 1
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 3
91863: PUSH
91864: LD_INT 1
91866: PUSH
91867: EMPTY
91868: LIST
91869: LIST
91870: PUSH
91871: LD_INT 2
91873: PUSH
91874: LD_INT 0
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: PUSH
91881: LD_INT 2
91883: PUSH
91884: LD_INT 1
91886: NEG
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 2
91894: PUSH
91895: LD_INT 2
91897: NEG
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 4
91905: PUSH
91906: LD_INT 2
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 4
91915: PUSH
91916: LD_INT 4
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 4
91925: PUSH
91926: LD_INT 3
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 5
91935: PUSH
91936: LD_INT 4
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 5
91945: PUSH
91946: LD_INT 5
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 4
91955: PUSH
91956: LD_INT 5
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 3
91965: PUSH
91966: LD_INT 4
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: PUSH
91976: LD_INT 3
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 5
91985: PUSH
91986: LD_INT 3
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 3
91995: PUSH
91996: LD_INT 5
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: LD_INT 3
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: LD_INT 2
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 1
92025: PUSH
92026: LD_INT 3
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 1
92035: PUSH
92036: LD_INT 4
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 0
92045: PUSH
92046: LD_INT 4
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 1
92055: NEG
92056: PUSH
92057: LD_INT 3
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 1
92066: NEG
92067: PUSH
92068: LD_INT 2
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 2
92077: PUSH
92078: LD_INT 4
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 2
92087: NEG
92088: PUSH
92089: LD_INT 2
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 4
92098: NEG
92099: PUSH
92100: LD_INT 0
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 4
92109: NEG
92110: PUSH
92111: LD_INT 1
92113: NEG
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 3
92121: NEG
92122: PUSH
92123: LD_INT 0
92125: PUSH
92126: EMPTY
92127: LIST
92128: LIST
92129: PUSH
92130: LD_INT 3
92132: NEG
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PUSH
92141: LD_INT 4
92143: NEG
92144: PUSH
92145: LD_INT 1
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: PUSH
92152: LD_INT 5
92154: NEG
92155: PUSH
92156: LD_INT 0
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: PUSH
92163: LD_INT 5
92165: NEG
92166: PUSH
92167: LD_INT 1
92169: NEG
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 5
92177: NEG
92178: PUSH
92179: LD_INT 2
92181: NEG
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 3
92189: NEG
92190: PUSH
92191: LD_INT 2
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: ST_TO_ADDR
// end ; end ;
92245: GO 92248
92247: POP
// case btype of b_depot , b_warehouse :
92248: LD_VAR 0 1
92252: PUSH
92253: LD_INT 0
92255: DOUBLE
92256: EQUAL
92257: IFTRUE 92267
92259: LD_INT 1
92261: DOUBLE
92262: EQUAL
92263: IFTRUE 92267
92265: GO 92468
92267: POP
// case nation of nation_american :
92268: LD_VAR 0 5
92272: PUSH
92273: LD_INT 1
92275: DOUBLE
92276: EQUAL
92277: IFTRUE 92281
92279: GO 92337
92281: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
92282: LD_ADDR_VAR 0 9
92286: PUSH
92287: LD_VAR 0 11
92291: PUSH
92292: LD_VAR 0 12
92296: PUSH
92297: LD_VAR 0 13
92301: PUSH
92302: LD_VAR 0 14
92306: PUSH
92307: LD_VAR 0 15
92311: PUSH
92312: LD_VAR 0 16
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: PUSH
92325: LD_VAR 0 4
92329: PUSH
92330: LD_INT 1
92332: PLUS
92333: ARRAY
92334: ST_TO_ADDR
92335: GO 92466
92337: LD_INT 2
92339: DOUBLE
92340: EQUAL
92341: IFTRUE 92345
92343: GO 92401
92345: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
92346: LD_ADDR_VAR 0 9
92350: PUSH
92351: LD_VAR 0 17
92355: PUSH
92356: LD_VAR 0 18
92360: PUSH
92361: LD_VAR 0 19
92365: PUSH
92366: LD_VAR 0 20
92370: PUSH
92371: LD_VAR 0 21
92375: PUSH
92376: LD_VAR 0 22
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: PUSH
92389: LD_VAR 0 4
92393: PUSH
92394: LD_INT 1
92396: PLUS
92397: ARRAY
92398: ST_TO_ADDR
92399: GO 92466
92401: LD_INT 3
92403: DOUBLE
92404: EQUAL
92405: IFTRUE 92409
92407: GO 92465
92409: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
92410: LD_ADDR_VAR 0 9
92414: PUSH
92415: LD_VAR 0 23
92419: PUSH
92420: LD_VAR 0 24
92424: PUSH
92425: LD_VAR 0 25
92429: PUSH
92430: LD_VAR 0 26
92434: PUSH
92435: LD_VAR 0 27
92439: PUSH
92440: LD_VAR 0 28
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: PUSH
92453: LD_VAR 0 4
92457: PUSH
92458: LD_INT 1
92460: PLUS
92461: ARRAY
92462: ST_TO_ADDR
92463: GO 92466
92465: POP
92466: GO 93021
92468: LD_INT 2
92470: DOUBLE
92471: EQUAL
92472: IFTRUE 92482
92474: LD_INT 3
92476: DOUBLE
92477: EQUAL
92478: IFTRUE 92482
92480: GO 92538
92482: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
92483: LD_ADDR_VAR 0 9
92487: PUSH
92488: LD_VAR 0 29
92492: PUSH
92493: LD_VAR 0 30
92497: PUSH
92498: LD_VAR 0 31
92502: PUSH
92503: LD_VAR 0 32
92507: PUSH
92508: LD_VAR 0 33
92512: PUSH
92513: LD_VAR 0 34
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: PUSH
92526: LD_VAR 0 4
92530: PUSH
92531: LD_INT 1
92533: PLUS
92534: ARRAY
92535: ST_TO_ADDR
92536: GO 93021
92538: LD_INT 16
92540: DOUBLE
92541: EQUAL
92542: IFTRUE 92600
92544: LD_INT 17
92546: DOUBLE
92547: EQUAL
92548: IFTRUE 92600
92550: LD_INT 18
92552: DOUBLE
92553: EQUAL
92554: IFTRUE 92600
92556: LD_INT 19
92558: DOUBLE
92559: EQUAL
92560: IFTRUE 92600
92562: LD_INT 22
92564: DOUBLE
92565: EQUAL
92566: IFTRUE 92600
92568: LD_INT 20
92570: DOUBLE
92571: EQUAL
92572: IFTRUE 92600
92574: LD_INT 21
92576: DOUBLE
92577: EQUAL
92578: IFTRUE 92600
92580: LD_INT 23
92582: DOUBLE
92583: EQUAL
92584: IFTRUE 92600
92586: LD_INT 24
92588: DOUBLE
92589: EQUAL
92590: IFTRUE 92600
92592: LD_INT 25
92594: DOUBLE
92595: EQUAL
92596: IFTRUE 92600
92598: GO 92656
92600: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
92601: LD_ADDR_VAR 0 9
92605: PUSH
92606: LD_VAR 0 35
92610: PUSH
92611: LD_VAR 0 36
92615: PUSH
92616: LD_VAR 0 37
92620: PUSH
92621: LD_VAR 0 38
92625: PUSH
92626: LD_VAR 0 39
92630: PUSH
92631: LD_VAR 0 40
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: PUSH
92644: LD_VAR 0 4
92648: PUSH
92649: LD_INT 1
92651: PLUS
92652: ARRAY
92653: ST_TO_ADDR
92654: GO 93021
92656: LD_INT 6
92658: DOUBLE
92659: EQUAL
92660: IFTRUE 92712
92662: LD_INT 7
92664: DOUBLE
92665: EQUAL
92666: IFTRUE 92712
92668: LD_INT 8
92670: DOUBLE
92671: EQUAL
92672: IFTRUE 92712
92674: LD_INT 13
92676: DOUBLE
92677: EQUAL
92678: IFTRUE 92712
92680: LD_INT 12
92682: DOUBLE
92683: EQUAL
92684: IFTRUE 92712
92686: LD_INT 15
92688: DOUBLE
92689: EQUAL
92690: IFTRUE 92712
92692: LD_INT 11
92694: DOUBLE
92695: EQUAL
92696: IFTRUE 92712
92698: LD_INT 14
92700: DOUBLE
92701: EQUAL
92702: IFTRUE 92712
92704: LD_INT 10
92706: DOUBLE
92707: EQUAL
92708: IFTRUE 92712
92710: GO 92768
92712: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
92713: LD_ADDR_VAR 0 9
92717: PUSH
92718: LD_VAR 0 41
92722: PUSH
92723: LD_VAR 0 42
92727: PUSH
92728: LD_VAR 0 43
92732: PUSH
92733: LD_VAR 0 44
92737: PUSH
92738: LD_VAR 0 45
92742: PUSH
92743: LD_VAR 0 46
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: PUSH
92756: LD_VAR 0 4
92760: PUSH
92761: LD_INT 1
92763: PLUS
92764: ARRAY
92765: ST_TO_ADDR
92766: GO 93021
92768: LD_INT 36
92770: DOUBLE
92771: EQUAL
92772: IFTRUE 92776
92774: GO 92832
92776: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
92777: LD_ADDR_VAR 0 9
92781: PUSH
92782: LD_VAR 0 47
92786: PUSH
92787: LD_VAR 0 48
92791: PUSH
92792: LD_VAR 0 49
92796: PUSH
92797: LD_VAR 0 50
92801: PUSH
92802: LD_VAR 0 51
92806: PUSH
92807: LD_VAR 0 52
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: PUSH
92820: LD_VAR 0 4
92824: PUSH
92825: LD_INT 1
92827: PLUS
92828: ARRAY
92829: ST_TO_ADDR
92830: GO 93021
92832: LD_INT 4
92834: DOUBLE
92835: EQUAL
92836: IFTRUE 92858
92838: LD_INT 5
92840: DOUBLE
92841: EQUAL
92842: IFTRUE 92858
92844: LD_INT 34
92846: DOUBLE
92847: EQUAL
92848: IFTRUE 92858
92850: LD_INT 37
92852: DOUBLE
92853: EQUAL
92854: IFTRUE 92858
92856: GO 92914
92858: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
92859: LD_ADDR_VAR 0 9
92863: PUSH
92864: LD_VAR 0 53
92868: PUSH
92869: LD_VAR 0 54
92873: PUSH
92874: LD_VAR 0 55
92878: PUSH
92879: LD_VAR 0 56
92883: PUSH
92884: LD_VAR 0 57
92888: PUSH
92889: LD_VAR 0 58
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: PUSH
92902: LD_VAR 0 4
92906: PUSH
92907: LD_INT 1
92909: PLUS
92910: ARRAY
92911: ST_TO_ADDR
92912: GO 93021
92914: LD_INT 31
92916: DOUBLE
92917: EQUAL
92918: IFTRUE 92964
92920: LD_INT 32
92922: DOUBLE
92923: EQUAL
92924: IFTRUE 92964
92926: LD_INT 33
92928: DOUBLE
92929: EQUAL
92930: IFTRUE 92964
92932: LD_INT 27
92934: DOUBLE
92935: EQUAL
92936: IFTRUE 92964
92938: LD_INT 26
92940: DOUBLE
92941: EQUAL
92942: IFTRUE 92964
92944: LD_INT 28
92946: DOUBLE
92947: EQUAL
92948: IFTRUE 92964
92950: LD_INT 29
92952: DOUBLE
92953: EQUAL
92954: IFTRUE 92964
92956: LD_INT 30
92958: DOUBLE
92959: EQUAL
92960: IFTRUE 92964
92962: GO 93020
92964: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
92965: LD_ADDR_VAR 0 9
92969: PUSH
92970: LD_VAR 0 59
92974: PUSH
92975: LD_VAR 0 60
92979: PUSH
92980: LD_VAR 0 61
92984: PUSH
92985: LD_VAR 0 62
92989: PUSH
92990: LD_VAR 0 63
92994: PUSH
92995: LD_VAR 0 64
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: PUSH
93008: LD_VAR 0 4
93012: PUSH
93013: LD_INT 1
93015: PLUS
93016: ARRAY
93017: ST_TO_ADDR
93018: GO 93021
93020: POP
// temp_list2 = [ ] ;
93021: LD_ADDR_VAR 0 10
93025: PUSH
93026: EMPTY
93027: ST_TO_ADDR
// for i in temp_list do
93028: LD_ADDR_VAR 0 8
93032: PUSH
93033: LD_VAR 0 9
93037: PUSH
93038: FOR_IN
93039: IFFALSE 93091
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
93041: LD_ADDR_VAR 0 10
93045: PUSH
93046: LD_VAR 0 10
93050: PUSH
93051: LD_VAR 0 8
93055: PUSH
93056: LD_INT 1
93058: ARRAY
93059: PUSH
93060: LD_VAR 0 2
93064: PLUS
93065: PUSH
93066: LD_VAR 0 8
93070: PUSH
93071: LD_INT 2
93073: ARRAY
93074: PUSH
93075: LD_VAR 0 3
93079: PLUS
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PUSH
93085: EMPTY
93086: LIST
93087: ADD
93088: ST_TO_ADDR
93089: GO 93038
93091: POP
93092: POP
// result = temp_list2 ;
93093: LD_ADDR_VAR 0 7
93097: PUSH
93098: LD_VAR 0 10
93102: ST_TO_ADDR
// end ;
93103: LD_VAR 0 7
93107: RET
// export function EnemyInRange ( unit , dist ) ; begin
93108: LD_INT 0
93110: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
93111: LD_ADDR_VAR 0 3
93115: PUSH
93116: LD_VAR 0 1
93120: PPUSH
93121: CALL_OW 255
93125: PPUSH
93126: LD_VAR 0 1
93130: PPUSH
93131: CALL_OW 250
93135: PPUSH
93136: LD_VAR 0 1
93140: PPUSH
93141: CALL_OW 251
93145: PPUSH
93146: LD_VAR 0 2
93150: PPUSH
93151: CALL 66503 0 4
93155: PUSH
93156: LD_INT 4
93158: ARRAY
93159: ST_TO_ADDR
// end ;
93160: LD_VAR 0 3
93164: RET
// export function PlayerSeeMe ( unit ) ; begin
93165: LD_INT 0
93167: PPUSH
// result := See ( your_side , unit ) ;
93168: LD_ADDR_VAR 0 2
93172: PUSH
93173: LD_OWVAR 2
93177: PPUSH
93178: LD_VAR 0 1
93182: PPUSH
93183: CALL_OW 292
93187: ST_TO_ADDR
// end ;
93188: LD_VAR 0 2
93192: RET
// export function ReverseDir ( unit ) ; begin
93193: LD_INT 0
93195: PPUSH
// if not unit then
93196: LD_VAR 0 1
93200: NOT
93201: IFFALSE 93205
// exit ;
93203: GO 93228
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
93205: LD_ADDR_VAR 0 2
93209: PUSH
93210: LD_VAR 0 1
93214: PPUSH
93215: CALL_OW 254
93219: PUSH
93220: LD_INT 3
93222: PLUS
93223: PUSH
93224: LD_INT 6
93226: MOD
93227: ST_TO_ADDR
// end ;
93228: LD_VAR 0 2
93232: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
93233: LD_INT 0
93235: PPUSH
93236: PPUSH
93237: PPUSH
93238: PPUSH
93239: PPUSH
// if not hexes then
93240: LD_VAR 0 2
93244: NOT
93245: IFFALSE 93249
// exit ;
93247: GO 93397
// dist := 9999 ;
93249: LD_ADDR_VAR 0 5
93253: PUSH
93254: LD_INT 9999
93256: ST_TO_ADDR
// for i = 1 to hexes do
93257: LD_ADDR_VAR 0 4
93261: PUSH
93262: DOUBLE
93263: LD_INT 1
93265: DEC
93266: ST_TO_ADDR
93267: LD_VAR 0 2
93271: PUSH
93272: FOR_TO
93273: IFFALSE 93385
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
93275: LD_VAR 0 1
93279: PPUSH
93280: LD_VAR 0 2
93284: PUSH
93285: LD_VAR 0 4
93289: ARRAY
93290: PUSH
93291: LD_INT 1
93293: ARRAY
93294: PPUSH
93295: LD_VAR 0 2
93299: PUSH
93300: LD_VAR 0 4
93304: ARRAY
93305: PUSH
93306: LD_INT 2
93308: ARRAY
93309: PPUSH
93310: CALL_OW 297
93314: PUSH
93315: LD_VAR 0 5
93319: LESS
93320: IFFALSE 93383
// begin hex := hexes [ i ] ;
93322: LD_ADDR_VAR 0 7
93326: PUSH
93327: LD_VAR 0 2
93331: PUSH
93332: LD_VAR 0 4
93336: ARRAY
93337: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
93338: LD_ADDR_VAR 0 5
93342: PUSH
93343: LD_VAR 0 1
93347: PPUSH
93348: LD_VAR 0 2
93352: PUSH
93353: LD_VAR 0 4
93357: ARRAY
93358: PUSH
93359: LD_INT 1
93361: ARRAY
93362: PPUSH
93363: LD_VAR 0 2
93367: PUSH
93368: LD_VAR 0 4
93372: ARRAY
93373: PUSH
93374: LD_INT 2
93376: ARRAY
93377: PPUSH
93378: CALL_OW 297
93382: ST_TO_ADDR
// end ; end ;
93383: GO 93272
93385: POP
93386: POP
// result := hex ;
93387: LD_ADDR_VAR 0 3
93391: PUSH
93392: LD_VAR 0 7
93396: ST_TO_ADDR
// end ;
93397: LD_VAR 0 3
93401: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
93402: LD_INT 0
93404: PPUSH
93405: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
93406: LD_VAR 0 1
93410: NOT
93411: PUSH
93412: LD_VAR 0 1
93416: PUSH
93417: LD_INT 21
93419: PUSH
93420: LD_INT 2
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 23
93429: PUSH
93430: LD_INT 2
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PPUSH
93441: CALL_OW 69
93445: IN
93446: NOT
93447: OR
93448: IFFALSE 93452
// exit ;
93450: GO 93499
// for i = 1 to 3 do
93452: LD_ADDR_VAR 0 3
93456: PUSH
93457: DOUBLE
93458: LD_INT 1
93460: DEC
93461: ST_TO_ADDR
93462: LD_INT 3
93464: PUSH
93465: FOR_TO
93466: IFFALSE 93497
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
93468: LD_VAR 0 1
93472: PPUSH
93473: CALL_OW 250
93477: PPUSH
93478: LD_VAR 0 1
93482: PPUSH
93483: CALL_OW 251
93487: PPUSH
93488: LD_INT 1
93490: PPUSH
93491: CALL_OW 453
93495: GO 93465
93497: POP
93498: POP
// end ;
93499: LD_VAR 0 2
93503: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
93504: LD_INT 0
93506: PPUSH
93507: PPUSH
93508: PPUSH
93509: PPUSH
93510: PPUSH
93511: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
93512: LD_VAR 0 1
93516: NOT
93517: PUSH
93518: LD_VAR 0 2
93522: NOT
93523: OR
93524: PUSH
93525: LD_VAR 0 1
93529: PPUSH
93530: CALL_OW 314
93534: OR
93535: IFFALSE 93539
// exit ;
93537: GO 93980
// x := GetX ( enemy_unit ) ;
93539: LD_ADDR_VAR 0 7
93543: PUSH
93544: LD_VAR 0 2
93548: PPUSH
93549: CALL_OW 250
93553: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
93554: LD_ADDR_VAR 0 8
93558: PUSH
93559: LD_VAR 0 2
93563: PPUSH
93564: CALL_OW 251
93568: ST_TO_ADDR
// if not x or not y then
93569: LD_VAR 0 7
93573: NOT
93574: PUSH
93575: LD_VAR 0 8
93579: NOT
93580: OR
93581: IFFALSE 93585
// exit ;
93583: GO 93980
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
93585: LD_ADDR_VAR 0 6
93589: PUSH
93590: LD_VAR 0 7
93594: PPUSH
93595: LD_INT 0
93597: PPUSH
93598: LD_INT 4
93600: PPUSH
93601: CALL_OW 272
93605: PUSH
93606: LD_VAR 0 8
93610: PPUSH
93611: LD_INT 0
93613: PPUSH
93614: LD_INT 4
93616: PPUSH
93617: CALL_OW 273
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_VAR 0 7
93630: PPUSH
93631: LD_INT 1
93633: PPUSH
93634: LD_INT 4
93636: PPUSH
93637: CALL_OW 272
93641: PUSH
93642: LD_VAR 0 8
93646: PPUSH
93647: LD_INT 1
93649: PPUSH
93650: LD_INT 4
93652: PPUSH
93653: CALL_OW 273
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_VAR 0 7
93666: PPUSH
93667: LD_INT 2
93669: PPUSH
93670: LD_INT 4
93672: PPUSH
93673: CALL_OW 272
93677: PUSH
93678: LD_VAR 0 8
93682: PPUSH
93683: LD_INT 2
93685: PPUSH
93686: LD_INT 4
93688: PPUSH
93689: CALL_OW 273
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: PUSH
93698: LD_VAR 0 7
93702: PPUSH
93703: LD_INT 3
93705: PPUSH
93706: LD_INT 4
93708: PPUSH
93709: CALL_OW 272
93713: PUSH
93714: LD_VAR 0 8
93718: PPUSH
93719: LD_INT 3
93721: PPUSH
93722: LD_INT 4
93724: PPUSH
93725: CALL_OW 273
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_VAR 0 7
93738: PPUSH
93739: LD_INT 4
93741: PPUSH
93742: LD_INT 4
93744: PPUSH
93745: CALL_OW 272
93749: PUSH
93750: LD_VAR 0 8
93754: PPUSH
93755: LD_INT 4
93757: PPUSH
93758: LD_INT 4
93760: PPUSH
93761: CALL_OW 273
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_VAR 0 7
93774: PPUSH
93775: LD_INT 5
93777: PPUSH
93778: LD_INT 4
93780: PPUSH
93781: CALL_OW 272
93785: PUSH
93786: LD_VAR 0 8
93790: PPUSH
93791: LD_INT 5
93793: PPUSH
93794: LD_INT 4
93796: PPUSH
93797: CALL_OW 273
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: ST_TO_ADDR
// for i = tmp downto 1 do
93814: LD_ADDR_VAR 0 4
93818: PUSH
93819: DOUBLE
93820: LD_VAR 0 6
93824: INC
93825: ST_TO_ADDR
93826: LD_INT 1
93828: PUSH
93829: FOR_DOWNTO
93830: IFFALSE 93931
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
93832: LD_VAR 0 6
93836: PUSH
93837: LD_VAR 0 4
93841: ARRAY
93842: PUSH
93843: LD_INT 1
93845: ARRAY
93846: PPUSH
93847: LD_VAR 0 6
93851: PUSH
93852: LD_VAR 0 4
93856: ARRAY
93857: PUSH
93858: LD_INT 2
93860: ARRAY
93861: PPUSH
93862: CALL_OW 488
93866: NOT
93867: PUSH
93868: LD_VAR 0 6
93872: PUSH
93873: LD_VAR 0 4
93877: ARRAY
93878: PUSH
93879: LD_INT 1
93881: ARRAY
93882: PPUSH
93883: LD_VAR 0 6
93887: PUSH
93888: LD_VAR 0 4
93892: ARRAY
93893: PUSH
93894: LD_INT 2
93896: ARRAY
93897: PPUSH
93898: CALL_OW 428
93902: PUSH
93903: LD_INT 0
93905: NONEQUAL
93906: OR
93907: IFFALSE 93929
// tmp := Delete ( tmp , i ) ;
93909: LD_ADDR_VAR 0 6
93913: PUSH
93914: LD_VAR 0 6
93918: PPUSH
93919: LD_VAR 0 4
93923: PPUSH
93924: CALL_OW 3
93928: ST_TO_ADDR
93929: GO 93829
93931: POP
93932: POP
// j := GetClosestHex ( unit , tmp ) ;
93933: LD_ADDR_VAR 0 5
93937: PUSH
93938: LD_VAR 0 1
93942: PPUSH
93943: LD_VAR 0 6
93947: PPUSH
93948: CALL 93233 0 2
93952: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
93953: LD_VAR 0 1
93957: PPUSH
93958: LD_VAR 0 5
93962: PUSH
93963: LD_INT 1
93965: ARRAY
93966: PPUSH
93967: LD_VAR 0 5
93971: PUSH
93972: LD_INT 2
93974: ARRAY
93975: PPUSH
93976: CALL_OW 111
// end ;
93980: LD_VAR 0 3
93984: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
93985: LD_INT 0
93987: PPUSH
93988: PPUSH
93989: PPUSH
// uc_side = 0 ;
93990: LD_ADDR_OWVAR 20
93994: PUSH
93995: LD_INT 0
93997: ST_TO_ADDR
// uc_nation = 0 ;
93998: LD_ADDR_OWVAR 21
94002: PUSH
94003: LD_INT 0
94005: ST_TO_ADDR
// InitHc_All ( ) ;
94006: CALL_OW 584
// InitVc ;
94010: CALL_OW 20
// if mastodonts then
94014: LD_VAR 0 6
94018: IFFALSE 94085
// for i = 1 to mastodonts do
94020: LD_ADDR_VAR 0 11
94024: PUSH
94025: DOUBLE
94026: LD_INT 1
94028: DEC
94029: ST_TO_ADDR
94030: LD_VAR 0 6
94034: PUSH
94035: FOR_TO
94036: IFFALSE 94083
// begin vc_chassis := 31 ;
94038: LD_ADDR_OWVAR 37
94042: PUSH
94043: LD_INT 31
94045: ST_TO_ADDR
// vc_control := control_rider ;
94046: LD_ADDR_OWVAR 38
94050: PUSH
94051: LD_INT 4
94053: ST_TO_ADDR
// animal := CreateVehicle ;
94054: LD_ADDR_VAR 0 12
94058: PUSH
94059: CALL_OW 45
94063: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94064: LD_VAR 0 12
94068: PPUSH
94069: LD_VAR 0 8
94073: PPUSH
94074: LD_INT 0
94076: PPUSH
94077: CALL 96273 0 3
// end ;
94081: GO 94035
94083: POP
94084: POP
// if horses then
94085: LD_VAR 0 5
94089: IFFALSE 94156
// for i = 1 to horses do
94091: LD_ADDR_VAR 0 11
94095: PUSH
94096: DOUBLE
94097: LD_INT 1
94099: DEC
94100: ST_TO_ADDR
94101: LD_VAR 0 5
94105: PUSH
94106: FOR_TO
94107: IFFALSE 94154
// begin hc_class := 21 ;
94109: LD_ADDR_OWVAR 28
94113: PUSH
94114: LD_INT 21
94116: ST_TO_ADDR
// hc_gallery :=  ;
94117: LD_ADDR_OWVAR 33
94121: PUSH
94122: LD_STRING 
94124: ST_TO_ADDR
// animal := CreateHuman ;
94125: LD_ADDR_VAR 0 12
94129: PUSH
94130: CALL_OW 44
94134: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94135: LD_VAR 0 12
94139: PPUSH
94140: LD_VAR 0 8
94144: PPUSH
94145: LD_INT 0
94147: PPUSH
94148: CALL 96273 0 3
// end ;
94152: GO 94106
94154: POP
94155: POP
// if birds then
94156: LD_VAR 0 1
94160: IFFALSE 94227
// for i = 1 to birds do
94162: LD_ADDR_VAR 0 11
94166: PUSH
94167: DOUBLE
94168: LD_INT 1
94170: DEC
94171: ST_TO_ADDR
94172: LD_VAR 0 1
94176: PUSH
94177: FOR_TO
94178: IFFALSE 94225
// begin hc_class = 18 ;
94180: LD_ADDR_OWVAR 28
94184: PUSH
94185: LD_INT 18
94187: ST_TO_ADDR
// hc_gallery =  ;
94188: LD_ADDR_OWVAR 33
94192: PUSH
94193: LD_STRING 
94195: ST_TO_ADDR
// animal := CreateHuman ;
94196: LD_ADDR_VAR 0 12
94200: PUSH
94201: CALL_OW 44
94205: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94206: LD_VAR 0 12
94210: PPUSH
94211: LD_VAR 0 8
94215: PPUSH
94216: LD_INT 0
94218: PPUSH
94219: CALL 96273 0 3
// end ;
94223: GO 94177
94225: POP
94226: POP
// if tigers then
94227: LD_VAR 0 2
94231: IFFALSE 94315
// for i = 1 to tigers do
94233: LD_ADDR_VAR 0 11
94237: PUSH
94238: DOUBLE
94239: LD_INT 1
94241: DEC
94242: ST_TO_ADDR
94243: LD_VAR 0 2
94247: PUSH
94248: FOR_TO
94249: IFFALSE 94313
// begin hc_class = class_tiger ;
94251: LD_ADDR_OWVAR 28
94255: PUSH
94256: LD_INT 14
94258: ST_TO_ADDR
// hc_gallery =  ;
94259: LD_ADDR_OWVAR 33
94263: PUSH
94264: LD_STRING 
94266: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
94267: LD_ADDR_OWVAR 35
94271: PUSH
94272: LD_INT 7
94274: NEG
94275: PPUSH
94276: LD_INT 7
94278: PPUSH
94279: CALL_OW 12
94283: ST_TO_ADDR
// animal := CreateHuman ;
94284: LD_ADDR_VAR 0 12
94288: PUSH
94289: CALL_OW 44
94293: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94294: LD_VAR 0 12
94298: PPUSH
94299: LD_VAR 0 8
94303: PPUSH
94304: LD_INT 0
94306: PPUSH
94307: CALL 96273 0 3
// end ;
94311: GO 94248
94313: POP
94314: POP
// if apemans then
94315: LD_VAR 0 3
94319: IFFALSE 94442
// for i = 1 to apemans do
94321: LD_ADDR_VAR 0 11
94325: PUSH
94326: DOUBLE
94327: LD_INT 1
94329: DEC
94330: ST_TO_ADDR
94331: LD_VAR 0 3
94335: PUSH
94336: FOR_TO
94337: IFFALSE 94440
// begin hc_class = class_apeman ;
94339: LD_ADDR_OWVAR 28
94343: PUSH
94344: LD_INT 12
94346: ST_TO_ADDR
// hc_gallery =  ;
94347: LD_ADDR_OWVAR 33
94351: PUSH
94352: LD_STRING 
94354: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
94355: LD_ADDR_OWVAR 35
94359: PUSH
94360: LD_INT 2
94362: NEG
94363: PPUSH
94364: LD_INT 2
94366: PPUSH
94367: CALL_OW 12
94371: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
94372: LD_ADDR_OWVAR 31
94376: PUSH
94377: LD_INT 1
94379: PPUSH
94380: LD_INT 3
94382: PPUSH
94383: CALL_OW 12
94387: PUSH
94388: LD_INT 1
94390: PPUSH
94391: LD_INT 3
94393: PPUSH
94394: CALL_OW 12
94398: PUSH
94399: LD_INT 0
94401: PUSH
94402: LD_INT 0
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: ST_TO_ADDR
// animal := CreateHuman ;
94411: LD_ADDR_VAR 0 12
94415: PUSH
94416: CALL_OW 44
94420: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94421: LD_VAR 0 12
94425: PPUSH
94426: LD_VAR 0 8
94430: PPUSH
94431: LD_INT 0
94433: PPUSH
94434: CALL 96273 0 3
// end ;
94438: GO 94336
94440: POP
94441: POP
// if enchidnas then
94442: LD_VAR 0 4
94446: IFFALSE 94513
// for i = 1 to enchidnas do
94448: LD_ADDR_VAR 0 11
94452: PUSH
94453: DOUBLE
94454: LD_INT 1
94456: DEC
94457: ST_TO_ADDR
94458: LD_VAR 0 4
94462: PUSH
94463: FOR_TO
94464: IFFALSE 94511
// begin hc_class = 13 ;
94466: LD_ADDR_OWVAR 28
94470: PUSH
94471: LD_INT 13
94473: ST_TO_ADDR
// hc_gallery =  ;
94474: LD_ADDR_OWVAR 33
94478: PUSH
94479: LD_STRING 
94481: ST_TO_ADDR
// animal := CreateHuman ;
94482: LD_ADDR_VAR 0 12
94486: PUSH
94487: CALL_OW 44
94491: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94492: LD_VAR 0 12
94496: PPUSH
94497: LD_VAR 0 8
94501: PPUSH
94502: LD_INT 0
94504: PPUSH
94505: CALL 96273 0 3
// end ;
94509: GO 94463
94511: POP
94512: POP
// if fishes then
94513: LD_VAR 0 7
94517: IFFALSE 94584
// for i = 1 to fishes do
94519: LD_ADDR_VAR 0 11
94523: PUSH
94524: DOUBLE
94525: LD_INT 1
94527: DEC
94528: ST_TO_ADDR
94529: LD_VAR 0 7
94533: PUSH
94534: FOR_TO
94535: IFFALSE 94582
// begin hc_class = 20 ;
94537: LD_ADDR_OWVAR 28
94541: PUSH
94542: LD_INT 20
94544: ST_TO_ADDR
// hc_gallery =  ;
94545: LD_ADDR_OWVAR 33
94549: PUSH
94550: LD_STRING 
94552: ST_TO_ADDR
// animal := CreateHuman ;
94553: LD_ADDR_VAR 0 12
94557: PUSH
94558: CALL_OW 44
94562: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
94563: LD_VAR 0 12
94567: PPUSH
94568: LD_VAR 0 9
94572: PPUSH
94573: LD_INT 0
94575: PPUSH
94576: CALL 96273 0 3
// end ;
94580: GO 94534
94582: POP
94583: POP
// end ;
94584: LD_VAR 0 10
94588: RET
// export function WantHeal ( sci , unit ) ; begin
94589: LD_INT 0
94591: PPUSH
// if GetTaskList ( sci ) > 0 then
94592: LD_VAR 0 1
94596: PPUSH
94597: CALL_OW 437
94601: PUSH
94602: LD_INT 0
94604: GREATER
94605: IFFALSE 94675
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
94607: LD_VAR 0 1
94611: PPUSH
94612: CALL_OW 437
94616: PUSH
94617: LD_INT 1
94619: ARRAY
94620: PUSH
94621: LD_INT 1
94623: ARRAY
94624: PUSH
94625: LD_STRING l
94627: EQUAL
94628: PUSH
94629: LD_VAR 0 1
94633: PPUSH
94634: CALL_OW 437
94638: PUSH
94639: LD_INT 1
94641: ARRAY
94642: PUSH
94643: LD_INT 4
94645: ARRAY
94646: PUSH
94647: LD_VAR 0 2
94651: EQUAL
94652: AND
94653: IFFALSE 94665
// result := true else
94655: LD_ADDR_VAR 0 3
94659: PUSH
94660: LD_INT 1
94662: ST_TO_ADDR
94663: GO 94673
// result := false ;
94665: LD_ADDR_VAR 0 3
94669: PUSH
94670: LD_INT 0
94672: ST_TO_ADDR
// end else
94673: GO 94683
// result := false ;
94675: LD_ADDR_VAR 0 3
94679: PUSH
94680: LD_INT 0
94682: ST_TO_ADDR
// end ;
94683: LD_VAR 0 3
94687: RET
// export function HealTarget ( sci ) ; begin
94688: LD_INT 0
94690: PPUSH
// if not sci then
94691: LD_VAR 0 1
94695: NOT
94696: IFFALSE 94700
// exit ;
94698: GO 94765
// result := 0 ;
94700: LD_ADDR_VAR 0 2
94704: PUSH
94705: LD_INT 0
94707: ST_TO_ADDR
// if GetTaskList ( sci ) then
94708: LD_VAR 0 1
94712: PPUSH
94713: CALL_OW 437
94717: IFFALSE 94765
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
94719: LD_VAR 0 1
94723: PPUSH
94724: CALL_OW 437
94728: PUSH
94729: LD_INT 1
94731: ARRAY
94732: PUSH
94733: LD_INT 1
94735: ARRAY
94736: PUSH
94737: LD_STRING l
94739: EQUAL
94740: IFFALSE 94765
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
94742: LD_ADDR_VAR 0 2
94746: PUSH
94747: LD_VAR 0 1
94751: PPUSH
94752: CALL_OW 437
94756: PUSH
94757: LD_INT 1
94759: ARRAY
94760: PUSH
94761: LD_INT 4
94763: ARRAY
94764: ST_TO_ADDR
// end ;
94765: LD_VAR 0 2
94769: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
94770: LD_INT 0
94772: PPUSH
94773: PPUSH
94774: PPUSH
94775: PPUSH
// if not base_units then
94776: LD_VAR 0 1
94780: NOT
94781: IFFALSE 94785
// exit ;
94783: GO 94872
// result := false ;
94785: LD_ADDR_VAR 0 2
94789: PUSH
94790: LD_INT 0
94792: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
94793: LD_ADDR_VAR 0 5
94797: PUSH
94798: LD_VAR 0 1
94802: PPUSH
94803: LD_INT 21
94805: PUSH
94806: LD_INT 3
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PPUSH
94813: CALL_OW 72
94817: ST_TO_ADDR
// if not tmp then
94818: LD_VAR 0 5
94822: NOT
94823: IFFALSE 94827
// exit ;
94825: GO 94872
// for i in tmp do
94827: LD_ADDR_VAR 0 3
94831: PUSH
94832: LD_VAR 0 5
94836: PUSH
94837: FOR_IN
94838: IFFALSE 94870
// begin result := EnemyInRange ( i , 22 ) ;
94840: LD_ADDR_VAR 0 2
94844: PUSH
94845: LD_VAR 0 3
94849: PPUSH
94850: LD_INT 22
94852: PPUSH
94853: CALL 93108 0 2
94857: ST_TO_ADDR
// if result then
94858: LD_VAR 0 2
94862: IFFALSE 94868
// exit ;
94864: POP
94865: POP
94866: GO 94872
// end ;
94868: GO 94837
94870: POP
94871: POP
// end ;
94872: LD_VAR 0 2
94876: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
94877: LD_INT 0
94879: PPUSH
94880: PPUSH
// if not units then
94881: LD_VAR 0 1
94885: NOT
94886: IFFALSE 94890
// exit ;
94888: GO 94960
// result := [ ] ;
94890: LD_ADDR_VAR 0 3
94894: PUSH
94895: EMPTY
94896: ST_TO_ADDR
// for i in units do
94897: LD_ADDR_VAR 0 4
94901: PUSH
94902: LD_VAR 0 1
94906: PUSH
94907: FOR_IN
94908: IFFALSE 94958
// if GetTag ( i ) = tag then
94910: LD_VAR 0 4
94914: PPUSH
94915: CALL_OW 110
94919: PUSH
94920: LD_VAR 0 2
94924: EQUAL
94925: IFFALSE 94956
// result := Insert ( result , result + 1 , i ) ;
94927: LD_ADDR_VAR 0 3
94931: PUSH
94932: LD_VAR 0 3
94936: PPUSH
94937: LD_VAR 0 3
94941: PUSH
94942: LD_INT 1
94944: PLUS
94945: PPUSH
94946: LD_VAR 0 4
94950: PPUSH
94951: CALL_OW 2
94955: ST_TO_ADDR
94956: GO 94907
94958: POP
94959: POP
// end ;
94960: LD_VAR 0 3
94964: RET
// export function IsDriver ( un ) ; begin
94965: LD_INT 0
94967: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
94968: LD_ADDR_VAR 0 2
94972: PUSH
94973: LD_VAR 0 1
94977: PUSH
94978: LD_INT 55
94980: PUSH
94981: EMPTY
94982: LIST
94983: PPUSH
94984: CALL_OW 69
94988: IN
94989: ST_TO_ADDR
// end ;
94990: LD_VAR 0 2
94994: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
94995: LD_INT 0
94997: PPUSH
94998: PPUSH
// list := [ ] ;
94999: LD_ADDR_VAR 0 5
95003: PUSH
95004: EMPTY
95005: ST_TO_ADDR
// case d of 0 :
95006: LD_VAR 0 3
95010: PUSH
95011: LD_INT 0
95013: DOUBLE
95014: EQUAL
95015: IFTRUE 95019
95017: GO 95152
95019: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
95020: LD_ADDR_VAR 0 5
95024: PUSH
95025: LD_VAR 0 1
95029: PUSH
95030: LD_INT 4
95032: MINUS
95033: PUSH
95034: LD_VAR 0 2
95038: PUSH
95039: LD_INT 4
95041: MINUS
95042: PUSH
95043: LD_INT 2
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: LIST
95050: PUSH
95051: LD_VAR 0 1
95055: PUSH
95056: LD_INT 3
95058: MINUS
95059: PUSH
95060: LD_VAR 0 2
95064: PUSH
95065: LD_INT 1
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: LIST
95072: PUSH
95073: LD_VAR 0 1
95077: PUSH
95078: LD_INT 4
95080: PLUS
95081: PUSH
95082: LD_VAR 0 2
95086: PUSH
95087: LD_INT 4
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: LIST
95094: PUSH
95095: LD_VAR 0 1
95099: PUSH
95100: LD_INT 3
95102: PLUS
95103: PUSH
95104: LD_VAR 0 2
95108: PUSH
95109: LD_INT 3
95111: PLUS
95112: PUSH
95113: LD_INT 5
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: LIST
95120: PUSH
95121: LD_VAR 0 1
95125: PUSH
95126: LD_VAR 0 2
95130: PUSH
95131: LD_INT 4
95133: PLUS
95134: PUSH
95135: LD_INT 0
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: LIST
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: ST_TO_ADDR
// end ; 1 :
95150: GO 95850
95152: LD_INT 1
95154: DOUBLE
95155: EQUAL
95156: IFTRUE 95160
95158: GO 95293
95160: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
95161: LD_ADDR_VAR 0 5
95165: PUSH
95166: LD_VAR 0 1
95170: PUSH
95171: LD_VAR 0 2
95175: PUSH
95176: LD_INT 4
95178: MINUS
95179: PUSH
95180: LD_INT 3
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: LIST
95187: PUSH
95188: LD_VAR 0 1
95192: PUSH
95193: LD_INT 3
95195: MINUS
95196: PUSH
95197: LD_VAR 0 2
95201: PUSH
95202: LD_INT 3
95204: MINUS
95205: PUSH
95206: LD_INT 2
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: LIST
95213: PUSH
95214: LD_VAR 0 1
95218: PUSH
95219: LD_INT 4
95221: MINUS
95222: PUSH
95223: LD_VAR 0 2
95227: PUSH
95228: LD_INT 1
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: LIST
95235: PUSH
95236: LD_VAR 0 1
95240: PUSH
95241: LD_VAR 0 2
95245: PUSH
95246: LD_INT 3
95248: PLUS
95249: PUSH
95250: LD_INT 0
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: LIST
95257: PUSH
95258: LD_VAR 0 1
95262: PUSH
95263: LD_INT 4
95265: PLUS
95266: PUSH
95267: LD_VAR 0 2
95271: PUSH
95272: LD_INT 4
95274: PLUS
95275: PUSH
95276: LD_INT 5
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: LIST
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: ST_TO_ADDR
// end ; 2 :
95291: GO 95850
95293: LD_INT 2
95295: DOUBLE
95296: EQUAL
95297: IFTRUE 95301
95299: GO 95430
95301: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
95302: LD_ADDR_VAR 0 5
95306: PUSH
95307: LD_VAR 0 1
95311: PUSH
95312: LD_VAR 0 2
95316: PUSH
95317: LD_INT 3
95319: MINUS
95320: PUSH
95321: LD_INT 3
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: LIST
95328: PUSH
95329: LD_VAR 0 1
95333: PUSH
95334: LD_INT 4
95336: PLUS
95337: PUSH
95338: LD_VAR 0 2
95342: PUSH
95343: LD_INT 4
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: LIST
95350: PUSH
95351: LD_VAR 0 1
95355: PUSH
95356: LD_VAR 0 2
95360: PUSH
95361: LD_INT 4
95363: PLUS
95364: PUSH
95365: LD_INT 0
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: LIST
95372: PUSH
95373: LD_VAR 0 1
95377: PUSH
95378: LD_INT 3
95380: MINUS
95381: PUSH
95382: LD_VAR 0 2
95386: PUSH
95387: LD_INT 1
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: LIST
95394: PUSH
95395: LD_VAR 0 1
95399: PUSH
95400: LD_INT 4
95402: MINUS
95403: PUSH
95404: LD_VAR 0 2
95408: PUSH
95409: LD_INT 4
95411: MINUS
95412: PUSH
95413: LD_INT 2
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: LIST
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: ST_TO_ADDR
// end ; 3 :
95428: GO 95850
95430: LD_INT 3
95432: DOUBLE
95433: EQUAL
95434: IFTRUE 95438
95436: GO 95571
95438: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
95439: LD_ADDR_VAR 0 5
95443: PUSH
95444: LD_VAR 0 1
95448: PUSH
95449: LD_INT 3
95451: PLUS
95452: PUSH
95453: LD_VAR 0 2
95457: PUSH
95458: LD_INT 4
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: LIST
95465: PUSH
95466: LD_VAR 0 1
95470: PUSH
95471: LD_INT 4
95473: PLUS
95474: PUSH
95475: LD_VAR 0 2
95479: PUSH
95480: LD_INT 4
95482: PLUS
95483: PUSH
95484: LD_INT 5
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: LIST
95491: PUSH
95492: LD_VAR 0 1
95496: PUSH
95497: LD_INT 4
95499: MINUS
95500: PUSH
95501: LD_VAR 0 2
95505: PUSH
95506: LD_INT 1
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: LIST
95513: PUSH
95514: LD_VAR 0 1
95518: PUSH
95519: LD_VAR 0 2
95523: PUSH
95524: LD_INT 4
95526: MINUS
95527: PUSH
95528: LD_INT 3
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: LIST
95535: PUSH
95536: LD_VAR 0 1
95540: PUSH
95541: LD_INT 3
95543: MINUS
95544: PUSH
95545: LD_VAR 0 2
95549: PUSH
95550: LD_INT 3
95552: MINUS
95553: PUSH
95554: LD_INT 2
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: LIST
95561: PUSH
95562: EMPTY
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: ST_TO_ADDR
// end ; 4 :
95569: GO 95850
95571: LD_INT 4
95573: DOUBLE
95574: EQUAL
95575: IFTRUE 95579
95577: GO 95712
95579: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
95580: LD_ADDR_VAR 0 5
95584: PUSH
95585: LD_VAR 0 1
95589: PUSH
95590: LD_VAR 0 2
95594: PUSH
95595: LD_INT 4
95597: PLUS
95598: PUSH
95599: LD_INT 0
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: LIST
95606: PUSH
95607: LD_VAR 0 1
95611: PUSH
95612: LD_INT 3
95614: PLUS
95615: PUSH
95616: LD_VAR 0 2
95620: PUSH
95621: LD_INT 3
95623: PLUS
95624: PUSH
95625: LD_INT 5
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: LIST
95632: PUSH
95633: LD_VAR 0 1
95637: PUSH
95638: LD_INT 4
95640: PLUS
95641: PUSH
95642: LD_VAR 0 2
95646: PUSH
95647: LD_INT 4
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: PUSH
95655: LD_VAR 0 1
95659: PUSH
95660: LD_VAR 0 2
95664: PUSH
95665: LD_INT 3
95667: MINUS
95668: PUSH
95669: LD_INT 3
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: LIST
95676: PUSH
95677: LD_VAR 0 1
95681: PUSH
95682: LD_INT 4
95684: MINUS
95685: PUSH
95686: LD_VAR 0 2
95690: PUSH
95691: LD_INT 4
95693: MINUS
95694: PUSH
95695: LD_INT 2
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: LIST
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: ST_TO_ADDR
// end ; 5 :
95710: GO 95850
95712: LD_INT 5
95714: DOUBLE
95715: EQUAL
95716: IFTRUE 95720
95718: GO 95849
95720: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
95721: LD_ADDR_VAR 0 5
95725: PUSH
95726: LD_VAR 0 1
95730: PUSH
95731: LD_INT 4
95733: MINUS
95734: PUSH
95735: LD_VAR 0 2
95739: PUSH
95740: LD_INT 1
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: LIST
95747: PUSH
95748: LD_VAR 0 1
95752: PUSH
95753: LD_VAR 0 2
95757: PUSH
95758: LD_INT 4
95760: MINUS
95761: PUSH
95762: LD_INT 3
95764: PUSH
95765: EMPTY
95766: LIST
95767: LIST
95768: LIST
95769: PUSH
95770: LD_VAR 0 1
95774: PUSH
95775: LD_INT 4
95777: PLUS
95778: PUSH
95779: LD_VAR 0 2
95783: PUSH
95784: LD_INT 4
95786: PLUS
95787: PUSH
95788: LD_INT 5
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: LIST
95795: PUSH
95796: LD_VAR 0 1
95800: PUSH
95801: LD_INT 3
95803: PLUS
95804: PUSH
95805: LD_VAR 0 2
95809: PUSH
95810: LD_INT 4
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: LIST
95817: PUSH
95818: LD_VAR 0 1
95822: PUSH
95823: LD_VAR 0 2
95827: PUSH
95828: LD_INT 3
95830: PLUS
95831: PUSH
95832: LD_INT 0
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: LIST
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: ST_TO_ADDR
// end ; end ;
95847: GO 95850
95849: POP
// result := list ;
95850: LD_ADDR_VAR 0 4
95854: PUSH
95855: LD_VAR 0 5
95859: ST_TO_ADDR
// end ;
95860: LD_VAR 0 4
95864: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
95865: LD_INT 0
95867: PPUSH
95868: PPUSH
95869: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
95870: LD_VAR 0 1
95874: NOT
95875: PUSH
95876: LD_VAR 0 2
95880: PUSH
95881: LD_INT 1
95883: PUSH
95884: LD_INT 2
95886: PUSH
95887: LD_INT 3
95889: PUSH
95890: LD_INT 4
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: IN
95899: NOT
95900: OR
95901: IFFALSE 95905
// exit ;
95903: GO 95997
// tmp := [ ] ;
95905: LD_ADDR_VAR 0 5
95909: PUSH
95910: EMPTY
95911: ST_TO_ADDR
// for i in units do
95912: LD_ADDR_VAR 0 4
95916: PUSH
95917: LD_VAR 0 1
95921: PUSH
95922: FOR_IN
95923: IFFALSE 95966
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
95925: LD_ADDR_VAR 0 5
95929: PUSH
95930: LD_VAR 0 5
95934: PPUSH
95935: LD_VAR 0 5
95939: PUSH
95940: LD_INT 1
95942: PLUS
95943: PPUSH
95944: LD_VAR 0 4
95948: PPUSH
95949: LD_VAR 0 2
95953: PPUSH
95954: CALL_OW 259
95958: PPUSH
95959: CALL_OW 2
95963: ST_TO_ADDR
95964: GO 95922
95966: POP
95967: POP
// if not tmp then
95968: LD_VAR 0 5
95972: NOT
95973: IFFALSE 95977
// exit ;
95975: GO 95997
// result := SortListByListDesc ( units , tmp ) ;
95977: LD_ADDR_VAR 0 3
95981: PUSH
95982: LD_VAR 0 1
95986: PPUSH
95987: LD_VAR 0 5
95991: PPUSH
95992: CALL_OW 77
95996: ST_TO_ADDR
// end ;
95997: LD_VAR 0 3
96001: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
96002: LD_INT 0
96004: PPUSH
96005: PPUSH
96006: PPUSH
// result := false ;
96007: LD_ADDR_VAR 0 3
96011: PUSH
96012: LD_INT 0
96014: ST_TO_ADDR
// x := GetX ( building ) ;
96015: LD_ADDR_VAR 0 4
96019: PUSH
96020: LD_VAR 0 2
96024: PPUSH
96025: CALL_OW 250
96029: ST_TO_ADDR
// y := GetY ( building ) ;
96030: LD_ADDR_VAR 0 5
96034: PUSH
96035: LD_VAR 0 2
96039: PPUSH
96040: CALL_OW 251
96044: ST_TO_ADDR
// if not building or not x or not y then
96045: LD_VAR 0 2
96049: NOT
96050: PUSH
96051: LD_VAR 0 4
96055: NOT
96056: OR
96057: PUSH
96058: LD_VAR 0 5
96062: NOT
96063: OR
96064: IFFALSE 96068
// exit ;
96066: GO 96160
// if GetTaskList ( unit ) then
96068: LD_VAR 0 1
96072: PPUSH
96073: CALL_OW 437
96077: IFFALSE 96160
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96079: LD_STRING e
96081: PUSH
96082: LD_VAR 0 1
96086: PPUSH
96087: CALL_OW 437
96091: PUSH
96092: LD_INT 1
96094: ARRAY
96095: PUSH
96096: LD_INT 1
96098: ARRAY
96099: EQUAL
96100: PUSH
96101: LD_VAR 0 4
96105: PUSH
96106: LD_VAR 0 1
96110: PPUSH
96111: CALL_OW 437
96115: PUSH
96116: LD_INT 1
96118: ARRAY
96119: PUSH
96120: LD_INT 2
96122: ARRAY
96123: EQUAL
96124: AND
96125: PUSH
96126: LD_VAR 0 5
96130: PUSH
96131: LD_VAR 0 1
96135: PPUSH
96136: CALL_OW 437
96140: PUSH
96141: LD_INT 1
96143: ARRAY
96144: PUSH
96145: LD_INT 3
96147: ARRAY
96148: EQUAL
96149: AND
96150: IFFALSE 96160
// result := true end ;
96152: LD_ADDR_VAR 0 3
96156: PUSH
96157: LD_INT 1
96159: ST_TO_ADDR
// end ;
96160: LD_VAR 0 3
96164: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
96165: LD_INT 0
96167: PPUSH
// result := false ;
96168: LD_ADDR_VAR 0 4
96172: PUSH
96173: LD_INT 0
96175: ST_TO_ADDR
// if GetTaskList ( unit ) then
96176: LD_VAR 0 1
96180: PPUSH
96181: CALL_OW 437
96185: IFFALSE 96268
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96187: LD_STRING M
96189: PUSH
96190: LD_VAR 0 1
96194: PPUSH
96195: CALL_OW 437
96199: PUSH
96200: LD_INT 1
96202: ARRAY
96203: PUSH
96204: LD_INT 1
96206: ARRAY
96207: EQUAL
96208: PUSH
96209: LD_VAR 0 2
96213: PUSH
96214: LD_VAR 0 1
96218: PPUSH
96219: CALL_OW 437
96223: PUSH
96224: LD_INT 1
96226: ARRAY
96227: PUSH
96228: LD_INT 2
96230: ARRAY
96231: EQUAL
96232: AND
96233: PUSH
96234: LD_VAR 0 3
96238: PUSH
96239: LD_VAR 0 1
96243: PPUSH
96244: CALL_OW 437
96248: PUSH
96249: LD_INT 1
96251: ARRAY
96252: PUSH
96253: LD_INT 3
96255: ARRAY
96256: EQUAL
96257: AND
96258: IFFALSE 96268
// result := true ;
96260: LD_ADDR_VAR 0 4
96264: PUSH
96265: LD_INT 1
96267: ST_TO_ADDR
// end ; end ;
96268: LD_VAR 0 4
96272: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
96273: LD_INT 0
96275: PPUSH
96276: PPUSH
96277: PPUSH
96278: PPUSH
// if not unit or not area then
96279: LD_VAR 0 1
96283: NOT
96284: PUSH
96285: LD_VAR 0 2
96289: NOT
96290: OR
96291: IFFALSE 96295
// exit ;
96293: GO 96459
// tmp := AreaToList ( area , i ) ;
96295: LD_ADDR_VAR 0 6
96299: PUSH
96300: LD_VAR 0 2
96304: PPUSH
96305: LD_VAR 0 5
96309: PPUSH
96310: CALL_OW 517
96314: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
96315: LD_ADDR_VAR 0 5
96319: PUSH
96320: DOUBLE
96321: LD_INT 1
96323: DEC
96324: ST_TO_ADDR
96325: LD_VAR 0 6
96329: PUSH
96330: LD_INT 1
96332: ARRAY
96333: PUSH
96334: FOR_TO
96335: IFFALSE 96457
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
96337: LD_ADDR_VAR 0 7
96341: PUSH
96342: LD_VAR 0 6
96346: PUSH
96347: LD_INT 1
96349: ARRAY
96350: PUSH
96351: LD_VAR 0 5
96355: ARRAY
96356: PUSH
96357: LD_VAR 0 6
96361: PUSH
96362: LD_INT 2
96364: ARRAY
96365: PUSH
96366: LD_VAR 0 5
96370: ARRAY
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
96376: LD_VAR 0 7
96380: PUSH
96381: LD_INT 1
96383: ARRAY
96384: PPUSH
96385: LD_VAR 0 7
96389: PUSH
96390: LD_INT 2
96392: ARRAY
96393: PPUSH
96394: CALL_OW 428
96398: PUSH
96399: LD_INT 0
96401: EQUAL
96402: IFFALSE 96455
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
96404: LD_VAR 0 1
96408: PPUSH
96409: LD_VAR 0 7
96413: PUSH
96414: LD_INT 1
96416: ARRAY
96417: PPUSH
96418: LD_VAR 0 7
96422: PUSH
96423: LD_INT 2
96425: ARRAY
96426: PPUSH
96427: LD_VAR 0 3
96431: PPUSH
96432: CALL_OW 48
// result := IsPlaced ( unit ) ;
96436: LD_ADDR_VAR 0 4
96440: PUSH
96441: LD_VAR 0 1
96445: PPUSH
96446: CALL_OW 305
96450: ST_TO_ADDR
// exit ;
96451: POP
96452: POP
96453: GO 96459
// end ; end ;
96455: GO 96334
96457: POP
96458: POP
// end ;
96459: LD_VAR 0 4
96463: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
96464: LD_INT 0
96466: PPUSH
96467: PPUSH
96468: PPUSH
// if not side or side > 8 then
96469: LD_VAR 0 1
96473: NOT
96474: PUSH
96475: LD_VAR 0 1
96479: PUSH
96480: LD_INT 8
96482: GREATER
96483: OR
96484: IFFALSE 96488
// exit ;
96486: GO 96675
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
96488: LD_ADDR_VAR 0 4
96492: PUSH
96493: LD_INT 22
96495: PUSH
96496: LD_VAR 0 1
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 21
96507: PUSH
96508: LD_INT 3
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PPUSH
96519: CALL_OW 69
96523: ST_TO_ADDR
// if not tmp then
96524: LD_VAR 0 4
96528: NOT
96529: IFFALSE 96533
// exit ;
96531: GO 96675
// enable_addtolog := true ;
96533: LD_ADDR_OWVAR 81
96537: PUSH
96538: LD_INT 1
96540: ST_TO_ADDR
// AddToLog ( [ ) ;
96541: LD_STRING [
96543: PPUSH
96544: CALL_OW 561
// for i in tmp do
96548: LD_ADDR_VAR 0 3
96552: PUSH
96553: LD_VAR 0 4
96557: PUSH
96558: FOR_IN
96559: IFFALSE 96666
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
96561: LD_STRING [
96563: PUSH
96564: LD_VAR 0 3
96568: PPUSH
96569: CALL_OW 266
96573: STR
96574: PUSH
96575: LD_STRING , 
96577: STR
96578: PUSH
96579: LD_VAR 0 3
96583: PPUSH
96584: CALL_OW 250
96588: STR
96589: PUSH
96590: LD_STRING , 
96592: STR
96593: PUSH
96594: LD_VAR 0 3
96598: PPUSH
96599: CALL_OW 251
96603: STR
96604: PUSH
96605: LD_STRING , 
96607: STR
96608: PUSH
96609: LD_VAR 0 3
96613: PPUSH
96614: CALL_OW 254
96618: STR
96619: PUSH
96620: LD_STRING , 
96622: STR
96623: PUSH
96624: LD_VAR 0 3
96628: PPUSH
96629: LD_INT 1
96631: PPUSH
96632: CALL_OW 268
96636: STR
96637: PUSH
96638: LD_STRING , 
96640: STR
96641: PUSH
96642: LD_VAR 0 3
96646: PPUSH
96647: LD_INT 2
96649: PPUSH
96650: CALL_OW 268
96654: STR
96655: PUSH
96656: LD_STRING ],
96658: STR
96659: PPUSH
96660: CALL_OW 561
// end ;
96664: GO 96558
96666: POP
96667: POP
// AddToLog ( ]; ) ;
96668: LD_STRING ];
96670: PPUSH
96671: CALL_OW 561
// end ;
96675: LD_VAR 0 2
96679: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
96680: LD_INT 0
96682: PPUSH
96683: PPUSH
96684: PPUSH
96685: PPUSH
96686: PPUSH
// if not area or not rate or not max then
96687: LD_VAR 0 1
96691: NOT
96692: PUSH
96693: LD_VAR 0 2
96697: NOT
96698: OR
96699: PUSH
96700: LD_VAR 0 4
96704: NOT
96705: OR
96706: IFFALSE 96710
// exit ;
96708: GO 96902
// while 1 do
96710: LD_INT 1
96712: IFFALSE 96902
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
96714: LD_ADDR_VAR 0 9
96718: PUSH
96719: LD_VAR 0 1
96723: PPUSH
96724: LD_INT 1
96726: PPUSH
96727: CALL_OW 287
96731: PUSH
96732: LD_INT 10
96734: MUL
96735: ST_TO_ADDR
// r := rate / 10 ;
96736: LD_ADDR_VAR 0 7
96740: PUSH
96741: LD_VAR 0 2
96745: PUSH
96746: LD_INT 10
96748: DIVREAL
96749: ST_TO_ADDR
// time := 1 1$00 ;
96750: LD_ADDR_VAR 0 8
96754: PUSH
96755: LD_INT 2100
96757: ST_TO_ADDR
// if amount < min then
96758: LD_VAR 0 9
96762: PUSH
96763: LD_VAR 0 3
96767: LESS
96768: IFFALSE 96786
// r := r * 2 else
96770: LD_ADDR_VAR 0 7
96774: PUSH
96775: LD_VAR 0 7
96779: PUSH
96780: LD_INT 2
96782: MUL
96783: ST_TO_ADDR
96784: GO 96812
// if amount > max then
96786: LD_VAR 0 9
96790: PUSH
96791: LD_VAR 0 4
96795: GREATER
96796: IFFALSE 96812
// r := r / 2 ;
96798: LD_ADDR_VAR 0 7
96802: PUSH
96803: LD_VAR 0 7
96807: PUSH
96808: LD_INT 2
96810: DIVREAL
96811: ST_TO_ADDR
// time := time / r ;
96812: LD_ADDR_VAR 0 8
96816: PUSH
96817: LD_VAR 0 8
96821: PUSH
96822: LD_VAR 0 7
96826: DIVREAL
96827: ST_TO_ADDR
// if time < 0 then
96828: LD_VAR 0 8
96832: PUSH
96833: LD_INT 0
96835: LESS
96836: IFFALSE 96853
// time := time * - 1 ;
96838: LD_ADDR_VAR 0 8
96842: PUSH
96843: LD_VAR 0 8
96847: PUSH
96848: LD_INT 1
96850: NEG
96851: MUL
96852: ST_TO_ADDR
// wait ( time ) ;
96853: LD_VAR 0 8
96857: PPUSH
96858: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
96862: LD_INT 35
96864: PPUSH
96865: LD_INT 875
96867: PPUSH
96868: CALL_OW 12
96872: PPUSH
96873: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
96877: LD_INT 1
96879: PPUSH
96880: LD_INT 5
96882: PPUSH
96883: CALL_OW 12
96887: PPUSH
96888: LD_VAR 0 1
96892: PPUSH
96893: LD_INT 1
96895: PPUSH
96896: CALL_OW 55
// end ;
96900: GO 96710
// end ;
96902: LD_VAR 0 5
96906: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
96907: LD_INT 0
96909: PPUSH
96910: PPUSH
96911: PPUSH
96912: PPUSH
96913: PPUSH
96914: PPUSH
96915: PPUSH
96916: PPUSH
// if not turrets or not factories then
96917: LD_VAR 0 1
96921: NOT
96922: PUSH
96923: LD_VAR 0 2
96927: NOT
96928: OR
96929: IFFALSE 96933
// exit ;
96931: GO 97240
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
96933: LD_ADDR_VAR 0 10
96937: PUSH
96938: LD_INT 5
96940: PUSH
96941: LD_INT 6
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: LD_INT 2
96950: PUSH
96951: LD_INT 4
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 3
96960: PUSH
96961: LD_INT 5
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 24
96975: PUSH
96976: LD_INT 25
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 23
96985: PUSH
96986: LD_INT 27
96988: PUSH
96989: EMPTY
96990: LIST
96991: LIST
96992: PUSH
96993: EMPTY
96994: LIST
96995: LIST
96996: PUSH
96997: LD_INT 42
96999: PUSH
97000: LD_INT 43
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 44
97009: PUSH
97010: LD_INT 46
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 45
97019: PUSH
97020: LD_INT 47
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: LIST
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: ST_TO_ADDR
// result := [ ] ;
97037: LD_ADDR_VAR 0 3
97041: PUSH
97042: EMPTY
97043: ST_TO_ADDR
// for i in turrets do
97044: LD_ADDR_VAR 0 4
97048: PUSH
97049: LD_VAR 0 1
97053: PUSH
97054: FOR_IN
97055: IFFALSE 97238
// begin nat := GetNation ( i ) ;
97057: LD_ADDR_VAR 0 7
97061: PUSH
97062: LD_VAR 0 4
97066: PPUSH
97067: CALL_OW 248
97071: ST_TO_ADDR
// weapon := 0 ;
97072: LD_ADDR_VAR 0 8
97076: PUSH
97077: LD_INT 0
97079: ST_TO_ADDR
// if not nat then
97080: LD_VAR 0 7
97084: NOT
97085: IFFALSE 97089
// continue ;
97087: GO 97054
// for j in list [ nat ] do
97089: LD_ADDR_VAR 0 5
97093: PUSH
97094: LD_VAR 0 10
97098: PUSH
97099: LD_VAR 0 7
97103: ARRAY
97104: PUSH
97105: FOR_IN
97106: IFFALSE 97147
// if GetBWeapon ( i ) = j [ 1 ] then
97108: LD_VAR 0 4
97112: PPUSH
97113: CALL_OW 269
97117: PUSH
97118: LD_VAR 0 5
97122: PUSH
97123: LD_INT 1
97125: ARRAY
97126: EQUAL
97127: IFFALSE 97145
// begin weapon := j [ 2 ] ;
97129: LD_ADDR_VAR 0 8
97133: PUSH
97134: LD_VAR 0 5
97138: PUSH
97139: LD_INT 2
97141: ARRAY
97142: ST_TO_ADDR
// break ;
97143: GO 97147
// end ;
97145: GO 97105
97147: POP
97148: POP
// if not weapon then
97149: LD_VAR 0 8
97153: NOT
97154: IFFALSE 97158
// continue ;
97156: GO 97054
// for k in factories do
97158: LD_ADDR_VAR 0 6
97162: PUSH
97163: LD_VAR 0 2
97167: PUSH
97168: FOR_IN
97169: IFFALSE 97234
// begin weapons := AvailableWeaponList ( k ) ;
97171: LD_ADDR_VAR 0 9
97175: PUSH
97176: LD_VAR 0 6
97180: PPUSH
97181: CALL_OW 478
97185: ST_TO_ADDR
// if not weapons then
97186: LD_VAR 0 9
97190: NOT
97191: IFFALSE 97195
// continue ;
97193: GO 97168
// if weapon in weapons then
97195: LD_VAR 0 8
97199: PUSH
97200: LD_VAR 0 9
97204: IN
97205: IFFALSE 97232
// begin result := [ i , weapon ] ;
97207: LD_ADDR_VAR 0 3
97211: PUSH
97212: LD_VAR 0 4
97216: PUSH
97217: LD_VAR 0 8
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: ST_TO_ADDR
// exit ;
97226: POP
97227: POP
97228: POP
97229: POP
97230: GO 97240
// end ; end ;
97232: GO 97168
97234: POP
97235: POP
// end ;
97236: GO 97054
97238: POP
97239: POP
// end ;
97240: LD_VAR 0 3
97244: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
97245: LD_INT 0
97247: PPUSH
// if not side or side > 8 then
97248: LD_VAR 0 3
97252: NOT
97253: PUSH
97254: LD_VAR 0 3
97258: PUSH
97259: LD_INT 8
97261: GREATER
97262: OR
97263: IFFALSE 97267
// exit ;
97265: GO 97326
// if not range then
97267: LD_VAR 0 4
97271: NOT
97272: IFFALSE 97283
// range := - 12 ;
97274: LD_ADDR_VAR 0 4
97278: PUSH
97279: LD_INT 12
97281: NEG
97282: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
97283: LD_VAR 0 1
97287: PPUSH
97288: LD_VAR 0 2
97292: PPUSH
97293: LD_VAR 0 3
97297: PPUSH
97298: LD_VAR 0 4
97302: PPUSH
97303: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
97307: LD_VAR 0 1
97311: PPUSH
97312: LD_VAR 0 2
97316: PPUSH
97317: LD_VAR 0 3
97321: PPUSH
97322: CALL_OW 331
// end ;
97326: LD_VAR 0 5
97330: RET
// export function Video ( mode ) ; begin
97331: LD_INT 0
97333: PPUSH
// ingame_video = mode ;
97334: LD_ADDR_OWVAR 52
97338: PUSH
97339: LD_VAR 0 1
97343: ST_TO_ADDR
// interface_hidden = mode ;
97344: LD_ADDR_OWVAR 54
97348: PUSH
97349: LD_VAR 0 1
97353: ST_TO_ADDR
// end ;
97354: LD_VAR 0 2
97358: RET
// export function Join ( array , element ) ; begin
97359: LD_INT 0
97361: PPUSH
// result := Replace ( array , array + 1 , element ) ;
97362: LD_ADDR_VAR 0 3
97366: PUSH
97367: LD_VAR 0 1
97371: PPUSH
97372: LD_VAR 0 1
97376: PUSH
97377: LD_INT 1
97379: PLUS
97380: PPUSH
97381: LD_VAR 0 2
97385: PPUSH
97386: CALL_OW 1
97390: ST_TO_ADDR
// end ;
97391: LD_VAR 0 3
97395: RET
// export function JoinUnion ( array , element ) ; begin
97396: LD_INT 0
97398: PPUSH
// result := array union element ;
97399: LD_ADDR_VAR 0 3
97403: PUSH
97404: LD_VAR 0 1
97408: PUSH
97409: LD_VAR 0 2
97413: UNION
97414: ST_TO_ADDR
// end ;
97415: LD_VAR 0 3
97419: RET
// export function GetBehemoths ( side ) ; begin
97420: LD_INT 0
97422: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
97423: LD_ADDR_VAR 0 2
97427: PUSH
97428: LD_INT 22
97430: PUSH
97431: LD_VAR 0 1
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 31
97442: PUSH
97443: LD_INT 25
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: PPUSH
97454: CALL_OW 69
97458: ST_TO_ADDR
// end ;
97459: LD_VAR 0 2
97463: RET
// export function Shuffle ( array ) ; var i , index ; begin
97464: LD_INT 0
97466: PPUSH
97467: PPUSH
97468: PPUSH
// result := [ ] ;
97469: LD_ADDR_VAR 0 2
97473: PUSH
97474: EMPTY
97475: ST_TO_ADDR
// if not array then
97476: LD_VAR 0 1
97480: NOT
97481: IFFALSE 97485
// exit ;
97483: GO 97584
// Randomize ;
97485: CALL_OW 10
// for i = array downto 1 do
97489: LD_ADDR_VAR 0 3
97493: PUSH
97494: DOUBLE
97495: LD_VAR 0 1
97499: INC
97500: ST_TO_ADDR
97501: LD_INT 1
97503: PUSH
97504: FOR_DOWNTO
97505: IFFALSE 97582
// begin index := rand ( 1 , array ) ;
97507: LD_ADDR_VAR 0 4
97511: PUSH
97512: LD_INT 1
97514: PPUSH
97515: LD_VAR 0 1
97519: PPUSH
97520: CALL_OW 12
97524: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
97525: LD_ADDR_VAR 0 2
97529: PUSH
97530: LD_VAR 0 2
97534: PPUSH
97535: LD_VAR 0 2
97539: PUSH
97540: LD_INT 1
97542: PLUS
97543: PPUSH
97544: LD_VAR 0 1
97548: PUSH
97549: LD_VAR 0 4
97553: ARRAY
97554: PPUSH
97555: CALL_OW 2
97559: ST_TO_ADDR
// array := Delete ( array , index ) ;
97560: LD_ADDR_VAR 0 1
97564: PUSH
97565: LD_VAR 0 1
97569: PPUSH
97570: LD_VAR 0 4
97574: PPUSH
97575: CALL_OW 3
97579: ST_TO_ADDR
// end ;
97580: GO 97504
97582: POP
97583: POP
// end ;
97584: LD_VAR 0 2
97588: RET
// export function GetBaseMaterials ( base ) ; begin
97589: LD_INT 0
97591: PPUSH
// result := [ 0 , 0 , 0 ] ;
97592: LD_ADDR_VAR 0 2
97596: PUSH
97597: LD_INT 0
97599: PUSH
97600: LD_INT 0
97602: PUSH
97603: LD_INT 0
97605: PUSH
97606: EMPTY
97607: LIST
97608: LIST
97609: LIST
97610: ST_TO_ADDR
// if not base then
97611: LD_VAR 0 1
97615: NOT
97616: IFFALSE 97620
// exit ;
97618: GO 97669
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
97620: LD_ADDR_VAR 0 2
97624: PUSH
97625: LD_VAR 0 1
97629: PPUSH
97630: LD_INT 1
97632: PPUSH
97633: CALL_OW 275
97637: PUSH
97638: LD_VAR 0 1
97642: PPUSH
97643: LD_INT 2
97645: PPUSH
97646: CALL_OW 275
97650: PUSH
97651: LD_VAR 0 1
97655: PPUSH
97656: LD_INT 3
97658: PPUSH
97659: CALL_OW 275
97663: PUSH
97664: EMPTY
97665: LIST
97666: LIST
97667: LIST
97668: ST_TO_ADDR
// end ;
97669: LD_VAR 0 2
97673: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
97674: LD_INT 0
97676: PPUSH
97677: PPUSH
// result := array ;
97678: LD_ADDR_VAR 0 3
97682: PUSH
97683: LD_VAR 0 1
97687: ST_TO_ADDR
// if size > 0 then
97688: LD_VAR 0 2
97692: PUSH
97693: LD_INT 0
97695: GREATER
97696: IFFALSE 97742
// for i := array downto size do
97698: LD_ADDR_VAR 0 4
97702: PUSH
97703: DOUBLE
97704: LD_VAR 0 1
97708: INC
97709: ST_TO_ADDR
97710: LD_VAR 0 2
97714: PUSH
97715: FOR_DOWNTO
97716: IFFALSE 97740
// result := Delete ( result , result ) ;
97718: LD_ADDR_VAR 0 3
97722: PUSH
97723: LD_VAR 0 3
97727: PPUSH
97728: LD_VAR 0 3
97732: PPUSH
97733: CALL_OW 3
97737: ST_TO_ADDR
97738: GO 97715
97740: POP
97741: POP
// end ;
97742: LD_VAR 0 3
97746: RET
// export function ComExit ( unit ) ; var tmp ; begin
97747: LD_INT 0
97749: PPUSH
97750: PPUSH
// if not IsInUnit ( unit ) then
97751: LD_VAR 0 1
97755: PPUSH
97756: CALL_OW 310
97760: NOT
97761: IFFALSE 97765
// exit ;
97763: GO 97825
// tmp := IsInUnit ( unit ) ;
97765: LD_ADDR_VAR 0 3
97769: PUSH
97770: LD_VAR 0 1
97774: PPUSH
97775: CALL_OW 310
97779: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
97780: LD_VAR 0 3
97784: PPUSH
97785: CALL_OW 247
97789: PUSH
97790: LD_INT 2
97792: EQUAL
97793: IFFALSE 97806
// ComExitVehicle ( unit ) else
97795: LD_VAR 0 1
97799: PPUSH
97800: CALL_OW 121
97804: GO 97815
// ComExitBuilding ( unit ) ;
97806: LD_VAR 0 1
97810: PPUSH
97811: CALL_OW 122
// result := tmp ;
97815: LD_ADDR_VAR 0 2
97819: PUSH
97820: LD_VAR 0 3
97824: ST_TO_ADDR
// end ;
97825: LD_VAR 0 2
97829: RET
// export function ComExitAll ( units ) ; var i ; begin
97830: LD_INT 0
97832: PPUSH
97833: PPUSH
// if not units then
97834: LD_VAR 0 1
97838: NOT
97839: IFFALSE 97843
// exit ;
97841: GO 97869
// for i in units do
97843: LD_ADDR_VAR 0 3
97847: PUSH
97848: LD_VAR 0 1
97852: PUSH
97853: FOR_IN
97854: IFFALSE 97867
// ComExit ( i ) ;
97856: LD_VAR 0 3
97860: PPUSH
97861: CALL 97747 0 1
97865: GO 97853
97867: POP
97868: POP
// end ;
97869: LD_VAR 0 2
97873: RET
// export function ResetHc ; begin
97874: LD_INT 0
97876: PPUSH
// InitHc ;
97877: CALL_OW 19
// hc_importance := 0 ;
97881: LD_ADDR_OWVAR 32
97885: PUSH
97886: LD_INT 0
97888: ST_TO_ADDR
// end ;
97889: LD_VAR 0 1
97893: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
97894: LD_INT 0
97896: PPUSH
97897: PPUSH
97898: PPUSH
// _x := ( x1 + x2 ) div 2 ;
97899: LD_ADDR_VAR 0 6
97903: PUSH
97904: LD_VAR 0 1
97908: PUSH
97909: LD_VAR 0 3
97913: PLUS
97914: PUSH
97915: LD_INT 2
97917: DIV
97918: ST_TO_ADDR
// if _x < 0 then
97919: LD_VAR 0 6
97923: PUSH
97924: LD_INT 0
97926: LESS
97927: IFFALSE 97944
// _x := _x * - 1 ;
97929: LD_ADDR_VAR 0 6
97933: PUSH
97934: LD_VAR 0 6
97938: PUSH
97939: LD_INT 1
97941: NEG
97942: MUL
97943: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
97944: LD_ADDR_VAR 0 7
97948: PUSH
97949: LD_VAR 0 2
97953: PUSH
97954: LD_VAR 0 4
97958: PLUS
97959: PUSH
97960: LD_INT 2
97962: DIV
97963: ST_TO_ADDR
// if _y < 0 then
97964: LD_VAR 0 7
97968: PUSH
97969: LD_INT 0
97971: LESS
97972: IFFALSE 97989
// _y := _y * - 1 ;
97974: LD_ADDR_VAR 0 7
97978: PUSH
97979: LD_VAR 0 7
97983: PUSH
97984: LD_INT 1
97986: NEG
97987: MUL
97988: ST_TO_ADDR
// result := [ _x , _y ] ;
97989: LD_ADDR_VAR 0 5
97993: PUSH
97994: LD_VAR 0 6
97998: PUSH
97999: LD_VAR 0 7
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: ST_TO_ADDR
// end ;
98008: LD_VAR 0 5
98012: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
98013: LD_INT 0
98015: PPUSH
98016: PPUSH
98017: PPUSH
98018: PPUSH
// task := GetTaskList ( unit ) ;
98019: LD_ADDR_VAR 0 7
98023: PUSH
98024: LD_VAR 0 1
98028: PPUSH
98029: CALL_OW 437
98033: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
98034: LD_VAR 0 7
98038: NOT
98039: PUSH
98040: LD_VAR 0 1
98044: PPUSH
98045: LD_VAR 0 2
98049: PPUSH
98050: CALL_OW 308
98054: NOT
98055: AND
98056: IFFALSE 98060
// exit ;
98058: GO 98178
// if IsInArea ( unit , area ) then
98060: LD_VAR 0 1
98064: PPUSH
98065: LD_VAR 0 2
98069: PPUSH
98070: CALL_OW 308
98074: IFFALSE 98092
// begin ComMoveToArea ( unit , goAway ) ;
98076: LD_VAR 0 1
98080: PPUSH
98081: LD_VAR 0 3
98085: PPUSH
98086: CALL_OW 113
// exit ;
98090: GO 98178
// end ; if task [ 1 ] [ 1 ] <> M then
98092: LD_VAR 0 7
98096: PUSH
98097: LD_INT 1
98099: ARRAY
98100: PUSH
98101: LD_INT 1
98103: ARRAY
98104: PUSH
98105: LD_STRING M
98107: NONEQUAL
98108: IFFALSE 98112
// exit ;
98110: GO 98178
// x := task [ 1 ] [ 2 ] ;
98112: LD_ADDR_VAR 0 5
98116: PUSH
98117: LD_VAR 0 7
98121: PUSH
98122: LD_INT 1
98124: ARRAY
98125: PUSH
98126: LD_INT 2
98128: ARRAY
98129: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
98130: LD_ADDR_VAR 0 6
98134: PUSH
98135: LD_VAR 0 7
98139: PUSH
98140: LD_INT 1
98142: ARRAY
98143: PUSH
98144: LD_INT 3
98146: ARRAY
98147: ST_TO_ADDR
// if InArea ( x , y , area ) then
98148: LD_VAR 0 5
98152: PPUSH
98153: LD_VAR 0 6
98157: PPUSH
98158: LD_VAR 0 2
98162: PPUSH
98163: CALL_OW 309
98167: IFFALSE 98178
// ComStop ( unit ) ;
98169: LD_VAR 0 1
98173: PPUSH
98174: CALL_OW 141
// end ;
98178: LD_VAR 0 4
98182: RET
// export function Abs ( value ) ; begin
98183: LD_INT 0
98185: PPUSH
// result := value ;
98186: LD_ADDR_VAR 0 2
98190: PUSH
98191: LD_VAR 0 1
98195: ST_TO_ADDR
// if value < 0 then
98196: LD_VAR 0 1
98200: PUSH
98201: LD_INT 0
98203: LESS
98204: IFFALSE 98221
// result := value * - 1 ;
98206: LD_ADDR_VAR 0 2
98210: PUSH
98211: LD_VAR 0 1
98215: PUSH
98216: LD_INT 1
98218: NEG
98219: MUL
98220: ST_TO_ADDR
// end ;
98221: LD_VAR 0 2
98225: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
98226: LD_INT 0
98228: PPUSH
98229: PPUSH
98230: PPUSH
98231: PPUSH
98232: PPUSH
98233: PPUSH
98234: PPUSH
98235: PPUSH
// if not unit or not building then
98236: LD_VAR 0 1
98240: NOT
98241: PUSH
98242: LD_VAR 0 2
98246: NOT
98247: OR
98248: IFFALSE 98252
// exit ;
98250: GO 98478
// x := GetX ( building ) ;
98252: LD_ADDR_VAR 0 4
98256: PUSH
98257: LD_VAR 0 2
98261: PPUSH
98262: CALL_OW 250
98266: ST_TO_ADDR
// y := GetY ( building ) ;
98267: LD_ADDR_VAR 0 6
98271: PUSH
98272: LD_VAR 0 2
98276: PPUSH
98277: CALL_OW 251
98281: ST_TO_ADDR
// d := GetDir ( building ) ;
98282: LD_ADDR_VAR 0 8
98286: PUSH
98287: LD_VAR 0 2
98291: PPUSH
98292: CALL_OW 254
98296: ST_TO_ADDR
// r := 4 ;
98297: LD_ADDR_VAR 0 9
98301: PUSH
98302: LD_INT 4
98304: ST_TO_ADDR
// for i := 1 to 5 do
98305: LD_ADDR_VAR 0 10
98309: PUSH
98310: DOUBLE
98311: LD_INT 1
98313: DEC
98314: ST_TO_ADDR
98315: LD_INT 5
98317: PUSH
98318: FOR_TO
98319: IFFALSE 98476
// begin _x := ShiftX ( x , d , r + i ) ;
98321: LD_ADDR_VAR 0 5
98325: PUSH
98326: LD_VAR 0 4
98330: PPUSH
98331: LD_VAR 0 8
98335: PPUSH
98336: LD_VAR 0 9
98340: PUSH
98341: LD_VAR 0 10
98345: PLUS
98346: PPUSH
98347: CALL_OW 272
98351: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
98352: LD_ADDR_VAR 0 7
98356: PUSH
98357: LD_VAR 0 6
98361: PPUSH
98362: LD_VAR 0 8
98366: PPUSH
98367: LD_VAR 0 9
98371: PUSH
98372: LD_VAR 0 10
98376: PLUS
98377: PPUSH
98378: CALL_OW 273
98382: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
98383: LD_VAR 0 5
98387: PPUSH
98388: LD_VAR 0 7
98392: PPUSH
98393: CALL_OW 488
98397: PUSH
98398: LD_VAR 0 5
98402: PPUSH
98403: LD_VAR 0 7
98407: PPUSH
98408: CALL_OW 428
98412: PPUSH
98413: CALL_OW 247
98417: PUSH
98418: LD_INT 3
98420: PUSH
98421: LD_INT 2
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: IN
98428: NOT
98429: AND
98430: IFFALSE 98474
// begin ComMoveXY ( unit , _x , _y ) ;
98432: LD_VAR 0 1
98436: PPUSH
98437: LD_VAR 0 5
98441: PPUSH
98442: LD_VAR 0 7
98446: PPUSH
98447: CALL_OW 111
// result := [ _x , _y ] ;
98451: LD_ADDR_VAR 0 3
98455: PUSH
98456: LD_VAR 0 5
98460: PUSH
98461: LD_VAR 0 7
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: ST_TO_ADDR
// exit ;
98470: POP
98471: POP
98472: GO 98478
// end ; end ;
98474: GO 98318
98476: POP
98477: POP
// end ;
98478: LD_VAR 0 3
98482: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
98483: LD_INT 0
98485: PPUSH
98486: PPUSH
98487: PPUSH
// result := 0 ;
98488: LD_ADDR_VAR 0 3
98492: PUSH
98493: LD_INT 0
98495: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
98496: LD_VAR 0 1
98500: PUSH
98501: LD_INT 0
98503: LESS
98504: PUSH
98505: LD_VAR 0 1
98509: PUSH
98510: LD_INT 8
98512: GREATER
98513: OR
98514: PUSH
98515: LD_VAR 0 2
98519: PUSH
98520: LD_INT 0
98522: LESS
98523: OR
98524: PUSH
98525: LD_VAR 0 2
98529: PUSH
98530: LD_INT 8
98532: GREATER
98533: OR
98534: IFFALSE 98538
// exit ;
98536: GO 98613
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
98538: LD_ADDR_VAR 0 4
98542: PUSH
98543: LD_INT 22
98545: PUSH
98546: LD_VAR 0 2
98550: PUSH
98551: EMPTY
98552: LIST
98553: LIST
98554: PPUSH
98555: CALL_OW 69
98559: PUSH
98560: FOR_IN
98561: IFFALSE 98611
// begin un := UnitShoot ( i ) ;
98563: LD_ADDR_VAR 0 5
98567: PUSH
98568: LD_VAR 0 4
98572: PPUSH
98573: CALL_OW 504
98577: ST_TO_ADDR
// if GetSide ( un ) = side1 then
98578: LD_VAR 0 5
98582: PPUSH
98583: CALL_OW 255
98587: PUSH
98588: LD_VAR 0 1
98592: EQUAL
98593: IFFALSE 98609
// begin result := un ;
98595: LD_ADDR_VAR 0 3
98599: PUSH
98600: LD_VAR 0 5
98604: ST_TO_ADDR
// exit ;
98605: POP
98606: POP
98607: GO 98613
// end ; end ;
98609: GO 98560
98611: POP
98612: POP
// end ;
98613: LD_VAR 0 3
98617: RET
// export function GetCargoBay ( units ) ; begin
98618: LD_INT 0
98620: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
98621: LD_ADDR_VAR 0 2
98625: PUSH
98626: LD_VAR 0 1
98630: PPUSH
98631: LD_INT 2
98633: PUSH
98634: LD_INT 34
98636: PUSH
98637: LD_INT 12
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PUSH
98644: LD_INT 34
98646: PUSH
98647: LD_INT 51
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 34
98656: PUSH
98657: LD_INT 32
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 34
98666: PUSH
98667: LD_EXP 74
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: EMPTY
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: PPUSH
98683: CALL_OW 72
98687: ST_TO_ADDR
// end ;
98688: LD_VAR 0 2
98692: RET
// export function Negate ( value ) ; begin
98693: LD_INT 0
98695: PPUSH
// result := not value ;
98696: LD_ADDR_VAR 0 2
98700: PUSH
98701: LD_VAR 0 1
98705: NOT
98706: ST_TO_ADDR
// end ;
98707: LD_VAR 0 2
98711: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
98712: LD_INT 0
98714: PPUSH
// if x1 = x2 then
98715: LD_VAR 0 1
98719: PUSH
98720: LD_VAR 0 3
98724: EQUAL
98725: IFFALSE 98759
// begin if y1 > y2 then
98727: LD_VAR 0 2
98731: PUSH
98732: LD_VAR 0 4
98736: GREATER
98737: IFFALSE 98749
// result := 0 else
98739: LD_ADDR_VAR 0 5
98743: PUSH
98744: LD_INT 0
98746: ST_TO_ADDR
98747: GO 98757
// result := 3 ;
98749: LD_ADDR_VAR 0 5
98753: PUSH
98754: LD_INT 3
98756: ST_TO_ADDR
// exit ;
98757: GO 98845
// end ; if y1 = y2 then
98759: LD_VAR 0 2
98763: PUSH
98764: LD_VAR 0 4
98768: EQUAL
98769: IFFALSE 98803
// begin if x1 > x2 then
98771: LD_VAR 0 1
98775: PUSH
98776: LD_VAR 0 3
98780: GREATER
98781: IFFALSE 98793
// result := 1 else
98783: LD_ADDR_VAR 0 5
98787: PUSH
98788: LD_INT 1
98790: ST_TO_ADDR
98791: GO 98801
// result := 4 ;
98793: LD_ADDR_VAR 0 5
98797: PUSH
98798: LD_INT 4
98800: ST_TO_ADDR
// exit ;
98801: GO 98845
// end ; if x1 > x2 and y1 > y2 then
98803: LD_VAR 0 1
98807: PUSH
98808: LD_VAR 0 3
98812: GREATER
98813: PUSH
98814: LD_VAR 0 2
98818: PUSH
98819: LD_VAR 0 4
98823: GREATER
98824: AND
98825: IFFALSE 98837
// result := 2 else
98827: LD_ADDR_VAR 0 5
98831: PUSH
98832: LD_INT 2
98834: ST_TO_ADDR
98835: GO 98845
// result := 5 ;
98837: LD_ADDR_VAR 0 5
98841: PUSH
98842: LD_INT 5
98844: ST_TO_ADDR
// end ;
98845: LD_VAR 0 5
98849: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
98850: LD_INT 0
98852: PPUSH
98853: PPUSH
// if not driver or not IsInUnit ( driver ) then
98854: LD_VAR 0 1
98858: NOT
98859: PUSH
98860: LD_VAR 0 1
98864: PPUSH
98865: CALL_OW 310
98869: NOT
98870: OR
98871: IFFALSE 98875
// exit ;
98873: GO 98965
// vehicle := IsInUnit ( driver ) ;
98875: LD_ADDR_VAR 0 3
98879: PUSH
98880: LD_VAR 0 1
98884: PPUSH
98885: CALL_OW 310
98889: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
98890: LD_VAR 0 1
98894: PPUSH
98895: LD_STRING \
98897: PUSH
98898: LD_INT 0
98900: PUSH
98901: LD_INT 0
98903: PUSH
98904: LD_INT 0
98906: PUSH
98907: LD_INT 0
98909: PUSH
98910: LD_INT 0
98912: PUSH
98913: LD_INT 0
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: LIST
98924: PUSH
98925: LD_STRING E
98927: PUSH
98928: LD_INT 0
98930: PUSH
98931: LD_INT 0
98933: PUSH
98934: LD_VAR 0 3
98938: PUSH
98939: LD_INT 0
98941: PUSH
98942: LD_INT 0
98944: PUSH
98945: LD_INT 0
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PPUSH
98961: CALL_OW 446
// end ;
98965: LD_VAR 0 2
98969: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
98970: LD_INT 0
98972: PPUSH
98973: PPUSH
98974: PPUSH
// tmp := [ ] ;
98975: LD_ADDR_VAR 0 5
98979: PUSH
98980: EMPTY
98981: ST_TO_ADDR
// for i in units do
98982: LD_ADDR_VAR 0 4
98986: PUSH
98987: LD_VAR 0 1
98991: PUSH
98992: FOR_IN
98993: IFFALSE 99031
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
98995: LD_ADDR_VAR 0 5
98999: PUSH
99000: LD_VAR 0 5
99004: PPUSH
99005: LD_VAR 0 5
99009: PUSH
99010: LD_INT 1
99012: PLUS
99013: PPUSH
99014: LD_VAR 0 4
99018: PPUSH
99019: CALL_OW 256
99023: PPUSH
99024: CALL_OW 2
99028: ST_TO_ADDR
99029: GO 98992
99031: POP
99032: POP
// if not tmp then
99033: LD_VAR 0 5
99037: NOT
99038: IFFALSE 99042
// exit ;
99040: GO 99090
// if asc then
99042: LD_VAR 0 2
99046: IFFALSE 99070
// result := SortListByListAsc ( units , tmp ) else
99048: LD_ADDR_VAR 0 3
99052: PUSH
99053: LD_VAR 0 1
99057: PPUSH
99058: LD_VAR 0 5
99062: PPUSH
99063: CALL_OW 76
99067: ST_TO_ADDR
99068: GO 99090
// result := SortListByListDesc ( units , tmp ) ;
99070: LD_ADDR_VAR 0 3
99074: PUSH
99075: LD_VAR 0 1
99079: PPUSH
99080: LD_VAR 0 5
99084: PPUSH
99085: CALL_OW 77
99089: ST_TO_ADDR
// end ;
99090: LD_VAR 0 3
99094: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
99095: LD_INT 0
99097: PPUSH
99098: PPUSH
// task := GetTaskList ( mech ) ;
99099: LD_ADDR_VAR 0 4
99103: PUSH
99104: LD_VAR 0 1
99108: PPUSH
99109: CALL_OW 437
99113: ST_TO_ADDR
// if not task then
99114: LD_VAR 0 4
99118: NOT
99119: IFFALSE 99123
// exit ;
99121: GO 99165
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
99123: LD_ADDR_VAR 0 3
99127: PUSH
99128: LD_VAR 0 4
99132: PUSH
99133: LD_INT 1
99135: ARRAY
99136: PUSH
99137: LD_INT 1
99139: ARRAY
99140: PUSH
99141: LD_STRING r
99143: EQUAL
99144: PUSH
99145: LD_VAR 0 4
99149: PUSH
99150: LD_INT 1
99152: ARRAY
99153: PUSH
99154: LD_INT 4
99156: ARRAY
99157: PUSH
99158: LD_VAR 0 2
99162: EQUAL
99163: AND
99164: ST_TO_ADDR
// end ;
99165: LD_VAR 0 3
99169: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
99170: LD_INT 0
99172: PPUSH
// SetDir ( unit , d ) ;
99173: LD_VAR 0 1
99177: PPUSH
99178: LD_VAR 0 4
99182: PPUSH
99183: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
99187: LD_VAR 0 1
99191: PPUSH
99192: LD_VAR 0 2
99196: PPUSH
99197: LD_VAR 0 3
99201: PPUSH
99202: LD_VAR 0 5
99206: PPUSH
99207: CALL_OW 48
// end ; end_of_file
99211: LD_VAR 0 6
99215: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
99216: LD_VAR 0 1
99220: PUSH
99221: LD_INT 200
99223: DOUBLE
99224: GREATEREQUAL
99225: IFFALSE 99233
99227: LD_INT 299
99229: DOUBLE
99230: LESSEQUAL
99231: IFTRUE 99235
99233: GO 99267
99235: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
99236: LD_VAR 0 1
99240: PPUSH
99241: LD_VAR 0 2
99245: PPUSH
99246: LD_VAR 0 3
99250: PPUSH
99251: LD_VAR 0 4
99255: PPUSH
99256: LD_VAR 0 5
99260: PPUSH
99261: CALL 56738 0 5
99265: GO 99344
99267: LD_INT 300
99269: DOUBLE
99270: GREATEREQUAL
99271: IFFALSE 99279
99273: LD_INT 399
99275: DOUBLE
99276: LESSEQUAL
99277: IFTRUE 99281
99279: GO 99343
99281: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
99282: LD_VAR 0 1
99286: PPUSH
99287: LD_VAR 0 2
99291: PPUSH
99292: LD_VAR 0 3
99296: PPUSH
99297: LD_VAR 0 4
99301: PPUSH
99302: LD_VAR 0 5
99306: PPUSH
99307: LD_VAR 0 6
99311: PPUSH
99312: LD_VAR 0 7
99316: PPUSH
99317: LD_VAR 0 8
99321: PPUSH
99322: LD_VAR 0 9
99326: PPUSH
99327: LD_VAR 0 10
99331: PPUSH
99332: LD_VAR 0 11
99336: PPUSH
99337: CALL 54626 0 11
99341: GO 99344
99343: POP
// end ;
99344: PPOPN 11
99346: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
99347: LD_VAR 0 1
99351: PPUSH
99352: LD_VAR 0 2
99356: PPUSH
99357: LD_VAR 0 3
99361: PPUSH
99362: LD_VAR 0 4
99366: PPUSH
99367: LD_VAR 0 5
99371: PPUSH
99372: CALL 56720 0 5
// end ; end_of_file
99376: PPOPN 5
99378: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
99379: LD_VAR 0 1
99383: PPUSH
99384: LD_VAR 0 2
99388: PPUSH
99389: LD_VAR 0 3
99393: PPUSH
99394: LD_VAR 0 4
99398: PPUSH
99399: LD_VAR 0 5
99403: PPUSH
99404: LD_VAR 0 6
99408: PPUSH
99409: CALL 43434 0 6
// end ;
99413: PPOPN 6
99415: END
